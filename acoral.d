
acoral.elf:     file format elf32-littlearm


Disassembly of section .text:

30000000 <__ENTRY>:
30000000:	ea000015 	b	3000005c <ResetHandler>
30000004:	ea00000d 	b	30000040 <HandleUndef>
30000008:	ea00000d 	b	30000044 <HandleSWI>
3000000c:	ea00000e 	b	3000004c <HandlePabort>
30000010:	ea00000c 	b	30000048 <HandleDabort>
30000014:	eafffffe 	b	30000014 <__ENTRY+0x14>
30000018:	ea000007 	b	3000003c <HandleIRQ>
3000001c:	ea000005 	b	30000038 <HandleFIQ>
	...
30000028:	30000000 	.word	0x30000000
3000002c:	00000988 	.word	0x00000988
30000030:	00000000 	.word	0x00000000
30000034:	eafffffe 	b	30000034 <__ENTRY+0x34>

30000038 <HandleFIQ>:
30000038:	e59ff244 	ldr	pc, [pc, #580]	; 30000284 <mem_cfg_val+0x34>

3000003c <HandleIRQ>:
3000003c:	e59ff244 	ldr	pc, [pc, #580]	; 30000288 <mem_cfg_val+0x38>

30000040 <HandleUndef>:
30000040:	e59ff244 	ldr	pc, [pc, #580]	; 3000028c <mem_cfg_val+0x3c>

30000044 <HandleSWI>:
30000044:	e59ff240 	ldr	pc, [pc, #576]	; 3000028c <mem_cfg_val+0x3c>

30000048 <HandleDabort>:
30000048:	e59ff23c 	ldr	pc, [pc, #572]	; 3000028c <mem_cfg_val+0x3c>

3000004c <HandlePabort>:
3000004c:	e59ff238 	ldr	pc, [pc, #568]	; 3000028c <mem_cfg_val+0x3c>

30000050 <_text_start>:
30000050:	30000000 	.word	0x30000000

30000054 <_bss_start>:
30000054:	30026938 	.word	0x30026938

30000058 <_bss_end>:
30000058:	3002b37c 	.word	0x3002b37c

3000005c <ResetHandler>:
3000005c:	e3a01453 	mov	r1, #1392508928	; 0x53000000
30000060:	e3a02000 	mov	r2, #0
30000064:	e5812000 	str	r2, [r1]
30000068:	e3a0144a 	mov	r1, #1241513984	; 0x4a000000
3000006c:	e3e02000 	mvn	r2, #0
30000070:	e5812008 	str	r2, [r1, #8]
30000074:	e59f2214 	ldr	r2, [pc, #532]	; 30000290 <mem_cfg_val+0x40>
30000078:	e581201c 	str	r2, [r1, #28]
3000007c:	e3a01313 	mov	r1, #1275068416	; 0x4c000000
30000080:	e3e024ff 	mvn	r2, #-16777216	; 0xff000000
30000084:	e5812000 	str	r2, [r1]
30000088:	e3a01313 	mov	r1, #1275068416	; 0x4c000000
3000008c:	e3a02005 	mov	r2, #5
30000090:	e5812014 	str	r2, [r1, #20]
30000094:	ee111f10 	mrc	15, 0, r1, cr1, cr0, {0}
30000098:	e3811103 	orr	r1, r1, #-1073741824	; 0xc0000000
3000009c:	ee011f10 	mcr	15, 0, r1, cr1, cr0, {0}
300000a0:	e3a01313 	mov	r1, #1275068416	; 0x4c000000
300000a4:	e59f21e8 	ldr	r2, [pc, #488]	; 30000294 <mem_cfg_val+0x44>
300000a8:	e5812004 	str	r2, [r1, #4]
300000ac:	eb000058 	bl	30000214 <memsetup>
300000b0:	eb00003e 	bl	300001b0 <InitStacks>
300000b4:	e24f00bc 	sub	r0, pc, #188	; 0xbc
300000b8:	e51f1070 	ldr	r1, [pc, #-112]	; 30000050 <_text_start>
300000bc:	e1500001 	cmp	r0, r1
300000c0:	1b000004 	blne	300000d8 <copy_self>
300000c4:	e51f0078 	ldr	r0, [pc, #-120]	; 30000054 <_bss_start>
300000c8:	e51f1078 	ldr	r1, [pc, #-120]	; 30000058 <_bss_end>
300000cc:	eb000059 	bl	30000238 <mem_clear>
300000d0:	e59ff1ac 	ldr	pc, [pc, #428]	; 30000284 <mem_cfg_val+0x34>
300000d4:	eafffffe 	b	300000d4 <ResetHandler+0x78>

300000d8 <copy_self>:
300000d8:	e3a011b1 	mov	r1, #1073741868	; 0x4000002c
300000dc:	e3a00000 	mov	r0, #0
300000e0:	e5810000 	str	r0, [r1]
300000e4:	e3a0102c 	mov	r1, #44	; 0x2c
300000e8:	e5910000 	ldr	r0, [r1]
300000ec:	e3500000 	cmp	r0, #0
300000f0:	1a000003 	bne	30000104 <copy_from_rom>
300000f4:	e59f019c 	ldr	r0, [pc, #412]	; 30000298 <mem_cfg_val+0x48>
300000f8:	e3a011b1 	mov	r1, #1073741868	; 0x4000002c
300000fc:	e5810000 	str	r0, [r1]
30000100:	ea000006 	b	30000120 <copy_from_nand>

30000104 <copy_from_rom>:
30000104:	e51f10bc 	ldr	r1, [pc, #-188]	; 30000050 <_text_start>
30000108:	e51f30bc 	ldr	r3, [pc, #-188]	; 30000054 <_bss_start>
3000010c:	e4902004 	ldr	r2, [r0], #4
30000110:	e4812004 	str	r2, [r1], #4
30000114:	e1510003 	cmp	r1, r3
30000118:	bafffff9 	blt	30000104 <copy_from_rom>
3000011c:	e1a0f00e 	mov	pc, lr

30000120 <copy_from_nand>:
30000120:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30000124:	eb000316 	bl	30000d84 <nand_init>
30000128:	e51f00e0 	ldr	r0, [pc, #-224]	; 30000050 <_text_start>
3000012c:	e3a01000 	mov	r1, #0
30000130:	e51f30e4 	ldr	r3, [pc, #-228]	; 30000054 <_bss_start>
30000134:	e0432000 	sub	r2, r3, r0
30000138:	eb000420 	bl	300011c0 <nand_read>
3000013c:	e3500000 	cmp	r0, #0
30000140:	0a000007 	beq	30000164 <ok_nand_read>

30000144 <bad_nand_read>:
30000144:	e59f0150 	ldr	r0, [pc, #336]	; 3000029c <mem_cfg_val+0x4c>
30000148:	e3a01a01 	mov	r1, #4096	; 0x1000
3000014c:	e5801000 	str	r1, [r0]
30000150:	e59f0148 	ldr	r0, [pc, #328]	; 300002a0 <mem_cfg_val+0x50>
30000154:	e3a01000 	mov	r1, #0
30000158:	e5801000 	str	r1, [r0]
3000015c:	eafffffe 	b	3000015c <bad_nand_read+0x18>
30000160:	eafffff7 	b	30000144 <bad_nand_read>

30000164 <ok_nand_read>:
30000164:	e3a00000 	mov	r0, #0
30000168:	e51f1120 	ldr	r1, [pc, #-288]	; 30000050 <_text_start>
3000016c:	e3a02c02 	mov	r2, #512	; 0x200

30000170 <go_next>:
30000170:	e4903004 	ldr	r3, [r0], #4
30000174:	e4914004 	ldr	r4, [r1], #4
30000178:	e1530004 	cmp	r3, r4
3000017c:	1a000002 	bne	3000018c <notmatch>
30000180:	e1500002 	cmp	r0, r2
30000184:	0a000008 	beq	300001ac <out>
30000188:	eafffff8 	b	30000170 <go_next>

3000018c <notmatch>:
3000018c:	e59f0108 	ldr	r0, [pc, #264]	; 3000029c <mem_cfg_val+0x4c>
30000190:	e3a01b01 	mov	r1, #1024	; 0x400
30000194:	e5801000 	str	r1, [r0]
30000198:	e59f0100 	ldr	r0, [pc, #256]	; 300002a0 <mem_cfg_val+0x50>
3000019c:	e3a01000 	mov	r1, #0
300001a0:	e5801000 	str	r1, [r0]
300001a4:	eafffffe 	b	300001a4 <notmatch+0x18>
300001a8:	eafffff7 	b	3000018c <notmatch>

300001ac <out>:
300001ac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)

300001b0 <InitStacks>:
300001b0:	e1a0200e 	mov	r2, lr
300001b4:	e10f0000 	mrs	r0, CPSR
300001b8:	e3c0001f 	bic	r0, r0, #31
300001bc:	e38010db 	orr	r1, r0, #219	; 0xdb
300001c0:	e12ff001 	msr	CPSR_fsxc, r1
300001c4:	e59fd0d8 	ldr	sp, [pc, #216]	; 300002a4 <mem_cfg_val+0x54>
300001c8:	e38010d7 	orr	r1, r0, #215	; 0xd7
300001cc:	e12ff001 	msr	CPSR_fsxc, r1
300001d0:	e59fd0d0 	ldr	sp, [pc, #208]	; 300002a8 <mem_cfg_val+0x58>
300001d4:	e38010d2 	orr	r1, r0, #210	; 0xd2
300001d8:	e12ff001 	msr	CPSR_fsxc, r1
300001dc:	e59fd0c8 	ldr	sp, [pc, #200]	; 300002ac <mem_cfg_val+0x5c>
300001e0:	e38010d1 	orr	r1, r0, #209	; 0xd1
300001e4:	e12ff001 	msr	CPSR_fsxc, r1
300001e8:	e59fd0c0 	ldr	sp, [pc, #192]	; 300002b0 <mem_cfg_val+0x60>
300001ec:	e3c000df 	bic	r0, r0, #223	; 0xdf
300001f0:	e3801013 	orr	r1, r0, #19
300001f4:	e12ff001 	msr	CPSR_fsxc, r1
300001f8:	e59fd0b4 	ldr	sp, [pc, #180]	; 300002b4 <mem_cfg_val+0x64>
300001fc:	e10f0000 	mrs	r0, CPSR
30000200:	e3c0001f 	bic	r0, r0, #31
30000204:	e38010df 	orr	r1, r0, #223	; 0xdf
30000208:	e12ff001 	msr	CPSR_fsxc, r1
3000020c:	e59fd0a4 	ldr	sp, [pc, #164]	; 300002b8 <mem_cfg_val+0x68>
30000210:	e1a0f002 	mov	pc, r2

30000214 <memsetup>:
30000214:	e3a01312 	mov	r1, #1207959552	; 0x48000000
30000218:	e28f2030 	add	r2, pc, #48	; 0x30
3000021c:	e1a00000 	nop			; (mov r0, r0)
30000220:	e2813034 	add	r3, r1, #52	; 0x34
30000224:	e4924004 	ldr	r4, [r2], #4
30000228:	e4814004 	str	r4, [r1], #4
3000022c:	e1510003 	cmp	r1, r3
30000230:	1afffffb 	bne	30000224 <memsetup+0x10>
30000234:	e1a0f00e 	mov	pc, lr

30000238 <mem_clear>:
30000238:	e3a02000 	mov	r2, #0
3000023c:	e4802004 	str	r2, [r0], #4
30000240:	e1500001 	cmp	r0, r1
30000244:	bafffffc 	blt	3000023c <mem_clear+0x4>
30000248:	e1a0f00e 	mov	pc, lr
3000024c:	e1a00000 	nop			; (mov r0, r0)

30000250 <mem_cfg_val>:
30000250:	22111110 	.word	0x22111110
30000254:	00000700 	.word	0x00000700
30000258:	00000700 	.word	0x00000700
3000025c:	00000700 	.word	0x00000700
30000260:	00000700 	.word	0x00000700
30000264:	00000700 	.word	0x00000700
30000268:	00000700 	.word	0x00000700
3000026c:	00018009 	.word	0x00018009
30000270:	00018009 	.word	0x00018009
30000274:	008e04eb 	.word	0x008e04eb
30000278:	000000b2 	.word	0x000000b2
3000027c:	00000030 	.word	0x00000030
30000280:	00000030 	.word	0x00000030
30000284:	30001a98 	.word	0x30001a98
30000288:	3000166c 	.word	0x3000166c
3000028c:	300016a8 	.word	0x300016a8
30000290:	000007ff 	.word	0x000007ff
30000294:	0007f021 	.word	0x0007f021
30000298:	00000988 	.word	0x00000988
3000029c:	56000010 	.word	0x56000010
300002a0:	56000014 	.word	0x56000014
300002a4:	33fffc00 	.word	0x33fffc00
300002a8:	33fffd00 	.word	0x33fffd00
300002ac:	33ffff00 	.word	0x33ffff00
300002b0:	33ffff00 	.word	0x33ffff00
300002b4:	33fffb00 	.word	0x33fffb00
300002b8:	33fff900 	.word	0x33fff900
300002bc:	e1a00000 	nop			; (mov r0, r0)

300002c0 <hal_stack_init>:
	acoral_u32 r12;
	acoral_u32 lr;
	acoral_u32 pc;
}hal_ctx_t;

void hal_stack_init(acoral_u32 **stk,void (*route)(),void (*exit)(),void *args){
300002c0:	e24dd018 	sub	sp, sp, #24
300002c4:	e58d000c 	str	r0, [sp, #12]
300002c8:	e58d1008 	str	r1, [sp, #8]
300002cc:	e58d2004 	str	r2, [sp, #4]
300002d0:	e58d3000 	str	r3, [sp]
	hal_ctx_t *ctx=(hal_ctx_t *)*stk;	
300002d4:	e59d300c 	ldr	r3, [sp, #12]
300002d8:	e5933000 	ldr	r3, [r3]
300002dc:	e58d3014 	str	r3, [sp, #20]
	ctx--;
300002e0:	e59d3014 	ldr	r3, [sp, #20]
300002e4:	e2433040 	sub	r3, r3, #64	; 0x40
300002e8:	e58d3014 	str	r3, [sp, #20]
	ctx=(hal_ctx_t *)((acoral_u32 *)ctx+1);
300002ec:	e59d3014 	ldr	r3, [sp, #20]
300002f0:	e2833004 	add	r3, r3, #4
300002f4:	e58d3014 	str	r3, [sp, #20]
	ctx->r0=(acoral_u32)args;
300002f8:	e59d2000 	ldr	r2, [sp]
300002fc:	e59d3014 	ldr	r3, [sp, #20]
30000300:	e5832004 	str	r2, [r3, #4]
	ctx->r1=1;
30000304:	e59d3014 	ldr	r3, [sp, #20]
30000308:	e3a02001 	mov	r2, #1
3000030c:	e5832008 	str	r2, [r3, #8]
	ctx->r2=2;
30000310:	e59d3014 	ldr	r3, [sp, #20]
30000314:	e3a02002 	mov	r2, #2
30000318:	e583200c 	str	r2, [r3, #12]
	ctx->r3=3;
3000031c:	e59d3014 	ldr	r3, [sp, #20]
30000320:	e3a02003 	mov	r2, #3
30000324:	e5832010 	str	r2, [r3, #16]
	ctx->r4=4;
30000328:	e59d3014 	ldr	r3, [sp, #20]
3000032c:	e3a02004 	mov	r2, #4
30000330:	e5832014 	str	r2, [r3, #20]
	ctx->r5=5;
30000334:	e59d3014 	ldr	r3, [sp, #20]
30000338:	e3a02005 	mov	r2, #5
3000033c:	e5832018 	str	r2, [r3, #24]
	ctx->r6=6;
30000340:	e59d3014 	ldr	r3, [sp, #20]
30000344:	e3a02006 	mov	r2, #6
30000348:	e583201c 	str	r2, [r3, #28]
	ctx->r7=7;
3000034c:	e59d3014 	ldr	r3, [sp, #20]
30000350:	e3a02007 	mov	r2, #7
30000354:	e5832020 	str	r2, [r3, #32]
	ctx->r8=8;
30000358:	e59d3014 	ldr	r3, [sp, #20]
3000035c:	e3a02008 	mov	r2, #8
30000360:	e5832024 	str	r2, [r3, #36]	; 0x24
	ctx->r9=9;
30000364:	e59d3014 	ldr	r3, [sp, #20]
30000368:	e3a02009 	mov	r2, #9
3000036c:	e5832028 	str	r2, [r3, #40]	; 0x28
	ctx->r10=10;
30000370:	e59d3014 	ldr	r3, [sp, #20]
30000374:	e3a0200a 	mov	r2, #10
30000378:	e583202c 	str	r2, [r3, #44]	; 0x2c
	ctx->r11=11;
3000037c:	e59d3014 	ldr	r3, [sp, #20]
30000380:	e3a0200b 	mov	r2, #11
30000384:	e5832030 	str	r2, [r3, #48]	; 0x30
	ctx->r12=12;
30000388:	e59d3014 	ldr	r3, [sp, #20]
3000038c:	e3a0200c 	mov	r2, #12
30000390:	e5832034 	str	r2, [r3, #52]	; 0x34
	ctx->lr=(acoral_u32)exit;
30000394:	e59d2004 	ldr	r2, [sp, #4]
30000398:	e59d3014 	ldr	r3, [sp, #20]
3000039c:	e5832038 	str	r2, [r3, #56]	; 0x38
	ctx->pc=(acoral_u32)route;
300003a0:	e59d2008 	ldr	r2, [sp, #8]
300003a4:	e59d3014 	ldr	r3, [sp, #20]
300003a8:	e583203c 	str	r2, [r3, #60]	; 0x3c
	ctx->cpsr=0x0000001fL;
300003ac:	e59d3014 	ldr	r3, [sp, #20]
300003b0:	e3a0201f 	mov	r2, #31
300003b4:	e5832000 	str	r2, [r3]
    *stk=(acoral_u32 *)ctx;
300003b8:	e59d2014 	ldr	r2, [sp, #20]
300003bc:	e59d300c 	ldr	r3, [sp, #12]
300003c0:	e5832000 	str	r2, [r3]
}
300003c4:	e28dd018 	add	sp, sp, #24
300003c8:	e12fff1e 	bx	lr

300003cc <hal_all_entry>:
#include<acoral.h>
#include<hal_2440_cfg.h>
#include<hal_2440_c.h>
void hal_all_entry(acoral_vector vector){
300003cc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300003d0:	e24dd014 	sub	sp, sp, #20
300003d4:	e58d0004 	str	r0, [sp, #4]
    unsigned long eint;
    unsigned long irq=4;
300003d8:	e3a03004 	mov	r3, #4
300003dc:	e58d300c 	str	r3, [sp, #12]
    if(vector==4||vector==5){
300003e0:	e59d3004 	ldr	r3, [sp, #4]
300003e4:	e3530004 	cmp	r3, #4
300003e8:	0a000002 	beq	300003f8 <hal_all_entry+0x2c>
300003ec:	e59d3004 	ldr	r3, [sp, #4]
300003f0:	e3530005 	cmp	r3, #5
300003f4:	1a000016 	bne	30000454 <hal_all_entry+0x88>
    	eint=rEINTPND;
300003f8:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300003fc:	e28330a8 	add	r3, r3, #168	; 0xa8
30000400:	e5933000 	ldr	r3, [r3]
30000404:	e58d3008 	str	r3, [sp, #8]
    	for(;irq<24;irq++){
30000408:	ea00000e 	b	30000448 <hal_all_entry+0x7c>
      		 if(eint & (1<<irq)){
3000040c:	e59d300c 	ldr	r3, [sp, #12]
30000410:	e3a02001 	mov	r2, #1
30000414:	e1a03312 	lsl	r3, r2, r3
30000418:	e1a02003 	mov	r2, r3
3000041c:	e59d3008 	ldr	r3, [sp, #8]
30000420:	e0023003 	and	r3, r2, r3
30000424:	e3530000 	cmp	r3, #0
30000428:	0a000003 	beq	3000043c <hal_all_entry+0x70>
           		acoral_intr_entry(irq);
3000042c:	e59d300c 	ldr	r3, [sp, #12]
30000430:	e1a00003 	mov	r0, r3
30000434:	eb000ef4 	bl	3000400c <acoral_intr_entry>
           		return;
30000438:	ea000012 	b	30000488 <hal_all_entry+0xbc>
void hal_all_entry(acoral_vector vector){
    unsigned long eint;
    unsigned long irq=4;
    if(vector==4||vector==5){
    	eint=rEINTPND;
    	for(;irq<24;irq++){
3000043c:	e59d300c 	ldr	r3, [sp, #12]
30000440:	e2833001 	add	r3, r3, #1
30000444:	e58d300c 	str	r3, [sp, #12]
30000448:	e59d300c 	ldr	r3, [sp, #12]
3000044c:	e3530017 	cmp	r3, #23
30000450:	9affffed 	bls	3000040c <hal_all_entry+0x40>
           		acoral_intr_entry(irq);
           		return;
           	 }
    	}
    }
    if(vector>5)
30000454:	e59d3004 	ldr	r3, [sp, #4]
30000458:	e3530005 	cmp	r3, #5
3000045c:	da000002 	ble	3000046c <hal_all_entry+0xa0>
    	vector+=18;
30000460:	e59d3004 	ldr	r3, [sp, #4]
30000464:	e2833012 	add	r3, r3, #18
30000468:	e58d3004 	str	r3, [sp, #4]
    if(vector==4)
3000046c:	e59d3004 	ldr	r3, [sp, #4]
30000470:	e3530004 	cmp	r3, #4
30000474:	1a000001 	bne	30000480 <hal_all_entry+0xb4>
    	acoral_prints("DErr\n");
30000478:	e59f0014 	ldr	r0, [pc, #20]	; 30000494 <hal_all_entry+0xc8>
3000047c:	eb002c0c 	bl	3000b4b4 <acoral_prints>
    acoral_intr_entry(vector);
30000480:	e59d0004 	ldr	r0, [sp, #4]
30000484:	eb000ee0 	bl	3000400c <acoral_intr_entry>
}
30000488:	e28dd014 	add	sp, sp, #20
3000048c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30000490:	e12fff1e 	bx	lr
30000494:	30025e3c 	.word	0x30025e3c

30000498 <hal_intr_unmask>:

static void hal_intr_unmask(acoral_vector vector){
30000498:	e24dd008 	sub	sp, sp, #8
3000049c:	e58d0004 	str	r0, [sp, #4]
          if((vector>3) && (vector<8)){
300004a0:	e59d3004 	ldr	r3, [sp, #4]
300004a4:	e3530003 	cmp	r3, #3
300004a8:	da000010 	ble	300004f0 <hal_intr_unmask+0x58>
300004ac:	e59d3004 	ldr	r3, [sp, #4]
300004b0:	e3530007 	cmp	r3, #7
300004b4:	ca00000d 	bgt	300004f0 <hal_intr_unmask+0x58>
               rEINTMSK &=~(1<<vector);
300004b8:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300004bc:	e28330a4 	add	r3, r3, #164	; 0xa4
300004c0:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300004c4:	e28220a4 	add	r2, r2, #164	; 0xa4
300004c8:	e5921000 	ldr	r1, [r2]
300004cc:	e3a00001 	mov	r0, #1
300004d0:	e59d2004 	ldr	r2, [sp, #4]
300004d4:	e1a02210 	lsl	r2, r0, r2
300004d8:	e1e02002 	mvn	r2, r2
300004dc:	e0012002 	and	r2, r1, r2
300004e0:	e5832000 	str	r2, [r3]
               vector = 4;
300004e4:	e3a03004 	mov	r3, #4
300004e8:	e58d3004 	str	r3, [sp, #4]
    	acoral_prints("DErr\n");
    acoral_intr_entry(vector);
}

static void hal_intr_unmask(acoral_vector vector){
          if((vector>3) && (vector<8)){
300004ec:	ea000019 	b	30000558 <hal_intr_unmask+0xc0>
               rEINTMSK &=~(1<<vector);
               vector = 4;
           }
         else if((vector>7) && (vector<24)){
300004f0:	e59d3004 	ldr	r3, [sp, #4]
300004f4:	e3530007 	cmp	r3, #7
300004f8:	da000010 	ble	30000540 <hal_intr_unmask+0xa8>
300004fc:	e59d3004 	ldr	r3, [sp, #4]
30000500:	e3530017 	cmp	r3, #23
30000504:	ca00000d 	bgt	30000540 <hal_intr_unmask+0xa8>
               rEINTMSK &=~(1<<vector);
30000508:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3000050c:	e28330a4 	add	r3, r3, #164	; 0xa4
30000510:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30000514:	e28220a4 	add	r2, r2, #164	; 0xa4
30000518:	e5921000 	ldr	r1, [r2]
3000051c:	e3a00001 	mov	r0, #1
30000520:	e59d2004 	ldr	r2, [sp, #4]
30000524:	e1a02210 	lsl	r2, r0, r2
30000528:	e1e02002 	mvn	r2, r2
3000052c:	e0012002 	and	r2, r1, r2
30000530:	e5832000 	str	r2, [r3]
               vector = 5;
30000534:	e3a03005 	mov	r3, #5
30000538:	e58d3004 	str	r3, [sp, #4]
static void hal_intr_unmask(acoral_vector vector){
          if((vector>3) && (vector<8)){
               rEINTMSK &=~(1<<vector);
               vector = 4;
           }
         else if((vector>7) && (vector<24)){
3000053c:	ea000005 	b	30000558 <hal_intr_unmask+0xc0>
               rEINTMSK &=~(1<<vector);
               vector = 5;
           }
         else if(vector > 23)
30000540:	e59d3004 	ldr	r3, [sp, #4]
30000544:	e3530017 	cmp	r3, #23
30000548:	da000002 	ble	30000558 <hal_intr_unmask+0xc0>
               vector -= 18; 
3000054c:	e59d3004 	ldr	r3, [sp, #4]
30000550:	e2433012 	sub	r3, r3, #18
30000554:	e58d3004 	str	r3, [sp, #4]

         rINTMSK &=~(1<<vector);			/*开启中断*/
30000558:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3000055c:	e2833008 	add	r3, r3, #8
30000560:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
30000564:	e2822008 	add	r2, r2, #8
30000568:	e5921000 	ldr	r1, [r2]
3000056c:	e3a00001 	mov	r0, #1
30000570:	e59d2004 	ldr	r2, [sp, #4]
30000574:	e1a02210 	lsl	r2, r0, r2
30000578:	e1e02002 	mvn	r2, r2
3000057c:	e0012002 	and	r2, r1, r2
30000580:	e5832000 	str	r2, [r3]
}
30000584:	e28dd008 	add	sp, sp, #8
30000588:	e12fff1e 	bx	lr

3000058c <hal_intr_mask>:

static void hal_intr_mask(acoral_vector vector){
3000058c:	e24dd008 	sub	sp, sp, #8
30000590:	e58d0004 	str	r0, [sp, #4]

         if((vector>3) && (vector<8)){
30000594:	e59d3004 	ldr	r3, [sp, #4]
30000598:	e3530003 	cmp	r3, #3
3000059c:	da00000f 	ble	300005e0 <hal_intr_mask+0x54>
300005a0:	e59d3004 	ldr	r3, [sp, #4]
300005a4:	e3530007 	cmp	r3, #7
300005a8:	ca00000c 	bgt	300005e0 <hal_intr_mask+0x54>
               rEINTMSK |=(1<<vector);
300005ac:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300005b0:	e28330a4 	add	r3, r3, #164	; 0xa4
300005b4:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300005b8:	e28220a4 	add	r2, r2, #164	; 0xa4
300005bc:	e5921000 	ldr	r1, [r2]
300005c0:	e3a00001 	mov	r0, #1
300005c4:	e59d2004 	ldr	r2, [sp, #4]
300005c8:	e1a02210 	lsl	r2, r0, r2
300005cc:	e1812002 	orr	r2, r1, r2
300005d0:	e5832000 	str	r2, [r3]
               vector = 4;
300005d4:	e3a03004 	mov	r3, #4
300005d8:	e58d3004 	str	r3, [sp, #4]
         rINTMSK &=~(1<<vector);			/*开启中断*/
}

static void hal_intr_mask(acoral_vector vector){

         if((vector>3) && (vector<8)){
300005dc:	ea000018 	b	30000644 <hal_intr_mask+0xb8>
               rEINTMSK |=(1<<vector);
               vector = 4;
           }
         else if((vector>7) && (vector<24)){
300005e0:	e59d3004 	ldr	r3, [sp, #4]
300005e4:	e3530007 	cmp	r3, #7
300005e8:	da00000f 	ble	3000062c <hal_intr_mask+0xa0>
300005ec:	e59d3004 	ldr	r3, [sp, #4]
300005f0:	e3530017 	cmp	r3, #23
300005f4:	ca00000c 	bgt	3000062c <hal_intr_mask+0xa0>
               rEINTMSK |=(1<<vector);
300005f8:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300005fc:	e28330a4 	add	r3, r3, #164	; 0xa4
30000600:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30000604:	e28220a4 	add	r2, r2, #164	; 0xa4
30000608:	e5921000 	ldr	r1, [r2]
3000060c:	e3a00001 	mov	r0, #1
30000610:	e59d2004 	ldr	r2, [sp, #4]
30000614:	e1a02210 	lsl	r2, r0, r2
30000618:	e1812002 	orr	r2, r1, r2
3000061c:	e5832000 	str	r2, [r3]
               vector = 5;
30000620:	e3a03005 	mov	r3, #5
30000624:	e58d3004 	str	r3, [sp, #4]

         if((vector>3) && (vector<8)){
               rEINTMSK |=(1<<vector);
               vector = 4;
           }
         else if((vector>7) && (vector<24)){
30000628:	ea000005 	b	30000644 <hal_intr_mask+0xb8>
               rEINTMSK |=(1<<vector);
               vector = 5;
           }
         else if(vector > 23)
3000062c:	e59d3004 	ldr	r3, [sp, #4]
30000630:	e3530017 	cmp	r3, #23
30000634:	da000002 	ble	30000644 <hal_intr_mask+0xb8>
               vector -= 18; 
30000638:	e59d3004 	ldr	r3, [sp, #4]
3000063c:	e2433012 	sub	r3, r3, #18
30000640:	e58d3004 	str	r3, [sp, #4]

         rINTMSK |= (1<<vector);
30000644:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30000648:	e2833008 	add	r3, r3, #8
3000064c:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
30000650:	e2822008 	add	r2, r2, #8
30000654:	e5921000 	ldr	r1, [r2]
30000658:	e3a00001 	mov	r0, #1
3000065c:	e59d2004 	ldr	r2, [sp, #4]
30000660:	e1a02210 	lsl	r2, r0, r2
30000664:	e1812002 	orr	r2, r1, r2
30000668:	e5832000 	str	r2, [r3]
}
3000066c:	e28dd008 	add	sp, sp, #8
30000670:	e12fff1e 	bx	lr

30000674 <hal_intr_ack>:

static void hal_intr_ack(acoral_u32 vector){
30000674:	e24dd008 	sub	sp, sp, #8
30000678:	e58d0004 	str	r0, [sp, #4]

        if((vector>3) && (vector<8)){
3000067c:	e59d3004 	ldr	r3, [sp, #4]
30000680:	e3530003 	cmp	r3, #3
30000684:	9a000010 	bls	300006cc <hal_intr_ack+0x58>
30000688:	e59d3004 	ldr	r3, [sp, #4]
3000068c:	e3530007 	cmp	r3, #7
30000690:	8a00000d 	bhi	300006cc <hal_intr_ack+0x58>
               rEINTPND &= ~(1<<vector);
30000694:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30000698:	e28330a8 	add	r3, r3, #168	; 0xa8
3000069c:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300006a0:	e28220a8 	add	r2, r2, #168	; 0xa8
300006a4:	e5921000 	ldr	r1, [r2]
300006a8:	e59d2004 	ldr	r2, [sp, #4]
300006ac:	e3a00001 	mov	r0, #1
300006b0:	e1a02210 	lsl	r2, r0, r2
300006b4:	e1e02002 	mvn	r2, r2
300006b8:	e0012002 	and	r2, r1, r2
300006bc:	e5832000 	str	r2, [r3]
               vector = 4;
300006c0:	e3a03004 	mov	r3, #4
300006c4:	e58d3004 	str	r3, [sp, #4]
         rINTMSK |= (1<<vector);
}

static void hal_intr_ack(acoral_u32 vector){

        if((vector>3) && (vector<8)){
300006c8:	ea000019 	b	30000734 <hal_intr_ack+0xc0>
               rEINTPND &= ~(1<<vector);
               vector = 4;
           }
        else if((vector>7) && (vector<24)){
300006cc:	e59d3004 	ldr	r3, [sp, #4]
300006d0:	e3530007 	cmp	r3, #7
300006d4:	9a000010 	bls	3000071c <hal_intr_ack+0xa8>
300006d8:	e59d3004 	ldr	r3, [sp, #4]
300006dc:	e3530017 	cmp	r3, #23
300006e0:	8a00000d 	bhi	3000071c <hal_intr_ack+0xa8>
               rEINTPND &= ~(1<<vector);
300006e4:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300006e8:	e28330a8 	add	r3, r3, #168	; 0xa8
300006ec:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300006f0:	e28220a8 	add	r2, r2, #168	; 0xa8
300006f4:	e5921000 	ldr	r1, [r2]
300006f8:	e59d2004 	ldr	r2, [sp, #4]
300006fc:	e3a00001 	mov	r0, #1
30000700:	e1a02210 	lsl	r2, r0, r2
30000704:	e1e02002 	mvn	r2, r2
30000708:	e0012002 	and	r2, r1, r2
3000070c:	e5832000 	str	r2, [r3]
               vector = 5;
30000710:	e3a03005 	mov	r3, #5
30000714:	e58d3004 	str	r3, [sp, #4]

        if((vector>3) && (vector<8)){
               rEINTPND &= ~(1<<vector);
               vector = 4;
           }
        else if((vector>7) && (vector<24)){
30000718:	ea000005 	b	30000734 <hal_intr_ack+0xc0>
               rEINTPND &= ~(1<<vector);
               vector = 5;
           }
        else if(vector > 23)
3000071c:	e59d3004 	ldr	r3, [sp, #4]
30000720:	e3530017 	cmp	r3, #23
30000724:	9a000002 	bls	30000734 <hal_intr_ack+0xc0>
               vector -= 18;
30000728:	e59d3004 	ldr	r3, [sp, #4]
3000072c:	e2433012 	sub	r3, r3, #18
30000730:	e58d3004 	str	r3, [sp, #4]
   
        
        rSRCPND = 1<<vector;
30000734:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30000738:	e59d2004 	ldr	r2, [sp, #4]
3000073c:	e3a01001 	mov	r1, #1
30000740:	e1a02211 	lsl	r2, r1, r2
30000744:	e5832000 	str	r2, [r3]
		rINTPND = 1<<vector;		
30000748:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3000074c:	e2833010 	add	r3, r3, #16
30000750:	e59d2004 	ldr	r2, [sp, #4]
30000754:	e3a01001 	mov	r1, #1
30000758:	e1a02211 	lsl	r2, r1, r2
3000075c:	e5832000 	str	r2, [r3]
}
30000760:	e28dd008 	add	sp, sp, #8
30000764:	e12fff1e 	bx	lr

30000768 <hal_intr_init>:

void hal_intr_init(){
30000768:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000076c:	e24dd00c 	sub	sp, sp, #12
	acoral_u32 i;
    /*配置中断管脚*/

	/*中断触发模式*/
	rEXTINT0 = 0x22222222;		/* EINT[7:0]*/
30000770:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30000774:	e2822088 	add	r2, r2, #136	; 0x88
30000778:	e3a03c22 	mov	r3, #8704	; 0x2200
3000077c:	e2833022 	add	r3, r3, #34	; 0x22
30000780:	e1833803 	orr	r3, r3, r3, lsl #16
30000784:	e5823000 	str	r3, [r2]
    rEXTINT1 = 0x22222222;		/* EINT[15:8]*/
30000788:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3000078c:	e282208c 	add	r2, r2, #140	; 0x8c
30000790:	e3a03c22 	mov	r3, #8704	; 0x2200
30000794:	e2833022 	add	r3, r3, #34	; 0x22
30000798:	e1833803 	orr	r3, r3, r3, lsl #16
3000079c:	e5823000 	str	r3, [r2]
    rEXTINT2 = 0x22222222;		/* EINT[23:16]*/
300007a0:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300007a4:	e2822090 	add	r2, r2, #144	; 0x90
300007a8:	e3a03c22 	mov	r3, #8704	; 0x2200
300007ac:	e2833022 	add	r3, r3, #34	; 0x22
300007b0:	e1833803 	orr	r3, r3, r3, lsl #16
300007b4:	e5823000 	str	r3, [r2]

  	rPRIORITY = 0x00000000;		/* 使用默认的固定的优先级*/
300007b8:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
300007bc:	e283300c 	add	r3, r3, #12
300007c0:	e3a02000 	mov	r2, #0
300007c4:	e5832000 	str	r2, [r3]
	rINTMOD = 0x00000000;		/* 所有中断均为IRQ中断*/
300007c8:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
300007cc:	e2833004 	add	r3, r3, #4
300007d0:	e3a02000 	mov	r2, #0
300007d4:	e5832000 	str	r2, [r3]
    rEINTMSK= 0xffffffff;      /*屏蔽所有外部中断*/
300007d8:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300007dc:	e28330a4 	add	r3, r3, #164	; 0xa4
300007e0:	e3e02000 	mvn	r2, #0
300007e4:	e5832000 	str	r2, [r3]
    rINTMSK = 0xffffffff;       /*屏蔽所有中断*/
300007e8:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
300007ec:	e2833008 	add	r3, r3, #8
300007f0:	e3e02000 	mvn	r2, #0
300007f4:	e5832000 	str	r2, [r3]

	for(i=HAL_INTR_MIN;i<=HAL_INTR_MAX;i++){
300007f8:	e3a03000 	mov	r3, #0
300007fc:	e58d3004 	str	r3, [sp, #4]
30000800:	ea00000e 	b	30000840 <hal_intr_init+0xd8>
		acoral_set_intr_enter(i,hal_intr_ack);
30000804:	e59d0004 	ldr	r0, [sp, #4]
30000808:	e59f1048 	ldr	r1, [pc, #72]	; 30000858 <hal_intr_init+0xf0>
3000080c:	eb000e8b 	bl	30004240 <acoral_set_intr_enter>
		acoral_set_intr_exit(i,NULL);
30000810:	e59d0004 	ldr	r0, [sp, #4]
30000814:	e3a01000 	mov	r1, #0
30000818:	eb000e9b 	bl	3000428c <acoral_set_intr_exit>
		acoral_set_intr_mask(i,hal_intr_mask);
3000081c:	e59d0004 	ldr	r0, [sp, #4]
30000820:	e59f1034 	ldr	r1, [pc, #52]	; 3000085c <hal_intr_init+0xf4>
30000824:	eb000eab 	bl	300042d8 <acoral_set_intr_mask>
		acoral_set_intr_unmask(i,hal_intr_unmask);
30000828:	e59d0004 	ldr	r0, [sp, #4]
3000082c:	e59f102c 	ldr	r1, [pc, #44]	; 30000860 <hal_intr_init+0xf8>
30000830:	eb000ebb 	bl	30004324 <acoral_set_intr_unmask>
  	rPRIORITY = 0x00000000;		/* 使用默认的固定的优先级*/
	rINTMOD = 0x00000000;		/* 所有中断均为IRQ中断*/
    rEINTMSK= 0xffffffff;      /*屏蔽所有外部中断*/
    rINTMSK = 0xffffffff;       /*屏蔽所有中断*/

	for(i=HAL_INTR_MIN;i<=HAL_INTR_MAX;i++){
30000834:	e59d3004 	ldr	r3, [sp, #4]
30000838:	e2833001 	add	r3, r3, #1
3000083c:	e58d3004 	str	r3, [sp, #4]
30000840:	e59d3004 	ldr	r3, [sp, #4]
30000844:	e3530031 	cmp	r3, #49	; 0x31
30000848:	9affffed 	bls	30000804 <hal_intr_init+0x9c>
		acoral_set_intr_enter(i,hal_intr_ack);
		acoral_set_intr_exit(i,NULL);
		acoral_set_intr_mask(i,hal_intr_mask);
		acoral_set_intr_unmask(i,hal_intr_unmask);
	}
}
3000084c:	e28dd00c 	add	sp, sp, #12
30000850:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30000854:	e12fff1e 	bx	lr
30000858:	30000674 	.word	0x30000674
3000085c:	3000058c 	.word	0x3000058c
30000860:	30000498 	.word	0x30000498

30000864 <hal_ticks_init>:
/****************************************
*****这个函数的作用是初始化滴答时钟数据**
****************相关数据*****************
*****************************************/
void hal_ticks_init(){
  	rTCON = rTCON & (~0xf) ;	/* clear manual update bit, stop Timer0*/
30000864:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30000868:	e2833008 	add	r3, r3, #8
3000086c:	e3a02451 	mov	r2, #1358954496	; 0x51000000
30000870:	e2822008 	add	r2, r2, #8
30000874:	e5922000 	ldr	r2, [r2]
30000878:	e3c2200f 	bic	r2, r2, #15
3000087c:	e5832000 	str	r2, [r3]
    rTCFG0 &= 0xFFFF00;
30000880:	e3a02451 	mov	r2, #1358954496	; 0x51000000
30000884:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30000888:	e5933000 	ldr	r3, [r3]
3000088c:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
30000890:	e3c330ff 	bic	r3, r3, #255	; 0xff
30000894:	e5823000 	str	r3, [r2]
 	rTCFG0 |= 0xF9;				/* prescaler等于249*/
30000898:	e3a03451 	mov	r3, #1358954496	; 0x51000000
3000089c:	e3a02451 	mov	r2, #1358954496	; 0x51000000
300008a0:	e5922000 	ldr	r2, [r2]
300008a4:	e38220f9 	orr	r2, r2, #249	; 0xf9
300008a8:	e5832000 	str	r2, [r3]
 	rTCFG1 &= ~0x0000F;   
300008ac:	e3a03451 	mov	r3, #1358954496	; 0x51000000
300008b0:	e2833004 	add	r3, r3, #4
300008b4:	e3a02451 	mov	r2, #1358954496	; 0x51000000
300008b8:	e2822004 	add	r2, r2, #4
300008bc:	e5922000 	ldr	r2, [r2]
300008c0:	e3c2200f 	bic	r2, r2, #15
300008c4:	e5832000 	str	r2, [r3]
 	rTCFG1 |= 0x2;			   /*divider等于8，则设置定时器4的时钟频率为25kHz*/
300008c8:	e3a03451 	mov	r3, #1358954496	; 0x51000000
300008cc:	e2833004 	add	r3, r3, #4
300008d0:	e3a02451 	mov	r2, #1358954496	; 0x51000000
300008d4:	e2822004 	add	r2, r2, #4
300008d8:	e5922000 	ldr	r2, [r2]
300008dc:	e3822002 	orr	r2, r2, #2
300008e0:	e5832000 	str	r2, [r3]

   	rTCNTB0 = PCLK /(8*(249+1)*ACORAL_TICKS_PER_SEC);
300008e4:	e3a03451 	mov	r3, #1358954496	; 0x51000000
300008e8:	e283300c 	add	r3, r3, #12
300008ec:	e3a020fa 	mov	r2, #250	; 0xfa
300008f0:	e5832000 	str	r2, [r3]
   	rTCON = rTCON & (~0xf) |0x02;              	/* updata*/
300008f4:	e3a03451 	mov	r3, #1358954496	; 0x51000000
300008f8:	e2833008 	add	r3, r3, #8
300008fc:	e3a02451 	mov	r2, #1358954496	; 0x51000000
30000900:	e2822008 	add	r2, r2, #8
30000904:	e5922000 	ldr	r2, [r2]
30000908:	e3c2200f 	bic	r2, r2, #15
3000090c:	e3822002 	orr	r2, r2, #2
30000910:	e5832000 	str	r2, [r3]
	rTCON = rTCON & (~0xf) |0x09; 			/* star*/
30000914:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30000918:	e2833008 	add	r3, r3, #8
3000091c:	e3a02451 	mov	r2, #1358954496	; 0x51000000
30000920:	e2822008 	add	r2, r2, #8
30000924:	e5922000 	ldr	r2, [r2]
30000928:	e3c2200f 	bic	r2, r2, #15
3000092c:	e3822009 	orr	r2, r2, #9
30000930:	e5832000 	str	r2, [r3]
}
30000934:	e12fff1e 	bx	lr

30000938 <hal_ticks_delay>:

acoral_u32 hal_ticks_delay(){
30000938:	e24dd008 	sub	sp, sp, #8
	acoral_u32 initial;
	acoral_u32 current;
	initial=rTCNTB0;
3000093c:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30000940:	e283300c 	add	r3, r3, #12
30000944:	e5933000 	ldr	r3, [r3]
30000948:	e58d3000 	str	r3, [sp]
	current=rTCNTO0;
3000094c:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30000950:	e2833014 	add	r3, r3, #20
30000954:	e5933000 	ldr	r3, [r3]
30000958:	e58d3004 	str	r3, [sp, #4]
	return (initial-current);
3000095c:	e59d2000 	ldr	r2, [sp]
30000960:	e59d3004 	ldr	r3, [sp, #4]
30000964:	e0633002 	rsb	r3, r3, r2
}
30000968:	e1a00003 	mov	r0, r3
3000096c:	e28dd008 	add	sp, sp, #8
30000970:	e12fff1e 	bx	lr

30000974 <hal_mem_init>:
#include"hal_2440_cfg.h"
extern acoral_u32 MMU_base[];
extern acoral_u32 __ENTRY[];
static void hal_mmu_init(void);

void hal_mem_init(){
30000974:	e92d4008 	push	{r3, lr}
  	hal_mmu_init();
30000978:	eb000022 	bl	30000a08 <hal_mmu_init>
}
3000097c:	e8bd4008 	pop	{r3, lr}
30000980:	e12fff1e 	bx	lr

30000984 <flush_cache>:

void flush_cache(){
30000984:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30000988:	e24dd00c 	sub	sp, sp, #12
    acoral_32 i,j;
    MMU_DisableDCache();
3000098c:	eb0002c6 	bl	300014ac <MMU_DisableDCache>
    MMU_DisableICache();
30000990:	eb0002bd 	bl	3000148c <MMU_DisableICache>
    /*If write-back is used,the DCache should be cleared.*/
    for(i=0;i<64;i++)
30000994:	e3a03000 	mov	r3, #0
30000998:	e58d3000 	str	r3, [sp]
3000099c:	ea000012 	b	300009ec <flush_cache+0x68>
    	for(j=0;j<8;j++)
300009a0:	e3a03000 	mov	r3, #0
300009a4:	e58d3004 	str	r3, [sp, #4]
300009a8:	ea000009 	b	300009d4 <flush_cache+0x50>
    	    MMU_CleanInvalidateDCacheIndex((i<<26)|(j<<5));
300009ac:	e59d3000 	ldr	r3, [sp]
300009b0:	e1a02d03 	lsl	r2, r3, #26
300009b4:	e59d3004 	ldr	r3, [sp, #4]
300009b8:	e1a03283 	lsl	r3, r3, #5
300009bc:	e1823003 	orr	r3, r2, r3
300009c0:	e1a00003 	mov	r0, r3
300009c4:	eb0002e2 	bl	30001554 <MMU_CleanInvalidateDCacheIndex>
    acoral_32 i,j;
    MMU_DisableDCache();
    MMU_DisableICache();
    /*If write-back is used,the DCache should be cleared.*/
    for(i=0;i<64;i++)
    	for(j=0;j<8;j++)
300009c8:	e59d3004 	ldr	r3, [sp, #4]
300009cc:	e2833001 	add	r3, r3, #1
300009d0:	e58d3004 	str	r3, [sp, #4]
300009d4:	e59d3004 	ldr	r3, [sp, #4]
300009d8:	e3530007 	cmp	r3, #7
300009dc:	dafffff2 	ble	300009ac <flush_cache+0x28>
void flush_cache(){
    acoral_32 i,j;
    MMU_DisableDCache();
    MMU_DisableICache();
    /*If write-back is used,the DCache should be cleared.*/
    for(i=0;i<64;i++)
300009e0:	e59d3000 	ldr	r3, [sp]
300009e4:	e2833001 	add	r3, r3, #1
300009e8:	e58d3000 	str	r3, [sp]
300009ec:	e59d3000 	ldr	r3, [sp]
300009f0:	e353003f 	cmp	r3, #63	; 0x3f
300009f4:	daffffe9 	ble	300009a0 <flush_cache+0x1c>
    	for(j=0;j<8;j++)
    	    MMU_CleanInvalidateDCacheIndex((i<<26)|(j<<5));
    MMU_InvalidateICache();
300009f8:	eb0002c5 	bl	30001514 <MMU_InvalidateICache>

}
300009fc:	e28dd00c 	add	sp, sp, #12
30000a00:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30000a04:	e12fff1e 	bx	lr

30000a08 <hal_mmu_init>:
static void hal_mmu_init(void)
{
30000a08:	e92d4008 	push	{r3, lr}
    /*The current stack and code area can't be re-mapped in this routine.*/
    /*If you want memory map mapped freely, your own sophiscated MMU*/
    /*initialization code is needed.*/
    /*===================================================================*/

    flush_cache(); 
30000a0c:	ebffffdc 	bl	30000984 <flush_cache>
    MMU_DisableMMU();
30000a10:	eb0002b5 	bl	300014ec <MMU_DisableMMU>
    MMU_InvalidateTLB();
30000a14:	eb0002d2 	bl	30001564 <MMU_InvalidateTLB>
    /*hal_mmu_setmtt(acoral_32 vaddrStart,acoral_32 vaddrEnd,acoral_32 paddrStart,acoral_32 attr)*/
    /*hal_mmu_setmtt(0x00000000,0x07f00000,0x00000000,RW_CNB);  bank0*/
    hal_mmu_setmtt(0x00000000,0x03f00000,(acoral_32)__ENTRY,RW_CB);  /*bank0*/
30000a18:	e59f31d8 	ldr	r3, [pc, #472]	; 30000bf8 <hal_mmu_init+0x1f0>
30000a1c:	e3a00000 	mov	r0, #0
30000a20:	e3a0163f 	mov	r1, #66060288	; 0x3f00000
30000a24:	e1a02003 	mov	r2, r3
30000a28:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000a2c:	e283300e 	add	r3, r3, #14
30000a30:	eb000073 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x04000000,0x07f00000,0,RW_NCNB);  			/*bank0*/
30000a34:	e3a00301 	mov	r0, #67108864	; 0x4000000
30000a38:	e3a0167f 	mov	r1, #133169152	; 0x7f00000
30000a3c:	e3a02000 	mov	r2, #0
30000a40:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000a44:	e2833002 	add	r3, r3, #2
30000a48:	eb00006d 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x08000000,0x0ff00000,0x08000000,RW_CNB);  /*bank1*/
30000a4c:	e3a00302 	mov	r0, #134217728	; 0x8000000
30000a50:	e3a016ff 	mov	r1, #267386880	; 0xff00000
30000a54:	e3a02302 	mov	r2, #134217728	; 0x8000000
30000a58:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000a5c:	e283300a 	add	r3, r3, #10
30000a60:	eb000067 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x10000000,0x17f00000,0x10000000,RW_NCNB); /*bank2*/
30000a64:	e3a00201 	mov	r0, #268435456	; 0x10000000
30000a68:	e3a0155f 	mov	r1, #398458880	; 0x17c00000
30000a6c:	e2811603 	add	r1, r1, #3145728	; 0x300000
30000a70:	e3a02201 	mov	r2, #268435456	; 0x10000000
30000a74:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000a78:	e2833002 	add	r3, r3, #2
30000a7c:	eb000060 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x18000000,0x1ff00000,0x18000000,RW_NCNB); /*bank3*/
30000a80:	e3a00306 	mov	r0, #402653184	; 0x18000000
30000a84:	e3a0157f 	mov	r1, #532676608	; 0x1fc00000
30000a88:	e2811603 	add	r1, r1, #3145728	; 0x300000
30000a8c:	e3a02306 	mov	r2, #402653184	; 0x18000000
30000a90:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000a94:	e2833002 	add	r3, r3, #2
30000a98:	eb000059 	bl	30000c04 <hal_mmu_setmtt>
    /*hal_mmu_setmtt(0x20000000,0x27f00000,0x20000000,RW_CB); bank4*/
    hal_mmu_setmtt(0x20000000,0x27f00000,0x20000000,RW_NCNB); /*bank4 for STRATA Flash*/
30000a9c:	e3a00202 	mov	r0, #536870912	; 0x20000000
30000aa0:	e3a0159f 	mov	r1, #666894336	; 0x27c00000
30000aa4:	e2811603 	add	r1, r1, #3145728	; 0x300000
30000aa8:	e3a02202 	mov	r2, #536870912	; 0x20000000
30000aac:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000ab0:	e2833002 	add	r3, r3, #2
30000ab4:	eb000052 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x28000000,0x2ff00000,0x28000000,RW_NCNB); /*bank5*/
30000ab8:	e3a0030a 	mov	r0, #671088640	; 0x28000000
30000abc:	e3a015bf 	mov	r1, #801112064	; 0x2fc00000
30000ac0:	e2811603 	add	r1, r1, #3145728	; 0x300000
30000ac4:	e3a0230a 	mov	r2, #671088640	; 0x28000000
30000ac8:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000acc:	e2833002 	add	r3, r3, #2
30000ad0:	eb00004b 	bl	30000c04 <hal_mmu_setmtt>
    /*30f00000->30100000, 31000000->30200000*/
    hal_mmu_setmtt(0x30000000,0x30100000,0x30000000,RW_CNB);	  /*bank6-1*/
30000ad4:	e3a00203 	mov	r0, #805306368	; 0x30000000
30000ad8:	e3a01203 	mov	r1, #805306368	; 0x30000000
30000adc:	e2811601 	add	r1, r1, #1048576	; 0x100000
30000ae0:	e3a02203 	mov	r2, #805306368	; 0x30000000
30000ae4:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000ae8:	e283300a 	add	r3, r3, #10
30000aec:	eb000044 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x30200000,0x33e00000,0x30200000,RW_CNB); /*bank6-2*/
30000af0:	e3a00203 	mov	r0, #805306368	; 0x30000000
30000af4:	e2800602 	add	r0, r0, #2097152	; 0x200000
30000af8:	e3a015cf 	mov	r1, #868220928	; 0x33c00000
30000afc:	e2811602 	add	r1, r1, #2097152	; 0x200000
30000b00:	e3a02203 	mov	r2, #805306368	; 0x30000000
30000b04:	e2822602 	add	r2, r2, #2097152	; 0x200000
30000b08:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000b0c:	e283300a 	add	r3, r3, #10
30000b10:	eb00003b 	bl	30000c04 <hal_mmu_setmtt>
    /**/
    hal_mmu_setmtt(0x33f00000,0x33f00000,0x33f00000,RW_NCNB);   /*bank6-3*/
30000b14:	e3a005cf 	mov	r0, #868220928	; 0x33c00000
30000b18:	e2800603 	add	r0, r0, #3145728	; 0x300000
30000b1c:	e3a015cf 	mov	r1, #868220928	; 0x33c00000
30000b20:	e2811603 	add	r1, r1, #3145728	; 0x300000
30000b24:	e3a025cf 	mov	r2, #868220928	; 0x33c00000
30000b28:	e2822603 	add	r2, r2, #3145728	; 0x300000
30000b2c:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000b30:	e2833002 	add	r3, r3, #2
30000b34:	eb000032 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x38000000,0x3ff00000,0x38000000,RW_NCNB); /*bank7*/
30000b38:	e3a0030e 	mov	r0, #939524096	; 0x38000000
30000b3c:	e3a015ff 	mov	r1, #1069547520	; 0x3fc00000
30000b40:	e2811603 	add	r1, r1, #3145728	; 0x300000
30000b44:	e3a0230e 	mov	r2, #939524096	; 0x38000000
30000b48:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000b4c:	e2833002 	add	r3, r3, #2
30000b50:	eb00002b 	bl	30000c04 <hal_mmu_setmtt>

    hal_mmu_setmtt(0x40000000,0x47f00000,0x40000000,RW_NCNB); /*SFR*/
30000b54:	e3a00101 	mov	r0, #1073741824	; 0x40000000
30000b58:	e3a01447 	mov	r1, #1191182336	; 0x47000000
30000b5c:	e281160f 	add	r1, r1, #15728640	; 0xf00000
30000b60:	e3a02101 	mov	r2, #1073741824	; 0x40000000
30000b64:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000b68:	e2833002 	add	r3, r3, #2
30000b6c:	eb000024 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x48000000,0x5af00000,0x48000000,RW_NCNB); /*SFR*/
30000b70:	e3a00312 	mov	r0, #1207959552	; 0x48000000
30000b74:	e3a0145a 	mov	r1, #1509949440	; 0x5a000000
30000b78:	e281160f 	add	r1, r1, #15728640	; 0xf00000
30000b7c:	e3a02312 	mov	r2, #1207959552	; 0x48000000
30000b80:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000b84:	e2833002 	add	r3, r3, #2
30000b88:	eb00001d 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x5b000000,0x5b000000,0x5b000000,RW_NCNB); /*SFR*/
30000b8c:	e3a0045b 	mov	r0, #1526726656	; 0x5b000000
30000b90:	e3a0145b 	mov	r1, #1526726656	; 0x5b000000
30000b94:	e3a0245b 	mov	r2, #1526726656	; 0x5b000000
30000b98:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000b9c:	e2833002 	add	r3, r3, #2
30000ba0:	eb000017 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x5b100000,0xfff00000,0x5b100000,RW_FAULT);/*not used*/
30000ba4:	e3a0045b 	mov	r0, #1526726656	; 0x5b000000
30000ba8:	e2800601 	add	r0, r0, #1048576	; 0x100000
30000bac:	e3a01102 	mov	r1, #-2147483648	; 0x80000000
30000bb0:	e1a015c1 	asr	r1, r1, #11
30000bb4:	e3a0245b 	mov	r2, #1526726656	; 0x5b000000
30000bb8:	e2822601 	add	r2, r2, #1048576	; 0x100000
30000bbc:	e3a03ec3 	mov	r3, #3120	; 0xc30
30000bc0:	e2833002 	add	r3, r3, #2
30000bc4:	eb00000e 	bl	30000c04 <hal_mmu_setmtt>


    MMU_SetTTBase(&MMU_base);
30000bc8:	e59f002c 	ldr	r0, [pc, #44]	; 30000bfc <hal_mmu_init+0x1f4>
30000bcc:	eb00024a 	bl	300014fc <MMU_SetTTBase>
    MMU_SetDomain(0x55555550|DOMAIN1_ATTR|DOMAIN0_ATTR);
30000bd0:	e59f0028 	ldr	r0, [pc, #40]	; 30000c00 <hal_mmu_init+0x1f8>
30000bd4:	eb00024a 	bl	30001504 <MMU_SetDomain>
    	/*DOMAIN1: no_access, DOMAIN0,2~15=client(AP is checked)*/
    MMU_SetProcessId(0x0);
30000bd8:	e3a00000 	mov	r0, #0
30000bdc:	eb000268 	bl	30001584 <MMU_SetProcessId>
    MMU_EnableAlignFault();
30000be0:	eb000235 	bl	300014bc <MMU_EnableAlignFault>
    MMU_EnableMMU();
30000be4:	eb00023c 	bl	300014dc <MMU_EnableMMU>
    MMU_EnableICache();
30000be8:	eb000223 	bl	3000147c <MMU_EnableICache>
    MMU_EnableDCache(); /*DCache should be turned on after MMU is turned on.*/
30000bec:	eb00022a 	bl	3000149c <MMU_EnableDCache>
}
30000bf0:	e8bd4008 	pop	{r3, lr}
30000bf4:	e12fff1e 	bx	lr
30000bf8:	30000000 	.word	0x30000000
30000bfc:	33f00000 	.word	0x33f00000
30000c00:	55555551 	.word	0x55555551

30000c04 <hal_mmu_setmtt>:


void hal_mmu_setmtt(acoral_32 vaddrStart,acoral_32 vaddrEnd,acoral_32 paddrStart,acoral_32 attr)
{
30000c04:	e24dd020 	sub	sp, sp, #32
30000c08:	e58d000c 	str	r0, [sp, #12]
30000c0c:	e58d1008 	str	r1, [sp, #8]
30000c10:	e58d2004 	str	r2, [sp, #4]
30000c14:	e58d3000 	str	r3, [sp]
    volatile acoral_u32 *pTT;
    volatile acoral_32 i,nSec;
    pTT=MMU_base+(vaddrStart>>20);
30000c18:	e59f208c 	ldr	r2, [pc, #140]	; 30000cac <hal_mmu_setmtt+0xa8>
30000c1c:	e59d300c 	ldr	r3, [sp, #12]
30000c20:	e1a03a43 	asr	r3, r3, #20
30000c24:	e1a03103 	lsl	r3, r3, #2
30000c28:	e0823003 	add	r3, r2, r3
30000c2c:	e58d301c 	str	r3, [sp, #28]
    nSec=(vaddrEnd>>20)-(vaddrStart>>20);
30000c30:	e59d3008 	ldr	r3, [sp, #8]
30000c34:	e1a02a43 	asr	r2, r3, #20
30000c38:	e59d300c 	ldr	r3, [sp, #12]
30000c3c:	e1a03a43 	asr	r3, r3, #20
30000c40:	e0633002 	rsb	r3, r3, r2
30000c44:	e58d3014 	str	r3, [sp, #20]
    for(i=0;i<=nSec;i++)*pTT++=attr |(((paddrStart>>20)+i)<<20);
30000c48:	e3a03000 	mov	r3, #0
30000c4c:	e58d3018 	str	r3, [sp, #24]
30000c50:	ea00000f 	b	30000c94 <hal_mmu_setmtt+0x90>
30000c54:	e59d3004 	ldr	r3, [sp, #4]
30000c58:	e1a02a43 	asr	r2, r3, #20
30000c5c:	e59d3018 	ldr	r3, [sp, #24]
30000c60:	e0823003 	add	r3, r2, r3
30000c64:	e1a02a03 	lsl	r2, r3, #20
30000c68:	e59d3000 	ldr	r3, [sp]
30000c6c:	e1823003 	orr	r3, r2, r3
30000c70:	e1a02003 	mov	r2, r3
30000c74:	e59d301c 	ldr	r3, [sp, #28]
30000c78:	e5832000 	str	r2, [r3]
30000c7c:	e59d301c 	ldr	r3, [sp, #28]
30000c80:	e2833004 	add	r3, r3, #4
30000c84:	e58d301c 	str	r3, [sp, #28]
30000c88:	e59d3018 	ldr	r3, [sp, #24]
30000c8c:	e2833001 	add	r3, r3, #1
30000c90:	e58d3018 	str	r3, [sp, #24]
30000c94:	e59d2018 	ldr	r2, [sp, #24]
30000c98:	e59d3014 	ldr	r3, [sp, #20]
30000c9c:	e1520003 	cmp	r2, r3
30000ca0:	daffffeb 	ble	30000c54 <hal_mmu_setmtt+0x50>
}
30000ca4:	e28dd020 	add	sp, sp, #32
30000ca8:	e12fff1e 	bx	lr
30000cac:	33f00000 	.word	0x33f00000

30000cb0 <nand_wait>:

void nand_init(void);
int nand_read(unsigned char *buf, unsigned long start_addr, int size);

static void nand_wait(void)
{
30000cb0:	e24dd008 	sub	sp, sp, #8
  int i;
  while (!(NFSTAT & NFSTAT_BUSY))
30000cb4:	ea000008 	b	30000cdc <nand_wait+0x2c>
   for (i=0; i<10; i++);
30000cb8:	e3a03000 	mov	r3, #0
30000cbc:	e58d3004 	str	r3, [sp, #4]
30000cc0:	ea000002 	b	30000cd0 <nand_wait+0x20>
30000cc4:	e59d3004 	ldr	r3, [sp, #4]
30000cc8:	e2833001 	add	r3, r3, #1
30000ccc:	e58d3004 	str	r3, [sp, #4]
30000cd0:	e59d3004 	ldr	r3, [sp, #4]
30000cd4:	e3530009 	cmp	r3, #9
30000cd8:	dafffff9 	ble	30000cc4 <nand_wait+0x14>
int nand_read(unsigned char *buf, unsigned long start_addr, int size);

static void nand_wait(void)
{
  int i;
  while (!(NFSTAT & NFSTAT_BUSY))
30000cdc:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000ce0:	e2833020 	add	r3, r3, #32
30000ce4:	e5d33000 	ldrb	r3, [r3]
30000ce8:	e20330ff 	and	r3, r3, #255	; 0xff
30000cec:	e2033004 	and	r3, r3, #4
30000cf0:	e3530000 	cmp	r3, #0
30000cf4:	0affffef 	beq	30000cb8 <nand_wait+0x8>
   for (i=0; i<10; i++);
}
30000cf8:	e28dd008 	add	sp, sp, #8
30000cfc:	e12fff1e 	bx	lr

30000d00 <nand_reset>:


static void nand_reset(){
30000d00:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30000d04:	e24dd00c 	sub	sp, sp, #12
   int i;

   nand_select();
30000d08:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000d0c:	e2833004 	add	r3, r3, #4
30000d10:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
30000d14:	e2822004 	add	r2, r2, #4
30000d18:	e5922000 	ldr	r2, [r2]
30000d1c:	e3c22002 	bic	r2, r2, #2
30000d20:	e5832000 	str	r2, [r3]
   NFCMD=NAND_CMD_RESET;
30000d24:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000d28:	e2833008 	add	r3, r3, #8
30000d2c:	e3e02000 	mvn	r2, #0
30000d30:	e5c32000 	strb	r2, [r3]
   for(i=0;i<10;i++);  
30000d34:	e3a03000 	mov	r3, #0
30000d38:	e58d3004 	str	r3, [sp, #4]
30000d3c:	ea000002 	b	30000d4c <nand_reset+0x4c>
30000d40:	e59d3004 	ldr	r3, [sp, #4]
30000d44:	e2833001 	add	r3, r3, #1
30000d48:	e58d3004 	str	r3, [sp, #4]
30000d4c:	e59d3004 	ldr	r3, [sp, #4]
30000d50:	e3530009 	cmp	r3, #9
30000d54:	dafffff9 	ble	30000d40 <nand_reset+0x40>
   nand_wait();  
30000d58:	ebffffd4 	bl	30000cb0 <nand_wait>
   nand_deselect();
30000d5c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000d60:	e2833004 	add	r3, r3, #4
30000d64:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
30000d68:	e2822004 	add	r2, r2, #4
30000d6c:	e5922000 	ldr	r2, [r2]
30000d70:	e3822002 	orr	r2, r2, #2
30000d74:	e5832000 	str	r2, [r3]
}
30000d78:	e28dd00c 	add	sp, sp, #12
30000d7c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30000d80:	e12fff1e 	bx	lr

30000d84 <nand_init>:


void nand_init(void){
30000d84:	e92d4008 	push	{r3, lr}
   

    NFCONF=(7<<12)|(7<<8)|(7<<4)|(0<<0);
30000d88:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
30000d8c:	e3a03c77 	mov	r3, #30464	; 0x7700
30000d90:	e2833070 	add	r3, r3, #112	; 0x70
30000d94:	e5823000 	str	r3, [r2]
    NFCONT=(1<<4)|(0<<1)|(1<<0);
30000d98:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000d9c:	e2833004 	add	r3, r3, #4
30000da0:	e3a02011 	mov	r2, #17
30000da4:	e5832000 	str	r2, [r3]
    
    nand_reset();
30000da8:	ebffffd4 	bl	30000d00 <nand_reset>
}
30000dac:	e8bd4008 	pop	{r3, lr}
30000db0:	e12fff1e 	bx	lr

30000db4 <is_bad_block>:
    int bad_block_offset;
};


static int is_bad_block(struct boot_nand_t * nand, unsigned long i)
{
30000db4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30000db8:	e24dd014 	sub	sp, sp, #20
30000dbc:	e58d0004 	str	r0, [sp, #4]
30000dc0:	e58d1000 	str	r1, [sp]
	unsigned char data;
	unsigned long page_num;

	nand_clear_RnB();
30000dc4:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000dc8:	e2833020 	add	r3, r3, #32
30000dcc:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
30000dd0:	e2822020 	add	r2, r2, #32
30000dd4:	e5d22000 	ldrb	r2, [r2]
30000dd8:	e20220ff 	and	r2, r2, #255	; 0xff
30000ddc:	e3822004 	orr	r2, r2, #4
30000de0:	e20220ff 	and	r2, r2, #255	; 0xff
30000de4:	e5c32000 	strb	r2, [r3]
	if (nand->page_size == 512) {
30000de8:	e59d3004 	ldr	r3, [sp, #4]
30000dec:	e5933000 	ldr	r3, [r3]
30000df0:	e3530c02 	cmp	r3, #512	; 0x200
30000df4:	1a00001d 	bne	30000e70 <is_bad_block+0xbc>
		NFCMD = NAND_CMD_READOOB; /* 0x50 */
30000df8:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000dfc:	e2833008 	add	r3, r3, #8
30000e00:	e3a02050 	mov	r2, #80	; 0x50
30000e04:	e5c32000 	strb	r2, [r3]
		NFADDR = nand->bad_block_offset & 0xf;
30000e08:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000e0c:	e283300c 	add	r3, r3, #12
30000e10:	e59d2004 	ldr	r2, [sp, #4]
30000e14:	e5922008 	ldr	r2, [r2, #8]
30000e18:	e20220ff 	and	r2, r2, #255	; 0xff
30000e1c:	e202200f 	and	r2, r2, #15
30000e20:	e5c32000 	strb	r2, [r3]
		NFADDR = (i >> 9) & 0xff;
30000e24:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000e28:	e283300c 	add	r3, r3, #12
30000e2c:	e59d2000 	ldr	r2, [sp]
30000e30:	e1a024a2 	lsr	r2, r2, #9
30000e34:	e20220ff 	and	r2, r2, #255	; 0xff
30000e38:	e5c32000 	strb	r2, [r3]
		NFADDR = (i >> 17) & 0xff;
30000e3c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000e40:	e283300c 	add	r3, r3, #12
30000e44:	e59d2000 	ldr	r2, [sp]
30000e48:	e1a028a2 	lsr	r2, r2, #17
30000e4c:	e20220ff 	and	r2, r2, #255	; 0xff
30000e50:	e5c32000 	strb	r2, [r3]
		NFADDR = (i >> 25) & 0xff;
30000e54:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000e58:	e283300c 	add	r3, r3, #12
30000e5c:	e59d2000 	ldr	r2, [sp]
30000e60:	e1a02ca2 	lsr	r2, r2, #25
30000e64:	e20220ff 	and	r2, r2, #255	; 0xff
30000e68:	e5c32000 	strb	r2, [r3]
30000e6c:	ea00002f 	b	30000f30 <is_bad_block+0x17c>
	} else if (nand->page_size == 2048) {
30000e70:	e59d3004 	ldr	r3, [sp, #4]
30000e74:	e5933000 	ldr	r3, [r3]
30000e78:	e3530b02 	cmp	r3, #2048	; 0x800
30000e7c:	1a000029 	bne	30000f28 <is_bad_block+0x174>
		page_num = i >> 11; /* addr / 2048 */
30000e80:	e59d3000 	ldr	r3, [sp]
30000e84:	e1a035a3 	lsr	r3, r3, #11
30000e88:	e58d300c 	str	r3, [sp, #12]
		NFCMD = NAND_CMD_READ0;
30000e8c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000e90:	e2833008 	add	r3, r3, #8
30000e94:	e3a02000 	mov	r2, #0
30000e98:	e5c32000 	strb	r2, [r3]
		NFADDR = nand->bad_block_offset & 0xff;
30000e9c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000ea0:	e283300c 	add	r3, r3, #12
30000ea4:	e59d2004 	ldr	r2, [sp, #4]
30000ea8:	e5922008 	ldr	r2, [r2, #8]
30000eac:	e20220ff 	and	r2, r2, #255	; 0xff
30000eb0:	e5c32000 	strb	r2, [r3]
		NFADDR = (nand->bad_block_offset >> 8) & 0xff;
30000eb4:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000eb8:	e283300c 	add	r3, r3, #12
30000ebc:	e59d2004 	ldr	r2, [sp, #4]
30000ec0:	e5922008 	ldr	r2, [r2, #8]
30000ec4:	e1a02442 	asr	r2, r2, #8
30000ec8:	e20220ff 	and	r2, r2, #255	; 0xff
30000ecc:	e5c32000 	strb	r2, [r3]
		NFADDR = page_num & 0xff;
30000ed0:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000ed4:	e283300c 	add	r3, r3, #12
30000ed8:	e59d200c 	ldr	r2, [sp, #12]
30000edc:	e20220ff 	and	r2, r2, #255	; 0xff
30000ee0:	e5c32000 	strb	r2, [r3]
		NFADDR = (page_num >> 8) & 0xff;
30000ee4:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000ee8:	e283300c 	add	r3, r3, #12
30000eec:	e59d200c 	ldr	r2, [sp, #12]
30000ef0:	e1a02422 	lsr	r2, r2, #8
30000ef4:	e20220ff 	and	r2, r2, #255	; 0xff
30000ef8:	e5c32000 	strb	r2, [r3]
		NFADDR = (page_num >> 16) & 0xff;
30000efc:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000f00:	e283300c 	add	r3, r3, #12
30000f04:	e59d200c 	ldr	r2, [sp, #12]
30000f08:	e1a02822 	lsr	r2, r2, #16
30000f0c:	e20220ff 	and	r2, r2, #255	; 0xff
30000f10:	e5c32000 	strb	r2, [r3]
		NFCMD = NAND_CMD_READSTART;
30000f14:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000f18:	e2833008 	add	r3, r3, #8
30000f1c:	e3a02030 	mov	r2, #48	; 0x30
30000f20:	e5c32000 	strb	r2, [r3]
30000f24:	ea000001 	b	30000f30 <is_bad_block+0x17c>
	} else {
		return -1;
30000f28:	e3e03000 	mvn	r3, #0
30000f2c:	ea00000a 	b	30000f5c <is_bad_block+0x1a8>
	}
	nand_wait();
30000f30:	ebffff5e 	bl	30000cb0 <nand_wait>
	data = (NFDATA & 0xff);
30000f34:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000f38:	e2833010 	add	r3, r3, #16
30000f3c:	e5d33000 	ldrb	r3, [r3]
30000f40:	e5cd300b 	strb	r3, [sp, #11]
	if (data != 0xff)
30000f44:	e5dd300b 	ldrb	r3, [sp, #11]
30000f48:	e35300ff 	cmp	r3, #255	; 0xff
30000f4c:	0a000001 	beq	30000f58 <is_bad_block+0x1a4>
		return 1;
30000f50:	e3a03001 	mov	r3, #1
30000f54:	ea000000 	b	30000f5c <is_bad_block+0x1a8>

	return 0;
30000f58:	e3a03000 	mov	r3, #0
}
30000f5c:	e1a00003 	mov	r0, r3
30000f60:	e28dd014 	add	sp, sp, #20
30000f64:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30000f68:	e12fff1e 	bx	lr

30000f6c <nand_read_page>:

static int nand_read_page(struct boot_nand_t * nand, unsigned char *buf, unsigned long addr)
{
30000f6c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30000f70:	e24dd024 	sub	sp, sp, #36	; 0x24
30000f74:	e58d000c 	str	r0, [sp, #12]
30000f78:	e58d1008 	str	r1, [sp, #8]
30000f7c:	e58d2004 	str	r2, [sp, #4]
	unsigned short *ptr16 = (unsigned short *)buf;
30000f80:	e59d3008 	ldr	r3, [sp, #8]
30000f84:	e58d3014 	str	r3, [sp, #20]
	unsigned int i, page_num;

	nand_clear_RnB();
30000f88:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000f8c:	e2833020 	add	r3, r3, #32
30000f90:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
30000f94:	e2822020 	add	r2, r2, #32
30000f98:	e5d22000 	ldrb	r2, [r2]
30000f9c:	e20220ff 	and	r2, r2, #255	; 0xff
30000fa0:	e3822004 	orr	r2, r2, #4
30000fa4:	e20220ff 	and	r2, r2, #255	; 0xff
30000fa8:	e5c32000 	strb	r2, [r3]

	NFCMD = NAND_CMD_READ0;
30000fac:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000fb0:	e2833008 	add	r3, r3, #8
30000fb4:	e3a02000 	mov	r2, #0
30000fb8:	e5c32000 	strb	r2, [r3]

	if (nand->page_size == 512) {
30000fbc:	e59d300c 	ldr	r3, [sp, #12]
30000fc0:	e5933000 	ldr	r3, [r3]
30000fc4:	e3530c02 	cmp	r3, #512	; 0x200
30000fc8:	1a000017 	bne	3000102c <nand_read_page+0xc0>
		/* Write Address */
		NFADDR = addr & 0xff;
30000fcc:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000fd0:	e283300c 	add	r3, r3, #12
30000fd4:	e59d2004 	ldr	r2, [sp, #4]
30000fd8:	e20220ff 	and	r2, r2, #255	; 0xff
30000fdc:	e5c32000 	strb	r2, [r3]
		NFADDR = (addr >> 9) & 0xff;
30000fe0:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000fe4:	e283300c 	add	r3, r3, #12
30000fe8:	e59d2004 	ldr	r2, [sp, #4]
30000fec:	e1a024a2 	lsr	r2, r2, #9
30000ff0:	e20220ff 	and	r2, r2, #255	; 0xff
30000ff4:	e5c32000 	strb	r2, [r3]
		NFADDR = (addr >> 17) & 0xff;
30000ff8:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000ffc:	e283300c 	add	r3, r3, #12
30001000:	e59d2004 	ldr	r2, [sp, #4]
30001004:	e1a028a2 	lsr	r2, r2, #17
30001008:	e20220ff 	and	r2, r2, #255	; 0xff
3000100c:	e5c32000 	strb	r2, [r3]
		NFADDR = (addr >> 25) & 0xff;
30001010:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001014:	e283300c 	add	r3, r3, #12
30001018:	e59d2004 	ldr	r2, [sp, #4]
3000101c:	e1a02ca2 	lsr	r2, r2, #25
30001020:	e20220ff 	and	r2, r2, #255	; 0xff
30001024:	e5c32000 	strb	r2, [r3]
30001028:	ea000026 	b	300010c8 <nand_read_page+0x15c>
	} else if (nand->page_size == 2048) {
3000102c:	e59d300c 	ldr	r3, [sp, #12]
30001030:	e5933000 	ldr	r3, [r3]
30001034:	e3530b02 	cmp	r3, #2048	; 0x800
30001038:	1a000020 	bne	300010c0 <nand_read_page+0x154>
		page_num = addr >> 11; /* addr / 2048 */
3000103c:	e59d3004 	ldr	r3, [sp, #4]
30001040:	e1a035a3 	lsr	r3, r3, #11
30001044:	e58d301c 	str	r3, [sp, #28]
		/* Write Address */
		NFADDR = 0;
30001048:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
3000104c:	e283300c 	add	r3, r3, #12
30001050:	e3a02000 	mov	r2, #0
30001054:	e5c32000 	strb	r2, [r3]
		NFADDR = 0;
30001058:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
3000105c:	e283300c 	add	r3, r3, #12
30001060:	e3a02000 	mov	r2, #0
30001064:	e5c32000 	strb	r2, [r3]
		NFADDR = page_num & 0xff;
30001068:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
3000106c:	e283300c 	add	r3, r3, #12
30001070:	e59d201c 	ldr	r2, [sp, #28]
30001074:	e20220ff 	and	r2, r2, #255	; 0xff
30001078:	e5c32000 	strb	r2, [r3]
		NFADDR = (page_num >> 8) & 0xff;
3000107c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001080:	e283300c 	add	r3, r3, #12
30001084:	e59d201c 	ldr	r2, [sp, #28]
30001088:	e1a02422 	lsr	r2, r2, #8
3000108c:	e20220ff 	and	r2, r2, #255	; 0xff
30001090:	e5c32000 	strb	r2, [r3]
		NFADDR = (page_num >> 16) & 0xff;
30001094:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001098:	e283300c 	add	r3, r3, #12
3000109c:	e59d201c 	ldr	r2, [sp, #28]
300010a0:	e1a02822 	lsr	r2, r2, #16
300010a4:	e20220ff 	and	r2, r2, #255	; 0xff
300010a8:	e5c32000 	strb	r2, [r3]
		NFCMD = NAND_CMD_READSTART;
300010ac:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
300010b0:	e2833008 	add	r3, r3, #8
300010b4:	e3a02030 	mov	r2, #48	; 0x30
300010b8:	e5c32000 	strb	r2, [r3]
300010bc:	ea000001 	b	300010c8 <nand_read_page+0x15c>
	} else {
		return -1;
300010c0:	e3e03000 	mvn	r3, #0
300010c4:	ea000019 	b	30001130 <nand_read_page+0x1c4>
	}
	nand_wait();
300010c8:	ebfffef8 	bl	30000cb0 <nand_wait>
	for (i = 0; i < (nand->page_size>>1); i++) {
300010cc:	e3a03000 	mov	r3, #0
300010d0:	e58d3018 	str	r3, [sp, #24]
300010d4:	ea00000c 	b	3000110c <nand_read_page+0x1a0>
		*ptr16 = NFDATA16;
300010d8:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
300010dc:	e2833010 	add	r3, r3, #16
300010e0:	e1d330b0 	ldrh	r3, [r3]
300010e4:	e1a03803 	lsl	r3, r3, #16
300010e8:	e1a02823 	lsr	r2, r3, #16
300010ec:	e59d3014 	ldr	r3, [sp, #20]
300010f0:	e1c320b0 	strh	r2, [r3]
		ptr16++;
300010f4:	e59d3014 	ldr	r3, [sp, #20]
300010f8:	e2833002 	add	r3, r3, #2
300010fc:	e58d3014 	str	r3, [sp, #20]
		NFCMD = NAND_CMD_READSTART;
	} else {
		return -1;
	}
	nand_wait();
	for (i = 0; i < (nand->page_size>>1); i++) {
30001100:	e59d3018 	ldr	r3, [sp, #24]
30001104:	e2833001 	add	r3, r3, #1
30001108:	e58d3018 	str	r3, [sp, #24]
3000110c:	e59d300c 	ldr	r3, [sp, #12]
30001110:	e5933000 	ldr	r3, [r3]
30001114:	e1a030c3 	asr	r3, r3, #1
30001118:	e1a02003 	mov	r2, r3
3000111c:	e59d3018 	ldr	r3, [sp, #24]
30001120:	e1520003 	cmp	r2, r3
30001124:	8affffeb 	bhi	300010d8 <nand_read_page+0x16c>
		*ptr16 = NFDATA16;
		ptr16++;
	}

	return nand->page_size;
30001128:	e59d300c 	ldr	r3, [sp, #12]
3000112c:	e5933000 	ldr	r3, [r3]
}
30001130:	e1a00003 	mov	r0, r3
30001134:	e28dd024 	add	sp, sp, #36	; 0x24
30001138:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000113c:	e12fff1e 	bx	lr

30001140 <nand_read_id>:


static unsigned short nand_read_id()
{
30001140:	e24dd008 	sub	sp, sp, #8
	unsigned short res = 0;
30001144:	e3a03000 	mov	r3, #0
30001148:	e1cd30b6 	strh	r3, [sp, #6]
	NFCMD = NAND_CMD_READID;
3000114c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001150:	e2833008 	add	r3, r3, #8
30001154:	e3e0206f 	mvn	r2, #111	; 0x6f
30001158:	e5c32000 	strb	r2, [r3]
	NFADDR = 0;
3000115c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001160:	e283300c 	add	r3, r3, #12
30001164:	e3a02000 	mov	r2, #0
30001168:	e5c32000 	strb	r2, [r3]
	res = NFDATA;
3000116c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001170:	e2833010 	add	r3, r3, #16
30001174:	e5d33000 	ldrb	r3, [r3]
30001178:	e20330ff 	and	r3, r3, #255	; 0xff
3000117c:	e1cd30b6 	strh	r3, [sp, #6]
	res = (res << 8) | NFDATA;
30001180:	e1dd30b6 	ldrh	r3, [sp, #6]
30001184:	e1a03403 	lsl	r3, r3, #8
30001188:	e1a03803 	lsl	r3, r3, #16
3000118c:	e1a02823 	lsr	r2, r3, #16
30001190:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001194:	e2833010 	add	r3, r3, #16
30001198:	e5d33000 	ldrb	r3, [r3]
3000119c:	e20330ff 	and	r3, r3, #255	; 0xff
300011a0:	e1823003 	orr	r3, r2, r3
300011a4:	e1a03803 	lsl	r3, r3, #16
300011a8:	e1a03823 	lsr	r3, r3, #16
300011ac:	e1cd30b6 	strh	r3, [sp, #6]
	return res;
300011b0:	e1dd30b6 	ldrh	r3, [sp, #6]
}
300011b4:	e1a00003 	mov	r0, r3
300011b8:	e28dd008 	add	sp, sp, #8
300011bc:	e12fff1e 	bx	lr

300011c0 <nand_read>:



int nand_read(unsigned char *buf, unsigned long start_addr, int size)
{
300011c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300011c4:	e24dd02c 	sub	sp, sp, #44	; 0x2c
300011c8:	e58d000c 	str	r0, [sp, #12]
300011cc:	e58d1008 	str	r1, [sp, #8]
300011d0:	e58d2004 	str	r2, [sp, #4]
	int i, j;
	unsigned short nand_id;
	struct boot_nand_t nand;

	
	nand_select();
300011d4:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
300011d8:	e2833004 	add	r3, r3, #4
300011dc:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
300011e0:	e2822004 	add	r2, r2, #4
300011e4:	e5922000 	ldr	r2, [r2]
300011e8:	e3c22002 	bic	r2, r2, #2
300011ec:	e5832000 	str	r2, [r3]
	nand_clear_RnB();
300011f0:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
300011f4:	e2833020 	add	r3, r3, #32
300011f8:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
300011fc:	e2822020 	add	r2, r2, #32
30001200:	e5d22000 	ldrb	r2, [r2]
30001204:	e20220ff 	and	r2, r2, #255	; 0xff
30001208:	e3822004 	orr	r2, r2, #4
3000120c:	e20220ff 	and	r2, r2, #255	; 0xff
30001210:	e5c32000 	strb	r2, [r3]
	
	for (i = 0; i < 10; i++);
30001214:	e3a03000 	mov	r3, #0
30001218:	e58d301c 	str	r3, [sp, #28]
3000121c:	ea000002 	b	3000122c <nand_read+0x6c>
30001220:	e59d301c 	ldr	r3, [sp, #28]
30001224:	e2833001 	add	r3, r3, #1
30001228:	e58d301c 	str	r3, [sp, #28]
3000122c:	e59d301c 	ldr	r3, [sp, #28]
30001230:	e3530009 	cmp	r3, #9
30001234:	dafffff9 	ble	30001220 <nand_read+0x60>

	nand_id = nand_read_id();	
30001238:	ebffffc0 	bl	30001140 <nand_read_id>
3000123c:	e1a03000 	mov	r3, r0
30001240:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26

       if (nand_id == 0xec76 ||		/* Samsung K91208 */
30001244:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
30001248:	e3a03b3b 	mov	r3, #60416	; 0xec00
3000124c:	e2833076 	add	r3, r3, #118	; 0x76
30001250:	e1520003 	cmp	r2, r3
30001254:	0a000004 	beq	3000126c <nand_read+0xac>
30001258:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
3000125c:	e3a03cad 	mov	r3, #44288	; 0xad00
30001260:	e2833076 	add	r3, r3, #118	; 0x76
30001264:	e1520003 	cmp	r2, r3
30001268:	1a000006 	bne	30001288 <nand_read+0xc8>
           nand_id == 0xad76 ) {	/*Hynix HY27US08121A*/
		nand.page_size = 512;
3000126c:	e3a03c02 	mov	r3, #512	; 0x200
30001270:	e58d3010 	str	r3, [sp, #16]
		nand.block_size = 16 * 1024;
30001274:	e3a03901 	mov	r3, #16384	; 0x4000
30001278:	e58d3014 	str	r3, [sp, #20]
		nand.bad_block_offset = 5;
3000127c:	e3a03005 	mov	r3, #5
30001280:	e58d3018 	str	r3, [sp, #24]
	
	for (i = 0; i < 10; i++);

	nand_id = nand_read_id();	

       if (nand_id == 0xec76 ||		/* Samsung K91208 */
30001284:	ea000017 	b	300012e8 <nand_read+0x128>
           nand_id == 0xad76 ) {	/*Hynix HY27US08121A*/
		nand.page_size = 512;
		nand.block_size = 16 * 1024;
		nand.bad_block_offset = 5;
	} 
        else if (nand_id == 0xecf1 ||	/* Samsung K9F1G08U0B */
30001288:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
3000128c:	e3a03ced 	mov	r3, #60672	; 0xed00
30001290:	e243300f 	sub	r3, r3, #15
30001294:	e1520003 	cmp	r2, r3
30001298:	0a000009 	beq	300012c4 <nand_read+0x104>
3000129c:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
300012a0:	e3a03b3b 	mov	r3, #60416	; 0xec00
300012a4:	e28330da 	add	r3, r3, #218	; 0xda
300012a8:	e1520003 	cmp	r2, r3
300012ac:	0a000004 	beq	300012c4 <nand_read+0x104>
300012b0:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
300012b4:	e3a03ced 	mov	r3, #60672	; 0xed00
300012b8:	e243302d 	sub	r3, r3, #45	; 0x2d
300012bc:	e1520003 	cmp	r2, r3
300012c0:	1a000006 	bne	300012e0 <nand_read+0x120>
		   nand_id == 0xecda ||	/* Samsung K9F2G08U0B */
		   nand_id == 0xecd3 )	{ /* Samsung K9K8G08 */
		nand.page_size = 2048;
300012c4:	e3a03b02 	mov	r3, #2048	; 0x800
300012c8:	e58d3010 	str	r3, [sp, #16]
		nand.block_size = 128 * 1024;
300012cc:	e3a03802 	mov	r3, #131072	; 0x20000
300012d0:	e58d3014 	str	r3, [sp, #20]
		nand.bad_block_offset = nand.page_size;
300012d4:	e59d3010 	ldr	r3, [sp, #16]
300012d8:	e58d3018 	str	r3, [sp, #24]
           nand_id == 0xad76 ) {	/*Hynix HY27US08121A*/
		nand.page_size = 512;
		nand.block_size = 16 * 1024;
		nand.bad_block_offset = 5;
	} 
        else if (nand_id == 0xecf1 ||	/* Samsung K9F1G08U0B */
300012dc:	ea000001 	b	300012e8 <nand_read+0x128>
		nand.page_size = 2048;
		nand.block_size = 128 * 1024;
		nand.bad_block_offset = nand.page_size;
	} 
        else {
		return -1; 
300012e0:	e3e03000 	mvn	r3, #0
300012e4:	ea000060 	b	3000146c <nand_read+0x2ac>
	}

         if ((start_addr & (nand.block_size-1)))
300012e8:	e59d3014 	ldr	r3, [sp, #20]
300012ec:	e2433001 	sub	r3, r3, #1
300012f0:	e1a02003 	mov	r2, r3
300012f4:	e59d3008 	ldr	r3, [sp, #8]
300012f8:	e0023003 	and	r3, r2, r3
300012fc:	e3530000 	cmp	r3, #0
30001300:	0a000001 	beq	3000130c <nand_read+0x14c>
		return -1;	
30001304:	e3e03000 	mvn	r3, #0
30001308:	ea000057 	b	3000146c <nand_read+0x2ac>
        
        if(size & (nand.page_size-1)){
3000130c:	e59d3010 	ldr	r3, [sp, #16]
30001310:	e2432001 	sub	r2, r3, #1
30001314:	e59d3004 	ldr	r3, [sp, #4]
30001318:	e0023003 	and	r3, r2, r3
3000131c:	e3530000 	cmp	r3, #0
30001320:	0a000007 	beq	30001344 <nand_read+0x184>
             size=(size+nand.page_size-1) & (~(nand.page_size-1));
30001324:	e59d2010 	ldr	r2, [sp, #16]
30001328:	e59d3004 	ldr	r3, [sp, #4]
3000132c:	e0823003 	add	r3, r2, r3
30001330:	e2432001 	sub	r2, r3, #1
30001334:	e59d3010 	ldr	r3, [sp, #16]
30001338:	e2633000 	rsb	r3, r3, #0
3000133c:	e0023003 	and	r3, r2, r3
30001340:	e58d3004 	str	r3, [sp, #4]
        }

        if ((size & (nand.page_size-1)))
30001344:	e59d3010 	ldr	r3, [sp, #16]
30001348:	e2432001 	sub	r2, r3, #1
3000134c:	e59d3004 	ldr	r3, [sp, #4]
30001350:	e0023003 	and	r3, r2, r3
30001354:	e3530000 	cmp	r3, #0
30001358:	0a000001 	beq	30001364 <nand_read+0x1a4>
		return -1;
3000135c:	e3e03000 	mvn	r3, #0
30001360:	ea000041 	b	3000146c <nand_read+0x2ac>

	for (i=start_addr; i < (start_addr + size);) {
30001364:	e59d3008 	ldr	r3, [sp, #8]
30001368:	e58d301c 	str	r3, [sp, #28]
3000136c:	ea000030 	b	30001434 <nand_read+0x274>

		if ((i & (nand.block_size-1))== 0) {
30001370:	e59d3014 	ldr	r3, [sp, #20]
30001374:	e2432001 	sub	r2, r3, #1
30001378:	e59d301c 	ldr	r3, [sp, #28]
3000137c:	e0023003 	and	r3, r2, r3
30001380:	e3530000 	cmp	r3, #0
30001384:	1a00001a 	bne	300013f4 <nand_read+0x234>
			if (is_bad_block(&nand, i) || is_bad_block(&nand, i + nand.page_size)) {
30001388:	e59d301c 	ldr	r3, [sp, #28]
3000138c:	e28d2010 	add	r2, sp, #16
30001390:	e1a00002 	mov	r0, r2
30001394:	e1a01003 	mov	r1, r3
30001398:	ebfffe85 	bl	30000db4 <is_bad_block>
3000139c:	e1a03000 	mov	r3, r0
300013a0:	e3530000 	cmp	r3, #0
300013a4:	1a000009 	bne	300013d0 <nand_read+0x210>
300013a8:	e59d2010 	ldr	r2, [sp, #16]
300013ac:	e59d301c 	ldr	r3, [sp, #28]
300013b0:	e0823003 	add	r3, r2, r3
300013b4:	e28d2010 	add	r2, sp, #16
300013b8:	e1a00002 	mov	r0, r2
300013bc:	e1a01003 	mov	r1, r3
300013c0:	ebfffe7b 	bl	30000db4 <is_bad_block>
300013c4:	e1a03000 	mov	r3, r0
300013c8:	e3530000 	cmp	r3, #0
300013cc:	0a000008 	beq	300013f4 <nand_read+0x234>
				i += nand.block_size;
300013d0:	e59d3014 	ldr	r3, [sp, #20]
300013d4:	e59d201c 	ldr	r2, [sp, #28]
300013d8:	e0823003 	add	r3, r2, r3
300013dc:	e58d301c 	str	r3, [sp, #28]
				size += nand.block_size;
300013e0:	e59d3014 	ldr	r3, [sp, #20]
300013e4:	e59d2004 	ldr	r2, [sp, #4]
300013e8:	e0823003 	add	r3, r2, r3
300013ec:	e58d3004 	str	r3, [sp, #4]
				continue;
300013f0:	ea00000f 	b	30001434 <nand_read+0x274>
			}
		}

		j = nand_read_page(&nand, buf, i);
300013f4:	e59d301c 	ldr	r3, [sp, #28]
300013f8:	e28d2010 	add	r2, sp, #16
300013fc:	e1a00002 	mov	r0, r2
30001400:	e59d100c 	ldr	r1, [sp, #12]
30001404:	e1a02003 	mov	r2, r3
30001408:	ebfffed7 	bl	30000f6c <nand_read_page>
3000140c:	e1a03000 	mov	r3, r0
30001410:	e58d3020 	str	r3, [sp, #32]
		i += j;
30001414:	e59d201c 	ldr	r2, [sp, #28]
30001418:	e59d3020 	ldr	r3, [sp, #32]
3000141c:	e0823003 	add	r3, r2, r3
30001420:	e58d301c 	str	r3, [sp, #28]
		buf += j;
30001424:	e59d3020 	ldr	r3, [sp, #32]
30001428:	e59d200c 	ldr	r2, [sp, #12]
3000142c:	e0823003 	add	r3, r2, r3
30001430:	e58d300c 	str	r3, [sp, #12]
        }

        if ((size & (nand.page_size-1)))
		return -1;

	for (i=start_addr; i < (start_addr + size);) {
30001434:	e59d201c 	ldr	r2, [sp, #28]
30001438:	e59d1004 	ldr	r1, [sp, #4]
3000143c:	e59d3008 	ldr	r3, [sp, #8]
30001440:	e0813003 	add	r3, r1, r3
30001444:	e1520003 	cmp	r2, r3
30001448:	3affffc8 	bcc	30001370 <nand_read+0x1b0>
		i += j;
		buf += j;
	}


	nand_deselect();
3000144c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001450:	e2833004 	add	r3, r3, #4
30001454:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
30001458:	e2822004 	add	r2, r2, #4
3000145c:	e5922000 	ldr	r2, [r2]
30001460:	e3822002 	orr	r2, r2, #2
30001464:	e5832000 	str	r2, [r3]

	return 0;
30001468:	e3a03000 	mov	r3, #0
}
3000146c:	e1a00003 	mov	r0, r3
30001470:	e28dd02c 	add	sp, sp, #44	; 0x2c
30001474:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001478:	e12fff1e 	bx	lr

3000147c <MMU_EnableICache>:
3000147c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
30001480:	e3800a01 	orr	r0, r0, #4096	; 0x1000
30001484:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
30001488:	e1a0f00e 	mov	pc, lr

3000148c <MMU_DisableICache>:
3000148c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
30001490:	e3c00a01 	bic	r0, r0, #4096	; 0x1000
30001494:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
30001498:	e1a0f00e 	mov	pc, lr

3000149c <MMU_EnableDCache>:
3000149c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
300014a0:	e3800004 	orr	r0, r0, #4
300014a4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
300014a8:	e1a0f00e 	mov	pc, lr

300014ac <MMU_DisableDCache>:
300014ac:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
300014b0:	e3c00004 	bic	r0, r0, #4
300014b4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
300014b8:	e1a0f00e 	mov	pc, lr

300014bc <MMU_EnableAlignFault>:
300014bc:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
300014c0:	e3800002 	orr	r0, r0, #2
300014c4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
300014c8:	e1a0f00e 	mov	pc, lr

300014cc <MMU_DisableAlignFault>:
300014cc:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
300014d0:	e3c00002 	bic	r0, r0, #2
300014d4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
300014d8:	e1a0f00e 	mov	pc, lr

300014dc <MMU_EnableMMU>:
300014dc:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
300014e0:	e3800001 	orr	r0, r0, #1
300014e4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
300014e8:	e1a0f00e 	mov	pc, lr

300014ec <MMU_DisableMMU>:
300014ec:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
300014f0:	e3c00001 	bic	r0, r0, #1
300014f4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
300014f8:	e1a0f00e 	mov	pc, lr

300014fc <MMU_SetTTBase>:
300014fc:	ee020f10 	mcr	15, 0, r0, cr2, cr0, {0}
30001500:	e1a0f00e 	mov	pc, lr

30001504 <MMU_SetDomain>:
30001504:	ee030f10 	mcr	15, 0, r0, cr3, cr0, {0}
30001508:	e1a0f00e 	mov	pc, lr

3000150c <MMU_InvalidateIDCache>:
3000150c:	ee070f17 	mcr	15, 0, r0, cr7, cr7, {0}
30001510:	e1a0f00e 	mov	pc, lr

30001514 <MMU_InvalidateICache>:
30001514:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
30001518:	e1a0f00e 	mov	pc, lr

3000151c <MMU_InvalidateICacheMVA>:
3000151c:	ee070f35 	mcr	15, 0, r0, cr7, cr5, {1}
30001520:	e1a0f00e 	mov	pc, lr

30001524 <MMU_PrefetchICacheMVA>:
30001524:	ee070f3d 	mcr	15, 0, r0, cr7, cr13, {1}
30001528:	e1a0f00e 	mov	pc, lr

3000152c <MMU_InvalidateDCache>:
3000152c:	ee070f16 	mcr	15, 0, r0, cr7, cr6, {0}
30001530:	e1a0f00e 	mov	pc, lr

30001534 <MMU_InvalidateDCacheMVA>:
30001534:	ee070f36 	mcr	15, 0, r0, cr7, cr6, {1}
30001538:	e1a0f00e 	mov	pc, lr

3000153c <MMU_CleanDCacheMVA>:
3000153c:	ee070f3a 	mcr	15, 0, r0, cr7, cr10, {1}
30001540:	e1a0f00e 	mov	pc, lr

30001544 <MMU_CleanInvalidateDCacheMVA>:
30001544:	ee070f3e 	mcr	15, 0, r0, cr7, cr14, {1}
30001548:	e1a0f00e 	mov	pc, lr

3000154c <MMU_CleanDCacheIndex>:
3000154c:	ee070f5a 	mcr	15, 0, r0, cr7, cr10, {2}
30001550:	e1a0f00e 	mov	pc, lr

30001554 <MMU_CleanInvalidateDCacheIndex>:
30001554:	ee070f5e 	mcr	15, 0, r0, cr7, cr14, {2}
30001558:	e1a0f00e 	mov	pc, lr

3000155c <MMU_WaitForInterrupt>:
3000155c:	ee070f90 	mcr	15, 0, r0, cr7, cr0, {4}
30001560:	e1a0f00e 	mov	pc, lr

30001564 <MMU_InvalidateTLB>:
30001564:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
30001568:	e1a0f00e 	mov	pc, lr

3000156c <MMU_InvalidateITLB>:
3000156c:	ee080f15 	mcr	15, 0, r0, cr8, cr5, {0}
30001570:	e1a0f00e 	mov	pc, lr

30001574 <MMU_InvalidateITLBMVA>:
30001574:	ee080f35 	mcr	15, 0, r0, cr8, cr5, {1}
30001578:	e1a0f00e 	mov	pc, lr

3000157c <MMU_InvalidateDTLB>:
3000157c:	ee080f16 	mcr	15, 0, r0, cr8, cr6, {0}
30001580:	e1a0f00e 	mov	pc, lr

30001584 <MMU_SetProcessId>:
30001584:	ee0d0f10 	mcr	15, 0, r0, cr13, cr0, {0}
30001588:	e1a0f00e 	mov	pc, lr

3000158c <HAL_SWITCH_TO>:
3000158c:	e590d000 	ldr	sp, [r0]
30001590:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
30001594:	e129f000 	msr	CPSR_fc, r0
30001598:	e8bddfff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}

3000159c <HAL_INTR_SWITCH_TO>:
3000159c:	e92d5ffe 	push	{r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
300015a0:	e59f20c0 	ldr	r2, [pc, #192]	; 30001668 <HAL_CONTEXT_SWITCH+0x24>
300015a4:	e242203c 	sub	r2, r2, #60	; 0x3c
300015a8:	e590c000 	ldr	ip, [r0]
300015ac:	e8bc0ff8 	ldm	ip!, {r3, r4, r5, r6, r7, r8, r9, sl, fp}
300015b0:	e8a20ff8 	stmia	r2!, {r3, r4, r5, r6, r7, r8, r9, sl, fp}
300015b4:	e8bc00f8 	ldm	ip!, {r3, r4, r5, r6, r7}
300015b8:	e8a200f8 	stmia	r2!, {r3, r4, r5, r6, r7}
300015bc:	e8fc4000 	ldm	ip!, {lr}^
300015c0:	e8bc0008 	ldm	ip!, {r3}
300015c4:	e2833004 	add	r3, r3, #4
300015c8:	e8a20008 	stmia	r2!, {r3}
300015cc:	e92c1000 	stmdb	ip!, {ip}
300015d0:	e8fc2000 	ldm	ip!, {sp}^
300015d4:	e1a00000 	nop			; (mov r0, r0)
300015d8:	e8bd9ffe 	pop	{r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}

300015dc <HAL_INTR_CTX_SWITCH>:
300015dc:	e92d5ffc 	push	{r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
300015e0:	e59f2080 	ldr	r2, [pc, #128]	; 30001668 <HAL_CONTEXT_SWITCH+0x24>
300015e4:	e93207f8 	ldmdb	r2!, {r3, r4, r5, r6, r7, r8, r9, sl}
300015e8:	e24aa004 	sub	sl, sl, #4
300015ec:	e1a0b00d 	mov	fp, sp
300015f0:	e96b2000 	stmdb	fp!, {sp}^
300015f4:	e8bb1000 	ldm	fp!, {ip}
300015f8:	e92c0400 	stmdb	ip!, {sl}
300015fc:	e96c4000 	stmdb	ip!, {lr}^
30001600:	e92c03f8 	stmdb	ip!, {r3, r4, r5, r6, r7, r8, r9}
30001604:	e93203f8 	ldmdb	r2!, {r3, r4, r5, r6, r7, r8, r9}
30001608:	e92c03f8 	stmdb	ip!, {r3, r4, r5, r6, r7, r8, r9}
3000160c:	e580c000 	str	ip, [r0]
30001610:	e591c000 	ldr	ip, [r1]
30001614:	e8bc0ff8 	ldm	ip!, {r3, r4, r5, r6, r7, r8, r9, sl, fp}
30001618:	e8a20ff8 	stmia	r2!, {r3, r4, r5, r6, r7, r8, r9, sl, fp}
3000161c:	e8bc00f8 	ldm	ip!, {r3, r4, r5, r6, r7}
30001620:	e8a200f8 	stmia	r2!, {r3, r4, r5, r6, r7}
30001624:	e8fc4000 	ldm	ip!, {lr}^
30001628:	e8bc0008 	ldm	ip!, {r3}
3000162c:	e2833004 	add	r3, r3, #4
30001630:	e8a20008 	stmia	r2!, {r3}
30001634:	e92c1000 	stmdb	ip!, {ip}
30001638:	e8fc2000 	ldm	ip!, {sp}^
3000163c:	e1a00000 	nop			; (mov r0, r0)
30001640:	e8bd9ffc 	pop	{r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}

30001644 <HAL_CONTEXT_SWITCH>:
30001644:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001648:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
3000164c:	e10f4000 	mrs	r4, CPSR
30001650:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
30001654:	e580d000 	str	sp, [r0]
30001658:	e591d000 	ldr	sp, [r1]
3000165c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
30001660:	e129f000 	msr	CPSR_fc, r0
30001664:	e8bddfff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
30001668:	33ffff00 	.word	0x33ffff00

3000166c <HAL_INTR_ENTRY>:
3000166c:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
30001670:	e14f1000 	mrs	r1, SPSR
30001674:	e52d1004 	push	{r1}		; (str r1, [sp, #-4]!)
30001678:	e321f093 	msr	CPSR_c, #147	; 0x93
3000167c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001680:	e59f008c 	ldr	r0, [pc, #140]	; 30001714 <HAL_INTR_DISABLE_SAVE+0x20>
30001684:	e5900000 	ldr	r0, [r0]
30001688:	e1a0e00f 	mov	lr, pc
3000168c:	e59ff084 	ldr	pc, [pc, #132]	; 30001718 <HAL_INTR_DISABLE_SAVE+0x24>
30001690:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001694:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
30001698:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
3000169c:	e16ff000 	msr	SPSR_fsxc, r0
300016a0:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
300016a4:	e25ef004 	subs	pc, lr, #4

300016a8 <EXP_HANDLER>:
300016a8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300016ac:	e1a0000d 	mov	r0, sp
300016b0:	e9602000 	stmdb	r0!, {sp}^
300016b4:	e8b00002 	ldm	r0!, {r1}
300016b8:	e1a0000e 	mov	r0, lr
300016bc:	eb000b3d 	bl	300043b8 <acoral_fault_entry>
300016c0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300016c4:	e25ef000 	subs	pc, lr, #0

300016c8 <HAL_INTR_ENABLE>:
300016c8:	e10f0000 	mrs	r0, CPSR
300016cc:	e3c000c0 	bic	r0, r0, #192	; 0xc0
300016d0:	e12ff000 	msr	CPSR_fsxc, r0
300016d4:	e1a0f00e 	mov	pc, lr

300016d8 <HAL_INTR_DISABLE>:
300016d8:	e10f0000 	mrs	r0, CPSR
300016dc:	e1a01000 	mov	r1, r0
300016e0:	e38110c0 	orr	r1, r1, #192	; 0xc0
300016e4:	e12ff001 	msr	CPSR_fsxc, r1
300016e8:	e1a0f00e 	mov	pc, lr

300016ec <HAL_INTR_RESTORE>:
300016ec:	e121f000 	msr	CPSR_c, r0
300016f0:	e1a0f00e 	mov	pc, lr

300016f4 <HAL_INTR_DISABLE_SAVE>:
300016f4:	e10f0000 	mrs	r0, CPSR
300016f8:	e38010c0 	orr	r1, r0, #192	; 0xc0
300016fc:	e121f001 	msr	CPSR_c, r1
30001700:	e10f1000 	mrs	r1, CPSR
30001704:	e20110c0 	and	r1, r1, #192	; 0xc0
30001708:	e35100c0 	cmp	r1, #192	; 0xc0
3000170c:	1afffff8 	bne	300016f4 <HAL_INTR_DISABLE_SAVE>
30001710:	e1a0f00e 	mov	pc, lr
30001714:	4a000014 	.word	0x4a000014
30001718:	300003cc 	.word	0x300003cc

3000171c <hal_intr_nesting_init_comm>:
acoral_u32 intr_nesting[HAL_MAX_CPU];
/*===========================                                                                                                                 
*initialize the nesting      
*中断嵌套初始化
*===========================*/
void hal_intr_nesting_init_comm(){
3000171c:	e24dd008 	sub	sp, sp, #8
	acoral_u32 i;
	for(i=0;i<HAL_MAX_CPU;i++)
30001720:	e3a03000 	mov	r3, #0
30001724:	e58d3004 	str	r3, [sp, #4]
30001728:	ea000006 	b	30001748 <hal_intr_nesting_init_comm+0x2c>
	  	intr_nesting[i]=0;
3000172c:	e59d2004 	ldr	r2, [sp, #4]
30001730:	e59f3024 	ldr	r3, [pc, #36]	; 3000175c <hal_intr_nesting_init_comm+0x40>
30001734:	e3a01000 	mov	r1, #0
30001738:	e7831102 	str	r1, [r3, r2, lsl #2]
*initialize the nesting      
*中断嵌套初始化
*===========================*/
void hal_intr_nesting_init_comm(){
	acoral_u32 i;
	for(i=0;i<HAL_MAX_CPU;i++)
3000173c:	e59d3004 	ldr	r3, [sp, #4]
30001740:	e2833001 	add	r3, r3, #1
30001744:	e58d3004 	str	r3, [sp, #4]
30001748:	e59d3004 	ldr	r3, [sp, #4]
3000174c:	e3530000 	cmp	r3, #0
30001750:	0afffff5 	beq	3000172c <hal_intr_nesting_init_comm+0x10>
	  	intr_nesting[i]=0;
}
30001754:	e28dd008 	add	sp, sp, #8
30001758:	e12fff1e 	bx	lr
3000175c:	3002b348 	.word	0x3002b348

30001760 <hal_get_intr_nesting_comm>:
/*===========================                                                                                                                 
*Get the nesting      
*获取当前CPU的中断嵌套数
*===========================*/
acoral_u32 hal_get_intr_nesting_comm(){
    return intr_nesting[acoral_current_cpu];
30001760:	e59f3008 	ldr	r3, [pc, #8]	; 30001770 <hal_get_intr_nesting_comm+0x10>
30001764:	e5933000 	ldr	r3, [r3]
}
30001768:	e1a00003 	mov	r0, r3
3000176c:	e12fff1e 	bx	lr
30001770:	3002b348 	.word	0x3002b348

30001774 <hal_intr_nesting_dec_comm>:

/*===========================                                                                                                                 
*Decrise the nesting      
*减少当前CPU中断嵌套数
*===========================*/
void hal_intr_nesting_dec_comm(){
30001774:	e24dd008 	sub	sp, sp, #8
    acoral_u8 cpu;
    cpu=acoral_current_cpu;
30001778:	e3a03000 	mov	r3, #0
3000177c:	e5cd3007 	strb	r3, [sp, #7]
    if(intr_nesting[cpu]>0)
30001780:	e5dd2007 	ldrb	r2, [sp, #7]
30001784:	e59f3028 	ldr	r3, [pc, #40]	; 300017b4 <hal_intr_nesting_dec_comm+0x40>
30001788:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3000178c:	e3530000 	cmp	r3, #0
30001790:	0a000005 	beq	300017ac <hal_intr_nesting_dec_comm+0x38>
	intr_nesting[cpu]--;
30001794:	e5dd3007 	ldrb	r3, [sp, #7]
30001798:	e59f2014 	ldr	r2, [pc, #20]	; 300017b4 <hal_intr_nesting_dec_comm+0x40>
3000179c:	e7922103 	ldr	r2, [r2, r3, lsl #2]
300017a0:	e2421001 	sub	r1, r2, #1
300017a4:	e59f2008 	ldr	r2, [pc, #8]	; 300017b4 <hal_intr_nesting_dec_comm+0x40>
300017a8:	e7821103 	str	r1, [r2, r3, lsl #2]
}
300017ac:	e28dd008 	add	sp, sp, #8
300017b0:	e12fff1e 	bx	lr
300017b4:	3002b348 	.word	0x3002b348

300017b8 <hal_intr_nesting_inc_comm>:
/*===========================                                                                                                                 
*Incrise the nesting        
*增加中断嵌套数
*===========================*/
void hal_intr_nesting_inc_comm(){
    intr_nesting[acoral_current_cpu]++;
300017b8:	e59f3010 	ldr	r3, [pc, #16]	; 300017d0 <hal_intr_nesting_inc_comm+0x18>
300017bc:	e5933000 	ldr	r3, [r3]
300017c0:	e2832001 	add	r2, r3, #1
300017c4:	e59f3004 	ldr	r3, [pc, #4]	; 300017d0 <hal_intr_nesting_inc_comm+0x18>
300017c8:	e5832000 	str	r2, [r3]
}
300017cc:	e12fff1e 	bx	lr
300017d0:	3002b348 	.word	0x3002b348

300017d4 <hal_sched_bridge_comm>:

void hal_sched_bridge_comm(){
300017d4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300017d8:	e24dd00c 	sub	sp, sp, #12
  	acoral_sr cpu_sr;
	HAL_ENTER_CRITICAL();
300017dc:	ebffffc4 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300017e0:	e1a03000 	mov	r3, r0
300017e4:	e58d3004 	str	r3, [sp, #4]
	acoral_real_sched();
300017e8:	eb000328 	bl	30002490 <acoral_real_sched>
	HAL_EXIT_CRITICAL();
300017ec:	e59d0004 	ldr	r0, [sp, #4]
300017f0:	ebffffbd 	bl	300016ec <HAL_INTR_RESTORE>
}
300017f4:	e28dd00c 	add	sp, sp, #12
300017f8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300017fc:	e12fff1e 	bx	lr

30001800 <hal_intr_exit_bridge_comm>:

void hal_intr_exit_bridge_comm(){
30001800:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001804:	e24dd00c 	sub	sp, sp, #12
  	acoral_sr cpu_sr;
	HAL_ENTER_CRITICAL();
30001808:	ebffffb9 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000180c:	e1a03000 	mov	r3, r0
30001810:	e58d3004 	str	r3, [sp, #4]
	acoral_real_intr_sched();
30001814:	eb000348 	bl	3000253c <acoral_real_intr_sched>
	HAL_EXIT_CRITICAL();
30001818:	e59d0004 	ldr	r0, [sp, #4]
3000181c:	ebffffb2 	bl	300016ec <HAL_INTR_RESTORE>
}
30001820:	e28dd00c 	add	sp, sp, #12
30001824:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001828:	e12fff1e 	bx	lr

3000182c <hal_atomic_add_comm>:

void hal_atomic_add_comm(int i, acoral_atomic_t *v)
{
3000182c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001830:	e24dd014 	sub	sp, sp, #20
30001834:	e58d0004 	str	r0, [sp, #4]
30001838:	e58d1000 	str	r1, [sp]
		acoral_sr sr;
		sr=HAL_INTR_DISABLE_SAVE();
3000183c:	ebffffac 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30001840:	e1a03000 	mov	r3, r0
30001844:	e58d300c 	str	r3, [sp, #12]
		v->val=v->val+i;
30001848:	e59d3000 	ldr	r3, [sp]
3000184c:	e5932000 	ldr	r2, [r3]
30001850:	e59d3004 	ldr	r3, [sp, #4]
30001854:	e0822003 	add	r2, r2, r3
30001858:	e59d3000 	ldr	r3, [sp]
3000185c:	e5832000 	str	r2, [r3]
		HAL_INTR_RESTORE(sr);
30001860:	e59d000c 	ldr	r0, [sp, #12]
30001864:	ebffffa0 	bl	300016ec <HAL_INTR_RESTORE>
}
30001868:	e28dd014 	add	sp, sp, #20
3000186c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001870:	e12fff1e 	bx	lr

30001874 <hal_atomic_sub_comm>:

void hal_atomic_sub_comm(int i, acoral_atomic_t *v)
{
30001874:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001878:	e24dd014 	sub	sp, sp, #20
3000187c:	e58d0004 	str	r0, [sp, #4]
30001880:	e58d1000 	str	r1, [sp]
	acoral_sr sr;
	sr=HAL_INTR_DISABLE_SAVE();
30001884:	ebffff9a 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30001888:	e1a03000 	mov	r3, r0
3000188c:	e58d300c 	str	r3, [sp, #12]
	v->val=v->val-i;
30001890:	e59d3000 	ldr	r3, [sp]
30001894:	e5932000 	ldr	r2, [r3]
30001898:	e59d3004 	ldr	r3, [sp, #4]
3000189c:	e0632002 	rsb	r2, r3, r2
300018a0:	e59d3000 	ldr	r3, [sp]
300018a4:	e5832000 	str	r2, [r3]
	HAL_INTR_RESTORE(sr);
300018a8:	e59d000c 	ldr	r0, [sp, #12]
300018ac:	ebffff8e 	bl	300016ec <HAL_INTR_RESTORE>
}
300018b0:	e28dd014 	add	sp, sp, #20
300018b4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300018b8:	e12fff1e 	bx	lr

300018bc <idle>:
extern volatile acoral_u32 idle_count[HAL_MAX_CPU];
/*================================
 *      idle thread
 *       空闲进程
 *================================*/
void idle(void *args){
300018bc:	e24dd008 	sub	sp, sp, #8
300018c0:	e58d0004 	str	r0, [sp, #4]
	while(1){
#ifdef CFG_STAT
		idle_count[acoral_current_cpu]++;
#endif
	}
300018c4:	eafffffe 	b	300018c4 <idle+0x8>

300018c8 <daem>:

/*================================
 *      resouce collection function
 *           资源回收函数
 *================================*/
void daem(void *args){
300018c8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300018cc:	e24dd024 	sub	sp, sp, #36	; 0x24
300018d0:	e58d0004 	str	r0, [sp, #4]
	acoral_sr cpu_sr;
	acoral_thread_t * thread;
	acoral_list_t *head,*tmp,*tmp1;
	head=&acoral_res_release_queue.head;
300018d4:	e59f30b8 	ldr	r3, [pc, #184]	; 30001994 <daem+0xcc>
300018d8:	e58d3014 	str	r3, [sp, #20]
	while(1){
		for(tmp=head->next;tmp!=head;){
300018dc:	e59d3014 	ldr	r3, [sp, #20]
300018e0:	e5933000 	ldr	r3, [r3]
300018e4:	e58d3018 	str	r3, [sp, #24]
300018e8:	ea000023 	b	3000197c <daem+0xb4>
			tmp1=tmp->next;
300018ec:	e59d3018 	ldr	r3, [sp, #24]
300018f0:	e5933000 	ldr	r3, [r3]
300018f4:	e58d301c 	str	r3, [sp, #28]
			HAL_ENTER_CRITICAL();
300018f8:	ebffff7d 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300018fc:	e1a03000 	mov	r3, r0
30001900:	e58d300c 	str	r3, [sp, #12]
			thread=list_entry(tmp,acoral_thread_t,waiting);
30001904:	e59d3018 	ldr	r3, [sp, #24]
30001908:	e2433020 	sub	r3, r3, #32
3000190c:	e58d3010 	str	r3, [sp, #16]
			/*如果线程资源已经不在使用，即release状态则释放*/
			acoral_spin_lock(&head->lock);/**/
			acoral_spin_lock(&tmp->lock);/**/
			acoral_list_del(tmp);/**/
30001910:	e59d0018 	ldr	r0, [sp, #24]
30001914:	eb002244 	bl	3000a22c <acoral_list_del>
			acoral_spin_unlock(&tmp->lock);/**/
			acoral_spin_unlock(&head->lock);/**/
			HAL_EXIT_CRITICAL();
30001918:	e59d000c 	ldr	r0, [sp, #12]
3000191c:	ebffff72 	bl	300016ec <HAL_INTR_RESTORE>
			tmp=tmp1;	
30001920:	e59d301c 	ldr	r3, [sp, #28]
30001924:	e58d3018 	str	r3, [sp, #24]
			if(thread->state==ACORAL_THREAD_STATE_RELEASE){
30001928:	e59d3010 	ldr	r3, [sp, #16]
3000192c:	e5d33004 	ldrb	r3, [r3, #4]
30001930:	e3530010 	cmp	r3, #16
30001934:	1a000003 	bne	30001948 <daem+0x80>
				acoral_release_thread((acoral_res_t *)thread);
30001938:	e59d3010 	ldr	r3, [sp, #16]
3000193c:	e1a00003 	mov	r0, r3
30001940:	eb000377 	bl	30002724 <acoral_release_thread>
30001944:	ea00000c 	b	3000197c <daem+0xb4>
			}else{
				HAL_ENTER_CRITICAL();
30001948:	ebffff69 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000194c:	e1a03000 	mov	r3, r0
30001950:	e58d300c 	str	r3, [sp, #12]
				acoral_spin_lock(&head->lock);/**/
				tmp1=head->prev;
30001954:	e59d3014 	ldr	r3, [sp, #20]
30001958:	e5933004 	ldr	r3, [r3, #4]
3000195c:	e58d301c 	str	r3, [sp, #28]
				acoral_spin_lock(&tmp1->lock);/**/
				acoral_list_add2_tail(&thread->waiting,head);/**/
30001960:	e59d3010 	ldr	r3, [sp, #16]
30001964:	e2833020 	add	r3, r3, #32
30001968:	e1a00003 	mov	r0, r3
3000196c:	e59d1014 	ldr	r1, [sp, #20]
30001970:	eb00221a 	bl	3000a1e0 <acoral_list_add2_tail>
				acoral_spin_unlock(&tmp1->lock);/**/
				acoral_spin_unlock(&head->lock);/**/
				HAL_EXIT_CRITICAL();
30001974:	e59d000c 	ldr	r0, [sp, #12]
30001978:	ebffff5b 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sr cpu_sr;
	acoral_thread_t * thread;
	acoral_list_t *head,*tmp,*tmp1;
	head=&acoral_res_release_queue.head;
	while(1){
		for(tmp=head->next;tmp!=head;){
3000197c:	e59d2018 	ldr	r2, [sp, #24]
30001980:	e59d3014 	ldr	r3, [sp, #20]
30001984:	e1520003 	cmp	r2, r3
30001988:	1affffd7 	bne	300018ec <daem+0x24>
				acoral_spin_unlock(&tmp1->lock);/**/
				acoral_spin_unlock(&head->lock);/**/
				HAL_EXIT_CRITICAL();
			}
		}
		acoral_suspend_self();
3000198c:	eb00038e 	bl	300027cc <acoral_suspend_self>
	}
30001990:	eaffffd1 	b	300018dc <daem+0x14>
30001994:	3002a884 	.word	0x3002a884

30001998 <init>:
#define DAEM_STACK_SIZE 512
#else
#define DAEM_STACK_SIZE 256
#endif
acoral_thread_t *thread;
void init(void *args){
30001998:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000199c:	e24dd024 	sub	sp, sp, #36	; 0x24
300019a0:	e58d0014 	str	r0, [sp, #20]
	acoral_prints("in init spg");
300019a4:	e59f00d0 	ldr	r0, [pc, #208]	; 30001a7c <init+0xe4>
300019a8:	eb0026c1 	bl	3000b4b4 <acoral_prints>
	acoral_comm_policy_data_t data;
	acoral_ticks_init();
300019ac:	eb000ae1 	bl	30004538 <acoral_ticks_init>
	/*ticks中断初始化函数*/
	acoral_start_sched=true;
300019b0:	e59f30c8 	ldr	r3, [pc, #200]	; 30001a80 <init+0xe8>
300019b4:	e3a02001 	mov	r2, #1
300019b8:	e5832000 	str	r2, [r3]
	/*软件延时初始化函数*/
#ifdef CFG_SOFT_DELAY
	soft_delay_init();
300019bc:	eb00208e 	bl	30009bfc <soft_delay_init>
#ifdef CFG_STAT
	/*内核统计相关数据初始化*/
	stat_init();
#endif
	/*创建后台服务进程*/
  	acoral_init_list(&acoral_res_release_queue.head);
300019c0:	e59f30bc 	ldr	r3, [pc, #188]	; 30001a84 <init+0xec>
300019c4:	e59f20b8 	ldr	r2, [pc, #184]	; 30001a84 <init+0xec>
300019c8:	e5832000 	str	r2, [r3]
300019cc:	e59f30b0 	ldr	r3, [pc, #176]	; 30001a84 <init+0xec>
300019d0:	e59f20ac 	ldr	r2, [pc, #172]	; 30001a84 <init+0xec>
300019d4:	e5832004 	str	r2, [r3, #4]
  	acoral_spin_init(&acoral_res_release_queue.head.lock);
	data.cpu=acoral_current_cpu;
300019d8:	e3a03000 	mov	r3, #0
300019dc:	e5cd301c 	strb	r3, [sp, #28]
	data.prio=ACORAL_DAEMON_PRIO;
300019e0:	e3a03043 	mov	r3, #67	; 0x43
300019e4:	e5cd301d 	strb	r3, [sp, #29]
	data.prio_type=ACORAL_ABSOLUTE_PRIO;
300019e8:	e3a03004 	mov	r3, #4
300019ec:	e5cd301e 	strb	r3, [sp, #30]
	daemon_id=acoral_create_thread_ext(daem,DAEM_STACK_SIZE,NULL,"daemon",NULL,ACORAL_SCHED_POLICY_COMM,&data);
300019f0:	e3a03000 	mov	r3, #0
300019f4:	e58d3000 	str	r3, [sp]
300019f8:	e3a03015 	mov	r3, #21
300019fc:	e58d3004 	str	r3, [sp, #4]
30001a00:	e28d301c 	add	r3, sp, #28
30001a04:	e58d3008 	str	r3, [sp, #8]
30001a08:	e59f0078 	ldr	r0, [pc, #120]	; 30001a88 <init+0xf0>
30001a0c:	e3a01c01 	mov	r1, #256	; 0x100
30001a10:	e3a02000 	mov	r2, #0
30001a14:	e59f3070 	ldr	r3, [pc, #112]	; 30001a8c <init+0xf4>
30001a18:	eb00008b 	bl	30001c4c <create_thread_ext>
30001a1c:	e1a02000 	mov	r2, r0
30001a20:	e59f3068 	ldr	r3, [pc, #104]	; 30001a90 <init+0xf8>
30001a24:	e5832000 	str	r2, [r3]
	thread=(acoral_thread_t *)acoral_get_res_by_id(daemon_id);
30001a28:	e59f3060 	ldr	r3, [pc, #96]	; 30001a90 <init+0xf8>
30001a2c:	e5933000 	ldr	r3, [r3]
30001a30:	e1a00003 	mov	r0, r3
30001a34:	eb00078d 	bl	30003870 <acoral_get_res_by_id>
30001a38:	e1a03000 	mov	r3, r0
30001a3c:	e1a02003 	mov	r2, r3
30001a40:	e59f304c 	ldr	r3, [pc, #76]	; 30001a94 <init+0xfc>
30001a44:	e5832000 	str	r2, [r3]
	if(daemon_id==-1)
30001a48:	e59f3040 	ldr	r3, [pc, #64]	; 30001a90 <init+0xf8>
30001a4c:	e5933000 	ldr	r3, [r3]
30001a50:	e3730001 	cmn	r3, #1
30001a54:	1a000000 	bne	30001a5c <init+0xc4>
		while(1);
30001a58:	eafffffe 	b	30001a58 <init+0xc0>
	/*应用级相关服务初始化,应用级不要使用延时函数，没有效果的*/
#ifdef CFG_SHELL
	acoral_shell_init();
30001a5c:	eb0088e8 	bl	30023e04 <acoral_shell_init>
#endif
	plugin_init();
30001a60:	eb002ba7 	bl	3000c904 <plugin_init>
	app_enter_policy_init();
30001a64:	eb00014b 	bl	30001f98 <app_enter_policy_init>
	user_main();
30001a68:	eb008761 	bl	300237f4 <user_main>
#ifdef CFG_TEST
	test_init();
#endif
	app_exit_policy_init();
30001a6c:	eb00014d 	bl	30001fa8 <app_exit_policy_init>
}
30001a70:	e28dd024 	add	sp, sp, #36	; 0x24
30001a74:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001a78:	e12fff1e 	bx	lr
30001a7c:	30025e44 	.word	0x30025e44
30001a80:	30026938 	.word	0x30026938
30001a84:	3002a884 	.word	0x3002a884
30001a88:	300018c8 	.word	0x300018c8
30001a8c:	30025e50 	.word	0x30025e50
30001a90:	3002a86c 	.word	0x3002a86c
30001a94:	3002a7a8 	.word	0x3002a7a8

30001a98 <acoral_start>:
acoral_thread_t orig_thread;
/*================================
 * Entry c function of start.S 
 *       c语言初始化入口函数
 *================================*/
void acoral_start(){
30001a98:	e92d4008 	push	{r3, lr}
		acoral_follow_cpu_start();
	}
	core_cpu=0;
	HAL_CORE_CPU_INIT();
#endif
	orig_thread.console_id=ACORAL_DEV_ERR_ID;
30001a9c:	e59f3038 	ldr	r3, [pc, #56]	; 30001adc <acoral_start+0x44>
30001aa0:	e3e02000 	mvn	r2, #0
30001aa4:	e583204c 	str	r2, [r3, #76]	; 0x4c
	acoral_set_orig_thread(&orig_thread);
30001aa8:	e59f002c 	ldr	r0, [pc, #44]	; 30001adc <acoral_start+0x44>
30001aac:	eb00015d 	bl	30002028 <acoral_set_orig_thread>
	/*板子初始化*/
	HAL_BOARD_INIT();

	/*内核模块初始化*/
	acoral_module_init();
30001ab0:	eb00005b 	bl	30001c24 <acoral_module_init>

	/*串口终端应该初始化好了，将根线程的终端id设置为串口终端*/
#ifdef CFG_DRIVER
	orig_thread.console_id=acoral_dev_open("console");
30001ab4:	e59f0024 	ldr	r0, [pc, #36]	; 30001ae0 <acoral_start+0x48>
30001ab8:	eb008a81 	bl	300244c4 <acoral_dev_open>
30001abc:	e1a02000 	mov	r2, r0
30001ac0:	e59f3014 	ldr	r3, [pc, #20]	; 30001adc <acoral_start+0x44>
30001ac4:	e583204c 	str	r2, [r3, #76]	; 0x4c
	acoral_prints("hello spg");
30001ac8:	e59f0014 	ldr	r0, [pc, #20]	; 30001ae4 <acoral_start+0x4c>
30001acc:	eb002678 	bl	3000b4b4 <acoral_prints>
	/*cmp初始化*/
    	acoral_cmp_init();
#endif

	/*主cpu开始函数*/
	acoral_core_cpu_start();
30001ad0:	eb000004 	bl	30001ae8 <acoral_core_cpu_start>
}
30001ad4:	e8bd4008 	pop	{r3, lr}
30001ad8:	e12fff1e 	bx	lr
30001adc:	3002a7ac 	.word	0x3002a7ac
30001ae0:	30025e58 	.word	0x30025e58
30001ae4:	30025e60 	.word	0x30025e60

30001ae8 <acoral_core_cpu_start>:
/*================================
 *  the primary cpu core start function 
 *      主cpu core的开始函数
 *================================*/
#define IDLE_STACK_SIZE 128
void acoral_core_cpu_start(){
30001ae8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001aec:	e24dd01c 	sub	sp, sp, #28
	acoral_comm_policy_data_t data;
	/*创建空闲线程*/
	acoral_start_sched=false;
30001af0:	e59f30cc 	ldr	r3, [pc, #204]	; 30001bc4 <acoral_core_cpu_start+0xdc>
30001af4:	e3a02000 	mov	r2, #0
30001af8:	e5832000 	str	r2, [r3]
	data.cpu=acoral_current_cpu;
30001afc:	e3a03000 	mov	r3, #0
30001b00:	e5cd3014 	strb	r3, [sp, #20]
	data.prio=ACORAL_IDLE_PRIO;
30001b04:	e3a03046 	mov	r3, #70	; 0x46
30001b08:	e5cd3015 	strb	r3, [sp, #21]
	data.prio_type=ACORAL_ABSOLUTE_PRIO;
30001b0c:	e3a03004 	mov	r3, #4
30001b10:	e5cd3016 	strb	r3, [sp, #22]
	idle_id=acoral_create_thread_ext(idle,IDLE_STACK_SIZE,NULL,"idle",NULL,ACORAL_SCHED_POLICY_COMM,&data);
30001b14:	e3a03000 	mov	r3, #0
30001b18:	e58d3000 	str	r3, [sp]
30001b1c:	e3a03015 	mov	r3, #21
30001b20:	e58d3004 	str	r3, [sp, #4]
30001b24:	e28d3014 	add	r3, sp, #20
30001b28:	e58d3008 	str	r3, [sp, #8]
30001b2c:	e59f0094 	ldr	r0, [pc, #148]	; 30001bc8 <acoral_core_cpu_start+0xe0>
30001b30:	e3a01080 	mov	r1, #128	; 0x80
30001b34:	e3a02000 	mov	r2, #0
30001b38:	e59f308c 	ldr	r3, [pc, #140]	; 30001bcc <acoral_core_cpu_start+0xe4>
30001b3c:	eb000042 	bl	30001c4c <create_thread_ext>
30001b40:	e1a02000 	mov	r2, r0
30001b44:	e59f3084 	ldr	r3, [pc, #132]	; 30001bd0 <acoral_core_cpu_start+0xe8>
30001b48:	e5832000 	str	r2, [r3]
	if(idle_id==-1)
30001b4c:	e59f307c 	ldr	r3, [pc, #124]	; 30001bd0 <acoral_core_cpu_start+0xe8>
30001b50:	e5933000 	ldr	r3, [r3]
30001b54:	e3730001 	cmn	r3, #1
30001b58:	1a000000 	bne	30001b60 <acoral_core_cpu_start+0x78>
		while(1);
30001b5c:	eafffffe 	b	30001b5c <acoral_core_cpu_start+0x74>
	/*创建初始化线程,这个调用层次比较多，需要多谢堆栈*/
	data.prio=ACORAL_INIT_PRIO;
30001b60:	e3a03000 	mov	r3, #0
30001b64:	e5cd3015 	strb	r3, [sp, #21]
	/*动态堆栈*/
	init_id=acoral_create_thread_ext(init,ACORAL_TEST_STACK_SIZE,"in init","init",NULL,ACORAL_SCHED_POLICY_COMM,&data);
30001b68:	e3a03000 	mov	r3, #0
30001b6c:	e58d3000 	str	r3, [sp]
30001b70:	e3a03015 	mov	r3, #21
30001b74:	e58d3004 	str	r3, [sp, #4]
30001b78:	e28d3014 	add	r3, sp, #20
30001b7c:	e58d3008 	str	r3, [sp, #8]
30001b80:	e59f004c 	ldr	r0, [pc, #76]	; 30001bd4 <acoral_core_cpu_start+0xec>
30001b84:	e3a01c02 	mov	r1, #512	; 0x200
30001b88:	e59f2048 	ldr	r2, [pc, #72]	; 30001bd8 <acoral_core_cpu_start+0xf0>
30001b8c:	e59f3048 	ldr	r3, [pc, #72]	; 30001bdc <acoral_core_cpu_start+0xf4>
30001b90:	eb00002d 	bl	30001c4c <create_thread_ext>
30001b94:	e1a02000 	mov	r2, r0
30001b98:	e59f3040 	ldr	r3, [pc, #64]	; 30001be0 <acoral_core_cpu_start+0xf8>
30001b9c:	e5832000 	str	r2, [r3]
	if(init_id==-1)
30001ba0:	e59f3038 	ldr	r3, [pc, #56]	; 30001be0 <acoral_core_cpu_start+0xf8>
30001ba4:	e5933000 	ldr	r3, [r3]
30001ba8:	e3730001 	cmn	r3, #1
30001bac:	1a000000 	bne	30001bb4 <acoral_core_cpu_start+0xcc>
		while(1);
30001bb0:	eafffffe 	b	30001bb0 <acoral_core_cpu_start+0xc8>
	acoral_start_os();
30001bb4:	eb00000a 	bl	30001be4 <acoral_start_os>
}
30001bb8:	e28dd01c 	add	sp, sp, #28
30001bbc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001bc0:	e12fff1e 	bx	lr
30001bc4:	30026938 	.word	0x30026938
30001bc8:	300018bc 	.word	0x300018bc
30001bcc:	30025e6c 	.word	0x30025e6c
30001bd0:	3002b100 	.word	0x3002b100
30001bd4:	30001998 	.word	0x30001998
30001bd8:	30025e74 	.word	0x30025e74
30001bdc:	30025e7c 	.word	0x30025e7c
30001be0:	3002b130 	.word	0x3002b130

30001be4 <acoral_start_os>:

void acoral_start_os(){
30001be4:	e92d4008 	push	{r3, lr}
	acoral_sched_init();
30001be8:	eb0000f2 	bl	30001fb8 <acoral_sched_init>
	acoral_select_thread();
30001bec:	eb00027d 	bl	300025e8 <acoral_select_thread>
	acoral_set_running_thread(acoral_ready_thread);
30001bf0:	e59f3024 	ldr	r3, [pc, #36]	; 30001c1c <acoral_start_os+0x38>
30001bf4:	e5933000 	ldr	r3, [r3]
30001bf8:	e1a00003 	mov	r0, r3
30001bfc:	eb000111 	bl	30002048 <acoral_set_running_thread>
	HAL_START_OS(&acoral_cur_thread->stack);
30001c00:	e59f3018 	ldr	r3, [pc, #24]	; 30001c20 <acoral_start_os+0x3c>
30001c04:	e5933000 	ldr	r3, [r3]
30001c08:	e2833034 	add	r3, r3, #52	; 0x34
30001c0c:	e1a00003 	mov	r0, r3
30001c10:	ebfffe5d 	bl	3000158c <HAL_SWITCH_TO>
}
30001c14:	e8bd4008 	pop	{r3, lr}
30001c18:	e12fff1e 	bx	lr
30001c1c:	3002b1c0 	.word	0x3002b1c0
30001c20:	3002b350 	.word	0x3002b350

30001c24 <acoral_module_init>:

/*================================
 *  the subsystem init of the kernel
 *     内核各模块初始化
 *================================*/
void acoral_module_init(){
30001c24:	e92d4008 	push	{r3, lr}
	/*中断系统初始化*/
	acoral_intr_sys_init();
30001c28:	eb000823 	bl	30003cbc <acoral_intr_sys_init>
	/*内存管理系统初始化*/
	acoral_mem_sys_init();
30001c2c:	eb000b91 	bl	30004a78 <acoral_mem_sys_init>
	/*资源管理系统初始化*/
	acoral_res_sys_init();
30001c30:	eb0007fd 	bl	30003c2c <acoral_res_sys_init>
	/*驱动管理系统初始化*/
	/*线程管理系统初始化*/
	acoral_thread_sys_init();
30001c34:	eb0004cf 	bl	30002f78 <acoral_thread_sys_init>
	/*时钟管理系统初始化*/
	acoral_time_sys_init();
30001c38:	eb000a22 	bl	300044c8 <acoral_time_sys_init>
	/*事件管理系统初始化,这个必须要，因为内存管理系统用到了*/
	acoral_evt_sys_init();
30001c3c:	eb000bca 	bl	30004b6c <acoral_evt_sys_init>
	/*消息管理系统初始化*/
#ifdef CFG_DRIVER
	acoral_drv_sys_init();
30001c40:	eb008aee 	bl	30024800 <acoral_drv_sys_init>
#endif
}
30001c44:	e8bd4008 	pop	{r3, lr}
30001c48:	e12fff1e 	bx	lr

30001c4c <create_thread_ext>:
#include<queue.h>
#include<thread.h>
#include<print.h>
#include<policy.h>
acoral_queue_t policy_list;
acoral_id create_thread_ext(void (*route)(void *args),acoral_u32 stack_size,void *args,acoral_char *name,void *stack,acoral_u32 sched_policy,void *data){
30001c4c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001c50:	e24dd024 	sub	sp, sp, #36	; 0x24
30001c54:	e58d0014 	str	r0, [sp, #20]
30001c58:	e58d1010 	str	r1, [sp, #16]
30001c5c:	e58d200c 	str	r2, [sp, #12]
30001c60:	e58d3008 	str	r3, [sp, #8]
	acoral_thread_t *thread;
        /*分配tcb数据块*/
	thread=acoral_alloc_thread();
30001c64:	eb0003fb 	bl	30002c58 <acoral_alloc_thread>
30001c68:	e1a03000 	mov	r3, r0
30001c6c:	e58d301c 	str	r3, [sp, #28]
	if(NULL==thread){
30001c70:	e59d301c 	ldr	r3, [sp, #28]
30001c74:	e3530000 	cmp	r3, #0
30001c78:	1a000004 	bne	30001c90 <create_thread_ext+0x44>
		acoral_printerr("Alloc thread:%s fail\n",name);
30001c7c:	e59f0098 	ldr	r0, [pc, #152]	; 30001d1c <create_thread_ext+0xd0>
30001c80:	e59d1008 	ldr	r1, [sp, #8]
30001c84:	eb0025e7 	bl	3000b428 <acoral_print>
		acoral_printk("No Mem Space or Beyond the max thread\n");
		return -1;
30001c88:	e3e03000 	mvn	r3, #0
30001c8c:	ea00001e 	b	30001d0c <create_thread_ext+0xc0>
	}
	thread->name=name;
30001c90:	e59d301c 	ldr	r3, [sp, #28]
30001c94:	e59d2008 	ldr	r2, [sp, #8]
30001c98:	e5832048 	str	r2, [r3, #72]	; 0x48
	stack_size=stack_size&(~3);
30001c9c:	e59d3010 	ldr	r3, [sp, #16]
30001ca0:	e3c33003 	bic	r3, r3, #3
30001ca4:	e58d3010 	str	r3, [sp, #16]
	thread->stack_size=stack_size;
30001ca8:	e59d301c 	ldr	r3, [sp, #28]
30001cac:	e59d2010 	ldr	r2, [sp, #16]
30001cb0:	e583203c 	str	r2, [r3, #60]	; 0x3c
	if(stack!=NULL)
30001cb4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30001cb8:	e3530000 	cmp	r3, #0
30001cbc:	0a000003 	beq	30001cd0 <create_thread_ext+0x84>
		thread->stack_buttom=(acoral_u32 *)stack;
30001cc0:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30001cc4:	e59d301c 	ldr	r3, [sp, #28]
30001cc8:	e5832038 	str	r2, [r3, #56]	; 0x38
30001ccc:	ea000002 	b	30001cdc <create_thread_ext+0x90>
	else
		thread->stack_buttom=NULL;
30001cd0:	e59d301c 	ldr	r3, [sp, #28]
30001cd4:	e3a02000 	mov	r2, #0
30001cd8:	e5832038 	str	r2, [r3, #56]	; 0x38
	thread->policy=sched_policy;
30001cdc:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30001ce0:	e20320ff 	and	r2, r3, #255	; 0xff
30001ce4:	e59d301c 	ldr	r3, [sp, #28]
30001ce8:	e5c3200c 	strb	r2, [r3, #12]
	return acoral_policy_thread_init(sched_policy,thread,route,args,data);
30001cec:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30001cf0:	e58d3000 	str	r3, [sp]
30001cf4:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30001cf8:	e59d101c 	ldr	r1, [sp, #28]
30001cfc:	e59d2014 	ldr	r2, [sp, #20]
30001d00:	e59d300c 	ldr	r3, [sp, #12]
30001d04:	eb000025 	bl	30001da0 <acoral_policy_thread_init>
30001d08:	e1a03000 	mov	r3, r0
}
30001d0c:	e1a00003 	mov	r0, r3
30001d10:	e28dd024 	add	sp, sp, #36	; 0x24
30001d14:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001d18:	e12fff1e 	bx	lr
30001d1c:	30025e84 	.word	0x30025e84

30001d20 <acoral_get_policy_ctrl>:

acoral_sched_policy_t *acoral_get_policy_ctrl(acoral_u8 type){
30001d20:	e24dd018 	sub	sp, sp, #24
30001d24:	e1a03000 	mov	r3, r0
30001d28:	e5cd3007 	strb	r3, [sp, #7]
	acoral_list_t   *tmp,*head;
	acoral_sched_policy_t  *policy_ctrl;
	head=&policy_list.head;
30001d2c:	e59f3068 	ldr	r3, [pc, #104]	; 30001d9c <acoral_get_policy_ctrl+0x7c>
30001d30:	e58d3010 	str	r3, [sp, #16]
	tmp=head;
30001d34:	e59d3010 	ldr	r3, [sp, #16]
30001d38:	e58d300c 	str	r3, [sp, #12]
	for(tmp=head->next;tmp!=head;tmp=tmp->next){
30001d3c:	e59d3010 	ldr	r3, [sp, #16]
30001d40:	e5933000 	ldr	r3, [r3]
30001d44:	e58d300c 	str	r3, [sp, #12]
30001d48:	ea00000b 	b	30001d7c <acoral_get_policy_ctrl+0x5c>
		policy_ctrl=list_entry(tmp,acoral_sched_policy_t,list);
30001d4c:	e59d300c 	ldr	r3, [sp, #12]
30001d50:	e58d3014 	str	r3, [sp, #20]
		if(policy_ctrl->type==type)
30001d54:	e59d3014 	ldr	r3, [sp, #20]
30001d58:	e5d33008 	ldrb	r3, [r3, #8]
30001d5c:	e5dd2007 	ldrb	r2, [sp, #7]
30001d60:	e1520003 	cmp	r2, r3
30001d64:	1a000001 	bne	30001d70 <acoral_get_policy_ctrl+0x50>
			return policy_ctrl;
30001d68:	e59d3014 	ldr	r3, [sp, #20]
30001d6c:	ea000007 	b	30001d90 <acoral_get_policy_ctrl+0x70>
acoral_sched_policy_t *acoral_get_policy_ctrl(acoral_u8 type){
	acoral_list_t   *tmp,*head;
	acoral_sched_policy_t  *policy_ctrl;
	head=&policy_list.head;
	tmp=head;
	for(tmp=head->next;tmp!=head;tmp=tmp->next){
30001d70:	e59d300c 	ldr	r3, [sp, #12]
30001d74:	e5933000 	ldr	r3, [r3]
30001d78:	e58d300c 	str	r3, [sp, #12]
30001d7c:	e59d200c 	ldr	r2, [sp, #12]
30001d80:	e59d3010 	ldr	r3, [sp, #16]
30001d84:	e1520003 	cmp	r2, r3
30001d88:	1affffef 	bne	30001d4c <acoral_get_policy_ctrl+0x2c>
		policy_ctrl=list_entry(tmp,acoral_sched_policy_t,list);
		if(policy_ctrl->type==type)
			return policy_ctrl;
	}
	return NULL;
30001d8c:	e3a03000 	mov	r3, #0
}
30001d90:	e1a00003 	mov	r0, r3
30001d94:	e28dd018 	add	sp, sp, #24
30001d98:	e12fff1e 	bx	lr
30001d9c:	3002b104 	.word	0x3002b104

30001da0 <acoral_policy_thread_init>:

acoral_id acoral_policy_thread_init(acoral_u32 policy,acoral_thread_t *thread,void (*route)(void *args),void *args,void *data){
30001da0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001da4:	e24dd01c 	sub	sp, sp, #28
30001da8:	e58d000c 	str	r0, [sp, #12]
30001dac:	e58d1008 	str	r1, [sp, #8]
30001db0:	e58d2004 	str	r2, [sp, #4]
30001db4:	e58d3000 	str	r3, [sp]
	acoral_sr cpu_sr;
	acoral_sched_policy_t   *policy_ctrl;
	policy_ctrl=acoral_get_policy_ctrl(policy);	
30001db8:	e59d300c 	ldr	r3, [sp, #12]
30001dbc:	e20330ff 	and	r3, r3, #255	; 0xff
30001dc0:	e1a00003 	mov	r0, r3
30001dc4:	ebffffd5 	bl	30001d20 <acoral_get_policy_ctrl>
30001dc8:	e1a03000 	mov	r3, r0
30001dcc:	e58d3014 	str	r3, [sp, #20]
	if(policy_ctrl==NULL||policy_ctrl->policy_thread_init==NULL){
30001dd0:	e59d3014 	ldr	r3, [sp, #20]
30001dd4:	e3530000 	cmp	r3, #0
30001dd8:	0a000003 	beq	30001dec <acoral_policy_thread_init+0x4c>
30001ddc:	e59d3014 	ldr	r3, [sp, #20]
30001de0:	e593300c 	ldr	r3, [r3, #12]
30001de4:	e3530000 	cmp	r3, #0
30001de8:	1a00000e 	bne	30001e28 <acoral_policy_thread_init+0x88>
		HAL_ENTER_CRITICAL();
30001dec:	ebfffe40 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30001df0:	e1a03000 	mov	r3, r0
30001df4:	e58d3010 	str	r3, [sp, #16]
		acoral_release_res((acoral_res_t *)thread);
30001df8:	e59d3008 	ldr	r3, [sp, #8]
30001dfc:	e1a00003 	mov	r0, r3
30001e00:	eb000606 	bl	30003620 <acoral_release_res>
		HAL_EXIT_CRITICAL();
30001e04:	e59d0010 	ldr	r0, [sp, #16]
30001e08:	ebfffe37 	bl	300016ec <HAL_INTR_RESTORE>
		acoral_printerr("No thread policy support:%d\n",thread->policy);
30001e0c:	e59d3008 	ldr	r3, [sp, #8]
30001e10:	e5d3300c 	ldrb	r3, [r3, #12]
30001e14:	e59f0040 	ldr	r0, [pc, #64]	; 30001e5c <acoral_policy_thread_init+0xbc>
30001e18:	e1a01003 	mov	r1, r3
30001e1c:	eb002581 	bl	3000b428 <acoral_print>
		return -1;
30001e20:	e3e03000 	mvn	r3, #0
30001e24:	ea000008 	b	30001e4c <acoral_policy_thread_init+0xac>
	}
	return policy_ctrl->policy_thread_init(thread,route,args,data);
30001e28:	e59d3014 	ldr	r3, [sp, #20]
30001e2c:	e593c00c 	ldr	ip, [r3, #12]
30001e30:	e59d0008 	ldr	r0, [sp, #8]
30001e34:	e59d1004 	ldr	r1, [sp, #4]
30001e38:	e59d2000 	ldr	r2, [sp]
30001e3c:	e59d3020 	ldr	r3, [sp, #32]
30001e40:	e1a0e00f 	mov	lr, pc
30001e44:	e12fff1c 	bx	ip
30001e48:	e1a03000 	mov	r3, r0
}
30001e4c:	e1a00003 	mov	r0, r3
30001e50:	e28dd01c 	add	sp, sp, #28
30001e54:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001e58:	e12fff1e 	bx	lr
30001e5c:	30025e9c 	.word	0x30025e9c

30001e60 <acoral_register_sched_policy>:

void acoral_register_sched_policy(acoral_sched_policy_t *policy){
30001e60:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001e64:	e24dd00c 	sub	sp, sp, #12
30001e68:	e58d0004 	str	r0, [sp, #4]
	acoral_list_add2_tail(&policy->list,&policy_list.head);
30001e6c:	e59d3004 	ldr	r3, [sp, #4]
30001e70:	e1a00003 	mov	r0, r3
30001e74:	e59f100c 	ldr	r1, [pc, #12]	; 30001e88 <acoral_register_sched_policy+0x28>
30001e78:	eb0020d8 	bl	3000a1e0 <acoral_list_add2_tail>
}
30001e7c:	e28dd00c 	add	sp, sp, #12
30001e80:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001e84:	e12fff1e 	bx	lr
30001e88:	3002b104 	.word	0x3002b104

30001e8c <acoral_policy_delay_deal>:

void acoral_policy_delay_deal(){
30001e8c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001e90:	e24dd014 	sub	sp, sp, #20
	acoral_list_t   *tmp,*head;
	acoral_sched_policy_t  *policy_ctrl;
	head=&policy_list.head;
30001e94:	e59f3068 	ldr	r3, [pc, #104]	; 30001f04 <acoral_policy_delay_deal+0x78>
30001e98:	e58d3008 	str	r3, [sp, #8]
	tmp=head;
30001e9c:	e59d3008 	ldr	r3, [sp, #8]
30001ea0:	e58d3004 	str	r3, [sp, #4]
	for(tmp=head->next;tmp!=head;tmp=tmp->next){
30001ea4:	e59d3008 	ldr	r3, [sp, #8]
30001ea8:	e5933000 	ldr	r3, [r3]
30001eac:	e58d3004 	str	r3, [sp, #4]
30001eb0:	ea00000c 	b	30001ee8 <acoral_policy_delay_deal+0x5c>
		policy_ctrl=list_entry(tmp,acoral_sched_policy_t,list);
30001eb4:	e59d3004 	ldr	r3, [sp, #4]
30001eb8:	e58d300c 	str	r3, [sp, #12]
		if(policy_ctrl->delay_deal!=NULL)
30001ebc:	e59d300c 	ldr	r3, [sp, #12]
30001ec0:	e5933014 	ldr	r3, [r3, #20]
30001ec4:	e3530000 	cmp	r3, #0
30001ec8:	0a000003 	beq	30001edc <acoral_policy_delay_deal+0x50>
			policy_ctrl->delay_deal();
30001ecc:	e59d300c 	ldr	r3, [sp, #12]
30001ed0:	e5933014 	ldr	r3, [r3, #20]
30001ed4:	e1a0e00f 	mov	lr, pc
30001ed8:	e12fff13 	bx	r3
void acoral_policy_delay_deal(){
	acoral_list_t   *tmp,*head;
	acoral_sched_policy_t  *policy_ctrl;
	head=&policy_list.head;
	tmp=head;
	for(tmp=head->next;tmp!=head;tmp=tmp->next){
30001edc:	e59d3004 	ldr	r3, [sp, #4]
30001ee0:	e5933000 	ldr	r3, [r3]
30001ee4:	e58d3004 	str	r3, [sp, #4]
30001ee8:	e59d2004 	ldr	r2, [sp, #4]
30001eec:	e59d3008 	ldr	r3, [sp, #8]
30001ef0:	e1520003 	cmp	r2, r3
30001ef4:	1affffee 	bne	30001eb4 <acoral_policy_delay_deal+0x28>
		policy_ctrl=list_entry(tmp,acoral_sched_policy_t,list);
		if(policy_ctrl->delay_deal!=NULL)
			policy_ctrl->delay_deal();
	}
}
30001ef8:	e28dd014 	add	sp, sp, #20
30001efc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001f00:	e12fff1e 	bx	lr
30001f04:	3002b104 	.word	0x3002b104

30001f08 <acoral_policy_thread_release>:

void acoral_policy_thread_release(acoral_thread_t *thread){
30001f08:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001f0c:	e24dd014 	sub	sp, sp, #20
30001f10:	e58d0004 	str	r0, [sp, #4]
	acoral_sched_policy_t   *policy_ctrl;
	policy_ctrl=acoral_get_policy_ctrl(thread->policy);
30001f14:	e59d3004 	ldr	r3, [sp, #4]
30001f18:	e5d3300c 	ldrb	r3, [r3, #12]
30001f1c:	e1a00003 	mov	r0, r3
30001f20:	ebffff7e 	bl	30001d20 <acoral_get_policy_ctrl>
30001f24:	e1a03000 	mov	r3, r0
30001f28:	e58d300c 	str	r3, [sp, #12]
	if(policy_ctrl->policy_thread_release!=NULL)
30001f2c:	e59d300c 	ldr	r3, [sp, #12]
30001f30:	e5933010 	ldr	r3, [r3, #16]
30001f34:	e3530000 	cmp	r3, #0
30001f38:	0a000004 	beq	30001f50 <acoral_policy_thread_release+0x48>
		policy_ctrl->policy_thread_release(thread);
30001f3c:	e59d300c 	ldr	r3, [sp, #12]
30001f40:	e5933010 	ldr	r3, [r3, #16]
30001f44:	e59d0004 	ldr	r0, [sp, #4]
30001f48:	e1a0e00f 	mov	lr, pc
30001f4c:	e12fff13 	bx	r3
}
30001f50:	e28dd014 	add	sp, sp, #20
30001f54:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001f58:	e12fff1e 	bx	lr

30001f5c <acoral_sched_policy_init>:


void acoral_sched_policy_init(){
30001f5c:	e92d4008 	push	{r3, lr}
	acoral_list_init(&policy_list.head);
30001f60:	e59f302c 	ldr	r3, [pc, #44]	; 30001f94 <acoral_sched_policy_init+0x38>
30001f64:	e59f2028 	ldr	r2, [pc, #40]	; 30001f94 <acoral_sched_policy_init+0x38>
30001f68:	e5832000 	str	r2, [r3]
30001f6c:	e59f3020 	ldr	r3, [pc, #32]	; 30001f94 <acoral_sched_policy_init+0x38>
30001f70:	e59f201c 	ldr	r2, [pc, #28]	; 30001f94 <acoral_sched_policy_init+0x38>
30001f74:	e5832004 	str	r2, [r3, #4]
	comm_policy_init();
30001f78:	eb000477 	bl	3000315c <comm_policy_init>
#ifdef CFG_THRD_SLICE
	slice_policy_init();
30001f7c:	eb001d83 	bl	30009590 <slice_policy_init>
#endif
#ifdef CFG_THRD_PERIOD
	period_policy_init();
30001f80:	eb001cc5 	bl	3000929c <period_policy_init>
#endif
#ifdef CFG_THRD_RM
	rm_policy_init();
30001f84:	eb001b3c 	bl	30008c7c <rm_policy_init>
#endif
#ifdef CFG_THRD_POSIX
	posix_policy_init();
30001f88:	eb001ecd 	bl	30009ac4 <posix_policy_init>
#endif
}
30001f8c:	e8bd4008 	pop	{r3, lr}
30001f90:	e12fff1e 	bx	lr
30001f94:	3002b104 	.word	0x3002b104

30001f98 <app_enter_policy_init>:

void app_enter_policy_init(){
30001f98:	e92d4008 	push	{r3, lr}
#ifdef CFG_THRD_RM
	rm_init();
30001f9c:	eb001b11 	bl	30008be8 <rm_init>
#endif
}
30001fa0:	e8bd4008 	pop	{r3, lr}
30001fa4:	e12fff1e 	bx	lr

30001fa8 <app_exit_policy_init>:

void app_exit_policy_init(){
30001fa8:	e92d4008 	push	{r3, lr}
#ifdef CFG_THRD_RM
	rm_end();
30001fac:	eb001b4b 	bl	30008ce0 <rm_end>
#endif
}
30001fb0:	e8bd4008 	pop	{r3, lr}
30001fb4:	e12fff1e 	bx	lr

30001fb8 <acoral_sched_init>:
#include<lsched.h>
acoral_u8 need_sched[HAL_MAX_CPU];
acoral_u8 sched_lock[HAL_MAX_CPU];
acoral_thread_t *running_thread[HAL_MAX_CPU],*ready_thread[HAL_MAX_CPU];
static acoral_rdy_queue_t acoral_ready_queues[HAL_MAX_CPU];
void acoral_sched_init(){
30001fb8:	e24dd008 	sub	sp, sp, #8
	acoral_u8 i;
	for(i=0;i<HAL_MAX_CPU;i++){
30001fbc:	e3a03000 	mov	r3, #0
30001fc0:	e5cd3007 	strb	r3, [sp, #7]
30001fc4:	ea000008 	b	30001fec <acoral_sched_init+0x34>
		sched_lock[acoral_current_cpu]=0;
30001fc8:	e59f3030 	ldr	r3, [pc, #48]	; 30002000 <acoral_sched_init+0x48>
30001fcc:	e3a02000 	mov	r2, #0
30001fd0:	e5c32000 	strb	r2, [r3]
		need_sched[acoral_current_cpu]=0;
30001fd4:	e59f3028 	ldr	r3, [pc, #40]	; 30002004 <acoral_sched_init+0x4c>
30001fd8:	e3a02000 	mov	r2, #0
30001fdc:	e5c32000 	strb	r2, [r3]
acoral_u8 sched_lock[HAL_MAX_CPU];
acoral_thread_t *running_thread[HAL_MAX_CPU],*ready_thread[HAL_MAX_CPU];
static acoral_rdy_queue_t acoral_ready_queues[HAL_MAX_CPU];
void acoral_sched_init(){
	acoral_u8 i;
	for(i=0;i<HAL_MAX_CPU;i++){
30001fe0:	e5dd3007 	ldrb	r3, [sp, #7]
30001fe4:	e2833001 	add	r3, r3, #1
30001fe8:	e5cd3007 	strb	r3, [sp, #7]
30001fec:	e5dd3007 	ldrb	r3, [sp, #7]
30001ff0:	e3530000 	cmp	r3, #0
30001ff4:	0afffff3 	beq	30001fc8 <acoral_sched_init+0x10>
		sched_lock[acoral_current_cpu]=0;
		need_sched[acoral_current_cpu]=0;
	}
}
30001ff8:	e28dd008 	add	sp, sp, #8
30001ffc:	e12fff1e 	bx	lr
30002000:	3002a14c 	.word	0x3002a14c
30002004:	3002b354 	.word	0x3002b354

30002008 <acoral_sched_unlock>:

void acoral_sched_unlock(){
30002008:	e92d4008 	push	{r3, lr}
	sched_lock[acoral_current_cpu]=0;	
3000200c:	e59f3010 	ldr	r3, [pc, #16]	; 30002024 <acoral_sched_unlock+0x1c>
30002010:	e3a02000 	mov	r2, #0
30002014:	e5c32000 	strb	r2, [r3]
	acoral_sched();
30002018:	eb0000fc 	bl	30002410 <acoral_sched>
}
3000201c:	e8bd4008 	pop	{r3, lr}
30002020:	e12fff1e 	bx	lr
30002024:	3002a14c 	.word	0x3002a14c

30002028 <acoral_set_orig_thread>:

void acoral_set_orig_thread(acoral_thread_t *thread){
30002028:	e24dd008 	sub	sp, sp, #8
3000202c:	e58d0004 	str	r0, [sp, #4]
  	running_thread[acoral_current_cpu]=thread;
30002030:	e59f300c 	ldr	r3, [pc, #12]	; 30002044 <acoral_set_orig_thread+0x1c>
30002034:	e59d2004 	ldr	r2, [sp, #4]
30002038:	e5832000 	str	r2, [r3]
}
3000203c:	e28dd008 	add	sp, sp, #8
30002040:	e12fff1e 	bx	lr
30002044:	3002b350 	.word	0x3002b350

30002048 <acoral_set_running_thread>:

void acoral_set_running_thread(acoral_thread_t *thread){
30002048:	e24dd008 	sub	sp, sp, #8
3000204c:	e58d0004 	str	r0, [sp, #4]
  	running_thread[acoral_current_cpu]->state&=~ACORAL_THREAD_STATE_RUNNING;
30002050:	e59f3040 	ldr	r3, [pc, #64]	; 30002098 <acoral_set_running_thread+0x50>
30002054:	e5932000 	ldr	r2, [r3]
30002058:	e59f3038 	ldr	r3, [pc, #56]	; 30002098 <acoral_set_running_thread+0x50>
3000205c:	e5933000 	ldr	r3, [r3]
30002060:	e5d33004 	ldrb	r3, [r3, #4]
30002064:	e20330fb 	and	r3, r3, #251	; 0xfb
30002068:	e5c23004 	strb	r3, [r2, #4]
	thread->state|=ACORAL_THREAD_STATE_RUNNING;
3000206c:	e59d3004 	ldr	r3, [sp, #4]
30002070:	e5d33004 	ldrb	r3, [r3, #4]
30002074:	e3833004 	orr	r3, r3, #4
30002078:	e20320ff 	and	r2, r3, #255	; 0xff
3000207c:	e59d3004 	ldr	r3, [sp, #4]
30002080:	e5c32004 	strb	r2, [r3, #4]
  	running_thread[acoral_current_cpu]=thread;
30002084:	e59f300c 	ldr	r3, [pc, #12]	; 30002098 <acoral_set_running_thread+0x50>
30002088:	e59d2004 	ldr	r2, [sp, #4]
3000208c:	e5832000 	str	r2, [r3]
}
30002090:	e28dd008 	add	sp, sp, #8
30002094:	e12fff1e 	bx	lr
30002098:	3002b350 	.word	0x3002b350

3000209c <acoral_thread_runqueue_init>:

/*================================
 * func: init acoral_ready_queues 
 *    初始化各个核上的就绪队列 
 *================================*/
void acoral_thread_runqueue_init(){
3000209c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300020a0:	e24dd014 	sub	sp, sp, #20
	acoral_prio_array_t *array;
	acoral_rdy_queue_t *rdy_queue;
	acoral_u8 cpu;
	/*初始化每个核上的优先级队列*/
	for(cpu=0;cpu<HAL_MAX_CPU;cpu++){
300020a4:	e3a03000 	mov	r3, #0
300020a8:	e5cd300f 	strb	r3, [sp, #15]
300020ac:	ea000011 	b	300020f8 <acoral_thread_runqueue_init+0x5c>
		rdy_queue=acoral_ready_queues+cpu;
300020b0:	e5dd200f 	ldrb	r2, [sp, #15]
300020b4:	e1a03002 	mov	r3, r2
300020b8:	e1a03183 	lsl	r3, r3, #3
300020bc:	e0623003 	rsb	r3, r2, r3
300020c0:	e1a02283 	lsl	r2, r3, #5
300020c4:	e0632002 	rsb	r2, r3, r2
300020c8:	e1a03102 	lsl	r3, r2, #2
300020cc:	e1a02003 	mov	r2, r3
300020d0:	e59f3038 	ldr	r3, [pc, #56]	; 30002110 <acoral_thread_runqueue_init+0x74>
300020d4:	e0823003 	add	r3, r2, r3
300020d8:	e58d3008 	str	r3, [sp, #8]
		array=&rdy_queue->array;
300020dc:	e59d3008 	ldr	r3, [sp, #8]
300020e0:	e58d3004 	str	r3, [sp, #4]
		acoral_prio_queue_init(array);
300020e4:	e59d0004 	ldr	r0, [sp, #4]
300020e8:	eb001ff7 	bl	3000a0cc <acoral_prio_queue_init>
void acoral_thread_runqueue_init(){
	acoral_prio_array_t *array;
	acoral_rdy_queue_t *rdy_queue;
	acoral_u8 cpu;
	/*初始化每个核上的优先级队列*/
	for(cpu=0;cpu<HAL_MAX_CPU;cpu++){
300020ec:	e5dd300f 	ldrb	r3, [sp, #15]
300020f0:	e2833001 	add	r3, r3, #1
300020f4:	e5cd300f 	strb	r3, [sp, #15]
300020f8:	e5dd300f 	ldrb	r3, [sp, #15]
300020fc:	e3530000 	cmp	r3, #0
30002100:	0affffea 	beq	300020b0 <acoral_thread_runqueue_init+0x14>
		rdy_queue=acoral_ready_queues+cpu;
		array=&rdy_queue->array;
		acoral_prio_queue_init(array);
	}

}
30002104:	e28dd014 	add	sp, sp, #20
30002108:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000210c:	e12fff1e 	bx	lr
30002110:	3002693c 	.word	0x3002693c

30002114 <acoral_get_idlest_cpu>:

/*================================
 *      Get the idlest core 
 *     获取最空闲的cpu核 
 *================================*/
acoral_u32 acoral_get_idlest_cpu(){
30002114:	e24dd010 	sub	sp, sp, #16
  	acoral_u32 cpu,i,count=-1;
30002118:	e3e03000 	mvn	r3, #0
3000211c:	e58d3008 	str	r3, [sp, #8]
	acoral_rdy_queue_t *rdy_queue;
  	for(i=0;i<HAL_MAX_CPU;i++){
30002120:	e3a03000 	mov	r3, #0
30002124:	e58d3004 	str	r3, [sp, #4]
30002128:	ea000017 	b	3000218c <acoral_get_idlest_cpu+0x78>
	    rdy_queue=acoral_ready_queues+i;
3000212c:	e59d2004 	ldr	r2, [sp, #4]
30002130:	e1a03002 	mov	r3, r2
30002134:	e1a03183 	lsl	r3, r3, #3
30002138:	e0623003 	rsb	r3, r2, r3
3000213c:	e1a02283 	lsl	r2, r3, #5
30002140:	e0632002 	rsb	r2, r3, r2
30002144:	e1a03102 	lsl	r3, r2, #2
30002148:	e1a02003 	mov	r2, r3
3000214c:	e59f3054 	ldr	r3, [pc, #84]	; 300021a8 <acoral_get_idlest_cpu+0x94>
30002150:	e0823003 	add	r3, r2, r3
30002154:	e58d300c 	str	r3, [sp, #12]
	    if(count>rdy_queue->array.num){
30002158:	e59d300c 	ldr	r3, [sp, #12]
3000215c:	e5932000 	ldr	r2, [r3]
30002160:	e59d3008 	ldr	r3, [sp, #8]
30002164:	e1520003 	cmp	r2, r3
30002168:	2a000004 	bcs	30002180 <acoral_get_idlest_cpu+0x6c>
	      	count=rdy_queue->array.num;
3000216c:	e59d300c 	ldr	r3, [sp, #12]
30002170:	e5933000 	ldr	r3, [r3]
30002174:	e58d3008 	str	r3, [sp, #8]
		cpu=i;
30002178:	e59d3004 	ldr	r3, [sp, #4]
3000217c:	e58d3000 	str	r3, [sp]
 *     获取最空闲的cpu核 
 *================================*/
acoral_u32 acoral_get_idlest_cpu(){
  	acoral_u32 cpu,i,count=-1;
	acoral_rdy_queue_t *rdy_queue;
  	for(i=0;i<HAL_MAX_CPU;i++){
30002180:	e59d3004 	ldr	r3, [sp, #4]
30002184:	e2833001 	add	r3, r3, #1
30002188:	e58d3004 	str	r3, [sp, #4]
3000218c:	e59d3004 	ldr	r3, [sp, #4]
30002190:	e3530000 	cmp	r3, #0
30002194:	0affffe4 	beq	3000212c <acoral_get_idlest_cpu+0x18>
	    if(count>rdy_queue->array.num){
	      	count=rdy_queue->array.num;
		cpu=i;
	    }
	}
	return cpu;
30002198:	e59d3000 	ldr	r3, [sp]
}
3000219c:	e1a00003 	mov	r0, r3
300021a0:	e28dd010 	add	sp, sp, #16
300021a4:	e12fff1e 	bx	lr
300021a8:	3002693c 	.word	0x3002693c

300021ac <acoral_get_idle_maskcpu>:

acoral_u32 acoral_get_idle_maskcpu(acoral_u32 cpu_mask){
300021ac:	e24dd018 	sub	sp, sp, #24
300021b0:	e58d0004 	str	r0, [sp, #4]
  	acoral_u32 cpu,i,count=-1;
300021b4:	e3e03000 	mvn	r3, #0
300021b8:	e58d3010 	str	r3, [sp, #16]
	acoral_rdy_queue_t *rdy_queue;
  	for(i=0,cpu=0;i<HAL_MAX_CPU;i++){
300021bc:	e3a03000 	mov	r3, #0
300021c0:	e58d300c 	str	r3, [sp, #12]
300021c4:	e3a03000 	mov	r3, #0
300021c8:	e58d3008 	str	r3, [sp, #8]
300021cc:	ea00001f 	b	30002250 <acoral_get_idle_maskcpu+0xa4>
	    rdy_queue=acoral_ready_queues+i;
300021d0:	e59d200c 	ldr	r2, [sp, #12]
300021d4:	e1a03002 	mov	r3, r2
300021d8:	e1a03183 	lsl	r3, r3, #3
300021dc:	e0623003 	rsb	r3, r2, r3
300021e0:	e1a02283 	lsl	r2, r3, #5
300021e4:	e0632002 	rsb	r2, r3, r2
300021e8:	e1a03102 	lsl	r3, r2, #2
300021ec:	e1a02003 	mov	r2, r3
300021f0:	e59f3074 	ldr	r3, [pc, #116]	; 3000226c <acoral_get_idle_maskcpu+0xc0>
300021f4:	e0823003 	add	r3, r2, r3
300021f8:	e58d3014 	str	r3, [sp, #20]
	    if(count>rdy_queue->array.num&&(1<<i&cpu_mask)){
300021fc:	e59d3014 	ldr	r3, [sp, #20]
30002200:	e5932000 	ldr	r2, [r3]
30002204:	e59d3010 	ldr	r3, [sp, #16]
30002208:	e1520003 	cmp	r2, r3
3000220c:	2a00000c 	bcs	30002244 <acoral_get_idle_maskcpu+0x98>
30002210:	e59d300c 	ldr	r3, [sp, #12]
30002214:	e3a02001 	mov	r2, #1
30002218:	e1a03312 	lsl	r3, r2, r3
3000221c:	e1a02003 	mov	r2, r3
30002220:	e59d3004 	ldr	r3, [sp, #4]
30002224:	e0023003 	and	r3, r2, r3
30002228:	e3530000 	cmp	r3, #0
3000222c:	0a000004 	beq	30002244 <acoral_get_idle_maskcpu+0x98>
	      	count=rdy_queue->array.num;
30002230:	e59d3014 	ldr	r3, [sp, #20]
30002234:	e5933000 	ldr	r3, [r3]
30002238:	e58d3010 	str	r3, [sp, #16]
		cpu=i;
3000223c:	e59d300c 	ldr	r3, [sp, #12]
30002240:	e58d3008 	str	r3, [sp, #8]
}

acoral_u32 acoral_get_idle_maskcpu(acoral_u32 cpu_mask){
  	acoral_u32 cpu,i,count=-1;
	acoral_rdy_queue_t *rdy_queue;
  	for(i=0,cpu=0;i<HAL_MAX_CPU;i++){
30002244:	e59d300c 	ldr	r3, [sp, #12]
30002248:	e2833001 	add	r3, r3, #1
3000224c:	e58d300c 	str	r3, [sp, #12]
30002250:	e59d300c 	ldr	r3, [sp, #12]
30002254:	e3530000 	cmp	r3, #0
30002258:	0affffdc 	beq	300021d0 <acoral_get_idle_maskcpu+0x24>
	    if(count>rdy_queue->array.num&&(1<<i&cpu_mask)){
	      	count=rdy_queue->array.num;
		cpu=i;
	    }
	}
	return cpu;
3000225c:	e59d3008 	ldr	r3, [sp, #8]
}
30002260:	e1a00003 	mov	r0, r3
30002264:	e28dd018 	add	sp, sp, #24
30002268:	e12fff1e 	bx	lr
3000226c:	3002693c 	.word	0x3002693c

30002270 <acoral_rdyqueue_add>:

/*================================
 * func: add thread to acoral_ready_queues
 *    将线程挂到就绪队列上
 *================================*/
void acoral_rdyqueue_add(acoral_thread_t *thread){
30002270:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002274:	e24dd014 	sub	sp, sp, #20
30002278:	e58d0004 	str	r0, [sp, #4]
	acoral_rdy_queue_t *rdy_queue;
	acoral_u8 cpu;
	cpu=thread->cpu;
3000227c:	e59d3004 	ldr	r3, [sp, #4]
30002280:	e5d33006 	ldrb	r3, [r3, #6]
30002284:	e5cd300f 	strb	r3, [sp, #15]
	rdy_queue=acoral_ready_queues+cpu;
30002288:	e5dd200f 	ldrb	r2, [sp, #15]
3000228c:	e1a03002 	mov	r3, r2
30002290:	e1a03183 	lsl	r3, r3, #3
30002294:	e0623003 	rsb	r3, r2, r3
30002298:	e1a02283 	lsl	r2, r3, #5
3000229c:	e0632002 	rsb	r2, r3, r2
300022a0:	e1a03102 	lsl	r3, r2, #2
300022a4:	e1a02003 	mov	r2, r3
300022a8:	e59f308c 	ldr	r3, [pc, #140]	; 3000233c <acoral_rdyqueue_add+0xcc>
300022ac:	e0823003 	add	r3, r2, r3
300022b0:	e58d3008 	str	r3, [sp, #8]
	acoral_prio_queue_add(&rdy_queue->array,thread->prio,&thread->ready);
300022b4:	e59d1008 	ldr	r1, [sp, #8]
300022b8:	e59d3004 	ldr	r3, [sp, #4]
300022bc:	e5d33005 	ldrb	r3, [r3, #5]
300022c0:	e1a02003 	mov	r2, r3
300022c4:	e59d3004 	ldr	r3, [sp, #4]
300022c8:	e2833010 	add	r3, r3, #16
300022cc:	e1a00001 	mov	r0, r1
300022d0:	e1a01002 	mov	r1, r2
300022d4:	e1a02003 	mov	r2, r3
300022d8:	eb001f26 	bl	30009f78 <acoral_prio_queue_add>
	thread->state&=~ACORAL_THREAD_STATE_SUSPEND;
300022dc:	e59d3004 	ldr	r3, [sp, #4]
300022e0:	e5d33004 	ldrb	r3, [r3, #4]
300022e4:	e20330fd 	and	r3, r3, #253	; 0xfd
300022e8:	e59d2004 	ldr	r2, [sp, #4]
300022ec:	e5c23004 	strb	r3, [r2, #4]
	thread->state|=ACORAL_THREAD_STATE_READY;
300022f0:	e59d3004 	ldr	r3, [sp, #4]
300022f4:	e5d33004 	ldrb	r3, [r3, #4]
300022f8:	e3833001 	orr	r3, r3, #1
300022fc:	e20320ff 	and	r2, r3, #255	; 0xff
30002300:	e59d3004 	ldr	r3, [sp, #4]
30002304:	e5c32004 	strb	r2, [r3, #4]
	thread->res.id=thread->res.id|cpu<<ACORAL_RES_CPU_BIT;
30002308:	e59d3004 	ldr	r3, [sp, #4]
3000230c:	e5932000 	ldr	r2, [r3]
30002310:	e5dd300f 	ldrb	r3, [sp, #15]
30002314:	e1a03c03 	lsl	r3, r3, #24
30002318:	e1822003 	orr	r2, r2, r3
3000231c:	e59d3004 	ldr	r3, [sp, #4]
30002320:	e5832000 	str	r2, [r3]
	acoral_set_need_sched(true);
30002324:	e59f3014 	ldr	r3, [pc, #20]	; 30002340 <acoral_rdyqueue_add+0xd0>
30002328:	e3a02001 	mov	r2, #1
3000232c:	e5c32000 	strb	r2, [r3]
}
30002330:	e28dd014 	add	sp, sp, #20
30002334:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002338:	e12fff1e 	bx	lr
3000233c:	3002693c 	.word	0x3002693c
30002340:	3002b354 	.word	0x3002b354

30002344 <acoral_rdyqueue_del>:

/*================================
 * func: remove thread from acoral_ready_queues 
 *    将线程从就绪队列上取下
 *================================*/
void acoral_rdyqueue_del(acoral_thread_t *thread){
30002344:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002348:	e24dd014 	sub	sp, sp, #20
3000234c:	e58d0004 	str	r0, [sp, #4]
	acoral_8 cpu;
	acoral_rdy_queue_t *rdy_queue;
	cpu=thread->cpu;
30002350:	e59d3004 	ldr	r3, [sp, #4]
30002354:	e5d33006 	ldrb	r3, [r3, #6]
30002358:	e5cd300b 	strb	r3, [sp, #11]
	rdy_queue=acoral_ready_queues+cpu;
3000235c:	e1dd20db 	ldrsb	r2, [sp, #11]
30002360:	e1a03002 	mov	r3, r2
30002364:	e1a03183 	lsl	r3, r3, #3
30002368:	e0623003 	rsb	r3, r2, r3
3000236c:	e1a02283 	lsl	r2, r3, #5
30002370:	e0632002 	rsb	r2, r3, r2
30002374:	e1a03102 	lsl	r3, r2, #2
30002378:	e1a02003 	mov	r2, r3
3000237c:	e59f3084 	ldr	r3, [pc, #132]	; 30002408 <acoral_rdyqueue_del+0xc4>
30002380:	e0823003 	add	r3, r2, r3
30002384:	e58d300c 	str	r3, [sp, #12]
        acoral_prio_queue_del(&rdy_queue->array,thread->prio,&thread->ready);
30002388:	e59d100c 	ldr	r1, [sp, #12]
3000238c:	e59d3004 	ldr	r3, [sp, #4]
30002390:	e5d33005 	ldrb	r3, [r3, #5]
30002394:	e1a02003 	mov	r2, r3
30002398:	e59d3004 	ldr	r3, [sp, #4]
3000239c:	e2833010 	add	r3, r3, #16
300023a0:	e1a00001 	mov	r0, r1
300023a4:	e1a01002 	mov	r1, r2
300023a8:	e1a02003 	mov	r2, r3
300023ac:	eb001f13 	bl	3000a000 <acoral_prio_queue_del>
	thread->state&=~ACORAL_THREAD_STATE_READY;
300023b0:	e59d3004 	ldr	r3, [sp, #4]
300023b4:	e5d33004 	ldrb	r3, [r3, #4]
300023b8:	e20330fe 	and	r3, r3, #254	; 0xfe
300023bc:	e59d2004 	ldr	r2, [sp, #4]
300023c0:	e5c23004 	strb	r3, [r2, #4]
	thread->state&=~ACORAL_THREAD_STATE_RUNNING;
300023c4:	e59d3004 	ldr	r3, [sp, #4]
300023c8:	e5d33004 	ldrb	r3, [r3, #4]
300023cc:	e20330fb 	and	r3, r3, #251	; 0xfb
300023d0:	e59d2004 	ldr	r2, [sp, #4]
300023d4:	e5c23004 	strb	r3, [r2, #4]
	thread->state|=ACORAL_THREAD_STATE_SUSPEND;
300023d8:	e59d3004 	ldr	r3, [sp, #4]
300023dc:	e5d33004 	ldrb	r3, [r3, #4]
300023e0:	e3833002 	orr	r3, r3, #2
300023e4:	e20320ff 	and	r2, r3, #255	; 0xff
300023e8:	e59d3004 	ldr	r3, [sp, #4]
300023ec:	e5c32004 	strb	r2, [r3, #4]
	/*设置线程所在的核可调度*/
	acoral_set_need_sched(true);
300023f0:	e59f3014 	ldr	r3, [pc, #20]	; 3000240c <acoral_rdyqueue_del+0xc8>
300023f4:	e3a02001 	mov	r2, #1
300023f8:	e5c32000 	strb	r2, [r3]
}
300023fc:	e28dd014 	add	sp, sp, #20
30002400:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002404:	e12fff1e 	bx	lr
30002408:	3002693c 	.word	0x3002693c
3000240c:	3002b354 	.word	0x3002b354

30002410 <acoral_sched>:

/*================================
 * func: sched thread in acoral
 *         调度线程
 *================================*/
void acoral_sched(){
30002410:	e92d4008 	push	{r3, lr}
	/*如果不需要调度，则返回*/
	if(!acoral_need_sched)
30002414:	e59f3068 	ldr	r3, [pc, #104]	; 30002484 <acoral_sched+0x74>
30002418:	e5d33000 	ldrb	r3, [r3]
3000241c:	e3530000 	cmp	r3, #0
30002420:	0a00000e 	beq	30002460 <acoral_sched+0x50>
		return;

	if(acoral_intr_nesting)
30002424:	ebfffccd 	bl	30001760 <hal_get_intr_nesting_comm>
30002428:	e1a03000 	mov	r3, r0
3000242c:	e3530000 	cmp	r3, #0
30002430:	1a00000c 	bne	30002468 <acoral_sched+0x58>
		return;

	if(acoral_sched_is_lock)
30002434:	e59f304c 	ldr	r3, [pc, #76]	; 30002488 <acoral_sched+0x78>
30002438:	e5d33000 	ldrb	r3, [r3]
3000243c:	e3530000 	cmp	r3, #0
30002440:	1a00000a 	bne	30002470 <acoral_sched+0x60>
		return;
	/*如果还没有开始调度，则返回*/
	if(!acoral_start_sched)
30002444:	e59f3040 	ldr	r3, [pc, #64]	; 3000248c <acoral_sched+0x7c>
30002448:	e5933000 	ldr	r3, [r3]
3000244c:	e3530000 	cmp	r3, #0
30002450:	0a000008 	beq	30002478 <acoral_sched+0x68>
	  	return;
	/*这个函数进行简单处理后会直接或间接调用acoral_real_sched,或者acoral_real_intr_sched*/
	HAL_SCHED_BRIDGE(); 
30002454:	ebfffcde 	bl	300017d4 <hal_sched_bridge_comm>
	return;
30002458:	e1a00000 	nop			; (mov r0, r0)
3000245c:	ea000006 	b	3000247c <acoral_sched+0x6c>
 *         调度线程
 *================================*/
void acoral_sched(){
	/*如果不需要调度，则返回*/
	if(!acoral_need_sched)
		return;
30002460:	e1a00000 	nop			; (mov r0, r0)
30002464:	ea000004 	b	3000247c <acoral_sched+0x6c>

	if(acoral_intr_nesting)
		return;
30002468:	e1a00000 	nop			; (mov r0, r0)
3000246c:	ea000002 	b	3000247c <acoral_sched+0x6c>

	if(acoral_sched_is_lock)
		return;
30002470:	e1a00000 	nop			; (mov r0, r0)
30002474:	ea000000 	b	3000247c <acoral_sched+0x6c>
	/*如果还没有开始调度，则返回*/
	if(!acoral_start_sched)
	  	return;
30002478:	e1a00000 	nop			; (mov r0, r0)
	/*这个函数进行简单处理后会直接或间接调用acoral_real_sched,或者acoral_real_intr_sched*/
	HAL_SCHED_BRIDGE(); 
	return;
}
3000247c:	e8bd4008 	pop	{r3, lr}
30002480:	e12fff1e 	bx	lr
30002484:	3002b354 	.word	0x3002b354
30002488:	3002a14c 	.word	0x3002a14c
3000248c:	30026938 	.word	0x30026938

30002490 <acoral_real_sched>:
/*================================
 * func: sched thread in acoral
 *        进程上下文调度实现
 *        这个函数必须是原子操作
 *================================*/
void acoral_real_sched(){
30002490:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002494:	e24dd00c 	sub	sp, sp, #12
	acoral_thread_t *prev;
	acoral_thread_t *next;
	acoral_set_need_sched(false);
30002498:	e59f3090 	ldr	r3, [pc, #144]	; 30002530 <acoral_real_sched+0xa0>
3000249c:	e3a02000 	mov	r2, #0
300024a0:	e5c32000 	strb	r2, [r3]
	prev=acoral_cur_thread;
300024a4:	e59f3088 	ldr	r3, [pc, #136]	; 30002534 <acoral_real_sched+0xa4>
300024a8:	e5933000 	ldr	r3, [r3]
300024ac:	e58d3000 	str	r3, [sp]
	/*选择最高优先级线程*/
	acoral_select_thread();
300024b0:	eb00004c 	bl	300025e8 <acoral_select_thread>
	next=acoral_ready_thread;
300024b4:	e59f307c 	ldr	r3, [pc, #124]	; 30002538 <acoral_real_sched+0xa8>
300024b8:	e5933000 	ldr	r3, [r3]
300024bc:	e58d3004 	str	r3, [sp, #4]
	if(prev!=next){
300024c0:	e59d2000 	ldr	r2, [sp]
300024c4:	e59d3004 	ldr	r3, [sp, #4]
300024c8:	e1520003 	cmp	r2, r3
300024cc:	0a000014 	beq	30002524 <acoral_real_sched+0x94>
	    acoral_set_running_thread(next);
300024d0:	e59d0004 	ldr	r0, [sp, #4]
300024d4:	ebfffedb 	bl	30002048 <acoral_set_running_thread>
	    if(prev->state==ACORAL_THREAD_STATE_EXIT){
300024d8:	e59d3000 	ldr	r3, [sp]
300024dc:	e5d33004 	ldrb	r3, [r3, #4]
300024e0:	e3530008 	cmp	r3, #8
300024e4:	1a000007 	bne	30002508 <acoral_real_sched+0x78>
		  prev->state=ACORAL_THREAD_STATE_RELEASE;
300024e8:	e59d3000 	ldr	r3, [sp]
300024ec:	e3a02010 	mov	r2, #16
300024f0:	e5c32004 	strb	r2, [r3, #4]
  		  HAL_SWITCH_TO(&next->stack);
300024f4:	e59d3004 	ldr	r3, [sp, #4]
300024f8:	e2833034 	add	r3, r3, #52	; 0x34
300024fc:	e1a00003 	mov	r0, r3
30002500:	ebfffc21 	bl	3000158c <HAL_SWITCH_TO>
		  return;
30002504:	ea000006 	b	30002524 <acoral_real_sched+0x94>
  		  HAL_MOVE_SWITCH_TO(&prev->move_lock,0,&next->stack);
		  return;
	    }
#endif
	    /*线程切换*/
	    HAL_CONTEXT_SWITCH(&prev->stack,&next->stack);
30002508:	e59d3000 	ldr	r3, [sp]
3000250c:	e2832034 	add	r2, r3, #52	; 0x34
30002510:	e59d3004 	ldr	r3, [sp, #4]
30002514:	e2833034 	add	r3, r3, #52	; 0x34
30002518:	e1a00002 	mov	r0, r2
3000251c:	e1a01003 	mov	r1, r3
30002520:	ebfffc47 	bl	30001644 <HAL_CONTEXT_SWITCH>
	}
}
30002524:	e28dd00c 	add	sp, sp, #12
30002528:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000252c:	e12fff1e 	bx	lr
30002530:	3002b354 	.word	0x3002b354
30002534:	3002b350 	.word	0x3002b350
30002538:	3002b1c0 	.word	0x3002b1c0

3000253c <acoral_real_intr_sched>:
/*================================
 * func: sched thread in acoral
 *        中断上下文调度实现
 *        这个函数必须是原子操作
 *================================*/
void acoral_real_intr_sched(){
3000253c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002540:	e24dd00c 	sub	sp, sp, #12
	acoral_thread_t *prev;
	acoral_thread_t *next;
	acoral_set_need_sched(false);
30002544:	e59f3090 	ldr	r3, [pc, #144]	; 300025dc <acoral_real_intr_sched+0xa0>
30002548:	e3a02000 	mov	r2, #0
3000254c:	e5c32000 	strb	r2, [r3]
	prev=acoral_cur_thread;
30002550:	e59f3088 	ldr	r3, [pc, #136]	; 300025e0 <acoral_real_intr_sched+0xa4>
30002554:	e5933000 	ldr	r3, [r3]
30002558:	e58d3000 	str	r3, [sp]
	/*选择最高优先级线程*/
	acoral_select_thread();
3000255c:	eb000021 	bl	300025e8 <acoral_select_thread>
	next=acoral_ready_thread;
30002560:	e59f307c 	ldr	r3, [pc, #124]	; 300025e4 <acoral_real_intr_sched+0xa8>
30002564:	e5933000 	ldr	r3, [r3]
30002568:	e58d3004 	str	r3, [sp, #4]
	if(prev!=next){
3000256c:	e59d2000 	ldr	r2, [sp]
30002570:	e59d3004 	ldr	r3, [sp, #4]
30002574:	e1520003 	cmp	r2, r3
30002578:	0a000014 	beq	300025d0 <acoral_real_intr_sched+0x94>
	    acoral_set_running_thread(next);
3000257c:	e59d0004 	ldr	r0, [sp, #4]
30002580:	ebfffeb0 	bl	30002048 <acoral_set_running_thread>
	    if(prev->state==ACORAL_THREAD_STATE_EXIT){
30002584:	e59d3000 	ldr	r3, [sp]
30002588:	e5d33004 	ldrb	r3, [r3, #4]
3000258c:	e3530008 	cmp	r3, #8
30002590:	1a000007 	bne	300025b4 <acoral_real_intr_sched+0x78>
		  prev->state=ACORAL_THREAD_STATE_RELEASE;
30002594:	e59d3000 	ldr	r3, [sp]
30002598:	e3a02010 	mov	r2, #16
3000259c:	e5c32004 	strb	r2, [r3, #4]
  		  HAL_INTR_SWITCH_TO(&next->stack);
300025a0:	e59d3004 	ldr	r3, [sp, #4]
300025a4:	e2833034 	add	r3, r3, #52	; 0x34
300025a8:	e1a00003 	mov	r0, r3
300025ac:	ebfffbfa 	bl	3000159c <HAL_INTR_SWITCH_TO>
		  return;
300025b0:	ea000006 	b	300025d0 <acoral_real_intr_sched+0x94>
  		  HAL_MOVE_SWITCH_TO(&prev->move_lock,0,&next->stack);
		  return;
	    }
#endif
	    /*线程切换*/
	    HAL_INTR_CTX_SWITCH(&prev->stack,&next->stack);
300025b4:	e59d3000 	ldr	r3, [sp]
300025b8:	e2832034 	add	r2, r3, #52	; 0x34
300025bc:	e59d3004 	ldr	r3, [sp, #4]
300025c0:	e2833034 	add	r3, r3, #52	; 0x34
300025c4:	e1a00002 	mov	r0, r2
300025c8:	e1a01003 	mov	r1, r3
300025cc:	ebfffc02 	bl	300015dc <HAL_INTR_CTX_SWITCH>
	}
}
300025d0:	e28dd00c 	add	sp, sp, #12
300025d4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300025d8:	e12fff1e 	bx	lr
300025dc:	3002b354 	.word	0x3002b354
300025e0:	3002b350 	.word	0x3002b350
300025e4:	3002b1c0 	.word	0x3002b1c0

300025e8 <acoral_select_thread>:

/*================================
 * func: sched thread in acoral
 *     选择优先级最高的线程
 *================================*/
void acoral_select_thread(){
300025e8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300025ec:	e24dd024 	sub	sp, sp, #36	; 0x24
	acoral_rdy_queue_t *rdy_queue;
	acoral_prio_array_t *array;
	acoral_list_t *head;
	acoral_thread_t *thread;
	acoral_queue_t *queue;
	cpu=acoral_current_cpu;
300025f0:	e3a03000 	mov	r3, #0
300025f4:	e5cd3007 	strb	r3, [sp, #7]
	rdy_queue=acoral_ready_queues+cpu;
300025f8:	e5dd2007 	ldrb	r2, [sp, #7]
300025fc:	e1a03002 	mov	r3, r2
30002600:	e1a03183 	lsl	r3, r3, #3
30002604:	e0623003 	rsb	r3, r2, r3
30002608:	e1a02283 	lsl	r2, r3, #5
3000260c:	e0632002 	rsb	r2, r3, r2
30002610:	e1a03102 	lsl	r3, r2, #2
30002614:	e1a02003 	mov	r2, r3
30002618:	e59f3084 	ldr	r3, [pc, #132]	; 300026a4 <acoral_select_thread+0xbc>
3000261c:	e0823003 	add	r3, r2, r3
30002620:	e58d300c 	str	r3, [sp, #12]
	array=&rdy_queue->array;
30002624:	e59d300c 	ldr	r3, [sp, #12]
30002628:	e58d3010 	str	r3, [sp, #16]
	/*找出就绪队列中优先级最高的线程的优先级*/
	index = acoral_get_highprio(array);
3000262c:	e59d0010 	ldr	r0, [sp, #16]
30002630:	eb001e98 	bl	3000a098 <acoral_get_highprio>
30002634:	e1a03000 	mov	r3, r0
30002638:	e58d3008 	str	r3, [sp, #8]
	queue = array->queue + index;
3000263c:	e59d3010 	ldr	r3, [sp, #16]
30002640:	e2831010 	add	r1, r3, #16
30002644:	e59d2008 	ldr	r2, [sp, #8]
30002648:	e1a03002 	mov	r3, r2
3000264c:	e1a03083 	lsl	r3, r3, #1
30002650:	e0833002 	add	r3, r3, r2
30002654:	e1a03103 	lsl	r3, r3, #2
30002658:	e0813003 	add	r3, r1, r3
3000265c:	e58d301c 	str	r3, [sp, #28]
	head=&queue->head;
30002660:	e59d301c 	ldr	r3, [sp, #28]
30002664:	e58d3014 	str	r3, [sp, #20]
	thread=list_entry(head->next, acoral_thread_t, ready);
30002668:	e59d3014 	ldr	r3, [sp, #20]
3000266c:	e5933000 	ldr	r3, [r3]
30002670:	e2433010 	sub	r3, r3, #16
30002674:	e58d3018 	str	r3, [sp, #24]
	ACORAL_ASSERT(thread,"Aseert:In select thread");
30002678:	e59d2018 	ldr	r2, [sp, #24]
3000267c:	e59f3024 	ldr	r3, [pc, #36]	; 300026a8 <acoral_select_thread+0xc0>
30002680:	e1a00002 	mov	r0, r2
30002684:	e1a01003 	mov	r1, r3
30002688:	eb00056b 	bl	30003c3c <acoral_assert_res>
	acoral_set_ready_thread(thread);
3000268c:	e59f3018 	ldr	r3, [pc, #24]	; 300026ac <acoral_select_thread+0xc4>
30002690:	e59d2018 	ldr	r2, [sp, #24]
30002694:	e5832000 	str	r2, [r3]
}
30002698:	e28dd024 	add	sp, sp, #36	; 0x24
3000269c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300026a0:	e12fff1e 	bx	lr
300026a4:	3002693c 	.word	0x3002693c
300026a8:	30025ebc 	.word	0x30025ebc
300026ac:	3002b1c0 	.word	0x3002b1c0

300026b0 <acoral_release_thread1>:
 * func: release thread in acoral
 *	
 *   thread     
 *    
 *================================*/
void acoral_release_thread1(acoral_thread_t *thread){
300026b0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300026b4:	e24dd01c 	sub	sp, sp, #28
300026b8:	e58d0004 	str	r0, [sp, #4]
	acoral_list_t *head,*tmp;
	acoral_thread_t *daem;
	thread->state=ACORAL_THREAD_STATE_EXIT;
300026bc:	e59d3004 	ldr	r3, [sp, #4]
300026c0:	e3a02008 	mov	r2, #8
300026c4:	e5c32004 	strb	r2, [r3, #4]
	head=&acoral_res_release_queue.head;
300026c8:	e59f304c 	ldr	r3, [pc, #76]	; 3000271c <acoral_release_thread1+0x6c>
300026cc:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&head->lock);
	tmp=head->prev;
300026d0:	e59d300c 	ldr	r3, [sp, #12]
300026d4:	e5933004 	ldr	r3, [r3, #4]
300026d8:	e58d3010 	str	r3, [sp, #16]
	if(tmp!=head)
		acoral_spin_lock(&tmp->lock);
	acoral_list_add2_tail(&thread->waiting,head);
300026dc:	e59d3004 	ldr	r3, [sp, #4]
300026e0:	e2833020 	add	r3, r3, #32
300026e4:	e1a00003 	mov	r0, r3
300026e8:	e59d100c 	ldr	r1, [sp, #12]
300026ec:	eb001ebb 	bl	3000a1e0 <acoral_list_add2_tail>
	if(tmp!=head)
		acoral_spin_unlock(&tmp->lock);
	acoral_spin_unlock(&head->lock);
	daem=(acoral_thread_t *)acoral_get_res_by_id(daemon_id);
300026f0:	e59f3028 	ldr	r3, [pc, #40]	; 30002720 <acoral_release_thread1+0x70>
300026f4:	e5933000 	ldr	r3, [r3]
300026f8:	e1a00003 	mov	r0, r3
300026fc:	eb00045b 	bl	30003870 <acoral_get_res_by_id>
30002700:	e1a03000 	mov	r3, r0
30002704:	e58d3014 	str	r3, [sp, #20]
	acoral_rdy_thread(daem);
30002708:	e59d0014 	ldr	r0, [sp, #20]
3000270c:	eb000117 	bl	30002b70 <acoral_rdy_thread>
}
30002710:	e28dd01c 	add	sp, sp, #28
30002714:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002718:	e12fff1e 	bx	lr
3000271c:	3002a884 	.word	0x3002a884
30002720:	3002a86c 	.word	0x3002a86c

30002724 <acoral_release_thread>:
/*================================
 * func: release thread in acoral
 *	
 *   thread     
 *================================*/
void acoral_release_thread(acoral_res_t *res){
30002724:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002728:	e24dd014 	sub	sp, sp, #20
3000272c:	e58d0004 	str	r0, [sp, #4]
	acoral_thread_t *thread;
	thread=(acoral_thread_t *)res;
30002730:	e59d3004 	ldr	r3, [sp, #4]
30002734:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&acoral_threads_queue.head.lock);
	acoral_list_del(&thread->global_list);
30002738:	e59d300c 	ldr	r3, [sp, #12]
3000273c:	e2833028 	add	r3, r3, #40	; 0x28
30002740:	e1a00003 	mov	r0, r3
30002744:	eb001eb8 	bl	3000a22c <acoral_list_del>
	acoral_spin_unlock(&acoral_threads_queue.head.lock);
#ifdef CFG_TEST
	acoral_print("Release %s thread\n",thread->name);
#endif
	acoral_policy_thread_release(thread);
30002748:	e59d000c 	ldr	r0, [sp, #12]
3000274c:	ebfffded 	bl	30001f08 <acoral_policy_thread_release>
  	acoral_free((void *)thread->stack_buttom);
30002750:	e59d300c 	ldr	r3, [sp, #12]
30002754:	e5933038 	ldr	r3, [r3, #56]	; 0x38
30002758:	e1a00003 	mov	r0, r3
3000275c:	eb000fcd 	bl	30006698 <buddy_free>
	acoral_release_res((acoral_res_t *)thread);
30002760:	e59d300c 	ldr	r3, [sp, #12]
30002764:	e1a00003 	mov	r0, r3
30002768:	eb0003ac 	bl	30003620 <acoral_release_res>
}
3000276c:	e28dd014 	add	sp, sp, #20
30002770:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002774:	e12fff1e 	bx	lr

30002778 <acoral_suspend_thread>:
 * func: suspend thread in acoral
 *         	
 * thread(TCB) 	
 *================================*/

void acoral_suspend_thread(acoral_thread_t *thread){
30002778:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000277c:	e24dd014 	sub	sp, sp, #20
30002780:	e58d0004 	str	r0, [sp, #4]
	acoral_sr cpu_sr;
	acoral_8 cpu;
	if(!(ACORAL_THREAD_STATE_READY&thread->state))
30002784:	e59d3004 	ldr	r3, [sp, #4]
30002788:	e5d33004 	ldrb	r3, [r3, #4]
3000278c:	e2033001 	and	r3, r3, #1
30002790:	e3530000 	cmp	r3, #0
30002794:	0a000008 	beq	300027bc <acoral_suspend_thread+0x44>
	if(cpu!=acoral_current_cpu){
	  	acoral_ipi_cmd_send(cpu,ACORAL_IPI_THREAD_SUSPEND,thread->res.id,NULL);
		return;
	}
#endif
	HAL_ENTER_CRITICAL();
30002798:	ebfffbd5 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000279c:	e1a03000 	mov	r3, r0
300027a0:	e58d3008 	str	r3, [sp, #8]
	/**/
	acoral_rdyqueue_del(thread);
300027a4:	e59d0004 	ldr	r0, [sp, #4]
300027a8:	ebfffee5 	bl	30002344 <acoral_rdyqueue_del>
	HAL_EXIT_CRITICAL();
300027ac:	e59d0008 	ldr	r0, [sp, #8]
300027b0:	ebfffbcd 	bl	300016ec <HAL_INTR_RESTORE>
	/**/
	acoral_sched();
300027b4:	ebffff15 	bl	30002410 <acoral_sched>
300027b8:	ea000000 	b	300027c0 <acoral_suspend_thread+0x48>

void acoral_suspend_thread(acoral_thread_t *thread){
	acoral_sr cpu_sr;
	acoral_8 cpu;
	if(!(ACORAL_THREAD_STATE_READY&thread->state))
		return;
300027bc:	e1a00000 	nop			; (mov r0, r0)
	/**/
	acoral_rdyqueue_del(thread);
	HAL_EXIT_CRITICAL();
	/**/
	acoral_sched();
}
300027c0:	e28dd014 	add	sp, sp, #20
300027c4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300027c8:	e12fff1e 	bx	lr

300027cc <acoral_suspend_self>:

/*================================
 * func: suspend thread in acoral
 *      	
 *================================*/
void acoral_suspend_self(){
300027cc:	e92d4008 	push	{r3, lr}
	acoral_suspend_thread(acoral_cur_thread);
300027d0:	e59f3010 	ldr	r3, [pc, #16]	; 300027e8 <acoral_suspend_self+0x1c>
300027d4:	e5933000 	ldr	r3, [r3]
300027d8:	e1a00003 	mov	r0, r3
300027dc:	ebffffe5 	bl	30002778 <acoral_suspend_thread>
}
300027e0:	e8bd4008 	pop	{r3, lr}
300027e4:	e12fff1e 	bx	lr
300027e8:	3002b350 	.word	0x3002b350

300027ec <acoral_suspend_thread_by_id>:
 * func: suspend thread in acoral
 *      ID	
 *      thread_idID
 *================================*/

void acoral_suspend_thread_by_id(acoral_u32 thread_id){
300027ec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300027f0:	e24dd014 	sub	sp, sp, #20
300027f4:	e58d0004 	str	r0, [sp, #4]
	acoral_thread_t *thread=(acoral_thread_t *)acoral_get_res_by_id(thread_id);
300027f8:	e59d3004 	ldr	r3, [sp, #4]
300027fc:	e1a00003 	mov	r0, r3
30002800:	eb00041a 	bl	30003870 <acoral_get_res_by_id>
30002804:	e1a03000 	mov	r3, r0
30002808:	e58d300c 	str	r3, [sp, #12]
	acoral_suspend_thread(thread);
3000280c:	e59d000c 	ldr	r0, [sp, #12]
30002810:	ebffffd8 	bl	30002778 <acoral_suspend_thread>
}
30002814:	e28dd014 	add	sp, sp, #20
30002818:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000281c:	e12fff1e 	bx	lr

30002820 <acoral_resume_thread_by_id>:
 * func: resume thread in acoral
 *         	
 *   thread_idID
 *================================*/

void acoral_resume_thread_by_id(acoral_u32 thread_id){
30002820:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002824:	e24dd014 	sub	sp, sp, #20
30002828:	e58d0004 	str	r0, [sp, #4]
	acoral_thread_t *thread=(acoral_thread_t *)acoral_get_res_by_id(thread_id);
3000282c:	e59d3004 	ldr	r3, [sp, #4]
30002830:	e1a00003 	mov	r0, r3
30002834:	eb00040d 	bl	30003870 <acoral_get_res_by_id>
30002838:	e1a03000 	mov	r3, r0
3000283c:	e58d300c 	str	r3, [sp, #12]
	acoral_resume_thread(thread);
30002840:	e59d000c 	ldr	r0, [sp, #12]
30002844:	eb000002 	bl	30002854 <acoral_resume_thread>
}
30002848:	e28dd014 	add	sp, sp, #20
3000284c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002850:	e12fff1e 	bx	lr

30002854 <acoral_resume_thread>:
/*================================
 * func: resume thread in acoral
 *         	
 * thread(TCB) 	
 *================================*/
void acoral_resume_thread(acoral_thread_t *thread){
30002854:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002858:	e24dd014 	sub	sp, sp, #20
3000285c:	e58d0004 	str	r0, [sp, #4]
	acoral_sr cpu_sr;
	acoral_8 cpu;
	if(!(thread->state&ACORAL_THREAD_STATE_SUSPEND))
30002860:	e59d3004 	ldr	r3, [sp, #4]
30002864:	e5d33004 	ldrb	r3, [r3, #4]
30002868:	e2033002 	and	r3, r3, #2
3000286c:	e3530000 	cmp	r3, #0
30002870:	0a000008 	beq	30002898 <acoral_resume_thread+0x44>
	if(cpu!=acoral_current_cpu){
	  	acoral_ipi_cmd_send(cpu,ACORAL_IPI_THREAD_RESUME,thread->res.id,NULL);
		return;
	}
#endif
	HAL_ENTER_CRITICAL();
30002874:	ebfffb9e 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30002878:	e1a03000 	mov	r3, r0
3000287c:	e58d3008 	str	r3, [sp, #8]
	/**/
	acoral_rdyqueue_add(thread);
30002880:	e59d0004 	ldr	r0, [sp, #4]
30002884:	ebfffe79 	bl	30002270 <acoral_rdyqueue_add>
	HAL_EXIT_CRITICAL();
30002888:	e59d0008 	ldr	r0, [sp, #8]
3000288c:	ebfffb96 	bl	300016ec <HAL_INTR_RESTORE>
	/**/
	acoral_sched();
30002890:	ebfffede 	bl	30002410 <acoral_sched>
30002894:	ea000000 	b	3000289c <acoral_resume_thread+0x48>
 *================================*/
void acoral_resume_thread(acoral_thread_t *thread){
	acoral_sr cpu_sr;
	acoral_8 cpu;
	if(!(thread->state&ACORAL_THREAD_STATE_SUSPEND))
		return;
30002898:	e1a00000 	nop			; (mov r0, r0)
	/**/
	acoral_rdyqueue_add(thread);
	HAL_EXIT_CRITICAL();
	/**/
	acoral_sched();
}
3000289c:	e28dd014 	add	sp, sp, #20
300028a0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300028a4:	e12fff1e 	bx	lr

300028a8 <acoral_delay_thread>:
 *         	
 * thread(TCB) 	
 * timems	
 *      
 *================================*/
static void acoral_delay_thread(acoral_thread_t* thread,acoral_time time){
300028a8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300028ac:	e24dd014 	sub	sp, sp, #20
300028b0:	e58d0004 	str	r0, [sp, #4]
300028b4:	e58d1000 	str	r1, [sp]
	acoral_u32 real_ticks;
	if(!acoral_list_empty(&thread->waiting)){
300028b8:	e59d3004 	ldr	r3, [sp, #4]
300028bc:	e5932020 	ldr	r2, [r3, #32]
300028c0:	e59d3004 	ldr	r3, [sp, #4]
300028c4:	e2833020 	add	r3, r3, #32
300028c8:	e1520003 	cmp	r2, r3
300028cc:	1a000012 	bne	3000291c <acoral_delay_thread+0x74>
		return;
	}
#endif
	/*timeticks*/
	/*real_ticks=time*ACORAL_TICKS_PER_SEC/1000;*/
	real_ticks = TIME_TO_TICKS(time);
300028d0:	e59d2000 	ldr	r2, [sp]
300028d4:	e1a03002 	mov	r3, r2
300028d8:	e1a03103 	lsl	r3, r3, #2
300028dc:	e0833002 	add	r3, r3, r2
300028e0:	e1a02103 	lsl	r2, r3, #2
300028e4:	e0833002 	add	r3, r3, r2
300028e8:	e1a03103 	lsl	r3, r3, #2
300028ec:	e1a02003 	mov	r2, r3
300028f0:	e59f3034 	ldr	r3, [pc, #52]	; 3000292c <acoral_delay_thread+0x84>
300028f4:	e0831392 	umull	r1, r3, r2, r3
300028f8:	e1a03323 	lsr	r3, r3, #6
300028fc:	e58d300c 	str	r3, [sp, #12]
	thread->delay=real_ticks;
30002900:	e59d200c 	ldr	r2, [sp, #12]
30002904:	e59d3004 	ldr	r3, [sp, #4]
30002908:	e5832040 	str	r2, [r3, #64]	; 0x40
	/**/
	acoral_delayqueue_add(&time_delay_queue,thread);
3000290c:	e59f001c 	ldr	r0, [pc, #28]	; 30002930 <acoral_delay_thread+0x88>
30002910:	e59d1004 	ldr	r1, [sp, #4]
30002914:	eb000729 	bl	300045c0 <acoral_delayqueue_add>
30002918:	ea000000 	b	30002920 <acoral_delay_thread+0x78>
 *      
 *================================*/
static void acoral_delay_thread(acoral_thread_t* thread,acoral_time time){
	acoral_u32 real_ticks;
	if(!acoral_list_empty(&thread->waiting)){
		return;	
3000291c:	e1a00000 	nop			; (mov r0, r0)
	/*real_ticks=time*ACORAL_TICKS_PER_SEC/1000;*/
	real_ticks = TIME_TO_TICKS(time);
	thread->delay=real_ticks;
	/**/
	acoral_delayqueue_add(&time_delay_queue,thread);
}
30002920:	e28dd014 	add	sp, sp, #20
30002924:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002928:	e12fff1e 	bx	lr
3000292c:	10624dd3 	.word	0x10624dd3
30002930:	3002b134 	.word	0x3002b134

30002934 <acoral_delay_thread_by_id>:
 *         	
 * thread_idID 	
 * timems	
 *      
 *================================*/
static void acoral_delay_thread_by_id(acoral_time time,acoral_id thread_id){
30002934:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002938:	e24dd014 	sub	sp, sp, #20
3000293c:	e58d0004 	str	r0, [sp, #4]
30002940:	e58d1000 	str	r1, [sp]
	acoral_thread_t *thread=(acoral_thread_t *)acoral_get_res_by_id(thread_id);
30002944:	e59d0000 	ldr	r0, [sp]
30002948:	eb0003c8 	bl	30003870 <acoral_get_res_by_id>
3000294c:	e1a03000 	mov	r3, r0
30002950:	e58d300c 	str	r3, [sp, #12]
	acoral_delay_thread(thread,time);
30002954:	e59d000c 	ldr	r0, [sp, #12]
30002958:	e59d1004 	ldr	r1, [sp, #4]
3000295c:	ebffffd1 	bl	300028a8 <acoral_delay_thread>
}
30002960:	e28dd014 	add	sp, sp, #20
30002964:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002968:	e12fff1e 	bx	lr

3000296c <acoral_delay_self>:
/*================================
 * func: delay current thread in acoral
 *         	
 * timems	
 *================================*/
void acoral_delay_self(acoral_time time){
3000296c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002970:	e24dd00c 	sub	sp, sp, #12
30002974:	e58d0004 	str	r0, [sp, #4]
	acoral_delay_thread(acoral_cur_thread,time);
30002978:	e59f3018 	ldr	r3, [pc, #24]	; 30002998 <acoral_delay_self+0x2c>
3000297c:	e5933000 	ldr	r3, [r3]
30002980:	e1a00003 	mov	r0, r3
30002984:	e59d1004 	ldr	r1, [sp, #4]
30002988:	ebffffc6 	bl	300028a8 <acoral_delay_thread>
}
3000298c:	e28dd00c 	add	sp, sp, #12
30002990:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002994:	e12fff1e 	bx	lr
30002998:	3002b350 	.word	0x3002b350

3000299c <acoral_kill_thread>:
/*================================
 * func: kill thread in acoral
 *         	
 * thread(TCB) 	
 *================================*/
void acoral_kill_thread(acoral_thread_t *thread){
3000299c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300029a0:	e24dd01c 	sub	sp, sp, #28
300029a4:	e58d0004 	str	r0, [sp, #4]
	if(cpu!=acoral_current_cpu){
	  	acoral_ipi_cmd_send(cpu,ACORAL_IPI_THREAD_KILL,thread->res.id,NULL);
		return;
	}
#endif
	HAL_ENTER_CRITICAL();
300029a8:	ebfffb51 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300029ac:	e1a03000 	mov	r3, r0
300029b0:	e58d300c 	str	r3, [sp, #12]
        /*	*/
        /*	*/
	if(thread->state&ACORAL_THREAD_STATE_SUSPEND){
300029b4:	e59d3004 	ldr	r3, [sp, #4]
300029b8:	e5d33004 	ldrb	r3, [r3, #4]
300029bc:	e2033002 	and	r3, r3, #2
300029c0:	e3530000 	cmp	r3, #0
300029c4:	0a000011 	beq	30002a10 <acoral_kill_thread+0x74>
		evt=thread->evt;
300029c8:	e59d3004 	ldr	r3, [sp, #4]
300029cc:	e5933030 	ldr	r3, [r3, #48]	; 0x30
300029d0:	e58d3014 	str	r3, [sp, #20]
		/**/
		if(thread->state&ACORAL_THREAD_STATE_DELAY){
300029d4:	e59d3004 	ldr	r3, [sp, #4]
300029d8:	e5d33004 	ldrb	r3, [r3, #4]
300029dc:	e2033020 	and	r3, r3, #32
300029e0:	e3530000 	cmp	r3, #0
300029e4:	0a000004 	beq	300029fc <acoral_kill_thread+0x60>
			acoral_spin_lock(&thread->waiting.prev->lock);
			acoral_spin_lock(&thread->waiting.lock);
			acoral_list_del(&thread->waiting);
300029e8:	e59d3004 	ldr	r3, [sp, #4]
300029ec:	e2833020 	add	r3, r3, #32
300029f0:	e1a00003 	mov	r0, r3
300029f4:	eb001e0c 	bl	3000a22c <acoral_list_del>
300029f8:	ea000004 	b	30002a10 <acoral_kill_thread+0x74>
			acoral_spin_unlock(&thread->waiting.lock);
			acoral_spin_unlock(&thread->waiting.prev->lock);
		}else
		{
			/**/
			if(evt!=NULL){
300029fc:	e59d3014 	ldr	r3, [sp, #20]
30002a00:	e3530000 	cmp	r3, #0
30002a04:	0a000001 	beq	30002a10 <acoral_kill_thread+0x74>
				acoral_spin_lock(&evt->spin_lock);
				acoral_evt_queue_del(thread);
30002a08:	e59d0004 	ldr	r0, [sp, #4]
30002a0c:	eb0008d7 	bl	30004d70 <acoral_evt_queue_del>
				acoral_spin_unlock(&evt->spin_lock);
			}
		}
	}
	acoral_unrdy_thread(thread);
30002a10:	e59d0004 	ldr	r0, [sp, #4]
30002a14:	eb000064 	bl	30002bac <acoral_unrdy_thread>
	acoral_release_thread1(thread);
30002a18:	e59d0004 	ldr	r0, [sp, #4]
30002a1c:	ebffff23 	bl	300026b0 <acoral_release_thread1>
      	HAL_EXIT_CRITICAL();
30002a20:	e59d000c 	ldr	r0, [sp, #12]
30002a24:	ebfffb30 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sched();
30002a28:	ebfffe78 	bl	30002410 <acoral_sched>
}
30002a2c:	e28dd01c 	add	sp, sp, #28
30002a30:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002a34:	e12fff1e 	bx	lr

30002a38 <acoral_kill_thread_by_id>:
/*================================
 * func: kill thread in acoral
 *         	
 * thread_idID 	
 *================================*/
void acoral_kill_thread_by_id(acoral_id id){
30002a38:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002a3c:	e24dd014 	sub	sp, sp, #20
30002a40:	e58d0004 	str	r0, [sp, #4]
	acoral_thread_t *thread;
	thread=(acoral_thread_t *)acoral_get_res_by_id(id);
30002a44:	e59d0004 	ldr	r0, [sp, #4]
30002a48:	eb000388 	bl	30003870 <acoral_get_res_by_id>
30002a4c:	e1a03000 	mov	r3, r0
30002a50:	e58d300c 	str	r3, [sp, #12]
	acoral_kill_thread(thread);
30002a54:	e59d000c 	ldr	r0, [sp, #12]
30002a58:	ebffffcf 	bl	3000299c <acoral_kill_thread>
}
30002a5c:	e28dd014 	add	sp, sp, #20
30002a60:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002a64:	e12fff1e 	bx	lr

30002a68 <acoral_thread_exit>:

/*================================
 * func: kill current thread in acoral
 *         	
 *================================*/
void acoral_thread_exit(){
30002a68:	e92d4008 	push	{r3, lr}
        acoral_kill_thread(acoral_cur_thread);
30002a6c:	e59f3010 	ldr	r3, [pc, #16]	; 30002a84 <acoral_thread_exit+0x1c>
30002a70:	e5933000 	ldr	r3, [r3]
30002a74:	e1a00003 	mov	r0, r3
30002a78:	ebffffc7 	bl	3000299c <acoral_kill_thread>
}
30002a7c:	e8bd4008 	pop	{r3, lr}
30002a80:	e12fff1e 	bx	lr
30002a84:	3002b350 	.word	0x3002b350

30002a88 <acoral_thread_change_prio>:

/*===========================
 *    change thread's prio
 *    
 *===========================*/
void acoral_thread_change_prio(acoral_thread_t* thread, acoral_u32 prio){
30002a88:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002a8c:	e24dd014 	sub	sp, sp, #20
30002a90:	e58d0004 	str	r0, [sp, #4]
30002a94:	e58d1000 	str	r1, [sp]
	if(cpu!=acoral_current_cpu){
	  	acoral_ipi_cmd_send(cpu,ACORAL_IPI_THREAD_CHG_PRIO,thread->res.id,(void *)prio);
		return;
	}
#endif
	HAL_ENTER_CRITICAL();
30002a98:	ebfffb15 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30002a9c:	e1a03000 	mov	r3, r0
30002aa0:	e58d3008 	str	r3, [sp, #8]
	if(thread->state&ACORAL_THREAD_STATE_READY){
30002aa4:	e59d3004 	ldr	r3, [sp, #4]
30002aa8:	e5d33004 	ldrb	r3, [r3, #4]
30002aac:	e2033001 	and	r3, r3, #1
30002ab0:	e20330ff 	and	r3, r3, #255	; 0xff
30002ab4:	e3530000 	cmp	r3, #0
30002ab8:	0a000008 	beq	30002ae0 <acoral_thread_change_prio+0x58>
		acoral_rdyqueue_del(thread);
30002abc:	e59d0004 	ldr	r0, [sp, #4]
30002ac0:	ebfffe1f 	bl	30002344 <acoral_rdyqueue_del>
		thread->prio = prio;
30002ac4:	e59d3000 	ldr	r3, [sp]
30002ac8:	e20320ff 	and	r2, r3, #255	; 0xff
30002acc:	e59d3004 	ldr	r3, [sp, #4]
30002ad0:	e5c32005 	strb	r2, [r3, #5]
		acoral_rdyqueue_add(thread);
30002ad4:	e59d0004 	ldr	r0, [sp, #4]
30002ad8:	ebfffde4 	bl	30002270 <acoral_rdyqueue_add>
30002adc:	ea000003 	b	30002af0 <acoral_thread_change_prio+0x68>
	}else
		thread->prio = prio;
30002ae0:	e59d3000 	ldr	r3, [sp]
30002ae4:	e20320ff 	and	r2, r3, #255	; 0xff
30002ae8:	e59d3004 	ldr	r3, [sp, #4]
30002aec:	e5c32005 	strb	r2, [r3, #5]
	HAL_EXIT_CRITICAL();
30002af0:	e59d0008 	ldr	r0, [sp, #8]
30002af4:	ebfffafc 	bl	300016ec <HAL_INTR_RESTORE>
}
30002af8:	e28dd014 	add	sp, sp, #20
30002afc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002b00:	e12fff1e 	bx	lr

30002b04 <acoral_change_prio_self>:

/*===========================
 *    change current thread's prio
 *    
 *===========================*/
void acoral_change_prio_self(acoral_u32 prio){
30002b04:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002b08:	e24dd00c 	sub	sp, sp, #12
30002b0c:	e58d0004 	str	r0, [sp, #4]
	acoral_thread_change_prio(acoral_cur_thread, prio);
30002b10:	e59f3018 	ldr	r3, [pc, #24]	; 30002b30 <acoral_change_prio_self+0x2c>
30002b14:	e5933000 	ldr	r3, [r3]
30002b18:	e1a00003 	mov	r0, r3
30002b1c:	e59d1004 	ldr	r1, [sp, #4]
30002b20:	ebffffd8 	bl	30002a88 <acoral_thread_change_prio>
}
30002b24:	e28dd00c 	add	sp, sp, #12
30002b28:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002b2c:	e12fff1e 	bx	lr
30002b30:	3002b350 	.word	0x3002b350

30002b34 <acoral_thread_change_prio_by_id>:

/*===========================
 *    change thread's prio
 *    ID
 *===========================*/
void acoral_thread_change_prio_by_id(acoral_u32 thread_id, acoral_u32 prio){
30002b34:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002b38:	e24dd014 	sub	sp, sp, #20
30002b3c:	e58d0004 	str	r0, [sp, #4]
30002b40:	e58d1000 	str	r1, [sp]
	acoral_thread_t *thread=(acoral_thread_t *)acoral_get_res_by_id(thread_id);
30002b44:	e59d3004 	ldr	r3, [sp, #4]
30002b48:	e1a00003 	mov	r0, r3
30002b4c:	eb000347 	bl	30003870 <acoral_get_res_by_id>
30002b50:	e1a03000 	mov	r3, r0
30002b54:	e58d300c 	str	r3, [sp, #12]
	acoral_thread_change_prio(thread, prio);
30002b58:	e59d000c 	ldr	r0, [sp, #12]
30002b5c:	e59d1000 	ldr	r1, [sp]
30002b60:	ebffffc8 	bl	30002a88 <acoral_thread_change_prio>
}
30002b64:	e28dd014 	add	sp, sp, #20
30002b68:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002b6c:	e12fff1e 	bx	lr

30002b70 <acoral_rdy_thread>:
 * func: ready thread in acoral
 *  ,
 * thread(TCB) 	
 *================================*/

void acoral_rdy_thread(acoral_thread_t *thread){
30002b70:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002b74:	e24dd014 	sub	sp, sp, #20
30002b78:	e58d0004 	str	r0, [sp, #4]
	acoral_8 cpu;
	if(!(ACORAL_THREAD_STATE_SUSPEND&thread->state))
30002b7c:	e59d3004 	ldr	r3, [sp, #4]
30002b80:	e5d33004 	ldrb	r3, [r3, #4]
30002b84:	e2033002 	and	r3, r3, #2
30002b88:	e3530000 	cmp	r3, #0
30002b8c:	0a000002 	beq	30002b9c <acoral_rdy_thread+0x2c>
	  	acoral_ipi_cmd_send(cpu,ACORAL_IPI_THREAD_RESUME,thread->res.id,NULL);
		return;
	}
#endif
	/**/
	acoral_rdyqueue_add(thread);
30002b90:	e59d0004 	ldr	r0, [sp, #4]
30002b94:	ebfffdb5 	bl	30002270 <acoral_rdyqueue_add>
30002b98:	ea000000 	b	30002ba0 <acoral_rdy_thread+0x30>
 *================================*/

void acoral_rdy_thread(acoral_thread_t *thread){
	acoral_8 cpu;
	if(!(ACORAL_THREAD_STATE_SUSPEND&thread->state))
		return;
30002b9c:	e1a00000 	nop			; (mov r0, r0)
		return;
	}
#endif
	/**/
	acoral_rdyqueue_add(thread);
}
30002ba0:	e28dd014 	add	sp, sp, #20
30002ba4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002ba8:	e12fff1e 	bx	lr

30002bac <acoral_unrdy_thread>:
 *     ,
 * thread(TCB) 	
 *
 *================================*/

void acoral_unrdy_thread(acoral_thread_t *thread){
30002bac:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002bb0:	e24dd014 	sub	sp, sp, #20
30002bb4:	e58d0004 	str	r0, [sp, #4]
	acoral_8 cpu;
	if(!(ACORAL_THREAD_STATE_READY&thread->state))
30002bb8:	e59d3004 	ldr	r3, [sp, #4]
30002bbc:	e5d33004 	ldrb	r3, [r3, #4]
30002bc0:	e2033001 	and	r3, r3, #1
30002bc4:	e3530000 	cmp	r3, #0
30002bc8:	0a000002 	beq	30002bd8 <acoral_unrdy_thread+0x2c>
	  	acoral_ipi_cmd_send(cpu,ACORAL_IPI_THREAD_SUSPEND,thread->res.id,NULL);
		return;
	}
#endif
	/**/
	acoral_rdyqueue_del(thread);
30002bcc:	e59d0004 	ldr	r0, [sp, #4]
30002bd0:	ebfffddb 	bl	30002344 <acoral_rdyqueue_del>
30002bd4:	ea000000 	b	30002bdc <acoral_unrdy_thread+0x30>
 *================================*/

void acoral_unrdy_thread(acoral_thread_t *thread){
	acoral_8 cpu;
	if(!(ACORAL_THREAD_STATE_READY&thread->state))
		return;
30002bd8:	e1a00000 	nop			; (mov r0, r0)
		return;
	}
#endif
	/**/
	acoral_rdyqueue_del(thread);
}
30002bdc:	e28dd014 	add	sp, sp, #20
30002be0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002be4:	e12fff1e 	bx	lr

30002be8 <acoral_thread_move2_tail>:

void acoral_thread_move2_tail(acoral_thread_t *thread){
30002be8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002bec:	e24dd014 	sub	sp, sp, #20
30002bf0:	e58d0004 	str	r0, [sp, #4]
	if(cpu!=acoral_current_cpu){
	  	acoral_ipi_cmd_send(cpu,ACORAL_IPI_THREAD_MOVE2_TAIL,thread->res.id,NULL);
		return;
	}
#endif
	HAL_ENTER_CRITICAL();
30002bf4:	ebfffabe 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30002bf8:	e1a03000 	mov	r3, r0
30002bfc:	e58d300c 	str	r3, [sp, #12]
	acoral_unrdy_thread(thread);
30002c00:	e59d0004 	ldr	r0, [sp, #4]
30002c04:	ebffffe8 	bl	30002bac <acoral_unrdy_thread>
	acoral_rdy_thread(thread);
30002c08:	e59d0004 	ldr	r0, [sp, #4]
30002c0c:	ebffffd7 	bl	30002b70 <acoral_rdy_thread>
	HAL_EXIT_CRITICAL();
30002c10:	e59d000c 	ldr	r0, [sp, #12]
30002c14:	ebfffab4 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sched();
30002c18:	ebfffdfc 	bl	30002410 <acoral_sched>
}
30002c1c:	e28dd014 	add	sp, sp, #20
30002c20:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002c24:	e12fff1e 	bx	lr

30002c28 <acoral_thread_move2_tail_by_id>:

void acoral_thread_move2_tail_by_id(acoral_id thread_id){
30002c28:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002c2c:	e24dd014 	sub	sp, sp, #20
30002c30:	e58d0004 	str	r0, [sp, #4]
	acoral_thread_t *thread=(acoral_thread_t *)acoral_get_res_by_id(thread_id);
30002c34:	e59d0004 	ldr	r0, [sp, #4]
30002c38:	eb00030c 	bl	30003870 <acoral_get_res_by_id>
30002c3c:	e1a03000 	mov	r3, r0
30002c40:	e58d300c 	str	r3, [sp, #12]
	acoral_thread_move2_tail(thread);
30002c44:	e59d000c 	ldr	r0, [sp, #12]
30002c48:	ebffffe6 	bl	30002be8 <acoral_thread_move2_tail>
}
30002c4c:	e28dd014 	add	sp, sp, #20
30002c50:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002c54:	e12fff1e 	bx	lr

30002c58 <acoral_alloc_thread>:

/*================================
 * func: alloc thread struct data in acoral
 *     TCB
 *================================*/
acoral_thread_t *acoral_alloc_thread(){
30002c58:	e92d4008 	push	{r3, lr}
  	return (acoral_thread_t *)acoral_get_res(&acoral_thread_pool_ctrl);
30002c5c:	e59f0010 	ldr	r0, [pc, #16]	; 30002c74 <acoral_alloc_thread+0x1c>
30002c60:	eb000223 	bl	300034f4 <acoral_get_res>
30002c64:	e1a03000 	mov	r3, r0
}
30002c68:	e1a00003 	mov	r0, r3
30002c6c:	e8bd4008 	pop	{r3, lr}
30002c70:	e12fff1e 	bx	lr
30002c74:	3002a72c 	.word	0x3002a72c

30002c78 <acoral_thread_init>:
 * in:   (*exit)   (acoral_thread_exit)
 *       stack_size 
 *       args       
 *       name       
 *================================*/
acoral_err acoral_thread_init(acoral_thread_t *thread,void (*route)(void *args),void (*exit)(void),void *args){
30002c78:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002c7c:	e24dd01c 	sub	sp, sp, #28
30002c80:	e58d000c 	str	r0, [sp, #12]
30002c84:	e58d1008 	str	r1, [sp, #8]
30002c88:	e58d2004 	str	r2, [sp, #4]
30002c8c:	e58d3000 	str	r3, [sp]
	acoral_sr cpu_sr;
	acoral_u32 stack_size=thread->stack_size;
30002c90:	e59d300c 	ldr	r3, [sp, #12]
30002c94:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
30002c98:	e58d3014 	str	r3, [sp, #20]
	if(thread->stack_buttom==NULL){
30002c9c:	e59d300c 	ldr	r3, [sp, #12]
30002ca0:	e5933038 	ldr	r3, [r3, #56]	; 0x38
30002ca4:	e3530000 	cmp	r3, #0
30002ca8:	1a000015 	bne	30002d04 <acoral_thread_init+0x8c>
		if(stack_size<ACORAL_MIN_STACK_SIZE)
30002cac:	e59d2014 	ldr	r2, [sp, #20]
30002cb0:	e3a03fff 	mov	r3, #1020	; 0x3fc
30002cb4:	e2833003 	add	r3, r3, #3
30002cb8:	e1520003 	cmp	r2, r3
30002cbc:	8a000001 	bhi	30002cc8 <acoral_thread_init+0x50>
			stack_size=ACORAL_MIN_STACK_SIZE;
30002cc0:	e3a03b01 	mov	r3, #1024	; 0x400
30002cc4:	e58d3014 	str	r3, [sp, #20]
		thread->stack_buttom=(acoral_u32 *)acoral_malloc(stack_size);
30002cc8:	e59d0014 	ldr	r0, [sp, #20]
30002ccc:	eb000e39 	bl	300065b8 <buddy_malloc>
30002cd0:	e1a03000 	mov	r3, r0
30002cd4:	e1a02003 	mov	r2, r3
30002cd8:	e59d300c 	ldr	r3, [sp, #12]
30002cdc:	e5832038 	str	r2, [r3, #56]	; 0x38
		if(thread->stack_buttom==NULL)
30002ce0:	e59d300c 	ldr	r3, [sp, #12]
30002ce4:	e5933038 	ldr	r3, [r3, #56]	; 0x38
30002ce8:	e3530000 	cmp	r3, #0
30002cec:	1a000001 	bne	30002cf8 <acoral_thread_init+0x80>
			return ACORAL_ERR_THREAD_NO_STACK;
30002cf0:	e3a03016 	mov	r3, #22
30002cf4:	ea000064 	b	30002e8c <acoral_thread_init+0x214>
		thread->stack_size=stack_size;
30002cf8:	e59d300c 	ldr	r3, [sp, #12]
30002cfc:	e59d2014 	ldr	r2, [sp, #20]
30002d00:	e583203c 	str	r2, [r3, #60]	; 0x3c
	}
	thread->stack=(acoral_u32 *)((acoral_8 *)thread->stack_buttom+stack_size-4);
30002d04:	e59d300c 	ldr	r3, [sp, #12]
30002d08:	e5932038 	ldr	r2, [r3, #56]	; 0x38
30002d0c:	e59d3014 	ldr	r3, [sp, #20]
30002d10:	e2433004 	sub	r3, r3, #4
30002d14:	e0822003 	add	r2, r2, r3
30002d18:	e59d300c 	ldr	r3, [sp, #12]
30002d1c:	e5832034 	str	r2, [r3, #52]	; 0x34
	HAL_STACK_INIT(&thread->stack,route,exit,args);
30002d20:	e59d300c 	ldr	r3, [sp, #12]
30002d24:	e2833034 	add	r3, r3, #52	; 0x34
30002d28:	e1a00003 	mov	r0, r3
30002d2c:	e59d1008 	ldr	r1, [sp, #8]
30002d30:	e59d2004 	ldr	r2, [sp, #4]
30002d34:	e59d3000 	ldr	r3, [sp]
30002d38:	ebfff560 	bl	300002c0 <hal_stack_init>
	/*cpu_mask*/
	if(thread->cpu_mask==-1)
30002d3c:	e59d300c 	ldr	r3, [sp, #12]
30002d40:	e5933008 	ldr	r3, [r3, #8]
30002d44:	e3730001 	cmn	r3, #1
30002d48:	1a000002 	bne	30002d58 <acoral_thread_init+0xe0>
		thread->cpu_mask=0xefffffff;
30002d4c:	e59d300c 	ldr	r3, [sp, #12]
30002d50:	e3e02201 	mvn	r2, #268435456	; 0x10000000
30002d54:	e5832008 	str	r2, [r3, #8]
	if(thread->cpu<0)
30002d58:	e59d300c 	ldr	r3, [sp, #12]
30002d5c:	e5d33006 	ldrb	r3, [r3, #6]
30002d60:	e1a03c03 	lsl	r3, r3, #24
30002d64:	e1a03c43 	asr	r3, r3, #24
30002d68:	e3530000 	cmp	r3, #0
30002d6c:	aa000007 	bge	30002d90 <acoral_thread_init+0x118>
	      thread->cpu=acoral_get_idle_maskcpu(thread->cpu_mask);
30002d70:	e59d300c 	ldr	r3, [sp, #12]
30002d74:	e5933008 	ldr	r3, [r3, #8]
30002d78:	e1a00003 	mov	r0, r3
30002d7c:	ebfffd0a 	bl	300021ac <acoral_get_idle_maskcpu>
30002d80:	e1a03000 	mov	r3, r0
30002d84:	e20320ff 	and	r2, r3, #255	; 0xff
30002d88:	e59d300c 	ldr	r3, [sp, #12]
30002d8c:	e5c32006 	strb	r2, [r3, #6]
	if(thread->cpu>=HAL_MAX_CPU)
30002d90:	e59d300c 	ldr	r3, [sp, #12]
30002d94:	e5d33006 	ldrb	r3, [r3, #6]
30002d98:	e1a03c03 	lsl	r3, r3, #24
30002d9c:	e1a03c43 	asr	r3, r3, #24
30002da0:	e3530000 	cmp	r3, #0
30002da4:	da000002 	ble	30002db4 <acoral_thread_init+0x13c>
		thread->cpu=HAL_MAX_CPU-1;
30002da8:	e59d300c 	ldr	r3, [sp, #12]
30002dac:	e3a02000 	mov	r2, #0
30002db0:	e5c32006 	strb	r2, [r3, #6]
	thread->data=NULL;
30002db4:	e59d300c 	ldr	r3, [sp, #12]
30002db8:	e3a02000 	mov	r2, #0
30002dbc:	e5832054 	str	r2, [r3, #84]	; 0x54
	thread->state=ACORAL_THREAD_STATE_SUSPEND;
30002dc0:	e59d300c 	ldr	r3, [sp, #12]
30002dc4:	e3a02002 	mov	r2, #2
30002dc8:	e5c32004 	strb	r2, [r3, #4]
	/*继承父线程的console_id*/
	thread->console_id=acoral_cur_thread->console_id;
30002dcc:	e59f30c8 	ldr	r3, [pc, #200]	; 30002e9c <acoral_thread_init+0x224>
30002dd0:	e5933000 	ldr	r3, [r3]
30002dd4:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
30002dd8:	e59d300c 	ldr	r3, [sp, #12]
30002ddc:	e583204c 	str	r2, [r3, #76]	; 0x4c
	acoral_init_list(&thread->waiting);
30002de0:	e59d300c 	ldr	r3, [sp, #12]
30002de4:	e2832020 	add	r2, r3, #32
30002de8:	e59d300c 	ldr	r3, [sp, #12]
30002dec:	e5832020 	str	r2, [r3, #32]
30002df0:	e59d300c 	ldr	r3, [sp, #12]
30002df4:	e2832020 	add	r2, r3, #32
30002df8:	e59d300c 	ldr	r3, [sp, #12]
30002dfc:	e5832024 	str	r2, [r3, #36]	; 0x24
	acoral_init_list(&thread->ready);
30002e00:	e59d300c 	ldr	r3, [sp, #12]
30002e04:	e2832010 	add	r2, r3, #16
30002e08:	e59d300c 	ldr	r3, [sp, #12]
30002e0c:	e5832010 	str	r2, [r3, #16]
30002e10:	e59d300c 	ldr	r3, [sp, #12]
30002e14:	e2832010 	add	r2, r3, #16
30002e18:	e59d300c 	ldr	r3, [sp, #12]
30002e1c:	e5832014 	str	r2, [r3, #20]
	acoral_init_list(&thread->timeout);
30002e20:	e59d300c 	ldr	r3, [sp, #12]
30002e24:	e2832018 	add	r2, r3, #24
30002e28:	e59d300c 	ldr	r3, [sp, #12]
30002e2c:	e5832018 	str	r2, [r3, #24]
30002e30:	e59d300c 	ldr	r3, [sp, #12]
30002e34:	e2832018 	add	r2, r3, #24
30002e38:	e59d300c 	ldr	r3, [sp, #12]
30002e3c:	e583201c 	str	r2, [r3, #28]
	acoral_init_list(&thread->global_list);
30002e40:	e59d300c 	ldr	r3, [sp, #12]
30002e44:	e2832028 	add	r2, r3, #40	; 0x28
30002e48:	e59d300c 	ldr	r3, [sp, #12]
30002e4c:	e5832028 	str	r2, [r3, #40]	; 0x28
30002e50:	e59d300c 	ldr	r3, [sp, #12]
30002e54:	e2832028 	add	r2, r3, #40	; 0x28
30002e58:	e59d300c 	ldr	r3, [sp, #12]
30002e5c:	e583202c 	str	r2, [r3, #44]	; 0x2c
	acoral_spin_init(&thread->timeout.lock);
	acoral_spin_init(&thread->waiting.lock);
	acoral_spin_init(&thread->ready.lock);
	acoral_spin_init(&thread->move_lock);
	HAL_ENTER_CRITICAL();
30002e60:	ebfffa23 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30002e64:	e1a03000 	mov	r3, r0
30002e68:	e58d3010 	str	r3, [sp, #16]
	acoral_spin_lock(&acoral_threads_queue.head.lock);
	acoral_list_add2_tail(&thread->global_list,&acoral_threads_queue.head);
30002e6c:	e59d300c 	ldr	r3, [sp, #12]
30002e70:	e2833028 	add	r3, r3, #40	; 0x28
30002e74:	e1a00003 	mov	r0, r3
30002e78:	e59f1020 	ldr	r1, [pc, #32]	; 30002ea0 <acoral_thread_init+0x228>
30002e7c:	eb001cd7 	bl	3000a1e0 <acoral_list_add2_tail>
	acoral_spin_unlock(&acoral_threads_queue.head.lock);
	HAL_EXIT_CRITICAL();
30002e80:	e59d0010 	ldr	r0, [sp, #16]
30002e84:	ebfffa18 	bl	300016ec <HAL_INTR_RESTORE>
#ifdef CFG_TEST
	acoral_print("%s thread initial well\n",thread->name);
#endif
	return 0;
30002e88:	e3a03000 	mov	r3, #0
}
30002e8c:	e1a00003 	mov	r0, r3
30002e90:	e28dd01c 	add	sp, sp, #28
30002e94:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002e98:	e12fff1e 	bx	lr
30002e9c:	3002b350 	.word	0x3002b350
30002ea0:	3002a79c 	.word	0x3002a79c

30002ea4 <acoral_thread_pool_init>:

/*================================
 *      init tcb pool
 *      
 *================================*/
void acoral_thread_pool_init(){
30002ea4:	e92d4008 	push	{r3, lr}
	thread_api.release_res=acoral_release_thread;
30002ea8:	e59f3068 	ldr	r3, [pc, #104]	; 30002f18 <acoral_thread_pool_init+0x74>
30002eac:	e59f2068 	ldr	r2, [pc, #104]	; 30002f1c <acoral_thread_pool_init+0x78>
30002eb0:	e5832000 	str	r2, [r3]
	acoral_thread_pool_ctrl.type=ACORAL_RES_THREAD;
30002eb4:	e59f3064 	ldr	r3, [pc, #100]	; 30002f20 <acoral_thread_pool_init+0x7c>
30002eb8:	e3a02001 	mov	r2, #1
30002ebc:	e5832000 	str	r2, [r3]
	acoral_thread_pool_ctrl.size=sizeof(acoral_thread_t);
30002ec0:	e59f3058 	ldr	r3, [pc, #88]	; 30002f20 <acoral_thread_pool_init+0x7c>
30002ec4:	e3a02058 	mov	r2, #88	; 0x58
30002ec8:	e5832004 	str	r2, [r3, #4]
	if(CFG_MAX_THREAD>20)
		acoral_thread_pool_ctrl.num_per_pool=20;
30002ecc:	e59f304c 	ldr	r3, [pc, #76]	; 30002f20 <acoral_thread_pool_init+0x7c>
30002ed0:	e3a02014 	mov	r2, #20
30002ed4:	e5832008 	str	r2, [r3, #8]
	else
		acoral_thread_pool_ctrl.num_per_pool=CFG_MAX_THREAD;
	acoral_thread_pool_ctrl.max_pools=ACORAL_MAX_THREAD/acoral_thread_pool_ctrl.num_per_pool;
30002ed8:	e59f3040 	ldr	r3, [pc, #64]	; 30002f20 <acoral_thread_pool_init+0x7c>
30002edc:	e5933008 	ldr	r3, [r3, #8]
30002ee0:	e3a00028 	mov	r0, #40	; 0x28
30002ee4:	e1a01003 	mov	r1, r3
30002ee8:	eb00898d 	bl	30025524 <__aeabi_uidiv>
30002eec:	e1a03000 	mov	r3, r0
30002ef0:	e1a02003 	mov	r2, r3
30002ef4:	e59f3024 	ldr	r3, [pc, #36]	; 30002f20 <acoral_thread_pool_init+0x7c>
30002ef8:	e5832010 	str	r2, [r3, #16]
	acoral_thread_pool_ctrl.api=&thread_api;
30002efc:	e59f301c 	ldr	r3, [pc, #28]	; 30002f20 <acoral_thread_pool_init+0x7c>
30002f00:	e59f2010 	ldr	r2, [pc, #16]	; 30002f18 <acoral_thread_pool_init+0x74>
30002f04:	e583202c 	str	r2, [r3, #44]	; 0x2c
	acoral_pool_ctrl_init(&acoral_thread_pool_ctrl);
30002f08:	e59f0010 	ldr	r0, [pc, #16]	; 30002f20 <acoral_thread_pool_init+0x7c>
30002f0c:	eb0002d7 	bl	30003a70 <acoral_pool_ctrl_init>
}
30002f10:	e8bd4008 	pop	{r3, lr}
30002f14:	e12fff1e 	bx	lr
30002f18:	3002a6e4 	.word	0x3002a6e4
30002f1c:	30002724 	.word	0x30002724
30002f20:	3002a72c 	.word	0x3002a72c

30002f24 <acoral_set_thread_console>:

void acoral_set_thread_console(acoral_id id){
30002f24:	e24dd008 	sub	sp, sp, #8
30002f28:	e58d0004 	str	r0, [sp, #4]
	acoral_cur_thread->console_id=id;	
30002f2c:	e59f3010 	ldr	r3, [pc, #16]	; 30002f44 <acoral_set_thread_console+0x20>
30002f30:	e5933000 	ldr	r3, [r3]
30002f34:	e59d2004 	ldr	r2, [sp, #4]
30002f38:	e583204c 	str	r2, [r3, #76]	; 0x4c
}
30002f3c:	e28dd008 	add	sp, sp, #8
30002f40:	e12fff1e 	bx	lr
30002f44:	3002b350 	.word	0x3002b350

30002f48 <acoral_sched_mechanism_init>:

void acoral_sched_mechanism_init(){
30002f48:	e92d4008 	push	{r3, lr}
	acoral_thread_pool_init();
30002f4c:	ebffffd4 	bl	30002ea4 <acoral_thread_pool_init>
	acoral_thread_runqueue_init();
30002f50:	ebfffc51 	bl	3000209c <acoral_thread_runqueue_init>
	acoral_init_list(&acoral_threads_queue.head);
30002f54:	e59f3018 	ldr	r3, [pc, #24]	; 30002f74 <acoral_sched_mechanism_init+0x2c>
30002f58:	e59f2014 	ldr	r2, [pc, #20]	; 30002f74 <acoral_sched_mechanism_init+0x2c>
30002f5c:	e5832000 	str	r2, [r3]
30002f60:	e59f300c 	ldr	r3, [pc, #12]	; 30002f74 <acoral_sched_mechanism_init+0x2c>
30002f64:	e59f2008 	ldr	r2, [pc, #8]	; 30002f74 <acoral_sched_mechanism_init+0x2c>
30002f68:	e5832004 	str	r2, [r3, #4]
	acoral_spin_init(&acoral_threads_queue.head.lock);
}
30002f6c:	e8bd4008 	pop	{r3, lr}
30002f70:	e12fff1e 	bx	lr
30002f74:	3002a79c 	.word	0x3002a79c

30002f78 <acoral_thread_sys_init>:

/*================================
 *      init thread system 
 *       
 *================================*/
void acoral_thread_sys_init(){
30002f78:	e92d4008 	push	{r3, lr}
	acoral_sched_mechanism_init();
30002f7c:	ebfffff1 	bl	30002f48 <acoral_sched_mechanism_init>
	acoral_sched_policy_init();
30002f80:	ebfffbf5 	bl	30001f5c <acoral_sched_policy_init>
}
30002f84:	e8bd4008 	pop	{r3, lr}
30002f88:	e12fff1e 	bx	lr

30002f8c <create_comm_thread>:
 *       args       传进线程的参数
 *       name       创建线程的名字
 *       prio       创建线程的优先级
 *       cpu        绑定进程到指定cpu运行,-1为由系统指定
 *================================*/
acoral_id create_comm_thread(void (*route)(void *args),acoral_u32 stack_size,void *args,acoral_char *name,acoral_u8 prio,acoral_8 cpu){
30002f8c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002f90:	e24dd01c 	sub	sp, sp, #28
30002f94:	e58d000c 	str	r0, [sp, #12]
30002f98:	e58d1008 	str	r1, [sp, #8]
30002f9c:	e58d2004 	str	r2, [sp, #4]
30002fa0:	e58d3000 	str	r3, [sp]
	acoral_comm_policy_data_t policy_ctrl;
	acoral_thread_t *thread;
        /*分配tcb数据块*/
	thread=acoral_alloc_thread();
30002fa4:	ebffff2b 	bl	30002c58 <acoral_alloc_thread>
30002fa8:	e1a03000 	mov	r3, r0
30002fac:	e58d3014 	str	r3, [sp, #20]
	if(NULL==thread){
30002fb0:	e59d3014 	ldr	r3, [sp, #20]
30002fb4:	e3530000 	cmp	r3, #0
30002fb8:	1a000004 	bne	30002fd0 <create_comm_thread+0x44>
		acoral_printerr("Alloc thread:%s fail\n",name);
30002fbc:	e59f0094 	ldr	r0, [pc, #148]	; 30003058 <create_comm_thread+0xcc>
30002fc0:	e59d1000 	ldr	r1, [sp]
30002fc4:	eb002117 	bl	3000b428 <acoral_print>
		acoral_printk("No Mem Space or Beyond the max thread\n");
		return -1;
30002fc8:	e3e03000 	mvn	r3, #0
30002fcc:	ea00001d 	b	30003048 <create_comm_thread+0xbc>
	}
	thread->name=name;
30002fd0:	e59d3014 	ldr	r3, [sp, #20]
30002fd4:	e59d2000 	ldr	r2, [sp]
30002fd8:	e5832048 	str	r2, [r3, #72]	; 0x48
	stack_size=stack_size&(~3);
30002fdc:	e59d3008 	ldr	r3, [sp, #8]
30002fe0:	e3c33003 	bic	r3, r3, #3
30002fe4:	e58d3008 	str	r3, [sp, #8]
	thread->stack_size=stack_size;
30002fe8:	e59d3014 	ldr	r3, [sp, #20]
30002fec:	e59d2008 	ldr	r2, [sp, #8]
30002ff0:	e583203c 	str	r2, [r3, #60]	; 0x3c
	thread->stack_buttom=NULL;
30002ff4:	e59d3014 	ldr	r3, [sp, #20]
30002ff8:	e3a02000 	mov	r2, #0
30002ffc:	e5832038 	str	r2, [r3, #56]	; 0x38
        /*设置线程要运行的cpu核心*/
	policy_ctrl.cpu=cpu;
30003000:	e5dd3024 	ldrb	r3, [sp, #36]	; 0x24
30003004:	e5cd3010 	strb	r3, [sp, #16]
        /*设置线程的优先级*/
	policy_ctrl.prio=prio;
30003008:	e5dd3020 	ldrb	r3, [sp, #32]
3000300c:	e5cd3011 	strb	r3, [sp, #17]
	policy_ctrl.prio_type=ACORAL_BASE_PRIO;
30003010:	e3a03002 	mov	r3, #2
30003014:	e5cd3012 	strb	r3, [sp, #18]
	thread->policy=ACORAL_SCHED_POLICY_COMM;
30003018:	e59d3014 	ldr	r3, [sp, #20]
3000301c:	e3a02015 	mov	r2, #21
30003020:	e5c3200c 	strb	r2, [r3, #12]
	thread->cpu_mask=-1;
30003024:	e59d3014 	ldr	r3, [sp, #20]
30003028:	e3e02000 	mvn	r2, #0
3000302c:	e5832008 	str	r2, [r3, #8]
	return comm_policy_thread_init(thread,route,args,&policy_ctrl);
30003030:	e28d3010 	add	r3, sp, #16
30003034:	e59d0014 	ldr	r0, [sp, #20]
30003038:	e59d100c 	ldr	r1, [sp, #12]
3000303c:	e59d2004 	ldr	r2, [sp, #4]
30003040:	eb000005 	bl	3000305c <comm_policy_thread_init>
30003044:	e1a03000 	mov	r3, r0
}
30003048:	e1a00003 	mov	r0, r3
3000304c:	e28dd01c 	add	sp, sp, #28
30003050:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003054:	e12fff1e 	bx	lr
30003058:	30025ed4 	.word	0x30025ed4

3000305c <comm_policy_thread_init>:

acoral_id comm_policy_thread_init(acoral_thread_t *thread,void (*route)(void *args),void *args,void *data){
3000305c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003060:	e24dd024 	sub	sp, sp, #36	; 0x24
30003064:	e58d000c 	str	r0, [sp, #12]
30003068:	e58d1008 	str	r1, [sp, #8]
3000306c:	e58d2004 	str	r2, [sp, #4]
30003070:	e58d3000 	str	r3, [sp]
	acoral_sr cpu_sr;
	acoral_u32 prio;
	acoral_comm_policy_data_t *policy_data;
	policy_data=(acoral_comm_policy_data_t *)data;
30003074:	e59d3000 	ldr	r3, [sp]
30003078:	e58d301c 	str	r3, [sp, #28]
	thread->cpu=policy_data->cpu;
3000307c:	e59d301c 	ldr	r3, [sp, #28]
30003080:	e5d32000 	ldrb	r2, [r3]
30003084:	e59d300c 	ldr	r3, [sp, #12]
30003088:	e5c32006 	strb	r2, [r3, #6]
	prio=policy_data->prio;
3000308c:	e59d301c 	ldr	r3, [sp, #28]
30003090:	e5d33001 	ldrb	r3, [r3, #1]
30003094:	e58d3018 	str	r3, [sp, #24]
	if(policy_data->prio_type==ACORAL_BASE_PRIO){
30003098:	e59d301c 	ldr	r3, [sp, #28]
3000309c:	e5d33002 	ldrb	r3, [r3, #2]
300030a0:	e3530002 	cmp	r3, #2
300030a4:	1a000007 	bne	300030c8 <comm_policy_thread_init+0x6c>
		prio+=ACORAL_BASE_PRIO_MIN;
300030a8:	e59d3018 	ldr	r3, [sp, #24]
300030ac:	e2833002 	add	r3, r3, #2
300030b0:	e58d3018 	str	r3, [sp, #24]
		if(prio>=ACORAL_BASE_PRIO_MAX)
300030b4:	e59d3018 	ldr	r3, [sp, #24]
300030b8:	e3530026 	cmp	r3, #38	; 0x26
300030bc:	9a000001 	bls	300030c8 <comm_policy_thread_init+0x6c>
			prio=ACORAL_BASE_PRIO_MAX-1;
300030c0:	e3a03026 	mov	r3, #38	; 0x26
300030c4:	e58d3018 	str	r3, [sp, #24]
	}
	thread->prio=prio;
300030c8:	e59d3018 	ldr	r3, [sp, #24]
300030cc:	e20320ff 	and	r2, r3, #255	; 0xff
300030d0:	e59d300c 	ldr	r3, [sp, #12]
300030d4:	e5c32005 	strb	r2, [r3, #5]
	if(acoral_thread_init(thread,route,acoral_thread_exit,args)!=0){
300030d8:	e59d000c 	ldr	r0, [sp, #12]
300030dc:	e59d1008 	ldr	r1, [sp, #8]
300030e0:	e59f206c 	ldr	r2, [pc, #108]	; 30003154 <comm_policy_thread_init+0xf8>
300030e4:	e59d3004 	ldr	r3, [sp, #4]
300030e8:	ebfffee2 	bl	30002c78 <acoral_thread_init>
300030ec:	e1a03000 	mov	r3, r0
300030f0:	e3530000 	cmp	r3, #0
300030f4:	0a00000e 	beq	30003134 <comm_policy_thread_init+0xd8>
		acoral_printerr("No thread stack:%s\n",thread->name);
300030f8:	e59d300c 	ldr	r3, [sp, #12]
300030fc:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30003100:	e59f0050 	ldr	r0, [pc, #80]	; 30003158 <comm_policy_thread_init+0xfc>
30003104:	e1a01003 	mov	r1, r3
30003108:	eb0020c6 	bl	3000b428 <acoral_print>
		HAL_ENTER_CRITICAL();
3000310c:	ebfff978 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30003110:	e1a03000 	mov	r3, r0
30003114:	e58d3014 	str	r3, [sp, #20]
		acoral_release_res((acoral_res_t *)thread);
30003118:	e59d300c 	ldr	r3, [sp, #12]
3000311c:	e1a00003 	mov	r0, r3
30003120:	eb00013e 	bl	30003620 <acoral_release_res>
		HAL_EXIT_CRITICAL();
30003124:	e59d0014 	ldr	r0, [sp, #20]
30003128:	ebfff96f 	bl	300016ec <HAL_INTR_RESTORE>
		return -1;
3000312c:	e3e03000 	mvn	r3, #0
30003130:	ea000003 	b	30003144 <comm_policy_thread_init+0xe8>
	}
        /*将线程就绪，并重新调度*/
	acoral_resume_thread(thread);
30003134:	e59d000c 	ldr	r0, [sp, #12]
30003138:	ebfffdc5 	bl	30002854 <acoral_resume_thread>
	return thread->res.id;
3000313c:	e59d300c 	ldr	r3, [sp, #12]
30003140:	e5933000 	ldr	r3, [r3]
}
30003144:	e1a00003 	mov	r0, r3
30003148:	e28dd024 	add	sp, sp, #36	; 0x24
3000314c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003150:	e12fff1e 	bx	lr
30003154:	30002a68 	.word	0x30002a68
30003158:	30025eec 	.word	0x30025eec

3000315c <comm_policy_init>:

void comm_policy_init(){
3000315c:	e92d4008 	push	{r3, lr}
	comm_policy.type=ACORAL_SCHED_POLICY_COMM;	
30003160:	e59f3044 	ldr	r3, [pc, #68]	; 300031ac <comm_policy_init+0x50>
30003164:	e3a02015 	mov	r2, #21
30003168:	e5c32008 	strb	r2, [r3, #8]
	comm_policy.policy_thread_init=comm_policy_thread_init;	
3000316c:	e59f3038 	ldr	r3, [pc, #56]	; 300031ac <comm_policy_init+0x50>
30003170:	e59f2038 	ldr	r2, [pc, #56]	; 300031b0 <comm_policy_init+0x54>
30003174:	e583200c 	str	r2, [r3, #12]
	comm_policy.policy_thread_release=NULL;	
30003178:	e59f302c 	ldr	r3, [pc, #44]	; 300031ac <comm_policy_init+0x50>
3000317c:	e3a02000 	mov	r2, #0
30003180:	e5832010 	str	r2, [r3, #16]
	comm_policy.delay_deal=NULL;	
30003184:	e59f3020 	ldr	r3, [pc, #32]	; 300031ac <comm_policy_init+0x50>
30003188:	e3a02000 	mov	r2, #0
3000318c:	e5832014 	str	r2, [r3, #20]
	comm_policy.name="comm";	
30003190:	e59f3014 	ldr	r3, [pc, #20]	; 300031ac <comm_policy_init+0x50>
30003194:	e59f2018 	ldr	r2, [pc, #24]	; 300031b4 <comm_policy_init+0x58>
30003198:	e5832018 	str	r2, [r3, #24]
	acoral_register_sched_policy(&comm_policy);
3000319c:	e59f0008 	ldr	r0, [pc, #8]	; 300031ac <comm_policy_init+0x50>
300031a0:	ebfffb2e 	bl	30001e60 <acoral_register_sched_policy>
}
300031a4:	e8bd4008 	pop	{r3, lr}
300031a8:	e12fff1e 	bx	lr
300031ac:	3002a110 	.word	0x3002a110
300031b0:	3000305c 	.word	0x3000305c
300031b4:	30025f00 	.word	0x30025f00

300031b8 <acoral_create_pool>:
/*================================
 *    create a kind of resource pool
 *       创建某一资源内存池
 *       pool_ctrl---资源内存池管理块
 *================================*/
acoral_err acoral_create_pool(acoral_pool_ctrl_t *pool_ctrl){
300031b8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300031bc:	e24dd014 	sub	sp, sp, #20
300031c0:	e58d0004 	str	r0, [sp, #4]
  	acoral_pool_t *pool;
	if(pool_ctrl->num>=pool_ctrl->max_pools)
300031c4:	e59d3004 	ldr	r3, [sp, #4]
300031c8:	e593200c 	ldr	r2, [r3, #12]
300031cc:	e59d3004 	ldr	r3, [sp, #4]
300031d0:	e5933010 	ldr	r3, [r3, #16]
300031d4:	e1520003 	cmp	r2, r3
300031d8:	3a000001 	bcc	300031e4 <acoral_create_pool+0x2c>
	    return ACORAL_RES_MAX_POOL;
300031dc:	e3a030f3 	mov	r3, #243	; 0xf3
300031e0:	ea000049 	b	3000330c <acoral_create_pool+0x154>
  	pool=acoral_get_free_pool();
300031e4:	eb000188 	bl	3000380c <acoral_get_free_pool>
300031e8:	e1a03000 	mov	r3, r0
300031ec:	e58d300c 	str	r3, [sp, #12]
	if(pool==NULL)
300031f0:	e59d300c 	ldr	r3, [sp, #12]
300031f4:	e3530000 	cmp	r3, #0
300031f8:	1a000001 	bne	30003204 <acoral_create_pool+0x4c>
		return ACORAL_RES_NO_POOL;
300031fc:	e3a030f1 	mov	r3, #241	; 0xf1
30003200:	ea000041 	b	3000330c <acoral_create_pool+0x154>
	pool->id=pool_ctrl->type<<ACORAL_RES_TYPE_BIT|pool->id;
30003204:	e59d3004 	ldr	r3, [sp, #4]
30003208:	e5933000 	ldr	r3, [r3]
3000320c:	e1a02503 	lsl	r2, r3, #10
30003210:	e59d300c 	ldr	r3, [sp, #12]
30003214:	e5933008 	ldr	r3, [r3, #8]
30003218:	e1823003 	orr	r3, r2, r3
3000321c:	e1a02003 	mov	r2, r3
30003220:	e59d300c 	ldr	r3, [sp, #12]
30003224:	e5832008 	str	r2, [r3, #8]
	pool->size=pool_ctrl->size;
30003228:	e59d3004 	ldr	r3, [sp, #4]
3000322c:	e5932004 	ldr	r2, [r3, #4]
30003230:	e59d300c 	ldr	r3, [sp, #12]
30003234:	e583200c 	str	r2, [r3, #12]
	pool->num=pool_ctrl->num_per_pool;
30003238:	e59d3004 	ldr	r3, [sp, #4]
3000323c:	e5932008 	ldr	r2, [r3, #8]
30003240:	e59d300c 	ldr	r3, [sp, #12]
30003244:	e5832010 	str	r2, [r3, #16]
	pool->base_adr=(void *)acoral_malloc(pool->size*pool->num);
30003248:	e59d300c 	ldr	r3, [sp, #12]
3000324c:	e593300c 	ldr	r3, [r3, #12]
30003250:	e59d200c 	ldr	r2, [sp, #12]
30003254:	e5922010 	ldr	r2, [r2, #16]
30003258:	e0030392 	mul	r3, r2, r3
3000325c:	e1a00003 	mov	r0, r3
30003260:	eb000cd4 	bl	300065b8 <buddy_malloc>
30003264:	e1a02000 	mov	r2, r0
30003268:	e59d300c 	ldr	r3, [sp, #12]
3000326c:	e5832000 	str	r2, [r3]
	if(pool->base_adr==NULL)
30003270:	e59d300c 	ldr	r3, [sp, #12]
30003274:	e5933000 	ldr	r3, [r3]
30003278:	e3530000 	cmp	r3, #0
3000327c:	1a000001 	bne	30003288 <acoral_create_pool+0xd0>
		return ACORAL_RES_NO_MEM;
30003280:	e3a030f2 	mov	r3, #242	; 0xf2
30003284:	ea000020 	b	3000330c <acoral_create_pool+0x154>
	pool->res_free=pool->base_adr;
30003288:	e59d300c 	ldr	r3, [sp, #12]
3000328c:	e5932000 	ldr	r2, [r3]
30003290:	e59d300c 	ldr	r3, [sp, #12]
30003294:	e5832004 	str	r2, [r3, #4]
	pool->free_num=pool->num;
30003298:	e59d300c 	ldr	r3, [sp, #12]
3000329c:	e5932010 	ldr	r2, [r3, #16]
300032a0:	e59d300c 	ldr	r3, [sp, #12]
300032a4:	e5832018 	str	r2, [r3, #24]
	pool->ctrl=pool_ctrl;
300032a8:	e59d300c 	ldr	r3, [sp, #12]
300032ac:	e59d2004 	ldr	r2, [sp, #4]
300032b0:	e583201c 	str	r2, [r3, #28]
	acoral_pool_res_init(pool);
300032b4:	e59d000c 	ldr	r0, [sp, #12]
300032b8:	eb00018a 	bl	300038e8 <acoral_pool_res_init>
        acoral_list_add2_tail(&pool->ctrl_list,pool_ctrl->pools);
300032bc:	e59d300c 	ldr	r3, [sp, #12]
300032c0:	e2832020 	add	r2, r3, #32
300032c4:	e59d3004 	ldr	r3, [sp, #4]
300032c8:	e5933018 	ldr	r3, [r3, #24]
300032cc:	e1a00002 	mov	r0, r2
300032d0:	e1a01003 	mov	r1, r3
300032d4:	eb001bc1 	bl	3000a1e0 <acoral_list_add2_tail>
	acoral_list_add2_tail(&pool->free_list,pool_ctrl->free_pools);
300032d8:	e59d300c 	ldr	r3, [sp, #12]
300032dc:	e2832028 	add	r2, r3, #40	; 0x28
300032e0:	e59d3004 	ldr	r3, [sp, #4]
300032e4:	e5933014 	ldr	r3, [r3, #20]
300032e8:	e1a00002 	mov	r0, r2
300032ec:	e1a01003 	mov	r1, r3
300032f0:	eb001bba 	bl	3000a1e0 <acoral_list_add2_tail>
	pool_ctrl->num++;
300032f4:	e59d3004 	ldr	r3, [sp, #4]
300032f8:	e593300c 	ldr	r3, [r3, #12]
300032fc:	e2832001 	add	r2, r3, #1
30003300:	e59d3004 	ldr	r3, [sp, #4]
30003304:	e583200c 	str	r2, [r3, #12]
	return 0;
30003308:	e3a03000 	mov	r3, #0
}
3000330c:	e1a00003 	mov	r0, r3
30003310:	e28dd014 	add	sp, sp, #20
30003314:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003318:	e12fff1e 	bx	lr

3000331c <acoral_release_pool>:
/*================================
 *      release a kind of resource pool
 *       释放某一资源内存池所有资源
 *       pool_ctrl--资源内存池管理块
 *================================*/
void acoral_release_pool(acoral_pool_ctrl_t *pool_ctrl){
3000331c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003320:	e24dd01c 	sub	sp, sp, #28
30003324:	e58d0004 	str	r0, [sp, #4]
	acoral_pool_t *pool;
	acoral_list_t *list,*head;
	head=pool_ctrl->pools;
30003328:	e59d3004 	ldr	r3, [sp, #4]
3000332c:	e5933018 	ldr	r3, [r3, #24]
30003330:	e58d3014 	str	r3, [sp, #20]
	if(acoral_list_empty(head))
30003334:	e59d3014 	ldr	r3, [sp, #20]
30003338:	e5932000 	ldr	r2, [r3]
3000333c:	e59d3014 	ldr	r3, [sp, #20]
30003340:	e1520003 	cmp	r2, r3
30003344:	0a000027 	beq	300033e8 <acoral_release_pool+0xcc>
	  	return;
   for(list=head->next;list!=head;list=list->next){
30003348:	e59d3014 	ldr	r3, [sp, #20]
3000334c:	e5933000 	ldr	r3, [r3]
30003350:	e58d3010 	str	r3, [sp, #16]
30003354:	ea00001e 	b	300033d4 <acoral_release_pool+0xb8>
			pool=list_entry(list,acoral_pool_t,free_list);
30003358:	e59d3010 	ldr	r3, [sp, #16]
3000335c:	e2433028 	sub	r3, r3, #40	; 0x28
30003360:	e58d300c 	str	r3, [sp, #12]
		    acoral_list_del(&pool->ctrl_list);
30003364:	e59d300c 	ldr	r3, [sp, #12]
30003368:	e2833020 	add	r3, r3, #32
3000336c:	e1a00003 	mov	r0, r3
30003370:	eb001bad 	bl	3000a22c <acoral_list_del>
			acoral_list_del(&pool->free_list);
30003374:	e59d300c 	ldr	r3, [sp, #12]
30003378:	e2833028 	add	r3, r3, #40	; 0x28
3000337c:	e1a00003 	mov	r0, r3
30003380:	eb001ba9 	bl	3000a22c <acoral_list_del>
			acoral_free(pool->base_adr);
30003384:	e59d300c 	ldr	r3, [sp, #12]
30003388:	e5933000 	ldr	r3, [r3]
3000338c:	e1a00003 	mov	r0, r3
30003390:	eb000cc0 	bl	30006698 <buddy_free>
			pool->base_adr=(void *)acoral_free_res_pool;
30003394:	e59f305c 	ldr	r3, [pc, #92]	; 300033f8 <acoral_release_pool+0xdc>
30003398:	e5932000 	ldr	r2, [r3]
3000339c:	e59d300c 	ldr	r3, [sp, #12]
300033a0:	e5832000 	str	r2, [r3]
			pool->id=pool->id&ACORAL_POOL_INDEX_MASK;
300033a4:	e59d300c 	ldr	r3, [sp, #12]
300033a8:	e5933008 	ldr	r3, [r3, #8]
300033ac:	e1a03b03 	lsl	r3, r3, #22
300033b0:	e1a03b23 	lsr	r3, r3, #22
300033b4:	e59d200c 	ldr	r2, [sp, #12]
300033b8:	e5823008 	str	r3, [r2, #8]
			acoral_free_res_pool=pool;
300033bc:	e59f3034 	ldr	r3, [pc, #52]	; 300033f8 <acoral_release_pool+0xdc>
300033c0:	e59d200c 	ldr	r2, [sp, #12]
300033c4:	e5832000 	str	r2, [r3]
	acoral_pool_t *pool;
	acoral_list_t *list,*head;
	head=pool_ctrl->pools;
	if(acoral_list_empty(head))
	  	return;
   for(list=head->next;list!=head;list=list->next){
300033c8:	e59d3010 	ldr	r3, [sp, #16]
300033cc:	e5933000 	ldr	r3, [r3]
300033d0:	e58d3010 	str	r3, [sp, #16]
300033d4:	e59d2010 	ldr	r2, [sp, #16]
300033d8:	e59d3014 	ldr	r3, [sp, #20]
300033dc:	e1520003 	cmp	r2, r3
300033e0:	1affffdc 	bne	30003358 <acoral_release_pool+0x3c>
300033e4:	ea000000 	b	300033ec <acoral_release_pool+0xd0>
void acoral_release_pool(acoral_pool_ctrl_t *pool_ctrl){
	acoral_pool_t *pool;
	acoral_list_t *list,*head;
	head=pool_ctrl->pools;
	if(acoral_list_empty(head))
	  	return;
300033e8:	e1a00000 	nop			; (mov r0, r0)
			acoral_free(pool->base_adr);
			pool->base_adr=(void *)acoral_free_res_pool;
			pool->id=pool->id&ACORAL_POOL_INDEX_MASK;
			acoral_free_res_pool=pool;
	}
}
300033ec:	e28dd01c 	add	sp, sp, #28
300033f0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300033f4:	e12fff1e 	bx	lr
300033f8:	3002a12c 	.word	0x3002a12c

300033fc <acoral_collect_pool>:
/*================================
 *    collect a kind of resource pool
 *       回收某一资源内存池空闲的内存池
 *       pool_ctrl--资源内存池管理块
 *================================*/
void acoral_collect_pool(acoral_pool_ctrl_t *pool_ctrl){
300033fc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003400:	e24dd01c 	sub	sp, sp, #28
30003404:	e58d0004 	str	r0, [sp, #4]
	acoral_pool_t *pool;
	acoral_list_t *list,*head;
	head=pool_ctrl->free_pools;
30003408:	e59d3004 	ldr	r3, [sp, #4]
3000340c:	e5933014 	ldr	r3, [r3, #20]
30003410:	e58d3014 	str	r3, [sp, #20]
	if(acoral_list_empty(head))
30003414:	e59d3014 	ldr	r3, [sp, #20]
30003418:	e5932000 	ldr	r2, [r3]
3000341c:	e59d3014 	ldr	r3, [sp, #20]
30003420:	e1520003 	cmp	r2, r3
30003424:	0a00002d 	beq	300034e0 <acoral_collect_pool+0xe4>
	  	return;
        for(list=head->next;list!=head;list=list->next){
30003428:	e59d3014 	ldr	r3, [sp, #20]
3000342c:	e5933000 	ldr	r3, [r3]
30003430:	e58d3010 	str	r3, [sp, #16]
30003434:	ea000024 	b	300034cc <acoral_collect_pool+0xd0>
			pool=list_entry(list,acoral_pool_t,free_list);
30003438:	e59d3010 	ldr	r3, [sp, #16]
3000343c:	e2433028 	sub	r3, r3, #40	; 0x28
30003440:	e58d300c 	str	r3, [sp, #12]
	       	if(pool->free_num==pool->num){
30003444:	e59d300c 	ldr	r3, [sp, #12]
30003448:	e5932018 	ldr	r2, [r3, #24]
3000344c:	e59d300c 	ldr	r3, [sp, #12]
30003450:	e5933010 	ldr	r3, [r3, #16]
30003454:	e1520003 	cmp	r2, r3
30003458:	1a000018 	bne	300034c0 <acoral_collect_pool+0xc4>
		      	acoral_list_del(&pool->ctrl_list);
3000345c:	e59d300c 	ldr	r3, [sp, #12]
30003460:	e2833020 	add	r3, r3, #32
30003464:	e1a00003 	mov	r0, r3
30003468:	eb001b6f 	bl	3000a22c <acoral_list_del>
				acoral_list_del(&pool->free_list);
3000346c:	e59d300c 	ldr	r3, [sp, #12]
30003470:	e2833028 	add	r3, r3, #40	; 0x28
30003474:	e1a00003 	mov	r0, r3
30003478:	eb001b6b 	bl	3000a22c <acoral_list_del>
				acoral_free(pool->base_adr);
3000347c:	e59d300c 	ldr	r3, [sp, #12]
30003480:	e5933000 	ldr	r3, [r3]
30003484:	e1a00003 	mov	r0, r3
30003488:	eb000c82 	bl	30006698 <buddy_free>
				pool->base_adr=(void *)acoral_free_res_pool;
3000348c:	e59f305c 	ldr	r3, [pc, #92]	; 300034f0 <acoral_collect_pool+0xf4>
30003490:	e5932000 	ldr	r2, [r3]
30003494:	e59d300c 	ldr	r3, [sp, #12]
30003498:	e5832000 	str	r2, [r3]
				pool->id=pool->id&ACORAL_POOL_INDEX_MASK;
3000349c:	e59d300c 	ldr	r3, [sp, #12]
300034a0:	e5933008 	ldr	r3, [r3, #8]
300034a4:	e1a03b03 	lsl	r3, r3, #22
300034a8:	e1a03b23 	lsr	r3, r3, #22
300034ac:	e59d200c 	ldr	r2, [sp, #12]
300034b0:	e5823008 	str	r3, [r2, #8]
				acoral_free_res_pool=pool;
300034b4:	e59f3034 	ldr	r3, [pc, #52]	; 300034f0 <acoral_collect_pool+0xf4>
300034b8:	e59d200c 	ldr	r2, [sp, #12]
300034bc:	e5832000 	str	r2, [r3]
	acoral_pool_t *pool;
	acoral_list_t *list,*head;
	head=pool_ctrl->free_pools;
	if(acoral_list_empty(head))
	  	return;
        for(list=head->next;list!=head;list=list->next){
300034c0:	e59d3010 	ldr	r3, [sp, #16]
300034c4:	e5933000 	ldr	r3, [r3]
300034c8:	e58d3010 	str	r3, [sp, #16]
300034cc:	e59d2010 	ldr	r2, [sp, #16]
300034d0:	e59d3014 	ldr	r3, [sp, #20]
300034d4:	e1520003 	cmp	r2, r3
300034d8:	1affffd6 	bne	30003438 <acoral_collect_pool+0x3c>
300034dc:	ea000000 	b	300034e4 <acoral_collect_pool+0xe8>
void acoral_collect_pool(acoral_pool_ctrl_t *pool_ctrl){
	acoral_pool_t *pool;
	acoral_list_t *list,*head;
	head=pool_ctrl->free_pools;
	if(acoral_list_empty(head))
	  	return;
300034e0:	e1a00000 	nop			; (mov r0, r0)
				pool->base_adr=(void *)acoral_free_res_pool;
				pool->id=pool->id&ACORAL_POOL_INDEX_MASK;
				acoral_free_res_pool=pool;
			}
	}
}
300034e4:	e28dd01c 	add	sp, sp, #28
300034e8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300034ec:	e12fff1e 	bx	lr
300034f0:	3002a12c 	.word	0x3002a12c

300034f4 <acoral_get_res>:
/*================================
 *    get a kind of resource 
 *       获取某一资源
 *       pool_ctrl--资源池管理块
 *================================*/
acoral_res_t *acoral_get_res(acoral_pool_ctrl_t *pool_ctrl){
300034f4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300034f8:	e24dd01c 	sub	sp, sp, #28
300034fc:	e58d0004 	str	r0, [sp, #4]
	acoral_sr cpu_sr;
  	acoral_list_t *first;
	acoral_res_t *res;
	acoral_pool_t *pool;
	HAL_ENTER_CRITICAL();
30003500:	ebfff87b 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30003504:	e1a03000 	mov	r3, r0
30003508:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&pool_ctrl->lock);
	first=pool_ctrl->free_pools->next;
3000350c:	e59d3004 	ldr	r3, [sp, #4]
30003510:	e5933014 	ldr	r3, [r3, #20]
30003514:	e5933000 	ldr	r3, [r3]
30003518:	e58d300c 	str	r3, [sp, #12]
	if(acoral_list_empty(first)){
3000351c:	e59d300c 	ldr	r3, [sp, #12]
30003520:	e5932000 	ldr	r2, [r3]
30003524:	e59d300c 	ldr	r3, [sp, #12]
30003528:	e1520003 	cmp	r2, r3
3000352c:	1a00000c 	bne	30003564 <acoral_get_res+0x70>
	  	if(acoral_create_pool(pool_ctrl)){
30003530:	e59d0004 	ldr	r0, [sp, #4]
30003534:	ebffff1f 	bl	300031b8 <acoral_create_pool>
30003538:	e1a03000 	mov	r3, r0
3000353c:	e3530000 	cmp	r3, #0
30003540:	0a000003 	beq	30003554 <acoral_get_res+0x60>
			acoral_spin_unlock(&pool_ctrl->lock);
			HAL_EXIT_CRITICAL();
30003544:	e59d0008 	ldr	r0, [sp, #8]
30003548:	ebfff867 	bl	300016ec <HAL_INTR_RESTORE>
			return NULL;
3000354c:	e3a03000 	mov	r3, #0
30003550:	ea00002e 	b	30003610 <acoral_get_res+0x11c>
		}
		else{
			first=pool_ctrl->free_pools->next;
30003554:	e59d3004 	ldr	r3, [sp, #4]
30003558:	e5933014 	ldr	r3, [r3, #20]
3000355c:	e5933000 	ldr	r3, [r3]
30003560:	e58d300c 	str	r3, [sp, #12]
		}
	}
	pool=list_entry(first,acoral_pool_t,free_list);
30003564:	e59d300c 	ldr	r3, [sp, #12]
30003568:	e2433028 	sub	r3, r3, #40	; 0x28
3000356c:	e58d3014 	str	r3, [sp, #20]
	res=(acoral_res_t *)pool->res_free;
30003570:	e59d3014 	ldr	r3, [sp, #20]
30003574:	e5933004 	ldr	r3, [r3, #4]
30003578:	e58d3010 	str	r3, [sp, #16]
	pool->res_free=(void *)((acoral_u8 *)pool->base_adr+res->next_id*pool->size);
3000357c:	e59d3014 	ldr	r3, [sp, #20]
30003580:	e5932000 	ldr	r2, [r3]
30003584:	e59d3010 	ldr	r3, [sp, #16]
30003588:	e1d330b0 	ldrh	r3, [r3]
3000358c:	e59d1014 	ldr	r1, [sp, #20]
30003590:	e591100c 	ldr	r1, [r1, #12]
30003594:	e0030391 	mul	r3, r1, r3
30003598:	e0822003 	add	r2, r2, r3
3000359c:	e59d3014 	ldr	r3, [sp, #20]
300035a0:	e5832004 	str	r2, [r3, #4]
	res->id=(res->id>>(ACORAL_RES_INDEX_INIT_BIT-ACORAL_RES_INDEX_BIT))&ACORAL_RES_INDEX_MASK|pool->id;
300035a4:	e59d3010 	ldr	r3, [sp, #16]
300035a8:	e5933000 	ldr	r3, [r3]
300035ac:	e1a03143 	asr	r3, r3, #2
300035b0:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
300035b4:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
300035b8:	e3c3303f 	bic	r3, r3, #63	; 0x3f
300035bc:	e59d2014 	ldr	r2, [sp, #20]
300035c0:	e5922008 	ldr	r2, [r2, #8]
300035c4:	e1832002 	orr	r2, r3, r2
300035c8:	e59d3010 	ldr	r3, [sp, #16]
300035cc:	e5832000 	str	r2, [r3]
        pool->free_num--;
300035d0:	e59d3014 	ldr	r3, [sp, #20]
300035d4:	e5933018 	ldr	r3, [r3, #24]
300035d8:	e2432001 	sub	r2, r3, #1
300035dc:	e59d3014 	ldr	r3, [sp, #20]
300035e0:	e5832018 	str	r2, [r3, #24]
#ifdef CFG_TEST
	acoral_print("Alloc res 0x%x\n",res);
#endif
	if(!pool->free_num){
300035e4:	e59d3014 	ldr	r3, [sp, #20]
300035e8:	e5933018 	ldr	r3, [r3, #24]
300035ec:	e3530000 	cmp	r3, #0
300035f0:	1a000003 	bne	30003604 <acoral_get_res+0x110>
	  	acoral_list_del(&pool->free_list);
300035f4:	e59d3014 	ldr	r3, [sp, #20]
300035f8:	e2833028 	add	r3, r3, #40	; 0x28
300035fc:	e1a00003 	mov	r0, r3
30003600:	eb001b09 	bl	3000a22c <acoral_list_del>
	}
	acoral_spin_unlock(&pool_ctrl->lock);
	HAL_EXIT_CRITICAL();
30003604:	e59d0008 	ldr	r0, [sp, #8]
30003608:	ebfff837 	bl	300016ec <HAL_INTR_RESTORE>
	return res;
3000360c:	e59d3010 	ldr	r3, [sp, #16]
}
30003610:	e1a00003 	mov	r0, r3
30003614:	e28dd01c 	add	sp, sp, #28
30003618:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000361c:	e12fff1e 	bx	lr

30003620 <acoral_release_res>:
/*================================
 *    release a kind of resource 
 *       释放某一资源
 *      res--资源数据块
 *================================*/
void acoral_release_res(acoral_res_t *res){
30003620:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003624:	e24dd01c 	sub	sp, sp, #28
30003628:	e58d0004 	str	r0, [sp, #4]
  	acoral_pool_t *pool;
	acoral_u32 index;
  	void *tmp;
       	acoral_pool_ctrl_t *pool_ctrl;
	if(!ACORAL_ASSERT(res,"Res Release\n"))
3000362c:	e59f3168 	ldr	r3, [pc, #360]	; 3000379c <acoral_release_res+0x17c>
30003630:	e59d0004 	ldr	r0, [sp, #4]
30003634:	e1a01003 	mov	r1, r3
30003638:	eb00017f 	bl	30003c3c <acoral_assert_res>
3000363c:	e1a03000 	mov	r3, r0
30003640:	e3530000 	cmp	r3, #0
30003644:	0a00004e 	beq	30003784 <acoral_release_res+0x164>
		return;
	pool=acoral_get_pool_by_id(res->id);
30003648:	e59d3004 	ldr	r3, [sp, #4]
3000364c:	e5933000 	ldr	r3, [r3]
30003650:	e1a00003 	mov	r0, r3
30003654:	eb000053 	bl	300037a8 <acoral_get_pool_by_id>
30003658:	e1a03000 	mov	r3, r0
3000365c:	e58d3008 	str	r3, [sp, #8]
	if(pool==NULL){
30003660:	e59d3008 	ldr	r3, [sp, #8]
30003664:	e3530000 	cmp	r3, #0
30003668:	1a000002 	bne	30003678 <acoral_release_res+0x58>
		acoral_printerr("Res release Err\n");
3000366c:	e59f012c 	ldr	r0, [pc, #300]	; 300037a0 <acoral_release_res+0x180>
30003670:	eb001f6c 	bl	3000b428 <acoral_print>
		return;
30003674:	ea000045 	b	30003790 <acoral_release_res+0x170>
	}
 	pool_ctrl=pool->ctrl;
30003678:	e59d3008 	ldr	r3, [sp, #8]
3000367c:	e593301c 	ldr	r3, [r3, #28]
30003680:	e58d3014 	str	r3, [sp, #20]
	acoral_spin_lock(&pool_ctrl->lock);
	if((void *)res<pool->base_adr){
30003684:	e59d3008 	ldr	r3, [sp, #8]
30003688:	e5932000 	ldr	r2, [r3]
3000368c:	e59d3004 	ldr	r3, [sp, #4]
30003690:	e1520003 	cmp	r2, r3
30003694:	9a000002 	bls	300036a4 <acoral_release_res+0x84>
		acoral_printerr("Err Res\n");
30003698:	e59f0104 	ldr	r0, [pc, #260]	; 300037a4 <acoral_release_res+0x184>
3000369c:	eb001f61 	bl	3000b428 <acoral_print>
		return;
300036a0:	ea00003a 	b	30003790 <acoral_release_res+0x170>
	}
	index=(((acoral_u32)res-(acoral_u32)pool->base_adr)/pool->size);
300036a4:	e59d2004 	ldr	r2, [sp, #4]
300036a8:	e59d3008 	ldr	r3, [sp, #8]
300036ac:	e5933000 	ldr	r3, [r3]
300036b0:	e0632002 	rsb	r2, r3, r2
300036b4:	e59d3008 	ldr	r3, [sp, #8]
300036b8:	e593300c 	ldr	r3, [r3, #12]
300036bc:	e1a00002 	mov	r0, r2
300036c0:	e1a01003 	mov	r1, r3
300036c4:	eb008796 	bl	30025524 <__aeabi_uidiv>
300036c8:	e1a03000 	mov	r3, r0
300036cc:	e58d300c 	str	r3, [sp, #12]
	if(index>=pool->num){
300036d0:	e59d3008 	ldr	r3, [sp, #8]
300036d4:	e5932010 	ldr	r2, [r3, #16]
300036d8:	e59d300c 	ldr	r3, [sp, #12]
300036dc:	e1520003 	cmp	r2, r3
300036e0:	8a000002 	bhi	300036f0 <acoral_release_res+0xd0>
		acoral_printerr("Err Res\n");
300036e4:	e59f00b8 	ldr	r0, [pc, #184]	; 300037a4 <acoral_release_res+0x184>
300036e8:	eb001f4e 	bl	3000b428 <acoral_print>
		return;
300036ec:	ea000027 	b	30003790 <acoral_release_res+0x170>
	}
#ifdef CFG_TEST
	acoral_print("Free res 0x%x\n",res);
#endif
	tmp=pool->res_free;
300036f0:	e59d3008 	ldr	r3, [sp, #8]
300036f4:	e5933004 	ldr	r3, [r3, #4]
300036f8:	e58d3010 	str	r3, [sp, #16]
	pool->res_free=(void *)res;
300036fc:	e59d3008 	ldr	r3, [sp, #8]
30003700:	e59d2004 	ldr	r2, [sp, #4]
30003704:	e5832004 	str	r2, [r3, #4]
	res->id=index<<ACORAL_RES_INDEX_INIT_BIT;
30003708:	e59d300c 	ldr	r3, [sp, #12]
3000370c:	e1a03803 	lsl	r3, r3, #16
30003710:	e1a02003 	mov	r2, r3
30003714:	e59d3004 	ldr	r3, [sp, #4]
30003718:	e5832000 	str	r2, [r3]
	res->next_id=((acoral_res_t *)tmp)->id>>ACORAL_RES_INDEX_INIT_BIT;
3000371c:	e59d3010 	ldr	r3, [sp, #16]
30003720:	e5933000 	ldr	r3, [r3]
30003724:	e1a03843 	asr	r3, r3, #16
30003728:	e1a03803 	lsl	r3, r3, #16
3000372c:	e1a02823 	lsr	r2, r3, #16
30003730:	e59d3004 	ldr	r3, [sp, #4]
30003734:	e1c320b0 	strh	r2, [r3]
	pool->free_num++;
30003738:	e59d3008 	ldr	r3, [sp, #8]
3000373c:	e5933018 	ldr	r3, [r3, #24]
30003740:	e2832001 	add	r2, r3, #1
30003744:	e59d3008 	ldr	r3, [sp, #8]
30003748:	e5832018 	str	r2, [r3, #24]
	if(acoral_list_empty(&pool->free_list))
3000374c:	e59d3008 	ldr	r3, [sp, #8]
30003750:	e5932028 	ldr	r2, [r3, #40]	; 0x28
30003754:	e59d3008 	ldr	r3, [sp, #8]
30003758:	e2833028 	add	r3, r3, #40	; 0x28
3000375c:	e1520003 	cmp	r2, r3
30003760:	1a000009 	bne	3000378c <acoral_release_res+0x16c>
	  	acoral_list_add(&pool->free_list,pool_ctrl->free_pools);
30003764:	e59d3008 	ldr	r3, [sp, #8]
30003768:	e2832028 	add	r2, r3, #40	; 0x28
3000376c:	e59d3014 	ldr	r3, [sp, #20]
30003770:	e5933014 	ldr	r3, [r3, #20]
30003774:	e1a00002 	mov	r0, r2
30003778:	e1a01003 	mov	r1, r3
3000377c:	eb001a84 	bl	3000a194 <acoral_list_add>
	acoral_spin_unlock(&pool_ctrl->lock);
	return;
30003780:	ea000002 	b	30003790 <acoral_release_res+0x170>
  	acoral_pool_t *pool;
	acoral_u32 index;
  	void *tmp;
       	acoral_pool_ctrl_t *pool_ctrl;
	if(!ACORAL_ASSERT(res,"Res Release\n"))
		return;
30003784:	e1a00000 	nop			; (mov r0, r0)
30003788:	ea000000 	b	30003790 <acoral_release_res+0x170>
	res->next_id=((acoral_res_t *)tmp)->id>>ACORAL_RES_INDEX_INIT_BIT;
	pool->free_num++;
	if(acoral_list_empty(&pool->free_list))
	  	acoral_list_add(&pool->free_list,pool_ctrl->free_pools);
	acoral_spin_unlock(&pool_ctrl->lock);
	return;
3000378c:	e1a00000 	nop			; (mov r0, r0)
}
30003790:	e28dd01c 	add	sp, sp, #28
30003794:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003798:	e12fff1e 	bx	lr
3000379c:	30025f08 	.word	0x30025f08
300037a0:	30025f18 	.word	0x30025f18
300037a4:	30025f2c 	.word	0x30025f2c

300037a8 <acoral_get_pool_by_id>:
/*================================
 *    get a kind of resource by res_id
 *  根据资源ID获取某一资源对应的资源池
 *      res_id--资源ID
 *================================*/
acoral_pool_t *acoral_get_pool_by_id(acoral_id res_id){
300037a8:	e24dd010 	sub	sp, sp, #16
300037ac:	e58d0004 	str	r0, [sp, #4]
  	acoral_u32 index;
	index=(res_id&ACORAL_POOL_INDEX_MASK)>>ACORAL_POOL_INDEX_BIT;
300037b0:	e59d3004 	ldr	r3, [sp, #4]
300037b4:	e1a03b03 	lsl	r3, r3, #22
300037b8:	e1a03b23 	lsr	r3, r3, #22
300037bc:	e58d300c 	str	r3, [sp, #12]
	if(index<ACORAL_MAX_POOLS)
300037c0:	e59d300c 	ldr	r3, [sp, #12]
300037c4:	e3530027 	cmp	r3, #39	; 0x27
300037c8:	8a00000a 	bhi	300037f8 <acoral_get_pool_by_id+0x50>
	  	return acoral_pools+index;
300037cc:	e59d200c 	ldr	r2, [sp, #12]
300037d0:	e1a03002 	mov	r3, r2
300037d4:	e1a03083 	lsl	r3, r3, #1
300037d8:	e0833002 	add	r3, r3, r2
300037dc:	e1a03103 	lsl	r3, r3, #2
300037e0:	e0833002 	add	r3, r3, r2
300037e4:	e1a03103 	lsl	r3, r3, #2
300037e8:	e1a02003 	mov	r2, r3
300037ec:	e59f3014 	ldr	r3, [pc, #20]	; 30003808 <acoral_get_pool_by_id+0x60>
300037f0:	e0823003 	add	r3, r2, r3
300037f4:	ea000000 	b	300037fc <acoral_get_pool_by_id+0x54>
	return NULL;
300037f8:	e3a03000 	mov	r3, #0
}
300037fc:	e1a00003 	mov	r0, r3
30003800:	e28dd010 	add	sp, sp, #16
30003804:	e12fff1e 	bx	lr
30003808:	3002a890 	.word	0x3002a890

3000380c <acoral_get_free_pool>:

/*================================
 *    get a free pool
 *     获取空闲资源池
 *================================*/
acoral_pool_t *acoral_get_free_pool(){
3000380c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003810:	e24dd00c 	sub	sp, sp, #12
	acoral_sr cpu_sr;
  	acoral_pool_t *tmp;
	HAL_ENTER_CRITICAL();
30003814:	ebfff7b6 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30003818:	e1a03000 	mov	r3, r0
3000381c:	e58d3000 	str	r3, [sp]
	tmp=acoral_free_res_pool;
30003820:	e59f3044 	ldr	r3, [pc, #68]	; 3000386c <acoral_get_free_pool+0x60>
30003824:	e5933000 	ldr	r3, [r3]
30003828:	e58d3004 	str	r3, [sp, #4]
	if(NULL!=tmp){
3000382c:	e59d3004 	ldr	r3, [sp, #4]
30003830:	e3530000 	cmp	r3, #0
30003834:	0a000005 	beq	30003850 <acoral_get_free_pool+0x44>
		acoral_spin_lock(&tmp->lock);
		acoral_free_res_pool=*(void **)tmp->base_adr;
30003838:	e59d3004 	ldr	r3, [sp, #4]
3000383c:	e5933000 	ldr	r3, [r3]
30003840:	e5933000 	ldr	r3, [r3]
30003844:	e1a02003 	mov	r2, r3
30003848:	e59f301c 	ldr	r3, [pc, #28]	; 3000386c <acoral_get_free_pool+0x60>
3000384c:	e5832000 	str	r2, [r3]
		acoral_spin_unlock(&tmp->lock);
	}
	HAL_EXIT_CRITICAL();
30003850:	e59d0000 	ldr	r0, [sp]
30003854:	ebfff7a4 	bl	300016ec <HAL_INTR_RESTORE>
	return tmp;
30003858:	e59d3004 	ldr	r3, [sp, #4]
}
3000385c:	e1a00003 	mov	r0, r3
30003860:	e28dd00c 	add	sp, sp, #12
30003864:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003868:	e12fff1e 	bx	lr
3000386c:	3002a12c 	.word	0x3002a12c

30003870 <acoral_get_res_by_id>:

acoral_res_t * acoral_get_res_by_id(acoral_id id){
30003870:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003874:	e24dd014 	sub	sp, sp, #20
30003878:	e58d0004 	str	r0, [sp, #4]
  	acoral_pool_t *pool;
	acoral_u32 index;
	pool=acoral_get_pool_by_id(id);
3000387c:	e59d0004 	ldr	r0, [sp, #4]
30003880:	ebffffc8 	bl	300037a8 <acoral_get_pool_by_id>
30003884:	e1a03000 	mov	r3, r0
30003888:	e58d3008 	str	r3, [sp, #8]
	if(pool==NULL)
3000388c:	e59d3008 	ldr	r3, [sp, #8]
30003890:	e3530000 	cmp	r3, #0
30003894:	1a000001 	bne	300038a0 <acoral_get_res_by_id+0x30>
		return NULL;
30003898:	e3a03000 	mov	r3, #0
3000389c:	ea00000d 	b	300038d8 <acoral_get_res_by_id+0x68>
	index=(id&ACORAL_RES_INDEX_MASK)>>ACORAL_RES_INDEX_BIT;
300038a0:	e59d3004 	ldr	r3, [sp, #4]
300038a4:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
300038a8:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
300038ac:	e3c3303f 	bic	r3, r3, #63	; 0x3f
300038b0:	e1a03743 	asr	r3, r3, #14
300038b4:	e58d300c 	str	r3, [sp, #12]
     	return (acoral_res_t *)((acoral_u8 *)pool->base_adr+index*pool->size);
300038b8:	e59d3008 	ldr	r3, [sp, #8]
300038bc:	e5933000 	ldr	r3, [r3]
300038c0:	e1a02003 	mov	r2, r3
300038c4:	e59d3008 	ldr	r3, [sp, #8]
300038c8:	e593300c 	ldr	r3, [r3, #12]
300038cc:	e59d100c 	ldr	r1, [sp, #12]
300038d0:	e0030391 	mul	r3, r1, r3
300038d4:	e0823003 	add	r3, r2, r3
}
300038d8:	e1a00003 	mov	r0, r3
300038dc:	e28dd014 	add	sp, sp, #20
300038e0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300038e4:	e12fff1e 	bx	lr

300038e8 <acoral_pool_res_init>:

/*================================
 *       a kind of resource initial 
 *        资源初始化
 *================================*/
void acoral_pool_res_init(acoral_pool_t * pool){
300038e8:	e24dd018 	sub	sp, sp, #24
300038ec:	e58d0004 	str	r0, [sp, #4]
	acoral_res_t *res;
	acoral_u32 i;
	acoral_u8 *pblk;
	acoral_u32 blks;
	blks=pool->num;
300038f0:	e59d3004 	ldr	r3, [sp, #4]
300038f4:	e5933010 	ldr	r3, [r3, #16]
300038f8:	e58d3014 	str	r3, [sp, #20]
	res=(acoral_res_t *)pool->base_adr;
300038fc:	e59d3004 	ldr	r3, [sp, #4]
30003900:	e5933000 	ldr	r3, [r3]
30003904:	e58d3008 	str	r3, [sp, #8]
     	pblk=(acoral_u8 *)pool->base_adr + pool->size;
30003908:	e59d3004 	ldr	r3, [sp, #4]
3000390c:	e5933000 	ldr	r3, [r3]
30003910:	e1a02003 	mov	r2, r3
30003914:	e59d3004 	ldr	r3, [sp, #4]
30003918:	e593300c 	ldr	r3, [r3, #12]
3000391c:	e0823003 	add	r3, r2, r3
30003920:	e58d3010 	str	r3, [sp, #16]
	for (i = 0; i < (blks - 1); i++) {
30003924:	e3a03000 	mov	r3, #0
30003928:	e58d300c 	str	r3, [sp, #12]
3000392c:	ea000016 	b	3000398c <acoral_pool_res_init+0xa4>
	    res->id=i<<ACORAL_RES_INDEX_INIT_BIT;
30003930:	e59d300c 	ldr	r3, [sp, #12]
30003934:	e1a03803 	lsl	r3, r3, #16
30003938:	e1a02003 	mov	r2, r3
3000393c:	e59d3008 	ldr	r3, [sp, #8]
30003940:	e5832000 	str	r2, [r3]
	    res->next_id=i+1;
30003944:	e59d300c 	ldr	r3, [sp, #12]
30003948:	e1a03803 	lsl	r3, r3, #16
3000394c:	e1a03823 	lsr	r3, r3, #16
30003950:	e2833001 	add	r3, r3, #1
30003954:	e1a03803 	lsl	r3, r3, #16
30003958:	e1a02823 	lsr	r2, r3, #16
3000395c:	e59d3008 	ldr	r3, [sp, #8]
30003960:	e1c320b0 	strh	r2, [r3]
	    res=(acoral_res_t *)pblk;
30003964:	e59d3010 	ldr	r3, [sp, #16]
30003968:	e58d3008 	str	r3, [sp, #8]
	    pblk+=pool->size;
3000396c:	e59d3004 	ldr	r3, [sp, #4]
30003970:	e593300c 	ldr	r3, [r3, #12]
30003974:	e59d2010 	ldr	r2, [sp, #16]
30003978:	e0823003 	add	r3, r2, r3
3000397c:	e58d3010 	str	r3, [sp, #16]
	acoral_u8 *pblk;
	acoral_u32 blks;
	blks=pool->num;
	res=(acoral_res_t *)pool->base_adr;
     	pblk=(acoral_u8 *)pool->base_adr + pool->size;
	for (i = 0; i < (blks - 1); i++) {
30003980:	e59d300c 	ldr	r3, [sp, #12]
30003984:	e2833001 	add	r3, r3, #1
30003988:	e58d300c 	str	r3, [sp, #12]
3000398c:	e59d3014 	ldr	r3, [sp, #20]
30003990:	e2432001 	sub	r2, r3, #1
30003994:	e59d300c 	ldr	r3, [sp, #12]
30003998:	e1520003 	cmp	r2, r3
3000399c:	8affffe3 	bhi	30003930 <acoral_pool_res_init+0x48>
	    res->id=i<<ACORAL_RES_INDEX_INIT_BIT;
	    res->next_id=i+1;
	    res=(acoral_res_t *)pblk;
	    pblk+=pool->size;
	}
	res->id=blks-1<<ACORAL_RES_INDEX_INIT_BIT;
300039a0:	e59d3014 	ldr	r3, [sp, #20]
300039a4:	e2433001 	sub	r3, r3, #1
300039a8:	e1a03803 	lsl	r3, r3, #16
300039ac:	e1a02003 	mov	r2, r3
300039b0:	e59d3008 	ldr	r3, [sp, #8]
300039b4:	e5832000 	str	r2, [r3]
	res->next_id=0;
300039b8:	e59d3008 	ldr	r3, [sp, #8]
300039bc:	e3a02000 	mov	r2, #0
300039c0:	e1c320b0 	strh	r2, [r3]
}
300039c4:	e28dd018 	add	sp, sp, #24
300039c8:	e12fff1e 	bx	lr

300039cc <acoral_pools_init>:
/*================================
 *        resource pool initial 
 *              资源池初始化
 *================================*/
void  acoral_pools_init(void)
{
300039cc:	e24dd008 	sub	sp, sp, #8
    acoral_pool_t  *pool;
    acoral_u32 i;
    pool = &acoral_pools[0];
300039d0:	e59f3090 	ldr	r3, [pc, #144]	; 30003a68 <acoral_pools_init+0x9c>
300039d4:	e58d3000 	str	r3, [sp]
    for (i = 0; i < (ACORAL_MAX_POOLS - 1); i++) {
300039d8:	e3a03000 	mov	r3, #0
300039dc:	e58d3004 	str	r3, [sp, #4]
300039e0:	ea000015 	b	30003a3c <acoral_pools_init+0x70>
        pool->base_adr= (void *)&acoral_pools[i+1];
300039e4:	e59d3004 	ldr	r3, [sp, #4]
300039e8:	e2832001 	add	r2, r3, #1
300039ec:	e1a03002 	mov	r3, r2
300039f0:	e1a03083 	lsl	r3, r3, #1
300039f4:	e0833002 	add	r3, r3, r2
300039f8:	e1a03103 	lsl	r3, r3, #2
300039fc:	e0833002 	add	r3, r3, r2
30003a00:	e1a03103 	lsl	r3, r3, #2
30003a04:	e1a02003 	mov	r2, r3
30003a08:	e59f3058 	ldr	r3, [pc, #88]	; 30003a68 <acoral_pools_init+0x9c>
30003a0c:	e0822003 	add	r2, r2, r3
30003a10:	e59d3000 	ldr	r3, [sp]
30003a14:	e5832000 	str	r2, [r3]
		pool->id=i;
30003a18:	e59d2004 	ldr	r2, [sp, #4]
30003a1c:	e59d3000 	ldr	r3, [sp]
30003a20:	e5832008 	str	r2, [r3, #8]
        pool++;
30003a24:	e59d3000 	ldr	r3, [sp]
30003a28:	e2833034 	add	r3, r3, #52	; 0x34
30003a2c:	e58d3000 	str	r3, [sp]
void  acoral_pools_init(void)
{
    acoral_pool_t  *pool;
    acoral_u32 i;
    pool = &acoral_pools[0];
    for (i = 0; i < (ACORAL_MAX_POOLS - 1); i++) {
30003a30:	e59d3004 	ldr	r3, [sp, #4]
30003a34:	e2833001 	add	r3, r3, #1
30003a38:	e58d3004 	str	r3, [sp, #4]
30003a3c:	e59d3004 	ldr	r3, [sp, #4]
30003a40:	e3530026 	cmp	r3, #38	; 0x26
30003a44:	9affffe6 	bls	300039e4 <acoral_pools_init+0x18>
        pool->base_adr= (void *)&acoral_pools[i+1];
		pool->id=i;
        pool++;
		acoral_spin_init(&pool->lock);
    }
    pool->base_adr= (void *)0;
30003a48:	e59d3000 	ldr	r3, [sp]
30003a4c:	e3a02000 	mov	r2, #0
30003a50:	e5832000 	str	r2, [r3]
    acoral_free_res_pool = &acoral_pools[0];
30003a54:	e59f3010 	ldr	r3, [pc, #16]	; 30003a6c <acoral_pools_init+0xa0>
30003a58:	e59f2008 	ldr	r2, [pc, #8]	; 30003a68 <acoral_pools_init+0x9c>
30003a5c:	e5832000 	str	r2, [r3]
	acoral_spin_init(&acoral_free_res_pool->lock);
}
30003a60:	e28dd008 	add	sp, sp, #8
30003a64:	e12fff1e 	bx	lr
30003a68:	3002a890 	.word	0x3002a890
30003a6c:	3002a12c 	.word	0x3002a12c

30003a70 <acoral_pool_ctrl_init>:
/*================================
 *        resource pool control initial 
 *              资源池控制块初始化
 *================================*/
void acoral_pool_ctrl_init(acoral_pool_ctrl_t *pool_ctrl)
{
30003a70:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003a74:	e24dd014 	sub	sp, sp, #20
30003a78:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 size;
	pool_ctrl->free_pools=&pool_ctrl->list[0];
30003a7c:	e59d3004 	ldr	r3, [sp, #4]
30003a80:	e283201c 	add	r2, r3, #28
30003a84:	e59d3004 	ldr	r3, [sp, #4]
30003a88:	e5832014 	str	r2, [r3, #20]
	pool_ctrl->pools=&pool_ctrl->list[1];
30003a8c:	e59d3004 	ldr	r3, [sp, #4]
30003a90:	e2832024 	add	r2, r3, #36	; 0x24
30003a94:	e59d3004 	ldr	r3, [sp, #4]
30003a98:	e5832018 	str	r2, [r3, #24]
	pool_ctrl->num=0;
30003a9c:	e59d3004 	ldr	r3, [sp, #4]
30003aa0:	e3a02000 	mov	r2, #0
30003aa4:	e583200c 	str	r2, [r3, #12]
	acoral_init_list(pool_ctrl->pools);
30003aa8:	e59d3004 	ldr	r3, [sp, #4]
30003aac:	e5933018 	ldr	r3, [r3, #24]
30003ab0:	e59d2004 	ldr	r2, [sp, #4]
30003ab4:	e5922018 	ldr	r2, [r2, #24]
30003ab8:	e5832000 	str	r2, [r3]
30003abc:	e59d3004 	ldr	r3, [sp, #4]
30003ac0:	e5933018 	ldr	r3, [r3, #24]
30003ac4:	e59d2004 	ldr	r2, [sp, #4]
30003ac8:	e5922018 	ldr	r2, [r2, #24]
30003acc:	e5832004 	str	r2, [r3, #4]
    acoral_init_list(pool_ctrl->free_pools);
30003ad0:	e59d3004 	ldr	r3, [sp, #4]
30003ad4:	e5933014 	ldr	r3, [r3, #20]
30003ad8:	e59d2004 	ldr	r2, [sp, #4]
30003adc:	e5922014 	ldr	r2, [r2, #20]
30003ae0:	e5832000 	str	r2, [r3]
30003ae4:	e59d3004 	ldr	r3, [sp, #4]
30003ae8:	e5933014 	ldr	r3, [r3, #20]
30003aec:	e59d2004 	ldr	r2, [sp, #4]
30003af0:	e5922014 	ldr	r2, [r2, #20]
30003af4:	e5832004 	str	r2, [r3, #4]
    acoral_spin_init(&pool_ctrl->lock);
	/*调整pool的对象个数以最大化利用分配了的内存*/
	size=acoral_malloc_size(pool_ctrl->size*pool_ctrl->num_per_pool);
30003af8:	e59d3004 	ldr	r3, [sp, #4]
30003afc:	e5933004 	ldr	r3, [r3, #4]
30003b00:	e59d2004 	ldr	r2, [sp, #4]
30003b04:	e5922008 	ldr	r2, [r2, #8]
30003b08:	e0030392 	mul	r3, r2, r3
30003b0c:	e1a00003 	mov	r0, r3
30003b10:	eb000a7f 	bl	30006514 <buddy_malloc_size>
30003b14:	e1a03000 	mov	r3, r0
30003b18:	e58d300c 	str	r3, [sp, #12]
	if(size<pool_ctrl->size){
30003b1c:	e59d3004 	ldr	r3, [sp, #4]
30003b20:	e5932004 	ldr	r2, [r3, #4]
30003b24:	e59d300c 	ldr	r3, [sp, #12]
30003b28:	e1520003 	cmp	r2, r3
30003b2c:	9a000003 	bls	30003b40 <acoral_pool_ctrl_init+0xd0>
		pool_ctrl->num_per_pool=0;
30003b30:	e59d3004 	ldr	r3, [sp, #4]
30003b34:	e3a02000 	mov	r2, #0
30003b38:	e5832008 	str	r2, [r3, #8]
30003b3c:	ea00000a 	b	30003b6c <acoral_pool_ctrl_init+0xfc>
	}
	else{
		pool_ctrl->num_per_pool=size/pool_ctrl->size;
30003b40:	e59d3004 	ldr	r3, [sp, #4]
30003b44:	e5933004 	ldr	r3, [r3, #4]
30003b48:	e59d000c 	ldr	r0, [sp, #12]
30003b4c:	e1a01003 	mov	r1, r3
30003b50:	eb008673 	bl	30025524 <__aeabi_uidiv>
30003b54:	e1a03000 	mov	r3, r0
30003b58:	e1a02003 	mov	r2, r3
30003b5c:	e59d3004 	ldr	r3, [sp, #4]
30003b60:	e5832008 	str	r2, [r3, #8]
		acoral_create_pool(pool_ctrl);
30003b64:	e59d0004 	ldr	r0, [sp, #4]
30003b68:	ebfffd92 	bl	300031b8 <acoral_create_pool>
	}
}
30003b6c:	e28dd014 	add	sp, sp, #20
30003b70:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003b74:	e12fff1e 	bx	lr

30003b78 <acoral_obj_pool_init>:
 *        user resource api
 *         用户资源相关接口
 *================================*/

void acoral_obj_pool_init(acoral_pool_ctrl_t *pool_ctrl)
{
30003b78:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003b7c:	e24dd00c 	sub	sp, sp, #12
30003b80:	e58d0004 	str	r0, [sp, #4]
	pool_ctrl->type=ACORAL_RES_USER;
30003b84:	e59d3004 	ldr	r3, [sp, #4]
30003b88:	e3a02006 	mov	r2, #6
30003b8c:	e5832000 	str	r2, [r3]
	pool_ctrl->size+=sizeof(acoral_res_t);
30003b90:	e59d3004 	ldr	r3, [sp, #4]
30003b94:	e5933004 	ldr	r3, [r3, #4]
30003b98:	e2832004 	add	r2, r3, #4
30003b9c:	e59d3004 	ldr	r3, [sp, #4]
30003ba0:	e5832004 	str	r2, [r3, #4]
	acoral_pool_ctrl_init(pool_ctrl);
30003ba4:	e59d0004 	ldr	r0, [sp, #4]
30003ba8:	ebffffb0 	bl	30003a70 <acoral_pool_ctrl_init>
}
30003bac:	e28dd00c 	add	sp, sp, #12
30003bb0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003bb4:	e12fff1e 	bx	lr

30003bb8 <acoral_obj_pool_release>:

void acoral_obj_pool_release(acoral_pool_ctrl_t *pool_ctrl){
30003bb8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003bbc:	e24dd00c 	sub	sp, sp, #12
30003bc0:	e58d0004 	str	r0, [sp, #4]
	 acoral_release_pool(pool_ctrl);
30003bc4:	e59d0004 	ldr	r0, [sp, #4]
30003bc8:	ebfffdd3 	bl	3000331c <acoral_release_pool>
}
30003bcc:	e28dd00c 	add	sp, sp, #12
30003bd0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003bd4:	e12fff1e 	bx	lr

30003bd8 <acoral_get_obj>:

void *acoral_get_obj(acoral_pool_ctrl_t *pool_ctrl){
30003bd8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003bdc:	e24dd00c 	sub	sp, sp, #12
30003be0:	e58d0004 	str	r0, [sp, #4]
	return (void *)((acoral_char *)acoral_get_res(pool_ctrl)+sizeof(acoral_res_t));
30003be4:	e59d0004 	ldr	r0, [sp, #4]
30003be8:	ebfffe41 	bl	300034f4 <acoral_get_res>
30003bec:	e1a03000 	mov	r3, r0
30003bf0:	e2833004 	add	r3, r3, #4
}
30003bf4:	e1a00003 	mov	r0, r3
30003bf8:	e28dd00c 	add	sp, sp, #12
30003bfc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003c00:	e12fff1e 	bx	lr

30003c04 <acoral_free_obj>:

void acoral_free_obj(void *obj){
30003c04:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003c08:	e24dd00c 	sub	sp, sp, #12
30003c0c:	e58d0004 	str	r0, [sp, #4]
	acoral_release_res((acoral_char *)obj-sizeof(acoral_res_t));
30003c10:	e59d3004 	ldr	r3, [sp, #4]
30003c14:	e2433004 	sub	r3, r3, #4
30003c18:	e1a00003 	mov	r0, r3
30003c1c:	ebfffe7f 	bl	30003620 <acoral_release_res>
}
30003c20:	e28dd00c 	add	sp, sp, #12
30003c24:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003c28:	e12fff1e 	bx	lr

30003c2c <acoral_res_sys_init>:

/*================================
 *        resource  system initial 
 *          资源系统初始化
 *================================*/
void acoral_res_sys_init(){
30003c2c:	e92d4008 	push	{r3, lr}
	acoral_pools_init();
30003c30:	ebffff65 	bl	300039cc <acoral_pools_init>
}
30003c34:	e8bd4008 	pop	{r3, lr}
30003c38:	e12fff1e 	bx	lr

30003c3c <acoral_assert_res>:

acoral_char acoral_assert_res(acoral_res_t *res,acoral_8 *assert){
30003c3c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003c40:	e24dd00c 	sub	sp, sp, #12
30003c44:	e58d0004 	str	r0, [sp, #4]
30003c48:	e58d1000 	str	r1, [sp]
	if(res==NULL||acoral_get_res_by_id(res->id)!=res){
30003c4c:	e59d3004 	ldr	r3, [sp, #4]
30003c50:	e3530000 	cmp	r3, #0
30003c54:	0a000007 	beq	30003c78 <acoral_assert_res+0x3c>
30003c58:	e59d3004 	ldr	r3, [sp, #4]
30003c5c:	e5933000 	ldr	r3, [r3]
30003c60:	e1a00003 	mov	r0, r3
30003c64:	ebffff01 	bl	30003870 <acoral_get_res_by_id>
30003c68:	e1a02000 	mov	r2, r0
30003c6c:	e59d3004 	ldr	r3, [sp, #4]
30003c70:	e1520003 	cmp	r2, r3
30003c74:	0a000009 	beq	30003ca0 <acoral_assert_res+0x64>
		acoral_printerr("%s\n",assert);
30003c78:	e59f0034 	ldr	r0, [pc, #52]	; 30003cb4 <acoral_assert_res+0x78>
30003c7c:	e59d1000 	ldr	r1, [sp]
30003c80:	eb001de8 	bl	3000b428 <acoral_print>
		acoral_printerr("Err res's id:%x\n",res->id);
30003c84:	e59d3004 	ldr	r3, [sp, #4]
30003c88:	e5933000 	ldr	r3, [r3]
30003c8c:	e59f0024 	ldr	r0, [pc, #36]	; 30003cb8 <acoral_assert_res+0x7c>
30003c90:	e1a01003 	mov	r1, r3
30003c94:	eb001de3 	bl	3000b428 <acoral_print>
		return false;
30003c98:	e3a03000 	mov	r3, #0
30003c9c:	ea000000 	b	30003ca4 <acoral_assert_res+0x68>
	}
	return true;
30003ca0:	e3a03001 	mov	r3, #1
}
30003ca4:	e1a00003 	mov	r0, r3
30003ca8:	e28dd00c 	add	sp, sp, #12
30003cac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003cb0:	e12fff1e 	bx	lr
30003cb4:	30025f38 	.word	0x30025f38
30003cb8:	30025f3c 	.word	0x30025f3c

30003cbc <acoral_intr_sys_init>:

/*===========================                                                                                                                 
*Initialize the interrupt      
*中断初始化函数
*===========================*/
void acoral_intr_sys_init(){
30003cbc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003cc0:	e24dd00c 	sub	sp, sp, #12
	acoral_u32 i;
	acoral_vector index;
      
    /*关中断*/
	acoral_intr_disable();
30003cc4:	ebfff683 	bl	300016d8 <HAL_INTR_DISABLE>

    /*中断嵌套标志初始化*/
    HAL_INTR_NESTING_INIT();
30003cc8:	ebfff693 	bl	3000171c <hal_intr_nesting_init_comm>

    /*中断底层初始化函数*/
	HAL_INTR_INIT();
30003ccc:	ebfff2a5 	bl	30000768 <hal_intr_init>


    /*对于每个中断，设置默认的服务处理程序，然后屏蔽该中断*/
	for(i=HAL_INTR_MIN;i<=HAL_INTR_MAX;i++){
30003cd0:	e3a03000 	mov	r3, #0
30003cd4:	e58d3000 	str	r3, [sp]
30003cd8:	ea00001b 	b	30003d4c <acoral_intr_sys_init+0x90>
		HAL_TRANSLATE_VECTOR(i,index);
30003cdc:	e59d3000 	ldr	r3, [sp]
30003ce0:	e58d3004 	str	r3, [sp, #4]
		intr_table[index].isr=acoral_default_isr;
30003ce4:	e59d2004 	ldr	r2, [sp, #4]
30003ce8:	e59f0074 	ldr	r0, [pc, #116]	; 30003d64 <acoral_intr_sys_init+0xa8>
30003cec:	e3a01008 	mov	r1, #8
30003cf0:	e1a03002 	mov	r3, r2
30003cf4:	e1a03183 	lsl	r3, r3, #3
30003cf8:	e0623003 	rsb	r3, r2, r3
30003cfc:	e1a03103 	lsl	r3, r3, #2
30003d00:	e0833000 	add	r3, r3, r0
30003d04:	e0833001 	add	r3, r3, r1
30003d08:	e59f2058 	ldr	r2, [pc, #88]	; 30003d68 <acoral_intr_sys_init+0xac>
30003d0c:	e5832000 	str	r2, [r3]
		intr_table[index].type=ACORAL_COMM_INTR;
30003d10:	e59d2004 	ldr	r2, [sp, #4]
30003d14:	e59f1048 	ldr	r1, [pc, #72]	; 30003d64 <acoral_intr_sys_init+0xa8>
30003d18:	e1a03002 	mov	r3, r2
30003d1c:	e1a03183 	lsl	r3, r3, #3
30003d20:	e0623003 	rsb	r3, r2, r3
30003d24:	e1a03103 	lsl	r3, r3, #2
30003d28:	e0833001 	add	r3, r3, r1
30003d2c:	e3a02001 	mov	r2, #1
30003d30:	e5c32005 	strb	r2, [r3, #5]
		acoral_intr_mask(i);
30003d34:	e59d3000 	ldr	r3, [sp]
30003d38:	e1a00003 	mov	r0, r3
30003d3c:	eb000078 	bl	30003f24 <acoral_intr_mask>
    /*中断底层初始化函数*/
	HAL_INTR_INIT();


    /*对于每个中断，设置默认的服务处理程序，然后屏蔽该中断*/
	for(i=HAL_INTR_MIN;i<=HAL_INTR_MAX;i++){
30003d40:	e59d3000 	ldr	r3, [sp]
30003d44:	e2833001 	add	r3, r3, #1
30003d48:	e58d3000 	str	r3, [sp]
30003d4c:	e59d3000 	ldr	r3, [sp]
30003d50:	e3530031 	cmp	r3, #49	; 0x31
30003d54:	9affffe0 	bls	30003cdc <acoral_intr_sys_init+0x20>
		HAL_TRANSLATE_VECTOR(i,index);
		intr_table[index].isr=acoral_default_isr;
		intr_table[index].type=ACORAL_COMM_INTR;
		acoral_intr_mask(i);
	}
}
30003d58:	e28dd00c 	add	sp, sp, #12
30003d5c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003d60:	e12fff1e 	bx	lr
30003d64:	3002a150 	.word	0x3002a150
30003d68:	300041b4 	.word	0x300041b4

30003d6c <acoral_intr_attach>:

/*===========================                                                                                                                 
*Binding the isr t0 the Vector      
*将服务函数isr绑定到中断向量Vector
*===========================*/
acoral_32 acoral_intr_attach(acoral_vector vector,void (*isr)(acoral_vector)){
30003d6c:	e24dd010 	sub	sp, sp, #16
30003d70:	e58d0004 	str	r0, [sp, #4]
30003d74:	e58d1000 	str	r1, [sp]
  	acoral_vector index;
   	HAL_TRANSLATE_VECTOR(vector,index);
30003d78:	e59d3004 	ldr	r3, [sp, #4]
30003d7c:	e58d300c 	str	r3, [sp, #12]
	if(intr_table[index].type!=ACORAL_RT_INTR)
30003d80:	e59d200c 	ldr	r2, [sp, #12]
30003d84:	e59f1058 	ldr	r1, [pc, #88]	; 30003de4 <acoral_intr_attach+0x78>
30003d88:	e1a03002 	mov	r3, r2
30003d8c:	e1a03183 	lsl	r3, r3, #3
30003d90:	e0623003 	rsb	r3, r2, r3
30003d94:	e1a03103 	lsl	r3, r3, #2
30003d98:	e0833001 	add	r3, r3, r1
30003d9c:	e5d33005 	ldrb	r3, [r3, #5]
30003da0:	e3530003 	cmp	r3, #3
30003da4:	0a00000a 	beq	30003dd4 <acoral_intr_attach+0x68>
		intr_table[index].isr =isr;
30003da8:	e59d200c 	ldr	r2, [sp, #12]
30003dac:	e59f0030 	ldr	r0, [pc, #48]	; 30003de4 <acoral_intr_attach+0x78>
30003db0:	e3a01008 	mov	r1, #8
30003db4:	e1a03002 	mov	r3, r2
30003db8:	e1a03183 	lsl	r3, r3, #3
30003dbc:	e0623003 	rsb	r3, r2, r3
30003dc0:	e1a03103 	lsl	r3, r3, #2
30003dc4:	e0833000 	add	r3, r3, r0
30003dc8:	e0833001 	add	r3, r3, r1
30003dcc:	e59d2000 	ldr	r2, [sp]
30003dd0:	e5832000 	str	r2, [r3]
	else
		HAL_INTR_ATTACH(vector,isr);
	return 0;
30003dd4:	e3a03000 	mov	r3, #0
}
30003dd8:	e1a00003 	mov	r0, r3
30003ddc:	e28dd010 	add	sp, sp, #16
30003de0:	e12fff1e 	bx	lr
30003de4:	3002a150 	.word	0x3002a150

30003de8 <acoral_intr_detach>:

/*===========================                                                                                                                 
*Detach the  isr from the Vector      
*将中断的服务函数设为默认的
*===========================*/
acoral_32 acoral_intr_detach(acoral_vector vector){
30003de8:	e24dd010 	sub	sp, sp, #16
30003dec:	e58d0004 	str	r0, [sp, #4]
  	acoral_vector index;
   	HAL_TRANSLATE_VECTOR(vector,index);
30003df0:	e59d3004 	ldr	r3, [sp, #4]
30003df4:	e58d300c 	str	r3, [sp, #12]
	intr_table[index].isr =acoral_default_isr;
30003df8:	e59d200c 	ldr	r2, [sp, #12]
30003dfc:	e59f0030 	ldr	r0, [pc, #48]	; 30003e34 <acoral_intr_detach+0x4c>
30003e00:	e3a01008 	mov	r1, #8
30003e04:	e1a03002 	mov	r3, r2
30003e08:	e1a03183 	lsl	r3, r3, #3
30003e0c:	e0623003 	rsb	r3, r2, r3
30003e10:	e1a03103 	lsl	r3, r3, #2
30003e14:	e0833000 	add	r3, r3, r0
30003e18:	e0833001 	add	r3, r3, r1
30003e1c:	e59f2014 	ldr	r2, [pc, #20]	; 30003e38 <acoral_intr_detach+0x50>
30003e20:	e5832000 	str	r2, [r3]
	return 0;
30003e24:	e3a03000 	mov	r3, #0
}
30003e28:	e1a00003 	mov	r0, r3
30003e2c:	e28dd010 	add	sp, sp, #16
30003e30:	e12fff1e 	bx	lr
30003e34:	3002a150 	.word	0x3002a150
30003e38:	300041b4 	.word	0x300041b4

30003e3c <acoral_intr_unmask>:

/*===========================                                                                                                                 
*Enable the interrupt      
*使能中断
*===========================*/
void acoral_intr_unmask(acoral_vector vector){
30003e3c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003e40:	e24dd014 	sub	sp, sp, #20
30003e44:	e58d0004 	str	r0, [sp, #4]
  	acoral_vector index;
	if(vector>HAL_INTR_MAX)
30003e48:	e59d3004 	ldr	r3, [sp, #4]
30003e4c:	e3530031 	cmp	r3, #49	; 0x31
30003e50:	ca00002e 	bgt	30003f10 <acoral_intr_unmask+0xd4>
		return;
   	HAL_TRANSLATE_VECTOR(vector,index);
30003e54:	e59d3004 	ldr	r3, [sp, #4]
30003e58:	e58d300c 	str	r3, [sp, #12]

        /*如果中断的使能函数不为空，就调用该使能函数*/
	if(intr_table[index].unmask!=NULL&&intr_table[index].type==ACORAL_COMM_INTR){
30003e5c:	e59d200c 	ldr	r2, [sp, #12]
30003e60:	e59f00b8 	ldr	r0, [pc, #184]	; 30003f20 <acoral_intr_unmask+0xe4>
30003e64:	e3a01018 	mov	r1, #24
30003e68:	e1a03002 	mov	r3, r2
30003e6c:	e1a03183 	lsl	r3, r3, #3
30003e70:	e0623003 	rsb	r3, r2, r3
30003e74:	e1a03103 	lsl	r3, r3, #2
30003e78:	e0833000 	add	r3, r3, r0
30003e7c:	e0833001 	add	r3, r3, r1
30003e80:	e5933000 	ldr	r3, [r3]
30003e84:	e3530000 	cmp	r3, #0
30003e88:	0a000021 	beq	30003f14 <acoral_intr_unmask+0xd8>
30003e8c:	e59d200c 	ldr	r2, [sp, #12]
30003e90:	e59f1088 	ldr	r1, [pc, #136]	; 30003f20 <acoral_intr_unmask+0xe4>
30003e94:	e1a03002 	mov	r3, r2
30003e98:	e1a03183 	lsl	r3, r3, #3
30003e9c:	e0623003 	rsb	r3, r2, r3
30003ea0:	e1a03103 	lsl	r3, r3, #2
30003ea4:	e0833001 	add	r3, r3, r1
30003ea8:	e5d33005 	ldrb	r3, [r3, #5]
30003eac:	e3530001 	cmp	r3, #1
30003eb0:	1a000017 	bne	30003f14 <acoral_intr_unmask+0xd8>
		intr_table[index].unmask(vector);
30003eb4:	e59d200c 	ldr	r2, [sp, #12]
30003eb8:	e59f0060 	ldr	r0, [pc, #96]	; 30003f20 <acoral_intr_unmask+0xe4>
30003ebc:	e3a01018 	mov	r1, #24
30003ec0:	e1a03002 	mov	r3, r2
30003ec4:	e1a03183 	lsl	r3, r3, #3
30003ec8:	e0623003 	rsb	r3, r2, r3
30003ecc:	e1a03103 	lsl	r3, r3, #2
30003ed0:	e0833000 	add	r3, r3, r0
30003ed4:	e0833001 	add	r3, r3, r1
30003ed8:	e5933000 	ldr	r3, [r3]
30003edc:	e59d0004 	ldr	r0, [sp, #4]
30003ee0:	e1a0e00f 	mov	lr, pc
30003ee4:	e12fff13 	bx	r3
		/*将中断状态设为真*/
		intr_table[index].state=true;
30003ee8:	e59d200c 	ldr	r2, [sp, #12]
30003eec:	e59f102c 	ldr	r1, [pc, #44]	; 30003f20 <acoral_intr_unmask+0xe4>
30003ef0:	e1a03002 	mov	r3, r2
30003ef4:	e1a03183 	lsl	r3, r3, #3
30003ef8:	e0623003 	rsb	r3, r2, r3
30003efc:	e1a03103 	lsl	r3, r3, #2
30003f00:	e0833001 	add	r3, r3, r1
30003f04:	e3a02001 	mov	r2, #1
30003f08:	e5c32004 	strb	r2, [r3, #4]
30003f0c:	ea000000 	b	30003f14 <acoral_intr_unmask+0xd8>
*使能中断
*===========================*/
void acoral_intr_unmask(acoral_vector vector){
  	acoral_vector index;
	if(vector>HAL_INTR_MAX)
		return;
30003f10:	e1a00000 	nop			; (mov r0, r0)
	if(intr_table[index].unmask!=NULL&&intr_table[index].type==ACORAL_COMM_INTR){
		intr_table[index].unmask(vector);
		/*将中断状态设为真*/
		intr_table[index].state=true;
	}
}
30003f14:	e28dd014 	add	sp, sp, #20
30003f18:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003f1c:	e12fff1e 	bx	lr
30003f20:	3002a150 	.word	0x3002a150

30003f24 <acoral_intr_mask>:

/*===========================                                                                                                                 
*Disable the interrupt       
*除能中断
*===========================*/
void acoral_intr_mask(acoral_vector vector){
30003f24:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003f28:	e24dd014 	sub	sp, sp, #20
30003f2c:	e58d0004 	str	r0, [sp, #4]
  	acoral_vector index;
	if(vector>HAL_INTR_MAX)
30003f30:	e59d3004 	ldr	r3, [sp, #4]
30003f34:	e3530031 	cmp	r3, #49	; 0x31
30003f38:	ca00002e 	bgt	30003ff8 <acoral_intr_mask+0xd4>
		return;
   	HAL_TRANSLATE_VECTOR(vector,index);
30003f3c:	e59d3004 	ldr	r3, [sp, #4]
30003f40:	e58d300c 	str	r3, [sp, #12]

        /*如果中断的除能函数不为空，就调用该除能函数 */
	if(intr_table[index].mask!=NULL&&intr_table[index].type==ACORAL_COMM_INTR){
30003f44:	e59d200c 	ldr	r2, [sp, #12]
30003f48:	e59f00b8 	ldr	r0, [pc, #184]	; 30004008 <acoral_intr_mask+0xe4>
30003f4c:	e3a01014 	mov	r1, #20
30003f50:	e1a03002 	mov	r3, r2
30003f54:	e1a03183 	lsl	r3, r3, #3
30003f58:	e0623003 	rsb	r3, r2, r3
30003f5c:	e1a03103 	lsl	r3, r3, #2
30003f60:	e0833000 	add	r3, r3, r0
30003f64:	e0833001 	add	r3, r3, r1
30003f68:	e5933000 	ldr	r3, [r3]
30003f6c:	e3530000 	cmp	r3, #0
30003f70:	0a000021 	beq	30003ffc <acoral_intr_mask+0xd8>
30003f74:	e59d200c 	ldr	r2, [sp, #12]
30003f78:	e59f1088 	ldr	r1, [pc, #136]	; 30004008 <acoral_intr_mask+0xe4>
30003f7c:	e1a03002 	mov	r3, r2
30003f80:	e1a03183 	lsl	r3, r3, #3
30003f84:	e0623003 	rsb	r3, r2, r3
30003f88:	e1a03103 	lsl	r3, r3, #2
30003f8c:	e0833001 	add	r3, r3, r1
30003f90:	e5d33005 	ldrb	r3, [r3, #5]
30003f94:	e3530001 	cmp	r3, #1
30003f98:	1a000017 	bne	30003ffc <acoral_intr_mask+0xd8>
		intr_table[index].mask(vector);
30003f9c:	e59d200c 	ldr	r2, [sp, #12]
30003fa0:	e59f0060 	ldr	r0, [pc, #96]	; 30004008 <acoral_intr_mask+0xe4>
30003fa4:	e3a01014 	mov	r1, #20
30003fa8:	e1a03002 	mov	r3, r2
30003fac:	e1a03183 	lsl	r3, r3, #3
30003fb0:	e0623003 	rsb	r3, r2, r3
30003fb4:	e1a03103 	lsl	r3, r3, #2
30003fb8:	e0833000 	add	r3, r3, r0
30003fbc:	e0833001 	add	r3, r3, r1
30003fc0:	e5933000 	ldr	r3, [r3]
30003fc4:	e59d0004 	ldr	r0, [sp, #4]
30003fc8:	e1a0e00f 	mov	lr, pc
30003fcc:	e12fff13 	bx	r3
		/*将中断状态设为假    */
		intr_table[index].state=false;
30003fd0:	e59d200c 	ldr	r2, [sp, #12]
30003fd4:	e59f102c 	ldr	r1, [pc, #44]	; 30004008 <acoral_intr_mask+0xe4>
30003fd8:	e1a03002 	mov	r3, r2
30003fdc:	e1a03183 	lsl	r3, r3, #3
30003fe0:	e0623003 	rsb	r3, r2, r3
30003fe4:	e1a03103 	lsl	r3, r3, #2
30003fe8:	e0833001 	add	r3, r3, r1
30003fec:	e3a02000 	mov	r2, #0
30003ff0:	e5c32004 	strb	r2, [r3, #4]
30003ff4:	ea000000 	b	30003ffc <acoral_intr_mask+0xd8>
*除能中断
*===========================*/
void acoral_intr_mask(acoral_vector vector){
  	acoral_vector index;
	if(vector>HAL_INTR_MAX)
		return;
30003ff8:	e1a00000 	nop			; (mov r0, r0)
	if(intr_table[index].mask!=NULL&&intr_table[index].type==ACORAL_COMM_INTR){
		intr_table[index].mask(vector);
		/*将中断状态设为假    */
		intr_table[index].state=false;
	}
}
30003ffc:	e28dd014 	add	sp, sp, #20
30004000:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004004:	e12fff1e 	bx	lr
30004008:	3002a150 	.word	0x3002a150

3000400c <acoral_intr_entry>:

/*===========================                                                                                                                 
*the commen isr of vector      
*中断公共服务入口函数
*===========================*/
void acoral_intr_entry(acoral_vector vector){
3000400c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004010:	e24dd014 	sub	sp, sp, #20
30004014:	e58d0004 	str	r0, [sp, #4]
	acoral_vector index;
#ifdef CFG_DEBUG
  	acoral_print("isr in cpu:%d\n",acoral_current_cpu);
#endif
   	HAL_TRANSLATE_VECTOR(vector,index);
30004018:	e59d3004 	ldr	r3, [sp, #4]
3000401c:	e58d300c 	str	r3, [sp, #12]
	acoral_intr_nesting_inc();
30004020:	ebfff5e4 	bl	300017b8 <hal_intr_nesting_inc_comm>
	if(intr_table[index].type==ACORAL_EXPERT_INTR){
30004024:	e59d200c 	ldr	r2, [sp, #12]
30004028:	e59f1180 	ldr	r1, [pc, #384]	; 300041b0 <acoral_intr_entry+0x1a4>
3000402c:	e1a03002 	mov	r3, r2
30004030:	e1a03183 	lsl	r3, r3, #3
30004034:	e0623003 	rsb	r3, r2, r3
30004038:	e1a03103 	lsl	r3, r3, #2
3000403c:	e0833001 	add	r3, r3, r1
30004040:	e5d33005 	ldrb	r3, [r3, #5]
30004044:	e3530002 	cmp	r3, #2
30004048:	1a00000e 	bne	30004088 <acoral_intr_entry+0x7c>
		intr_table[index].isr(vector);
3000404c:	e59d200c 	ldr	r2, [sp, #12]
30004050:	e59f0158 	ldr	r0, [pc, #344]	; 300041b0 <acoral_intr_entry+0x1a4>
30004054:	e3a01008 	mov	r1, #8
30004058:	e1a03002 	mov	r3, r2
3000405c:	e1a03183 	lsl	r3, r3, #3
30004060:	e0623003 	rsb	r3, r2, r3
30004064:	e1a03103 	lsl	r3, r3, #2
30004068:	e0833000 	add	r3, r3, r0
3000406c:	e0833001 	add	r3, r3, r1
30004070:	e5933000 	ldr	r3, [r3]
30004074:	e59d0004 	ldr	r0, [sp, #4]
30004078:	e1a0e00f 	mov	lr, pc
3000407c:	e12fff13 	bx	r3
		acoral_intr_disable();
30004080:	ebfff594 	bl	300016d8 <HAL_INTR_DISABLE>
30004084:	ea000044 	b	3000419c <acoral_intr_entry+0x190>
	}else{
		/*这个之前都要是关中断的，调用中断进入函数*/
		if(intr_table[index].enter!=NULL)
30004088:	e59d200c 	ldr	r2, [sp, #12]
3000408c:	e59f011c 	ldr	r0, [pc, #284]	; 300041b0 <acoral_intr_entry+0x1a4>
30004090:	e3a0100c 	mov	r1, #12
30004094:	e1a03002 	mov	r3, r2
30004098:	e1a03183 	lsl	r3, r3, #3
3000409c:	e0623003 	rsb	r3, r2, r3
300040a0:	e1a03103 	lsl	r3, r3, #2
300040a4:	e0833000 	add	r3, r3, r0
300040a8:	e0833001 	add	r3, r3, r1
300040ac:	e5933000 	ldr	r3, [r3]
300040b0:	e3530000 	cmp	r3, #0
300040b4:	0a00000c 	beq	300040ec <acoral_intr_entry+0xe0>
			intr_table[index].enter(vector);
300040b8:	e59d200c 	ldr	r2, [sp, #12]
300040bc:	e59f00ec 	ldr	r0, [pc, #236]	; 300041b0 <acoral_intr_entry+0x1a4>
300040c0:	e3a0100c 	mov	r1, #12
300040c4:	e1a03002 	mov	r3, r2
300040c8:	e1a03183 	lsl	r3, r3, #3
300040cc:	e0623003 	rsb	r3, r2, r3
300040d0:	e1a03103 	lsl	r3, r3, #2
300040d4:	e0833000 	add	r3, r3, r0
300040d8:	e0833001 	add	r3, r3, r1
300040dc:	e5933000 	ldr	r3, [r3]
300040e0:	e59d0004 	ldr	r0, [sp, #4]
300040e4:	e1a0e00f 	mov	lr, pc
300040e8:	e12fff13 	bx	r3
	
		acoral_intr_mask(vector);	
300040ec:	e59d0004 	ldr	r0, [sp, #4]
300040f0:	ebffff8b 	bl	30003f24 <acoral_intr_mask>
		/*开中断*/
		acoral_intr_enable();
300040f4:	ebfff573 	bl	300016c8 <HAL_INTR_ENABLE>

		/*调用该中断的服务处理函数*/
		intr_table[index].isr(vector);
300040f8:	e59d200c 	ldr	r2, [sp, #12]
300040fc:	e59f00ac 	ldr	r0, [pc, #172]	; 300041b0 <acoral_intr_entry+0x1a4>
30004100:	e3a01008 	mov	r1, #8
30004104:	e1a03002 	mov	r3, r2
30004108:	e1a03183 	lsl	r3, r3, #3
3000410c:	e0623003 	rsb	r3, r2, r3
30004110:	e1a03103 	lsl	r3, r3, #2
30004114:	e0833000 	add	r3, r3, r0
30004118:	e0833001 	add	r3, r3, r1
3000411c:	e5933000 	ldr	r3, [r3]
30004120:	e59d0004 	ldr	r0, [sp, #4]
30004124:	e1a0e00f 	mov	lr, pc
30004128:	e12fff13 	bx	r3
	
		/*关中断*/
		acoral_intr_disable();
3000412c:	ebfff569 	bl	300016d8 <HAL_INTR_DISABLE>
	
		acoral_intr_unmask(vector);	
30004130:	e59d0004 	ldr	r0, [sp, #4]
30004134:	ebffff40 	bl	30003e3c <acoral_intr_unmask>
		/*调用中断退出函数*/
		if(intr_table[index].exit!=NULL)
30004138:	e59d200c 	ldr	r2, [sp, #12]
3000413c:	e59f006c 	ldr	r0, [pc, #108]	; 300041b0 <acoral_intr_entry+0x1a4>
30004140:	e3a01010 	mov	r1, #16
30004144:	e1a03002 	mov	r3, r2
30004148:	e1a03183 	lsl	r3, r3, #3
3000414c:	e0623003 	rsb	r3, r2, r3
30004150:	e1a03103 	lsl	r3, r3, #2
30004154:	e0833000 	add	r3, r3, r0
30004158:	e0833001 	add	r3, r3, r1
3000415c:	e5933000 	ldr	r3, [r3]
30004160:	e3530000 	cmp	r3, #0
30004164:	0a00000c 	beq	3000419c <acoral_intr_entry+0x190>
			intr_table[index].exit(vector);
30004168:	e59d200c 	ldr	r2, [sp, #12]
3000416c:	e59f003c 	ldr	r0, [pc, #60]	; 300041b0 <acoral_intr_entry+0x1a4>
30004170:	e3a01010 	mov	r1, #16
30004174:	e1a03002 	mov	r3, r2
30004178:	e1a03183 	lsl	r3, r3, #3
3000417c:	e0623003 	rsb	r3, r2, r3
30004180:	e1a03103 	lsl	r3, r3, #2
30004184:	e0833000 	add	r3, r3, r0
30004188:	e0833001 	add	r3, r3, r1
3000418c:	e5933000 	ldr	r3, [r3]
30004190:	e59d0004 	ldr	r0, [sp, #4]
30004194:	e1a0e00f 	mov	lr, pc
30004198:	e12fff13 	bx	r3
	}
	acoral_intr_nesting_dec();
3000419c:	ebfff574 	bl	30001774 <hal_intr_nesting_dec_comm>
	acoral_intr_exit();
300041a0:	eb000007 	bl	300041c4 <acoral_intr_exit>
}
300041a4:	e28dd014 	add	sp, sp, #20
300041a8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300041ac:	e12fff1e 	bx	lr
300041b0:	3002a150 	.word	0x3002a150

300041b4 <acoral_default_isr>:

/*===========================                                                                                                                 
*The default isr      
*默认中断处理程序
*===========================*/
void acoral_default_isr(acoral_vector vector){
300041b4:	e24dd008 	sub	sp, sp, #8
300041b8:	e58d0004 	str	r0, [sp, #4]
  	acoral_printdbg("in Default interrupt route\n");
}
300041bc:	e28dd008 	add	sp, sp, #8
300041c0:	e12fff1e 	bx	lr

300041c4 <acoral_intr_exit>:

/*===========================                                                                                                                 
*The exit function of the vector      
*中断退出函数
*===========================*/
void acoral_intr_exit(){
300041c4:	e92d4008 	push	{r3, lr}
      	if(!acoral_need_sched)
300041c8:	e59f3064 	ldr	r3, [pc, #100]	; 30004234 <acoral_intr_exit+0x70>
300041cc:	e5d33000 	ldrb	r3, [r3]
300041d0:	e3530000 	cmp	r3, #0
300041d4:	0a00000d 	beq	30004210 <acoral_intr_exit+0x4c>
	    return;

	if(acoral_intr_nesting)
300041d8:	ebfff560 	bl	30001760 <hal_get_intr_nesting_comm>
300041dc:	e1a03000 	mov	r3, r0
300041e0:	e3530000 	cmp	r3, #0
300041e4:	1a00000b 	bne	30004218 <acoral_intr_exit+0x54>
	    return;

	if(acoral_sched_is_lock)
300041e8:	e59f3048 	ldr	r3, [pc, #72]	; 30004238 <acoral_intr_exit+0x74>
300041ec:	e5d33000 	ldrb	r3, [r3]
300041f0:	e3530000 	cmp	r3, #0
300041f4:	1a000009 	bne	30004220 <acoral_intr_exit+0x5c>
	    return;

	if (!acoral_start_sched)
300041f8:	e59f303c 	ldr	r3, [pc, #60]	; 3000423c <acoral_intr_exit+0x78>
300041fc:	e5933000 	ldr	r3, [r3]
30004200:	e3530000 	cmp	r3, #0
30004204:	0a000007 	beq	30004228 <acoral_intr_exit+0x64>
	    return;
      
      /*如果需要调度，则调用此函数*/
	HAL_INTR_EXIT_BRIDGE();
30004208:	ebfff57c 	bl	30001800 <hal_intr_exit_bridge_comm>
3000420c:	ea000006 	b	3000422c <acoral_intr_exit+0x68>
*The exit function of the vector      
*中断退出函数
*===========================*/
void acoral_intr_exit(){
      	if(!acoral_need_sched)
	    return;
30004210:	e1a00000 	nop			; (mov r0, r0)
30004214:	ea000004 	b	3000422c <acoral_intr_exit+0x68>

	if(acoral_intr_nesting)
	    return;
30004218:	e1a00000 	nop			; (mov r0, r0)
3000421c:	ea000002 	b	3000422c <acoral_intr_exit+0x68>

	if(acoral_sched_is_lock)
	    return;
30004220:	e1a00000 	nop			; (mov r0, r0)
30004224:	ea000000 	b	3000422c <acoral_intr_exit+0x68>

	if (!acoral_start_sched)
	    return;
30004228:	e1a00000 	nop			; (mov r0, r0)
      
      /*如果需要调度，则调用此函数*/
	HAL_INTR_EXIT_BRIDGE();
}
3000422c:	e8bd4008 	pop	{r3, lr}
30004230:	e12fff1e 	bx	lr
30004234:	3002b354 	.word	0x3002b354
30004238:	3002a14c 	.word	0x3002a14c
3000423c:	30026938 	.word	0x30026938

30004240 <acoral_set_intr_enter>:

/*===========================                                                                                                                 
*Set the enter function of the vector      
*设置中断进入函数为isr
*===========================*/
void acoral_set_intr_enter(acoral_vector vector,void (*enter)(acoral_vector)){
30004240:	e24dd010 	sub	sp, sp, #16
30004244:	e58d0004 	str	r0, [sp, #4]
30004248:	e58d1000 	str	r1, [sp]
	acoral_vector index;
	HAL_TRANSLATE_VECTOR(vector,index);
3000424c:	e59d3004 	ldr	r3, [sp, #4]
30004250:	e58d300c 	str	r3, [sp, #12]
	intr_table[index].enter=enter;
30004254:	e59d200c 	ldr	r2, [sp, #12]
30004258:	e59f0028 	ldr	r0, [pc, #40]	; 30004288 <acoral_set_intr_enter+0x48>
3000425c:	e3a0100c 	mov	r1, #12
30004260:	e1a03002 	mov	r3, r2
30004264:	e1a03183 	lsl	r3, r3, #3
30004268:	e0623003 	rsb	r3, r2, r3
3000426c:	e1a03103 	lsl	r3, r3, #2
30004270:	e0833000 	add	r3, r3, r0
30004274:	e0833001 	add	r3, r3, r1
30004278:	e59d2000 	ldr	r2, [sp]
3000427c:	e5832000 	str	r2, [r3]
}
30004280:	e28dd010 	add	sp, sp, #16
30004284:	e12fff1e 	bx	lr
30004288:	3002a150 	.word	0x3002a150

3000428c <acoral_set_intr_exit>:

/*===========================                                                                                                                 
*Set the exit  function of the vector 
*设置中断退出函数为isr
*===========================*/
void acoral_set_intr_exit(acoral_vector vector,void (*exit)(acoral_vector)){
3000428c:	e24dd010 	sub	sp, sp, #16
30004290:	e58d0004 	str	r0, [sp, #4]
30004294:	e58d1000 	str	r1, [sp]
	acoral_vector index;
	HAL_TRANSLATE_VECTOR(vector,index);
30004298:	e59d3004 	ldr	r3, [sp, #4]
3000429c:	e58d300c 	str	r3, [sp, #12]
	intr_table[index].exit=exit;
300042a0:	e59d200c 	ldr	r2, [sp, #12]
300042a4:	e59f0028 	ldr	r0, [pc, #40]	; 300042d4 <acoral_set_intr_exit+0x48>
300042a8:	e3a01010 	mov	r1, #16
300042ac:	e1a03002 	mov	r3, r2
300042b0:	e1a03183 	lsl	r3, r3, #3
300042b4:	e0623003 	rsb	r3, r2, r3
300042b8:	e1a03103 	lsl	r3, r3, #2
300042bc:	e0833000 	add	r3, r3, r0
300042c0:	e0833001 	add	r3, r3, r1
300042c4:	e59d2000 	ldr	r2, [sp]
300042c8:	e5832000 	str	r2, [r3]
}
300042cc:	e28dd010 	add	sp, sp, #16
300042d0:	e12fff1e 	bx	lr
300042d4:	3002a150 	.word	0x3002a150

300042d8 <acoral_set_intr_mask>:

/*===========================                                                                                                                 
*Set the mask  function of the vector 
*设置中断屏蔽函数为isr
*===========================*/
void acoral_set_intr_mask(acoral_vector vector,void (*mask)(acoral_vector)){
300042d8:	e24dd010 	sub	sp, sp, #16
300042dc:	e58d0004 	str	r0, [sp, #4]
300042e0:	e58d1000 	str	r1, [sp]
	acoral_vector index;
	HAL_TRANSLATE_VECTOR(vector,index);
300042e4:	e59d3004 	ldr	r3, [sp, #4]
300042e8:	e58d300c 	str	r3, [sp, #12]
	intr_table[index].mask=mask;
300042ec:	e59d200c 	ldr	r2, [sp, #12]
300042f0:	e59f0028 	ldr	r0, [pc, #40]	; 30004320 <acoral_set_intr_mask+0x48>
300042f4:	e3a01014 	mov	r1, #20
300042f8:	e1a03002 	mov	r3, r2
300042fc:	e1a03183 	lsl	r3, r3, #3
30004300:	e0623003 	rsb	r3, r2, r3
30004304:	e1a03103 	lsl	r3, r3, #2
30004308:	e0833000 	add	r3, r3, r0
3000430c:	e0833001 	add	r3, r3, r1
30004310:	e59d2000 	ldr	r2, [sp]
30004314:	e5832000 	str	r2, [r3]
}
30004318:	e28dd010 	add	sp, sp, #16
3000431c:	e12fff1e 	bx	lr
30004320:	3002a150 	.word	0x3002a150

30004324 <acoral_set_intr_unmask>:

/*===========================                                                                                                                 
*Set the unmask function of the vector 
*设置中断使能函数为isr
*===========================*/
void acoral_set_intr_unmask(acoral_vector vector,void (*unmask)(acoral_vector)){
30004324:	e24dd010 	sub	sp, sp, #16
30004328:	e58d0004 	str	r0, [sp, #4]
3000432c:	e58d1000 	str	r1, [sp]
	acoral_vector index;
	HAL_TRANSLATE_VECTOR(vector,index);
30004330:	e59d3004 	ldr	r3, [sp, #4]
30004334:	e58d300c 	str	r3, [sp, #12]
	intr_table[index].unmask=unmask;
30004338:	e59d200c 	ldr	r2, [sp, #12]
3000433c:	e59f0028 	ldr	r0, [pc, #40]	; 3000436c <acoral_set_intr_unmask+0x48>
30004340:	e3a01018 	mov	r1, #24
30004344:	e1a03002 	mov	r3, r2
30004348:	e1a03183 	lsl	r3, r3, #3
3000434c:	e0623003 	rsb	r3, r2, r3
30004350:	e1a03103 	lsl	r3, r3, #2
30004354:	e0833000 	add	r3, r3, r0
30004358:	e0833001 	add	r3, r3, r1
3000435c:	e59d2000 	ldr	r2, [sp]
30004360:	e5832000 	str	r2, [r3]
}
30004364:	e28dd010 	add	sp, sp, #16
30004368:	e12fff1e 	bx	lr
3000436c:	3002a150 	.word	0x3002a150

30004370 <acoral_intr_set_type>:

/*===========================                                                                                                                 
*Set interrupt type
*设置中断类型
*===========================*/
void acoral_intr_set_type(acoral_vector vector,acoral_u8 type){
30004370:	e24dd010 	sub	sp, sp, #16
30004374:	e58d0004 	str	r0, [sp, #4]
30004378:	e1a03001 	mov	r3, r1
3000437c:	e5cd3003 	strb	r3, [sp, #3]
  	acoral_vector index;
   	HAL_TRANSLATE_VECTOR(vector,index);
30004380:	e59d3004 	ldr	r3, [sp, #4]
30004384:	e58d300c 	str	r3, [sp, #12]
	intr_table[index].type =type;
30004388:	e59d200c 	ldr	r2, [sp, #12]
3000438c:	e59f1020 	ldr	r1, [pc, #32]	; 300043b4 <acoral_intr_set_type+0x44>
30004390:	e1a03002 	mov	r3, r2
30004394:	e1a03183 	lsl	r3, r3, #3
30004398:	e0623003 	rsb	r3, r2, r3
3000439c:	e1a03103 	lsl	r3, r3, #2
300043a0:	e0833001 	add	r3, r3, r1
300043a4:	e5dd2003 	ldrb	r2, [sp, #3]
300043a8:	e5c32005 	strb	r2, [r3, #5]
}
300043ac:	e28dd010 	add	sp, sp, #16
300043b0:	e12fff1e 	bx	lr
300043b4:	3002a150 	.word	0x3002a150

300043b8 <acoral_fault_entry>:
/*===========================                                                                                                                 
*     exception err output
*        异常错误输出
*===========================*/

void acoral_fault_entry(acoral_u32 lr,acoral_u32 *stack){
300043b8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300043bc:	e24dd00c 	sub	sp, sp, #12
300043c0:	e58d0004 	str	r0, [sp, #4]
300043c4:	e58d1000 	str	r1, [sp]
	acoral_intr_disable();
300043c8:	ebfff4c2 	bl	300016d8 <HAL_INTR_DISABLE>
	if(!acoral_start_sched)
300043cc:	e59f30c4 	ldr	r3, [pc, #196]	; 30004498 <acoral_fault_entry+0xe0>
300043d0:	e5933000 	ldr	r3, [r3]
300043d4:	e3530000 	cmp	r3, #0
300043d8:	1a000000 	bne	300043e0 <acoral_fault_entry+0x28>
		while(1);	
300043dc:	eafffffe 	b	300043dc <acoral_fault_entry+0x24>
	acoral_printerr("Exception occur\n");
300043e0:	e59f00b4 	ldr	r0, [pc, #180]	; 3000449c <acoral_fault_entry+0xe4>
300043e4:	eb001c0f 	bl	3000b428 <acoral_print>
	acoral_printerr("******************\n");
300043e8:	e59f00b0 	ldr	r0, [pc, #176]	; 300044a0 <acoral_fault_entry+0xe8>
300043ec:	eb001c0d 	bl	3000b428 <acoral_print>
	acoral_printerr("CPU:%d\n",acoral_current_cpu);;
300043f0:	e59f00ac 	ldr	r0, [pc, #172]	; 300044a4 <acoral_fault_entry+0xec>
300043f4:	e3a01000 	mov	r1, #0
300043f8:	eb001c0a 	bl	3000b428 <acoral_print>
	acoral_printerr("Thread name:%s\n",acoral_cur_thread->name);;
300043fc:	e59f30a4 	ldr	r3, [pc, #164]	; 300044a8 <acoral_fault_entry+0xf0>
30004400:	e5933000 	ldr	r3, [r3]
30004404:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30004408:	e59f009c 	ldr	r0, [pc, #156]	; 300044ac <acoral_fault_entry+0xf4>
3000440c:	e1a01003 	mov	r1, r3
30004410:	eb001c04 	bl	3000b428 <acoral_print>
	acoral_printerr("Thread prio:%d\n",acoral_cur_thread->prio);;
30004414:	e59f308c 	ldr	r3, [pc, #140]	; 300044a8 <acoral_fault_entry+0xf0>
30004418:	e5933000 	ldr	r3, [r3]
3000441c:	e5d33005 	ldrb	r3, [r3, #5]
30004420:	e59f0088 	ldr	r0, [pc, #136]	; 300044b0 <acoral_fault_entry+0xf8>
30004424:	e1a01003 	mov	r1, r3
30004428:	eb001bfe 	bl	3000b428 <acoral_print>
	acoral_printerr("Thread stack_size:%d\n",acoral_cur_thread->stack_size);;
3000442c:	e59f3074 	ldr	r3, [pc, #116]	; 300044a8 <acoral_fault_entry+0xf0>
30004430:	e5933000 	ldr	r3, [r3]
30004434:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
30004438:	e59f0074 	ldr	r0, [pc, #116]	; 300044b4 <acoral_fault_entry+0xfc>
3000443c:	e1a01003 	mov	r1, r3
30004440:	eb001bf8 	bl	3000b428 <acoral_print>
	acoral_printerr("Thread stack_buttom:0x%x\n",acoral_cur_thread->stack_buttom);;
30004444:	e59f305c 	ldr	r3, [pc, #92]	; 300044a8 <acoral_fault_entry+0xf0>
30004448:	e5933000 	ldr	r3, [r3]
3000444c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
30004450:	e59f0060 	ldr	r0, [pc, #96]	; 300044b8 <acoral_fault_entry+0x100>
30004454:	e1a01003 	mov	r1, r3
30004458:	eb001bf2 	bl	3000b428 <acoral_print>
	acoral_printerr("Thread stack:0x%x\n",acoral_cur_thread->stack);;
3000445c:	e59f3044 	ldr	r3, [pc, #68]	; 300044a8 <acoral_fault_entry+0xf0>
30004460:	e5933000 	ldr	r3, [r3]
30004464:	e5933034 	ldr	r3, [r3, #52]	; 0x34
30004468:	e59f004c 	ldr	r0, [pc, #76]	; 300044bc <acoral_fault_entry+0x104>
3000446c:	e1a01003 	mov	r1, r3
30004470:	eb001bec 	bl	3000b428 <acoral_print>
	acoral_printerr("Pc:0x%x\n",lr);
30004474:	e59f0044 	ldr	r0, [pc, #68]	; 300044c0 <acoral_fault_entry+0x108>
30004478:	e59d1004 	ldr	r1, [sp, #4]
3000447c:	eb001be9 	bl	3000b428 <acoral_print>
	acoral_printerr("Stack:0x%x\n",stack);
30004480:	e59f003c 	ldr	r0, [pc, #60]	; 300044c4 <acoral_fault_entry+0x10c>
30004484:	e59d1000 	ldr	r1, [sp]
30004488:	eb001be6 	bl	3000b428 <acoral_print>
	acoral_printerr("******************\n");
3000448c:	e59f000c 	ldr	r0, [pc, #12]	; 300044a0 <acoral_fault_entry+0xe8>
30004490:	eb001be4 	bl	3000b428 <acoral_print>
	while(1);
30004494:	eafffffe 	b	30004494 <acoral_fault_entry+0xdc>
30004498:	30026938 	.word	0x30026938
3000449c:	30025f50 	.word	0x30025f50
300044a0:	30025f64 	.word	0x30025f64
300044a4:	30025f78 	.word	0x30025f78
300044a8:	3002b350 	.word	0x3002b350
300044ac:	30025f80 	.word	0x30025f80
300044b0:	30025f90 	.word	0x30025f90
300044b4:	30025fa0 	.word	0x30025fa0
300044b8:	30025fb8 	.word	0x30025fb8
300044bc:	30025fd4 	.word	0x30025fd4
300044c0:	30025fe8 	.word	0x30025fe8
300044c4:	30025ff4 	.word	0x30025ff4

300044c8 <acoral_time_sys_init>:
/*  pegasus   0719*/
/*----------------*/
acoral_queue_t timeout_queue;
static acoral_u32 ticks;
void acoral_time_sys_init(){
  	acoral_init_list(&time_delay_queue.head);
300044c8:	e59f302c 	ldr	r3, [pc, #44]	; 300044fc <acoral_time_sys_init+0x34>
300044cc:	e59f2028 	ldr	r2, [pc, #40]	; 300044fc <acoral_time_sys_init+0x34>
300044d0:	e5832000 	str	r2, [r3]
300044d4:	e59f3020 	ldr	r3, [pc, #32]	; 300044fc <acoral_time_sys_init+0x34>
300044d8:	e59f201c 	ldr	r2, [pc, #28]	; 300044fc <acoral_time_sys_init+0x34>
300044dc:	e5832004 	str	r2, [r3, #4]

	/*---------------*/
	/*  新增延时初始化 timeout_queue*/
	/*  pegasus   0719*/
	/*---------------*/
	acoral_init_list(&timeout_queue.head);
300044e0:	e59f3018 	ldr	r3, [pc, #24]	; 30004500 <acoral_time_sys_init+0x38>
300044e4:	e59f2014 	ldr	r2, [pc, #20]	; 30004500 <acoral_time_sys_init+0x38>
300044e8:	e5832000 	str	r2, [r3]
300044ec:	e59f300c 	ldr	r3, [pc, #12]	; 30004500 <acoral_time_sys_init+0x38>
300044f0:	e59f2008 	ldr	r2, [pc, #8]	; 30004500 <acoral_time_sys_init+0x38>
300044f4:	e5832004 	str	r2, [r3, #4]
	acoral_spin_init(&timeout_queue.head.lock);
}
300044f8:	e12fff1e 	bx	lr
300044fc:	3002b134 	.word	0x3002b134
30004500:	3002b1b4 	.word	0x3002b1b4

30004504 <acoral_get_ticks>:


acoral_time acoral_get_ticks(){
	return ticks;
30004504:	e59f3008 	ldr	r3, [pc, #8]	; 30004514 <acoral_get_ticks+0x10>
30004508:	e5933000 	ldr	r3, [r3]
}
3000450c:	e1a00003 	mov	r0, r3
30004510:	e12fff1e 	bx	lr
30004514:	30026ca0 	.word	0x30026ca0

30004518 <acoral_set_ticks>:

void acoral_set_ticks(acoral_time time){
30004518:	e24dd008 	sub	sp, sp, #8
3000451c:	e58d0004 	str	r0, [sp, #4]
  	ticks=time;
30004520:	e59f300c 	ldr	r3, [pc, #12]	; 30004534 <acoral_set_ticks+0x1c>
30004524:	e59d2004 	ldr	r2, [sp, #4]
30004528:	e5832000 	str	r2, [r3]
}
3000452c:	e28dd008 	add	sp, sp, #8
30004530:	e12fff1e 	bx	lr
30004534:	30026ca0 	.word	0x30026ca0

30004538 <acoral_ticks_init>:

void acoral_ticks_init(){
30004538:	e92d4008 	push	{r3, lr}
  	ticks=0;                                      /*初始化滴答时钟计数器*/
3000453c:	e59f3024 	ldr	r3, [pc, #36]	; 30004568 <acoral_ticks_init+0x30>
30004540:	e3a02000 	mov	r2, #0
30004544:	e5832000 	str	r2, [r3]
	acoral_intr_attach(HAL_TICKS_INTR,acoral_ticks_entry);/*这个用于注册ticks的处理函数*/
30004548:	e3a0001c 	mov	r0, #28
3000454c:	e59f1018 	ldr	r1, [pc, #24]	; 3000456c <acoral_ticks_init+0x34>
30004550:	ebfffe05 	bl	30003d6c <acoral_intr_attach>
	HAL_TICKS_INIT();                            /*这个主要用于将用于ticks的时钟初始化*/
30004554:	ebfff0c2 	bl	30000864 <hal_ticks_init>
	acoral_intr_unmask(HAL_TICKS_INTR);
30004558:	e3a0001c 	mov	r0, #28
3000455c:	ebfffe36 	bl	30003e3c <acoral_intr_unmask>
	return;
}
30004560:	e8bd4008 	pop	{r3, lr}
30004564:	e12fff1e 	bx	lr
30004568:	30026ca0 	.word	0x30026ca0
3000456c:	30004570 	.word	0x30004570

30004570 <acoral_ticks_entry>:

void acoral_ticks_entry(acoral_vector vector){
30004570:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004574:	e24dd00c 	sub	sp, sp, #12
30004578:	e58d0004 	str	r0, [sp, #4]
#ifdef CFG_HOOK_TICKS
	acoral_ticks_hook();
#endif
        ticks++;
3000457c:	e59f3034 	ldr	r3, [pc, #52]	; 300045b8 <acoral_ticks_entry+0x48>
30004580:	e5933000 	ldr	r3, [r3]
30004584:	e2832001 	add	r2, r3, #1
30004588:	e59f3028 	ldr	r3, [pc, #40]	; 300045b8 <acoral_ticks_entry+0x48>
3000458c:	e5832000 	str	r2, [r3]
	acoral_printdbg("In ticks isr\n");
	if(acoral_start_sched==true){
30004590:	e59f3024 	ldr	r3, [pc, #36]	; 300045bc <acoral_ticks_entry+0x4c>
30004594:	e5933000 	ldr	r3, [r3]
30004598:	e3530001 	cmp	r3, #1
3000459c:	1a000002 	bne	300045ac <acoral_ticks_entry+0x3c>
		time_delay_deal();
300045a0:	eb000051 	bl	300046ec <time_delay_deal>
		acoral_policy_delay_deal();
300045a4:	ebfff638 	bl	30001e8c <acoral_policy_delay_deal>
		/*--------------------*/
		/* 超时链表处理函数*/
		/* pegasus  0719*/
		/*--------------------*/
		timeout_delay_deal();
300045a8:	eb0000ef 	bl	3000496c <timeout_delay_deal>
	}
}
300045ac:	e28dd00c 	add	sp, sp, #12
300045b0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300045b4:	e12fff1e 	bx	lr
300045b8:	30026ca0 	.word	0x30026ca0
300045bc:	30026938 	.word	0x30026938

300045c0 <acoral_delayqueue_add>:

/*================================
 * func: add thread to  time_delay_queue 
 *    将线程挂到延时队列上
 *================================*/
void acoral_delayqueue_add(acoral_queue_t *queue, acoral_thread_t *new){
300045c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300045c4:	e24dd02c 	sub	sp, sp, #44	; 0x2c
300045c8:	e58d0004 	str	r0, [sp, #4]
300045cc:	e58d1000 	str	r1, [sp]
	acoral_sr cpu_sr;
	acoral_list_t   *tmp, *tmp1,*head;
	acoral_thread_t *thread;
	acoral_32  delay2;
	acoral_32  delay= new->delay;
300045d0:	e59d3000 	ldr	r3, [sp]
300045d4:	e5933040 	ldr	r3, [r3, #64]	; 0x40
300045d8:	e58d3024 	str	r3, [sp, #36]	; 0x24
	if(new->state&ACORAL_THREAD_STATE_DELAY){
		acoral_printerr("Still in delay but be waked,why?\n");
		return;
	}
#endif
	head=&queue->head;
300045dc:	e59d3004 	ldr	r3, [sp, #4]
300045e0:	e58d3018 	str	r3, [sp, #24]
	HAL_ENTER_CRITICAL();
300045e4:	ebfff442 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300045e8:	e1a03000 	mov	r3, r0
300045ec:	e58d300c 	str	r3, [sp, #12]
		/*获取下一个成员锁*/
		acoral_spin_lock(&tmp1->lock);
		acoral_spin_unlock(&tmp->lock);
	}
#else
	new->state|=ACORAL_THREAD_STATE_DELAY;
300045f0:	e59d3000 	ldr	r3, [sp]
300045f4:	e5d33004 	ldrb	r3, [r3, #4]
300045f8:	e3833020 	orr	r3, r3, #32
300045fc:	e20320ff 	and	r2, r3, #255	; 0xff
30004600:	e59d3000 	ldr	r3, [sp]
30004604:	e5c32004 	strb	r2, [r3, #4]
	for (tmp=head->next;delay2=delay,tmp!=head; tmp=tmp->next){
30004608:	e59d3018 	ldr	r3, [sp, #24]
3000460c:	e5933000 	ldr	r3, [r3]
30004610:	e58d3010 	str	r3, [sp, #16]
30004614:	ea00000d 	b	30004650 <acoral_delayqueue_add+0x90>
		thread = list_entry (tmp, acoral_thread_t, waiting);
30004618:	e59d3010 	ldr	r3, [sp, #16]
3000461c:	e2433020 	sub	r3, r3, #32
30004620:	e58d301c 	str	r3, [sp, #28]
		delay  = delay-thread->delay;
30004624:	e59d301c 	ldr	r3, [sp, #28]
30004628:	e5933040 	ldr	r3, [r3, #64]	; 0x40
3000462c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30004630:	e0633002 	rsb	r3, r3, r2
30004634:	e58d3024 	str	r3, [sp, #36]	; 0x24
		if (delay < 0)
30004638:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3000463c:	e3530000 	cmp	r3, #0
30004640:	ba000009 	blt	3000466c <acoral_delayqueue_add+0xac>
		acoral_spin_lock(&tmp1->lock);
		acoral_spin_unlock(&tmp->lock);
	}
#else
	new->state|=ACORAL_THREAD_STATE_DELAY;
	for (tmp=head->next;delay2=delay,tmp!=head; tmp=tmp->next){
30004644:	e59d3010 	ldr	r3, [sp, #16]
30004648:	e5933000 	ldr	r3, [r3]
3000464c:	e58d3010 	str	r3, [sp, #16]
30004650:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30004654:	e58d3020 	str	r3, [sp, #32]
30004658:	e59d2010 	ldr	r2, [sp, #16]
3000465c:	e59d3018 	ldr	r3, [sp, #24]
30004660:	e1520003 	cmp	r2, r3
30004664:	1affffeb 	bne	30004618 <acoral_delayqueue_add+0x58>
30004668:	ea000000 	b	30004670 <acoral_delayqueue_add+0xb0>
		thread = list_entry (tmp, acoral_thread_t, waiting);
		delay  = delay-thread->delay;
		if (delay < 0)
			break;
3000466c:	e1a00000 	nop			; (mov r0, r0)
	}
	new->delay = delay2;
30004670:	e59d3000 	ldr	r3, [sp]
30004674:	e59d2020 	ldr	r2, [sp, #32]
30004678:	e5832040 	str	r2, [r3, #64]	; 0x40
	acoral_list_add(&new->waiting,tmp->prev);
3000467c:	e59d3000 	ldr	r3, [sp]
30004680:	e2832020 	add	r2, r3, #32
30004684:	e59d3010 	ldr	r3, [sp, #16]
30004688:	e5933004 	ldr	r3, [r3, #4]
3000468c:	e1a00002 	mov	r0, r2
30004690:	e1a01003 	mov	r1, r3
30004694:	eb0016be 	bl	3000a194 <acoral_list_add>
	/* 插入等待任务后，后继等待任务时间处理*/
	if(tmp != head){
30004698:	e59d2010 	ldr	r2, [sp, #16]
3000469c:	e59d3018 	ldr	r3, [sp, #24]
300046a0:	e1520003 	cmp	r2, r3
300046a4:	0a000008 	beq	300046cc <acoral_delayqueue_add+0x10c>
		thread = list_entry(tmp, acoral_thread_t, waiting);
300046a8:	e59d3010 	ldr	r3, [sp, #16]
300046ac:	e2433020 	sub	r3, r3, #32
300046b0:	e58d301c 	str	r3, [sp, #28]
		thread->delay-=delay2;
300046b4:	e59d301c 	ldr	r3, [sp, #28]
300046b8:	e5932040 	ldr	r2, [r3, #64]	; 0x40
300046bc:	e59d3020 	ldr	r3, [sp, #32]
300046c0:	e0632002 	rsb	r2, r3, r2
300046c4:	e59d301c 	ldr	r3, [sp, #28]
300046c8:	e5832040 	str	r2, [r3, #64]	; 0x40
	}
	acoral_unrdy_thread(new);
300046cc:	e59d0000 	ldr	r0, [sp]
300046d0:	ebfff935 	bl	30002bac <acoral_unrdy_thread>
#endif
	HAL_EXIT_CRITICAL();
300046d4:	e59d000c 	ldr	r0, [sp, #12]
300046d8:	ebfff403 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sched();
300046dc:	ebfff74b 	bl	30002410 <acoral_sched>
	return;
}
300046e0:	e28dd02c 	add	sp, sp, #44	; 0x2c
300046e4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300046e8:	e12fff1e 	bx	lr

300046ec <time_delay_deal>:

void time_delay_deal(){
300046ec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300046f0:	e24dd014 	sub	sp, sp, #20
	acoral_list_t   *tmp,*tmp1,*head;
	acoral_thread_t *thread;
	head = &time_delay_queue.head;
300046f4:	e59f30f8 	ldr	r3, [pc, #248]	; 300047f4 <time_delay_deal+0x108>
300046f8:	e58d3008 	str	r3, [sp, #8]
	if(acoral_list_empty(head))
300046fc:	e59d3008 	ldr	r3, [sp, #8]
30004700:	e5932000 	ldr	r2, [r3]
30004704:	e59d3008 	ldr	r3, [sp, #8]
30004708:	e1520003 	cmp	r2, r3
3000470c:	0a000032 	beq	300047dc <time_delay_deal+0xf0>
	  	return;
	thread=list_entry(head->next,acoral_thread_t,waiting);
30004710:	e59d3008 	ldr	r3, [sp, #8]
30004714:	e5933000 	ldr	r3, [r3]
30004718:	e2433020 	sub	r3, r3, #32
3000471c:	e58d300c 	str	r3, [sp, #12]
	ACORAL_ASSERT(thread,"in time deal");
30004720:	e59d200c 	ldr	r2, [sp, #12]
30004724:	e59f30cc 	ldr	r3, [pc, #204]	; 300047f8 <time_delay_deal+0x10c>
30004728:	e1a00002 	mov	r0, r2
3000472c:	e1a01003 	mov	r1, r3
30004730:	ebfffd41 	bl	30003c3c <acoral_assert_res>
	thread->delay--;
30004734:	e59d300c 	ldr	r3, [sp, #12]
30004738:	e5933040 	ldr	r3, [r3, #64]	; 0x40
3000473c:	e2432001 	sub	r2, r3, #1
30004740:	e59d300c 	ldr	r3, [sp, #12]
30004744:	e5832040 	str	r2, [r3, #64]	; 0x40
	for(tmp=head->next;tmp!=head;){
30004748:	e59d3008 	ldr	r3, [sp, #8]
3000474c:	e5933000 	ldr	r3, [r3]
30004750:	e58d3000 	str	r3, [sp]
30004754:	ea00001b 	b	300047c8 <time_delay_deal+0xdc>
		thread=list_entry(tmp,acoral_thread_t,waiting);
30004758:	e59d3000 	ldr	r3, [sp]
3000475c:	e2433020 	sub	r3, r3, #32
30004760:	e58d300c 	str	r3, [sp, #12]
		ACORAL_ASSERT(thread,"in time deal for");
30004764:	e59d200c 	ldr	r2, [sp, #12]
30004768:	e59f308c 	ldr	r3, [pc, #140]	; 300047fc <time_delay_deal+0x110>
3000476c:	e1a00002 	mov	r0, r2
30004770:	e1a01003 	mov	r1, r3
30004774:	ebfffd30 	bl	30003c3c <acoral_assert_res>
		if(thread->delay>0)
30004778:	e59d300c 	ldr	r3, [sp, #12]
3000477c:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30004780:	e3530000 	cmp	r3, #0
30004784:	ca000016 	bgt	300047e4 <time_delay_deal+0xf8>
		/*防止add判断delay时取下thread*/
#ifndef CFG_TICKS_PRIVATE
		acoral_spin_lock(&head->lock);
		acoral_spin_lock(&tmp->lock);
#endif
		tmp1=tmp->next;
30004788:	e59d3000 	ldr	r3, [sp]
3000478c:	e5933000 	ldr	r3, [r3]
30004790:	e58d3004 	str	r3, [sp, #4]
		acoral_list_del(&thread->waiting);
30004794:	e59d300c 	ldr	r3, [sp, #12]
30004798:	e2833020 	add	r3, r3, #32
3000479c:	e1a00003 	mov	r0, r3
300047a0:	eb0016a1 	bl	3000a22c <acoral_list_del>
#ifndef CFG_TICKS_PRIVATE
		acoral_spin_unlock(&tmp->lock);
		acoral_spin_unlock(&head->lock);
#endif
		tmp=tmp1;
300047a4:	e59d3004 	ldr	r3, [sp, #4]
300047a8:	e58d3000 	str	r3, [sp]
		thread->state&=~ACORAL_THREAD_STATE_DELAY;
300047ac:	e59d300c 	ldr	r3, [sp, #12]
300047b0:	e5d33004 	ldrb	r3, [r3, #4]
300047b4:	e20330df 	and	r3, r3, #223	; 0xdf
300047b8:	e59d200c 	ldr	r2, [sp, #12]
300047bc:	e5c23004 	strb	r3, [r2, #4]
		acoral_rdy_thread(thread);
300047c0:	e59d000c 	ldr	r0, [sp, #12]
300047c4:	ebfff8e9 	bl	30002b70 <acoral_rdy_thread>
	if(acoral_list_empty(head))
	  	return;
	thread=list_entry(head->next,acoral_thread_t,waiting);
	ACORAL_ASSERT(thread,"in time deal");
	thread->delay--;
	for(tmp=head->next;tmp!=head;){
300047c8:	e59d2000 	ldr	r2, [sp]
300047cc:	e59d3008 	ldr	r3, [sp, #8]
300047d0:	e1520003 	cmp	r2, r3
300047d4:	1affffdf 	bne	30004758 <time_delay_deal+0x6c>
300047d8:	ea000002 	b	300047e8 <time_delay_deal+0xfc>
void time_delay_deal(){
	acoral_list_t   *tmp,*tmp1,*head;
	acoral_thread_t *thread;
	head = &time_delay_queue.head;
	if(acoral_list_empty(head))
	  	return;
300047dc:	e1a00000 	nop			; (mov r0, r0)
300047e0:	ea000000 	b	300047e8 <time_delay_deal+0xfc>
	thread->delay--;
	for(tmp=head->next;tmp!=head;){
		thread=list_entry(tmp,acoral_thread_t,waiting);
		ACORAL_ASSERT(thread,"in time deal for");
		if(thread->delay>0)
		    break;
300047e4:	e1a00000 	nop			; (mov r0, r0)
#endif
		tmp=tmp1;
		thread->state&=~ACORAL_THREAD_STATE_DELAY;
		acoral_rdy_thread(thread);
	}
}
300047e8:	e28dd014 	add	sp, sp, #20
300047ec:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300047f0:	e12fff1e 	bx	lr
300047f4:	3002b134 	.word	0x3002b134
300047f8:	30026000 	.word	0x30026000
300047fc:	30026010 	.word	0x30026010

30004800 <timeout_queue_add>:
/*================================
 *  
 *    将线程挂到超时队列上
 *================================*/
void timeout_queue_add(acoral_thread_t *new)
{
30004800:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004804:	e24dd02c 	sub	sp, sp, #44	; 0x2c
30004808:	e58d0004 	str	r0, [sp, #4]
	acoral_sr cpu_sr;
	acoral_list_t   *tmp, *tmp1,*head;
	acoral_thread_t *thread;
	acoral_32  delay2;
	acoral_32  delay= new->delay;
3000480c:	e59d3004 	ldr	r3, [sp, #4]
30004810:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30004814:	e58d3024 	str	r3, [sp, #36]	; 0x24
	head=&timeout_queue.head;
30004818:	e59f30e4 	ldr	r3, [pc, #228]	; 30004904 <timeout_queue_add+0x104>
3000481c:	e58d3018 	str	r3, [sp, #24]
	HAL_ENTER_CRITICAL();
30004820:	ebfff3b3 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30004824:	e1a03000 	mov	r3, r0
30004828:	e58d300c 	str	r3, [sp, #12]
		/*获取下一个成员锁*/
		acoral_spin_lock(&tmp1->lock);
		acoral_spin_unlock(&tmp->lock);
	}
#else
	for (tmp=head->next;delay2=delay,tmp!=head; tmp=tmp->next){
3000482c:	e59d3018 	ldr	r3, [sp, #24]
30004830:	e5933000 	ldr	r3, [r3]
30004834:	e58d3010 	str	r3, [sp, #16]
30004838:	ea00000d 	b	30004874 <timeout_queue_add+0x74>
		thread = list_entry (tmp, acoral_thread_t, timeout);
3000483c:	e59d3010 	ldr	r3, [sp, #16]
30004840:	e2433018 	sub	r3, r3, #24
30004844:	e58d301c 	str	r3, [sp, #28]
		delay  = delay-thread->delay;
30004848:	e59d301c 	ldr	r3, [sp, #28]
3000484c:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30004850:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30004854:	e0633002 	rsb	r3, r3, r2
30004858:	e58d3024 	str	r3, [sp, #36]	; 0x24
		if (delay < 0)
3000485c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30004860:	e3530000 	cmp	r3, #0
30004864:	ba000009 	blt	30004890 <timeout_queue_add+0x90>
		/*获取下一个成员锁*/
		acoral_spin_lock(&tmp1->lock);
		acoral_spin_unlock(&tmp->lock);
	}
#else
	for (tmp=head->next;delay2=delay,tmp!=head; tmp=tmp->next){
30004868:	e59d3010 	ldr	r3, [sp, #16]
3000486c:	e5933000 	ldr	r3, [r3]
30004870:	e58d3010 	str	r3, [sp, #16]
30004874:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30004878:	e58d3020 	str	r3, [sp, #32]
3000487c:	e59d2010 	ldr	r2, [sp, #16]
30004880:	e59d3018 	ldr	r3, [sp, #24]
30004884:	e1520003 	cmp	r2, r3
30004888:	1affffeb 	bne	3000483c <timeout_queue_add+0x3c>
3000488c:	ea000000 	b	30004894 <timeout_queue_add+0x94>
		thread = list_entry (tmp, acoral_thread_t, timeout);
		delay  = delay-thread->delay;
		if (delay < 0)
			break;
30004890:	e1a00000 	nop			; (mov r0, r0)
	}
	new->delay = delay2;
30004894:	e59d3004 	ldr	r3, [sp, #4]
30004898:	e59d2020 	ldr	r2, [sp, #32]
3000489c:	e5832040 	str	r2, [r3, #64]	; 0x40
	acoral_list_add(&new->timeout,tmp->prev);
300048a0:	e59d3004 	ldr	r3, [sp, #4]
300048a4:	e2832018 	add	r2, r3, #24
300048a8:	e59d3010 	ldr	r3, [sp, #16]
300048ac:	e5933004 	ldr	r3, [r3, #4]
300048b0:	e1a00002 	mov	r0, r2
300048b4:	e1a01003 	mov	r1, r3
300048b8:	eb001635 	bl	3000a194 <acoral_list_add>
	/* 插入等待任务后，后继等待任务时间处理*/
	if(tmp != head){
300048bc:	e59d2010 	ldr	r2, [sp, #16]
300048c0:	e59d3018 	ldr	r3, [sp, #24]
300048c4:	e1520003 	cmp	r2, r3
300048c8:	0a000008 	beq	300048f0 <timeout_queue_add+0xf0>
		thread = list_entry(tmp, acoral_thread_t, timeout);
300048cc:	e59d3010 	ldr	r3, [sp, #16]
300048d0:	e2433018 	sub	r3, r3, #24
300048d4:	e58d301c 	str	r3, [sp, #28]
		thread->delay-=delay2;
300048d8:	e59d301c 	ldr	r3, [sp, #28]
300048dc:	e5932040 	ldr	r2, [r3, #64]	; 0x40
300048e0:	e59d3020 	ldr	r3, [sp, #32]
300048e4:	e0632002 	rsb	r2, r3, r2
300048e8:	e59d301c 	ldr	r3, [sp, #28]
300048ec:	e5832040 	str	r2, [r3, #64]	; 0x40
	}
#endif

	HAL_EXIT_CRITICAL();
300048f0:	e59d000c 	ldr	r0, [sp, #12]
300048f4:	ebfff37c 	bl	300016ec <HAL_INTR_RESTORE>
	return;
}
300048f8:	e28dd02c 	add	sp, sp, #44	; 0x2c
300048fc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004900:	e12fff1e 	bx	lr
30004904:	3002b1b4 	.word	0x3002b1b4

30004908 <timeout_queue_del>:
/*================================
 *  
 *    将线程超时队列删除
 *================================*/
void timeout_queue_del(acoral_thread_t *new)
{
30004908:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000490c:	e24dd014 	sub	sp, sp, #20
30004910:	e58d0004 	str	r0, [sp, #4]
	acoral_list_t  *p, *q;
	
	if (acoral_list_empty(&new->timeout))
30004914:	e59d3004 	ldr	r3, [sp, #4]
30004918:	e5932018 	ldr	r2, [r3, #24]
3000491c:	e59d3004 	ldr	r3, [sp, #4]
30004920:	e2833018 	add	r3, r3, #24
30004924:	e1520003 	cmp	r2, r3
30004928:	0a00000b 	beq	3000495c <timeout_queue_del+0x54>
		return;

	p = new->timeout.prev;
3000492c:	e59d3004 	ldr	r3, [sp, #4]
30004930:	e593301c 	ldr	r3, [r3, #28]
30004934:	e58d3008 	str	r3, [sp, #8]
	q = &new->timeout;
30004938:	e59d3004 	ldr	r3, [sp, #4]
3000493c:	e2833018 	add	r3, r3, #24
30004940:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&p->lock);
	acoral_spin_lock(&q->lock);
	acoral_list_del(&new->timeout);
30004944:	e59d3004 	ldr	r3, [sp, #4]
30004948:	e2833018 	add	r3, r3, #24
3000494c:	e1a00003 	mov	r0, r3
30004950:	eb001635 	bl	3000a22c <acoral_list_del>
	acoral_spin_unlock(&q->lock);
	acoral_spin_unlock(&p->lock);
	return;
30004954:	e1a00000 	nop			; (mov r0, r0)
30004958:	ea000000 	b	30004960 <timeout_queue_del+0x58>
void timeout_queue_del(acoral_thread_t *new)
{
	acoral_list_t  *p, *q;
	
	if (acoral_list_empty(&new->timeout))
		return;
3000495c:	e1a00000 	nop			; (mov r0, r0)
	acoral_spin_lock(&q->lock);
	acoral_list_del(&new->timeout);
	acoral_spin_unlock(&q->lock);
	acoral_spin_unlock(&p->lock);
	return;
}
30004960:	e28dd014 	add	sp, sp, #20
30004964:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004968:	e12fff1e 	bx	lr

3000496c <timeout_delay_deal>:
/*---------------------*/
/*  超时链表处理函数*/
/*   pegasus  0719*/
/*---------------------*/
void timeout_delay_deal()
{
3000496c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004970:	e24dd014 	sub	sp, sp, #20
	acoral_list_t *tmp, *tmp1, *head;
	acoral_thread_t  *thread;

	head = &timeout_queue.head;
30004974:	e59f30f4 	ldr	r3, [pc, #244]	; 30004a70 <timeout_delay_deal+0x104>
30004978:	e58d3008 	str	r3, [sp, #8]
	if(acoral_list_empty(head))
3000497c:	e59d3008 	ldr	r3, [sp, #8]
30004980:	e5932000 	ldr	r2, [r3]
30004984:	e59d3008 	ldr	r3, [sp, #8]
30004988:	e1520003 	cmp	r2, r3
3000498c:	0a000031 	beq	30004a58 <timeout_delay_deal+0xec>
	{
	  	return;
	}

	thread=list_entry(head->next,acoral_thread_t,timeout);
30004990:	e59d3008 	ldr	r3, [sp, #8]
30004994:	e5933000 	ldr	r3, [r3]
30004998:	e2433018 	sub	r3, r3, #24
3000499c:	e58d300c 	str	r3, [sp, #12]
	ACORAL_ASSERT(thread,"in timeout deal");
300049a0:	e59d200c 	ldr	r2, [sp, #12]
300049a4:	e59f30c8 	ldr	r3, [pc, #200]	; 30004a74 <timeout_delay_deal+0x108>
300049a8:	e1a00002 	mov	r0, r2
300049ac:	e1a01003 	mov	r1, r3
300049b0:	ebfffca1 	bl	30003c3c <acoral_assert_res>
	if (thread->delay>0)
300049b4:	e59d300c 	ldr	r3, [sp, #12]
300049b8:	e5933040 	ldr	r3, [r3, #64]	; 0x40
300049bc:	e3530000 	cmp	r3, #0
300049c0:	da000004 	ble	300049d8 <timeout_delay_deal+0x6c>
		thread->delay--;
300049c4:	e59d300c 	ldr	r3, [sp, #12]
300049c8:	e5933040 	ldr	r3, [r3, #64]	; 0x40
300049cc:	e2432001 	sub	r2, r3, #1
300049d0:	e59d300c 	ldr	r3, [sp, #12]
300049d4:	e5832040 	str	r2, [r3, #64]	; 0x40
	for(tmp=head->next;tmp!=head;)
300049d8:	e59d3008 	ldr	r3, [sp, #8]
300049dc:	e5933000 	ldr	r3, [r3]
300049e0:	e58d3000 	str	r3, [sp]
300049e4:	ea000016 	b	30004a44 <timeout_delay_deal+0xd8>
	{
		thread=list_entry(tmp,acoral_thread_t,timeout);
300049e8:	e59d3000 	ldr	r3, [sp]
300049ec:	e2433018 	sub	r3, r3, #24
300049f0:	e58d300c 	str	r3, [sp, #12]
		ACORAL_ASSERT(thread,"in timeout deal");
300049f4:	e59d200c 	ldr	r2, [sp, #12]
300049f8:	e59f3074 	ldr	r3, [pc, #116]	; 30004a74 <timeout_delay_deal+0x108>
300049fc:	e1a00002 	mov	r0, r2
30004a00:	e1a01003 	mov	r1, r3
30004a04:	ebfffc8c 	bl	30003c3c <acoral_assert_res>
		if(thread->delay>0)
30004a08:	e59d300c 	ldr	r3, [sp, #12]
30004a0c:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30004a10:	e3530000 	cmp	r3, #0
30004a14:	ca000011 	bgt	30004a60 <timeout_delay_deal+0xf4>
		    break;
#ifndef CFG_TICKS_PRIVATE
		acoral_spin_lock(&head->lock);
		acoral_spin_lock(&tmp->lock);
#endif
		tmp1=tmp->next;
30004a18:	e59d3000 	ldr	r3, [sp]
30004a1c:	e5933000 	ldr	r3, [r3]
30004a20:	e58d3004 	str	r3, [sp, #4]
		acoral_list_del(&thread->timeout);
30004a24:	e59d300c 	ldr	r3, [sp, #12]
30004a28:	e2833018 	add	r3, r3, #24
30004a2c:	e1a00003 	mov	r0, r3
30004a30:	eb0015fd 	bl	3000a22c <acoral_list_del>
#ifndef CFG_TICKS_PRIVATE
		acoral_spin_unlock(&tmp->lock);
		acoral_spin_unlock(&head->lock);
#endif
		tmp=tmp1;
30004a34:	e59d3004 	ldr	r3, [sp, #4]
30004a38:	e58d3000 	str	r3, [sp]
		/*thread->state*/
		acoral_rdy_thread(thread);
30004a3c:	e59d000c 	ldr	r0, [sp, #12]
30004a40:	ebfff84a 	bl	30002b70 <acoral_rdy_thread>

	thread=list_entry(head->next,acoral_thread_t,timeout);
	ACORAL_ASSERT(thread,"in timeout deal");
	if (thread->delay>0)
		thread->delay--;
	for(tmp=head->next;tmp!=head;)
30004a44:	e59d2000 	ldr	r2, [sp]
30004a48:	e59d3008 	ldr	r3, [sp, #8]
30004a4c:	e1520003 	cmp	r2, r3
30004a50:	1affffe4 	bne	300049e8 <timeout_delay_deal+0x7c>
30004a54:	ea000002 	b	30004a64 <timeout_delay_deal+0xf8>
	acoral_thread_t  *thread;

	head = &timeout_queue.head;
	if(acoral_list_empty(head))
	{
	  	return;
30004a58:	e1a00000 	nop			; (mov r0, r0)
30004a5c:	ea000000 	b	30004a64 <timeout_delay_deal+0xf8>
	for(tmp=head->next;tmp!=head;)
	{
		thread=list_entry(tmp,acoral_thread_t,timeout);
		ACORAL_ASSERT(thread,"in timeout deal");
		if(thread->delay>0)
		    break;
30004a60:	e1a00000 	nop			; (mov r0, r0)
#endif
		tmp=tmp1;
		/*thread->state*/
		acoral_rdy_thread(thread);
	}
}
30004a64:	e28dd014 	add	sp, sp, #20
30004a68:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004a6c:	e12fff1e 	bx	lr
30004a70:	3002b1b4 	.word	0x3002b1b4
30004a74:	30026024 	.word	0x30026024

30004a78 <acoral_mem_sys_init>:
#include<mem.h>
/*================================
 *   memory system initialize
 *	内存管理系统初始化
 *================================*/
void acoral_mem_sys_init(){
30004a78:	e92d4008 	push	{r3, lr}
	/*硬件相关的内存初始化，比如内存控制器等*/
  	HAL_MEM_INIT();
30004a7c:	ebffefbc 	bl	30000974 <hal_mem_init>
	/*堆初始化,这个可以选择不同管理系统，比如buddy内存管理等*/
  	acoral_mem_init((acoral_u32)HAL_HEAP_START,(acoral_u32)HAL_HEAP_END);
30004a80:	e59f2018 	ldr	r2, [pc, #24]	; 30004aa0 <acoral_mem_sys_init+0x28>
30004a84:	e59f3018 	ldr	r3, [pc, #24]	; 30004aa4 <acoral_mem_sys_init+0x2c>
30004a88:	e1a00002 	mov	r0, r2
30004a8c:	e1a01003 	mov	r1, r3
30004a90:	eb000335 	bl	3000576c <buddy_init>
#ifdef CFG_MEM2
  	acoral_mem_init2();
30004a94:	eb000998 	bl	300070fc <v_mem_init>
#endif
}
30004a98:	e8bd4008 	pop	{r3, lr}
30004a9c:	e12fff1e 	bx	lr
30004aa0:	3002b37c 	.word	0x3002b37c
30004aa4:	33eff000 	.word	0x33eff000

30004aa8 <spin_lock_intr_save>:
#include <hal.h>
#include <spinlock.h>
#include <lsched.h>
acoral_sr spin_lock_intr_save(acoral_spinlock_t *v){
30004aa8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004aac:	e24dd014 	sub	sp, sp, #20
30004ab0:	e58d0004 	str	r0, [sp, #4]
	acoral_sr sr;
	sr=HAL_INTR_DISABLE_SAVE();
30004ab4:	ebfff30e 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30004ab8:	e1a03000 	mov	r3, r0
30004abc:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(v);
	return sr;
30004ac0:	e59d300c 	ldr	r3, [sp, #12]
}
30004ac4:	e1a00003 	mov	r0, r3
30004ac8:	e28dd014 	add	sp, sp, #20
30004acc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004ad0:	e12fff1e 	bx	lr

30004ad4 <spin_unlock_intr_restore>:

void spin_unlock_intr_restore(acoral_sr sr,acoral_spinlock_t *v){
30004ad4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004ad8:	e24dd00c 	sub	sp, sp, #12
30004adc:	e58d0004 	str	r0, [sp, #4]
30004ae0:	e58d1000 	str	r1, [sp]
	acoral_spin_unlock(v);
	HAL_INTR_RESTORE(sr);
30004ae4:	e59d0004 	ldr	r0, [sp, #4]
30004ae8:	ebfff2ff 	bl	300016ec <HAL_INTR_RESTORE>
}
30004aec:	e28dd00c 	add	sp, sp, #12
30004af0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004af4:	e12fff1e 	bx	lr

30004af8 <spin_lock_intr>:

void spin_lock_intr(acoral_spinlock_t *v){
30004af8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004afc:	e24dd00c 	sub	sp, sp, #12
30004b00:	e58d0004 	str	r0, [sp, #4]
	HAL_INTR_DISABLE();
30004b04:	ebfff2f3 	bl	300016d8 <HAL_INTR_DISABLE>
	acoral_spin_lock(v);
}
30004b08:	e28dd00c 	add	sp, sp, #12
30004b0c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004b10:	e12fff1e 	bx	lr

30004b14 <spin_unlock_intr>:

void spin_unlock_intr(acoral_spinlock_t *v){
30004b14:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004b18:	e24dd00c 	sub	sp, sp, #12
30004b1c:	e58d0004 	str	r0, [sp, #4]
	acoral_spin_unlock(v);
	HAL_INTR_ENABLE();
30004b20:	ebfff2e8 	bl	300016c8 <HAL_INTR_ENABLE>
}
30004b24:	e28dd00c 	add	sp, sp, #12
30004b28:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004b2c:	e12fff1e 	bx	lr

30004b30 <spin_lock_stamp>:

void spin_lock_stamp(acoral_spinlock_t *v){
30004b30:	e24dd008 	sub	sp, sp, #8
30004b34:	e58d0004 	str	r0, [sp, #4]
	acoral_sched_lock();
30004b38:	e59f300c 	ldr	r3, [pc, #12]	; 30004b4c <spin_lock_stamp+0x1c>
30004b3c:	e3a02001 	mov	r2, #1
30004b40:	e5c32000 	strb	r2, [r3]
	acoral_spin_lock(v);
}
30004b44:	e28dd008 	add	sp, sp, #8
30004b48:	e12fff1e 	bx	lr
30004b4c:	3002a14c 	.word	0x3002a14c

30004b50 <spin_unlock_stamp>:

void spin_unlock_stamp(acoral_spinlock_t *v){
30004b50:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004b54:	e24dd00c 	sub	sp, sp, #12
30004b58:	e58d0004 	str	r0, [sp, #4]
	acoral_spin_unlock(v);
	acoral_sched_unlock();
30004b5c:	ebfff529 	bl	30002008 <acoral_sched_unlock>
}
30004b60:	e28dd00c 	add	sp, sp, #12
30004b64:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004b68:	e12fff1e 	bx	lr

30004b6c <acoral_evt_sys_init>:
#include "acoral.h"
#include "event.h"
acoral_pool_ctrl_t acoral_evt_pool_ctrl;
void acoral_evt_sys_init(){
30004b6c:	e92d4008 	push	{r3, lr}
	acoral_evt_pool_init();
30004b70:	eb000001 	bl	30004b7c <acoral_evt_pool_init>
}
30004b74:	e8bd4008 	pop	{r3, lr}
30004b78:	e12fff1e 	bx	lr

30004b7c <acoral_evt_pool_init>:

void acoral_evt_pool_init(){
30004b7c:	e92d4008 	push	{r3, lr}
	acoral_evt_pool_ctrl.type=ACORAL_RES_EVENT;
30004b80:	e59f3048 	ldr	r3, [pc, #72]	; 30004bd0 <acoral_evt_pool_init+0x54>
30004b84:	e3a02002 	mov	r2, #2
30004b88:	e5832000 	str	r2, [r3]
	acoral_evt_pool_ctrl.size=sizeof(acoral_evt_t);
30004b8c:	e59f303c 	ldr	r3, [pc, #60]	; 30004bd0 <acoral_evt_pool_init+0x54>
30004b90:	e3a02024 	mov	r2, #36	; 0x24
30004b94:	e5832004 	str	r2, [r3, #4]
	acoral_evt_pool_ctrl.num_per_pool=8;
30004b98:	e59f3030 	ldr	r3, [pc, #48]	; 30004bd0 <acoral_evt_pool_init+0x54>
30004b9c:	e3a02008 	mov	r2, #8
30004ba0:	e5832008 	str	r2, [r3, #8]
	acoral_evt_pool_ctrl.num=0;
30004ba4:	e59f3024 	ldr	r3, [pc, #36]	; 30004bd0 <acoral_evt_pool_init+0x54>
30004ba8:	e3a02000 	mov	r2, #0
30004bac:	e583200c 	str	r2, [r3, #12]
	acoral_evt_pool_ctrl.max_pools=4;
30004bb0:	e59f3018 	ldr	r3, [pc, #24]	; 30004bd0 <acoral_evt_pool_init+0x54>
30004bb4:	e3a02004 	mov	r2, #4
30004bb8:	e5832010 	str	r2, [r3, #16]
	acoral_pool_ctrl_init(&acoral_evt_pool_ctrl);
30004bbc:	e59f000c 	ldr	r0, [pc, #12]	; 30004bd0 <acoral_evt_pool_init+0x54>
30004bc0:	ebfffbaa 	bl	30003a70 <acoral_pool_ctrl_init>
#ifdef CFG_MSG
	acoral_msg_sys_init();
30004bc4:	eb000bfc 	bl	30007bbc <acoral_msg_sys_init>
#endif
}
30004bc8:	e8bd4008 	pop	{r3, lr}
30004bcc:	e12fff1e 	bx	lr
30004bd0:	3002b140 	.word	0x3002b140

30004bd4 <acoral_alloc_evt>:

acoral_evt_t *acoral_alloc_evt(){
30004bd4:	e92d4008 	push	{r3, lr}
  	return (acoral_evt_t *)acoral_get_res(&acoral_evt_pool_ctrl);
30004bd8:	e59f0010 	ldr	r0, [pc, #16]	; 30004bf0 <acoral_alloc_evt+0x1c>
30004bdc:	ebfffa44 	bl	300034f4 <acoral_get_res>
30004be0:	e1a03000 	mov	r3, r0
}
30004be4:	e1a00003 	mov	r0, r3
30004be8:	e8bd4008 	pop	{r3, lr}
30004bec:	e12fff1e 	bx	lr
30004bf0:	3002b140 	.word	0x3002b140

30004bf4 <acoral_evt_init>:

void acoral_evt_init(acoral_evt_t *evt){
30004bf4:	e24dd008 	sub	sp, sp, #8
30004bf8:	e58d0004 	str	r0, [sp, #4]
	acoral_spin_init(&evt->spin_lock);
	acoral_list_init(&evt->wait_queue.head);
30004bfc:	e59d3004 	ldr	r3, [sp, #4]
30004c00:	e2832010 	add	r2, r3, #16
30004c04:	e59d3004 	ldr	r3, [sp, #4]
30004c08:	e5832010 	str	r2, [r3, #16]
30004c0c:	e59d3004 	ldr	r3, [sp, #4]
30004c10:	e2832010 	add	r2, r3, #16
30004c14:	e59d3004 	ldr	r3, [sp, #4]
30004c18:	e5832014 	str	r2, [r3, #20]
}
30004c1c:	e28dd008 	add	sp, sp, #8
30004c20:	e12fff1e 	bx	lr

30004c24 <acoral_evt_queue_empty>:

bool acoral_evt_queue_empty(acoral_evt_t *evt){
30004c24:	e24dd008 	sub	sp, sp, #8
30004c28:	e58d0004 	str	r0, [sp, #4]
	return acoral_list_empty(&evt->wait_queue.head);
30004c2c:	e59d3004 	ldr	r3, [sp, #4]
30004c30:	e5932010 	ldr	r2, [r3, #16]
30004c34:	e59d3004 	ldr	r3, [sp, #4]
30004c38:	e2833010 	add	r3, r3, #16
30004c3c:	e1520003 	cmp	r2, r3
30004c40:	13a03000 	movne	r3, #0
30004c44:	03a03001 	moveq	r3, #1
30004c48:	e1a03c03 	lsl	r3, r3, #24
30004c4c:	e1a03c43 	asr	r3, r3, #24
}
30004c50:	e1a00003 	mov	r0, r3
30004c54:	e28dd008 	add	sp, sp, #8
30004c58:	e12fff1e 	bx	lr

30004c5c <acoral_evt_high_thread>:

acoral_thread_t *acoral_evt_high_thread(acoral_evt_t *evt){
30004c5c:	e24dd010 	sub	sp, sp, #16
30004c60:	e58d0004 	str	r0, [sp, #4]
	acoral_list_t *head;
	acoral_thread_t *thread;
	head=&evt->wait_queue.head;
30004c64:	e59d3004 	ldr	r3, [sp, #4]
30004c68:	e2833010 	add	r3, r3, #16
30004c6c:	e58d3008 	str	r3, [sp, #8]
	if(acoral_list_empty(head))
30004c70:	e59d3008 	ldr	r3, [sp, #8]
30004c74:	e5932000 	ldr	r2, [r3]
30004c78:	e59d3008 	ldr	r3, [sp, #8]
30004c7c:	e1520003 	cmp	r2, r3
30004c80:	1a000001 	bne	30004c8c <acoral_evt_high_thread+0x30>
		return NULL;
30004c84:	e3a03000 	mov	r3, #0
30004c88:	ea000004 	b	30004ca0 <acoral_evt_high_thread+0x44>
	thread=list_entry(head->next,acoral_thread_t,waiting);
30004c8c:	e59d3008 	ldr	r3, [sp, #8]
30004c90:	e5933000 	ldr	r3, [r3]
30004c94:	e2433020 	sub	r3, r3, #32
30004c98:	e58d300c 	str	r3, [sp, #12]
	return thread;	
30004c9c:	e59d300c 	ldr	r3, [sp, #12]
}
30004ca0:	e1a00003 	mov	r0, r3
30004ca4:	e28dd010 	add	sp, sp, #16
30004ca8:	e12fff1e 	bx	lr

30004cac <acoral_evt_queue_add>:

void acoral_evt_queue_add(acoral_evt_t *evt,acoral_thread_t *new){
30004cac:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004cb0:	e24dd01c 	sub	sp, sp, #28
30004cb4:	e58d0004 	str	r0, [sp, #4]
30004cb8:	e58d1000 	str	r1, [sp]
	acoral_list_t *head,*tmp;
	acoral_thread_t *thread;
  	new->evt=evt;
30004cbc:	e59d3000 	ldr	r3, [sp]
30004cc0:	e59d2004 	ldr	r2, [sp, #4]
30004cc4:	e5832030 	str	r2, [r3, #48]	; 0x30
	head=&evt->wait_queue.head;
30004cc8:	e59d3004 	ldr	r3, [sp, #4]
30004ccc:	e2833010 	add	r3, r3, #16
30004cd0:	e58d300c 	str	r3, [sp, #12]
	for(tmp=head->next;tmp!=head;tmp=tmp->next){
30004cd4:	e59d300c 	ldr	r3, [sp, #12]
30004cd8:	e5933000 	ldr	r3, [r3]
30004cdc:	e58d3010 	str	r3, [sp, #16]
30004ce0:	ea000010 	b	30004d28 <acoral_evt_queue_add+0x7c>
		thread=list_entry(tmp,acoral_thread_t,waiting);
30004ce4:	e59d3010 	ldr	r3, [sp, #16]
30004ce8:	e2433020 	sub	r3, r3, #32
30004cec:	e58d3014 	str	r3, [sp, #20]
		/*如果线程资源已经不在使用，即release状态则释放*/
		if(thread->prio>new->prio)
30004cf0:	e59d3014 	ldr	r3, [sp, #20]
30004cf4:	e5d32005 	ldrb	r2, [r3, #5]
30004cf8:	e59d3000 	ldr	r3, [sp]
30004cfc:	e5d33005 	ldrb	r3, [r3, #5]
30004d00:	e1520003 	cmp	r2, r3
30004d04:	8a00000c 	bhi	30004d3c <acoral_evt_queue_add+0x90>
			break;


		if(tmp == tmp->next)
30004d08:	e59d3010 	ldr	r3, [sp, #16]
30004d0c:	e5932000 	ldr	r2, [r3]
30004d10:	e59d3010 	ldr	r3, [sp, #16]
30004d14:	e1520003 	cmp	r2, r3
30004d18:	0a000009 	beq	30004d44 <acoral_evt_queue_add+0x98>
void acoral_evt_queue_add(acoral_evt_t *evt,acoral_thread_t *new){
	acoral_list_t *head,*tmp;
	acoral_thread_t *thread;
  	new->evt=evt;
	head=&evt->wait_queue.head;
	for(tmp=head->next;tmp!=head;tmp=tmp->next){
30004d1c:	e59d3010 	ldr	r3, [sp, #16]
30004d20:	e5933000 	ldr	r3, [r3]
30004d24:	e58d3010 	str	r3, [sp, #16]
30004d28:	e59d2010 	ldr	r2, [sp, #16]
30004d2c:	e59d300c 	ldr	r3, [sp, #12]
30004d30:	e1520003 	cmp	r2, r3
30004d34:	1affffea 	bne	30004ce4 <acoral_evt_queue_add+0x38>
30004d38:	ea000002 	b	30004d48 <acoral_evt_queue_add+0x9c>
		thread=list_entry(tmp,acoral_thread_t,waiting);
		/*如果线程资源已经不在使用，即release状态则释放*/
		if(thread->prio>new->prio)
			break;
30004d3c:	e1a00000 	nop			; (mov r0, r0)
30004d40:	ea000000 	b	30004d48 <acoral_evt_queue_add+0x9c>


		if(tmp == tmp->next)
			break;
30004d44:	e1a00000 	nop			; (mov r0, r0)

	}
	acoral_list_add(&new->waiting,tmp->prev);
30004d48:	e59d3000 	ldr	r3, [sp]
30004d4c:	e2832020 	add	r2, r3, #32
30004d50:	e59d3010 	ldr	r3, [sp, #16]
30004d54:	e5933004 	ldr	r3, [r3, #4]
30004d58:	e1a00002 	mov	r0, r2
30004d5c:	e1a01003 	mov	r1, r3
30004d60:	eb00150b 	bl	3000a194 <acoral_list_add>
}
30004d64:	e28dd01c 	add	sp, sp, #28
30004d68:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004d6c:	e12fff1e 	bx	lr

30004d70 <acoral_evt_queue_del>:

void acoral_evt_queue_del(acoral_thread_t *thread){
30004d70:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004d74:	e24dd00c 	sub	sp, sp, #12
30004d78:	e58d0004 	str	r0, [sp, #4]
	acoral_list_del(&thread->waiting);
30004d7c:	e59d3004 	ldr	r3, [sp, #4]
30004d80:	e2833020 	add	r3, r3, #32
30004d84:	e1a00003 	mov	r0, r3
30004d88:	eb001527 	bl	3000a22c <acoral_list_del>
	thread->evt=NULL;
30004d8c:	e59d3004 	ldr	r3, [sp, #4]
30004d90:	e3a02000 	mov	r2, #0
30004d94:	e5832030 	str	r2, [r3, #48]	; 0x30
}
30004d98:	e28dd00c 	add	sp, sp, #12
30004d9c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004da0:	e12fff1e 	bx	lr

30004da4 <acoral_mutex_init>:
/*==============================
 *  The initialize of the mutex
 *       信号量初始化函数
 *==============================*/
acoral_u32 acoral_mutex_init(acoral_evt_t *evt, acoral_u8 prio)
{
30004da4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004da8:	e24dd00c 	sub	sp, sp, #12
30004dac:	e58d0004 	str	r0, [sp, #4]
30004db0:	e1a03001 	mov	r3, r1
30004db4:	e5cd3003 	strb	r3, [sp, #3]
	if ((acoral_evt_t*)0 == evt)
30004db8:	e59d3004 	ldr	r3, [sp, #4]
30004dbc:	e3530000 	cmp	r3, #0
30004dc0:	1a000001 	bne	30004dcc <acoral_mutex_init+0x28>
	{
		return MUTEX_ERR_NULL;
30004dc4:	e3a03002 	mov	r3, #2
30004dc8:	ea00000d 	b	30004e04 <acoral_mutex_init+0x60>
	}
	evt->count  = (prio << 8) | MUTEX_AVAI;
30004dcc:	e5dd3003 	ldrb	r3, [sp, #3]
30004dd0:	e1a03403 	lsl	r3, r3, #8
30004dd4:	e38320ff 	orr	r2, r3, #255	; 0xff
30004dd8:	e59d3004 	ldr	r3, [sp, #4]
30004ddc:	e583200c 	str	r2, [r3, #12]
	evt->type = ACORAL_EVENT_MUTEX;
30004de0:	e59d3004 	ldr	r3, [sp, #4]
30004de4:	e3a02001 	mov	r2, #1
30004de8:	e5c32004 	strb	r2, [r3, #4]
	evt->data = NULL;
30004dec:	e59d3004 	ldr	r3, [sp, #4]
30004df0:	e3a02000 	mov	r2, #0
30004df4:	e5832020 	str	r2, [r3, #32]
	acoral_evt_init(evt);
30004df8:	e59d0004 	ldr	r0, [sp, #4]
30004dfc:	ebffff7c 	bl	30004bf4 <acoral_evt_init>
	return MUTEX_SUCCED;
30004e00:	e3a03000 	mov	r3, #0
}
30004e04:	e1a00003 	mov	r0, r3
30004e08:	e28dd00c 	add	sp, sp, #12
30004e0c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004e10:	e12fff1e 	bx	lr

30004e14 <acoral_mutex_create>:
/*==============================
 *  The creation of the mutex
 *       信号量创建函数
 *==============================*/
acoral_evt_t *acoral_mutex_create(acoral_u8 prio, acoral_u32 *err)
{
30004e14:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004e18:	e24dd014 	sub	sp, sp, #20
30004e1c:	e1a03000 	mov	r3, r0
30004e20:	e58d1000 	str	r1, [sp]
30004e24:	e5cd3007 	strb	r3, [sp, #7]
	acoral_evt_t *evt;

	/* 是否大于最小优先线，和是否该优先级已占用*/
	evt = acoral_alloc_evt();      /* alloc a RAM for the event*/
30004e28:	ebffff69 	bl	30004bd4 <acoral_alloc_evt>
30004e2c:	e1a03000 	mov	r3, r0
30004e30:	e58d300c 	str	r3, [sp, #12]
	if (NULL == evt)
30004e34:	e59d300c 	ldr	r3, [sp, #12]
30004e38:	e3530000 	cmp	r3, #0
30004e3c:	1a000004 	bne	30004e54 <acoral_mutex_create+0x40>
	{
		*err = MUTEX_ERR_NULL;
30004e40:	e59d3000 	ldr	r3, [sp]
30004e44:	e3a02002 	mov	r2, #2
30004e48:	e5832000 	str	r2, [r3]
		return NULL;
30004e4c:	e3a03000 	mov	r3, #0
30004e50:	ea00000e 	b	30004e90 <acoral_mutex_create+0x7c>
	}
	evt->count  = (prio << 16) | MUTEX_AVAI | MUTEX_U_MASK;
30004e54:	e5dd3007 	ldrb	r3, [sp, #7]
30004e58:	e1a03803 	lsl	r3, r3, #16
30004e5c:	e1e03823 	mvn	r3, r3, lsr #16
30004e60:	e1e03803 	mvn	r3, r3, lsl #16
30004e64:	e59d200c 	ldr	r2, [sp, #12]
30004e68:	e582300c 	str	r3, [r2, #12]
	evt->type = ACORAL_EVENT_MUTEX;
30004e6c:	e59d300c 	ldr	r3, [sp, #12]
30004e70:	e3a02001 	mov	r2, #1
30004e74:	e5c32004 	strb	r2, [r3, #4]
	evt->data = NULL;
30004e78:	e59d300c 	ldr	r3, [sp, #12]
30004e7c:	e3a02000 	mov	r2, #0
30004e80:	e5832020 	str	r2, [r3, #32]
	acoral_evt_init(evt);
30004e84:	e59d000c 	ldr	r0, [sp, #12]
30004e88:	ebffff59 	bl	30004bf4 <acoral_evt_init>
	return evt;
30004e8c:	e59d300c 	ldr	r3, [sp, #12]
}
30004e90:	e1a00003 	mov	r0, r3
30004e94:	e28dd014 	add	sp, sp, #20
30004e98:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004e9c:	e12fff1e 	bx	lr

30004ea0 <acoral_mutex_del>:
/*=============================
 *  The deletion of the mutex
 *      信号号删除函数
 *============================= */
acoral_u32 acoral_mutex_del(acoral_evt_t *evt, acoral_u32 opt)
{
30004ea0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004ea4:	e24dd014 	sub	sp, sp, #20
30004ea8:	e58d0004 	str	r0, [sp, #4]
30004eac:	e58d1000 	str	r1, [sp]
	acoral_sr            cpu_sr;

	/* 参数检测 */
	if (NULL == evt)
30004eb0:	e59d3004 	ldr	r3, [sp, #4]
30004eb4:	e3530000 	cmp	r3, #0
30004eb8:	1a000001 	bne	30004ec4 <acoral_mutex_del+0x24>
	{
		return MUTEX_ERR_NULL; /*error*/
30004ebc:	e3a03002 	mov	r3, #2
30004ec0:	ea000015 	b	30004f1c <acoral_mutex_del+0x7c>
	}

	if ( ACORAL_EVENT_MUTEX != evt->type )
30004ec4:	e59d3004 	ldr	r3, [sp, #4]
30004ec8:	e5d33004 	ldrb	r3, [r3, #4]
30004ecc:	e3530001 	cmp	r3, #1
30004ed0:	0a000001 	beq	30004edc <acoral_mutex_del+0x3c>
	{
		return MUTEX_ERR_TYPE; /*error*/
30004ed4:	e3a03003 	mov	r3, #3
30004ed8:	ea00000f 	b	30004f1c <acoral_mutex_del+0x7c>
	}

	/* 是否有任务等待*/
	HAL_ENTER_CRITICAL();
30004edc:	ebfff204 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30004ee0:	e1a03000 	mov	r3, r0
30004ee4:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&evt->spin_lock);
	if (acoral_evt_queue_empty(evt))
30004ee8:	e59d0004 	ldr	r0, [sp, #4]
30004eec:	ebffff4c 	bl	30004c24 <acoral_evt_queue_empty>
30004ef0:	e1a03000 	mov	r3, r0
30004ef4:	e20330ff 	and	r3, r3, #255	; 0xff
30004ef8:	e3530000 	cmp	r3, #0
30004efc:	0a000003 	beq	30004f10 <acoral_mutex_del+0x70>
	{
		/*无等待任务删除*/
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30004f00:	e59d000c 	ldr	r0, [sp, #12]
30004f04:	ebfff1f8 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_SUCCED;
30004f08:	e3a03000 	mov	r3, #0
30004f0c:	ea000002 	b	30004f1c <acoral_mutex_del+0x7c>
	}
	else
	{
		/*有等待任务*/
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30004f10:	e59d000c 	ldr	r0, [sp, #12]
30004f14:	ebfff1f4 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_TASK_EXIST;
30004f18:	e3a03004 	mov	r3, #4
	}
}
30004f1c:	e1a00003 	mov	r0, r3
30004f20:	e28dd014 	add	sp, sp, #20
30004f24:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004f28:	e12fff1e 	bx	lr

30004f2c <acoral_mutex_trypend>:
 *  the appliation for mutex
 *      信号号申请操作
 *  	  非阻塞式
 *=============================*/
acoral_u32 acoral_mutex_trypend(acoral_evt_t *evt)
{
30004f2c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004f30:	e24dd014 	sub	sp, sp, #20
30004f34:	e58d0004 	str	r0, [sp, #4]
	acoral_sr        cpu_sr;
	acoral_thread_t *cur;

	if(acoral_intr_nesting>0)
30004f38:	ebfff208 	bl	30001760 <hal_get_intr_nesting_comm>
30004f3c:	e1a03000 	mov	r3, r0
30004f40:	e3530000 	cmp	r3, #0
30004f44:	da000001 	ble	30004f50 <acoral_mutex_trypend+0x24>
		return MUTEX_ERR_INTR;
30004f48:	e3a03005 	mov	r3, #5
30004f4c:	ea000027 	b	30004ff0 <acoral_mutex_trypend+0xc4>
	
	cur=acoral_cur_thread;
30004f50:	e59f30a8 	ldr	r3, [pc, #168]	; 30005000 <acoral_mutex_trypend+0xd4>
30004f54:	e5933000 	ldr	r3, [r3]
30004f58:	e58d300c 	str	r3, [sp, #12]
	
	HAL_ENTER_CRITICAL();
30004f5c:	ebfff1e4 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30004f60:	e1a03000 	mov	r3, r0
30004f64:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&evt->spin_lock);
	if (NULL== evt)
30004f68:	e59d3004 	ldr	r3, [sp, #4]
30004f6c:	e3530000 	cmp	r3, #0
30004f70:	1a000003 	bne	30004f84 <acoral_mutex_trypend+0x58>
	{
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30004f74:	e59d0008 	ldr	r0, [sp, #8]
30004f78:	ebfff1db 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_NULL;
30004f7c:	e3a03002 	mov	r3, #2
30004f80:	ea00001a 	b	30004ff0 <acoral_mutex_trypend+0xc4>
	}
	
	if ((acoral_u8)(evt->count & MUTEX_L_MASK) == MUTEX_AVAI)
30004f84:	e59d3004 	ldr	r3, [sp, #4]
30004f88:	e593300c 	ldr	r3, [r3, #12]
30004f8c:	e20330ff 	and	r3, r3, #255	; 0xff
30004f90:	e35300ff 	cmp	r3, #255	; 0xff
30004f94:	1a000012 	bne	30004fe4 <acoral_mutex_trypend+0xb8>
	{
		/* 申请成功*/
		evt->count &= MUTEX_U_MASK;
30004f98:	e59d3004 	ldr	r3, [sp, #4]
30004f9c:	e593300c 	ldr	r3, [r3, #12]
30004fa0:	e2032cff 	and	r2, r3, #65280	; 0xff00
30004fa4:	e59d3004 	ldr	r3, [sp, #4]
30004fa8:	e583200c 	str	r2, [r3, #12]
		evt->count |= cur->prio;
30004fac:	e59d3004 	ldr	r3, [sp, #4]
30004fb0:	e593200c 	ldr	r2, [r3, #12]
30004fb4:	e59d300c 	ldr	r3, [sp, #12]
30004fb8:	e5d33005 	ldrb	r3, [r3, #5]
30004fbc:	e1822003 	orr	r2, r2, r3
30004fc0:	e59d3004 	ldr	r3, [sp, #4]
30004fc4:	e583200c 	str	r2, [r3, #12]
		evt->data = (void*)cur;
30004fc8:	e59d3004 	ldr	r3, [sp, #4]
30004fcc:	e59d200c 	ldr	r2, [sp, #12]
30004fd0:	e5832020 	str	r2, [r3, #32]
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30004fd4:	e59d0008 	ldr	r0, [sp, #8]
30004fd8:	ebfff1c3 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_SUCCED;
30004fdc:	e3a03000 	mov	r3, #0
30004fe0:	ea000002 	b	30004ff0 <acoral_mutex_trypend+0xc4>
	}

	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
30004fe4:	e59d0008 	ldr	r0, [sp, #8]
30004fe8:	ebfff1bf 	bl	300016ec <HAL_INTR_RESTORE>
	return MUTEX_ERR_TIMEOUT;
30004fec:	e3a03007 	mov	r3, #7
}
30004ff0:	e1a00003 	mov	r0, r3
30004ff4:	e28dd014 	add	sp, sp, #20
30004ff8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004ffc:	e12fff1e 	bx	lr
30005000:	3002b350 	.word	0x3002b350

30005004 <acoral_mutex_pend>:
 *  the appliation for mutex
 *      信号号申请操作
 *  优先级继承的优先级反转解决
 *=============================*/
acoral_u32 acoral_mutex_pend(acoral_evt_t *evt, acoral_time timeout)
{
30005004:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30005008:	e24dd01c 	sub	sp, sp, #28
3000500c:	e58d0004 	str	r0, [sp, #4]
30005010:	e58d1000 	str	r1, [sp]
	acoral_u8        highPrio;
	acoral_u8        ownerPrio;
	acoral_thread_t *thread;
	acoral_thread_t *cur;

	if(acoral_intr_nesting>0)
30005014:	ebfff1d1 	bl	30001760 <hal_get_intr_nesting_comm>
30005018:	e1a03000 	mov	r3, r0
3000501c:	e3530000 	cmp	r3, #0
30005020:	da000001 	ble	3000502c <acoral_mutex_pend+0x28>
		return MUTEX_ERR_INTR;
30005024:	e3a03005 	mov	r3, #5
30005028:	ea000087 	b	3000524c <acoral_mutex_pend+0x248>
	
	cur=acoral_cur_thread;
3000502c:	e59f3228 	ldr	r3, [pc, #552]	; 3000525c <acoral_mutex_pend+0x258>
30005030:	e5933000 	ldr	r3, [r3]
30005034:	e58d3014 	str	r3, [sp, #20]
	
	HAL_ENTER_CRITICAL();
30005038:	ebfff1ad 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000503c:	e1a03000 	mov	r3, r0
30005040:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&evt->spin_lock);
	if (NULL== evt)
30005044:	e59d3004 	ldr	r3, [sp, #4]
30005048:	e3530000 	cmp	r3, #0
3000504c:	1a000003 	bne	30005060 <acoral_mutex_pend+0x5c>
	{
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30005050:	e59d0008 	ldr	r0, [sp, #8]
30005054:	ebfff1a4 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_NULL;
30005058:	e3a03002 	mov	r3, #2
3000505c:	ea00007a 	b	3000524c <acoral_mutex_pend+0x248>
	}
	
	if ((acoral_u8)(evt->count & MUTEX_L_MASK) == MUTEX_AVAI)
30005060:	e59d3004 	ldr	r3, [sp, #4]
30005064:	e593300c 	ldr	r3, [r3, #12]
30005068:	e20330ff 	and	r3, r3, #255	; 0xff
3000506c:	e35300ff 	cmp	r3, #255	; 0xff
30005070:	1a000012 	bne	300050c0 <acoral_mutex_pend+0xbc>
	{
		/* 申请成功*/
		evt->count &= MUTEX_U_MASK;
30005074:	e59d3004 	ldr	r3, [sp, #4]
30005078:	e593300c 	ldr	r3, [r3, #12]
3000507c:	e2032cff 	and	r2, r3, #65280	; 0xff00
30005080:	e59d3004 	ldr	r3, [sp, #4]
30005084:	e583200c 	str	r2, [r3, #12]
		evt->count |= cur->prio;
30005088:	e59d3004 	ldr	r3, [sp, #4]
3000508c:	e593200c 	ldr	r2, [r3, #12]
30005090:	e59d3014 	ldr	r3, [sp, #20]
30005094:	e5d33005 	ldrb	r3, [r3, #5]
30005098:	e1822003 	orr	r2, r2, r3
3000509c:	e59d3004 	ldr	r3, [sp, #4]
300050a0:	e583200c 	str	r2, [r3, #12]
		evt->data = (void*)cur;
300050a4:	e59d3004 	ldr	r3, [sp, #4]
300050a8:	e59d2014 	ldr	r2, [sp, #20]
300050ac:	e5832020 	str	r2, [r3, #32]
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
300050b0:	e59d0008 	ldr	r0, [sp, #8]
300050b4:	ebfff18c 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_SUCCED;
300050b8:	e3a03000 	mov	r3, #0
300050bc:	ea000062 	b	3000524c <acoral_mutex_pend+0x248>
	}
	
	/* 互斥量已被占有*/
	highPrio = (acoral_u8)(evt->count >> 8);
300050c0:	e59d3004 	ldr	r3, [sp, #4]
300050c4:	e593300c 	ldr	r3, [r3, #12]
300050c8:	e1a03443 	asr	r3, r3, #8
300050cc:	e5cd300e 	strb	r3, [sp, #14]
	thread = (acoral_thread_t*)evt->data;
300050d0:	e59d3004 	ldr	r3, [sp, #4]
300050d4:	e5933020 	ldr	r3, [r3, #32]
300050d8:	e58d3010 	str	r3, [sp, #16]

	/*有可能优先级反转，继承最高优先级*/
	if (thread->prio>cur->prio)
300050dc:	e59d3010 	ldr	r3, [sp, #16]
300050e0:	e5d32005 	ldrb	r2, [r3, #5]
300050e4:	e59d3014 	ldr	r3, [sp, #20]
300050e8:	e5d33005 	ldrb	r3, [r3, #5]
300050ec:	e1520003 	cmp	r2, r3
300050f0:	9a000017 	bls	30005154 <acoral_mutex_pend+0x150>
	{
		if(cur->prio<highPrio)
300050f4:	e59d3014 	ldr	r3, [sp, #20]
300050f8:	e5d33005 	ldrb	r3, [r3, #5]
300050fc:	e5dd200e 	ldrb	r2, [sp, #14]
30005100:	e1520003 	cmp	r2, r3
30005104:	9a00000e 	bls	30005144 <acoral_mutex_pend+0x140>
		{
			highPrio=cur->prio;
30005108:	e59d3014 	ldr	r3, [sp, #20]
3000510c:	e5d33005 	ldrb	r3, [r3, #5]
30005110:	e5cd300e 	strb	r3, [sp, #14]
			evt->count &= ~MUTEX_U_MASK;
30005114:	e59d3004 	ldr	r3, [sp, #4]
30005118:	e593300c 	ldr	r3, [r3, #12]
3000511c:	e3c32cff 	bic	r2, r3, #65280	; 0xff00
30005120:	e59d3004 	ldr	r3, [sp, #4]
30005124:	e583200c 	str	r2, [r3, #12]
			evt->count |= highPrio << 8;
30005128:	e59d3004 	ldr	r3, [sp, #4]
3000512c:	e593200c 	ldr	r2, [r3, #12]
30005130:	e5dd300e 	ldrb	r3, [sp, #14]
30005134:	e1a03403 	lsl	r3, r3, #8
30005138:	e1822003 	orr	r2, r2, r3
3000513c:	e59d3004 	ldr	r3, [sp, #4]
30005140:	e583200c 	str	r2, [r3, #12]
		}
		acoral_thread_change_prio(thread,highPrio);
30005144:	e5dd300e 	ldrb	r3, [sp, #14]
30005148:	e59d0010 	ldr	r0, [sp, #16]
3000514c:	e1a01003 	mov	r1, r3
30005150:	ebfff64c 	bl	30002a88 <acoral_thread_change_prio>
	}
	/*不需要或不能提高优先级*/
	acoral_unrdy_thread(cur);
30005154:	e59d0014 	ldr	r0, [sp, #20]
30005158:	ebfff693 	bl	30002bac <acoral_unrdy_thread>
	acoral_evt_queue_add(evt,cur);
3000515c:	e59d0004 	ldr	r0, [sp, #4]
30005160:	e59d1014 	ldr	r1, [sp, #20]
30005164:	ebfffed0 	bl	30004cac <acoral_evt_queue_add>
	if (timeout > 0)
30005168:	e59d3000 	ldr	r3, [sp]
3000516c:	e3530000 	cmp	r3, #0
30005170:	0a00000f 	beq	300051b4 <acoral_mutex_pend+0x1b0>
	{
		/*加载到超时队列*/
		cur->delay = TIME_TO_TICKS(timeout);
30005174:	e59d2000 	ldr	r2, [sp]
30005178:	e1a03002 	mov	r3, r2
3000517c:	e1a03103 	lsl	r3, r3, #2
30005180:	e0833002 	add	r3, r3, r2
30005184:	e1a02103 	lsl	r2, r3, #2
30005188:	e0833002 	add	r3, r3, r2
3000518c:	e1a03103 	lsl	r3, r3, #2
30005190:	e1a02003 	mov	r2, r3
30005194:	e59f30c4 	ldr	r3, [pc, #196]	; 30005260 <acoral_mutex_pend+0x25c>
30005198:	e0831392 	umull	r1, r3, r2, r3
3000519c:	e1a03323 	lsr	r3, r3, #6
300051a0:	e1a02003 	mov	r2, r3
300051a4:	e59d3014 	ldr	r3, [sp, #20]
300051a8:	e5832040 	str	r2, [r3, #64]	; 0x40
		timeout_queue_add(cur);
300051ac:	e59d0014 	ldr	r0, [sp, #20]
300051b0:	ebfffd92 	bl	30004800 <timeout_queue_add>
	}
	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
300051b4:	e59d0008 	ldr	r0, [sp, #8]
300051b8:	ebfff14b 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sched();
300051bc:	ebfff493 	bl	30002410 <acoral_sched>
	HAL_ENTER_CRITICAL();
300051c0:	ebfff14b 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300051c4:	e1a03000 	mov	r3, r0
300051c8:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&evt->spin_lock);
	if(evt->data!=cur&&timeout>0&&cur->delay<=0){
300051cc:	e59d3004 	ldr	r3, [sp, #4]
300051d0:	e5932020 	ldr	r2, [r3, #32]
300051d4:	e59d3014 	ldr	r3, [sp, #20]
300051d8:	e1520003 	cmp	r2, r3
300051dc:	0a00000c 	beq	30005214 <acoral_mutex_pend+0x210>
300051e0:	e59d3000 	ldr	r3, [sp]
300051e4:	e3530000 	cmp	r3, #0
300051e8:	0a000009 	beq	30005214 <acoral_mutex_pend+0x210>
300051ec:	e59d3014 	ldr	r3, [sp, #20]
300051f0:	e5933040 	ldr	r3, [r3, #64]	; 0x40
300051f4:	e3530000 	cmp	r3, #0
300051f8:	ca000005 	bgt	30005214 <acoral_mutex_pend+0x210>
		acoral_printk("Time Out Return\n");
		acoral_evt_queue_del(cur);
300051fc:	e59d0014 	ldr	r0, [sp, #20]
30005200:	ebfffeda 	bl	30004d70 <acoral_evt_queue_del>
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30005204:	e59d0008 	ldr	r0, [sp, #8]
30005208:	ebfff137 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_TIMEOUT;
3000520c:	e3a03007 	mov	r3, #7
30005210:	ea00000d 	b	3000524c <acoral_mutex_pend+0x248>
	}

	//---------------
	// modify by pegasus 0804: timeout_queue_del [+]
	timeout_queue_del(cur);
30005214:	e59d0014 	ldr	r0, [sp, #20]
30005218:	ebfffdba 	bl	30004908 <timeout_queue_del>

	if(evt->data!=cur){
3000521c:	e59d3004 	ldr	r3, [sp, #4]
30005220:	e5932020 	ldr	r2, [r3, #32]
30005224:	e59d3014 	ldr	r3, [sp, #20]
30005228:	e1520003 	cmp	r2, r3
3000522c:	0a000005 	beq	30005248 <acoral_mutex_pend+0x244>
		acoral_printk("Err Ready Return\n");
		acoral_evt_queue_del(cur);
30005230:	e59d0014 	ldr	r0, [sp, #20]
30005234:	ebfffecd 	bl	30004d70 <acoral_evt_queue_del>
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30005238:	e59d0008 	ldr	r0, [sp, #8]
3000523c:	ebfff12a 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_RDY;
30005240:	e3a03008 	mov	r3, #8
30005244:	ea000000 	b	3000524c <acoral_mutex_pend+0x248>
	}
	
	return MUTEX_SUCCED;
30005248:	e3a03000 	mov	r3, #0
}
3000524c:	e1a00003 	mov	r0, r3
30005250:	e28dd01c 	add	sp, sp, #28
30005254:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30005258:	e12fff1e 	bx	lr
3000525c:	3002b350 	.word	0x3002b350
30005260:	10624dd3 	.word	0x10624dd3

30005264 <acoral_mutex_pend2>:
 *  the appliation for mutex
 *      信号号申请操作
 *  优先级天花板的优先级反转解决
 *=============================*/
acoral_u32 acoral_mutex_pend2(acoral_evt_t *evt, acoral_time timeout)
{
30005264:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30005268:	e24dd01c 	sub	sp, sp, #28
3000526c:	e58d0004 	str	r0, [sp, #4]
30005270:	e58d1000 	str	r1, [sp]
	acoral_u8        highPrio;
	acoral_u8        ownerPrio;
	acoral_thread_t *thread;
	acoral_thread_t *cur;

	if(acoral_intr_nesting>0)
30005274:	ebfff139 	bl	30001760 <hal_get_intr_nesting_comm>
30005278:	e1a03000 	mov	r3, r0
3000527c:	e3530000 	cmp	r3, #0
30005280:	da000001 	ble	3000528c <acoral_mutex_pend2+0x28>
		return MUTEX_ERR_INTR;
30005284:	e3a03005 	mov	r3, #5
30005288:	ea000069 	b	30005434 <acoral_mutex_pend2+0x1d0>
	
	cur=acoral_cur_thread;
3000528c:	e59f31b0 	ldr	r3, [pc, #432]	; 30005444 <acoral_mutex_pend2+0x1e0>
30005290:	e5933000 	ldr	r3, [r3]
30005294:	e58d3014 	str	r3, [sp, #20]
	
	HAL_ENTER_CRITICAL();
30005298:	ebfff115 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000529c:	e1a03000 	mov	r3, r0
300052a0:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&evt->spin_lock);
	if (NULL== evt)
300052a4:	e59d3004 	ldr	r3, [sp, #4]
300052a8:	e3530000 	cmp	r3, #0
300052ac:	1a000003 	bne	300052c0 <acoral_mutex_pend2+0x5c>
	{
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
300052b0:	e59d0008 	ldr	r0, [sp, #8]
300052b4:	ebfff10c 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_NULL;
300052b8:	e3a03002 	mov	r3, #2
300052bc:	ea00005c 	b	30005434 <acoral_mutex_pend2+0x1d0>
	}
	
	if ((acoral_u8)(evt->count & MUTEX_L_MASK) == MUTEX_AVAI)
300052c0:	e59d3004 	ldr	r3, [sp, #4]
300052c4:	e593300c 	ldr	r3, [r3, #12]
300052c8:	e20330ff 	and	r3, r3, #255	; 0xff
300052cc:	e35300ff 	cmp	r3, #255	; 0xff
300052d0:	1a000019 	bne	3000533c <acoral_mutex_pend2+0xd8>
	{
		/* 申请成功*/
		evt->count &= MUTEX_U_MASK;
300052d4:	e59d3004 	ldr	r3, [sp, #4]
300052d8:	e593300c 	ldr	r3, [r3, #12]
300052dc:	e2032cff 	and	r2, r3, #65280	; 0xff00
300052e0:	e59d3004 	ldr	r3, [sp, #4]
300052e4:	e583200c 	str	r2, [r3, #12]
		evt->count |= cur->prio;
300052e8:	e59d3004 	ldr	r3, [sp, #4]
300052ec:	e593200c 	ldr	r2, [r3, #12]
300052f0:	e59d3014 	ldr	r3, [sp, #20]
300052f4:	e5d33005 	ldrb	r3, [r3, #5]
300052f8:	e1822003 	orr	r2, r2, r3
300052fc:	e59d3004 	ldr	r3, [sp, #4]
30005300:	e583200c 	str	r2, [r3, #12]
		evt->data = (void*)cur;
30005304:	e59d3004 	ldr	r3, [sp, #4]
30005308:	e59d2014 	ldr	r2, [sp, #20]
3000530c:	e5832020 	str	r2, [r3, #32]

		/*提升至天花板优先级*/
		cur->prio = (evt->count & MUTEX_CEILING_MASK)>> 16;
30005310:	e59d3004 	ldr	r3, [sp, #4]
30005314:	e593300c 	ldr	r3, [r3, #12]
30005318:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
3000531c:	e1a03843 	asr	r3, r3, #16
30005320:	e20320ff 	and	r2, r3, #255	; 0xff
30005324:	e59d3014 	ldr	r3, [sp, #20]
30005328:	e5c32005 	strb	r2, [r3, #5]
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
3000532c:	e59d0008 	ldr	r0, [sp, #8]
30005330:	ebfff0ed 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_SUCCED;
30005334:	e3a03000 	mov	r3, #0
30005338:	ea00003d 	b	30005434 <acoral_mutex_pend2+0x1d0>
	}
	
	/* 互斥量已被占有*/
	acoral_unrdy_thread(cur);
3000533c:	e59d0014 	ldr	r0, [sp, #20]
30005340:	ebfff619 	bl	30002bac <acoral_unrdy_thread>
	acoral_evt_queue_add(evt,cur);
30005344:	e59d0004 	ldr	r0, [sp, #4]
30005348:	e59d1014 	ldr	r1, [sp, #20]
3000534c:	ebfffe56 	bl	30004cac <acoral_evt_queue_add>
	if (timeout > 0)
30005350:	e59d3000 	ldr	r3, [sp]
30005354:	e3530000 	cmp	r3, #0
30005358:	0a00000f 	beq	3000539c <acoral_mutex_pend2+0x138>
	{
		/*加载到超时队列*/
		cur->delay = TIME_TO_TICKS(timeout);
3000535c:	e59d2000 	ldr	r2, [sp]
30005360:	e1a03002 	mov	r3, r2
30005364:	e1a03103 	lsl	r3, r3, #2
30005368:	e0833002 	add	r3, r3, r2
3000536c:	e1a02103 	lsl	r2, r3, #2
30005370:	e0833002 	add	r3, r3, r2
30005374:	e1a03103 	lsl	r3, r3, #2
30005378:	e1a02003 	mov	r2, r3
3000537c:	e59f30c4 	ldr	r3, [pc, #196]	; 30005448 <acoral_mutex_pend2+0x1e4>
30005380:	e0831392 	umull	r1, r3, r2, r3
30005384:	e1a03323 	lsr	r3, r3, #6
30005388:	e1a02003 	mov	r2, r3
3000538c:	e59d3014 	ldr	r3, [sp, #20]
30005390:	e5832040 	str	r2, [r3, #64]	; 0x40
		timeout_queue_add(cur);
30005394:	e59d0014 	ldr	r0, [sp, #20]
30005398:	ebfffd18 	bl	30004800 <timeout_queue_add>
	}
	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
3000539c:	e59d0008 	ldr	r0, [sp, #8]
300053a0:	ebfff0d1 	bl	300016ec <HAL_INTR_RESTORE>

	/*触发调度*/
	acoral_sched();
300053a4:	ebfff419 	bl	30002410 <acoral_sched>

	HAL_ENTER_CRITICAL();
300053a8:	ebfff0d1 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300053ac:	e1a03000 	mov	r3, r0
300053b0:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&evt->spin_lock);

	/*超时时间内未获得互斥量*/
	if(evt->data!=cur&&timeout>0&&cur->delay<=0){
300053b4:	e59d3004 	ldr	r3, [sp, #4]
300053b8:	e5932020 	ldr	r2, [r3, #32]
300053bc:	e59d3014 	ldr	r3, [sp, #20]
300053c0:	e1520003 	cmp	r2, r3
300053c4:	0a00000c 	beq	300053fc <acoral_mutex_pend2+0x198>
300053c8:	e59d3000 	ldr	r3, [sp]
300053cc:	e3530000 	cmp	r3, #0
300053d0:	0a000009 	beq	300053fc <acoral_mutex_pend2+0x198>
300053d4:	e59d3014 	ldr	r3, [sp, #20]
300053d8:	e5933040 	ldr	r3, [r3, #64]	; 0x40
300053dc:	e3530000 	cmp	r3, #0
300053e0:	ca000005 	bgt	300053fc <acoral_mutex_pend2+0x198>
		acoral_printk("Time Out Return\n");
		acoral_evt_queue_del(cur);
300053e4:	e59d0014 	ldr	r0, [sp, #20]
300053e8:	ebfffe60 	bl	30004d70 <acoral_evt_queue_del>
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
300053ec:	e59d0008 	ldr	r0, [sp, #8]
300053f0:	ebfff0bd 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_TIMEOUT;
300053f4:	e3a03007 	mov	r3, #7
300053f8:	ea00000d 	b	30005434 <acoral_mutex_pend2+0x1d0>
	}

	/*超时时间内获得了互斥量*/
	timeout_queue_del(cur);
300053fc:	e59d0014 	ldr	r0, [sp, #20]
30005400:	ebfffd40 	bl	30004908 <timeout_queue_del>

	if(evt->data!=cur){
30005404:	e59d3004 	ldr	r3, [sp, #4]
30005408:	e5932020 	ldr	r2, [r3, #32]
3000540c:	e59d3014 	ldr	r3, [sp, #20]
30005410:	e1520003 	cmp	r2, r3
30005414:	0a000005 	beq	30005430 <acoral_mutex_pend2+0x1cc>
		acoral_printk("Err Ready Return\n");
		acoral_evt_queue_del(cur);
30005418:	e59d0014 	ldr	r0, [sp, #20]
3000541c:	ebfffe53 	bl	30004d70 <acoral_evt_queue_del>
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30005420:	e59d0008 	ldr	r0, [sp, #8]
30005424:	ebfff0b0 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_RDY;
30005428:	e3a03008 	mov	r3, #8
3000542c:	ea000000 	b	30005434 <acoral_mutex_pend2+0x1d0>
	}
	
	return MUTEX_SUCCED;
30005430:	e3a03000 	mov	r3, #0
}
30005434:	e1a00003 	mov	r0, r3
30005438:	e28dd01c 	add	sp, sp, #28
3000543c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30005440:	e12fff1e 	bx	lr
30005444:	3002b350 	.word	0x3002b350
30005448:	10624dd3 	.word	0x10624dd3

3000544c <acoral_mutex_post>:
/*============================
 *  post a mutex to thread
 *     信号量的释放
 *===========================*/
acoral_u32 acoral_mutex_post(acoral_evt_t *evt)
{
3000544c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30005450:	e24dd01c 	sub	sp, sp, #28
30005454:	e58d0004 	str	r0, [sp, #4]
	acoral_u8             ownerPrio;
	acoral_u8             highPrio;
	acoral_thread_t      *thread;
	acoral_thread_t      *cur;

	HAL_ENTER_CRITICAL();
30005458:	ebfff0a5 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000545c:	e1a03000 	mov	r3, r0
30005460:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&evt->spin_lock);

	if ( NULL == evt )
30005464:	e59d3004 	ldr	r3, [sp, #4]
30005468:	e3530000 	cmp	r3, #0
3000546c:	1a000005 	bne	30005488 <acoral_mutex_post+0x3c>
	{
		acoral_printerr("mutex NULL\n");
30005470:	e59f0170 	ldr	r0, [pc, #368]	; 300055e8 <acoral_mutex_post+0x19c>
30005474:	eb0017eb 	bl	3000b428 <acoral_print>
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30005478:	e59d0008 	ldr	r0, [sp, #8]
3000547c:	ebfff09a 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_NULL;   /*error*/
30005480:	e3a03002 	mov	r3, #2
30005484:	ea000053 	b	300055d8 <acoral_mutex_post+0x18c>
	}
	
	highPrio  = (acoral_u8)(evt->count >> 8);
30005488:	e59d3004 	ldr	r3, [sp, #4]
3000548c:	e593300c 	ldr	r3, [r3, #12]
30005490:	e1a03443 	asr	r3, r3, #8
30005494:	e5cd300f 	strb	r3, [sp, #15]
	ownerPrio = (acoral_u8)(evt->count & MUTEX_L_MASK);
30005498:	e59d3004 	ldr	r3, [sp, #4]
3000549c:	e593300c 	ldr	r3, [r3, #12]
300054a0:	e5cd300e 	strb	r3, [sp, #14]
	cur=acoral_cur_thread;
300054a4:	e59f3140 	ldr	r3, [pc, #320]	; 300055ec <acoral_mutex_post+0x1a0>
300054a8:	e5933000 	ldr	r3, [r3]
300054ac:	e58d3014 	str	r3, [sp, #20]
	if (highPrio!=0&&cur->prio != highPrio && cur->prio != ownerPrio )
300054b0:	e5dd300f 	ldrb	r3, [sp, #15]
300054b4:	e3530000 	cmp	r3, #0
300054b8:	0a00000f 	beq	300054fc <acoral_mutex_post+0xb0>
300054bc:	e59d3014 	ldr	r3, [sp, #20]
300054c0:	e5d33005 	ldrb	r3, [r3, #5]
300054c4:	e5dd200f 	ldrb	r2, [sp, #15]
300054c8:	e1520003 	cmp	r2, r3
300054cc:	0a00000a 	beq	300054fc <acoral_mutex_post+0xb0>
300054d0:	e59d3014 	ldr	r3, [sp, #20]
300054d4:	e5d33005 	ldrb	r3, [r3, #5]
300054d8:	e5dd200e 	ldrb	r2, [sp, #14]
300054dc:	e1520003 	cmp	r2, r3
300054e0:	0a000005 	beq	300054fc <acoral_mutex_post+0xb0>
	{
		acoral_printerr("mutex prio err\n");
300054e4:	e59f0104 	ldr	r0, [pc, #260]	; 300055f0 <acoral_mutex_post+0x1a4>
300054e8:	eb0017ce 	bl	3000b428 <acoral_print>
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
300054ec:	e59d0008 	ldr	r0, [sp, #8]
300054f0:	ebfff07d 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_UNDEF;
300054f4:	e3a03006 	mov	r3, #6
300054f8:	ea000036 	b	300055d8 <acoral_mutex_post+0x18c>
	}
	cur->evt=NULL;	
300054fc:	e59d3014 	ldr	r3, [sp, #20]
30005500:	e3a02000 	mov	r2, #0
30005504:	e5832030 	str	r2, [r3, #48]	; 0x30
	if (cur->prio != ownerPrio)
30005508:	e59d3014 	ldr	r3, [sp, #20]
3000550c:	e5d33005 	ldrb	r3, [r3, #5]
30005510:	e5dd200e 	ldrb	r2, [sp, #14]
30005514:	e1520003 	cmp	r2, r3
30005518:	0a000002 	beq	30005528 <acoral_mutex_post+0xdc>
	{
		/* 提升过优先级，进行优先级复原*/
		acoral_change_prio_self(ownerPrio);
3000551c:	e5dd300e 	ldrb	r3, [sp, #14]
30005520:	e1a00003 	mov	r0, r3
30005524:	ebfff576 	bl	30002b04 <acoral_change_prio_self>
	}
    
	thread =acoral_evt_high_thread(evt);
30005528:	e59d0004 	ldr	r0, [sp, #4]
3000552c:	ebfffdca 	bl	30004c5c <acoral_evt_high_thread>
30005530:	e1a03000 	mov	r3, r0
30005534:	e58d3010 	str	r3, [sp, #16]
	if (thread==NULL){
30005538:	e59d3010 	ldr	r3, [sp, #16]
3000553c:	e3530000 	cmp	r3, #0
30005540:	1a00000b 	bne	30005574 <acoral_mutex_post+0x128>
			evt->count |= MUTEX_AVAI;
30005544:	e59d3004 	ldr	r3, [sp, #4]
30005548:	e593300c 	ldr	r3, [r3, #12]
3000554c:	e38320ff 	orr	r2, r3, #255	; 0xff
30005550:	e59d3004 	ldr	r3, [sp, #4]
30005554:	e583200c 	str	r2, [r3, #12]
			evt->data = NULL;
30005558:	e59d3004 	ldr	r3, [sp, #4]
3000555c:	e3a02000 	mov	r2, #0
30005560:	e5832020 	str	r2, [r3, #32]
			acoral_spin_unlock(&evt->spin_lock);
			HAL_EXIT_CRITICAL();
30005564:	e59d0008 	ldr	r0, [sp, #8]
30005568:	ebfff05f 	bl	300016ec <HAL_INTR_RESTORE>
			return MUTEX_SUCCED;
3000556c:	e3a03000 	mov	r3, #0
30005570:	ea000018 	b	300055d8 <acoral_mutex_post+0x18c>
	}
	timeout_queue_del(thread);
30005574:	e59d0010 	ldr	r0, [sp, #16]
30005578:	ebfffce2 	bl	30004908 <timeout_queue_del>
	acoral_evt_queue_del(thread);
3000557c:	e59d0010 	ldr	r0, [sp, #16]
30005580:	ebfffdfa 	bl	30004d70 <acoral_evt_queue_del>
#ifdef CFG_TEST
	acoral_print("%d post %d\n",cur->prio,thread->prio);
#endif
	evt->count &= MUTEX_U_MASK;
30005584:	e59d3004 	ldr	r3, [sp, #4]
30005588:	e593300c 	ldr	r3, [r3, #12]
3000558c:	e2032cff 	and	r2, r3, #65280	; 0xff00
30005590:	e59d3004 	ldr	r3, [sp, #4]
30005594:	e583200c 	str	r2, [r3, #12]
	evt->count |= thread->prio;
30005598:	e59d3004 	ldr	r3, [sp, #4]
3000559c:	e593200c 	ldr	r2, [r3, #12]
300055a0:	e59d3010 	ldr	r3, [sp, #16]
300055a4:	e5d33005 	ldrb	r3, [r3, #5]
300055a8:	e1822003 	orr	r2, r2, r3
300055ac:	e59d3004 	ldr	r3, [sp, #4]
300055b0:	e583200c 	str	r2, [r3, #12]
	evt->data = thread;
300055b4:	e59d3004 	ldr	r3, [sp, #4]
300055b8:	e59d2010 	ldr	r2, [sp, #16]
300055bc:	e5832020 	str	r2, [r3, #32]
	acoral_rdy_thread(thread);
300055c0:	e59d0010 	ldr	r0, [sp, #16]
300055c4:	ebfff569 	bl	30002b70 <acoral_rdy_thread>
	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
300055c8:	e59d0008 	ldr	r0, [sp, #8]
300055cc:	ebfff046 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sched();
300055d0:	ebfff38e 	bl	30002410 <acoral_sched>
	return MUTEX_SUCCED;
300055d4:	e3a03000 	mov	r3, #0
}
300055d8:	e1a00003 	mov	r0, r3
300055dc:	e28dd01c 	add	sp, sp, #28
300055e0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300055e4:	e12fff1e 	bx	lr
300055e8:	30026034 	.word	0x30026034
300055ec:	3002b350 	.word	0x3002b350
300055f0:	30026040 	.word	0x30026040

300055f4 <buddy_scan>:
}acoral_block_ctr_t;

acoral_block_ctr_t *acoral_mem_ctrl;
acoral_block_t *acoral_mem_blocks;

void buddy_scan(){
300055f4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300055f8:	e24dd01c 	sub	sp, sp, #28
	acoral_u32 i,k,num,n;	
	acoral_u32 max_level=acoral_mem_ctrl->level;
300055fc:	e59f314c 	ldr	r3, [pc, #332]	; 30005750 <buddy_scan+0x15c>
30005600:	e5933000 	ldr	r3, [r3]
30005604:	e5d330e0 	ldrb	r3, [r3, #224]	; 0xe0
30005608:	e1a03c03 	lsl	r3, r3, #24
3000560c:	e1a03c43 	asr	r3, r3, #24
30005610:	e58d3014 	str	r3, [sp, #20]
	for(i=0;i<max_level;i++){
30005614:	e3a03000 	mov	r3, #0
30005618:	e58d3004 	str	r3, [sp, #4]
3000561c:	ea00003c 	b	30005714 <buddy_scan+0x120>
		acoral_print("Level%d\r\n",i); 	
30005620:	e59f012c 	ldr	r0, [pc, #300]	; 30005754 <buddy_scan+0x160>
30005624:	e59d1004 	ldr	r1, [sp, #4]
30005628:	eb00177e 	bl	3000b428 <acoral_print>
		acoral_prints("bitmap:"); 	
3000562c:	e59f0124 	ldr	r0, [pc, #292]	; 30005758 <buddy_scan+0x164>
30005630:	eb00179f 	bl	3000b4b4 <acoral_prints>
		num=acoral_mem_ctrl->num[i];
30005634:	e59f3114 	ldr	r3, [pc, #276]	; 30005750 <buddy_scan+0x15c>
30005638:	e5933000 	ldr	r3, [r3]
3000563c:	e59d2004 	ldr	r2, [sp, #4]
30005640:	e282202a 	add	r2, r2, #42	; 0x2a
30005644:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30005648:	e58d300c 	str	r3, [sp, #12]
		for(k=0;k<num;){
3000564c:	e3a03000 	mov	r3, #0
30005650:	e58d3008 	str	r3, [sp, #8]
30005654:	ea00001d 	b	300056d0 <buddy_scan+0xdc>
			for(n=0;n<8&&k<num;n++,k++){
30005658:	e3a03000 	mov	r3, #0
3000565c:	e58d3010 	str	r3, [sp, #16]
30005660:	ea000011 	b	300056ac <buddy_scan+0xb8>
				acoral_print("%x ",acoral_mem_ctrl->bitmap[i][k]); 
30005664:	e59f30e4 	ldr	r3, [pc, #228]	; 30005750 <buddy_scan+0x15c>
30005668:	e5933000 	ldr	r3, [r3]
3000566c:	e59d2004 	ldr	r2, [sp, #4]
30005670:	e282200e 	add	r2, r2, #14
30005674:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005678:	e59d3008 	ldr	r3, [sp, #8]
3000567c:	e1a03103 	lsl	r3, r3, #2
30005680:	e0823003 	add	r3, r2, r3
30005684:	e5933000 	ldr	r3, [r3]
30005688:	e59f00cc 	ldr	r0, [pc, #204]	; 3000575c <buddy_scan+0x168>
3000568c:	e1a01003 	mov	r1, r3
30005690:	eb001764 	bl	3000b428 <acoral_print>
	for(i=0;i<max_level;i++){
		acoral_print("Level%d\r\n",i); 	
		acoral_prints("bitmap:"); 	
		num=acoral_mem_ctrl->num[i];
		for(k=0;k<num;){
			for(n=0;n<8&&k<num;n++,k++){
30005694:	e59d3010 	ldr	r3, [sp, #16]
30005698:	e2833001 	add	r3, r3, #1
3000569c:	e58d3010 	str	r3, [sp, #16]
300056a0:	e59d3008 	ldr	r3, [sp, #8]
300056a4:	e2833001 	add	r3, r3, #1
300056a8:	e58d3008 	str	r3, [sp, #8]
300056ac:	e59d3010 	ldr	r3, [sp, #16]
300056b0:	e3530007 	cmp	r3, #7
300056b4:	8a000003 	bhi	300056c8 <buddy_scan+0xd4>
300056b8:	e59d2008 	ldr	r2, [sp, #8]
300056bc:	e59d300c 	ldr	r3, [sp, #12]
300056c0:	e1520003 	cmp	r2, r3
300056c4:	3affffe6 	bcc	30005664 <buddy_scan+0x70>
				acoral_print("%x ",acoral_mem_ctrl->bitmap[i][k]); 
			}	
			acoral_prints("\r\n"); 	
300056c8:	e59f0090 	ldr	r0, [pc, #144]	; 30005760 <buddy_scan+0x16c>
300056cc:	eb001778 	bl	3000b4b4 <acoral_prints>
	acoral_u32 max_level=acoral_mem_ctrl->level;
	for(i=0;i<max_level;i++){
		acoral_print("Level%d\r\n",i); 	
		acoral_prints("bitmap:"); 	
		num=acoral_mem_ctrl->num[i];
		for(k=0;k<num;){
300056d0:	e59d2008 	ldr	r2, [sp, #8]
300056d4:	e59d300c 	ldr	r3, [sp, #12]
300056d8:	e1520003 	cmp	r2, r3
300056dc:	3affffdd 	bcc	30005658 <buddy_scan+0x64>
			for(n=0;n<8&&k<num;n++,k++){
				acoral_print("%x ",acoral_mem_ctrl->bitmap[i][k]); 
			}	
			acoral_prints("\r\n"); 	
		}
		acoral_print("Free Block head:%d\r\n",acoral_mem_ctrl->free_cur[i]); 	
300056e0:	e59f3068 	ldr	r3, [pc, #104]	; 30005750 <buddy_scan+0x15c>
300056e4:	e5933000 	ldr	r3, [r3]
300056e8:	e59d2004 	ldr	r2, [sp, #4]
300056ec:	e282201c 	add	r2, r2, #28
300056f0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300056f4:	e59f0068 	ldr	r0, [pc, #104]	; 30005764 <buddy_scan+0x170>
300056f8:	e1a01003 	mov	r1, r3
300056fc:	eb001749 	bl	3000b428 <acoral_print>
		acoral_prints("\r\n"); 	
30005700:	e59f0058 	ldr	r0, [pc, #88]	; 30005760 <buddy_scan+0x16c>
30005704:	eb00176a 	bl	3000b4b4 <acoral_prints>
acoral_block_t *acoral_mem_blocks;

void buddy_scan(){
	acoral_u32 i,k,num,n;	
	acoral_u32 max_level=acoral_mem_ctrl->level;
	for(i=0;i<max_level;i++){
30005708:	e59d3004 	ldr	r3, [sp, #4]
3000570c:	e2833001 	add	r3, r3, #1
30005710:	e58d3004 	str	r3, [sp, #4]
30005714:	e59d2004 	ldr	r2, [sp, #4]
30005718:	e59d3014 	ldr	r3, [sp, #20]
3000571c:	e1520003 	cmp	r2, r3
30005720:	3affffbe 	bcc	30005620 <buddy_scan+0x2c>
			acoral_prints("\r\n"); 	
		}
		acoral_print("Free Block head:%d\r\n",acoral_mem_ctrl->free_cur[i]); 	
		acoral_prints("\r\n"); 	
	}
	acoral_print("Free Mem Block Number:%d\r\n",acoral_mem_ctrl->free_num); 	
30005724:	e59f3024 	ldr	r3, [pc, #36]	; 30005750 <buddy_scan+0x15c>
30005728:	e5933000 	ldr	r3, [r3]
3000572c:	e59330f0 	ldr	r3, [r3, #240]	; 0xf0
30005730:	e59f0030 	ldr	r0, [pc, #48]	; 30005768 <buddy_scan+0x174>
30005734:	e1a01003 	mov	r1, r3
30005738:	eb00173a 	bl	3000b428 <acoral_print>
	acoral_print("\r\n"); 	
3000573c:	e59f001c 	ldr	r0, [pc, #28]	; 30005760 <buddy_scan+0x16c>
30005740:	eb001738 	bl	3000b428 <acoral_print>
}
30005744:	e28dd01c 	add	sp, sp, #28
30005748:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000574c:	e12fff1e 	bx	lr
30005750:	3002b110 	.word	0x3002b110
30005754:	30026050 	.word	0x30026050
30005758:	3002605c 	.word	0x3002605c
3000575c:	30026064 	.word	0x30026064
30005760:	30026068 	.word	0x30026068
30005764:	3002606c 	.word	0x3002606c
30005768:	30026084 	.word	0x30026084

3000576c <buddy_init>:

acoral_err buddy_init(acoral_u32 start_adr,acoral_u32 end_adr){
3000576c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30005770:	e24dd03c 	sub	sp, sp, #60	; 0x3c
30005774:	e58d0004 	str	r0, [sp, #4]
30005778:	e58d1000 	str	r1, [sp]
	acoral_32 i,k;
	acoral_u32 resize_size;
	acoral_u32 save_adr;
	acoral_u32 index;
	acoral_u32 num=1;
3000577c:	e3a03001 	mov	r3, #1
30005780:	e58d3020 	str	r3, [sp, #32]
	acoral_u32 adjust_level=1;
30005784:	e3a03001 	mov	r3, #1
30005788:	e58d3024 	str	r3, [sp, #36]	; 0x24
	acoral_32 level=0;
3000578c:	e3a03000 	mov	r3, #0
30005790:	e58d3028 	str	r3, [sp, #40]	; 0x28
	acoral_u32 max_num,o_num;
	acoral_u32 cur;
	start_adr+=3;
30005794:	e59d3004 	ldr	r3, [sp, #4]
30005798:	e2833003 	add	r3, r3, #3
3000579c:	e58d3004 	str	r3, [sp, #4]
	start_adr&=~(4-1);		
300057a0:	e59d3004 	ldr	r3, [sp, #4]
300057a4:	e3c33003 	bic	r3, r3, #3
300057a8:	e58d3004 	str	r3, [sp, #4]
	end_adr&=~(4-1);		
300057ac:	e59d3000 	ldr	r3, [sp]
300057b0:	e3c33003 	bic	r3, r3, #3
300057b4:	e58d3000 	str	r3, [sp]
	resize_size=BLOCK_SIZE;
300057b8:	e3a03080 	mov	r3, #128	; 0x80
300057bc:	e58d3014 	str	r3, [sp, #20]
	end_adr=end_adr - sizeof(acoral_block_ctr_t);
300057c0:	e59d3000 	ldr	r3, [sp]
300057c4:	e24330fc 	sub	r3, r3, #252	; 0xfc
300057c8:	e58d3000 	str	r3, [sp]
	end_adr&=~(4-1);
300057cc:	e59d3000 	ldr	r3, [sp]
300057d0:	e3c33003 	bic	r3, r3, #3
300057d4:	e58d3000 	str	r3, [sp]
	acoral_mem_ctrl=(acoral_block_ctr_t *)end_adr;
300057d8:	e59d2000 	ldr	r2, [sp]
300057dc:	e59f3720 	ldr	r3, [pc, #1824]	; 30005f04 <buddy_init+0x798>
300057e0:	e5832000 	str	r2, [r3]
	/*如果内存这么少，不适合分配*/
	if(start_adr>end_adr||end_adr-start_adr<BLOCK_SIZE){
300057e4:	e59d2004 	ldr	r2, [sp, #4]
300057e8:	e59d3000 	ldr	r3, [sp]
300057ec:	e1520003 	cmp	r2, r3
300057f0:	8a000004 	bhi	30005808 <buddy_init+0x9c>
300057f4:	e59d2000 	ldr	r2, [sp]
300057f8:	e59d3004 	ldr	r3, [sp, #4]
300057fc:	e0633002 	rsb	r3, r3, r2
30005800:	e353007f 	cmp	r3, #127	; 0x7f
30005804:	8a000005 	bhi	30005820 <buddy_init+0xb4>
		acoral_mem_ctrl->state=MEM_NO_ALLOC;
30005808:	e59f36f4 	ldr	r3, [pc, #1780]	; 30005f04 <buddy_init+0x798>
3000580c:	e5933000 	ldr	r3, [r3]
30005810:	e3a02000 	mov	r2, #0
30005814:	e5c320e1 	strb	r2, [r3, #225]	; 0xe1
		return -1;
30005818:	e3e03000 	mvn	r3, #0
3000581c:	ea0001b4 	b	30005ef4 <buddy_init+0x788>
	}
	acoral_mem_ctrl->state=MEM_OK;
30005820:	e59f36dc 	ldr	r3, [pc, #1756]	; 30005f04 <buddy_init+0x798>
30005824:	e5933000 	ldr	r3, [r3]
30005828:	e3a02001 	mov	r2, #1
3000582c:	e5c320e1 	strb	r2, [r3, #225]	; 0xe1
	while(1){
		if(end_adr<=start_adr+resize_size)
30005830:	e59d2004 	ldr	r2, [sp, #4]
30005834:	e59d3014 	ldr	r3, [sp, #20]
30005838:	e0822003 	add	r2, r2, r3
3000583c:	e59d3000 	ldr	r3, [sp]
30005840:	e1520003 	cmp	r2, r3
30005844:	3a00000e 	bcc	30005884 <buddy_init+0x118>
			break;
		resize_size=resize_size<<1;
		num=num<<1;
		adjust_level++;
	}
	acoral_mem_blocks=(acoral_block_t *)end_adr-num;
30005848:	e59d2000 	ldr	r2, [sp]
3000584c:	e59d3020 	ldr	r3, [sp, #32]
30005850:	e0633002 	rsb	r3, r3, r2
30005854:	e1a02003 	mov	r2, r3
30005858:	e59f36a8 	ldr	r3, [pc, #1704]	; 30005f08 <buddy_init+0x79c>
3000585c:	e5832000 	str	r2, [r3]
	save_adr=(acoral_u32)acoral_mem_blocks;
30005860:	e59f36a0 	ldr	r3, [pc, #1696]	; 30005f08 <buddy_init+0x79c>
30005864:	e5933000 	ldr	r3, [r3]
30005868:	e58d3018 	str	r3, [sp, #24]
	level=adjust_level;
3000586c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30005870:	e58d3028 	str	r3, [sp, #40]	; 0x28
	if(adjust_level>LEVEL)
30005874:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30005878:	e353000e 	cmp	r3, #14
3000587c:	8a00000a 	bhi	300058ac <buddy_init+0x140>
30005880:	ea00000b 	b	300058b4 <buddy_init+0x148>
	}
	acoral_mem_ctrl->state=MEM_OK;
	while(1){
		if(end_adr<=start_adr+resize_size)
			break;
		resize_size=resize_size<<1;
30005884:	e59d3014 	ldr	r3, [sp, #20]
30005888:	e1a03083 	lsl	r3, r3, #1
3000588c:	e58d3014 	str	r3, [sp, #20]
		num=num<<1;
30005890:	e59d3020 	ldr	r3, [sp, #32]
30005894:	e1a03083 	lsl	r3, r3, #1
30005898:	e58d3020 	str	r3, [sp, #32]
		adjust_level++;
3000589c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300058a0:	e2833001 	add	r3, r3, #1
300058a4:	e58d3024 	str	r3, [sp, #36]	; 0x24
	}
300058a8:	eaffffe0 	b	30005830 <buddy_init+0xc4>
	acoral_mem_blocks=(acoral_block_t *)end_adr-num;
	save_adr=(acoral_u32)acoral_mem_blocks;
	level=adjust_level;
	if(adjust_level>LEVEL)
		level=LEVEL;
300058ac:	e3a0300e 	mov	r3, #14
300058b0:	e58d3028 	str	r3, [sp, #40]	; 0x28
	num=num/32; 
300058b4:	e59d3020 	ldr	r3, [sp, #32]
300058b8:	e1a032a3 	lsr	r3, r3, #5
300058bc:	e58d3020 	str	r3, [sp, #32]
	for(i=0;i<level-1;i++){
300058c0:	e3a03000 	mov	r3, #0
300058c4:	e58d300c 	str	r3, [sp, #12]
300058c8:	ea00004e 	b	30005a08 <buddy_init+0x29c>
		num=num>>1;
300058cc:	e59d3020 	ldr	r3, [sp, #32]
300058d0:	e1a030a3 	lsr	r3, r3, #1
300058d4:	e58d3020 	str	r3, [sp, #32]
		if(num==0)
300058d8:	e59d3020 	ldr	r3, [sp, #32]
300058dc:	e3530000 	cmp	r3, #0
300058e0:	1a000001 	bne	300058ec <buddy_init+0x180>
			num=1;
300058e4:	e3a03001 	mov	r3, #1
300058e8:	e58d3020 	str	r3, [sp, #32]
		save_adr-=num*4;
300058ec:	e59d3020 	ldr	r3, [sp, #32]
300058f0:	e1a03103 	lsl	r3, r3, #2
300058f4:	e59d2018 	ldr	r2, [sp, #24]
300058f8:	e0633002 	rsb	r3, r3, r2
300058fc:	e58d3018 	str	r3, [sp, #24]
		save_adr&=~(4-1);
30005900:	e59d3018 	ldr	r3, [sp, #24]
30005904:	e3c33003 	bic	r3, r3, #3
30005908:	e58d3018 	str	r3, [sp, #24]
		acoral_mem_ctrl->bitmap[i]=(acoral_u32 *)save_adr;
3000590c:	e59f35f0 	ldr	r3, [pc, #1520]	; 30005f04 <buddy_init+0x798>
30005910:	e5933000 	ldr	r3, [r3]
30005914:	e59d200c 	ldr	r2, [sp, #12]
30005918:	e59d1018 	ldr	r1, [sp, #24]
3000591c:	e282200e 	add	r2, r2, #14
30005920:	e7831102 	str	r1, [r3, r2, lsl #2]
		acoral_mem_ctrl->num[i]=num;
30005924:	e59f35d8 	ldr	r3, [pc, #1496]	; 30005f04 <buddy_init+0x798>
30005928:	e5933000 	ldr	r3, [r3]
3000592c:	e59d200c 	ldr	r2, [sp, #12]
30005930:	e282202a 	add	r2, r2, #42	; 0x2a
30005934:	e59d1020 	ldr	r1, [sp, #32]
30005938:	e7831102 	str	r1, [r3, r2, lsl #2]
		save_adr-=num*4;
3000593c:	e59d3020 	ldr	r3, [sp, #32]
30005940:	e1a03103 	lsl	r3, r3, #2
30005944:	e59d2018 	ldr	r2, [sp, #24]
30005948:	e0633002 	rsb	r3, r3, r2
3000594c:	e58d3018 	str	r3, [sp, #24]
		save_adr&=~(4-1);
30005950:	e59d3018 	ldr	r3, [sp, #24]
30005954:	e3c33003 	bic	r3, r3, #3
30005958:	e58d3018 	str	r3, [sp, #24]
		acoral_mem_ctrl->free_list[i]=(acoral_32 *)save_adr;
3000595c:	e59f35a0 	ldr	r3, [pc, #1440]	; 30005f04 <buddy_init+0x798>
30005960:	e5933000 	ldr	r3, [r3]
30005964:	e59d200c 	ldr	r2, [sp, #12]
30005968:	e59d1018 	ldr	r1, [sp, #24]
3000596c:	e7831102 	str	r1, [r3, r2, lsl #2]
		for(k=0;k<num;k++){
30005970:	e3a03000 	mov	r3, #0
30005974:	e58d3010 	str	r3, [sp, #16]
30005978:	ea000015 	b	300059d4 <buddy_init+0x268>
			acoral_mem_ctrl->bitmap[i][k]=0;;
3000597c:	e59f3580 	ldr	r3, [pc, #1408]	; 30005f04 <buddy_init+0x798>
30005980:	e5933000 	ldr	r3, [r3]
30005984:	e59d200c 	ldr	r2, [sp, #12]
30005988:	e282200e 	add	r2, r2, #14
3000598c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005990:	e59d3010 	ldr	r3, [sp, #16]
30005994:	e1a03103 	lsl	r3, r3, #2
30005998:	e0823003 	add	r3, r2, r3
3000599c:	e3a02000 	mov	r2, #0
300059a0:	e5832000 	str	r2, [r3]
			acoral_mem_ctrl->free_list[i][k]=-1;
300059a4:	e59f3558 	ldr	r3, [pc, #1368]	; 30005f04 <buddy_init+0x798>
300059a8:	e5933000 	ldr	r3, [r3]
300059ac:	e59d200c 	ldr	r2, [sp, #12]
300059b0:	e7932102 	ldr	r2, [r3, r2, lsl #2]
300059b4:	e59d3010 	ldr	r3, [sp, #16]
300059b8:	e1a03103 	lsl	r3, r3, #2
300059bc:	e0823003 	add	r3, r2, r3
300059c0:	e3e02000 	mvn	r2, #0
300059c4:	e5832000 	str	r2, [r3]
		acoral_mem_ctrl->bitmap[i]=(acoral_u32 *)save_adr;
		acoral_mem_ctrl->num[i]=num;
		save_adr-=num*4;
		save_adr&=~(4-1);
		acoral_mem_ctrl->free_list[i]=(acoral_32 *)save_adr;
		for(k=0;k<num;k++){
300059c8:	e59d3010 	ldr	r3, [sp, #16]
300059cc:	e2833001 	add	r3, r3, #1
300059d0:	e58d3010 	str	r3, [sp, #16]
300059d4:	e59d2010 	ldr	r2, [sp, #16]
300059d8:	e59d3020 	ldr	r3, [sp, #32]
300059dc:	e1520003 	cmp	r2, r3
300059e0:	3affffe5 	bcc	3000597c <buddy_init+0x210>
			acoral_mem_ctrl->bitmap[i][k]=0;;
			acoral_mem_ctrl->free_list[i][k]=-1;
		}
		acoral_mem_ctrl->free_cur[i]=-1;
300059e4:	e59f3518 	ldr	r3, [pc, #1304]	; 30005f04 <buddy_init+0x798>
300059e8:	e5933000 	ldr	r3, [r3]
300059ec:	e59d200c 	ldr	r2, [sp, #12]
300059f0:	e282201c 	add	r2, r2, #28
300059f4:	e3e01000 	mvn	r1, #0
300059f8:	e7831102 	str	r1, [r3, r2, lsl #2]
	save_adr=(acoral_u32)acoral_mem_blocks;
	level=adjust_level;
	if(adjust_level>LEVEL)
		level=LEVEL;
	num=num/32; 
	for(i=0;i<level-1;i++){
300059fc:	e59d300c 	ldr	r3, [sp, #12]
30005a00:	e2833001 	add	r3, r3, #1
30005a04:	e58d300c 	str	r3, [sp, #12]
30005a08:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30005a0c:	e2432001 	sub	r2, r3, #1
30005a10:	e59d300c 	ldr	r3, [sp, #12]
30005a14:	e1520003 	cmp	r2, r3
30005a18:	caffffab 	bgt	300058cc <buddy_init+0x160>
			acoral_mem_ctrl->bitmap[i][k]=0;;
			acoral_mem_ctrl->free_list[i][k]=-1;
		}
		acoral_mem_ctrl->free_cur[i]=-1;
	}
	if(num==0)
30005a1c:	e59d3020 	ldr	r3, [sp, #32]
30005a20:	e3530000 	cmp	r3, #0
30005a24:	1a000001 	bne	30005a30 <buddy_init+0x2c4>
		num=1;
30005a28:	e3a03001 	mov	r3, #1
30005a2c:	e58d3020 	str	r3, [sp, #32]
	save_adr-=num*4;
30005a30:	e59d3020 	ldr	r3, [sp, #32]
30005a34:	e1a03103 	lsl	r3, r3, #2
30005a38:	e59d2018 	ldr	r2, [sp, #24]
30005a3c:	e0633002 	rsb	r3, r3, r2
30005a40:	e58d3018 	str	r3, [sp, #24]
	save_adr&=~(4-1);
30005a44:	e59d3018 	ldr	r3, [sp, #24]
30005a48:	e3c33003 	bic	r3, r3, #3
30005a4c:	e58d3018 	str	r3, [sp, #24]
	acoral_mem_ctrl->bitmap[i]=(acoral_u32 *)save_adr;
30005a50:	e59f34ac 	ldr	r3, [pc, #1196]	; 30005f04 <buddy_init+0x798>
30005a54:	e5933000 	ldr	r3, [r3]
30005a58:	e59d200c 	ldr	r2, [sp, #12]
30005a5c:	e59d1018 	ldr	r1, [sp, #24]
30005a60:	e282200e 	add	r2, r2, #14
30005a64:	e7831102 	str	r1, [r3, r2, lsl #2]
	acoral_mem_ctrl->num[i]=num;
30005a68:	e59f3494 	ldr	r3, [pc, #1172]	; 30005f04 <buddy_init+0x798>
30005a6c:	e5933000 	ldr	r3, [r3]
30005a70:	e59d200c 	ldr	r2, [sp, #12]
30005a74:	e282202a 	add	r2, r2, #42	; 0x2a
30005a78:	e59d1020 	ldr	r1, [sp, #32]
30005a7c:	e7831102 	str	r1, [r3, r2, lsl #2]
	save_adr-=num*4;
30005a80:	e59d3020 	ldr	r3, [sp, #32]
30005a84:	e1a03103 	lsl	r3, r3, #2
30005a88:	e59d2018 	ldr	r2, [sp, #24]
30005a8c:	e0633002 	rsb	r3, r3, r2
30005a90:	e58d3018 	str	r3, [sp, #24]
	save_adr&=~(4-1);
30005a94:	e59d3018 	ldr	r3, [sp, #24]
30005a98:	e3c33003 	bic	r3, r3, #3
30005a9c:	e58d3018 	str	r3, [sp, #24]
	acoral_mem_ctrl->free_list[i]=(acoral_32 *)save_adr;
30005aa0:	e59f345c 	ldr	r3, [pc, #1116]	; 30005f04 <buddy_init+0x798>
30005aa4:	e5933000 	ldr	r3, [r3]
30005aa8:	e59d200c 	ldr	r2, [sp, #12]
30005aac:	e59d1018 	ldr	r1, [sp, #24]
30005ab0:	e7831102 	str	r1, [r3, r2, lsl #2]
	for(k=0;k<num;k++){
30005ab4:	e3a03000 	mov	r3, #0
30005ab8:	e58d3010 	str	r3, [sp, #16]
30005abc:	ea000015 	b	30005b18 <buddy_init+0x3ac>
		acoral_mem_ctrl->bitmap[i][k]=0;;
30005ac0:	e59f343c 	ldr	r3, [pc, #1084]	; 30005f04 <buddy_init+0x798>
30005ac4:	e5933000 	ldr	r3, [r3]
30005ac8:	e59d200c 	ldr	r2, [sp, #12]
30005acc:	e282200e 	add	r2, r2, #14
30005ad0:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005ad4:	e59d3010 	ldr	r3, [sp, #16]
30005ad8:	e1a03103 	lsl	r3, r3, #2
30005adc:	e0823003 	add	r3, r2, r3
30005ae0:	e3a02000 	mov	r2, #0
30005ae4:	e5832000 	str	r2, [r3]
		acoral_mem_ctrl->free_list[i][k]=-1;
30005ae8:	e59f3414 	ldr	r3, [pc, #1044]	; 30005f04 <buddy_init+0x798>
30005aec:	e5933000 	ldr	r3, [r3]
30005af0:	e59d200c 	ldr	r2, [sp, #12]
30005af4:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005af8:	e59d3010 	ldr	r3, [sp, #16]
30005afc:	e1a03103 	lsl	r3, r3, #2
30005b00:	e0823003 	add	r3, r2, r3
30005b04:	e3e02000 	mvn	r2, #0
30005b08:	e5832000 	str	r2, [r3]
	acoral_mem_ctrl->bitmap[i]=(acoral_u32 *)save_adr;
	acoral_mem_ctrl->num[i]=num;
	save_adr-=num*4;
	save_adr&=~(4-1);
	acoral_mem_ctrl->free_list[i]=(acoral_32 *)save_adr;
	for(k=0;k<num;k++){
30005b0c:	e59d3010 	ldr	r3, [sp, #16]
30005b10:	e2833001 	add	r3, r3, #1
30005b14:	e58d3010 	str	r3, [sp, #16]
30005b18:	e59d2010 	ldr	r2, [sp, #16]
30005b1c:	e59d3020 	ldr	r3, [sp, #32]
30005b20:	e1520003 	cmp	r2, r3
30005b24:	3affffe5 	bcc	30005ac0 <buddy_init+0x354>
		acoral_mem_ctrl->bitmap[i][k]=0;;
		acoral_mem_ctrl->free_list[i][k]=-1;
	}
	acoral_mem_ctrl->free_cur[i]=-1;
30005b28:	e59f33d4 	ldr	r3, [pc, #980]	; 30005f04 <buddy_init+0x798>
30005b2c:	e5933000 	ldr	r3, [r3]
30005b30:	e59d200c 	ldr	r2, [sp, #12]
30005b34:	e282201c 	add	r2, r2, #28
30005b38:	e3e01000 	mvn	r1, #0
30005b3c:	e7831102 	str	r1, [r3, r2, lsl #2]

	/*如果减去刚才bitmap用的内存刚好是下一level*/
	if(save_adr<=(start_adr+(resize_size>>1)))
30005b40:	e59d3014 	ldr	r3, [sp, #20]
30005b44:	e1a020a3 	lsr	r2, r3, #1
30005b48:	e59d3004 	ldr	r3, [sp, #4]
30005b4c:	e0822003 	add	r2, r2, r3
30005b50:	e59d3018 	ldr	r3, [sp, #24]
30005b54:	e1520003 	cmp	r2, r3
30005b58:	3a000002 	bcc	30005b68 <buddy_init+0x3fc>
		adjust_level--;
30005b5c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30005b60:	e2433001 	sub	r3, r3, #1
30005b64:	e58d3024 	str	r3, [sp, #36]	; 0x24
	if(adjust_level>LEVEL)
30005b68:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30005b6c:	e353000e 	cmp	r3, #14
30005b70:	9a000001 	bls	30005b7c <buddy_init+0x410>
		level=LEVEL;
30005b74:	e3a0300e 	mov	r3, #14
30005b78:	e58d3028 	str	r3, [sp, #40]	; 0x28
	acoral_mem_ctrl->level=level;
30005b7c:	e59f3380 	ldr	r3, [pc, #896]	; 30005f04 <buddy_init+0x798>
30005b80:	e5933000 	ldr	r3, [r3]
30005b84:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005b88:	e20220ff 	and	r2, r2, #255	; 0xff
30005b8c:	e5c320e0 	strb	r2, [r3, #224]	; 0xe0
	acoral_mem_ctrl->start_adr=start_adr;
30005b90:	e59f336c 	ldr	r3, [pc, #876]	; 30005f04 <buddy_init+0x798>
30005b94:	e5933000 	ldr	r3, [r3]
30005b98:	e59d2004 	ldr	r2, [sp, #4]
30005b9c:	e58320e4 	str	r2, [r3, #228]	; 0xe4
	num=(save_adr-start_adr)>>BLOCK_SHIFT;
30005ba0:	e59d2018 	ldr	r2, [sp, #24]
30005ba4:	e59d3004 	ldr	r3, [sp, #4]
30005ba8:	e0633002 	rsb	r3, r3, r2
30005bac:	e1a033a3 	lsr	r3, r3, #7
30005bb0:	e58d3020 	str	r3, [sp, #32]
	acoral_mem_ctrl->end_adr=start_adr+(num<<BLOCK_SHIFT);
30005bb4:	e59f3348 	ldr	r3, [pc, #840]	; 30005f04 <buddy_init+0x798>
30005bb8:	e5933000 	ldr	r3, [r3]
30005bbc:	e59d2020 	ldr	r2, [sp, #32]
30005bc0:	e1a01382 	lsl	r1, r2, #7
30005bc4:	e59d2004 	ldr	r2, [sp, #4]
30005bc8:	e0812002 	add	r2, r1, r2
30005bcc:	e58320e8 	str	r2, [r3, #232]	; 0xe8
	acoral_mem_ctrl->block_num=num;
30005bd0:	e59f332c 	ldr	r3, [pc, #812]	; 30005f04 <buddy_init+0x798>
30005bd4:	e5933000 	ldr	r3, [r3]
30005bd8:	e59d2020 	ldr	r2, [sp, #32]
30005bdc:	e58320ec 	str	r2, [r3, #236]	; 0xec
	acoral_mem_ctrl->free_num=num;
30005be0:	e59f331c 	ldr	r3, [pc, #796]	; 30005f04 <buddy_init+0x798>
30005be4:	e5933000 	ldr	r3, [r3]
30005be8:	e59d2020 	ldr	r2, [sp, #32]
30005bec:	e58320f0 	str	r2, [r3, #240]	; 0xf0
	acoral_mem_ctrl->block_size=BLOCK_SIZE;
30005bf0:	e59f330c 	ldr	r3, [pc, #780]	; 30005f04 <buddy_init+0x798>
30005bf4:	e5933000 	ldr	r3, [r3]
30005bf8:	e3a02080 	mov	r2, #128	; 0x80
30005bfc:	e58320f4 	str	r2, [r3, #244]	; 0xf4

	i=0;
30005c00:	e3a03000 	mov	r3, #0
30005c04:	e58d300c 	str	r3, [sp, #12]
	max_num=1<<level-1;
30005c08:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30005c0c:	e2433001 	sub	r3, r3, #1
30005c10:	e3a02001 	mov	r2, #1
30005c14:	e1a03312 	lsl	r3, r2, r3
30005c18:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	o_num=0;
30005c1c:	e3a03000 	mov	r3, #0
30005c20:	e58d3030 	str	r3, [sp, #48]	; 0x30
	if(num>0)
30005c24:	e59d3020 	ldr	r3, [sp, #32]
30005c28:	e3530000 	cmp	r3, #0
30005c2c:	0a000007 	beq	30005c50 <buddy_init+0x4e4>
		acoral_mem_ctrl->free_cur[level-1]=0;
30005c30:	e59f32cc 	ldr	r3, [pc, #716]	; 30005f04 <buddy_init+0x798>
30005c34:	e5933000 	ldr	r3, [r3]
30005c38:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005c3c:	e2422001 	sub	r2, r2, #1
30005c40:	e282201c 	add	r2, r2, #28
30005c44:	e3a01000 	mov	r1, #0
30005c48:	e7831102 	str	r1, [r3, r2, lsl #2]
	else
		acoral_mem_ctrl->free_cur[level-1]=-1;

	while(num>=max_num*32){
30005c4c:	ea00002a 	b	30005cfc <buddy_init+0x590>
	max_num=1<<level-1;
	o_num=0;
	if(num>0)
		acoral_mem_ctrl->free_cur[level-1]=0;
	else
		acoral_mem_ctrl->free_cur[level-1]=-1;
30005c50:	e59f32ac 	ldr	r3, [pc, #684]	; 30005f04 <buddy_init+0x798>
30005c54:	e5933000 	ldr	r3, [r3]
30005c58:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005c5c:	e2422001 	sub	r2, r2, #1
30005c60:	e282201c 	add	r2, r2, #28
30005c64:	e3e01000 	mvn	r1, #0
30005c68:	e7831102 	str	r1, [r3, r2, lsl #2]

	while(num>=max_num*32){
30005c6c:	ea000022 	b	30005cfc <buddy_init+0x590>
		acoral_mem_ctrl->bitmap[level-1][i]=-1;;
30005c70:	e59f328c 	ldr	r3, [pc, #652]	; 30005f04 <buddy_init+0x798>
30005c74:	e5933000 	ldr	r3, [r3]
30005c78:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005c7c:	e2422001 	sub	r2, r2, #1
30005c80:	e282200e 	add	r2, r2, #14
30005c84:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005c88:	e59d300c 	ldr	r3, [sp, #12]
30005c8c:	e1a03103 	lsl	r3, r3, #2
30005c90:	e0823003 	add	r3, r2, r3
30005c94:	e3e02000 	mvn	r2, #0
30005c98:	e5832000 	str	r2, [r3]
		acoral_mem_ctrl->free_list[level-1][i]=i+1;
30005c9c:	e59f3260 	ldr	r3, [pc, #608]	; 30005f04 <buddy_init+0x798>
30005ca0:	e5933000 	ldr	r3, [r3]
30005ca4:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005ca8:	e2422001 	sub	r2, r2, #1
30005cac:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005cb0:	e59d300c 	ldr	r3, [sp, #12]
30005cb4:	e1a03103 	lsl	r3, r3, #2
30005cb8:	e0823003 	add	r3, r2, r3
30005cbc:	e59d200c 	ldr	r2, [sp, #12]
30005cc0:	e2822001 	add	r2, r2, #1
30005cc4:	e5832000 	str	r2, [r3]
		num-=max_num*32;
30005cc8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005ccc:	e1a03283 	lsl	r3, r3, #5
30005cd0:	e59d2020 	ldr	r2, [sp, #32]
30005cd4:	e0633002 	rsb	r3, r3, r2
30005cd8:	e58d3020 	str	r3, [sp, #32]
		o_num+=max_num*32;
30005cdc:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005ce0:	e1a03283 	lsl	r3, r3, #5
30005ce4:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
30005ce8:	e0823003 	add	r3, r2, r3
30005cec:	e58d3030 	str	r3, [sp, #48]	; 0x30
		i++;
30005cf0:	e59d300c 	ldr	r3, [sp, #12]
30005cf4:	e2833001 	add	r3, r3, #1
30005cf8:	e58d300c 	str	r3, [sp, #12]
	if(num>0)
		acoral_mem_ctrl->free_cur[level-1]=0;
	else
		acoral_mem_ctrl->free_cur[level-1]=-1;

	while(num>=max_num*32){
30005cfc:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005d00:	e1a02283 	lsl	r2, r3, #5
30005d04:	e59d3020 	ldr	r3, [sp, #32]
30005d08:	e1520003 	cmp	r2, r3
30005d0c:	9affffd7 	bls	30005c70 <buddy_init+0x504>
		acoral_mem_ctrl->free_list[level-1][i]=i+1;
		num-=max_num*32;
		o_num+=max_num*32;
		i++;
	}
	if(num==0)
30005d10:	e59d3020 	ldr	r3, [sp, #32]
30005d14:	e3530000 	cmp	r3, #0
30005d18:	1a000021 	bne	30005da4 <buddy_init+0x638>
		acoral_mem_ctrl->free_list[level-1][i-1]=-1;
30005d1c:	e59f31e0 	ldr	r3, [pc, #480]	; 30005f04 <buddy_init+0x798>
30005d20:	e5933000 	ldr	r3, [r3]
30005d24:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005d28:	e2422001 	sub	r2, r2, #1
30005d2c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005d30:	e59d300c 	ldr	r3, [sp, #12]
30005d34:	e2433001 	sub	r3, r3, #1
30005d38:	e1a03103 	lsl	r3, r3, #2
30005d3c:	e0823003 	add	r3, r2, r3
30005d40:	e3e02000 	mvn	r2, #0
30005d44:	e5832000 	str	r2, [r3]
	while(num>=max_num){
30005d48:	ea000015 	b	30005da4 <buddy_init+0x638>
		index=o_num>>level-1;
30005d4c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30005d50:	e2433001 	sub	r3, r3, #1
30005d54:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
30005d58:	e1a03332 	lsr	r3, r2, r3
30005d5c:	e58d301c 	str	r3, [sp, #28]
		acoral_set_bit(index,acoral_mem_ctrl->bitmap[level-1]);
30005d60:	e59f319c 	ldr	r3, [pc, #412]	; 30005f04 <buddy_init+0x798>
30005d64:	e5933000 	ldr	r3, [r3]
30005d68:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005d6c:	e2422001 	sub	r2, r2, #1
30005d70:	e282200e 	add	r2, r2, #14
30005d74:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30005d78:	e59d001c 	ldr	r0, [sp, #28]
30005d7c:	e1a01003 	mov	r1, r3
30005d80:	eb001034 	bl	30009e58 <acoral_set_bit>
		num-=max_num;
30005d84:	e59d2020 	ldr	r2, [sp, #32]
30005d88:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005d8c:	e0633002 	rsb	r3, r3, r2
30005d90:	e58d3020 	str	r3, [sp, #32]
		o_num+=max_num;
30005d94:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
30005d98:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005d9c:	e0823003 	add	r3, r2, r3
30005da0:	e58d3030 	str	r3, [sp, #48]	; 0x30
		o_num+=max_num*32;
		i++;
	}
	if(num==0)
		acoral_mem_ctrl->free_list[level-1][i-1]=-1;
	while(num>=max_num){
30005da4:	e59d2020 	ldr	r2, [sp, #32]
30005da8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005dac:	e1520003 	cmp	r2, r3
30005db0:	2affffe5 	bcs	30005d4c <buddy_init+0x5e0>
		index=o_num>>level-1;
		acoral_set_bit(index,acoral_mem_ctrl->bitmap[level-1]);
		num-=max_num;
		o_num+=max_num;
	}
	acoral_mem_ctrl->free_list[level-1][i]=-1;
30005db4:	e59f3148 	ldr	r3, [pc, #328]	; 30005f04 <buddy_init+0x798>
30005db8:	e5933000 	ldr	r3, [r3]
30005dbc:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005dc0:	e2422001 	sub	r2, r2, #1
30005dc4:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005dc8:	e59d300c 	ldr	r3, [sp, #12]
30005dcc:	e1a03103 	lsl	r3, r3, #2
30005dd0:	e0823003 	add	r3, r2, r3
30005dd4:	e3e02000 	mvn	r2, #0
30005dd8:	e5832000 	str	r2, [r3]

	
	while(--level>0){
30005ddc:	ea00003b 	b	30005ed0 <buddy_init+0x764>
		index=o_num>>level;
30005de0:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
30005de4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30005de8:	e1a03332 	lsr	r3, r2, r3
30005dec:	e58d301c 	str	r3, [sp, #28]
		if(num==0)
30005df0:	e59d3020 	ldr	r3, [sp, #32]
30005df4:	e3530000 	cmp	r3, #0
30005df8:	0a00003b 	beq	30005eec <buddy_init+0x780>
			break;
		cur=index/32;
30005dfc:	e59d301c 	ldr	r3, [sp, #28]
30005e00:	e1a032a3 	lsr	r3, r3, #5
30005e04:	e58d3034 	str	r3, [sp, #52]	; 0x34
		max_num=1<<level-1;
30005e08:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30005e0c:	e2433001 	sub	r3, r3, #1
30005e10:	e3a02001 	mov	r2, #1
30005e14:	e1a03312 	lsl	r3, r2, r3
30005e18:	e58d302c 	str	r3, [sp, #44]	; 0x2c
		if(num>=max_num){
30005e1c:	e59d2020 	ldr	r2, [sp, #32]
30005e20:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005e24:	e1520003 	cmp	r2, r3
30005e28:	3a000028 	bcc	30005ed0 <buddy_init+0x764>
			acoral_mem_blocks[BLOCK_INDEX(o_num)].level=-1;	
30005e2c:	e59f30d4 	ldr	r3, [pc, #212]	; 30005f08 <buddy_init+0x79c>
30005e30:	e5932000 	ldr	r2, [r3]
30005e34:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30005e38:	e1a030a3 	lsr	r3, r3, #1
30005e3c:	e0823003 	add	r3, r2, r3
30005e40:	e3e02000 	mvn	r2, #0
30005e44:	e5c32000 	strb	r2, [r3]
			acoral_set_bit(index,acoral_mem_ctrl->bitmap[level-1]);
30005e48:	e59f30b4 	ldr	r3, [pc, #180]	; 30005f04 <buddy_init+0x798>
30005e4c:	e5933000 	ldr	r3, [r3]
30005e50:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005e54:	e2422001 	sub	r2, r2, #1
30005e58:	e282200e 	add	r2, r2, #14
30005e5c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30005e60:	e59d001c 	ldr	r0, [sp, #28]
30005e64:	e1a01003 	mov	r1, r3
30005e68:	eb000ffa 	bl	30009e58 <acoral_set_bit>
			acoral_mem_ctrl->free_list[level-1][cur]=-1;	
30005e6c:	e59f3090 	ldr	r3, [pc, #144]	; 30005f04 <buddy_init+0x798>
30005e70:	e5933000 	ldr	r3, [r3]
30005e74:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005e78:	e2422001 	sub	r2, r2, #1
30005e7c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005e80:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30005e84:	e1a03103 	lsl	r3, r3, #2
30005e88:	e0823003 	add	r3, r2, r3
30005e8c:	e3e02000 	mvn	r2, #0
30005e90:	e5832000 	str	r2, [r3]
			acoral_mem_ctrl->free_cur[level-1]=cur;	
30005e94:	e59f3068 	ldr	r3, [pc, #104]	; 30005f04 <buddy_init+0x798>
30005e98:	e5933000 	ldr	r3, [r3]
30005e9c:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005ea0:	e2422001 	sub	r2, r2, #1
30005ea4:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
30005ea8:	e282201c 	add	r2, r2, #28
30005eac:	e7831102 	str	r1, [r3, r2, lsl #2]
			o_num+=max_num;
30005eb0:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
30005eb4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005eb8:	e0823003 	add	r3, r2, r3
30005ebc:	e58d3030 	str	r3, [sp, #48]	; 0x30
			num-=max_num;
30005ec0:	e59d2020 	ldr	r2, [sp, #32]
30005ec4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005ec8:	e0633002 	rsb	r3, r3, r2
30005ecc:	e58d3020 	str	r3, [sp, #32]
		o_num+=max_num;
	}
	acoral_mem_ctrl->free_list[level-1][i]=-1;

	
	while(--level>0){
30005ed0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30005ed4:	e2433001 	sub	r3, r3, #1
30005ed8:	e58d3028 	str	r3, [sp, #40]	; 0x28
30005edc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30005ee0:	e3530000 	cmp	r3, #0
30005ee4:	caffffbd 	bgt	30005de0 <buddy_init+0x674>
30005ee8:	ea000000 	b	30005ef0 <buddy_init+0x784>
		index=o_num>>level;
		if(num==0)
			break;
30005eec:	e1a00000 	nop			; (mov r0, r0)
			o_num+=max_num;
			num-=max_num;
		}
	}
	acoral_spin_init(&acoral_mem_ctrl->lock);
	return 0;
30005ef0:	e3a03000 	mov	r3, #0
}
30005ef4:	e1a00003 	mov	r0, r3
30005ef8:	e28dd03c 	add	sp, sp, #60	; 0x3c
30005efc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30005f00:	e12fff1e 	bx	lr
30005f04:	3002b110 	.word	0x3002b110
30005f08:	3002a810 	.word	0x3002a810

30005f0c <recus_malloc>:

static acoral_32 recus_malloc(level){
30005f0c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30005f10:	e24dd01c 	sub	sp, sp, #28
30005f14:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 index;
	acoral_32 cur;
	acoral_32 num;
	if(level>=acoral_mem_ctrl->level)
30005f18:	e59f328c 	ldr	r3, [pc, #652]	; 300061ac <recus_malloc+0x2a0>
30005f1c:	e5933000 	ldr	r3, [r3]
30005f20:	e5d330e0 	ldrb	r3, [r3, #224]	; 0xe0
30005f24:	e1a03c03 	lsl	r3, r3, #24
30005f28:	e1a02c43 	asr	r2, r3, #24
30005f2c:	e59d3004 	ldr	r3, [sp, #4]
30005f30:	e1520003 	cmp	r2, r3
30005f34:	ca000001 	bgt	30005f40 <recus_malloc+0x34>
		return -1;
30005f38:	e3e03000 	mvn	r3, #0
30005f3c:	ea000096 	b	3000619c <recus_malloc+0x290>
	cur=acoral_mem_ctrl->free_cur[level];
30005f40:	e59f3264 	ldr	r3, [pc, #612]	; 300061ac <recus_malloc+0x2a0>
30005f44:	e5933000 	ldr	r3, [r3]
30005f48:	e59d2004 	ldr	r2, [sp, #4]
30005f4c:	e282201c 	add	r2, r2, #28
30005f50:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30005f54:	e58d3010 	str	r3, [sp, #16]
	if(cur<0){
30005f58:	e59d3010 	ldr	r3, [sp, #16]
30005f5c:	e3530000 	cmp	r3, #0
30005f60:	aa00002b 	bge	30006014 <recus_malloc+0x108>
		num=recus_malloc(level+1);
30005f64:	e59d3004 	ldr	r3, [sp, #4]
30005f68:	e2833001 	add	r3, r3, #1
30005f6c:	e1a00003 	mov	r0, r3
30005f70:	ebffffe5 	bl	30005f0c <recus_malloc>
30005f74:	e1a03000 	mov	r3, r0
30005f78:	e58d3014 	str	r3, [sp, #20]
		if(num<0)
30005f7c:	e59d3014 	ldr	r3, [sp, #20]
30005f80:	e3530000 	cmp	r3, #0
30005f84:	aa000001 	bge	30005f90 <recus_malloc+0x84>
			return -1;
30005f88:	e3e03000 	mvn	r3, #0
30005f8c:	ea000082 	b	3000619c <recus_malloc+0x290>
		index=num>>level+1;
30005f90:	e59d3004 	ldr	r3, [sp, #4]
30005f94:	e2833001 	add	r3, r3, #1
30005f98:	e59d2014 	ldr	r2, [sp, #20]
30005f9c:	e1a03352 	asr	r3, r2, r3
30005fa0:	e58d300c 	str	r3, [sp, #12]
		cur=index/32;
30005fa4:	e59d300c 	ldr	r3, [sp, #12]
30005fa8:	e1a032a3 	lsr	r3, r3, #5
30005fac:	e58d3010 	str	r3, [sp, #16]
		acoral_set_bit(index,acoral_mem_ctrl->bitmap[level]);
30005fb0:	e59f31f4 	ldr	r3, [pc, #500]	; 300061ac <recus_malloc+0x2a0>
30005fb4:	e5933000 	ldr	r3, [r3]
30005fb8:	e59d2004 	ldr	r2, [sp, #4]
30005fbc:	e282200e 	add	r2, r2, #14
30005fc0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30005fc4:	e59d000c 	ldr	r0, [sp, #12]
30005fc8:	e1a01003 	mov	r1, r3
30005fcc:	eb000fa1 	bl	30009e58 <acoral_set_bit>
		acoral_mem_ctrl->free_list[level][cur]=-1;
30005fd0:	e59f31d4 	ldr	r3, [pc, #468]	; 300061ac <recus_malloc+0x2a0>
30005fd4:	e5933000 	ldr	r3, [r3]
30005fd8:	e59d2004 	ldr	r2, [sp, #4]
30005fdc:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005fe0:	e59d3010 	ldr	r3, [sp, #16]
30005fe4:	e1a03103 	lsl	r3, r3, #2
30005fe8:	e0823003 	add	r3, r2, r3
30005fec:	e3e02000 	mvn	r2, #0
30005ff0:	e5832000 	str	r2, [r3]
		acoral_mem_ctrl->free_cur[level]=cur;
30005ff4:	e59f31b0 	ldr	r3, [pc, #432]	; 300061ac <recus_malloc+0x2a0>
30005ff8:	e5933000 	ldr	r3, [r3]
30005ffc:	e59d2004 	ldr	r2, [sp, #4]
30006000:	e282201c 	add	r2, r2, #28
30006004:	e59d1010 	ldr	r1, [sp, #16]
30006008:	e7831102 	str	r1, [r3, r2, lsl #2]
		return num;
3000600c:	e59d3014 	ldr	r3, [sp, #20]
30006010:	ea000061 	b	3000619c <recus_malloc+0x290>
	}
	index=acoral_ffs(acoral_mem_ctrl->bitmap[level][cur]);
30006014:	e59f3190 	ldr	r3, [pc, #400]	; 300061ac <recus_malloc+0x2a0>
30006018:	e5933000 	ldr	r3, [r3]
3000601c:	e59d2004 	ldr	r2, [sp, #4]
30006020:	e282200e 	add	r2, r2, #14
30006024:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30006028:	e59d3010 	ldr	r3, [sp, #16]
3000602c:	e1a03103 	lsl	r3, r3, #2
30006030:	e0823003 	add	r3, r2, r3
30006034:	e5933000 	ldr	r3, [r3]
30006038:	e1a00003 	mov	r0, r3
3000603c:	eb000f2a 	bl	30009cec <acoral_ffs>
30006040:	e1a03000 	mov	r3, r0
30006044:	e58d300c 	str	r3, [sp, #12]
	index=cur*32+index;
30006048:	e59d3010 	ldr	r3, [sp, #16]
3000604c:	e1a03283 	lsl	r3, r3, #5
30006050:	e59d200c 	ldr	r2, [sp, #12]
30006054:	e0823003 	add	r3, r2, r3
30006058:	e58d300c 	str	r3, [sp, #12]
	acoral_clear_bit(index,acoral_mem_ctrl->bitmap[level]);
3000605c:	e59f3148 	ldr	r3, [pc, #328]	; 300061ac <recus_malloc+0x2a0>
30006060:	e5933000 	ldr	r3, [r3]
30006064:	e59d2004 	ldr	r2, [sp, #4]
30006068:	e282200e 	add	r2, r2, #14
3000606c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30006070:	e59d000c 	ldr	r0, [sp, #12]
30006074:	e1a01003 	mov	r1, r3
30006078:	eb000f8e 	bl	30009eb8 <acoral_clear_bit>
	if(acoral_mem_ctrl->bitmap[level][cur]==0)
3000607c:	e59f3128 	ldr	r3, [pc, #296]	; 300061ac <recus_malloc+0x2a0>
30006080:	e5933000 	ldr	r3, [r3]
30006084:	e59d2004 	ldr	r2, [sp, #4]
30006088:	e282200e 	add	r2, r2, #14
3000608c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30006090:	e59d3010 	ldr	r3, [sp, #16]
30006094:	e1a03103 	lsl	r3, r3, #2
30006098:	e0823003 	add	r3, r2, r3
3000609c:	e5933000 	ldr	r3, [r3]
300060a0:	e3530000 	cmp	r3, #0
300060a4:	1a00000c 	bne	300060dc <recus_malloc+0x1d0>
		acoral_mem_ctrl->free_cur[level]=acoral_mem_ctrl->free_list[level][cur];
300060a8:	e59f30fc 	ldr	r3, [pc, #252]	; 300061ac <recus_malloc+0x2a0>
300060ac:	e5933000 	ldr	r3, [r3]
300060b0:	e59d2004 	ldr	r2, [sp, #4]
300060b4:	e59f10f0 	ldr	r1, [pc, #240]	; 300061ac <recus_malloc+0x2a0>
300060b8:	e5911000 	ldr	r1, [r1]
300060bc:	e59d0004 	ldr	r0, [sp, #4]
300060c0:	e7910100 	ldr	r0, [r1, r0, lsl #2]
300060c4:	e59d1010 	ldr	r1, [sp, #16]
300060c8:	e1a01101 	lsl	r1, r1, #2
300060cc:	e0801001 	add	r1, r0, r1
300060d0:	e5911000 	ldr	r1, [r1]
300060d4:	e282201c 	add	r2, r2, #28
300060d8:	e7831102 	str	r1, [r3, r2, lsl #2]
	num=index<<level+1;
300060dc:	e59d3004 	ldr	r3, [sp, #4]
300060e0:	e2833001 	add	r3, r3, #1
300060e4:	e59d200c 	ldr	r2, [sp, #12]
300060e8:	e1a03312 	lsl	r3, r2, r3
300060ec:	e58d3014 	str	r3, [sp, #20]
	/*最高level情况*/
	if(level==acoral_mem_ctrl->level-1){
300060f0:	e59f30b4 	ldr	r3, [pc, #180]	; 300061ac <recus_malloc+0x2a0>
300060f4:	e5933000 	ldr	r3, [r3]
300060f8:	e5d330e0 	ldrb	r3, [r3, #224]	; 0xe0
300060fc:	e1a03c03 	lsl	r3, r3, #24
30006100:	e1a03c43 	asr	r3, r3, #24
30006104:	e2432001 	sub	r2, r3, #1
30006108:	e59d3004 	ldr	r3, [sp, #4]
3000610c:	e1520003 	cmp	r2, r3
30006110:	1a000010 	bne	30006158 <recus_malloc+0x24c>
		if((num>>1)+(1<<level)>acoral_mem_ctrl->block_num)
30006114:	e59d3014 	ldr	r3, [sp, #20]
30006118:	e1a020c3 	asr	r2, r3, #1
3000611c:	e3a01001 	mov	r1, #1
30006120:	e59d3004 	ldr	r3, [sp, #4]
30006124:	e1a03311 	lsl	r3, r1, r3
30006128:	e0823003 	add	r3, r2, r3
3000612c:	e1a02003 	mov	r2, r3
30006130:	e59f3074 	ldr	r3, [pc, #116]	; 300061ac <recus_malloc+0x2a0>
30006134:	e5933000 	ldr	r3, [r3]
30006138:	e59330ec 	ldr	r3, [r3, #236]	; 0xec
3000613c:	e1520003 	cmp	r2, r3
30006140:	9a000001 	bls	3000614c <recus_malloc+0x240>
			return -1;
30006144:	e3e03000 	mvn	r3, #0
30006148:	ea000013 	b	3000619c <recus_malloc+0x290>
		return num>>1;
3000614c:	e59d3014 	ldr	r3, [sp, #20]
30006150:	e1a030c3 	asr	r3, r3, #1
30006154:	ea000010 	b	3000619c <recus_malloc+0x290>
	}
	if(acoral_mem_blocks[BLOCK_INDEX(num)].level>=0)
30006158:	e59f3050 	ldr	r3, [pc, #80]	; 300061b0 <recus_malloc+0x2a4>
3000615c:	e5932000 	ldr	r2, [r3]
30006160:	e59d3014 	ldr	r3, [sp, #20]
30006164:	e1a030c3 	asr	r3, r3, #1
30006168:	e0823003 	add	r3, r2, r3
3000616c:	e5d33000 	ldrb	r3, [r3]
30006170:	e1a03c03 	lsl	r3, r3, #24
30006174:	e1a03c43 	asr	r3, r3, #24
30006178:	e3530000 	cmp	r3, #0
3000617c:	ba000005 	blt	30006198 <recus_malloc+0x28c>
		return num+(1<<level);
30006180:	e3a02001 	mov	r2, #1
30006184:	e59d3004 	ldr	r3, [sp, #4]
30006188:	e1a02312 	lsl	r2, r2, r3
3000618c:	e59d3014 	ldr	r3, [sp, #20]
30006190:	e0823003 	add	r3, r2, r3
30006194:	ea000000 	b	3000619c <recus_malloc+0x290>
	else
		return num;
30006198:	e59d3014 	ldr	r3, [sp, #20]
}
3000619c:	e1a00003 	mov	r0, r3
300061a0:	e28dd01c 	add	sp, sp, #28
300061a4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300061a8:	e12fff1e 	bx	lr
300061ac:	3002b110 	.word	0x3002b110
300061b0:	3002a810 	.word	0x3002a810

300061b4 <r_malloc>:

static void *r_malloc(acoral_u8 level){
300061b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300061b8:	e24dd01c 	sub	sp, sp, #28
300061bc:	e1a03000 	mov	r3, r0
300061c0:	e5cd3007 	strb	r3, [sp, #7]
	acoral_sr cpu_sr;
	acoral_u32 index;
	acoral_32 num,cur;
	HAL_ENTER_CRITICAL();
300061c4:	ebffed4a 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300061c8:	e1a03000 	mov	r3, r0
300061cc:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&acoral_mem_ctrl->lock);
	acoral_mem_ctrl->free_num-=1<<level;
300061d0:	e59f3334 	ldr	r3, [pc, #820]	; 3000650c <r_malloc+0x358>
300061d4:	e5933000 	ldr	r3, [r3]
300061d8:	e59f232c 	ldr	r2, [pc, #812]	; 3000650c <r_malloc+0x358>
300061dc:	e5922000 	ldr	r2, [r2]
300061e0:	e59210f0 	ldr	r1, [r2, #240]	; 0xf0
300061e4:	e5dd2007 	ldrb	r2, [sp, #7]
300061e8:	e3a00001 	mov	r0, #1
300061ec:	e1a02210 	lsl	r2, r0, r2
300061f0:	e0622001 	rsb	r2, r2, r1
300061f4:	e58320f0 	str	r2, [r3, #240]	; 0xf0
	cur=acoral_mem_ctrl->free_cur[level];
300061f8:	e59f330c 	ldr	r3, [pc, #780]	; 3000650c <r_malloc+0x358>
300061fc:	e5933000 	ldr	r3, [r3]
30006200:	e5dd2007 	ldrb	r2, [sp, #7]
30006204:	e282201c 	add	r2, r2, #28
30006208:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3000620c:	e58d3014 	str	r3, [sp, #20]
	if(cur<0){
30006210:	e59d3014 	ldr	r3, [sp, #20]
30006214:	e3530000 	cmp	r3, #0
30006218:	aa00003f 	bge	3000631c <r_malloc+0x168>
		num=recus_malloc(level+1);
3000621c:	e5dd3007 	ldrb	r3, [sp, #7]
30006220:	e2833001 	add	r3, r3, #1
30006224:	e1a00003 	mov	r0, r3
30006228:	ebffff37 	bl	30005f0c <recus_malloc>
3000622c:	e1a03000 	mov	r3, r0
30006230:	e58d3010 	str	r3, [sp, #16]
		if(num<0){
30006234:	e59d3010 	ldr	r3, [sp, #16]
30006238:	e3530000 	cmp	r3, #0
3000623c:	aa000003 	bge	30006250 <r_malloc+0x9c>
			acoral_spin_unlock(&acoral_mem_ctrl->lock);
			HAL_EXIT_CRITICAL();
30006240:	e59d0008 	ldr	r0, [sp, #8]
30006244:	ebffed28 	bl	300016ec <HAL_INTR_RESTORE>
			return NULL;
30006248:	e3a03000 	mov	r3, #0
3000624c:	ea0000aa 	b	300064fc <r_malloc+0x348>
		}
		index=num>>level+1;
30006250:	e5dd3007 	ldrb	r3, [sp, #7]
30006254:	e2833001 	add	r3, r3, #1
30006258:	e59d2010 	ldr	r2, [sp, #16]
3000625c:	e1a03352 	asr	r3, r2, r3
30006260:	e58d300c 	str	r3, [sp, #12]
		cur=index/32;
30006264:	e59d300c 	ldr	r3, [sp, #12]
30006268:	e1a032a3 	lsr	r3, r3, #5
3000626c:	e58d3014 	str	r3, [sp, #20]
		acoral_set_bit(index,acoral_mem_ctrl->bitmap[level]);
30006270:	e59f3294 	ldr	r3, [pc, #660]	; 3000650c <r_malloc+0x358>
30006274:	e5933000 	ldr	r3, [r3]
30006278:	e5dd2007 	ldrb	r2, [sp, #7]
3000627c:	e282200e 	add	r2, r2, #14
30006280:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30006284:	e59d000c 	ldr	r0, [sp, #12]
30006288:	e1a01003 	mov	r1, r3
3000628c:	eb000ef1 	bl	30009e58 <acoral_set_bit>
		acoral_mem_ctrl->free_list[level][cur]=-1;
30006290:	e59f3274 	ldr	r3, [pc, #628]	; 3000650c <r_malloc+0x358>
30006294:	e5933000 	ldr	r3, [r3]
30006298:	e5dd2007 	ldrb	r2, [sp, #7]
3000629c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
300062a0:	e59d3014 	ldr	r3, [sp, #20]
300062a4:	e1a03103 	lsl	r3, r3, #2
300062a8:	e0823003 	add	r3, r2, r3
300062ac:	e3e02000 	mvn	r2, #0
300062b0:	e5832000 	str	r2, [r3]
		acoral_mem_ctrl->free_cur[level]=cur;
300062b4:	e59f3250 	ldr	r3, [pc, #592]	; 3000650c <r_malloc+0x358>
300062b8:	e5933000 	ldr	r3, [r3]
300062bc:	e5dd2007 	ldrb	r2, [sp, #7]
300062c0:	e282201c 	add	r2, r2, #28
300062c4:	e59d1014 	ldr	r1, [sp, #20]
300062c8:	e7831102 	str	r1, [r3, r2, lsl #2]
		if((num&0x1)==0)
300062cc:	e59d3010 	ldr	r3, [sp, #16]
300062d0:	e2033001 	and	r3, r3, #1
300062d4:	e3530000 	cmp	r3, #0
300062d8:	1a000006 	bne	300062f8 <r_malloc+0x144>
			acoral_mem_blocks[BLOCK_INDEX(num)].level=level;
300062dc:	e59f322c 	ldr	r3, [pc, #556]	; 30006510 <r_malloc+0x35c>
300062e0:	e5932000 	ldr	r2, [r3]
300062e4:	e59d3010 	ldr	r3, [sp, #16]
300062e8:	e1a030c3 	asr	r3, r3, #1
300062ec:	e0823003 	add	r3, r2, r3
300062f0:	e5dd2007 	ldrb	r2, [sp, #7]
300062f4:	e5c32000 	strb	r2, [r3]
#endif
#ifdef CFG_TEST_MEM
		buddy_scan();
#endif
		acoral_spin_unlock(&acoral_mem_ctrl->lock);
		HAL_EXIT_CRITICAL();
300062f8:	e59d0008 	ldr	r0, [sp, #8]
300062fc:	ebffecfa 	bl	300016ec <HAL_INTR_RESTORE>
		return (void *)(acoral_mem_ctrl->start_adr+(num<<BLOCK_SHIFT));
30006300:	e59f3204 	ldr	r3, [pc, #516]	; 3000650c <r_malloc+0x358>
30006304:	e5933000 	ldr	r3, [r3]
30006308:	e59320e4 	ldr	r2, [r3, #228]	; 0xe4
3000630c:	e59d3010 	ldr	r3, [sp, #16]
30006310:	e1a03383 	lsl	r3, r3, #7
30006314:	e0823003 	add	r3, r2, r3
30006318:	ea000077 	b	300064fc <r_malloc+0x348>
	}
	index=acoral_ffs(acoral_mem_ctrl->bitmap[level][cur]);
3000631c:	e59f31e8 	ldr	r3, [pc, #488]	; 3000650c <r_malloc+0x358>
30006320:	e5933000 	ldr	r3, [r3]
30006324:	e5dd2007 	ldrb	r2, [sp, #7]
30006328:	e282200e 	add	r2, r2, #14
3000632c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30006330:	e59d3014 	ldr	r3, [sp, #20]
30006334:	e1a03103 	lsl	r3, r3, #2
30006338:	e0823003 	add	r3, r2, r3
3000633c:	e5933000 	ldr	r3, [r3]
30006340:	e1a00003 	mov	r0, r3
30006344:	eb000e68 	bl	30009cec <acoral_ffs>
30006348:	e1a03000 	mov	r3, r0
3000634c:	e58d300c 	str	r3, [sp, #12]
	index=index+cur*32;
30006350:	e59d3014 	ldr	r3, [sp, #20]
30006354:	e1a03283 	lsl	r3, r3, #5
30006358:	e59d200c 	ldr	r2, [sp, #12]
3000635c:	e0823003 	add	r3, r2, r3
30006360:	e58d300c 	str	r3, [sp, #12]
	acoral_clear_bit(index,acoral_mem_ctrl->bitmap[level]);
30006364:	e59f31a0 	ldr	r3, [pc, #416]	; 3000650c <r_malloc+0x358>
30006368:	e5933000 	ldr	r3, [r3]
3000636c:	e5dd2007 	ldrb	r2, [sp, #7]
30006370:	e282200e 	add	r2, r2, #14
30006374:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30006378:	e59d000c 	ldr	r0, [sp, #12]
3000637c:	e1a01003 	mov	r1, r3
30006380:	eb000ecc 	bl	30009eb8 <acoral_clear_bit>
	if(acoral_mem_ctrl->bitmap[level][cur]==0){
30006384:	e59f3180 	ldr	r3, [pc, #384]	; 3000650c <r_malloc+0x358>
30006388:	e5933000 	ldr	r3, [r3]
3000638c:	e5dd2007 	ldrb	r2, [sp, #7]
30006390:	e282200e 	add	r2, r2, #14
30006394:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30006398:	e59d3014 	ldr	r3, [sp, #20]
3000639c:	e1a03103 	lsl	r3, r3, #2
300063a0:	e0823003 	add	r3, r2, r3
300063a4:	e5933000 	ldr	r3, [r3]
300063a8:	e3530000 	cmp	r3, #0
300063ac:	1a00000c 	bne	300063e4 <r_malloc+0x230>
		acoral_mem_ctrl->free_cur[level]=acoral_mem_ctrl->free_list[level][cur];
300063b0:	e59f3154 	ldr	r3, [pc, #340]	; 3000650c <r_malloc+0x358>
300063b4:	e5933000 	ldr	r3, [r3]
300063b8:	e5dd2007 	ldrb	r2, [sp, #7]
300063bc:	e59f1148 	ldr	r1, [pc, #328]	; 3000650c <r_malloc+0x358>
300063c0:	e5911000 	ldr	r1, [r1]
300063c4:	e5dd0007 	ldrb	r0, [sp, #7]
300063c8:	e7910100 	ldr	r0, [r1, r0, lsl #2]
300063cc:	e59d1014 	ldr	r1, [sp, #20]
300063d0:	e1a01101 	lsl	r1, r1, #2
300063d4:	e0801001 	add	r1, r0, r1
300063d8:	e5911000 	ldr	r1, [r1]
300063dc:	e282201c 	add	r2, r2, #28
300063e0:	e7831102 	str	r1, [r3, r2, lsl #2]
	}
	if(level==acoral_mem_ctrl->level-1){
300063e4:	e5dd2007 	ldrb	r2, [sp, #7]
300063e8:	e59f311c 	ldr	r3, [pc, #284]	; 3000650c <r_malloc+0x358>
300063ec:	e5933000 	ldr	r3, [r3]
300063f0:	e5d330e0 	ldrb	r3, [r3, #224]	; 0xe0
300063f4:	e1a03c03 	lsl	r3, r3, #24
300063f8:	e1a03c43 	asr	r3, r3, #24
300063fc:	e2433001 	sub	r3, r3, #1
30006400:	e1520003 	cmp	r2, r3
30006404:	1a000012 	bne	30006454 <r_malloc+0x2a0>
		num=index<<level;
30006408:	e5dd3007 	ldrb	r3, [sp, #7]
3000640c:	e59d200c 	ldr	r2, [sp, #12]
30006410:	e1a03312 	lsl	r3, r2, r3
30006414:	e58d3010 	str	r3, [sp, #16]
		if(num+(1<<level)>acoral_mem_ctrl->block_num){
30006418:	e5dd3007 	ldrb	r3, [sp, #7]
3000641c:	e3a02001 	mov	r2, #1
30006420:	e1a02312 	lsl	r2, r2, r3
30006424:	e59d3010 	ldr	r3, [sp, #16]
30006428:	e0823003 	add	r3, r2, r3
3000642c:	e1a02003 	mov	r2, r3
30006430:	e59f30d4 	ldr	r3, [pc, #212]	; 3000650c <r_malloc+0x358>
30006434:	e5933000 	ldr	r3, [r3]
30006438:	e59330ec 	ldr	r3, [r3, #236]	; 0xec
3000643c:	e1520003 	cmp	r2, r3
30006440:	9a000019 	bls	300064ac <r_malloc+0x2f8>
			acoral_spin_unlock(&acoral_mem_ctrl->lock);
			HAL_EXIT_CRITICAL();
30006444:	e59d0008 	ldr	r0, [sp, #8]
30006448:	ebffeca7 	bl	300016ec <HAL_INTR_RESTORE>
			return NULL; 
3000644c:	e3a03000 	mov	r3, #0
30006450:	ea000029 	b	300064fc <r_malloc+0x348>
		}
	}
	else{
		num=index<<level+1;
30006454:	e5dd3007 	ldrb	r3, [sp, #7]
30006458:	e2833001 	add	r3, r3, #1
3000645c:	e59d200c 	ldr	r2, [sp, #12]
30006460:	e1a03312 	lsl	r3, r2, r3
30006464:	e58d3010 	str	r3, [sp, #16]
		if(acoral_mem_blocks[BLOCK_INDEX(num)].level>=0)
30006468:	e59f30a0 	ldr	r3, [pc, #160]	; 30006510 <r_malloc+0x35c>
3000646c:	e5932000 	ldr	r2, [r3]
30006470:	e59d3010 	ldr	r3, [sp, #16]
30006474:	e1a030c3 	asr	r3, r3, #1
30006478:	e0823003 	add	r3, r2, r3
3000647c:	e5d33000 	ldrb	r3, [r3]
30006480:	e1a03c03 	lsl	r3, r3, #24
30006484:	e1a03c43 	asr	r3, r3, #24
30006488:	e3530000 	cmp	r3, #0
3000648c:	ba000007 	blt	300064b0 <r_malloc+0x2fc>
			num+=(1<<level);
30006490:	e5dd3007 	ldrb	r3, [sp, #7]
30006494:	e3a02001 	mov	r2, #1
30006498:	e1a03312 	lsl	r3, r2, r3
3000649c:	e59d2010 	ldr	r2, [sp, #16]
300064a0:	e0823003 	add	r3, r2, r3
300064a4:	e58d3010 	str	r3, [sp, #16]
300064a8:	ea000000 	b	300064b0 <r_malloc+0x2fc>
	if(level==acoral_mem_ctrl->level-1){
		num=index<<level;
		if(num+(1<<level)>acoral_mem_ctrl->block_num){
			acoral_spin_unlock(&acoral_mem_ctrl->lock);
			HAL_EXIT_CRITICAL();
			return NULL; 
300064ac:	e1a00000 	nop			; (mov r0, r0)
	else{
		num=index<<level+1;
		if(acoral_mem_blocks[BLOCK_INDEX(num)].level>=0)
			num+=(1<<level);
	}
	if((num&0x1)==0)
300064b0:	e59d3010 	ldr	r3, [sp, #16]
300064b4:	e2033001 	and	r3, r3, #1
300064b8:	e3530000 	cmp	r3, #0
300064bc:	1a000006 	bne	300064dc <r_malloc+0x328>
		acoral_mem_blocks[BLOCK_INDEX(num)].level=level;
300064c0:	e59f3048 	ldr	r3, [pc, #72]	; 30006510 <r_malloc+0x35c>
300064c4:	e5932000 	ldr	r2, [r3]
300064c8:	e59d3010 	ldr	r3, [sp, #16]
300064cc:	e1a030c3 	asr	r3, r3, #1
300064d0:	e0823003 	add	r3, r2, r3
300064d4:	e5dd2007 	ldrb	r2, [sp, #7]
300064d8:	e5c32000 	strb	r2, [r3]
#endif
#ifdef CFG_TEST_MEM
	buddy_scan();
#endif
	acoral_spin_unlock(&acoral_mem_ctrl->lock);
	HAL_EXIT_CRITICAL();
300064dc:	e59d0008 	ldr	r0, [sp, #8]
300064e0:	ebffec81 	bl	300016ec <HAL_INTR_RESTORE>
	return (void *)(acoral_mem_ctrl->start_adr+(num<<BLOCK_SHIFT));
300064e4:	e59f3020 	ldr	r3, [pc, #32]	; 3000650c <r_malloc+0x358>
300064e8:	e5933000 	ldr	r3, [r3]
300064ec:	e59320e4 	ldr	r2, [r3, #228]	; 0xe4
300064f0:	e59d3010 	ldr	r3, [sp, #16]
300064f4:	e1a03383 	lsl	r3, r3, #7
300064f8:	e0823003 	add	r3, r2, r3
}
300064fc:	e1a00003 	mov	r0, r3
30006500:	e28dd01c 	add	sp, sp, #28
30006504:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30006508:	e12fff1e 	bx	lr
3000650c:	3002b110 	.word	0x3002b110
30006510:	3002a810 	.word	0x3002a810

30006514 <buddy_malloc_size>:

acoral_u32 buddy_malloc_size(acoral_u32 size){
30006514:	e24dd018 	sub	sp, sp, #24
30006518:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 resize_size;	
	acoral_u8 level=0;	
3000651c:	e3a03000 	mov	r3, #0
30006520:	e5cd3013 	strb	r3, [sp, #19]
	acoral_u32 num=1;	
30006524:	e3a03001 	mov	r3, #1
30006528:	e58d3014 	str	r3, [sp, #20]
	resize_size=BLOCK_SIZE;
3000652c:	e3a03080 	mov	r3, #128	; 0x80
30006530:	e58d300c 	str	r3, [sp, #12]
	if(acoral_mem_ctrl->state==MEM_NO_ALLOC)
30006534:	e59f3078 	ldr	r3, [pc, #120]	; 300065b4 <buddy_malloc_size+0xa0>
30006538:	e5933000 	ldr	r3, [r3]
3000653c:	e5d330e1 	ldrb	r3, [r3, #225]	; 0xe1
30006540:	e3530000 	cmp	r3, #0
30006544:	1a00000a 	bne	30006574 <buddy_malloc_size+0x60>
		return 0;
30006548:	e3a03000 	mov	r3, #0
3000654c:	ea000015 	b	300065a8 <buddy_malloc_size+0x94>
	while(resize_size<size&&level<acoral_mem_ctrl->level){
		num=num<<1;
30006550:	e59d3014 	ldr	r3, [sp, #20]
30006554:	e1a03083 	lsl	r3, r3, #1
30006558:	e58d3014 	str	r3, [sp, #20]
		level++;
3000655c:	e5dd3013 	ldrb	r3, [sp, #19]
30006560:	e2833001 	add	r3, r3, #1
30006564:	e5cd3013 	strb	r3, [sp, #19]
		resize_size=resize_size<<1;
30006568:	e59d300c 	ldr	r3, [sp, #12]
3000656c:	e1a03083 	lsl	r3, r3, #1
30006570:	e58d300c 	str	r3, [sp, #12]
	acoral_u8 level=0;	
	acoral_u32 num=1;	
	resize_size=BLOCK_SIZE;
	if(acoral_mem_ctrl->state==MEM_NO_ALLOC)
		return 0;
	while(resize_size<size&&level<acoral_mem_ctrl->level){
30006574:	e59d200c 	ldr	r2, [sp, #12]
30006578:	e59d3004 	ldr	r3, [sp, #4]
3000657c:	e1520003 	cmp	r2, r3
30006580:	2a000007 	bcs	300065a4 <buddy_malloc_size+0x90>
30006584:	e5dd2013 	ldrb	r2, [sp, #19]
30006588:	e59f3024 	ldr	r3, [pc, #36]	; 300065b4 <buddy_malloc_size+0xa0>
3000658c:	e5933000 	ldr	r3, [r3]
30006590:	e5d330e0 	ldrb	r3, [r3, #224]	; 0xe0
30006594:	e1a03c03 	lsl	r3, r3, #24
30006598:	e1a03c43 	asr	r3, r3, #24
3000659c:	e1520003 	cmp	r2, r3
300065a0:	baffffea 	blt	30006550 <buddy_malloc_size+0x3c>
		num=num<<1;
		level++;
		resize_size=resize_size<<1;
	}
	return resize_size;
300065a4:	e59d300c 	ldr	r3, [sp, #12]
}
300065a8:	e1a00003 	mov	r0, r3
300065ac:	e28dd018 	add	sp, sp, #24
300065b0:	e12fff1e 	bx	lr
300065b4:	3002b110 	.word	0x3002b110

300065b8 <buddy_malloc>:

void *buddy_malloc(acoral_u32 size){
300065b8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300065bc:	e24dd01c 	sub	sp, sp, #28
300065c0:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 resize_size;	
	acoral_u8 level=0;	
300065c4:	e3a03000 	mov	r3, #0
300065c8:	e5cd3013 	strb	r3, [sp, #19]
	acoral_u32 num=1;	
300065cc:	e3a03001 	mov	r3, #1
300065d0:	e58d3014 	str	r3, [sp, #20]
	resize_size=BLOCK_SIZE;
300065d4:	e3a03080 	mov	r3, #128	; 0x80
300065d8:	e58d300c 	str	r3, [sp, #12]
	if(acoral_mem_ctrl->state==MEM_NO_ALLOC)
300065dc:	e59f30b0 	ldr	r3, [pc, #176]	; 30006694 <buddy_malloc+0xdc>
300065e0:	e5933000 	ldr	r3, [r3]
300065e4:	e5d330e1 	ldrb	r3, [r3, #225]	; 0xe1
300065e8:	e3530000 	cmp	r3, #0
300065ec:	1a00000a 	bne	3000661c <buddy_malloc+0x64>
		return NULL;
300065f0:	e3a03000 	mov	r3, #0
300065f4:	ea000022 	b	30006684 <buddy_malloc+0xcc>
	while(resize_size<size){
		num=num<<1;
300065f8:	e59d3014 	ldr	r3, [sp, #20]
300065fc:	e1a03083 	lsl	r3, r3, #1
30006600:	e58d3014 	str	r3, [sp, #20]
		level++;
30006604:	e5dd3013 	ldrb	r3, [sp, #19]
30006608:	e2833001 	add	r3, r3, #1
3000660c:	e5cd3013 	strb	r3, [sp, #19]
		resize_size=resize_size<<1;
30006610:	e59d300c 	ldr	r3, [sp, #12]
30006614:	e1a03083 	lsl	r3, r3, #1
30006618:	e58d300c 	str	r3, [sp, #12]
	acoral_u8 level=0;	
	acoral_u32 num=1;	
	resize_size=BLOCK_SIZE;
	if(acoral_mem_ctrl->state==MEM_NO_ALLOC)
		return NULL;
	while(resize_size<size){
3000661c:	e59d200c 	ldr	r2, [sp, #12]
30006620:	e59d3004 	ldr	r3, [sp, #4]
30006624:	e1520003 	cmp	r2, r3
30006628:	3afffff2 	bcc	300065f8 <buddy_malloc+0x40>
		num=num<<1;
		level++;
		resize_size=resize_size<<1;
	}
	if(num>acoral_mem_ctrl->free_num)
3000662c:	e59f3060 	ldr	r3, [pc, #96]	; 30006694 <buddy_malloc+0xdc>
30006630:	e5933000 	ldr	r3, [r3]
30006634:	e59320f0 	ldr	r2, [r3, #240]	; 0xf0
30006638:	e59d3014 	ldr	r3, [sp, #20]
3000663c:	e1520003 	cmp	r2, r3
30006640:	2a000001 	bcs	3000664c <buddy_malloc+0x94>
		return NULL;
30006644:	e3a03000 	mov	r3, #0
30006648:	ea00000d 	b	30006684 <buddy_malloc+0xcc>
	if(level>=acoral_mem_ctrl->level)
3000664c:	e5dd2013 	ldrb	r2, [sp, #19]
30006650:	e59f303c 	ldr	r3, [pc, #60]	; 30006694 <buddy_malloc+0xdc>
30006654:	e5933000 	ldr	r3, [r3]
30006658:	e5d330e0 	ldrb	r3, [r3, #224]	; 0xe0
3000665c:	e1a03c03 	lsl	r3, r3, #24
30006660:	e1a03c43 	asr	r3, r3, #24
30006664:	e1520003 	cmp	r2, r3
30006668:	ba000001 	blt	30006674 <buddy_malloc+0xbc>
		return NULL;	
3000666c:	e3a03000 	mov	r3, #0
30006670:	ea000003 	b	30006684 <buddy_malloc+0xcc>
	return r_malloc(level);
30006674:	e5dd3013 	ldrb	r3, [sp, #19]
30006678:	e1a00003 	mov	r0, r3
3000667c:	ebfffecc 	bl	300061b4 <r_malloc>
30006680:	e1a03000 	mov	r3, r0
}
30006684:	e1a00003 	mov	r0, r3
30006688:	e28dd01c 	add	sp, sp, #28
3000668c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30006690:	e12fff1e 	bx	lr
30006694:	3002b110 	.word	0x3002b110

30006698 <buddy_free>:

void buddy_free(void *ptr){
30006698:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000669c:	e24dd02c 	sub	sp, sp, #44	; 0x2c
300066a0:	e58d0004 	str	r0, [sp, #4]
	acoral_32 cur;
	acoral_u32 index;
	acoral_u32 num;
	acoral_u32 max_level;
	acoral_u32 adr;
	adr=(acoral_u32)ptr;
300066a4:	e59d3004 	ldr	r3, [sp, #4]
300066a8:	e58d3024 	str	r3, [sp, #36]	; 0x24
	if(acoral_mem_ctrl->state==MEM_NO_ALLOC)
300066ac:	e59f348c 	ldr	r3, [pc, #1164]	; 30006b40 <buddy_free+0x4a8>
300066b0:	e5933000 	ldr	r3, [r3]
300066b4:	e5d330e1 	ldrb	r3, [r3, #225]	; 0xe1
300066b8:	e3530000 	cmp	r3, #0
300066bc:	0a00011b 	beq	30006b30 <buddy_free+0x498>
		return;
	if(ptr==NULL||adr<acoral_mem_ctrl->start_adr||adr+BLOCK_SIZE>acoral_mem_ctrl->end_adr){
300066c0:	e59d3004 	ldr	r3, [sp, #4]
300066c4:	e3530000 	cmp	r3, #0
300066c8:	0a00000c 	beq	30006700 <buddy_free+0x68>
300066cc:	e59f346c 	ldr	r3, [pc, #1132]	; 30006b40 <buddy_free+0x4a8>
300066d0:	e5933000 	ldr	r3, [r3]
300066d4:	e59320e4 	ldr	r2, [r3, #228]	; 0xe4
300066d8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300066dc:	e1520003 	cmp	r2, r3
300066e0:	8a000006 	bhi	30006700 <buddy_free+0x68>
300066e4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300066e8:	e2832080 	add	r2, r3, #128	; 0x80
300066ec:	e59f344c 	ldr	r3, [pc, #1100]	; 30006b40 <buddy_free+0x4a8>
300066f0:	e5933000 	ldr	r3, [r3]
300066f4:	e59330e8 	ldr	r3, [r3, #232]	; 0xe8
300066f8:	e1520003 	cmp	r2, r3
300066fc:	9a000003 	bls	30006710 <buddy_free+0x78>
		acoral_printerr("Invalid Free Address:0x%x\n",ptr);
30006700:	e59f043c 	ldr	r0, [pc, #1084]	; 30006b44 <buddy_free+0x4ac>
30006704:	e59d1004 	ldr	r1, [sp, #4]
30006708:	eb001346 	bl	3000b428 <acoral_print>
		return;
3000670c:	ea000108 	b	30006b34 <buddy_free+0x49c>
	}
	max_level=acoral_mem_ctrl->level;
30006710:	e59f3428 	ldr	r3, [pc, #1064]	; 30006b40 <buddy_free+0x4a8>
30006714:	e5933000 	ldr	r3, [r3]
30006718:	e5d330e0 	ldrb	r3, [r3, #224]	; 0xe0
3000671c:	e1a03c03 	lsl	r3, r3, #24
30006720:	e1a03c43 	asr	r3, r3, #24
30006724:	e58d3020 	str	r3, [sp, #32]
	num=(adr-acoral_mem_ctrl->start_adr)>>BLOCK_SHIFT;
30006728:	e59f3410 	ldr	r3, [pc, #1040]	; 30006b40 <buddy_free+0x4a8>
3000672c:	e5933000 	ldr	r3, [r3]
30006730:	e59330e4 	ldr	r3, [r3, #228]	; 0xe4
30006734:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30006738:	e0633002 	rsb	r3, r3, r2
3000673c:	e1a033a3 	lsr	r3, r3, #7
30006740:	e58d301c 	str	r3, [sp, #28]
	/*如果不是block整数倍，肯定是非法地址*/
	if(adr!=acoral_mem_ctrl->start_adr+(num<<BLOCK_SHIFT)){
30006744:	e59f33f4 	ldr	r3, [pc, #1012]	; 30006b40 <buddy_free+0x4a8>
30006748:	e5933000 	ldr	r3, [r3]
3000674c:	e59320e4 	ldr	r2, [r3, #228]	; 0xe4
30006750:	e59d301c 	ldr	r3, [sp, #28]
30006754:	e1a03383 	lsl	r3, r3, #7
30006758:	e0822003 	add	r2, r2, r3
3000675c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30006760:	e1520003 	cmp	r2, r3
30006764:	0a000003 	beq	30006778 <buddy_free+0xe0>
		acoral_printerr("Invalid Free Address:0x%x\n",ptr);
30006768:	e59f03d4 	ldr	r0, [pc, #980]	; 30006b44 <buddy_free+0x4ac>
3000676c:	e59d1004 	ldr	r1, [sp, #4]
30006770:	eb00132c 	bl	3000b428 <acoral_print>
		return;
30006774:	ea0000ee 	b	30006b34 <buddy_free+0x49c>
	}
	HAL_ENTER_CRITICAL();
30006778:	ebffebdd 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000677c:	e1a03000 	mov	r3, r0
30006780:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&acoral_mem_ctrl->lock);
	if(num&0x1){
30006784:	e59d301c 	ldr	r3, [sp, #28]
30006788:	e2033001 	and	r3, r3, #1
3000678c:	e20330ff 	and	r3, r3, #255	; 0xff
30006790:	e3530000 	cmp	r3, #0
30006794:	0a00003c 	beq	3000688c <buddy_free+0x1f4>
		level=0;
30006798:	e3a03000 	mov	r3, #0
3000679c:	e5cd3012 	strb	r3, [sp, #18]
		/*下面是地址检查*/
		index=num>>1;
300067a0:	e59d301c 	ldr	r3, [sp, #28]
300067a4:	e1a030a3 	lsr	r3, r3, #1
300067a8:	e58d3018 	str	r3, [sp, #24]
		buddy_level=acoral_mem_blocks[BLOCK_INDEX(num)].level;
300067ac:	e59f3394 	ldr	r3, [pc, #916]	; 30006b48 <buddy_free+0x4b0>
300067b0:	e5932000 	ldr	r2, [r3]
300067b4:	e59d301c 	ldr	r3, [sp, #28]
300067b8:	e1a030a3 	lsr	r3, r3, #1
300067bc:	e0823003 	add	r3, r2, r3
300067c0:	e5d33000 	ldrb	r3, [r3]
300067c4:	e5cd3013 	strb	r3, [sp, #19]
		if(buddy_level>0){
300067c8:	e1dd31d3 	ldrsb	r3, [sp, #19]
300067cc:	e3530000 	cmp	r3, #0
300067d0:	da000005 	ble	300067ec <buddy_free+0x154>
			acoral_printerr("Invalid Free Address:0x%x\n",ptr);
300067d4:	e59f0368 	ldr	r0, [pc, #872]	; 30006b44 <buddy_free+0x4ac>
300067d8:	e59d1004 	ldr	r1, [sp, #4]
300067dc:	eb001311 	bl	3000b428 <acoral_print>
			acoral_spin_unlock(&acoral_mem_ctrl->lock);
			HAL_EXIT_CRITICAL();
300067e0:	e59d000c 	ldr	r0, [sp, #12]
300067e4:	ebffebc0 	bl	300016ec <HAL_INTR_RESTORE>
			return;
300067e8:	ea0000d1 	b	30006b34 <buddy_free+0x49c>
		}
		/*伙伴分配出去，如果对应的位为1,肯定是回收过一次了*/
		if(buddy_level==0&&acoral_get_bit(index,acoral_mem_ctrl->bitmap[level])){
300067ec:	e1dd31d3 	ldrsb	r3, [sp, #19]
300067f0:	e3530000 	cmp	r3, #0
300067f4:	1a000010 	bne	3000683c <buddy_free+0x1a4>
300067f8:	e59f3340 	ldr	r3, [pc, #832]	; 30006b40 <buddy_free+0x4a8>
300067fc:	e5933000 	ldr	r3, [r3]
30006800:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006804:	e282200e 	add	r2, r2, #14
30006808:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3000680c:	e59d0018 	ldr	r0, [sp, #24]
30006810:	e1a01003 	mov	r1, r3
30006814:	eb000dc0 	bl	30009f1c <acoral_get_bit>
30006818:	e1a03000 	mov	r3, r0
3000681c:	e3530000 	cmp	r3, #0
30006820:	0a000005 	beq	3000683c <buddy_free+0x1a4>
			acoral_printerr("Address:0x%x have been freed\n",ptr);
30006824:	e59f0320 	ldr	r0, [pc, #800]	; 30006b4c <buddy_free+0x4b4>
30006828:	e59d1004 	ldr	r1, [sp, #4]
3000682c:	eb0012fd 	bl	3000b428 <acoral_print>
			acoral_spin_unlock(&acoral_mem_ctrl->lock);
			HAL_EXIT_CRITICAL();
30006830:	e59d000c 	ldr	r0, [sp, #12]
30006834:	ebffebac 	bl	300016ec <HAL_INTR_RESTORE>
			return;
30006838:	ea0000bd 	b	30006b34 <buddy_free+0x49c>
		}
		/*伙伴没有分配出去了，如果对应的位为0,肯定是回收过一次了*/
		if(buddy_level<0&&!acoral_get_bit(index,acoral_mem_ctrl->bitmap[level])){
3000683c:	e1dd31d3 	ldrsb	r3, [sp, #19]
30006840:	e3530000 	cmp	r3, #0
30006844:	aa000032 	bge	30006914 <buddy_free+0x27c>
30006848:	e59f32f0 	ldr	r3, [pc, #752]	; 30006b40 <buddy_free+0x4a8>
3000684c:	e5933000 	ldr	r3, [r3]
30006850:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006854:	e282200e 	add	r2, r2, #14
30006858:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3000685c:	e59d0018 	ldr	r0, [sp, #24]
30006860:	e1a01003 	mov	r1, r3
30006864:	eb000dac 	bl	30009f1c <acoral_get_bit>
30006868:	e1a03000 	mov	r3, r0
3000686c:	e3530000 	cmp	r3, #0
30006870:	1a000029 	bne	3000691c <buddy_free+0x284>
			acoral_printerr("Address:0x%x have been freed\n",ptr);
30006874:	e59f02d0 	ldr	r0, [pc, #720]	; 30006b4c <buddy_free+0x4b4>
30006878:	e59d1004 	ldr	r1, [sp, #4]
3000687c:	eb0012e9 	bl	3000b428 <acoral_print>
			acoral_spin_unlock(&acoral_mem_ctrl->lock);
			HAL_EXIT_CRITICAL();
30006880:	e59d000c 	ldr	r0, [sp, #12]
30006884:	ebffeb98 	bl	300016ec <HAL_INTR_RESTORE>
			return;
30006888:	ea0000a9 	b	30006b34 <buddy_free+0x49c>
		}
	}else{
		level=acoral_mem_blocks[BLOCK_INDEX(num)].level;
3000688c:	e59f32b4 	ldr	r3, [pc, #692]	; 30006b48 <buddy_free+0x4b0>
30006890:	e5932000 	ldr	r2, [r3]
30006894:	e59d301c 	ldr	r3, [sp, #28]
30006898:	e1a030a3 	lsr	r3, r3, #1
3000689c:	e0823003 	add	r3, r2, r3
300068a0:	e5d33000 	ldrb	r3, [r3]
300068a4:	e5cd3012 	strb	r3, [sp, #18]
		/*已经释放*/
		if(level<0){
300068a8:	e1dd31d2 	ldrsb	r3, [sp, #18]
300068ac:	e3530000 	cmp	r3, #0
300068b0:	aa000005 	bge	300068cc <buddy_free+0x234>
			acoral_printerr("Address:0x%x have been freed\n",ptr);
300068b4:	e59f0290 	ldr	r0, [pc, #656]	; 30006b4c <buddy_free+0x4b4>
300068b8:	e59d1004 	ldr	r1, [sp, #4]
300068bc:	eb0012d9 	bl	3000b428 <acoral_print>
			acoral_spin_unlock(&acoral_mem_ctrl->lock);
			HAL_EXIT_CRITICAL();
300068c0:	e59d000c 	ldr	r0, [sp, #12]
300068c4:	ebffeb88 	bl	300016ec <HAL_INTR_RESTORE>
			return;
300068c8:	ea000099 	b	30006b34 <buddy_free+0x49c>
		}	
		acoral_mem_ctrl->free_num+=1<<level;
300068cc:	e59f326c 	ldr	r3, [pc, #620]	; 30006b40 <buddy_free+0x4a8>
300068d0:	e5933000 	ldr	r3, [r3]
300068d4:	e59f2264 	ldr	r2, [pc, #612]	; 30006b40 <buddy_free+0x4a8>
300068d8:	e5922000 	ldr	r2, [r2]
300068dc:	e59210f0 	ldr	r1, [r2, #240]	; 0xf0
300068e0:	e1dd21d2 	ldrsb	r2, [sp, #18]
300068e4:	e3a00001 	mov	r0, #1
300068e8:	e1a02210 	lsl	r2, r0, r2
300068ec:	e0812002 	add	r2, r1, r2
300068f0:	e58320f0 	str	r2, [r3, #240]	; 0xf0
		acoral_mem_blocks[BLOCK_INDEX(num)].level=-1;
300068f4:	e59f324c 	ldr	r3, [pc, #588]	; 30006b48 <buddy_free+0x4b0>
300068f8:	e5932000 	ldr	r2, [r3]
300068fc:	e59d301c 	ldr	r3, [sp, #28]
30006900:	e1a030a3 	lsr	r3, r3, #1
30006904:	e0823003 	add	r3, r2, r3
30006908:	e3e02000 	mvn	r2, #0
3000690c:	e5c32000 	strb	r2, [r3]
30006910:	ea000002 	b	30006920 <buddy_free+0x288>
		/*伙伴没有分配出去了，如果对应的位为0,肯定是回收过一次了*/
		if(buddy_level<0&&!acoral_get_bit(index,acoral_mem_ctrl->bitmap[level])){
			acoral_printerr("Address:0x%x have been freed\n",ptr);
			acoral_spin_unlock(&acoral_mem_ctrl->lock);
			HAL_EXIT_CRITICAL();
			return;
30006914:	e1a00000 	nop			; (mov r0, r0)
30006918:	ea000000 	b	30006920 <buddy_free+0x288>
3000691c:	e1a00000 	nop			; (mov r0, r0)
		acoral_mem_blocks[BLOCK_INDEX(num)].level=-1;
	}
#ifdef CFG_TEST
	acoral_print("Free-level:%d,num:%d\n",level,num);
#endif
	if(level==max_level-1){
30006920:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006924:	e59d3020 	ldr	r3, [sp, #32]
30006928:	e2433001 	sub	r3, r3, #1
3000692c:	e1520003 	cmp	r2, r3
30006930:	1a00000e 	bne	30006970 <buddy_free+0x2d8>
		index=num>>level;
30006934:	e1dd31d2 	ldrsb	r3, [sp, #18]
30006938:	e59d201c 	ldr	r2, [sp, #28]
3000693c:	e1a03332 	lsr	r3, r2, r3
30006940:	e58d3018 	str	r3, [sp, #24]
		acoral_set_bit(index,acoral_mem_ctrl->bitmap[level]);
30006944:	e59f31f4 	ldr	r3, [pc, #500]	; 30006b40 <buddy_free+0x4a8>
30006948:	e5933000 	ldr	r3, [r3]
3000694c:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006950:	e282200e 	add	r2, r2, #14
30006954:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30006958:	e59d0018 	ldr	r0, [sp, #24]
3000695c:	e1a01003 	mov	r1, r3
30006960:	eb000d3c 	bl	30009e58 <acoral_set_bit>
		HAL_EXIT_CRITICAL();
30006964:	e59d000c 	ldr	r0, [sp, #12]
30006968:	ebffeb5f 	bl	300016ec <HAL_INTR_RESTORE>
		acoral_spin_unlock(&acoral_mem_ctrl->lock);
		return;
3000696c:	ea000070 	b	30006b34 <buddy_free+0x49c>
	}
	index=num>>1+level;
30006970:	e1dd31d2 	ldrsb	r3, [sp, #18]
30006974:	e2833001 	add	r3, r3, #1
30006978:	e59d201c 	ldr	r2, [sp, #28]
3000697c:	e1a03332 	lsr	r3, r2, r3
30006980:	e58d3018 	str	r3, [sp, #24]
	while(level<max_level){
30006984:	ea000060 	b	30006b0c <buddy_free+0x474>
		cur=index/32;
30006988:	e59d3018 	ldr	r3, [sp, #24]
3000698c:	e1a032a3 	lsr	r3, r3, #5
30006990:	e58d3014 	str	r3, [sp, #20]
		if(!acoral_get_bit(index,acoral_mem_ctrl->bitmap[level])){
30006994:	e59f31a4 	ldr	r3, [pc, #420]	; 30006b40 <buddy_free+0x4a8>
30006998:	e5933000 	ldr	r3, [r3]
3000699c:	e1dd21d2 	ldrsb	r2, [sp, #18]
300069a0:	e282200e 	add	r2, r2, #14
300069a4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300069a8:	e59d0018 	ldr	r0, [sp, #24]
300069ac:	e1a01003 	mov	r1, r3
300069b0:	eb000d59 	bl	30009f1c <acoral_get_bit>
300069b4:	e1a03000 	mov	r3, r0
300069b8:	e3530000 	cmp	r3, #0
300069bc:	1a00002a 	bne	30006a6c <buddy_free+0x3d4>
			acoral_set_bit(index,acoral_mem_ctrl->bitmap[level]);
300069c0:	e59f3178 	ldr	r3, [pc, #376]	; 30006b40 <buddy_free+0x4a8>
300069c4:	e5933000 	ldr	r3, [r3]
300069c8:	e1dd21d2 	ldrsb	r2, [sp, #18]
300069cc:	e282200e 	add	r2, r2, #14
300069d0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300069d4:	e59d0018 	ldr	r0, [sp, #24]
300069d8:	e1a01003 	mov	r1, r3
300069dc:	eb000d1d 	bl	30009e58 <acoral_set_bit>
			if(acoral_mem_ctrl->free_cur[level]<0||cur<acoral_mem_ctrl->free_cur[level]){
300069e0:	e59f3158 	ldr	r3, [pc, #344]	; 30006b40 <buddy_free+0x4a8>
300069e4:	e5933000 	ldr	r3, [r3]
300069e8:	e1dd21d2 	ldrsb	r2, [sp, #18]
300069ec:	e282201c 	add	r2, r2, #28
300069f0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300069f4:	e3530000 	cmp	r3, #0
300069f8:	ba000007 	blt	30006a1c <buddy_free+0x384>
300069fc:	e59f313c 	ldr	r3, [pc, #316]	; 30006b40 <buddy_free+0x4a8>
30006a00:	e5933000 	ldr	r3, [r3]
30006a04:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006a08:	e282201c 	add	r2, r2, #28
30006a0c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30006a10:	e59d3014 	ldr	r3, [sp, #20]
30006a14:	e1520003 	cmp	r2, r3
30006a18:	da000040 	ble	30006b20 <buddy_free+0x488>
				acoral_mem_ctrl->free_list[level][cur]=acoral_mem_ctrl->free_cur[level];	
30006a1c:	e59f311c 	ldr	r3, [pc, #284]	; 30006b40 <buddy_free+0x4a8>
30006a20:	e5933000 	ldr	r3, [r3]
30006a24:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006a28:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30006a2c:	e59d3014 	ldr	r3, [sp, #20]
30006a30:	e1a03103 	lsl	r3, r3, #2
30006a34:	e0823003 	add	r3, r2, r3
30006a38:	e59f2100 	ldr	r2, [pc, #256]	; 30006b40 <buddy_free+0x4a8>
30006a3c:	e5922000 	ldr	r2, [r2]
30006a40:	e1dd11d2 	ldrsb	r1, [sp, #18]
30006a44:	e281101c 	add	r1, r1, #28
30006a48:	e7922101 	ldr	r2, [r2, r1, lsl #2]
30006a4c:	e5832000 	str	r2, [r3]
				acoral_mem_ctrl->free_cur[level]=cur;	
30006a50:	e59f30e8 	ldr	r3, [pc, #232]	; 30006b40 <buddy_free+0x4a8>
30006a54:	e5933000 	ldr	r3, [r3]
30006a58:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006a5c:	e282201c 	add	r2, r2, #28
30006a60:	e59d1014 	ldr	r1, [sp, #20]
30006a64:	e7831102 	str	r1, [r3, r2, lsl #2]
			}
			break;
30006a68:	ea00002d 	b	30006b24 <buddy_free+0x48c>
		}
		/*有个伙伴是空闲的，向上级回收*/
		acoral_clear_bit(index,acoral_mem_ctrl->bitmap[level]);
30006a6c:	e59f30cc 	ldr	r3, [pc, #204]	; 30006b40 <buddy_free+0x4a8>
30006a70:	e5933000 	ldr	r3, [r3]
30006a74:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006a78:	e282200e 	add	r2, r2, #14
30006a7c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30006a80:	e59d0018 	ldr	r0, [sp, #24]
30006a84:	e1a01003 	mov	r1, r3
30006a88:	eb000d0a 	bl	30009eb8 <acoral_clear_bit>
		if(cur==acoral_mem_ctrl->free_cur[level])
30006a8c:	e59f30ac 	ldr	r3, [pc, #172]	; 30006b40 <buddy_free+0x4a8>
30006a90:	e5933000 	ldr	r3, [r3]
30006a94:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006a98:	e282201c 	add	r2, r2, #28
30006a9c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30006aa0:	e59d3014 	ldr	r3, [sp, #20]
30006aa4:	e1520003 	cmp	r2, r3
30006aa8:	1a00000c 	bne	30006ae0 <buddy_free+0x448>
			acoral_mem_ctrl->free_cur[level]=acoral_mem_ctrl->free_list[level][cur];	
30006aac:	e59f308c 	ldr	r3, [pc, #140]	; 30006b40 <buddy_free+0x4a8>
30006ab0:	e5933000 	ldr	r3, [r3]
30006ab4:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006ab8:	e59f1080 	ldr	r1, [pc, #128]	; 30006b40 <buddy_free+0x4a8>
30006abc:	e5911000 	ldr	r1, [r1]
30006ac0:	e1dd01d2 	ldrsb	r0, [sp, #18]
30006ac4:	e7910100 	ldr	r0, [r1, r0, lsl #2]
30006ac8:	e59d1014 	ldr	r1, [sp, #20]
30006acc:	e1a01101 	lsl	r1, r1, #2
30006ad0:	e0801001 	add	r1, r0, r1
30006ad4:	e5911000 	ldr	r1, [r1]
30006ad8:	e282201c 	add	r2, r2, #28
30006adc:	e7831102 	str	r1, [r3, r2, lsl #2]
		level++;
30006ae0:	e5dd3012 	ldrb	r3, [sp, #18]
30006ae4:	e2833001 	add	r3, r3, #1
30006ae8:	e5cd3012 	strb	r3, [sp, #18]
		if(level<max_level-1)
30006aec:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006af0:	e59d3020 	ldr	r3, [sp, #32]
30006af4:	e2433001 	sub	r3, r3, #1
30006af8:	e1520003 	cmp	r2, r3
30006afc:	2a000002 	bcs	30006b0c <buddy_free+0x474>
			index=index>>1;
30006b00:	e59d3018 	ldr	r3, [sp, #24]
30006b04:	e1a030a3 	lsr	r3, r3, #1
30006b08:	e58d3018 	str	r3, [sp, #24]
		HAL_EXIT_CRITICAL();
		acoral_spin_unlock(&acoral_mem_ctrl->lock);
		return;
	}
	index=num>>1+level;
	while(level<max_level){
30006b0c:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006b10:	e59d3020 	ldr	r3, [sp, #32]
30006b14:	e1520003 	cmp	r2, r3
30006b18:	3affff9a 	bcc	30006988 <buddy_free+0x2f0>
30006b1c:	ea000000 	b	30006b24 <buddy_free+0x48c>
			acoral_set_bit(index,acoral_mem_ctrl->bitmap[level]);
			if(acoral_mem_ctrl->free_cur[level]<0||cur<acoral_mem_ctrl->free_cur[level]){
				acoral_mem_ctrl->free_list[level][cur]=acoral_mem_ctrl->free_cur[level];	
				acoral_mem_ctrl->free_cur[level]=cur;	
			}
			break;
30006b20:	e1a00000 	nop			; (mov r0, r0)
			acoral_mem_ctrl->free_cur[level]=acoral_mem_ctrl->free_list[level][cur];	
		level++;
		if(level<max_level-1)
			index=index>>1;
	}
	HAL_EXIT_CRITICAL();
30006b24:	e59d000c 	ldr	r0, [sp, #12]
30006b28:	ebffeaef 	bl	300016ec <HAL_INTR_RESTORE>
30006b2c:	ea000000 	b	30006b34 <buddy_free+0x49c>
	acoral_u32 num;
	acoral_u32 max_level;
	acoral_u32 adr;
	adr=(acoral_u32)ptr;
	if(acoral_mem_ctrl->state==MEM_NO_ALLOC)
		return;
30006b30:	e1a00000 	nop			; (mov r0, r0)
	HAL_EXIT_CRITICAL();
	acoral_spin_unlock(&acoral_mem_ctrl->lock);
#ifdef CFG_TEST_MEM
	buddy_scan();
#endif
}
30006b34:	e28dd02c 	add	sp, sp, #44	; 0x2c
30006b38:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30006b3c:	e12fff1e 	bx	lr
30006b40:	3002b110 	.word	0x3002b110
30006b44:	300260a0 	.word	0x300260a0
30006b48:	3002a810 	.word	0x3002a810
30006b4c:	300260bc 	.word	0x300260bc

30006b50 <r_malloc>:
	acoral_u32 alloc_size;
#endif
	acoral_u8 mem_state;
}mem_ctrl;

static void *r_malloc(acoral_32 size){
30006b50:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30006b54:	e24dd01c 	sub	sp, sp, #28
30006b58:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 * tp;
	acoral_8 * ctp;
	acoral_u32 b_size;
	size=size+4;
30006b5c:	e59d3004 	ldr	r3, [sp, #4]
30006b60:	e2833004 	add	r3, r3, #4
30006b64:	e58d3004 	str	r3, [sp, #4]
	while(acoral_mutex_pend(&mem_ctrl.mutex, 0)!=MUTEX_SUCCED)
30006b68:	ea000000 	b	30006b70 <r_malloc+0x20>
		acoral_suspend_self();
30006b6c:	ebffef16 	bl	300027cc <acoral_suspend_self>
static void *r_malloc(acoral_32 size){
	acoral_u32 * tp;
	acoral_8 * ctp;
	acoral_u32 b_size;
	size=size+4;
	while(acoral_mutex_pend(&mem_ctrl.mutex, 0)!=MUTEX_SUCCED)
30006b70:	e59f0284 	ldr	r0, [pc, #644]	; 30006dfc <r_malloc+0x2ac>
30006b74:	e3a01000 	mov	r1, #0
30006b78:	ebfff921 	bl	30005004 <acoral_mutex_pend>
30006b7c:	e1a03000 	mov	r3, r0
30006b80:	e3530000 	cmp	r3, #0
30006b84:	1afffff8 	bne	30006b6c <r_malloc+0x1c>
#ifdef CFG_TEST
	mem_ctrl.alloc_size+=size;
	mem_ctrl.alloc_num++;
	acoral_print("In malloc:%d\n",size);
#endif
	tp=mem_ctrl.freep_p;
30006b88:	e59f326c 	ldr	r3, [pc, #620]	; 30006dfc <r_malloc+0x2ac>
30006b8c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
30006b90:	e58d300c 	str	r3, [sp, #12]
	ctp=(acoral_8 *)tp;
30006b94:	e59d300c 	ldr	r3, [sp, #12]
30006b98:	e58d3010 	str	r3, [sp, #16]
	while(ctp<mem_ctrl.top_p){
30006b9c:	ea00003f 	b	30006ca0 <r_malloc+0x150>
             b_size=BLOCK_SIZE(*tp);
30006ba0:	e59d300c 	ldr	r3, [sp, #12]
30006ba4:	e5933000 	ldr	r3, [r3]
30006ba8:	e1a03423 	lsr	r3, r3, #8
30006bac:	e58d3014 	str	r3, [sp, #20]
	     if(b_size==0){
30006bb0:	e59d3014 	ldr	r3, [sp, #20]
30006bb4:	e3530000 	cmp	r3, #0
30006bb8:	1a000006 	bne	30006bd8 <r_malloc+0x88>
			acoral_printerr("Err address is 0x%x,size should not be 0",tp);
30006bbc:	e59f023c 	ldr	r0, [pc, #572]	; 30006e00 <r_malloc+0x2b0>
30006bc0:	e59d100c 	ldr	r1, [sp, #12]
30006bc4:	eb001217 	bl	3000b428 <acoral_print>
			acoral_mutex_post(&mem_ctrl.mutex);
30006bc8:	e59f022c 	ldr	r0, [pc, #556]	; 30006dfc <r_malloc+0x2ac>
30006bcc:	ebfffa1e 	bl	3000544c <acoral_mutex_post>
			return NULL;
30006bd0:	e3a03000 	mov	r3, #0
30006bd4:	ea000084 	b	30006dec <r_malloc+0x29c>
	     }
	     if(BLOCK_USED(*tp)||b_size<size){
30006bd8:	e59d300c 	ldr	r3, [sp, #12]
30006bdc:	e5933000 	ldr	r3, [r3]
30006be0:	e2033001 	and	r3, r3, #1
30006be4:	e20330ff 	and	r3, r3, #255	; 0xff
30006be8:	e3530000 	cmp	r3, #0
30006bec:	1a000003 	bne	30006c00 <r_malloc+0xb0>
30006bf0:	e59d2004 	ldr	r2, [sp, #4]
30006bf4:	e59d3014 	ldr	r3, [sp, #20]
30006bf8:	e1520003 	cmp	r2, r3
30006bfc:	9a000006 	bls	30006c1c <r_malloc+0xcc>
        	ctp=ctp+b_size;
30006c00:	e59d2010 	ldr	r2, [sp, #16]
30006c04:	e59d3014 	ldr	r3, [sp, #20]
30006c08:	e0823003 	add	r3, r2, r3
30006c0c:	e58d3010 	str	r3, [sp, #16]
		tp=(acoral_u32 *)ctp;
30006c10:	e59d3010 	ldr	r3, [sp, #16]
30006c14:	e58d300c 	str	r3, [sp, #12]
	     if(b_size==0){
			acoral_printerr("Err address is 0x%x,size should not be 0",tp);
			acoral_mutex_post(&mem_ctrl.mutex);
			return NULL;
	     }
	     if(BLOCK_USED(*tp)||b_size<size){
30006c18:	ea000020 	b	30006ca0 <r_malloc+0x150>
        	ctp=ctp+b_size;
		tp=(acoral_u32 *)ctp;
	     }
	     else
	     {
		BLOCK_SET_USED(tp,size);
30006c1c:	e59d3004 	ldr	r3, [sp, #4]
30006c20:	e1a03403 	lsl	r3, r3, #8
30006c24:	e38330cd 	orr	r3, r3, #205	; 0xcd
30006c28:	e1a02003 	mov	r2, r3
30006c2c:	e59d300c 	ldr	r3, [sp, #12]
30006c30:	e5832000 	str	r2, [r3]
		ctp=ctp+size;
30006c34:	e59d3004 	ldr	r3, [sp, #4]
30006c38:	e59d2010 	ldr	r2, [sp, #16]
30006c3c:	e0823003 	add	r3, r2, r3
30006c40:	e58d3010 	str	r3, [sp, #16]
		tp=(acoral_u32 *)ctp;
30006c44:	e59d3010 	ldr	r3, [sp, #16]
30006c48:	e58d300c 	str	r3, [sp, #12]
		if(b_size-size>0)
30006c4c:	e59d2004 	ldr	r2, [sp, #4]
30006c50:	e59d3014 	ldr	r3, [sp, #20]
30006c54:	e1520003 	cmp	r2, r3
30006c58:	0a000006 	beq	30006c78 <r_malloc+0x128>
			BLOCK_SET_FREE(tp,b_size-size);
30006c5c:	e59d3004 	ldr	r3, [sp, #4]
30006c60:	e59d2014 	ldr	r2, [sp, #20]
30006c64:	e0633002 	rsb	r3, r3, r2
30006c68:	e1a03403 	lsl	r3, r3, #8
30006c6c:	e38320cc 	orr	r2, r3, #204	; 0xcc
30006c70:	e59d300c 	ldr	r3, [sp, #12]
30006c74:	e5832000 	str	r2, [r3]
		mem_ctrl.freep_p=tp;
30006c78:	e59f317c 	ldr	r3, [pc, #380]	; 30006dfc <r_malloc+0x2ac>
30006c7c:	e59d200c 	ldr	r2, [sp, #12]
30006c80:	e583202c 	str	r2, [r3, #44]	; 0x2c
#ifdef CFG_TEST_MEM2
		acoral_print("After malloc\n");
		v_mem_scan();
		acoral_print("...................\n");
#endif
		acoral_mutex_post(&mem_ctrl.mutex);
30006c84:	e59f0170 	ldr	r0, [pc, #368]	; 30006dfc <r_malloc+0x2ac>
30006c88:	ebfff9ef 	bl	3000544c <acoral_mutex_post>
	        return (void *)(ctp-size+4);	
30006c8c:	e59d3004 	ldr	r3, [sp, #4]
30006c90:	e2632004 	rsb	r2, r3, #4
30006c94:	e59d3010 	ldr	r3, [sp, #16]
30006c98:	e0823003 	add	r3, r2, r3
30006c9c:	ea000052 	b	30006dec <r_malloc+0x29c>
	mem_ctrl.alloc_num++;
	acoral_print("In malloc:%d\n",size);
#endif
	tp=mem_ctrl.freep_p;
	ctp=(acoral_8 *)tp;
	while(ctp<mem_ctrl.top_p){
30006ca0:	e59f3154 	ldr	r3, [pc, #340]	; 30006dfc <r_malloc+0x2ac>
30006ca4:	e5932024 	ldr	r2, [r3, #36]	; 0x24
30006ca8:	e59d3010 	ldr	r3, [sp, #16]
30006cac:	e1520003 	cmp	r2, r3
30006cb0:	8affffba 	bhi	30006ba0 <r_malloc+0x50>
#endif
		acoral_mutex_post(&mem_ctrl.mutex);
	        return (void *)(ctp-size+4);	
	     }
	}
    	ctp=mem_ctrl.down_p;
30006cb4:	e59f3140 	ldr	r3, [pc, #320]	; 30006dfc <r_malloc+0x2ac>
30006cb8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30006cbc:	e58d3010 	str	r3, [sp, #16]
	tp=(acoral_u32 *)ctp;
30006cc0:	e59d3010 	ldr	r3, [sp, #16]
30006cc4:	e58d300c 	str	r3, [sp, #12]
	while(tp<mem_ctrl.freep_p){
30006cc8:	ea00003f 	b	30006dcc <r_malloc+0x27c>
	     b_size=BLOCK_SIZE(*tp);
30006ccc:	e59d300c 	ldr	r3, [sp, #12]
30006cd0:	e5933000 	ldr	r3, [r3]
30006cd4:	e1a03423 	lsr	r3, r3, #8
30006cd8:	e58d3014 	str	r3, [sp, #20]
	     if(b_size==0){
30006cdc:	e59d3014 	ldr	r3, [sp, #20]
30006ce0:	e3530000 	cmp	r3, #0
30006ce4:	1a000006 	bne	30006d04 <r_malloc+0x1b4>
			acoral_printerr("Err address is 0x%x,size should not be 0",tp);
30006ce8:	e59f0110 	ldr	r0, [pc, #272]	; 30006e00 <r_malloc+0x2b0>
30006cec:	e59d100c 	ldr	r1, [sp, #12]
30006cf0:	eb0011cc 	bl	3000b428 <acoral_print>
			acoral_mutex_post(&mem_ctrl.mutex);
30006cf4:	e59f0100 	ldr	r0, [pc, #256]	; 30006dfc <r_malloc+0x2ac>
30006cf8:	ebfff9d3 	bl	3000544c <acoral_mutex_post>
			return NULL;
30006cfc:	e3a03000 	mov	r3, #0
30006d00:	ea000039 	b	30006dec <r_malloc+0x29c>
	     }
	     if(BLOCK_USED(*tp)||b_size<size){
30006d04:	e59d300c 	ldr	r3, [sp, #12]
30006d08:	e5933000 	ldr	r3, [r3]
30006d0c:	e2033001 	and	r3, r3, #1
30006d10:	e20330ff 	and	r3, r3, #255	; 0xff
30006d14:	e3530000 	cmp	r3, #0
30006d18:	1a000003 	bne	30006d2c <r_malloc+0x1dc>
30006d1c:	e59d2004 	ldr	r2, [sp, #4]
30006d20:	e59d3014 	ldr	r3, [sp, #20]
30006d24:	e1520003 	cmp	r2, r3
30006d28:	9a000006 	bls	30006d48 <r_malloc+0x1f8>
        	ctp=ctp+b_size;
30006d2c:	e59d2010 	ldr	r2, [sp, #16]
30006d30:	e59d3014 	ldr	r3, [sp, #20]
30006d34:	e0823003 	add	r3, r2, r3
30006d38:	e58d3010 	str	r3, [sp, #16]
		tp=(acoral_u32 *)ctp;
30006d3c:	e59d3010 	ldr	r3, [sp, #16]
30006d40:	e58d300c 	str	r3, [sp, #12]
	     if(b_size==0){
			acoral_printerr("Err address is 0x%x,size should not be 0",tp);
			acoral_mutex_post(&mem_ctrl.mutex);
			return NULL;
	     }
	     if(BLOCK_USED(*tp)||b_size<size){
30006d44:	ea000020 	b	30006dcc <r_malloc+0x27c>
        	ctp=ctp+b_size;
		tp=(acoral_u32 *)ctp;
	     }
	     else
	     {
		BLOCK_SET_USED(tp,size);
30006d48:	e59d3004 	ldr	r3, [sp, #4]
30006d4c:	e1a03403 	lsl	r3, r3, #8
30006d50:	e38330cd 	orr	r3, r3, #205	; 0xcd
30006d54:	e1a02003 	mov	r2, r3
30006d58:	e59d300c 	ldr	r3, [sp, #12]
30006d5c:	e5832000 	str	r2, [r3]
		ctp=ctp+size;
30006d60:	e59d3004 	ldr	r3, [sp, #4]
30006d64:	e59d2010 	ldr	r2, [sp, #16]
30006d68:	e0823003 	add	r3, r2, r3
30006d6c:	e58d3010 	str	r3, [sp, #16]
		tp=(acoral_u32 *)ctp;
30006d70:	e59d3010 	ldr	r3, [sp, #16]
30006d74:	e58d300c 	str	r3, [sp, #12]
		if(b_size-size>0)
30006d78:	e59d2004 	ldr	r2, [sp, #4]
30006d7c:	e59d3014 	ldr	r3, [sp, #20]
30006d80:	e1520003 	cmp	r2, r3
30006d84:	0a000006 	beq	30006da4 <r_malloc+0x254>
			BLOCK_SET_FREE(tp,b_size-size);
30006d88:	e59d3004 	ldr	r3, [sp, #4]
30006d8c:	e59d2014 	ldr	r2, [sp, #20]
30006d90:	e0633002 	rsb	r3, r3, r2
30006d94:	e1a03403 	lsl	r3, r3, #8
30006d98:	e38320cc 	orr	r2, r3, #204	; 0xcc
30006d9c:	e59d300c 	ldr	r3, [sp, #12]
30006da0:	e5832000 	str	r2, [r3]
		mem_ctrl.freep_p=tp;
30006da4:	e59f3050 	ldr	r3, [pc, #80]	; 30006dfc <r_malloc+0x2ac>
30006da8:	e59d200c 	ldr	r2, [sp, #12]
30006dac:	e583202c 	str	r2, [r3, #44]	; 0x2c
#ifdef CFG_TEST_MEM2
		acoral_print("After malloc\n");
		v_mem_scan();
		acoral_print("...................\n");
#endif
		acoral_mutex_post(&mem_ctrl.mutex);
30006db0:	e59f0044 	ldr	r0, [pc, #68]	; 30006dfc <r_malloc+0x2ac>
30006db4:	ebfff9a4 	bl	3000544c <acoral_mutex_post>
	        return (void *)(ctp-size+4);	
30006db8:	e59d3004 	ldr	r3, [sp, #4]
30006dbc:	e2632004 	rsb	r2, r3, #4
30006dc0:	e59d3010 	ldr	r3, [sp, #16]
30006dc4:	e0823003 	add	r3, r2, r3
30006dc8:	ea000007 	b	30006dec <r_malloc+0x29c>
	        return (void *)(ctp-size+4);	
	     }
	}
    	ctp=mem_ctrl.down_p;
	tp=(acoral_u32 *)ctp;
	while(tp<mem_ctrl.freep_p){
30006dcc:	e59f3028 	ldr	r3, [pc, #40]	; 30006dfc <r_malloc+0x2ac>
30006dd0:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
30006dd4:	e59d300c 	ldr	r3, [sp, #12]
30006dd8:	e1520003 	cmp	r2, r3
30006ddc:	8affffba 	bhi	30006ccc <r_malloc+0x17c>
	acoral_print("...................\n");
#endif
#ifdef CFG_TEST
	mem_ctrl.alloc_size-=size;
#endif
	acoral_mutex_post(&mem_ctrl.mutex);
30006de0:	e59f0014 	ldr	r0, [pc, #20]	; 30006dfc <r_malloc+0x2ac>
30006de4:	ebfff998 	bl	3000544c <acoral_mutex_post>
	return NULL;
30006de8:	e3a03000 	mov	r3, #0
}
30006dec:	e1a00003 	mov	r0, r3
30006df0:	e28dd01c 	add	sp, sp, #28
30006df4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30006df8:	e12fff1e 	bx	lr
30006dfc:	3002a6f0 	.word	0x3002a6f0
30006e00:	300260dc 	.word	0x300260dc

30006e04 <v_malloc>:

void * v_malloc(acoral_32 size){
30006e04:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30006e08:	e24dd00c 	sub	sp, sp, #12
30006e0c:	e58d0004 	str	r0, [sp, #4]
	if(mem_ctrl.mem_state==0)
30006e10:	e59f303c 	ldr	r3, [pc, #60]	; 30006e54 <v_malloc+0x50>
30006e14:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
30006e18:	e3530000 	cmp	r3, #0
30006e1c:	1a000001 	bne	30006e28 <v_malloc+0x24>
		return NULL;
30006e20:	e3a03000 	mov	r3, #0
30006e24:	ea000006 	b	30006e44 <v_malloc+0x40>
	size=(size+3)&~3;
30006e28:	e59d3004 	ldr	r3, [sp, #4]
30006e2c:	e2833003 	add	r3, r3, #3
30006e30:	e3c33003 	bic	r3, r3, #3
30006e34:	e58d3004 	str	r3, [sp, #4]
    return r_malloc(size);
30006e38:	e59d0004 	ldr	r0, [sp, #4]
30006e3c:	ebffff43 	bl	30006b50 <r_malloc>
30006e40:	e1a03000 	mov	r3, r0
}
30006e44:	e1a00003 	mov	r0, r3
30006e48:	e28dd00c 	add	sp, sp, #12
30006e4c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30006e50:	e12fff1e 	bx	lr
30006e54:	3002a6f0 	.word	0x3002a6f0

30006e58 <v_free>:

void v_free(void * p){
30006e58:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30006e5c:	e24dd024 	sub	sp, sp, #36	; 0x24
30006e60:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 * tp,*prev_tp;
	acoral_8 * ctp;
	acoral_u32 b_size,size;
	if(mem_ctrl.mem_state==0)
30006e64:	e59f327c 	ldr	r3, [pc, #636]	; 300070e8 <v_free+0x290>
30006e68:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
30006e6c:	e3530000 	cmp	r3, #0
30006e70:	0a000098 	beq	300070d8 <v_free+0x280>
		return;
	p=(acoral_8 *)p-4;
30006e74:	e59d3004 	ldr	r3, [sp, #4]
30006e78:	e2433004 	sub	r3, r3, #4
30006e7c:	e58d3004 	str	r3, [sp, #4]
	tp=(acoral_u32 *)p;
30006e80:	e59d3004 	ldr	r3, [sp, #4]
30006e84:	e58d300c 	str	r3, [sp, #12]
	while(acoral_mutex_pend(&mem_ctrl.mutex, 0)!=0) //周期性任务
30006e88:	ea000000 	b	30006e90 <v_free+0x38>
		acoral_suspend_self();
30006e8c:	ebffee4e 	bl	300027cc <acoral_suspend_self>
	acoral_u32 b_size,size;
	if(mem_ctrl.mem_state==0)
		return;
	p=(acoral_8 *)p-4;
	tp=(acoral_u32 *)p;
	while(acoral_mutex_pend(&mem_ctrl.mutex, 0)!=0) //周期性任务
30006e90:	e59f0250 	ldr	r0, [pc, #592]	; 300070e8 <v_free+0x290>
30006e94:	e3a01000 	mov	r1, #0
30006e98:	ebfff859 	bl	30005004 <acoral_mutex_pend>
30006e9c:	e1a03000 	mov	r3, r0
30006ea0:	e3530000 	cmp	r3, #0
30006ea4:	1afffff8 	bne	30006e8c <v_free+0x34>
		acoral_suspend_self();
	if(p==NULL||(acoral_8 *)p<mem_ctrl.down_p||(acoral_8 *)p>=mem_ctrl.top_p||!BLOCK_CHECK(*tp)){
30006ea8:	e59d3004 	ldr	r3, [sp, #4]
30006eac:	e3530000 	cmp	r3, #0
30006eb0:	0a00000e 	beq	30006ef0 <v_free+0x98>
30006eb4:	e59f322c 	ldr	r3, [pc, #556]	; 300070e8 <v_free+0x290>
30006eb8:	e5932028 	ldr	r2, [r3, #40]	; 0x28
30006ebc:	e59d3004 	ldr	r3, [sp, #4]
30006ec0:	e1520003 	cmp	r2, r3
30006ec4:	8a000009 	bhi	30006ef0 <v_free+0x98>
30006ec8:	e59f3218 	ldr	r3, [pc, #536]	; 300070e8 <v_free+0x290>
30006ecc:	e5932024 	ldr	r2, [r3, #36]	; 0x24
30006ed0:	e59d3004 	ldr	r3, [sp, #4]
30006ed4:	e1520003 	cmp	r2, r3
30006ed8:	9a000004 	bls	30006ef0 <v_free+0x98>
30006edc:	e59d300c 	ldr	r3, [sp, #12]
30006ee0:	e5933000 	ldr	r3, [r3]
30006ee4:	e20330fe 	and	r3, r3, #254	; 0xfe
30006ee8:	e35300cc 	cmp	r3, #204	; 0xcc
30006eec:	0a000003 	beq	30006f00 <v_free+0xa8>
		acoral_printerr("Invalide Free address:0x%x\n",tp);
30006ef0:	e59f01f4 	ldr	r0, [pc, #500]	; 300070ec <v_free+0x294>
30006ef4:	e59d100c 	ldr	r1, [sp, #12]
30006ef8:	eb00114a 	bl	3000b428 <acoral_print>
		return;
30006efc:	ea000076 	b	300070dc <v_free+0x284>
	}
	if(BLOCK_FREE(*tp)){
30006f00:	e59d300c 	ldr	r3, [sp, #12]
30006f04:	e5933000 	ldr	r3, [r3]
30006f08:	e2033001 	and	r3, r3, #1
30006f0c:	e3530000 	cmp	r3, #0
30006f10:	1a000003 	bne	30006f24 <v_free+0xcc>
		acoral_printerr("Address:0x%x have been freed\n",tp);
30006f14:	e59f01d4 	ldr	r0, [pc, #468]	; 300070f0 <v_free+0x298>
30006f18:	e59d100c 	ldr	r1, [sp, #12]
30006f1c:	eb001141 	bl	3000b428 <acoral_print>
		return;
30006f20:	ea00006d 	b	300070dc <v_free+0x284>
	}
	prev_tp=tp;
30006f24:	e59d300c 	ldr	r3, [sp, #12]
30006f28:	e58d3010 	str	r3, [sp, #16]
	ctp=(acoral_8 *)tp;
30006f2c:	e59d300c 	ldr	r3, [sp, #12]
30006f30:	e58d3014 	str	r3, [sp, #20]
    b_size=BLOCK_SIZE(*tp);
30006f34:	e59d300c 	ldr	r3, [sp, #12]
30006f38:	e5933000 	ldr	r3, [r3]
30006f3c:	e1a03423 	lsr	r3, r3, #8
30006f40:	e58d3018 	str	r3, [sp, #24]
#ifdef CFG_TEST_MEM2
	acoral_print("...................\n");
	acoral_print("Before free\n");
	v_mem_scan();
#endif
   	ctp=ctp+b_size;
30006f44:	e59d2014 	ldr	r2, [sp, #20]
30006f48:	e59d3018 	ldr	r3, [sp, #24]
30006f4c:	e0823003 	add	r3, r2, r3
30006f50:	e58d3014 	str	r3, [sp, #20]
	tp=(acoral_u32 *)ctp;
30006f54:	e59d3014 	ldr	r3, [sp, #20]
30006f58:	e58d300c 	str	r3, [sp, #12]
	if(BLOCK_FREE(*tp)){
30006f5c:	e59d300c 	ldr	r3, [sp, #12]
30006f60:	e5933000 	ldr	r3, [r3]
30006f64:	e2033001 	and	r3, r3, #1
30006f68:	e3530000 	cmp	r3, #0
30006f6c:	1a000013 	bne	30006fc0 <v_free+0x168>
		size=BLOCK_SIZE(*tp);
30006f70:	e59d300c 	ldr	r3, [sp, #12]
30006f74:	e5933000 	ldr	r3, [r3]
30006f78:	e1a03423 	lsr	r3, r3, #8
30006f7c:	e58d301c 	str	r3, [sp, #28]
		if(size==0){
30006f80:	e59d301c 	ldr	r3, [sp, #28]
30006f84:	e3530000 	cmp	r3, #0
30006f88:	1a000005 	bne	30006fa4 <v_free+0x14c>
			acoral_printerr("Err address is 0x%x,size should not be 0",tp);
30006f8c:	e59f0160 	ldr	r0, [pc, #352]	; 300070f4 <v_free+0x29c>
30006f90:	e59d100c 	ldr	r1, [sp, #12]
30006f94:	eb001123 	bl	3000b428 <acoral_print>
			acoral_mutex_post(&mem_ctrl.mutex);
30006f98:	e59f0148 	ldr	r0, [pc, #328]	; 300070e8 <v_free+0x290>
30006f9c:	ebfff92a 	bl	3000544c <acoral_mutex_post>
			return;
30006fa0:	ea00004d 	b	300070dc <v_free+0x284>
		}
		b_size+=size;
30006fa4:	e59d2018 	ldr	r2, [sp, #24]
30006fa8:	e59d301c 	ldr	r3, [sp, #28]
30006fac:	e0823003 	add	r3, r2, r3
30006fb0:	e58d3018 	str	r3, [sp, #24]
		BLOCK_CLEAR(tp);
30006fb4:	e59d300c 	ldr	r3, [sp, #12]
30006fb8:	e3a02000 	mov	r2, #0
30006fbc:	e5832000 	str	r2, [r3]
	}
	BLOCK_SET_FREE(prev_tp,b_size);
30006fc0:	e59d3018 	ldr	r3, [sp, #24]
30006fc4:	e1a03403 	lsl	r3, r3, #8
30006fc8:	e38320cc 	orr	r2, r3, #204	; 0xcc
30006fcc:	e59d3010 	ldr	r3, [sp, #16]
30006fd0:	e5832000 	str	r2, [r3]
	mem_ctrl.freep_p=prev_tp;
30006fd4:	e59f310c 	ldr	r3, [pc, #268]	; 300070e8 <v_free+0x290>
30006fd8:	e59d2010 	ldr	r2, [sp, #16]
30006fdc:	e583202c 	str	r2, [r3, #44]	; 0x2c
	if(p==mem_ctrl.down_p){
30006fe0:	e59f3100 	ldr	r3, [pc, #256]	; 300070e8 <v_free+0x290>
30006fe4:	e5932028 	ldr	r2, [r3, #40]	; 0x28
30006fe8:	e59d3004 	ldr	r3, [sp, #4]
30006fec:	e1520003 	cmp	r2, r3
30006ff0:	1a000002 	bne	30007000 <v_free+0x1a8>
#ifdef CFG_TEST_MEM2
		acoral_print("After free\n");
		v_mem_scan();
		acoral_print("...................\n");
#endif
		acoral_mutex_post(&mem_ctrl.mutex);
30006ff4:	e59f00ec 	ldr	r0, [pc, #236]	; 300070e8 <v_free+0x290>
30006ff8:	ebfff913 	bl	3000544c <acoral_mutex_post>
		return;
30006ffc:	ea000036 	b	300070dc <v_free+0x284>
	}
	ctp=mem_ctrl.down_p;
30007000:	e59f30e0 	ldr	r3, [pc, #224]	; 300070e8 <v_free+0x290>
30007004:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30007008:	e58d3014 	str	r3, [sp, #20]
	tp=(acoral_u32 *)ctp;
3000700c:	e59d3014 	ldr	r3, [sp, #20]
30007010:	e58d300c 	str	r3, [sp, #12]
	while(ctp<(acoral_8 *)p){
30007014:	ea000014 	b	3000706c <v_free+0x214>
	     size=BLOCK_SIZE(*tp);
30007018:	e59d300c 	ldr	r3, [sp, #12]
3000701c:	e5933000 	ldr	r3, [r3]
30007020:	e1a03423 	lsr	r3, r3, #8
30007024:	e58d301c 	str	r3, [sp, #28]
	     if(size==0){
30007028:	e59d301c 	ldr	r3, [sp, #28]
3000702c:	e3530000 	cmp	r3, #0
30007030:	1a000005 	bne	3000704c <v_free+0x1f4>
			acoral_printerr("err address is 0x%x,size should not be 0",tp);
30007034:	e59f00bc 	ldr	r0, [pc, #188]	; 300070f8 <v_free+0x2a0>
30007038:	e59d100c 	ldr	r1, [sp, #12]
3000703c:	eb0010f9 	bl	3000b428 <acoral_print>
			acoral_mutex_post(&mem_ctrl.mutex);
30007040:	e59f00a0 	ldr	r0, [pc, #160]	; 300070e8 <v_free+0x290>
30007044:	ebfff900 	bl	3000544c <acoral_mutex_post>
			return;
30007048:	ea000023 	b	300070dc <v_free+0x284>
             }
	     ctp=ctp+size;
3000704c:	e59d2014 	ldr	r2, [sp, #20]
30007050:	e59d301c 	ldr	r3, [sp, #28]
30007054:	e0823003 	add	r3, r2, r3
30007058:	e58d3014 	str	r3, [sp, #20]
	     prev_tp=tp;
3000705c:	e59d300c 	ldr	r3, [sp, #12]
30007060:	e58d3010 	str	r3, [sp, #16]
	     tp=(acoral_u32 *)ctp;
30007064:	e59d3014 	ldr	r3, [sp, #20]
30007068:	e58d300c 	str	r3, [sp, #12]
		acoral_mutex_post(&mem_ctrl.mutex);
		return;
	}
	ctp=mem_ctrl.down_p;
	tp=(acoral_u32 *)ctp;
	while(ctp<(acoral_8 *)p){
3000706c:	e59d3004 	ldr	r3, [sp, #4]
30007070:	e59d2014 	ldr	r2, [sp, #20]
30007074:	e1520003 	cmp	r2, r3
30007078:	3affffe6 	bcc	30007018 <v_free+0x1c0>
             }
	     ctp=ctp+size;
	     prev_tp=tp;
	     tp=(acoral_u32 *)ctp;
	}
	if(BLOCK_FREE(*prev_tp)){
3000707c:	e59d3010 	ldr	r3, [sp, #16]
30007080:	e5933000 	ldr	r3, [r3]
30007084:	e2033001 	and	r3, r3, #1
30007088:	e3530000 	cmp	r3, #0
3000708c:	1a00000e 	bne	300070cc <v_free+0x274>
		tp=(acoral_u32*)p;
30007090:	e59d3004 	ldr	r3, [sp, #4]
30007094:	e58d300c 	str	r3, [sp, #12]
		BLOCK_CLEAR(tp);
30007098:	e59d300c 	ldr	r3, [sp, #12]
3000709c:	e3a02000 	mov	r2, #0
300070a0:	e5832000 	str	r2, [r3]
		BLOCK_SET_FREE(prev_tp,b_size+size);
300070a4:	e59d2018 	ldr	r2, [sp, #24]
300070a8:	e59d301c 	ldr	r3, [sp, #28]
300070ac:	e0823003 	add	r3, r2, r3
300070b0:	e1a03403 	lsl	r3, r3, #8
300070b4:	e38320cc 	orr	r2, r3, #204	; 0xcc
300070b8:	e59d3010 	ldr	r3, [sp, #16]
300070bc:	e5832000 	str	r2, [r3]
		mem_ctrl.freep_p=prev_tp;
300070c0:	e59f3020 	ldr	r3, [pc, #32]	; 300070e8 <v_free+0x290>
300070c4:	e59d2010 	ldr	r2, [sp, #16]
300070c8:	e583202c 	str	r2, [r3, #44]	; 0x2c
#ifdef CFG_TEST_MEM2
	acoral_print("After free\n");
	v_mem_scan();
	acoral_print("...................\n");
#endif
	acoral_mutex_post(&mem_ctrl.mutex);
300070cc:	e59f0014 	ldr	r0, [pc, #20]	; 300070e8 <v_free+0x290>
300070d0:	ebfff8dd 	bl	3000544c <acoral_mutex_post>
300070d4:	ea000000 	b	300070dc <v_free+0x284>
void v_free(void * p){
	acoral_u32 * tp,*prev_tp;
	acoral_8 * ctp;
	acoral_u32 b_size,size;
	if(mem_ctrl.mem_state==0)
		return;
300070d8:	e1a00000 	nop			; (mov r0, r0)
	acoral_print("After free\n");
	v_mem_scan();
	acoral_print("...................\n");
#endif
	acoral_mutex_post(&mem_ctrl.mutex);
}
300070dc:	e28dd024 	add	sp, sp, #36	; 0x24
300070e0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300070e4:	e12fff1e 	bx	lr
300070e8:	3002a6f0 	.word	0x3002a6f0
300070ec:	30026108 	.word	0x30026108
300070f0:	30026124 	.word	0x30026124
300070f4:	300260dc 	.word	0x300260dc
300070f8:	30026144 	.word	0x30026144

300070fc <v_mem_init>:

void v_mem_init(){
300070fc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007100:	e24dd00c 	sub	sp, sp, #12
	acoral_size size;
	size=acoral_malloc_size(MEM_SIZE);
30007104:	e3a00afa 	mov	r0, #1024000	; 0xfa000
30007108:	ebfffd01 	bl	30006514 <buddy_malloc_size>
3000710c:	e1a03000 	mov	r3, r0
30007110:	e58d3004 	str	r3, [sp, #4]
	mem_ctrl.down_p=(acoral_8 *)acoral_malloc(size);
30007114:	e59d0004 	ldr	r0, [sp, #4]
30007118:	ebfffd26 	bl	300065b8 <buddy_malloc>
3000711c:	e1a03000 	mov	r3, r0
30007120:	e1a02003 	mov	r2, r3
30007124:	e59f3088 	ldr	r3, [pc, #136]	; 300071b4 <v_mem_init+0xb8>
30007128:	e5832028 	str	r2, [r3, #40]	; 0x28
	if(mem_ctrl.down_p==NULL){
3000712c:	e59f3080 	ldr	r3, [pc, #128]	; 300071b4 <v_mem_init+0xb8>
30007130:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30007134:	e3530000 	cmp	r3, #0
30007138:	1a000003 	bne	3000714c <v_mem_init+0x50>
		mem_ctrl.mem_state=0;
3000713c:	e59f3070 	ldr	r3, [pc, #112]	; 300071b4 <v_mem_init+0xb8>
30007140:	e3a02000 	mov	r2, #0
30007144:	e5c32030 	strb	r2, [r3, #48]	; 0x30
		return;
30007148:	ea000016 	b	300071a8 <v_mem_init+0xac>
	}
	else{
		mem_ctrl.mem_state=1;
3000714c:	e59f3060 	ldr	r3, [pc, #96]	; 300071b4 <v_mem_init+0xb8>
30007150:	e3a02001 	mov	r2, #1
30007154:	e5c32030 	strb	r2, [r3, #48]	; 0x30
	}
	acoral_mutex_init(&mem_ctrl.mutex,0);
30007158:	e59f0054 	ldr	r0, [pc, #84]	; 300071b4 <v_mem_init+0xb8>
3000715c:	e3a01000 	mov	r1, #0
30007160:	ebfff70f 	bl	30004da4 <acoral_mutex_init>
	mem_ctrl.top_p=mem_ctrl.down_p+size;
30007164:	e59f3048 	ldr	r3, [pc, #72]	; 300071b4 <v_mem_init+0xb8>
30007168:	e5932028 	ldr	r2, [r3, #40]	; 0x28
3000716c:	e59d3004 	ldr	r3, [sp, #4]
30007170:	e0822003 	add	r2, r2, r3
30007174:	e59f3038 	ldr	r3, [pc, #56]	; 300071b4 <v_mem_init+0xb8>
30007178:	e5832024 	str	r2, [r3, #36]	; 0x24
	mem_ctrl.freep_p=(acoral_u32 *)mem_ctrl.down_p;
3000717c:	e59f3030 	ldr	r3, [pc, #48]	; 300071b4 <v_mem_init+0xb8>
30007180:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30007184:	e1a02003 	mov	r2, r3
30007188:	e59f3024 	ldr	r3, [pc, #36]	; 300071b4 <v_mem_init+0xb8>
3000718c:	e583202c 	str	r2, [r3, #44]	; 0x2c
	BLOCK_SET_FREE(mem_ctrl.freep_p,size);
30007190:	e59f301c 	ldr	r3, [pc, #28]	; 300071b4 <v_mem_init+0xb8>
30007194:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
30007198:	e59d2004 	ldr	r2, [sp, #4]
3000719c:	e1a02402 	lsl	r2, r2, #8
300071a0:	e38220cc 	orr	r2, r2, #204	; 0xcc
300071a4:	e5832000 	str	r2, [r3]
#ifdef CFG_TEST
	mem_ctrl.alloc_size=0;
	mem_ctrl.alloc_num=0;
	mem_ctrl.free_num=0;
#endif
}
300071a8:	e28dd00c 	add	sp, sp, #12
300071ac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300071b0:	e12fff1e 	bx	lr
300071b4:	3002a6f0 	.word	0x3002a6f0

300071b8 <v_mem_scan>:

void v_mem_scan(void){
300071b8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300071bc:	e24dd014 	sub	sp, sp, #20
        acoral_8 * ctp;
	acoral_u32 * tp;
	acoral_u32 size;
	if(mem_ctrl.mem_state==0){
300071c0:	e59f30c0 	ldr	r3, [pc, #192]	; 30007288 <v_mem_scan+0xd0>
300071c4:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
300071c8:	e3530000 	cmp	r3, #0
300071cc:	1a000002 	bne	300071dc <v_mem_scan+0x24>
		acoral_print("Mem Init Err ,so no mem space to malloc\r\n");
300071d0:	e59f00b4 	ldr	r0, [pc, #180]	; 3000728c <v_mem_scan+0xd4>
300071d4:	eb001093 	bl	3000b428 <acoral_print>
		return;
300071d8:	ea000027 	b	3000727c <v_mem_scan+0xc4>
	}
	ctp=mem_ctrl.down_p;
300071dc:	e59f30a4 	ldr	r3, [pc, #164]	; 30007288 <v_mem_scan+0xd0>
300071e0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
300071e4:	e58d3004 	str	r3, [sp, #4]
	do{
		tp=(acoral_u32 *)ctp;
300071e8:	e59d3004 	ldr	r3, [sp, #4]
300071ec:	e58d3008 	str	r3, [sp, #8]
		size=BLOCK_SIZE(*tp);
300071f0:	e59d3008 	ldr	r3, [sp, #8]
300071f4:	e5933000 	ldr	r3, [r3]
300071f8:	e1a03423 	lsr	r3, r3, #8
300071fc:	e58d300c 	str	r3, [sp, #12]
		if(size==0){
30007200:	e59d300c 	ldr	r3, [sp, #12]
30007204:	e3530000 	cmp	r3, #0
30007208:	1a000003 	bne	3000721c <v_mem_scan+0x64>
			acoral_print("Err address is 0x%x,size should not be 0\r\n",tp);
3000720c:	e59f007c 	ldr	r0, [pc, #124]	; 30007290 <v_mem_scan+0xd8>
30007210:	e59d1008 	ldr	r1, [sp, #8]
30007214:	eb001083 	bl	3000b428 <acoral_print>
			break;
30007218:	ea000017 	b	3000727c <v_mem_scan+0xc4>
		}
		if(BLOCK_USED(*tp)){
3000721c:	e59d3008 	ldr	r3, [sp, #8]
30007220:	e5933000 	ldr	r3, [r3]
30007224:	e2033001 	and	r3, r3, #1
30007228:	e20330ff 	and	r3, r3, #255	; 0xff
3000722c:	e3530000 	cmp	r3, #0
30007230:	0a000004 	beq	30007248 <v_mem_scan+0x90>
			acoral_print("The address is 0x%x,the block is used and it's size is %d\r\n",tp,size);
30007234:	e59f0058 	ldr	r0, [pc, #88]	; 30007294 <v_mem_scan+0xdc>
30007238:	e59d1008 	ldr	r1, [sp, #8]
3000723c:	e59d200c 	ldr	r2, [sp, #12]
30007240:	eb001078 	bl	3000b428 <acoral_print>
30007244:	ea000003 	b	30007258 <v_mem_scan+0xa0>
		}
		else{
			
			acoral_print("The address is 0x%x,the block is unused and it's size is %d\r\n",tp,size);
30007248:	e59f0048 	ldr	r0, [pc, #72]	; 30007298 <v_mem_scan+0xe0>
3000724c:	e59d1008 	ldr	r1, [sp, #8]
30007250:	e59d200c 	ldr	r2, [sp, #12]
30007254:	eb001073 	bl	3000b428 <acoral_print>
		}
		ctp=ctp+size;
30007258:	e59d2004 	ldr	r2, [sp, #4]
3000725c:	e59d300c 	ldr	r3, [sp, #12]
30007260:	e0823003 	add	r3, r2, r3
30007264:	e58d3004 	str	r3, [sp, #4]
	}while(ctp<mem_ctrl.top_p);
30007268:	e59f3018 	ldr	r3, [pc, #24]	; 30007288 <v_mem_scan+0xd0>
3000726c:	e5932024 	ldr	r2, [r3, #36]	; 0x24
30007270:	e59d3004 	ldr	r3, [sp, #4]
30007274:	e1520003 	cmp	r2, r3
30007278:	8affffda 	bhi	300071e8 <v_mem_scan+0x30>
#ifdef CFG_TEST
	acoral_print("Alloc Size:%d  Free_num:%d  alloc_num:%d\r\n",mem_ctrl.alloc_size,mem_ctrl.free_num,mem_ctrl.alloc_num);
#endif
}
3000727c:	e28dd014 	add	sp, sp, #20
30007280:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007284:	e12fff1e 	bx	lr
30007288:	3002a6f0 	.word	0x3002a6f0
3000728c:	30026170 	.word	0x30026170
30007290:	3002619c 	.word	0x3002619c
30007294:	300261c8 	.word	0x300261c8
30007298:	30026204 	.word	0x30026204

3000729c <acoral_mbox_create>:
/*====================================
 *     create a mailbox
 *       创建一个邮箱
 *====================================*/
acoral_evt_t *acoral_mbox_create()
{
3000729c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300072a0:	e24dd00c 	sub	sp, sp, #12
  	acoral_evt_t * event;
	
	event=acoral_alloc_evt();
300072a4:	ebfff64a 	bl	30004bd4 <acoral_alloc_evt>
300072a8:	e1a03000 	mov	r3, r0
300072ac:	e58d3004 	str	r3, [sp, #4]
	if (NULL == event)
300072b0:	e59d3004 	ldr	r3, [sp, #4]
300072b4:	e3530000 	cmp	r3, #0
300072b8:	1a000001 	bne	300072c4 <acoral_mbox_create+0x28>
		return NULL;
300072bc:	e3a03000 	mov	r3, #0
300072c0:	ea00000b 	b	300072f4 <acoral_mbox_create+0x58>

	event->type  = ACORAL_EVENT_MBOX;
300072c4:	e59d3004 	ldr	r3, [sp, #4]
300072c8:	e3a02003 	mov	r2, #3
300072cc:	e5c32004 	strb	r2, [r3, #4]
	event->count = 0x00000000;
300072d0:	e59d3004 	ldr	r3, [sp, #4]
300072d4:	e3a02000 	mov	r2, #0
300072d8:	e583200c 	str	r2, [r3, #12]
	event->data  = NULL;
300072dc:	e59d3004 	ldr	r3, [sp, #4]
300072e0:	e3a02000 	mov	r2, #0
300072e4:	e5832020 	str	r2, [r3, #32]
	acoral_evt_init(event);
300072e8:	e59d0004 	ldr	r0, [sp, #4]
300072ec:	ebfff640 	bl	30004bf4 <acoral_evt_init>
	return event;
300072f0:	e59d3004 	ldr	r3, [sp, #4]
}
300072f4:	e1a00003 	mov	r0, r3
300072f8:	e28dd00c 	add	sp, sp, #12
300072fc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007300:	e12fff1e 	bx	lr

30007304 <acoral_mbox_del>:
/*=====================================
 *   delete a mailbox
 *     删除一个邮箱
 *=====================================*/
acoral_u32 acoral_mbox_del(acoral_evt_t* event)
{
30007304:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007308:	e24dd00c 	sub	sp, sp, #12
3000730c:	e58d0004 	str	r0, [sp, #4]
	if (acoral_intr_nesting > 0)
30007310:	ebffe912 	bl	30001760 <hal_get_intr_nesting_comm>
30007314:	e1a03000 	mov	r3, r0
30007318:	e3530000 	cmp	r3, #0
3000731c:	da000001 	ble	30007328 <acoral_mbox_del+0x24>
		return MBOX_ERR_INTR;
30007320:	e3a03006 	mov	r3, #6
30007324:	ea00000e 	b	30007364 <acoral_mbox_del+0x60>
	
	if (NULL == event)
30007328:	e59d3004 	ldr	r3, [sp, #4]
3000732c:	e3530000 	cmp	r3, #0
30007330:	1a000001 	bne	3000733c <acoral_mbox_del+0x38>
		return MBOX_ERR_NULL;
30007334:	e3a03002 	mov	r3, #2
30007338:	ea000009 	b	30007364 <acoral_mbox_del+0x60>

	if(event->type != ACORAL_EVENT_MBOX)
3000733c:	e59d3004 	ldr	r3, [sp, #4]
30007340:	e5d33004 	ldrb	r3, [r3, #4]
30007344:	e3530003 	cmp	r3, #3
30007348:	0a000001 	beq	30007354 <acoral_mbox_del+0x50>
		return MBOX_ERR_TYPE;
3000734c:	e3a03004 	mov	r3, #4
30007350:	ea000003 	b	30007364 <acoral_mbox_del+0x60>

	acoral_release_thread((acoral_res_t *)event); 
30007354:	e59d3004 	ldr	r3, [sp, #4]
30007358:	e1a00003 	mov	r0, r3
3000735c:	ebffecf0 	bl	30002724 <acoral_release_thread>
	return MBOX_SUCCED;
30007360:	e3a03000 	mov	r3, #0
}
30007364:	e1a00003 	mov	r0, r3
30007368:	e28dd00c 	add	sp, sp, #12
3000736c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007370:	e12fff1e 	bx	lr

30007374 <acoral_mbox_send>:
/*======================================
 *     send a mail to mailbox
 *       发送邮件至邮箱
 *======================================*/
acoral_u32 acoral_mbox_send(acoral_evt_t * event, void *msg)
{
30007374:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007378:	e24dd014 	sub	sp, sp, #20
3000737c:	e58d0004 	str	r0, [sp, #4]
30007380:	e58d1000 	str	r1, [sp]
	acoral_thread_t     *thread;

	/*if (acoral_intr_nesting > 0)
		return MBOX_ERR_INTR;
	*/
	if (NULL == event)
30007384:	e59d3004 	ldr	r3, [sp, #4]
30007388:	e3530000 	cmp	r3, #0
3000738c:	1a000001 	bne	30007398 <acoral_mbox_send+0x24>
		return MBOX_ERR_NULL;
30007390:	e3a03002 	mov	r3, #2
30007394:	ea000028 	b	3000743c <acoral_mbox_send+0xc8>

	if(event->type != ACORAL_EVENT_MBOX)
30007398:	e59d3004 	ldr	r3, [sp, #4]
3000739c:	e5d33004 	ldrb	r3, [r3, #4]
300073a0:	e3530003 	cmp	r3, #3
300073a4:	0a000001 	beq	300073b0 <acoral_mbox_send+0x3c>
		return MBOX_ERR_TYPE;
300073a8:	e3a03004 	mov	r3, #4
300073ac:	ea000022 	b	3000743c <acoral_mbox_send+0xc8>

	HAL_ENTER_CRITICAL();
300073b0:	ebffe8cf 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300073b4:	e1a03000 	mov	r3, r0
300073b8:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&event->spin_lock);
	if(event->data != NULL)
300073bc:	e59d3004 	ldr	r3, [sp, #4]
300073c0:	e5933020 	ldr	r3, [r3, #32]
300073c4:	e3530000 	cmp	r3, #0
300073c8:	0a000003 	beq	300073dc <acoral_mbox_send+0x68>
	{
		acoral_spin_unlock(&event->spin_lock);
		HAL_EXIT_CRITICAL();
300073cc:	e59d0008 	ldr	r0, [sp, #8]
300073d0:	ebffe8c5 	bl	300016ec <HAL_INTR_RESTORE>
		return MBOX_ERR_MES_EXIST;
300073d4:	e3a03005 	mov	r3, #5
300073d8:	ea000017 	b	3000743c <acoral_mbox_send+0xc8>
	}
	event->data = msg;
300073dc:	e59d3004 	ldr	r3, [sp, #4]
300073e0:	e59d2000 	ldr	r2, [sp]
300073e4:	e5832020 	str	r2, [r3, #32]
	thread =acoral_evt_high_thread(event);
300073e8:	e59d0004 	ldr	r0, [sp, #4]
300073ec:	ebfff61a 	bl	30004c5c <acoral_evt_high_thread>
300073f0:	e1a03000 	mov	r3, r0
300073f4:	e58d300c 	str	r3, [sp, #12]
	/* 释放等待进程*/
	if (thread==NULL)
300073f8:	e59d300c 	ldr	r3, [sp, #12]
300073fc:	e3530000 	cmp	r3, #0
30007400:	1a000003 	bne	30007414 <acoral_mbox_send+0xa0>
	{
		/* 没有等待队列*/
		acoral_spin_unlock(&event->spin_lock);
		HAL_EXIT_CRITICAL();
30007404:	e59d0008 	ldr	r0, [sp, #8]
30007408:	ebffe8b7 	bl	300016ec <HAL_INTR_RESTORE>
		return  MBOX_SUCCED;
3000740c:	e3a03000 	mov	r3, #0
30007410:	ea000009 	b	3000743c <acoral_mbox_send+0xc8>
	}
	/*释放等待任务*/
	timeout_queue_del(thread);
30007414:	e59d000c 	ldr	r0, [sp, #12]
30007418:	ebfff53a 	bl	30004908 <timeout_queue_del>
	acoral_evt_queue_del(thread);
3000741c:	e59d000c 	ldr	r0, [sp, #12]
30007420:	ebfff652 	bl	30004d70 <acoral_evt_queue_del>
	acoral_rdy_thread(thread);
30007424:	e59d000c 	ldr	r0, [sp, #12]
30007428:	ebffedd0 	bl	30002b70 <acoral_rdy_thread>
	acoral_spin_unlock(&event->spin_lock);
	HAL_EXIT_CRITICAL();
3000742c:	e59d0008 	ldr	r0, [sp, #8]
30007430:	ebffe8ad 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sched();
30007434:	ebffebf5 	bl	30002410 <acoral_sched>
	return MBOX_SUCCED;
30007438:	e3a03000 	mov	r3, #0
}
3000743c:	e1a00003 	mov	r0, r3
30007440:	e28dd014 	add	sp, sp, #20
30007444:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007448:	e12fff1e 	bx	lr

3000744c <acoral_mbox_recv>:
/*======================================
 *    receive  a mail to mailbox
 *       接收邮件从邮箱
 *======================================*/
void* acoral_mbox_recv(acoral_evt_t * event, acoral_time timeout)
{
3000744c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007450:	e24dd01c 	sub	sp, sp, #28
30007454:	e58d0004 	str	r0, [sp, #4]
30007458:	e58d1000 	str	r1, [sp]
	void            *msg;
	acoral_sr         cpu_sr;
	acoral_thread_t  *cur;
	
	if (acoral_intr_nesting > 0)
3000745c:	ebffe8bf 	bl	30001760 <hal_get_intr_nesting_comm>
30007460:	e1a03000 	mov	r3, r0
30007464:	e3530000 	cmp	r3, #0
30007468:	da000001 	ble	30007474 <acoral_mbox_recv+0x28>
		return NULL;
3000746c:	e3a03000 	mov	r3, #0
30007470:	ea00004d 	b	300075ac <acoral_mbox_recv+0x160>

	if(event->type!=ACORAL_EVENT_MBOX)
30007474:	e59d3004 	ldr	r3, [sp, #4]
30007478:	e5d33004 	ldrb	r3, [r3, #4]
3000747c:	e3530003 	cmp	r3, #3
30007480:	0a000001 	beq	3000748c <acoral_mbox_recv+0x40>
		return NULL;
30007484:	e3a03000 	mov	r3, #0
30007488:	ea000047 	b	300075ac <acoral_mbox_recv+0x160>
	
	HAL_ENTER_CRITICAL();
3000748c:	ebffe898 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30007490:	e1a03000 	mov	r3, r0
30007494:	e58d3010 	str	r3, [sp, #16]
	acoral_spin_lock(&event->spin_lock);
	if( event->data == NULL)
30007498:	e59d3004 	ldr	r3, [sp, #4]
3000749c:	e5933020 	ldr	r3, [r3, #32]
300074a0:	e3530000 	cmp	r3, #0
300074a4:	1a000037 	bne	30007588 <acoral_mbox_recv+0x13c>
	{
		cur = acoral_cur_thread;
300074a8:	e59f310c 	ldr	r3, [pc, #268]	; 300075bc <acoral_mbox_recv+0x170>
300074ac:	e5933000 	ldr	r3, [r3]
300074b0:	e58d3014 	str	r3, [sp, #20]
		if (timeout > 0)
300074b4:	e59d3000 	ldr	r3, [sp]
300074b8:	e3530000 	cmp	r3, #0
300074bc:	0a00000f 	beq	30007500 <acoral_mbox_recv+0xb4>
		{
			cur->delay = TIME_TO_TICKS(timeout);
300074c0:	e59d2000 	ldr	r2, [sp]
300074c4:	e1a03002 	mov	r3, r2
300074c8:	e1a03103 	lsl	r3, r3, #2
300074cc:	e0833002 	add	r3, r3, r2
300074d0:	e1a02103 	lsl	r2, r3, #2
300074d4:	e0833002 	add	r3, r3, r2
300074d8:	e1a03103 	lsl	r3, r3, #2
300074dc:	e1a02003 	mov	r2, r3
300074e0:	e59f30d8 	ldr	r3, [pc, #216]	; 300075c0 <acoral_mbox_recv+0x174>
300074e4:	e0831392 	umull	r1, r3, r2, r3
300074e8:	e1a03323 	lsr	r3, r3, #6
300074ec:	e1a02003 	mov	r2, r3
300074f0:	e59d3014 	ldr	r3, [sp, #20]
300074f4:	e5832040 	str	r2, [r3, #64]	; 0x40
			timeout_queue_add(cur);
300074f8:	e59d0014 	ldr	r0, [sp, #20]
300074fc:	ebfff4bf 	bl	30004800 <timeout_queue_add>
		}
		acoral_unrdy_thread(cur);
30007500:	e59d0014 	ldr	r0, [sp, #20]
30007504:	ebffeda8 	bl	30002bac <acoral_unrdy_thread>
		acoral_evt_queue_add(event, cur);
30007508:	e59d0004 	ldr	r0, [sp, #4]
3000750c:	e59d1014 	ldr	r1, [sp, #20]
30007510:	ebfff5e5 	bl	30004cac <acoral_evt_queue_add>
		acoral_spin_unlock(&event->spin_lock);
		HAL_EXIT_CRITICAL();
30007514:	e59d0010 	ldr	r0, [sp, #16]
30007518:	ebffe873 	bl	300016ec <HAL_INTR_RESTORE>
		acoral_sched();
3000751c:	ebffebbb 	bl	30002410 <acoral_sched>
		HAL_ENTER_CRITICAL();
30007520:	ebffe873 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30007524:	e1a03000 	mov	r3, r0
30007528:	e58d3010 	str	r3, [sp, #16]
		acoral_spin_lock(&event->spin_lock);

		if (timeout > 0 && cur->delay <= 0)
3000752c:	e59d3000 	ldr	r3, [sp]
30007530:	e3530000 	cmp	r3, #0
30007534:	0a000009 	beq	30007560 <acoral_mbox_recv+0x114>
30007538:	e59d3014 	ldr	r3, [sp, #20]
3000753c:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30007540:	e3530000 	cmp	r3, #0
30007544:	ca000005 	bgt	30007560 <acoral_mbox_recv+0x114>
		{
			acoral_evt_queue_del(cur);
30007548:	e59d0014 	ldr	r0, [sp, #20]
3000754c:	ebfff607 	bl	30004d70 <acoral_evt_queue_del>
			acoral_spin_unlock(&event->spin_lock);
			HAL_EXIT_CRITICAL();
30007550:	e59d0010 	ldr	r0, [sp, #16]
30007554:	ebffe864 	bl	300016ec <HAL_INTR_RESTORE>
			return NULL;
30007558:	e3a03000 	mov	r3, #0
3000755c:	ea000012 	b	300075ac <acoral_mbox_recv+0x160>
		}

		msg        = event->data;
30007560:	e59d3004 	ldr	r3, [sp, #4]
30007564:	e5933020 	ldr	r3, [r3, #32]
30007568:	e58d300c 	str	r3, [sp, #12]
		event->data = NULL;
3000756c:	e59d3004 	ldr	r3, [sp, #4]
30007570:	e3a02000 	mov	r2, #0
30007574:	e5832020 	str	r2, [r3, #32]
		acoral_spin_unlock(&event->spin_lock);
		HAL_EXIT_CRITICAL();
30007578:	e59d0010 	ldr	r0, [sp, #16]
3000757c:	ebffe85a 	bl	300016ec <HAL_INTR_RESTORE>
		return msg;
30007580:	e59d300c 	ldr	r3, [sp, #12]
30007584:	ea000008 	b	300075ac <acoral_mbox_recv+0x160>
	}
	
	msg         = event->data;
30007588:	e59d3004 	ldr	r3, [sp, #4]
3000758c:	e5933020 	ldr	r3, [r3, #32]
30007590:	e58d300c 	str	r3, [sp, #12]
	event->data = NULL;
30007594:	e59d3004 	ldr	r3, [sp, #4]
30007598:	e3a02000 	mov	r2, #0
3000759c:	e5832020 	str	r2, [r3, #32]
	acoral_spin_unlock(&event->spin_lock);
	HAL_EXIT_CRITICAL();
300075a0:	e59d0010 	ldr	r0, [sp, #16]
300075a4:	ebffe850 	bl	300016ec <HAL_INTR_RESTORE>

	return msg;
300075a8:	e59d300c 	ldr	r3, [sp, #12]
}
300075ac:	e1a00003 	mov	r0, r3
300075b0:	e28dd01c 	add	sp, sp, #28
300075b4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300075b8:	e12fff1e 	bx	lr
300075bc:	3002b350 	.word	0x3002b350
300075c0:	10624dd3 	.word	0x10624dd3

300075c4 <acoral_mbox_tryrecv>:
/*======================================
 *   try receive  a mail to mailbox
 *       接收邮件从邮箱
 *======================================*/
void* acoral_mbox_tryrecv(acoral_evt_t * event)
{
300075c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300075c8:	e24dd014 	sub	sp, sp, #20
300075cc:	e58d0004 	str	r0, [sp, #4]
	void            *msg;
	acoral_sr         cpu_sr;
	
	if (acoral_intr_nesting > 0)
300075d0:	ebffe862 	bl	30001760 <hal_get_intr_nesting_comm>
300075d4:	e1a03000 	mov	r3, r0
300075d8:	e3530000 	cmp	r3, #0
300075dc:	da000001 	ble	300075e8 <acoral_mbox_tryrecv+0x24>
		return NULL;
300075e0:	e3a03000 	mov	r3, #0
300075e4:	ea000019 	b	30007650 <acoral_mbox_tryrecv+0x8c>

	if(event->type!=ACORAL_EVENT_MBOX)
300075e8:	e59d3004 	ldr	r3, [sp, #4]
300075ec:	e5d33004 	ldrb	r3, [r3, #4]
300075f0:	e3530003 	cmp	r3, #3
300075f4:	0a000001 	beq	30007600 <acoral_mbox_tryrecv+0x3c>
		return NULL;
300075f8:	e3a03000 	mov	r3, #0
300075fc:	ea000013 	b	30007650 <acoral_mbox_tryrecv+0x8c>
	
	HAL_ENTER_CRITICAL();
30007600:	ebffe83b 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30007604:	e1a03000 	mov	r3, r0
30007608:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&event->spin_lock);
	if( event->data == NULL)
3000760c:	e59d3004 	ldr	r3, [sp, #4]
30007610:	e5933020 	ldr	r3, [r3, #32]
30007614:	e3530000 	cmp	r3, #0
30007618:	1a000003 	bne	3000762c <acoral_mbox_tryrecv+0x68>
	{
		acoral_spin_unlock(&event->spin_lock);
		HAL_EXIT_CRITICAL();
3000761c:	e59d000c 	ldr	r0, [sp, #12]
30007620:	ebffe831 	bl	300016ec <HAL_INTR_RESTORE>
		return NULL;
30007624:	e3a03000 	mov	r3, #0
30007628:	ea000008 	b	30007650 <acoral_mbox_tryrecv+0x8c>
	}
	
	msg         = event->data;
3000762c:	e59d3004 	ldr	r3, [sp, #4]
30007630:	e5933020 	ldr	r3, [r3, #32]
30007634:	e58d3008 	str	r3, [sp, #8]
	event->data = NULL;
30007638:	e59d3004 	ldr	r3, [sp, #4]
3000763c:	e3a02000 	mov	r2, #0
30007640:	e5832020 	str	r2, [r3, #32]
	acoral_spin_unlock(&event->spin_lock);
	HAL_EXIT_CRITICAL();
30007644:	e59d000c 	ldr	r0, [sp, #12]
30007648:	ebffe827 	bl	300016ec <HAL_INTR_RESTORE>

	return msg;
3000764c:	e59d3008 	ldr	r3, [sp, #8]
}
30007650:	e1a00003 	mov	r0, r3
30007654:	e28dd014 	add	sp, sp, #20
30007658:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000765c:	e12fff1e 	bx	lr

30007660 <acoral_sem_init>:
#include <timer.h>
#include <print.h>
#include <sem.h>
acoral_thread_t *acoral_evt_high_thread(acoral_evt_t *evt);
acoral_u32 *acoral_sem_init(acoral_evt_t *evt,acoral_u32 semNum)
{
30007660:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007664:	e24dd00c 	sub	sp, sp, #12
30007668:	e58d0004 	str	r0, [sp, #4]
3000766c:	e58d1000 	str	r1, [sp]
	if (NULL == evt)
30007670:	e59d3004 	ldr	r3, [sp, #4]
30007674:	e3530000 	cmp	r3, #0
30007678:	1a000001 	bne	30007684 <acoral_sem_init+0x24>
	{
		return NULL;
3000767c:	e3a03000 	mov	r3, #0
30007680:	ea00000e 	b	300076c0 <acoral_sem_init+0x60>
	}
	semNum = 1 - semNum;  /* 拥有多个资源，0,一个  -1 两个， -2 三个 ....*/
30007684:	e59d3000 	ldr	r3, [sp]
30007688:	e2633001 	rsb	r3, r3, #1
3000768c:	e58d3000 	str	r3, [sp]
	evt->count = semNum;
30007690:	e59d2000 	ldr	r2, [sp]
30007694:	e59d3004 	ldr	r3, [sp, #4]
30007698:	e583200c 	str	r2, [r3, #12]
	evt->type  = ACORAL_EVENT_SEM;
3000769c:	e59d3004 	ldr	r3, [sp, #4]
300076a0:	e3a02000 	mov	r2, #0
300076a4:	e5c32004 	strb	r2, [r3, #4]
	evt->data  = NULL;
300076a8:	e59d3004 	ldr	r3, [sp, #4]
300076ac:	e3a02000 	mov	r2, #0
300076b0:	e5832020 	str	r2, [r3, #32]
	acoral_evt_init(evt);
300076b4:	e59d0004 	ldr	r0, [sp, #4]
300076b8:	ebfff54d 	bl	30004bf4 <acoral_evt_init>
	return SEM_SUCCED;
300076bc:	e3a03000 	mov	r3, #0
}
300076c0:	e1a00003 	mov	r0, r3
300076c4:	e28dd00c 	add	sp, sp, #12
300076c8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300076cc:	e12fff1e 	bx	lr

300076d0 <acoral_sem_create>:
/*============================
 *   the creation of signal
 *   计算信号量的创建
 *============================*/
acoral_evt_t *acoral_sem_create(acoral_u32 semNum)
{
300076d0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300076d4:	e24dd014 	sub	sp, sp, #20
300076d8:	e58d0004 	str	r0, [sp, #4]
	acoral_evt_t *evt;
	evt = acoral_alloc_evt();
300076dc:	ebfff53c 	bl	30004bd4 <acoral_alloc_evt>
300076e0:	e1a03000 	mov	r3, r0
300076e4:	e58d300c 	str	r3, [sp, #12]
	if (NULL == evt)
300076e8:	e59d300c 	ldr	r3, [sp, #12]
300076ec:	e3530000 	cmp	r3, #0
300076f0:	1a000001 	bne	300076fc <acoral_sem_create+0x2c>
	{
		return NULL;
300076f4:	e3a03000 	mov	r3, #0
300076f8:	ea00000e 	b	30007738 <acoral_sem_create+0x68>
	}
	semNum = 1 - semNum;  /* 拥有多个资源，0,一个  -1 两个， -2 三个 ....*/
300076fc:	e59d3004 	ldr	r3, [sp, #4]
30007700:	e2633001 	rsb	r3, r3, #1
30007704:	e58d3004 	str	r3, [sp, #4]
	evt->count = semNum;
30007708:	e59d2004 	ldr	r2, [sp, #4]
3000770c:	e59d300c 	ldr	r3, [sp, #12]
30007710:	e583200c 	str	r2, [r3, #12]
	evt->type  = ACORAL_EVENT_SEM;
30007714:	e59d300c 	ldr	r3, [sp, #12]
30007718:	e3a02000 	mov	r2, #0
3000771c:	e5c32004 	strb	r2, [r3, #4]
	evt->data  = NULL;
30007720:	e59d300c 	ldr	r3, [sp, #12]
30007724:	e3a02000 	mov	r2, #0
30007728:	e5832020 	str	r2, [r3, #32]
	acoral_evt_init(evt);
3000772c:	e59d000c 	ldr	r0, [sp, #12]
30007730:	ebfff52f 	bl	30004bf4 <acoral_evt_init>
	return evt;
30007734:	e59d300c 	ldr	r3, [sp, #12]
}
30007738:	e1a00003 	mov	r0, r3
3000773c:	e28dd014 	add	sp, sp, #20
30007740:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007744:	e12fff1e 	bx	lr

30007748 <acoral_sem_del>:
/*============================
 *  the deletion of singal 
 *   计算信号量的删除
 *============================*/
acoral_u32 acoral_sem_del(acoral_evt_t *evt, acoral_u32 opt)
{
30007748:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000774c:	e24dd014 	sub	sp, sp, #20
30007750:	e58d0004 	str	r0, [sp, #4]
30007754:	e58d1000 	str	r1, [sp]
	acoral_sr            cpu_sr;
	acoral_thread_t     *thread;
	if (acoral_intr_nesting)
30007758:	ebffe800 	bl	30001760 <hal_get_intr_nesting_comm>
3000775c:	e1a03000 	mov	r3, r0
30007760:	e3530000 	cmp	r3, #0
30007764:	0a000001 	beq	30007770 <acoral_sem_del+0x28>
	{
		return SEM_ERR_INTR;
30007768:	e3a03006 	mov	r3, #6
3000776c:	ea00001d 	b	300077e8 <acoral_sem_del+0xa0>
	}
	/* 参数检测*/
	if (NULL == evt)
30007770:	e59d3004 	ldr	r3, [sp, #4]
30007774:	e3530000 	cmp	r3, #0
30007778:	1a000001 	bne	30007784 <acoral_sem_del+0x3c>
		return SEM_ERR_NULL; /* error*/
3000777c:	e3a03002 	mov	r3, #2
30007780:	ea000018 	b	300077e8 <acoral_sem_del+0xa0>
	if ( evt->type != ACORAL_EVENT_SEM )
30007784:	e59d3004 	ldr	r3, [sp, #4]
30007788:	e5d33004 	ldrb	r3, [r3, #4]
3000778c:	e3530000 	cmp	r3, #0
30007790:	0a000001 	beq	3000779c <acoral_sem_del+0x54>
		return SEM_ERR_TYPE; /* error*/
30007794:	e3a03004 	mov	r3, #4
30007798:	ea000012 	b	300077e8 <acoral_sem_del+0xa0>

	HAL_ENTER_CRITICAL();
3000779c:	ebffe7d4 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300077a0:	e1a03000 	mov	r3, r0
300077a4:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&evt->spin_lock);
	thread =acoral_evt_high_thread(evt);
300077a8:	e59d0004 	ldr	r0, [sp, #4]
300077ac:	ebfff52a 	bl	30004c5c <acoral_evt_high_thread>
300077b0:	e1a03000 	mov	r3, r0
300077b4:	e58d300c 	str	r3, [sp, #12]
	if (thread==NULL)
300077b8:	e59d300c 	ldr	r3, [sp, #12]
300077bc:	e3530000 	cmp	r3, #0
300077c0:	1a000005 	bne	300077dc <acoral_sem_del+0x94>
	{
		/*队列上无等待任务*/
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
300077c4:	e59d0008 	ldr	r0, [sp, #8]
300077c8:	ebffe7c7 	bl	300016ec <HAL_INTR_RESTORE>
		evt = NULL;
300077cc:	e3a03000 	mov	r3, #0
300077d0:	e58d3004 	str	r3, [sp, #4]
		return SEM_ERR_UNDEF;
300077d4:	e3a03007 	mov	r3, #7
300077d8:	ea000002 	b	300077e8 <acoral_sem_del+0xa0>
	}
	else
	{
		/*有等待任务*/
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
300077dc:	e59d0008 	ldr	r0, [sp, #8]
300077e0:	ebffe7c1 	bl	300016ec <HAL_INTR_RESTORE>
		return SEM_ERR_TASK_EXIST; /*error*/
300077e4:	e3a03005 	mov	r3, #5
	}
}
300077e8:	e1a00003 	mov	r0, r3
300077ec:	e28dd014 	add	sp, sp, #20
300077f0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300077f4:	e12fff1e 	bx	lr

300077f8 <acoral_sem_trypend>:
 *  计算信号量的申请
 *  desp: count <= SEM_RES_AVAI  信号量有效 a++
 *        count >  SEM_RES_AVAI  信号量无效 a++ && thread suspend
 *============================*/
acoral_u32 acoral_sem_trypend(acoral_evt_t *evt)
{
300077f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300077fc:	e24dd014 	sub	sp, sp, #20
30007800:	e58d0004 	str	r0, [sp, #4]
	acoral_sr cpu_sr;

	if (acoral_intr_nesting)
30007804:	ebffe7d5 	bl	30001760 <hal_get_intr_nesting_comm>
30007808:	e1a03000 	mov	r3, r0
3000780c:	e3530000 	cmp	r3, #0
30007810:	0a000001 	beq	3000781c <acoral_sem_trypend+0x24>
	{
		return SEM_ERR_INTR;
30007814:	e3a03006 	mov	r3, #6
30007818:	ea000020 	b	300078a0 <acoral_sem_trypend+0xa8>
	}

	/* 参数检测 */
	if (NULL == evt)
3000781c:	e59d3004 	ldr	r3, [sp, #4]
30007820:	e3530000 	cmp	r3, #0
30007824:	1a000001 	bne	30007830 <acoral_sem_trypend+0x38>
	{
		return SEM_ERR_NULL; /*error*/
30007828:	e3a03002 	mov	r3, #2
3000782c:	ea00001b 	b	300078a0 <acoral_sem_trypend+0xa8>
	}
	if (ACORAL_EVENT_SEM != evt->type)
30007830:	e59d3004 	ldr	r3, [sp, #4]
30007834:	e5d33004 	ldrb	r3, [r3, #4]
30007838:	e3530000 	cmp	r3, #0
3000783c:	0a000001 	beq	30007848 <acoral_sem_trypend+0x50>
	{
		return SEM_ERR_TYPE; /*error*/
30007840:	e3a03004 	mov	r3, #4
30007844:	ea000015 	b	300078a0 <acoral_sem_trypend+0xa8>
	}

	/* 计算信号量处理*/
	HAL_ENTER_CRITICAL();
30007848:	ebffe7a9 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000784c:	e1a03000 	mov	r3, r0
30007850:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&evt->spin_lock);
	if ((acoral_8)evt->count <= SEM_RES_AVAI)
30007854:	e59d3004 	ldr	r3, [sp, #4]
30007858:	e593300c 	ldr	r3, [r3, #12]
3000785c:	e20330ff 	and	r3, r3, #255	; 0xff
30007860:	e1a03c03 	lsl	r3, r3, #24
30007864:	e1a03c43 	asr	r3, r3, #24
30007868:	e3530000 	cmp	r3, #0
3000786c:	ca000008 	bgt	30007894 <acoral_sem_trypend+0x9c>
	{   /* available*/
		evt->count++;
30007870:	e59d3004 	ldr	r3, [sp, #4]
30007874:	e593300c 	ldr	r3, [r3, #12]
30007878:	e2832001 	add	r2, r3, #1
3000787c:	e59d3004 	ldr	r3, [sp, #4]
30007880:	e583200c 	str	r2, [r3, #12]
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30007884:	e59d000c 	ldr	r0, [sp, #12]
30007888:	ebffe797 	bl	300016ec <HAL_INTR_RESTORE>
		return SEM_SUCCED;
3000788c:	e3a03000 	mov	r3, #0
30007890:	ea000002 	b	300078a0 <acoral_sem_trypend+0xa8>
	}

	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
30007894:	e59d000c 	ldr	r0, [sp, #12]
30007898:	ebffe793 	bl	300016ec <HAL_INTR_RESTORE>
	return SEM_ERR_TIMEOUT;
3000789c:	e3a03008 	mov	r3, #8
}
300078a0:	e1a00003 	mov	r0, r3
300078a4:	e28dd014 	add	sp, sp, #20
300078a8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300078ac:	e12fff1e 	bx	lr

300078b0 <acoral_sem_pend>:
 *  计算信号量的申请
 *  desp: count <= SEM_RES_AVAI  信号量有效 a++
 *        count >  SEM_RES_AVAI  信号量无效 a++ && thread suspend
 *============================*/
acoral_u32 acoral_sem_pend(acoral_evt_t *evt, acoral_time timeout)
{
300078b0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300078b4:	e24dd014 	sub	sp, sp, #20
300078b8:	e58d0004 	str	r0, [sp, #4]
300078bc:	e58d1000 	str	r1, [sp]
	acoral_thread_t *cur = acoral_cur_thread;
300078c0:	e59f318c 	ldr	r3, [pc, #396]	; 30007a54 <acoral_sem_pend+0x1a4>
300078c4:	e5933000 	ldr	r3, [r3]
300078c8:	e58d3008 	str	r3, [sp, #8]
	acoral_sr cpu_sr;

	if (acoral_intr_nesting)
300078cc:	ebffe7a3 	bl	30001760 <hal_get_intr_nesting_comm>
300078d0:	e1a03000 	mov	r3, r0
300078d4:	e3530000 	cmp	r3, #0
300078d8:	0a000001 	beq	300078e4 <acoral_sem_pend+0x34>
	{
		return SEM_ERR_INTR;
300078dc:	e3a03006 	mov	r3, #6
300078e0:	ea000057 	b	30007a44 <acoral_sem_pend+0x194>
	}

	/* 参数检测 */
	if (NULL == evt)
300078e4:	e59d3004 	ldr	r3, [sp, #4]
300078e8:	e3530000 	cmp	r3, #0
300078ec:	1a000001 	bne	300078f8 <acoral_sem_pend+0x48>
	{
		return SEM_ERR_NULL; /*error*/
300078f0:	e3a03002 	mov	r3, #2
300078f4:	ea000052 	b	30007a44 <acoral_sem_pend+0x194>
	}
	if (ACORAL_EVENT_SEM != evt->type)
300078f8:	e59d3004 	ldr	r3, [sp, #4]
300078fc:	e5d33004 	ldrb	r3, [r3, #4]
30007900:	e3530000 	cmp	r3, #0
30007904:	0a000001 	beq	30007910 <acoral_sem_pend+0x60>
	{
		return SEM_ERR_TYPE; /*error*/
30007908:	e3a03004 	mov	r3, #4
3000790c:	ea00004c 	b	30007a44 <acoral_sem_pend+0x194>
	}

	/* 计算信号量处理*/
	HAL_ENTER_CRITICAL();
30007910:	ebffe777 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30007914:	e1a03000 	mov	r3, r0
30007918:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&evt->spin_lock);
	if ((acoral_8)evt->count <= SEM_RES_AVAI)
3000791c:	e59d3004 	ldr	r3, [sp, #4]
30007920:	e593300c 	ldr	r3, [r3, #12]
30007924:	e20330ff 	and	r3, r3, #255	; 0xff
30007928:	e1a03c03 	lsl	r3, r3, #24
3000792c:	e1a03c43 	asr	r3, r3, #24
30007930:	e3530000 	cmp	r3, #0
30007934:	ca000008 	bgt	3000795c <acoral_sem_pend+0xac>
	{   /* available*/
		evt->count++;
30007938:	e59d3004 	ldr	r3, [sp, #4]
3000793c:	e593300c 	ldr	r3, [r3, #12]
30007940:	e2832001 	add	r2, r3, #1
30007944:	e59d3004 	ldr	r3, [sp, #4]
30007948:	e583200c 	str	r2, [r3, #12]
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
3000794c:	e59d000c 	ldr	r0, [sp, #12]
30007950:	ebffe765 	bl	300016ec <HAL_INTR_RESTORE>
		return SEM_SUCCED;
30007954:	e3a03000 	mov	r3, #0
30007958:	ea000039 	b	30007a44 <acoral_sem_pend+0x194>
	}

	evt->count++;
3000795c:	e59d3004 	ldr	r3, [sp, #4]
30007960:	e593300c 	ldr	r3, [r3, #12]
30007964:	e2832001 	add	r2, r3, #1
30007968:	e59d3004 	ldr	r3, [sp, #4]
3000796c:	e583200c 	str	r2, [r3, #12]
	acoral_unrdy_thread(cur);
30007970:	e59d0008 	ldr	r0, [sp, #8]
30007974:	ebffec8c 	bl	30002bac <acoral_unrdy_thread>
	if (timeout > 0)
30007978:	e59d3000 	ldr	r3, [sp]
3000797c:	e3530000 	cmp	r3, #0
30007980:	0a00000f 	beq	300079c4 <acoral_sem_pend+0x114>
	{
		cur->delay = TIME_TO_TICKS(timeout);
30007984:	e59d2000 	ldr	r2, [sp]
30007988:	e1a03002 	mov	r3, r2
3000798c:	e1a03103 	lsl	r3, r3, #2
30007990:	e0833002 	add	r3, r3, r2
30007994:	e1a02103 	lsl	r2, r3, #2
30007998:	e0833002 	add	r3, r3, r2
3000799c:	e1a03103 	lsl	r3, r3, #2
300079a0:	e1a02003 	mov	r2, r3
300079a4:	e59f30ac 	ldr	r3, [pc, #172]	; 30007a58 <acoral_sem_pend+0x1a8>
300079a8:	e0831392 	umull	r1, r3, r2, r3
300079ac:	e1a03323 	lsr	r3, r3, #6
300079b0:	e1a02003 	mov	r2, r3
300079b4:	e59d3008 	ldr	r3, [sp, #8]
300079b8:	e5832040 	str	r2, [r3, #64]	; 0x40
		timeout_queue_add(cur);
300079bc:	e59d0008 	ldr	r0, [sp, #8]
300079c0:	ebfff38e 	bl	30004800 <timeout_queue_add>
	}
	acoral_evt_queue_add(evt,cur);
300079c4:	e59d0004 	ldr	r0, [sp, #4]
300079c8:	e59d1008 	ldr	r1, [sp, #8]
300079cc:	ebfff4b6 	bl	30004cac <acoral_evt_queue_add>
	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
300079d0:	e59d000c 	ldr	r0, [sp, #12]
300079d4:	ebffe744 	bl	300016ec <HAL_INTR_RESTORE>
	
	acoral_sched();
300079d8:	ebffea8c 	bl	30002410 <acoral_sched>

	HAL_ENTER_CRITICAL();
300079dc:	ebffe744 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300079e0:	e1a03000 	mov	r3, r0
300079e4:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&evt->spin_lock);
	if(timeout>0 && cur->delay<=0)
300079e8:	e59d3000 	ldr	r3, [sp]
300079ec:	e3530000 	cmp	r3, #0
300079f0:	0a00000e 	beq	30007a30 <acoral_sem_pend+0x180>
300079f4:	e59d3008 	ldr	r3, [sp, #8]
300079f8:	e5933040 	ldr	r3, [r3, #64]	; 0x40
300079fc:	e3530000 	cmp	r3, #0
30007a00:	ca00000a 	bgt	30007a30 <acoral_sem_pend+0x180>
	{
		//--------------
		// modify by pegasus 0804: count-- [+]
		evt->count--;
30007a04:	e59d3004 	ldr	r3, [sp, #4]
30007a08:	e593300c 	ldr	r3, [r3, #12]
30007a0c:	e2432001 	sub	r2, r3, #1
30007a10:	e59d3004 	ldr	r3, [sp, #4]
30007a14:	e583200c 	str	r2, [r3, #12]
		acoral_evt_queue_del(cur);
30007a18:	e59d0008 	ldr	r0, [sp, #8]
30007a1c:	ebfff4d3 	bl	30004d70 <acoral_evt_queue_del>
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30007a20:	e59d000c 	ldr	r0, [sp, #12]
30007a24:	ebffe730 	bl	300016ec <HAL_INTR_RESTORE>
		return SEM_ERR_TIMEOUT;
30007a28:	e3a03008 	mov	r3, #8
30007a2c:	ea000004 	b	30007a44 <acoral_sem_pend+0x194>
	}

	//-------------------
	// modify by pegasus 0804: timeout_queue_del [+]
	timeout_queue_del(cur);
30007a30:	e59d0008 	ldr	r0, [sp, #8]
30007a34:	ebfff3b3 	bl	30004908 <timeout_queue_del>
	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
30007a38:	e59d000c 	ldr	r0, [sp, #12]
30007a3c:	ebffe72a 	bl	300016ec <HAL_INTR_RESTORE>
	return SEM_SUCCED;
30007a40:	e3a03000 	mov	r3, #0
}
30007a44:	e1a00003 	mov	r0, r3
30007a48:	e28dd014 	add	sp, sp, #20
30007a4c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007a50:	e12fff1e 	bx	lr
30007a54:	3002b350 	.word	0x3002b350
30007a58:	10624dd3 	.word	0x10624dd3

30007a5c <acoral_sem_post>:
 *  计算信号量的释放
 *  desp: count > SEM_RES_NOAVAI 有等待线程 a-- && resume waiting thread.
 *        count <= SEM_RES_NOAVAI 无等待线程 a--
 *===========================*/
acoral_u32 acoral_sem_post(acoral_evt_t *evt)
{
30007a5c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007a60:	e24dd014 	sub	sp, sp, #20
30007a64:	e58d0004 	str	r0, [sp, #4]
	acoral_thread_t     *thread;
	acoral_sr            cpu_sr;

	/* 参数检测*/
	if ( NULL == evt)
30007a68:	e59d3004 	ldr	r3, [sp, #4]
30007a6c:	e3530000 	cmp	r3, #0
30007a70:	1a000001 	bne	30007a7c <acoral_sem_post+0x20>
	{
		return SEM_ERR_NULL; /* error*/
30007a74:	e3a03002 	mov	r3, #2
30007a78:	ea000034 	b	30007b50 <acoral_sem_post+0xf4>
	}
	if (ACORAL_EVENT_SEM != evt->type)
30007a7c:	e59d3004 	ldr	r3, [sp, #4]
30007a80:	e5d33004 	ldrb	r3, [r3, #4]
30007a84:	e3530000 	cmp	r3, #0
30007a88:	0a000001 	beq	30007a94 <acoral_sem_post+0x38>
	{
		return SEM_ERR_TYPE;
30007a8c:	e3a03004 	mov	r3, #4
30007a90:	ea00002e 	b	30007b50 <acoral_sem_post+0xf4>
	}

	HAL_ENTER_CRITICAL();
30007a94:	ebffe716 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30007a98:	e1a03000 	mov	r3, r0
30007a9c:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&evt->spin_lock);

	/* 计算信号量的释放*/
	if ((acoral_8)evt->count <= SEM_RES_NOAVAI)
30007aa0:	e59d3004 	ldr	r3, [sp, #4]
30007aa4:	e593300c 	ldr	r3, [r3, #12]
30007aa8:	e20330ff 	and	r3, r3, #255	; 0xff
30007aac:	e1a03c03 	lsl	r3, r3, #24
30007ab0:	e1a03c43 	asr	r3, r3, #24
30007ab4:	e3530001 	cmp	r3, #1
30007ab8:	ca000008 	bgt	30007ae0 <acoral_sem_post+0x84>
	{ /* no waiting thread*/
		evt->count--;
30007abc:	e59d3004 	ldr	r3, [sp, #4]
30007ac0:	e593300c 	ldr	r3, [r3, #12]
30007ac4:	e2432001 	sub	r2, r3, #1
30007ac8:	e59d3004 	ldr	r3, [sp, #4]
30007acc:	e583200c 	str	r2, [r3, #12]
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30007ad0:	e59d000c 	ldr	r0, [sp, #12]
30007ad4:	ebffe704 	bl	300016ec <HAL_INTR_RESTORE>
		return SEM_SUCCED;
30007ad8:	e3a03000 	mov	r3, #0
30007adc:	ea00001b 	b	30007b50 <acoral_sem_post+0xf4>
	}
	/* 有等待线程*/
	evt->count--;
30007ae0:	e59d3004 	ldr	r3, [sp, #4]
30007ae4:	e593300c 	ldr	r3, [r3, #12]
30007ae8:	e2432001 	sub	r2, r3, #1
30007aec:	e59d3004 	ldr	r3, [sp, #4]
30007af0:	e583200c 	str	r2, [r3, #12]
	thread =acoral_evt_high_thread(evt);
30007af4:	e59d0004 	ldr	r0, [sp, #4]
30007af8:	ebfff457 	bl	30004c5c <acoral_evt_high_thread>
30007afc:	e1a03000 	mov	r3, r0
30007b00:	e58d3008 	str	r3, [sp, #8]
	if (thread==NULL)
30007b04:	e59d3008 	ldr	r3, [sp, #8]
30007b08:	e3530000 	cmp	r3, #0
30007b0c:	1a000005 	bne	30007b28 <acoral_sem_post+0xcc>
	{
		/*应该有等待线程却没有找到*/
		acoral_printerr("Err Sem post\n");
30007b10:	e59f0048 	ldr	r0, [pc, #72]	; 30007b60 <acoral_sem_post+0x104>
30007b14:	eb000e43 	bl	3000b428 <acoral_print>
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30007b18:	e59d000c 	ldr	r0, [sp, #12]
30007b1c:	ebffe6f2 	bl	300016ec <HAL_INTR_RESTORE>
		return SEM_ERR_UNDEF;
30007b20:	e3a03007 	mov	r3, #7
30007b24:	ea000009 	b	30007b50 <acoral_sem_post+0xf4>
	}
	timeout_queue_del(thread);
30007b28:	e59d0008 	ldr	r0, [sp, #8]
30007b2c:	ebfff375 	bl	30004908 <timeout_queue_del>
	/*释放等待任务*/
	acoral_evt_queue_del(thread);
30007b30:	e59d0008 	ldr	r0, [sp, #8]
30007b34:	ebfff48d 	bl	30004d70 <acoral_evt_queue_del>
	acoral_rdy_thread(thread);
30007b38:	e59d0008 	ldr	r0, [sp, #8]
30007b3c:	ebffec0b 	bl	30002b70 <acoral_rdy_thread>
	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
30007b40:	e59d000c 	ldr	r0, [sp, #12]
30007b44:	ebffe6e8 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sched();
30007b48:	ebffea30 	bl	30002410 <acoral_sched>
	return SEM_SUCCED;
30007b4c:	e3a03000 	mov	r3, #0
}
30007b50:	e1a00003 	mov	r0, r3
30007b54:	e28dd014 	add	sp, sp, #20
30007b58:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007b5c:	e12fff1e 	bx	lr
30007b60:	30026244 	.word	0x30026244

30007b64 <acoral_sem_getnum>:
/*===================================
 *   get singal's number now
 *     得到当前信号量数目
 *===================================*/
acoral_32 acoral_sem_getnum(acoral_evt_t* evt)
{
30007b64:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007b68:	e24dd014 	sub	sp, sp, #20
30007b6c:	e58d0004 	str	r0, [sp, #4]
	acoral_32 t;
	acoral_sr cpu_sr;

	if (NULL == evt)
30007b70:	e59d3004 	ldr	r3, [sp, #4]
30007b74:	e3530000 	cmp	r3, #0
30007b78:	1a000001 	bne	30007b84 <acoral_sem_getnum+0x20>
		return SEM_ERR_NULL;
30007b7c:	e3a03002 	mov	r3, #2
30007b80:	ea000009 	b	30007bac <acoral_sem_getnum+0x48>

	HAL_ENTER_CRITICAL();
30007b84:	ebffe6da 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30007b88:	e1a03000 	mov	r3, r0
30007b8c:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&evt->spin_lock);
	t = 1 - (acoral_32)evt->count;
30007b90:	e59d3004 	ldr	r3, [sp, #4]
30007b94:	e593300c 	ldr	r3, [r3, #12]
30007b98:	e2633001 	rsb	r3, r3, #1
30007b9c:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
30007ba0:	e59d000c 	ldr	r0, [sp, #12]
30007ba4:	ebffe6d0 	bl	300016ec <HAL_INTR_RESTORE>
	return t;
30007ba8:	e59d3008 	ldr	r3, [sp, #8]
}
30007bac:	e1a00003 	mov	r0, r3
30007bb0:	e28dd014 	add	sp, sp, #20
30007bb4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007bb8:	e12fff1e 	bx	lr

30007bbc <acoral_msg_sys_init>:
/*=============================
 *
 *  mssage 机制缓冲池初始化
 *=============================*/
void acoral_msg_sys_init()
{
30007bbc:	e92d4008 	push	{r3, lr}
	/*初始化全局事件列表头*/
	acoral_init_list (&(g_msgctr_header.head));
30007bc0:	e59f3094 	ldr	r3, [pc, #148]	; 30007c5c <acoral_msg_sys_init+0xa0>
30007bc4:	e59f2090 	ldr	r2, [pc, #144]	; 30007c5c <acoral_msg_sys_init+0xa0>
30007bc8:	e5832000 	str	r2, [r3]
30007bcc:	e59f3088 	ldr	r3, [pc, #136]	; 30007c5c <acoral_msg_sys_init+0xa0>
30007bd0:	e59f2084 	ldr	r2, [pc, #132]	; 30007c5c <acoral_msg_sys_init+0xa0>
30007bd4:	e5832004 	str	r2, [r3, #4]
	g_msgctr_header.data = NULL;
30007bd8:	e59f307c 	ldr	r3, [pc, #124]	; 30007c5c <acoral_msg_sys_init+0xa0>
30007bdc:	e3a02000 	mov	r2, #0
30007be0:	e5832008 	str	r2, [r3, #8]
	acoral_msgctr_pool_ctrl.type=ACORAL_RES_MST;
30007be4:	e59f3074 	ldr	r3, [pc, #116]	; 30007c60 <acoral_msg_sys_init+0xa4>
30007be8:	e3a02006 	mov	r2, #6
30007bec:	e5832000 	str	r2, [r3]
	acoral_msgctr_pool_ctrl.size=sizeof(acoral_msgctr_t);
30007bf0:	e59f3068 	ldr	r3, [pc, #104]	; 30007c60 <acoral_msg_sys_init+0xa4>
30007bf4:	e3a02030 	mov	r2, #48	; 0x30
30007bf8:	e5832004 	str	r2, [r3, #4]
	acoral_msgctr_pool_ctrl.num_per_pool=10;
30007bfc:	e59f305c 	ldr	r3, [pc, #92]	; 30007c60 <acoral_msg_sys_init+0xa4>
30007c00:	e3a0200a 	mov	r2, #10
30007c04:	e5832008 	str	r2, [r3, #8]
	acoral_msgctr_pool_ctrl.max_pools=4;
30007c08:	e59f3050 	ldr	r3, [pc, #80]	; 30007c60 <acoral_msg_sys_init+0xa4>
30007c0c:	e3a02004 	mov	r2, #4
30007c10:	e5832010 	str	r2, [r3, #16]

	acoral_msg_pool_ctrl.type=ACORAL_RES_MSG;
30007c14:	e59f3048 	ldr	r3, [pc, #72]	; 30007c64 <acoral_msg_sys_init+0xa8>
30007c18:	e3a02005 	mov	r2, #5
30007c1c:	e5832000 	str	r2, [r3]
	acoral_msg_pool_ctrl.size=sizeof(acoral_msg_t);
30007c20:	e59f303c 	ldr	r3, [pc, #60]	; 30007c64 <acoral_msg_sys_init+0xa8>
30007c24:	e3a0201c 	mov	r2, #28
30007c28:	e5832004 	str	r2, [r3, #4]
	acoral_msg_pool_ctrl.num_per_pool=10;
30007c2c:	e59f3030 	ldr	r3, [pc, #48]	; 30007c64 <acoral_msg_sys_init+0xa8>
30007c30:	e3a0200a 	mov	r2, #10
30007c34:	e5832008 	str	r2, [r3, #8]
	acoral_msg_pool_ctrl.max_pools=4;
30007c38:	e59f3024 	ldr	r3, [pc, #36]	; 30007c64 <acoral_msg_sys_init+0xa8>
30007c3c:	e3a02004 	mov	r2, #4
30007c40:	e5832010 	str	r2, [r3, #16]

	acoral_pool_ctrl_init(&acoral_msgctr_pool_ctrl);
30007c44:	e59f0014 	ldr	r0, [pc, #20]	; 30007c60 <acoral_msg_sys_init+0xa4>
30007c48:	ebffef88 	bl	30003a70 <acoral_pool_ctrl_init>
	acoral_pool_ctrl_init(&acoral_msg_pool_ctrl);
30007c4c:	e59f0010 	ldr	r0, [pc, #16]	; 30007c64 <acoral_msg_sys_init+0xa8>
30007c50:	ebffef86 	bl	30003a70 <acoral_pool_ctrl_init>
}
30007c54:	e8bd4008 	pop	{r3, lr}
30007c58:	e12fff1e 	bx	lr
30007c5c:	3002a0b0 	.word	0x3002a0b0
30007c60:	3002b178 	.word	0x3002b178
30007c64:	3002b0b0 	.word	0x3002b0b0

30007c68 <acoral_msgctr_list_queueadd>:
 *  静态创建的acoral_msgctr_t调用
 *  message container 挂全局队列
 *  在中断中处理 ttl 时使用
 *==============================*/
void acoral_msgctr_list_queueadd(acoral_msgctr_t* msgctr)
{
30007c68:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007c6c:	e24dd00c 	sub	sp, sp, #12
30007c70:	e58d0004 	str	r0, [sp, #4]
  	acoral_list_add2_tail (&msgctr->msgctr_list, &(g_msgctr_header.head));
30007c74:	e59d3004 	ldr	r3, [sp, #4]
30007c78:	e283300c 	add	r3, r3, #12
30007c7c:	e1a00003 	mov	r0, r3
30007c80:	e59f100c 	ldr	r1, [pc, #12]	; 30007c94 <acoral_msgctr_list_queueadd+0x2c>
30007c84:	eb000955 	bl	3000a1e0 <acoral_list_add2_tail>
}
30007c88:	e28dd00c 	add	sp, sp, #12
30007c8c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007c90:	e12fff1e 	bx	lr
30007c94:	3002a0b0 	.word	0x3002a0b0

30007c98 <acoral_alloc_msgctr>:
/*==============================
 *
 *  message 分配
 *==============================*/
acoral_msgctr_t* acoral_alloc_msgctr()
{
30007c98:	e92d4008 	push	{r3, lr}
	return (acoral_msgctr_t*)acoral_get_res (&acoral_msgctr_pool_ctrl);
30007c9c:	e59f0010 	ldr	r0, [pc, #16]	; 30007cb4 <acoral_alloc_msgctr+0x1c>
30007ca0:	ebffee13 	bl	300034f4 <acoral_get_res>
30007ca4:	e1a03000 	mov	r3, r0
}
30007ca8:	e1a00003 	mov	r0, r3
30007cac:	e8bd4008 	pop	{r3, lr}
30007cb0:	e12fff1e 	bx	lr
30007cb4:	3002b178 	.word	0x3002b178

30007cb8 <acoral_alloc_msg>:

acoral_msg_t* acoral_alloc_msg()
{
30007cb8:	e92d4008 	push	{r3, lr}
	return (acoral_msg_t*)acoral_get_res (&acoral_msg_pool_ctrl);
30007cbc:	e59f0010 	ldr	r0, [pc, #16]	; 30007cd4 <acoral_alloc_msg+0x1c>
30007cc0:	ebffee0b 	bl	300034f4 <acoral_get_res>
30007cc4:	e1a03000 	mov	r3, r0
}
30007cc8:	e1a00003 	mov	r0, r3
30007ccc:	e8bd4008 	pop	{r3, lr}
30007cd0:	e12fff1e 	bx	lr
30007cd4:	3002b0b0 	.word	0x3002b0b0

30007cd8 <acoral_msgctr_queue_add>:
 *
 *  message 等待队列增加
 *==============================*/
void acoral_msgctr_queue_add (acoral_msgctr_t* msgctr, 
		                            acoral_thread_t* thread)
{   /*需按优先级排序*/
30007cd8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007cdc:	e24dd01c 	sub	sp, sp, #28
30007ce0:	e58d0004 	str	r0, [sp, #4]
30007ce4:	e58d1000 	str	r1, [sp]
	/*acoral_list_add2_tail (&thread->waiting, &msgctr->waiting);*/
	acoral_list_t *p, *q;
	acoral_thread_t*  ptd;
	
	p = &msgctr->waiting;
30007ce8:	e59d3004 	ldr	r3, [sp, #4]
30007cec:	e2833020 	add	r3, r3, #32
30007cf0:	e58d300c 	str	r3, [sp, #12]
	q = p->next;
30007cf4:	e59d300c 	ldr	r3, [sp, #12]
30007cf8:	e5933000 	ldr	r3, [r3]
30007cfc:	e58d3010 	str	r3, [sp, #16]
	for( ; p != q; q=q->next)
30007d00:	ea00000b 	b	30007d34 <acoral_msgctr_queue_add+0x5c>
	{
		ptd = list_entry( q, acoral_thread_t, waiting);
30007d04:	e59d3010 	ldr	r3, [sp, #16]
30007d08:	e2433020 	sub	r3, r3, #32
30007d0c:	e58d3014 	str	r3, [sp, #20]
		if (ptd->prio > thread->prio)
30007d10:	e59d3014 	ldr	r3, [sp, #20]
30007d14:	e5d32005 	ldrb	r2, [r3, #5]
30007d18:	e59d3000 	ldr	r3, [sp]
30007d1c:	e5d33005 	ldrb	r3, [r3, #5]
30007d20:	e1520003 	cmp	r2, r3
30007d24:	8a000007 	bhi	30007d48 <acoral_msgctr_queue_add+0x70>
	acoral_list_t *p, *q;
	acoral_thread_t*  ptd;
	
	p = &msgctr->waiting;
	q = p->next;
	for( ; p != q; q=q->next)
30007d28:	e59d3010 	ldr	r3, [sp, #16]
30007d2c:	e5933000 	ldr	r3, [r3]
30007d30:	e58d3010 	str	r3, [sp, #16]
30007d34:	e59d200c 	ldr	r2, [sp, #12]
30007d38:	e59d3010 	ldr	r3, [sp, #16]
30007d3c:	e1520003 	cmp	r2, r3
30007d40:	1affffef 	bne	30007d04 <acoral_msgctr_queue_add+0x2c>
30007d44:	ea000000 	b	30007d4c <acoral_msgctr_queue_add+0x74>
	{
		ptd = list_entry( q, acoral_thread_t, waiting);
		if (ptd->prio > thread->prio)
			break;
30007d48:	e1a00000 	nop			; (mov r0, r0)
	}
	acoral_list_add( &thread->waiting, q->prev);
30007d4c:	e59d3000 	ldr	r3, [sp]
30007d50:	e2832020 	add	r2, r3, #32
30007d54:	e59d3010 	ldr	r3, [sp, #16]
30007d58:	e5933004 	ldr	r3, [r3, #4]
30007d5c:	e1a00002 	mov	r0, r2
30007d60:	e1a01003 	mov	r1, r3
30007d64:	eb00090a 	bl	3000a194 <acoral_list_add>
}
30007d68:	e28dd01c 	add	sp, sp, #28
30007d6c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007d70:	e12fff1e 	bx	lr

30007d74 <acoral_msg_queue_add>:

void acoral_msg_queue_add (acoral_msgctr_t* msgctr, 
		                          acoral_msg_t* msg)
{
30007d74:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007d78:	e24dd00c 	sub	sp, sp, #12
30007d7c:	e58d0004 	str	r0, [sp, #4]
30007d80:	e58d1000 	str	r1, [sp]
	acoral_list_add2_tail (&msg->msglist, &msgctr->msglist);
30007d84:	e59d3000 	ldr	r3, [sp]
30007d88:	e2832004 	add	r2, r3, #4
30007d8c:	e59d3004 	ldr	r3, [sp, #4]
30007d90:	e2833028 	add	r3, r3, #40	; 0x28
30007d94:	e1a00002 	mov	r0, r2
30007d98:	e1a01003 	mov	r1, r3
30007d9c:	eb00090f 	bl	3000a1e0 <acoral_list_add2_tail>
}
30007da0:	e28dd00c 	add	sp, sp, #12
30007da4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007da8:	e12fff1e 	bx	lr

30007dac <acoral_msgctr_init>:
/*==============================
 * The initialize of the message
 *       消息容器初始化
 *==============================*/
acoral_u32  acoral_msgctr_init(acoral_msgctr_t *msgctr)
{
30007dac:	e24dd008 	sub	sp, sp, #8
30007db0:	e58d0004 	str	r0, [sp, #4]
	if (msgctr == NULL)
30007db4:	e59d3004 	ldr	r3, [sp, #4]
30007db8:	e3530000 	cmp	r3, #0
30007dbc:	1a000001 	bne	30007dc8 <acoral_msgctr_init+0x1c>
		return MST_ERR_NULL;
30007dc0:	e3a03000 	mov	r3, #0
30007dc4:	ea000024 	b	30007e5c <acoral_msgctr_init+0xb0>

	msgctr->name  = NULL;
30007dc8:	e59d3004 	ldr	r3, [sp, #4]
30007dcc:	e3a02000 	mov	r2, #0
30007dd0:	e5832004 	str	r2, [r3, #4]
	msgctr->type  = ACORAL_MSGCTR;
30007dd4:	e59d3004 	ldr	r3, [sp, #4]
30007dd8:	e3a02001 	mov	r2, #1
30007ddc:	e5c32008 	strb	r2, [r3, #8]
	msgctr->count = 0;
30007de0:	e59d3004 	ldr	r3, [sp, #4]
30007de4:	e3a02000 	mov	r2, #0
30007de8:	e5832018 	str	r2, [r3, #24]
	msgctr->wait_thread_num = 0;
30007dec:	e59d3004 	ldr	r3, [sp, #4]
30007df0:	e3a02000 	mov	r2, #0
30007df4:	e583201c 	str	r2, [r3, #28]

	acoral_init_list(&msgctr->msglist);
30007df8:	e59d3004 	ldr	r3, [sp, #4]
30007dfc:	e2832028 	add	r2, r3, #40	; 0x28
30007e00:	e59d3004 	ldr	r3, [sp, #4]
30007e04:	e5832028 	str	r2, [r3, #40]	; 0x28
30007e08:	e59d3004 	ldr	r3, [sp, #4]
30007e0c:	e2832028 	add	r2, r3, #40	; 0x28
30007e10:	e59d3004 	ldr	r3, [sp, #4]
30007e14:	e583202c 	str	r2, [r3, #44]	; 0x2c
	acoral_init_list(&msgctr->waiting);
30007e18:	e59d3004 	ldr	r3, [sp, #4]
30007e1c:	e2832020 	add	r2, r3, #32
30007e20:	e59d3004 	ldr	r3, [sp, #4]
30007e24:	e5832020 	str	r2, [r3, #32]
30007e28:	e59d3004 	ldr	r3, [sp, #4]
30007e2c:	e2832020 	add	r2, r3, #32
30007e30:	e59d3004 	ldr	r3, [sp, #4]
30007e34:	e5832024 	str	r2, [r3, #36]	; 0x24
	acoral_init_list(&msgctr->msgctr_list);
30007e38:	e59d3004 	ldr	r3, [sp, #4]
30007e3c:	e283200c 	add	r2, r3, #12
30007e40:	e59d3004 	ldr	r3, [sp, #4]
30007e44:	e583200c 	str	r2, [r3, #12]
30007e48:	e59d3004 	ldr	r3, [sp, #4]
30007e4c:	e283200c 	add	r2, r3, #12
30007e50:	e59d3004 	ldr	r3, [sp, #4]
30007e54:	e5832010 	str	r2, [r3, #16]
	acoral_spin_init(&msgctr->spin_lock);
	return MSGCTR_SUCCED;
30007e58:	e3a03004 	mov	r3, #4
}
30007e5c:	e1a00003 	mov	r0, r3
30007e60:	e28dd008 	add	sp, sp, #8
30007e64:	e12fff1e 	bx	lr

30007e68 <acoral_msg_init>:

acoral_u32 acoral_msg_init(
		acoral_msg_t *msg, acoral_u32 id /*= 0*/, acoral_u32 n /*= 0*/, 
		acoral_u32  nTtl /*= 0*/, void* dat /*= NULL*/)
{
30007e68:	e24dd010 	sub	sp, sp, #16
30007e6c:	e58d000c 	str	r0, [sp, #12]
30007e70:	e58d1008 	str	r1, [sp, #8]
30007e74:	e58d2004 	str	r2, [sp, #4]
30007e78:	e58d3000 	str	r3, [sp]
	if (msg == NULL)
30007e7c:	e59d300c 	ldr	r3, [sp, #12]
30007e80:	e3530000 	cmp	r3, #0
30007e84:	1a000001 	bne	30007e90 <acoral_msg_init+0x28>
		return MSG_ERR_NULL;
30007e88:	e3a03007 	mov	r3, #7
30007e8c:	ea000014 	b	30007ee4 <acoral_msg_init+0x7c>

	msg->id   =  id;                /*消息标识*/
30007e90:	e59d300c 	ldr	r3, [sp, #12]
30007e94:	e59d2008 	ldr	r2, [sp, #8]
30007e98:	e583200c 	str	r2, [r3, #12]
	msg->n    =  n;                 /*消息被接收次数*/
30007e9c:	e59d300c 	ldr	r3, [sp, #12]
30007ea0:	e59d2004 	ldr	r2, [sp, #4]
30007ea4:	e5832010 	str	r2, [r3, #16]
	msg->ttl  =  nTtl;              /*消息生存周期*/
30007ea8:	e59d300c 	ldr	r3, [sp, #12]
30007eac:	e59d2000 	ldr	r2, [sp]
30007eb0:	e5832014 	str	r2, [r3, #20]
	msg->data =  dat;               /*消息指针*/
30007eb4:	e59d300c 	ldr	r3, [sp, #12]
30007eb8:	e59d2010 	ldr	r2, [sp, #16]
30007ebc:	e5832018 	str	r2, [r3, #24]
	acoral_init_list(&msg->msglist);
30007ec0:	e59d300c 	ldr	r3, [sp, #12]
30007ec4:	e2832004 	add	r2, r3, #4
30007ec8:	e59d300c 	ldr	r3, [sp, #12]
30007ecc:	e5832004 	str	r2, [r3, #4]
30007ed0:	e59d300c 	ldr	r3, [sp, #12]
30007ed4:	e2832004 	add	r2, r3, #4
30007ed8:	e59d300c 	ldr	r3, [sp, #12]
30007edc:	e5832008 	str	r2, [r3, #8]
	acoral_spin_init(&(msg->msglist.lock));
	return 0;
30007ee0:	e3a03000 	mov	r3, #0
}
30007ee4:	e1a00003 	mov	r0, r3
30007ee8:	e28dd010 	add	sp, sp, #16
30007eec:	e12fff1e 	bx	lr

30007ef0 <acoral_msg_assign>:

acoral_32 acoral_msg_assign(
		acoral_msg_t* msg, void* dat, acoral_u32 id,
		acoral_u32 nTtl, acoral_u32 n)
{
30007ef0:	e24dd010 	sub	sp, sp, #16
30007ef4:	e58d000c 	str	r0, [sp, #12]
30007ef8:	e58d1008 	str	r1, [sp, #8]
30007efc:	e58d2004 	str	r2, [sp, #4]
30007f00:	e58d3000 	str	r3, [sp]
	if (msg == NULL)
30007f04:	e59d300c 	ldr	r3, [sp, #12]
30007f08:	e3530000 	cmp	r3, #0
30007f0c:	1a000001 	bne	30007f18 <acoral_msg_assign+0x28>
		return MSG_ERR_NULL;
30007f10:	e3a03007 	mov	r3, #7
30007f14:	ea00000c 	b	30007f4c <acoral_msg_assign+0x5c>

	msg->id   =  id;                /*消息标识*/
30007f18:	e59d300c 	ldr	r3, [sp, #12]
30007f1c:	e59d2004 	ldr	r2, [sp, #4]
30007f20:	e583200c 	str	r2, [r3, #12]
	msg->n    =  n;                 /*消息被接收次数*/
30007f24:	e59d300c 	ldr	r3, [sp, #12]
30007f28:	e59d2010 	ldr	r2, [sp, #16]
30007f2c:	e5832010 	str	r2, [r3, #16]
	msg->ttl  =  nTtl;              /*消息生存周期*/
30007f30:	e59d300c 	ldr	r3, [sp, #12]
30007f34:	e59d2000 	ldr	r2, [sp]
30007f38:	e5832014 	str	r2, [r3, #20]
	msg->data =  dat;               /*消息指针*/
30007f3c:	e59d300c 	ldr	r3, [sp, #12]
30007f40:	e59d2008 	ldr	r2, [sp, #8]
30007f44:	e5832018 	str	r2, [r3, #24]
	return 0;
30007f48:	e3a03000 	mov	r3, #0
}
30007f4c:	e1a00003 	mov	r0, r3
30007f50:	e28dd010 	add	sp, sp, #16
30007f54:	e12fff1e 	bx	lr

30007f58 <acoral_msgctr_create>:
/*==================================
 *
 *   消息创建
 *==================================*/
acoral_msgctr_t*  acoral_msgctr_create (acoral_u32 *err)
{
30007f58:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007f5c:	e24dd014 	sub	sp, sp, #20
30007f60:	e58d0004 	str	r0, [sp, #4]
	acoral_msgctr_t *msgctr;

	msgctr = acoral_alloc_msgctr();
30007f64:	ebffff4b 	bl	30007c98 <acoral_alloc_msgctr>
30007f68:	e1a03000 	mov	r3, r0
30007f6c:	e58d300c 	str	r3, [sp, #12]

	if (msgctr == NULL)
30007f70:	e59d300c 	ldr	r3, [sp, #12]
30007f74:	e3530000 	cmp	r3, #0
30007f78:	1a000001 	bne	30007f84 <acoral_msgctr_create+0x2c>
		return NULL;
30007f7c:	e3a03000 	mov	r3, #0
30007f80:	ea000029 	b	3000802c <acoral_msgctr_create+0xd4>

	msgctr->name  = NULL;
30007f84:	e59d300c 	ldr	r3, [sp, #12]
30007f88:	e3a02000 	mov	r2, #0
30007f8c:	e5832004 	str	r2, [r3, #4]
	msgctr->type  = ACORAL_MSGCTR;
30007f90:	e59d300c 	ldr	r3, [sp, #12]
30007f94:	e3a02001 	mov	r2, #1
30007f98:	e5c32008 	strb	r2, [r3, #8]
	msgctr->count = 0;
30007f9c:	e59d300c 	ldr	r3, [sp, #12]
30007fa0:	e3a02000 	mov	r2, #0
30007fa4:	e5832018 	str	r2, [r3, #24]
	msgctr->wait_thread_num = 0;
30007fa8:	e59d300c 	ldr	r3, [sp, #12]
30007fac:	e3a02000 	mov	r2, #0
30007fb0:	e583201c 	str	r2, [r3, #28]

	acoral_init_list(&msgctr->msgctr_list);
30007fb4:	e59d300c 	ldr	r3, [sp, #12]
30007fb8:	e283200c 	add	r2, r3, #12
30007fbc:	e59d300c 	ldr	r3, [sp, #12]
30007fc0:	e583200c 	str	r2, [r3, #12]
30007fc4:	e59d300c 	ldr	r3, [sp, #12]
30007fc8:	e283200c 	add	r2, r3, #12
30007fcc:	e59d300c 	ldr	r3, [sp, #12]
30007fd0:	e5832010 	str	r2, [r3, #16]
	acoral_init_list(&msgctr->msglist);
30007fd4:	e59d300c 	ldr	r3, [sp, #12]
30007fd8:	e2832028 	add	r2, r3, #40	; 0x28
30007fdc:	e59d300c 	ldr	r3, [sp, #12]
30007fe0:	e5832028 	str	r2, [r3, #40]	; 0x28
30007fe4:	e59d300c 	ldr	r3, [sp, #12]
30007fe8:	e2832028 	add	r2, r3, #40	; 0x28
30007fec:	e59d300c 	ldr	r3, [sp, #12]
30007ff0:	e583202c 	str	r2, [r3, #44]	; 0x2c
	acoral_init_list(&msgctr->waiting);
30007ff4:	e59d300c 	ldr	r3, [sp, #12]
30007ff8:	e2832020 	add	r2, r3, #32
30007ffc:	e59d300c 	ldr	r3, [sp, #12]
30008000:	e5832020 	str	r2, [r3, #32]
30008004:	e59d300c 	ldr	r3, [sp, #12]
30008008:	e2832020 	add	r2, r3, #32
3000800c:	e59d300c 	ldr	r3, [sp, #12]
30008010:	e5832024 	str	r2, [r3, #36]	; 0x24
	acoral_spin_init(&(msgctr->msgctr_list.lock));
	acoral_spin_init(&(msgctr->msglist.lock));
	acoral_spin_init(&(msgctr->waiting.lock));

	acoral_spin_init(&msgctr->spin_lock);
	acoral_list_add2_tail (&msgctr->msgctr_list, &(g_msgctr_header.head));
30008014:	e59d300c 	ldr	r3, [sp, #12]
30008018:	e283300c 	add	r3, r3, #12
3000801c:	e1a00003 	mov	r0, r3
30008020:	e59f1014 	ldr	r1, [pc, #20]	; 3000803c <acoral_msgctr_create+0xe4>
30008024:	eb00086d 	bl	3000a1e0 <acoral_list_add2_tail>
	return msgctr;
30008028:	e59d300c 	ldr	r3, [sp, #12]
}
3000802c:	e1a00003 	mov	r0, r3
30008030:	e28dd014 	add	sp, sp, #20
30008034:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30008038:	e12fff1e 	bx	lr
3000803c:	3002a0b0 	.word	0x3002a0b0

30008040 <acoral_msg_create>:

acoral_msg_t* acoral_msg_create (
		acoral_u32 n, acoral_u32 *err, acoral_u32 id, 
		acoral_u32 nTtl/* = 0*/, void* dat /*= NULL*/)
{
30008040:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008044:	e24dd01c 	sub	sp, sp, #28
30008048:	e58d000c 	str	r0, [sp, #12]
3000804c:	e58d1008 	str	r1, [sp, #8]
30008050:	e58d2004 	str	r2, [sp, #4]
30008054:	e58d3000 	str	r3, [sp]
	acoral_msg_t *msg;

	msg = acoral_alloc_msg();
30008058:	ebffff16 	bl	30007cb8 <acoral_alloc_msg>
3000805c:	e1a03000 	mov	r3, r0
30008060:	e58d3014 	str	r3, [sp, #20]

	if (msg == NULL)
30008064:	e59d3014 	ldr	r3, [sp, #20]
30008068:	e3530000 	cmp	r3, #0
3000806c:	1a000001 	bne	30008078 <acoral_msg_create+0x38>
		return NULL;
30008070:	e3a03000 	mov	r3, #0
30008074:	ea000014 	b	300080cc <acoral_msg_create+0x8c>

	msg->id   =  id;                 /*消息标识*/
30008078:	e59d3014 	ldr	r3, [sp, #20]
3000807c:	e59d2004 	ldr	r2, [sp, #4]
30008080:	e583200c 	str	r2, [r3, #12]
	msg->n    =  n;                  /*消息被接收次数*/
30008084:	e59d3014 	ldr	r3, [sp, #20]
30008088:	e59d200c 	ldr	r2, [sp, #12]
3000808c:	e5832010 	str	r2, [r3, #16]
	msg->ttl  =  nTtl;               /*消息生存周期*/
30008090:	e59d3014 	ldr	r3, [sp, #20]
30008094:	e59d2000 	ldr	r2, [sp]
30008098:	e5832014 	str	r2, [r3, #20]
	msg->data =  dat;                /*消息指针*/
3000809c:	e59d3014 	ldr	r3, [sp, #20]
300080a0:	e59d2020 	ldr	r2, [sp, #32]
300080a4:	e5832018 	str	r2, [r3, #24]
	acoral_init_list(&msg->msglist);
300080a8:	e59d3014 	ldr	r3, [sp, #20]
300080ac:	e2832004 	add	r2, r3, #4
300080b0:	e59d3014 	ldr	r3, [sp, #20]
300080b4:	e5832004 	str	r2, [r3, #4]
300080b8:	e59d3014 	ldr	r3, [sp, #20]
300080bc:	e2832004 	add	r2, r3, #4
300080c0:	e59d3014 	ldr	r3, [sp, #20]
300080c4:	e5832008 	str	r2, [r3, #8]
	return msg;
300080c8:	e59d3014 	ldr	r3, [sp, #20]
}
300080cc:	e1a00003 	mov	r0, r3
300080d0:	e28dd01c 	add	sp, sp, #28
300080d4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300080d8:	e12fff1e 	bx	lr

300080dc <acoral_msg_send>:
/*===================================
 * 
 *   消息发送
 *===================================*/
acoral_u32 acoral_msg_send(acoral_msgctr_t* msgctr, acoral_msg_t* msg)
{
300080dc:	e92d4010 	push	{r4, lr}
300080e0:	e24dd010 	sub	sp, sp, #16
300080e4:	e58d0004 	str	r0, [sp, #4]
300080e8:	e58d1000 	str	r1, [sp]
	acoral_sr     cpu_sr;
	
/*	if (acoral_intr_nesting > 0)
		return MST_ERR_INTR;
*/
	HAL_ENTER_CRITICAL();
300080ec:	ebffe580 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300080f0:	e1a03000 	mov	r3, r0
300080f4:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&msgctr->spin_lock);

	if (NULL == msgctr)
300080f8:	e59d3004 	ldr	r3, [sp, #4]
300080fc:	e3530000 	cmp	r3, #0
30008100:	1a000003 	bne	30008114 <acoral_msg_send+0x38>
	{
		acoral_spin_unlock(&msgctr->spin_lock);
		HAL_EXIT_CRITICAL();
30008104:	e59d000c 	ldr	r0, [sp, #12]
30008108:	ebffe577 	bl	300016ec <HAL_INTR_RESTORE>
		return MST_ERR_NULL;
3000810c:	e3a03000 	mov	r3, #0
30008110:	ea000032 	b	300081e0 <acoral_msg_send+0x104>
	}

	if (NULL == msg)
30008114:	e59d3000 	ldr	r3, [sp]
30008118:	e3530000 	cmp	r3, #0
3000811c:	1a000003 	bne	30008130 <acoral_msg_send+0x54>
	{
		acoral_spin_unlock(&msgctr->spin_lock);
		HAL_EXIT_CRITICAL();
30008120:	e59d000c 	ldr	r0, [sp, #12]
30008124:	ebffe570 	bl	300016ec <HAL_INTR_RESTORE>
		return MSG_ERR_NULL;
30008128:	e3a03007 	mov	r3, #7
3000812c:	ea00002b 	b	300081e0 <acoral_msg_send+0x104>
	}

	/*----------------*/
	/*   消息数限制*/
	/*----------------*/
	if (ACORAL_MESSAGE_MAX_COUNT <= msgctr->count)
30008130:	e59d3004 	ldr	r3, [sp, #4]
30008134:	e5933018 	ldr	r3, [r3, #24]
30008138:	e3530009 	cmp	r3, #9
3000813c:	9a000003 	bls	30008150 <acoral_msg_send+0x74>
	{
		acoral_spin_unlock(&msgctr->spin_lock);
		HAL_EXIT_CRITICAL();
30008140:	e59d000c 	ldr	r0, [sp, #12]
30008144:	ebffe568 	bl	300016ec <HAL_INTR_RESTORE>
		return MSG_ERR_COUNT;
30008148:	e3a03003 	mov	r3, #3
3000814c:	ea000023 	b	300081e0 <acoral_msg_send+0x104>
	}

	/*----------------*/
	/*   增加消息*/
	/*----------------*/
	msgctr->count++;
30008150:	e59d3004 	ldr	r3, [sp, #4]
30008154:	e5933018 	ldr	r3, [r3, #24]
30008158:	e2832001 	add	r2, r3, #1
3000815c:	e59d3004 	ldr	r3, [sp, #4]
30008160:	e5832018 	str	r2, [r3, #24]
	msg->ttl += acoral_get_ticks();
30008164:	e59d3000 	ldr	r3, [sp]
30008168:	e5934014 	ldr	r4, [r3, #20]
3000816c:	ebfff0e4 	bl	30004504 <acoral_get_ticks>
30008170:	e1a03000 	mov	r3, r0
30008174:	e0842003 	add	r2, r4, r3
30008178:	e59d3000 	ldr	r3, [sp]
3000817c:	e5832014 	str	r2, [r3, #20]
	acoral_list_add2_tail(&msg->msglist, &msgctr->msglist);
30008180:	e59d3000 	ldr	r3, [sp]
30008184:	e2832004 	add	r2, r3, #4
30008188:	e59d3004 	ldr	r3, [sp, #4]
3000818c:	e2833028 	add	r3, r3, #40	; 0x28
30008190:	e1a00002 	mov	r0, r2
30008194:	e1a01003 	mov	r1, r3
30008198:	eb000810 	bl	3000a1e0 <acoral_list_add2_tail>

	/*----------------*/
	/*   唤醒等待*/
	/*----------------*/
	if (msgctr->wait_thread_num > 0)
3000819c:	e59d3004 	ldr	r3, [sp, #4]
300081a0:	e593301c 	ldr	r3, [r3, #28]
300081a4:	e3530000 	cmp	r3, #0
300081a8:	0a000008 	beq	300081d0 <acoral_msg_send+0xf4>
	{
		/* 此处将最高优先级唤醒*/
		wake_up_thread(&msgctr->waiting);
300081ac:	e59d3004 	ldr	r3, [sp, #4]
300081b0:	e2833020 	add	r3, r3, #32
300081b4:	e1a00003 	mov	r0, r3
300081b8:	eb000103 	bl	300085cc <wake_up_thread>
		msgctr->wait_thread_num--;
300081bc:	e59d3004 	ldr	r3, [sp, #4]
300081c0:	e593301c 	ldr	r3, [r3, #28]
300081c4:	e2432001 	sub	r2, r3, #1
300081c8:	e59d3004 	ldr	r3, [sp, #4]
300081cc:	e583201c 	str	r2, [r3, #28]
	}
	acoral_spin_unlock(&msgctr->spin_lock);
	HAL_EXIT_CRITICAL();
300081d0:	e59d000c 	ldr	r0, [sp, #12]
300081d4:	ebffe544 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sched();
300081d8:	ebffe88c 	bl	30002410 <acoral_sched>
	return MSGCTR_SUCCED;
300081dc:	e3a03004 	mov	r3, #4
}
300081e0:	e1a00003 	mov	r0, r3
300081e4:	e28dd010 	add	sp, sp, #16
300081e8:	e8bd4010 	pop	{r4, lr}
300081ec:	e12fff1e 	bx	lr

300081f0 <acoral_msg_recv>:
 *===================================*/
void* acoral_msg_recv (acoral_msgctr_t* msgctr,
						acoral_u32  id,
						acoral_time  timeout,
						acoral_u32  *err)
{
300081f0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300081f4:	e24dd02c 	sub	sp, sp, #44	; 0x2c
300081f8:	e58d000c 	str	r0, [sp, #12]
300081fc:	e58d1008 	str	r1, [sp, #8]
30008200:	e58d2004 	str	r2, [sp, #4]
30008204:	e58d3000 	str	r3, [sp]
	acoral_sr        cpu_sr;
	acoral_list_t    *p, *q;
	acoral_msg_t     *pmsg;
	acoral_thread_t  *cur;

	if (acoral_intr_nesting > 0)
30008208:	ebffe554 	bl	30001760 <hal_get_intr_nesting_comm>
3000820c:	e1a03000 	mov	r3, r0
30008210:	e3530000 	cmp	r3, #0
30008214:	da000004 	ble	3000822c <acoral_msg_recv+0x3c>
	{
		*err = MST_ERR_INTR;
30008218:	e59d3000 	ldr	r3, [sp]
3000821c:	e3a02001 	mov	r2, #1
30008220:	e5832000 	str	r2, [r3]
		return NULL;
30008224:	e3a03000 	mov	r3, #0
30008228:	ea000080 	b	30008430 <acoral_msg_recv+0x240>
	}
	if (NULL == msgctr)
3000822c:	e59d300c 	ldr	r3, [sp, #12]
30008230:	e3530000 	cmp	r3, #0
30008234:	1a000004 	bne	3000824c <acoral_msg_recv+0x5c>
	{
		*err = MST_ERR_NULL;
30008238:	e59d3000 	ldr	r3, [sp]
3000823c:	e3a02000 	mov	r2, #0
30008240:	e5832000 	str	r2, [r3]
		return NULL;
30008244:	e3a03000 	mov	r3, #0
30008248:	ea000078 	b	30008430 <acoral_msg_recv+0x240>
	}

	cur = acoral_cur_thread;
3000824c:	e59f31ec 	ldr	r3, [pc, #492]	; 30008440 <acoral_msg_recv+0x250>
30008250:	e5933000 	ldr	r3, [r3]
30008254:	e58d3024 	str	r3, [sp, #36]	; 0x24

	HAL_ENTER_CRITICAL();
30008258:	ebffe525 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000825c:	e1a03000 	mov	r3, r0
30008260:	e58d3014 	str	r3, [sp, #20]
	acoral_spin_lock(&msgctr->spin_lock);
	if(timeout>0){
30008264:	e59d3004 	ldr	r3, [sp, #4]
30008268:	e3530000 	cmp	r3, #0
3000826c:	0a000013 	beq	300082c0 <acoral_msg_recv+0xd0>
		cur->delay = TIME_TO_TICKS(timeout);
30008270:	e59d2004 	ldr	r2, [sp, #4]
30008274:	e1a03002 	mov	r3, r2
30008278:	e1a03103 	lsl	r3, r3, #2
3000827c:	e0833002 	add	r3, r3, r2
30008280:	e1a02103 	lsl	r2, r3, #2
30008284:	e0833002 	add	r3, r3, r2
30008288:	e1a03103 	lsl	r3, r3, #2
3000828c:	e1a02003 	mov	r2, r3
30008290:	e59f31ac 	ldr	r3, [pc, #428]	; 30008444 <acoral_msg_recv+0x254>
30008294:	e0831392 	umull	r1, r3, r2, r3
30008298:	e1a03323 	lsr	r3, r3, #6
3000829c:	e1a02003 	mov	r2, r3
300082a0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300082a4:	e5832040 	str	r2, [r3, #64]	; 0x40
		timeout_queue_add( cur);
300082a8:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
300082ac:	ebfff153 	bl	30004800 <timeout_queue_add>
300082b0:	ea000002 	b	300082c0 <acoral_msg_recv+0xd0>
		acoral_spin_lock(&msgctr->spin_lock);
	
		if (timeout>0&&(acoral_32)cur->delay <=0 )
			break;

	}
300082b4:	e1a00000 	nop			; (mov r0, r0)
300082b8:	ea000000 	b	300082c0 <acoral_msg_recv+0xd0>
300082bc:	e1a00000 	nop			; (mov r0, r0)
		cur->delay = TIME_TO_TICKS(timeout);
		timeout_queue_add( cur);
	}
	while(1)
	{
		p = &msgctr->msglist;
300082c0:	e59d300c 	ldr	r3, [sp, #12]
300082c4:	e2833028 	add	r3, r3, #40	; 0x28
300082c8:	e58d3018 	str	r3, [sp, #24]
		q = p->next;
300082cc:	e59d3018 	ldr	r3, [sp, #24]
300082d0:	e5933000 	ldr	r3, [r3]
300082d4:	e58d301c 	str	r3, [sp, #28]
		for( ;p != q; q = q->next)
300082d8:	ea000026 	b	30008378 <acoral_msg_recv+0x188>
		{
			pmsg = list_entry( q, acoral_msg_t, msglist);
300082dc:	e59d301c 	ldr	r3, [sp, #28]
300082e0:	e2433004 	sub	r3, r3, #4
300082e4:	e58d3020 	str	r3, [sp, #32]
			if ( (pmsg->id == id) && (pmsg->n > 0))
300082e8:	e59d3020 	ldr	r3, [sp, #32]
300082ec:	e593200c 	ldr	r2, [r3, #12]
300082f0:	e59d3008 	ldr	r3, [sp, #8]
300082f4:	e1520003 	cmp	r2, r3
300082f8:	1a00001b 	bne	3000836c <acoral_msg_recv+0x17c>
300082fc:	e59d3020 	ldr	r3, [sp, #32]
30008300:	e5933010 	ldr	r3, [r3, #16]
30008304:	e3530000 	cmp	r3, #0
30008308:	0a000017 	beq	3000836c <acoral_msg_recv+0x17c>
			{
				/*-----------------*/
				/* 有接收消息*/
				/*-----------------*/
				pmsg->n--;
3000830c:	e59d3020 	ldr	r3, [sp, #32]
30008310:	e5933010 	ldr	r3, [r3, #16]
30008314:	e2432001 	sub	r2, r3, #1
30008318:	e59d3020 	ldr	r3, [sp, #32]
3000831c:	e5832010 	str	r2, [r3, #16]
				/*-----------------*/
				/* 延时列表删除*/
				/*-----------------*/
				timeout_queue_del(cur);
30008320:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
30008324:	ebfff177 	bl	30004908 <timeout_queue_del>
				dat = pmsg->data;
30008328:	e59d3020 	ldr	r3, [sp, #32]
3000832c:	e5933018 	ldr	r3, [r3, #24]
30008330:	e58d3010 	str	r3, [sp, #16]
				acoral_list_del (q);
30008334:	e59d001c 	ldr	r0, [sp, #28]
30008338:	eb0007bb 	bl	3000a22c <acoral_list_del>
				acoral_release_res ((acoral_res_t *)pmsg);		
3000833c:	e59d3020 	ldr	r3, [sp, #32]
30008340:	e1a00003 	mov	r0, r3
30008344:	ebffecb5 	bl	30003620 <acoral_release_res>
				msgctr->count--;
30008348:	e59d300c 	ldr	r3, [sp, #12]
3000834c:	e5933018 	ldr	r3, [r3, #24]
30008350:	e2432001 	sub	r2, r3, #1
30008354:	e59d300c 	ldr	r3, [sp, #12]
30008358:	e5832018 	str	r2, [r3, #24]
				acoral_spin_unlock(&msgctr->spin_lock);
				HAL_EXIT_CRITICAL();
3000835c:	e59d0014 	ldr	r0, [sp, #20]
30008360:	ebffe4e1 	bl	300016ec <HAL_INTR_RESTORE>
				return dat;
30008364:	e59d3010 	ldr	r3, [sp, #16]
30008368:	ea000030 	b	30008430 <acoral_msg_recv+0x240>
	}
	while(1)
	{
		p = &msgctr->msglist;
		q = p->next;
		for( ;p != q; q = q->next)
3000836c:	e59d301c 	ldr	r3, [sp, #28]
30008370:	e5933000 	ldr	r3, [r3]
30008374:	e58d301c 	str	r3, [sp, #28]
30008378:	e59d2018 	ldr	r2, [sp, #24]
3000837c:	e59d301c 	ldr	r3, [sp, #28]
30008380:	e1520003 	cmp	r2, r3
30008384:	1affffd4 	bne	300082dc <acoral_msg_recv+0xec>
		}
	
		/*-----------------*/
		/*  没有接收消息*/
		/*-----------------*/
		msgctr->wait_thread_num++;
30008388:	e59d300c 	ldr	r3, [sp, #12]
3000838c:	e593301c 	ldr	r3, [r3, #28]
30008390:	e2832001 	add	r2, r3, #1
30008394:	e59d300c 	ldr	r3, [sp, #12]
30008398:	e583201c 	str	r2, [r3, #28]
		acoral_msgctr_queue_add(msgctr, cur);
3000839c:	e59d000c 	ldr	r0, [sp, #12]
300083a0:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
300083a4:	ebfffe4b 	bl	30007cd8 <acoral_msgctr_queue_add>
		acoral_unrdy_thread(cur);
300083a8:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
300083ac:	ebffe9fe 	bl	30002bac <acoral_unrdy_thread>
		acoral_spin_unlock(&msgctr->spin_lock);
		HAL_EXIT_CRITICAL();
300083b0:	e59d0014 	ldr	r0, [sp, #20]
300083b4:	ebffe4cc 	bl	300016ec <HAL_INTR_RESTORE>
		acoral_sched();
300083b8:	ebffe814 	bl	30002410 <acoral_sched>
		/*-----------------*/
		/*  看有没有超时*/
		/*-----------------*/
		HAL_ENTER_CRITICAL();
300083bc:	ebffe4cc 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300083c0:	e1a03000 	mov	r3, r0
300083c4:	e58d3014 	str	r3, [sp, #20]
		acoral_spin_lock(&msgctr->spin_lock);
	
		if (timeout>0&&(acoral_32)cur->delay <=0 )
300083c8:	e59d3004 	ldr	r3, [sp, #4]
300083cc:	e3530000 	cmp	r3, #0
300083d0:	0affffb7 	beq	300082b4 <acoral_msg_recv+0xc4>
300083d4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300083d8:	e5933040 	ldr	r3, [r3, #64]	; 0x40
300083dc:	e3530000 	cmp	r3, #0
300083e0:	caffffb5 	bgt	300082bc <acoral_msg_recv+0xcc>

	/*---------------*/
	/*  超时退出*/
	/*---------------*/
//	timeout_queue_del(cur);
	if(msgctr->wait_thread_num>0)
300083e4:	e59d300c 	ldr	r3, [sp, #12]
300083e8:	e593301c 	ldr	r3, [r3, #28]
300083ec:	e3530000 	cmp	r3, #0
300083f0:	0a000004 	beq	30008408 <acoral_msg_recv+0x218>
		msgctr->wait_thread_num--;
300083f4:	e59d300c 	ldr	r3, [sp, #12]
300083f8:	e593301c 	ldr	r3, [r3, #28]
300083fc:	e2432001 	sub	r2, r3, #1
30008400:	e59d300c 	ldr	r3, [sp, #12]
30008404:	e583201c 	str	r2, [r3, #28]
	acoral_list_del(&cur->waiting);
30008408:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3000840c:	e2833020 	add	r3, r3, #32
30008410:	e1a00003 	mov	r0, r3
30008414:	eb000784 	bl	3000a22c <acoral_list_del>
	acoral_spin_unlock(&msgctr->spin_lock);
	HAL_EXIT_CRITICAL();
30008418:	e59d0014 	ldr	r0, [sp, #20]
3000841c:	ebffe4b2 	bl	300016ec <HAL_INTR_RESTORE>
	*err = MST_ERR_TIMEOUT;
30008420:	e59d3000 	ldr	r3, [sp]
30008424:	e3a02002 	mov	r2, #2
30008428:	e5832000 	str	r2, [r3]
	return NULL;
3000842c:	e3a03000 	mov	r3, #0

}
30008430:	e1a00003 	mov	r0, r3
30008434:	e28dd02c 	add	sp, sp, #44	; 0x2c
30008438:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000843c:	e12fff1e 	bx	lr
30008440:	3002b350 	.word	0x3002b350
30008444:	10624dd3 	.word	0x10624dd3

30008448 <acoral_msgctr_del>:
/*===================================
 *
 *  消息删除
 *===================================*/
acoral_u32 acoral_msgctr_del(acoral_msgctr_t* pmsgctr, acoral_u32 flag)
{
30008448:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000844c:	e24dd01c 	sub	sp, sp, #28
30008450:	e58d0004 	str	r0, [sp, #4]
30008454:	e58d1000 	str	r1, [sp]
	acoral_list_t    *p, *q;
	acoral_thread_t  *thread;
	acoral_msg_t     *pmsg;
	
	if(NULL == pmsgctr)
30008458:	e59d3004 	ldr	r3, [sp, #4]
3000845c:	e3530000 	cmp	r3, #0
30008460:	1a000001 	bne	3000846c <acoral_msgctr_del+0x24>
		return MST_ERR_NULL;
30008464:	e3a03000 	mov	r3, #0
30008468:	ea000045 	b	30008584 <acoral_msgctr_del+0x13c>
	if (flag == MST_DEL_UNFORCE)
3000846c:	e59d3000 	ldr	r3, [sp]
30008470:	e3530000 	cmp	r3, #0
30008474:	1a00000d 	bne	300084b0 <acoral_msgctr_del+0x68>
	{
		if ((pmsgctr->count > 0) || (pmsgctr->wait_thread_num > 0))
30008478:	e59d3004 	ldr	r3, [sp, #4]
3000847c:	e5933018 	ldr	r3, [r3, #24]
30008480:	e3530000 	cmp	r3, #0
30008484:	1a000003 	bne	30008498 <acoral_msgctr_del+0x50>
30008488:	e59d3004 	ldr	r3, [sp, #4]
3000848c:	e593301c 	ldr	r3, [r3, #28]
30008490:	e3530000 	cmp	r3, #0
30008494:	0a000001 	beq	300084a0 <acoral_msgctr_del+0x58>
			return MST_ERR_UNDEF;
30008498:	e3a03003 	mov	r3, #3
3000849c:	ea000038 	b	30008584 <acoral_msgctr_del+0x13c>
		else
			acoral_release_res((acoral_res_t *)pmsgctr);
300084a0:	e59d3004 	ldr	r3, [sp, #4]
300084a4:	e1a00003 	mov	r0, r3
300084a8:	ebffec5c 	bl	30003620 <acoral_release_res>
300084ac:	ea000033 	b	30008580 <acoral_msgctr_del+0x138>
	}
	else
	{
		// 释放等待进程
		if (pmsgctr->wait_thread_num > 0)
300084b0:	e59d3004 	ldr	r3, [sp, #4]
300084b4:	e593301c 	ldr	r3, [r3, #28]
300084b8:	e3530000 	cmp	r3, #0
300084bc:	0a000012 	beq	3000850c <acoral_msgctr_del+0xc4>
		{
			p = &pmsgctr->waiting;
300084c0:	e59d3004 	ldr	r3, [sp, #4]
300084c4:	e2833020 	add	r3, r3, #32
300084c8:	e58d3008 	str	r3, [sp, #8]
			q = p->next;
300084cc:	e59d3008 	ldr	r3, [sp, #8]
300084d0:	e5933000 	ldr	r3, [r3]
300084d4:	e58d300c 	str	r3, [sp, #12]
			for(; q != p; q = q->next)
300084d8:	ea000007 	b	300084fc <acoral_msgctr_del+0xb4>
			{
				thread=list_entry( q, acoral_thread_t, waiting);
300084dc:	e59d300c 	ldr	r3, [sp, #12]
300084e0:	e2433020 	sub	r3, r3, #32
300084e4:	e58d3010 	str	r3, [sp, #16]
				//acoral_list_del  (&thread->waiting);
				acoral_rdy_thread(thread);
300084e8:	e59d0010 	ldr	r0, [sp, #16]
300084ec:	ebffe99f 	bl	30002b70 <acoral_rdy_thread>
		// 释放等待进程
		if (pmsgctr->wait_thread_num > 0)
		{
			p = &pmsgctr->waiting;
			q = p->next;
			for(; q != p; q = q->next)
300084f0:	e59d300c 	ldr	r3, [sp, #12]
300084f4:	e5933000 	ldr	r3, [r3]
300084f8:	e58d300c 	str	r3, [sp, #12]
300084fc:	e59d200c 	ldr	r2, [sp, #12]
30008500:	e59d3008 	ldr	r3, [sp, #8]
30008504:	e1520003 	cmp	r2, r3
30008508:	1afffff3 	bne	300084dc <acoral_msgctr_del+0x94>
				acoral_rdy_thread(thread);
			}
		}
		
		// 释放消息结构
		if (pmsgctr->count > 0)
3000850c:	e59d3004 	ldr	r3, [sp, #4]
30008510:	e5933018 	ldr	r3, [r3, #24]
30008514:	e3530000 	cmp	r3, #0
30008518:	0a000015 	beq	30008574 <acoral_msgctr_del+0x12c>
		{
			p = &pmsgctr->msglist;
3000851c:	e59d3004 	ldr	r3, [sp, #4]
30008520:	e2833028 	add	r3, r3, #40	; 0x28
30008524:	e58d3008 	str	r3, [sp, #8]
			q = p->next;
30008528:	e59d3008 	ldr	r3, [sp, #8]
3000852c:	e5933000 	ldr	r3, [r3]
30008530:	e58d300c 	str	r3, [sp, #12]
			for( ;p != q; q = p->next)
30008534:	ea00000a 	b	30008564 <acoral_msgctr_del+0x11c>
			{
				pmsg = list_entry( q, acoral_msg_t, msglist);
30008538:	e59d300c 	ldr	r3, [sp, #12]
3000853c:	e2433004 	sub	r3, r3, #4
30008540:	e58d3014 	str	r3, [sp, #20]
				acoral_list_del (q);
30008544:	e59d000c 	ldr	r0, [sp, #12]
30008548:	eb000737 	bl	3000a22c <acoral_list_del>
				acoral_release_res ((acoral_res_t *)pmsg);		
3000854c:	e59d3014 	ldr	r3, [sp, #20]
30008550:	e1a00003 	mov	r0, r3
30008554:	ebffec31 	bl	30003620 <acoral_release_res>
		// 释放消息结构
		if (pmsgctr->count > 0)
		{
			p = &pmsgctr->msglist;
			q = p->next;
			for( ;p != q; q = p->next)
30008558:	e59d3008 	ldr	r3, [sp, #8]
3000855c:	e5933000 	ldr	r3, [r3]
30008560:	e58d300c 	str	r3, [sp, #12]
30008564:	e59d2008 	ldr	r2, [sp, #8]
30008568:	e59d300c 	ldr	r3, [sp, #12]
3000856c:	e1520003 	cmp	r2, r3
30008570:	1afffff0 	bne	30008538 <acoral_msgctr_del+0xf0>
				acoral_release_res ((acoral_res_t *)pmsg);		
			}		
		}
		
		// 释放资源
		acoral_release_res((acoral_res_t *)pmsgctr);
30008574:	e59d3004 	ldr	r3, [sp, #4]
30008578:	e1a00003 	mov	r0, r3
3000857c:	ebffec27 	bl	30003620 <acoral_release_res>
30008580:	eaffffff 	b	30008584 <acoral_msgctr_del+0x13c>
	}
}
30008584:	e1a00003 	mov	r0, r3
30008588:	e28dd01c 	add	sp, sp, #28
3000858c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30008590:	e12fff1e 	bx	lr

30008594 <acoral_msg_del>:

acoral_u32 acoral_msg_del(acoral_msg_t* pmsg)
{
30008594:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008598:	e24dd00c 	sub	sp, sp, #12
3000859c:	e58d0004 	str	r0, [sp, #4]
	if (NULL != pmsg)
300085a0:	e59d3004 	ldr	r3, [sp, #4]
300085a4:	e3530000 	cmp	r3, #0
300085a8:	0a000002 	beq	300085b8 <acoral_msg_del+0x24>
		acoral_release_res ((acoral_res_t *)pmsg);
300085ac:	e59d3004 	ldr	r3, [sp, #4]
300085b0:	e1a00003 	mov	r0, r3
300085b4:	ebffec19 	bl	30003620 <acoral_release_res>
	return 0;
300085b8:	e3a03000 	mov	r3, #0
}
300085bc:	e1a00003 	mov	r0, r3
300085c0:	e28dd00c 	add	sp, sp, #12
300085c4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300085c8:	e12fff1e 	bx	lr

300085cc <wake_up_thread>:
/*==========================
 *
 *  唤醒最高优先等待线程
 *==========================*/
void wake_up_thread(acoral_list_t  *head)
{
300085cc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300085d0:	e24dd01c 	sub	sp, sp, #28
300085d4:	e58d0004 	str	r0, [sp, #4]
	acoral_list_t    *p, *q;
	acoral_thread_t  *thread;

	p = head;
300085d8:	e59d3004 	ldr	r3, [sp, #4]
300085dc:	e58d300c 	str	r3, [sp, #12]
	q = p->next;
300085e0:	e59d300c 	ldr	r3, [sp, #12]
300085e4:	e5933000 	ldr	r3, [r3]
300085e8:	e58d3010 	str	r3, [sp, #16]
	thread=list_entry( q, acoral_thread_t, waiting);
300085ec:	e59d3010 	ldr	r3, [sp, #16]
300085f0:	e2433020 	sub	r3, r3, #32
300085f4:	e58d3014 	str	r3, [sp, #20]
	acoral_list_del  (&thread->waiting);
300085f8:	e59d3014 	ldr	r3, [sp, #20]
300085fc:	e2833020 	add	r3, r3, #32
30008600:	e1a00003 	mov	r0, r3
30008604:	eb000708 	bl	3000a22c <acoral_list_del>
	acoral_rdy_thread(thread);
30008608:	e59d0014 	ldr	r0, [sp, #20]
3000860c:	ebffe957 	bl	30002b70 <acoral_rdy_thread>
}
30008610:	e28dd01c 	add	sp, sp, #28
30008614:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30008618:	e12fff1e 	bx	lr

3000861c <acoral_print_all_msg>:
/*======================*/
/**/
/*  输出事件容器上全部消息*/
/*======================*/
void acoral_print_all_msg(acoral_msgctr_t* msgctr)
{
3000861c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008620:	e24dd01c 	sub	sp, sp, #28
30008624:	e58d0004 	str	r0, [sp, #4]
	acoral_list_t *p, *q;
	acoral_msg_t  *pmsg;

	acoral_doMsgTtl_checked = DO_CHECKED_TRUE;
30008628:	e59f3074 	ldr	r3, [pc, #116]	; 300086a4 <acoral_print_all_msg+0x88>
3000862c:	e3a02000 	mov	r2, #0
30008630:	e5832000 	str	r2, [r3]

	p = &msgctr->msglist;
30008634:	e59d3004 	ldr	r3, [sp, #4]
30008638:	e2833028 	add	r3, r3, #40	; 0x28
3000863c:	e58d300c 	str	r3, [sp, #12]
	q = p->next;
30008640:	e59d300c 	ldr	r3, [sp, #12]
30008644:	e5933000 	ldr	r3, [r3]
30008648:	e58d3010 	str	r3, [sp, #16]
	for( ;p != q; q = q->next)
3000864c:	ea00000a 	b	3000867c <acoral_print_all_msg+0x60>
	{
		pmsg = list_entry( q, acoral_msg_t, msglist);
30008650:	e59d3010 	ldr	r3, [sp, #16]
30008654:	e2433004 	sub	r3, r3, #4
30008658:	e58d3014 	str	r3, [sp, #20]
		acoral_print ("\nid = %d", pmsg->id);
3000865c:	e59d3014 	ldr	r3, [sp, #20]
30008660:	e593300c 	ldr	r3, [r3, #12]
30008664:	e59f003c 	ldr	r0, [pc, #60]	; 300086a8 <acoral_print_all_msg+0x8c>
30008668:	e1a01003 	mov	r1, r3
3000866c:	eb000b6d 	bl	3000b428 <acoral_print>

	acoral_doMsgTtl_checked = DO_CHECKED_TRUE;

	p = &msgctr->msglist;
	q = p->next;
	for( ;p != q; q = q->next)
30008670:	e59d3010 	ldr	r3, [sp, #16]
30008674:	e5933000 	ldr	r3, [r3]
30008678:	e58d3010 	str	r3, [sp, #16]
3000867c:	e59d200c 	ldr	r2, [sp, #12]
30008680:	e59d3010 	ldr	r3, [sp, #16]
30008684:	e1520003 	cmp	r2, r3
30008688:	1afffff0 	bne	30008650 <acoral_print_all_msg+0x34>
	{
		pmsg = list_entry( q, acoral_msg_t, msglist);
		acoral_print ("\nid = %d", pmsg->id);
	}

	acoral_doMsgTtl_checked = DO_CHECKED_FALSE;
3000868c:	e59f3010 	ldr	r3, [pc, #16]	; 300086a4 <acoral_print_all_msg+0x88>
30008690:	e3a02001 	mov	r2, #1
30008694:	e5832000 	str	r2, [r3]

}
30008698:	e28dd01c 	add	sp, sp, #28
3000869c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300086a0:	e12fff1e 	bx	lr
300086a4:	30026894 	.word	0x30026894
300086a8:	30026254 	.word	0x30026254

300086ac <acoral_print_waitThreadsNum>:
/*======================*/
/**/
/*  输出等待任务数目*/
/*======================*/
void acoral_print_waitThreadsNum(acoral_msgctr_t* msgctr)
{
300086ac:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300086b0:	e24dd00c 	sub	sp, sp, #12
300086b4:	e58d0004 	str	r0, [sp, #4]
	acoral_print("\n wait threads mum = %d", msgctr->wait_thread_num);
300086b8:	e59d3004 	ldr	r3, [sp, #4]
300086bc:	e593301c 	ldr	r3, [r3, #28]
300086c0:	e59f0010 	ldr	r0, [pc, #16]	; 300086d8 <acoral_print_waitThreadsNum+0x2c>
300086c4:	e1a01003 	mov	r1, r3
300086c8:	eb000b56 	bl	3000b428 <acoral_print>
}
300086cc:	e28dd00c 	add	sp, sp, #12
300086d0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300086d4:	e12fff1e 	bx	lr
300086d8:	30026260 	.word	0x30026260

300086dc <rm_policy_thread_init>:
struct{
	acoral_u32 num;
	acoral_fl sum;
}left[HAL_MAX_CPU];

acoral_id rm_policy_thread_init(acoral_thread_t *thread,void (*route)(void *args),void *args,void *data){
300086dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300086e0:	e24dd024 	sub	sp, sp, #36	; 0x24
300086e4:	e58d000c 	str	r0, [sp, #12]
300086e8:	e58d1008 	str	r1, [sp, #8]
300086ec:	e58d2004 	str	r2, [sp, #4]
300086f0:	e58d3000 	str	r3, [sp]
	acoral_sr cpu_sr;
	acoral_rm_policy_data_t *policy_data;
	rm_policy_data_t *private_data;
	policy_data=(acoral_rm_policy_data_t *)data;
300086f4:	e59d3000 	ldr	r3, [sp]
300086f8:	e58d3018 	str	r3, [sp, #24]
	private_data=(rm_policy_data_t *)acoral_malloc2(sizeof(rm_policy_data_t));
300086fc:	e3a0001c 	mov	r0, #28
30008700:	ebfff9bf 	bl	30006e04 <v_malloc>
30008704:	e1a03000 	mov	r3, r0
30008708:	e58d301c 	str	r3, [sp, #28]
	if(private_data==NULL){
3000870c:	e59d301c 	ldr	r3, [sp, #28]
30008710:	e3530000 	cmp	r3, #0
30008714:	1a00000e 	bne	30008754 <rm_policy_thread_init+0x78>
		acoral_printerr("No level2 mem space for private_data:%s\n",thread->name);
30008718:	e59d300c 	ldr	r3, [sp, #12]
3000871c:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30008720:	e59f00f8 	ldr	r0, [pc, #248]	; 30008820 <rm_policy_thread_init+0x144>
30008724:	e1a01003 	mov	r1, r3
30008728:	eb000b3e 	bl	3000b428 <acoral_print>
		HAL_ENTER_CRITICAL();
3000872c:	ebffe3f0 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30008730:	e1a03000 	mov	r3, r0
30008734:	e58d3014 	str	r3, [sp, #20]
		acoral_release_res((acoral_res_t *)thread);
30008738:	e59d300c 	ldr	r3, [sp, #12]
3000873c:	e1a00003 	mov	r0, r3
30008740:	ebffebb6 	bl	30003620 <acoral_release_res>
		HAL_EXIT_CRITICAL();
30008744:	e59d0014 	ldr	r0, [sp, #20]
30008748:	ebffe3e7 	bl	300016ec <HAL_INTR_RESTORE>
		return -1;
3000874c:	e3e03000 	mvn	r3, #0
30008750:	ea00002e 	b	30008810 <rm_policy_thread_init+0x134>
	}
	private_data->t=100*policy_data->t;
30008754:	e59d3018 	ldr	r3, [sp, #24]
30008758:	e5932000 	ldr	r2, [r3]
3000875c:	e1a03002 	mov	r3, r2
30008760:	e1a03103 	lsl	r3, r3, #2
30008764:	e0833002 	add	r3, r3, r2
30008768:	e1a02103 	lsl	r2, r3, #2
3000876c:	e0833002 	add	r3, r3, r2
30008770:	e1a03103 	lsl	r3, r3, #2
30008774:	e1a02003 	mov	r2, r3
30008778:	e59d301c 	ldr	r3, [sp, #28]
3000877c:	e583200c 	str	r2, [r3, #12]
	private_data->lt=private_data->t;
30008780:	e59d301c 	ldr	r3, [sp, #28]
30008784:	e593200c 	ldr	r2, [r3, #12]
30008788:	e59d301c 	ldr	r3, [sp, #28]
3000878c:	e5832010 	str	r2, [r3, #16]
	private_data->e=100*policy_data->e;
30008790:	e59d3018 	ldr	r3, [sp, #24]
30008794:	e5932004 	ldr	r2, [r3, #4]
30008798:	e1a03002 	mov	r3, r2
3000879c:	e1a03103 	lsl	r3, r3, #2
300087a0:	e0833002 	add	r3, r3, r2
300087a4:	e1a02103 	lsl	r2, r3, #2
300087a8:	e0833002 	add	r3, r3, r2
300087ac:	e1a03103 	lsl	r3, r3, #2
300087b0:	e1a02003 	mov	r2, r3
300087b4:	e59d301c 	ldr	r3, [sp, #28]
300087b8:	e5832014 	str	r2, [r3, #20]
	private_data->le=private_data->e;
300087bc:	e59d301c 	ldr	r3, [sp, #28]
300087c0:	e5932014 	ldr	r2, [r3, #20]
300087c4:	e59d301c 	ldr	r3, [sp, #28]
300087c8:	e5832018 	str	r2, [r3, #24]
	private_data->period_data.args=args;
300087cc:	e59d301c 	ldr	r3, [sp, #28]
300087d0:	e59d2004 	ldr	r2, [sp, #4]
300087d4:	e5832008 	str	r2, [r3, #8]
	private_data->period_data.route=route;
300087d8:	e59d301c 	ldr	r3, [sp, #28]
300087dc:	e59d2008 	ldr	r2, [sp, #8]
300087e0:	e5832004 	str	r2, [r3, #4]
	private_data->period_data.time=private_data->t;
300087e4:	e59d301c 	ldr	r3, [sp, #28]
300087e8:	e593200c 	ldr	r2, [r3, #12]
300087ec:	e59d301c 	ldr	r3, [sp, #28]
300087f0:	e5832000 	str	r2, [r3]
	thread->private_data=private_data;
300087f4:	e59d300c 	ldr	r3, [sp, #12]
300087f8:	e59d201c 	ldr	r2, [sp, #28]
300087fc:	e5832050 	str	r2, [r3, #80]	; 0x50
	rm_queue_ascend_add(thread);
30008800:	e59d000c 	ldr	r0, [sp, #12]
30008804:	eb000021 	bl	30008890 <rm_queue_ascend_add>
	return thread->res.id;
30008808:	e59d300c 	ldr	r3, [sp, #12]
3000880c:	e5933000 	ldr	r3, [r3]
}
30008810:	e1a00003 	mov	r0, r3
30008814:	e28dd024 	add	sp, sp, #36	; 0x24
30008818:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000881c:	e12fff1e 	bx	lr
30008820:	30026278 	.word	0x30026278

30008824 <rm_policy_thread_release>:

void rm_policy_thread_release(acoral_thread_t *thread){
30008824:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008828:	e24dd00c 	sub	sp, sp, #12
3000882c:	e58d0004 	str	r0, [sp, #4]
	acoral_printk("Release Rm thread\n");
	acoral_free2(thread->private_data);	
30008830:	e59d3004 	ldr	r3, [sp, #4]
30008834:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30008838:	e1a00003 	mov	r0, r3
3000883c:	ebfff985 	bl	30006e58 <v_free>
}
30008840:	e28dd00c 	add	sp, sp, #12
30008844:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30008848:	e12fff1e 	bx	lr

3000884c <rm_discard_thread>:

void rm_discard_thread(acoral_thread_t *thread){
3000884c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008850:	e24dd00c 	sub	sp, sp, #12
30008854:	e58d0004 	str	r0, [sp, #4]
	acoral_list_del(&thread->ready);
30008858:	e59d3004 	ldr	r3, [sp, #4]
3000885c:	e2833010 	add	r3, r3, #16
30008860:	e1a00003 	mov	r0, r3
30008864:	eb000670 	bl	3000a22c <acoral_list_del>
	acoral_free2(thread->private_data);	
30008868:	e59d3004 	ldr	r3, [sp, #4]
3000886c:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30008870:	e1a00003 	mov	r0, r3
30008874:	ebfff977 	bl	30006e58 <v_free>
	acoral_release_res((acoral_res_t *)thread);
30008878:	e59d3004 	ldr	r3, [sp, #4]
3000887c:	e1a00003 	mov	r0, r3
30008880:	ebffeb66 	bl	30003620 <acoral_release_res>
}
30008884:	e28dd00c 	add	sp, sp, #12
30008888:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000888c:	e12fff1e 	bx	lr

30008890 <rm_queue_ascend_add>:

void rm_queue_ascend_add(acoral_thread_t *new){
30008890:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008894:	e24dd024 	sub	sp, sp, #36	; 0x24
30008898:	e58d0004 	str	r0, [sp, #4]
      rm_policy_data_t *new_data;
      rm_policy_data_t *old_data;
      acoral_thread_t * thread;
      acoral_list_t *tmp,*head;
      head=&rm_queue->head;
3000889c:	e59f309c 	ldr	r3, [pc, #156]	; 30008940 <rm_queue_ascend_add+0xb0>
300088a0:	e5933000 	ldr	r3, [r3]
300088a4:	e58d301c 	str	r3, [sp, #28]
      new_data=new->private_data; 
300088a8:	e59d3004 	ldr	r3, [sp, #4]
300088ac:	e5933050 	ldr	r3, [r3, #80]	; 0x50
300088b0:	e58d300c 	str	r3, [sp, #12]
      for (tmp=head->next;tmp!=head; tmp=tmp->next){
300088b4:	e59d301c 	ldr	r3, [sp, #28]
300088b8:	e5933000 	ldr	r3, [r3]
300088bc:	e58d3018 	str	r3, [sp, #24]
300088c0:	ea00000e 	b	30008900 <rm_queue_ascend_add+0x70>
		thread =list_entry(tmp, acoral_thread_t,ready);
300088c4:	e59d3018 	ldr	r3, [sp, #24]
300088c8:	e2433010 	sub	r3, r3, #16
300088cc:	e58d3014 	str	r3, [sp, #20]
		old_data=thread->private_data;
300088d0:	e59d3014 	ldr	r3, [sp, #20]
300088d4:	e5933050 	ldr	r3, [r3, #80]	; 0x50
300088d8:	e58d3010 	str	r3, [sp, #16]
      	        if(old_data->lt>new_data->lt)
300088dc:	e59d3010 	ldr	r3, [sp, #16]
300088e0:	e5932010 	ldr	r2, [r3, #16]
300088e4:	e59d300c 	ldr	r3, [sp, #12]
300088e8:	e5933010 	ldr	r3, [r3, #16]
300088ec:	e1520003 	cmp	r2, r3
300088f0:	8a000007 	bhi	30008914 <rm_queue_ascend_add+0x84>
      rm_policy_data_t *old_data;
      acoral_thread_t * thread;
      acoral_list_t *tmp,*head;
      head=&rm_queue->head;
      new_data=new->private_data; 
      for (tmp=head->next;tmp!=head; tmp=tmp->next){
300088f4:	e59d3018 	ldr	r3, [sp, #24]
300088f8:	e5933000 	ldr	r3, [r3]
300088fc:	e58d3018 	str	r3, [sp, #24]
30008900:	e59d2018 	ldr	r2, [sp, #24]
30008904:	e59d301c 	ldr	r3, [sp, #28]
30008908:	e1520003 	cmp	r2, r3
3000890c:	1affffec 	bne	300088c4 <rm_queue_ascend_add+0x34>
30008910:	ea000000 	b	30008918 <rm_queue_ascend_add+0x88>
		thread =list_entry(tmp, acoral_thread_t,ready);
		old_data=thread->private_data;
      	        if(old_data->lt>new_data->lt)
			break;		  
30008914:	e1a00000 	nop			; (mov r0, r0)
     }
     acoral_list_add(&new->ready,tmp->prev);
30008918:	e59d3004 	ldr	r3, [sp, #4]
3000891c:	e2832010 	add	r2, r3, #16
30008920:	e59d3018 	ldr	r3, [sp, #24]
30008924:	e5933004 	ldr	r3, [r3, #4]
30008928:	e1a00002 	mov	r0, r2
3000892c:	e1a01003 	mov	r1, r3
30008930:	eb000617 	bl	3000a194 <acoral_list_add>
}
30008934:	e28dd024 	add	sp, sp, #36	; 0x24
30008938:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000893c:	e12fff1e 	bx	lr
30008940:	3002689c 	.word	0x3002689c

30008944 <rm_check>:

/*多核可调度性判断*/
acoral_u8 rm_check(acoral_thread_t *thread,acoral_u32 cpu){
30008944:	e92d4010 	push	{r4, lr}
30008948:	e24dd010 	sub	sp, sp, #16
3000894c:	e58d0004 	str	r0, [sp, #4]
30008950:	e58d1000 	str	r1, [sp]
	rm_policy_data_t *data;
	acoral_fl tmp;
	data=thread->private_data;
30008954:	e59d3004 	ldr	r3, [sp, #4]
30008958:	e5933050 	ldr	r3, [r3, #80]	; 0x50
3000895c:	e58d3008 	str	r3, [sp, #8]
	tmp=(acoral_fl)data->e/(acoral_fl)data->t;		
30008960:	e59d3008 	ldr	r3, [sp, #8]
30008964:	e5933014 	ldr	r3, [r3, #20]
30008968:	e1a00003 	mov	r0, r3
3000896c:	eb0073f6 	bl	3002594c <__aeabi_ui2f>
30008970:	e1a04000 	mov	r4, r0
30008974:	e59d3008 	ldr	r3, [sp, #8]
30008978:	e593300c 	ldr	r3, [r3, #12]
3000897c:	e1a00003 	mov	r0, r3
30008980:	eb0073f1 	bl	3002594c <__aeabi_ui2f>
30008984:	e1a03000 	mov	r3, r0
30008988:	e1a00004 	mov	r0, r4
3000898c:	e1a01003 	mov	r1, r3
30008990:	eb00748c 	bl	30025bc8 <__aeabi_fdiv>
30008994:	e1a03000 	mov	r3, r0
30008998:	e58d300c 	str	r3, [sp, #12]
	if(left[cpu].sum+tmp<right[left[cpu].num]){
3000899c:	e59d1000 	ldr	r1, [sp]
300089a0:	e59f20ec 	ldr	r2, [pc, #236]	; 30008a94 <rm_check+0x150>
300089a4:	e3a03004 	mov	r3, #4
300089a8:	e1a01181 	lsl	r1, r1, #3
300089ac:	e0812002 	add	r2, r1, r2
300089b0:	e0823003 	add	r3, r2, r3
300089b4:	e5933000 	ldr	r3, [r3]
300089b8:	e1a00003 	mov	r0, r3
300089bc:	e59d100c 	ldr	r1, [sp, #12]
300089c0:	eb007372 	bl	30025790 <__addsf3>
300089c4:	e1a03000 	mov	r3, r0
300089c8:	e1a02003 	mov	r2, r3
300089cc:	e59d1000 	ldr	r1, [sp]
300089d0:	e59f30bc 	ldr	r3, [pc, #188]	; 30008a94 <rm_check+0x150>
300089d4:	e7931181 	ldr	r1, [r3, r1, lsl #3]
300089d8:	e59f30b8 	ldr	r3, [pc, #184]	; 30008a98 <rm_check+0x154>
300089dc:	e7933101 	ldr	r3, [r3, r1, lsl #2]
300089e0:	e3a01000 	mov	r1, #0
300089e4:	e1a04001 	mov	r4, r1
300089e8:	e1a00002 	mov	r0, r2
300089ec:	e1a01003 	mov	r1, r3
300089f0:	eb0074f9 	bl	30025ddc <__aeabi_fcmplt>
300089f4:	e1a03000 	mov	r3, r0
300089f8:	e3530000 	cmp	r3, #0
300089fc:	0a000001 	beq	30008a08 <rm_check+0xc4>
30008a00:	e3a03001 	mov	r3, #1
30008a04:	e1a04003 	mov	r4, r3
30008a08:	e20430ff 	and	r3, r4, #255	; 0xff
30008a0c:	e3530000 	cmp	r3, #0
30008a10:	0a00001a 	beq	30008a80 <rm_check+0x13c>
		left[cpu].sum+=tmp;
30008a14:	e59d4000 	ldr	r4, [sp]
30008a18:	e59d1000 	ldr	r1, [sp]
30008a1c:	e59f2070 	ldr	r2, [pc, #112]	; 30008a94 <rm_check+0x150>
30008a20:	e3a03004 	mov	r3, #4
30008a24:	e1a01181 	lsl	r1, r1, #3
30008a28:	e0812002 	add	r2, r1, r2
30008a2c:	e0823003 	add	r3, r2, r3
30008a30:	e5933000 	ldr	r3, [r3]
30008a34:	e1a00003 	mov	r0, r3
30008a38:	e59d100c 	ldr	r1, [sp, #12]
30008a3c:	eb007353 	bl	30025790 <__addsf3>
30008a40:	e1a03000 	mov	r3, r0
30008a44:	e1a02003 	mov	r2, r3
30008a48:	e59f1044 	ldr	r1, [pc, #68]	; 30008a94 <rm_check+0x150>
30008a4c:	e3a03004 	mov	r3, #4
30008a50:	e1a00184 	lsl	r0, r4, #3
30008a54:	e0801001 	add	r1, r0, r1
30008a58:	e0813003 	add	r3, r1, r3
30008a5c:	e5832000 	str	r2, [r3]
		left[cpu].num++;
30008a60:	e59d3000 	ldr	r3, [sp]
30008a64:	e59f2028 	ldr	r2, [pc, #40]	; 30008a94 <rm_check+0x150>
30008a68:	e7922183 	ldr	r2, [r2, r3, lsl #3]
30008a6c:	e2821001 	add	r1, r2, #1
30008a70:	e59f201c 	ldr	r2, [pc, #28]	; 30008a94 <rm_check+0x150>
30008a74:	e7821183 	str	r1, [r2, r3, lsl #3]
		return 1;
30008a78:	e3a03001 	mov	r3, #1
30008a7c:	ea000000 	b	30008a84 <rm_check+0x140>
	}
	return 0;
30008a80:	e3a03000 	mov	r3, #0
}
30008a84:	e1a00003 	mov	r0, r3
30008a88:	e28dd010 	add	sp, sp, #16
30008a8c:	e8bd4010 	pop	{r4, lr}
30008a90:	e12fff1e 	bx	lr
30008a94:	3002a830 	.word	0x3002a830
30008a98:	300268a0 	.word	0x300268a0

30008a9c <rm_thread_dispatch>:

void rm_thread_dispatch(){
30008a9c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008aa0:	e24dd01c 	sub	sp, sp, #28
	acoral_sr cpu_sr;
	acoral_u32 i;
	acoral_thread_t * thread;
	acoral_list_t *tmp,*head;
	HAL_ENTER_CRITICAL();
30008aa4:	ebffe312 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30008aa8:	e1a03000 	mov	r3, r0
30008aac:	e58d3004 	str	r3, [sp, #4]
	head=&rm_queue->head;
30008ab0:	e59f3120 	ldr	r3, [pc, #288]	; 30008bd8 <rm_thread_dispatch+0x13c>
30008ab4:	e5933000 	ldr	r3, [r3]
30008ab8:	e58d3014 	str	r3, [sp, #20]
	for (tmp=head->next;tmp!=head;){
30008abc:	e59d3014 	ldr	r3, [sp, #20]
30008ac0:	e5933000 	ldr	r3, [r3]
30008ac4:	e58d3010 	str	r3, [sp, #16]
30008ac8:	ea000039 	b	30008bb4 <rm_thread_dispatch+0x118>
		thread =list_entry(tmp, acoral_thread_t,ready);
30008acc:	e59d3010 	ldr	r3, [sp, #16]
30008ad0:	e2433010 	sub	r3, r3, #16
30008ad4:	e58d300c 	str	r3, [sp, #12]
		tmp=tmp->next;
30008ad8:	e59d3010 	ldr	r3, [sp, #16]
30008adc:	e5933000 	ldr	r3, [r3]
30008ae0:	e58d3010 	str	r3, [sp, #16]
		if(prio>=ACORAL_HARD_RT_PRIO_MAX){
30008ae4:	e59f30f0 	ldr	r3, [pc, #240]	; 30008bdc <rm_thread_dispatch+0x140>
30008ae8:	e5933000 	ldr	r3, [r3]
30008aec:	e3530001 	cmp	r3, #1
30008af0:	9a000007 	bls	30008b14 <rm_thread_dispatch+0x78>
				acoral_printerr("RM thread %s Err,Prio is not enough\n",thread->name);
30008af4:	e59d300c 	ldr	r3, [sp, #12]
30008af8:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30008afc:	e59f00dc 	ldr	r0, [pc, #220]	; 30008be0 <rm_thread_dispatch+0x144>
30008b00:	e1a01003 	mov	r1, r3
30008b04:	eb000a47 	bl	3000b428 <acoral_print>
				/*这个线程还没初始化，包括它的stack,lock等,原来是用acoral_release_thread导致很多错误*/
				rm_discard_thread(thread);
30008b08:	e59d000c 	ldr	r0, [sp, #12]
30008b0c:	ebffff4e 	bl	3000884c <rm_discard_thread>
30008b10:	ea000027 	b	30008bb4 <rm_thread_dispatch+0x118>
		}else{
			thread->prio=prio;
30008b14:	e59f30c0 	ldr	r3, [pc, #192]	; 30008bdc <rm_thread_dispatch+0x140>
30008b18:	e5933000 	ldr	r3, [r3]
30008b1c:	e20320ff 	and	r2, r3, #255	; 0xff
30008b20:	e59d300c 	ldr	r3, [sp, #12]
30008b24:	e5c32005 	strb	r2, [r3, #5]
			prio++;
30008b28:	e59f30ac 	ldr	r3, [pc, #172]	; 30008bdc <rm_thread_dispatch+0x140>
30008b2c:	e5933000 	ldr	r3, [r3]
30008b30:	e2832001 	add	r2, r3, #1
30008b34:	e59f30a0 	ldr	r3, [pc, #160]	; 30008bdc <rm_thread_dispatch+0x140>
30008b38:	e5832000 	str	r2, [r3]
			for(i=0;i<HAL_MAX_CPU;i++){
30008b3c:	e3a03000 	mov	r3, #0
30008b40:	e58d3008 	str	r3, [sp, #8]
30008b44:	ea00000d 	b	30008b80 <rm_thread_dispatch+0xe4>
				if(rm_check(thread,i)){
30008b48:	e59d000c 	ldr	r0, [sp, #12]
30008b4c:	e59d1008 	ldr	r1, [sp, #8]
30008b50:	ebffff7b 	bl	30008944 <rm_check>
30008b54:	e1a03000 	mov	r3, r0
30008b58:	e3530000 	cmp	r3, #0
30008b5c:	0a000004 	beq	30008b74 <rm_thread_dispatch+0xd8>
					thread->cpu=i;
30008b60:	e59d3008 	ldr	r3, [sp, #8]
30008b64:	e20320ff 	and	r2, r3, #255	; 0xff
30008b68:	e59d300c 	ldr	r3, [sp, #12]
30008b6c:	e5c32006 	strb	r2, [r3, #6]
					break;
30008b70:	ea000005 	b	30008b8c <rm_thread_dispatch+0xf0>
				/*这个线程还没初始化，包括它的stack,lock等,原来是用acoral_release_thread导致很多错误*/
				rm_discard_thread(thread);
		}else{
			thread->prio=prio;
			prio++;
			for(i=0;i<HAL_MAX_CPU;i++){
30008b74:	e59d3008 	ldr	r3, [sp, #8]
30008b78:	e2833001 	add	r3, r3, #1
30008b7c:	e58d3008 	str	r3, [sp, #8]
30008b80:	e59d3008 	ldr	r3, [sp, #8]
30008b84:	e3530000 	cmp	r3, #0
30008b88:	0affffee 	beq	30008b48 <rm_thread_dispatch+0xac>
				if(rm_check(thread,i)){
					thread->cpu=i;
					break;
				}
			}
			if(i==HAL_MAX_CPU){
30008b8c:	e59d3008 	ldr	r3, [sp, #8]
30008b90:	e3530001 	cmp	r3, #1
30008b94:	1a000006 	bne	30008bb4 <rm_thread_dispatch+0x118>
				acoral_printerr("Discard thread %s\n",thread->name);
30008b98:	e59d300c 	ldr	r3, [sp, #12]
30008b9c:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30008ba0:	e59f003c 	ldr	r0, [pc, #60]	; 30008be4 <rm_thread_dispatch+0x148>
30008ba4:	e1a01003 	mov	r1, r3
30008ba8:	eb000a1e 	bl	3000b428 <acoral_print>
				/*这个线程还没初始化，包括它的stack,lock等*/
				rm_discard_thread(thread);
30008bac:	e59d000c 	ldr	r0, [sp, #12]
30008bb0:	ebffff25 	bl	3000884c <rm_discard_thread>
	acoral_u32 i;
	acoral_thread_t * thread;
	acoral_list_t *tmp,*head;
	HAL_ENTER_CRITICAL();
	head=&rm_queue->head;
	for (tmp=head->next;tmp!=head;){
30008bb4:	e59d2010 	ldr	r2, [sp, #16]
30008bb8:	e59d3014 	ldr	r3, [sp, #20]
30008bbc:	e1520003 	cmp	r2, r3
30008bc0:	1affffc1 	bne	30008acc <rm_thread_dispatch+0x30>
				/*这个线程还没初始化，包括它的stack,lock等*/
				rm_discard_thread(thread);
			}
		} 
	}
	HAL_EXIT_CRITICAL();
30008bc4:	e59d0004 	ldr	r0, [sp, #4]
30008bc8:	ebffe2c7 	bl	300016ec <HAL_INTR_RESTORE>
	return;
}
30008bcc:	e28dd01c 	add	sp, sp, #28
30008bd0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30008bd4:	e12fff1e 	bx	lr
30008bd8:	3002689c 	.word	0x3002689c
30008bdc:	30026898 	.word	0x30026898
30008be0:	300262a4 	.word	0x300262a4
30008be4:	300262cc 	.word	0x300262cc

30008be8 <rm_init>:

void rm_init(){
30008be8:	e24dd008 	sub	sp, sp, #8
      acoral_u32 i;
      acoral_init_list(&rm_queue->head);
30008bec:	e59f307c 	ldr	r3, [pc, #124]	; 30008c70 <rm_init+0x88>
30008bf0:	e5933000 	ldr	r3, [r3]
30008bf4:	e59f2074 	ldr	r2, [pc, #116]	; 30008c70 <rm_init+0x88>
30008bf8:	e5922000 	ldr	r2, [r2]
30008bfc:	e5832000 	str	r2, [r3]
30008c00:	e59f3068 	ldr	r3, [pc, #104]	; 30008c70 <rm_init+0x88>
30008c04:	e5933000 	ldr	r3, [r3]
30008c08:	e59f2060 	ldr	r2, [pc, #96]	; 30008c70 <rm_init+0x88>
30008c0c:	e5922000 	ldr	r2, [r2]
30008c10:	e5832004 	str	r2, [r3, #4]
      for(i=0;i<HAL_MAX_CPU;i++){
30008c14:	e3a03000 	mov	r3, #0
30008c18:	e58d3004 	str	r3, [sp, #4]
30008c1c:	ea00000e 	b	30008c5c <rm_init+0x74>
		left[i].sum=0;
30008c20:	e59d1004 	ldr	r1, [sp, #4]
30008c24:	e59f2048 	ldr	r2, [pc, #72]	; 30008c74 <rm_init+0x8c>
30008c28:	e3a03004 	mov	r3, #4
30008c2c:	e1a01181 	lsl	r1, r1, #3
30008c30:	e0812002 	add	r2, r1, r2
30008c34:	e0823003 	add	r3, r2, r3
30008c38:	e59f2038 	ldr	r2, [pc, #56]	; 30008c78 <rm_init+0x90>
30008c3c:	e5832000 	str	r2, [r3]
		left[i].num=0;
30008c40:	e59d2004 	ldr	r2, [sp, #4]
30008c44:	e59f3028 	ldr	r3, [pc, #40]	; 30008c74 <rm_init+0x8c>
30008c48:	e3a01000 	mov	r1, #0
30008c4c:	e7831182 	str	r1, [r3, r2, lsl #3]
}

void rm_init(){
      acoral_u32 i;
      acoral_init_list(&rm_queue->head);
      for(i=0;i<HAL_MAX_CPU;i++){
30008c50:	e59d3004 	ldr	r3, [sp, #4]
30008c54:	e2833001 	add	r3, r3, #1
30008c58:	e58d3004 	str	r3, [sp, #4]
30008c5c:	e59d3004 	ldr	r3, [sp, #4]
30008c60:	e3530000 	cmp	r3, #0
30008c64:	0affffed 	beq	30008c20 <rm_init+0x38>
		left[i].sum=0;
		left[i].num=0;
      }
}
30008c68:	e28dd008 	add	sp, sp, #8
30008c6c:	e12fff1e 	bx	lr
30008c70:	3002689c 	.word	0x3002689c
30008c74:	3002a830 	.word	0x3002a830
30008c78:	00000000 	.word	0x00000000

30008c7c <rm_policy_init>:

acoral_sched_policy_t rm_policy;
void rm_policy_init(){
30008c7c:	e92d4008 	push	{r3, lr}
	rm_init();
30008c80:	ebffffd8 	bl	30008be8 <rm_init>
	rm_policy.type=ACORAL_SCHED_POLICY_RM;
30008c84:	e59f3044 	ldr	r3, [pc, #68]	; 30008cd0 <rm_policy_init+0x54>
30008c88:	e3a02017 	mov	r2, #23
30008c8c:	e5c32008 	strb	r2, [r3, #8]
	rm_policy.policy_thread_init=rm_policy_thread_init;
30008c90:	e59f3038 	ldr	r3, [pc, #56]	; 30008cd0 <rm_policy_init+0x54>
30008c94:	e59f2038 	ldr	r2, [pc, #56]	; 30008cd4 <rm_policy_init+0x58>
30008c98:	e583200c 	str	r2, [r3, #12]
	rm_policy.policy_thread_release=rm_policy_thread_release;
30008c9c:	e59f302c 	ldr	r3, [pc, #44]	; 30008cd0 <rm_policy_init+0x54>
30008ca0:	e59f2030 	ldr	r2, [pc, #48]	; 30008cd8 <rm_policy_init+0x5c>
30008ca4:	e5832010 	str	r2, [r3, #16]
	rm_policy.delay_deal=NULL;
30008ca8:	e59f3020 	ldr	r3, [pc, #32]	; 30008cd0 <rm_policy_init+0x54>
30008cac:	e3a02000 	mov	r2, #0
30008cb0:	e5832014 	str	r2, [r3, #20]
	rm_policy.name="rm";
30008cb4:	e59f3014 	ldr	r3, [pc, #20]	; 30008cd0 <rm_policy_init+0x54>
30008cb8:	e59f201c 	ldr	r2, [pc, #28]	; 30008cdc <rm_policy_init+0x60>
30008cbc:	e5832018 	str	r2, [r3, #24]
	acoral_register_sched_policy(&rm_policy);
30008cc0:	e59f0008 	ldr	r0, [pc, #8]	; 30008cd0 <rm_policy_init+0x54>
30008cc4:	ebffe465 	bl	30001e60 <acoral_register_sched_policy>
}
30008cc8:	e8bd4008 	pop	{r3, lr}
30008ccc:	e12fff1e 	bx	lr
30008cd0:	3002b114 	.word	0x3002b114
30008cd4:	300086dc 	.word	0x300086dc
30008cd8:	30008824 	.word	0x30008824
30008cdc:	300262e0 	.word	0x300262e0

30008ce0 <rm_end>:

void rm_end(){
30008ce0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008ce4:	e24dd024 	sub	sp, sp, #36	; 0x24
      acoral_sr cpu_sr;
      acoral_thread_t * thread;
      rm_policy_data_t *private_data;
      acoral_list_t *tmp,*head;
      rm_thread_dispatch();	//可调度性分析
30008ce8:	ebffff6b 	bl	30008a9c <rm_thread_dispatch>
      HAL_ENTER_CRITICAL();
30008cec:	ebffe280 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30008cf0:	e1a03000 	mov	r3, r0
30008cf4:	e58d300c 	str	r3, [sp, #12]
      head=&rm_queue->head;
30008cf8:	e59f3090 	ldr	r3, [pc, #144]	; 30008d90 <rm_end+0xb0>
30008cfc:	e5933000 	ldr	r3, [r3]
30008d00:	e58d301c 	str	r3, [sp, #28]
      for (tmp=head->next;tmp!=head;){
30008d04:	e59d301c 	ldr	r3, [sp, #28]
30008d08:	e5933000 	ldr	r3, [r3]
30008d0c:	e58d3018 	str	r3, [sp, #24]
30008d10:	ea000015 	b	30008d6c <rm_end+0x8c>
	  	thread =list_entry(tmp, acoral_thread_t,ready);
30008d14:	e59d3018 	ldr	r3, [sp, #24]
30008d18:	e2433010 	sub	r3, r3, #16
30008d1c:	e58d3010 	str	r3, [sp, #16]
	  	tmp=tmp->next;
30008d20:	e59d3018 	ldr	r3, [sp, #24]
30008d24:	e5933000 	ldr	r3, [r3]
30008d28:	e58d3018 	str	r3, [sp, #24]
	 	acoral_list_del(&thread->ready); /*从队列上取下线程*/
30008d2c:	e59d3010 	ldr	r3, [sp, #16]
30008d30:	e2833010 	add	r3, r3, #16
30008d34:	e1a00003 	mov	r0, r3
30008d38:	eb00053b 	bl	3000a22c <acoral_list_del>
	  	private_data=thread->private_data;
30008d3c:	e59d3010 	ldr	r3, [sp, #16]
30008d40:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30008d44:	e58d3014 	str	r3, [sp, #20]
	  	acoral_policy_thread_init(ACORAL_SCHED_POLICY_PERIOD,thread,private_data->period_data.route,private_data->period_data.args,NULL);
30008d48:	e59d3014 	ldr	r3, [sp, #20]
30008d4c:	e5932004 	ldr	r2, [r3, #4]
30008d50:	e59d3014 	ldr	r3, [sp, #20]
30008d54:	e5933008 	ldr	r3, [r3, #8]
30008d58:	e3a01000 	mov	r1, #0
30008d5c:	e58d1000 	str	r1, [sp]
30008d60:	e3a00016 	mov	r0, #22
30008d64:	e59d1010 	ldr	r1, [sp, #16]
30008d68:	ebffe40c 	bl	30001da0 <acoral_policy_thread_init>
      rm_policy_data_t *private_data;
      acoral_list_t *tmp,*head;
      rm_thread_dispatch();	//可调度性分析
      HAL_ENTER_CRITICAL();
      head=&rm_queue->head;
      for (tmp=head->next;tmp!=head;){
30008d6c:	e59d2018 	ldr	r2, [sp, #24]
30008d70:	e59d301c 	ldr	r3, [sp, #28]
30008d74:	e1520003 	cmp	r2, r3
30008d78:	1affffe5 	bne	30008d14 <rm_end+0x34>
	  	tmp=tmp->next;
	 	acoral_list_del(&thread->ready); /*从队列上取下线程*/
	  	private_data=thread->private_data;
	  	acoral_policy_thread_init(ACORAL_SCHED_POLICY_PERIOD,thread,private_data->period_data.route,private_data->period_data.args,NULL);
     }
     HAL_EXIT_CRITICAL();
30008d7c:	e59d000c 	ldr	r0, [sp, #12]
30008d80:	ebffe259 	bl	300016ec <HAL_INTR_RESTORE>
}
30008d84:	e28dd024 	add	sp, sp, #36	; 0x24
30008d88:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30008d8c:	e12fff1e 	bx	lr
30008d90:	3002689c 	.word	0x3002689c

30008d94 <period_policy_thread_init>:
#include<policy.h>
#include<mem.h>
#include<timer.h>
#include<period_thrd.h>
acoral_queue_t period_delay_queue;
acoral_id period_policy_thread_init(acoral_thread_t *thread,void (*route)(void *args),void *args,void *data){
30008d94:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008d98:	e24dd024 	sub	sp, sp, #36	; 0x24
30008d9c:	e58d000c 	str	r0, [sp, #12]
30008da0:	e58d1008 	str	r1, [sp, #8]
30008da4:	e58d2004 	str	r2, [sp, #4]
30008da8:	e58d3000 	str	r3, [sp]
	acoral_sr cpu_sr;
	acoral_u32 prio;
	acoral_period_policy_data_t *policy_data;
	period_policy_data_t *private_data;
	if(thread->policy==ACORAL_SCHED_POLICY_PERIOD){
30008dac:	e59d300c 	ldr	r3, [sp, #12]
30008db0:	e5d3300c 	ldrb	r3, [r3, #12]
30008db4:	e3530016 	cmp	r3, #22
30008db8:	1a000040 	bne	30008ec0 <period_policy_thread_init+0x12c>
		policy_data=(acoral_period_policy_data_t *)data;
30008dbc:	e59d3000 	ldr	r3, [sp]
30008dc0:	e58d3018 	str	r3, [sp, #24]
		thread->cpu=policy_data->cpu;
30008dc4:	e59d3018 	ldr	r3, [sp, #24]
30008dc8:	e5d32000 	ldrb	r2, [r3]
30008dcc:	e59d300c 	ldr	r3, [sp, #12]
30008dd0:	e5c32006 	strb	r2, [r3, #6]
		prio=policy_data->prio;
30008dd4:	e59d3018 	ldr	r3, [sp, #24]
30008dd8:	e5d33001 	ldrb	r3, [r3, #1]
30008ddc:	e58d3014 	str	r3, [sp, #20]
		if(policy_data->prio_type==ACORAL_BASE_PRIO){
30008de0:	e59d3018 	ldr	r3, [sp, #24]
30008de4:	e5d33002 	ldrb	r3, [r3, #2]
30008de8:	e1a03c03 	lsl	r3, r3, #24
30008dec:	e1a03c43 	asr	r3, r3, #24
30008df0:	e3530002 	cmp	r3, #2
30008df4:	1a000007 	bne	30008e18 <period_policy_thread_init+0x84>
			prio+=ACORAL_BASE_PRIO_MIN;
30008df8:	e59d3014 	ldr	r3, [sp, #20]
30008dfc:	e2833002 	add	r3, r3, #2
30008e00:	e58d3014 	str	r3, [sp, #20]
			if(prio>=ACORAL_BASE_PRIO_MAX)
30008e04:	e59d3014 	ldr	r3, [sp, #20]
30008e08:	e3530026 	cmp	r3, #38	; 0x26
30008e0c:	9a000001 	bls	30008e18 <period_policy_thread_init+0x84>
				prio=ACORAL_BASE_PRIO_MAX-1;
30008e10:	e3a03026 	mov	r3, #38	; 0x26
30008e14:	e58d3014 	str	r3, [sp, #20]
		}
		thread->prio=prio;
30008e18:	e59d3014 	ldr	r3, [sp, #20]
30008e1c:	e20320ff 	and	r2, r3, #255	; 0xff
30008e20:	e59d300c 	ldr	r3, [sp, #12]
30008e24:	e5c32005 	strb	r2, [r3, #5]
		private_data=(period_policy_data_t *)acoral_malloc2(sizeof(period_policy_data_t));
30008e28:	e3a0000c 	mov	r0, #12
30008e2c:	ebfff7f4 	bl	30006e04 <v_malloc>
30008e30:	e1a03000 	mov	r3, r0
30008e34:	e58d301c 	str	r3, [sp, #28]
		if(private_data==NULL){
30008e38:	e59d301c 	ldr	r3, [sp, #28]
30008e3c:	e3530000 	cmp	r3, #0
30008e40:	1a00000e 	bne	30008e80 <period_policy_thread_init+0xec>
			acoral_printerr("No level2 mem space for private_data:%s\n",thread->name);
30008e44:	e59d300c 	ldr	r3, [sp, #12]
30008e48:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30008e4c:	e59f0118 	ldr	r0, [pc, #280]	; 30008f6c <period_policy_thread_init+0x1d8>
30008e50:	e1a01003 	mov	r1, r3
30008e54:	eb000973 	bl	3000b428 <acoral_print>
			HAL_ENTER_CRITICAL();
30008e58:	ebffe225 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30008e5c:	e1a03000 	mov	r3, r0
30008e60:	e58d3010 	str	r3, [sp, #16]
			acoral_release_res((acoral_res_t *)thread);
30008e64:	e59d300c 	ldr	r3, [sp, #12]
30008e68:	e1a00003 	mov	r0, r3
30008e6c:	ebffe9eb 	bl	30003620 <acoral_release_res>
			HAL_EXIT_CRITICAL();
30008e70:	e59d0010 	ldr	r0, [sp, #16]
30008e74:	ebffe21c 	bl	300016ec <HAL_INTR_RESTORE>
			return -1;
30008e78:	e3e03000 	mvn	r3, #0
30008e7c:	ea000036 	b	30008f5c <period_policy_thread_init+0x1c8>
		}
		private_data->time=policy_data->time;
30008e80:	e59d3018 	ldr	r3, [sp, #24]
30008e84:	e5932004 	ldr	r2, [r3, #4]
30008e88:	e59d301c 	ldr	r3, [sp, #28]
30008e8c:	e5832000 	str	r2, [r3]
		private_data->route=route;
30008e90:	e59d301c 	ldr	r3, [sp, #28]
30008e94:	e59d2008 	ldr	r2, [sp, #8]
30008e98:	e5832004 	str	r2, [r3, #4]
		private_data->args=args;
30008e9c:	e59d301c 	ldr	r3, [sp, #28]
30008ea0:	e59d2004 	ldr	r2, [sp, #4]
30008ea4:	e5832008 	str	r2, [r3, #8]
		thread->private_data=private_data;
30008ea8:	e59d300c 	ldr	r3, [sp, #12]
30008eac:	e59d201c 	ldr	r2, [sp, #28]
30008eb0:	e5832050 	str	r2, [r3, #80]	; 0x50
		thread->cpu_mask=-1;
30008eb4:	e59d300c 	ldr	r3, [sp, #12]
30008eb8:	e3e02000 	mvn	r2, #0
30008ebc:	e5832008 	str	r2, [r3, #8]
	}
	if(acoral_thread_init(thread,route,period_thread_exit,args)!=0){
30008ec0:	e59f30a8 	ldr	r3, [pc, #168]	; 30008f70 <period_policy_thread_init+0x1dc>
30008ec4:	e59d000c 	ldr	r0, [sp, #12]
30008ec8:	e59d1008 	ldr	r1, [sp, #8]
30008ecc:	e1a02003 	mov	r2, r3
30008ed0:	e59d3004 	ldr	r3, [sp, #4]
30008ed4:	ebffe767 	bl	30002c78 <acoral_thread_init>
30008ed8:	e1a03000 	mov	r3, r0
30008edc:	e3530000 	cmp	r3, #0
30008ee0:	0a00000e 	beq	30008f20 <period_policy_thread_init+0x18c>
		acoral_printerr("No thread stack:%s\n",thread->name);
30008ee4:	e59d300c 	ldr	r3, [sp, #12]
30008ee8:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30008eec:	e59f0080 	ldr	r0, [pc, #128]	; 30008f74 <period_policy_thread_init+0x1e0>
30008ef0:	e1a01003 	mov	r1, r3
30008ef4:	eb00094b 	bl	3000b428 <acoral_print>
		HAL_ENTER_CRITICAL();
30008ef8:	ebffe1fd 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30008efc:	e1a03000 	mov	r3, r0
30008f00:	e58d3010 	str	r3, [sp, #16]
		acoral_release_res((acoral_res_t *)thread);
30008f04:	e59d300c 	ldr	r3, [sp, #12]
30008f08:	e1a00003 	mov	r0, r3
30008f0c:	ebffe9c3 	bl	30003620 <acoral_release_res>
		HAL_EXIT_CRITICAL();
30008f10:	e59d0010 	ldr	r0, [sp, #16]
30008f14:	ebffe1f4 	bl	300016ec <HAL_INTR_RESTORE>
		return -1;
30008f18:	e3e03000 	mvn	r3, #0
30008f1c:	ea00000e 	b	30008f5c <period_policy_thread_init+0x1c8>
	}
        /*将线程就绪，并重新调度*/
	acoral_resume_thread(thread);
30008f20:	e59d000c 	ldr	r0, [sp, #12]
30008f24:	ebffe64a 	bl	30002854 <acoral_resume_thread>
	HAL_ENTER_CRITICAL();
30008f28:	ebffe1f1 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30008f2c:	e1a03000 	mov	r3, r0
30008f30:	e58d3010 	str	r3, [sp, #16]
	period_thread_delay(thread,((period_policy_data_t *)thread->private_data)->time);
30008f34:	e59d300c 	ldr	r3, [sp, #12]
30008f38:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30008f3c:	e5933000 	ldr	r3, [r3]
30008f40:	e59d000c 	ldr	r0, [sp, #12]
30008f44:	e1a01003 	mov	r1, r3
30008f48:	eb000057 	bl	300090ac <period_thread_delay>
	HAL_EXIT_CRITICAL();
30008f4c:	e59d0010 	ldr	r0, [sp, #16]
30008f50:	ebffe1e5 	bl	300016ec <HAL_INTR_RESTORE>
	return thread->res.id;
30008f54:	e59d300c 	ldr	r3, [sp, #12]
30008f58:	e5933000 	ldr	r3, [r3]
}
30008f5c:	e1a00003 	mov	r0, r3
30008f60:	e28dd024 	add	sp, sp, #36	; 0x24
30008f64:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30008f68:	e12fff1e 	bx	lr
30008f6c:	300262e4 	.word	0x300262e4
30008f70:	3000928c 	.word	0x3000928c
30008f74:	30026310 	.word	0x30026310

30008f78 <period_policy_thread_release>:

void period_policy_thread_release(acoral_thread_t *thread){
30008f78:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008f7c:	e24dd00c 	sub	sp, sp, #12
30008f80:	e58d0004 	str	r0, [sp, #4]
	acoral_free2(thread->private_data);	
30008f84:	e59d3004 	ldr	r3, [sp, #4]
30008f88:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30008f8c:	e1a00003 	mov	r0, r3
30008f90:	ebfff7b0 	bl	30006e58 <v_free>
}
30008f94:	e28dd00c 	add	sp, sp, #12
30008f98:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30008f9c:	e12fff1e 	bx	lr

30008fa0 <acoral_periodqueue_add>:

void acoral_periodqueue_add(acoral_thread_t *new){
30008fa0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008fa4:	e24dd024 	sub	sp, sp, #36	; 0x24
30008fa8:	e58d0004 	str	r0, [sp, #4]
	acoral_list_t   *tmp,*head;
	acoral_thread_t *thread;
	acoral_32  delay2;
	acoral_32  delay= new->delay;
30008fac:	e59d3004 	ldr	r3, [sp, #4]
30008fb0:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30008fb4:	e58d301c 	str	r3, [sp, #28]
	head=&period_delay_queue.head;
30008fb8:	e59f30e8 	ldr	r3, [pc, #232]	; 300090a8 <acoral_periodqueue_add+0x108>
30008fbc:	e58d3010 	str	r3, [sp, #16]
	acoral_spin_lock(&head->lock);
	new->state|=ACORAL_THREAD_STATE_DELAY;
30008fc0:	e59d3004 	ldr	r3, [sp, #4]
30008fc4:	e5d33004 	ldrb	r3, [r3, #4]
30008fc8:	e3833020 	orr	r3, r3, #32
30008fcc:	e20320ff 	and	r2, r3, #255	; 0xff
30008fd0:	e59d3004 	ldr	r3, [sp, #4]
30008fd4:	e5c32004 	strb	r2, [r3, #4]
	for (tmp=head->next;delay2=delay,tmp!=head; tmp=tmp->next){
30008fd8:	e59d3010 	ldr	r3, [sp, #16]
30008fdc:	e5933000 	ldr	r3, [r3]
30008fe0:	e58d300c 	str	r3, [sp, #12]
30008fe4:	ea00000d 	b	30009020 <acoral_periodqueue_add+0x80>
		thread = list_entry (tmp, acoral_thread_t, waiting);
30008fe8:	e59d300c 	ldr	r3, [sp, #12]
30008fec:	e2433020 	sub	r3, r3, #32
30008ff0:	e58d3014 	str	r3, [sp, #20]
		delay  = delay-thread->delay;
30008ff4:	e59d3014 	ldr	r3, [sp, #20]
30008ff8:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30008ffc:	e59d201c 	ldr	r2, [sp, #28]
30009000:	e0633002 	rsb	r3, r3, r2
30009004:	e58d301c 	str	r3, [sp, #28]
		if (delay < 0)
30009008:	e59d301c 	ldr	r3, [sp, #28]
3000900c:	e3530000 	cmp	r3, #0
30009010:	ba000009 	blt	3000903c <acoral_periodqueue_add+0x9c>
	acoral_32  delay2;
	acoral_32  delay= new->delay;
	head=&period_delay_queue.head;
	acoral_spin_lock(&head->lock);
	new->state|=ACORAL_THREAD_STATE_DELAY;
	for (tmp=head->next;delay2=delay,tmp!=head; tmp=tmp->next){
30009014:	e59d300c 	ldr	r3, [sp, #12]
30009018:	e5933000 	ldr	r3, [r3]
3000901c:	e58d300c 	str	r3, [sp, #12]
30009020:	e59d301c 	ldr	r3, [sp, #28]
30009024:	e58d3018 	str	r3, [sp, #24]
30009028:	e59d200c 	ldr	r2, [sp, #12]
3000902c:	e59d3010 	ldr	r3, [sp, #16]
30009030:	e1520003 	cmp	r2, r3
30009034:	1affffeb 	bne	30008fe8 <acoral_periodqueue_add+0x48>
30009038:	ea000000 	b	30009040 <acoral_periodqueue_add+0xa0>
		thread = list_entry (tmp, acoral_thread_t, waiting);
		delay  = delay-thread->delay;
		if (delay < 0)
			break;
3000903c:	e1a00000 	nop			; (mov r0, r0)
	}
	new->delay = delay2;
30009040:	e59d3004 	ldr	r3, [sp, #4]
30009044:	e59d2018 	ldr	r2, [sp, #24]
30009048:	e5832040 	str	r2, [r3, #64]	; 0x40
	acoral_list_add(&new->waiting,tmp->prev);
3000904c:	e59d3004 	ldr	r3, [sp, #4]
30009050:	e2832020 	add	r2, r3, #32
30009054:	e59d300c 	ldr	r3, [sp, #12]
30009058:	e5933004 	ldr	r3, [r3, #4]
3000905c:	e1a00002 	mov	r0, r2
30009060:	e1a01003 	mov	r1, r3
30009064:	eb00044a 	bl	3000a194 <acoral_list_add>
	/* 插入等待任务后，后继等待任务时间处理*/
	if(tmp != head){
30009068:	e59d200c 	ldr	r2, [sp, #12]
3000906c:	e59d3010 	ldr	r3, [sp, #16]
30009070:	e1520003 	cmp	r2, r3
30009074:	0a000008 	beq	3000909c <acoral_periodqueue_add+0xfc>
		thread = list_entry(tmp, acoral_thread_t, waiting);
30009078:	e59d300c 	ldr	r3, [sp, #12]
3000907c:	e2433020 	sub	r3, r3, #32
30009080:	e58d3014 	str	r3, [sp, #20]
		thread->delay-=delay2;
30009084:	e59d3014 	ldr	r3, [sp, #20]
30009088:	e5932040 	ldr	r2, [r3, #64]	; 0x40
3000908c:	e59d3018 	ldr	r3, [sp, #24]
30009090:	e0632002 	rsb	r2, r3, r2
30009094:	e59d3014 	ldr	r3, [sp, #20]
30009098:	e5832040 	str	r2, [r3, #64]	; 0x40
	}
	acoral_spin_unlock(&head->lock);
}
3000909c:	e28dd024 	add	sp, sp, #36	; 0x24
300090a0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300090a4:	e12fff1e 	bx	lr
300090a8:	3002a870 	.word	0x3002a870

300090ac <period_thread_delay>:

void period_thread_delay(acoral_thread_t* thread,acoral_time time){
300090ac:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300090b0:	e24dd00c 	sub	sp, sp, #12
300090b4:	e58d0004 	str	r0, [sp, #4]
300090b8:	e58d1000 	str	r1, [sp]
	thread->delay=TIME_TO_TICKS(time);
300090bc:	e59d2000 	ldr	r2, [sp]
300090c0:	e1a03002 	mov	r3, r2
300090c4:	e1a03103 	lsl	r3, r3, #2
300090c8:	e0833002 	add	r3, r3, r2
300090cc:	e1a02103 	lsl	r2, r3, #2
300090d0:	e0833002 	add	r3, r3, r2
300090d4:	e1a03103 	lsl	r3, r3, #2
300090d8:	e1a02003 	mov	r2, r3
300090dc:	e59f3024 	ldr	r3, [pc, #36]	; 30009108 <period_thread_delay+0x5c>
300090e0:	e0831392 	umull	r1, r3, r2, r3
300090e4:	e1a03323 	lsr	r3, r3, #6
300090e8:	e1a02003 	mov	r2, r3
300090ec:	e59d3004 	ldr	r3, [sp, #4]
300090f0:	e5832040 	str	r2, [r3, #64]	; 0x40
	acoral_periodqueue_add(thread);
300090f4:	e59d0004 	ldr	r0, [sp, #4]
300090f8:	ebffffa8 	bl	30008fa0 <acoral_periodqueue_add>
}
300090fc:	e28dd00c 	add	sp, sp, #12
30009100:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009104:	e12fff1e 	bx	lr
30009108:	10624dd3 	.word	0x10624dd3

3000910c <period_delay_deal>:

void period_delay_deal(){
3000910c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009110:	e24dd01c 	sub	sp, sp, #28
	acoral_list_t *tmp,*tmp1,*head;
	acoral_thread_t * thread;
	period_policy_data_t * private_data;
	head=&period_delay_queue.head;
30009114:	e59f3160 	ldr	r3, [pc, #352]	; 3000927c <period_delay_deal+0x170>
30009118:	e58d300c 	str	r3, [sp, #12]
	if(acoral_list_empty(head))
3000911c:	e59d300c 	ldr	r3, [sp, #12]
30009120:	e5932000 	ldr	r2, [r3]
30009124:	e59d300c 	ldr	r3, [sp, #12]
30009128:	e1520003 	cmp	r2, r3
3000912c:	0a00004c 	beq	30009264 <period_delay_deal+0x158>
	    	return;
	thread=list_entry(head->next,acoral_thread_t,waiting);
30009130:	e59d300c 	ldr	r3, [sp, #12]
30009134:	e5933000 	ldr	r3, [r3]
30009138:	e2433020 	sub	r3, r3, #32
3000913c:	e58d3010 	str	r3, [sp, #16]
	ACORAL_ASSERT(thread,"in period thread deal");
30009140:	e59d2010 	ldr	r2, [sp, #16]
30009144:	e59f3134 	ldr	r3, [pc, #308]	; 30009280 <period_delay_deal+0x174>
30009148:	e1a00002 	mov	r0, r2
3000914c:	e1a01003 	mov	r1, r3
30009150:	ebffeab9 	bl	30003c3c <acoral_assert_res>
	thread->delay--;
30009154:	e59d3010 	ldr	r3, [sp, #16]
30009158:	e5933040 	ldr	r3, [r3, #64]	; 0x40
3000915c:	e2432001 	sub	r2, r3, #1
30009160:	e59d3010 	ldr	r3, [sp, #16]
30009164:	e5832040 	str	r2, [r3, #64]	; 0x40
	for(tmp=head->next;tmp!=head;){
30009168:	e59d300c 	ldr	r3, [sp, #12]
3000916c:	e5933000 	ldr	r3, [r3]
30009170:	e58d3004 	str	r3, [sp, #4]
30009174:	ea000035 	b	30009250 <period_delay_deal+0x144>
		thread=list_entry(tmp,acoral_thread_t,waiting);
30009178:	e59d3004 	ldr	r3, [sp, #4]
3000917c:	e2433020 	sub	r3, r3, #32
30009180:	e58d3010 	str	r3, [sp, #16]
		ACORAL_ASSERT(thread,"in period thread deal ");
30009184:	e59d2010 	ldr	r2, [sp, #16]
30009188:	e59f30f4 	ldr	r3, [pc, #244]	; 30009284 <period_delay_deal+0x178>
3000918c:	e1a00002 	mov	r0, r2
30009190:	e1a01003 	mov	r1, r3
30009194:	ebffeaa8 	bl	30003c3c <acoral_assert_res>
		if(thread->delay>0)
30009198:	e59d3010 	ldr	r3, [sp, #16]
3000919c:	e5933040 	ldr	r3, [r3, #64]	; 0x40
300091a0:	e3530000 	cmp	r3, #0
300091a4:	ca000030 	bgt	3000926c <period_delay_deal+0x160>
		    break;
		private_data=thread->private_data;
300091a8:	e59d3010 	ldr	r3, [sp, #16]
300091ac:	e5933050 	ldr	r3, [r3, #80]	; 0x50
300091b0:	e58d3014 	str	r3, [sp, #20]
		/*防止add判断delay时取下thread*/
		acoral_spin_lock(&head->lock);
		tmp1=tmp->next;
300091b4:	e59d3004 	ldr	r3, [sp, #4]
300091b8:	e5933000 	ldr	r3, [r3]
300091bc:	e58d3008 	str	r3, [sp, #8]
		acoral_list_del(&thread->waiting);
300091c0:	e59d3010 	ldr	r3, [sp, #16]
300091c4:	e2833020 	add	r3, r3, #32
300091c8:	e1a00003 	mov	r0, r3
300091cc:	eb000416 	bl	3000a22c <acoral_list_del>
		tmp=tmp1;
300091d0:	e59d3008 	ldr	r3, [sp, #8]
300091d4:	e58d3004 	str	r3, [sp, #4]
		acoral_spin_unlock(&head->lock);
		if(thread->state&ACORAL_THREAD_STATE_SUSPEND){
300091d8:	e59d3010 	ldr	r3, [sp, #16]
300091dc:	e5d33004 	ldrb	r3, [r3, #4]
300091e0:	e2033002 	and	r3, r3, #2
300091e4:	e3530000 	cmp	r3, #0
300091e8:	0a000013 	beq	3000923c <period_delay_deal+0x130>
			thread->stack=(acoral_u32 *)((acoral_8 *)thread->stack_buttom+thread->stack_size-4);
300091ec:	e59d3010 	ldr	r3, [sp, #16]
300091f0:	e5932038 	ldr	r2, [r3, #56]	; 0x38
300091f4:	e59d3010 	ldr	r3, [sp, #16]
300091f8:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
300091fc:	e2433004 	sub	r3, r3, #4
30009200:	e0822003 	add	r2, r2, r3
30009204:	e59d3010 	ldr	r3, [sp, #16]
30009208:	e5832034 	str	r2, [r3, #52]	; 0x34
			HAL_STACK_INIT(&thread->stack,private_data->route,period_thread_exit,private_data->args);
3000920c:	e59d3010 	ldr	r3, [sp, #16]
30009210:	e2831034 	add	r1, r3, #52	; 0x34
30009214:	e59d3014 	ldr	r3, [sp, #20]
30009218:	e5932004 	ldr	r2, [r3, #4]
3000921c:	e59d3014 	ldr	r3, [sp, #20]
30009220:	e5933008 	ldr	r3, [r3, #8]
30009224:	e1a00001 	mov	r0, r1
30009228:	e1a01002 	mov	r1, r2
3000922c:	e59f2054 	ldr	r2, [pc, #84]	; 30009288 <period_delay_deal+0x17c>
30009230:	ebffdc22 	bl	300002c0 <hal_stack_init>
			acoral_rdy_thread(thread);
30009234:	e59d0010 	ldr	r0, [sp, #16]
30009238:	ebffe64c 	bl	30002b70 <acoral_rdy_thread>
		}
		period_thread_delay(thread,private_data->time);
3000923c:	e59d3014 	ldr	r3, [sp, #20]
30009240:	e5933000 	ldr	r3, [r3]
30009244:	e59d0010 	ldr	r0, [sp, #16]
30009248:	e1a01003 	mov	r1, r3
3000924c:	ebffff96 	bl	300090ac <period_thread_delay>
	if(acoral_list_empty(head))
	    	return;
	thread=list_entry(head->next,acoral_thread_t,waiting);
	ACORAL_ASSERT(thread,"in period thread deal");
	thread->delay--;
	for(tmp=head->next;tmp!=head;){
30009250:	e59d2004 	ldr	r2, [sp, #4]
30009254:	e59d300c 	ldr	r3, [sp, #12]
30009258:	e1520003 	cmp	r2, r3
3000925c:	1affffc5 	bne	30009178 <period_delay_deal+0x6c>
30009260:	ea000002 	b	30009270 <period_delay_deal+0x164>
	acoral_list_t *tmp,*tmp1,*head;
	acoral_thread_t * thread;
	period_policy_data_t * private_data;
	head=&period_delay_queue.head;
	if(acoral_list_empty(head))
	    	return;
30009264:	e1a00000 	nop			; (mov r0, r0)
30009268:	ea000000 	b	30009270 <period_delay_deal+0x164>
	thread->delay--;
	for(tmp=head->next;tmp!=head;){
		thread=list_entry(tmp,acoral_thread_t,waiting);
		ACORAL_ASSERT(thread,"in period thread deal ");
		if(thread->delay>0)
		    break;
3000926c:	e1a00000 	nop			; (mov r0, r0)
			HAL_STACK_INIT(&thread->stack,private_data->route,period_thread_exit,private_data->args);
			acoral_rdy_thread(thread);
		}
		period_thread_delay(thread,private_data->time);
	}
}
30009270:	e28dd01c 	add	sp, sp, #28
30009274:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009278:	e12fff1e 	bx	lr
3000927c:	3002a870 	.word	0x3002a870
30009280:	30026324 	.word	0x30026324
30009284:	3002633c 	.word	0x3002633c
30009288:	3000928c 	.word	0x3000928c

3000928c <period_thread_exit>:

void period_thread_exit(){
3000928c:	e92d4008 	push	{r3, lr}
	acoral_suspend_self();
30009290:	ebffe54d 	bl	300027cc <acoral_suspend_self>
}
30009294:	e8bd4008 	pop	{r3, lr}
30009298:	e12fff1e 	bx	lr

3000929c <period_policy_init>:

acoral_sched_policy_t period_policy;
void period_policy_init(){
3000929c:	e92d4008 	push	{r3, lr}
	acoral_list_init(&period_delay_queue.head);
300092a0:	e59f305c 	ldr	r3, [pc, #92]	; 30009304 <period_policy_init+0x68>
300092a4:	e59f2058 	ldr	r2, [pc, #88]	; 30009304 <period_policy_init+0x68>
300092a8:	e5832000 	str	r2, [r3]
300092ac:	e59f3050 	ldr	r3, [pc, #80]	; 30009304 <period_policy_init+0x68>
300092b0:	e59f204c 	ldr	r2, [pc, #76]	; 30009304 <period_policy_init+0x68>
300092b4:	e5832004 	str	r2, [r3, #4]
	acoral_spin_init(&period_delay_queue.head.lock);
	period_policy.type=ACORAL_SCHED_POLICY_PERIOD;
300092b8:	e59f3048 	ldr	r3, [pc, #72]	; 30009308 <period_policy_init+0x6c>
300092bc:	e3a02016 	mov	r2, #22
300092c0:	e5c32008 	strb	r2, [r3, #8]
	period_policy.policy_thread_init=period_policy_thread_init;
300092c4:	e59f303c 	ldr	r3, [pc, #60]	; 30009308 <period_policy_init+0x6c>
300092c8:	e59f203c 	ldr	r2, [pc, #60]	; 3000930c <period_policy_init+0x70>
300092cc:	e583200c 	str	r2, [r3, #12]
	period_policy.policy_thread_release=period_policy_thread_release;
300092d0:	e59f3030 	ldr	r3, [pc, #48]	; 30009308 <period_policy_init+0x6c>
300092d4:	e59f2034 	ldr	r2, [pc, #52]	; 30009310 <period_policy_init+0x74>
300092d8:	e5832010 	str	r2, [r3, #16]
	period_policy.delay_deal=period_delay_deal;
300092dc:	e59f3024 	ldr	r3, [pc, #36]	; 30009308 <period_policy_init+0x6c>
300092e0:	e59f202c 	ldr	r2, [pc, #44]	; 30009314 <period_policy_init+0x78>
300092e4:	e5832014 	str	r2, [r3, #20]
	period_policy.name="period";
300092e8:	e59f3018 	ldr	r3, [pc, #24]	; 30009308 <period_policy_init+0x6c>
300092ec:	e59f2024 	ldr	r2, [pc, #36]	; 30009318 <period_policy_init+0x7c>
300092f0:	e5832018 	str	r2, [r3, #24]
	acoral_register_sched_policy(&period_policy);
300092f4:	e59f000c 	ldr	r0, [pc, #12]	; 30009308 <period_policy_init+0x6c>
300092f8:	ebffe2d8 	bl	30001e60 <acoral_register_sched_policy>
}
300092fc:	e8bd4008 	pop	{r3, lr}
30009300:	e12fff1e 	bx	lr
30009304:	3002a870 	.word	0x3002a870
30009308:	3002b358 	.word	0x3002b358
3000930c:	30008d94 	.word	0x30008d94
30009310:	30008f78 	.word	0x30008f78
30009314:	3000910c 	.word	0x3000910c
30009318:	30026354 	.word	0x30026354

3000931c <slice_policy_thread_init>:
#include<policy.h>
#include<timer.h>
#include<mem.h>
#include<slice_thrd.h>
acoral_sched_policy_t slice_policy;
acoral_id slice_policy_thread_init(acoral_thread_t *thread,void (*route)(void *args),void *args,void *data){
3000931c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009320:	e24dd024 	sub	sp, sp, #36	; 0x24
30009324:	e58d000c 	str	r0, [sp, #12]
30009328:	e58d1008 	str	r1, [sp, #8]
3000932c:	e58d2004 	str	r2, [sp, #4]
30009330:	e58d3000 	str	r3, [sp]
	acoral_sr cpu_sr;
	acoral_u32 prio;
	acoral_slice_policy_data_t *policy_data;
	slice_policy_data_t *private_data;
	if(thread->policy==ACORAL_SCHED_POLICY_SLICE){
30009334:	e59d300c 	ldr	r3, [sp, #12]
30009338:	e5d3300c 	ldrb	r3, [r3, #12]
3000933c:	e3530018 	cmp	r3, #24
30009340:	1a000046 	bne	30009460 <slice_policy_thread_init+0x144>
		policy_data=(acoral_slice_policy_data_t *)data;
30009344:	e59d3000 	ldr	r3, [sp]
30009348:	e58d3018 	str	r3, [sp, #24]
		thread->cpu=policy_data->cpu;
3000934c:	e59d3018 	ldr	r3, [sp, #24]
30009350:	e5d32000 	ldrb	r2, [r3]
30009354:	e59d300c 	ldr	r3, [sp, #12]
30009358:	e5c32006 	strb	r2, [r3, #6]
		prio=policy_data->prio;
3000935c:	e59d3018 	ldr	r3, [sp, #24]
30009360:	e5d33001 	ldrb	r3, [r3, #1]
30009364:	e58d3014 	str	r3, [sp, #20]
		if(policy_data->prio_type==ACORAL_BASE_PRIO){
30009368:	e59d3018 	ldr	r3, [sp, #24]
3000936c:	e5d33002 	ldrb	r3, [r3, #2]
30009370:	e3530002 	cmp	r3, #2
30009374:	1a000007 	bne	30009398 <slice_policy_thread_init+0x7c>
			prio+=ACORAL_BASE_PRIO_MIN;
30009378:	e59d3014 	ldr	r3, [sp, #20]
3000937c:	e2833002 	add	r3, r3, #2
30009380:	e58d3014 	str	r3, [sp, #20]
			if(prio>=ACORAL_BASE_PRIO_MAX)
30009384:	e59d3014 	ldr	r3, [sp, #20]
30009388:	e3530026 	cmp	r3, #38	; 0x26
3000938c:	9a000001 	bls	30009398 <slice_policy_thread_init+0x7c>
				prio=ACORAL_BASE_PRIO_MAX-1;
30009390:	e3a03026 	mov	r3, #38	; 0x26
30009394:	e58d3014 	str	r3, [sp, #20]
		}
		thread->prio=prio;
30009398:	e59d3014 	ldr	r3, [sp, #20]
3000939c:	e20320ff 	and	r2, r3, #255	; 0xff
300093a0:	e59d300c 	ldr	r3, [sp, #12]
300093a4:	e5c32005 	strb	r2, [r3, #5]
		private_data=(slice_policy_data_t *)acoral_malloc2(sizeof(slice_policy_data_t));
300093a8:	e3a00004 	mov	r0, #4
300093ac:	ebfff694 	bl	30006e04 <v_malloc>
300093b0:	e1a03000 	mov	r3, r0
300093b4:	e58d301c 	str	r3, [sp, #28]
		if(private_data==NULL){
300093b8:	e59d301c 	ldr	r3, [sp, #28]
300093bc:	e3530000 	cmp	r3, #0
300093c0:	1a00000e 	bne	30009400 <slice_policy_thread_init+0xe4>
			acoral_printerr("No level2 mem space for private_data:%s\n",thread->name);
300093c4:	e59d300c 	ldr	r3, [sp, #12]
300093c8:	e5933048 	ldr	r3, [r3, #72]	; 0x48
300093cc:	e59f0108 	ldr	r0, [pc, #264]	; 300094dc <slice_policy_thread_init+0x1c0>
300093d0:	e1a01003 	mov	r1, r3
300093d4:	eb000813 	bl	3000b428 <acoral_print>
			HAL_ENTER_CRITICAL();
300093d8:	ebffe0c5 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300093dc:	e1a03000 	mov	r3, r0
300093e0:	e58d3010 	str	r3, [sp, #16]
			acoral_release_res((acoral_res_t *)thread);
300093e4:	e59d300c 	ldr	r3, [sp, #12]
300093e8:	e1a00003 	mov	r0, r3
300093ec:	ebffe88b 	bl	30003620 <acoral_release_res>
			HAL_EXIT_CRITICAL();
300093f0:	e59d0010 	ldr	r0, [sp, #16]
300093f4:	ebffe0bc 	bl	300016ec <HAL_INTR_RESTORE>
			return -1;
300093f8:	e3e03000 	mvn	r3, #0
300093fc:	ea000032 	b	300094cc <slice_policy_thread_init+0x1b0>
		}
		private_data->slice_ld=TIME_TO_TICKS(policy_data->slice);
30009400:	e59d3018 	ldr	r3, [sp, #24]
30009404:	e5932004 	ldr	r2, [r3, #4]
30009408:	e1a03002 	mov	r3, r2
3000940c:	e1a03103 	lsl	r3, r3, #2
30009410:	e0833002 	add	r3, r3, r2
30009414:	e1a02103 	lsl	r2, r3, #2
30009418:	e0833002 	add	r3, r3, r2
3000941c:	e1a03103 	lsl	r3, r3, #2
30009420:	e1a02003 	mov	r2, r3
30009424:	e59f30b4 	ldr	r3, [pc, #180]	; 300094e0 <slice_policy_thread_init+0x1c4>
30009428:	e0831392 	umull	r1, r3, r2, r3
3000942c:	e1a02323 	lsr	r2, r3, #6
30009430:	e59d301c 	ldr	r3, [sp, #28]
30009434:	e5832000 	str	r2, [r3]
		thread->slice=private_data->slice_ld;
30009438:	e59d301c 	ldr	r3, [sp, #28]
3000943c:	e5932000 	ldr	r2, [r3]
30009440:	e59d300c 	ldr	r3, [sp, #12]
30009444:	e5832044 	str	r2, [r3, #68]	; 0x44
		thread->private_data=private_data;
30009448:	e59d300c 	ldr	r3, [sp, #12]
3000944c:	e59d201c 	ldr	r2, [sp, #28]
30009450:	e5832050 	str	r2, [r3, #80]	; 0x50
		thread->cpu_mask=-1;
30009454:	e59d300c 	ldr	r3, [sp, #12]
30009458:	e3e02000 	mvn	r2, #0
3000945c:	e5832008 	str	r2, [r3, #8]
	}
	if(acoral_thread_init(thread,route,acoral_thread_exit,args)!=0){
30009460:	e59d000c 	ldr	r0, [sp, #12]
30009464:	e59d1008 	ldr	r1, [sp, #8]
30009468:	e59f2074 	ldr	r2, [pc, #116]	; 300094e4 <slice_policy_thread_init+0x1c8>
3000946c:	e59d3004 	ldr	r3, [sp, #4]
30009470:	ebffe600 	bl	30002c78 <acoral_thread_init>
30009474:	e1a03000 	mov	r3, r0
30009478:	e3530000 	cmp	r3, #0
3000947c:	0a00000e 	beq	300094bc <slice_policy_thread_init+0x1a0>
		acoral_printerr("No thread stack:%s\n",thread->name);
30009480:	e59d300c 	ldr	r3, [sp, #12]
30009484:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30009488:	e59f0058 	ldr	r0, [pc, #88]	; 300094e8 <slice_policy_thread_init+0x1cc>
3000948c:	e1a01003 	mov	r1, r3
30009490:	eb0007e4 	bl	3000b428 <acoral_print>
		HAL_ENTER_CRITICAL();
30009494:	ebffe096 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30009498:	e1a03000 	mov	r3, r0
3000949c:	e58d3010 	str	r3, [sp, #16]
		acoral_release_res((acoral_res_t *)thread);
300094a0:	e59d300c 	ldr	r3, [sp, #12]
300094a4:	e1a00003 	mov	r0, r3
300094a8:	ebffe85c 	bl	30003620 <acoral_release_res>
		HAL_EXIT_CRITICAL();
300094ac:	e59d0010 	ldr	r0, [sp, #16]
300094b0:	ebffe08d 	bl	300016ec <HAL_INTR_RESTORE>
		return -1;
300094b4:	e3e03000 	mvn	r3, #0
300094b8:	ea000003 	b	300094cc <slice_policy_thread_init+0x1b0>
	}
        /*将线程就绪，并重新调度*/
	acoral_resume_thread(thread);
300094bc:	e59d000c 	ldr	r0, [sp, #12]
300094c0:	ebffe4e3 	bl	30002854 <acoral_resume_thread>
	return thread->res.id;
300094c4:	e59d300c 	ldr	r3, [sp, #12]
300094c8:	e5933000 	ldr	r3, [r3]
}
300094cc:	e1a00003 	mov	r0, r3
300094d0:	e28dd024 	add	sp, sp, #36	; 0x24
300094d4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300094d8:	e12fff1e 	bx	lr
300094dc:	3002635c 	.word	0x3002635c
300094e0:	10624dd3 	.word	0x10624dd3
300094e4:	30002a68 	.word	0x30002a68
300094e8:	30026388 	.word	0x30026388

300094ec <slice_policy_thread_release>:

void slice_policy_thread_release(acoral_thread_t *thread){
300094ec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300094f0:	e24dd00c 	sub	sp, sp, #12
300094f4:	e58d0004 	str	r0, [sp, #4]
	acoral_free2(thread->private_data);	
300094f8:	e59d3004 	ldr	r3, [sp, #4]
300094fc:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30009500:	e1a00003 	mov	r0, r3
30009504:	ebfff653 	bl	30006e58 <v_free>
}
30009508:	e28dd00c 	add	sp, sp, #12
3000950c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009510:	e12fff1e 	bx	lr

30009514 <slice_delay_deal>:

void slice_delay_deal(){
30009514:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009518:	e24dd00c 	sub	sp, sp, #12
#ifndef CFG_TICKS_PRIVATE
	acoral_u32 i;
	for(i=0;i<HAL_MAX_CPU;i++){
		cur=acoral_get_running_thread(i);
#else
		cur=acoral_cur_thread;
3000951c:	e59f3068 	ldr	r3, [pc, #104]	; 3000958c <slice_delay_deal+0x78>
30009520:	e5933000 	ldr	r3, [r3]
30009524:	e58d3000 	str	r3, [sp]
#endif
		if(cur->policy==ACORAL_SCHED_POLICY_SLICE){
30009528:	e59d3000 	ldr	r3, [sp]
3000952c:	e5d3300c 	ldrb	r3, [r3, #12]
30009530:	e3530018 	cmp	r3, #24
30009534:	1a000011 	bne	30009580 <slice_delay_deal+0x6c>
			cur->slice--;
30009538:	e59d3000 	ldr	r3, [sp]
3000953c:	e5933044 	ldr	r3, [r3, #68]	; 0x44
30009540:	e2432001 	sub	r2, r3, #1
30009544:	e59d3000 	ldr	r3, [sp]
30009548:	e5832044 	str	r2, [r3, #68]	; 0x44
			if(cur->slice<=0){
3000954c:	e59d3000 	ldr	r3, [sp]
30009550:	e5933044 	ldr	r3, [r3, #68]	; 0x44
30009554:	e3530000 	cmp	r3, #0
30009558:	1a000008 	bne	30009580 <slice_delay_deal+0x6c>
				data=(slice_policy_data_t *)cur->private_data;
3000955c:	e59d3000 	ldr	r3, [sp]
30009560:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30009564:	e58d3004 	str	r3, [sp, #4]
				cur->slice=data->slice_ld;
30009568:	e59d3004 	ldr	r3, [sp, #4]
3000956c:	e5932000 	ldr	r2, [r3]
30009570:	e59d3000 	ldr	r3, [sp]
30009574:	e5832044 	str	r2, [r3, #68]	; 0x44
				acoral_thread_move2_tail(cur);
30009578:	e59d0000 	ldr	r0, [sp]
3000957c:	ebffe599 	bl	30002be8 <acoral_thread_move2_tail>
			}
		}
#ifndef CFG_TICKS_PRIVATE
	}
#endif
}
30009580:	e28dd00c 	add	sp, sp, #12
30009584:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009588:	e12fff1e 	bx	lr
3000958c:	3002b350 	.word	0x3002b350

30009590 <slice_policy_init>:

void slice_policy_init(){
30009590:	e92d4008 	push	{r3, lr}
	slice_policy.type=ACORAL_SCHED_POLICY_SLICE;
30009594:	e59f3044 	ldr	r3, [pc, #68]	; 300095e0 <slice_policy_init+0x50>
30009598:	e3a02018 	mov	r2, #24
3000959c:	e5c32008 	strb	r2, [r3, #8]
	slice_policy.policy_thread_release=slice_policy_thread_release;
300095a0:	e59f3038 	ldr	r3, [pc, #56]	; 300095e0 <slice_policy_init+0x50>
300095a4:	e59f2038 	ldr	r2, [pc, #56]	; 300095e4 <slice_policy_init+0x54>
300095a8:	e5832010 	str	r2, [r3, #16]
	slice_policy.policy_thread_init=slice_policy_thread_init;
300095ac:	e59f302c 	ldr	r3, [pc, #44]	; 300095e0 <slice_policy_init+0x50>
300095b0:	e59f2030 	ldr	r2, [pc, #48]	; 300095e8 <slice_policy_init+0x58>
300095b4:	e583200c 	str	r2, [r3, #12]
	slice_policy.delay_deal=slice_delay_deal;
300095b8:	e59f3020 	ldr	r3, [pc, #32]	; 300095e0 <slice_policy_init+0x50>
300095bc:	e59f2028 	ldr	r2, [pc, #40]	; 300095ec <slice_policy_init+0x5c>
300095c0:	e5832014 	str	r2, [r3, #20]
	slice_policy.name="slice";
300095c4:	e59f3014 	ldr	r3, [pc, #20]	; 300095e0 <slice_policy_init+0x50>
300095c8:	e59f2020 	ldr	r2, [pc, #32]	; 300095f0 <slice_policy_init+0x60>
300095cc:	e5832018 	str	r2, [r3, #24]
	acoral_register_sched_policy(&slice_policy);
300095d0:	e59f0008 	ldr	r0, [pc, #8]	; 300095e0 <slice_policy_init+0x50>
300095d4:	ebffe221 	bl	30001e60 <acoral_register_sched_policy>
}
300095d8:	e8bd4008 	pop	{r3, lr}
300095dc:	e12fff1e 	bx	lr
300095e0:	3002a6c8 	.word	0x3002a6c8
300095e4:	300094ec 	.word	0x300094ec
300095e8:	3000931c 	.word	0x3000931c
300095ec:	30009514 	.word	0x30009514
300095f0:	3002639c 	.word	0x3002639c

300095f4 <posix_delay_deal>:
#include<policy.h>
#include<mem.h>
#include<timer.h>
#include<posix_thrd.h>
#define POSIX_SLICE_RATE 5
void posix_delay_deal(){
300095f4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300095f8:	e24dd00c 	sub	sp, sp, #12
#ifndef CFG_TICKS_PRIVATE
	acoral_u32 i;
	for(i=0;i<HAL_MAX_CPU;i++){
		cur=acoral_get_running_thread(i);
#else
		cur=acoral_cur_thread;
300095fc:	e59f3178 	ldr	r3, [pc, #376]	; 3000977c <posix_delay_deal+0x188>
30009600:	e5933000 	ldr	r3, [r3]
30009604:	e58d3000 	str	r3, [sp]
#endif
		if(cur->policy==ACORAL_SCHED_POLICY_POSIX){
30009608:	e59d3000 	ldr	r3, [sp]
3000960c:	e5d3300c 	ldrb	r3, [r3, #12]
30009610:	e3530019 	cmp	r3, #25
30009614:	1a000055 	bne	30009770 <posix_delay_deal+0x17c>
			cur->slice--;
30009618:	e59d3000 	ldr	r3, [sp]
3000961c:	e5933044 	ldr	r3, [r3, #68]	; 0x44
30009620:	e2432001 	sub	r2, r3, #1
30009624:	e59d3000 	ldr	r3, [sp]
30009628:	e5832044 	str	r2, [r3, #68]	; 0x44
			if(cur->slice==0){
3000962c:	e59d3000 	ldr	r3, [sp]
30009630:	e5933044 	ldr	r3, [r3, #68]	; 0x44
30009634:	e3530000 	cmp	r3, #0
30009638:	1a00004c 	bne	30009770 <posix_delay_deal+0x17c>
				data=(posix_policy_data_t *)cur->private_data;
3000963c:	e59d3000 	ldr	r3, [sp]
30009640:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30009644:	e58d3004 	str	r3, [sp, #4]
				data->stair++;
30009648:	e59d3004 	ldr	r3, [sp, #4]
3000964c:	e5d33008 	ldrb	r3, [r3, #8]
30009650:	e2833001 	add	r3, r3, #1
30009654:	e20320ff 	and	r2, r3, #255	; 0xff
30009658:	e59d3004 	ldr	r3, [sp, #4]
3000965c:	e5c32008 	strb	r2, [r3, #8]
				if(data->stair>=ACORAL_POSIX_PRIO_MAX){
30009660:	e59d3004 	ldr	r3, [sp, #4]
30009664:	e5d33008 	ldrb	r3, [r3, #8]
30009668:	e3530044 	cmp	r3, #68	; 0x44
3000966c:	9a000029 	bls	30009718 <posix_delay_deal+0x124>
					if(data->time<ACORAL_POSIX_STAIR_NUM){
30009670:	e59d3004 	ldr	r3, [sp, #4]
30009674:	e5d33009 	ldrb	r3, [r3, #9]
30009678:	e353001d 	cmp	r3, #29
3000967c:	8a00000c 	bhi	300096b4 <posix_delay_deal+0xc0>
						data->stair=ACORAL_POSIX_PRIO_MIN+data->time;
30009680:	e59d3004 	ldr	r3, [sp, #4]
30009684:	e5d33009 	ldrb	r3, [r3, #9]
30009688:	e2833027 	add	r3, r3, #39	; 0x27
3000968c:	e20320ff 	and	r2, r3, #255	; 0xff
30009690:	e59d3004 	ldr	r3, [sp, #4]
30009694:	e5c32008 	strb	r2, [r3, #8]
						data->time++;
30009698:	e59d3004 	ldr	r3, [sp, #4]
3000969c:	e5d33009 	ldrb	r3, [r3, #9]
300096a0:	e2833001 	add	r3, r3, #1
300096a4:	e20320ff 	and	r2, r3, #255	; 0xff
300096a8:	e59d3004 	ldr	r3, [sp, #4]
300096ac:	e5c32009 	strb	r2, [r3, #9]
300096b0:	ea000018 	b	30009718 <posix_delay_deal+0x124>
					}
					else{
						cur->policy=ACORAL_SCHED_POLICY_SLICE;
300096b4:	e59d3000 	ldr	r3, [sp]
300096b8:	e3a02018 	mov	r2, #24
300096bc:	e5c3200c 	strb	r2, [r3, #12]
						((slice_policy_data_t *)data)->slice_ld=TIME_TO_TICKS(data->time<<POSIX_SLICE_RATE);
300096c0:	e59d1004 	ldr	r1, [sp, #4]
300096c4:	e59d3004 	ldr	r3, [sp, #4]
300096c8:	e5d33009 	ldrb	r3, [r3, #9]
300096cc:	e1a02283 	lsl	r2, r3, #5
300096d0:	e1a03002 	mov	r3, r2
300096d4:	e1a03103 	lsl	r3, r3, #2
300096d8:	e0833002 	add	r3, r3, r2
300096dc:	e1a02103 	lsl	r2, r3, #2
300096e0:	e0833002 	add	r3, r3, r2
300096e4:	e1a03103 	lsl	r3, r3, #2
300096e8:	e59f2090 	ldr	r2, [pc, #144]	; 30009780 <posix_delay_deal+0x18c>
300096ec:	e0c20293 	smull	r0, r2, r3, r2
300096f0:	e1a02342 	asr	r2, r2, #6
300096f4:	e1a03fc3 	asr	r3, r3, #31
300096f8:	e0633002 	rsb	r3, r3, r2
300096fc:	e5813000 	str	r3, [r1]
						data->stair--;
30009700:	e59d3004 	ldr	r3, [sp, #4]
30009704:	e5d33008 	ldrb	r3, [r3, #8]
30009708:	e2433001 	sub	r3, r3, #1
3000970c:	e20320ff 	and	r2, r3, #255	; 0xff
30009710:	e59d3004 	ldr	r3, [sp, #4]
30009714:	e5c32008 	strb	r2, [r3, #8]
					}
				}
				cur->slice=TIME_TO_TICKS(data->time<<POSIX_SLICE_RATE);
30009718:	e59d3004 	ldr	r3, [sp, #4]
3000971c:	e5d33009 	ldrb	r3, [r3, #9]
30009720:	e1a02283 	lsl	r2, r3, #5
30009724:	e1a03002 	mov	r3, r2
30009728:	e1a03103 	lsl	r3, r3, #2
3000972c:	e0833002 	add	r3, r3, r2
30009730:	e1a02103 	lsl	r2, r3, #2
30009734:	e0833002 	add	r3, r3, r2
30009738:	e1a03103 	lsl	r3, r3, #2
3000973c:	e59f203c 	ldr	r2, [pc, #60]	; 30009780 <posix_delay_deal+0x18c>
30009740:	e0c21293 	smull	r1, r2, r3, r2
30009744:	e1a02342 	asr	r2, r2, #6
30009748:	e1a03fc3 	asr	r3, r3, #31
3000974c:	e0633002 	rsb	r3, r3, r2
30009750:	e1a02003 	mov	r2, r3
30009754:	e59d3000 	ldr	r3, [sp]
30009758:	e5832044 	str	r2, [r3, #68]	; 0x44
				acoral_thread_change_prio(cur,data->stair);
3000975c:	e59d3004 	ldr	r3, [sp, #4]
30009760:	e5d33008 	ldrb	r3, [r3, #8]
30009764:	e59d0000 	ldr	r0, [sp]
30009768:	e1a01003 	mov	r1, r3
3000976c:	ebffe4c5 	bl	30002a88 <acoral_thread_change_prio>
			}
		}
#ifndef CFG_TICKS_PRIVATE
	}
#endif
}
30009770:	e28dd00c 	add	sp, sp, #12
30009774:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009778:	e12fff1e 	bx	lr
3000977c:	3002b350 	.word	0x3002b350
30009780:	10624dd3 	.word	0x10624dd3

30009784 <acoral_posix_create>:

void acoral_posix_create(acoral_id* id,acoral_posix_policy_data_t *data,void (*route)(void *args),void *args){
30009784:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009788:	e24dd01c 	sub	sp, sp, #28
3000978c:	e58d000c 	str	r0, [sp, #12]
30009790:	e58d1008 	str	r1, [sp, #8]
30009794:	e58d2004 	str	r2, [sp, #4]
30009798:	e58d3000 	str	r3, [sp]
	acoral_thread_t *thread;
	thread=acoral_alloc_thread();
3000979c:	ebffe52d 	bl	30002c58 <acoral_alloc_thread>
300097a0:	e1a03000 	mov	r3, r0
300097a4:	e58d3014 	str	r3, [sp, #20]
	if(NULL==thread){
300097a8:	e59d3014 	ldr	r3, [sp, #20]
300097ac:	e3530000 	cmp	r3, #0
300097b0:	1a000002 	bne	300097c0 <acoral_posix_create+0x3c>
		acoral_printerr("Alloc Posix thread fail\n");
300097b4:	e59f0084 	ldr	r0, [pc, #132]	; 30009840 <acoral_posix_create+0xbc>
300097b8:	eb00071a 	bl	3000b428 <acoral_print>
		acoral_printk("No Mem Space or Beyond the max thread\n");
		return ;
300097bc:	ea00001c 	b	30009834 <acoral_posix_create+0xb0>
	}
	thread->stack_size=0;
300097c0:	e59d3014 	ldr	r3, [sp, #20]
300097c4:	e3a02000 	mov	r2, #0
300097c8:	e583203c 	str	r2, [r3, #60]	; 0x3c
	thread->stack_buttom=NULL;
300097cc:	e59d3014 	ldr	r3, [sp, #20]
300097d0:	e3a02000 	mov	r2, #0
300097d4:	e5832038 	str	r2, [r3, #56]	; 0x38
	thread->name=NULL;
300097d8:	e59d3014 	ldr	r3, [sp, #20]
300097dc:	e3a02000 	mov	r2, #0
300097e0:	e5832048 	str	r2, [r3, #72]	; 0x48
	thread->policy=ACORAL_SCHED_POLICY_POSIX;
300097e4:	e59d3014 	ldr	r3, [sp, #20]
300097e8:	e3a02019 	mov	r2, #25
300097ec:	e5c3200c 	strb	r2, [r3, #12]
	if(id!=NULL)
300097f0:	e59d300c 	ldr	r3, [sp, #12]
300097f4:	e3530000 	cmp	r3, #0
300097f8:	0a000008 	beq	30009820 <acoral_posix_create+0x9c>
		*id=posix_policy_thread_init(thread,route,args,data);
300097fc:	e59d0014 	ldr	r0, [sp, #20]
30009800:	e59d1004 	ldr	r1, [sp, #4]
30009804:	e59d2000 	ldr	r2, [sp]
30009808:	e59d3008 	ldr	r3, [sp, #8]
3000980c:	eb00000c 	bl	30009844 <posix_policy_thread_init>
30009810:	e1a02000 	mov	r2, r0
30009814:	e59d300c 	ldr	r3, [sp, #12]
30009818:	e5832000 	str	r2, [r3]
3000981c:	ea000004 	b	30009834 <acoral_posix_create+0xb0>
	else
		posix_policy_thread_init(thread,route,args,data);
30009820:	e59d0014 	ldr	r0, [sp, #20]
30009824:	e59d1004 	ldr	r1, [sp, #4]
30009828:	e59d2000 	ldr	r2, [sp]
3000982c:	e59d3008 	ldr	r3, [sp, #8]
30009830:	eb000003 	bl	30009844 <posix_policy_thread_init>
}
30009834:	e28dd01c 	add	sp, sp, #28
30009838:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000983c:	e12fff1e 	bx	lr
30009840:	300263a4 	.word	0x300263a4

30009844 <posix_policy_thread_init>:

acoral_id posix_policy_thread_init(acoral_thread_t *thread,void (*route)(void *args),void *args,void *data){
30009844:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009848:	e24dd024 	sub	sp, sp, #36	; 0x24
3000984c:	e58d000c 	str	r0, [sp, #12]
30009850:	e58d1008 	str	r1, [sp, #8]
30009854:	e58d2004 	str	r2, [sp, #4]
30009858:	e58d3000 	str	r3, [sp]
	acoral_sr cpu_sr;
	acoral_posix_policy_data_t *policy_data;
	posix_policy_data_t *private_data;
	policy_data=(acoral_posix_policy_data_t *)data;
3000985c:	e59d3000 	ldr	r3, [sp]
30009860:	e58d3018 	str	r3, [sp, #24]
	private_data=(posix_policy_data_t *)posix_malloc(sizeof(posix_policy_data_t));
30009864:	e3a0000c 	mov	r0, #12
30009868:	ebfff565 	bl	30006e04 <v_malloc>
3000986c:	e1a03000 	mov	r3, r0
30009870:	e58d301c 	str	r3, [sp, #28]
	if(private_data==NULL){
30009874:	e59d301c 	ldr	r3, [sp, #28]
30009878:	e3530000 	cmp	r3, #0
3000987c:	1a00000e 	bne	300098bc <posix_policy_thread_init+0x78>
		acoral_printerr("No mem space for posix private_data:%s\n",thread->name);
30009880:	e59d300c 	ldr	r3, [sp, #12]
30009884:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30009888:	e59f01a4 	ldr	r0, [pc, #420]	; 30009a34 <posix_policy_thread_init+0x1f0>
3000988c:	e1a01003 	mov	r1, r3
30009890:	eb0006e4 	bl	3000b428 <acoral_print>
		HAL_ENTER_CRITICAL();
30009894:	ebffdf96 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30009898:	e1a03000 	mov	r3, r0
3000989c:	e58d3014 	str	r3, [sp, #20]
		acoral_release_res((acoral_res_t *)thread);
300098a0:	e59d300c 	ldr	r3, [sp, #12]
300098a4:	e1a00003 	mov	r0, r3
300098a8:	ebffe75c 	bl	30003620 <acoral_release_res>
		HAL_EXIT_CRITICAL();
300098ac:	e59d0014 	ldr	r0, [sp, #20]
300098b0:	ebffdf8d 	bl	300016ec <HAL_INTR_RESTORE>
		return -1;
300098b4:	e3e03000 	mvn	r3, #0
300098b8:	ea000059 	b	30009a24 <posix_policy_thread_init+0x1e0>
	}
	posix_policy_data_init(private_data);
300098bc:	e59d001c 	ldr	r0, [sp, #28]
300098c0:	eb000069 	bl	30009a6c <posix_policy_data_init>
	if(policy_data!=NULL){
300098c4:	e59d3018 	ldr	r3, [sp, #24]
300098c8:	e3530000 	cmp	r3, #0
300098cc:	0a000014 	beq	30009924 <posix_policy_thread_init+0xe0>
		private_data->attach_state=policy_data->attach_state;
300098d0:	e59d3018 	ldr	r3, [sp, #24]
300098d4:	e5d32004 	ldrb	r2, [r3, #4]
300098d8:	e59d301c 	ldr	r3, [sp, #28]
300098dc:	e5c32004 	strb	r2, [r3, #4]
		private_data->cpu_mask=policy_data->cpu_mask;
300098e0:	e59d3018 	ldr	r3, [sp, #24]
300098e4:	e5933008 	ldr	r3, [r3, #8]
300098e8:	e20320ff 	and	r2, r3, #255	; 0xff
300098ec:	e59d301c 	ldr	r3, [sp, #28]
300098f0:	e5c32007 	strb	r2, [r3, #7]
		private_data->cancel_type=policy_data->cancel_type;
300098f4:	e59d3018 	ldr	r3, [sp, #24]
300098f8:	e5d32005 	ldrb	r2, [r3, #5]
300098fc:	e59d301c 	ldr	r3, [sp, #28]
30009900:	e5c32005 	strb	r2, [r3, #5]
		private_data->cancel_enable=policy_data->cancel_enable;
30009904:	e59d3018 	ldr	r3, [sp, #24]
30009908:	e5d32006 	ldrb	r2, [r3, #6]
3000990c:	e59d301c 	ldr	r3, [sp, #28]
30009910:	e5c32006 	strb	r2, [r3, #6]
		thread->stack_size=policy_data->stack_size;
30009914:	e59d3018 	ldr	r3, [sp, #24]
30009918:	e593200c 	ldr	r2, [r3, #12]
3000991c:	e59d300c 	ldr	r3, [sp, #12]
30009920:	e583203c 	str	r2, [r3, #60]	; 0x3c
	}
	thread->private_data=private_data;
30009924:	e59d300c 	ldr	r3, [sp, #12]
30009928:	e59d201c 	ldr	r2, [sp, #28]
3000992c:	e5832050 	str	r2, [r3, #80]	; 0x50
	if(thread->stack_size==0)
30009930:	e59d300c 	ldr	r3, [sp, #12]
30009934:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
30009938:	e3530000 	cmp	r3, #0
3000993c:	1a000002 	bne	3000994c <posix_policy_thread_init+0x108>
		thread->stack_size=POSIX_DEFAULT_STACK_SIZE;
30009940:	e59d300c 	ldr	r3, [sp, #12]
30009944:	e3a02b05 	mov	r2, #5120	; 0x1400
30009948:	e583203c 	str	r2, [r3, #60]	; 0x3c
	thread->cpu=-1;
3000994c:	e59d300c 	ldr	r3, [sp, #12]
30009950:	e3e02000 	mvn	r2, #0
30009954:	e5c32006 	strb	r2, [r3, #6]
	thread->cpu_mask=-1;
30009958:	e59d300c 	ldr	r3, [sp, #12]
3000995c:	e3e02000 	mvn	r2, #0
30009960:	e5832008 	str	r2, [r3, #8]
	thread->prio=private_data->stair;
30009964:	e59d301c 	ldr	r3, [sp, #28]
30009968:	e5d32008 	ldrb	r2, [r3, #8]
3000996c:	e59d300c 	ldr	r3, [sp, #12]
30009970:	e5c32005 	strb	r2, [r3, #5]
	thread->slice=TIME_TO_TICKS(private_data->time<<POSIX_SLICE_RATE);
30009974:	e59d301c 	ldr	r3, [sp, #28]
30009978:	e5d33009 	ldrb	r3, [r3, #9]
3000997c:	e1a02283 	lsl	r2, r3, #5
30009980:	e1a03002 	mov	r3, r2
30009984:	e1a03103 	lsl	r3, r3, #2
30009988:	e0833002 	add	r3, r3, r2
3000998c:	e1a02103 	lsl	r2, r3, #2
30009990:	e0833002 	add	r3, r3, r2
30009994:	e1a03103 	lsl	r3, r3, #2
30009998:	e59f2098 	ldr	r2, [pc, #152]	; 30009a38 <posix_policy_thread_init+0x1f4>
3000999c:	e0c21293 	smull	r1, r2, r3, r2
300099a0:	e1a02342 	asr	r2, r2, #6
300099a4:	e1a03fc3 	asr	r3, r3, #31
300099a8:	e0633002 	rsb	r3, r3, r2
300099ac:	e1a02003 	mov	r2, r3
300099b0:	e59d300c 	ldr	r3, [sp, #12]
300099b4:	e5832044 	str	r2, [r3, #68]	; 0x44
	if(acoral_thread_init(thread,route,acoral_thread_exit,args)!=0){
300099b8:	e59d000c 	ldr	r0, [sp, #12]
300099bc:	e59d1008 	ldr	r1, [sp, #8]
300099c0:	e59f2074 	ldr	r2, [pc, #116]	; 30009a3c <posix_policy_thread_init+0x1f8>
300099c4:	e59d3004 	ldr	r3, [sp, #4]
300099c8:	ebffe4aa 	bl	30002c78 <acoral_thread_init>
300099cc:	e1a03000 	mov	r3, r0
300099d0:	e3530000 	cmp	r3, #0
300099d4:	0a00000e 	beq	30009a14 <posix_policy_thread_init+0x1d0>
		acoral_printerr("No thread stack:%s\n",thread->name);
300099d8:	e59d300c 	ldr	r3, [sp, #12]
300099dc:	e5933048 	ldr	r3, [r3, #72]	; 0x48
300099e0:	e59f0058 	ldr	r0, [pc, #88]	; 30009a40 <posix_policy_thread_init+0x1fc>
300099e4:	e1a01003 	mov	r1, r3
300099e8:	eb00068e 	bl	3000b428 <acoral_print>
		HAL_ENTER_CRITICAL();
300099ec:	ebffdf40 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300099f0:	e1a03000 	mov	r3, r0
300099f4:	e58d3014 	str	r3, [sp, #20]
		acoral_release_res((acoral_res_t *)thread);
300099f8:	e59d300c 	ldr	r3, [sp, #12]
300099fc:	e1a00003 	mov	r0, r3
30009a00:	ebffe706 	bl	30003620 <acoral_release_res>
		HAL_EXIT_CRITICAL();
30009a04:	e59d0014 	ldr	r0, [sp, #20]
30009a08:	ebffdf37 	bl	300016ec <HAL_INTR_RESTORE>
		return -1;
30009a0c:	e3e03000 	mvn	r3, #0
30009a10:	ea000003 	b	30009a24 <posix_policy_thread_init+0x1e0>
	}
	acoral_resume_thread(thread);
30009a14:	e59d000c 	ldr	r0, [sp, #12]
30009a18:	ebffe38d 	bl	30002854 <acoral_resume_thread>
	return thread->res.id;
30009a1c:	e59d300c 	ldr	r3, [sp, #12]
30009a20:	e5933000 	ldr	r3, [r3]
}
30009a24:	e1a00003 	mov	r0, r3
30009a28:	e28dd024 	add	sp, sp, #36	; 0x24
30009a2c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009a30:	e12fff1e 	bx	lr
30009a34:	300263c0 	.word	0x300263c0
30009a38:	10624dd3 	.word	0x10624dd3
30009a3c:	30002a68 	.word	0x30002a68
30009a40:	300263e8 	.word	0x300263e8

30009a44 <posix_policy_thread_release>:

void posix_policy_thread_release(acoral_thread_t *thread){
30009a44:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009a48:	e24dd00c 	sub	sp, sp, #12
30009a4c:	e58d0004 	str	r0, [sp, #4]
	posix_free(thread->private_data);
30009a50:	e59d3004 	ldr	r3, [sp, #4]
30009a54:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30009a58:	e1a00003 	mov	r0, r3
30009a5c:	ebfff4fd 	bl	30006e58 <v_free>
}
30009a60:	e28dd00c 	add	sp, sp, #12
30009a64:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009a68:	e12fff1e 	bx	lr

30009a6c <posix_policy_data_init>:

void posix_policy_data_init(posix_policy_data_t *private_data){
30009a6c:	e24dd008 	sub	sp, sp, #8
30009a70:	e58d0004 	str	r0, [sp, #4]
	private_data->attach_state=POSIX_JOINABLE;
30009a74:	e59d3004 	ldr	r3, [sp, #4]
30009a78:	e3a02001 	mov	r2, #1
30009a7c:	e5c32004 	strb	r2, [r3, #4]
	private_data->cancel_type=POSIX_CANCEL_DEFER;
30009a80:	e59d3004 	ldr	r3, [sp, #4]
30009a84:	e3a02000 	mov	r2, #0
30009a88:	e5c32005 	strb	r2, [r3, #5]
	private_data->cancel_enable=true;
30009a8c:	e59d3004 	ldr	r3, [sp, #4]
30009a90:	e3a02001 	mov	r2, #1
30009a94:	e5c32006 	strb	r2, [r3, #6]
	private_data->cpu_mask=0xff;
30009a98:	e59d3004 	ldr	r3, [sp, #4]
30009a9c:	e3e02000 	mvn	r2, #0
30009aa0:	e5c32007 	strb	r2, [r3, #7]
	private_data->stair=ACORAL_POSIX_PRIO_MIN;
30009aa4:	e59d3004 	ldr	r3, [sp, #4]
30009aa8:	e3a02027 	mov	r2, #39	; 0x27
30009aac:	e5c32008 	strb	r2, [r3, #8]
	private_data->time=1;
30009ab0:	e59d3004 	ldr	r3, [sp, #4]
30009ab4:	e3a02001 	mov	r2, #1
30009ab8:	e5c32009 	strb	r2, [r3, #9]
}
30009abc:	e28dd008 	add	sp, sp, #8
30009ac0:	e12fff1e 	bx	lr

30009ac4 <posix_policy_init>:

acoral_sched_policy_t posix_policy;
void posix_policy_init(){
30009ac4:	e92d4008 	push	{r3, lr}
	posix_policy.type=ACORAL_SCHED_POLICY_POSIX;
30009ac8:	e59f3044 	ldr	r3, [pc, #68]	; 30009b14 <posix_policy_init+0x50>
30009acc:	e3a02019 	mov	r2, #25
30009ad0:	e5c32008 	strb	r2, [r3, #8]
	posix_policy.policy_thread_init=posix_policy_thread_init;
30009ad4:	e59f3038 	ldr	r3, [pc, #56]	; 30009b14 <posix_policy_init+0x50>
30009ad8:	e59f2038 	ldr	r2, [pc, #56]	; 30009b18 <posix_policy_init+0x54>
30009adc:	e583200c 	str	r2, [r3, #12]
	posix_policy.policy_thread_release=posix_policy_thread_release;
30009ae0:	e59f302c 	ldr	r3, [pc, #44]	; 30009b14 <posix_policy_init+0x50>
30009ae4:	e59f2030 	ldr	r2, [pc, #48]	; 30009b1c <posix_policy_init+0x58>
30009ae8:	e5832010 	str	r2, [r3, #16]
	posix_policy.delay_deal=posix_delay_deal;
30009aec:	e59f3020 	ldr	r3, [pc, #32]	; 30009b14 <posix_policy_init+0x50>
30009af0:	e59f2028 	ldr	r2, [pc, #40]	; 30009b20 <posix_policy_init+0x5c>
30009af4:	e5832014 	str	r2, [r3, #20]
	posix_policy.name="posix";
30009af8:	e59f3014 	ldr	r3, [pc, #20]	; 30009b14 <posix_policy_init+0x50>
30009afc:	e59f2020 	ldr	r2, [pc, #32]	; 30009b24 <posix_policy_init+0x60>
30009b00:	e5832018 	str	r2, [r3, #24]
	acoral_register_sched_policy(&posix_policy);
30009b04:	e59f0008 	ldr	r0, [pc, #8]	; 30009b14 <posix_policy_init+0x50>
30009b08:	ebffe0d4 	bl	30001e60 <acoral_register_sched_policy>
}
30009b0c:	e8bd4008 	pop	{r3, lr}
30009b10:	e12fff1e 	bx	lr
30009b14:	3002a130 	.word	0x3002a130
30009b18:	30009844 	.word	0x30009844
30009b1c:	30009a44 	.word	0x30009a44
30009b20:	300095f4 	.word	0x300095f4
30009b24:	300263fc 	.word	0x300263fc

30009b28 <delay>:
#include<hal.h>
#include<cpu.h>
#include<policy.h>
acoral_u32 sample_100ms;
volatile acoral_u32 sample;
void delay(){
30009b28:	e24dd008 	sub	sp, sp, #8
	volatile acoral_32 tmp=0xfff;
30009b2c:	e3a03eff 	mov	r3, #4080	; 0xff0
30009b30:	e283300f 	add	r3, r3, #15
30009b34:	e58d3004 	str	r3, [sp, #4]
	while(tmp-->0);
30009b38:	e59d3004 	ldr	r3, [sp, #4]
30009b3c:	e3530000 	cmp	r3, #0
30009b40:	d3a02000 	movle	r2, #0
30009b44:	c3a02001 	movgt	r2, #1
30009b48:	e20220ff 	and	r2, r2, #255	; 0xff
30009b4c:	e2433001 	sub	r3, r3, #1
30009b50:	e58d3004 	str	r3, [sp, #4]
30009b54:	e3520000 	cmp	r2, #0
30009b58:	1afffff6 	bne	30009b38 <delay+0x10>
	sample++;
30009b5c:	e59f3014 	ldr	r3, [pc, #20]	; 30009b78 <delay+0x50>
30009b60:	e5933000 	ldr	r3, [r3]
30009b64:	e2832001 	add	r2, r3, #1
30009b68:	e59f3008 	ldr	r3, [pc, #8]	; 30009b78 <delay+0x50>
30009b6c:	e5832000 	str	r2, [r3]
}
30009b70:	e28dd008 	add	sp, sp, #8
30009b74:	e12fff1e 	bx	lr
30009b78:	3002b374 	.word	0x3002b374

30009b7c <delay_task>:

void delay_task(void *args){
30009b7c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009b80:	e24dd00c 	sub	sp, sp, #12
30009b84:	e58d0004 	str	r0, [sp, #4]
	sample=0;
30009b88:	e59f300c 	ldr	r3, [pc, #12]	; 30009b9c <delay_task+0x20>
30009b8c:	e3a02000 	mov	r2, #0
30009b90:	e5832000 	str	r2, [r3]
	for(;;){
		delay();
30009b94:	ebffffe3 	bl	30009b28 <delay>
	}
30009b98:	eafffffd 	b	30009b94 <delay_task+0x18>
30009b9c:	3002b374 	.word	0x3002b374

30009ba0 <acoral_soft_delay>:
}

void acoral_soft_delay(acoral_u32 n100ms){
30009ba0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009ba4:	e24dd014 	sub	sp, sp, #20
30009ba8:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 i;
	acoral_u32 tmp=n100ms*sample_100ms;	
30009bac:	e59f3044 	ldr	r3, [pc, #68]	; 30009bf8 <acoral_soft_delay+0x58>
30009bb0:	e5932000 	ldr	r2, [r3]
30009bb4:	e59d3004 	ldr	r3, [sp, #4]
30009bb8:	e0030392 	mul	r3, r2, r3
30009bbc:	e58d300c 	str	r3, [sp, #12]
	for(i=0;i<tmp;i++)
30009bc0:	e3a03000 	mov	r3, #0
30009bc4:	e58d3008 	str	r3, [sp, #8]
30009bc8:	ea000003 	b	30009bdc <acoral_soft_delay+0x3c>
		delay();
30009bcc:	ebffffd5 	bl	30009b28 <delay>
}

void acoral_soft_delay(acoral_u32 n100ms){
	acoral_u32 i;
	acoral_u32 tmp=n100ms*sample_100ms;	
	for(i=0;i<tmp;i++)
30009bd0:	e59d3008 	ldr	r3, [sp, #8]
30009bd4:	e2833001 	add	r3, r3, #1
30009bd8:	e58d3008 	str	r3, [sp, #8]
30009bdc:	e59d2008 	ldr	r2, [sp, #8]
30009be0:	e59d300c 	ldr	r3, [sp, #12]
30009be4:	e1520003 	cmp	r2, r3
30009be8:	3afffff7 	bcc	30009bcc <acoral_soft_delay+0x2c>
		delay();
}
30009bec:	e28dd014 	add	sp, sp, #20
30009bf0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009bf4:	e12fff1e 	bx	lr
30009bf8:	3002a814 	.word	0x3002a814

30009bfc <soft_delay_init>:

void soft_delay_init(){
30009bfc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009c00:	e24dd024 	sub	sp, sp, #36	; 0x24
	acoral_sr cpu_sr;
	acoral_comm_policy_data_t data;
	acoral_thread_t *thread;
	acoral_id tmp_id;
	data.cpu=acoral_current_cpu;
30009c04:	e3a03000 	mov	r3, #0
30009c08:	e5cd3010 	strb	r3, [sp, #16]
	data.prio=ACORAL_TMP_PRIO;
30009c0c:	e3a03045 	mov	r3, #69	; 0x45
30009c10:	e5cd3011 	strb	r3, [sp, #17]
	data.prio_type=ACORAL_ABSOLUTE_PRIO;
30009c14:	e3a03004 	mov	r3, #4
30009c18:	e5cd3012 	strb	r3, [sp, #18]
	tmp_id=acoral_create_thread_ext(delay_task,256,NULL,"softdelay",NULL,ACORAL_SCHED_POLICY_COMM,&data);
30009c1c:	e3a03000 	mov	r3, #0
30009c20:	e58d3000 	str	r3, [sp]
30009c24:	e3a03015 	mov	r3, #21
30009c28:	e58d3004 	str	r3, [sp, #4]
30009c2c:	e28d3010 	add	r3, sp, #16
30009c30:	e58d3008 	str	r3, [sp, #8]
30009c34:	e59f0090 	ldr	r0, [pc, #144]	; 30009ccc <soft_delay_init+0xd0>
30009c38:	e3a01c01 	mov	r1, #256	; 0x100
30009c3c:	e3a02000 	mov	r2, #0
30009c40:	e59f3088 	ldr	r3, [pc, #136]	; 30009cd0 <soft_delay_init+0xd4>
30009c44:	ebffe000 	bl	30001c4c <create_thread_ext>
30009c48:	e1a03000 	mov	r3, r0
30009c4c:	e58d301c 	str	r3, [sp, #28]
	if(tmp_id==-1)
30009c50:	e59d301c 	ldr	r3, [sp, #28]
30009c54:	e3730001 	cmn	r3, #1
30009c58:	0a000017 	beq	30009cbc <soft_delay_init+0xc0>
		return;
	acoral_delay_self(1000);
30009c5c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
30009c60:	ebffe341 	bl	3000296c <acoral_delay_self>
	sample_100ms=sample/10;
30009c64:	e59f3068 	ldr	r3, [pc, #104]	; 30009cd4 <soft_delay_init+0xd8>
30009c68:	e5932000 	ldr	r2, [r3]
30009c6c:	e59f3064 	ldr	r3, [pc, #100]	; 30009cd8 <soft_delay_init+0xdc>
30009c70:	e0831392 	umull	r1, r3, r2, r3
30009c74:	e1a021a3 	lsr	r2, r3, #3
30009c78:	e59f305c 	ldr	r3, [pc, #92]	; 30009cdc <soft_delay_init+0xe0>
30009c7c:	e5832000 	str	r2, [r3]
	/*这里daemo回收进程还没启动，不能使用acoral_kill_thread*/
	thread=(acoral_thread_t *)acoral_get_res_by_id(tmp_id);
30009c80:	e59d001c 	ldr	r0, [sp, #28]
30009c84:	ebffe6f9 	bl	30003870 <acoral_get_res_by_id>
30009c88:	e1a03000 	mov	r3, r0
30009c8c:	e58d3018 	str	r3, [sp, #24]
	HAL_ENTER_CRITICAL();
30009c90:	ebffde97 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30009c94:	e1a03000 	mov	r3, r0
30009c98:	e58d3014 	str	r3, [sp, #20]
	acoral_unrdy_thread(thread);
30009c9c:	e59d0018 	ldr	r0, [sp, #24]
30009ca0:	ebffe3c1 	bl	30002bac <acoral_unrdy_thread>
	acoral_release_thread((acoral_res_t *)thread);
30009ca4:	e59d3018 	ldr	r3, [sp, #24]
30009ca8:	e1a00003 	mov	r0, r3
30009cac:	ebffe29c 	bl	30002724 <acoral_release_thread>
	HAL_EXIT_CRITICAL();
30009cb0:	e59d0014 	ldr	r0, [sp, #20]
30009cb4:	ebffde8c 	bl	300016ec <HAL_INTR_RESTORE>
30009cb8:	ea000000 	b	30009cc0 <soft_delay_init+0xc4>
	data.cpu=acoral_current_cpu;
	data.prio=ACORAL_TMP_PRIO;
	data.prio_type=ACORAL_ABSOLUTE_PRIO;
	tmp_id=acoral_create_thread_ext(delay_task,256,NULL,"softdelay",NULL,ACORAL_SCHED_POLICY_COMM,&data);
	if(tmp_id==-1)
		return;
30009cbc:	e1a00000 	nop			; (mov r0, r0)
	thread=(acoral_thread_t *)acoral_get_res_by_id(tmp_id);
	HAL_ENTER_CRITICAL();
	acoral_unrdy_thread(thread);
	acoral_release_thread((acoral_res_t *)thread);
	HAL_EXIT_CRITICAL();
}
30009cc0:	e28dd024 	add	sp, sp, #36	; 0x24
30009cc4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009cc8:	e12fff1e 	bx	lr
30009ccc:	30009b7c 	.word	0x30009b7c
30009cd0:	30026404 	.word	0x30026404
30009cd4:	3002b374 	.word	0x3002b374
30009cd8:	cccccccd 	.word	0xcccccccd
30009cdc:	3002a814 	.word	0x3002a814

30009ce0 <dummy_print>:
#include<type.h>
acoral_32 dummy_print(const acoral_char *fmt, ...){
30009ce0:	e92d000f 	push	{r0, r1, r2, r3}
}
30009ce4:	e28dd010 	add	sp, sp, #16
30009ce8:	e12fff1e 	bx	lr

30009cec <acoral_ffs>:
#include<type.h>
#include<bitops.h>
acoral_u32 acoral_ffs(acoral_u32 word)
{
30009cec:	e24dd010 	sub	sp, sp, #16
30009cf0:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 k;
	k = 31;
30009cf4:	e3a0301f 	mov	r3, #31
30009cf8:	e58d300c 	str	r3, [sp, #12]
	if (word & 0x0000ffff) { k -= 16; word <<= 16; }
30009cfc:	e59d3004 	ldr	r3, [sp, #4]
30009d00:	e1a03803 	lsl	r3, r3, #16
30009d04:	e1a03823 	lsr	r3, r3, #16
30009d08:	e3530000 	cmp	r3, #0
30009d0c:	0a000005 	beq	30009d28 <acoral_ffs+0x3c>
30009d10:	e59d300c 	ldr	r3, [sp, #12]
30009d14:	e2433010 	sub	r3, r3, #16
30009d18:	e58d300c 	str	r3, [sp, #12]
30009d1c:	e59d3004 	ldr	r3, [sp, #4]
30009d20:	e1a03803 	lsl	r3, r3, #16
30009d24:	e58d3004 	str	r3, [sp, #4]
	if (word & 0x00ff0000) { k -= 8;  word <<= 8;  }
30009d28:	e59d3004 	ldr	r3, [sp, #4]
30009d2c:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
30009d30:	e3530000 	cmp	r3, #0
30009d34:	0a000005 	beq	30009d50 <acoral_ffs+0x64>
30009d38:	e59d300c 	ldr	r3, [sp, #12]
30009d3c:	e2433008 	sub	r3, r3, #8
30009d40:	e58d300c 	str	r3, [sp, #12]
30009d44:	e59d3004 	ldr	r3, [sp, #4]
30009d48:	e1a03403 	lsl	r3, r3, #8
30009d4c:	e58d3004 	str	r3, [sp, #4]
	if (word & 0x0f000000) { k -= 4;  word <<= 4;  }
30009d50:	e59d3004 	ldr	r3, [sp, #4]
30009d54:	e203340f 	and	r3, r3, #251658240	; 0xf000000
30009d58:	e3530000 	cmp	r3, #0
30009d5c:	0a000005 	beq	30009d78 <acoral_ffs+0x8c>
30009d60:	e59d300c 	ldr	r3, [sp, #12]
30009d64:	e2433004 	sub	r3, r3, #4
30009d68:	e58d300c 	str	r3, [sp, #12]
30009d6c:	e59d3004 	ldr	r3, [sp, #4]
30009d70:	e1a03203 	lsl	r3, r3, #4
30009d74:	e58d3004 	str	r3, [sp, #4]
	if (word & 0x30000000) { k -= 2;  word <<= 2;  }
30009d78:	e59d3004 	ldr	r3, [sp, #4]
30009d7c:	e2033203 	and	r3, r3, #805306368	; 0x30000000
30009d80:	e3530000 	cmp	r3, #0
30009d84:	0a000005 	beq	30009da0 <acoral_ffs+0xb4>
30009d88:	e59d300c 	ldr	r3, [sp, #12]
30009d8c:	e2433002 	sub	r3, r3, #2
30009d90:	e58d300c 	str	r3, [sp, #12]
30009d94:	e59d3004 	ldr	r3, [sp, #4]
30009d98:	e1a03103 	lsl	r3, r3, #2
30009d9c:	e58d3004 	str	r3, [sp, #4]
	if (word & 0x40000000) { k -= 1; }
30009da0:	e59d3004 	ldr	r3, [sp, #4]
30009da4:	e2033101 	and	r3, r3, #1073741824	; 0x40000000
30009da8:	e3530000 	cmp	r3, #0
30009dac:	0a000002 	beq	30009dbc <acoral_ffs+0xd0>
30009db0:	e59d300c 	ldr	r3, [sp, #12]
30009db4:	e2433001 	sub	r3, r3, #1
30009db8:	e58d300c 	str	r3, [sp, #12]
        return k;
30009dbc:	e59d300c 	ldr	r3, [sp, #12]
}
30009dc0:	e1a00003 	mov	r0, r3
30009dc4:	e28dd010 	add	sp, sp, #16
30009dc8:	e12fff1e 	bx	lr

30009dcc <acoral_find_first_bit>:

acoral_u32 acoral_find_first_bit(const acoral_u32 *b,acoral_u32 length)
{
30009dcc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009dd0:	e24dd014 	sub	sp, sp, #20
30009dd4:	e58d0004 	str	r0, [sp, #4]
30009dd8:	e58d1000 	str	r1, [sp]
	acoral_u32 v;
	acoral_u32 off;

	for (off = 0; v = b[off], off < length; off++) {
30009ddc:	e3a03000 	mov	r3, #0
30009de0:	e58d300c 	str	r3, [sp, #12]
30009de4:	ea000005 	b	30009e00 <acoral_find_first_bit+0x34>
		if (v)
30009de8:	e59d3008 	ldr	r3, [sp, #8]
30009dec:	e3530000 	cmp	r3, #0
30009df0:	1a00000d 	bne	30009e2c <acoral_find_first_bit+0x60>
acoral_u32 acoral_find_first_bit(const acoral_u32 *b,acoral_u32 length)
{
	acoral_u32 v;
	acoral_u32 off;

	for (off = 0; v = b[off], off < length; off++) {
30009df4:	e59d300c 	ldr	r3, [sp, #12]
30009df8:	e2833001 	add	r3, r3, #1
30009dfc:	e58d300c 	str	r3, [sp, #12]
30009e00:	e59d300c 	ldr	r3, [sp, #12]
30009e04:	e1a02103 	lsl	r2, r3, #2
30009e08:	e59d3004 	ldr	r3, [sp, #4]
30009e0c:	e0823003 	add	r3, r2, r3
30009e10:	e5933000 	ldr	r3, [r3]
30009e14:	e58d3008 	str	r3, [sp, #8]
30009e18:	e59d200c 	ldr	r2, [sp, #12]
30009e1c:	e59d3000 	ldr	r3, [sp]
30009e20:	e1520003 	cmp	r2, r3
30009e24:	3affffef 	bcc	30009de8 <acoral_find_first_bit+0x1c>
30009e28:	ea000000 	b	30009e30 <acoral_find_first_bit+0x64>
		if (v)
			break;
30009e2c:	e1a00000 	nop			; (mov r0, r0)
	}
	return acoral_ffs(v) + off * 32;
30009e30:	e59d0008 	ldr	r0, [sp, #8]
30009e34:	ebffffac 	bl	30009cec <acoral_ffs>
30009e38:	e1a02000 	mov	r2, r0
30009e3c:	e59d300c 	ldr	r3, [sp, #12]
30009e40:	e1a03283 	lsl	r3, r3, #5
30009e44:	e0823003 	add	r3, r2, r3
}
30009e48:	e1a00003 	mov	r0, r3
30009e4c:	e28dd014 	add	sp, sp, #20
30009e50:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009e54:	e12fff1e 	bx	lr

30009e58 <acoral_set_bit>:

void acoral_set_bit(acoral_32 nr,acoral_u32 *bitmap)
{
30009e58:	e24dd018 	sub	sp, sp, #24
30009e5c:	e58d0004 	str	r0, [sp, #4]
30009e60:	e58d1000 	str	r1, [sp]
	acoral_u32 oldval, mask = 1UL << (nr & 31);
30009e64:	e59d3004 	ldr	r3, [sp, #4]
30009e68:	e203301f 	and	r3, r3, #31
30009e6c:	e3a02001 	mov	r2, #1
30009e70:	e1a03312 	lsl	r3, r2, r3
30009e74:	e58d3010 	str	r3, [sp, #16]
	acoral_u32 *p;
	p =bitmap+(nr>>5);
30009e78:	e59d3004 	ldr	r3, [sp, #4]
30009e7c:	e1a032c3 	asr	r3, r3, #5
30009e80:	e1a03103 	lsl	r3, r3, #2
30009e84:	e59d2000 	ldr	r2, [sp]
30009e88:	e0823003 	add	r3, r2, r3
30009e8c:	e58d3014 	str	r3, [sp, #20]
	oldval = *p;
30009e90:	e59d3014 	ldr	r3, [sp, #20]
30009e94:	e5933000 	ldr	r3, [r3]
30009e98:	e58d300c 	str	r3, [sp, #12]
	*p = oldval | mask;
30009e9c:	e59d200c 	ldr	r2, [sp, #12]
30009ea0:	e59d3010 	ldr	r3, [sp, #16]
30009ea4:	e1822003 	orr	r2, r2, r3
30009ea8:	e59d3014 	ldr	r3, [sp, #20]
30009eac:	e5832000 	str	r2, [r3]
}
30009eb0:	e28dd018 	add	sp, sp, #24
30009eb4:	e12fff1e 	bx	lr

30009eb8 <acoral_clear_bit>:

void acoral_clear_bit(acoral_32 nr,acoral_u32 *bitmap)
{
30009eb8:	e24dd018 	sub	sp, sp, #24
30009ebc:	e58d0004 	str	r0, [sp, #4]
30009ec0:	e58d1000 	str	r1, [sp]
	acoral_u32 oldval, mask = 1UL << (nr & 31);
30009ec4:	e59d3004 	ldr	r3, [sp, #4]
30009ec8:	e203301f 	and	r3, r3, #31
30009ecc:	e3a02001 	mov	r2, #1
30009ed0:	e1a03312 	lsl	r3, r2, r3
30009ed4:	e58d3010 	str	r3, [sp, #16]
	acoral_u32 *p;
	p =bitmap+(nr >> 5);
30009ed8:	e59d3004 	ldr	r3, [sp, #4]
30009edc:	e1a032c3 	asr	r3, r3, #5
30009ee0:	e1a03103 	lsl	r3, r3, #2
30009ee4:	e59d2000 	ldr	r2, [sp]
30009ee8:	e0823003 	add	r3, r2, r3
30009eec:	e58d3014 	str	r3, [sp, #20]
	oldval = *p;
30009ef0:	e59d3014 	ldr	r3, [sp, #20]
30009ef4:	e5933000 	ldr	r3, [r3]
30009ef8:	e58d300c 	str	r3, [sp, #12]
	*p = oldval &(~mask);
30009efc:	e59d3010 	ldr	r3, [sp, #16]
30009f00:	e1e02003 	mvn	r2, r3
30009f04:	e59d300c 	ldr	r3, [sp, #12]
30009f08:	e0022003 	and	r2, r2, r3
30009f0c:	e59d3014 	ldr	r3, [sp, #20]
30009f10:	e5832000 	str	r2, [r3]
}
30009f14:	e28dd018 	add	sp, sp, #24
30009f18:	e12fff1e 	bx	lr

30009f1c <acoral_get_bit>:

acoral_u32 acoral_get_bit(acoral_32 nr,acoral_u32 *bitmap)
{
30009f1c:	e24dd018 	sub	sp, sp, #24
30009f20:	e58d0004 	str	r0, [sp, #4]
30009f24:	e58d1000 	str	r1, [sp]
	acoral_u32 oldval, mask = 1UL << (nr & 31);
30009f28:	e59d3004 	ldr	r3, [sp, #4]
30009f2c:	e203301f 	and	r3, r3, #31
30009f30:	e3a02001 	mov	r2, #1
30009f34:	e1a03312 	lsl	r3, r2, r3
30009f38:	e58d3010 	str	r3, [sp, #16]
	acoral_u32 *p;
	p =bitmap+(nr>>5);
30009f3c:	e59d3004 	ldr	r3, [sp, #4]
30009f40:	e1a032c3 	asr	r3, r3, #5
30009f44:	e1a03103 	lsl	r3, r3, #2
30009f48:	e59d2000 	ldr	r2, [sp]
30009f4c:	e0823003 	add	r3, r2, r3
30009f50:	e58d3014 	str	r3, [sp, #20]
	oldval = *p;
30009f54:	e59d3014 	ldr	r3, [sp, #20]
30009f58:	e5933000 	ldr	r3, [r3]
30009f5c:	e58d300c 	str	r3, [sp, #12]
	return oldval & mask;
30009f60:	e59d200c 	ldr	r2, [sp, #12]
30009f64:	e59d3010 	ldr	r3, [sp, #16]
30009f68:	e0023003 	and	r3, r2, r3
}
30009f6c:	e1a00003 	mov	r0, r3
30009f70:	e28dd018 	add	sp, sp, #24
30009f74:	e12fff1e 	bx	lr

30009f78 <acoral_prio_queue_add>:
#include<queue.h>
#include<list.h>
#include<bitops.h>
void acoral_prio_queue_add(acoral_prio_array_t *array,acoral_u8 prio,acoral_list_t *list){
30009f78:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009f7c:	e24dd01c 	sub	sp, sp, #28
30009f80:	e58d000c 	str	r0, [sp, #12]
30009f84:	e1a03001 	mov	r3, r1
30009f88:	e58d2004 	str	r2, [sp, #4]
30009f8c:	e5cd300b 	strb	r3, [sp, #11]
	acoral_queue_t *queue;
	acoral_list_t *head;
	array->num++;
30009f90:	e59d300c 	ldr	r3, [sp, #12]
30009f94:	e5933000 	ldr	r3, [r3]
30009f98:	e2832001 	add	r2, r3, #1
30009f9c:	e59d300c 	ldr	r3, [sp, #12]
30009fa0:	e5832000 	str	r2, [r3]
        queue=array->queue + prio;
30009fa4:	e59d300c 	ldr	r3, [sp, #12]
30009fa8:	e2831010 	add	r1, r3, #16
30009fac:	e5dd200b 	ldrb	r2, [sp, #11]
30009fb0:	e1a03002 	mov	r3, r2
30009fb4:	e1a03083 	lsl	r3, r3, #1
30009fb8:	e0833002 	add	r3, r3, r2
30009fbc:	e1a03103 	lsl	r3, r3, #2
30009fc0:	e0813003 	add	r3, r1, r3
30009fc4:	e58d3010 	str	r3, [sp, #16]
	head=&queue->head;
30009fc8:	e59d3010 	ldr	r3, [sp, #16]
30009fcc:	e58d3014 	str	r3, [sp, #20]
	acoral_list_add2_tail(list,head);
30009fd0:	e59d0004 	ldr	r0, [sp, #4]
30009fd4:	e59d1014 	ldr	r1, [sp, #20]
30009fd8:	eb000080 	bl	3000a1e0 <acoral_list_add2_tail>
	acoral_set_bit(prio,array->bitmap);
30009fdc:	e5dd200b 	ldrb	r2, [sp, #11]
30009fe0:	e59d300c 	ldr	r3, [sp, #12]
30009fe4:	e2833004 	add	r3, r3, #4
30009fe8:	e1a00002 	mov	r0, r2
30009fec:	e1a01003 	mov	r1, r3
30009ff0:	ebffff98 	bl	30009e58 <acoral_set_bit>
}
30009ff4:	e28dd01c 	add	sp, sp, #28
30009ff8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009ffc:	e12fff1e 	bx	lr

3000a000 <acoral_prio_queue_del>:

void acoral_prio_queue_del(acoral_prio_array_t *array,acoral_u8 prio,acoral_list_t *list){
3000a000:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000a004:	e24dd01c 	sub	sp, sp, #28
3000a008:	e58d000c 	str	r0, [sp, #12]
3000a00c:	e1a03001 	mov	r3, r1
3000a010:	e58d2004 	str	r2, [sp, #4]
3000a014:	e5cd300b 	strb	r3, [sp, #11]
	acoral_queue_t *queue;
	acoral_list_t *head;
        queue= array->queue + prio;
3000a018:	e59d300c 	ldr	r3, [sp, #12]
3000a01c:	e2831010 	add	r1, r3, #16
3000a020:	e5dd200b 	ldrb	r2, [sp, #11]
3000a024:	e1a03002 	mov	r3, r2
3000a028:	e1a03083 	lsl	r3, r3, #1
3000a02c:	e0833002 	add	r3, r3, r2
3000a030:	e1a03103 	lsl	r3, r3, #2
3000a034:	e0813003 	add	r3, r1, r3
3000a038:	e58d3010 	str	r3, [sp, #16]
	head=&queue->head;
3000a03c:	e59d3010 	ldr	r3, [sp, #16]
3000a040:	e58d3014 	str	r3, [sp, #20]
	array->num--;
3000a044:	e59d300c 	ldr	r3, [sp, #12]
3000a048:	e5933000 	ldr	r3, [r3]
3000a04c:	e2432001 	sub	r2, r3, #1
3000a050:	e59d300c 	ldr	r3, [sp, #12]
3000a054:	e5832000 	str	r2, [r3]
	acoral_list_del(list);
3000a058:	e59d0004 	ldr	r0, [sp, #4]
3000a05c:	eb000072 	bl	3000a22c <acoral_list_del>
	if(acoral_list_empty(head))
3000a060:	e59d3014 	ldr	r3, [sp, #20]
3000a064:	e5932000 	ldr	r2, [r3]
3000a068:	e59d3014 	ldr	r3, [sp, #20]
3000a06c:	e1520003 	cmp	r2, r3
3000a070:	1a000005 	bne	3000a08c <acoral_prio_queue_del+0x8c>
		acoral_clear_bit(prio,array->bitmap);
3000a074:	e5dd200b 	ldrb	r2, [sp, #11]
3000a078:	e59d300c 	ldr	r3, [sp, #12]
3000a07c:	e2833004 	add	r3, r3, #4
3000a080:	e1a00002 	mov	r0, r2
3000a084:	e1a01003 	mov	r1, r3
3000a088:	ebffff8a 	bl	30009eb8 <acoral_clear_bit>
}
3000a08c:	e28dd01c 	add	sp, sp, #28
3000a090:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000a094:	e12fff1e 	bx	lr

3000a098 <acoral_get_highprio>:

acoral_u32 acoral_get_highprio(acoral_prio_array_t *array){
3000a098:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000a09c:	e24dd00c 	sub	sp, sp, #12
3000a0a0:	e58d0004 	str	r0, [sp, #4]
	return acoral_find_first_bit(array->bitmap,PRIO_BITMAP_SIZE);
3000a0a4:	e59d3004 	ldr	r3, [sp, #4]
3000a0a8:	e2833004 	add	r3, r3, #4
3000a0ac:	e1a00003 	mov	r0, r3
3000a0b0:	e3a01003 	mov	r1, #3
3000a0b4:	ebffff44 	bl	30009dcc <acoral_find_first_bit>
3000a0b8:	e1a03000 	mov	r3, r0
}
3000a0bc:	e1a00003 	mov	r0, r3
3000a0c0:	e28dd00c 	add	sp, sp, #12
3000a0c4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000a0c8:	e12fff1e 	bx	lr

3000a0cc <acoral_prio_queue_init>:

void acoral_prio_queue_init(acoral_prio_array_t *array){
3000a0cc:	e24dd018 	sub	sp, sp, #24
3000a0d0:	e58d0004 	str	r0, [sp, #4]
  	acoral_u8 i;
	acoral_queue_t *queue;
	acoral_list_t *head;
	array->num=0;
3000a0d4:	e59d3004 	ldr	r3, [sp, #4]
3000a0d8:	e3a02000 	mov	r2, #0
3000a0dc:	e5832000 	str	r2, [r3]
	for(i=0;i<PRIO_BITMAP_SIZE;i++)
3000a0e0:	e3a03000 	mov	r3, #0
3000a0e4:	e5cd300f 	strb	r3, [sp, #15]
3000a0e8:	ea00000a 	b	3000a118 <acoral_prio_queue_init+0x4c>
	    array->bitmap[i]=0;
3000a0ec:	e5dd100f 	ldrb	r1, [sp, #15]
3000a0f0:	e59d2004 	ldr	r2, [sp, #4]
3000a0f4:	e3a03004 	mov	r3, #4
3000a0f8:	e1a01101 	lsl	r1, r1, #2
3000a0fc:	e0812002 	add	r2, r1, r2
3000a100:	e0823003 	add	r3, r2, r3
3000a104:	e3a02000 	mov	r2, #0
3000a108:	e5832000 	str	r2, [r3]
void acoral_prio_queue_init(acoral_prio_array_t *array){
  	acoral_u8 i;
	acoral_queue_t *queue;
	acoral_list_t *head;
	array->num=0;
	for(i=0;i<PRIO_BITMAP_SIZE;i++)
3000a10c:	e5dd300f 	ldrb	r3, [sp, #15]
3000a110:	e2833001 	add	r3, r3, #1
3000a114:	e5cd300f 	strb	r3, [sp, #15]
3000a118:	e5dd300f 	ldrb	r3, [sp, #15]
3000a11c:	e3530002 	cmp	r3, #2
3000a120:	9afffff1 	bls	3000a0ec <acoral_prio_queue_init+0x20>
	    array->bitmap[i]=0;
  	for(i=0;i<ACORAL_MAX_PRIO_NUM;i++){
3000a124:	e3a03000 	mov	r3, #0
3000a128:	e5cd300f 	strb	r3, [sp, #15]
3000a12c:	ea000013 	b	3000a180 <acoral_prio_queue_init+0xb4>
	    queue= array->queue + i;
3000a130:	e59d3004 	ldr	r3, [sp, #4]
3000a134:	e2831010 	add	r1, r3, #16
3000a138:	e5dd200f 	ldrb	r2, [sp, #15]
3000a13c:	e1a03002 	mov	r3, r2
3000a140:	e1a03083 	lsl	r3, r3, #1
3000a144:	e0833002 	add	r3, r3, r2
3000a148:	e1a03103 	lsl	r3, r3, #2
3000a14c:	e0813003 	add	r3, r1, r3
3000a150:	e58d3010 	str	r3, [sp, #16]
	    head=&queue->head;
3000a154:	e59d3010 	ldr	r3, [sp, #16]
3000a158:	e58d3014 	str	r3, [sp, #20]
	    acoral_init_list(head);
3000a15c:	e59d3014 	ldr	r3, [sp, #20]
3000a160:	e59d2014 	ldr	r2, [sp, #20]
3000a164:	e5832000 	str	r2, [r3]
3000a168:	e59d3014 	ldr	r3, [sp, #20]
3000a16c:	e59d2014 	ldr	r2, [sp, #20]
3000a170:	e5832004 	str	r2, [r3, #4]
	acoral_queue_t *queue;
	acoral_list_t *head;
	array->num=0;
	for(i=0;i<PRIO_BITMAP_SIZE;i++)
	    array->bitmap[i]=0;
  	for(i=0;i<ACORAL_MAX_PRIO_NUM;i++){
3000a174:	e5dd300f 	ldrb	r3, [sp, #15]
3000a178:	e2833001 	add	r3, r3, #1
3000a17c:	e5cd300f 	strb	r3, [sp, #15]
3000a180:	e5dd300f 	ldrb	r3, [sp, #15]
3000a184:	e3530046 	cmp	r3, #70	; 0x46
3000a188:	9affffe8 	bls	3000a130 <acoral_prio_queue_init+0x64>
	    queue= array->queue + i;
	    head=&queue->head;
	    acoral_init_list(head);
	} 	
}
3000a18c:	e28dd018 	add	sp, sp, #24
3000a190:	e12fff1e 	bx	lr

3000a194 <acoral_list_add>:
#include<list.h>
void acoral_list_add(acoral_list_t *new, acoral_list_t *head)
{
3000a194:	e24dd008 	sub	sp, sp, #8
3000a198:	e58d0004 	str	r0, [sp, #4]
3000a19c:	e58d1000 	str	r1, [sp]
	new->prev=head;	
3000a1a0:	e59d3004 	ldr	r3, [sp, #4]
3000a1a4:	e59d2000 	ldr	r2, [sp]
3000a1a8:	e5832004 	str	r2, [r3, #4]
	new->next=head->next;	
3000a1ac:	e59d3000 	ldr	r3, [sp]
3000a1b0:	e5932000 	ldr	r2, [r3]
3000a1b4:	e59d3004 	ldr	r3, [sp, #4]
3000a1b8:	e5832000 	str	r2, [r3]
	head->next->prev=new;	
3000a1bc:	e59d3000 	ldr	r3, [sp]
3000a1c0:	e5933000 	ldr	r3, [r3]
3000a1c4:	e59d2004 	ldr	r2, [sp, #4]
3000a1c8:	e5832004 	str	r2, [r3, #4]
	head->next=new;	
3000a1cc:	e59d3000 	ldr	r3, [sp]
3000a1d0:	e59d2004 	ldr	r2, [sp, #4]
3000a1d4:	e5832000 	str	r2, [r3]
}
3000a1d8:	e28dd008 	add	sp, sp, #8
3000a1dc:	e12fff1e 	bx	lr

3000a1e0 <acoral_list_add2_tail>:

void acoral_list_add2_tail(acoral_list_t *new, acoral_list_t *head)
{
3000a1e0:	e24dd008 	sub	sp, sp, #8
3000a1e4:	e58d0004 	str	r0, [sp, #4]
3000a1e8:	e58d1000 	str	r1, [sp]
	new->prev=head->prev;
3000a1ec:	e59d3000 	ldr	r3, [sp]
3000a1f0:	e5932004 	ldr	r2, [r3, #4]
3000a1f4:	e59d3004 	ldr	r3, [sp, #4]
3000a1f8:	e5832004 	str	r2, [r3, #4]
	new->next=head;
3000a1fc:	e59d3004 	ldr	r3, [sp, #4]
3000a200:	e59d2000 	ldr	r2, [sp]
3000a204:	e5832000 	str	r2, [r3]
	head->prev->next=new;
3000a208:	e59d3000 	ldr	r3, [sp]
3000a20c:	e5933004 	ldr	r3, [r3, #4]
3000a210:	e59d2004 	ldr	r2, [sp, #4]
3000a214:	e5832000 	str	r2, [r3]
	head->prev=new;
3000a218:	e59d3000 	ldr	r3, [sp]
3000a21c:	e59d2004 	ldr	r2, [sp, #4]
3000a220:	e5832004 	str	r2, [r3, #4]
}
3000a224:	e28dd008 	add	sp, sp, #8
3000a228:	e12fff1e 	bx	lr

3000a22c <acoral_list_del>:

//从list中删除entry节点
void acoral_list_del(acoral_list_t *entry)
{
3000a22c:	e24dd008 	sub	sp, sp, #8
3000a230:	e58d0004 	str	r0, [sp, #4]
	entry->prev->next= entry->next;
3000a234:	e59d3004 	ldr	r3, [sp, #4]
3000a238:	e5933004 	ldr	r3, [r3, #4]
3000a23c:	e59d2004 	ldr	r2, [sp, #4]
3000a240:	e5922000 	ldr	r2, [r2]
3000a244:	e5832000 	str	r2, [r3]
	entry->next->prev=entry->prev;
3000a248:	e59d3004 	ldr	r3, [sp, #4]
3000a24c:	e5933000 	ldr	r3, [r3]
3000a250:	e59d2004 	ldr	r2, [sp, #4]
3000a254:	e5922004 	ldr	r2, [r2, #4]
3000a258:	e5832004 	str	r2, [r3, #4]
	entry->next = entry;
3000a25c:	e59d3004 	ldr	r3, [sp, #4]
3000a260:	e59d2004 	ldr	r2, [sp, #4]
3000a264:	e5832000 	str	r2, [r3]
	entry->prev = entry;
3000a268:	e59d3004 	ldr	r3, [sp, #4]
3000a26c:	e59d2004 	ldr	r2, [sp, #4]
3000a270:	e5832004 	str	r2, [r3, #4]
}
3000a274:	e28dd008 	add	sp, sp, #8
3000a278:	e12fff1e 	bx	lr

3000a27c <do_div>:
#define SPACE	8		/* space if plus */
#define LEFT	16		/* left justified */
#define SPECIAL	32		/* 0x */
#define LARGE	64		/* use 'ABCDEF' instead of 'abcdef' */
static acoral_32 do_div(acoral_64 *n,acoral_32 base)		
{								
3000a27c:	e92d4010 	push	{r4, lr}
3000a280:	e24dd010 	sub	sp, sp, #16
3000a284:	e58d0004 	str	r0, [sp, #4]
3000a288:	e58d1000 	str	r1, [sp]
	acoral_32 __res;				
	__res = ((acoral_u32)*n) % (acoral_u32)base;
3000a28c:	e59d3004 	ldr	r3, [sp, #4]
3000a290:	e8930018 	ldm	r3, {r3, r4}
3000a294:	e1a02003 	mov	r2, r3
3000a298:	e59d3000 	ldr	r3, [sp]
3000a29c:	e1a00002 	mov	r0, r2
3000a2a0:	e1a01003 	mov	r1, r3
3000a2a4:	eb006cdb 	bl	30025618 <__aeabi_uidivmod>
3000a2a8:	e1a03001 	mov	r3, r1
3000a2ac:	e58d300c 	str	r3, [sp, #12]
	*n = ((acoral_u32)*n) / (acoral_u32)base;	
3000a2b0:	e59d3004 	ldr	r3, [sp, #4]
3000a2b4:	e8930018 	ldm	r3, {r3, r4}
3000a2b8:	e1a02003 	mov	r2, r3
3000a2bc:	e59d3000 	ldr	r3, [sp]
3000a2c0:	e1a00002 	mov	r0, r2
3000a2c4:	e1a01003 	mov	r1, r3
3000a2c8:	eb006c95 	bl	30025524 <__aeabi_uidiv>
3000a2cc:	e1a03000 	mov	r3, r0
3000a2d0:	e3a04000 	mov	r4, #0
3000a2d4:	e59d2004 	ldr	r2, [sp, #4]
3000a2d8:	e8820018 	stm	r2, {r3, r4}
	return __res;					
3000a2dc:	e59d300c 	ldr	r3, [sp, #12]
}
3000a2e0:	e1a00003 	mov	r0, r3
3000a2e4:	e28dd010 	add	sp, sp, #16
3000a2e8:	e8bd4010 	pop	{r4, lr}
3000a2ec:	e12fff1e 	bx	lr

3000a2f0 <skip_atoi>:


acoral_32 skip_atoi(const acoral_char **s)
    {/*change the string "s" to digit*/
3000a2f0:	e24dd010 	sub	sp, sp, #16
3000a2f4:	e58d0004 	str	r0, [sp, #4]
            acoral_32 i=0;
3000a2f8:	e3a03000 	mov	r3, #0
3000a2fc:	e58d300c 	str	r3, [sp, #12]
 
            while (IS_DIGIT(**s))
3000a300:	ea00000e 	b	3000a340 <skip_atoi+0x50>
                    i = i*10 + *((*s)++) - '0';
3000a304:	e59d200c 	ldr	r2, [sp, #12]
3000a308:	e1a03002 	mov	r3, r2
3000a30c:	e1a03103 	lsl	r3, r3, #2
3000a310:	e0833002 	add	r3, r3, r2
3000a314:	e1a03083 	lsl	r3, r3, #1
3000a318:	e1a01003 	mov	r1, r3
3000a31c:	e59d3004 	ldr	r3, [sp, #4]
3000a320:	e5933000 	ldr	r3, [r3]
3000a324:	e5d32000 	ldrb	r2, [r3]
3000a328:	e0812002 	add	r2, r1, r2
3000a32c:	e2422030 	sub	r2, r2, #48	; 0x30
3000a330:	e58d200c 	str	r2, [sp, #12]
3000a334:	e2832001 	add	r2, r3, #1
3000a338:	e59d3004 	ldr	r3, [sp, #4]
3000a33c:	e5832000 	str	r2, [r3]

acoral_32 skip_atoi(const acoral_char **s)
    {/*change the string "s" to digit*/
            acoral_32 i=0;
 
            while (IS_DIGIT(**s))
3000a340:	e59d3004 	ldr	r3, [sp, #4]
3000a344:	e5933000 	ldr	r3, [r3]
3000a348:	e5d33000 	ldrb	r3, [r3]
3000a34c:	e353002f 	cmp	r3, #47	; 0x2f
3000a350:	9a000004 	bls	3000a368 <skip_atoi+0x78>
3000a354:	e59d3004 	ldr	r3, [sp, #4]
3000a358:	e5933000 	ldr	r3, [r3]
3000a35c:	e5d33000 	ldrb	r3, [r3]
3000a360:	e3530038 	cmp	r3, #56	; 0x38
3000a364:	9affffe6 	bls	3000a304 <skip_atoi+0x14>
                    i = i*10 + *((*s)++) - '0';
            return i;
3000a368:	e59d300c 	ldr	r3, [sp, #12]
} 
3000a36c:	e1a00003 	mov	r0, r3
3000a370:	e28dd010 	add	sp, sp, #16
3000a374:	e12fff1e 	bx	lr

3000a378 <number>:

const acoral_char small_digits[] = "0123456789abcdefghijklmnopqrstuvwxyz";
const acoral_char large_digits[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
acoral_char * number(acoral_char * buf, acoral_char * end, acoral_64 num, acoral_32 base, acoral_32 size, acoral_32 precision, acoral_32 type)
{
3000a378:	e92d4010 	push	{r4, lr}
3000a37c:	e24dd060 	sub	sp, sp, #96	; 0x60
3000a380:	e58d000c 	str	r0, [sp, #12]
3000a384:	e58d1008 	str	r1, [sp, #8]
3000a388:	e88d000c 	stm	sp, {r2, r3}
	acoral_char c,sign,tmp[66];
	const acoral_char *digits;
	acoral_32 i;

	digits = (type & LARGE) ? large_digits : small_digits;
3000a38c:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a390:	e2033040 	and	r3, r3, #64	; 0x40
3000a394:	e3530000 	cmp	r3, #0
3000a398:	0a000001 	beq	3000a3a4 <number+0x2c>
3000a39c:	e59f34e4 	ldr	r3, [pc, #1252]	; 3000a888 <number+0x510>
3000a3a0:	ea000000 	b	3000a3a8 <number+0x30>
3000a3a4:	e59f34e0 	ldr	r3, [pc, #1248]	; 3000a88c <number+0x514>
3000a3a8:	e58d3058 	str	r3, [sp, #88]	; 0x58
	if (type & LEFT)
3000a3ac:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a3b0:	e2033010 	and	r3, r3, #16
3000a3b4:	e3530000 	cmp	r3, #0
3000a3b8:	0a000002 	beq	3000a3c8 <number+0x50>
		type &= ~ZEROPAD;
3000a3bc:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a3c0:	e3c33001 	bic	r3, r3, #1
3000a3c4:	e58d3074 	str	r3, [sp, #116]	; 0x74
	if (base < 2 || base > 36)
3000a3c8:	e59d3068 	ldr	r3, [sp, #104]	; 0x68
3000a3cc:	e3530001 	cmp	r3, #1
3000a3d0:	da000002 	ble	3000a3e0 <number+0x68>
3000a3d4:	e59d3068 	ldr	r3, [sp, #104]	; 0x68
3000a3d8:	e3530024 	cmp	r3, #36	; 0x24
3000a3dc:	da000001 	ble	3000a3e8 <number+0x70>
		return 0;
3000a3e0:	e3a03000 	mov	r3, #0
3000a3e4:	ea000123 	b	3000a878 <number+0x500>
	c = (type & ZEROPAD) ? '0' : ' ';
3000a3e8:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a3ec:	e2033001 	and	r3, r3, #1
3000a3f0:	e20330ff 	and	r3, r3, #255	; 0xff
3000a3f4:	e3530000 	cmp	r3, #0
3000a3f8:	0a000001 	beq	3000a404 <number+0x8c>
3000a3fc:	e3a03030 	mov	r3, #48	; 0x30
3000a400:	ea000000 	b	3000a408 <number+0x90>
3000a404:	e3a03020 	mov	r3, #32
3000a408:	e5cd3056 	strb	r3, [sp, #86]	; 0x56
	sign = 0;
3000a40c:	e3a03000 	mov	r3, #0
3000a410:	e5cd3057 	strb	r3, [sp, #87]	; 0x57
	if (type & SIGN) {
3000a414:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a418:	e2033002 	and	r3, r3, #2
3000a41c:	e3530000 	cmp	r3, #0
3000a420:	0a000020 	beq	3000a4a8 <number+0x130>
		if (num < 0) {
3000a424:	e89d0018 	ldm	sp, {r3, r4}
3000a428:	e3530000 	cmp	r3, #0
3000a42c:	e2d40000 	sbcs	r0, r4, #0
3000a430:	aa000009 	bge	3000a45c <number+0xe4>
			sign = '-';
3000a434:	e3a0302d 	mov	r3, #45	; 0x2d
3000a438:	e5cd3057 	strb	r3, [sp, #87]	; 0x57
			num = -num;
3000a43c:	e89d0018 	ldm	sp, {r3, r4}
3000a440:	e2733000 	rsbs	r3, r3, #0
3000a444:	e2e44000 	rsc	r4, r4, #0
3000a448:	e88d0018 	stm	sp, {r3, r4}
			size--;
3000a44c:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
3000a450:	e2433001 	sub	r3, r3, #1
3000a454:	e58d306c 	str	r3, [sp, #108]	; 0x6c
3000a458:	ea000012 	b	3000a4a8 <number+0x130>
		} else if (type & PLUS) {
3000a45c:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a460:	e2033004 	and	r3, r3, #4
3000a464:	e3530000 	cmp	r3, #0
3000a468:	0a000005 	beq	3000a484 <number+0x10c>
			sign = '+';
3000a46c:	e3a0302b 	mov	r3, #43	; 0x2b
3000a470:	e5cd3057 	strb	r3, [sp, #87]	; 0x57
			size--;
3000a474:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
3000a478:	e2433001 	sub	r3, r3, #1
3000a47c:	e58d306c 	str	r3, [sp, #108]	; 0x6c
3000a480:	ea000008 	b	3000a4a8 <number+0x130>
		} else if (type & SPACE) {
3000a484:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a488:	e2033008 	and	r3, r3, #8
3000a48c:	e3530000 	cmp	r3, #0
3000a490:	0a000004 	beq	3000a4a8 <number+0x130>
			sign = ' ';
3000a494:	e3a03020 	mov	r3, #32
3000a498:	e5cd3057 	strb	r3, [sp, #87]	; 0x57
			size--;
3000a49c:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
3000a4a0:	e2433001 	sub	r3, r3, #1
3000a4a4:	e58d306c 	str	r3, [sp, #108]	; 0x6c
		}
	}
	if (type & SPECIAL) {
3000a4a8:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a4ac:	e2033020 	and	r3, r3, #32
3000a4b0:	e3530000 	cmp	r3, #0
3000a4b4:	0a00000c 	beq	3000a4ec <number+0x174>
		if (base == 16)
3000a4b8:	e59d3068 	ldr	r3, [sp, #104]	; 0x68
3000a4bc:	e3530010 	cmp	r3, #16
3000a4c0:	1a000003 	bne	3000a4d4 <number+0x15c>
			size -= 2;
3000a4c4:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
3000a4c8:	e2433002 	sub	r3, r3, #2
3000a4cc:	e58d306c 	str	r3, [sp, #108]	; 0x6c
3000a4d0:	ea000005 	b	3000a4ec <number+0x174>
		else if (base == 8)
3000a4d4:	e59d3068 	ldr	r3, [sp, #104]	; 0x68
3000a4d8:	e3530008 	cmp	r3, #8
3000a4dc:	1a000002 	bne	3000a4ec <number+0x174>
			size--;
3000a4e0:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
3000a4e4:	e2433001 	sub	r3, r3, #1
3000a4e8:	e58d306c 	str	r3, [sp, #108]	; 0x6c
	}
	i = 0;
3000a4ec:	e3a03000 	mov	r3, #0
3000a4f0:	e58d305c 	str	r3, [sp, #92]	; 0x5c
	if (num == 0)
3000a4f4:	e89d0018 	ldm	sp, {r3, r4}
3000a4f8:	e1931004 	orrs	r1, r3, r4
3000a4fc:	1a00001d 	bne	3000a578 <number+0x200>
		tmp[i++]='0';
3000a500:	e59d205c 	ldr	r2, [sp, #92]	; 0x5c
3000a504:	e3e0304b 	mvn	r3, #75	; 0x4b
3000a508:	e28d0060 	add	r0, sp, #96	; 0x60
3000a50c:	e0802002 	add	r2, r0, r2
3000a510:	e0823003 	add	r3, r2, r3
3000a514:	e3a02030 	mov	r2, #48	; 0x30
3000a518:	e5c32000 	strb	r2, [r3]
3000a51c:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
3000a520:	e2833001 	add	r3, r3, #1
3000a524:	e58d305c 	str	r3, [sp, #92]	; 0x5c
3000a528:	ea000016 	b	3000a588 <number+0x210>
	else while (num != 0)
		tmp[i++] = digits[do_div(&num,base)];
3000a52c:	e59d405c 	ldr	r4, [sp, #92]	; 0x5c
3000a530:	e1a0300d 	mov	r3, sp
3000a534:	e1a00003 	mov	r0, r3
3000a538:	e59d1068 	ldr	r1, [sp, #104]	; 0x68
3000a53c:	ebffff4e 	bl	3000a27c <do_div>
3000a540:	e1a03000 	mov	r3, r0
3000a544:	e1a02003 	mov	r2, r3
3000a548:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000a54c:	e0823003 	add	r3, r2, r3
3000a550:	e5d32000 	ldrb	r2, [r3]
3000a554:	e3e0304b 	mvn	r3, #75	; 0x4b
3000a558:	e28d0060 	add	r0, sp, #96	; 0x60
3000a55c:	e0801004 	add	r1, r0, r4
3000a560:	e0813003 	add	r3, r1, r3
3000a564:	e5c32000 	strb	r2, [r3]
3000a568:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
3000a56c:	e2833001 	add	r3, r3, #1
3000a570:	e58d305c 	str	r3, [sp, #92]	; 0x5c
3000a574:	ea000000 	b	3000a57c <number+0x204>
			size--;
	}
	i = 0;
	if (num == 0)
		tmp[i++]='0';
	else while (num != 0)
3000a578:	e1a00000 	nop			; (mov r0, r0)
3000a57c:	e89d0018 	ldm	sp, {r3, r4}
3000a580:	e1931004 	orrs	r1, r3, r4
3000a584:	1affffe8 	bne	3000a52c <number+0x1b4>
		tmp[i++] = digits[do_div(&num,base)];
	if (i > precision)
3000a588:	e59d205c 	ldr	r2, [sp, #92]	; 0x5c
3000a58c:	e59d3070 	ldr	r3, [sp, #112]	; 0x70
3000a590:	e1520003 	cmp	r2, r3
3000a594:	da000001 	ble	3000a5a0 <number+0x228>
		precision = i;
3000a598:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
3000a59c:	e58d3070 	str	r3, [sp, #112]	; 0x70
	size -= precision;
3000a5a0:	e59d206c 	ldr	r2, [sp, #108]	; 0x6c
3000a5a4:	e59d3070 	ldr	r3, [sp, #112]	; 0x70
3000a5a8:	e0633002 	rsb	r3, r3, r2
3000a5ac:	e58d306c 	str	r3, [sp, #108]	; 0x6c
	if (!(type&(ZEROPAD+LEFT))) {
3000a5b0:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a5b4:	e2033011 	and	r3, r3, #17
3000a5b8:	e3530000 	cmp	r3, #0
3000a5bc:	1a000014 	bne	3000a614 <number+0x29c>
		while(size-->0) {
3000a5c0:	ea000009 	b	3000a5ec <number+0x274>
			if (buf <= end)
3000a5c4:	e59d200c 	ldr	r2, [sp, #12]
3000a5c8:	e59d3008 	ldr	r3, [sp, #8]
3000a5cc:	e1520003 	cmp	r2, r3
3000a5d0:	8a000002 	bhi	3000a5e0 <number+0x268>
				*buf = ' ';
3000a5d4:	e59d300c 	ldr	r3, [sp, #12]
3000a5d8:	e3a02020 	mov	r2, #32
3000a5dc:	e5c32000 	strb	r2, [r3]
			++buf;
3000a5e0:	e59d300c 	ldr	r3, [sp, #12]
3000a5e4:	e2833001 	add	r3, r3, #1
3000a5e8:	e58d300c 	str	r3, [sp, #12]
		tmp[i++] = digits[do_div(&num,base)];
	if (i > precision)
		precision = i;
	size -= precision;
	if (!(type&(ZEROPAD+LEFT))) {
		while(size-->0) {
3000a5ec:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
3000a5f0:	e3530000 	cmp	r3, #0
3000a5f4:	d3a03000 	movle	r3, #0
3000a5f8:	c3a03001 	movgt	r3, #1
3000a5fc:	e20330ff 	and	r3, r3, #255	; 0xff
3000a600:	e59d206c 	ldr	r2, [sp, #108]	; 0x6c
3000a604:	e2422001 	sub	r2, r2, #1
3000a608:	e58d206c 	str	r2, [sp, #108]	; 0x6c
3000a60c:	e3530000 	cmp	r3, #0
3000a610:	1affffeb 	bne	3000a5c4 <number+0x24c>
			if (buf <= end)
				*buf = ' ';
			++buf;
		}
	}
	if (sign) {
3000a614:	e5dd3057 	ldrb	r3, [sp, #87]	; 0x57
3000a618:	e3530000 	cmp	r3, #0
3000a61c:	0a000009 	beq	3000a648 <number+0x2d0>
		if (buf <= end)
3000a620:	e59d200c 	ldr	r2, [sp, #12]
3000a624:	e59d3008 	ldr	r3, [sp, #8]
3000a628:	e1520003 	cmp	r2, r3
3000a62c:	8a000002 	bhi	3000a63c <number+0x2c4>
			*buf = sign;
3000a630:	e59d300c 	ldr	r3, [sp, #12]
3000a634:	e5dd2057 	ldrb	r2, [sp, #87]	; 0x57
3000a638:	e5c32000 	strb	r2, [r3]
		++buf;
3000a63c:	e59d300c 	ldr	r3, [sp, #12]
3000a640:	e2833001 	add	r3, r3, #1
3000a644:	e58d300c 	str	r3, [sp, #12]
	}
	if (type & SPECIAL) {
3000a648:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a64c:	e2033020 	and	r3, r3, #32
3000a650:	e3530000 	cmp	r3, #0
3000a654:	0a000026 	beq	3000a6f4 <number+0x37c>
		if (base==8) {
3000a658:	e59d3068 	ldr	r3, [sp, #104]	; 0x68
3000a65c:	e3530008 	cmp	r3, #8
3000a660:	1a00000a 	bne	3000a690 <number+0x318>
			if (buf <= end)
3000a664:	e59d200c 	ldr	r2, [sp, #12]
3000a668:	e59d3008 	ldr	r3, [sp, #8]
3000a66c:	e1520003 	cmp	r2, r3
3000a670:	8a000002 	bhi	3000a680 <number+0x308>
				*buf = '0';
3000a674:	e59d300c 	ldr	r3, [sp, #12]
3000a678:	e3a02030 	mov	r2, #48	; 0x30
3000a67c:	e5c32000 	strb	r2, [r3]
			++buf;
3000a680:	e59d300c 	ldr	r3, [sp, #12]
3000a684:	e2833001 	add	r3, r3, #1
3000a688:	e58d300c 	str	r3, [sp, #12]
3000a68c:	ea000018 	b	3000a6f4 <number+0x37c>
		} else if (base==16) {
3000a690:	e59d3068 	ldr	r3, [sp, #104]	; 0x68
3000a694:	e3530010 	cmp	r3, #16
3000a698:	1a000015 	bne	3000a6f4 <number+0x37c>
			if (buf <= end)
3000a69c:	e59d200c 	ldr	r2, [sp, #12]
3000a6a0:	e59d3008 	ldr	r3, [sp, #8]
3000a6a4:	e1520003 	cmp	r2, r3
3000a6a8:	8a000002 	bhi	3000a6b8 <number+0x340>
				*buf = '0';
3000a6ac:	e59d300c 	ldr	r3, [sp, #12]
3000a6b0:	e3a02030 	mov	r2, #48	; 0x30
3000a6b4:	e5c32000 	strb	r2, [r3]
			++buf;
3000a6b8:	e59d300c 	ldr	r3, [sp, #12]
3000a6bc:	e2833001 	add	r3, r3, #1
3000a6c0:	e58d300c 	str	r3, [sp, #12]
			if (buf <= end)
3000a6c4:	e59d200c 	ldr	r2, [sp, #12]
3000a6c8:	e59d3008 	ldr	r3, [sp, #8]
3000a6cc:	e1520003 	cmp	r2, r3
3000a6d0:	8a000004 	bhi	3000a6e8 <number+0x370>
				*buf = digits[33];
3000a6d4:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000a6d8:	e2833021 	add	r3, r3, #33	; 0x21
3000a6dc:	e5d32000 	ldrb	r2, [r3]
3000a6e0:	e59d300c 	ldr	r3, [sp, #12]
3000a6e4:	e5c32000 	strb	r2, [r3]
			++buf;
3000a6e8:	e59d300c 	ldr	r3, [sp, #12]
3000a6ec:	e2833001 	add	r3, r3, #1
3000a6f0:	e58d300c 	str	r3, [sp, #12]
		}
	}
	if (!(type & LEFT)) {
3000a6f4:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a6f8:	e2033010 	and	r3, r3, #16
3000a6fc:	e3530000 	cmp	r3, #0
3000a700:	1a000020 	bne	3000a788 <number+0x410>
		while (size-- > 0) {
3000a704:	ea000009 	b	3000a730 <number+0x3b8>
			if (buf <= end)
3000a708:	e59d200c 	ldr	r2, [sp, #12]
3000a70c:	e59d3008 	ldr	r3, [sp, #8]
3000a710:	e1520003 	cmp	r2, r3
3000a714:	8a000002 	bhi	3000a724 <number+0x3ac>
				*buf = c;
3000a718:	e59d300c 	ldr	r3, [sp, #12]
3000a71c:	e5dd2056 	ldrb	r2, [sp, #86]	; 0x56
3000a720:	e5c32000 	strb	r2, [r3]
			++buf;
3000a724:	e59d300c 	ldr	r3, [sp, #12]
3000a728:	e2833001 	add	r3, r3, #1
3000a72c:	e58d300c 	str	r3, [sp, #12]
				*buf = digits[33];
			++buf;
		}
	}
	if (!(type & LEFT)) {
		while (size-- > 0) {
3000a730:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
3000a734:	e3530000 	cmp	r3, #0
3000a738:	d3a03000 	movle	r3, #0
3000a73c:	c3a03001 	movgt	r3, #1
3000a740:	e20330ff 	and	r3, r3, #255	; 0xff
3000a744:	e59d206c 	ldr	r2, [sp, #108]	; 0x6c
3000a748:	e2422001 	sub	r2, r2, #1
3000a74c:	e58d206c 	str	r2, [sp, #108]	; 0x6c
3000a750:	e3530000 	cmp	r3, #0
3000a754:	1affffeb 	bne	3000a708 <number+0x390>
			if (buf <= end)
				*buf = c;
			++buf;
		}
	}
	while (i < precision--) {
3000a758:	ea00000b 	b	3000a78c <number+0x414>
		if (buf <= end)
3000a75c:	e59d200c 	ldr	r2, [sp, #12]
3000a760:	e59d3008 	ldr	r3, [sp, #8]
3000a764:	e1520003 	cmp	r2, r3
3000a768:	8a000002 	bhi	3000a778 <number+0x400>
			*buf = '0';
3000a76c:	e59d300c 	ldr	r3, [sp, #12]
3000a770:	e3a02030 	mov	r2, #48	; 0x30
3000a774:	e5c32000 	strb	r2, [r3]
		++buf;
3000a778:	e59d300c 	ldr	r3, [sp, #12]
3000a77c:	e2833001 	add	r3, r3, #1
3000a780:	e58d300c 	str	r3, [sp, #12]
3000a784:	ea000000 	b	3000a78c <number+0x414>
			if (buf <= end)
				*buf = c;
			++buf;
		}
	}
	while (i < precision--) {
3000a788:	e1a00000 	nop			; (mov r0, r0)
3000a78c:	e59d2070 	ldr	r2, [sp, #112]	; 0x70
3000a790:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
3000a794:	e1520003 	cmp	r2, r3
3000a798:	d3a03000 	movle	r3, #0
3000a79c:	c3a03001 	movgt	r3, #1
3000a7a0:	e20330ff 	and	r3, r3, #255	; 0xff
3000a7a4:	e59d2070 	ldr	r2, [sp, #112]	; 0x70
3000a7a8:	e2422001 	sub	r2, r2, #1
3000a7ac:	e58d2070 	str	r2, [sp, #112]	; 0x70
3000a7b0:	e3530000 	cmp	r3, #0
3000a7b4:	1affffe8 	bne	3000a75c <number+0x3e4>
		if (buf <= end)
			*buf = '0';
		++buf;
	}
	while (i-- > 0) {
3000a7b8:	ea00000e 	b	3000a7f8 <number+0x480>
		if (buf <= end)
3000a7bc:	e59d200c 	ldr	r2, [sp, #12]
3000a7c0:	e59d3008 	ldr	r3, [sp, #8]
3000a7c4:	e1520003 	cmp	r2, r3
3000a7c8:	8a000007 	bhi	3000a7ec <number+0x474>
			*buf = tmp[i];
3000a7cc:	e59d205c 	ldr	r2, [sp, #92]	; 0x5c
3000a7d0:	e3e0304b 	mvn	r3, #75	; 0x4b
3000a7d4:	e28d0060 	add	r0, sp, #96	; 0x60
3000a7d8:	e0802002 	add	r2, r0, r2
3000a7dc:	e0823003 	add	r3, r2, r3
3000a7e0:	e5d32000 	ldrb	r2, [r3]
3000a7e4:	e59d300c 	ldr	r3, [sp, #12]
3000a7e8:	e5c32000 	strb	r2, [r3]
		++buf;
3000a7ec:	e59d300c 	ldr	r3, [sp, #12]
3000a7f0:	e2833001 	add	r3, r3, #1
3000a7f4:	e58d300c 	str	r3, [sp, #12]
	while (i < precision--) {
		if (buf <= end)
			*buf = '0';
		++buf;
	}
	while (i-- > 0) {
3000a7f8:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
3000a7fc:	e3530000 	cmp	r3, #0
3000a800:	d3a03000 	movle	r3, #0
3000a804:	c3a03001 	movgt	r3, #1
3000a808:	e20330ff 	and	r3, r3, #255	; 0xff
3000a80c:	e59d205c 	ldr	r2, [sp, #92]	; 0x5c
3000a810:	e2422001 	sub	r2, r2, #1
3000a814:	e58d205c 	str	r2, [sp, #92]	; 0x5c
3000a818:	e3530000 	cmp	r3, #0
3000a81c:	1affffe6 	bne	3000a7bc <number+0x444>
		if (buf <= end)
			*buf = tmp[i];
		++buf;
	}
	while (size-- > 0) {
3000a820:	ea000009 	b	3000a84c <number+0x4d4>
		if (buf <= end)
3000a824:	e59d200c 	ldr	r2, [sp, #12]
3000a828:	e59d3008 	ldr	r3, [sp, #8]
3000a82c:	e1520003 	cmp	r2, r3
3000a830:	8a000002 	bhi	3000a840 <number+0x4c8>
			*buf = ' ';
3000a834:	e59d300c 	ldr	r3, [sp, #12]
3000a838:	e3a02020 	mov	r2, #32
3000a83c:	e5c32000 	strb	r2, [r3]
		++buf;
3000a840:	e59d300c 	ldr	r3, [sp, #12]
3000a844:	e2833001 	add	r3, r3, #1
3000a848:	e58d300c 	str	r3, [sp, #12]
	while (i-- > 0) {
		if (buf <= end)
			*buf = tmp[i];
		++buf;
	}
	while (size-- > 0) {
3000a84c:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
3000a850:	e3530000 	cmp	r3, #0
3000a854:	d3a03000 	movle	r3, #0
3000a858:	c3a03001 	movgt	r3, #1
3000a85c:	e20330ff 	and	r3, r3, #255	; 0xff
3000a860:	e59d206c 	ldr	r2, [sp, #108]	; 0x6c
3000a864:	e2422001 	sub	r2, r2, #1
3000a868:	e58d206c 	str	r2, [sp, #108]	; 0x6c
3000a86c:	e3530000 	cmp	r3, #0
3000a870:	1affffeb 	bne	3000a824 <number+0x4ac>
		if (buf <= end)
			*buf = ' ';
		++buf;
	}
	return buf;
3000a874:	e59d300c 	ldr	r3, [sp, #12]
}
3000a878:	e1a00003 	mov	r0, r3
3000a87c:	e28dd060 	add	sp, sp, #96	; 0x60
3000a880:	e8bd4010 	pop	{r4, lr}
3000a884:	e12fff1e 	bx	lr
3000a888:	30026438 	.word	0x30026438
3000a88c:	30026410 	.word	0x30026410

3000a890 <vsnprintf>:
				   number of acoral_chars for from string */
	acoral_32 qualifier;		/* 'h', 'l', or 'L' for acoral_32eger fields */
				/* 'z' support added 23/7/1999 S.H.    */
				/* 'z' changed to 'Z' --davidm 1/25/99 */

	str = buf;
3000a890:	e92d4010 	push	{r4, lr}
3000a894:	e24dd068 	sub	sp, sp, #104	; 0x68
3000a898:	e58d001c 	str	r0, [sp, #28]
3000a89c:	e58d1018 	str	r1, [sp, #24]
3000a8a0:	e58d2014 	str	r2, [sp, #20]
3000a8a4:	e58d3010 	str	r3, [sp, #16]
3000a8a8:	e59d301c 	ldr	r3, [sp, #28]
3000a8ac:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	end = buf + size - 1;
3000a8b0:	e59d3018 	ldr	r3, [sp, #24]
3000a8b4:	e2433001 	sub	r3, r3, #1
3000a8b8:	e59d201c 	ldr	r2, [sp, #28]
3000a8bc:	e0823003 	add	r3, r2, r3
3000a8c0:	e58d3040 	str	r3, [sp, #64]	; 0x40

	if (end < buf - 1) {
3000a8c4:	e59d301c 	ldr	r3, [sp, #28]
3000a8c8:	e2432001 	sub	r2, r3, #1
3000a8cc:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000a8d0:	e1520003 	cmp	r2, r3
3000a8d4:	9a0002a0 	bls	3000b35c <vsnprintf+0xacc>
		end = ((void *) -1);
3000a8d8:	e3e03000 	mvn	r3, #0
3000a8dc:	e58d3040 	str	r3, [sp, #64]	; 0x40
		size = end - buf + 1;
3000a8e0:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
3000a8e4:	e59d301c 	ldr	r3, [sp, #28]
3000a8e8:	e0633002 	rsb	r3, r3, r2
3000a8ec:	e2833001 	add	r3, r3, #1
3000a8f0:	e58d3018 	str	r3, [sp, #24]
	}

	for (; *fmt ; ++fmt) {
3000a8f4:	ea000299 	b	3000b360 <vsnprintf+0xad0>
		if (*fmt != '%') {
3000a8f8:	e59d3014 	ldr	r3, [sp, #20]
3000a8fc:	e5d33000 	ldrb	r3, [r3]
3000a900:	e3530025 	cmp	r3, #37	; 0x25
3000a904:	0a00000b 	beq	3000a938 <vsnprintf+0xa8>
			if (str <= end)
3000a908:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000a90c:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000a910:	e1520003 	cmp	r2, r3
3000a914:	8a000003 	bhi	3000a928 <vsnprintf+0x98>
				*str = *fmt;
3000a918:	e59d3014 	ldr	r3, [sp, #20]
3000a91c:	e5d32000 	ldrb	r2, [r3]
3000a920:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000a924:	e5c32000 	strb	r2, [r3]
			++str;
3000a928:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000a92c:	e2833001 	add	r3, r3, #1
3000a930:	e58d303c 	str	r3, [sp, #60]	; 0x3c
			continue;
3000a934:	ea000284 	b	3000b34c <vsnprintf+0xabc>
		}

		/* process flags */
		flags = 0;
3000a938:	e3a03000 	mov	r3, #0
3000a93c:	e58d304c 	str	r3, [sp, #76]	; 0x4c
		repeat:
			++fmt;		/* this also skips first '%' */
3000a940:	e59d3014 	ldr	r3, [sp, #20]
3000a944:	e2833001 	add	r3, r3, #1
3000a948:	e58d3014 	str	r3, [sp, #20]
			switch (*fmt) {
3000a94c:	e59d3014 	ldr	r3, [sp, #20]
3000a950:	e5d33000 	ldrb	r3, [r3]
3000a954:	e2433020 	sub	r3, r3, #32
3000a958:	e3530010 	cmp	r3, #16
3000a95c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3000a960:	ea000024 	b	3000a9f8 <vsnprintf+0x168>
3000a964:	3000a9c8 	.word	0x3000a9c8
3000a968:	3000a9f8 	.word	0x3000a9f8
3000a96c:	3000a9f8 	.word	0x3000a9f8
3000a970:	3000a9d8 	.word	0x3000a9d8
3000a974:	3000a9f8 	.word	0x3000a9f8
3000a978:	3000a9f8 	.word	0x3000a9f8
3000a97c:	3000a9f8 	.word	0x3000a9f8
3000a980:	3000a9f8 	.word	0x3000a9f8
3000a984:	3000a9f8 	.word	0x3000a9f8
3000a988:	3000a9f8 	.word	0x3000a9f8
3000a98c:	3000a9f8 	.word	0x3000a9f8
3000a990:	3000a9b8 	.word	0x3000a9b8
3000a994:	3000a9f8 	.word	0x3000a9f8
3000a998:	3000a9a8 	.word	0x3000a9a8
3000a99c:	3000a9f8 	.word	0x3000a9f8
3000a9a0:	3000a9f8 	.word	0x3000a9f8
3000a9a4:	3000a9e8 	.word	0x3000a9e8
				case '-': flags |= LEFT; goto repeat;
3000a9a8:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000a9ac:	e3833010 	orr	r3, r3, #16
3000a9b0:	e58d304c 	str	r3, [sp, #76]	; 0x4c
3000a9b4:	eaffffe1 	b	3000a940 <vsnprintf+0xb0>
				case '+': flags |= PLUS; goto repeat;
3000a9b8:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000a9bc:	e3833004 	orr	r3, r3, #4
3000a9c0:	e58d304c 	str	r3, [sp, #76]	; 0x4c
3000a9c4:	eaffffdd 	b	3000a940 <vsnprintf+0xb0>
				case ' ': flags |= SPACE; goto repeat;
3000a9c8:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000a9cc:	e3833008 	orr	r3, r3, #8
3000a9d0:	e58d304c 	str	r3, [sp, #76]	; 0x4c
3000a9d4:	eaffffd9 	b	3000a940 <vsnprintf+0xb0>
				case '#': flags |= SPECIAL; goto repeat;
3000a9d8:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000a9dc:	e3833020 	orr	r3, r3, #32
3000a9e0:	e58d304c 	str	r3, [sp, #76]	; 0x4c
3000a9e4:	eaffffd5 	b	3000a940 <vsnprintf+0xb0>
				case '0': flags |= ZEROPAD; goto repeat;
3000a9e8:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000a9ec:	e3833001 	orr	r3, r3, #1
3000a9f0:	e58d304c 	str	r3, [sp, #76]	; 0x4c
3000a9f4:	eaffffd1 	b	3000a940 <vsnprintf+0xb0>
			}

		/* get field width */
		field_width = -1;
3000a9f8:	e3e03000 	mvn	r3, #0
3000a9fc:	e58d3050 	str	r3, [sp, #80]	; 0x50
		if (IS_DIGIT(*fmt))
3000aa00:	e59d3014 	ldr	r3, [sp, #20]
3000aa04:	e5d33000 	ldrb	r3, [r3]
3000aa08:	e353002f 	cmp	r3, #47	; 0x2f
3000aa0c:	9a000009 	bls	3000aa38 <vsnprintf+0x1a8>
3000aa10:	e59d3014 	ldr	r3, [sp, #20]
3000aa14:	e5d33000 	ldrb	r3, [r3]
3000aa18:	e3530038 	cmp	r3, #56	; 0x38
3000aa1c:	8a000005 	bhi	3000aa38 <vsnprintf+0x1a8>
			field_width = skip_atoi(&fmt);
3000aa20:	e28d3014 	add	r3, sp, #20
3000aa24:	e1a00003 	mov	r0, r3
3000aa28:	ebfffe30 	bl	3000a2f0 <skip_atoi>
3000aa2c:	e1a03000 	mov	r3, r0
3000aa30:	e58d3050 	str	r3, [sp, #80]	; 0x50
				case '0': flags |= ZEROPAD; goto repeat;
			}

		/* get field width */
		field_width = -1;
		if (IS_DIGIT(*fmt))
3000aa34:	ea000016 	b	3000aa94 <vsnprintf+0x204>
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
3000aa38:	e59d3014 	ldr	r3, [sp, #20]
3000aa3c:	e5d33000 	ldrb	r3, [r3]
3000aa40:	e353002a 	cmp	r3, #42	; 0x2a
3000aa44:	1a000012 	bne	3000aa94 <vsnprintf+0x204>
			++fmt;
3000aa48:	e59d3014 	ldr	r3, [sp, #20]
3000aa4c:	e2833001 	add	r3, r3, #1
3000aa50:	e58d3014 	str	r3, [sp, #20]
			/* it's the next argument */
			field_width = va_arg(args, acoral_32);
3000aa54:	e59d3010 	ldr	r3, [sp, #16]
3000aa58:	e2833004 	add	r3, r3, #4
3000aa5c:	e58d3010 	str	r3, [sp, #16]
3000aa60:	e59d3010 	ldr	r3, [sp, #16]
3000aa64:	e2433004 	sub	r3, r3, #4
3000aa68:	e5933000 	ldr	r3, [r3]
3000aa6c:	e58d3050 	str	r3, [sp, #80]	; 0x50
			if (field_width < 0) {
3000aa70:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
3000aa74:	e3530000 	cmp	r3, #0
3000aa78:	aa000005 	bge	3000aa94 <vsnprintf+0x204>
				field_width = -field_width;
3000aa7c:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
3000aa80:	e2633000 	rsb	r3, r3, #0
3000aa84:	e58d3050 	str	r3, [sp, #80]	; 0x50
				flags |= LEFT;
3000aa88:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000aa8c:	e3833010 	orr	r3, r3, #16
3000aa90:	e58d304c 	str	r3, [sp, #76]	; 0x4c
			}
		}

		/* get the precision */
		precision = -1;
3000aa94:	e3e03000 	mvn	r3, #0
3000aa98:	e58d3054 	str	r3, [sp, #84]	; 0x54
		if (*fmt == '.') {
3000aa9c:	e59d3014 	ldr	r3, [sp, #20]
3000aaa0:	e5d33000 	ldrb	r3, [r3]
3000aaa4:	e353002e 	cmp	r3, #46	; 0x2e
3000aaa8:	1a000023 	bne	3000ab3c <vsnprintf+0x2ac>
			++fmt;	
3000aaac:	e59d3014 	ldr	r3, [sp, #20]
3000aab0:	e2833001 	add	r3, r3, #1
3000aab4:	e58d3014 	str	r3, [sp, #20]
			if (IS_DIGIT(*fmt))
3000aab8:	e59d3014 	ldr	r3, [sp, #20]
3000aabc:	e5d33000 	ldrb	r3, [r3]
3000aac0:	e353002f 	cmp	r3, #47	; 0x2f
3000aac4:	9a000009 	bls	3000aaf0 <vsnprintf+0x260>
3000aac8:	e59d3014 	ldr	r3, [sp, #20]
3000aacc:	e5d33000 	ldrb	r3, [r3]
3000aad0:	e3530038 	cmp	r3, #56	; 0x38
3000aad4:	8a000005 	bhi	3000aaf0 <vsnprintf+0x260>
				precision = skip_atoi(&fmt);
3000aad8:	e28d3014 	add	r3, sp, #20
3000aadc:	e1a00003 	mov	r0, r3
3000aae0:	ebfffe02 	bl	3000a2f0 <skip_atoi>
3000aae4:	e1a03000 	mov	r3, r0
3000aae8:	e58d3054 	str	r3, [sp, #84]	; 0x54

		/* get the precision */
		precision = -1;
		if (*fmt == '.') {
			++fmt;	
			if (IS_DIGIT(*fmt))
3000aaec:	ea00000d 	b	3000ab28 <vsnprintf+0x298>
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
3000aaf0:	e59d3014 	ldr	r3, [sp, #20]
3000aaf4:	e5d33000 	ldrb	r3, [r3]
3000aaf8:	e353002a 	cmp	r3, #42	; 0x2a
3000aafc:	1a000009 	bne	3000ab28 <vsnprintf+0x298>
				++fmt;
3000ab00:	e59d3014 	ldr	r3, [sp, #20]
3000ab04:	e2833001 	add	r3, r3, #1
3000ab08:	e58d3014 	str	r3, [sp, #20]
				/* it's the next argument */
				precision = va_arg(args, acoral_32);
3000ab0c:	e59d3010 	ldr	r3, [sp, #16]
3000ab10:	e2833004 	add	r3, r3, #4
3000ab14:	e58d3010 	str	r3, [sp, #16]
3000ab18:	e59d3010 	ldr	r3, [sp, #16]
3000ab1c:	e2433004 	sub	r3, r3, #4
3000ab20:	e5933000 	ldr	r3, [r3]
3000ab24:	e58d3054 	str	r3, [sp, #84]	; 0x54
			}
			if (precision < 0)
3000ab28:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
3000ab2c:	e3530000 	cmp	r3, #0
3000ab30:	aa000001 	bge	3000ab3c <vsnprintf+0x2ac>
				precision = 0;
3000ab34:	e3a03000 	mov	r3, #0
3000ab38:	e58d3054 	str	r3, [sp, #84]	; 0x54
		}

		/* get the conversion qualifier */
		qualifier = -1;
3000ab3c:	e3e03000 	mvn	r3, #0
3000ab40:	e58d3058 	str	r3, [sp, #88]	; 0x58
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt =='Z') {
3000ab44:	e59d3014 	ldr	r3, [sp, #20]
3000ab48:	e5d33000 	ldrb	r3, [r3]
3000ab4c:	e3530068 	cmp	r3, #104	; 0x68
3000ab50:	0a00000b 	beq	3000ab84 <vsnprintf+0x2f4>
3000ab54:	e59d3014 	ldr	r3, [sp, #20]
3000ab58:	e5d33000 	ldrb	r3, [r3]
3000ab5c:	e353006c 	cmp	r3, #108	; 0x6c
3000ab60:	0a000007 	beq	3000ab84 <vsnprintf+0x2f4>
3000ab64:	e59d3014 	ldr	r3, [sp, #20]
3000ab68:	e5d33000 	ldrb	r3, [r3]
3000ab6c:	e353004c 	cmp	r3, #76	; 0x4c
3000ab70:	0a000003 	beq	3000ab84 <vsnprintf+0x2f4>
3000ab74:	e59d3014 	ldr	r3, [sp, #20]
3000ab78:	e5d33000 	ldrb	r3, [r3]
3000ab7c:	e353005a 	cmp	r3, #90	; 0x5a
3000ab80:	1a000011 	bne	3000abcc <vsnprintf+0x33c>
			qualifier = *fmt;
3000ab84:	e59d3014 	ldr	r3, [sp, #20]
3000ab88:	e5d33000 	ldrb	r3, [r3]
3000ab8c:	e58d3058 	str	r3, [sp, #88]	; 0x58
			++fmt;
3000ab90:	e59d3014 	ldr	r3, [sp, #20]
3000ab94:	e2833001 	add	r3, r3, #1
3000ab98:	e58d3014 	str	r3, [sp, #20]
			if (qualifier == 'l' && *fmt == 'l') {
3000ab9c:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000aba0:	e353006c 	cmp	r3, #108	; 0x6c
3000aba4:	1a000008 	bne	3000abcc <vsnprintf+0x33c>
3000aba8:	e59d3014 	ldr	r3, [sp, #20]
3000abac:	e5d33000 	ldrb	r3, [r3]
3000abb0:	e353006c 	cmp	r3, #108	; 0x6c
3000abb4:	1a000004 	bne	3000abcc <vsnprintf+0x33c>
				qualifier = 'L';
3000abb8:	e3a0304c 	mov	r3, #76	; 0x4c
3000abbc:	e58d3058 	str	r3, [sp, #88]	; 0x58
				++fmt;
3000abc0:	e59d3014 	ldr	r3, [sp, #20]
3000abc4:	e2833001 	add	r3, r3, #1
3000abc8:	e58d3014 	str	r3, [sp, #20]
			}
		}

		/* default base */
		base = 10;
3000abcc:	e3a0300a 	mov	r3, #10
3000abd0:	e58d3038 	str	r3, [sp, #56]	; 0x38

		switch (*fmt) {
3000abd4:	e59d3014 	ldr	r3, [sp, #20]
3000abd8:	e5d33000 	ldrb	r3, [r3]
3000abdc:	e2433025 	sub	r3, r3, #37	; 0x25
3000abe0:	e3530053 	cmp	r3, #83	; 0x53
3000abe4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3000abe8:	ea00014b 	b	3000b11c <vsnprintf+0x88c>
3000abec:	3000b0bc 	.word	0x3000b0bc
3000abf0:	3000b11c 	.word	0x3000b11c
3000abf4:	3000b11c 	.word	0x3000b11c
3000abf8:	3000b11c 	.word	0x3000b11c
3000abfc:	3000b11c 	.word	0x3000b11c
3000ac00:	3000b11c 	.word	0x3000b11c
3000ac04:	3000b11c 	.word	0x3000b11c
3000ac08:	3000b11c 	.word	0x3000b11c
3000ac0c:	3000b11c 	.word	0x3000b11c
3000ac10:	3000b11c 	.word	0x3000b11c
3000ac14:	3000b11c 	.word	0x3000b11c
3000ac18:	3000b11c 	.word	0x3000b11c
3000ac1c:	3000b11c 	.word	0x3000b11c
3000ac20:	3000b11c 	.word	0x3000b11c
3000ac24:	3000b11c 	.word	0x3000b11c
3000ac28:	3000b11c 	.word	0x3000b11c
3000ac2c:	3000b11c 	.word	0x3000b11c
3000ac30:	3000b11c 	.word	0x3000b11c
3000ac34:	3000b11c 	.word	0x3000b11c
3000ac38:	3000b11c 	.word	0x3000b11c
3000ac3c:	3000b11c 	.word	0x3000b11c
3000ac40:	3000b11c 	.word	0x3000b11c
3000ac44:	3000b11c 	.word	0x3000b11c
3000ac48:	3000b11c 	.word	0x3000b11c
3000ac4c:	3000b11c 	.word	0x3000b11c
3000ac50:	3000b11c 	.word	0x3000b11c
3000ac54:	3000b11c 	.word	0x3000b11c
3000ac58:	3000b11c 	.word	0x3000b11c
3000ac5c:	3000b11c 	.word	0x3000b11c
3000ac60:	3000b11c 	.word	0x3000b11c
3000ac64:	3000b11c 	.word	0x3000b11c
3000ac68:	3000b11c 	.word	0x3000b11c
3000ac6c:	3000b11c 	.word	0x3000b11c
3000ac70:	3000b11c 	.word	0x3000b11c
3000ac74:	3000b11c 	.word	0x3000b11c
3000ac78:	3000b11c 	.word	0x3000b11c
3000ac7c:	3000b11c 	.word	0x3000b11c
3000ac80:	3000b11c 	.word	0x3000b11c
3000ac84:	3000b11c 	.word	0x3000b11c
3000ac88:	3000b11c 	.word	0x3000b11c
3000ac8c:	3000b11c 	.word	0x3000b11c
3000ac90:	3000b11c 	.word	0x3000b11c
3000ac94:	3000b11c 	.word	0x3000b11c
3000ac98:	3000b11c 	.word	0x3000b11c
3000ac9c:	3000b11c 	.word	0x3000b11c
3000aca0:	3000b11c 	.word	0x3000b11c
3000aca4:	3000b11c 	.word	0x3000b11c
3000aca8:	3000b11c 	.word	0x3000b11c
3000acac:	3000b11c 	.word	0x3000b11c
3000acb0:	3000b11c 	.word	0x3000b11c
3000acb4:	3000b11c 	.word	0x3000b11c
3000acb8:	3000b0f4 	.word	0x3000b0f4
3000acbc:	3000b11c 	.word	0x3000b11c
3000acc0:	3000b11c 	.word	0x3000b11c
3000acc4:	3000b11c 	.word	0x3000b11c
3000acc8:	3000b11c 	.word	0x3000b11c
3000accc:	3000b11c 	.word	0x3000b11c
3000acd0:	3000b11c 	.word	0x3000b11c
3000acd4:	3000b11c 	.word	0x3000b11c
3000acd8:	3000b11c 	.word	0x3000b11c
3000acdc:	3000b11c 	.word	0x3000b11c
3000ace0:	3000b11c 	.word	0x3000b11c
3000ace4:	3000ad3c 	.word	0x3000ad3c
3000ace8:	3000b10c 	.word	0x3000b10c
3000acec:	3000b11c 	.word	0x3000b11c
3000acf0:	3000b11c 	.word	0x3000b11c
3000acf4:	3000b11c 	.word	0x3000b11c
3000acf8:	3000b11c 	.word	0x3000b11c
3000acfc:	3000b10c 	.word	0x3000b10c
3000ad00:	3000b11c 	.word	0x3000b11c
3000ad04:	3000b11c 	.word	0x3000b11c
3000ad08:	3000b11c 	.word	0x3000b11c
3000ad0c:	3000b11c 	.word	0x3000b11c
3000ad10:	3000b004 	.word	0x3000b004
3000ad14:	3000b0e8 	.word	0x3000b0e8
3000ad18:	3000af88 	.word	0x3000af88
3000ad1c:	3000b11c 	.word	0x3000b11c
3000ad20:	3000b11c 	.word	0x3000b11c
3000ad24:	3000ae1c 	.word	0x3000ae1c
3000ad28:	3000b11c 	.word	0x3000b11c
3000ad2c:	3000b194 	.word	0x3000b194
3000ad30:	3000b11c 	.word	0x3000b11c
3000ad34:	3000b11c 	.word	0x3000b11c
3000ad38:	3000b100 	.word	0x3000b100
			case 'c':
				if (!(flags & LEFT)) {
3000ad3c:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000ad40:	e2033010 	and	r3, r3, #16
3000ad44:	e3530000 	cmp	r3, #0
3000ad48:	1a000010 	bne	3000ad90 <vsnprintf+0x500>
					while (--field_width > 0) {
3000ad4c:	ea000009 	b	3000ad78 <vsnprintf+0x4e8>
						if (str <= end)
3000ad50:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000ad54:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000ad58:	e1520003 	cmp	r2, r3
3000ad5c:	8a000002 	bhi	3000ad6c <vsnprintf+0x4dc>
							*str = ' ';
3000ad60:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000ad64:	e3a02020 	mov	r2, #32
3000ad68:	e5c32000 	strb	r2, [r3]
						++str;
3000ad6c:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000ad70:	e2833001 	add	r3, r3, #1
3000ad74:	e58d303c 	str	r3, [sp, #60]	; 0x3c
		base = 10;

		switch (*fmt) {
			case 'c':
				if (!(flags & LEFT)) {
					while (--field_width > 0) {
3000ad78:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
3000ad7c:	e2433001 	sub	r3, r3, #1
3000ad80:	e58d3050 	str	r3, [sp, #80]	; 0x50
3000ad84:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
3000ad88:	e3530000 	cmp	r3, #0
3000ad8c:	caffffef 	bgt	3000ad50 <vsnprintf+0x4c0>
						if (str <= end)
							*str = ' ';
						++str;
					}
				}
				c = (acoral_u8) va_arg(args, acoral_32);
3000ad90:	e59d3010 	ldr	r3, [sp, #16]
3000ad94:	e2833004 	add	r3, r3, #4
3000ad98:	e58d3010 	str	r3, [sp, #16]
3000ad9c:	e59d3010 	ldr	r3, [sp, #16]
3000ada0:	e2433004 	sub	r3, r3, #4
3000ada4:	e5933000 	ldr	r3, [r3]
3000ada8:	e5cd3047 	strb	r3, [sp, #71]	; 0x47
				if (str <= end)
3000adac:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000adb0:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000adb4:	e1520003 	cmp	r2, r3
3000adb8:	8a000002 	bhi	3000adc8 <vsnprintf+0x538>
					*str = c;
3000adbc:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000adc0:	e5dd2047 	ldrb	r2, [sp, #71]	; 0x47
3000adc4:	e5c32000 	strb	r2, [r3]
				++str;
3000adc8:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000adcc:	e2833001 	add	r3, r3, #1
3000add0:	e58d303c 	str	r3, [sp, #60]	; 0x3c
				while (--field_width > 0) {
3000add4:	ea000009 	b	3000ae00 <vsnprintf+0x570>
					if (str <= end)
3000add8:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000addc:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000ade0:	e1520003 	cmp	r2, r3
3000ade4:	8a000002 	bhi	3000adf4 <vsnprintf+0x564>
						*str = ' ';
3000ade8:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000adec:	e3a02020 	mov	r2, #32
3000adf0:	e5c32000 	strb	r2, [r3]
					++str;
3000adf4:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000adf8:	e2833001 	add	r3, r3, #1
3000adfc:	e58d303c 	str	r3, [sp, #60]	; 0x3c
				}
				c = (acoral_u8) va_arg(args, acoral_32);
				if (str <= end)
					*str = c;
				++str;
				while (--field_width > 0) {
3000ae00:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
3000ae04:	e2433001 	sub	r3, r3, #1
3000ae08:	e58d3050 	str	r3, [sp, #80]	; 0x50
3000ae0c:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
3000ae10:	e3530000 	cmp	r3, #0
3000ae14:	caffffef 	bgt	3000add8 <vsnprintf+0x548>
					if (str <= end)
						*str = ' ';
					++str;
				}
				continue;
3000ae18:	ea00014b 	b	3000b34c <vsnprintf+0xabc>

			case 's':
				s = va_arg(args, acoral_char *);
3000ae1c:	e59d3010 	ldr	r3, [sp, #16]
3000ae20:	e2833004 	add	r3, r3, #4
3000ae24:	e58d3010 	str	r3, [sp, #16]
3000ae28:	e59d3010 	ldr	r3, [sp, #16]
3000ae2c:	e2433004 	sub	r3, r3, #4
3000ae30:	e5933000 	ldr	r3, [r3]
3000ae34:	e58d3048 	str	r3, [sp, #72]	; 0x48
				if (!s)
3000ae38:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
3000ae3c:	e3530000 	cmp	r3, #0
3000ae40:	1a000001 	bne	3000ae4c <vsnprintf+0x5bc>
					s = "<NULL>";
3000ae44:	e59f3578 	ldr	r3, [pc, #1400]	; 3000b3c4 <vsnprintf+0xb34>
3000ae48:	e58d3048 	str	r3, [sp, #72]	; 0x48

				len = acoral_str_nlen(s, precision);
3000ae4c:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
3000ae50:	e59d0048 	ldr	r0, [sp, #72]	; 0x48
3000ae54:	e1a01003 	mov	r1, r3
3000ae58:	eb0004c5 	bl	3000c174 <acoral_str_nlen>
3000ae5c:	e1a03000 	mov	r3, r0
3000ae60:	e58d3024 	str	r3, [sp, #36]	; 0x24

				if (!(flags & LEFT)) {
3000ae64:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000ae68:	e2033010 	and	r3, r3, #16
3000ae6c:	e3530000 	cmp	r3, #0
3000ae70:	1a000015 	bne	3000aecc <vsnprintf+0x63c>
					while (len < field_width--) {
3000ae74:	ea000009 	b	3000aea0 <vsnprintf+0x610>
						if (str <= end)
3000ae78:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000ae7c:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000ae80:	e1520003 	cmp	r2, r3
3000ae84:	8a000002 	bhi	3000ae94 <vsnprintf+0x604>
							*str = ' ';
3000ae88:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000ae8c:	e3a02020 	mov	r2, #32
3000ae90:	e5c32000 	strb	r2, [r3]
						++str;
3000ae94:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000ae98:	e2833001 	add	r3, r3, #1
3000ae9c:	e58d303c 	str	r3, [sp, #60]	; 0x3c
					s = "<NULL>";

				len = acoral_str_nlen(s, precision);

				if (!(flags & LEFT)) {
					while (len < field_width--) {
3000aea0:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
3000aea4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3000aea8:	e1520003 	cmp	r2, r3
3000aeac:	d3a03000 	movle	r3, #0
3000aeb0:	c3a03001 	movgt	r3, #1
3000aeb4:	e20330ff 	and	r3, r3, #255	; 0xff
3000aeb8:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
3000aebc:	e2422001 	sub	r2, r2, #1
3000aec0:	e58d2050 	str	r2, [sp, #80]	; 0x50
3000aec4:	e3530000 	cmp	r3, #0
3000aec8:	1affffea 	bne	3000ae78 <vsnprintf+0x5e8>
						if (str <= end)
							*str = ' ';
						++str;
					}
				}
				for (i = 0; i < len; ++i) {
3000aecc:	e3a03000 	mov	r3, #0
3000aed0:	e58d3034 	str	r3, [sp, #52]	; 0x34
3000aed4:	ea000010 	b	3000af1c <vsnprintf+0x68c>
					if (str <= end)
3000aed8:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000aedc:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000aee0:	e1520003 	cmp	r2, r3
3000aee4:	8a000003 	bhi	3000aef8 <vsnprintf+0x668>
						*str = *s;
3000aee8:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
3000aeec:	e5d32000 	ldrb	r2, [r3]
3000aef0:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000aef4:	e5c32000 	strb	r2, [r3]
					++str; ++s;
3000aef8:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000aefc:	e2833001 	add	r3, r3, #1
3000af00:	e58d303c 	str	r3, [sp, #60]	; 0x3c
3000af04:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
3000af08:	e2833001 	add	r3, r3, #1
3000af0c:	e58d3048 	str	r3, [sp, #72]	; 0x48
						if (str <= end)
							*str = ' ';
						++str;
					}
				}
				for (i = 0; i < len; ++i) {
3000af10:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3000af14:	e2833001 	add	r3, r3, #1
3000af18:	e58d3034 	str	r3, [sp, #52]	; 0x34
3000af1c:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3000af20:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3000af24:	e1520003 	cmp	r2, r3
3000af28:	baffffea 	blt	3000aed8 <vsnprintf+0x648>
					if (str <= end)
						*str = *s;
					++str; ++s;
				}
				while (len < field_width--) {
3000af2c:	ea000009 	b	3000af58 <vsnprintf+0x6c8>
					if (str <= end)
3000af30:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000af34:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000af38:	e1520003 	cmp	r2, r3
3000af3c:	8a000002 	bhi	3000af4c <vsnprintf+0x6bc>
						*str = ' ';
3000af40:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000af44:	e3a02020 	mov	r2, #32
3000af48:	e5c32000 	strb	r2, [r3]
					++str;
3000af4c:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000af50:	e2833001 	add	r3, r3, #1
3000af54:	e58d303c 	str	r3, [sp, #60]	; 0x3c
				for (i = 0; i < len; ++i) {
					if (str <= end)
						*str = *s;
					++str; ++s;
				}
				while (len < field_width--) {
3000af58:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
3000af5c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3000af60:	e1520003 	cmp	r2, r3
3000af64:	d3a03000 	movle	r3, #0
3000af68:	c3a03001 	movgt	r3, #1
3000af6c:	e20330ff 	and	r3, r3, #255	; 0xff
3000af70:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
3000af74:	e2422001 	sub	r2, r2, #1
3000af78:	e58d2050 	str	r2, [sp, #80]	; 0x50
3000af7c:	e3530000 	cmp	r3, #0
3000af80:	1affffea 	bne	3000af30 <vsnprintf+0x6a0>
					if (str <= end)
						*str = ' ';
					++str;
				}
				continue;
3000af84:	ea0000f0 	b	3000b34c <vsnprintf+0xabc>

			case 'p':
				if (field_width == -1) {
3000af88:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
3000af8c:	e3730001 	cmn	r3, #1
3000af90:	1a000004 	bne	3000afa8 <vsnprintf+0x718>
					field_width = 2*sizeof(void *);
3000af94:	e3a03008 	mov	r3, #8
3000af98:	e58d3050 	str	r3, [sp, #80]	; 0x50
					flags |= ZEROPAD;
3000af9c:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000afa0:	e3833001 	orr	r3, r3, #1
3000afa4:	e58d304c 	str	r3, [sp, #76]	; 0x4c
				}
				str = number(str, end,
3000afa8:	e59d3010 	ldr	r3, [sp, #16]
3000afac:	e2833004 	add	r3, r3, #4
3000afb0:	e58d3010 	str	r3, [sp, #16]
						(acoral_u32) va_arg(args, void *),
3000afb4:	e59d3010 	ldr	r3, [sp, #16]
3000afb8:	e2433004 	sub	r3, r3, #4
3000afbc:	e5933000 	ldr	r3, [r3]
			case 'p':
				if (field_width == -1) {
					field_width = 2*sizeof(void *);
					flags |= ZEROPAD;
				}
				str = number(str, end,
3000afc0:	e3a04000 	mov	r4, #0
3000afc4:	e3a02010 	mov	r2, #16
3000afc8:	e58d2000 	str	r2, [sp]
3000afcc:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
3000afd0:	e58d2004 	str	r2, [sp, #4]
3000afd4:	e59d2054 	ldr	r2, [sp, #84]	; 0x54
3000afd8:	e58d2008 	str	r2, [sp, #8]
3000afdc:	e59d204c 	ldr	r2, [sp, #76]	; 0x4c
3000afe0:	e58d200c 	str	r2, [sp, #12]
3000afe4:	e59d003c 	ldr	r0, [sp, #60]	; 0x3c
3000afe8:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
3000afec:	e1a02003 	mov	r2, r3
3000aff0:	e1a03004 	mov	r3, r4
3000aff4:	ebfffcdf 	bl	3000a378 <number>
3000aff8:	e1a03000 	mov	r3, r0
3000affc:	e58d303c 	str	r3, [sp, #60]	; 0x3c
						(acoral_u32) va_arg(args, void *),
						16, field_width, precision, flags);
				continue;
3000b000:	ea0000d1 	b	3000b34c <vsnprintf+0xabc>


			case 'n':
				/* FIXME:
				* What does C99 say about the overflow case here? */
				if (qualifier == 'l') {
3000b004:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000b008:	e353006c 	cmp	r3, #108	; 0x6c
3000b00c:	1a00000c 	bne	3000b044 <vsnprintf+0x7b4>
					acoral_32 * ip = va_arg(args, acoral_32 *);
3000b010:	e59d3010 	ldr	r3, [sp, #16]
3000b014:	e2833004 	add	r3, r3, #4
3000b018:	e58d3010 	str	r3, [sp, #16]
3000b01c:	e59d3010 	ldr	r3, [sp, #16]
3000b020:	e2433004 	sub	r3, r3, #4
3000b024:	e5933000 	ldr	r3, [r3]
3000b028:	e58d305c 	str	r3, [sp, #92]	; 0x5c
					*ip = (str - buf);
3000b02c:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000b030:	e59d301c 	ldr	r3, [sp, #28]
3000b034:	e0632002 	rsb	r2, r3, r2
3000b038:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
3000b03c:	e5832000 	str	r2, [r3]
					*ip = (str - buf);
				} else {
					acoral_32 * ip = va_arg(args, acoral_32 *);
					*ip = (str - buf);
				}
				continue;
3000b040:	ea0000c1 	b	3000b34c <vsnprintf+0xabc>
				/* FIXME:
				* What does C99 say about the overflow case here? */
				if (qualifier == 'l') {
					acoral_32 * ip = va_arg(args, acoral_32 *);
					*ip = (str - buf);
				} else if (qualifier == 'Z') {
3000b044:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000b048:	e353005a 	cmp	r3, #90	; 0x5a
3000b04c:	1a00000d 	bne	3000b088 <vsnprintf+0x7f8>
					acoral_u32 * ip = va_arg(args, acoral_u32 *);
3000b050:	e59d3010 	ldr	r3, [sp, #16]
3000b054:	e2833004 	add	r3, r3, #4
3000b058:	e58d3010 	str	r3, [sp, #16]
3000b05c:	e59d3010 	ldr	r3, [sp, #16]
3000b060:	e2433004 	sub	r3, r3, #4
3000b064:	e5933000 	ldr	r3, [r3]
3000b068:	e58d3060 	str	r3, [sp, #96]	; 0x60
					*ip = (str - buf);
3000b06c:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000b070:	e59d301c 	ldr	r3, [sp, #28]
3000b074:	e0633002 	rsb	r3, r3, r2
3000b078:	e1a02003 	mov	r2, r3
3000b07c:	e59d3060 	ldr	r3, [sp, #96]	; 0x60
3000b080:	e5832000 	str	r2, [r3]
				} else {
					acoral_32 * ip = va_arg(args, acoral_32 *);
					*ip = (str - buf);
				}
				continue;
3000b084:	ea0000b0 	b	3000b34c <vsnprintf+0xabc>
					*ip = (str - buf);
				} else if (qualifier == 'Z') {
					acoral_u32 * ip = va_arg(args, acoral_u32 *);
					*ip = (str - buf);
				} else {
					acoral_32 * ip = va_arg(args, acoral_32 *);
3000b088:	e59d3010 	ldr	r3, [sp, #16]
3000b08c:	e2833004 	add	r3, r3, #4
3000b090:	e58d3010 	str	r3, [sp, #16]
3000b094:	e59d3010 	ldr	r3, [sp, #16]
3000b098:	e2433004 	sub	r3, r3, #4
3000b09c:	e5933000 	ldr	r3, [r3]
3000b0a0:	e58d3064 	str	r3, [sp, #100]	; 0x64
					*ip = (str - buf);
3000b0a4:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000b0a8:	e59d301c 	ldr	r3, [sp, #28]
3000b0ac:	e0632002 	rsb	r2, r3, r2
3000b0b0:	e59d3064 	ldr	r3, [sp, #100]	; 0x64
3000b0b4:	e5832000 	str	r2, [r3]
				}
				continue;
3000b0b8:	ea0000a3 	b	3000b34c <vsnprintf+0xabc>

			case '%':
				if (str <= end)
3000b0bc:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000b0c0:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000b0c4:	e1520003 	cmp	r2, r3
3000b0c8:	8a000002 	bhi	3000b0d8 <vsnprintf+0x848>
					*str = '%';
3000b0cc:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000b0d0:	e3a02025 	mov	r2, #37	; 0x25
3000b0d4:	e5c32000 	strb	r2, [r3]
				++str;
3000b0d8:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000b0dc:	e2833001 	add	r3, r3, #1
3000b0e0:	e58d303c 	str	r3, [sp, #60]	; 0x3c
				continue;
3000b0e4:	ea000098 	b	3000b34c <vsnprintf+0xabc>

				/* acoral_32eger number formats - set up the flags and "break" */
			case 'o':
				base = 8;
3000b0e8:	e3a03008 	mov	r3, #8
3000b0ec:	e58d3038 	str	r3, [sp, #56]	; 0x38
				break;
3000b0f0:	ea000028 	b	3000b198 <vsnprintf+0x908>

			case 'X':
				flags |= LARGE;
3000b0f4:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000b0f8:	e3833040 	orr	r3, r3, #64	; 0x40
3000b0fc:	e58d304c 	str	r3, [sp, #76]	; 0x4c
			case 'x':
				base = 16;
3000b100:	e3a03010 	mov	r3, #16
3000b104:	e58d3038 	str	r3, [sp, #56]	; 0x38
				break;
3000b108:	ea000022 	b	3000b198 <vsnprintf+0x908>

			case 'd':
			case 'i':
				flags |= SIGN;
3000b10c:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000b110:	e3833002 	orr	r3, r3, #2
3000b114:	e58d304c 	str	r3, [sp, #76]	; 0x4c
			case 'u':
				break;
3000b118:	ea00001e 	b	3000b198 <vsnprintf+0x908>

			default:
				if (str <= end)
3000b11c:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000b120:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000b124:	e1520003 	cmp	r2, r3
3000b128:	8a000002 	bhi	3000b138 <vsnprintf+0x8a8>
					*str = '%';
3000b12c:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000b130:	e3a02025 	mov	r2, #37	; 0x25
3000b134:	e5c32000 	strb	r2, [r3]
				++str;
3000b138:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000b13c:	e2833001 	add	r3, r3, #1
3000b140:	e58d303c 	str	r3, [sp, #60]	; 0x3c
				if (*fmt) {
3000b144:	e59d3014 	ldr	r3, [sp, #20]
3000b148:	e5d33000 	ldrb	r3, [r3]
3000b14c:	e3530000 	cmp	r3, #0
3000b150:	0a00000b 	beq	3000b184 <vsnprintf+0x8f4>
					if (str <= end)
3000b154:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000b158:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000b15c:	e1520003 	cmp	r2, r3
3000b160:	8a000003 	bhi	3000b174 <vsnprintf+0x8e4>
						*str = *fmt;
3000b164:	e59d3014 	ldr	r3, [sp, #20]
3000b168:	e5d32000 	ldrb	r2, [r3]
3000b16c:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000b170:	e5c32000 	strb	r2, [r3]
					++str;
3000b174:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000b178:	e2833001 	add	r3, r3, #1
3000b17c:	e58d303c 	str	r3, [sp, #60]	; 0x3c
				} else {
					--fmt;
				}
				continue;
3000b180:	ea000071 	b	3000b34c <vsnprintf+0xabc>
				if (*fmt) {
					if (str <= end)
						*str = *fmt;
					++str;
				} else {
					--fmt;
3000b184:	e59d3014 	ldr	r3, [sp, #20]
3000b188:	e2433001 	sub	r3, r3, #1
3000b18c:	e58d3014 	str	r3, [sp, #20]
				}
				continue;
3000b190:	ea00006d 	b	3000b34c <vsnprintf+0xabc>

			case 'd':
			case 'i':
				flags |= SIGN;
			case 'u':
				break;
3000b194:	e1a00000 	nop			; (mov r0, r0)
				} else {
					--fmt;
				}
				continue;
		}
		if (qualifier == 'L')
3000b198:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000b19c:	e353004c 	cmp	r3, #76	; 0x4c
3000b1a0:	1a000008 	bne	3000b1c8 <vsnprintf+0x938>
			num = va_arg(args, acoral_64);
3000b1a4:	e59d3010 	ldr	r3, [sp, #16]
3000b1a8:	e2833008 	add	r3, r3, #8
3000b1ac:	e58d3010 	str	r3, [sp, #16]
3000b1b0:	e59d3010 	ldr	r3, [sp, #16]
3000b1b4:	e2433008 	sub	r3, r3, #8
3000b1b8:	e8930018 	ldm	r3, {r3, r4}
3000b1bc:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000b1c0:	e58d402c 	str	r4, [sp, #44]	; 0x2c
3000b1c4:	ea00004f 	b	3000b308 <vsnprintf+0xa78>
		else if (qualifier == 'l') {
3000b1c8:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000b1cc:	e353006c 	cmp	r3, #108	; 0x6c
3000b1d0:	1a000011 	bne	3000b21c <vsnprintf+0x98c>
			num = va_arg(args, acoral_u32);
3000b1d4:	e59d3010 	ldr	r3, [sp, #16]
3000b1d8:	e2833004 	add	r3, r3, #4
3000b1dc:	e58d3010 	str	r3, [sp, #16]
3000b1e0:	e59d3010 	ldr	r3, [sp, #16]
3000b1e4:	e2433004 	sub	r3, r3, #4
3000b1e8:	e5933000 	ldr	r3, [r3]
3000b1ec:	e3a04000 	mov	r4, #0
3000b1f0:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000b1f4:	e58d402c 	str	r4, [sp, #44]	; 0x2c
			if (flags & SIGN)
3000b1f8:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000b1fc:	e2033002 	and	r3, r3, #2
3000b200:	e3530000 	cmp	r3, #0
3000b204:	0a00003c 	beq	3000b2fc <vsnprintf+0xa6c>
				num = (acoral_32) num;
3000b208:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000b20c:	e1a04fc3 	asr	r4, r3, #31
3000b210:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000b214:	e58d402c 	str	r4, [sp, #44]	; 0x2c
3000b218:	ea00003a 	b	3000b308 <vsnprintf+0xa78>
		} else if (qualifier == 'Z') {
3000b21c:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000b220:	e353005a 	cmp	r3, #90	; 0x5a
3000b224:	1a000009 	bne	3000b250 <vsnprintf+0x9c0>
			num = va_arg(args, acoral_u32);
3000b228:	e59d3010 	ldr	r3, [sp, #16]
3000b22c:	e2833004 	add	r3, r3, #4
3000b230:	e58d3010 	str	r3, [sp, #16]
3000b234:	e59d3010 	ldr	r3, [sp, #16]
3000b238:	e2433004 	sub	r3, r3, #4
3000b23c:	e5933000 	ldr	r3, [r3]
3000b240:	e3a04000 	mov	r4, #0
3000b244:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000b248:	e58d402c 	str	r4, [sp, #44]	; 0x2c
3000b24c:	ea00002d 	b	3000b308 <vsnprintf+0xa78>
		} else if (qualifier == 'h') {
3000b250:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000b254:	e3530068 	cmp	r3, #104	; 0x68
3000b258:	1a000015 	bne	3000b2b4 <vsnprintf+0xa24>
			num = (acoral_u16) va_arg(args, acoral_32);
3000b25c:	e59d3010 	ldr	r3, [sp, #16]
3000b260:	e2833004 	add	r3, r3, #4
3000b264:	e58d3010 	str	r3, [sp, #16]
3000b268:	e59d3010 	ldr	r3, [sp, #16]
3000b26c:	e2433004 	sub	r3, r3, #4
3000b270:	e5933000 	ldr	r3, [r3]
3000b274:	e1a03803 	lsl	r3, r3, #16
3000b278:	e1a03823 	lsr	r3, r3, #16
3000b27c:	e3a04000 	mov	r4, #0
3000b280:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000b284:	e58d402c 	str	r4, [sp, #44]	; 0x2c
			if (flags & SIGN)
3000b288:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000b28c:	e2033002 	and	r3, r3, #2
3000b290:	e3530000 	cmp	r3, #0
3000b294:	0a00001a 	beq	3000b304 <vsnprintf+0xa74>
				num = (acoral_16) num;
3000b298:	e1dd32b8 	ldrh	r3, [sp, #40]	; 0x28
3000b29c:	e1a03803 	lsl	r3, r3, #16
3000b2a0:	e1a03843 	asr	r3, r3, #16
3000b2a4:	e1a04fc3 	asr	r4, r3, #31
3000b2a8:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000b2ac:	e58d402c 	str	r4, [sp, #44]	; 0x2c
3000b2b0:	ea000014 	b	3000b308 <vsnprintf+0xa78>
		} else {
			num = va_arg(args, acoral_u32);
3000b2b4:	e59d3010 	ldr	r3, [sp, #16]
3000b2b8:	e2833004 	add	r3, r3, #4
3000b2bc:	e58d3010 	str	r3, [sp, #16]
3000b2c0:	e59d3010 	ldr	r3, [sp, #16]
3000b2c4:	e2433004 	sub	r3, r3, #4
3000b2c8:	e5933000 	ldr	r3, [r3]
3000b2cc:	e3a04000 	mov	r4, #0
3000b2d0:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000b2d4:	e58d402c 	str	r4, [sp, #44]	; 0x2c
			if (flags & SIGN)
3000b2d8:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000b2dc:	e2033002 	and	r3, r3, #2
3000b2e0:	e3530000 	cmp	r3, #0
3000b2e4:	0a000007 	beq	3000b308 <vsnprintf+0xa78>
				num = (acoral_32) num;
3000b2e8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000b2ec:	e1a04fc3 	asr	r4, r3, #31
3000b2f0:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000b2f4:	e58d402c 	str	r4, [sp, #44]	; 0x2c
3000b2f8:	ea000002 	b	3000b308 <vsnprintf+0xa78>
		if (qualifier == 'L')
			num = va_arg(args, acoral_64);
		else if (qualifier == 'l') {
			num = va_arg(args, acoral_u32);
			if (flags & SIGN)
				num = (acoral_32) num;
3000b2fc:	e1a00000 	nop			; (mov r0, r0)
3000b300:	ea000000 	b	3000b308 <vsnprintf+0xa78>
		} else if (qualifier == 'Z') {
			num = va_arg(args, acoral_u32);
		} else if (qualifier == 'h') {
			num = (acoral_u16) va_arg(args, acoral_32);
			if (flags & SIGN)
				num = (acoral_16) num;
3000b304:	e1a00000 	nop			; (mov r0, r0)
		} else {
			num = va_arg(args, acoral_u32);
			if (flags & SIGN)
				num = (acoral_32) num;
		}
		str = number(str, end, num, base,
3000b308:	e28d4028 	add	r4, sp, #40	; 0x28
3000b30c:	e8940018 	ldm	r4, {r3, r4}
3000b310:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
3000b314:	e58d2000 	str	r2, [sp]
3000b318:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
3000b31c:	e58d2004 	str	r2, [sp, #4]
3000b320:	e59d2054 	ldr	r2, [sp, #84]	; 0x54
3000b324:	e58d2008 	str	r2, [sp, #8]
3000b328:	e59d204c 	ldr	r2, [sp, #76]	; 0x4c
3000b32c:	e58d200c 	str	r2, [sp, #12]
3000b330:	e59d003c 	ldr	r0, [sp, #60]	; 0x3c
3000b334:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
3000b338:	e1a02003 	mov	r2, r3
3000b33c:	e1a03004 	mov	r3, r4
3000b340:	ebfffc0c 	bl	3000a378 <number>
3000b344:	e1a03000 	mov	r3, r0
3000b348:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	if (end < buf - 1) {
		end = ((void *) -1);
		size = end - buf + 1;
	}

	for (; *fmt ; ++fmt) {
3000b34c:	e59d3014 	ldr	r3, [sp, #20]
3000b350:	e2833001 	add	r3, r3, #1
3000b354:	e58d3014 	str	r3, [sp, #20]
3000b358:	ea000000 	b	3000b360 <vsnprintf+0xad0>
3000b35c:	e1a00000 	nop			; (mov r0, r0)
3000b360:	e59d3014 	ldr	r3, [sp, #20]
3000b364:	e5d33000 	ldrb	r3, [r3]
3000b368:	e3530000 	cmp	r3, #0
3000b36c:	1afffd61 	bne	3000a8f8 <vsnprintf+0x68>
				num = (acoral_32) num;
		}
		str = number(str, end, num, base,
				field_width, precision, flags);
	}
	if (str <= end)
3000b370:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000b374:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000b378:	e1520003 	cmp	r2, r3
3000b37c:	8a000003 	bhi	3000b390 <vsnprintf+0xb00>
		*str = '\0';
3000b380:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000b384:	e3a02000 	mov	r2, #0
3000b388:	e5c32000 	strb	r2, [r3]
3000b38c:	ea000005 	b	3000b3a8 <vsnprintf+0xb18>
	else if (size > 0)
3000b390:	e59d3018 	ldr	r3, [sp, #24]
3000b394:	e3530000 	cmp	r3, #0
3000b398:	0a000002 	beq	3000b3a8 <vsnprintf+0xb18>
		/* don't write out a null byte if the buf size is zero */
		*end = '\0';
3000b39c:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000b3a0:	e3a02000 	mov	r2, #0
3000b3a4:	e5c32000 	strb	r2, [r3]
	/* the trailing null byte doesn't count towards the total
	* ++str;
	*/
	return str-buf;
3000b3a8:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000b3ac:	e59d301c 	ldr	r3, [sp, #28]
3000b3b0:	e0633002 	rsb	r3, r3, r2
}
3000b3b4:	e1a00003 	mov	r0, r3
3000b3b8:	e28dd068 	add	sp, sp, #104	; 0x68
3000b3bc:	e8bd4010 	pop	{r4, lr}
3000b3c0:	e12fff1e 	bx	lr
3000b3c4:	30026460 	.word	0x30026460

3000b3c8 <acoral_sprint>:

acoral_32 acoral_sprint(acoral_char * buf, acoral_u32 size, const acoral_char *fmt, ...)
{
3000b3c8:	e92d000c 	push	{r2, r3}
3000b3cc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b3d0:	e24dd014 	sub	sp, sp, #20
3000b3d4:	e58d0004 	str	r0, [sp, #4]
3000b3d8:	e58d1000 	str	r1, [sp]
	acoral_32 i;
	va_list args;
	va_start(args, fmt);
3000b3dc:	e28d3018 	add	r3, sp, #24
3000b3e0:	e2833004 	add	r3, r3, #4
3000b3e4:	e58d300c 	str	r3, [sp, #12]
	i=vsnprintf(buf,size,fmt,args);
3000b3e8:	e59d3018 	ldr	r3, [sp, #24]
3000b3ec:	e59d0004 	ldr	r0, [sp, #4]
3000b3f0:	e59d1000 	ldr	r1, [sp]
3000b3f4:	e1a02003 	mov	r2, r3
3000b3f8:	e59d300c 	ldr	r3, [sp, #12]
3000b3fc:	ebfffd23 	bl	3000a890 <vsnprintf>
3000b400:	e1a03000 	mov	r3, r0
3000b404:	e58d3008 	str	r3, [sp, #8]
	va_end(args);
3000b408:	e3a03000 	mov	r3, #0
3000b40c:	e58d300c 	str	r3, [sp, #12]
	return i;
3000b410:	e59d3008 	ldr	r3, [sp, #8]
}
3000b414:	e1a00003 	mov	r0, r3
3000b418:	e28dd014 	add	sp, sp, #20
3000b41c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000b420:	e28dd008 	add	sp, sp, #8
3000b424:	e12fff1e 	bx	lr

3000b428 <acoral_print>:

acoral_32 acoral_print(const acoral_char *fmt, ...)
{
3000b428:	e92d000f 	push	{r0, r1, r2, r3}
3000b42c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b430:	e24dd014 	sub	sp, sp, #20
	va_list args;
	acoral_32 printed_len;
	static acoral_char print_buf[256];
	va_start(args, fmt);
3000b434:	e28d3018 	add	r3, sp, #24
3000b438:	e2833004 	add	r3, r3, #4
3000b43c:	e58d3008 	str	r3, [sp, #8]
	printed_len =vsnprintf(print_buf, sizeof(print_buf), fmt, args);
3000b440:	e59d3018 	ldr	r3, [sp, #24]
3000b444:	e59f0060 	ldr	r0, [pc, #96]	; 3000b4ac <acoral_print+0x84>
3000b448:	e3a01c01 	mov	r1, #256	; 0x100
3000b44c:	e1a02003 	mov	r2, r3
3000b450:	e59d3008 	ldr	r3, [sp, #8]
3000b454:	ebfffd0d 	bl	3000a890 <vsnprintf>
3000b458:	e1a03000 	mov	r3, r0
3000b45c:	e58d300c 	str	r3, [sp, #12]
	va_end(args);
3000b460:	e3a03000 	mov	r3, #0
3000b464:	e58d3008 	str	r3, [sp, #8]
	return acoral_dev_write(acoral_cur_thread->console_id,(void *)print_buf,printed_len,0,0);
3000b468:	e59f3040 	ldr	r3, [pc, #64]	; 3000b4b0 <acoral_print+0x88>
3000b46c:	e5933000 	ldr	r3, [r3]
3000b470:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
3000b474:	e59d300c 	ldr	r3, [sp, #12]
3000b478:	e3a01000 	mov	r1, #0
3000b47c:	e58d1000 	str	r1, [sp]
3000b480:	e1a00002 	mov	r0, r2
3000b484:	e59f1020 	ldr	r1, [pc, #32]	; 3000b4ac <acoral_print+0x84>
3000b488:	e1a02003 	mov	r2, r3
3000b48c:	e3a03000 	mov	r3, #0
3000b490:	eb006430 	bl	30024558 <acoral_dev_write>
3000b494:	e1a03000 	mov	r3, r0
}
3000b498:	e1a00003 	mov	r0, r3
3000b49c:	e28dd014 	add	sp, sp, #20
3000b4a0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000b4a4:	e28dd010 	add	sp, sp, #16
3000b4a8:	e12fff1e 	bx	lr
3000b4ac:	300270a4 	.word	0x300270a4
3000b4b0:	3002b350 	.word	0x3002b350

3000b4b4 <acoral_prints>:

acoral_32 acoral_prints(const acoral_char *str)
{
3000b4b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b4b8:	e24dd01c 	sub	sp, sp, #28
3000b4bc:	e58d000c 	str	r0, [sp, #12]
	acoral_32 printed_len;
	printed_len=acoral_str_len(str);  
3000b4c0:	e59d000c 	ldr	r0, [sp, #12]
3000b4c4:	eb000115 	bl	3000b920 <acoral_str_len>
3000b4c8:	e1a03000 	mov	r3, r0
3000b4cc:	e58d3014 	str	r3, [sp, #20]
	return acoral_dev_write(acoral_cur_thread->console_id,(void *)str,printed_len,0,0);
3000b4d0:	e59f3038 	ldr	r3, [pc, #56]	; 3000b510 <acoral_prints+0x5c>
3000b4d4:	e5933000 	ldr	r3, [r3]
3000b4d8:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
3000b4dc:	e59d3014 	ldr	r3, [sp, #20]
3000b4e0:	e3a01000 	mov	r1, #0
3000b4e4:	e58d1000 	str	r1, [sp]
3000b4e8:	e1a00002 	mov	r0, r2
3000b4ec:	e59d100c 	ldr	r1, [sp, #12]
3000b4f0:	e1a02003 	mov	r2, r3
3000b4f4:	e3a03000 	mov	r3, #0
3000b4f8:	eb006416 	bl	30024558 <acoral_dev_write>
3000b4fc:	e1a03000 	mov	r3, r0
}
3000b500:	e1a00003 	mov	r0, r3
3000b504:	e28dd01c 	add	sp, sp, #28
3000b508:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000b50c:	e12fff1e 	bx	lr
3000b510:	3002b350 	.word	0x3002b350

3000b514 <acoral_getchar>:

acoral_char acoral_getchar(){
3000b514:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b518:	e24dd014 	sub	sp, sp, #20
	acoral_char c;
	acoral_dev_read(acoral_cur_thread->console_id,&c,1,0,0);
3000b51c:	e59f3038 	ldr	r3, [pc, #56]	; 3000b55c <acoral_getchar+0x48>
3000b520:	e5933000 	ldr	r3, [r3]
3000b524:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
3000b528:	e28d300f 	add	r3, sp, #15
3000b52c:	e3a01000 	mov	r1, #0
3000b530:	e58d1000 	str	r1, [sp]
3000b534:	e1a00002 	mov	r0, r2
3000b538:	e1a01003 	mov	r1, r3
3000b53c:	e3a02001 	mov	r2, #1
3000b540:	e3a03000 	mov	r3, #0
3000b544:	eb006429 	bl	300245f0 <acoral_dev_read>
	return c;
3000b548:	e5dd300f 	ldrb	r3, [sp, #15]
}
3000b54c:	e1a00003 	mov	r0, r3
3000b550:	e28dd014 	add	sp, sp, #20
3000b554:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000b558:	e12fff1e 	bx	lr
3000b55c:	3002b350 	.word	0x3002b350

3000b560 <acoral_putchar>:

acoral_char acoral_putchar(acoral_char c){
3000b560:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b564:	e24dd014 	sub	sp, sp, #20
3000b568:	e1a03000 	mov	r3, r0
3000b56c:	e5cd300f 	strb	r3, [sp, #15]
	acoral_dev_write(acoral_cur_thread->console_id,&c,1,0,0);
3000b570:	e59f3038 	ldr	r3, [pc, #56]	; 3000b5b0 <acoral_putchar+0x50>
3000b574:	e5933000 	ldr	r3, [r3]
3000b578:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
3000b57c:	e28d300f 	add	r3, sp, #15
3000b580:	e3a01000 	mov	r1, #0
3000b584:	e58d1000 	str	r1, [sp]
3000b588:	e1a00002 	mov	r0, r2
3000b58c:	e1a01003 	mov	r1, r3
3000b590:	e3a02001 	mov	r2, #1
3000b594:	e3a03000 	mov	r3, #0
3000b598:	eb0063ee 	bl	30024558 <acoral_dev_write>
	return c;
3000b59c:	e5dd300f 	ldrb	r3, [sp, #15]
}
3000b5a0:	e1a00003 	mov	r0, r3
3000b5a4:	e28dd014 	add	sp, sp, #20
3000b5a8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000b5ac:	e12fff1e 	bx	lr
3000b5b0:	3002b350 	.word	0x3002b350

3000b5b4 <acoral_debug>:

static acoral_id console_id=ACORAL_DEV_ERR_ID;
//======================
acoral_32 acoral_debug(const acoral_char *fmt, ...)
{
3000b5b4:	e92d000f 	push	{r0, r1, r2, r3}
3000b5b8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b5bc:	e24dd014 	sub	sp, sp, #20
	va_list args;
	acoral_32 printed_len;
	static acoral_char print_buf[1024];
	va_start(args, fmt);
3000b5c0:	e28d3018 	add	r3, sp, #24
3000b5c4:	e2833004 	add	r3, r3, #4
3000b5c8:	e58d3008 	str	r3, [sp, #8]
	printed_len =vsnprintf(print_buf, sizeof(print_buf), fmt, args);
3000b5cc:	e59d3018 	ldr	r3, [sp, #24]
3000b5d0:	e59f0094 	ldr	r0, [pc, #148]	; 3000b66c <acoral_debug+0xb8>
3000b5d4:	e3a01b01 	mov	r1, #1024	; 0x400
3000b5d8:	e1a02003 	mov	r2, r3
3000b5dc:	e59d3008 	ldr	r3, [sp, #8]
3000b5e0:	ebfffcaa 	bl	3000a890 <vsnprintf>
3000b5e4:	e1a03000 	mov	r3, r0
3000b5e8:	e58d300c 	str	r3, [sp, #12]
	va_end(args);
3000b5ec:	e3a03000 	mov	r3, #0
3000b5f0:	e58d3008 	str	r3, [sp, #8]
	if(console_id==ACORAL_DEV_ERR_ID){
3000b5f4:	e59f3074 	ldr	r3, [pc, #116]	; 3000b670 <acoral_debug+0xbc>
3000b5f8:	e5933000 	ldr	r3, [r3]
3000b5fc:	e3730001 	cmn	r3, #1
3000b600:	1a000009 	bne	3000b62c <acoral_debug+0x78>
		console_id=acoral_dev_open("console");
3000b604:	e59f0068 	ldr	r0, [pc, #104]	; 3000b674 <acoral_debug+0xc0>
3000b608:	eb0063ad 	bl	300244c4 <acoral_dev_open>
3000b60c:	e1a02000 	mov	r2, r0
3000b610:	e59f3058 	ldr	r3, [pc, #88]	; 3000b670 <acoral_debug+0xbc>
3000b614:	e5832000 	str	r2, [r3]
		if(console_id==ACORAL_DEV_ERR_ID)
3000b618:	e59f3050 	ldr	r3, [pc, #80]	; 3000b670 <acoral_debug+0xbc>
3000b61c:	e5933000 	ldr	r3, [r3]
3000b620:	e3730001 	cmn	r3, #1
3000b624:	1a000000 	bne	3000b62c <acoral_debug+0x78>
3000b628:	ea00000a 	b	3000b658 <acoral_debug+0xa4>
			return;
	}
	return acoral_dev_write(console_id,(void *)print_buf,printed_len,0,0);
3000b62c:	e59f303c 	ldr	r3, [pc, #60]	; 3000b670 <acoral_debug+0xbc>
3000b630:	e5932000 	ldr	r2, [r3]
3000b634:	e59d300c 	ldr	r3, [sp, #12]
3000b638:	e3a01000 	mov	r1, #0
3000b63c:	e58d1000 	str	r1, [sp]
3000b640:	e1a00002 	mov	r0, r2
3000b644:	e59f1020 	ldr	r1, [pc, #32]	; 3000b66c <acoral_debug+0xb8>
3000b648:	e1a02003 	mov	r2, r3
3000b64c:	e3a03000 	mov	r3, #0
3000b650:	eb0063c0 	bl	30024558 <acoral_dev_write>
3000b654:	e1a03000 	mov	r3, r0
}
3000b658:	e1a00003 	mov	r0, r3
3000b65c:	e28dd014 	add	sp, sp, #20
3000b660:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000b664:	e28dd010 	add	sp, sp, #16
3000b668:	e12fff1e 	bx	lr
3000b66c:	30026ca4 	.word	0x30026ca4
3000b670:	300268c8 	.word	0x300268c8
3000b674:	30026468 	.word	0x30026468

3000b678 <acoral_debugs>:

acoral_32 acoral_debugs(const acoral_char *str)
{
3000b678:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b67c:	e24dd01c 	sub	sp, sp, #28
3000b680:	e58d000c 	str	r0, [sp, #12]
	acoral_32 printed_len;
	printed_len=acoral_str_len(str);  
3000b684:	e59d000c 	ldr	r0, [sp, #12]
3000b688:	eb0000a4 	bl	3000b920 <acoral_str_len>
3000b68c:	e1a03000 	mov	r3, r0
3000b690:	e58d3014 	str	r3, [sp, #20]
	if(console_id==ACORAL_DEV_ERR_ID){
3000b694:	e59f306c 	ldr	r3, [pc, #108]	; 3000b708 <acoral_debugs+0x90>
3000b698:	e5933000 	ldr	r3, [r3]
3000b69c:	e3730001 	cmn	r3, #1
3000b6a0:	1a000009 	bne	3000b6cc <acoral_debugs+0x54>
		console_id=acoral_dev_open("console");
3000b6a4:	e59f0060 	ldr	r0, [pc, #96]	; 3000b70c <acoral_debugs+0x94>
3000b6a8:	eb006385 	bl	300244c4 <acoral_dev_open>
3000b6ac:	e1a02000 	mov	r2, r0
3000b6b0:	e59f3050 	ldr	r3, [pc, #80]	; 3000b708 <acoral_debugs+0x90>
3000b6b4:	e5832000 	str	r2, [r3]
		if(console_id==ACORAL_DEV_ERR_ID)
3000b6b8:	e59f3048 	ldr	r3, [pc, #72]	; 3000b708 <acoral_debugs+0x90>
3000b6bc:	e5933000 	ldr	r3, [r3]
3000b6c0:	e3730001 	cmn	r3, #1
3000b6c4:	1a000000 	bne	3000b6cc <acoral_debugs+0x54>
3000b6c8:	ea00000a 	b	3000b6f8 <acoral_debugs+0x80>
			return;
	}
	return acoral_dev_write(console_id,(void *)str,printed_len,0,0);
3000b6cc:	e59f3034 	ldr	r3, [pc, #52]	; 3000b708 <acoral_debugs+0x90>
3000b6d0:	e5932000 	ldr	r2, [r3]
3000b6d4:	e59d3014 	ldr	r3, [sp, #20]
3000b6d8:	e3a01000 	mov	r1, #0
3000b6dc:	e58d1000 	str	r1, [sp]
3000b6e0:	e1a00002 	mov	r0, r2
3000b6e4:	e59d100c 	ldr	r1, [sp, #12]
3000b6e8:	e1a02003 	mov	r2, r3
3000b6ec:	e3a03000 	mov	r3, #0
3000b6f0:	eb006398 	bl	30024558 <acoral_dev_write>
3000b6f4:	e1a03000 	mov	r3, r0
}
3000b6f8:	e1a00003 	mov	r0, r3
3000b6fc:	e28dd01c 	add	sp, sp, #28
3000b700:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000b704:	e12fff1e 	bx	lr
3000b708:	300268c8 	.word	0x300268c8
3000b70c:	30026468 	.word	0x30026468

3000b710 <acoral_tolower>:
#include<string.h>

acoral_u8  acoral_tolower(acoral_u8 c){
3000b710:	e24dd008 	sub	sp, sp, #8
3000b714:	e1a03000 	mov	r3, r0
3000b718:	e5cd3007 	strb	r3, [sp, #7]
      if(IS_LOWER(c))
3000b71c:	e5dd3007 	ldrb	r3, [sp, #7]
3000b720:	e3530060 	cmp	r3, #96	; 0x60
3000b724:	9a000004 	bls	3000b73c <acoral_tolower+0x2c>
3000b728:	e5dd3007 	ldrb	r3, [sp, #7]
3000b72c:	e353007a 	cmp	r3, #122	; 0x7a
3000b730:	8a000001 	bhi	3000b73c <acoral_tolower+0x2c>
        return c;
3000b734:	e5dd3007 	ldrb	r3, [sp, #7]
3000b738:	ea00000a 	b	3000b768 <acoral_tolower+0x58>
      else if(IS_UPPER(c))
3000b73c:	e5dd3007 	ldrb	r3, [sp, #7]
3000b740:	e3530040 	cmp	r3, #64	; 0x40
3000b744:	9a000006 	bls	3000b764 <acoral_tolower+0x54>
3000b748:	e5dd3007 	ldrb	r3, [sp, #7]
3000b74c:	e353005a 	cmp	r3, #90	; 0x5a
3000b750:	8a000003 	bhi	3000b764 <acoral_tolower+0x54>
        return (acoral_u8)(c+32);
3000b754:	e5dd3007 	ldrb	r3, [sp, #7]
3000b758:	e2833020 	add	r3, r3, #32
3000b75c:	e20330ff 	and	r3, r3, #255	; 0xff
3000b760:	ea000000 	b	3000b768 <acoral_tolower+0x58>
      else
        return FALSE; 
3000b764:	e3a03000 	mov	r3, #0
            
}
3000b768:	e1a00003 	mov	r0, r3
3000b76c:	e28dd008 	add	sp, sp, #8
3000b770:	e12fff1e 	bx	lr

3000b774 <acoral_toupper>:
acoral_u8  acoral_toupper(acoral_u8 c){
3000b774:	e24dd008 	sub	sp, sp, #8
3000b778:	e1a03000 	mov	r3, r0
3000b77c:	e5cd3007 	strb	r3, [sp, #7]
     if(IS_LOWER(c))
3000b780:	e5dd3007 	ldrb	r3, [sp, #7]
3000b784:	e3530060 	cmp	r3, #96	; 0x60
3000b788:	9a000006 	bls	3000b7a8 <acoral_toupper+0x34>
3000b78c:	e5dd3007 	ldrb	r3, [sp, #7]
3000b790:	e353007a 	cmp	r3, #122	; 0x7a
3000b794:	8a000003 	bhi	3000b7a8 <acoral_toupper+0x34>
        return (acoral_u8)(c-32);
3000b798:	e5dd3007 	ldrb	r3, [sp, #7]
3000b79c:	e2433020 	sub	r3, r3, #32
3000b7a0:	e20330ff 	and	r3, r3, #255	; 0xff
3000b7a4:	ea000008 	b	3000b7cc <acoral_toupper+0x58>
     else if(IS_UPPER(c))
3000b7a8:	e5dd3007 	ldrb	r3, [sp, #7]
3000b7ac:	e3530040 	cmp	r3, #64	; 0x40
3000b7b0:	9a000004 	bls	3000b7c8 <acoral_toupper+0x54>
3000b7b4:	e5dd3007 	ldrb	r3, [sp, #7]
3000b7b8:	e353005a 	cmp	r3, #90	; 0x5a
3000b7bc:	8a000001 	bhi	3000b7c8 <acoral_toupper+0x54>
        return c;
3000b7c0:	e5dd3007 	ldrb	r3, [sp, #7]
3000b7c4:	ea000000 	b	3000b7cc <acoral_toupper+0x58>
     else
        return FALSE; 
3000b7c8:	e3a03000 	mov	r3, #0
}
3000b7cc:	e1a00003 	mov	r0, r3
3000b7d0:	e28dd008 	add	sp, sp, #8
3000b7d4:	e12fff1e 	bx	lr

3000b7d8 <acoral_str_upr>:

acoral_char *acoral_str_upr(acoral_char *str){
3000b7d8:	e24dd010 	sub	sp, sp, #16
3000b7dc:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 i=0;
3000b7e0:	e3a03000 	mov	r3, #0
3000b7e4:	e58d3008 	str	r3, [sp, #8]
	acoral_char *s=str;
3000b7e8:	e59d3004 	ldr	r3, [sp, #4]
3000b7ec:	e58d300c 	str	r3, [sp, #12]
	while(s[i]!='\0'){
3000b7f0:	ea000018 	b	3000b858 <acoral_str_upr+0x80>
		if(s[i]>='a'&&s[i]<='z')
3000b7f4:	e59d200c 	ldr	r2, [sp, #12]
3000b7f8:	e59d3008 	ldr	r3, [sp, #8]
3000b7fc:	e0823003 	add	r3, r2, r3
3000b800:	e5d33000 	ldrb	r3, [r3]
3000b804:	e3530060 	cmp	r3, #96	; 0x60
3000b808:	9a00000f 	bls	3000b84c <acoral_str_upr+0x74>
3000b80c:	e59d200c 	ldr	r2, [sp, #12]
3000b810:	e59d3008 	ldr	r3, [sp, #8]
3000b814:	e0823003 	add	r3, r2, r3
3000b818:	e5d33000 	ldrb	r3, [r3]
3000b81c:	e353007a 	cmp	r3, #122	; 0x7a
3000b820:	8a000009 	bhi	3000b84c <acoral_str_upr+0x74>
			s[i]-=32;
3000b824:	e59d200c 	ldr	r2, [sp, #12]
3000b828:	e59d3008 	ldr	r3, [sp, #8]
3000b82c:	e0823003 	add	r3, r2, r3
3000b830:	e59d100c 	ldr	r1, [sp, #12]
3000b834:	e59d2008 	ldr	r2, [sp, #8]
3000b838:	e0812002 	add	r2, r1, r2
3000b83c:	e5d22000 	ldrb	r2, [r2]
3000b840:	e2422020 	sub	r2, r2, #32
3000b844:	e20220ff 	and	r2, r2, #255	; 0xff
3000b848:	e5c32000 	strb	r2, [r3]
		i++;
3000b84c:	e59d3008 	ldr	r3, [sp, #8]
3000b850:	e2833001 	add	r3, r3, #1
3000b854:	e58d3008 	str	r3, [sp, #8]
}

acoral_char *acoral_str_upr(acoral_char *str){
	acoral_u32 i=0;
	acoral_char *s=str;
	while(s[i]!='\0'){
3000b858:	e59d200c 	ldr	r2, [sp, #12]
3000b85c:	e59d3008 	ldr	r3, [sp, #8]
3000b860:	e0823003 	add	r3, r2, r3
3000b864:	e5d33000 	ldrb	r3, [r3]
3000b868:	e3530000 	cmp	r3, #0
3000b86c:	1affffe0 	bne	3000b7f4 <acoral_str_upr+0x1c>
		if(s[i]>='a'&&s[i]<='z')
			s[i]-=32;
		i++;
	} 
	return str;
3000b870:	e59d3004 	ldr	r3, [sp, #4]
}
3000b874:	e1a00003 	mov	r0, r3
3000b878:	e28dd010 	add	sp, sp, #16
3000b87c:	e12fff1e 	bx	lr

3000b880 <acoral_str_lwr>:

acoral_char *acoral_str_lwr(acoral_char *s){
3000b880:	e24dd010 	sub	sp, sp, #16
3000b884:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 i=0;
3000b888:	e3a03000 	mov	r3, #0
3000b88c:	e58d300c 	str	r3, [sp, #12]
	while(s[i]!='\0'){
3000b890:	ea000018 	b	3000b8f8 <acoral_str_lwr+0x78>
		if(s[i]>='A'&&s[i]<='Z')
3000b894:	e59d2004 	ldr	r2, [sp, #4]
3000b898:	e59d300c 	ldr	r3, [sp, #12]
3000b89c:	e0823003 	add	r3, r2, r3
3000b8a0:	e5d33000 	ldrb	r3, [r3]
3000b8a4:	e3530040 	cmp	r3, #64	; 0x40
3000b8a8:	9a00000f 	bls	3000b8ec <acoral_str_lwr+0x6c>
3000b8ac:	e59d2004 	ldr	r2, [sp, #4]
3000b8b0:	e59d300c 	ldr	r3, [sp, #12]
3000b8b4:	e0823003 	add	r3, r2, r3
3000b8b8:	e5d33000 	ldrb	r3, [r3]
3000b8bc:	e353005a 	cmp	r3, #90	; 0x5a
3000b8c0:	8a000009 	bhi	3000b8ec <acoral_str_lwr+0x6c>
			s[i]+=32;
3000b8c4:	e59d2004 	ldr	r2, [sp, #4]
3000b8c8:	e59d300c 	ldr	r3, [sp, #12]
3000b8cc:	e0823003 	add	r3, r2, r3
3000b8d0:	e59d1004 	ldr	r1, [sp, #4]
3000b8d4:	e59d200c 	ldr	r2, [sp, #12]
3000b8d8:	e0812002 	add	r2, r1, r2
3000b8dc:	e5d22000 	ldrb	r2, [r2]
3000b8e0:	e2822020 	add	r2, r2, #32
3000b8e4:	e20220ff 	and	r2, r2, #255	; 0xff
3000b8e8:	e5c32000 	strb	r2, [r3]
		i++;
3000b8ec:	e59d300c 	ldr	r3, [sp, #12]
3000b8f0:	e2833001 	add	r3, r3, #1
3000b8f4:	e58d300c 	str	r3, [sp, #12]
	return str;
}

acoral_char *acoral_str_lwr(acoral_char *s){
	acoral_u32 i=0;
	while(s[i]!='\0'){
3000b8f8:	e59d2004 	ldr	r2, [sp, #4]
3000b8fc:	e59d300c 	ldr	r3, [sp, #12]
3000b900:	e0823003 	add	r3, r2, r3
3000b904:	e5d33000 	ldrb	r3, [r3]
3000b908:	e3530000 	cmp	r3, #0
3000b90c:	1affffe0 	bne	3000b894 <acoral_str_lwr+0x14>
		if(s[i]>='A'&&s[i]<='Z')
			s[i]+=32;
		i++;
	} 
	return s;
3000b910:	e59d3004 	ldr	r3, [sp, #4]
}
3000b914:	e1a00003 	mov	r0, r3
3000b918:	e28dd010 	add	sp, sp, #16
3000b91c:	e12fff1e 	bx	lr

3000b920 <acoral_str_len>:

acoral_u32 acoral_str_len(const acoral_char *str)  
{  
3000b920:	e24dd010 	sub	sp, sp, #16
3000b924:	e58d0004 	str	r0, [sp, #4]
  acoral_u32  i=0;  
3000b928:	e3a03000 	mov	r3, #0
3000b92c:	e58d3008 	str	r3, [sp, #8]
  const acoral_char *p=str;
3000b930:	e59d3004 	ldr	r3, [sp, #4]
3000b934:	e58d300c 	str	r3, [sp, #12]
  while(*p++)  
3000b938:	ea000002 	b	3000b948 <acoral_str_len+0x28>
      i++;  
3000b93c:	e59d3008 	ldr	r3, [sp, #8]
3000b940:	e2833001 	add	r3, r3, #1
3000b944:	e58d3008 	str	r3, [sp, #8]

acoral_u32 acoral_str_len(const acoral_char *str)  
{  
  acoral_u32  i=0;  
  const acoral_char *p=str;
  while(*p++)  
3000b948:	e59d300c 	ldr	r3, [sp, #12]
3000b94c:	e5d33000 	ldrb	r3, [r3]
3000b950:	e3530000 	cmp	r3, #0
3000b954:	03a03000 	moveq	r3, #0
3000b958:	13a03001 	movne	r3, #1
3000b95c:	e20330ff 	and	r3, r3, #255	; 0xff
3000b960:	e59d200c 	ldr	r2, [sp, #12]
3000b964:	e2822001 	add	r2, r2, #1
3000b968:	e58d200c 	str	r2, [sp, #12]
3000b96c:	e3530000 	cmp	r3, #0
3000b970:	1afffff1 	bne	3000b93c <acoral_str_len+0x1c>
      i++;  
  return  i;  
3000b974:	e59d3008 	ldr	r3, [sp, #8]
}
3000b978:	e1a00003 	mov	r0, r3
3000b97c:	e28dd010 	add	sp, sp, #16
3000b980:	e12fff1e 	bx	lr

3000b984 <acoral_str_cpy>:

acoral_char *acoral_str_cpy(acoral_char *to, const acoral_char *from)
{
3000b984:	e24dd010 	sub	sp, sp, #16
3000b988:	e58d0004 	str	r0, [sp, #4]
3000b98c:	e58d1000 	str	r1, [sp]
    acoral_char *rev = to;
3000b990:	e59d3004 	ldr	r3, [sp, #4]
3000b994:	e58d300c 	str	r3, [sp, #12]
    while(*to++ = *from++);
3000b998:	e59d3000 	ldr	r3, [sp]
3000b99c:	e5d32000 	ldrb	r2, [r3]
3000b9a0:	e59d3004 	ldr	r3, [sp, #4]
3000b9a4:	e5c32000 	strb	r2, [r3]
3000b9a8:	e59d3004 	ldr	r3, [sp, #4]
3000b9ac:	e5d33000 	ldrb	r3, [r3]
3000b9b0:	e3530000 	cmp	r3, #0
3000b9b4:	03a03000 	moveq	r3, #0
3000b9b8:	13a03001 	movne	r3, #1
3000b9bc:	e20330ff 	and	r3, r3, #255	; 0xff
3000b9c0:	e59d2004 	ldr	r2, [sp, #4]
3000b9c4:	e2822001 	add	r2, r2, #1
3000b9c8:	e58d2004 	str	r2, [sp, #4]
3000b9cc:	e59d2000 	ldr	r2, [sp]
3000b9d0:	e2822001 	add	r2, r2, #1
3000b9d4:	e58d2000 	str	r2, [sp]
3000b9d8:	e3530000 	cmp	r3, #0
3000b9dc:	1affffed 	bne	3000b998 <acoral_str_cpy+0x14>
    return rev;
3000b9e0:	e59d300c 	ldr	r3, [sp, #12]
}
3000b9e4:	e1a00003 	mov	r0, r3
3000b9e8:	e28dd010 	add	sp, sp, #16
3000b9ec:	e12fff1e 	bx	lr

3000b9f0 <acoral_str_cmp>:

acoral_u32 acoral_str_cmp(const acoral_char * des,const  acoral_char * src)
{
3000b9f0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b9f4:	e24dd01c 	sub	sp, sp, #28
3000b9f8:	e58d0004 	str	r0, [sp, #4]
3000b9fc:	e58d1000 	str	r1, [sp]
    acoral_u32 c;
    acoral_u32 len1;
    acoral_u32 len2;
    if(des == NULL || src == NULL)
3000ba00:	e59d3004 	ldr	r3, [sp, #4]
3000ba04:	e3530000 	cmp	r3, #0
3000ba08:	0a000002 	beq	3000ba18 <acoral_str_cmp+0x28>
3000ba0c:	e59d3000 	ldr	r3, [sp]
3000ba10:	e3530000 	cmp	r3, #0
3000ba14:	1a000001 	bne	3000ba20 <acoral_str_cmp+0x30>
      	return -1;	
3000ba18:	e3e03000 	mvn	r3, #0
3000ba1c:	ea00002b 	b	3000bad0 <acoral_str_cmp+0xe0>
    len1 = acoral_str_len(des);
3000ba20:	e59d0004 	ldr	r0, [sp, #4]
3000ba24:	ebffffbd 	bl	3000b920 <acoral_str_len>
3000ba28:	e1a03000 	mov	r3, r0
3000ba2c:	e58d3010 	str	r3, [sp, #16]
    len2 = acoral_str_len(src);
3000ba30:	e59d0000 	ldr	r0, [sp]
3000ba34:	ebffffb9 	bl	3000b920 <acoral_str_len>
3000ba38:	e1a03000 	mov	r3, r0
3000ba3c:	e58d3014 	str	r3, [sp, #20]
    if(len1 != len2)
3000ba40:	e59d2010 	ldr	r2, [sp, #16]
3000ba44:	e59d3014 	ldr	r3, [sp, #20]
3000ba48:	e1520003 	cmp	r2, r3
3000ba4c:	0a000019 	beq	3000bab8 <acoral_str_cmp+0xc8>
    {
        return len1-len2;
3000ba50:	e59d2010 	ldr	r2, [sp, #16]
3000ba54:	e59d3014 	ldr	r3, [sp, #20]
3000ba58:	e0633002 	rsb	r3, r3, r2
3000ba5c:	ea00001b 	b	3000bad0 <acoral_str_cmp+0xe0>
    }
    while(*des != '\0')
    {
        if((c=(*des++ - * src++)) != 0)
3000ba60:	e59d3004 	ldr	r3, [sp, #4]
3000ba64:	e5d33000 	ldrb	r3, [r3]
3000ba68:	e1a02003 	mov	r2, r3
3000ba6c:	e59d3000 	ldr	r3, [sp]
3000ba70:	e5d33000 	ldrb	r3, [r3]
3000ba74:	e0633002 	rsb	r3, r3, r2
3000ba78:	e58d300c 	str	r3, [sp, #12]
3000ba7c:	e59d300c 	ldr	r3, [sp, #12]
3000ba80:	e3530000 	cmp	r3, #0
3000ba84:	03a03000 	moveq	r3, #0
3000ba88:	13a03001 	movne	r3, #1
3000ba8c:	e20330ff 	and	r3, r3, #255	; 0xff
3000ba90:	e59d2004 	ldr	r2, [sp, #4]
3000ba94:	e2822001 	add	r2, r2, #1
3000ba98:	e58d2004 	str	r2, [sp, #4]
3000ba9c:	e59d2000 	ldr	r2, [sp]
3000baa0:	e2822001 	add	r2, r2, #1
3000baa4:	e58d2000 	str	r2, [sp]
3000baa8:	e3530000 	cmp	r3, #0
3000baac:	0a000002 	beq	3000babc <acoral_str_cmp+0xcc>
        {
            return c;
3000bab0:	e59d300c 	ldr	r3, [sp, #12]
3000bab4:	ea000005 	b	3000bad0 <acoral_str_cmp+0xe0>
    len2 = acoral_str_len(src);
    if(len1 != len2)
    {
        return len1-len2;
    }
    while(*des != '\0')
3000bab8:	e1a00000 	nop			; (mov r0, r0)
3000babc:	e59d3004 	ldr	r3, [sp, #4]
3000bac0:	e5d33000 	ldrb	r3, [r3]
3000bac4:	e3530000 	cmp	r3, #0
3000bac8:	1affffe4 	bne	3000ba60 <acoral_str_cmp+0x70>
        if((c=(*des++ - * src++)) != 0)
        {
            return c;
        }
    }
    return c;
3000bacc:	e59d300c 	ldr	r3, [sp, #12]
}
3000bad0:	e1a00003 	mov	r0, r3
3000bad4:	e28dd01c 	add	sp, sp, #28
3000bad8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000badc:	e12fff1e 	bx	lr

3000bae0 <acoral_str_nicmp>:
 * @s1: One string
 * @s2: The other string
 * @len: the maximum number of characters to compare
 */
acoral_32 acoral_str_nicmp(const acoral_char *s1, const acoral_char *s2, acoral_u32 len)
{
3000bae0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000bae4:	e24dd01c 	sub	sp, sp, #28
3000bae8:	e58d000c 	str	r0, [sp, #12]
3000baec:	e58d1008 	str	r1, [sp, #8]
3000baf0:	e58d2004 	str	r2, [sp, #4]
	/* Yes, Virginia, it had better be unsigned */
	acoral_u8 c1, c2;

	c1 = 0;	c2 = 0;
3000baf4:	e3a03000 	mov	r3, #0
3000baf8:	e5cd3016 	strb	r3, [sp, #22]
3000bafc:	e3a03000 	mov	r3, #0
3000bb00:	e5cd3017 	strb	r3, [sp, #23]
	if (len) {
3000bb04:	e59d3004 	ldr	r3, [sp, #4]
3000bb08:	e3530000 	cmp	r3, #0
3000bb0c:	0a000031 	beq	3000bbd8 <acoral_str_nicmp+0xf8>
		do {
			c1 = *s1; c2 = *s2;
3000bb10:	e59d300c 	ldr	r3, [sp, #12]
3000bb14:	e5d33000 	ldrb	r3, [r3]
3000bb18:	e5cd3016 	strb	r3, [sp, #22]
3000bb1c:	e59d3008 	ldr	r3, [sp, #8]
3000bb20:	e5d33000 	ldrb	r3, [r3]
3000bb24:	e5cd3017 	strb	r3, [sp, #23]
			s1++; s2++;
3000bb28:	e59d300c 	ldr	r3, [sp, #12]
3000bb2c:	e2833001 	add	r3, r3, #1
3000bb30:	e58d300c 	str	r3, [sp, #12]
3000bb34:	e59d3008 	ldr	r3, [sp, #8]
3000bb38:	e2833001 	add	r3, r3, #1
3000bb3c:	e58d3008 	str	r3, [sp, #8]
			if (!c1)
3000bb40:	e5dd3016 	ldrb	r3, [sp, #22]
3000bb44:	e3530000 	cmp	r3, #0
3000bb48:	0a00001d 	beq	3000bbc4 <acoral_str_nicmp+0xe4>
				break;
			if (!c2)
3000bb4c:	e5dd3017 	ldrb	r3, [sp, #23]
3000bb50:	e3530000 	cmp	r3, #0
3000bb54:	0a00001c 	beq	3000bbcc <acoral_str_nicmp+0xec>
				break;
			if (c1 == c2)
3000bb58:	e5dd2016 	ldrb	r2, [sp, #22]
3000bb5c:	e5dd3017 	ldrb	r3, [sp, #23]
3000bb60:	e1520003 	cmp	r2, r3
3000bb64:	0a00000e 	beq	3000bba4 <acoral_str_nicmp+0xc4>
				continue;
			c1 = acoral_tolower(c1);
3000bb68:	e5dd3016 	ldrb	r3, [sp, #22]
3000bb6c:	e1a00003 	mov	r0, r3
3000bb70:	ebfffee6 	bl	3000b710 <acoral_tolower>
3000bb74:	e1a03000 	mov	r3, r0
3000bb78:	e5cd3016 	strb	r3, [sp, #22]
			c2 = acoral_tolower(c2);
3000bb7c:	e5dd3017 	ldrb	r3, [sp, #23]
3000bb80:	e1a00003 	mov	r0, r3
3000bb84:	ebfffee1 	bl	3000b710 <acoral_tolower>
3000bb88:	e1a03000 	mov	r3, r0
3000bb8c:	e5cd3017 	strb	r3, [sp, #23]
			if (c1 != c2)
3000bb90:	e5dd2016 	ldrb	r2, [sp, #22]
3000bb94:	e5dd3017 	ldrb	r3, [sp, #23]
3000bb98:	e1520003 	cmp	r2, r3
3000bb9c:	1a00000c 	bne	3000bbd4 <acoral_str_nicmp+0xf4>
3000bba0:	ea000000 	b	3000bba8 <acoral_str_nicmp+0xc8>
			if (!c1)
				break;
			if (!c2)
				break;
			if (c1 == c2)
				continue;
3000bba4:	e1a00000 	nop			; (mov r0, r0)
			c1 = acoral_tolower(c1);
			c2 = acoral_tolower(c2);
			if (c1 != c2)
				break;
		} while (--len);
3000bba8:	e59d3004 	ldr	r3, [sp, #4]
3000bbac:	e2433001 	sub	r3, r3, #1
3000bbb0:	e58d3004 	str	r3, [sp, #4]
3000bbb4:	e59d3004 	ldr	r3, [sp, #4]
3000bbb8:	e3530000 	cmp	r3, #0
3000bbbc:	1affffd3 	bne	3000bb10 <acoral_str_nicmp+0x30>
3000bbc0:	ea000004 	b	3000bbd8 <acoral_str_nicmp+0xf8>
	if (len) {
		do {
			c1 = *s1; c2 = *s2;
			s1++; s2++;
			if (!c1)
				break;
3000bbc4:	e1a00000 	nop			; (mov r0, r0)
3000bbc8:	ea000002 	b	3000bbd8 <acoral_str_nicmp+0xf8>
			if (!c2)
				break;
3000bbcc:	e1a00000 	nop			; (mov r0, r0)
3000bbd0:	ea000000 	b	3000bbd8 <acoral_str_nicmp+0xf8>
			if (c1 == c2)
				continue;
			c1 = acoral_tolower(c1);
			c2 = acoral_tolower(c2);
			if (c1 != c2)
				break;
3000bbd4:	e1a00000 	nop			; (mov r0, r0)
		} while (--len);
	}
	return (acoral_32)c1 - (acoral_32)c2;
3000bbd8:	e5dd2016 	ldrb	r2, [sp, #22]
3000bbdc:	e5dd3017 	ldrb	r3, [sp, #23]
3000bbe0:	e0633002 	rsb	r3, r3, r2
}
3000bbe4:	e1a00003 	mov	r0, r3
3000bbe8:	e28dd01c 	add	sp, sp, #28
3000bbec:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000bbf0:	e12fff1e 	bx	lr

3000bbf4 <acoral_str_ncpy>:
 *
 * The result is not %NUL-terminated if the source exceeds
 * @count bytes.
 */
acoral_char * acoral_str_ncpy(acoral_char * dest,const acoral_char *src,acoral_u32 count)
{
3000bbf4:	e24dd018 	sub	sp, sp, #24
3000bbf8:	e58d000c 	str	r0, [sp, #12]
3000bbfc:	e58d1008 	str	r1, [sp, #8]
3000bc00:	e58d2004 	str	r2, [sp, #4]
	acoral_char *tmp = dest;
3000bc04:	e59d300c 	ldr	r3, [sp, #12]
3000bc08:	e58d3014 	str	r3, [sp, #20]

	while (count) {
3000bc0c:	ea000012 	b	3000bc5c <acoral_str_ncpy+0x68>
		if ((*tmp = *src) == '\0')
3000bc10:	e59d3008 	ldr	r3, [sp, #8]
3000bc14:	e5d32000 	ldrb	r2, [r3]
3000bc18:	e59d3014 	ldr	r3, [sp, #20]
3000bc1c:	e5c32000 	strb	r2, [r3]
3000bc20:	e59d3014 	ldr	r3, [sp, #20]
3000bc24:	e5d33000 	ldrb	r3, [r3]
3000bc28:	e3530000 	cmp	r3, #0
3000bc2c:	1a000001 	bne	3000bc38 <acoral_str_ncpy+0x44>
			return dest;
3000bc30:	e59d300c 	ldr	r3, [sp, #12]
3000bc34:	ea00000f 	b	3000bc78 <acoral_str_ncpy+0x84>
		src++;
3000bc38:	e59d3008 	ldr	r3, [sp, #8]
3000bc3c:	e2833001 	add	r3, r3, #1
3000bc40:	e58d3008 	str	r3, [sp, #8]
		tmp++;
3000bc44:	e59d3014 	ldr	r3, [sp, #20]
3000bc48:	e2833001 	add	r3, r3, #1
3000bc4c:	e58d3014 	str	r3, [sp, #20]
		count--;
3000bc50:	e59d3004 	ldr	r3, [sp, #4]
3000bc54:	e2433001 	sub	r3, r3, #1
3000bc58:	e58d3004 	str	r3, [sp, #4]
 */
acoral_char * acoral_str_ncpy(acoral_char * dest,const acoral_char *src,acoral_u32 count)
{
	acoral_char *tmp = dest;

	while (count) {
3000bc5c:	e59d3004 	ldr	r3, [sp, #4]
3000bc60:	e3530000 	cmp	r3, #0
3000bc64:	1affffe9 	bne	3000bc10 <acoral_str_ncpy+0x1c>
			return dest;
		src++;
		tmp++;
		count--;
	}
	*tmp = '\0';
3000bc68:	e59d3014 	ldr	r3, [sp, #20]
3000bc6c:	e3a02000 	mov	r2, #0
3000bc70:	e5c32000 	strb	r2, [r3]
	return dest;
3000bc74:	e59d300c 	ldr	r3, [sp, #12]
}
3000bc78:	e1a00003 	mov	r0, r3
3000bc7c:	e28dd018 	add	sp, sp, #24
3000bc80:	e12fff1e 	bx	lr

3000bc84 <acoral_str_lcpy>:
 * NUL-terminated string that fits in the buffer (unless,
 * of course, the buffer size is zero). It does not pad
 * out the result like acoral_str_ncpy() does.
 */
acoral_u32 acoral_str_lcpy(acoral_char *dest, const acoral_char *src, acoral_u32 size)
{
3000bc84:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000bc88:	e24dd01c 	sub	sp, sp, #28
3000bc8c:	e58d000c 	str	r0, [sp, #12]
3000bc90:	e58d1008 	str	r1, [sp, #8]
3000bc94:	e58d2004 	str	r2, [sp, #4]
	acoral_u32 ret = acoral_str_len(src);
3000bc98:	e59d0008 	ldr	r0, [sp, #8]
3000bc9c:	ebffff1f 	bl	3000b920 <acoral_str_len>
3000bca0:	e1a03000 	mov	r3, r0
3000bca4:	e58d3010 	str	r3, [sp, #16]

	if (size) {
3000bca8:	e59d3004 	ldr	r3, [sp, #4]
3000bcac:	e3530000 	cmp	r3, #0
3000bcb0:	0a000011 	beq	3000bcfc <acoral_str_lcpy+0x78>
		acoral_u32 len = (ret >= size) ? size-1 : ret;
3000bcb4:	e59d2010 	ldr	r2, [sp, #16]
3000bcb8:	e59d3004 	ldr	r3, [sp, #4]
3000bcbc:	e1520003 	cmp	r2, r3
3000bcc0:	3a000002 	bcc	3000bcd0 <acoral_str_lcpy+0x4c>
3000bcc4:	e59d3004 	ldr	r3, [sp, #4]
3000bcc8:	e2433001 	sub	r3, r3, #1
3000bccc:	ea000000 	b	3000bcd4 <acoral_str_lcpy+0x50>
3000bcd0:	e59d3010 	ldr	r3, [sp, #16]
3000bcd4:	e58d3014 	str	r3, [sp, #20]
		acoral_memcpy(dest, src, len);
3000bcd8:	e59d000c 	ldr	r0, [sp, #12]
3000bcdc:	e59d1008 	ldr	r1, [sp, #8]
3000bce0:	e59d2014 	ldr	r2, [sp, #20]
3000bce4:	eb0001f6 	bl	3000c4c4 <acoral_memcpy>
		dest[len] = '\0';
3000bce8:	e59d200c 	ldr	r2, [sp, #12]
3000bcec:	e59d3014 	ldr	r3, [sp, #20]
3000bcf0:	e0823003 	add	r3, r2, r3
3000bcf4:	e3a02000 	mov	r2, #0
3000bcf8:	e5c32000 	strb	r2, [r3]
	}
	return ret;
3000bcfc:	e59d3010 	ldr	r3, [sp, #16]
}
3000bd00:	e1a00003 	mov	r0, r3
3000bd04:	e28dd01c 	add	sp, sp, #28
3000bd08:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000bd0c:	e12fff1e 	bx	lr

3000bd10 <acoral_str_cat>:
 * acoral_str_cat - Append one %NUL-terminated string to another
 * @dest: The string to be appended to
 * @src: The string to append to it
 */
acoral_char * acoral_str_cat(acoral_char * dest, const acoral_char * src)
{
3000bd10:	e24dd010 	sub	sp, sp, #16
3000bd14:	e58d0004 	str	r0, [sp, #4]
3000bd18:	e58d1000 	str	r1, [sp]
	acoral_char *tmp = dest;
3000bd1c:	e59d3004 	ldr	r3, [sp, #4]
3000bd20:	e58d300c 	str	r3, [sp, #12]

	while (*dest)
3000bd24:	ea000002 	b	3000bd34 <acoral_str_cat+0x24>
		dest++;
3000bd28:	e59d3004 	ldr	r3, [sp, #4]
3000bd2c:	e2833001 	add	r3, r3, #1
3000bd30:	e58d3004 	str	r3, [sp, #4]
 */
acoral_char * acoral_str_cat(acoral_char * dest, const acoral_char * src)
{
	acoral_char *tmp = dest;

	while (*dest)
3000bd34:	e59d3004 	ldr	r3, [sp, #4]
3000bd38:	e5d33000 	ldrb	r3, [r3]
3000bd3c:	e3530000 	cmp	r3, #0
3000bd40:	1afffff8 	bne	3000bd28 <acoral_str_cat+0x18>
		dest++;
	while ((*dest++ = *src++) != '\0')
3000bd44:	e59d3000 	ldr	r3, [sp]
3000bd48:	e5d32000 	ldrb	r2, [r3]
3000bd4c:	e59d3004 	ldr	r3, [sp, #4]
3000bd50:	e5c32000 	strb	r2, [r3]
3000bd54:	e59d3004 	ldr	r3, [sp, #4]
3000bd58:	e5d33000 	ldrb	r3, [r3]
3000bd5c:	e3530000 	cmp	r3, #0
3000bd60:	03a03000 	moveq	r3, #0
3000bd64:	13a03001 	movne	r3, #1
3000bd68:	e20330ff 	and	r3, r3, #255	; 0xff
3000bd6c:	e59d2004 	ldr	r2, [sp, #4]
3000bd70:	e2822001 	add	r2, r2, #1
3000bd74:	e58d2004 	str	r2, [sp, #4]
3000bd78:	e59d2000 	ldr	r2, [sp]
3000bd7c:	e2822001 	add	r2, r2, #1
3000bd80:	e58d2000 	str	r2, [sp]
3000bd84:	e3530000 	cmp	r3, #0
3000bd88:	1affffed 	bne	3000bd44 <acoral_str_cat+0x34>
		;

	return tmp;
3000bd8c:	e59d300c 	ldr	r3, [sp, #12]
}
3000bd90:	e1a00003 	mov	r0, r3
3000bd94:	e28dd010 	add	sp, sp, #16
3000bd98:	e12fff1e 	bx	lr

3000bd9c <acoral_str_ncat>:
 *
 * Note that in contrast to acoral_str_ncpy, acoral_str_ncat ensures the result is
 * terminated.
 */
acoral_char * acoral_str_ncat(acoral_char *dest, const acoral_char *src, acoral_u32 count)
{
3000bd9c:	e24dd018 	sub	sp, sp, #24
3000bda0:	e58d000c 	str	r0, [sp, #12]
3000bda4:	e58d1008 	str	r1, [sp, #8]
3000bda8:	e58d2004 	str	r2, [sp, #4]
	acoral_char *tmp = dest;
3000bdac:	e59d300c 	ldr	r3, [sp, #12]
3000bdb0:	e58d3014 	str	r3, [sp, #20]

	if (count) {
3000bdb4:	e59d3004 	ldr	r3, [sp, #4]
3000bdb8:	e3530000 	cmp	r3, #0
3000bdbc:	0a000024 	beq	3000be54 <acoral_str_ncat+0xb8>
		while (*dest)
3000bdc0:	ea000002 	b	3000bdd0 <acoral_str_ncat+0x34>
			dest++;
3000bdc4:	e59d300c 	ldr	r3, [sp, #12]
3000bdc8:	e2833001 	add	r3, r3, #1
3000bdcc:	e58d300c 	str	r3, [sp, #12]
acoral_char * acoral_str_ncat(acoral_char *dest, const acoral_char *src, acoral_u32 count)
{
	acoral_char *tmp = dest;

	if (count) {
		while (*dest)
3000bdd0:	e59d300c 	ldr	r3, [sp, #12]
3000bdd4:	e5d33000 	ldrb	r3, [r3]
3000bdd8:	e3530000 	cmp	r3, #0
3000bddc:	1afffff8 	bne	3000bdc4 <acoral_str_ncat+0x28>
			dest++;
		while ((*dest++ = *src++) != 0) {
3000bde0:	ea000009 	b	3000be0c <acoral_str_ncat+0x70>
			if (--count == 0) {
3000bde4:	e59d3004 	ldr	r3, [sp, #4]
3000bde8:	e2433001 	sub	r3, r3, #1
3000bdec:	e58d3004 	str	r3, [sp, #4]
3000bdf0:	e59d3004 	ldr	r3, [sp, #4]
3000bdf4:	e3530000 	cmp	r3, #0
3000bdf8:	1a000003 	bne	3000be0c <acoral_str_ncat+0x70>
				*dest = '\0';
3000bdfc:	e59d300c 	ldr	r3, [sp, #12]
3000be00:	e3a02000 	mov	r2, #0
3000be04:	e5c32000 	strb	r2, [r3]
				break;
3000be08:	ea000011 	b	3000be54 <acoral_str_ncat+0xb8>
	acoral_char *tmp = dest;

	if (count) {
		while (*dest)
			dest++;
		while ((*dest++ = *src++) != 0) {
3000be0c:	e59d3008 	ldr	r3, [sp, #8]
3000be10:	e5d32000 	ldrb	r2, [r3]
3000be14:	e59d300c 	ldr	r3, [sp, #12]
3000be18:	e5c32000 	strb	r2, [r3]
3000be1c:	e59d300c 	ldr	r3, [sp, #12]
3000be20:	e5d33000 	ldrb	r3, [r3]
3000be24:	e3530000 	cmp	r3, #0
3000be28:	03a03000 	moveq	r3, #0
3000be2c:	13a03001 	movne	r3, #1
3000be30:	e20330ff 	and	r3, r3, #255	; 0xff
3000be34:	e59d200c 	ldr	r2, [sp, #12]
3000be38:	e2822001 	add	r2, r2, #1
3000be3c:	e58d200c 	str	r2, [sp, #12]
3000be40:	e59d2008 	ldr	r2, [sp, #8]
3000be44:	e2822001 	add	r2, r2, #1
3000be48:	e58d2008 	str	r2, [sp, #8]
3000be4c:	e3530000 	cmp	r3, #0
3000be50:	1affffe3 	bne	3000bde4 <acoral_str_ncat+0x48>
				break;
			}
		}
	}

	return tmp;
3000be54:	e59d3014 	ldr	r3, [sp, #20]
}
3000be58:	e1a00003 	mov	r0, r3
3000be5c:	e28dd018 	add	sp, sp, #24
3000be60:	e12fff1e 	bx	lr

3000be64 <acoral_str_lcat>:
 * @dest: The string to be appended to
 * @src: The string to append to it
 * @count: The size of the destination buffer.
 */
acoral_u32 acoral_str_lcat(acoral_char *dest, const acoral_char *src, acoral_u32 count)
{
3000be64:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000be68:	e24dd024 	sub	sp, sp, #36	; 0x24
3000be6c:	e58d000c 	str	r0, [sp, #12]
3000be70:	e58d1008 	str	r1, [sp, #8]
3000be74:	e58d2004 	str	r2, [sp, #4]
	acoral_u32 dsize = acoral_str_len(dest);
3000be78:	e59d000c 	ldr	r0, [sp, #12]
3000be7c:	ebfffea7 	bl	3000b920 <acoral_str_len>
3000be80:	e1a03000 	mov	r3, r0
3000be84:	e58d3014 	str	r3, [sp, #20]
	acoral_u32 len = acoral_str_len(src);
3000be88:	e59d0008 	ldr	r0, [sp, #8]
3000be8c:	ebfffea3 	bl	3000b920 <acoral_str_len>
3000be90:	e1a03000 	mov	r3, r0
3000be94:	e58d3018 	str	r3, [sp, #24]
	acoral_u32 res = dsize + len;
3000be98:	e59d2014 	ldr	r2, [sp, #20]
3000be9c:	e59d3018 	ldr	r3, [sp, #24]
3000bea0:	e0823003 	add	r3, r2, r3
3000bea4:	e58d301c 	str	r3, [sp, #28]

	/* This would be a bug */
//	BUG_ON(dsize >= count);

	dest += dsize;
3000bea8:	e59d200c 	ldr	r2, [sp, #12]
3000beac:	e59d3014 	ldr	r3, [sp, #20]
3000beb0:	e0823003 	add	r3, r2, r3
3000beb4:	e58d300c 	str	r3, [sp, #12]
	count -= dsize;
3000beb8:	e59d2004 	ldr	r2, [sp, #4]
3000bebc:	e59d3014 	ldr	r3, [sp, #20]
3000bec0:	e0633002 	rsb	r3, r3, r2
3000bec4:	e58d3004 	str	r3, [sp, #4]
	if (len >= count)
3000bec8:	e59d2018 	ldr	r2, [sp, #24]
3000becc:	e59d3004 	ldr	r3, [sp, #4]
3000bed0:	e1520003 	cmp	r2, r3
3000bed4:	3a000002 	bcc	3000bee4 <acoral_str_lcat+0x80>
		len = count-1;
3000bed8:	e59d3004 	ldr	r3, [sp, #4]
3000bedc:	e2433001 	sub	r3, r3, #1
3000bee0:	e58d3018 	str	r3, [sp, #24]
	acoral_memcpy(dest, src, len);
3000bee4:	e59d000c 	ldr	r0, [sp, #12]
3000bee8:	e59d1008 	ldr	r1, [sp, #8]
3000beec:	e59d2018 	ldr	r2, [sp, #24]
3000bef0:	eb000173 	bl	3000c4c4 <acoral_memcpy>
	dest[len] = 0;
3000bef4:	e59d200c 	ldr	r2, [sp, #12]
3000bef8:	e59d3018 	ldr	r3, [sp, #24]
3000befc:	e0823003 	add	r3, r2, r3
3000bf00:	e3a02000 	mov	r2, #0
3000bf04:	e5c32000 	strb	r2, [r3]
	return res;
3000bf08:	e59d301c 	ldr	r3, [sp, #28]
}
3000bf0c:	e1a00003 	mov	r0, r3
3000bf10:	e28dd024 	add	sp, sp, #36	; 0x24
3000bf14:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000bf18:	e12fff1e 	bx	lr

3000bf1c <acoral_str_ncmp>:
 * @cs: One string
 * @ct: Another string
 * @count: The maximum number of bytes to compare
 */
acoral_32 acoral_str_ncmp(const acoral_char * cs,const acoral_char * ct,acoral_u32 count)
{
3000bf1c:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
3000bf20:	e24dd014 	sub	sp, sp, #20
3000bf24:	e58d000c 	str	r0, [sp, #12]
3000bf28:	e58d1008 	str	r1, [sp, #8]
3000bf2c:	e58d2004 	str	r2, [sp, #4]
	register acoral_8 __res = 0;
3000bf30:	e3a04000 	mov	r4, #0

	while (count) {
3000bf34:	ea00001f 	b	3000bfb8 <acoral_str_ncmp+0x9c>
		if ((__res = *cs - *ct++) != 0 || !*cs++)
3000bf38:	e59d300c 	ldr	r3, [sp, #12]
3000bf3c:	e5d32000 	ldrb	r2, [r3]
3000bf40:	e59d3008 	ldr	r3, [sp, #8]
3000bf44:	e5d33000 	ldrb	r3, [r3]
3000bf48:	e0633002 	rsb	r3, r3, r2
3000bf4c:	e20330ff 	and	r3, r3, #255	; 0xff
3000bf50:	e1a04003 	mov	r4, r3
3000bf54:	e1a03c04 	lsl	r3, r4, #24
3000bf58:	e1a03c43 	asr	r3, r3, #24
3000bf5c:	e3530000 	cmp	r3, #0
3000bf60:	03a03000 	moveq	r3, #0
3000bf64:	13a03001 	movne	r3, #1
3000bf68:	e20330ff 	and	r3, r3, #255	; 0xff
3000bf6c:	e59d2008 	ldr	r2, [sp, #8]
3000bf70:	e2822001 	add	r2, r2, #1
3000bf74:	e58d2008 	str	r2, [sp, #8]
3000bf78:	e3530000 	cmp	r3, #0
3000bf7c:	1a000010 	bne	3000bfc4 <acoral_str_ncmp+0xa8>
3000bf80:	e59d300c 	ldr	r3, [sp, #12]
3000bf84:	e5d33000 	ldrb	r3, [r3]
3000bf88:	e3530000 	cmp	r3, #0
3000bf8c:	13a03000 	movne	r3, #0
3000bf90:	03a03001 	moveq	r3, #1
3000bf94:	e20330ff 	and	r3, r3, #255	; 0xff
3000bf98:	e59d200c 	ldr	r2, [sp, #12]
3000bf9c:	e2822001 	add	r2, r2, #1
3000bfa0:	e58d200c 	str	r2, [sp, #12]
3000bfa4:	e3530000 	cmp	r3, #0
3000bfa8:	1a000005 	bne	3000bfc4 <acoral_str_ncmp+0xa8>
			break;
		count--;
3000bfac:	e59d3004 	ldr	r3, [sp, #4]
3000bfb0:	e2433001 	sub	r3, r3, #1
3000bfb4:	e58d3004 	str	r3, [sp, #4]
 */
acoral_32 acoral_str_ncmp(const acoral_char * cs,const acoral_char * ct,acoral_u32 count)
{
	register acoral_8 __res = 0;

	while (count) {
3000bfb8:	e59d3004 	ldr	r3, [sp, #4]
3000bfbc:	e3530000 	cmp	r3, #0
3000bfc0:	1affffdc 	bne	3000bf38 <acoral_str_ncmp+0x1c>
		if ((__res = *cs - *ct++) != 0 || !*cs++)
			break;
		count--;
	}

	return __res;
3000bfc4:	e1a03c04 	lsl	r3, r4, #24
3000bfc8:	e1a03c43 	asr	r3, r3, #24
}
3000bfcc:	e1a00003 	mov	r0, r3
3000bfd0:	e28dd014 	add	sp, sp, #20
3000bfd4:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
3000bfd8:	e12fff1e 	bx	lr

3000bfdc <acoral_str_chr>:
 * acoral_str_chr - Find the first occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
acoral_32  acoral_str_chr(const acoral_char * s, acoral_32 c)
{
3000bfdc:	e24dd010 	sub	sp, sp, #16
3000bfe0:	e58d0004 	str	r0, [sp, #4]
3000bfe4:	e58d1000 	str	r1, [sp]
	acoral_u32 pos = 1;
3000bfe8:	e3a03001 	mov	r3, #1
3000bfec:	e58d300c 	str	r3, [sp, #12]
	for(; *s != (acoral_char) c; ++s,++pos)
3000bff0:	ea00000b 	b	3000c024 <acoral_str_chr+0x48>
		if (*s == '\0')
3000bff4:	e59d3004 	ldr	r3, [sp, #4]
3000bff8:	e5d33000 	ldrb	r3, [r3]
3000bffc:	e3530000 	cmp	r3, #0
3000c000:	1a000001 	bne	3000c00c <acoral_str_chr+0x30>
			return 0;
3000c004:	e3a03000 	mov	r3, #0
3000c008:	ea00000c 	b	3000c040 <acoral_str_chr+0x64>
 * @c: The character to search for
 */
acoral_32  acoral_str_chr(const acoral_char * s, acoral_32 c)
{
	acoral_u32 pos = 1;
	for(; *s != (acoral_char) c; ++s,++pos)
3000c00c:	e59d3004 	ldr	r3, [sp, #4]
3000c010:	e2833001 	add	r3, r3, #1
3000c014:	e58d3004 	str	r3, [sp, #4]
3000c018:	e59d300c 	ldr	r3, [sp, #12]
3000c01c:	e2833001 	add	r3, r3, #1
3000c020:	e58d300c 	str	r3, [sp, #12]
3000c024:	e59d3004 	ldr	r3, [sp, #4]
3000c028:	e5d32000 	ldrb	r2, [r3]
3000c02c:	e59d3000 	ldr	r3, [sp]
3000c030:	e20330ff 	and	r3, r3, #255	; 0xff
3000c034:	e1520003 	cmp	r2, r3
3000c038:	1affffed 	bne	3000bff4 <acoral_str_chr+0x18>
		if (*s == '\0')
			return 0;
	return pos;
3000c03c:	e59d300c 	ldr	r3, [sp, #12]
}
3000c040:	e1a00003 	mov	r0, r3
3000c044:	e28dd010 	add	sp, sp, #16
3000c048:	e12fff1e 	bx	lr

3000c04c <acoral_str_rchr>:
 * acoral_str_rchr - Find the last occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
acoral_32  acoral_str_rchr(const acoral_char * s, acoral_32 c)
{
3000c04c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000c050:	e24dd014 	sub	sp, sp, #20
3000c054:	e58d0004 	str	r0, [sp, #4]
3000c058:	e58d1000 	str	r1, [sp]
	   acoral_u32 pos = acoral_str_len(s);
3000c05c:	e59d0004 	ldr	r0, [sp, #4]
3000c060:	ebfffe2e 	bl	3000b920 <acoral_str_len>
3000c064:	e1a03000 	mov	r3, r0
3000c068:	e58d3008 	str	r3, [sp, #8]
       const acoral_char *p = s + pos;
3000c06c:	e59d2004 	ldr	r2, [sp, #4]
3000c070:	e59d3008 	ldr	r3, [sp, #8]
3000c074:	e0823003 	add	r3, r2, r3
3000c078:	e58d300c 	str	r3, [sp, #12]
       do {
           if (*p == (acoral_char)c)
3000c07c:	e59d300c 	ldr	r3, [sp, #12]
3000c080:	e5d32000 	ldrb	r2, [r3]
3000c084:	e59d3000 	ldr	r3, [sp]
3000c088:	e20330ff 	and	r3, r3, #255	; 0xff
3000c08c:	e1520003 	cmp	r2, r3
3000c090:	1a000001 	bne	3000c09c <acoral_str_rchr+0x50>
               return pos;
3000c094:	e59d3008 	ldr	r3, [sp, #8]
3000c098:	ea00000a 	b	3000c0c8 <acoral_str_rchr+0x7c>
           --pos;
3000c09c:	e59d3008 	ldr	r3, [sp, #8]
3000c0a0:	e2433001 	sub	r3, r3, #1
3000c0a4:	e58d3008 	str	r3, [sp, #8]
       } while (--p >= s);
3000c0a8:	e59d300c 	ldr	r3, [sp, #12]
3000c0ac:	e2433001 	sub	r3, r3, #1
3000c0b0:	e58d300c 	str	r3, [sp, #12]
3000c0b4:	e59d200c 	ldr	r2, [sp, #12]
3000c0b8:	e59d3004 	ldr	r3, [sp, #4]
3000c0bc:	e1520003 	cmp	r2, r3
3000c0c0:	2affffed 	bcs	3000c07c <acoral_str_rchr+0x30>
       return 0;
3000c0c4:	e3a03000 	mov	r3, #0
}
3000c0c8:	e1a00003 	mov	r0, r3
3000c0cc:	e28dd014 	add	sp, sp, #20
3000c0d0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000c0d4:	e12fff1e 	bx	lr

3000c0d8 <acoral_str_nchr>:
 * @s: The string to be searched
 * @count: The number of characters to be searched
 * @c: The character to search for
 */
acoral_32 acoral_str_nchr(const acoral_char *s, acoral_u32 count, acoral_32 c)
{
3000c0d8:	e24dd018 	sub	sp, sp, #24
3000c0dc:	e58d000c 	str	r0, [sp, #12]
3000c0e0:	e58d1008 	str	r1, [sp, #8]
3000c0e4:	e58d2004 	str	r2, [sp, #4]
	acoral_u32 pos = 1;
3000c0e8:	e3a03001 	mov	r3, #1
3000c0ec:	e58d3014 	str	r3, [sp, #20]
	for (; count-- && *s != '\0'; ++s,++pos)
3000c0f0:	ea00000d 	b	3000c12c <acoral_str_nchr+0x54>
		if (*s == (acoral_char) c)
3000c0f4:	e59d300c 	ldr	r3, [sp, #12]
3000c0f8:	e5d32000 	ldrb	r2, [r3]
3000c0fc:	e59d3004 	ldr	r3, [sp, #4]
3000c100:	e20330ff 	and	r3, r3, #255	; 0xff
3000c104:	e1520003 	cmp	r2, r3
3000c108:	1a000001 	bne	3000c114 <acoral_str_nchr+0x3c>
			return pos;
3000c10c:	e59d3014 	ldr	r3, [sp, #20]
3000c110:	ea000014 	b	3000c168 <acoral_str_nchr+0x90>
 * @c: The character to search for
 */
acoral_32 acoral_str_nchr(const acoral_char *s, acoral_u32 count, acoral_32 c)
{
	acoral_u32 pos = 1;
	for (; count-- && *s != '\0'; ++s,++pos)
3000c114:	e59d300c 	ldr	r3, [sp, #12]
3000c118:	e2833001 	add	r3, r3, #1
3000c11c:	e58d300c 	str	r3, [sp, #12]
3000c120:	e59d3014 	ldr	r3, [sp, #20]
3000c124:	e2833001 	add	r3, r3, #1
3000c128:	e58d3014 	str	r3, [sp, #20]
3000c12c:	e59d3008 	ldr	r3, [sp, #8]
3000c130:	e3530000 	cmp	r3, #0
3000c134:	03a03000 	moveq	r3, #0
3000c138:	13a03001 	movne	r3, #1
3000c13c:	e20330ff 	and	r3, r3, #255	; 0xff
3000c140:	e59d2008 	ldr	r2, [sp, #8]
3000c144:	e2422001 	sub	r2, r2, #1
3000c148:	e58d2008 	str	r2, [sp, #8]
3000c14c:	e3530000 	cmp	r3, #0
3000c150:	0a000003 	beq	3000c164 <acoral_str_nchr+0x8c>
3000c154:	e59d300c 	ldr	r3, [sp, #12]
3000c158:	e5d33000 	ldrb	r3, [r3]
3000c15c:	e3530000 	cmp	r3, #0
3000c160:	1affffe3 	bne	3000c0f4 <acoral_str_nchr+0x1c>
		if (*s == (acoral_char) c)
			return pos;
	return 0;
3000c164:	e3a03000 	mov	r3, #0
}
3000c168:	e1a00003 	mov	r0, r3
3000c16c:	e28dd018 	add	sp, sp, #24
3000c170:	e12fff1e 	bx	lr

3000c174 <acoral_str_nlen>:
 * acoral_str_nlen - Find the length of a length-limited string
 * @s: The string to be sized
 * @count: The maximum number of bytes to search
 */
acoral_u32 acoral_str_nlen(const acoral_char * s, acoral_u32 count)
{
3000c174:	e24dd010 	sub	sp, sp, #16
3000c178:	e58d0004 	str	r0, [sp, #4]
3000c17c:	e58d1000 	str	r1, [sp]
	const acoral_char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
3000c180:	e59d3004 	ldr	r3, [sp, #4]
3000c184:	e58d300c 	str	r3, [sp, #12]
3000c188:	ea000002 	b	3000c198 <acoral_str_nlen+0x24>
3000c18c:	e59d300c 	ldr	r3, [sp, #12]
3000c190:	e2833001 	add	r3, r3, #1
3000c194:	e58d300c 	str	r3, [sp, #12]
3000c198:	e59d3000 	ldr	r3, [sp]
3000c19c:	e3530000 	cmp	r3, #0
3000c1a0:	03a03000 	moveq	r3, #0
3000c1a4:	13a03001 	movne	r3, #1
3000c1a8:	e20330ff 	and	r3, r3, #255	; 0xff
3000c1ac:	e59d2000 	ldr	r2, [sp]
3000c1b0:	e2422001 	sub	r2, r2, #1
3000c1b4:	e58d2000 	str	r2, [sp]
3000c1b8:	e3530000 	cmp	r3, #0
3000c1bc:	0a000003 	beq	3000c1d0 <acoral_str_nlen+0x5c>
3000c1c0:	e59d300c 	ldr	r3, [sp, #12]
3000c1c4:	e5d33000 	ldrb	r3, [r3]
3000c1c8:	e3530000 	cmp	r3, #0
3000c1cc:	1affffee 	bne	3000c18c <acoral_str_nlen+0x18>
		/* nothing */;
	return sc - s;
3000c1d0:	e59d200c 	ldr	r2, [sp, #12]
3000c1d4:	e59d3004 	ldr	r3, [sp, #4]
3000c1d8:	e0633002 	rsb	r3, r3, r2
}
3000c1dc:	e1a00003 	mov	r0, r3
3000c1e0:	e28dd010 	add	sp, sp, #16
3000c1e4:	e12fff1e 	bx	lr

3000c1e8 <acoral_str_spn>:
 * 	contain letters in @accept
 * @s: The string to be searched
 * @accept: The string to search for
 */
acoral_u32 acoral_str_spn(const acoral_char *s, const acoral_char *accept)
{
3000c1e8:	e24dd018 	sub	sp, sp, #24
3000c1ec:	e58d0004 	str	r0, [sp, #4]
3000c1f0:	e58d1000 	str	r1, [sp]
	const acoral_char *p;
	const acoral_char *a;
	acoral_u32 count = 0;
3000c1f4:	e3a03000 	mov	r3, #0
3000c1f8:	e58d3014 	str	r3, [sp, #20]

	for (p = s; *p != '\0'; ++p) {
3000c1fc:	e59d3004 	ldr	r3, [sp, #4]
3000c200:	e58d300c 	str	r3, [sp, #12]
3000c204:	ea00001d 	b	3000c280 <acoral_str_spn+0x98>
		for (a = accept; *a != '\0'; ++a) {
3000c208:	e59d3000 	ldr	r3, [sp]
3000c20c:	e58d3010 	str	r3, [sp, #16]
3000c210:	ea000008 	b	3000c238 <acoral_str_spn+0x50>
			if (*p == *a)
3000c214:	e59d300c 	ldr	r3, [sp, #12]
3000c218:	e5d32000 	ldrb	r2, [r3]
3000c21c:	e59d3010 	ldr	r3, [sp, #16]
3000c220:	e5d33000 	ldrb	r3, [r3]
3000c224:	e1520003 	cmp	r2, r3
3000c228:	0a000007 	beq	3000c24c <acoral_str_spn+0x64>
	const acoral_char *p;
	const acoral_char *a;
	acoral_u32 count = 0;

	for (p = s; *p != '\0'; ++p) {
		for (a = accept; *a != '\0'; ++a) {
3000c22c:	e59d3010 	ldr	r3, [sp, #16]
3000c230:	e2833001 	add	r3, r3, #1
3000c234:	e58d3010 	str	r3, [sp, #16]
3000c238:	e59d3010 	ldr	r3, [sp, #16]
3000c23c:	e5d33000 	ldrb	r3, [r3]
3000c240:	e3530000 	cmp	r3, #0
3000c244:	1afffff2 	bne	3000c214 <acoral_str_spn+0x2c>
3000c248:	ea000000 	b	3000c250 <acoral_str_spn+0x68>
			if (*p == *a)
				break;
3000c24c:	e1a00000 	nop			; (mov r0, r0)
		}
		if (*a == '\0')
3000c250:	e59d3010 	ldr	r3, [sp, #16]
3000c254:	e5d33000 	ldrb	r3, [r3]
3000c258:	e3530000 	cmp	r3, #0
3000c25c:	1a000001 	bne	3000c268 <acoral_str_spn+0x80>
			return count;
3000c260:	e59d3014 	ldr	r3, [sp, #20]
3000c264:	ea00000a 	b	3000c294 <acoral_str_spn+0xac>
		++count;
3000c268:	e59d3014 	ldr	r3, [sp, #20]
3000c26c:	e2833001 	add	r3, r3, #1
3000c270:	e58d3014 	str	r3, [sp, #20]
{
	const acoral_char *p;
	const acoral_char *a;
	acoral_u32 count = 0;

	for (p = s; *p != '\0'; ++p) {
3000c274:	e59d300c 	ldr	r3, [sp, #12]
3000c278:	e2833001 	add	r3, r3, #1
3000c27c:	e58d300c 	str	r3, [sp, #12]
3000c280:	e59d300c 	ldr	r3, [sp, #12]
3000c284:	e5d33000 	ldrb	r3, [r3]
3000c288:	e3530000 	cmp	r3, #0
3000c28c:	1affffdd 	bne	3000c208 <acoral_str_spn+0x20>
		if (*a == '\0')
			return count;
		++count;
	}

	return count;
3000c290:	e59d3014 	ldr	r3, [sp, #20]
}
3000c294:	e1a00003 	mov	r0, r3
3000c298:	e28dd018 	add	sp, sp, #24
3000c29c:	e12fff1e 	bx	lr

3000c2a0 <acoral_str_cspn>:
 * 	not contain letters in @reject
 * @s: The string to be searched
 * @reject: The string to avoid
 */
acoral_u32 acoral_str_cspn(const acoral_char *s, const acoral_char *reject)
{
3000c2a0:	e24dd018 	sub	sp, sp, #24
3000c2a4:	e58d0004 	str	r0, [sp, #4]
3000c2a8:	e58d1000 	str	r1, [sp]
	const acoral_char *p;
	const acoral_char *r;
	acoral_u32 count = 0;
3000c2ac:	e3a03000 	mov	r3, #0
3000c2b0:	e58d3014 	str	r3, [sp, #20]

	for (p = s; *p != '\0'; ++p) {
3000c2b4:	e59d3004 	ldr	r3, [sp, #4]
3000c2b8:	e58d300c 	str	r3, [sp, #12]
3000c2bc:	ea000017 	b	3000c320 <acoral_str_cspn+0x80>
		for (r = reject; *r != '\0'; ++r) {
3000c2c0:	e59d3000 	ldr	r3, [sp]
3000c2c4:	e58d3010 	str	r3, [sp, #16]
3000c2c8:	ea00000a 	b	3000c2f8 <acoral_str_cspn+0x58>
			if (*p == *r)
3000c2cc:	e59d300c 	ldr	r3, [sp, #12]
3000c2d0:	e5d32000 	ldrb	r2, [r3]
3000c2d4:	e59d3010 	ldr	r3, [sp, #16]
3000c2d8:	e5d33000 	ldrb	r3, [r3]
3000c2dc:	e1520003 	cmp	r2, r3
3000c2e0:	1a000001 	bne	3000c2ec <acoral_str_cspn+0x4c>
				return count;
3000c2e4:	e59d3014 	ldr	r3, [sp, #20]
3000c2e8:	ea000011 	b	3000c334 <acoral_str_cspn+0x94>
	const acoral_char *p;
	const acoral_char *r;
	acoral_u32 count = 0;

	for (p = s; *p != '\0'; ++p) {
		for (r = reject; *r != '\0'; ++r) {
3000c2ec:	e59d3010 	ldr	r3, [sp, #16]
3000c2f0:	e2833001 	add	r3, r3, #1
3000c2f4:	e58d3010 	str	r3, [sp, #16]
3000c2f8:	e59d3010 	ldr	r3, [sp, #16]
3000c2fc:	e5d33000 	ldrb	r3, [r3]
3000c300:	e3530000 	cmp	r3, #0
3000c304:	1afffff0 	bne	3000c2cc <acoral_str_cspn+0x2c>
			if (*p == *r)
				return count;
		}
		++count;
3000c308:	e59d3014 	ldr	r3, [sp, #20]
3000c30c:	e2833001 	add	r3, r3, #1
3000c310:	e58d3014 	str	r3, [sp, #20]
{
	const acoral_char *p;
	const acoral_char *r;
	acoral_u32 count = 0;

	for (p = s; *p != '\0'; ++p) {
3000c314:	e59d300c 	ldr	r3, [sp, #12]
3000c318:	e2833001 	add	r3, r3, #1
3000c31c:	e58d300c 	str	r3, [sp, #12]
3000c320:	e59d300c 	ldr	r3, [sp, #12]
3000c324:	e5d33000 	ldrb	r3, [r3]
3000c328:	e3530000 	cmp	r3, #0
3000c32c:	1affffe3 	bne	3000c2c0 <acoral_str_cspn+0x20>
				return count;
		}
		++count;
	}

	return count;
3000c330:	e59d3014 	ldr	r3, [sp, #20]
}	
3000c334:	e1a00003 	mov	r0, r3
3000c338:	e28dd018 	add	sp, sp, #24
3000c33c:	e12fff1e 	bx	lr

3000c340 <acoral_str_pbrk>:
 * acoral_str_pbrk - Find the first occurrence of a set of characters
 * @cs: The string to be searched
 * @ct: The characters to search for
 */
acoral_char * acoral_str_pbrk(const acoral_char * cs,const acoral_char * ct)
{
3000c340:	e24dd010 	sub	sp, sp, #16
3000c344:	e58d0004 	str	r0, [sp, #4]
3000c348:	e58d1000 	str	r1, [sp]
	const acoral_char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
3000c34c:	e59d3004 	ldr	r3, [sp, #4]
3000c350:	e58d3008 	str	r3, [sp, #8]
3000c354:	ea000014 	b	3000c3ac <acoral_str_pbrk+0x6c>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
3000c358:	e59d3000 	ldr	r3, [sp]
3000c35c:	e58d300c 	str	r3, [sp, #12]
3000c360:	ea00000a 	b	3000c390 <acoral_str_pbrk+0x50>
			if (*sc1 == *sc2)
3000c364:	e59d3008 	ldr	r3, [sp, #8]
3000c368:	e5d32000 	ldrb	r2, [r3]
3000c36c:	e59d300c 	ldr	r3, [sp, #12]
3000c370:	e5d33000 	ldrb	r3, [r3]
3000c374:	e1520003 	cmp	r2, r3
3000c378:	1a000001 	bne	3000c384 <acoral_str_pbrk+0x44>
				return (acoral_char *) sc1;
3000c37c:	e59d3008 	ldr	r3, [sp, #8]
3000c380:	ea00000e 	b	3000c3c0 <acoral_str_pbrk+0x80>
acoral_char * acoral_str_pbrk(const acoral_char * cs,const acoral_char * ct)
{
	const acoral_char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
3000c384:	e59d300c 	ldr	r3, [sp, #12]
3000c388:	e2833001 	add	r3, r3, #1
3000c38c:	e58d300c 	str	r3, [sp, #12]
3000c390:	e59d300c 	ldr	r3, [sp, #12]
3000c394:	e5d33000 	ldrb	r3, [r3]
3000c398:	e3530000 	cmp	r3, #0
3000c39c:	1afffff0 	bne	3000c364 <acoral_str_pbrk+0x24>
 */
acoral_char * acoral_str_pbrk(const acoral_char * cs,const acoral_char * ct)
{
	const acoral_char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
3000c3a0:	e59d3008 	ldr	r3, [sp, #8]
3000c3a4:	e2833001 	add	r3, r3, #1
3000c3a8:	e58d3008 	str	r3, [sp, #8]
3000c3ac:	e59d3008 	ldr	r3, [sp, #8]
3000c3b0:	e5d33000 	ldrb	r3, [r3]
3000c3b4:	e3530000 	cmp	r3, #0
3000c3b8:	1affffe6 	bne	3000c358 <acoral_str_pbrk+0x18>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
				return (acoral_char *) sc1;
		}
	}
	return NULL;
3000c3bc:	e3a03000 	mov	r3, #0
}
3000c3c0:	e1a00003 	mov	r0, r3
3000c3c4:	e28dd010 	add	sp, sp, #16
3000c3c8:	e12fff1e 	bx	lr

3000c3cc <acoral_str_sep>:
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
acoral_char * acoral_str_sep(acoral_char **s, const acoral_char *ct)
{
3000c3cc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000c3d0:	e24dd014 	sub	sp, sp, #20
3000c3d4:	e58d0004 	str	r0, [sp, #4]
3000c3d8:	e58d1000 	str	r1, [sp]
	acoral_char *sbegin = *s, *end;
3000c3dc:	e59d3004 	ldr	r3, [sp, #4]
3000c3e0:	e5933000 	ldr	r3, [r3]
3000c3e4:	e58d3008 	str	r3, [sp, #8]

	if (sbegin == NULL)
3000c3e8:	e59d3008 	ldr	r3, [sp, #8]
3000c3ec:	e3530000 	cmp	r3, #0
3000c3f0:	1a000001 	bne	3000c3fc <acoral_str_sep+0x30>
		return NULL;
3000c3f4:	e3a03000 	mov	r3, #0
3000c3f8:	ea000011 	b	3000c444 <acoral_str_sep+0x78>

	end = acoral_str_pbrk(sbegin, ct);
3000c3fc:	e59d0008 	ldr	r0, [sp, #8]
3000c400:	e59d1000 	ldr	r1, [sp]
3000c404:	ebffffcd 	bl	3000c340 <acoral_str_pbrk>
3000c408:	e1a03000 	mov	r3, r0
3000c40c:	e58d300c 	str	r3, [sp, #12]
	if (end)
3000c410:	e59d300c 	ldr	r3, [sp, #12]
3000c414:	e3530000 	cmp	r3, #0
3000c418:	0a000005 	beq	3000c434 <acoral_str_sep+0x68>
		*end++ = '\0';
3000c41c:	e59d300c 	ldr	r3, [sp, #12]
3000c420:	e3a02000 	mov	r2, #0
3000c424:	e5c32000 	strb	r2, [r3]
3000c428:	e59d300c 	ldr	r3, [sp, #12]
3000c42c:	e2833001 	add	r3, r3, #1
3000c430:	e58d300c 	str	r3, [sp, #12]
	*s = end;
3000c434:	e59d3004 	ldr	r3, [sp, #4]
3000c438:	e59d200c 	ldr	r2, [sp, #12]
3000c43c:	e5832000 	str	r2, [r3]

	return sbegin;
3000c440:	e59d3008 	ldr	r3, [sp, #8]
}
3000c444:	e1a00003 	mov	r0, r3
3000c448:	e28dd014 	add	sp, sp, #20
3000c44c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000c450:	e12fff1e 	bx	lr

3000c454 <acoral_memset>:
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * acoral_memset(void * s,acoral_32 c,acoral_u32 count)
{
3000c454:	e24dd018 	sub	sp, sp, #24
3000c458:	e58d000c 	str	r0, [sp, #12]
3000c45c:	e58d1008 	str	r1, [sp, #8]
3000c460:	e58d2004 	str	r2, [sp, #4]
	acoral_char *xs = (acoral_char *) s;
3000c464:	e59d300c 	ldr	r3, [sp, #12]
3000c468:	e58d3014 	str	r3, [sp, #20]

	while (count--)
3000c46c:	ea000006 	b	3000c48c <acoral_memset+0x38>
		*xs++ = c;
3000c470:	e59d3008 	ldr	r3, [sp, #8]
3000c474:	e20320ff 	and	r2, r3, #255	; 0xff
3000c478:	e59d3014 	ldr	r3, [sp, #20]
3000c47c:	e5c32000 	strb	r2, [r3]
3000c480:	e59d3014 	ldr	r3, [sp, #20]
3000c484:	e2833001 	add	r3, r3, #1
3000c488:	e58d3014 	str	r3, [sp, #20]
 */
void * acoral_memset(void * s,acoral_32 c,acoral_u32 count)
{
	acoral_char *xs = (acoral_char *) s;

	while (count--)
3000c48c:	e59d3004 	ldr	r3, [sp, #4]
3000c490:	e3530000 	cmp	r3, #0
3000c494:	03a03000 	moveq	r3, #0
3000c498:	13a03001 	movne	r3, #1
3000c49c:	e20330ff 	and	r3, r3, #255	; 0xff
3000c4a0:	e59d2004 	ldr	r2, [sp, #4]
3000c4a4:	e2422001 	sub	r2, r2, #1
3000c4a8:	e58d2004 	str	r2, [sp, #4]
3000c4ac:	e3530000 	cmp	r3, #0
3000c4b0:	1affffee 	bne	3000c470 <acoral_memset+0x1c>
		*xs++ = c;

	return s;
3000c4b4:	e59d300c 	ldr	r3, [sp, #12]
}
3000c4b8:	e1a00003 	mov	r0, r3
3000c4bc:	e28dd018 	add	sp, sp, #24
3000c4c0:	e12fff1e 	bx	lr

3000c4c4 <acoral_memcpy>:
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * acoral_memcpy(void * dest,const void *src,acoral_u32 count)
{
3000c4c4:	e24dd018 	sub	sp, sp, #24
3000c4c8:	e58d000c 	str	r0, [sp, #12]
3000c4cc:	e58d1008 	str	r1, [sp, #8]
3000c4d0:	e58d2004 	str	r2, [sp, #4]
	acoral_char *tmp = (acoral_char *) dest, *s = (acoral_char *) src;
3000c4d4:	e59d300c 	ldr	r3, [sp, #12]
3000c4d8:	e58d3010 	str	r3, [sp, #16]
3000c4dc:	e59d3008 	ldr	r3, [sp, #8]
3000c4e0:	e58d3014 	str	r3, [sp, #20]

	while (count--)
3000c4e4:	ea000009 	b	3000c510 <acoral_memcpy+0x4c>
		*tmp++ = *s++;
3000c4e8:	e59d3014 	ldr	r3, [sp, #20]
3000c4ec:	e5d32000 	ldrb	r2, [r3]
3000c4f0:	e59d3010 	ldr	r3, [sp, #16]
3000c4f4:	e5c32000 	strb	r2, [r3]
3000c4f8:	e59d3010 	ldr	r3, [sp, #16]
3000c4fc:	e2833001 	add	r3, r3, #1
3000c500:	e58d3010 	str	r3, [sp, #16]
3000c504:	e59d3014 	ldr	r3, [sp, #20]
3000c508:	e2833001 	add	r3, r3, #1
3000c50c:	e58d3014 	str	r3, [sp, #20]
 */
void * acoral_memcpy(void * dest,const void *src,acoral_u32 count)
{
	acoral_char *tmp = (acoral_char *) dest, *s = (acoral_char *) src;

	while (count--)
3000c510:	e59d3004 	ldr	r3, [sp, #4]
3000c514:	e3530000 	cmp	r3, #0
3000c518:	03a03000 	moveq	r3, #0
3000c51c:	13a03001 	movne	r3, #1
3000c520:	e20330ff 	and	r3, r3, #255	; 0xff
3000c524:	e59d2004 	ldr	r2, [sp, #4]
3000c528:	e2422001 	sub	r2, r2, #1
3000c52c:	e58d2004 	str	r2, [sp, #4]
3000c530:	e3530000 	cmp	r3, #0
3000c534:	1affffeb 	bne	3000c4e8 <acoral_memcpy+0x24>
		*tmp++ = *s++;

	return dest;
3000c538:	e59d300c 	ldr	r3, [sp, #12]
}
3000c53c:	e1a00003 	mov	r0, r3
3000c540:	e28dd018 	add	sp, sp, #24
3000c544:	e12fff1e 	bx	lr

3000c548 <acoral_memmove>:
 * @count: The size of the area.
 *
 * Unlike memcpy(), memmove() copes with overlapping areas.
 */
void * acoral_memmove(void * dest,const void *src,acoral_u32 count)
{
3000c548:	e24dd018 	sub	sp, sp, #24
3000c54c:	e58d000c 	str	r0, [sp, #12]
3000c550:	e58d1008 	str	r1, [sp, #8]
3000c554:	e58d2004 	str	r2, [sp, #4]
	acoral_char *tmp, *s;

	if (dest <= src) {
3000c558:	e59d200c 	ldr	r2, [sp, #12]
3000c55c:	e59d3008 	ldr	r3, [sp, #8]
3000c560:	e1520003 	cmp	r2, r3
3000c564:	8a000019 	bhi	3000c5d0 <acoral_memmove+0x88>
		tmp = (acoral_char *) dest;
3000c568:	e59d300c 	ldr	r3, [sp, #12]
3000c56c:	e58d3010 	str	r3, [sp, #16]
		s = (acoral_char *) src;
3000c570:	e59d3008 	ldr	r3, [sp, #8]
3000c574:	e58d3014 	str	r3, [sp, #20]
		while (count--)
3000c578:	ea000009 	b	3000c5a4 <acoral_memmove+0x5c>
			*tmp++ = *s++;
3000c57c:	e59d3014 	ldr	r3, [sp, #20]
3000c580:	e5d32000 	ldrb	r2, [r3]
3000c584:	e59d3010 	ldr	r3, [sp, #16]
3000c588:	e5c32000 	strb	r2, [r3]
3000c58c:	e59d3010 	ldr	r3, [sp, #16]
3000c590:	e2833001 	add	r3, r3, #1
3000c594:	e58d3010 	str	r3, [sp, #16]
3000c598:	e59d3014 	ldr	r3, [sp, #20]
3000c59c:	e2833001 	add	r3, r3, #1
3000c5a0:	e58d3014 	str	r3, [sp, #20]
	acoral_char *tmp, *s;

	if (dest <= src) {
		tmp = (acoral_char *) dest;
		s = (acoral_char *) src;
		while (count--)
3000c5a4:	e59d3004 	ldr	r3, [sp, #4]
3000c5a8:	e3530000 	cmp	r3, #0
3000c5ac:	03a03000 	moveq	r3, #0
3000c5b0:	13a03001 	movne	r3, #1
3000c5b4:	e20330ff 	and	r3, r3, #255	; 0xff
3000c5b8:	e59d2004 	ldr	r2, [sp, #4]
3000c5bc:	e2422001 	sub	r2, r2, #1
3000c5c0:	e58d2004 	str	r2, [sp, #4]
3000c5c4:	e3530000 	cmp	r3, #0
3000c5c8:	1affffeb 	bne	3000c57c <acoral_memmove+0x34>
3000c5cc:	ea00001c 	b	3000c644 <acoral_memmove+0xfc>
			*tmp++ = *s++;
		}
	else {
		tmp = (acoral_char *) dest + count;
3000c5d0:	e59d200c 	ldr	r2, [sp, #12]
3000c5d4:	e59d3004 	ldr	r3, [sp, #4]
3000c5d8:	e0823003 	add	r3, r2, r3
3000c5dc:	e58d3010 	str	r3, [sp, #16]
		s = (acoral_char *) src + count;
3000c5e0:	e59d2008 	ldr	r2, [sp, #8]
3000c5e4:	e59d3004 	ldr	r3, [sp, #4]
3000c5e8:	e0823003 	add	r3, r2, r3
3000c5ec:	e58d3014 	str	r3, [sp, #20]
		while (count--)
3000c5f0:	ea000009 	b	3000c61c <acoral_memmove+0xd4>
			*--tmp = *--s;
3000c5f4:	e59d3010 	ldr	r3, [sp, #16]
3000c5f8:	e2433001 	sub	r3, r3, #1
3000c5fc:	e58d3010 	str	r3, [sp, #16]
3000c600:	e59d3014 	ldr	r3, [sp, #20]
3000c604:	e2433001 	sub	r3, r3, #1
3000c608:	e58d3014 	str	r3, [sp, #20]
3000c60c:	e59d3014 	ldr	r3, [sp, #20]
3000c610:	e5d32000 	ldrb	r2, [r3]
3000c614:	e59d3010 	ldr	r3, [sp, #16]
3000c618:	e5c32000 	strb	r2, [r3]
			*tmp++ = *s++;
		}
	else {
		tmp = (acoral_char *) dest + count;
		s = (acoral_char *) src + count;
		while (count--)
3000c61c:	e59d3004 	ldr	r3, [sp, #4]
3000c620:	e3530000 	cmp	r3, #0
3000c624:	03a03000 	moveq	r3, #0
3000c628:	13a03001 	movne	r3, #1
3000c62c:	e20330ff 	and	r3, r3, #255	; 0xff
3000c630:	e59d2004 	ldr	r2, [sp, #4]
3000c634:	e2422001 	sub	r2, r2, #1
3000c638:	e58d2004 	str	r2, [sp, #4]
3000c63c:	e3530000 	cmp	r3, #0
3000c640:	1affffeb 	bne	3000c5f4 <acoral_memmove+0xac>
			*--tmp = *--s;
		}

	return dest;
3000c644:	e59d300c 	ldr	r3, [sp, #12]
}
3000c648:	e1a00003 	mov	r0, r3
3000c64c:	e28dd018 	add	sp, sp, #24
3000c650:	e12fff1e 	bx	lr

3000c654 <acoral_memcmp>:
 * @cs: One area of memory
 * @ct: Another area of memory
 * @count: The size of the area.
 */
acoral_32 acoral_memcmp(const void * cs,const void * ct,acoral_u32 count)
{
3000c654:	e24dd020 	sub	sp, sp, #32
3000c658:	e58d000c 	str	r0, [sp, #12]
3000c65c:	e58d1008 	str	r1, [sp, #8]
3000c660:	e58d2004 	str	r2, [sp, #4]
	const acoral_u8 *su1, *su2;
	acoral_32 res = 0;
3000c664:	e3a03000 	mov	r3, #0
3000c668:	e58d301c 	str	r3, [sp, #28]

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
3000c66c:	e59d300c 	ldr	r3, [sp, #12]
3000c670:	e58d3014 	str	r3, [sp, #20]
3000c674:	e59d3008 	ldr	r3, [sp, #8]
3000c678:	e58d3018 	str	r3, [sp, #24]
3000c67c:	ea000012 	b	3000c6cc <acoral_memcmp+0x78>
		if ((res = *su1 - *su2) != 0)
3000c680:	e59d3014 	ldr	r3, [sp, #20]
3000c684:	e5d33000 	ldrb	r3, [r3]
3000c688:	e1a02003 	mov	r2, r3
3000c68c:	e59d3018 	ldr	r3, [sp, #24]
3000c690:	e5d33000 	ldrb	r3, [r3]
3000c694:	e0633002 	rsb	r3, r3, r2
3000c698:	e58d301c 	str	r3, [sp, #28]
3000c69c:	e59d301c 	ldr	r3, [sp, #28]
3000c6a0:	e3530000 	cmp	r3, #0
3000c6a4:	1a00000c 	bne	3000c6dc <acoral_memcmp+0x88>
acoral_32 acoral_memcmp(const void * cs,const void * ct,acoral_u32 count)
{
	const acoral_u8 *su1, *su2;
	acoral_32 res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
3000c6a8:	e59d3014 	ldr	r3, [sp, #20]
3000c6ac:	e2833001 	add	r3, r3, #1
3000c6b0:	e58d3014 	str	r3, [sp, #20]
3000c6b4:	e59d3018 	ldr	r3, [sp, #24]
3000c6b8:	e2833001 	add	r3, r3, #1
3000c6bc:	e58d3018 	str	r3, [sp, #24]
3000c6c0:	e59d3004 	ldr	r3, [sp, #4]
3000c6c4:	e2433001 	sub	r3, r3, #1
3000c6c8:	e58d3004 	str	r3, [sp, #4]
3000c6cc:	e59d3004 	ldr	r3, [sp, #4]
3000c6d0:	e3530000 	cmp	r3, #0
3000c6d4:	1affffe9 	bne	3000c680 <acoral_memcmp+0x2c>
3000c6d8:	ea000000 	b	3000c6e0 <acoral_memcmp+0x8c>
		if ((res = *su1 - *su2) != 0)
			break;
3000c6dc:	e1a00000 	nop			; (mov r0, r0)
	return res;
3000c6e0:	e59d301c 	ldr	r3, [sp, #28]
}
3000c6e4:	e1a00003 	mov	r0, r3
3000c6e8:	e28dd020 	add	sp, sp, #32
3000c6ec:	e12fff1e 	bx	lr

3000c6f0 <acoral_memscan>:
 *
 * returns the address of the first occurrence of @c, or 1 byte past
 * the area if @c is not found
 */
void * acoral_memscan(void * addr, acoral_32 c, acoral_u32 size)
{
3000c6f0:	e24dd018 	sub	sp, sp, #24
3000c6f4:	e58d000c 	str	r0, [sp, #12]
3000c6f8:	e58d1008 	str	r1, [sp, #8]
3000c6fc:	e58d2004 	str	r2, [sp, #4]
	acoral_u8 * p = (acoral_u8 *) addr;
3000c700:	e59d300c 	ldr	r3, [sp, #12]
3000c704:	e58d3014 	str	r3, [sp, #20]

	while (size) {
3000c708:	ea00000d 	b	3000c744 <acoral_memscan+0x54>
		if (*p == c)
3000c70c:	e59d3014 	ldr	r3, [sp, #20]
3000c710:	e5d33000 	ldrb	r3, [r3]
3000c714:	e1a02003 	mov	r2, r3
3000c718:	e59d3008 	ldr	r3, [sp, #8]
3000c71c:	e1520003 	cmp	r2, r3
3000c720:	1a000001 	bne	3000c72c <acoral_memscan+0x3c>
			return (void *) p;
3000c724:	e59d3014 	ldr	r3, [sp, #20]
3000c728:	ea000009 	b	3000c754 <acoral_memscan+0x64>
		p++;
3000c72c:	e59d3014 	ldr	r3, [sp, #20]
3000c730:	e2833001 	add	r3, r3, #1
3000c734:	e58d3014 	str	r3, [sp, #20]
		size--;
3000c738:	e59d3004 	ldr	r3, [sp, #4]
3000c73c:	e2433001 	sub	r3, r3, #1
3000c740:	e58d3004 	str	r3, [sp, #4]
 */
void * acoral_memscan(void * addr, acoral_32 c, acoral_u32 size)
{
	acoral_u8 * p = (acoral_u8 *) addr;

	while (size) {
3000c744:	e59d3004 	ldr	r3, [sp, #4]
3000c748:	e3530000 	cmp	r3, #0
3000c74c:	1affffee 	bne	3000c70c <acoral_memscan+0x1c>
		if (*p == c)
			return (void *) p;
		p++;
		size--;
	}
  	return (void *) p;
3000c750:	e59d3014 	ldr	r3, [sp, #20]
}
3000c754:	e1a00003 	mov	r0, r3
3000c758:	e28dd018 	add	sp, sp, #24
3000c75c:	e12fff1e 	bx	lr

3000c760 <acoral_strstr>:
 * acoral_strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
acoral_char * acoral_strstr(const acoral_char * s1,const acoral_char * s2)
{
3000c760:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000c764:	e24dd014 	sub	sp, sp, #20
3000c768:	e58d0004 	str	r0, [sp, #4]
3000c76c:	e58d1000 	str	r1, [sp]
	acoral_32 l1, l2;

	l2 = acoral_str_len(s2);
3000c770:	e59d0000 	ldr	r0, [sp]
3000c774:	ebfffc69 	bl	3000b920 <acoral_str_len>
3000c778:	e1a03000 	mov	r3, r0
3000c77c:	e58d300c 	str	r3, [sp, #12]
	if (!l2)
3000c780:	e59d300c 	ldr	r3, [sp, #12]
3000c784:	e3530000 	cmp	r3, #0
3000c788:	1a000001 	bne	3000c794 <acoral_strstr+0x34>
		return (acoral_char *) s1;
3000c78c:	e59d3004 	ldr	r3, [sp, #4]
3000c790:	ea000019 	b	3000c7fc <acoral_strstr+0x9c>
	l1 = acoral_str_len(s1);
3000c794:	e59d0004 	ldr	r0, [sp, #4]
3000c798:	ebfffc60 	bl	3000b920 <acoral_str_len>
3000c79c:	e1a03000 	mov	r3, r0
3000c7a0:	e58d3008 	str	r3, [sp, #8]
	while (l1 >= l2) {
3000c7a4:	ea00000f 	b	3000c7e8 <acoral_strstr+0x88>
		l1--;
3000c7a8:	e59d3008 	ldr	r3, [sp, #8]
3000c7ac:	e2433001 	sub	r3, r3, #1
3000c7b0:	e58d3008 	str	r3, [sp, #8]
		if (!acoral_memcmp(s1,s2,l2))
3000c7b4:	e59d300c 	ldr	r3, [sp, #12]
3000c7b8:	e59d0004 	ldr	r0, [sp, #4]
3000c7bc:	e59d1000 	ldr	r1, [sp]
3000c7c0:	e1a02003 	mov	r2, r3
3000c7c4:	ebffffa2 	bl	3000c654 <acoral_memcmp>
3000c7c8:	e1a03000 	mov	r3, r0
3000c7cc:	e3530000 	cmp	r3, #0
3000c7d0:	1a000001 	bne	3000c7dc <acoral_strstr+0x7c>
			return (acoral_char *) s1;
3000c7d4:	e59d3004 	ldr	r3, [sp, #4]
3000c7d8:	ea000007 	b	3000c7fc <acoral_strstr+0x9c>
		s1++;
3000c7dc:	e59d3004 	ldr	r3, [sp, #4]
3000c7e0:	e2833001 	add	r3, r3, #1
3000c7e4:	e58d3004 	str	r3, [sp, #4]

	l2 = acoral_str_len(s2);
	if (!l2)
		return (acoral_char *) s1;
	l1 = acoral_str_len(s1);
	while (l1 >= l2) {
3000c7e8:	e59d2008 	ldr	r2, [sp, #8]
3000c7ec:	e59d300c 	ldr	r3, [sp, #12]
3000c7f0:	e1520003 	cmp	r2, r3
3000c7f4:	aaffffeb 	bge	3000c7a8 <acoral_strstr+0x48>
		l1--;
		if (!acoral_memcmp(s1,s2,l2))
			return (acoral_char *) s1;
		s1++;
	}
	return NULL;
3000c7f8:	e3a03000 	mov	r3, #0
}
3000c7fc:	e1a00003 	mov	r0, r3
3000c800:	e28dd014 	add	sp, sp, #20
3000c804:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000c808:	e12fff1e 	bx	lr

3000c80c <acoral_memchr>:
 *
 * returns the address of the first occurrence of @c, or %NULL
 * if @c is not found
 */
void *acoral_memchr(const void *s, acoral_32 c, acoral_u32 n)
{
3000c80c:	e24dd018 	sub	sp, sp, #24
3000c810:	e58d000c 	str	r0, [sp, #12]
3000c814:	e58d1008 	str	r1, [sp, #8]
3000c818:	e58d2004 	str	r2, [sp, #4]
	const acoral_u8 *p = s;
3000c81c:	e59d300c 	ldr	r3, [sp, #12]
3000c820:	e58d3014 	str	r3, [sp, #20]
	while (n-- != 0) {
3000c824:	ea00000f 	b	3000c868 <acoral_memchr+0x5c>
        	if ((acoral_u8)c == *p++) {
3000c828:	e59d3008 	ldr	r3, [sp, #8]
3000c82c:	e20320ff 	and	r2, r3, #255	; 0xff
3000c830:	e59d3014 	ldr	r3, [sp, #20]
3000c834:	e5d33000 	ldrb	r3, [r3]
3000c838:	e1520003 	cmp	r2, r3
3000c83c:	13a03000 	movne	r3, #0
3000c840:	03a03001 	moveq	r3, #1
3000c844:	e20330ff 	and	r3, r3, #255	; 0xff
3000c848:	e59d2014 	ldr	r2, [sp, #20]
3000c84c:	e2822001 	add	r2, r2, #1
3000c850:	e58d2014 	str	r2, [sp, #20]
3000c854:	e3530000 	cmp	r3, #0
3000c858:	0a000002 	beq	3000c868 <acoral_memchr+0x5c>
			return (void *)(p-1);
3000c85c:	e59d3014 	ldr	r3, [sp, #20]
3000c860:	e2433001 	sub	r3, r3, #1
3000c864:	ea00000a 	b	3000c894 <acoral_memchr+0x88>
 * if @c is not found
 */
void *acoral_memchr(const void *s, acoral_32 c, acoral_u32 n)
{
	const acoral_u8 *p = s;
	while (n-- != 0) {
3000c868:	e59d3004 	ldr	r3, [sp, #4]
3000c86c:	e3530000 	cmp	r3, #0
3000c870:	03a03000 	moveq	r3, #0
3000c874:	13a03001 	movne	r3, #1
3000c878:	e20330ff 	and	r3, r3, #255	; 0xff
3000c87c:	e59d2004 	ldr	r2, [sp, #4]
3000c880:	e2422001 	sub	r2, r2, #1
3000c884:	e58d2004 	str	r2, [sp, #4]
3000c888:	e3530000 	cmp	r3, #0
3000c88c:	1affffe5 	bne	3000c828 <acoral_memchr+0x1c>
        	if ((acoral_u8)c == *p++) {
			return (void *)(p-1);
		}
	}
	return NULL;
3000c890:	e3a03000 	mov	r3, #0
}
3000c894:	e1a00003 	mov	r0, r3
3000c898:	e28dd018 	add	sp, sp, #24
3000c89c:	e12fff1e 	bx	lr

3000c8a0 <acoral_rand>:
#include<acoral.h>
static acoral_u32 rand_seed;
acoral_u32 acoral_rand(void)
{
	rand_seed=(rand_seed*123+59)%65536;
3000c8a0:	e59f3038 	ldr	r3, [pc, #56]	; 3000c8e0 <acoral_rand+0x40>
3000c8a4:	e5932000 	ldr	r2, [r3]
3000c8a8:	e1a03002 	mov	r3, r2
3000c8ac:	e1a03283 	lsl	r3, r3, #5
3000c8b0:	e0623003 	rsb	r3, r2, r3
3000c8b4:	e1a03103 	lsl	r3, r3, #2
3000c8b8:	e0623003 	rsb	r3, r2, r3
3000c8bc:	e283303b 	add	r3, r3, #59	; 0x3b
3000c8c0:	e1a03803 	lsl	r3, r3, #16
3000c8c4:	e1a03823 	lsr	r3, r3, #16
3000c8c8:	e59f2010 	ldr	r2, [pc, #16]	; 3000c8e0 <acoral_rand+0x40>
3000c8cc:	e5823000 	str	r3, [r2]
	return rand_seed;
3000c8d0:	e59f3008 	ldr	r3, [pc, #8]	; 3000c8e0 <acoral_rand+0x40>
3000c8d4:	e5933000 	ldr	r3, [r3]
}
3000c8d8:	e1a00003 	mov	r0, r3
3000c8dc:	e12fff1e 	bx	lr
3000c8e0:	300271a4 	.word	0x300271a4

3000c8e4 <acoral_rand_start>:

void acoral_rand_start(void)
{
3000c8e4:	e92d4008 	push	{r3, lr}
	rand_seed=acoral_ticks;
3000c8e8:	ebffdf05 	bl	30004504 <acoral_get_ticks>
3000c8ec:	e1a02000 	mov	r2, r0
3000c8f0:	e59f3008 	ldr	r3, [pc, #8]	; 3000c900 <acoral_rand_start+0x1c>
3000c8f4:	e5832000 	str	r2, [r3]
}
3000c8f8:	e8bd4008 	pop	{r3, lr}
3000c8fc:	e12fff1e 	bx	lr
3000c900:	300271a4 	.word	0x300271a4

3000c904 <plugin_init>:
#include<acoral.h>
#include<plugin.h>
void plugin_init(){
3000c904:	e92d4008 	push	{r3, lr}
#ifdef CFG_PLUGIN_NET
	acoral_net_lwip_init();
3000c908:	eb00002b 	bl	3000c9bc <acoral_net_lwip_init>
#endif

#ifdef CFG_PLUGIN_GUI
	acoral_gui_init();
#endif
}
3000c90c:	e8bd4008 	pop	{r3, lr}
3000c910:	e12fff1e 	bx	lr

3000c914 <my_lwip_init>:
err_t ethernetif_init(struct netif *netif);
void  tcpip_init(void (* initfunc)(void *), void *arg);
void  ethernetif_input(void *arg);

void  my_lwip_init(void)
{  	
3000c914:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000c918:	e24dd024 	sub	sp, sp, #36	; 0x24
	struct ip_addr ipaddr, netmask, gw;
	u8_t bTemp;

	tcpip_init(NULL, NULL);
3000c91c:	e3a00000 	mov	r0, #0
3000c920:	e3a01000 	mov	r1, #0
3000c924:	eb0017f1 	bl	300128f0 <tcpip_init>
	IP4_ADDR(&gw, 192,168,1,1);
3000c928:	e3a00c01 	mov	r0, #256	; 0x100
3000c92c:	e2800107 	add	r0, r0, #-1073741823	; 0xc0000001
3000c930:	e280072a 	add	r0, r0, #11010048	; 0xa80000
3000c934:	eb001bff 	bl	30013938 <htonl>
3000c938:	e1a03000 	mov	r3, r0
3000c93c:	e58d3010 	str	r3, [sp, #16]
	IP4_ADDR(&ipaddr, 192,168,1,177);
3000c940:	e3a00e1b 	mov	r0, #432	; 0x1b0
3000c944:	e2800107 	add	r0, r0, #-1073741823	; 0xc0000001
3000c948:	e280072a 	add	r0, r0, #11010048	; 0xa80000
3000c94c:	eb001bf9 	bl	30013938 <htonl>
3000c950:	e1a03000 	mov	r3, r0
3000c954:	e58d3018 	str	r3, [sp, #24]
	IP4_ADDR(&netmask, 255,255,255,0);
3000c958:	e3e000ff 	mvn	r0, #255	; 0xff
3000c95c:	eb001bf5 	bl	30013938 <htonl>
3000c960:	e1a03000 	mov	r3, r0
3000c964:	e58d3014 	str	r3, [sp, #20]
	netif_add(&net_if, &ipaddr, &netmask, &gw, NULL, ethernetif_init, tcpip_input);  
3000c968:	e28d1018 	add	r1, sp, #24
3000c96c:	e28d2014 	add	r2, sp, #20
3000c970:	e28d3010 	add	r3, sp, #16
3000c974:	e3a00000 	mov	r0, #0
3000c978:	e58d0000 	str	r0, [sp]
3000c97c:	e59f002c 	ldr	r0, [pc, #44]	; 3000c9b0 <my_lwip_init+0x9c>
3000c980:	e58d0004 	str	r0, [sp, #4]
3000c984:	e59f0028 	ldr	r0, [pc, #40]	; 3000c9b4 <my_lwip_init+0xa0>
3000c988:	e58d0008 	str	r0, [sp, #8]
3000c98c:	e59f0024 	ldr	r0, [pc, #36]	; 3000c9b8 <my_lwip_init+0xa4>
3000c990:	eb0023ac 	bl	30015848 <netif_add>
	netif_set_default(&net_if);
3000c994:	e59f001c 	ldr	r0, [pc, #28]	; 3000c9b8 <my_lwip_init+0xa4>
3000c998:	eb0024fa 	bl	30015d88 <netif_set_default>
	netif_set_up(&net_if);	 
3000c99c:	e59f0014 	ldr	r0, [pc, #20]	; 3000c9b8 <my_lwip_init+0xa4>
3000c9a0:	eb002500 	bl	30015da8 <netif_set_up>
}
3000c9a4:	e28dd024 	add	sp, sp, #36	; 0x24
3000c9a8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000c9ac:	e12fff1e 	bx	lr
3000c9b0:	3002371c 	.word	0x3002371c
3000c9b4:	300125a4 	.word	0x300125a4
3000c9b8:	3002a83c 	.word	0x3002a83c

3000c9bc <acoral_net_lwip_init>:


void acoral_net_lwip_init()
{
3000c9bc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000c9c0:	e24dd00c 	sub	sp, sp, #12
	acoral_prints("\r\nacoral_net_lwip_init\r\m");
3000c9c4:	e59f002c 	ldr	r0, [pc, #44]	; 3000c9f8 <acoral_net_lwip_init+0x3c>
3000c9c8:	ebfffab9 	bl	3000b4b4 <acoral_prints>
	my_lwip_init();
3000c9cc:	ebffffd0 	bl	3000c914 <my_lwip_init>
	sys_thread_new("RecvData", ethernetif_input, &net_if, 512, ETH_RECV_TASK_PPIO);
3000c9d0:	e3a03014 	mov	r3, #20
3000c9d4:	e58d3000 	str	r3, [sp]
3000c9d8:	e59f001c 	ldr	r0, [pc, #28]	; 3000c9fc <acoral_net_lwip_init+0x40>
3000c9dc:	e59f101c 	ldr	r1, [pc, #28]	; 3000ca00 <acoral_net_lwip_init+0x44>
3000c9e0:	e59f201c 	ldr	r2, [pc, #28]	; 3000ca04 <acoral_net_lwip_init+0x48>
3000c9e4:	e3a03c02 	mov	r3, #512	; 0x200
3000c9e8:	eb0000db 	bl	3000cd5c <sys_thread_new>
}
3000c9ec:	e28dd00c 	add	sp, sp, #12
3000c9f0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000c9f4:	e12fff1e 	bx	lr
3000c9f8:	30026470 	.word	0x30026470
3000c9fc:	3002648c 	.word	0x3002648c
3000ca00:	30023614 	.word	0x30023614
3000ca04:	3002a83c 	.word	0x3002a83c

3000ca08 <sys_init>:

/*-----------------------------
   void sys_init()
 */
void sys_init(void)
{
3000ca08:	e24dd008 	sub	sp, sp, #8
	int i;
	
    timeoutslist = &nulltimeouts;
3000ca0c:	e59f30a4 	ldr	r3, [pc, #164]	; 3000cab8 <sys_init+0xb0>
3000ca10:	e59f20a4 	ldr	r2, [pc, #164]	; 3000cabc <sys_init+0xb4>
3000ca14:	e5832000 	str	r2, [r3]
    
    nulltimeouts.timeouts.next = NULL; 
3000ca18:	e59f309c 	ldr	r3, [pc, #156]	; 3000cabc <sys_init+0xb4>
3000ca1c:	e3a02000 	mov	r2, #0
3000ca20:	e5832000 	str	r2, [r3]
    
    nulltimeouts.next = NULL;
3000ca24:	e59f3090 	ldr	r3, [pc, #144]	; 3000cabc <sys_init+0xb4>
3000ca28:	e3a02000 	mov	r2, #0
3000ca2c:	e5832008 	str	r2, [r3, #8]
    
    /* timeoutnodes init */
    timeoutnodes.flag = 0;
3000ca30:	e59f3088 	ldr	r3, [pc, #136]	; 3000cac0 <sys_init+0xb8>
3000ca34:	e3a02000 	mov	r2, #0
3000ca38:	e5832048 	str	r2, [r3, #72]	; 0x48
    for(i=0; i<TCPIP_THREAD_MAXNUM; i++)
3000ca3c:	e3a03000 	mov	r3, #0
3000ca40:	e58d3004 	str	r3, [sp, #4]
3000ca44:	ea000016 	b	3000caa4 <sys_init+0x9c>
    {
    	timeoutnodes.p[i].next = NULL;  /*初始化为未使用*/
3000ca48:	e59d2004 	ldr	r2, [sp, #4]
3000ca4c:	e59f006c 	ldr	r0, [pc, #108]	; 3000cac0 <sys_init+0xb8>
3000ca50:	e3a01008 	mov	r1, #8
3000ca54:	e1a03002 	mov	r3, r2
3000ca58:	e1a03083 	lsl	r3, r3, #1
3000ca5c:	e0833002 	add	r3, r3, r2
3000ca60:	e1a03103 	lsl	r3, r3, #2
3000ca64:	e0833000 	add	r3, r3, r0
3000ca68:	e0833001 	add	r3, r3, r1
3000ca6c:	e3a02000 	mov	r2, #0
3000ca70:	e5832000 	str	r2, [r3]
    	timeoutnodes.p[i].timeouts.next = NULL;
3000ca74:	e59d2004 	ldr	r2, [sp, #4]
3000ca78:	e59f1040 	ldr	r1, [pc, #64]	; 3000cac0 <sys_init+0xb8>
3000ca7c:	e1a03002 	mov	r3, r2
3000ca80:	e1a03083 	lsl	r3, r3, #1
3000ca84:	e0833002 	add	r3, r3, r2
3000ca88:	e1a03103 	lsl	r3, r3, #2
3000ca8c:	e0833001 	add	r3, r3, r1
3000ca90:	e3a02000 	mov	r2, #0
3000ca94:	e5832000 	str	r2, [r3]
    
    nulltimeouts.next = NULL;
    
    /* timeoutnodes init */
    timeoutnodes.flag = 0;
    for(i=0; i<TCPIP_THREAD_MAXNUM; i++)
3000ca98:	e59d3004 	ldr	r3, [sp, #4]
3000ca9c:	e2833001 	add	r3, r3, #1
3000caa0:	e58d3004 	str	r3, [sp, #4]
3000caa4:	e59d3004 	ldr	r3, [sp, #4]
3000caa8:	e3530004 	cmp	r3, #4
3000caac:	daffffe5 	ble	3000ca48 <sys_init+0x40>
    {
    	timeoutnodes.p[i].next = NULL;  /*初始化为未使用*/
    	timeoutnodes.p[i].timeouts.next = NULL;
    }
    
}
3000cab0:	e28dd008 	add	sp, sp, #8
3000cab4:	e12fff1e 	bx	lr
3000cab8:	3002b1b0 	.word	0x3002b1b0
3000cabc:	3002a0a4 	.word	0x3002a0a4
3000cac0:	3002b1c8 	.word	0x3002b1c8

3000cac4 <sys_sem_new>:

/*----------------------------
	sys_sem_t sys_sem_new(u8_t count)
 */
sys_sem_t sys_sem_new(u8_t count)
{
3000cac4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cac8:	e24dd00c 	sub	sp, sp, #12
3000cacc:	e1a03000 	mov	r3, r0
3000cad0:	e5cd3007 	strb	r3, [sp, #7]
	return acoral_sem_create(count);
3000cad4:	e5dd3007 	ldrb	r3, [sp, #7]
3000cad8:	e1a00003 	mov	r0, r3
3000cadc:	ebffeafb 	bl	300076d0 <acoral_sem_create>
3000cae0:	e1a03000 	mov	r3, r0
}
3000cae4:	e1a00003 	mov	r0, r3
3000cae8:	e28dd00c 	add	sp, sp, #12
3000caec:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000caf0:	e12fff1e 	bx	lr

3000caf4 <sys_sem_free>:

/*------------------------------
   void sys_sem_free(sys_sem_t sem)
 */
void sys_sem_free(sys_sem_t sem)
{
3000caf4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000caf8:	e24dd00c 	sub	sp, sp, #12
3000cafc:	e58d0004 	str	r0, [sp, #4]
	acoral_sem_del(sem, 0);
3000cb00:	e59d0004 	ldr	r0, [sp, #4]
3000cb04:	e3a01000 	mov	r1, #0
3000cb08:	ebffeb0e 	bl	30007748 <acoral_sem_del>
}
3000cb0c:	e28dd00c 	add	sp, sp, #12
3000cb10:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000cb14:	e12fff1e 	bx	lr

3000cb18 <sys_sem_signal>:

/*--------------------------------
   void sys_sem_signal(sys_sem_t sem)
 */
void sys_sem_signal(sys_sem_t sem)
{
3000cb18:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cb1c:	e24dd00c 	sub	sp, sp, #12
3000cb20:	e58d0004 	str	r0, [sp, #4]
	acoral_sem_post(sem);
3000cb24:	e59d0004 	ldr	r0, [sp, #4]
3000cb28:	ebffebcb 	bl	30007a5c <acoral_sem_post>
}
3000cb2c:	e28dd00c 	add	sp, sp, #12
3000cb30:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000cb34:	e12fff1e 	bx	lr

3000cb38 <sys_arch_sem_wait>:

/*----------------------------------
   u32_t sys_arch_sem_wait(sys_sem_t sem, u32_t timeout)
 */
u32_t sys_arch_sem_wait(sys_sem_t sem, u32_t timeout)
{
3000cb38:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cb3c:	e24dd00c 	sub	sp, sp, #12
3000cb40:	e58d0004 	str	r0, [sp, #4]
3000cb44:	e58d1000 	str	r1, [sp]
	if(SEM_SUCCED == acoral_sem_pend(sem, timeout))
3000cb48:	e59d0004 	ldr	r0, [sp, #4]
3000cb4c:	e59d1000 	ldr	r1, [sp]
3000cb50:	ebffeb56 	bl	300078b0 <acoral_sem_pend>
3000cb54:	e1a03000 	mov	r3, r0
3000cb58:	e3530000 	cmp	r3, #0
3000cb5c:	1a000001 	bne	3000cb68 <sys_arch_sem_wait+0x30>
		return 0;
3000cb60:	e3a03000 	mov	r3, #0
3000cb64:	ea000000 	b	3000cb6c <sys_arch_sem_wait+0x34>
	else
		return SYS_ARCH_TIMEOUT;
3000cb68:	e3e03000 	mvn	r3, #0
}
3000cb6c:	e1a00003 	mov	r0, r3
3000cb70:	e28dd00c 	add	sp, sp, #12
3000cb74:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000cb78:	e12fff1e 	bx	lr

3000cb7c <sys_mbox_new>:

/*---------------------------------
   sys_mbox_t sys_mbox_new()
 */
sys_mbox_t sys_mbox_new(int size)
{
3000cb7c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cb80:	e24dd014 	sub	sp, sp, #20
3000cb84:	e58d0004 	str	r0, [sp, #4]
	u32_t  err;
	return acoral_msgctr_create(&err);
3000cb88:	e28d300c 	add	r3, sp, #12
3000cb8c:	e1a00003 	mov	r0, r3
3000cb90:	ebffecf0 	bl	30007f58 <acoral_msgctr_create>
3000cb94:	e1a03000 	mov	r3, r0
	//return acoral_mbox_create();
}
3000cb98:	e1a00003 	mov	r0, r3
3000cb9c:	e28dd014 	add	sp, sp, #20
3000cba0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000cba4:	e12fff1e 	bx	lr

3000cba8 <sys_mbox_free>:

/*--------------------------------
   void sys_mbox_free(sys_mbox_t mbox)
 */
void sys_mbox_free(sys_mbox_t mbox)
{
3000cba8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cbac:	e24dd00c 	sub	sp, sp, #12
3000cbb0:	e58d0004 	str	r0, [sp, #4]
	acoral_msgctr_del(mbox, 1);
3000cbb4:	e59d0004 	ldr	r0, [sp, #4]
3000cbb8:	e3a01001 	mov	r1, #1
3000cbbc:	ebffee21 	bl	30008448 <acoral_msgctr_del>
	//acoral_mbox_del(mbox);
}
3000cbc0:	e28dd00c 	add	sp, sp, #12
3000cbc4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000cbc8:	e12fff1e 	bx	lr

3000cbcc <sys_mbox_post>:

/*--------------------------------
   void sys_mbox_post(sys_mbox_t  mbox, void *msg)
 */
void sys_mbox_post(sys_mbox_t mbox, void* msg)
{
3000cbcc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cbd0:	e24dd024 	sub	sp, sp, #36	; 0x24
3000cbd4:	e58d000c 	str	r0, [sp, #12]
3000cbd8:	e58d1008 	str	r1, [sp, #8]
	u32_t err;
	u32_t id = 1;
3000cbdc:	e3a03001 	mov	r3, #1
3000cbe0:	e58d3018 	str	r3, [sp, #24]
	sys_msg_t pmsg = acoral_msg_create(1, &err, id, 0, msg);
3000cbe4:	e28d3014 	add	r3, sp, #20
3000cbe8:	e59d2008 	ldr	r2, [sp, #8]
3000cbec:	e58d2000 	str	r2, [sp]
3000cbf0:	e3a00001 	mov	r0, #1
3000cbf4:	e1a01003 	mov	r1, r3
3000cbf8:	e59d2018 	ldr	r2, [sp, #24]
3000cbfc:	e3a03000 	mov	r3, #0
3000cc00:	ebffed0e 	bl	30008040 <acoral_msg_create>
3000cc04:	e1a03000 	mov	r3, r0
3000cc08:	e58d301c 	str	r3, [sp, #28]
	if (NULL != pmsg)
3000cc0c:	e59d301c 	ldr	r3, [sp, #28]
3000cc10:	e3530000 	cmp	r3, #0
3000cc14:	0a000002 	beq	3000cc24 <sys_mbox_post+0x58>
		acoral_msg_send(mbox, pmsg);
3000cc18:	e59d000c 	ldr	r0, [sp, #12]
3000cc1c:	e59d101c 	ldr	r1, [sp, #28]
3000cc20:	ebffed2d 	bl	300080dc <acoral_msg_send>
	//acoral_mbox_send(mbox,msg);
}
3000cc24:	e28dd024 	add	sp, sp, #36	; 0x24
3000cc28:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000cc2c:	e12fff1e 	bx	lr

3000cc30 <sys_mbox_trypost>:

/*--------------------------------
   err_t sys_mbox_trypost(sys_mbox_t  mbox, void *msg)
 */
err_t sys_mbox_trypost(sys_mbox_t mbox, void* msg)
{
3000cc30:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cc34:	e24dd024 	sub	sp, sp, #36	; 0x24
3000cc38:	e58d000c 	str	r0, [sp, #12]
3000cc3c:	e58d1008 	str	r1, [sp, #8]
	u32_t err;
	u32_t id = 1;
3000cc40:	e3a03001 	mov	r3, #1
3000cc44:	e58d3018 	str	r3, [sp, #24]
	sys_msg_t pmsg = acoral_msg_create(1, &err, id, 0, msg);
3000cc48:	e28d3014 	add	r3, sp, #20
3000cc4c:	e59d2008 	ldr	r2, [sp, #8]
3000cc50:	e58d2000 	str	r2, [sp]
3000cc54:	e3a00001 	mov	r0, #1
3000cc58:	e1a01003 	mov	r1, r3
3000cc5c:	e59d2018 	ldr	r2, [sp, #24]
3000cc60:	e3a03000 	mov	r3, #0
3000cc64:	ebffecf5 	bl	30008040 <acoral_msg_create>
3000cc68:	e1a03000 	mov	r3, r0
3000cc6c:	e58d301c 	str	r3, [sp, #28]
	if (NULL != pmsg)
3000cc70:	e59d301c 	ldr	r3, [sp, #28]
3000cc74:	e3530000 	cmp	r3, #0
3000cc78:	0a000002 	beq	3000cc88 <sys_mbox_trypost+0x58>
		acoral_msg_send(mbox, pmsg);
3000cc7c:	e59d000c 	ldr	r0, [sp, #12]
3000cc80:	e59d101c 	ldr	r1, [sp, #28]
3000cc84:	ebffed14 	bl	300080dc <acoral_msg_send>
	//acoral_mbox_send(mbox,msg);
	return ERR_OK;
3000cc88:	e3a03000 	mov	r3, #0
3000cc8c:	e1a03c03 	lsl	r3, r3, #24
3000cc90:	e1a03c43 	asr	r3, r3, #24
}
3000cc94:	e1a00003 	mov	r0, r3
3000cc98:	e28dd024 	add	sp, sp, #36	; 0x24
3000cc9c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000cca0:	e12fff1e 	bx	lr

3000cca4 <sys_arch_mbox_fetch>:

/*---------------------------------
   u32_t sys_arch_mbox_fetch(sys_mbox_t mbox, void** msg, u32_t timeout)
 */
u32_t sys_arch_mbox_fetch(sys_mbox_t mbox, void** msg, u32_t timeout)
{
3000cca4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cca8:	e24dd01c 	sub	sp, sp, #28
3000ccac:	e58d000c 	str	r0, [sp, #12]
3000ccb0:	e58d1008 	str	r1, [sp, #8]
3000ccb4:	e58d2004 	str	r2, [sp, #4]

	u32_t err;
	u32_t id = 1;
3000ccb8:	e3a03001 	mov	r3, #1
3000ccbc:	e58d3014 	str	r3, [sp, #20]
	*msg = acoral_msg_recv(mbox, id, timeout, &err);
3000ccc0:	e28d3010 	add	r3, sp, #16
3000ccc4:	e59d000c 	ldr	r0, [sp, #12]
3000ccc8:	e59d1014 	ldr	r1, [sp, #20]
3000cccc:	e59d2004 	ldr	r2, [sp, #4]
3000ccd0:	ebffed46 	bl	300081f0 <acoral_msg_recv>
3000ccd4:	e1a02000 	mov	r2, r0
3000ccd8:	e59d3008 	ldr	r3, [sp, #8]
3000ccdc:	e5832000 	str	r2, [r3]
	//*msg = acoral_mbox_recv(mbox, timeout);
	if (*msg == NULL)
3000cce0:	e59d3008 	ldr	r3, [sp, #8]
3000cce4:	e5933000 	ldr	r3, [r3]
3000cce8:	e3530000 	cmp	r3, #0
3000ccec:	1a000001 	bne	3000ccf8 <sys_arch_mbox_fetch+0x54>
		return SYS_ARCH_TIMEOUT;
3000ccf0:	e3e03000 	mvn	r3, #0
3000ccf4:	ea000000 	b	3000ccfc <sys_arch_mbox_fetch+0x58>
	else
		return 0;
3000ccf8:	e3a03000 	mov	r3, #0
}
3000ccfc:	e1a00003 	mov	r0, r3
3000cd00:	e28dd01c 	add	sp, sp, #28
3000cd04:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000cd08:	e12fff1e 	bx	lr

3000cd0c <getTONAvai>:


int getTONAvai()
{
3000cd0c:	e24dd008 	sub	sp, sp, #8
	int ret;
    
    if(timeoutnodes.flag < TCPIP_THREAD_MAXNUM)
3000cd10:	e59f3040 	ldr	r3, [pc, #64]	; 3000cd58 <getTONAvai+0x4c>
3000cd14:	e5933048 	ldr	r3, [r3, #72]	; 0x48
3000cd18:	e3530004 	cmp	r3, #4
3000cd1c:	ca000009 	bgt	3000cd48 <getTONAvai+0x3c>
    {
	    ret =timeoutnodes.flag;
3000cd20:	e59f3030 	ldr	r3, [pc, #48]	; 3000cd58 <getTONAvai+0x4c>
3000cd24:	e5933048 	ldr	r3, [r3, #72]	; 0x48
3000cd28:	e58d3004 	str	r3, [sp, #4]
    
    	timeoutnodes.flag += 1;
3000cd2c:	e59f3024 	ldr	r3, [pc, #36]	; 3000cd58 <getTONAvai+0x4c>
3000cd30:	e5933048 	ldr	r3, [r3, #72]	; 0x48
3000cd34:	e2832001 	add	r2, r3, #1
3000cd38:	e59f3018 	ldr	r3, [pc, #24]	; 3000cd58 <getTONAvai+0x4c>
3000cd3c:	e5832048 	str	r2, [r3, #72]	; 0x48
    	return ret;
3000cd40:	e59d3004 	ldr	r3, [sp, #4]
3000cd44:	ea000000 	b	3000cd4c <getTONAvai+0x40>
    }
   	return TCPIP_THREAD_MAXNUM;
3000cd48:	e3a03005 	mov	r3, #5
}
3000cd4c:	e1a00003 	mov	r0, r3
3000cd50:	e28dd008 	add	sp, sp, #8
3000cd54:	e12fff1e 	bx	lr
3000cd58:	3002b1c8 	.word	0x3002b1c8

3000cd5c <sys_thread_new>:

/*----------------------------------
   sys_thread_t sys_thread_new(void(*thread)(void* arg), void *arg, int prio)
 */
sys_thread_t sys_thread_new(char *name, void (* thread)(void *arg), void *arg, int stacksize, int prio)
{
3000cd5c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cd60:	e24dd02c 	sub	sp, sp, #44	; 0x2c
3000cd64:	e58d0014 	str	r0, [sp, #20]
3000cd68:	e58d1010 	str	r1, [sp, #16]
3000cd6c:	e58d200c 	str	r2, [sp, #12]
3000cd70:	e58d3008 	str	r3, [sp, #8]
		sys_thread_t tmp;
		int          i;
		struct timeoutnode * pto;
		SYS_ARCH_DECL_PROTECT(x);
		
		tmp =  acoral_create_thread(thread, TCPIP_THREAD_STACKSIZE, arg, NULL, prio, 0 );
3000cd74:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3000cd78:	e20330ff 	and	r3, r3, #255	; 0xff
3000cd7c:	e58d3000 	str	r3, [sp]
3000cd80:	e3a03000 	mov	r3, #0
3000cd84:	e58d3004 	str	r3, [sp, #4]
3000cd88:	e59d0010 	ldr	r0, [sp, #16]
3000cd8c:	e3a01a01 	mov	r1, #4096	; 0x1000
3000cd90:	e59d200c 	ldr	r2, [sp, #12]
3000cd94:	e3a03000 	mov	r3, #0
3000cd98:	ebffd87b 	bl	30002f8c <create_comm_thread>
3000cd9c:	e1a03000 	mov	r3, r0
3000cda0:	e58d3018 	str	r3, [sp, #24]
		i   = getTONAvai();
3000cda4:	ebffffd8 	bl	3000cd0c <getTONAvai>
3000cda8:	e1a03000 	mov	r3, r0
3000cdac:	e58d301c 	str	r3, [sp, #28]
		if (i >= TCPIP_THREAD_MAXNUM)
3000cdb0:	e59d301c 	ldr	r3, [sp, #28]
3000cdb4:	e3530004 	cmp	r3, #4
3000cdb8:	da000001 	ble	3000cdc4 <sys_thread_new+0x68>
			return 0;
3000cdbc:	e3a03000 	mov	r3, #0
3000cdc0:	ea00001c 	b	3000ce38 <sys_thread_new+0xdc>
			
		pto = &timeoutnodes.p[i];
3000cdc4:	e59d201c 	ldr	r2, [sp, #28]
3000cdc8:	e1a03002 	mov	r3, r2
3000cdcc:	e1a03083 	lsl	r3, r3, #1
3000cdd0:	e0833002 	add	r3, r3, r2
3000cdd4:	e1a03103 	lsl	r3, r3, #2
3000cdd8:	e1a02003 	mov	r2, r3
3000cddc:	e59f3064 	ldr	r3, [pc, #100]	; 3000ce48 <sys_thread_new+0xec>
3000cde0:	e0823003 	add	r3, r2, r3
3000cde4:	e58d3020 	str	r3, [sp, #32]
		
		pto->prio = prio;
3000cde8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3000cdec:	e20320ff 	and	r2, r3, #255	; 0xff
3000cdf0:	e59d3020 	ldr	r3, [sp, #32]
3000cdf4:	e5c32004 	strb	r2, [r3, #4]
		    
		pto->timeouts.next = NULL;
3000cdf8:	e59d3020 	ldr	r3, [sp, #32]
3000cdfc:	e3a02000 	mov	r2, #0
3000ce00:	e5832000 	str	r2, [r3]
       	SYS_ARCH_PROTECT(x)
3000ce04:	ebffd23a 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000ce08:	e1a03000 	mov	r3, r0
3000ce0c:	e58d3024 	str	r3, [sp, #36]	; 0x24
	    pto->next = timeoutslist;
3000ce10:	e59f3034 	ldr	r3, [pc, #52]	; 3000ce4c <sys_thread_new+0xf0>
3000ce14:	e5932000 	ldr	r2, [r3]
3000ce18:	e59d3020 	ldr	r3, [sp, #32]
3000ce1c:	e5832008 	str	r2, [r3, #8]
		timeoutslist = pto;
3000ce20:	e59f3024 	ldr	r3, [pc, #36]	; 3000ce4c <sys_thread_new+0xf0>
3000ce24:	e59d2020 	ldr	r2, [sp, #32]
3000ce28:	e5832000 	str	r2, [r3]
      	SYS_ARCH_UNPROTECT(x)
3000ce2c:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3000ce30:	ebffd22d 	bl	300016ec <HAL_INTR_RESTORE>
		
		return tmp;	
3000ce34:	e59d3018 	ldr	r3, [sp, #24]

}
3000ce38:	e1a00003 	mov	r0, r3
3000ce3c:	e28dd02c 	add	sp, sp, #44	; 0x2c
3000ce40:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000ce44:	e12fff1e 	bx	lr
3000ce48:	3002b1c8 	.word	0x3002b1c8
3000ce4c:	3002b1b0 	.word	0x3002b1b0

3000ce50 <sys_arch_timeouts>:
* 输　	 入 : 无
*        
* 输　	 出 : struct sys_timeouts *: 线程的超时结构
********************************************/
struct sys_timeouts * sys_arch_timeouts(void)
{
3000ce50:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000ce54:	e24dd014 	sub	sp, sp, #20
    struct timeoutnode * pto = timeoutslist;
3000ce58:	e59f3078 	ldr	r3, [pc, #120]	; 3000ced8 <sys_arch_timeouts+0x88>
3000ce5c:	e5933000 	ldr	r3, [r3]
3000ce60:	e58d3004 	str	r3, [sp, #4]
   	u8_t curprio;	    
	SYS_ARCH_DECL_PROTECT(cpusr);

	SYS_ARCH_PROTECT(cpusr);
3000ce64:	ebffd222 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000ce68:	e1a03000 	mov	r3, r0
3000ce6c:	e58d300c 	str	r3, [sp, #12]
	curprio = acoral_cur_thread->prio;
3000ce70:	e59f3064 	ldr	r3, [pc, #100]	; 3000cedc <sys_arch_timeouts+0x8c>
3000ce74:	e5933000 	ldr	r3, [r3]
3000ce78:	e5d33005 	ldrb	r3, [r3, #5]
3000ce7c:	e5cd300b 	strb	r3, [sp, #11]
    SYS_ARCH_UNPROTECT(cpusr);
3000ce80:	e59d000c 	ldr	r0, [sp, #12]
3000ce84:	ebffd218 	bl	300016ec <HAL_INTR_RESTORE>
           	    
    while (pto != &nulltimeouts)
3000ce88:	ea000009 	b	3000ceb4 <sys_arch_timeouts+0x64>
    {
    	if (pto->prio == curprio)
3000ce8c:	e59d3004 	ldr	r3, [sp, #4]
3000ce90:	e5d33004 	ldrb	r3, [r3, #4]
3000ce94:	e5dd200b 	ldrb	r2, [sp, #11]
3000ce98:	e1520003 	cmp	r2, r3
3000ce9c:	1a000001 	bne	3000cea8 <sys_arch_timeouts+0x58>
    	{
    		return &(pto->timeouts);
3000cea0:	e59d3004 	ldr	r3, [sp, #4]
3000cea4:	ea000007 	b	3000cec8 <sys_arch_timeouts+0x78>
    	}
    	else
    	{
    		pto = pto->next;
3000cea8:	e59d3004 	ldr	r3, [sp, #4]
3000ceac:	e5933008 	ldr	r3, [r3, #8]
3000ceb0:	e58d3004 	str	r3, [sp, #4]

	SYS_ARCH_PROTECT(cpusr);
	curprio = acoral_cur_thread->prio;
    SYS_ARCH_UNPROTECT(cpusr);
           	    
    while (pto != &nulltimeouts)
3000ceb4:	e59d2004 	ldr	r2, [sp, #4]
3000ceb8:	e59f3020 	ldr	r3, [pc, #32]	; 3000cee0 <sys_arch_timeouts+0x90>
3000cebc:	e1520003 	cmp	r2, r3
3000cec0:	1afffff1 	bne	3000ce8c <sys_arch_timeouts+0x3c>
    	{
    		pto = pto->next;
    	}
    }

    return &(pto->timeouts);
3000cec4:	e59d3004 	ldr	r3, [sp, #4]
}
3000cec8:	e1a00003 	mov	r0, r3
3000cecc:	e28dd014 	add	sp, sp, #20
3000ced0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000ced4:	e12fff1e 	bx	lr
3000ced8:	3002b1b0 	.word	0x3002b1b0
3000cedc:	3002b350 	.word	0x3002b350
3000cee0:	3002a0a4 	.word	0x3002a0a4

3000cee4 <__re_memset>:



void __re_memset(void* head, u8_t c, s32_t len)
{
3000cee4:	e24dd018 	sub	sp, sp, #24
3000cee8:	e58d000c 	str	r0, [sp, #12]
3000ceec:	e1a03001 	mov	r3, r1
3000cef0:	e58d2004 	str	r2, [sp, #4]
3000cef4:	e5cd300b 	strb	r3, [sp, #11]
	int i = len;;
3000cef8:	e59d3004 	ldr	r3, [sp, #4]
3000cefc:	e58d3014 	str	r3, [sp, #20]
	while(i--)
3000cf00:	ea000005 	b	3000cf1c <__re_memset+0x38>
	{
		*((u8_t*)head++) = c;
3000cf04:	e59d300c 	ldr	r3, [sp, #12]
3000cf08:	e5dd200b 	ldrb	r2, [sp, #11]
3000cf0c:	e5c32000 	strb	r2, [r3]
3000cf10:	e59d300c 	ldr	r3, [sp, #12]
3000cf14:	e2833001 	add	r3, r3, #1
3000cf18:	e58d300c 	str	r3, [sp, #12]


void __re_memset(void* head, u8_t c, s32_t len)
{
	int i = len;;
	while(i--)
3000cf1c:	e59d3014 	ldr	r3, [sp, #20]
3000cf20:	e3530000 	cmp	r3, #0
3000cf24:	03a03000 	moveq	r3, #0
3000cf28:	13a03001 	movne	r3, #1
3000cf2c:	e20330ff 	and	r3, r3, #255	; 0xff
3000cf30:	e59d2014 	ldr	r2, [sp, #20]
3000cf34:	e2422001 	sub	r2, r2, #1
3000cf38:	e58d2014 	str	r2, [sp, #20]
3000cf3c:	e3530000 	cmp	r3, #0
3000cf40:	1affffef 	bne	3000cf04 <__re_memset+0x20>
	{
		*((u8_t*)head++) = c;
	}
}
3000cf44:	e28dd018 	add	sp, sp, #24
3000cf48:	e12fff1e 	bx	lr

3000cf4c <__re_memcpy>:

void __re_memcpy(void* src, const void* des, s32_t len)
{
3000cf4c:	e24dd018 	sub	sp, sp, #24
3000cf50:	e58d000c 	str	r0, [sp, #12]
3000cf54:	e58d1008 	str	r1, [sp, #8]
3000cf58:	e58d2004 	str	r2, [sp, #4]
	int i = len;
3000cf5c:	e59d3004 	ldr	r3, [sp, #4]
3000cf60:	e58d3014 	str	r3, [sp, #20]
	while(i--)
3000cf64:	ea000009 	b	3000cf90 <__re_memcpy+0x44>
	{
		*((u8_t*)src++) = *((u8_t*)des++);
3000cf68:	e59d300c 	ldr	r3, [sp, #12]
3000cf6c:	e59d2008 	ldr	r2, [sp, #8]
3000cf70:	e5d22000 	ldrb	r2, [r2]
3000cf74:	e5c32000 	strb	r2, [r3]
3000cf78:	e59d300c 	ldr	r3, [sp, #12]
3000cf7c:	e2833001 	add	r3, r3, #1
3000cf80:	e58d300c 	str	r3, [sp, #12]
3000cf84:	e59d3008 	ldr	r3, [sp, #8]
3000cf88:	e2833001 	add	r3, r3, #1
3000cf8c:	e58d3008 	str	r3, [sp, #8]
}

void __re_memcpy(void* src, const void* des, s32_t len)
{
	int i = len;
	while(i--)
3000cf90:	e59d3014 	ldr	r3, [sp, #20]
3000cf94:	e3530000 	cmp	r3, #0
3000cf98:	03a03000 	moveq	r3, #0
3000cf9c:	13a03001 	movne	r3, #1
3000cfa0:	e20330ff 	and	r3, r3, #255	; 0xff
3000cfa4:	e59d2014 	ldr	r2, [sp, #20]
3000cfa8:	e2422001 	sub	r2, r2, #1
3000cfac:	e58d2014 	str	r2, [sp, #20]
3000cfb0:	e3530000 	cmp	r3, #0
3000cfb4:	1affffeb 	bne	3000cf68 <__re_memcpy+0x1c>
	{
		*((u8_t*)src++) = *((u8_t*)des++);
	}
}
3000cfb8:	e28dd018 	add	sp, sp, #24
3000cfbc:	e12fff1e 	bx	lr

3000cfc0 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
3000cfc0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cfc4:	e24dd024 	sub	sp, sp, #36	; 0x24
3000cfc8:	e1a03001 	mov	r3, r1
3000cfcc:	e58d2000 	str	r2, [sp]
3000cfd0:	e1a02000 	mov	r2, r0
3000cfd4:	e5cd2007 	strb	r2, [sp, #7]
3000cfd8:	e5cd3006 	strb	r3, [sp, #6]
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
3000cfdc:	e5dd3007 	ldrb	r3, [sp, #7]
3000cfe0:	e1a00003 	mov	r0, r3
3000cfe4:	e59d1000 	ldr	r1, [sp]
3000cfe8:	eb000477 	bl	3000e1cc <netconn_alloc>
3000cfec:	e1a03000 	mov	r3, r0
3000cff0:	e58d301c 	str	r3, [sp, #28]
  if (conn != NULL ) {
3000cff4:	e59d301c 	ldr	r3, [sp, #28]
3000cff8:	e3530000 	cmp	r3, #0
3000cffc:	0a000019 	beq	3000d068 <netconn_new_with_proto_and_callback+0xa8>
    msg.function = do_newconn;
3000d000:	e59f3074 	ldr	r3, [pc, #116]	; 3000d07c <netconn_new_with_proto_and_callback+0xbc>
3000d004:	e58d3008 	str	r3, [sp, #8]
    msg.msg.msg.n.proto = proto;
3000d008:	e5dd3006 	ldrb	r3, [sp, #6]
3000d00c:	e5cd3010 	strb	r3, [sp, #16]
    msg.msg.conn = conn;
3000d010:	e59d301c 	ldr	r3, [sp, #28]
3000d014:	e58d300c 	str	r3, [sp, #12]
    TCPIP_APIMSG(&msg);
3000d018:	e28d3008 	add	r3, sp, #8
3000d01c:	e1a00003 	mov	r0, r3
3000d020:	eb001611 	bl	3001286c <tcpip_apimsg>

    if (conn->err != ERR_OK) {
3000d024:	e59d301c 	ldr	r3, [sp, #28]
3000d028:	e5d33008 	ldrb	r3, [r3, #8]
3000d02c:	e3530000 	cmp	r3, #0
3000d030:	0a00000c 	beq	3000d068 <netconn_new_with_proto_and_callback+0xa8>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
      sys_sem_free(conn->op_completed);
3000d034:	e59d301c 	ldr	r3, [sp, #28]
3000d038:	e593300c 	ldr	r3, [r3, #12]
3000d03c:	e1a00003 	mov	r0, r3
3000d040:	ebfffeab 	bl	3000caf4 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
3000d044:	e59d301c 	ldr	r3, [sp, #28]
3000d048:	e5933010 	ldr	r3, [r3, #16]
3000d04c:	e1a00003 	mov	r0, r3
3000d050:	ebfffed4 	bl	3000cba8 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
3000d054:	e3a00006 	mov	r0, #6
3000d058:	e59d101c 	ldr	r1, [sp, #28]
3000d05c:	eb0021c8 	bl	30015784 <memp_free>
      return NULL;
3000d060:	e3a03000 	mov	r3, #0
3000d064:	ea000000 	b	3000d06c <netconn_new_with_proto_and_callback+0xac>
    }
  }
  return conn;
3000d068:	e59d301c 	ldr	r3, [sp, #28]
}
3000d06c:	e1a00003 	mov	r0, r3
3000d070:	e28dd024 	add	sp, sp, #36	; 0x24
3000d074:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d078:	e12fff1e 	bx	lr
3000d07c:	3000e184 	.word	0x3000e184

3000d080 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
3000d080:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d084:	e24dd024 	sub	sp, sp, #36	; 0x24
3000d088:	e58d0004 	str	r0, [sp, #4]
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
3000d08c:	e59d3004 	ldr	r3, [sp, #4]
3000d090:	e3530000 	cmp	r3, #0
3000d094:	1a000001 	bne	3000d0a0 <netconn_delete+0x20>
    return ERR_OK;
3000d098:	e3a03000 	mov	r3, #0
3000d09c:	ea00000c 	b	3000d0d4 <netconn_delete+0x54>
  }

  msg.function = do_delconn;
3000d0a0:	e59f3044 	ldr	r3, [pc, #68]	; 3000d0ec <netconn_delete+0x6c>
3000d0a4:	e58d300c 	str	r3, [sp, #12]
  msg.msg.conn = conn;
3000d0a8:	e59d3004 	ldr	r3, [sp, #4]
3000d0ac:	e58d3010 	str	r3, [sp, #16]
  tcpip_apimsg(&msg);
3000d0b0:	e28d300c 	add	r3, sp, #12
3000d0b4:	e1a00003 	mov	r0, r3
3000d0b8:	eb0015eb 	bl	3001286c <tcpip_apimsg>

  conn->pcb.tcp = NULL;
3000d0bc:	e59d3004 	ldr	r3, [sp, #4]
3000d0c0:	e3a02000 	mov	r2, #0
3000d0c4:	e5832004 	str	r2, [r3, #4]
  netconn_free(conn);
3000d0c8:	e59d0004 	ldr	r0, [sp, #4]
3000d0cc:	eb00048b 	bl	3000e300 <netconn_free>

  return ERR_OK;
3000d0d0:	e3a03000 	mov	r3, #0
3000d0d4:	e1a03c03 	lsl	r3, r3, #24
3000d0d8:	e1a03c43 	asr	r3, r3, #24
}
3000d0dc:	e1a00003 	mov	r0, r3
3000d0e0:	e28dd024 	add	sp, sp, #36	; 0x24
3000d0e4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d0e8:	e12fff1e 	bx	lr
3000d0ec:	3000e5c4 	.word	0x3000e5c4

3000d0f0 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
3000d0f0:	e24dd008 	sub	sp, sp, #8
3000d0f4:	e58d0004 	str	r0, [sp, #4]
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  return conn->type;
3000d0f8:	e59d3004 	ldr	r3, [sp, #4]
3000d0fc:	e5d33000 	ldrb	r3, [r3]
}
3000d100:	e1a00003 	mov	r0, r3
3000d104:	e28dd008 	add	sp, sp, #8
3000d108:	e12fff1e 	bx	lr

3000d10c <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
3000d10c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d110:	e24dd02c 	sub	sp, sp, #44	; 0x2c
3000d114:	e58d000c 	str	r0, [sp, #12]
3000d118:	e58d1008 	str	r1, [sp, #8]
3000d11c:	e58d2004 	str	r2, [sp, #4]
3000d120:	e5cd3003 	strb	r3, [sp, #3]

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);

  msg.function = do_getaddr;
3000d124:	e59f304c 	ldr	r3, [pc, #76]	; 3000d178 <netconn_getaddr+0x6c>
3000d128:	e58d3014 	str	r3, [sp, #20]
  msg.msg.conn = conn;
3000d12c:	e59d300c 	ldr	r3, [sp, #12]
3000d130:	e58d3018 	str	r3, [sp, #24]
  msg.msg.msg.ad.ipaddr = addr;
3000d134:	e59d3008 	ldr	r3, [sp, #8]
3000d138:	e58d301c 	str	r3, [sp, #28]
  msg.msg.msg.ad.port = port;
3000d13c:	e59d3004 	ldr	r3, [sp, #4]
3000d140:	e58d3020 	str	r3, [sp, #32]
  msg.msg.msg.ad.local = local;
3000d144:	e5dd3003 	ldrb	r3, [sp, #3]
3000d148:	e5cd3024 	strb	r3, [sp, #36]	; 0x24
  TCPIP_APIMSG(&msg);
3000d14c:	e28d3014 	add	r3, sp, #20
3000d150:	e1a00003 	mov	r0, r3
3000d154:	eb0015c4 	bl	3001286c <tcpip_apimsg>

  return conn->err;
3000d158:	e59d300c 	ldr	r3, [sp, #12]
3000d15c:	e5d33008 	ldrb	r3, [r3, #8]
3000d160:	e1a03c03 	lsl	r3, r3, #24
3000d164:	e1a03c43 	asr	r3, r3, #24
}
3000d168:	e1a00003 	mov	r0, r3
3000d16c:	e28dd02c 	add	sp, sp, #44	; 0x2c
3000d170:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d174:	e12fff1e 	bx	lr
3000d178:	3000f280 	.word	0x3000f280

3000d17c <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
3000d17c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d180:	e24dd02c 	sub	sp, sp, #44	; 0x2c
3000d184:	e58d000c 	str	r0, [sp, #12]
3000d188:	e58d1008 	str	r1, [sp, #8]
3000d18c:	e1a03002 	mov	r3, r2
3000d190:	e1cd30b6 	strh	r3, [sp, #6]
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);

  msg.function = do_bind;
3000d194:	e59f3044 	ldr	r3, [pc, #68]	; 3000d1e0 <netconn_bind+0x64>
3000d198:	e58d3014 	str	r3, [sp, #20]
  msg.msg.conn = conn;
3000d19c:	e59d300c 	ldr	r3, [sp, #12]
3000d1a0:	e58d3018 	str	r3, [sp, #24]
  msg.msg.msg.bc.ipaddr = addr;
3000d1a4:	e59d3008 	ldr	r3, [sp, #8]
3000d1a8:	e58d301c 	str	r3, [sp, #28]
  msg.msg.msg.bc.port = port;
3000d1ac:	e1dd30b6 	ldrh	r3, [sp, #6]
3000d1b0:	e1cd32b0 	strh	r3, [sp, #32]
  TCPIP_APIMSG(&msg);
3000d1b4:	e28d3014 	add	r3, sp, #20
3000d1b8:	e1a00003 	mov	r0, r3
3000d1bc:	eb0015aa 	bl	3001286c <tcpip_apimsg>
  return conn->err;
3000d1c0:	e59d300c 	ldr	r3, [sp, #12]
3000d1c4:	e5d33008 	ldrb	r3, [r3, #8]
3000d1c8:	e1a03c03 	lsl	r3, r3, #24
3000d1cc:	e1a03c43 	asr	r3, r3, #24
}
3000d1d0:	e1a00003 	mov	r0, r3
3000d1d4:	e28dd02c 	add	sp, sp, #44	; 0x2c
3000d1d8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d1dc:	e12fff1e 	bx	lr
3000d1e0:	3000e724 	.word	0x3000e724

3000d1e4 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
3000d1e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d1e8:	e24dd02c 	sub	sp, sp, #44	; 0x2c
3000d1ec:	e58d000c 	str	r0, [sp, #12]
3000d1f0:	e58d1008 	str	r1, [sp, #8]
3000d1f4:	e1a03002 	mov	r3, r2
3000d1f8:	e1cd30b6 	strh	r3, [sp, #6]
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);

  msg.function = do_connect;
3000d1fc:	e59f3044 	ldr	r3, [pc, #68]	; 3000d248 <netconn_connect+0x64>
3000d200:	e58d3014 	str	r3, [sp, #20]
  msg.msg.conn = conn;
3000d204:	e59d300c 	ldr	r3, [sp, #12]
3000d208:	e58d3018 	str	r3, [sp, #24]
  msg.msg.msg.bc.ipaddr = addr;
3000d20c:	e59d3008 	ldr	r3, [sp, #8]
3000d210:	e58d301c 	str	r3, [sp, #28]
  msg.msg.msg.bc.port = port;
3000d214:	e1dd30b6 	ldrh	r3, [sp, #6]
3000d218:	e1cd32b0 	strh	r3, [sp, #32]
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
3000d21c:	e28d3014 	add	r3, sp, #20
3000d220:	e1a00003 	mov	r0, r3
3000d224:	eb001590 	bl	3001286c <tcpip_apimsg>
  return conn->err;
3000d228:	e59d300c 	ldr	r3, [sp, #12]
3000d22c:	e5d33008 	ldrb	r3, [r3, #8]
3000d230:	e1a03c03 	lsl	r3, r3, #24
3000d234:	e1a03c43 	asr	r3, r3, #24
}
3000d238:	e1a00003 	mov	r0, r3
3000d23c:	e28dd02c 	add	sp, sp, #44	; 0x2c
3000d240:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d244:	e12fff1e 	bx	lr
3000d248:	3000e91c 	.word	0x3000e91c

3000d24c <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
3000d24c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d250:	e24dd024 	sub	sp, sp, #36	; 0x24
3000d254:	e58d0004 	str	r0, [sp, #4]
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);

  msg.function = do_disconnect;
3000d258:	e59f3034 	ldr	r3, [pc, #52]	; 3000d294 <netconn_disconnect+0x48>
3000d25c:	e58d300c 	str	r3, [sp, #12]
  msg.msg.conn = conn;
3000d260:	e59d3004 	ldr	r3, [sp, #4]
3000d264:	e58d3010 	str	r3, [sp, #16]
  TCPIP_APIMSG(&msg);
3000d268:	e28d300c 	add	r3, sp, #12
3000d26c:	e1a00003 	mov	r0, r3
3000d270:	eb00157d 	bl	3001286c <tcpip_apimsg>
  return conn->err;
3000d274:	e59d3004 	ldr	r3, [sp, #4]
3000d278:	e5d33008 	ldrb	r3, [r3, #8]
3000d27c:	e1a03c03 	lsl	r3, r3, #24
3000d280:	e1a03c43 	asr	r3, r3, #24
}
3000d284:	e1a00003 	mov	r0, r3
3000d288:	e28dd024 	add	sp, sp, #36	; 0x24
3000d28c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d290:	e12fff1e 	bx	lr
3000d294:	3000ea98 	.word	0x3000ea98

3000d298 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
3000d298:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d29c:	e24dd024 	sub	sp, sp, #36	; 0x24
3000d2a0:	e58d0004 	str	r0, [sp, #4]
3000d2a4:	e1a03001 	mov	r3, r1
3000d2a8:	e5cd3003 	strb	r3, [sp, #3]
  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);

  msg.function = do_listen;
3000d2ac:	e59f3034 	ldr	r3, [pc, #52]	; 3000d2e8 <netconn_listen_with_backlog+0x50>
3000d2b0:	e58d300c 	str	r3, [sp, #12]
  msg.msg.conn = conn;
3000d2b4:	e59d3004 	ldr	r3, [sp, #4]
3000d2b8:	e58d3010 	str	r3, [sp, #16]
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
3000d2bc:	e28d300c 	add	r3, sp, #12
3000d2c0:	e1a00003 	mov	r0, r3
3000d2c4:	eb001568 	bl	3001286c <tcpip_apimsg>
  return conn->err;
3000d2c8:	e59d3004 	ldr	r3, [sp, #4]
3000d2cc:	e5d33008 	ldrb	r3, [r3, #8]
3000d2d0:	e1a03c03 	lsl	r3, r3, #24
3000d2d4:	e1a03c43 	asr	r3, r3, #24
}
3000d2d8:	e1a00003 	mov	r0, r3
3000d2dc:	e28dd024 	add	sp, sp, #36	; 0x24
3000d2e0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d2e4:	e12fff1e 	bx	lr
3000d2e8:	3000eaf0 	.word	0x3000eaf0

3000d2ec <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
3000d2ec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d2f0:	e24dd014 	sub	sp, sp, #20
3000d2f4:	e58d0004 	str	r0, [sp, #4]
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
3000d2f8:	e59d3004 	ldr	r3, [sp, #4]
3000d2fc:	e5932014 	ldr	r2, [r3, #20]
3000d300:	e28d300c 	add	r3, sp, #12
3000d304:	e1a00002 	mov	r0, r2
3000d308:	e1a01003 	mov	r1, r3
3000d30c:	e3a02000 	mov	r2, #0
3000d310:	ebfffe63 	bl	3000cca4 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
3000d314:	e59d3004 	ldr	r3, [sp, #4]
3000d318:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d31c:	e3530000 	cmp	r3, #0
3000d320:	0a000006 	beq	3000d340 <netconn_accept+0x54>
3000d324:	e59d3004 	ldr	r3, [sp, #4]
3000d328:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d32c:	e59d0004 	ldr	r0, [sp, #4]
3000d330:	e3a01001 	mov	r1, #1
3000d334:	e3a02000 	mov	r2, #0
3000d338:	e1a0e00f 	mov	lr, pc
3000d33c:	e12fff13 	bx	r3
      TCPIP_APIMSG(&msg);
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
3000d340:	e59d300c 	ldr	r3, [sp, #12]
}
3000d344:	e1a00003 	mov	r0, r3
3000d348:	e28dd014 	add	sp, sp, #20
3000d34c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d350:	e12fff1e 	bx	lr

3000d354 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
3000d354:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d358:	e24dd034 	sub	sp, sp, #52	; 0x34
3000d35c:	e58d0004 	str	r0, [sp, #4]
  struct api_msg msg;
  struct netbuf *buf = NULL;
3000d360:	e3a03000 	mov	r3, #0
3000d364:	e58d300c 	str	r3, [sp, #12]
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);

  if (conn->recvmbox == SYS_MBOX_NULL) {
3000d368:	e59d3004 	ldr	r3, [sp, #4]
3000d36c:	e5933010 	ldr	r3, [r3, #16]
3000d370:	e3530000 	cmp	r3, #0
3000d374:	1a000004 	bne	3000d38c <netconn_recv+0x38>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
3000d378:	e59d3004 	ldr	r3, [sp, #4]
3000d37c:	e3e02006 	mvn	r2, #6
3000d380:	e5c32008 	strb	r2, [r3, #8]
    return NULL;
3000d384:	e3a03000 	mov	r3, #0
3000d388:	ea00009d 	b	3000d604 <netconn_recv+0x2b0>
  }

  if (ERR_IS_FATAL(conn->err)) {
3000d38c:	e59d3004 	ldr	r3, [sp, #4]
3000d390:	e5d33008 	ldrb	r3, [r3, #8]
3000d394:	e1a03c03 	lsl	r3, r3, #24
3000d398:	e1a03c43 	asr	r3, r3, #24
3000d39c:	e3730003 	cmn	r3, #3
3000d3a0:	aa000001 	bge	3000d3ac <netconn_recv+0x58>
    return NULL;
3000d3a4:	e3a03000 	mov	r3, #0
3000d3a8:	ea000095 	b	3000d604 <netconn_recv+0x2b0>
  }

  if (conn->type == NETCONN_TCP) {
3000d3ac:	e59d3004 	ldr	r3, [sp, #4]
3000d3b0:	e5d33000 	ldrb	r3, [r3]
3000d3b4:	e3530010 	cmp	r3, #16
3000d3b8:	1a00006a 	bne	3000d568 <netconn_recv+0x214>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
3000d3bc:	e59d3004 	ldr	r3, [sp, #4]
3000d3c0:	e5d33001 	ldrb	r3, [r3, #1]
3000d3c4:	e3530002 	cmp	r3, #2
3000d3c8:	1a000004 	bne	3000d3e0 <netconn_recv+0x8c>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
3000d3cc:	e59d3004 	ldr	r3, [sp, #4]
3000d3d0:	e3e02006 	mvn	r2, #6
3000d3d4:	e5c32008 	strb	r2, [r3, #8]
      return NULL;
3000d3d8:	e3a03000 	mov	r3, #0
3000d3dc:	ea000088 	b	3000d604 <netconn_recv+0x2b0>
    }

    buf = memp_malloc(MEMP_NETBUF);
3000d3e0:	e3a00005 	mov	r0, #5
3000d3e4:	eb002081 	bl	300155f0 <memp_malloc>
3000d3e8:	e1a03000 	mov	r3, r0
3000d3ec:	e58d300c 	str	r3, [sp, #12]

    if (buf == NULL) {
3000d3f0:	e59d300c 	ldr	r3, [sp, #12]
3000d3f4:	e3530000 	cmp	r3, #0
3000d3f8:	1a000004 	bne	3000d410 <netconn_recv+0xbc>
      conn->err = ERR_MEM;
3000d3fc:	e59d3004 	ldr	r3, [sp, #4]
3000d400:	e3e02000 	mvn	r2, #0
3000d404:	e5c32008 	strb	r2, [r3, #8]
      return NULL;
3000d408:	e3a03000 	mov	r3, #0
3000d40c:	ea00007c 	b	3000d604 <netconn_recv+0x2b0>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
3000d410:	e59d3004 	ldr	r3, [sp, #4]
3000d414:	e5932010 	ldr	r2, [r3, #16]
3000d418:	e28d3008 	add	r3, sp, #8
3000d41c:	e1a00002 	mov	r0, r2
3000d420:	e1a01003 	mov	r1, r3
3000d424:	e3a02000 	mov	r2, #0
3000d428:	ebfffe1d 	bl	3000cca4 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
3000d42c:	e59d3008 	ldr	r3, [sp, #8]
3000d430:	e3530000 	cmp	r3, #0
3000d434:	0a000010 	beq	3000d47c <netconn_recv+0x128>
      len = p->tot_len;
3000d438:	e59d3008 	ldr	r3, [sp, #8]
3000d43c:	e1d330b8 	ldrh	r3, [r3, #8]
3000d440:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
      SYS_ARCH_DEC(conn->recv_avail, len);
3000d444:	ebffd0aa 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000d448:	e1a03000 	mov	r3, r0
3000d44c:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000d450:	e59d3004 	ldr	r3, [sp, #4]
3000d454:	e1d321bc 	ldrh	r2, [r3, #28]
3000d458:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3000d45c:	e0633002 	rsb	r3, r3, r2
3000d460:	e1a03803 	lsl	r3, r3, #16
3000d464:	e1a02823 	lsr	r2, r3, #16
3000d468:	e59d3004 	ldr	r3, [sp, #4]
3000d46c:	e1c321bc 	strh	r2, [r3, #28]
3000d470:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
3000d474:	ebffd09c 	bl	300016ec <HAL_INTR_RESTORE>
3000d478:	ea000001 	b	3000d484 <netconn_recv+0x130>
    } else {
      len = 0;
3000d47c:	e3a03000 	mov	r3, #0
3000d480:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
3000d484:	e59d3004 	ldr	r3, [sp, #4]
3000d488:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d48c:	e3530000 	cmp	r3, #0
3000d490:	0a000006 	beq	3000d4b0 <netconn_recv+0x15c>
3000d494:	e59d3004 	ldr	r3, [sp, #4]
3000d498:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d49c:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
3000d4a0:	e59d0004 	ldr	r0, [sp, #4]
3000d4a4:	e3a01001 	mov	r1, #1
3000d4a8:	e1a0e00f 	mov	lr, pc
3000d4ac:	e12fff13 	bx	r3

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
3000d4b0:	e59d3008 	ldr	r3, [sp, #8]
3000d4b4:	e3530000 	cmp	r3, #0
3000d4b8:	1a00000c 	bne	3000d4f0 <netconn_recv+0x19c>
      memp_free(MEMP_NETBUF, buf);
3000d4bc:	e59d300c 	ldr	r3, [sp, #12]
3000d4c0:	e3a00005 	mov	r0, #5
3000d4c4:	e1a01003 	mov	r1, r3
3000d4c8:	eb0020ad 	bl	30015784 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
3000d4cc:	e59d3004 	ldr	r3, [sp, #4]
3000d4d0:	e5d33008 	ldrb	r3, [r3, #8]
3000d4d4:	e3530000 	cmp	r3, #0
3000d4d8:	1a000002 	bne	3000d4e8 <netconn_recv+0x194>
        conn->err = ERR_CLSD;
3000d4dc:	e59d3004 	ldr	r3, [sp, #4]
3000d4e0:	e3e02005 	mvn	r2, #5
3000d4e4:	e5c32008 	strb	r2, [r3, #8]
      }
      return NULL;
3000d4e8:	e3a03000 	mov	r3, #0
3000d4ec:	ea000044 	b	3000d604 <netconn_recv+0x2b0>
    }

    buf->p = p;
3000d4f0:	e59d300c 	ldr	r3, [sp, #12]
3000d4f4:	e59d2008 	ldr	r2, [sp, #8]
3000d4f8:	e5832000 	str	r2, [r3]
    buf->ptr = p;
3000d4fc:	e59d300c 	ldr	r3, [sp, #12]
3000d500:	e59d2008 	ldr	r2, [sp, #8]
3000d504:	e5832004 	str	r2, [r3, #4]
    buf->port = 0;
3000d508:	e59d300c 	ldr	r3, [sp, #12]
3000d50c:	e3a02000 	mov	r2, #0
3000d510:	e1c320bc 	strh	r2, [r3, #12]
    buf->addr = NULL;
3000d514:	e59d300c 	ldr	r3, [sp, #12]
3000d518:	e3a02000 	mov	r2, #0
3000d51c:	e5832008 	str	r2, [r3, #8]

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
3000d520:	e59f30ec 	ldr	r3, [pc, #236]	; 3000d614 <netconn_recv+0x2c0>
3000d524:	e58d3010 	str	r3, [sp, #16]
    msg.msg.conn = conn;
3000d528:	e59d3004 	ldr	r3, [sp, #4]
3000d52c:	e58d3014 	str	r3, [sp, #20]
    if (buf != NULL) {
3000d530:	e59d300c 	ldr	r3, [sp, #12]
3000d534:	e3530000 	cmp	r3, #0
3000d538:	0a000004 	beq	3000d550 <netconn_recv+0x1fc>
      msg.msg.msg.r.len = buf->p->tot_len;
3000d53c:	e59d300c 	ldr	r3, [sp, #12]
3000d540:	e5933000 	ldr	r3, [r3]
3000d544:	e1d330b8 	ldrh	r3, [r3, #8]
3000d548:	e1cd31b8 	strh	r3, [sp, #24]
3000d54c:	ea000001 	b	3000d558 <netconn_recv+0x204>
    } else {
      msg.msg.msg.r.len = 1;
3000d550:	e3a03001 	mov	r3, #1
3000d554:	e1cd31b8 	strh	r3, [sp, #24]
    }
    TCPIP_APIMSG(&msg);
3000d558:	e28d3010 	add	r3, sp, #16
3000d55c:	e1a00003 	mov	r0, r3
3000d560:	eb0014c1 	bl	3001286c <tcpip_apimsg>
3000d564:	ea000025 	b	3000d600 <netconn_recv+0x2ac>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
3000d568:	e59d3004 	ldr	r3, [sp, #4]
3000d56c:	e5932010 	ldr	r2, [r3, #16]
3000d570:	e28d300c 	add	r3, sp, #12
3000d574:	e1a00002 	mov	r0, r2
3000d578:	e1a01003 	mov	r1, r3
3000d57c:	e3a02000 	mov	r2, #0
3000d580:	ebfffdc7 	bl	3000cca4 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
3000d584:	e59d300c 	ldr	r3, [sp, #12]
3000d588:	e3530000 	cmp	r3, #0
3000d58c:	0a00001b 	beq	3000d600 <netconn_recv+0x2ac>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
3000d590:	ebffd057 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000d594:	e1a03000 	mov	r3, r0
3000d598:	e58d302c 	str	r3, [sp, #44]	; 0x2c
3000d59c:	e59d3004 	ldr	r3, [sp, #4]
3000d5a0:	e1d321bc 	ldrh	r2, [r3, #28]
3000d5a4:	e59d300c 	ldr	r3, [sp, #12]
3000d5a8:	e5933000 	ldr	r3, [r3]
3000d5ac:	e1d330b8 	ldrh	r3, [r3, #8]
3000d5b0:	e0633002 	rsb	r3, r3, r2
3000d5b4:	e1a03803 	lsl	r3, r3, #16
3000d5b8:	e1a02823 	lsr	r2, r3, #16
3000d5bc:	e59d3004 	ldr	r3, [sp, #4]
3000d5c0:	e1c321bc 	strh	r2, [r3, #28]
3000d5c4:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
3000d5c8:	ebffd047 	bl	300016ec <HAL_INTR_RESTORE>
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
3000d5cc:	e59d3004 	ldr	r3, [sp, #4]
3000d5d0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d5d4:	e3530000 	cmp	r3, #0
3000d5d8:	0a000008 	beq	3000d600 <netconn_recv+0x2ac>
3000d5dc:	e59d3004 	ldr	r3, [sp, #4]
3000d5e0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d5e4:	e59d200c 	ldr	r2, [sp, #12]
3000d5e8:	e5922000 	ldr	r2, [r2]
3000d5ec:	e1d220b8 	ldrh	r2, [r2, #8]
3000d5f0:	e59d0004 	ldr	r0, [sp, #4]
3000d5f4:	e3a01001 	mov	r1, #1
3000d5f8:	e1a0e00f 	mov	lr, pc
3000d5fc:	e12fff13 	bx	r3
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
3000d600:	e59d300c 	ldr	r3, [sp, #12]
}
3000d604:	e1a00003 	mov	r0, r3
3000d608:	e28dd034 	add	sp, sp, #52	; 0x34
3000d60c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d610:	e12fff1e 	bx	lr
3000d614:	3000ee74 	.word	0x3000ee74

3000d618 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
3000d618:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d61c:	e24dd014 	sub	sp, sp, #20
3000d620:	e58d000c 	str	r0, [sp, #12]
3000d624:	e58d1008 	str	r1, [sp, #8]
3000d628:	e58d2004 	str	r2, [sp, #4]
3000d62c:	e1cd30b2 	strh	r3, [sp, #2]
  if (buf != NULL) {
3000d630:	e59d3008 	ldr	r3, [sp, #8]
3000d634:	e3530000 	cmp	r3, #0
3000d638:	0a00000c 	beq	3000d670 <netconn_sendto+0x58>
    buf->addr = addr;
3000d63c:	e59d3008 	ldr	r3, [sp, #8]
3000d640:	e59d2004 	ldr	r2, [sp, #4]
3000d644:	e5832008 	str	r2, [r3, #8]
    buf->port = port;
3000d648:	e59d3008 	ldr	r3, [sp, #8]
3000d64c:	e1dd20b2 	ldrh	r2, [sp, #2]
3000d650:	e1c320bc 	strh	r2, [r3, #12]
    return netconn_send(conn, buf);
3000d654:	e59d000c 	ldr	r0, [sp, #12]
3000d658:	e59d1008 	ldr	r1, [sp, #8]
3000d65c:	eb00000a 	bl	3000d68c <netconn_send>
3000d660:	e1a03000 	mov	r3, r0
3000d664:	e20330ff 	and	r3, r3, #255	; 0xff
3000d668:	e20330ff 	and	r3, r3, #255	; 0xff
3000d66c:	ea000000 	b	3000d674 <netconn_sendto+0x5c>
  }
  return ERR_VAL;
3000d670:	e3a030f8 	mov	r3, #248	; 0xf8
3000d674:	e1a03c03 	lsl	r3, r3, #24
3000d678:	e1a03c43 	asr	r3, r3, #24
}
3000d67c:	e1a00003 	mov	r0, r3
3000d680:	e28dd014 	add	sp, sp, #20
3000d684:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d688:	e12fff1e 	bx	lr

3000d68c <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
3000d68c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d690:	e24dd024 	sub	sp, sp, #36	; 0x24
3000d694:	e58d0004 	str	r0, [sp, #4]
3000d698:	e58d1000 	str	r1, [sp]
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
3000d69c:	e59f303c 	ldr	r3, [pc, #60]	; 3000d6e0 <netconn_send+0x54>
3000d6a0:	e58d300c 	str	r3, [sp, #12]
  msg.msg.conn = conn;
3000d6a4:	e59d3004 	ldr	r3, [sp, #4]
3000d6a8:	e58d3010 	str	r3, [sp, #16]
  msg.msg.msg.b = buf;
3000d6ac:	e59d3000 	ldr	r3, [sp]
3000d6b0:	e58d3014 	str	r3, [sp, #20]
  TCPIP_APIMSG(&msg);
3000d6b4:	e28d300c 	add	r3, sp, #12
3000d6b8:	e1a00003 	mov	r0, r3
3000d6bc:	eb00146a 	bl	3001286c <tcpip_apimsg>
  return conn->err;
3000d6c0:	e59d3004 	ldr	r3, [sp, #4]
3000d6c4:	e5d33008 	ldrb	r3, [r3, #8]
3000d6c8:	e1a03c03 	lsl	r3, r3, #24
3000d6cc:	e1a03c43 	asr	r3, r3, #24
}
3000d6d0:	e1a00003 	mov	r0, r3
3000d6d4:	e28dd024 	add	sp, sp, #36	; 0x24
3000d6d8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d6dc:	e12fff1e 	bx	lr
3000d6e0:	3000ecc4 	.word	0x3000ecc4

3000d6e4 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
3000d6e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d6e8:	e24dd02c 	sub	sp, sp, #44	; 0x2c
3000d6ec:	e58d000c 	str	r0, [sp, #12]
3000d6f0:	e58d1008 	str	r1, [sp, #8]
3000d6f4:	e58d2004 	str	r2, [sp, #4]
3000d6f8:	e5cd3003 	strb	r3, [sp, #3]
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);

  msg.function = do_write;
3000d6fc:	e59f304c 	ldr	r3, [pc, #76]	; 3000d750 <netconn_write+0x6c>
3000d700:	e58d3014 	str	r3, [sp, #20]
  msg.msg.conn = conn;
3000d704:	e59d300c 	ldr	r3, [sp, #12]
3000d708:	e58d3018 	str	r3, [sp, #24]
  msg.msg.msg.w.dataptr = dataptr;
3000d70c:	e59d3008 	ldr	r3, [sp, #8]
3000d710:	e58d301c 	str	r3, [sp, #28]
  msg.msg.msg.w.apiflags = apiflags;
3000d714:	e5dd3003 	ldrb	r3, [sp, #3]
3000d718:	e5cd3024 	strb	r3, [sp, #36]	; 0x24
  msg.msg.msg.w.len = size;
3000d71c:	e59d3004 	ldr	r3, [sp, #4]
3000d720:	e58d3020 	str	r3, [sp, #32]
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  //acoral_prints("\r\nnetconnWrite\r\n");
  TCPIP_APIMSG(&msg);
3000d724:	e28d3014 	add	r3, sp, #20
3000d728:	e1a00003 	mov	r0, r3
3000d72c:	eb00144e 	bl	3001286c <tcpip_apimsg>
  return conn->err;
3000d730:	e59d300c 	ldr	r3, [sp, #12]
3000d734:	e5d33008 	ldrb	r3, [r3, #8]
3000d738:	e1a03c03 	lsl	r3, r3, #24
3000d73c:	e1a03c43 	asr	r3, r3, #24
}
3000d740:	e1a00003 	mov	r0, r3
3000d744:	e28dd02c 	add	sp, sp, #44	; 0x2c
3000d748:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d74c:	e12fff1e 	bx	lr
3000d750:	3000f1bc 	.word	0x3000f1bc

3000d754 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
3000d754:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d758:	e24dd024 	sub	sp, sp, #36	; 0x24
3000d75c:	e58d0004 	str	r0, [sp, #4]
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);

  msg.function = do_close;
3000d760:	e59f3034 	ldr	r3, [pc, #52]	; 3000d79c <netconn_close+0x48>
3000d764:	e58d300c 	str	r3, [sp, #12]
  msg.msg.conn = conn;
3000d768:	e59d3004 	ldr	r3, [sp, #4]
3000d76c:	e58d3010 	str	r3, [sp, #16]
  tcpip_apimsg(&msg);
3000d770:	e28d300c 	add	r3, sp, #12
3000d774:	e1a00003 	mov	r0, r3
3000d778:	eb00143b 	bl	3001286c <tcpip_apimsg>
  return conn->err;
3000d77c:	e59d3004 	ldr	r3, [sp, #4]
3000d780:	e5d33008 	ldrb	r3, [r3, #8]
3000d784:	e1a03c03 	lsl	r3, r3, #24
3000d788:	e1a03c43 	asr	r3, r3, #24
}
3000d78c:	e1a00003 	mov	r0, r3
3000d790:	e28dd024 	add	sp, sp, #36	; 0x24
3000d794:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d798:	e12fff1e 	bx	lr
3000d79c:	3000f43c 	.word	0x3000f43c

3000d7a0 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
3000d7a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d7a4:	e24dd024 	sub	sp, sp, #36	; 0x24
3000d7a8:	e58d000c 	str	r0, [sp, #12]
3000d7ac:	e58d1008 	str	r1, [sp, #8]
3000d7b0:	e58d2004 	str	r2, [sp, #4]
3000d7b4:	e58d3000 	str	r3, [sp]
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
3000d7b8:	e59d300c 	ldr	r3, [sp, #12]
3000d7bc:	e58d3018 	str	r3, [sp, #24]
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
3000d7c0:	e59d3018 	ldr	r3, [sp, #24]
3000d7c4:	e3530000 	cmp	r3, #0
3000d7c8:	0a00005c 	beq	3000d940 <recv_raw+0x1a0>
3000d7cc:	e59d3018 	ldr	r3, [sp, #24]
3000d7d0:	e5933010 	ldr	r3, [r3, #16]
3000d7d4:	e3530000 	cmp	r3, #0
3000d7d8:	0a000058 	beq	3000d940 <recv_raw+0x1a0>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
3000d7dc:	e59d3004 	ldr	r3, [sp, #4]
3000d7e0:	e1d330b8 	ldrh	r3, [r3, #8]
3000d7e4:	e3a00003 	mov	r0, #3
3000d7e8:	e1a01003 	mov	r1, r3
3000d7ec:	e3a02000 	mov	r2, #0
3000d7f0:	eb00219f 	bl	30015e74 <pbuf_alloc>
3000d7f4:	e1a03000 	mov	r3, r0
3000d7f8:	e58d3010 	str	r3, [sp, #16]
    if(q != NULL) {
3000d7fc:	e59d3010 	ldr	r3, [sp, #16]
3000d800:	e3530000 	cmp	r3, #0
3000d804:	0a00000a 	beq	3000d834 <recv_raw+0x94>
      if (pbuf_copy(q, p) != ERR_OK) {
3000d808:	e59d0010 	ldr	r0, [sp, #16]
3000d80c:	e59d1004 	ldr	r1, [sp, #4]
3000d810:	eb00240c 	bl	30016848 <pbuf_copy>
3000d814:	e1a03000 	mov	r3, r0
3000d818:	e20330ff 	and	r3, r3, #255	; 0xff
3000d81c:	e3530000 	cmp	r3, #0
3000d820:	0a000003 	beq	3000d834 <recv_raw+0x94>
        pbuf_free(q);
3000d824:	e59d0010 	ldr	r0, [sp, #16]
3000d828:	eb002340 	bl	30016530 <pbuf_free>
        q = NULL;
3000d82c:	e3a03000 	mov	r3, #0
3000d830:	e58d3010 	str	r3, [sp, #16]
      }
    }

    if(q != NULL) {
3000d834:	e59d3010 	ldr	r3, [sp, #16]
3000d838:	e3530000 	cmp	r3, #0
3000d83c:	0a00003f 	beq	3000d940 <recv_raw+0x1a0>
      buf = memp_malloc(MEMP_NETBUF);
3000d840:	e3a00005 	mov	r0, #5
3000d844:	eb001f69 	bl	300155f0 <memp_malloc>
3000d848:	e1a03000 	mov	r3, r0
3000d84c:	e58d3014 	str	r3, [sp, #20]
      if (buf == NULL) {
3000d850:	e59d3014 	ldr	r3, [sp, #20]
3000d854:	e3530000 	cmp	r3, #0
3000d858:	1a000003 	bne	3000d86c <recv_raw+0xcc>
        pbuf_free(q);
3000d85c:	e59d0010 	ldr	r0, [sp, #16]
3000d860:	eb002332 	bl	30016530 <pbuf_free>
        return 0;
3000d864:	e3a03000 	mov	r3, #0
3000d868:	ea000035 	b	3000d944 <recv_raw+0x1a4>
      }

      buf->p = q;
3000d86c:	e59d3014 	ldr	r3, [sp, #20]
3000d870:	e59d2010 	ldr	r2, [sp, #16]
3000d874:	e5832000 	str	r2, [r3]
      buf->ptr = q;
3000d878:	e59d3014 	ldr	r3, [sp, #20]
3000d87c:	e59d2010 	ldr	r2, [sp, #16]
3000d880:	e5832004 	str	r2, [r3, #4]
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
3000d884:	e59d3010 	ldr	r3, [sp, #16]
3000d888:	e5933004 	ldr	r3, [r3, #4]
3000d88c:	e283200c 	add	r2, r3, #12
3000d890:	e59d3014 	ldr	r3, [sp, #20]
3000d894:	e5832008 	str	r2, [r3, #8]
      buf->port = pcb->protocol;
3000d898:	e59d3008 	ldr	r3, [sp, #8]
3000d89c:	e5d33010 	ldrb	r3, [r3, #16]
3000d8a0:	e1a02003 	mov	r2, r3
3000d8a4:	e59d3014 	ldr	r3, [sp, #20]
3000d8a8:	e1c320bc 	strh	r2, [r3, #12]

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
3000d8ac:	ebffcf90 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000d8b0:	e1a03000 	mov	r3, r0
3000d8b4:	e58d301c 	str	r3, [sp, #28]
3000d8b8:	e59d3018 	ldr	r3, [sp, #24]
3000d8bc:	e1d321bc 	ldrh	r2, [r3, #28]
3000d8c0:	e59d3010 	ldr	r3, [sp, #16]
3000d8c4:	e1d330b8 	ldrh	r3, [r3, #8]
3000d8c8:	e0823003 	add	r3, r2, r3
3000d8cc:	e1a03803 	lsl	r3, r3, #16
3000d8d0:	e1a02823 	lsr	r2, r3, #16
3000d8d4:	e59d3018 	ldr	r3, [sp, #24]
3000d8d8:	e1c321bc 	strh	r2, [r3, #28]
3000d8dc:	e59d001c 	ldr	r0, [sp, #28]
3000d8e0:	ebffcf81 	bl	300016ec <HAL_INTR_RESTORE>
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
3000d8e4:	e59d3018 	ldr	r3, [sp, #24]
3000d8e8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d8ec:	e3530000 	cmp	r3, #0
3000d8f0:	0a000007 	beq	3000d914 <recv_raw+0x174>
3000d8f4:	e59d3018 	ldr	r3, [sp, #24]
3000d8f8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d8fc:	e59d2010 	ldr	r2, [sp, #16]
3000d900:	e1d220b8 	ldrh	r2, [r2, #8]
3000d904:	e59d0018 	ldr	r0, [sp, #24]
3000d908:	e3a01000 	mov	r1, #0
3000d90c:	e1a0e00f 	mov	lr, pc
3000d910:	e12fff13 	bx	r3
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
3000d914:	e59d3018 	ldr	r3, [sp, #24]
3000d918:	e5933010 	ldr	r3, [r3, #16]
3000d91c:	e1a00003 	mov	r0, r3
3000d920:	e59d1014 	ldr	r1, [sp, #20]
3000d924:	ebfffcc1 	bl	3000cc30 <sys_mbox_trypost>
3000d928:	e1a03000 	mov	r3, r0
3000d92c:	e20330ff 	and	r3, r3, #255	; 0xff
3000d930:	e3530000 	cmp	r3, #0
3000d934:	0a000001 	beq	3000d940 <recv_raw+0x1a0>
        netbuf_delete(buf);
3000d938:	e59d0014 	ldr	r0, [sp, #20]
3000d93c:	eb0006f9 	bl	3000f528 <netbuf_delete>
      }
    }
  }

  return 0; /* do not eat the packet */
3000d940:	e3a03000 	mov	r3, #0
}
3000d944:	e1a00003 	mov	r0, r3
3000d948:	e28dd024 	add	sp, sp, #36	; 0x24
3000d94c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d950:	e12fff1e 	bx	lr

3000d954 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
3000d954:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d958:	e24dd024 	sub	sp, sp, #36	; 0x24
3000d95c:	e58d000c 	str	r0, [sp, #12]
3000d960:	e58d1008 	str	r1, [sp, #8]
3000d964:	e58d2004 	str	r2, [sp, #4]
3000d968:	e58d3000 	str	r3, [sp]
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  conn = arg;
3000d96c:	e59d300c 	ldr	r3, [sp, #12]
3000d970:	e58d3018 	str	r3, [sp, #24]
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
3000d974:	e59d3018 	ldr	r3, [sp, #24]
3000d978:	e3530000 	cmp	r3, #0
3000d97c:	0a000003 	beq	3000d990 <recv_udp+0x3c>
3000d980:	e59d3018 	ldr	r3, [sp, #24]
3000d984:	e5933010 	ldr	r3, [r3, #16]
3000d988:	e3530000 	cmp	r3, #0
3000d98c:	1a000002 	bne	3000d99c <recv_udp+0x48>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
3000d990:	e59d0004 	ldr	r0, [sp, #4]
3000d994:	eb0022e5 	bl	30016530 <pbuf_free>
    return;
3000d998:	ea00003b 	b	3000da8c <recv_udp+0x138>
  }

  buf = memp_malloc(MEMP_NETBUF);
3000d99c:	e3a00005 	mov	r0, #5
3000d9a0:	eb001f12 	bl	300155f0 <memp_malloc>
3000d9a4:	e1a03000 	mov	r3, r0
3000d9a8:	e58d3014 	str	r3, [sp, #20]
  if (buf == NULL) {
3000d9ac:	e59d3014 	ldr	r3, [sp, #20]
3000d9b0:	e3530000 	cmp	r3, #0
3000d9b4:	1a000002 	bne	3000d9c4 <recv_udp+0x70>
    pbuf_free(p);
3000d9b8:	e59d0004 	ldr	r0, [sp, #4]
3000d9bc:	eb0022db 	bl	30016530 <pbuf_free>
    return;
3000d9c0:	ea000031 	b	3000da8c <recv_udp+0x138>
  } else {
    buf->p = p;
3000d9c4:	e59d3014 	ldr	r3, [sp, #20]
3000d9c8:	e59d2004 	ldr	r2, [sp, #4]
3000d9cc:	e5832000 	str	r2, [r3]
    buf->ptr = p;
3000d9d0:	e59d3014 	ldr	r3, [sp, #20]
3000d9d4:	e59d2004 	ldr	r2, [sp, #4]
3000d9d8:	e5832004 	str	r2, [r3, #4]
    buf->addr = addr;
3000d9dc:	e59d3014 	ldr	r3, [sp, #20]
3000d9e0:	e59d2000 	ldr	r2, [sp]
3000d9e4:	e5832008 	str	r2, [r3, #8]
    buf->port = port;
3000d9e8:	e59d3014 	ldr	r3, [sp, #20]
3000d9ec:	e1dd22b8 	ldrh	r2, [sp, #40]	; 0x28
3000d9f0:	e1c320bc 	strh	r2, [r3, #12]
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
3000d9f4:	ebffcf3e 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000d9f8:	e1a03000 	mov	r3, r0
3000d9fc:	e58d301c 	str	r3, [sp, #28]
3000da00:	e59d3018 	ldr	r3, [sp, #24]
3000da04:	e1d321bc 	ldrh	r2, [r3, #28]
3000da08:	e59d3004 	ldr	r3, [sp, #4]
3000da0c:	e1d330b8 	ldrh	r3, [r3, #8]
3000da10:	e0823003 	add	r3, r2, r3
3000da14:	e1a03803 	lsl	r3, r3, #16
3000da18:	e1a02823 	lsr	r2, r3, #16
3000da1c:	e59d3018 	ldr	r3, [sp, #24]
3000da20:	e1c321bc 	strh	r2, [r3, #28]
3000da24:	e59d001c 	ldr	r0, [sp, #28]
3000da28:	ebffcf2f 	bl	300016ec <HAL_INTR_RESTORE>
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
3000da2c:	e59d3018 	ldr	r3, [sp, #24]
3000da30:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000da34:	e3530000 	cmp	r3, #0
3000da38:	0a000007 	beq	3000da5c <recv_udp+0x108>
3000da3c:	e59d3018 	ldr	r3, [sp, #24]
3000da40:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000da44:	e59d2004 	ldr	r2, [sp, #4]
3000da48:	e1d220b8 	ldrh	r2, [r2, #8]
3000da4c:	e59d0018 	ldr	r0, [sp, #24]
3000da50:	e3a01000 	mov	r1, #0
3000da54:	e1a0e00f 	mov	lr, pc
3000da58:	e12fff13 	bx	r3
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
3000da5c:	e59d3018 	ldr	r3, [sp, #24]
3000da60:	e5933010 	ldr	r3, [r3, #16]
3000da64:	e1a00003 	mov	r0, r3
3000da68:	e59d1014 	ldr	r1, [sp, #20]
3000da6c:	ebfffc6f 	bl	3000cc30 <sys_mbox_trypost>
3000da70:	e1a03000 	mov	r3, r0
3000da74:	e20330ff 	and	r3, r3, #255	; 0xff
3000da78:	e3530000 	cmp	r3, #0
3000da7c:	0a000002 	beq	3000da8c <recv_udp+0x138>
    netbuf_delete(buf);
3000da80:	e59d0014 	ldr	r0, [sp, #20]
3000da84:	eb0006a7 	bl	3000f528 <netbuf_delete>
    return;
3000da88:	e1a00000 	nop			; (mov r0, r0)
  }
}
3000da8c:	e28dd024 	add	sp, sp, #36	; 0x24
3000da90:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000da94:	e12fff1e 	bx	lr

3000da98 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
3000da98:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000da9c:	e24dd024 	sub	sp, sp, #36	; 0x24
3000daa0:	e58d000c 	str	r0, [sp, #12]
3000daa4:	e58d1008 	str	r1, [sp, #8]
3000daa8:	e58d2004 	str	r2, [sp, #4]
3000daac:	e5cd3003 	strb	r3, [sp, #3]
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = arg;
3000dab0:	e59d300c 	ldr	r3, [sp, #12]
3000dab4:	e58d3014 	str	r3, [sp, #20]
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
3000dab8:	e59d3014 	ldr	r3, [sp, #20]
3000dabc:	e3530000 	cmp	r3, #0
3000dac0:	0a000003 	beq	3000dad4 <recv_tcp+0x3c>
3000dac4:	e59d3014 	ldr	r3, [sp, #20]
3000dac8:	e5933010 	ldr	r3, [r3, #16]
3000dacc:	e3530000 	cmp	r3, #0
3000dad0:	1a000001 	bne	3000dadc <recv_tcp+0x44>
    return ERR_VAL;
3000dad4:	e3a030f8 	mov	r3, #248	; 0xf8
3000dad8:	ea00002f 	b	3000db9c <recv_tcp+0x104>
  }

  conn->err = err;
3000dadc:	e59d3014 	ldr	r3, [sp, #20]
3000dae0:	e5dd2003 	ldrb	r2, [sp, #3]
3000dae4:	e5c32008 	strb	r2, [r3, #8]
  if (p != NULL) {
3000dae8:	e59d3004 	ldr	r3, [sp, #4]
3000daec:	e3530000 	cmp	r3, #0
3000daf0:	0a000010 	beq	3000db38 <recv_tcp+0xa0>
    len = p->tot_len;
3000daf4:	e59d3004 	ldr	r3, [sp, #4]
3000daf8:	e1d330b8 	ldrh	r3, [r3, #8]
3000dafc:	e1cd31ba 	strh	r3, [sp, #26]
    SYS_ARCH_INC(conn->recv_avail, len);
3000db00:	ebffcefb 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000db04:	e1a03000 	mov	r3, r0
3000db08:	e58d301c 	str	r3, [sp, #28]
3000db0c:	e59d3014 	ldr	r3, [sp, #20]
3000db10:	e1d321bc 	ldrh	r2, [r3, #28]
3000db14:	e1dd31ba 	ldrh	r3, [sp, #26]
3000db18:	e0823003 	add	r3, r2, r3
3000db1c:	e1a03803 	lsl	r3, r3, #16
3000db20:	e1a02823 	lsr	r2, r3, #16
3000db24:	e59d3014 	ldr	r3, [sp, #20]
3000db28:	e1c321bc 	strh	r2, [r3, #28]
3000db2c:	e59d001c 	ldr	r0, [sp, #28]
3000db30:	ebffceed 	bl	300016ec <HAL_INTR_RESTORE>
3000db34:	ea000001 	b	3000db40 <recv_tcp+0xa8>
  } else {
    len = 0;
3000db38:	e3a03000 	mov	r3, #0
3000db3c:	e1cd31ba 	strh	r3, [sp, #26]
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
3000db40:	e59d3014 	ldr	r3, [sp, #20]
3000db44:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000db48:	e3530000 	cmp	r3, #0
3000db4c:	0a000006 	beq	3000db6c <recv_tcp+0xd4>
3000db50:	e59d3014 	ldr	r3, [sp, #20]
3000db54:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000db58:	e1dd21ba 	ldrh	r2, [sp, #26]
3000db5c:	e59d0014 	ldr	r0, [sp, #20]
3000db60:	e3a01000 	mov	r1, #0
3000db64:	e1a0e00f 	mov	lr, pc
3000db68:	e12fff13 	bx	r3
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
3000db6c:	e59d3014 	ldr	r3, [sp, #20]
3000db70:	e5933010 	ldr	r3, [r3, #16]
3000db74:	e1a00003 	mov	r0, r3
3000db78:	e59d1004 	ldr	r1, [sp, #4]
3000db7c:	ebfffc2b 	bl	3000cc30 <sys_mbox_trypost>
3000db80:	e1a03000 	mov	r3, r0
3000db84:	e20330ff 	and	r3, r3, #255	; 0xff
3000db88:	e3530000 	cmp	r3, #0
3000db8c:	0a000001 	beq	3000db98 <recv_tcp+0x100>
    return ERR_MEM;
3000db90:	e3a030ff 	mov	r3, #255	; 0xff
3000db94:	ea000000 	b	3000db9c <recv_tcp+0x104>
  }

  return ERR_OK;
3000db98:	e3a03000 	mov	r3, #0
3000db9c:	e1a03c03 	lsl	r3, r3, #24
3000dba0:	e1a03c43 	asr	r3, r3, #24
}
3000dba4:	e1a00003 	mov	r0, r3
3000dba8:	e28dd024 	add	sp, sp, #36	; 0x24
3000dbac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000dbb0:	e12fff1e 	bx	lr

3000dbb4 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
3000dbb4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000dbb8:	e24dd014 	sub	sp, sp, #20
3000dbbc:	e58d0004 	str	r0, [sp, #4]
3000dbc0:	e58d1000 	str	r1, [sp]
  struct netconn *conn = arg;
3000dbc4:	e59d3004 	ldr	r3, [sp, #4]
3000dbc8:	e58d300c 	str	r3, [sp, #12]

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn->state == NETCONN_WRITE) {
3000dbcc:	e59d300c 	ldr	r3, [sp, #12]
3000dbd0:	e5d33001 	ldrb	r3, [r3, #1]
3000dbd4:	e3530001 	cmp	r3, #1
3000dbd8:	1a000002 	bne	3000dbe8 <poll_tcp+0x34>
    do_writemore(conn);
3000dbdc:	e59d000c 	ldr	r0, [sp, #12]
3000dbe0:	eb0004c7 	bl	3000ef04 <do_writemore>
3000dbe4:	ea000005 	b	3000dc00 <poll_tcp+0x4c>
  } else if (conn->state == NETCONN_CLOSE) {
3000dbe8:	e59d300c 	ldr	r3, [sp, #12]
3000dbec:	e5d33001 	ldrb	r3, [r3, #1]
3000dbf0:	e3530004 	cmp	r3, #4
3000dbf4:	1a000001 	bne	3000dc00 <poll_tcp+0x4c>
    do_close_internal(conn);
3000dbf8:	e59d000c 	ldr	r0, [sp, #12]
3000dbfc:	eb00020e 	bl	3000e43c <do_close_internal>
  }

  return ERR_OK;
3000dc00:	e3a03000 	mov	r3, #0
3000dc04:	e1a03c03 	lsl	r3, r3, #24
3000dc08:	e1a03c43 	asr	r3, r3, #24
}
3000dc0c:	e1a00003 	mov	r0, r3
3000dc10:	e28dd014 	add	sp, sp, #20
3000dc14:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000dc18:	e12fff1e 	bx	lr

3000dc1c <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
3000dc1c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000dc20:	e24dd01c 	sub	sp, sp, #28
3000dc24:	e58d000c 	str	r0, [sp, #12]
3000dc28:	e58d1008 	str	r1, [sp, #8]
3000dc2c:	e1a03002 	mov	r3, r2
3000dc30:	e1cd30b6 	strh	r3, [sp, #6]
  struct netconn *conn = arg;
3000dc34:	e59d300c 	ldr	r3, [sp, #12]
3000dc38:	e58d3014 	str	r3, [sp, #20]

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn->state == NETCONN_WRITE) {
3000dc3c:	e59d3014 	ldr	r3, [sp, #20]
3000dc40:	e5d33001 	ldrb	r3, [r3, #1]
3000dc44:	e3530001 	cmp	r3, #1
3000dc48:	1a000002 	bne	3000dc58 <sent_tcp+0x3c>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
    do_writemore(conn);
3000dc4c:	e59d0014 	ldr	r0, [sp, #20]
3000dc50:	eb0004ab 	bl	3000ef04 <do_writemore>
3000dc54:	ea000005 	b	3000dc70 <sent_tcp+0x54>
  } else if (conn->state == NETCONN_CLOSE) {
3000dc58:	e59d3014 	ldr	r3, [sp, #20]
3000dc5c:	e5d33001 	ldrb	r3, [r3, #1]
3000dc60:	e3530004 	cmp	r3, #4
3000dc64:	1a000001 	bne	3000dc70 <sent_tcp+0x54>
    do_close_internal(conn);
3000dc68:	e59d0014 	ldr	r0, [sp, #20]
3000dc6c:	eb0001f2 	bl	3000e43c <do_close_internal>
  }

  if (conn) {
3000dc70:	e59d3014 	ldr	r3, [sp, #20]
3000dc74:	e3530000 	cmp	r3, #0
3000dc78:	0a000013 	beq	3000dccc <sent_tcp+0xb0>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
3000dc7c:	e59d3014 	ldr	r3, [sp, #20]
3000dc80:	e5933004 	ldr	r3, [r3, #4]
3000dc84:	e3530000 	cmp	r3, #0
3000dc88:	0a00000f 	beq	3000dccc <sent_tcp+0xb0>
3000dc8c:	e59d3014 	ldr	r3, [sp, #20]
3000dc90:	e5933004 	ldr	r3, [r3, #4]
3000dc94:	e1d336ba 	ldrh	r3, [r3, #106]	; 0x6a
3000dc98:	e3530080 	cmp	r3, #128	; 0x80
3000dc9c:	9a00000a 	bls	3000dccc <sent_tcp+0xb0>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
3000dca0:	e59d3014 	ldr	r3, [sp, #20]
3000dca4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000dca8:	e3530000 	cmp	r3, #0
3000dcac:	0a000006 	beq	3000dccc <sent_tcp+0xb0>
3000dcb0:	e59d3014 	ldr	r3, [sp, #20]
3000dcb4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000dcb8:	e1dd20b6 	ldrh	r2, [sp, #6]
3000dcbc:	e59d0014 	ldr	r0, [sp, #20]
3000dcc0:	e3a01002 	mov	r1, #2
3000dcc4:	e1a0e00f 	mov	lr, pc
3000dcc8:	e12fff13 	bx	r3
    }
  }
  
  return ERR_OK;
3000dccc:	e3a03000 	mov	r3, #0
3000dcd0:	e1a03c03 	lsl	r3, r3, #24
3000dcd4:	e1a03c43 	asr	r3, r3, #24
}
3000dcd8:	e1a00003 	mov	r0, r3
3000dcdc:	e28dd01c 	add	sp, sp, #28
3000dce0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000dce4:	e12fff1e 	bx	lr

3000dce8 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
3000dce8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000dcec:	e24dd014 	sub	sp, sp, #20
3000dcf0:	e58d0004 	str	r0, [sp, #4]
3000dcf4:	e1a03001 	mov	r3, r1
3000dcf8:	e5cd3003 	strb	r3, [sp, #3]
  struct netconn *conn;

  conn = arg;
3000dcfc:	e59d3004 	ldr	r3, [sp, #4]
3000dd00:	e58d300c 	str	r3, [sp, #12]
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  conn->pcb.tcp = NULL;
3000dd04:	e59d300c 	ldr	r3, [sp, #12]
3000dd08:	e3a02000 	mov	r2, #0
3000dd0c:	e5832004 	str	r2, [r3, #4]

  conn->err = err;
3000dd10:	e59d300c 	ldr	r3, [sp, #12]
3000dd14:	e5dd2003 	ldrb	r2, [sp, #3]
3000dd18:	e5c32008 	strb	r2, [r3, #8]
  if (conn->recvmbox != SYS_MBOX_NULL) {
3000dd1c:	e59d300c 	ldr	r3, [sp, #12]
3000dd20:	e5933010 	ldr	r3, [r3, #16]
3000dd24:	e3530000 	cmp	r3, #0
3000dd28:	0a00000f 	beq	3000dd6c <err_tcp+0x84>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
3000dd2c:	e59d300c 	ldr	r3, [sp, #12]
3000dd30:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000dd34:	e3530000 	cmp	r3, #0
3000dd38:	0a000006 	beq	3000dd58 <err_tcp+0x70>
3000dd3c:	e59d300c 	ldr	r3, [sp, #12]
3000dd40:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000dd44:	e59d000c 	ldr	r0, [sp, #12]
3000dd48:	e3a01000 	mov	r1, #0
3000dd4c:	e3a02000 	mov	r2, #0
3000dd50:	e1a0e00f 	mov	lr, pc
3000dd54:	e12fff13 	bx	r3
    sys_mbox_post(conn->recvmbox, NULL);
3000dd58:	e59d300c 	ldr	r3, [sp, #12]
3000dd5c:	e5933010 	ldr	r3, [r3, #16]
3000dd60:	e1a00003 	mov	r0, r3
3000dd64:	e3a01000 	mov	r1, #0
3000dd68:	ebfffb97 	bl	3000cbcc <sys_mbox_post>
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
3000dd6c:	e59d300c 	ldr	r3, [sp, #12]
3000dd70:	e593300c 	ldr	r3, [r3, #12]
3000dd74:	e3530000 	cmp	r3, #0
3000dd78:	0a00000a 	beq	3000dda8 <err_tcp+0xc0>
3000dd7c:	e59d300c 	ldr	r3, [sp, #12]
3000dd80:	e5d33001 	ldrb	r3, [r3, #1]
3000dd84:	e3530003 	cmp	r3, #3
3000dd88:	1a000006 	bne	3000dda8 <err_tcp+0xc0>
    conn->state = NETCONN_NONE;
3000dd8c:	e59d300c 	ldr	r3, [sp, #12]
3000dd90:	e3a02000 	mov	r2, #0
3000dd94:	e5c32001 	strb	r2, [r3, #1]
    sys_sem_signal(conn->op_completed);
3000dd98:	e59d300c 	ldr	r3, [sp, #12]
3000dd9c:	e593300c 	ldr	r3, [r3, #12]
3000dda0:	e1a00003 	mov	r0, r3
3000dda4:	ebfffb5b 	bl	3000cb18 <sys_sem_signal>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
3000dda8:	e59d300c 	ldr	r3, [sp, #12]
3000ddac:	e5933014 	ldr	r3, [r3, #20]
3000ddb0:	e3530000 	cmp	r3, #0
3000ddb4:	0a00000f 	beq	3000ddf8 <err_tcp+0x110>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
3000ddb8:	e59d300c 	ldr	r3, [sp, #12]
3000ddbc:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000ddc0:	e3530000 	cmp	r3, #0
3000ddc4:	0a000006 	beq	3000dde4 <err_tcp+0xfc>
3000ddc8:	e59d300c 	ldr	r3, [sp, #12]
3000ddcc:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000ddd0:	e59d000c 	ldr	r0, [sp, #12]
3000ddd4:	e3a01000 	mov	r1, #0
3000ddd8:	e3a02000 	mov	r2, #0
3000dddc:	e1a0e00f 	mov	lr, pc
3000dde0:	e12fff13 	bx	r3
    sys_mbox_post(conn->acceptmbox, NULL);
3000dde4:	e59d300c 	ldr	r3, [sp, #12]
3000dde8:	e5933014 	ldr	r3, [r3, #20]
3000ddec:	e1a00003 	mov	r0, r3
3000ddf0:	e3a01000 	mov	r1, #0
3000ddf4:	ebfffb74 	bl	3000cbcc <sys_mbox_post>
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
3000ddf8:	e59d300c 	ldr	r3, [sp, #12]
3000ddfc:	e5d33001 	ldrb	r3, [r3, #1]
3000de00:	e3530001 	cmp	r3, #1
3000de04:	0a000003 	beq	3000de18 <err_tcp+0x130>
3000de08:	e59d300c 	ldr	r3, [sp, #12]
3000de0c:	e5d33001 	ldrb	r3, [r3, #1]
3000de10:	e3530004 	cmp	r3, #4
3000de14:	1a000006 	bne	3000de34 <err_tcp+0x14c>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
3000de18:	e59d300c 	ldr	r3, [sp, #12]
3000de1c:	e3a02000 	mov	r2, #0
3000de20:	e5c32001 	strb	r2, [r3, #1]
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
3000de24:	e59d300c 	ldr	r3, [sp, #12]
3000de28:	e593300c 	ldr	r3, [r3, #12]
3000de2c:	e1a00003 	mov	r0, r3
3000de30:	ebfffb38 	bl	3000cb18 <sys_sem_signal>
  }
}
3000de34:	e28dd014 	add	sp, sp, #20
3000de38:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000de3c:	e12fff1e 	bx	lr

3000de40 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
3000de40:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000de44:	e24dd014 	sub	sp, sp, #20
3000de48:	e58d0004 	str	r0, [sp, #4]
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
3000de4c:	e59d3004 	ldr	r3, [sp, #4]
3000de50:	e5933004 	ldr	r3, [r3, #4]
3000de54:	e58d300c 	str	r3, [sp, #12]
  tcp_arg(pcb, conn);
3000de58:	e59d000c 	ldr	r0, [sp, #12]
3000de5c:	e59d1004 	ldr	r1, [sp, #4]
3000de60:	eb002d83 	bl	30019474 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
3000de64:	e59d000c 	ldr	r0, [sp, #12]
3000de68:	e59f1034 	ldr	r1, [pc, #52]	; 3000dea4 <setup_tcp+0x64>
3000de6c:	eb002d88 	bl	30019494 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
3000de70:	e59d000c 	ldr	r0, [sp, #12]
3000de74:	e59f102c 	ldr	r1, [pc, #44]	; 3000dea8 <setup_tcp+0x68>
3000de78:	eb002d8d 	bl	300194b4 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
3000de7c:	e59d000c 	ldr	r0, [sp, #12]
3000de80:	e59f1024 	ldr	r1, [pc, #36]	; 3000deac <setup_tcp+0x6c>
3000de84:	e3a02004 	mov	r2, #4
3000de88:	eb002da1 	bl	30019514 <tcp_poll>
  tcp_err(pcb, err_tcp);
3000de8c:	e59d000c 	ldr	r0, [sp, #12]
3000de90:	e59f1018 	ldr	r1, [pc, #24]	; 3000deb0 <setup_tcp+0x70>
3000de94:	eb002d8e 	bl	300194d4 <tcp_err>
}
3000de98:	e28dd014 	add	sp, sp, #20
3000de9c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000dea0:	e12fff1e 	bx	lr
3000dea4:	3000da98 	.word	0x3000da98
3000dea8:	3000dc1c 	.word	0x3000dc1c
3000deac:	3000dbb4 	.word	0x3000dbb4
3000deb0:	3000dce8 	.word	0x3000dce8

3000deb4 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
3000deb4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000deb8:	e24dd01c 	sub	sp, sp, #28
3000debc:	e58d000c 	str	r0, [sp, #12]
3000dec0:	e58d1008 	str	r1, [sp, #8]
3000dec4:	e1a03002 	mov	r3, r2
3000dec8:	e5cd3007 	strb	r3, [sp, #7]
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
3000decc:	e59d300c 	ldr	r3, [sp, #12]
3000ded0:	e58d3014 	str	r3, [sp, #20]
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
3000ded4:	e59d3014 	ldr	r3, [sp, #20]
3000ded8:	e5d32000 	ldrb	r2, [r3]
3000dedc:	e59d3014 	ldr	r3, [sp, #20]
3000dee0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000dee4:	e1a00002 	mov	r0, r2
3000dee8:	e1a01003 	mov	r1, r3
3000deec:	eb0000b6 	bl	3000e1cc <netconn_alloc>
3000def0:	e1a03000 	mov	r3, r0
3000def4:	e58d3010 	str	r3, [sp, #16]
  if (newconn == NULL) {
3000def8:	e59d3010 	ldr	r3, [sp, #16]
3000defc:	e3530000 	cmp	r3, #0
3000df00:	1a000001 	bne	3000df0c <accept_function+0x58>
    return ERR_MEM;
3000df04:	e3a030ff 	mov	r3, #255	; 0xff
3000df08:	ea000023 	b	3000df9c <accept_function+0xe8>
  }
  newconn->pcb.tcp = newpcb;
3000df0c:	e59d3010 	ldr	r3, [sp, #16]
3000df10:	e59d2008 	ldr	r2, [sp, #8]
3000df14:	e5832004 	str	r2, [r3, #4]
  setup_tcp(newconn);
3000df18:	e59d0010 	ldr	r0, [sp, #16]
3000df1c:	ebffffc7 	bl	3000de40 <setup_tcp>
  newconn->err = err;
3000df20:	e59d3010 	ldr	r3, [sp, #16]
3000df24:	e5dd2007 	ldrb	r2, [sp, #7]
3000df28:	e5c32008 	strb	r2, [r3, #8]
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
3000df2c:	e59d3014 	ldr	r3, [sp, #20]
3000df30:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000df34:	e3530000 	cmp	r3, #0
3000df38:	0a000006 	beq	3000df58 <accept_function+0xa4>
3000df3c:	e59d3014 	ldr	r3, [sp, #20]
3000df40:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000df44:	e59d0014 	ldr	r0, [sp, #20]
3000df48:	e3a01000 	mov	r1, #0
3000df4c:	e3a02000 	mov	r2, #0
3000df50:	e1a0e00f 	mov	lr, pc
3000df54:	e12fff13 	bx	r3

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
3000df58:	e59d3014 	ldr	r3, [sp, #20]
3000df5c:	e5933014 	ldr	r3, [r3, #20]
3000df60:	e1a00003 	mov	r0, r3
3000df64:	e59d1010 	ldr	r1, [sp, #16]
3000df68:	ebfffb30 	bl	3000cc30 <sys_mbox_trypost>
3000df6c:	e1a03000 	mov	r3, r0
3000df70:	e20330ff 	and	r3, r3, #255	; 0xff
3000df74:	e3530000 	cmp	r3, #0
3000df78:	0a000006 	beq	3000df98 <accept_function+0xe4>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
3000df7c:	e59d3010 	ldr	r3, [sp, #16]
3000df80:	e3a02000 	mov	r2, #0
3000df84:	e5832004 	str	r2, [r3, #4]
    netconn_free(newconn);
3000df88:	e59d0010 	ldr	r0, [sp, #16]
3000df8c:	eb0000db 	bl	3000e300 <netconn_free>
    return ERR_MEM;
3000df90:	e3a030ff 	mov	r3, #255	; 0xff
3000df94:	ea000000 	b	3000df9c <accept_function+0xe8>
  }
  return ERR_OK;
3000df98:	e3a03000 	mov	r3, #0
3000df9c:	e1a03c03 	lsl	r3, r3, #24
3000dfa0:	e1a03c43 	asr	r3, r3, #24
}
3000dfa4:	e1a00003 	mov	r0, r3
3000dfa8:	e28dd01c 	add	sp, sp, #28
3000dfac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000dfb0:	e12fff1e 	bx	lr

3000dfb4 <pcb_new>:
 * @param msg the api_msg_msg describing the connection type
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
3000dfb4:	e92d4010 	push	{r4, lr}
3000dfb8:	e24dd008 	sub	sp, sp, #8
3000dfbc:	e58d0004 	str	r0, [sp, #4]
   msg->conn->err = ERR_OK;
3000dfc0:	e59d3004 	ldr	r3, [sp, #4]
3000dfc4:	e5933000 	ldr	r3, [r3]
3000dfc8:	e3a02000 	mov	r2, #0
3000dfcc:	e5c32008 	strb	r2, [r3, #8]

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
3000dfd0:	e59d3004 	ldr	r3, [sp, #4]
3000dfd4:	e5933000 	ldr	r3, [r3]
3000dfd8:	e5d33000 	ldrb	r3, [r3]
3000dfdc:	e20330f0 	and	r3, r3, #240	; 0xf0
3000dfe0:	e3530020 	cmp	r3, #32
3000dfe4:	0a000020 	beq	3000e06c <pcb_new+0xb8>
3000dfe8:	e3530040 	cmp	r3, #64	; 0x40
3000dfec:	0a000002 	beq	3000dffc <pcb_new+0x48>
3000dff0:	e3530010 	cmp	r3, #16
3000dff4:	0a00003f 	beq	3000e0f8 <pcb_new+0x144>
3000dff8:	ea000052 	b	3000e148 <pcb_new+0x194>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
3000dffc:	e59d3004 	ldr	r3, [sp, #4]
3000e000:	e5934000 	ldr	r4, [r3]
3000e004:	e59d3004 	ldr	r3, [sp, #4]
3000e008:	e5d33004 	ldrb	r3, [r3, #4]
3000e00c:	e1a00003 	mov	r0, r3
3000e010:	eb0023ed 	bl	30016fcc <raw_new>
3000e014:	e1a03000 	mov	r3, r0
3000e018:	e5843004 	str	r3, [r4, #4]
     if(msg->conn->pcb.raw == NULL) {
3000e01c:	e59d3004 	ldr	r3, [sp, #4]
3000e020:	e5933000 	ldr	r3, [r3]
3000e024:	e5933004 	ldr	r3, [r3, #4]
3000e028:	e3530000 	cmp	r3, #0
3000e02c:	1a000004 	bne	3000e044 <pcb_new+0x90>
       msg->conn->err = ERR_MEM;
3000e030:	e59d3004 	ldr	r3, [sp, #4]
3000e034:	e5933000 	ldr	r3, [r3]
3000e038:	e3e02000 	mvn	r2, #0
3000e03c:	e5c32008 	strb	r2, [r3, #8]
       break;
3000e040:	ea000044 	b	3000e158 <pcb_new+0x1a4>
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
3000e044:	e59d3004 	ldr	r3, [sp, #4]
3000e048:	e5933000 	ldr	r3, [r3]
3000e04c:	e5932004 	ldr	r2, [r3, #4]
3000e050:	e59d3004 	ldr	r3, [sp, #4]
3000e054:	e5933000 	ldr	r3, [r3]
3000e058:	e1a00002 	mov	r0, r2
3000e05c:	e59f1118 	ldr	r1, [pc, #280]	; 3000e17c <pcb_new+0x1c8>
3000e060:	e1a02003 	mov	r2, r3
3000e064:	eb00232f 	bl	30016d28 <raw_recv>
     break;
3000e068:	ea00003a 	b	3000e158 <pcb_new+0x1a4>
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
3000e06c:	e59d3004 	ldr	r3, [sp, #4]
3000e070:	e5934000 	ldr	r4, [r3]
3000e074:	eb004ab4 	bl	30020b4c <udp_new>
3000e078:	e1a03000 	mov	r3, r0
3000e07c:	e5843004 	str	r3, [r4, #4]
     if(msg->conn->pcb.udp == NULL) {
3000e080:	e59d3004 	ldr	r3, [sp, #4]
3000e084:	e5933000 	ldr	r3, [r3]
3000e088:	e5933004 	ldr	r3, [r3, #4]
3000e08c:	e3530000 	cmp	r3, #0
3000e090:	1a000004 	bne	3000e0a8 <pcb_new+0xf4>
       msg->conn->err = ERR_MEM;
3000e094:	e59d3004 	ldr	r3, [sp, #4]
3000e098:	e5933000 	ldr	r3, [r3]
3000e09c:	e3e02000 	mvn	r2, #0
3000e0a0:	e5c32008 	strb	r2, [r3, #8]
       break;
3000e0a4:	ea00002b 	b	3000e158 <pcb_new+0x1a4>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
3000e0a8:	e59d3004 	ldr	r3, [sp, #4]
3000e0ac:	e5933000 	ldr	r3, [r3]
3000e0b0:	e5d33000 	ldrb	r3, [r3]
3000e0b4:	e3530022 	cmp	r3, #34	; 0x22
3000e0b8:	1a000004 	bne	3000e0d0 <pcb_new+0x11c>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
3000e0bc:	e59d3004 	ldr	r3, [sp, #4]
3000e0c0:	e5933000 	ldr	r3, [r3]
3000e0c4:	e5933004 	ldr	r3, [r3, #4]
3000e0c8:	e3a02001 	mov	r2, #1
3000e0cc:	e5c32010 	strb	r2, [r3, #16]
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
3000e0d0:	e59d3004 	ldr	r3, [sp, #4]
3000e0d4:	e5933000 	ldr	r3, [r3]
3000e0d8:	e5932004 	ldr	r2, [r3, #4]
3000e0dc:	e59d3004 	ldr	r3, [sp, #4]
3000e0e0:	e5933000 	ldr	r3, [r3]
3000e0e4:	e1a00002 	mov	r0, r2
3000e0e8:	e59f1090 	ldr	r1, [pc, #144]	; 3000e180 <pcb_new+0x1cc>
3000e0ec:	e1a02003 	mov	r2, r3
3000e0f0:	eb004a5d 	bl	30020a6c <udp_recv>
     break;
3000e0f4:	ea000017 	b	3000e158 <pcb_new+0x1a4>
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
3000e0f8:	e59d3004 	ldr	r3, [sp, #4]
3000e0fc:	e5934000 	ldr	r4, [r3]
3000e100:	eb002cd4 	bl	30019458 <tcp_new>
3000e104:	e1a03000 	mov	r3, r0
3000e108:	e5843004 	str	r3, [r4, #4]
     if(msg->conn->pcb.tcp == NULL) {
3000e10c:	e59d3004 	ldr	r3, [sp, #4]
3000e110:	e5933000 	ldr	r3, [r3]
3000e114:	e5933004 	ldr	r3, [r3, #4]
3000e118:	e3530000 	cmp	r3, #0
3000e11c:	1a000004 	bne	3000e134 <pcb_new+0x180>
       msg->conn->err = ERR_MEM;
3000e120:	e59d3004 	ldr	r3, [sp, #4]
3000e124:	e5933000 	ldr	r3, [r3]
3000e128:	e3e02000 	mvn	r2, #0
3000e12c:	e5c32008 	strb	r2, [r3, #8]
       break;
3000e130:	ea000008 	b	3000e158 <pcb_new+0x1a4>
     }
     setup_tcp(msg->conn);
3000e134:	e59d3004 	ldr	r3, [sp, #4]
3000e138:	e5933000 	ldr	r3, [r3]
3000e13c:	e1a00003 	mov	r0, r3
3000e140:	ebffff3e 	bl	3000de40 <setup_tcp>
     break;
3000e144:	ea000003 	b	3000e158 <pcb_new+0x1a4>
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
3000e148:	e59d3004 	ldr	r3, [sp, #4]
3000e14c:	e5933000 	ldr	r3, [r3]
3000e150:	e3e02007 	mvn	r2, #7
3000e154:	e5c32008 	strb	r2, [r3, #8]
     break;
   }

  return msg->conn->err;
3000e158:	e59d3004 	ldr	r3, [sp, #4]
3000e15c:	e5933000 	ldr	r3, [r3]
3000e160:	e5d33008 	ldrb	r3, [r3, #8]
3000e164:	e1a03c03 	lsl	r3, r3, #24
3000e168:	e1a03c43 	asr	r3, r3, #24
}
3000e16c:	e1a00003 	mov	r0, r3
3000e170:	e28dd008 	add	sp, sp, #8
3000e174:	e8bd4010 	pop	{r4, lr}
3000e178:	e12fff1e 	bx	lr
3000e17c:	3000d7a0 	.word	0x3000d7a0
3000e180:	3000d954 	.word	0x3000d954

3000e184 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
3000e184:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000e188:	e24dd00c 	sub	sp, sp, #12
3000e18c:	e58d0004 	str	r0, [sp, #4]
   if(msg->conn->pcb.tcp == NULL) {
3000e190:	e59d3004 	ldr	r3, [sp, #4]
3000e194:	e5933000 	ldr	r3, [r3]
3000e198:	e5933004 	ldr	r3, [r3, #4]
3000e19c:	e3530000 	cmp	r3, #0
3000e1a0:	1a000001 	bne	3000e1ac <do_newconn+0x28>
     pcb_new(msg);
3000e1a4:	e59d0004 	ldr	r0, [sp, #4]
3000e1a8:	ebffff81 	bl	3000dfb4 <pcb_new>
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
3000e1ac:	e59d3004 	ldr	r3, [sp, #4]
3000e1b0:	e5933000 	ldr	r3, [r3]
3000e1b4:	e593300c 	ldr	r3, [r3, #12]
3000e1b8:	e1a00003 	mov	r0, r3
3000e1bc:	ebfffa55 	bl	3000cb18 <sys_sem_signal>
}
3000e1c0:	e28dd00c 	add	sp, sp, #12
3000e1c4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000e1c8:	e12fff1e 	bx	lr

3000e1cc <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
3000e1cc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000e1d0:	e24dd014 	sub	sp, sp, #20
3000e1d4:	e1a03000 	mov	r3, r0
3000e1d8:	e58d1000 	str	r1, [sp]
3000e1dc:	e5cd3007 	strb	r3, [sp, #7]
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
3000e1e0:	e3a00006 	mov	r0, #6
3000e1e4:	eb001d01 	bl	300155f0 <memp_malloc>
3000e1e8:	e1a03000 	mov	r3, r0
3000e1ec:	e58d3008 	str	r3, [sp, #8]
  if (conn == NULL) {
3000e1f0:	e59d3008 	ldr	r3, [sp, #8]
3000e1f4:	e3530000 	cmp	r3, #0
3000e1f8:	1a000001 	bne	3000e204 <netconn_alloc+0x38>
    return NULL;
3000e1fc:	e3a03000 	mov	r3, #0
3000e200:	ea00003a 	b	3000e2f0 <netconn_alloc+0x124>
  }

  conn->err = ERR_OK;
3000e204:	e59d3008 	ldr	r3, [sp, #8]
3000e208:	e3a02000 	mov	r2, #0
3000e20c:	e5c32008 	strb	r2, [r3, #8]
  conn->type = t;
3000e210:	e59d3008 	ldr	r3, [sp, #8]
3000e214:	e5dd2007 	ldrb	r2, [sp, #7]
3000e218:	e5c32000 	strb	r2, [r3]
  conn->pcb.tcp = NULL;
3000e21c:	e59d3008 	ldr	r3, [sp, #8]
3000e220:	e3a02000 	mov	r2, #0
3000e224:	e5832004 	str	r2, [r3, #4]

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
3000e228:	e3a0300a 	mov	r3, #10
3000e22c:	e58d300c 	str	r3, [sp, #12]
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
3000e230:	e3a00000 	mov	r0, #0
3000e234:	ebfffa22 	bl	3000cac4 <sys_sem_new>
3000e238:	e1a02000 	mov	r2, r0
3000e23c:	e59d3008 	ldr	r3, [sp, #8]
3000e240:	e583200c 	str	r2, [r3, #12]
3000e244:	e59d3008 	ldr	r3, [sp, #8]
3000e248:	e593300c 	ldr	r3, [r3, #12]
3000e24c:	e3530000 	cmp	r3, #0
3000e250:	1a000004 	bne	3000e268 <netconn_alloc+0x9c>
    memp_free(MEMP_NETCONN, conn);
3000e254:	e3a00006 	mov	r0, #6
3000e258:	e59d1008 	ldr	r1, [sp, #8]
3000e25c:	eb001d48 	bl	30015784 <memp_free>
    return NULL;
3000e260:	e3a03000 	mov	r3, #0
3000e264:	ea000021 	b	3000e2f0 <netconn_alloc+0x124>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
3000e268:	e59d000c 	ldr	r0, [sp, #12]
3000e26c:	ebfffa42 	bl	3000cb7c <sys_mbox_new>
3000e270:	e1a02000 	mov	r2, r0
3000e274:	e59d3008 	ldr	r3, [sp, #8]
3000e278:	e5832010 	str	r2, [r3, #16]
3000e27c:	e59d3008 	ldr	r3, [sp, #8]
3000e280:	e5933010 	ldr	r3, [r3, #16]
3000e284:	e3530000 	cmp	r3, #0
3000e288:	1a000008 	bne	3000e2b0 <netconn_alloc+0xe4>
    sys_sem_free(conn->op_completed);
3000e28c:	e59d3008 	ldr	r3, [sp, #8]
3000e290:	e593300c 	ldr	r3, [r3, #12]
3000e294:	e1a00003 	mov	r0, r3
3000e298:	ebfffa15 	bl	3000caf4 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
3000e29c:	e3a00006 	mov	r0, #6
3000e2a0:	e59d1008 	ldr	r1, [sp, #8]
3000e2a4:	eb001d36 	bl	30015784 <memp_free>
    return NULL;
3000e2a8:	e3a03000 	mov	r3, #0
3000e2ac:	ea00000f 	b	3000e2f0 <netconn_alloc+0x124>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
3000e2b0:	e59d3008 	ldr	r3, [sp, #8]
3000e2b4:	e3a02000 	mov	r2, #0
3000e2b8:	e5832014 	str	r2, [r3, #20]
  conn->state        = NETCONN_NONE;
3000e2bc:	e59d3008 	ldr	r3, [sp, #8]
3000e2c0:	e3a02000 	mov	r2, #0
3000e2c4:	e5c32001 	strb	r2, [r3, #1]
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
3000e2c8:	e59d3008 	ldr	r3, [sp, #8]
3000e2cc:	e3e02000 	mvn	r2, #0
3000e2d0:	e5832018 	str	r2, [r3, #24]
  conn->callback     = callback;
3000e2d4:	e59d3008 	ldr	r3, [sp, #8]
3000e2d8:	e59d2000 	ldr	r2, [sp]
3000e2dc:	e5832028 	str	r2, [r3, #40]	; 0x28
  conn->recv_avail   = 0;
3000e2e0:	e59d3008 	ldr	r3, [sp, #8]
3000e2e4:	e3a02000 	mov	r2, #0
3000e2e8:	e1c321bc 	strh	r2, [r3, #28]
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
3000e2ec:	e59d3008 	ldr	r3, [sp, #8]
}
3000e2f0:	e1a00003 	mov	r0, r3
3000e2f4:	e28dd014 	add	sp, sp, #20
3000e2f8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000e2fc:	e12fff1e 	bx	lr

3000e300 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
3000e300:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000e304:	e24dd014 	sub	sp, sp, #20
3000e308:	e58d0004 	str	r0, [sp, #4]
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
3000e30c:	e59d3004 	ldr	r3, [sp, #4]
3000e310:	e5933010 	ldr	r3, [r3, #16]
3000e314:	e3530000 	cmp	r3, #0
3000e318:	0a000021 	beq	3000e3a4 <netconn_free+0xa4>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
3000e31c:	ea00000f 	b	3000e360 <netconn_free+0x60>
      if (conn->type == NETCONN_TCP) {
3000e320:	e59d3004 	ldr	r3, [sp, #4]
3000e324:	e5d33000 	ldrb	r3, [r3]
3000e328:	e3530010 	cmp	r3, #16
3000e32c:	1a000006 	bne	3000e34c <netconn_free+0x4c>
        if(mem != NULL) {
3000e330:	e59d300c 	ldr	r3, [sp, #12]
3000e334:	e3530000 	cmp	r3, #0
3000e338:	0a000007 	beq	3000e35c <netconn_free+0x5c>
          pbuf_free((struct pbuf *)mem);
3000e33c:	e59d300c 	ldr	r3, [sp, #12]
3000e340:	e1a00003 	mov	r0, r3
3000e344:	eb002079 	bl	30016530 <pbuf_free>
3000e348:	ea000004 	b	3000e360 <netconn_free+0x60>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
3000e34c:	e59d300c 	ldr	r3, [sp, #12]
3000e350:	e1a00003 	mov	r0, r3
3000e354:	eb000473 	bl	3000f528 <netbuf_delete>
3000e358:	ea000000 	b	3000e360 <netconn_free+0x60>
  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
        if(mem != NULL) {
          pbuf_free((struct pbuf *)mem);
3000e35c:	e1a00000 	nop			; (mov r0, r0)
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
3000e360:	e59d3004 	ldr	r3, [sp, #4]
3000e364:	e5932010 	ldr	r2, [r3, #16]
3000e368:	e28d300c 	add	r3, sp, #12
3000e36c:	e1a00002 	mov	r0, r2
3000e370:	e1a01003 	mov	r1, r3
3000e374:	e3a02001 	mov	r2, #1
3000e378:	ebfffa49 	bl	3000cca4 <sys_arch_mbox_fetch>
3000e37c:	e1a03000 	mov	r3, r0
3000e380:	e3730001 	cmn	r3, #1
3000e384:	1affffe5 	bne	3000e320 <netconn_free+0x20>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
3000e388:	e59d3004 	ldr	r3, [sp, #4]
3000e38c:	e5933010 	ldr	r3, [r3, #16]
3000e390:	e1a00003 	mov	r0, r3
3000e394:	ebfffa03 	bl	3000cba8 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
3000e398:	e59d3004 	ldr	r3, [sp, #4]
3000e39c:	e3a02000 	mov	r2, #0
3000e3a0:	e5832010 	str	r2, [r3, #16]
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
3000e3a4:	e59d3004 	ldr	r3, [sp, #4]
3000e3a8:	e5933014 	ldr	r3, [r3, #20]
3000e3ac:	e3530000 	cmp	r3, #0
3000e3b0:	0a000014 	beq	3000e408 <netconn_free+0x108>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
3000e3b4:	ea000002 	b	3000e3c4 <netconn_free+0xc4>
      netconn_delete((struct netconn *)mem);
3000e3b8:	e59d300c 	ldr	r3, [sp, #12]
3000e3bc:	e1a00003 	mov	r0, r3
3000e3c0:	ebfffb2e 	bl	3000d080 <netconn_delete>
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
3000e3c4:	e59d3004 	ldr	r3, [sp, #4]
3000e3c8:	e5932014 	ldr	r2, [r3, #20]
3000e3cc:	e28d300c 	add	r3, sp, #12
3000e3d0:	e1a00002 	mov	r0, r2
3000e3d4:	e1a01003 	mov	r1, r3
3000e3d8:	e3a02001 	mov	r2, #1
3000e3dc:	ebfffa30 	bl	3000cca4 <sys_arch_mbox_fetch>
3000e3e0:	e1a03000 	mov	r3, r0
3000e3e4:	e3730001 	cmn	r3, #1
3000e3e8:	1afffff2 	bne	3000e3b8 <netconn_free+0xb8>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
3000e3ec:	e59d3004 	ldr	r3, [sp, #4]
3000e3f0:	e5933014 	ldr	r3, [r3, #20]
3000e3f4:	e1a00003 	mov	r0, r3
3000e3f8:	ebfff9ea 	bl	3000cba8 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
3000e3fc:	e59d3004 	ldr	r3, [sp, #4]
3000e400:	e3a02000 	mov	r2, #0
3000e404:	e5832014 	str	r2, [r3, #20]
  }

  sys_sem_free(conn->op_completed);
3000e408:	e59d3004 	ldr	r3, [sp, #4]
3000e40c:	e593300c 	ldr	r3, [r3, #12]
3000e410:	e1a00003 	mov	r0, r3
3000e414:	ebfff9b6 	bl	3000caf4 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
3000e418:	e59d3004 	ldr	r3, [sp, #4]
3000e41c:	e3a02000 	mov	r2, #0
3000e420:	e583200c 	str	r2, [r3, #12]

  memp_free(MEMP_NETCONN, conn);
3000e424:	e3a00006 	mov	r0, #6
3000e428:	e59d1004 	ldr	r1, [sp, #4]
3000e42c:	eb001cd4 	bl	30015784 <memp_free>
}
3000e430:	e28dd014 	add	sp, sp, #20
3000e434:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000e438:	e12fff1e 	bx	lr

3000e43c <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
3000e43c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000e440:	e24dd014 	sub	sp, sp, #20
3000e444:	e58d0004 	str	r0, [sp, #4]
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));

  /* Set back some callback pointers */
  if (conn->pcb.tcp->state == LISTEN) {
3000e448:	e59d3004 	ldr	r3, [sp, #4]
3000e44c:	e5933004 	ldr	r3, [r3, #4]
3000e450:	e5d33010 	ldrb	r3, [r3, #16]
3000e454:	e3530001 	cmp	r3, #1
3000e458:	1a00000a 	bne	3000e488 <do_close_internal+0x4c>
    tcp_arg(conn->pcb.tcp, NULL);
3000e45c:	e59d3004 	ldr	r3, [sp, #4]
3000e460:	e5933004 	ldr	r3, [r3, #4]
3000e464:	e1a00003 	mov	r0, r3
3000e468:	e3a01000 	mov	r1, #0
3000e46c:	eb002c00 	bl	30019474 <tcp_arg>
    tcp_accept(conn->pcb.tcp, NULL);
3000e470:	e59d3004 	ldr	r3, [sp, #4]
3000e474:	e5933004 	ldr	r3, [r3, #4]
3000e478:	e1a00003 	mov	r0, r3
3000e47c:	e3a01000 	mov	r1, #0
3000e480:	eb002c1b 	bl	300194f4 <tcp_accept>
3000e484:	ea000004 	b	3000e49c <do_close_internal+0x60>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
3000e488:	e59d3004 	ldr	r3, [sp, #4]
3000e48c:	e5933004 	ldr	r3, [r3, #4]
3000e490:	e1a00003 	mov	r0, r3
3000e494:	e3a01000 	mov	r1, #0
3000e498:	eb002bfd 	bl	30019494 <tcp_recv>
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
3000e49c:	e59d3004 	ldr	r3, [sp, #4]
3000e4a0:	e5933004 	ldr	r3, [r3, #4]
3000e4a4:	e1a00003 	mov	r0, r3
3000e4a8:	eb0024a7 	bl	3001774c <tcp_close>
3000e4ac:	e1a03000 	mov	r3, r0
3000e4b0:	e20330ff 	and	r3, r3, #255	; 0xff
3000e4b4:	e5cd300f 	strb	r3, [sp, #15]
  if (err == ERR_OK) {
3000e4b8:	e1dd30df 	ldrsb	r3, [sp, #15]
3000e4bc:	e3530000 	cmp	r3, #0
3000e4c0:	1a00003c 	bne	3000e5b8 <do_close_internal+0x17c>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
3000e4c4:	e59d3004 	ldr	r3, [sp, #4]
3000e4c8:	e3a02000 	mov	r2, #0
3000e4cc:	e5c32001 	strb	r2, [r3, #1]
    /* Set back some callback pointers as conn is going away */
    tcp_err(conn->pcb.tcp, NULL);
3000e4d0:	e59d3004 	ldr	r3, [sp, #4]
3000e4d4:	e5933004 	ldr	r3, [r3, #4]
3000e4d8:	e1a00003 	mov	r0, r3
3000e4dc:	e3a01000 	mov	r1, #0
3000e4e0:	eb002bfb 	bl	300194d4 <tcp_err>
    tcp_poll(conn->pcb.tcp, NULL, 4);
3000e4e4:	e59d3004 	ldr	r3, [sp, #4]
3000e4e8:	e5933004 	ldr	r3, [r3, #4]
3000e4ec:	e1a00003 	mov	r0, r3
3000e4f0:	e3a01000 	mov	r1, #0
3000e4f4:	e3a02004 	mov	r2, #4
3000e4f8:	eb002c05 	bl	30019514 <tcp_poll>
    tcp_sent(conn->pcb.tcp, NULL);
3000e4fc:	e59d3004 	ldr	r3, [sp, #4]
3000e500:	e5933004 	ldr	r3, [r3, #4]
3000e504:	e1a00003 	mov	r0, r3
3000e508:	e3a01000 	mov	r1, #0
3000e50c:	eb002be8 	bl	300194b4 <tcp_sent>
    tcp_recv(conn->pcb.tcp, NULL);
3000e510:	e59d3004 	ldr	r3, [sp, #4]
3000e514:	e5933004 	ldr	r3, [r3, #4]
3000e518:	e1a00003 	mov	r0, r3
3000e51c:	e3a01000 	mov	r1, #0
3000e520:	eb002bdb 	bl	30019494 <tcp_recv>
    tcp_arg(conn->pcb.tcp, NULL);
3000e524:	e59d3004 	ldr	r3, [sp, #4]
3000e528:	e5933004 	ldr	r3, [r3, #4]
3000e52c:	e1a00003 	mov	r0, r3
3000e530:	e3a01000 	mov	r1, #0
3000e534:	eb002bce 	bl	30019474 <tcp_arg>
    conn->pcb.tcp = NULL;
3000e538:	e59d3004 	ldr	r3, [sp, #4]
3000e53c:	e3a02000 	mov	r2, #0
3000e540:	e5832004 	str	r2, [r3, #4]
    conn->err = ERR_OK;
3000e544:	e59d3004 	ldr	r3, [sp, #4]
3000e548:	e3a02000 	mov	r2, #0
3000e54c:	e5c32008 	strb	r2, [r3, #8]
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
3000e550:	e59d3004 	ldr	r3, [sp, #4]
3000e554:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000e558:	e3530000 	cmp	r3, #0
3000e55c:	0a000006 	beq	3000e57c <do_close_internal+0x140>
3000e560:	e59d3004 	ldr	r3, [sp, #4]
3000e564:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000e568:	e59d0004 	ldr	r0, [sp, #4]
3000e56c:	e3a01000 	mov	r1, #0
3000e570:	e3a02000 	mov	r2, #0
3000e574:	e1a0e00f 	mov	lr, pc
3000e578:	e12fff13 	bx	r3
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
3000e57c:	e59d3004 	ldr	r3, [sp, #4]
3000e580:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000e584:	e3530000 	cmp	r3, #0
3000e588:	0a000006 	beq	3000e5a8 <do_close_internal+0x16c>
3000e58c:	e59d3004 	ldr	r3, [sp, #4]
3000e590:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000e594:	e59d0004 	ldr	r0, [sp, #4]
3000e598:	e3a01002 	mov	r1, #2
3000e59c:	e3a02000 	mov	r2, #0
3000e5a0:	e1a0e00f 	mov	lr, pc
3000e5a4:	e12fff13 	bx	r3
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
3000e5a8:	e59d3004 	ldr	r3, [sp, #4]
3000e5ac:	e593300c 	ldr	r3, [r3, #12]
3000e5b0:	e1a00003 	mov	r0, r3
3000e5b4:	ebfff957 	bl	3000cb18 <sys_sem_signal>
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
3000e5b8:	e28dd014 	add	sp, sp, #20
3000e5bc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000e5c0:	e12fff1e 	bx	lr

3000e5c4 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
3000e5c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000e5c8:	e24dd00c 	sub	sp, sp, #12
3000e5cc:	e58d0004 	str	r0, [sp, #4]
  if (msg->conn->pcb.tcp != NULL) {
3000e5d0:	e59d3004 	ldr	r3, [sp, #4]
3000e5d4:	e5933000 	ldr	r3, [r3]
3000e5d8:	e5933004 	ldr	r3, [r3, #4]
3000e5dc:	e3530000 	cmp	r3, #0
3000e5e0:	0a000024 	beq	3000e678 <do_delconn+0xb4>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
3000e5e4:	e59d3004 	ldr	r3, [sp, #4]
3000e5e8:	e5933000 	ldr	r3, [r3]
3000e5ec:	e5d33000 	ldrb	r3, [r3]
3000e5f0:	e20330f0 	and	r3, r3, #240	; 0xf0
3000e5f4:	e3530020 	cmp	r3, #32
3000e5f8:	0a00000a 	beq	3000e628 <do_delconn+0x64>
3000e5fc:	e3530040 	cmp	r3, #64	; 0x40
3000e600:	0a000002 	beq	3000e610 <do_delconn+0x4c>
3000e604:	e3530010 	cmp	r3, #16
3000e608:	0a000011 	beq	3000e654 <do_delconn+0x90>
3000e60c:	ea000019 	b	3000e678 <do_delconn+0xb4>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
3000e610:	e59d3004 	ldr	r3, [sp, #4]
3000e614:	e5933000 	ldr	r3, [r3]
3000e618:	e5933004 	ldr	r3, [r3, #4]
3000e61c:	e1a00003 	mov	r0, r3
3000e620:	eb00223d 	bl	30016f1c <raw_remove>
      break;
3000e624:	ea000013 	b	3000e678 <do_delconn+0xb4>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
3000e628:	e59d3004 	ldr	r3, [sp, #4]
3000e62c:	e5933000 	ldr	r3, [r3]
3000e630:	e5933004 	ldr	r3, [r3, #4]
3000e634:	e3a02000 	mov	r2, #0
3000e638:	e583201c 	str	r2, [r3, #28]
      udp_remove(msg->conn->pcb.udp);
3000e63c:	e59d3004 	ldr	r3, [sp, #4]
3000e640:	e5933000 	ldr	r3, [r3]
3000e644:	e5933004 	ldr	r3, [r3, #4]
3000e648:	e1a00003 	mov	r0, r3
3000e64c:	eb004912 	bl	30020a9c <udp_remove>
      break;
3000e650:	ea000008 	b	3000e678 <do_delconn+0xb4>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
3000e654:	e59d3004 	ldr	r3, [sp, #4]
3000e658:	e5933000 	ldr	r3, [r3]
3000e65c:	e3a02004 	mov	r2, #4
3000e660:	e5c32001 	strb	r2, [r3, #1]
      do_close_internal(msg->conn);
3000e664:	e59d3004 	ldr	r3, [sp, #4]
3000e668:	e5933000 	ldr	r3, [r3]
3000e66c:	e1a00003 	mov	r0, r3
3000e670:	ebffff71 	bl	3000e43c <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
3000e674:	ea000027 	b	3000e718 <do_delconn+0x154>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
3000e678:	e59d3004 	ldr	r3, [sp, #4]
3000e67c:	e5933000 	ldr	r3, [r3]
3000e680:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000e684:	e3530000 	cmp	r3, #0
3000e688:	0a000009 	beq	3000e6b4 <do_delconn+0xf0>
3000e68c:	e59d3004 	ldr	r3, [sp, #4]
3000e690:	e5933000 	ldr	r3, [r3]
3000e694:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000e698:	e59d2004 	ldr	r2, [sp, #4]
3000e69c:	e5922000 	ldr	r2, [r2]
3000e6a0:	e1a00002 	mov	r0, r2
3000e6a4:	e3a01000 	mov	r1, #0
3000e6a8:	e3a02000 	mov	r2, #0
3000e6ac:	e1a0e00f 	mov	lr, pc
3000e6b0:	e12fff13 	bx	r3
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
3000e6b4:	e59d3004 	ldr	r3, [sp, #4]
3000e6b8:	e5933000 	ldr	r3, [r3]
3000e6bc:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000e6c0:	e3530000 	cmp	r3, #0
3000e6c4:	0a000009 	beq	3000e6f0 <do_delconn+0x12c>
3000e6c8:	e59d3004 	ldr	r3, [sp, #4]
3000e6cc:	e5933000 	ldr	r3, [r3]
3000e6d0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000e6d4:	e59d2004 	ldr	r2, [sp, #4]
3000e6d8:	e5922000 	ldr	r2, [r2]
3000e6dc:	e1a00002 	mov	r0, r2
3000e6e0:	e3a01002 	mov	r1, #2
3000e6e4:	e3a02000 	mov	r2, #0
3000e6e8:	e1a0e00f 	mov	lr, pc
3000e6ec:	e12fff13 	bx	r3

  if (msg->conn->op_completed != SYS_SEM_NULL) {
3000e6f0:	e59d3004 	ldr	r3, [sp, #4]
3000e6f4:	e5933000 	ldr	r3, [r3]
3000e6f8:	e593300c 	ldr	r3, [r3, #12]
3000e6fc:	e3530000 	cmp	r3, #0
3000e700:	0a000004 	beq	3000e718 <do_delconn+0x154>
    sys_sem_signal(msg->conn->op_completed);
3000e704:	e59d3004 	ldr	r3, [sp, #4]
3000e708:	e5933000 	ldr	r3, [r3]
3000e70c:	e593300c 	ldr	r3, [r3, #12]
3000e710:	e1a00003 	mov	r0, r3
3000e714:	ebfff8ff 	bl	3000cb18 <sys_sem_signal>
  }
}
3000e718:	e28dd00c 	add	sp, sp, #12
3000e71c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000e720:	e12fff1e 	bx	lr

3000e724 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
3000e724:	e92d4010 	push	{r4, lr}
3000e728:	e24dd008 	sub	sp, sp, #8
3000e72c:	e58d0004 	str	r0, [sp, #4]
  if (!ERR_IS_FATAL(msg->conn->err)) {
3000e730:	e59d3004 	ldr	r3, [sp, #4]
3000e734:	e5933000 	ldr	r3, [r3]
3000e738:	e5d33008 	ldrb	r3, [r3, #8]
3000e73c:	e1a03c03 	lsl	r3, r3, #24
3000e740:	e1a03c43 	asr	r3, r3, #24
3000e744:	e3730003 	cmn	r3, #3
3000e748:	ba000044 	blt	3000e860 <do_bind+0x13c>
    if (msg->conn->pcb.tcp != NULL) {
3000e74c:	e59d3004 	ldr	r3, [sp, #4]
3000e750:	e5933000 	ldr	r3, [r3]
3000e754:	e5933004 	ldr	r3, [r3, #4]
3000e758:	e3530000 	cmp	r3, #0
3000e75c:	0a00003b 	beq	3000e850 <do_bind+0x12c>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
3000e760:	e59d3004 	ldr	r3, [sp, #4]
3000e764:	e5933000 	ldr	r3, [r3]
3000e768:	e5d33000 	ldrb	r3, [r3]
3000e76c:	e20330f0 	and	r3, r3, #240	; 0xf0
3000e770:	e3530020 	cmp	r3, #32
3000e774:	0a000012 	beq	3000e7c4 <do_bind+0xa0>
3000e778:	e3530040 	cmp	r3, #64	; 0x40
3000e77c:	0a000002 	beq	3000e78c <do_bind+0x68>
3000e780:	e3530010 	cmp	r3, #16
3000e784:	0a000020 	beq	3000e80c <do_bind+0xe8>
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
        break;
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
3000e788:	ea000034 	b	3000e860 <do_bind+0x13c>
  if (!ERR_IS_FATAL(msg->conn->err)) {
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
3000e78c:	e59d3004 	ldr	r3, [sp, #4]
3000e790:	e5934000 	ldr	r4, [r3]
3000e794:	e59d3004 	ldr	r3, [sp, #4]
3000e798:	e5933000 	ldr	r3, [r3]
3000e79c:	e5932004 	ldr	r2, [r3, #4]
3000e7a0:	e59d3004 	ldr	r3, [sp, #4]
3000e7a4:	e5933004 	ldr	r3, [r3, #4]
3000e7a8:	e1a00002 	mov	r0, r2
3000e7ac:	e1a01003 	mov	r1, r3
3000e7b0:	eb002126 	bl	30016c50 <raw_bind>
3000e7b4:	e1a03000 	mov	r3, r0
3000e7b8:	e20330ff 	and	r3, r3, #255	; 0xff
3000e7bc:	e5c43008 	strb	r3, [r4, #8]
        break;
3000e7c0:	ea000026 	b	3000e860 <do_bind+0x13c>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
3000e7c4:	e59d3004 	ldr	r3, [sp, #4]
3000e7c8:	e5934000 	ldr	r4, [r3]
3000e7cc:	e59d3004 	ldr	r3, [sp, #4]
3000e7d0:	e5933000 	ldr	r3, [r3]
3000e7d4:	e5931004 	ldr	r1, [r3, #4]
3000e7d8:	e59d3004 	ldr	r3, [sp, #4]
3000e7dc:	e5932004 	ldr	r2, [r3, #4]
3000e7e0:	e59d3004 	ldr	r3, [sp, #4]
3000e7e4:	e1d330b8 	ldrh	r3, [r3, #8]
3000e7e8:	e1a00001 	mov	r0, r1
3000e7ec:	e1a01002 	mov	r1, r2
3000e7f0:	e1a02003 	mov	r2, r3
3000e7f4:	eb0047cc 	bl	3002072c <udp_bind>
3000e7f8:	e1a03000 	mov	r3, r0
3000e7fc:	e20330ff 	and	r3, r3, #255	; 0xff
3000e800:	e5c43008 	strb	r3, [r4, #8]
        break;
3000e804:	e1a00000 	nop			; (mov r0, r0)
3000e808:	ea000014 	b	3000e860 <do_bind+0x13c>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
3000e80c:	e59d3004 	ldr	r3, [sp, #4]
3000e810:	e5934000 	ldr	r4, [r3]
3000e814:	e59d3004 	ldr	r3, [sp, #4]
3000e818:	e5933000 	ldr	r3, [r3]
3000e81c:	e5931004 	ldr	r1, [r3, #4]
3000e820:	e59d3004 	ldr	r3, [sp, #4]
3000e824:	e5932004 	ldr	r2, [r3, #4]
3000e828:	e59d3004 	ldr	r3, [sp, #4]
3000e82c:	e1d330b8 	ldrh	r3, [r3, #8]
3000e830:	e1a00001 	mov	r0, r1
3000e834:	e1a01002 	mov	r1, r2
3000e838:	e1a02003 	mov	r2, r3
3000e83c:	eb0024c6 	bl	30017b5c <tcp_bind>
3000e840:	e1a03000 	mov	r3, r0
3000e844:	e20330ff 	and	r3, r3, #255	; 0xff
3000e848:	e5c43008 	strb	r3, [r4, #8]
3000e84c:	ea000003 	b	3000e860 <do_bind+0x13c>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
3000e850:	e59d3004 	ldr	r3, [sp, #4]
3000e854:	e5933000 	ldr	r3, [r3]
3000e858:	e3e02007 	mvn	r2, #7
3000e85c:	e5c32008 	strb	r2, [r3, #8]
    }
  }
  TCPIP_APIMSG_ACK(msg);
3000e860:	e59d3004 	ldr	r3, [sp, #4]
3000e864:	e5933000 	ldr	r3, [r3]
3000e868:	e593300c 	ldr	r3, [r3, #12]
3000e86c:	e1a00003 	mov	r0, r3
3000e870:	ebfff8a8 	bl	3000cb18 <sys_sem_signal>
}
3000e874:	e28dd008 	add	sp, sp, #8
3000e878:	e8bd4010 	pop	{r4, lr}
3000e87c:	e12fff1e 	bx	lr

3000e880 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
3000e880:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000e884:	e24dd01c 	sub	sp, sp, #28
3000e888:	e58d000c 	str	r0, [sp, #12]
3000e88c:	e58d1008 	str	r1, [sp, #8]
3000e890:	e1a03002 	mov	r3, r2
3000e894:	e5cd3007 	strb	r3, [sp, #7]
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
3000e898:	e59d300c 	ldr	r3, [sp, #12]
3000e89c:	e58d3014 	str	r3, [sp, #20]

  if (conn == NULL) {
3000e8a0:	e59d3014 	ldr	r3, [sp, #20]
3000e8a4:	e3530000 	cmp	r3, #0
3000e8a8:	1a000001 	bne	3000e8b4 <do_connected+0x34>
    return ERR_VAL;
3000e8ac:	e3a030f8 	mov	r3, #248	; 0xf8
3000e8b0:	ea000013 	b	3000e904 <do_connected+0x84>
  }

  conn->err = err;
3000e8b4:	e59d3014 	ldr	r3, [sp, #20]
3000e8b8:	e5dd2007 	ldrb	r2, [sp, #7]
3000e8bc:	e5c32008 	strb	r2, [r3, #8]
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
3000e8c0:	e59d3014 	ldr	r3, [sp, #20]
3000e8c4:	e5d33000 	ldrb	r3, [r3]
3000e8c8:	e3530010 	cmp	r3, #16
3000e8cc:	1a000004 	bne	3000e8e4 <do_connected+0x64>
3000e8d0:	e1dd30d7 	ldrsb	r3, [sp, #7]
3000e8d4:	e3530000 	cmp	r3, #0
3000e8d8:	1a000001 	bne	3000e8e4 <do_connected+0x64>
    setup_tcp(conn);
3000e8dc:	e59d0014 	ldr	r0, [sp, #20]
3000e8e0:	ebfffd56 	bl	3000de40 <setup_tcp>
  }
  conn->state = NETCONN_NONE;
3000e8e4:	e59d3014 	ldr	r3, [sp, #20]
3000e8e8:	e3a02000 	mov	r2, #0
3000e8ec:	e5c32001 	strb	r2, [r3, #1]
  sys_sem_signal(conn->op_completed);
3000e8f0:	e59d3014 	ldr	r3, [sp, #20]
3000e8f4:	e593300c 	ldr	r3, [r3, #12]
3000e8f8:	e1a00003 	mov	r0, r3
3000e8fc:	ebfff885 	bl	3000cb18 <sys_sem_signal>
  return ERR_OK;
3000e900:	e3a03000 	mov	r3, #0
3000e904:	e1a03c03 	lsl	r3, r3, #24
3000e908:	e1a03c43 	asr	r3, r3, #24
}
3000e90c:	e1a00003 	mov	r0, r3
3000e910:	e28dd01c 	add	sp, sp, #28
3000e914:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000e918:	e12fff1e 	bx	lr

3000e91c <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
3000e91c:	e92d4010 	push	{r4, lr}
3000e920:	e24dd008 	sub	sp, sp, #8
3000e924:	e58d0004 	str	r0, [sp, #4]
  if (msg->conn->pcb.tcp == NULL) {
3000e928:	e59d3004 	ldr	r3, [sp, #4]
3000e92c:	e5933000 	ldr	r3, [r3]
3000e930:	e5933004 	ldr	r3, [r3, #4]
3000e934:	e3530000 	cmp	r3, #0
3000e938:	1a000005 	bne	3000e954 <do_connect+0x38>
    sys_sem_signal(msg->conn->op_completed);
3000e93c:	e59d3004 	ldr	r3, [sp, #4]
3000e940:	e5933000 	ldr	r3, [r3]
3000e944:	e593300c 	ldr	r3, [r3, #12]
3000e948:	e1a00003 	mov	r0, r3
3000e94c:	ebfff871 	bl	3000cb18 <sys_sem_signal>
    return;
3000e950:	ea00004c 	b	3000ea88 <do_connect+0x16c>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
3000e954:	e59d3004 	ldr	r3, [sp, #4]
3000e958:	e5933000 	ldr	r3, [r3]
3000e95c:	e5d33000 	ldrb	r3, [r3]
3000e960:	e20330f0 	and	r3, r3, #240	; 0xf0
3000e964:	e3530020 	cmp	r3, #32
3000e968:	0a000017 	beq	3000e9cc <do_connect+0xb0>
3000e96c:	e3530040 	cmp	r3, #64	; 0x40
3000e970:	0a000002 	beq	3000e980 <do_connect+0x64>
3000e974:	e3530010 	cmp	r3, #16
3000e978:	0a000029 	beq	3000ea24 <do_connect+0x108>
3000e97c:	ea000041 	b	3000ea88 <do_connect+0x16c>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
3000e980:	e59d3004 	ldr	r3, [sp, #4]
3000e984:	e5934000 	ldr	r4, [r3]
3000e988:	e59d3004 	ldr	r3, [sp, #4]
3000e98c:	e5933000 	ldr	r3, [r3]
3000e990:	e5932004 	ldr	r2, [r3, #4]
3000e994:	e59d3004 	ldr	r3, [sp, #4]
3000e998:	e5933004 	ldr	r3, [r3, #4]
3000e99c:	e1a00002 	mov	r0, r2
3000e9a0:	e1a01003 	mov	r1, r3
3000e9a4:	eb0020c4 	bl	30016cbc <raw_connect>
3000e9a8:	e1a03000 	mov	r3, r0
3000e9ac:	e20330ff 	and	r3, r3, #255	; 0xff
3000e9b0:	e5c43008 	strb	r3, [r4, #8]
    sys_sem_signal(msg->conn->op_completed);
3000e9b4:	e59d3004 	ldr	r3, [sp, #4]
3000e9b8:	e5933000 	ldr	r3, [r3]
3000e9bc:	e593300c 	ldr	r3, [r3, #12]
3000e9c0:	e1a00003 	mov	r0, r3
3000e9c4:	ebfff853 	bl	3000cb18 <sys_sem_signal>
    break;
3000e9c8:	ea00002e 	b	3000ea88 <do_connect+0x16c>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
3000e9cc:	e59d3004 	ldr	r3, [sp, #4]
3000e9d0:	e5934000 	ldr	r4, [r3]
3000e9d4:	e59d3004 	ldr	r3, [sp, #4]
3000e9d8:	e5933000 	ldr	r3, [r3]
3000e9dc:	e5931004 	ldr	r1, [r3, #4]
3000e9e0:	e59d3004 	ldr	r3, [sp, #4]
3000e9e4:	e5932004 	ldr	r2, [r3, #4]
3000e9e8:	e59d3004 	ldr	r3, [sp, #4]
3000e9ec:	e1d330b8 	ldrh	r3, [r3, #8]
3000e9f0:	e1a00001 	mov	r0, r1
3000e9f4:	e1a01002 	mov	r1, r2
3000e9f8:	e1a02003 	mov	r2, r3
3000e9fc:	eb0047ac 	bl	300208b4 <udp_connect>
3000ea00:	e1a03000 	mov	r3, r0
3000ea04:	e20330ff 	and	r3, r3, #255	; 0xff
3000ea08:	e5c43008 	strb	r3, [r4, #8]
    sys_sem_signal(msg->conn->op_completed);
3000ea0c:	e59d3004 	ldr	r3, [sp, #4]
3000ea10:	e5933000 	ldr	r3, [r3]
3000ea14:	e593300c 	ldr	r3, [r3, #12]
3000ea18:	e1a00003 	mov	r0, r3
3000ea1c:	ebfff83d 	bl	3000cb18 <sys_sem_signal>
    break;
3000ea20:	ea000018 	b	3000ea88 <do_connect+0x16c>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
3000ea24:	e59d3004 	ldr	r3, [sp, #4]
3000ea28:	e5933000 	ldr	r3, [r3]
3000ea2c:	e3a02003 	mov	r2, #3
3000ea30:	e5c32001 	strb	r2, [r3, #1]
    setup_tcp(msg->conn);
3000ea34:	e59d3004 	ldr	r3, [sp, #4]
3000ea38:	e5933000 	ldr	r3, [r3]
3000ea3c:	e1a00003 	mov	r0, r3
3000ea40:	ebfffcfe 	bl	3000de40 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
3000ea44:	e59d3004 	ldr	r3, [sp, #4]
3000ea48:	e5934000 	ldr	r4, [r3]
3000ea4c:	e59d3004 	ldr	r3, [sp, #4]
3000ea50:	e5933000 	ldr	r3, [r3]
3000ea54:	e5931004 	ldr	r1, [r3, #4]
3000ea58:	e59d3004 	ldr	r3, [sp, #4]
3000ea5c:	e5932004 	ldr	r2, [r3, #4]
3000ea60:	e59d3004 	ldr	r3, [sp, #4]
3000ea64:	e1d330b8 	ldrh	r3, [r3, #8]
3000ea68:	e1a00001 	mov	r0, r1
3000ea6c:	e1a01002 	mov	r1, r2
3000ea70:	e1a02003 	mov	r2, r3
3000ea74:	e59f3018 	ldr	r3, [pc, #24]	; 3000ea94 <do_connect+0x178>
3000ea78:	eb002677 	bl	3001845c <tcp_connect>
3000ea7c:	e1a03000 	mov	r3, r0
3000ea80:	e20330ff 	and	r3, r3, #255	; 0xff
3000ea84:	e5c43008 	strb	r3, [r4, #8]
    break;
#endif /* LWIP_TCP */
  default:
    break;
  }
}
3000ea88:	e28dd008 	add	sp, sp, #8
3000ea8c:	e8bd4010 	pop	{r4, lr}
3000ea90:	e12fff1e 	bx	lr
3000ea94:	3000e880 	.word	0x3000e880

3000ea98 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
3000ea98:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000ea9c:	e24dd00c 	sub	sp, sp, #12
3000eaa0:	e58d0004 	str	r0, [sp, #4]
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
3000eaa4:	e59d3004 	ldr	r3, [sp, #4]
3000eaa8:	e5933000 	ldr	r3, [r3]
3000eaac:	e5d33000 	ldrb	r3, [r3]
3000eab0:	e20330f0 	and	r3, r3, #240	; 0xf0
3000eab4:	e3530020 	cmp	r3, #32
3000eab8:	1a000004 	bne	3000ead0 <do_disconnect+0x38>
    udp_disconnect(msg->conn->pcb.udp);
3000eabc:	e59d3004 	ldr	r3, [sp, #4]
3000eac0:	e5933000 	ldr	r3, [r3]
3000eac4:	e5933004 	ldr	r3, [r3, #4]
3000eac8:	e1a00003 	mov	r0, r3
3000eacc:	eb0047cb 	bl	30020a00 <udp_disconnect>
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
3000ead0:	e59d3004 	ldr	r3, [sp, #4]
3000ead4:	e5933000 	ldr	r3, [r3]
3000ead8:	e593300c 	ldr	r3, [r3, #12]
3000eadc:	e1a00003 	mov	r0, r3
3000eae0:	ebfff80c 	bl	3000cb18 <sys_sem_signal>
}
3000eae4:	e28dd00c 	add	sp, sp, #12
3000eae8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000eaec:	e12fff1e 	bx	lr

3000eaf0 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
3000eaf0:	e92d4010 	push	{r4, lr}
3000eaf4:	e24dd010 	sub	sp, sp, #16
3000eaf8:	e58d0004 	str	r0, [sp, #4]
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
3000eafc:	e59d3004 	ldr	r3, [sp, #4]
3000eb00:	e5933000 	ldr	r3, [r3]
3000eb04:	e5d33008 	ldrb	r3, [r3, #8]
3000eb08:	e1a03c03 	lsl	r3, r3, #24
3000eb0c:	e1a03c43 	asr	r3, r3, #24
3000eb10:	e3730003 	cmn	r3, #3
3000eb14:	ba000061 	blt	3000eca0 <do_listen+0x1b0>
    if (msg->conn->pcb.tcp != NULL) {
3000eb18:	e59d3004 	ldr	r3, [sp, #4]
3000eb1c:	e5933000 	ldr	r3, [r3]
3000eb20:	e5933004 	ldr	r3, [r3, #4]
3000eb24:	e3530000 	cmp	r3, #0
3000eb28:	0a00005c 	beq	3000eca0 <do_listen+0x1b0>
      if (msg->conn->type == NETCONN_TCP) {
3000eb2c:	e59d3004 	ldr	r3, [sp, #4]
3000eb30:	e5933000 	ldr	r3, [r3]
3000eb34:	e5d33000 	ldrb	r3, [r3]
3000eb38:	e3530010 	cmp	r3, #16
3000eb3c:	1a000057 	bne	3000eca0 <do_listen+0x1b0>
        if (msg->conn->pcb.tcp->state == CLOSED) {
3000eb40:	e59d3004 	ldr	r3, [sp, #4]
3000eb44:	e5933000 	ldr	r3, [r3]
3000eb48:	e5933004 	ldr	r3, [r3, #4]
3000eb4c:	e5d33010 	ldrb	r3, [r3, #16]
3000eb50:	e3530000 	cmp	r3, #0
3000eb54:	1a00004b 	bne	3000ec88 <do_listen+0x198>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
3000eb58:	e59d3004 	ldr	r3, [sp, #4]
3000eb5c:	e5933000 	ldr	r3, [r3]
3000eb60:	e5933004 	ldr	r3, [r3, #4]
3000eb64:	e1a00003 	mov	r0, r3
3000eb68:	e3a010ff 	mov	r1, #255	; 0xff
3000eb6c:	eb00250a 	bl	30017f9c <tcp_listen_with_backlog>
3000eb70:	e1a03000 	mov	r3, r0
3000eb74:	e58d300c 	str	r3, [sp, #12]
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
3000eb78:	e59d300c 	ldr	r3, [sp, #12]
3000eb7c:	e3530000 	cmp	r3, #0
3000eb80:	1a000004 	bne	3000eb98 <do_listen+0xa8>
            msg->conn->err = ERR_MEM;
3000eb84:	e59d3004 	ldr	r3, [sp, #4]
3000eb88:	e5933000 	ldr	r3, [r3]
3000eb8c:	e3e02000 	mvn	r2, #0
3000eb90:	e5c32008 	strb	r2, [r3, #8]
            }
            if (msg->conn->err == ERR_OK) {
              msg->conn->state = NETCONN_LISTEN;
              msg->conn->pcb.tcp = lpcb;
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
              tcp_accept(msg->conn->pcb.tcp, accept_function);
3000eb94:	ea000041 	b	3000eca0 <do_listen+0x1b0>
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
            msg->conn->err = ERR_MEM;
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
3000eb98:	e59d3004 	ldr	r3, [sp, #4]
3000eb9c:	e5933000 	ldr	r3, [r3]
3000eba0:	e5933010 	ldr	r3, [r3, #16]
3000eba4:	e3530000 	cmp	r3, #0
3000eba8:	0a000008 	beq	3000ebd0 <do_listen+0xe0>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
3000ebac:	e59d3004 	ldr	r3, [sp, #4]
3000ebb0:	e5933000 	ldr	r3, [r3]
3000ebb4:	e5933010 	ldr	r3, [r3, #16]
3000ebb8:	e1a00003 	mov	r0, r3
3000ebbc:	ebfff7f9 	bl	3000cba8 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
3000ebc0:	e59d3004 	ldr	r3, [sp, #4]
3000ebc4:	e5933000 	ldr	r3, [r3]
3000ebc8:	e3a02000 	mov	r2, #0
3000ebcc:	e5832010 	str	r2, [r3, #16]
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
3000ebd0:	e59d3004 	ldr	r3, [sp, #4]
3000ebd4:	e5933000 	ldr	r3, [r3]
3000ebd8:	e5933014 	ldr	r3, [r3, #20]
3000ebdc:	e3530000 	cmp	r3, #0
3000ebe0:	1a00000c 	bne	3000ec18 <do_listen+0x128>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
3000ebe4:	e59d3004 	ldr	r3, [sp, #4]
3000ebe8:	e5934000 	ldr	r4, [r3]
3000ebec:	e3a0000a 	mov	r0, #10
3000ebf0:	ebfff7e1 	bl	3000cb7c <sys_mbox_new>
3000ebf4:	e1a03000 	mov	r3, r0
3000ebf8:	e5843014 	str	r3, [r4, #20]
3000ebfc:	e5943014 	ldr	r3, [r4, #20]
3000ec00:	e3530000 	cmp	r3, #0
3000ec04:	1a000003 	bne	3000ec18 <do_listen+0x128>
                msg->conn->err = ERR_MEM;
3000ec08:	e59d3004 	ldr	r3, [sp, #4]
3000ec0c:	e5933000 	ldr	r3, [r3]
3000ec10:	e3e02000 	mvn	r2, #0
3000ec14:	e5c32008 	strb	r2, [r3, #8]
              }
            }
            if (msg->conn->err == ERR_OK) {
3000ec18:	e59d3004 	ldr	r3, [sp, #4]
3000ec1c:	e5933000 	ldr	r3, [r3]
3000ec20:	e5d33008 	ldrb	r3, [r3, #8]
3000ec24:	e3530000 	cmp	r3, #0
3000ec28:	1a00001b 	bne	3000ec9c <do_listen+0x1ac>
              msg->conn->state = NETCONN_LISTEN;
3000ec2c:	e59d3004 	ldr	r3, [sp, #4]
3000ec30:	e5933000 	ldr	r3, [r3]
3000ec34:	e3a02002 	mov	r2, #2
3000ec38:	e5c32001 	strb	r2, [r3, #1]
              msg->conn->pcb.tcp = lpcb;
3000ec3c:	e59d3004 	ldr	r3, [sp, #4]
3000ec40:	e5933000 	ldr	r3, [r3]
3000ec44:	e59d200c 	ldr	r2, [sp, #12]
3000ec48:	e5832004 	str	r2, [r3, #4]
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
3000ec4c:	e59d3004 	ldr	r3, [sp, #4]
3000ec50:	e5933000 	ldr	r3, [r3]
3000ec54:	e5932004 	ldr	r2, [r3, #4]
3000ec58:	e59d3004 	ldr	r3, [sp, #4]
3000ec5c:	e5933000 	ldr	r3, [r3]
3000ec60:	e1a00002 	mov	r0, r2
3000ec64:	e1a01003 	mov	r1, r3
3000ec68:	eb002a01 	bl	30019474 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
3000ec6c:	e59d3004 	ldr	r3, [sp, #4]
3000ec70:	e5933000 	ldr	r3, [r3]
3000ec74:	e5933004 	ldr	r3, [r3, #4]
3000ec78:	e1a00003 	mov	r0, r3
3000ec7c:	e59f103c 	ldr	r1, [pc, #60]	; 3000ecc0 <do_listen+0x1d0>
3000ec80:	eb002a1b 	bl	300194f4 <tcp_accept>
3000ec84:	ea000005 	b	3000eca0 <do_listen+0x1b0>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
3000ec88:	e59d3004 	ldr	r3, [sp, #4]
3000ec8c:	e5933000 	ldr	r3, [r3]
3000ec90:	e3e02006 	mvn	r2, #6
3000ec94:	e5c32008 	strb	r2, [r3, #8]
3000ec98:	ea000000 	b	3000eca0 <do_listen+0x1b0>
            }
            if (msg->conn->err == ERR_OK) {
              msg->conn->state = NETCONN_LISTEN;
              msg->conn->pcb.tcp = lpcb;
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
              tcp_accept(msg->conn->pcb.tcp, accept_function);
3000ec9c:	e1a00000 	nop			; (mov r0, r0)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
3000eca0:	e59d3004 	ldr	r3, [sp, #4]
3000eca4:	e5933000 	ldr	r3, [r3]
3000eca8:	e593300c 	ldr	r3, [r3, #12]
3000ecac:	e1a00003 	mov	r0, r3
3000ecb0:	ebfff798 	bl	3000cb18 <sys_sem_signal>
}
3000ecb4:	e28dd010 	add	sp, sp, #16
3000ecb8:	e8bd4010 	pop	{r4, lr}
3000ecbc:	e12fff1e 	bx	lr
3000ecc0:	3000deb4 	.word	0x3000deb4

3000ecc4 <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
3000ecc4:	e92d4010 	push	{r4, lr}
3000ecc8:	e24dd008 	sub	sp, sp, #8
3000eccc:	e58d0004 	str	r0, [sp, #4]
  if (!ERR_IS_FATAL(msg->conn->err)) {
3000ecd0:	e59d3004 	ldr	r3, [sp, #4]
3000ecd4:	e5933000 	ldr	r3, [r3]
3000ecd8:	e5d33008 	ldrb	r3, [r3, #8]
3000ecdc:	e1a03c03 	lsl	r3, r3, #24
3000ece0:	e1a03c43 	asr	r3, r3, #24
3000ece4:	e3730003 	cmn	r3, #3
3000ece8:	ba000059 	blt	3000ee54 <do_send+0x190>
    if (msg->conn->pcb.tcp != NULL) {
3000ecec:	e59d3004 	ldr	r3, [sp, #4]
3000ecf0:	e5933000 	ldr	r3, [r3]
3000ecf4:	e5933004 	ldr	r3, [r3, #4]
3000ecf8:	e3530000 	cmp	r3, #0
3000ecfc:	0a000054 	beq	3000ee54 <do_send+0x190>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
3000ed00:	e59d3004 	ldr	r3, [sp, #4]
3000ed04:	e5933000 	ldr	r3, [r3]
3000ed08:	e5d33000 	ldrb	r3, [r3]
3000ed0c:	e20330f0 	and	r3, r3, #240	; 0xf0
3000ed10:	e3530020 	cmp	r3, #32
3000ed14:	0a000028 	beq	3000edbc <do_send+0xf8>
3000ed18:	e3530040 	cmp	r3, #64	; 0x40
3000ed1c:	1a00004c 	bne	3000ee54 <do_send+0x190>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
3000ed20:	e59d3004 	ldr	r3, [sp, #4]
3000ed24:	e5933004 	ldr	r3, [r3, #4]
3000ed28:	e5933008 	ldr	r3, [r3, #8]
3000ed2c:	e3530000 	cmp	r3, #0
3000ed30:	1a00000e 	bne	3000ed70 <do_send+0xac>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
3000ed34:	e59d3004 	ldr	r3, [sp, #4]
3000ed38:	e5934000 	ldr	r4, [r3]
3000ed3c:	e59d3004 	ldr	r3, [sp, #4]
3000ed40:	e5933000 	ldr	r3, [r3]
3000ed44:	e5932004 	ldr	r2, [r3, #4]
3000ed48:	e59d3004 	ldr	r3, [sp, #4]
3000ed4c:	e5933004 	ldr	r3, [r3, #4]
3000ed50:	e5933000 	ldr	r3, [r3]
3000ed54:	e1a00002 	mov	r0, r2
3000ed58:	e1a01003 	mov	r1, r3
3000ed5c:	eb00205b 	bl	30016ed0 <raw_send>
3000ed60:	e1a03000 	mov	r3, r0
3000ed64:	e20330ff 	and	r3, r3, #255	; 0xff
3000ed68:	e5c43008 	strb	r3, [r4, #8]
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
        }
        break;
3000ed6c:	ea000038 	b	3000ee54 <do_send+0x190>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
3000ed70:	e59d3004 	ldr	r3, [sp, #4]
3000ed74:	e5934000 	ldr	r4, [r3]
3000ed78:	e59d3004 	ldr	r3, [sp, #4]
3000ed7c:	e5933000 	ldr	r3, [r3]
3000ed80:	e5931004 	ldr	r1, [r3, #4]
3000ed84:	e59d3004 	ldr	r3, [sp, #4]
3000ed88:	e5933004 	ldr	r3, [r3, #4]
3000ed8c:	e5932000 	ldr	r2, [r3]
3000ed90:	e59d3004 	ldr	r3, [sp, #4]
3000ed94:	e5933004 	ldr	r3, [r3, #4]
3000ed98:	e5933008 	ldr	r3, [r3, #8]
3000ed9c:	e1a00001 	mov	r0, r1
3000eda0:	e1a01002 	mov	r1, r2
3000eda4:	e1a02003 	mov	r2, r3
3000eda8:	eb001fea 	bl	30016d58 <raw_sendto>
3000edac:	e1a03000 	mov	r3, r0
3000edb0:	e20330ff 	and	r3, r3, #255	; 0xff
3000edb4:	e5c43008 	strb	r3, [r4, #8]
        }
        break;
3000edb8:	ea000025 	b	3000ee54 <do_send+0x190>
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
3000edbc:	e59d3004 	ldr	r3, [sp, #4]
3000edc0:	e5933004 	ldr	r3, [r3, #4]
3000edc4:	e5933008 	ldr	r3, [r3, #8]
3000edc8:	e3530000 	cmp	r3, #0
3000edcc:	1a00000e 	bne	3000ee0c <do_send+0x148>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
3000edd0:	e59d3004 	ldr	r3, [sp, #4]
3000edd4:	e5934000 	ldr	r4, [r3]
3000edd8:	e59d3004 	ldr	r3, [sp, #4]
3000eddc:	e5933000 	ldr	r3, [r3]
3000ede0:	e5932004 	ldr	r2, [r3, #4]
3000ede4:	e59d3004 	ldr	r3, [sp, #4]
3000ede8:	e5933004 	ldr	r3, [r3, #4]
3000edec:	e5933000 	ldr	r3, [r3]
3000edf0:	e1a00002 	mov	r0, r2
3000edf4:	e1a01003 	mov	r1, r3
3000edf8:	eb00453a 	bl	300202e8 <udp_send>
3000edfc:	e1a03000 	mov	r3, r0
3000ee00:	e20330ff 	and	r3, r3, #255	; 0xff
3000ee04:	e5c43008 	strb	r3, [r4, #8]
3000ee08:	ea000011 	b	3000ee54 <do_send+0x190>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
3000ee0c:	e59d3004 	ldr	r3, [sp, #4]
3000ee10:	e5934000 	ldr	r4, [r3]
3000ee14:	e59d3004 	ldr	r3, [sp, #4]
3000ee18:	e5933000 	ldr	r3, [r3]
3000ee1c:	e5930004 	ldr	r0, [r3, #4]
3000ee20:	e59d3004 	ldr	r3, [sp, #4]
3000ee24:	e5933004 	ldr	r3, [r3, #4]
3000ee28:	e5931000 	ldr	r1, [r3]
3000ee2c:	e59d3004 	ldr	r3, [sp, #4]
3000ee30:	e5933004 	ldr	r3, [r3, #4]
3000ee34:	e5932008 	ldr	r2, [r3, #8]
3000ee38:	e59d3004 	ldr	r3, [sp, #4]
3000ee3c:	e5933004 	ldr	r3, [r3, #4]
3000ee40:	e1d330bc 	ldrh	r3, [r3, #12]
3000ee44:	eb00453b 	bl	30020338 <udp_sendto>
3000ee48:	e1a03000 	mov	r3, r0
3000ee4c:	e20330ff 	and	r3, r3, #255	; 0xff
3000ee50:	e5c43008 	strb	r3, [r4, #8]
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
3000ee54:	e59d3004 	ldr	r3, [sp, #4]
3000ee58:	e5933000 	ldr	r3, [r3]
3000ee5c:	e593300c 	ldr	r3, [r3, #12]
3000ee60:	e1a00003 	mov	r0, r3
3000ee64:	ebfff72b 	bl	3000cb18 <sys_sem_signal>
}
3000ee68:	e28dd008 	add	sp, sp, #8
3000ee6c:	e8bd4010 	pop	{r4, lr}
3000ee70:	e12fff1e 	bx	lr

3000ee74 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
3000ee74:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000ee78:	e24dd00c 	sub	sp, sp, #12
3000ee7c:	e58d0004 	str	r0, [sp, #4]
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
3000ee80:	e59d3004 	ldr	r3, [sp, #4]
3000ee84:	e5933000 	ldr	r3, [r3]
3000ee88:	e5d33008 	ldrb	r3, [r3, #8]
3000ee8c:	e1a03c03 	lsl	r3, r3, #24
3000ee90:	e1a03c43 	asr	r3, r3, #24
3000ee94:	e3730003 	cmn	r3, #3
3000ee98:	ba000011 	blt	3000eee4 <do_recv+0x70>
    if (msg->conn->pcb.tcp != NULL) {
3000ee9c:	e59d3004 	ldr	r3, [sp, #4]
3000eea0:	e5933000 	ldr	r3, [r3]
3000eea4:	e5933004 	ldr	r3, [r3, #4]
3000eea8:	e3530000 	cmp	r3, #0
3000eeac:	0a00000c 	beq	3000eee4 <do_recv+0x70>
      if (msg->conn->type == NETCONN_TCP) {
3000eeb0:	e59d3004 	ldr	r3, [sp, #4]
3000eeb4:	e5933000 	ldr	r3, [r3]
3000eeb8:	e5d33000 	ldrb	r3, [r3]
3000eebc:	e3530010 	cmp	r3, #16
3000eec0:	1a000007 	bne	3000eee4 <do_recv+0x70>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
3000eec4:	e59d3004 	ldr	r3, [sp, #4]
3000eec8:	e5933000 	ldr	r3, [r3]
3000eecc:	e5932004 	ldr	r2, [r3, #4]
3000eed0:	e59d3004 	ldr	r3, [sp, #4]
3000eed4:	e1d330b4 	ldrh	r3, [r3, #4]
3000eed8:	e1a00002 	mov	r0, r2
3000eedc:	e1a01003 	mov	r1, r3
3000eee0:	eb0024ac 	bl	30018198 <tcp_recved>
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
3000eee4:	e59d3004 	ldr	r3, [sp, #4]
3000eee8:	e5933000 	ldr	r3, [r3]
3000eeec:	e593300c 	ldr	r3, [r3, #12]
3000eef0:	e1a00003 	mov	r0, r3
3000eef4:	ebfff707 	bl	3000cb18 <sys_sem_signal>
}
3000eef8:	e28dd00c 	add	sp, sp, #12
3000eefc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000ef00:	e12fff1e 	bx	lr

3000ef04 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
3000ef04:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000ef08:	e24dd01c 	sub	sp, sp, #28
3000ef0c:	e58d0004 	str	r0, [sp, #4]
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
3000ef10:	e3a03000 	mov	r3, #0
3000ef14:	e5cd3017 	strb	r3, [sp, #23]

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
3000ef18:	e59d3004 	ldr	r3, [sp, #4]
3000ef1c:	e5933020 	ldr	r3, [r3, #32]
3000ef20:	e5932004 	ldr	r2, [r3, #4]
3000ef24:	e59d3004 	ldr	r3, [sp, #4]
3000ef28:	e5933024 	ldr	r3, [r3, #36]	; 0x24
3000ef2c:	e0823003 	add	r3, r2, r3
3000ef30:	e58d300c 	str	r3, [sp, #12]
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
3000ef34:	e59d3004 	ldr	r3, [sp, #4]
3000ef38:	e5933020 	ldr	r3, [r3, #32]
3000ef3c:	e5932008 	ldr	r2, [r3, #8]
3000ef40:	e59d3004 	ldr	r3, [sp, #4]
3000ef44:	e5933024 	ldr	r3, [r3, #36]	; 0x24
3000ef48:	e0632002 	rsb	r2, r3, r2
3000ef4c:	e3a03801 	mov	r3, #65536	; 0x10000
3000ef50:	e2433001 	sub	r3, r3, #1
3000ef54:	e1520003 	cmp	r2, r3
3000ef58:	da000002 	ble	3000ef68 <do_writemore+0x64>
    len = 0xffff;
3000ef5c:	e3e03000 	mvn	r3, #0
3000ef60:	e1cd31b2 	strh	r3, [sp, #18]
3000ef64:	ea00000a 	b	3000ef94 <do_writemore+0x90>
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
3000ef68:	e59d3004 	ldr	r3, [sp, #4]
3000ef6c:	e5933020 	ldr	r3, [r3, #32]
3000ef70:	e5933008 	ldr	r3, [r3, #8]
3000ef74:	e1a03803 	lsl	r3, r3, #16
3000ef78:	e1a02823 	lsr	r2, r3, #16
3000ef7c:	e59d3004 	ldr	r3, [sp, #4]
3000ef80:	e5933024 	ldr	r3, [r3, #36]	; 0x24
3000ef84:	e1a03803 	lsl	r3, r3, #16
3000ef88:	e1a03823 	lsr	r3, r3, #16
3000ef8c:	e0633002 	rsb	r3, r3, r2
3000ef90:	e1cd31b2 	strh	r3, [sp, #18]
  }
  available = tcp_sndbuf(conn->pcb.tcp);
3000ef94:	e59d3004 	ldr	r3, [sp, #4]
3000ef98:	e5933004 	ldr	r3, [r3, #4]
3000ef9c:	e1d336ba 	ldrh	r3, [r3, #106]	; 0x6a
3000efa0:	e1cd31b4 	strh	r3, [sp, #20]
  if (available < len) {
3000efa4:	e1dd21b4 	ldrh	r2, [sp, #20]
3000efa8:	e1dd31b2 	ldrh	r3, [sp, #18]
3000efac:	e1520003 	cmp	r2, r3
3000efb0:	2a000001 	bcs	3000efbc <do_writemore+0xb8>
    /* don't try to write more than sendbuf */
    len = available;
3000efb4:	e1dd31b4 	ldrh	r3, [sp, #20]
3000efb8:	e1cd31b2 	strh	r3, [sp, #18]
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
3000efbc:	e59d3004 	ldr	r3, [sp, #4]
3000efc0:	e5931004 	ldr	r1, [r3, #4]
3000efc4:	e59d3004 	ldr	r3, [sp, #4]
3000efc8:	e5933020 	ldr	r3, [r3, #32]
3000efcc:	e5d3300c 	ldrb	r3, [r3, #12]
3000efd0:	e1dd21b2 	ldrh	r2, [sp, #18]
3000efd4:	e1a00001 	mov	r0, r1
3000efd8:	e59d100c 	ldr	r1, [sp, #12]
3000efdc:	eb003a29 	bl	3001d888 <tcp_write>
3000efe0:	e1a03000 	mov	r3, r0
3000efe4:	e20330ff 	and	r3, r3, #255	; 0xff
3000efe8:	e5cd300b 	strb	r3, [sp, #11]
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
3000efec:	e1dd30db 	ldrsb	r3, [sp, #11]
3000eff0:	e3530000 	cmp	r3, #0
3000eff4:	1a00004b 	bne	3000f128 <do_writemore+0x224>
    conn->write_offset += len;
3000eff8:	e59d3004 	ldr	r3, [sp, #4]
3000effc:	e5932024 	ldr	r2, [r3, #36]	; 0x24
3000f000:	e1dd31b2 	ldrh	r3, [sp, #18]
3000f004:	e0822003 	add	r2, r2, r3
3000f008:	e59d3004 	ldr	r3, [sp, #4]
3000f00c:	e5832024 	str	r2, [r3, #36]	; 0x24
    if (conn->write_offset == conn->write_msg->msg.w.len) {
3000f010:	e59d3004 	ldr	r3, [sp, #4]
3000f014:	e5932024 	ldr	r2, [r3, #36]	; 0x24
3000f018:	e59d3004 	ldr	r3, [sp, #4]
3000f01c:	e5933020 	ldr	r3, [r3, #32]
3000f020:	e5933008 	ldr	r3, [r3, #8]
3000f024:	e1520003 	cmp	r2, r3
3000f028:	1a000007 	bne	3000f04c <do_writemore+0x148>
      /* everything was written */
      write_finished = 1;
3000f02c:	e3a03001 	mov	r3, #1
3000f030:	e5cd3017 	strb	r3, [sp, #23]
      conn->write_msg = NULL;
3000f034:	e59d3004 	ldr	r3, [sp, #4]
3000f038:	e3a02000 	mov	r2, #0
3000f03c:	e5832020 	str	r2, [r3, #32]
      conn->write_offset = 0;
3000f040:	e59d3004 	ldr	r3, [sp, #4]
3000f044:	e3a02000 	mov	r2, #0
3000f048:	e5832024 	str	r2, [r3, #36]	; 0x24
	//acoral_print("\r\ndWMS\r\n");   
    //acoral_print("\r\n=%d\r\n",((conn->pcb.tcp)->unacked == NULL)?1:0);
    //acoral_print("\r\n=%d\r\n",((conn->pcb.tcp)->flags & TF_NODELAY)?1:0);
    //acoral_print("\r\n=%d\r\n",((conn->pcb.tcp)->unsent != NULL)?1:0);
    //acoral_print("\r\n=%d\r\n",((conn->pcb.tcp)->unsent->next != NULL)?1:0);
    err = tcp_output_nagle(conn->pcb.tcp);
3000f04c:	e59d3004 	ldr	r3, [sp, #4]
3000f050:	e5933004 	ldr	r3, [r3, #4]
3000f054:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3000f058:	e3530000 	cmp	r3, #0
3000f05c:	0a000010 	beq	3000f0a4 <do_writemore+0x1a0>
3000f060:	e59d3004 	ldr	r3, [sp, #4]
3000f064:	e5933004 	ldr	r3, [r3, #4]
3000f068:	e5d3301c 	ldrb	r3, [r3, #28]
3000f06c:	e2033040 	and	r3, r3, #64	; 0x40
3000f070:	e3530000 	cmp	r3, #0
3000f074:	1a00000a 	bne	3000f0a4 <do_writemore+0x1a0>
3000f078:	e59d3004 	ldr	r3, [sp, #4]
3000f07c:	e5933004 	ldr	r3, [r3, #4]
3000f080:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3000f084:	e3530000 	cmp	r3, #0
3000f088:	0a00000d 	beq	3000f0c4 <do_writemore+0x1c0>
3000f08c:	e59d3004 	ldr	r3, [sp, #4]
3000f090:	e5933004 	ldr	r3, [r3, #4]
3000f094:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3000f098:	e5933000 	ldr	r3, [r3]
3000f09c:	e3530000 	cmp	r3, #0
3000f0a0:	0a000007 	beq	3000f0c4 <do_writemore+0x1c0>
3000f0a4:	e59d3004 	ldr	r3, [sp, #4]
3000f0a8:	e5933004 	ldr	r3, [r3, #4]
3000f0ac:	e1a00003 	mov	r0, r3
3000f0b0:	eb003c73 	bl	3001e284 <tcp_output>
3000f0b4:	e1a03000 	mov	r3, r0
3000f0b8:	e20330ff 	and	r3, r3, #255	; 0xff
3000f0bc:	e20330ff 	and	r3, r3, #255	; 0xff
3000f0c0:	ea000000 	b	3000f0c8 <do_writemore+0x1c4>
3000f0c4:	e3a03000 	mov	r3, #0
3000f0c8:	e5cd300b 	strb	r3, [sp, #11]
    //acoral_print("\r\ndWME########%d\r\n",err);
    conn->err = err;
3000f0cc:	e59d3004 	ldr	r3, [sp, #4]
3000f0d0:	e5dd200b 	ldrb	r2, [sp, #11]
3000f0d4:	e5c32008 	strb	r2, [r3, #8]
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
3000f0d8:	e1dd30db 	ldrsb	r3, [sp, #11]
3000f0dc:	e3530000 	cmp	r3, #0
3000f0e0:	1a000021 	bne	3000f16c <do_writemore+0x268>
3000f0e4:	e59d3004 	ldr	r3, [sp, #4]
3000f0e8:	e5933004 	ldr	r3, [r3, #4]
3000f0ec:	e1d336ba 	ldrh	r3, [r3, #106]	; 0x6a
3000f0f0:	e3530080 	cmp	r3, #128	; 0x80
3000f0f4:	8a00001e 	bhi	3000f174 <do_writemore+0x270>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
3000f0f8:	e59d3004 	ldr	r3, [sp, #4]
3000f0fc:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000f100:	e3530000 	cmp	r3, #0
3000f104:	0a00001b 	beq	3000f178 <do_writemore+0x274>
3000f108:	e59d3004 	ldr	r3, [sp, #4]
3000f10c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000f110:	e1dd21b2 	ldrh	r2, [sp, #18]
3000f114:	e59d0004 	ldr	r0, [sp, #4]
3000f118:	e3a01003 	mov	r1, #3
3000f11c:	e1a0e00f 	mov	lr, pc
3000f120:	e12fff13 	bx	r3
3000f124:	ea000013 	b	3000f178 <do_writemore+0x274>
    }
  } else if (err == ERR_MEM) {
3000f128:	e1dd30db 	ldrsb	r3, [sp, #11]
3000f12c:	e3730001 	cmn	r3, #1
3000f130:	1a000007 	bne	3000f154 <do_writemore+0x250>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
3000f134:	e59d3004 	ldr	r3, [sp, #4]
3000f138:	e5933004 	ldr	r3, [r3, #4]
3000f13c:	e1a00003 	mov	r0, r3
3000f140:	eb003c4f 	bl	3001e284 <tcp_output>
3000f144:	e1a03000 	mov	r3, r0
3000f148:	e20330ff 	and	r3, r3, #255	; 0xff
3000f14c:	e5cd300b 	strb	r3, [sp, #11]
3000f150:	ea000008 	b	3000f178 <do_writemore+0x274>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
3000f154:	e59d3004 	ldr	r3, [sp, #4]
3000f158:	e5dd200b 	ldrb	r2, [sp, #11]
3000f15c:	e5c32008 	strb	r2, [r3, #8]
    write_finished = 1;
3000f160:	e3a03001 	mov	r3, #1
3000f164:	e5cd3017 	strb	r3, [sp, #23]
3000f168:	ea000002 	b	3000f178 <do_writemore+0x274>
    //acoral_print("\r\n=%d\r\n",((conn->pcb.tcp)->unsent->next != NULL)?1:0);
    err = tcp_output_nagle(conn->pcb.tcp);
    //acoral_print("\r\ndWME########%d\r\n",err);
    conn->err = err;
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
3000f16c:	e1a00000 	nop			; (mov r0, r0)
3000f170:	ea000000 	b	3000f178 <do_writemore+0x274>
3000f174:	e1a00000 	nop			; (mov r0, r0)
       the error to the application thread. */
    conn->err = err;
    write_finished = 1;
  }

  if (write_finished) {
3000f178:	e5dd3017 	ldrb	r3, [sp, #23]
3000f17c:	e3530000 	cmp	r3, #0
3000f180:	0a000006 	beq	3000f1a0 <do_writemore+0x29c>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
3000f184:	e59d3004 	ldr	r3, [sp, #4]
3000f188:	e3a02000 	mov	r2, #0
3000f18c:	e5c32001 	strb	r2, [r3, #1]
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
3000f190:	e59d3004 	ldr	r3, [sp, #4]
3000f194:	e593300c 	ldr	r3, [r3, #12]
3000f198:	e1a00003 	mov	r0, r3
3000f19c:	ebfff65d 	bl	3000cb18 <sys_sem_signal>
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
3000f1a0:	e3a03000 	mov	r3, #0
3000f1a4:	e1a03c03 	lsl	r3, r3, #24
3000f1a8:	e1a03c43 	asr	r3, r3, #24
}
3000f1ac:	e1a00003 	mov	r0, r3
3000f1b0:	e28dd01c 	add	sp, sp, #28
3000f1b4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f1b8:	e12fff1e 	bx	lr

3000f1bc <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
3000f1bc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f1c0:	e24dd00c 	sub	sp, sp, #12
3000f1c4:	e58d0004 	str	r0, [sp, #4]
  if (!ERR_IS_FATAL(msg->conn->err)) {
3000f1c8:	e59d3004 	ldr	r3, [sp, #4]
3000f1cc:	e5933000 	ldr	r3, [r3]
3000f1d0:	e5d33008 	ldrb	r3, [r3, #8]
3000f1d4:	e1a03c03 	lsl	r3, r3, #24
3000f1d8:	e1a03c43 	asr	r3, r3, #24
3000f1dc:	e3730003 	cmn	r3, #3
3000f1e0:	ba00001e 	blt	3000f260 <do_write+0xa4>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
3000f1e4:	e59d3004 	ldr	r3, [sp, #4]
3000f1e8:	e5933000 	ldr	r3, [r3]
3000f1ec:	e5933004 	ldr	r3, [r3, #4]
3000f1f0:	e3530000 	cmp	r3, #0
3000f1f4:	0a000015 	beq	3000f250 <do_write+0x94>
3000f1f8:	e59d3004 	ldr	r3, [sp, #4]
3000f1fc:	e5933000 	ldr	r3, [r3]
3000f200:	e5d33000 	ldrb	r3, [r3]
3000f204:	e3530010 	cmp	r3, #16
3000f208:	1a000010 	bne	3000f250 <do_write+0x94>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
3000f20c:	e59d3004 	ldr	r3, [sp, #4]
3000f210:	e5933000 	ldr	r3, [r3]
3000f214:	e3a02001 	mov	r2, #1
3000f218:	e5c32001 	strb	r2, [r3, #1]
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
3000f21c:	e59d3004 	ldr	r3, [sp, #4]
3000f220:	e5933000 	ldr	r3, [r3]
3000f224:	e59d2004 	ldr	r2, [sp, #4]
3000f228:	e5832020 	str	r2, [r3, #32]
      msg->conn->write_offset = 0;
3000f22c:	e59d3004 	ldr	r3, [sp, #4]
3000f230:	e5933000 	ldr	r3, [r3]
3000f234:	e3a02000 	mov	r2, #0
3000f238:	e5832024 	str	r2, [r3, #36]	; 0x24
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
	 // acoral_prints("\r\ndWSta\r\n");
      do_writemore(msg->conn);
3000f23c:	e59d3004 	ldr	r3, [sp, #4]
3000f240:	e5933000 	ldr	r3, [r3]
3000f244:	e1a00003 	mov	r0, r3
3000f248:	ebffff2d 	bl	3000ef04 <do_writemore>
     // acoral_prints("\r\ndWEnd\r\n");
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
3000f24c:	ea000008 	b	3000f274 <do_write+0xb8>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
3000f250:	e59d3004 	ldr	r3, [sp, #4]
3000f254:	e5933000 	ldr	r3, [r3]
3000f258:	e3e02007 	mvn	r2, #7
3000f25c:	e5c32008 	strb	r2, [r3, #8]
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
3000f260:	e59d3004 	ldr	r3, [sp, #4]
3000f264:	e5933000 	ldr	r3, [r3]
3000f268:	e593300c 	ldr	r3, [r3, #12]
3000f26c:	e1a00003 	mov	r0, r3
3000f270:	ebfff628 	bl	3000cb18 <sys_sem_signal>
}
3000f274:	e28dd00c 	add	sp, sp, #12
3000f278:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f27c:	e12fff1e 	bx	lr

3000f280 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
3000f280:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f284:	e24dd00c 	sub	sp, sp, #12
3000f288:	e58d0004 	str	r0, [sp, #4]
  if (msg->conn->pcb.ip != NULL) {
3000f28c:	e59d3004 	ldr	r3, [sp, #4]
3000f290:	e5933000 	ldr	r3, [r3]
3000f294:	e5933004 	ldr	r3, [r3, #4]
3000f298:	e3530000 	cmp	r3, #0
3000f29c:	0a00005a 	beq	3000f40c <do_getaddr+0x18c>
    (msg->msg.ad.ipaddr) = (msg->msg.ad.local?&(msg->conn->pcb.ip->local_ip):&(msg->conn->pcb.ip->remote_ip));
3000f2a0:	e59d3004 	ldr	r3, [sp, #4]
3000f2a4:	e5d3300c 	ldrb	r3, [r3, #12]
3000f2a8:	e3530000 	cmp	r3, #0
3000f2ac:	0a000003 	beq	3000f2c0 <do_getaddr+0x40>
3000f2b0:	e59d3004 	ldr	r3, [sp, #4]
3000f2b4:	e5933000 	ldr	r3, [r3]
3000f2b8:	e5933004 	ldr	r3, [r3, #4]
3000f2bc:	ea000003 	b	3000f2d0 <do_getaddr+0x50>
3000f2c0:	e59d3004 	ldr	r3, [sp, #4]
3000f2c4:	e5933000 	ldr	r3, [r3]
3000f2c8:	e5933004 	ldr	r3, [r3, #4]
3000f2cc:	e2833004 	add	r3, r3, #4
3000f2d0:	e59d2004 	ldr	r2, [sp, #4]
3000f2d4:	e5823004 	str	r3, [r2, #4]
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
3000f2d8:	e59d3004 	ldr	r3, [sp, #4]
3000f2dc:	e5933000 	ldr	r3, [r3]
3000f2e0:	e5d33000 	ldrb	r3, [r3]
3000f2e4:	e20330f0 	and	r3, r3, #240	; 0xf0
3000f2e8:	e3530020 	cmp	r3, #32
3000f2ec:	0a000015 	beq	3000f348 <do_getaddr+0xc8>
3000f2f0:	e3530040 	cmp	r3, #64	; 0x40
3000f2f4:	0a000002 	beq	3000f304 <do_getaddr+0x84>
3000f2f8:	e3530010 	cmp	r3, #16
3000f2fc:	0a000031 	beq	3000f3c8 <do_getaddr+0x148>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
3000f300:	ea000045 	b	3000f41c <do_getaddr+0x19c>
    (msg->msg.ad.ipaddr) = (msg->msg.ad.local?&(msg->conn->pcb.ip->local_ip):&(msg->conn->pcb.ip->remote_ip));
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
3000f304:	e59d3004 	ldr	r3, [sp, #4]
3000f308:	e5d3300c 	ldrb	r3, [r3, #12]
3000f30c:	e3530000 	cmp	r3, #0
3000f310:	0a000007 	beq	3000f334 <do_getaddr+0xb4>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
3000f314:	e59d3004 	ldr	r3, [sp, #4]
3000f318:	e5933008 	ldr	r3, [r3, #8]
3000f31c:	e59d2004 	ldr	r2, [sp, #4]
3000f320:	e5922000 	ldr	r2, [r2]
3000f324:	e5922004 	ldr	r2, [r2, #4]
3000f328:	e5d22010 	ldrb	r2, [r2, #16]
3000f32c:	e1c320b0 	strh	r2, [r3]
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
      }
      break;
3000f330:	ea000039 	b	3000f41c <do_getaddr+0x19c>
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
3000f334:	e59d3004 	ldr	r3, [sp, #4]
3000f338:	e5933000 	ldr	r3, [r3]
3000f33c:	e3e02006 	mvn	r2, #6
3000f340:	e5c32008 	strb	r2, [r3, #8]
      }
      break;
3000f344:	ea000034 	b	3000f41c <do_getaddr+0x19c>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
3000f348:	e59d3004 	ldr	r3, [sp, #4]
3000f34c:	e5d3300c 	ldrb	r3, [r3, #12]
3000f350:	e3530000 	cmp	r3, #0
3000f354:	0a000007 	beq	3000f378 <do_getaddr+0xf8>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
3000f358:	e59d3004 	ldr	r3, [sp, #4]
3000f35c:	e5933008 	ldr	r3, [r3, #8]
3000f360:	e59d2004 	ldr	r2, [sp, #4]
3000f364:	e5922000 	ldr	r2, [r2]
3000f368:	e5922004 	ldr	r2, [r2, #4]
3000f36c:	e1d221b2 	ldrh	r2, [r2, #18]
3000f370:	e1c320b0 	strh	r2, [r3]
          msg->conn->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
3000f374:	ea000028 	b	3000f41c <do_getaddr+0x19c>
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
3000f378:	e59d3004 	ldr	r3, [sp, #4]
3000f37c:	e5933000 	ldr	r3, [r3]
3000f380:	e5933004 	ldr	r3, [r3, #4]
3000f384:	e5d33010 	ldrb	r3, [r3, #16]
3000f388:	e2033004 	and	r3, r3, #4
3000f38c:	e3530000 	cmp	r3, #0
3000f390:	1a000004 	bne	3000f3a8 <do_getaddr+0x128>
          msg->conn->err = ERR_CONN;
3000f394:	e59d3004 	ldr	r3, [sp, #4]
3000f398:	e5933000 	ldr	r3, [r3]
3000f39c:	e3e02006 	mvn	r2, #6
3000f3a0:	e5c32008 	strb	r2, [r3, #8]
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
3000f3a4:	ea00001c 	b	3000f41c <do_getaddr+0x19c>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
          msg->conn->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
3000f3a8:	e59d3004 	ldr	r3, [sp, #4]
3000f3ac:	e5933008 	ldr	r3, [r3, #8]
3000f3b0:	e59d2004 	ldr	r2, [sp, #4]
3000f3b4:	e5922000 	ldr	r2, [r2]
3000f3b8:	e5922004 	ldr	r2, [r2, #4]
3000f3bc:	e1d221b4 	ldrh	r2, [r2, #20]
3000f3c0:	e1c320b0 	strh	r2, [r3]
        }
      }
      break;
3000f3c4:	ea000014 	b	3000f41c <do_getaddr+0x19c>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
3000f3c8:	e59d3004 	ldr	r3, [sp, #4]
3000f3cc:	e5932008 	ldr	r2, [r3, #8]
3000f3d0:	e59d3004 	ldr	r3, [sp, #4]
3000f3d4:	e5d3300c 	ldrb	r3, [r3, #12]
3000f3d8:	e3530000 	cmp	r3, #0
3000f3dc:	0a000004 	beq	3000f3f4 <do_getaddr+0x174>
3000f3e0:	e59d3004 	ldr	r3, [sp, #4]
3000f3e4:	e5933000 	ldr	r3, [r3]
3000f3e8:	e5933004 	ldr	r3, [r3, #4]
3000f3ec:	e1d331b8 	ldrh	r3, [r3, #24]
3000f3f0:	ea000003 	b	3000f404 <do_getaddr+0x184>
3000f3f4:	e59d3004 	ldr	r3, [sp, #4]
3000f3f8:	e5933000 	ldr	r3, [r3]
3000f3fc:	e5933004 	ldr	r3, [r3, #4]
3000f400:	e1d331ba 	ldrh	r3, [r3, #26]
3000f404:	e1c230b0 	strh	r3, [r2]
3000f408:	ea000003 	b	3000f41c <do_getaddr+0x19c>
      break;
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
3000f40c:	e59d3004 	ldr	r3, [sp, #4]
3000f410:	e5933000 	ldr	r3, [r3]
3000f414:	e3e02006 	mvn	r2, #6
3000f418:	e5c32008 	strb	r2, [r3, #8]
  }
  TCPIP_APIMSG_ACK(msg);
3000f41c:	e59d3004 	ldr	r3, [sp, #4]
3000f420:	e5933000 	ldr	r3, [r3]
3000f424:	e593300c 	ldr	r3, [r3, #12]
3000f428:	e1a00003 	mov	r0, r3
3000f42c:	ebfff5b9 	bl	3000cb18 <sys_sem_signal>
}
3000f430:	e28dd00c 	add	sp, sp, #12
3000f434:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f438:	e12fff1e 	bx	lr

3000f43c <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
3000f43c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f440:	e24dd00c 	sub	sp, sp, #12
3000f444:	e58d0004 	str	r0, [sp, #4]
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
3000f448:	e59d3004 	ldr	r3, [sp, #4]
3000f44c:	e5933000 	ldr	r3, [r3]
3000f450:	e5933004 	ldr	r3, [r3, #4]
3000f454:	e3530000 	cmp	r3, #0
3000f458:	0a00000d 	beq	3000f494 <do_close+0x58>
3000f45c:	e59d3004 	ldr	r3, [sp, #4]
3000f460:	e5933000 	ldr	r3, [r3]
3000f464:	e5d33000 	ldrb	r3, [r3]
3000f468:	e3530010 	cmp	r3, #16
3000f46c:	1a000008 	bne	3000f494 <do_close+0x58>
      msg->conn->state = NETCONN_CLOSE;
3000f470:	e59d3004 	ldr	r3, [sp, #4]
3000f474:	e5933000 	ldr	r3, [r3]
3000f478:	e3a02004 	mov	r2, #4
3000f47c:	e5c32001 	strb	r2, [r3, #1]
      do_close_internal(msg->conn);
3000f480:	e59d3004 	ldr	r3, [sp, #4]
3000f484:	e5933000 	ldr	r3, [r3]
3000f488:	e1a00003 	mov	r0, r3
3000f48c:	ebfffbea 	bl	3000e43c <do_close_internal>
 */
void
do_close(struct api_msg_msg *msg)
{
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
3000f490:	ea000008 	b	3000f4b8 <do_close+0x7c>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
3000f494:	e59d3004 	ldr	r3, [sp, #4]
3000f498:	e5933000 	ldr	r3, [r3]
3000f49c:	e3e02007 	mvn	r2, #7
3000f4a0:	e5c32008 	strb	r2, [r3, #8]
    TCPIP_APIMSG_ACK(msg);
3000f4a4:	e59d3004 	ldr	r3, [sp, #4]
3000f4a8:	e5933000 	ldr	r3, [r3]
3000f4ac:	e593300c 	ldr	r3, [r3, #12]
3000f4b0:	e1a00003 	mov	r0, r3
3000f4b4:	ebfff597 	bl	3000cb18 <sys_sem_signal>
  }
}
3000f4b8:	e28dd00c 	add	sp, sp, #12
3000f4bc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f4c0:	e12fff1e 	bx	lr

3000f4c4 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
3000f4c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f4c8:	e24dd00c 	sub	sp, sp, #12
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
3000f4cc:	e3a00005 	mov	r0, #5
3000f4d0:	eb001846 	bl	300155f0 <memp_malloc>
3000f4d4:	e1a03000 	mov	r3, r0
3000f4d8:	e58d3004 	str	r3, [sp, #4]
  if (buf != NULL) {
3000f4dc:	e59d3004 	ldr	r3, [sp, #4]
3000f4e0:	e3530000 	cmp	r3, #0
3000f4e4:	0a00000a 	beq	3000f514 <netbuf_new+0x50>
    buf->p = NULL;
3000f4e8:	e59d3004 	ldr	r3, [sp, #4]
3000f4ec:	e3a02000 	mov	r2, #0
3000f4f0:	e5832000 	str	r2, [r3]
    buf->ptr = NULL;
3000f4f4:	e59d3004 	ldr	r3, [sp, #4]
3000f4f8:	e3a02000 	mov	r2, #0
3000f4fc:	e5832004 	str	r2, [r3, #4]
    buf->addr = NULL;
3000f500:	e59d3004 	ldr	r3, [sp, #4]
3000f504:	e3a02000 	mov	r2, #0
3000f508:	e5832008 	str	r2, [r3, #8]
    return buf;
3000f50c:	e59d3004 	ldr	r3, [sp, #4]
3000f510:	ea000000 	b	3000f518 <netbuf_new+0x54>
  } else {
    return NULL;
3000f514:	e3a03000 	mov	r3, #0
  }
}
3000f518:	e1a00003 	mov	r0, r3
3000f51c:	e28dd00c 	add	sp, sp, #12
3000f520:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f524:	e12fff1e 	bx	lr

3000f528 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
3000f528:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f52c:	e24dd00c 	sub	sp, sp, #12
3000f530:	e58d0004 	str	r0, [sp, #4]
  if (buf != NULL) {
3000f534:	e59d3004 	ldr	r3, [sp, #4]
3000f538:	e3530000 	cmp	r3, #0
3000f53c:	0a000011 	beq	3000f588 <netbuf_delete+0x60>
    if (buf->p != NULL) {
3000f540:	e59d3004 	ldr	r3, [sp, #4]
3000f544:	e5933000 	ldr	r3, [r3]
3000f548:	e3530000 	cmp	r3, #0
3000f54c:	0a00000a 	beq	3000f57c <netbuf_delete+0x54>
      pbuf_free(buf->p);
3000f550:	e59d3004 	ldr	r3, [sp, #4]
3000f554:	e5933000 	ldr	r3, [r3]
3000f558:	e1a00003 	mov	r0, r3
3000f55c:	eb001bf3 	bl	30016530 <pbuf_free>
      buf->p = buf->ptr = NULL;
3000f560:	e59d3004 	ldr	r3, [sp, #4]
3000f564:	e3a02000 	mov	r2, #0
3000f568:	e5832004 	str	r2, [r3, #4]
3000f56c:	e59d3004 	ldr	r3, [sp, #4]
3000f570:	e5932004 	ldr	r2, [r3, #4]
3000f574:	e59d3004 	ldr	r3, [sp, #4]
3000f578:	e5832000 	str	r2, [r3]
    }
    memp_free(MEMP_NETBUF, buf);
3000f57c:	e3a00005 	mov	r0, #5
3000f580:	e59d1004 	ldr	r1, [sp, #4]
3000f584:	eb00187e 	bl	30015784 <memp_free>
  }
}
3000f588:	e28dd00c 	add	sp, sp, #12
3000f58c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f590:	e12fff1e 	bx	lr

3000f594 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
3000f594:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f598:	e24dd00c 	sub	sp, sp, #12
3000f59c:	e58d0004 	str	r0, [sp, #4]
3000f5a0:	e1a03001 	mov	r3, r1
3000f5a4:	e1cd30b2 	strh	r3, [sp, #2]
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
3000f5a8:	e59d3004 	ldr	r3, [sp, #4]
3000f5ac:	e5933000 	ldr	r3, [r3]
3000f5b0:	e3530000 	cmp	r3, #0
3000f5b4:	0a000003 	beq	3000f5c8 <netbuf_alloc+0x34>
    pbuf_free(buf->p);
3000f5b8:	e59d3004 	ldr	r3, [sp, #4]
3000f5bc:	e5933000 	ldr	r3, [r3]
3000f5c0:	e1a00003 	mov	r0, r3
3000f5c4:	eb001bd9 	bl	30016530 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
3000f5c8:	e1dd30b2 	ldrh	r3, [sp, #2]
3000f5cc:	e3a00000 	mov	r0, #0
3000f5d0:	e1a01003 	mov	r1, r3
3000f5d4:	e3a02000 	mov	r2, #0
3000f5d8:	eb001a25 	bl	30015e74 <pbuf_alloc>
3000f5dc:	e1a02000 	mov	r2, r0
3000f5e0:	e59d3004 	ldr	r3, [sp, #4]
3000f5e4:	e5832000 	str	r2, [r3]
  if (buf->p == NULL) {
3000f5e8:	e59d3004 	ldr	r3, [sp, #4]
3000f5ec:	e5933000 	ldr	r3, [r3]
3000f5f0:	e3530000 	cmp	r3, #0
3000f5f4:	1a000001 	bne	3000f600 <netbuf_alloc+0x6c>
     return NULL;
3000f5f8:	e3a03000 	mov	r3, #0
3000f5fc:	ea000006 	b	3000f61c <netbuf_alloc+0x88>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
3000f600:	e59d3004 	ldr	r3, [sp, #4]
3000f604:	e5932000 	ldr	r2, [r3]
3000f608:	e59d3004 	ldr	r3, [sp, #4]
3000f60c:	e5832004 	str	r2, [r3, #4]
  return buf->p->payload;
3000f610:	e59d3004 	ldr	r3, [sp, #4]
3000f614:	e5933000 	ldr	r3, [r3]
3000f618:	e5933004 	ldr	r3, [r3, #4]
}
3000f61c:	e1a00003 	mov	r0, r3
3000f620:	e28dd00c 	add	sp, sp, #12
3000f624:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f628:	e12fff1e 	bx	lr

3000f62c <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
3000f62c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f630:	e24dd00c 	sub	sp, sp, #12
3000f634:	e58d0004 	str	r0, [sp, #4]
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  if (buf->p != NULL) {
3000f638:	e59d3004 	ldr	r3, [sp, #4]
3000f63c:	e5933000 	ldr	r3, [r3]
3000f640:	e3530000 	cmp	r3, #0
3000f644:	0a000003 	beq	3000f658 <netbuf_free+0x2c>
    pbuf_free(buf->p);
3000f648:	e59d3004 	ldr	r3, [sp, #4]
3000f64c:	e5933000 	ldr	r3, [r3]
3000f650:	e1a00003 	mov	r0, r3
3000f654:	eb001bb5 	bl	30016530 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
3000f658:	e59d3004 	ldr	r3, [sp, #4]
3000f65c:	e3a02000 	mov	r2, #0
3000f660:	e5832004 	str	r2, [r3, #4]
3000f664:	e59d3004 	ldr	r3, [sp, #4]
3000f668:	e5932004 	ldr	r2, [r3, #4]
3000f66c:	e59d3004 	ldr	r3, [sp, #4]
3000f670:	e5832000 	str	r2, [r3]
}
3000f674:	e28dd00c 	add	sp, sp, #12
3000f678:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f67c:	e12fff1e 	bx	lr

3000f680 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
3000f680:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f684:	e24dd014 	sub	sp, sp, #20
3000f688:	e58d000c 	str	r0, [sp, #12]
3000f68c:	e58d1008 	str	r1, [sp, #8]
3000f690:	e1a03002 	mov	r3, r2
3000f694:	e1cd30b6 	strh	r3, [sp, #6]
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  if (buf->p != NULL) {
3000f698:	e59d300c 	ldr	r3, [sp, #12]
3000f69c:	e5933000 	ldr	r3, [r3]
3000f6a0:	e3530000 	cmp	r3, #0
3000f6a4:	0a000003 	beq	3000f6b8 <netbuf_ref+0x38>
    pbuf_free(buf->p);
3000f6a8:	e59d300c 	ldr	r3, [sp, #12]
3000f6ac:	e5933000 	ldr	r3, [r3]
3000f6b0:	e1a00003 	mov	r0, r3
3000f6b4:	eb001b9d 	bl	30016530 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
3000f6b8:	e3a00000 	mov	r0, #0
3000f6bc:	e3a01000 	mov	r1, #0
3000f6c0:	e3a02002 	mov	r2, #2
3000f6c4:	eb0019ea 	bl	30015e74 <pbuf_alloc>
3000f6c8:	e1a02000 	mov	r2, r0
3000f6cc:	e59d300c 	ldr	r3, [sp, #12]
3000f6d0:	e5832000 	str	r2, [r3]
  if (buf->p == NULL) {
3000f6d4:	e59d300c 	ldr	r3, [sp, #12]
3000f6d8:	e5933000 	ldr	r3, [r3]
3000f6dc:	e3530000 	cmp	r3, #0
3000f6e0:	1a000004 	bne	3000f6f8 <netbuf_ref+0x78>
    buf->ptr = NULL;
3000f6e4:	e59d300c 	ldr	r3, [sp, #12]
3000f6e8:	e3a02000 	mov	r2, #0
3000f6ec:	e5832004 	str	r2, [r3, #4]
    return ERR_MEM;
3000f6f0:	e3a030ff 	mov	r3, #255	; 0xff
3000f6f4:	ea000010 	b	3000f73c <netbuf_ref+0xbc>
  }
  buf->p->payload = (void*)dataptr;
3000f6f8:	e59d300c 	ldr	r3, [sp, #12]
3000f6fc:	e5933000 	ldr	r3, [r3]
3000f700:	e59d2008 	ldr	r2, [sp, #8]
3000f704:	e5832004 	str	r2, [r3, #4]
  buf->p->len = buf->p->tot_len = size;
3000f708:	e59d300c 	ldr	r3, [sp, #12]
3000f70c:	e5932000 	ldr	r2, [r3]
3000f710:	e59d300c 	ldr	r3, [sp, #12]
3000f714:	e5933000 	ldr	r3, [r3]
3000f718:	e1dd10b6 	ldrh	r1, [sp, #6]
3000f71c:	e1c310b8 	strh	r1, [r3, #8]
3000f720:	e1d330b8 	ldrh	r3, [r3, #8]
3000f724:	e1c230ba 	strh	r3, [r2, #10]
  buf->ptr = buf->p;
3000f728:	e59d300c 	ldr	r3, [sp, #12]
3000f72c:	e5932000 	ldr	r2, [r3]
3000f730:	e59d300c 	ldr	r3, [sp, #12]
3000f734:	e5832004 	str	r2, [r3, #4]
  return ERR_OK;
3000f738:	e3a03000 	mov	r3, #0
3000f73c:	e1a03c03 	lsl	r3, r3, #24
3000f740:	e1a03c43 	asr	r3, r3, #24
}
3000f744:	e1a00003 	mov	r0, r3
3000f748:	e28dd014 	add	sp, sp, #20
3000f74c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f750:	e12fff1e 	bx	lr

3000f754 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
3000f754:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f758:	e24dd00c 	sub	sp, sp, #12
3000f75c:	e58d0004 	str	r0, [sp, #4]
3000f760:	e58d1000 	str	r1, [sp]
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  pbuf_chain(head->p, tail->p);
3000f764:	e59d3004 	ldr	r3, [sp, #4]
3000f768:	e5932000 	ldr	r2, [r3]
3000f76c:	e59d3000 	ldr	r3, [sp]
3000f770:	e5933000 	ldr	r3, [r3]
3000f774:	e1a00002 	mov	r0, r2
3000f778:	e1a01003 	mov	r1, r3
3000f77c:	eb001bfc 	bl	30016774 <pbuf_chain>
  head->ptr = head->p;
3000f780:	e59d3004 	ldr	r3, [sp, #4]
3000f784:	e5932000 	ldr	r2, [r3]
3000f788:	e59d3004 	ldr	r3, [sp, #4]
3000f78c:	e5832004 	str	r2, [r3, #4]
  memp_free(MEMP_NETBUF, tail);
3000f790:	e3a00005 	mov	r0, #5
3000f794:	e59d1000 	ldr	r1, [sp]
3000f798:	eb0017f9 	bl	30015784 <memp_free>
}
3000f79c:	e28dd00c 	add	sp, sp, #12
3000f7a0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f7a4:	e12fff1e 	bx	lr

3000f7a8 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
3000f7a8:	e24dd010 	sub	sp, sp, #16
3000f7ac:	e58d000c 	str	r0, [sp, #12]
3000f7b0:	e58d1008 	str	r1, [sp, #8]
3000f7b4:	e58d2004 	str	r2, [sp, #4]
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);

  if (buf->ptr == NULL) {
3000f7b8:	e59d300c 	ldr	r3, [sp, #12]
3000f7bc:	e5933004 	ldr	r3, [r3, #4]
3000f7c0:	e3530000 	cmp	r3, #0
3000f7c4:	1a000001 	bne	3000f7d0 <netbuf_data+0x28>
    return ERR_BUF;
3000f7c8:	e3a030fe 	mov	r3, #254	; 0xfe
3000f7cc:	ea00000a 	b	3000f7fc <netbuf_data+0x54>
  }
  *dataptr = buf->ptr->payload;
3000f7d0:	e59d300c 	ldr	r3, [sp, #12]
3000f7d4:	e5933004 	ldr	r3, [r3, #4]
3000f7d8:	e5932004 	ldr	r2, [r3, #4]
3000f7dc:	e59d3008 	ldr	r3, [sp, #8]
3000f7e0:	e5832000 	str	r2, [r3]
  *len = buf->ptr->len;
3000f7e4:	e59d300c 	ldr	r3, [sp, #12]
3000f7e8:	e5933004 	ldr	r3, [r3, #4]
3000f7ec:	e1d320ba 	ldrh	r2, [r3, #10]
3000f7f0:	e59d3004 	ldr	r3, [sp, #4]
3000f7f4:	e1c320b0 	strh	r2, [r3]
  return ERR_OK;
3000f7f8:	e3a03000 	mov	r3, #0
3000f7fc:	e1a03c03 	lsl	r3, r3, #24
3000f800:	e1a03c43 	asr	r3, r3, #24
}
3000f804:	e1a00003 	mov	r0, r3
3000f808:	e28dd010 	add	sp, sp, #16
3000f80c:	e12fff1e 	bx	lr

3000f810 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
3000f810:	e24dd008 	sub	sp, sp, #8
3000f814:	e58d0004 	str	r0, [sp, #4]
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  if (buf->ptr->next == NULL) {
3000f818:	e59d3004 	ldr	r3, [sp, #4]
3000f81c:	e5933004 	ldr	r3, [r3, #4]
3000f820:	e5933000 	ldr	r3, [r3]
3000f824:	e3530000 	cmp	r3, #0
3000f828:	1a000001 	bne	3000f834 <netbuf_next+0x24>
    return -1;
3000f82c:	e3a030ff 	mov	r3, #255	; 0xff
3000f830:	ea00000c 	b	3000f868 <netbuf_next+0x58>
  }
  buf->ptr = buf->ptr->next;
3000f834:	e59d3004 	ldr	r3, [sp, #4]
3000f838:	e5933004 	ldr	r3, [r3, #4]
3000f83c:	e5932000 	ldr	r2, [r3]
3000f840:	e59d3004 	ldr	r3, [sp, #4]
3000f844:	e5832004 	str	r2, [r3, #4]
  if (buf->ptr->next == NULL) {
3000f848:	e59d3004 	ldr	r3, [sp, #4]
3000f84c:	e5933004 	ldr	r3, [r3, #4]
3000f850:	e5933000 	ldr	r3, [r3]
3000f854:	e3530000 	cmp	r3, #0
3000f858:	1a000001 	bne	3000f864 <netbuf_next+0x54>
    return 1;
3000f85c:	e3a03001 	mov	r3, #1
3000f860:	ea000000 	b	3000f868 <netbuf_next+0x58>
  }
  return 0;
3000f864:	e3a03000 	mov	r3, #0
3000f868:	e1a03c03 	lsl	r3, r3, #24
3000f86c:	e1a03c43 	asr	r3, r3, #24
}
3000f870:	e1a00003 	mov	r0, r3
3000f874:	e28dd008 	add	sp, sp, #8
3000f878:	e12fff1e 	bx	lr

3000f87c <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
3000f87c:	e24dd008 	sub	sp, sp, #8
3000f880:	e58d0004 	str	r0, [sp, #4]
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  buf->ptr = buf->p;
3000f884:	e59d3004 	ldr	r3, [sp, #4]
3000f888:	e5932000 	ldr	r2, [r3]
3000f88c:	e59d3004 	ldr	r3, [sp, #4]
3000f890:	e5832004 	str	r2, [r3, #4]
}
3000f894:	e28dd008 	add	sp, sp, #8
3000f898:	e12fff1e 	bx	lr

3000f89c <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
3000f89c:	e92d4008 	push	{r3, lr}
  socksem   = sys_sem_new(1);
3000f8a0:	e3a00001 	mov	r0, #1
3000f8a4:	ebfff486 	bl	3000cac4 <sys_sem_new>
3000f8a8:	e1a02000 	mov	r2, r0
3000f8ac:	e59f301c 	ldr	r3, [pc, #28]	; 3000f8d0 <lwip_socket_init+0x34>
3000f8b0:	e5832000 	str	r2, [r3]
  selectsem = sys_sem_new(1);
3000f8b4:	e3a00001 	mov	r0, #1
3000f8b8:	ebfff481 	bl	3000cac4 <sys_sem_new>
3000f8bc:	e1a02000 	mov	r2, r0
3000f8c0:	e59f300c 	ldr	r3, [pc, #12]	; 3000f8d4 <lwip_socket_init+0x38>
3000f8c4:	e5832000 	str	r2, [r3]
}
3000f8c8:	e8bd4008 	pop	{r3, lr}
3000f8cc:	e12fff1e 	bx	lr
3000f8d0:	300271fc 	.word	0x300271fc
3000f8d4:	30027200 	.word	0x30027200

3000f8d8 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
3000f8d8:	e24dd010 	sub	sp, sp, #16
3000f8dc:	e58d0004 	str	r0, [sp, #4]
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
3000f8e0:	e59d3004 	ldr	r3, [sp, #4]
3000f8e4:	e3530000 	cmp	r3, #0
3000f8e8:	ba000002 	blt	3000f8f8 <get_socket+0x20>
3000f8ec:	e59d3004 	ldr	r3, [sp, #4]
3000f8f0:	e3530003 	cmp	r3, #3
3000f8f4:	da000001 	ble	3000f900 <get_socket+0x28>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
3000f8f8:	e3a03000 	mov	r3, #0
3000f8fc:	ea00000f 	b	3000f940 <get_socket+0x68>
  }

  sock = &sockets[s];
3000f900:	e59d2004 	ldr	r2, [sp, #4]
3000f904:	e1a03002 	mov	r3, r2
3000f908:	e1a03103 	lsl	r3, r3, #2
3000f90c:	e0833002 	add	r3, r3, r2
3000f910:	e1a03103 	lsl	r3, r3, #2
3000f914:	e1a02003 	mov	r2, r3
3000f918:	e59f302c 	ldr	r3, [pc, #44]	; 3000f94c <get_socket+0x74>
3000f91c:	e0823003 	add	r3, r2, r3
3000f920:	e58d300c 	str	r3, [sp, #12]

  if (!sock->conn) {
3000f924:	e59d300c 	ldr	r3, [sp, #12]
3000f928:	e5933000 	ldr	r3, [r3]
3000f92c:	e3530000 	cmp	r3, #0
3000f930:	1a000001 	bne	3000f93c <get_socket+0x64>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
    return NULL;
3000f934:	e3a03000 	mov	r3, #0
3000f938:	ea000000 	b	3000f940 <get_socket+0x68>
  }

  return sock;
3000f93c:	e59d300c 	ldr	r3, [sp, #12]
}
3000f940:	e1a00003 	mov	r0, r3
3000f944:	e28dd010 	add	sp, sp, #16
3000f948:	e12fff1e 	bx	lr
3000f94c:	300271a8 	.word	0x300271a8

3000f950 <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
3000f950:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f954:	e24dd014 	sub	sp, sp, #20
3000f958:	e58d0004 	str	r0, [sp, #4]
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
3000f95c:	e59f31bc 	ldr	r3, [pc, #444]	; 3000fb20 <alloc_socket+0x1d0>
3000f960:	e5933000 	ldr	r3, [r3]
3000f964:	e1a00003 	mov	r0, r3
3000f968:	eb001e12 	bl	300171b8 <sys_sem_wait>

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
3000f96c:	e3a03000 	mov	r3, #0
3000f970:	e58d300c 	str	r3, [sp, #12]
3000f974:	ea00005d 	b	3000faf0 <alloc_socket+0x1a0>
    if (!sockets[i].conn) {
3000f978:	e59d200c 	ldr	r2, [sp, #12]
3000f97c:	e59f11a0 	ldr	r1, [pc, #416]	; 3000fb24 <alloc_socket+0x1d4>
3000f980:	e1a03002 	mov	r3, r2
3000f984:	e1a03103 	lsl	r3, r3, #2
3000f988:	e0833002 	add	r3, r3, r2
3000f98c:	e1a03103 	lsl	r3, r3, #2
3000f990:	e0833001 	add	r3, r3, r1
3000f994:	e5933000 	ldr	r3, [r3]
3000f998:	e3530000 	cmp	r3, #0
3000f99c:	1a000050 	bne	3000fae4 <alloc_socket+0x194>
      sockets[i].conn       = newconn;
3000f9a0:	e59d200c 	ldr	r2, [sp, #12]
3000f9a4:	e59f1178 	ldr	r1, [pc, #376]	; 3000fb24 <alloc_socket+0x1d4>
3000f9a8:	e1a03002 	mov	r3, r2
3000f9ac:	e1a03103 	lsl	r3, r3, #2
3000f9b0:	e0833002 	add	r3, r3, r2
3000f9b4:	e1a03103 	lsl	r3, r3, #2
3000f9b8:	e0833001 	add	r3, r3, r1
3000f9bc:	e59d2004 	ldr	r2, [sp, #4]
3000f9c0:	e5832000 	str	r2, [r3]
      sockets[i].lastdata   = NULL;
3000f9c4:	e59d200c 	ldr	r2, [sp, #12]
3000f9c8:	e59f0154 	ldr	r0, [pc, #340]	; 3000fb24 <alloc_socket+0x1d4>
3000f9cc:	e3a01004 	mov	r1, #4
3000f9d0:	e1a03002 	mov	r3, r2
3000f9d4:	e1a03103 	lsl	r3, r3, #2
3000f9d8:	e0833002 	add	r3, r3, r2
3000f9dc:	e1a03103 	lsl	r3, r3, #2
3000f9e0:	e0833000 	add	r3, r3, r0
3000f9e4:	e0833001 	add	r3, r3, r1
3000f9e8:	e3a02000 	mov	r2, #0
3000f9ec:	e5832000 	str	r2, [r3]
      sockets[i].lastoffset = 0;
3000f9f0:	e59d200c 	ldr	r2, [sp, #12]
3000f9f4:	e59f0128 	ldr	r0, [pc, #296]	; 3000fb24 <alloc_socket+0x1d4>
3000f9f8:	e3a01008 	mov	r1, #8
3000f9fc:	e1a03002 	mov	r3, r2
3000fa00:	e1a03103 	lsl	r3, r3, #2
3000fa04:	e0833002 	add	r3, r3, r2
3000fa08:	e1a03103 	lsl	r3, r3, #2
3000fa0c:	e0833000 	add	r3, r3, r0
3000fa10:	e0833001 	add	r3, r3, r1
3000fa14:	e3a02000 	mov	r2, #0
3000fa18:	e1c320b0 	strh	r2, [r3]
      sockets[i].rcvevent   = 0;
3000fa1c:	e59d200c 	ldr	r2, [sp, #12]
3000fa20:	e59f00fc 	ldr	r0, [pc, #252]	; 3000fb24 <alloc_socket+0x1d4>
3000fa24:	e3a01008 	mov	r1, #8
3000fa28:	e1a03002 	mov	r3, r2
3000fa2c:	e1a03103 	lsl	r3, r3, #2
3000fa30:	e0833002 	add	r3, r3, r2
3000fa34:	e1a03103 	lsl	r3, r3, #2
3000fa38:	e0833000 	add	r3, r3, r0
3000fa3c:	e0833001 	add	r3, r3, r1
3000fa40:	e3a02000 	mov	r2, #0
3000fa44:	e1c320b2 	strh	r2, [r3, #2]
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
3000fa48:	e59d200c 	ldr	r2, [sp, #12]
3000fa4c:	e59f00d0 	ldr	r0, [pc, #208]	; 3000fb24 <alloc_socket+0x1d4>
3000fa50:	e3a01008 	mov	r1, #8
3000fa54:	e1a03002 	mov	r3, r2
3000fa58:	e1a03103 	lsl	r3, r3, #2
3000fa5c:	e0833002 	add	r3, r3, r2
3000fa60:	e1a03103 	lsl	r3, r3, #2
3000fa64:	e0833000 	add	r3, r3, r0
3000fa68:	e0833001 	add	r3, r3, r1
3000fa6c:	e3a02001 	mov	r2, #1
3000fa70:	e1c320b4 	strh	r2, [r3, #4]
      sockets[i].flags      = 0;
3000fa74:	e59d200c 	ldr	r2, [sp, #12]
3000fa78:	e59f00a4 	ldr	r0, [pc, #164]	; 3000fb24 <alloc_socket+0x1d4>
3000fa7c:	e3a01008 	mov	r1, #8
3000fa80:	e1a03002 	mov	r3, r2
3000fa84:	e1a03103 	lsl	r3, r3, #2
3000fa88:	e0833002 	add	r3, r3, r2
3000fa8c:	e1a03103 	lsl	r3, r3, #2
3000fa90:	e0833000 	add	r3, r3, r0
3000fa94:	e0833001 	add	r3, r3, r1
3000fa98:	e3a02000 	mov	r2, #0
3000fa9c:	e1c320b6 	strh	r2, [r3, #6]
      sockets[i].err        = 0;
3000faa0:	e59d200c 	ldr	r2, [sp, #12]
3000faa4:	e59f0078 	ldr	r0, [pc, #120]	; 3000fb24 <alloc_socket+0x1d4>
3000faa8:	e3a01010 	mov	r1, #16
3000faac:	e1a03002 	mov	r3, r2
3000fab0:	e1a03103 	lsl	r3, r3, #2
3000fab4:	e0833002 	add	r3, r3, r2
3000fab8:	e1a03103 	lsl	r3, r3, #2
3000fabc:	e0833000 	add	r3, r3, r0
3000fac0:	e0833001 	add	r3, r3, r1
3000fac4:	e3a02000 	mov	r2, #0
3000fac8:	e5832000 	str	r2, [r3]
      sys_sem_signal(socksem);
3000facc:	e59f304c 	ldr	r3, [pc, #76]	; 3000fb20 <alloc_socket+0x1d0>
3000fad0:	e5933000 	ldr	r3, [r3]
3000fad4:	e1a00003 	mov	r0, r3
3000fad8:	ebfff40e 	bl	3000cb18 <sys_sem_signal>
      return i;
3000fadc:	e59d300c 	ldr	r3, [sp, #12]
3000fae0:	ea00000a 	b	3000fb10 <alloc_socket+0x1c0>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
3000fae4:	e59d300c 	ldr	r3, [sp, #12]
3000fae8:	e2833001 	add	r3, r3, #1
3000faec:	e58d300c 	str	r3, [sp, #12]
3000faf0:	e59d300c 	ldr	r3, [sp, #12]
3000faf4:	e3530003 	cmp	r3, #3
3000faf8:	daffff9e 	ble	3000f978 <alloc_socket+0x28>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
3000fafc:	e59f301c 	ldr	r3, [pc, #28]	; 3000fb20 <alloc_socket+0x1d0>
3000fb00:	e5933000 	ldr	r3, [r3]
3000fb04:	e1a00003 	mov	r0, r3
3000fb08:	ebfff402 	bl	3000cb18 <sys_sem_signal>
  return -1;
3000fb0c:	e3e03000 	mvn	r3, #0
}
3000fb10:	e1a00003 	mov	r0, r3
3000fb14:	e28dd014 	add	sp, sp, #20
3000fb18:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000fb1c:	e12fff1e 	bx	lr
3000fb20:	300271fc 	.word	0x300271fc
3000fb24:	300271a8 	.word	0x300271a8

3000fb28 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
3000fb28:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000fb2c:	e24dd044 	sub	sp, sp, #68	; 0x44
3000fb30:	e58d000c 	str	r0, [sp, #12]
3000fb34:	e58d1008 	str	r1, [sp, #8]
3000fb38:	e58d2004 	str	r2, [sp, #4]
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
3000fb3c:	e59d000c 	ldr	r0, [sp, #12]
3000fb40:	ebffff64 	bl	3000f8d8 <get_socket>
3000fb44:	e1a03000 	mov	r3, r0
3000fb48:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  if (!sock)
3000fb4c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3000fb50:	e3530000 	cmp	r3, #0
3000fb54:	1a000001 	bne	3000fb60 <lwip_accept+0x38>
    return -1;
3000fb58:	e3e03000 	mvn	r3, #0
3000fb5c:	ea000090 	b	3000fda4 <lwip_accept+0x27c>

  newconn = netconn_accept(sock->conn);
3000fb60:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3000fb64:	e5933000 	ldr	r3, [r3]
3000fb68:	e1a00003 	mov	r0, r3
3000fb6c:	ebfff5de 	bl	3000d2ec <netconn_accept>
3000fb70:	e1a03000 	mov	r3, r0
3000fb74:	e58d3034 	str	r3, [sp, #52]	; 0x34
  if (!newconn) {
3000fb78:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3000fb7c:	e3530000 	cmp	r3, #0
3000fb80:	1a000015 	bne	3000fbdc <lwip_accept+0xb4>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
3000fb84:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3000fb88:	e5933000 	ldr	r3, [r3]
3000fb8c:	e5d33008 	ldrb	r3, [r3, #8]
3000fb90:	e1a03c03 	lsl	r3, r3, #24
3000fb94:	e1a03c43 	asr	r3, r3, #24
3000fb98:	e2633000 	rsb	r3, r3, #0
3000fb9c:	e353000e 	cmp	r3, #14
3000fba0:	8a000008 	bhi	3000fbc8 <lwip_accept+0xa0>
3000fba4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3000fba8:	e5933000 	ldr	r3, [r3]
3000fbac:	e5d33008 	ldrb	r3, [r3, #8]
3000fbb0:	e1a03c03 	lsl	r3, r3, #24
3000fbb4:	e1a03c43 	asr	r3, r3, #24
3000fbb8:	e2632000 	rsb	r2, r3, #0
3000fbbc:	e59f31f0 	ldr	r3, [pc, #496]	; 3000fdb4 <lwip_accept+0x28c>
3000fbc0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3000fbc4:	ea000000 	b	3000fbcc <lwip_accept+0xa4>
3000fbc8:	e3a03005 	mov	r3, #5
3000fbcc:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
3000fbd0:	e5823010 	str	r3, [r2, #16]
    return -1;
3000fbd4:	e3e03000 	mvn	r3, #0
3000fbd8:	ea000071 	b	3000fda4 <lwip_accept+0x27c>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
3000fbdc:	e28d2028 	add	r2, sp, #40	; 0x28
3000fbe0:	e28d3026 	add	r3, sp, #38	; 0x26
3000fbe4:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
3000fbe8:	e1a01002 	mov	r1, r2
3000fbec:	e1a02003 	mov	r2, r3
3000fbf0:	e3a03000 	mov	r3, #0
3000fbf4:	ebfff544 	bl	3000d10c <netconn_getaddr>
3000fbf8:	e1a03000 	mov	r3, r0
3000fbfc:	e20330ff 	and	r3, r3, #255	; 0xff
3000fc00:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
  if (err != ERR_OK) {
3000fc04:	e1dd33df 	ldrsb	r3, [sp, #63]	; 0x3f
3000fc08:	e3530000 	cmp	r3, #0
3000fc0c:	0a00000f 	beq	3000fc50 <lwip_accept+0x128>
    netconn_delete(newconn);
3000fc10:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
3000fc14:	ebfff519 	bl	3000d080 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
3000fc18:	e1dd33df 	ldrsb	r3, [sp, #63]	; 0x3f
3000fc1c:	e2633000 	rsb	r3, r3, #0
3000fc20:	e353000e 	cmp	r3, #14
3000fc24:	8a000004 	bhi	3000fc3c <lwip_accept+0x114>
3000fc28:	e1dd33df 	ldrsb	r3, [sp, #63]	; 0x3f
3000fc2c:	e2632000 	rsb	r2, r3, #0
3000fc30:	e59f317c 	ldr	r3, [pc, #380]	; 3000fdb4 <lwip_accept+0x28c>
3000fc34:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3000fc38:	ea000000 	b	3000fc40 <lwip_accept+0x118>
3000fc3c:	e3a03005 	mov	r3, #5
3000fc40:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
3000fc44:	e5823010 	str	r3, [r2, #16]
    return -1;
3000fc48:	e3e03000 	mvn	r3, #0
3000fc4c:	ea000054 	b	3000fda4 <lwip_accept+0x27c>
  }

  memset(&sin, 0, sizeof(sin));
3000fc50:	e28d3014 	add	r3, sp, #20
3000fc54:	e1a00003 	mov	r0, r3
3000fc58:	e3a01000 	mov	r1, #0
3000fc5c:	e3a02010 	mov	r2, #16
3000fc60:	ebfff49f 	bl	3000cee4 <__re_memset>
  sin.sin_len = sizeof(sin);
3000fc64:	e3a03010 	mov	r3, #16
3000fc68:	e5cd3014 	strb	r3, [sp, #20]
  sin.sin_family = AF_INET;
3000fc6c:	e3a03002 	mov	r3, #2
3000fc70:	e5cd3015 	strb	r3, [sp, #21]
  sin.sin_port = htons(port);
3000fc74:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3000fc78:	e1a00003 	mov	r0, r3
3000fc7c:	eb000f0e 	bl	300138bc <htons>
3000fc80:	e1a03000 	mov	r3, r0
3000fc84:	e1cd31b6 	strh	r3, [sp, #22]
  sin.sin_addr.s_addr = naddr.addr;
3000fc88:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000fc8c:	e58d3018 	str	r3, [sp, #24]

  if (*addrlen > sizeof(sin))
3000fc90:	e59d3004 	ldr	r3, [sp, #4]
3000fc94:	e5933000 	ldr	r3, [r3]
3000fc98:	e3530010 	cmp	r3, #16
3000fc9c:	9a000002 	bls	3000fcac <lwip_accept+0x184>
    *addrlen = sizeof(sin);
3000fca0:	e59d3004 	ldr	r3, [sp, #4]
3000fca4:	e3a02010 	mov	r2, #16
3000fca8:	e5832000 	str	r2, [r3]

  SMEMCPY(addr, &sin, *addrlen);
3000fcac:	e59d3004 	ldr	r3, [sp, #4]
3000fcb0:	e5933000 	ldr	r3, [r3]
3000fcb4:	e28d2014 	add	r2, sp, #20
3000fcb8:	e59d0008 	ldr	r0, [sp, #8]
3000fcbc:	e1a01002 	mov	r1, r2
3000fcc0:	e1a02003 	mov	r2, r3
3000fcc4:	ebfff4a0 	bl	3000cf4c <__re_memcpy>

  newsock = alloc_socket(newconn);
3000fcc8:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
3000fccc:	ebffff1f 	bl	3000f950 <alloc_socket>
3000fcd0:	e1a03000 	mov	r3, r0
3000fcd4:	e58d3038 	str	r3, [sp, #56]	; 0x38
  if (newsock == -1) {
3000fcd8:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3000fcdc:	e3730001 	cmn	r3, #1
3000fce0:	1a000006 	bne	3000fd00 <lwip_accept+0x1d8>
    netconn_delete(newconn);
3000fce4:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
3000fce8:	ebfff4e4 	bl	3000d080 <netconn_delete>
    sock_set_errno(sock, ENFILE);
3000fcec:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3000fcf0:	e3a02017 	mov	r2, #23
3000fcf4:	e5832010 	str	r2, [r3, #16]
    return -1;
3000fcf8:	e3e03000 	mvn	r3, #0
3000fcfc:	ea000028 	b	3000fda4 <lwip_accept+0x27c>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  newconn->callback = event_callback;
3000fd00:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3000fd04:	e59f20ac 	ldr	r2, [pc, #172]	; 3000fdb8 <lwip_accept+0x290>
3000fd08:	e5832028 	str	r2, [r3, #40]	; 0x28
  nsock = &sockets[newsock];
3000fd0c:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
3000fd10:	e1a03002 	mov	r3, r2
3000fd14:	e1a03103 	lsl	r3, r3, #2
3000fd18:	e0833002 	add	r3, r3, r2
3000fd1c:	e1a03103 	lsl	r3, r3, #2
3000fd20:	e1a02003 	mov	r2, r3
3000fd24:	e59f3090 	ldr	r3, [pc, #144]	; 3000fdbc <lwip_accept+0x294>
3000fd28:	e0823003 	add	r3, r2, r3
3000fd2c:	e58d3030 	str	r3, [sp, #48]	; 0x30
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);

  sys_sem_wait(socksem);
3000fd30:	e59f3088 	ldr	r3, [pc, #136]	; 3000fdc0 <lwip_accept+0x298>
3000fd34:	e5933000 	ldr	r3, [r3]
3000fd38:	e1a00003 	mov	r0, r3
3000fd3c:	eb001d1d 	bl	300171b8 <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
3000fd40:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3000fd44:	e1d320ba 	ldrh	r2, [r3, #10]
3000fd48:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3000fd4c:	e5933018 	ldr	r3, [r3, #24]
3000fd50:	e1a03803 	lsl	r3, r3, #16
3000fd54:	e1a03823 	lsr	r3, r3, #16
3000fd58:	e1e03003 	mvn	r3, r3
3000fd5c:	e1a03803 	lsl	r3, r3, #16
3000fd60:	e1a03823 	lsr	r3, r3, #16
3000fd64:	e0823003 	add	r3, r2, r3
3000fd68:	e1a03803 	lsl	r3, r3, #16
3000fd6c:	e1a02823 	lsr	r2, r3, #16
3000fd70:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3000fd74:	e1c320ba 	strh	r2, [r3, #10]
  newconn->socket = newsock;
3000fd78:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3000fd7c:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
3000fd80:	e5832018 	str	r2, [r3, #24]
  sys_sem_signal(socksem);
3000fd84:	e59f3034 	ldr	r3, [pc, #52]	; 3000fdc0 <lwip_accept+0x298>
3000fd88:	e5933000 	ldr	r3, [r3]
3000fd8c:	e1a00003 	mov	r0, r3
3000fd90:	ebfff360 	bl	3000cb18 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
3000fd94:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3000fd98:	e3a02000 	mov	r2, #0
3000fd9c:	e5832010 	str	r2, [r3, #16]
  return newsock;
3000fda0:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
}
3000fda4:	e1a00003 	mov	r0, r3
3000fda8:	e28dd044 	add	sp, sp, #68	; 0x44
3000fdac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000fdb0:	e12fff1e 	bx	lr
3000fdb4:	30026498 	.word	0x30026498
3000fdb8:	300111b4 	.word	0x300111b4
3000fdbc:	300271a8 	.word	0x300271a8
3000fdc0:	300271fc 	.word	0x300271fc

3000fdc4 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
3000fdc4:	e92d4010 	push	{r4, lr}
3000fdc8:	e24dd020 	sub	sp, sp, #32
3000fdcc:	e58d000c 	str	r0, [sp, #12]
3000fdd0:	e58d1008 	str	r1, [sp, #8]
3000fdd4:	e58d2004 	str	r2, [sp, #4]
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
3000fdd8:	e59d000c 	ldr	r0, [sp, #12]
3000fddc:	ebfffebd 	bl	3000f8d8 <get_socket>
3000fde0:	e1a03000 	mov	r3, r0
3000fde4:	e58d3018 	str	r3, [sp, #24]
  if (!sock)
3000fde8:	e59d3018 	ldr	r3, [sp, #24]
3000fdec:	e3530000 	cmp	r3, #0
3000fdf0:	1a000001 	bne	3000fdfc <lwip_bind+0x38>
    return -1;
3000fdf4:	e3e03000 	mvn	r3, #0
3000fdf8:	ea000028 	b	3000fea0 <lwip_bind+0xdc>

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
3000fdfc:	e59d3008 	ldr	r3, [sp, #8]
3000fe00:	e5933004 	ldr	r3, [r3, #4]
3000fe04:	e58d3014 	str	r3, [sp, #20]
  local_port = ((struct sockaddr_in *)name)->sin_port;
3000fe08:	e59d3008 	ldr	r3, [sp, #8]
3000fe0c:	e1d330b2 	ldrh	r3, [r3, #2]
3000fe10:	e1cd31bc 	strh	r3, [sp, #28]

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
3000fe14:	e59d3018 	ldr	r3, [sp, #24]
3000fe18:	e5934000 	ldr	r4, [r3]
3000fe1c:	e1dd31bc 	ldrh	r3, [sp, #28]
3000fe20:	e1a00003 	mov	r0, r3
3000fe24:	eb000eb7 	bl	30013908 <ntohs>
3000fe28:	e1a03000 	mov	r3, r0
3000fe2c:	e28d2014 	add	r2, sp, #20
3000fe30:	e1a00004 	mov	r0, r4
3000fe34:	e1a01002 	mov	r1, r2
3000fe38:	e1a02003 	mov	r2, r3
3000fe3c:	ebfff4ce 	bl	3000d17c <netconn_bind>
3000fe40:	e1a03000 	mov	r3, r0
3000fe44:	e20330ff 	and	r3, r3, #255	; 0xff
3000fe48:	e5cd301f 	strb	r3, [sp, #31]

  if (err != ERR_OK) {
3000fe4c:	e1dd31df 	ldrsb	r3, [sp, #31]
3000fe50:	e3530000 	cmp	r3, #0
3000fe54:	0a00000d 	beq	3000fe90 <lwip_bind+0xcc>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
3000fe58:	e1dd31df 	ldrsb	r3, [sp, #31]
3000fe5c:	e2633000 	rsb	r3, r3, #0
3000fe60:	e353000e 	cmp	r3, #14
3000fe64:	8a000004 	bhi	3000fe7c <lwip_bind+0xb8>
3000fe68:	e1dd31df 	ldrsb	r3, [sp, #31]
3000fe6c:	e2632000 	rsb	r2, r3, #0
3000fe70:	e59f3038 	ldr	r3, [pc, #56]	; 3000feb0 <lwip_bind+0xec>
3000fe74:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3000fe78:	ea000000 	b	3000fe80 <lwip_bind+0xbc>
3000fe7c:	e3a03005 	mov	r3, #5
3000fe80:	e59d2018 	ldr	r2, [sp, #24]
3000fe84:	e5823010 	str	r3, [r2, #16]
    return -1;
3000fe88:	e3e03000 	mvn	r3, #0
3000fe8c:	ea000003 	b	3000fea0 <lwip_bind+0xdc>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
3000fe90:	e59d3018 	ldr	r3, [sp, #24]
3000fe94:	e3a02000 	mov	r2, #0
3000fe98:	e5832010 	str	r2, [r3, #16]
  return 0;
3000fe9c:	e3a03000 	mov	r3, #0
}
3000fea0:	e1a00003 	mov	r0, r3
3000fea4:	e28dd020 	add	sp, sp, #32
3000fea8:	e8bd4010 	pop	{r4, lr}
3000feac:	e12fff1e 	bx	lr
3000feb0:	30026498 	.word	0x30026498

3000feb4 <lwip_close>:

int
lwip_close(int s)
{
3000feb4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000feb8:	e24dd014 	sub	sp, sp, #20
3000febc:	e58d0004 	str	r0, [sp, #4]
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
3000fec0:	e59d0004 	ldr	r0, [sp, #4]
3000fec4:	ebfffe83 	bl	3000f8d8 <get_socket>
3000fec8:	e1a03000 	mov	r3, r0
3000fecc:	e58d300c 	str	r3, [sp, #12]
  if (!sock) {
3000fed0:	e59d300c 	ldr	r3, [sp, #12]
3000fed4:	e3530000 	cmp	r3, #0
3000fed8:	1a000001 	bne	3000fee4 <lwip_close+0x30>
    return -1;
3000fedc:	e3e03000 	mvn	r3, #0
3000fee0:	ea000020 	b	3000ff68 <lwip_close+0xb4>
  }

  netconn_delete(sock->conn);
3000fee4:	e59d300c 	ldr	r3, [sp, #12]
3000fee8:	e5933000 	ldr	r3, [r3]
3000feec:	e1a00003 	mov	r0, r3
3000fef0:	ebfff462 	bl	3000d080 <netconn_delete>

  sys_sem_wait(socksem);
3000fef4:	e59f307c 	ldr	r3, [pc, #124]	; 3000ff78 <lwip_close+0xc4>
3000fef8:	e5933000 	ldr	r3, [r3]
3000fefc:	e1a00003 	mov	r0, r3
3000ff00:	eb001cac 	bl	300171b8 <sys_sem_wait>
  if (sock->lastdata) {
3000ff04:	e59d300c 	ldr	r3, [sp, #12]
3000ff08:	e5933004 	ldr	r3, [r3, #4]
3000ff0c:	e3530000 	cmp	r3, #0
3000ff10:	0a000003 	beq	3000ff24 <lwip_close+0x70>
    netbuf_delete(sock->lastdata);
3000ff14:	e59d300c 	ldr	r3, [sp, #12]
3000ff18:	e5933004 	ldr	r3, [r3, #4]
3000ff1c:	e1a00003 	mov	r0, r3
3000ff20:	ebfffd80 	bl	3000f528 <netbuf_delete>
  }
  sock->lastdata   = NULL;
3000ff24:	e59d300c 	ldr	r3, [sp, #12]
3000ff28:	e3a02000 	mov	r2, #0
3000ff2c:	e5832004 	str	r2, [r3, #4]
  sock->lastoffset = 0;
3000ff30:	e59d300c 	ldr	r3, [sp, #12]
3000ff34:	e3a02000 	mov	r2, #0
3000ff38:	e1c320b8 	strh	r2, [r3, #8]
  sock->conn       = NULL;
3000ff3c:	e59d300c 	ldr	r3, [sp, #12]
3000ff40:	e3a02000 	mov	r2, #0
3000ff44:	e5832000 	str	r2, [r3]
  sock_set_errno(sock, 0);
3000ff48:	e59d300c 	ldr	r3, [sp, #12]
3000ff4c:	e3a02000 	mov	r2, #0
3000ff50:	e5832010 	str	r2, [r3, #16]
  sys_sem_signal(socksem);
3000ff54:	e59f301c 	ldr	r3, [pc, #28]	; 3000ff78 <lwip_close+0xc4>
3000ff58:	e5933000 	ldr	r3, [r3]
3000ff5c:	e1a00003 	mov	r0, r3
3000ff60:	ebfff2ec 	bl	3000cb18 <sys_sem_signal>
  return 0;
3000ff64:	e3a03000 	mov	r3, #0
}
3000ff68:	e1a00003 	mov	r0, r3
3000ff6c:	e28dd014 	add	sp, sp, #20
3000ff70:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000ff74:	e12fff1e 	bx	lr
3000ff78:	300271fc 	.word	0x300271fc

3000ff7c <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
3000ff7c:	e92d4010 	push	{r4, lr}
3000ff80:	e24dd020 	sub	sp, sp, #32
3000ff84:	e58d000c 	str	r0, [sp, #12]
3000ff88:	e58d1008 	str	r1, [sp, #8]
3000ff8c:	e58d2004 	str	r2, [sp, #4]
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
3000ff90:	e59d000c 	ldr	r0, [sp, #12]
3000ff94:	ebfffe4f 	bl	3000f8d8 <get_socket>
3000ff98:	e1a03000 	mov	r3, r0
3000ff9c:	e58d3018 	str	r3, [sp, #24]
  if (!sock)
3000ffa0:	e59d3018 	ldr	r3, [sp, #24]
3000ffa4:	e3530000 	cmp	r3, #0
3000ffa8:	1a000001 	bne	3000ffb4 <lwip_connect+0x38>
    return -1;
3000ffac:	e3e03000 	mvn	r3, #0
3000ffb0:	ea000034 	b	30010088 <lwip_connect+0x10c>

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  if (((struct sockaddr_in *)name)->sin_family == AF_UNSPEC) {
3000ffb4:	e59d3008 	ldr	r3, [sp, #8]
3000ffb8:	e5d33001 	ldrb	r3, [r3, #1]
3000ffbc:	e3530000 	cmp	r3, #0
3000ffc0:	1a000007 	bne	3000ffe4 <lwip_connect+0x68>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
3000ffc4:	e59d3018 	ldr	r3, [sp, #24]
3000ffc8:	e5933000 	ldr	r3, [r3]
3000ffcc:	e1a00003 	mov	r0, r3
3000ffd0:	ebfff49d 	bl	3000d24c <netconn_disconnect>
3000ffd4:	e1a03000 	mov	r3, r0
3000ffd8:	e20330ff 	and	r3, r3, #255	; 0xff
3000ffdc:	e5cd301d 	strb	r3, [sp, #29]
3000ffe0:	ea000013 	b	30010034 <lwip_connect+0xb8>
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
3000ffe4:	e59d3008 	ldr	r3, [sp, #8]
3000ffe8:	e5933004 	ldr	r3, [r3, #4]
3000ffec:	e58d3014 	str	r3, [sp, #20]
    remote_port = ((struct sockaddr_in *)name)->sin_port;
3000fff0:	e59d3008 	ldr	r3, [sp, #8]
3000fff4:	e1d330b2 	ldrh	r3, [r3, #2]
3000fff8:	e1cd31be 	strh	r3, [sp, #30]

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
3000fffc:	e59d3018 	ldr	r3, [sp, #24]
30010000:	e5934000 	ldr	r4, [r3]
30010004:	e1dd31be 	ldrh	r3, [sp, #30]
30010008:	e1a00003 	mov	r0, r3
3001000c:	eb000e3d 	bl	30013908 <ntohs>
30010010:	e1a03000 	mov	r3, r0
30010014:	e28d2014 	add	r2, sp, #20
30010018:	e1a00004 	mov	r0, r4
3001001c:	e1a01002 	mov	r1, r2
30010020:	e1a02003 	mov	r2, r3
30010024:	ebfff46e 	bl	3000d1e4 <netconn_connect>
30010028:	e1a03000 	mov	r3, r0
3001002c:	e20330ff 	and	r3, r3, #255	; 0xff
30010030:	e5cd301d 	strb	r3, [sp, #29]
  }

  if (err != ERR_OK) {
30010034:	e1dd31dd 	ldrsb	r3, [sp, #29]
30010038:	e3530000 	cmp	r3, #0
3001003c:	0a00000d 	beq	30010078 <lwip_connect+0xfc>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
30010040:	e1dd31dd 	ldrsb	r3, [sp, #29]
30010044:	e2633000 	rsb	r3, r3, #0
30010048:	e353000e 	cmp	r3, #14
3001004c:	8a000004 	bhi	30010064 <lwip_connect+0xe8>
30010050:	e1dd31dd 	ldrsb	r3, [sp, #29]
30010054:	e2632000 	rsb	r2, r3, #0
30010058:	e59f3038 	ldr	r3, [pc, #56]	; 30010098 <lwip_connect+0x11c>
3001005c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30010060:	ea000000 	b	30010068 <lwip_connect+0xec>
30010064:	e3a03005 	mov	r3, #5
30010068:	e59d2018 	ldr	r2, [sp, #24]
3001006c:	e5823010 	str	r3, [r2, #16]
    return -1;
30010070:	e3e03000 	mvn	r3, #0
30010074:	ea000003 	b	30010088 <lwip_connect+0x10c>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
30010078:	e59d3018 	ldr	r3, [sp, #24]
3001007c:	e3a02000 	mov	r2, #0
30010080:	e5832010 	str	r2, [r3, #16]
  return 0;
30010084:	e3a03000 	mov	r3, #0
}
30010088:	e1a00003 	mov	r0, r3
3001008c:	e28dd020 	add	sp, sp, #32
30010090:	e8bd4010 	pop	{r4, lr}
30010094:	e12fff1e 	bx	lr
30010098:	30026498 	.word	0x30026498

3001009c <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
3001009c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300100a0:	e24dd014 	sub	sp, sp, #20
300100a4:	e58d0004 	str	r0, [sp, #4]
300100a8:	e58d1000 	str	r1, [sp]
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
300100ac:	e59d0004 	ldr	r0, [sp, #4]
300100b0:	ebfffe08 	bl	3000f8d8 <get_socket>
300100b4:	e1a03000 	mov	r3, r0
300100b8:	e58d3008 	str	r3, [sp, #8]
  if (!sock)
300100bc:	e59d3008 	ldr	r3, [sp, #8]
300100c0:	e3530000 	cmp	r3, #0
300100c4:	1a000001 	bne	300100d0 <lwip_listen+0x34>
    return -1;
300100c8:	e3e03000 	mvn	r3, #0
300100cc:	ea000028 	b	30010174 <lwip_listen+0xd8>

  /* limit the "backlog" parameter to fit in an u8_t */
  if (backlog < 0) {
300100d0:	e59d3000 	ldr	r3, [sp]
300100d4:	e3530000 	cmp	r3, #0
300100d8:	aa000001 	bge	300100e4 <lwip_listen+0x48>
    backlog = 0;
300100dc:	e3a03000 	mov	r3, #0
300100e0:	e58d3000 	str	r3, [sp]
  }
  if (backlog > 0xff) {
300100e4:	e59d3000 	ldr	r3, [sp]
300100e8:	e35300ff 	cmp	r3, #255	; 0xff
300100ec:	da000001 	ble	300100f8 <lwip_listen+0x5c>
    backlog = 0xff;
300100f0:	e3a030ff 	mov	r3, #255	; 0xff
300100f4:	e58d3000 	str	r3, [sp]
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
300100f8:	e59d3008 	ldr	r3, [sp, #8]
300100fc:	e5932000 	ldr	r2, [r3]
30010100:	e59d3000 	ldr	r3, [sp]
30010104:	e20330ff 	and	r3, r3, #255	; 0xff
30010108:	e1a00002 	mov	r0, r2
3001010c:	e1a01003 	mov	r1, r3
30010110:	ebfff460 	bl	3000d298 <netconn_listen_with_backlog>
30010114:	e1a03000 	mov	r3, r0
30010118:	e20330ff 	and	r3, r3, #255	; 0xff
3001011c:	e5cd300f 	strb	r3, [sp, #15]

  if (err != ERR_OK) {
30010120:	e1dd30df 	ldrsb	r3, [sp, #15]
30010124:	e3530000 	cmp	r3, #0
30010128:	0a00000d 	beq	30010164 <lwip_listen+0xc8>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
3001012c:	e1dd30df 	ldrsb	r3, [sp, #15]
30010130:	e2633000 	rsb	r3, r3, #0
30010134:	e353000e 	cmp	r3, #14
30010138:	8a000004 	bhi	30010150 <lwip_listen+0xb4>
3001013c:	e1dd30df 	ldrsb	r3, [sp, #15]
30010140:	e2632000 	rsb	r2, r3, #0
30010144:	e59f3038 	ldr	r3, [pc, #56]	; 30010184 <lwip_listen+0xe8>
30010148:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3001014c:	ea000000 	b	30010154 <lwip_listen+0xb8>
30010150:	e3a03005 	mov	r3, #5
30010154:	e59d2008 	ldr	r2, [sp, #8]
30010158:	e5823010 	str	r3, [r2, #16]
    return -1;
3001015c:	e3e03000 	mvn	r3, #0
30010160:	ea000003 	b	30010174 <lwip_listen+0xd8>
  }

  sock_set_errno(sock, 0);
30010164:	e59d3008 	ldr	r3, [sp, #8]
30010168:	e3a02000 	mov	r2, #0
3001016c:	e5832010 	str	r2, [r3, #16]
  return 0;
30010170:	e3a03000 	mov	r3, #0
}
30010174:	e1a00003 	mov	r0, r3
30010178:	e28dd014 	add	sp, sp, #20
3001017c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30010180:	e12fff1e 	bx	lr
30010184:	30026498 	.word	0x30026498

30010188 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
30010188:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001018c:	e24dd044 	sub	sp, sp, #68	; 0x44
30010190:	e58d000c 	str	r0, [sp, #12]
30010194:	e58d1008 	str	r1, [sp, #8]
30010198:	e58d2004 	str	r2, [sp, #4]
3001019c:	e58d3000 	str	r3, [sp]
  struct lwip_socket *sock;
  struct netbuf      *buf;
  u16_t               buflen, copylen, off = 0;
300101a0:	e3a03000 	mov	r3, #0
300101a4:	e1cd33b6 	strh	r3, [sp, #54]	; 0x36
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;
300101a8:	e3a03000 	mov	r3, #0
300101ac:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
300101b0:	e59d000c 	ldr	r0, [sp, #12]
300101b4:	ebfffdc7 	bl	3000f8d8 <get_socket>
300101b8:	e1a03000 	mov	r3, r0
300101bc:	e58d3028 	str	r3, [sp, #40]	; 0x28
  if (!sock)
300101c0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300101c4:	e3530000 	cmp	r3, #0
300101c8:	1a000001 	bne	300101d4 <lwip_recvfrom+0x4c>
    return -1;
300101cc:	e3e03000 	mvn	r3, #0
300101d0:	ea0000fa 	b	300105c0 <lwip_recvfrom+0x438>

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
300101d4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300101d8:	e5933004 	ldr	r3, [r3, #4]
300101dc:	e3530000 	cmp	r3, #0
300101e0:	0a000003 	beq	300101f4 <lwip_recvfrom+0x6c>
      buf = sock->lastdata;
300101e4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300101e8:	e5933004 	ldr	r3, [r3, #4]
300101ec:	e58d302c 	str	r3, [sp, #44]	; 0x2c
300101f0:	ea00003f 	b	300102f4 <lwip_recvfrom+0x16c>
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
300101f4:	e59d3000 	ldr	r3, [sp]
300101f8:	e2033008 	and	r3, r3, #8
300101fc:	e3530000 	cmp	r3, #0
30010200:	1a000004 	bne	30010218 <lwip_recvfrom+0x90>
30010204:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010208:	e1d330be 	ldrh	r3, [r3, #14]
3001020c:	e2033b02 	and	r3, r3, #2048	; 0x800
30010210:	e3530000 	cmp	r3, #0
30010214:	0a000008 	beq	3001023c <lwip_recvfrom+0xb4>
30010218:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001021c:	e1d330ba 	ldrh	r3, [r3, #10]
30010220:	e3530000 	cmp	r3, #0
30010224:	1a000004 	bne	3001023c <lwip_recvfrom+0xb4>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
30010228:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001022c:	e3a0200b 	mov	r2, #11
30010230:	e5832010 	str	r2, [r3, #16]
        return -1;
30010234:	e3e03000 	mvn	r3, #0
30010238:	ea0000e0 	b	300105c0 <lwip_recvfrom+0x438>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
3001023c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010240:	e5933000 	ldr	r3, [r3]
30010244:	e1a00003 	mov	r0, r3
30010248:	ebfff441 	bl	3000d354 <netconn_recv>
3001024c:	e1a03000 	mov	r3, r0
30010250:	e58d302c 	str	r3, [sp, #44]	; 0x2c
30010254:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010258:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
3001025c:	e5832004 	str	r2, [r3, #4]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
30010260:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30010264:	e3530000 	cmp	r3, #0
30010268:	1a000021 	bne	300102f4 <lwip_recvfrom+0x16c>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
3001026c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010270:	e5933000 	ldr	r3, [r3]
30010274:	e5933004 	ldr	r3, [r3, #4]
30010278:	e3530000 	cmp	r3, #0
3001027c:	0a000004 	beq	30010294 <lwip_recvfrom+0x10c>
30010280:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010284:	e5933000 	ldr	r3, [r3]
30010288:	e5d33008 	ldrb	r3, [r3, #8]
3001028c:	e3530000 	cmp	r3, #0
30010290:	0a000012 	beq	300102e0 <lwip_recvfrom+0x158>
30010294:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010298:	e5933000 	ldr	r3, [r3]
3001029c:	e5d33008 	ldrb	r3, [r3, #8]
300102a0:	e1a03c03 	lsl	r3, r3, #24
300102a4:	e1a03c43 	asr	r3, r3, #24
300102a8:	e2633000 	rsb	r3, r3, #0
300102ac:	e353000e 	cmp	r3, #14
300102b0:	8a000008 	bhi	300102d8 <lwip_recvfrom+0x150>
300102b4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300102b8:	e5933000 	ldr	r3, [r3]
300102bc:	e5d33008 	ldrb	r3, [r3, #8]
300102c0:	e1a03c03 	lsl	r3, r3, #24
300102c4:	e1a03c43 	asr	r3, r3, #24
300102c8:	e2632000 	rsb	r2, r3, #0
300102cc:	e59f32fc 	ldr	r3, [pc, #764]	; 300105d0 <lwip_recvfrom+0x448>
300102d0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300102d4:	ea000000 	b	300102dc <lwip_recvfrom+0x154>
300102d8:	e3a03005 	mov	r3, #5
300102dc:	ea000000 	b	300102e4 <lwip_recvfrom+0x15c>
300102e0:	e3a0306e 	mov	r3, #110	; 0x6e
300102e4:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
300102e8:	e5823010 	str	r3, [r2, #16]
        return 0;
300102ec:	e3a03000 	mov	r3, #0
300102f0:	ea0000b2 	b	300105c0 <lwip_recvfrom+0x438>
      }
    }

    buflen = netbuf_len(buf);
300102f4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300102f8:	e5933000 	ldr	r3, [r3]
300102fc:	e1d330b8 	ldrh	r3, [r3, #8]
30010300:	e1cd33b2 	strh	r3, [sp, #50]	; 0x32
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
30010304:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010308:	e1d330b8 	ldrh	r3, [r3, #8]
3001030c:	e1dd23b2 	ldrh	r2, [sp, #50]	; 0x32
30010310:	e0633002 	rsb	r3, r3, r2
30010314:	e1cd33b2 	strh	r3, [sp, #50]	; 0x32

    if (len > buflen) {
30010318:	e1dd23b2 	ldrh	r2, [sp, #50]	; 0x32
3001031c:	e59d3004 	ldr	r3, [sp, #4]
30010320:	e1520003 	cmp	r2, r3
30010324:	aa000002 	bge	30010334 <lwip_recvfrom+0x1ac>
      copylen = buflen;
30010328:	e1dd33b2 	ldrh	r3, [sp, #50]	; 0x32
3001032c:	e1cd33b4 	strh	r3, [sp, #52]	; 0x34
30010330:	ea000001 	b	3001033c <lwip_recvfrom+0x1b4>
    } else {
      copylen = len;
30010334:	e59d3004 	ldr	r3, [sp, #4]
30010338:	e1cd33b4 	strh	r3, [sp, #52]	; 0x34
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
3001033c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30010340:	e5930000 	ldr	r0, [r3]
30010344:	e1dd23b6 	ldrh	r2, [sp, #54]	; 0x36
30010348:	e59d3008 	ldr	r3, [sp, #8]
3001034c:	e0821003 	add	r1, r2, r3
30010350:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010354:	e1d330b8 	ldrh	r3, [r3, #8]
30010358:	e1dd23b4 	ldrh	r2, [sp, #52]	; 0x34
3001035c:	eb00198f 	bl	300169a0 <pbuf_copy_partial>

    off += copylen;
30010360:	e1dd23b6 	ldrh	r2, [sp, #54]	; 0x36
30010364:	e1dd33b4 	ldrh	r3, [sp, #52]	; 0x34
30010368:	e0823003 	add	r3, r2, r3
3001036c:	e1cd33b6 	strh	r3, [sp, #54]	; 0x36

    if (netconn_type(sock->conn) == NETCONN_TCP) {
30010370:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010374:	e5933000 	ldr	r3, [r3]
30010378:	e1a00003 	mov	r0, r3
3001037c:	ebfff35b 	bl	3000d0f0 <netconn_type>
30010380:	e1a03000 	mov	r3, r0
30010384:	e3530010 	cmp	r3, #16
30010388:	1a000014 	bne	300103e0 <lwip_recvfrom+0x258>
      len -= copylen;
3001038c:	e1dd33b4 	ldrh	r3, [sp, #52]	; 0x34
30010390:	e59d2004 	ldr	r2, [sp, #4]
30010394:	e0633002 	rsb	r3, r3, r2
30010398:	e58d3004 	str	r3, [sp, #4]
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
3001039c:	e59d3004 	ldr	r3, [sp, #4]
300103a0:	e3530000 	cmp	r3, #0
300103a4:	da00000a 	ble	300103d4 <lwip_recvfrom+0x24c>
300103a8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300103ac:	e5933000 	ldr	r3, [r3]
300103b0:	e5d3300d 	ldrb	r3, [r3, #13]
300103b4:	e2033001 	and	r3, r3, #1
300103b8:	e20330ff 	and	r3, r3, #255	; 0xff
300103bc:	e3530000 	cmp	r3, #0
300103c0:	1a000003 	bne	300103d4 <lwip_recvfrom+0x24c>
300103c4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300103c8:	e1d330ba 	ldrh	r3, [r3, #10]
300103cc:	e3530000 	cmp	r3, #0
300103d0:	1a000005 	bne	300103ec <lwip_recvfrom+0x264>
        done = 1;
300103d4:	e3a03001 	mov	r3, #1
300103d8:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
300103dc:	ea000003 	b	300103f0 <lwip_recvfrom+0x268>
      }
    } else {
      done = 1;
300103e0:	e3a03001 	mov	r3, #1
300103e4:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
300103e8:	ea000000 	b	300103f0 <lwip_recvfrom+0x268>
    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      len -= copylen;
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
        done = 1;
300103ec:	e1a00000 	nop			; (mov r0, r0)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
300103f0:	e59d3000 	ldr	r3, [sp]
300103f4:	e2033001 	and	r3, r3, #1
300103f8:	e3530000 	cmp	r3, #0
300103fc:	1a00001f 	bne	30010480 <lwip_recvfrom+0x2f8>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
30010400:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010404:	e5933000 	ldr	r3, [r3]
30010408:	e5d33000 	ldrb	r3, [r3]
3001040c:	e3530010 	cmp	r3, #16
30010410:	1a000011 	bne	3001045c <lwip_recvfrom+0x2d4>
30010414:	e1dd23b2 	ldrh	r2, [sp, #50]	; 0x32
30010418:	e1dd33b4 	ldrh	r3, [sp, #52]	; 0x34
3001041c:	e0633002 	rsb	r3, r3, r2
30010420:	e3530000 	cmp	r3, #0
30010424:	da00000c 	ble	3001045c <lwip_recvfrom+0x2d4>
        sock->lastdata = buf;
30010428:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001042c:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30010430:	e5832004 	str	r2, [r3, #4]
        sock->lastoffset += copylen;
30010434:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010438:	e1d320b8 	ldrh	r2, [r3, #8]
3001043c:	e1dd33b4 	ldrh	r3, [sp, #52]	; 0x34
30010440:	e0823003 	add	r3, r2, r3
30010444:	e1a03803 	lsl	r3, r3, #16
30010448:	e1a02823 	lsr	r2, r3, #16
3001044c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010450:	e1c320b8 	strh	r2, [r3, #8]
    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
30010454:	e1a00000 	nop			; (mov r0, r0)
30010458:	ea00000a 	b	30010488 <lwip_recvfrom+0x300>
        sock->lastdata = buf;
        sock->lastoffset += copylen;
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
      } else {
        sock->lastdata = NULL;
3001045c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010460:	e3a02000 	mov	r2, #0
30010464:	e5832004 	str	r2, [r3, #4]
        sock->lastoffset = 0;
30010468:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001046c:	e3a02000 	mov	r2, #0
30010470:	e1c320b8 	strh	r2, [r3, #8]
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
30010474:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30010478:	ebfffc2a 	bl	3000f528 <netbuf_delete>
3001047c:	ea000001 	b	30010488 <lwip_recvfrom+0x300>
      }
    } else {
      done = 1;
30010480:	e3a03001 	mov	r3, #1
30010484:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
    }
  } while (!done);
30010488:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
3001048c:	e3530000 	cmp	r3, #0
30010490:	0affff4f 	beq	300101d4 <lwip_recvfrom+0x4c>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
30010494:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
30010498:	e3530000 	cmp	r3, #0
3001049c:	0a000043 	beq	300105b0 <lwip_recvfrom+0x428>
300104a0:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
300104a4:	e3530000 	cmp	r3, #0
300104a8:	0a000040 	beq	300105b0 <lwip_recvfrom+0x428>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
300104ac:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300104b0:	e5933000 	ldr	r3, [r3]
300104b4:	e1a00003 	mov	r0, r3
300104b8:	ebfff30c 	bl	3000d0f0 <netconn_type>
300104bc:	e1a03000 	mov	r3, r0
300104c0:	e3530010 	cmp	r3, #16
300104c4:	1a00000b 	bne	300104f8 <lwip_recvfrom+0x370>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
300104c8:	e28d3014 	add	r3, sp, #20
300104cc:	e2833004 	add	r3, r3, #4
300104d0:	e58d3038 	str	r3, [sp, #56]	; 0x38
      netconn_getaddr(sock->conn, addr, &port, 0);
300104d4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300104d8:	e5932000 	ldr	r2, [r3]
300104dc:	e28d3026 	add	r3, sp, #38	; 0x26
300104e0:	e1a00002 	mov	r0, r2
300104e4:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
300104e8:	e1a02003 	mov	r2, r3
300104ec:	e3a03000 	mov	r3, #0
300104f0:	ebfff305 	bl	3000d10c <netconn_getaddr>
300104f4:	ea000005 	b	30010510 <lwip_recvfrom+0x388>
    } else {
      addr = netbuf_fromaddr(buf);
300104f8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300104fc:	e5933008 	ldr	r3, [r3, #8]
30010500:	e58d3038 	str	r3, [sp, #56]	; 0x38
      port = netbuf_fromport(buf);
30010504:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30010508:	e1d330bc 	ldrh	r3, [r3, #12]
3001050c:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
    }

    memset(&sin, 0, sizeof(sin));
30010510:	e28d3014 	add	r3, sp, #20
30010514:	e1a00003 	mov	r0, r3
30010518:	e3a01000 	mov	r1, #0
3001051c:	e3a02010 	mov	r2, #16
30010520:	ebfff26f 	bl	3000cee4 <__re_memset>
    sin.sin_len = sizeof(sin);
30010524:	e3a03010 	mov	r3, #16
30010528:	e5cd3014 	strb	r3, [sp, #20]
    sin.sin_family = AF_INET;
3001052c:	e3a03002 	mov	r3, #2
30010530:	e5cd3015 	strb	r3, [sp, #21]
    sin.sin_port = htons(port);
30010534:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
30010538:	e1a00003 	mov	r0, r3
3001053c:	eb000cde 	bl	300138bc <htons>
30010540:	e1a03000 	mov	r3, r0
30010544:	e1cd31b6 	strh	r3, [sp, #22]
    sin.sin_addr.s_addr = addr->addr;
30010548:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3001054c:	e5d32000 	ldrb	r2, [r3]
30010550:	e5d31001 	ldrb	r1, [r3, #1]
30010554:	e1a01401 	lsl	r1, r1, #8
30010558:	e1812002 	orr	r2, r1, r2
3001055c:	e5d31002 	ldrb	r1, [r3, #2]
30010560:	e1a01801 	lsl	r1, r1, #16
30010564:	e1812002 	orr	r2, r1, r2
30010568:	e5d33003 	ldrb	r3, [r3, #3]
3001056c:	e1a03c03 	lsl	r3, r3, #24
30010570:	e1833002 	orr	r3, r3, r2
30010574:	e58d3018 	str	r3, [sp, #24]

    if (*fromlen > sizeof(sin))
30010578:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3001057c:	e5933000 	ldr	r3, [r3]
30010580:	e3530010 	cmp	r3, #16
30010584:	9a000002 	bls	30010594 <lwip_recvfrom+0x40c>
      *fromlen = sizeof(sin);
30010588:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3001058c:	e3a02010 	mov	r2, #16
30010590:	e5832000 	str	r2, [r3]

    SMEMCPY(from, &sin, *fromlen);
30010594:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
30010598:	e5933000 	ldr	r3, [r3]
3001059c:	e28d2014 	add	r2, sp, #20
300105a0:	e59d0048 	ldr	r0, [sp, #72]	; 0x48
300105a4:	e1a01002 	mov	r1, r2
300105a8:	e1a02003 	mov	r2, r3
300105ac:	ebfff266 	bl	3000cf4c <__re_memcpy>
    ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
300105b0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300105b4:	e3a02000 	mov	r2, #0
300105b8:	e5832010 	str	r2, [r3, #16]
  return off;
300105bc:	e1dd33b6 	ldrh	r3, [sp, #54]	; 0x36
}
300105c0:	e1a00003 	mov	r0, r3
300105c4:	e28dd044 	add	sp, sp, #68	; 0x44
300105c8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300105cc:	e12fff1e 	bx	lr
300105d0:	30026498 	.word	0x30026498

300105d4 <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
300105d4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300105d8:	e24dd01c 	sub	sp, sp, #28
300105dc:	e58d0014 	str	r0, [sp, #20]
300105e0:	e58d1010 	str	r1, [sp, #16]
300105e4:	e58d200c 	str	r2, [sp, #12]
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
300105e8:	e3a03000 	mov	r3, #0
300105ec:	e58d3000 	str	r3, [sp]
300105f0:	e3a03000 	mov	r3, #0
300105f4:	e58d3004 	str	r3, [sp, #4]
300105f8:	e59d0014 	ldr	r0, [sp, #20]
300105fc:	e59d1010 	ldr	r1, [sp, #16]
30010600:	e59d200c 	ldr	r2, [sp, #12]
30010604:	e3a03000 	mov	r3, #0
30010608:	ebfffede 	bl	30010188 <lwip_recvfrom>
3001060c:	e1a03000 	mov	r3, r0
}
30010610:	e1a00003 	mov	r0, r3
30010614:	e28dd01c 	add	sp, sp, #28
30010618:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001061c:	e12fff1e 	bx	lr

30010620 <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
30010620:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30010624:	e24dd01c 	sub	sp, sp, #28
30010628:	e58d0014 	str	r0, [sp, #20]
3001062c:	e58d1010 	str	r1, [sp, #16]
30010630:	e58d200c 	str	r2, [sp, #12]
30010634:	e58d3008 	str	r3, [sp, #8]
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
30010638:	e3a03000 	mov	r3, #0
3001063c:	e58d3000 	str	r3, [sp]
30010640:	e3a03000 	mov	r3, #0
30010644:	e58d3004 	str	r3, [sp, #4]
30010648:	e59d0014 	ldr	r0, [sp, #20]
3001064c:	e59d1010 	ldr	r1, [sp, #16]
30010650:	e59d200c 	ldr	r2, [sp, #12]
30010654:	e59d3008 	ldr	r3, [sp, #8]
30010658:	ebfffeca 	bl	30010188 <lwip_recvfrom>
3001065c:	e1a03000 	mov	r3, r0
}
30010660:	e1a00003 	mov	r0, r3
30010664:	e28dd01c 	add	sp, sp, #28
30010668:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001066c:	e12fff1e 	bx	lr

30010670 <lwip_send>:

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
30010670:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30010674:	e24dd024 	sub	sp, sp, #36	; 0x24
30010678:	e58d0014 	str	r0, [sp, #20]
3001067c:	e58d1010 	str	r1, [sp, #16]
30010680:	e58d200c 	str	r2, [sp, #12]
30010684:	e58d3008 	str	r3, [sp, #8]
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
30010688:	e59d0014 	ldr	r0, [sp, #20]
3001068c:	ebfffc91 	bl	3000f8d8 <get_socket>
30010690:	e1a03000 	mov	r3, r0
30010694:	e58d3018 	str	r3, [sp, #24]
  if (!sock)
30010698:	e59d3018 	ldr	r3, [sp, #24]
3001069c:	e3530000 	cmp	r3, #0
300106a0:	1a000001 	bne	300106ac <lwip_send+0x3c>
    return -1;
300106a4:	e3e03000 	mvn	r3, #0
300106a8:	ea000031 	b	30010774 <lwip_send+0x104>

  if (sock->conn->type!=NETCONN_TCP) {
300106ac:	e59d3018 	ldr	r3, [sp, #24]
300106b0:	e5933000 	ldr	r3, [r3]
300106b4:	e5d33000 	ldrb	r3, [r3]
300106b8:	e3530010 	cmp	r3, #16
300106bc:	0a00000a 	beq	300106ec <lwip_send+0x7c>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
300106c0:	e3a03000 	mov	r3, #0
300106c4:	e58d3000 	str	r3, [sp]
300106c8:	e3a03000 	mov	r3, #0
300106cc:	e58d3004 	str	r3, [sp, #4]
300106d0:	e59d0014 	ldr	r0, [sp, #20]
300106d4:	e59d1010 	ldr	r1, [sp, #16]
300106d8:	e59d200c 	ldr	r2, [sp, #12]
300106dc:	e59d3008 	ldr	r3, [sp, #8]
300106e0:	eb000028 	bl	30010788 <lwip_sendto>
300106e4:	e1a03000 	mov	r3, r0
300106e8:	ea000021 	b	30010774 <lwip_send+0x104>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
300106ec:	e59d3018 	ldr	r3, [sp, #24]
300106f0:	e5932000 	ldr	r2, [r3]
300106f4:	e59d3008 	ldr	r3, [sp, #8]
300106f8:	e2033010 	and	r3, r3, #16
300106fc:	e3530000 	cmp	r3, #0
30010700:	0a000001 	beq	3001070c <lwip_send+0x9c>
30010704:	e3a03003 	mov	r3, #3
30010708:	ea000000 	b	30010710 <lwip_send+0xa0>
3001070c:	e3a03001 	mov	r3, #1
30010710:	e1a00002 	mov	r0, r2
30010714:	e59d1010 	ldr	r1, [sp, #16]
30010718:	e59d200c 	ldr	r2, [sp, #12]
3001071c:	ebfff3f0 	bl	3000d6e4 <netconn_write>
30010720:	e1a03000 	mov	r3, r0
30010724:	e20330ff 	and	r3, r3, #255	; 0xff
30010728:	e5cd301f 	strb	r3, [sp, #31]

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
3001072c:	e1dd31df 	ldrsb	r3, [sp, #31]
30010730:	e2633000 	rsb	r3, r3, #0
30010734:	e353000e 	cmp	r3, #14
30010738:	8a000004 	bhi	30010750 <lwip_send+0xe0>
3001073c:	e1dd31df 	ldrsb	r3, [sp, #31]
30010740:	e2632000 	rsb	r2, r3, #0
30010744:	e59f3038 	ldr	r3, [pc, #56]	; 30010784 <lwip_send+0x114>
30010748:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3001074c:	ea000000 	b	30010754 <lwip_send+0xe4>
30010750:	e3a03005 	mov	r3, #5
30010754:	e59d2018 	ldr	r2, [sp, #24]
30010758:	e5823010 	str	r3, [r2, #16]
  return (err==ERR_OK?size:-1);
3001075c:	e1dd31df 	ldrsb	r3, [sp, #31]
30010760:	e3530000 	cmp	r3, #0
30010764:	1a000001 	bne	30010770 <lwip_send+0x100>
30010768:	e59d300c 	ldr	r3, [sp, #12]
3001076c:	ea000000 	b	30010774 <lwip_send+0x104>
30010770:	e3e03000 	mvn	r3, #0
}
30010774:	e1a00003 	mov	r0, r3
30010778:	e28dd024 	add	sp, sp, #36	; 0x24
3001077c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30010780:	e12fff1e 	bx	lr
30010784:	30026498 	.word	0x30026498

30010788 <lwip_sendto>:

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
30010788:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001078c:	e24dd034 	sub	sp, sp, #52	; 0x34
30010790:	e58d000c 	str	r0, [sp, #12]
30010794:	e58d1008 	str	r1, [sp, #8]
30010798:	e58d2004 	str	r2, [sp, #4]
3001079c:	e58d3000 	str	r3, [sp]
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
300107a0:	e59d000c 	ldr	r0, [sp, #12]
300107a4:	ebfffc4b 	bl	3000f8d8 <get_socket>
300107a8:	e1a03000 	mov	r3, r0
300107ac:	e58d3024 	str	r3, [sp, #36]	; 0x24
  if (!sock)
300107b0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300107b4:	e3530000 	cmp	r3, #0
300107b8:	1a000001 	bne	300107c4 <lwip_sendto+0x3c>
    return -1;
300107bc:	e3e03000 	mvn	r3, #0
300107c0:	ea00005b 	b	30010934 <lwip_sendto+0x1ac>

  if (sock->conn->type==NETCONN_TCP) {
300107c4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300107c8:	e5933000 	ldr	r3, [r3]
300107cc:	e5d33000 	ldrb	r3, [r3]
300107d0:	e3530010 	cmp	r3, #16
300107d4:	1a000006 	bne	300107f4 <lwip_sendto+0x6c>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
300107d8:	e59d000c 	ldr	r0, [sp, #12]
300107dc:	e59d1008 	ldr	r1, [sp, #8]
300107e0:	e59d2004 	ldr	r2, [sp, #4]
300107e4:	e59d3000 	ldr	r3, [sp]
300107e8:	ebffffa0 	bl	30010670 <lwip_send>
300107ec:	e1a03000 	mov	r3, r0
300107f0:	ea00004f 	b	30010934 <lwip_sendto+0x1ac>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
300107f4:	e3a03000 	mov	r3, #0
300107f8:	e58d3014 	str	r3, [sp, #20]
300107fc:	e59d3014 	ldr	r3, [sp, #20]
30010800:	e58d3010 	str	r3, [sp, #16]
  if (to) {
30010804:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30010808:	e3530000 	cmp	r3, #0
3001080c:	0a00000d 	beq	30010848 <lwip_sendto+0xc0>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
30010810:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30010814:	e5933004 	ldr	r3, [r3, #4]
30010818:	e58d3020 	str	r3, [sp, #32]
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
3001081c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30010820:	e1d330b2 	ldrh	r3, [r3, #2]
30010824:	e1a00003 	mov	r0, r3
30010828:	eb000c36 	bl	30013908 <ntohs>
3001082c:	e1a03000 	mov	r3, r0
30010830:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
    buf.addr         = &remote_addr;
30010834:	e28d3020 	add	r3, sp, #32
30010838:	e58d3018 	str	r3, [sp, #24]
    buf.port         = remote_port;
3001083c:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
30010840:	e1cd31bc 	strh	r3, [sp, #28]
30010844:	ea000007 	b	30010868 <lwip_sendto+0xe0>
  } else {
    remote_addr.addr = 0;
30010848:	e3a03000 	mov	r3, #0
3001084c:	e58d3020 	str	r3, [sp, #32]
    remote_port      = 0;
30010850:	e3a03000 	mov	r3, #0
30010854:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
    buf.addr         = NULL;
30010858:	e3a03000 	mov	r3, #0
3001085c:	e58d3018 	str	r3, [sp, #24]
    buf.port         = 0;
30010860:	e3a03000 	mov	r3, #0
30010864:	e1cd31bc 	strh	r3, [sp, #28]
              s, data, size, flags));
  ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
30010868:	e59d3004 	ldr	r3, [sp, #4]
3001086c:	e1a03803 	lsl	r3, r3, #16
30010870:	e1a03823 	lsr	r3, r3, #16
30010874:	e28d2010 	add	r2, sp, #16
30010878:	e1a00002 	mov	r0, r2
3001087c:	e59d1008 	ldr	r1, [sp, #8]
30010880:	e1a02003 	mov	r2, r3
30010884:	ebfffb7d 	bl	3000f680 <netbuf_ref>
30010888:	e1a03000 	mov	r3, r0
3001088c:	e20330ff 	and	r3, r3, #255	; 0xff
30010890:	e1a03c03 	lsl	r3, r3, #24
30010894:	e1a03c43 	asr	r3, r3, #24
30010898:	e58d3028 	str	r3, [sp, #40]	; 0x28
3001089c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300108a0:	e3530000 	cmp	r3, #0
300108a4:	1a00000a 	bne	300108d4 <lwip_sendto+0x14c>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
300108a8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300108ac:	e5932000 	ldr	r2, [r3]
300108b0:	e28d3010 	add	r3, sp, #16
300108b4:	e1a00002 	mov	r0, r2
300108b8:	e1a01003 	mov	r1, r3
300108bc:	ebfff372 	bl	3000d68c <netconn_send>
300108c0:	e1a03000 	mov	r3, r0
300108c4:	e20330ff 	and	r3, r3, #255	; 0xff
300108c8:	e1a03c03 	lsl	r3, r3, #24
300108cc:	e1a03c43 	asr	r3, r3, #24
300108d0:	e58d3028 	str	r3, [sp, #40]	; 0x28
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
300108d4:	e59d3010 	ldr	r3, [sp, #16]
300108d8:	e3530000 	cmp	r3, #0
300108dc:	0a000002 	beq	300108ec <lwip_sendto+0x164>
    pbuf_free(buf.p);
300108e0:	e59d3010 	ldr	r3, [sp, #16]
300108e4:	e1a00003 	mov	r0, r3
300108e8:	eb001710 	bl	30016530 <pbuf_free>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
300108ec:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300108f0:	e2633000 	rsb	r3, r3, #0
300108f4:	e353000e 	cmp	r3, #14
300108f8:	8a000004 	bhi	30010910 <lwip_sendto+0x188>
300108fc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010900:	e2632000 	rsb	r2, r3, #0
30010904:	e59f3038 	ldr	r3, [pc, #56]	; 30010944 <lwip_sendto+0x1bc>
30010908:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3001090c:	ea000000 	b	30010914 <lwip_sendto+0x18c>
30010910:	e3a03005 	mov	r3, #5
30010914:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30010918:	e5823010 	str	r3, [r2, #16]
  return (err==ERR_OK?size:-1);
3001091c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010920:	e3530000 	cmp	r3, #0
30010924:	1a000001 	bne	30010930 <lwip_sendto+0x1a8>
30010928:	e59d3004 	ldr	r3, [sp, #4]
3001092c:	ea000000 	b	30010934 <lwip_sendto+0x1ac>
30010930:	e3e03000 	mvn	r3, #0
}
30010934:	e1a00003 	mov	r0, r3
30010938:	e28dd034 	add	sp, sp, #52	; 0x34
3001093c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30010940:	e12fff1e 	bx	lr
30010944:	30026498 	.word	0x30026498

30010948 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
30010948:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001094c:	e24dd01c 	sub	sp, sp, #28
30010950:	e58d000c 	str	r0, [sp, #12]
30010954:	e58d1008 	str	r1, [sp, #8]
30010958:	e58d2004 	str	r2, [sp, #4]
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
3001095c:	e59d3008 	ldr	r3, [sp, #8]
30010960:	e3530002 	cmp	r3, #2
30010964:	0a00000d 	beq	300109a0 <lwip_socket+0x58>
30010968:	e3530003 	cmp	r3, #3
3001096c:	0a000002 	beq	3001097c <lwip_socket+0x34>
30010970:	e3530001 	cmp	r3, #1
30010974:	0a000016 	beq	300109d4 <lwip_socket+0x8c>
30010978:	ea00001c 	b	300109f0 <lwip_socket+0xa8>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
3001097c:	e59d3004 	ldr	r3, [sp, #4]
30010980:	e20330ff 	and	r3, r3, #255	; 0xff
30010984:	e3a00040 	mov	r0, #64	; 0x40
30010988:	e1a01003 	mov	r1, r3
3001098c:	e59f20c4 	ldr	r2, [pc, #196]	; 30010a58 <lwip_socket+0x110>
30010990:	ebfff18a 	bl	3000cfc0 <netconn_new_with_proto_and_callback>
30010994:	e1a03000 	mov	r3, r0
30010998:	e58d3010 	str	r3, [sp, #16]
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
3001099c:	ea000015 	b	300109f8 <lwip_socket+0xb0>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
300109a0:	e59d3004 	ldr	r3, [sp, #4]
300109a4:	e3530088 	cmp	r3, #136	; 0x88
300109a8:	1a000001 	bne	300109b4 <lwip_socket+0x6c>
300109ac:	e3a03021 	mov	r3, #33	; 0x21
300109b0:	ea000000 	b	300109b8 <lwip_socket+0x70>
300109b4:	e3a03020 	mov	r3, #32
300109b8:	e1a00003 	mov	r0, r3
300109bc:	e3a01000 	mov	r1, #0
300109c0:	e59f2090 	ldr	r2, [pc, #144]	; 30010a58 <lwip_socket+0x110>
300109c4:	ebfff17d 	bl	3000cfc0 <netconn_new_with_proto_and_callback>
300109c8:	e1a03000 	mov	r3, r0
300109cc:	e58d3010 	str	r3, [sp, #16]
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
300109d0:	ea000008 	b	300109f8 <lwip_socket+0xb0>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
300109d4:	e3a00010 	mov	r0, #16
300109d8:	e3a01000 	mov	r1, #0
300109dc:	e59f2074 	ldr	r2, [pc, #116]	; 30010a58 <lwip_socket+0x110>
300109e0:	ebfff176 	bl	3000cfc0 <netconn_new_with_proto_and_callback>
300109e4:	e1a03000 	mov	r3, r0
300109e8:	e58d3010 	str	r3, [sp, #16]
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
300109ec:	ea000001 	b	300109f8 <lwip_socket+0xb0>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
    return -1;
300109f0:	e3e03000 	mvn	r3, #0
300109f4:	ea000013 	b	30010a48 <lwip_socket+0x100>
  }

  if (!conn) {
300109f8:	e59d3010 	ldr	r3, [sp, #16]
300109fc:	e3530000 	cmp	r3, #0
30010a00:	1a000001 	bne	30010a0c <lwip_socket+0xc4>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
    return -1;
30010a04:	e3e03000 	mvn	r3, #0
30010a08:	ea00000e 	b	30010a48 <lwip_socket+0x100>
  }

  i = alloc_socket(conn);
30010a0c:	e59d0010 	ldr	r0, [sp, #16]
30010a10:	ebfffbce 	bl	3000f950 <alloc_socket>
30010a14:	e1a03000 	mov	r3, r0
30010a18:	e58d3014 	str	r3, [sp, #20]

  if (i == -1) {
30010a1c:	e59d3014 	ldr	r3, [sp, #20]
30010a20:	e3730001 	cmn	r3, #1
30010a24:	1a000003 	bne	30010a38 <lwip_socket+0xf0>
    netconn_delete(conn);
30010a28:	e59d0010 	ldr	r0, [sp, #16]
30010a2c:	ebfff193 	bl	3000d080 <netconn_delete>
    set_errno(ENFILE);
    return -1;
30010a30:	e3e03000 	mvn	r3, #0
30010a34:	ea000003 	b	30010a48 <lwip_socket+0x100>
  }
  conn->socket = i;
30010a38:	e59d3010 	ldr	r3, [sp, #16]
30010a3c:	e59d2014 	ldr	r2, [sp, #20]
30010a40:	e5832018 	str	r2, [r3, #24]
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  return i;
30010a44:	e59d3014 	ldr	r3, [sp, #20]
}
30010a48:	e1a00003 	mov	r0, r3
30010a4c:	e28dd01c 	add	sp, sp, #28
30010a50:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30010a54:	e12fff1e 	bx	lr
30010a58:	300111b4 	.word	0x300111b4

30010a5c <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
30010a5c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30010a60:	e24dd014 	sub	sp, sp, #20
30010a64:	e58d000c 	str	r0, [sp, #12]
30010a68:	e58d1008 	str	r1, [sp, #8]
30010a6c:	e58d2004 	str	r2, [sp, #4]
  return lwip_send(s, data, size, 0);
30010a70:	e59d000c 	ldr	r0, [sp, #12]
30010a74:	e59d1008 	ldr	r1, [sp, #8]
30010a78:	e59d2004 	ldr	r2, [sp, #4]
30010a7c:	e3a03000 	mov	r3, #0
30010a80:	ebfffefa 	bl	30010670 <lwip_send>
30010a84:	e1a03000 	mov	r3, r0
}
30010a88:	e1a00003 	mov	r0, r3
30010a8c:	e28dd014 	add	sp, sp, #20
30010a90:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30010a94:	e12fff1e 	bx	lr

30010a98 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
30010a98:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30010a9c:	e24dd02c 	sub	sp, sp, #44	; 0x2c
30010aa0:	e58d000c 	str	r0, [sp, #12]
30010aa4:	e58d1008 	str	r1, [sp, #8]
30010aa8:	e58d2004 	str	r2, [sp, #4]
30010aac:	e58d3000 	str	r3, [sp]
  int i, nready = 0;
30010ab0:	e3a03000 	mov	r3, #0
30010ab4:	e58d3020 	str	r3, [sp, #32]
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
30010ab8:	e28d3018 	add	r3, sp, #24
30010abc:	e1a00003 	mov	r0, r3
30010ac0:	e3a01000 	mov	r1, #0
30010ac4:	e3a02001 	mov	r2, #1
30010ac8:	ebfff105 	bl	3000cee4 <__re_memset>
  FD_ZERO(&lwriteset);
30010acc:	e28d3014 	add	r3, sp, #20
30010ad0:	e1a00003 	mov	r0, r3
30010ad4:	e3a01000 	mov	r1, #0
30010ad8:	e3a02001 	mov	r2, #1
30010adc:	ebfff100 	bl	3000cee4 <__re_memset>
  FD_ZERO(&lexceptset);
30010ae0:	e28d3010 	add	r3, sp, #16
30010ae4:	e1a00003 	mov	r0, r3
30010ae8:	e3a01000 	mov	r1, #0
30010aec:	e3a02001 	mov	r2, #1
30010af0:	ebfff0fb 	bl	3000cee4 <__re_memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
30010af4:	e3a03000 	mov	r3, #0
30010af8:	e58d301c 	str	r3, [sp, #28]
30010afc:	ea000074 	b	30010cd4 <lwip_selscan+0x23c>
    if (FD_ISSET(i, readset)) {
30010b00:	e59d301c 	ldr	r3, [sp, #28]
30010b04:	e2832007 	add	r2, r3, #7
30010b08:	e3530000 	cmp	r3, #0
30010b0c:	b1a03002 	movlt	r3, r2
30010b10:	e1a031c3 	asr	r3, r3, #3
30010b14:	e59d2008 	ldr	r2, [sp, #8]
30010b18:	e7d23003 	ldrb	r3, [r2, r3]
30010b1c:	e1a02003 	mov	r2, r3
30010b20:	e59d301c 	ldr	r3, [sp, #28]
30010b24:	e2033007 	and	r3, r3, #7
30010b28:	e1a03352 	asr	r3, r2, r3
30010b2c:	e2033001 	and	r3, r3, #1
30010b30:	e20330ff 	and	r3, r3, #255	; 0xff
30010b34:	e3530000 	cmp	r3, #0
30010b38:	0a00002b 	beq	30010bec <lwip_selscan+0x154>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
30010b3c:	e59d001c 	ldr	r0, [sp, #28]
30010b40:	ebfffb64 	bl	3000f8d8 <get_socket>
30010b44:	e1a03000 	mov	r3, r0
30010b48:	e58d3024 	str	r3, [sp, #36]	; 0x24
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
30010b4c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30010b50:	e3530000 	cmp	r3, #0
30010b54:	0a000024 	beq	30010bec <lwip_selscan+0x154>
30010b58:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30010b5c:	e5933004 	ldr	r3, [r3, #4]
30010b60:	e3530000 	cmp	r3, #0
30010b64:	1a000003 	bne	30010b78 <lwip_selscan+0xe0>
30010b68:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30010b6c:	e1d330ba 	ldrh	r3, [r3, #10]
30010b70:	e3530000 	cmp	r3, #0
30010b74:	0a00001c 	beq	30010bec <lwip_selscan+0x154>
        FD_SET(i, &lreadset);
30010b78:	e59d301c 	ldr	r3, [sp, #28]
30010b7c:	e2832007 	add	r2, r3, #7
30010b80:	e3530000 	cmp	r3, #0
30010b84:	b1a03002 	movlt	r3, r2
30010b88:	e1a031c3 	asr	r3, r3, #3
30010b8c:	e1a01003 	mov	r1, r3
30010b90:	e1a02003 	mov	r2, r3
30010b94:	e3e0300f 	mvn	r3, #15
30010b98:	e28d0028 	add	r0, sp, #40	; 0x28
30010b9c:	e0802002 	add	r2, r0, r2
30010ba0:	e0823003 	add	r3, r2, r3
30010ba4:	e5d33000 	ldrb	r3, [r3]
30010ba8:	e1a02003 	mov	r2, r3
30010bac:	e59d301c 	ldr	r3, [sp, #28]
30010bb0:	e2033007 	and	r3, r3, #7
30010bb4:	e3a00001 	mov	r0, #1
30010bb8:	e1a03310 	lsl	r3, r0, r3
30010bbc:	e20330ff 	and	r3, r3, #255	; 0xff
30010bc0:	e1823003 	orr	r3, r2, r3
30010bc4:	e20330ff 	and	r3, r3, #255	; 0xff
30010bc8:	e20320ff 	and	r2, r3, #255	; 0xff
30010bcc:	e3e0300f 	mvn	r3, #15
30010bd0:	e28d0028 	add	r0, sp, #40	; 0x28
30010bd4:	e0801001 	add	r1, r0, r1
30010bd8:	e0813003 	add	r3, r1, r3
30010bdc:	e5c32000 	strb	r2, [r3]
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
30010be0:	e59d3020 	ldr	r3, [sp, #32]
30010be4:	e2833001 	add	r3, r3, #1
30010be8:	e58d3020 	str	r3, [sp, #32]
      }
    }
    if (FD_ISSET(i, writeset)) {
30010bec:	e59d301c 	ldr	r3, [sp, #28]
30010bf0:	e2832007 	add	r2, r3, #7
30010bf4:	e3530000 	cmp	r3, #0
30010bf8:	b1a03002 	movlt	r3, r2
30010bfc:	e1a031c3 	asr	r3, r3, #3
30010c00:	e59d2004 	ldr	r2, [sp, #4]
30010c04:	e7d23003 	ldrb	r3, [r2, r3]
30010c08:	e1a02003 	mov	r2, r3
30010c0c:	e59d301c 	ldr	r3, [sp, #28]
30010c10:	e2033007 	and	r3, r3, #7
30010c14:	e1a03352 	asr	r3, r2, r3
30010c18:	e2033001 	and	r3, r3, #1
30010c1c:	e20330ff 	and	r3, r3, #255	; 0xff
30010c20:	e3530000 	cmp	r3, #0
30010c24:	0a000027 	beq	30010cc8 <lwip_selscan+0x230>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
30010c28:	e59d001c 	ldr	r0, [sp, #28]
30010c2c:	ebfffb29 	bl	3000f8d8 <get_socket>
30010c30:	e1a03000 	mov	r3, r0
30010c34:	e58d3024 	str	r3, [sp, #36]	; 0x24
      if (p_sock && p_sock->sendevent) {
30010c38:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30010c3c:	e3530000 	cmp	r3, #0
30010c40:	0a000020 	beq	30010cc8 <lwip_selscan+0x230>
30010c44:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30010c48:	e1d330bc 	ldrh	r3, [r3, #12]
30010c4c:	e3530000 	cmp	r3, #0
30010c50:	0a00001c 	beq	30010cc8 <lwip_selscan+0x230>
        FD_SET(i, &lwriteset);
30010c54:	e59d301c 	ldr	r3, [sp, #28]
30010c58:	e2832007 	add	r2, r3, #7
30010c5c:	e3530000 	cmp	r3, #0
30010c60:	b1a03002 	movlt	r3, r2
30010c64:	e1a031c3 	asr	r3, r3, #3
30010c68:	e1a01003 	mov	r1, r3
30010c6c:	e1a02003 	mov	r2, r3
30010c70:	e3e03013 	mvn	r3, #19
30010c74:	e28d0028 	add	r0, sp, #40	; 0x28
30010c78:	e0802002 	add	r2, r0, r2
30010c7c:	e0823003 	add	r3, r2, r3
30010c80:	e5d33000 	ldrb	r3, [r3]
30010c84:	e1a02003 	mov	r2, r3
30010c88:	e59d301c 	ldr	r3, [sp, #28]
30010c8c:	e2033007 	and	r3, r3, #7
30010c90:	e3a00001 	mov	r0, #1
30010c94:	e1a03310 	lsl	r3, r0, r3
30010c98:	e20330ff 	and	r3, r3, #255	; 0xff
30010c9c:	e1823003 	orr	r3, r2, r3
30010ca0:	e20330ff 	and	r3, r3, #255	; 0xff
30010ca4:	e20320ff 	and	r2, r3, #255	; 0xff
30010ca8:	e3e03013 	mvn	r3, #19
30010cac:	e28d0028 	add	r0, sp, #40	; 0x28
30010cb0:	e0801001 	add	r1, r0, r1
30010cb4:	e0813003 	add	r3, r1, r3
30010cb8:	e5c32000 	strb	r2, [r3]
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
30010cbc:	e59d3020 	ldr	r3, [sp, #32]
30010cc0:	e2833001 	add	r3, r3, #1
30010cc4:	e58d3020 	str	r3, [sp, #32]
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
30010cc8:	e59d301c 	ldr	r3, [sp, #28]
30010ccc:	e2833001 	add	r3, r3, #1
30010cd0:	e58d301c 	str	r3, [sp, #28]
30010cd4:	e59d201c 	ldr	r2, [sp, #28]
30010cd8:	e59d300c 	ldr	r3, [sp, #12]
30010cdc:	e1520003 	cmp	r2, r3
30010ce0:	baffff86 	blt	30010b00 <lwip_selscan+0x68>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
30010ce4:	e59d3008 	ldr	r3, [sp, #8]
30010ce8:	e5dd2018 	ldrb	r2, [sp, #24]
30010cec:	e5c32000 	strb	r2, [r3]
  *writeset = lwriteset;
30010cf0:	e59d3004 	ldr	r3, [sp, #4]
30010cf4:	e5dd2014 	ldrb	r2, [sp, #20]
30010cf8:	e5c32000 	strb	r2, [r3]
  FD_ZERO(exceptset);
30010cfc:	e59d0000 	ldr	r0, [sp]
30010d00:	e3a01000 	mov	r1, #0
30010d04:	e3a02001 	mov	r2, #1
30010d08:	ebfff075 	bl	3000cee4 <__re_memset>
  
  return nready;
30010d0c:	e59d3020 	ldr	r3, [sp, #32]
}
30010d10:	e1a00003 	mov	r0, r3
30010d14:	e28dd02c 	add	sp, sp, #44	; 0x2c
30010d18:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30010d1c:	e12fff1e 	bx	lr

30010d20 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
30010d20:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30010d24:	e24dd04c 	sub	sp, sp, #76	; 0x4c
30010d28:	e58d000c 	str	r0, [sp, #12]
30010d2c:	e58d1008 	str	r1, [sp, #8]
30010d30:	e58d2004 	str	r2, [sp, #4]
30010d34:	e58d3000 	str	r3, [sp]

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
30010d38:	e3a03000 	mov	r3, #0
30010d3c:	e58d3014 	str	r3, [sp, #20]
  select_cb.readset = readset;
30010d40:	e59d3008 	ldr	r3, [sp, #8]
30010d44:	e58d3018 	str	r3, [sp, #24]
  select_cb.writeset = writeset;
30010d48:	e59d3004 	ldr	r3, [sp, #4]
30010d4c:	e58d301c 	str	r3, [sp, #28]
  select_cb.exceptset = exceptset;
30010d50:	e59d3000 	ldr	r3, [sp]
30010d54:	e58d3020 	str	r3, [sp, #32]
  select_cb.sem_signalled = 0;
30010d58:	e3a03000 	mov	r3, #0
30010d5c:	e58d3024 	str	r3, [sp, #36]	; 0x24

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
30010d60:	e59f3440 	ldr	r3, [pc, #1088]	; 300111a8 <lwip_select+0x488>
30010d64:	e5933000 	ldr	r3, [r3]
30010d68:	e1a00003 	mov	r0, r3
30010d6c:	eb001911 	bl	300171b8 <sys_sem_wait>

  if (readset)
30010d70:	e59d3008 	ldr	r3, [sp, #8]
30010d74:	e3530000 	cmp	r3, #0
30010d78:	0a000003 	beq	30010d8c <lwip_select+0x6c>
    lreadset = *readset;
30010d7c:	e59d3008 	ldr	r3, [sp, #8]
30010d80:	e5d33000 	ldrb	r3, [r3]
30010d84:	e5cd3034 	strb	r3, [sp, #52]	; 0x34
30010d88:	ea000004 	b	30010da0 <lwip_select+0x80>
  else
    FD_ZERO(&lreadset);
30010d8c:	e28d3034 	add	r3, sp, #52	; 0x34
30010d90:	e1a00003 	mov	r0, r3
30010d94:	e3a01000 	mov	r1, #0
30010d98:	e3a02001 	mov	r2, #1
30010d9c:	ebfff050 	bl	3000cee4 <__re_memset>
  if (writeset)
30010da0:	e59d3004 	ldr	r3, [sp, #4]
30010da4:	e3530000 	cmp	r3, #0
30010da8:	0a000003 	beq	30010dbc <lwip_select+0x9c>
    lwriteset = *writeset;
30010dac:	e59d3004 	ldr	r3, [sp, #4]
30010db0:	e5d33000 	ldrb	r3, [r3]
30010db4:	e5cd3030 	strb	r3, [sp, #48]	; 0x30
30010db8:	ea000004 	b	30010dd0 <lwip_select+0xb0>
  else
    FD_ZERO(&lwriteset);
30010dbc:	e28d3030 	add	r3, sp, #48	; 0x30
30010dc0:	e1a00003 	mov	r0, r3
30010dc4:	e3a01000 	mov	r1, #0
30010dc8:	e3a02001 	mov	r2, #1
30010dcc:	ebfff044 	bl	3000cee4 <__re_memset>
  if (exceptset)
30010dd0:	e59d3000 	ldr	r3, [sp]
30010dd4:	e3530000 	cmp	r3, #0
30010dd8:	0a000003 	beq	30010dec <lwip_select+0xcc>
    lexceptset = *exceptset;
30010ddc:	e59d3000 	ldr	r3, [sp]
30010de0:	e5d33000 	ldrb	r3, [r3]
30010de4:	e5cd302c 	strb	r3, [sp, #44]	; 0x2c
30010de8:	ea000004 	b	30010e00 <lwip_select+0xe0>
  else
    FD_ZERO(&lexceptset);
30010dec:	e28d302c 	add	r3, sp, #44	; 0x2c
30010df0:	e1a00003 	mov	r0, r3
30010df4:	e3a01000 	mov	r1, #0
30010df8:	e3a02001 	mov	r2, #1
30010dfc:	ebfff038 	bl	3000cee4 <__re_memset>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
30010e00:	e28d1034 	add	r1, sp, #52	; 0x34
30010e04:	e28d2030 	add	r2, sp, #48	; 0x30
30010e08:	e28d302c 	add	r3, sp, #44	; 0x2c
30010e0c:	e59d000c 	ldr	r0, [sp, #12]
30010e10:	ebffff20 	bl	30010a98 <lwip_selscan>
30010e14:	e1a03000 	mov	r3, r0
30010e18:	e58d303c 	str	r3, [sp, #60]	; 0x3c

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
30010e1c:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30010e20:	e3530000 	cmp	r3, #0
30010e24:	1a0000c4 	bne	3001113c <lwip_select+0x41c>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
30010e28:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
30010e2c:	e3530000 	cmp	r3, #0
30010e30:	0a000022 	beq	30010ec0 <lwip_select+0x1a0>
30010e34:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
30010e38:	e5933000 	ldr	r3, [r3]
30010e3c:	e3530000 	cmp	r3, #0
30010e40:	1a00001e 	bne	30010ec0 <lwip_select+0x1a0>
30010e44:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
30010e48:	e5933004 	ldr	r3, [r3, #4]
30010e4c:	e3530000 	cmp	r3, #0
30010e50:	1a00001a 	bne	30010ec0 <lwip_select+0x1a0>
      sys_sem_signal(selectsem);
30010e54:	e59f334c 	ldr	r3, [pc, #844]	; 300111a8 <lwip_select+0x488>
30010e58:	e5933000 	ldr	r3, [r3]
30010e5c:	e1a00003 	mov	r0, r3
30010e60:	ebffef2c 	bl	3000cb18 <sys_sem_signal>
      if (readset)
30010e64:	e59d3008 	ldr	r3, [sp, #8]
30010e68:	e3530000 	cmp	r3, #0
30010e6c:	0a000003 	beq	30010e80 <lwip_select+0x160>
        FD_ZERO(readset);
30010e70:	e59d0008 	ldr	r0, [sp, #8]
30010e74:	e3a01000 	mov	r1, #0
30010e78:	e3a02001 	mov	r2, #1
30010e7c:	ebfff018 	bl	3000cee4 <__re_memset>
      if (writeset)
30010e80:	e59d3004 	ldr	r3, [sp, #4]
30010e84:	e3530000 	cmp	r3, #0
30010e88:	0a000003 	beq	30010e9c <lwip_select+0x17c>
        FD_ZERO(writeset);
30010e8c:	e59d0004 	ldr	r0, [sp, #4]
30010e90:	e3a01000 	mov	r1, #0
30010e94:	e3a02001 	mov	r2, #1
30010e98:	ebfff011 	bl	3000cee4 <__re_memset>
      if (exceptset)
30010e9c:	e59d3000 	ldr	r3, [sp]
30010ea0:	e3530000 	cmp	r3, #0
30010ea4:	0a000003 	beq	30010eb8 <lwip_select+0x198>
        FD_ZERO(exceptset);
30010ea8:	e59d0000 	ldr	r0, [sp]
30010eac:	e3a01000 	mov	r1, #0
30010eb0:	e3a02001 	mov	r2, #1
30010eb4:	ebfff00a 	bl	3000cee4 <__re_memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  
      return 0;
30010eb8:	e3a03000 	mov	r3, #0
30010ebc:	ea0000b5 	b	30011198 <lwip_select+0x478>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
30010ec0:	e3a00000 	mov	r0, #0
30010ec4:	ebffeefe 	bl	3000cac4 <sys_sem_new>
30010ec8:	e1a03000 	mov	r3, r0
30010ecc:	e58d3028 	str	r3, [sp, #40]	; 0x28
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
30010ed0:	e59f32d4 	ldr	r3, [pc, #724]	; 300111ac <lwip_select+0x48c>
30010ed4:	e5933000 	ldr	r3, [r3]
30010ed8:	e58d3014 	str	r3, [sp, #20]
    select_cb_list = &select_cb;
30010edc:	e59f32c8 	ldr	r3, [pc, #712]	; 300111ac <lwip_select+0x48c>
30010ee0:	e28d2014 	add	r2, sp, #20
30010ee4:	e5832000 	str	r2, [r3]
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
30010ee8:	e59f32b8 	ldr	r3, [pc, #696]	; 300111a8 <lwip_select+0x488>
30010eec:	e5933000 	ldr	r3, [r3]
30010ef0:	e1a00003 	mov	r0, r3
30010ef4:	ebffef07 	bl	3000cb18 <sys_sem_signal>
    
    /* Now just wait to be woken */
    if (timeout == 0)
30010ef8:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
30010efc:	e3530000 	cmp	r3, #0
30010f00:	1a000002 	bne	30010f10 <lwip_select+0x1f0>
      /* Wait forever */
      msectimeout = 0;
30010f04:	e3a03000 	mov	r3, #0
30010f08:	e58d3040 	str	r3, [sp, #64]	; 0x40
30010f0c:	ea000017 	b	30010f70 <lwip_select+0x250>
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
30010f10:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
30010f14:	e5932000 	ldr	r2, [r3]
30010f18:	e1a03002 	mov	r3, r2
30010f1c:	e1a03283 	lsl	r3, r3, #5
30010f20:	e0623003 	rsb	r3, r2, r3
30010f24:	e1a03103 	lsl	r3, r3, #2
30010f28:	e0833002 	add	r3, r3, r2
30010f2c:	e1a03183 	lsl	r3, r3, #3
30010f30:	e1a02003 	mov	r2, r3
30010f34:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
30010f38:	e5933004 	ldr	r3, [r3, #4]
30010f3c:	e2833f7d 	add	r3, r3, #500	; 0x1f4
30010f40:	e59f1268 	ldr	r1, [pc, #616]	; 300111b0 <lwip_select+0x490>
30010f44:	e0c10193 	smull	r0, r1, r3, r1
30010f48:	e1a01341 	asr	r1, r1, #6
30010f4c:	e1a03fc3 	asr	r3, r3, #31
30010f50:	e0633001 	rsb	r3, r3, r1
30010f54:	e0823003 	add	r3, r2, r3
30010f58:	e58d3040 	str	r3, [sp, #64]	; 0x40
      if(msectimeout == 0)
30010f5c:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
30010f60:	e3530000 	cmp	r3, #0
30010f64:	1a000001 	bne	30010f70 <lwip_select+0x250>
        msectimeout = 1;
30010f68:	e3a03001 	mov	r3, #1
30010f6c:	e58d3040 	str	r3, [sp, #64]	; 0x40
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
30010f70:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010f74:	e1a00003 	mov	r0, r3
30010f78:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
30010f7c:	eb0019af 	bl	30017640 <sys_sem_wait_timeout>
30010f80:	e1a03000 	mov	r3, r0
30010f84:	e58d3038 	str	r3, [sp, #56]	; 0x38
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
30010f88:	e59f3218 	ldr	r3, [pc, #536]	; 300111a8 <lwip_select+0x488>
30010f8c:	e5933000 	ldr	r3, [r3]
30010f90:	e1a00003 	mov	r0, r3
30010f94:	eb001887 	bl	300171b8 <sys_sem_wait>
    if (select_cb_list == &select_cb)
30010f98:	e59f320c 	ldr	r3, [pc, #524]	; 300111ac <lwip_select+0x48c>
30010f9c:	e5933000 	ldr	r3, [r3]
30010fa0:	e28d2014 	add	r2, sp, #20
30010fa4:	e1520003 	cmp	r2, r3
30010fa8:	1a000003 	bne	30010fbc <lwip_select+0x29c>
      select_cb_list = select_cb.next;
30010fac:	e59d2014 	ldr	r2, [sp, #20]
30010fb0:	e59f31f4 	ldr	r3, [pc, #500]	; 300111ac <lwip_select+0x48c>
30010fb4:	e5832000 	str	r2, [r3]
30010fb8:	ea000012 	b	30011008 <lwip_select+0x2e8>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
30010fbc:	e59f31e8 	ldr	r3, [pc, #488]	; 300111ac <lwip_select+0x48c>
30010fc0:	e5933000 	ldr	r3, [r3]
30010fc4:	e58d3044 	str	r3, [sp, #68]	; 0x44
30010fc8:	ea00000b 	b	30010ffc <lwip_select+0x2dc>
        if (p_selcb->next == &select_cb) {
30010fcc:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30010fd0:	e5933000 	ldr	r3, [r3]
30010fd4:	e28d2014 	add	r2, sp, #20
30010fd8:	e1520003 	cmp	r2, r3
30010fdc:	1a000003 	bne	30010ff0 <lwip_select+0x2d0>
          p_selcb->next = select_cb.next;
30010fe0:	e59d2014 	ldr	r2, [sp, #20]
30010fe4:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30010fe8:	e5832000 	str	r2, [r3]
          break;
30010fec:	ea000005 	b	30011008 <lwip_select+0x2e8>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
30010ff0:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30010ff4:	e5933000 	ldr	r3, [r3]
30010ff8:	e58d3044 	str	r3, [sp, #68]	; 0x44
30010ffc:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30011000:	e3530000 	cmp	r3, #0
30011004:	1afffff0 	bne	30010fcc <lwip_select+0x2ac>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
30011008:	e59f3198 	ldr	r3, [pc, #408]	; 300111a8 <lwip_select+0x488>
3001100c:	e5933000 	ldr	r3, [r3]
30011010:	e1a00003 	mov	r0, r3
30011014:	ebffeebf 	bl	3000cb18 <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
30011018:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001101c:	e1a00003 	mov	r0, r3
30011020:	ebffeeb3 	bl	3000caf4 <sys_sem_free>
    if (i == 0)  {
30011024:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30011028:	e3530000 	cmp	r3, #0
3001102c:	1a000016 	bne	3001108c <lwip_select+0x36c>
      /* Timeout */
      if (readset)
30011030:	e59d3008 	ldr	r3, [sp, #8]
30011034:	e3530000 	cmp	r3, #0
30011038:	0a000003 	beq	3001104c <lwip_select+0x32c>
        FD_ZERO(readset);
3001103c:	e59d0008 	ldr	r0, [sp, #8]
30011040:	e3a01000 	mov	r1, #0
30011044:	e3a02001 	mov	r2, #1
30011048:	ebffefa5 	bl	3000cee4 <__re_memset>
      if (writeset)
3001104c:	e59d3004 	ldr	r3, [sp, #4]
30011050:	e3530000 	cmp	r3, #0
30011054:	0a000003 	beq	30011068 <lwip_select+0x348>
        FD_ZERO(writeset);
30011058:	e59d0004 	ldr	r0, [sp, #4]
3001105c:	e3a01000 	mov	r1, #0
30011060:	e3a02001 	mov	r2, #1
30011064:	ebffef9e 	bl	3000cee4 <__re_memset>
      if (exceptset)
30011068:	e59d3000 	ldr	r3, [sp]
3001106c:	e3530000 	cmp	r3, #0
30011070:	0a000003 	beq	30011084 <lwip_select+0x364>
        FD_ZERO(exceptset);
30011074:	e59d0000 	ldr	r0, [sp]
30011078:	e3a01000 	mov	r1, #0
3001107c:	e3a02001 	mov	r2, #1
30011080:	ebffef97 	bl	3000cee4 <__re_memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  
      return 0;
30011084:	e3a03000 	mov	r3, #0
30011088:	ea000042 	b	30011198 <lwip_select+0x478>
    }
    
    if (readset)
3001108c:	e59d3008 	ldr	r3, [sp, #8]
30011090:	e3530000 	cmp	r3, #0
30011094:	0a000003 	beq	300110a8 <lwip_select+0x388>
      lreadset = *readset;
30011098:	e59d3008 	ldr	r3, [sp, #8]
3001109c:	e5d33000 	ldrb	r3, [r3]
300110a0:	e5cd3034 	strb	r3, [sp, #52]	; 0x34
300110a4:	ea000004 	b	300110bc <lwip_select+0x39c>
    else
      FD_ZERO(&lreadset);
300110a8:	e28d3034 	add	r3, sp, #52	; 0x34
300110ac:	e1a00003 	mov	r0, r3
300110b0:	e3a01000 	mov	r1, #0
300110b4:	e3a02001 	mov	r2, #1
300110b8:	ebffef89 	bl	3000cee4 <__re_memset>
    if (writeset)
300110bc:	e59d3004 	ldr	r3, [sp, #4]
300110c0:	e3530000 	cmp	r3, #0
300110c4:	0a000003 	beq	300110d8 <lwip_select+0x3b8>
      lwriteset = *writeset;
300110c8:	e59d3004 	ldr	r3, [sp, #4]
300110cc:	e5d33000 	ldrb	r3, [r3]
300110d0:	e5cd3030 	strb	r3, [sp, #48]	; 0x30
300110d4:	ea000004 	b	300110ec <lwip_select+0x3cc>
    else
      FD_ZERO(&lwriteset);
300110d8:	e28d3030 	add	r3, sp, #48	; 0x30
300110dc:	e1a00003 	mov	r0, r3
300110e0:	e3a01000 	mov	r1, #0
300110e4:	e3a02001 	mov	r2, #1
300110e8:	ebffef7d 	bl	3000cee4 <__re_memset>
    if (exceptset)
300110ec:	e59d3000 	ldr	r3, [sp]
300110f0:	e3530000 	cmp	r3, #0
300110f4:	0a000003 	beq	30011108 <lwip_select+0x3e8>
      lexceptset = *exceptset;
300110f8:	e59d3000 	ldr	r3, [sp]
300110fc:	e5d33000 	ldrb	r3, [r3]
30011100:	e5cd302c 	strb	r3, [sp, #44]	; 0x2c
30011104:	ea000004 	b	3001111c <lwip_select+0x3fc>
    else
      FD_ZERO(&lexceptset);
30011108:	e28d302c 	add	r3, sp, #44	; 0x2c
3001110c:	e1a00003 	mov	r0, r3
30011110:	e3a01000 	mov	r1, #0
30011114:	e3a02001 	mov	r2, #1
30011118:	ebffef71 	bl	3000cee4 <__re_memset>
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
3001111c:	e28d1034 	add	r1, sp, #52	; 0x34
30011120:	e28d2030 	add	r2, sp, #48	; 0x30
30011124:	e28d302c 	add	r3, sp, #44	; 0x2c
30011128:	e59d000c 	ldr	r0, [sp, #12]
3001112c:	ebfffe59 	bl	30010a98 <lwip_selscan>
30011130:	e1a03000 	mov	r3, r0
30011134:	e58d303c 	str	r3, [sp, #60]	; 0x3c
30011138:	ea000003 	b	3001114c <lwip_select+0x42c>
  } else
    sys_sem_signal(selectsem);
3001113c:	e59f3064 	ldr	r3, [pc, #100]	; 300111a8 <lwip_select+0x488>
30011140:	e5933000 	ldr	r3, [r3]
30011144:	e1a00003 	mov	r0, r3
30011148:	ebffee72 	bl	3000cb18 <sys_sem_signal>
  
  if (readset)
3001114c:	e59d3008 	ldr	r3, [sp, #8]
30011150:	e3530000 	cmp	r3, #0
30011154:	0a000002 	beq	30011164 <lwip_select+0x444>
    *readset = lreadset;
30011158:	e59d3008 	ldr	r3, [sp, #8]
3001115c:	e5dd2034 	ldrb	r2, [sp, #52]	; 0x34
30011160:	e5c32000 	strb	r2, [r3]
  if (writeset)
30011164:	e59d3004 	ldr	r3, [sp, #4]
30011168:	e3530000 	cmp	r3, #0
3001116c:	0a000002 	beq	3001117c <lwip_select+0x45c>
    *writeset = lwriteset;
30011170:	e59d3004 	ldr	r3, [sp, #4]
30011174:	e5dd2030 	ldrb	r2, [sp, #48]	; 0x30
30011178:	e5c32000 	strb	r2, [r3]
  if (exceptset)
3001117c:	e59d3000 	ldr	r3, [sp]
30011180:	e3530000 	cmp	r3, #0
30011184:	0a000002 	beq	30011194 <lwip_select+0x474>
    *exceptset = lexceptset;
30011188:	e59d3000 	ldr	r3, [sp]
3001118c:	e5dd202c 	ldrb	r2, [sp, #44]	; 0x2c
30011190:	e5c32000 	strb	r2, [r3]
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  
  return nready;
30011194:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
}
30011198:	e1a00003 	mov	r0, r3
3001119c:	e28dd04c 	add	sp, sp, #76	; 0x4c
300111a0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300111a4:	e12fff1e 	bx	lr
300111a8:	30027200 	.word	0x30027200
300111ac:	300271f8 	.word	0x300271f8
300111b0:	10624dd3 	.word	0x10624dd3

300111b4 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
300111b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300111b8:	e24dd01c 	sub	sp, sp, #28
300111bc:	e58d0004 	str	r0, [sp, #4]
300111c0:	e1a03002 	mov	r3, r2
300111c4:	e1a02001 	mov	r2, r1
300111c8:	e5cd2003 	strb	r2, [sp, #3]
300111cc:	e1cd30b0 	strh	r3, [sp]
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
300111d0:	e59d3004 	ldr	r3, [sp, #4]
300111d4:	e3530000 	cmp	r3, #0
300111d8:	0a0000a7 	beq	3001147c <event_callback+0x2c8>
    s = conn->socket;
300111dc:	e59d3004 	ldr	r3, [sp, #4]
300111e0:	e5933018 	ldr	r3, [r3, #24]
300111e4:	e58d300c 	str	r3, [sp, #12]
    if (s < 0) {
300111e8:	e59d300c 	ldr	r3, [sp, #12]
300111ec:	e3530000 	cmp	r3, #0
300111f0:	aa000018 	bge	30011258 <event_callback+0xa4>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
300111f4:	e59f3298 	ldr	r3, [pc, #664]	; 30011494 <event_callback+0x2e0>
300111f8:	e5933000 	ldr	r3, [r3]
300111fc:	e1a00003 	mov	r0, r3
30011200:	eb0017ec 	bl	300171b8 <sys_sem_wait>
      if (conn->socket < 0) {
30011204:	e59d3004 	ldr	r3, [sp, #4]
30011208:	e5933018 	ldr	r3, [r3, #24]
3001120c:	e3530000 	cmp	r3, #0
30011210:	aa00000c 	bge	30011248 <event_callback+0x94>
        if (evt == NETCONN_EVT_RCVPLUS) {
30011214:	e5dd3003 	ldrb	r3, [sp, #3]
30011218:	e3530000 	cmp	r3, #0
3001121c:	1a000004 	bne	30011234 <event_callback+0x80>
          conn->socket--;
30011220:	e59d3004 	ldr	r3, [sp, #4]
30011224:	e5933018 	ldr	r3, [r3, #24]
30011228:	e2432001 	sub	r2, r3, #1
3001122c:	e59d3004 	ldr	r3, [sp, #4]
30011230:	e5832018 	str	r2, [r3, #24]
        }
        sys_sem_signal(socksem);
30011234:	e59f3258 	ldr	r3, [pc, #600]	; 30011494 <event_callback+0x2e0>
30011238:	e5933000 	ldr	r3, [r3]
3001123c:	e1a00003 	mov	r0, r3
30011240:	ebffee34 	bl	3000cb18 <sys_sem_signal>
        return;
30011244:	ea00008f 	b	30011488 <event_callback+0x2d4>
      }
      sys_sem_signal(socksem);
30011248:	e59f3244 	ldr	r3, [pc, #580]	; 30011494 <event_callback+0x2e0>
3001124c:	e5933000 	ldr	r3, [r3]
30011250:	e1a00003 	mov	r0, r3
30011254:	ebffee2f 	bl	3000cb18 <sys_sem_signal>
    }

    sock = get_socket(s);
30011258:	e59d000c 	ldr	r0, [sp, #12]
3001125c:	ebfff99d 	bl	3000f8d8 <get_socket>
30011260:	e1a03000 	mov	r3, r0
30011264:	e58d3010 	str	r3, [sp, #16]
    if (!sock) {
30011268:	e59d3010 	ldr	r3, [sp, #16]
3001126c:	e3530000 	cmp	r3, #0
30011270:	0a000083 	beq	30011484 <event_callback+0x2d0>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
30011274:	e59f321c 	ldr	r3, [pc, #540]	; 30011498 <event_callback+0x2e4>
30011278:	e5933000 	ldr	r3, [r3]
3001127c:	e1a00003 	mov	r0, r3
30011280:	eb0017cc 	bl	300171b8 <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
30011284:	e5dd3003 	ldrb	r3, [sp, #3]
30011288:	e3530003 	cmp	r3, #3
3001128c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30011290:	ea00001a 	b	30011300 <event_callback+0x14c>
30011294:	300112a4 	.word	0x300112a4
30011298:	300112c4 	.word	0x300112c4
3001129c:	300112e4 	.word	0x300112e4
300112a0:	300112f4 	.word	0x300112f4
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
300112a4:	e59d3010 	ldr	r3, [sp, #16]
300112a8:	e1d330ba 	ldrh	r3, [r3, #10]
300112ac:	e2833001 	add	r3, r3, #1
300112b0:	e1a03803 	lsl	r3, r3, #16
300112b4:	e1a02823 	lsr	r2, r3, #16
300112b8:	e59d3010 	ldr	r3, [sp, #16]
300112bc:	e1c320ba 	strh	r2, [r3, #10]
      break;
300112c0:	ea00000e 	b	30011300 <event_callback+0x14c>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
300112c4:	e59d3010 	ldr	r3, [sp, #16]
300112c8:	e1d330ba 	ldrh	r3, [r3, #10]
300112cc:	e2433001 	sub	r3, r3, #1
300112d0:	e1a03803 	lsl	r3, r3, #16
300112d4:	e1a02823 	lsr	r2, r3, #16
300112d8:	e59d3010 	ldr	r3, [sp, #16]
300112dc:	e1c320ba 	strh	r2, [r3, #10]
      break;
300112e0:	ea000006 	b	30011300 <event_callback+0x14c>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
300112e4:	e59d3010 	ldr	r3, [sp, #16]
300112e8:	e3a02001 	mov	r2, #1
300112ec:	e1c320bc 	strh	r2, [r3, #12]
      break;
300112f0:	ea000002 	b	30011300 <event_callback+0x14c>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
300112f4:	e59d3010 	ldr	r3, [sp, #16]
300112f8:	e3a02000 	mov	r2, #0
300112fc:	e1c320bc 	strh	r2, [r3, #12]
      break;
    default:
      LWIP_ASSERT("unknown event", 0);
      break;
  }
  sys_sem_signal(selectsem);
30011300:	e59f3190 	ldr	r3, [pc, #400]	; 30011498 <event_callback+0x2e4>
30011304:	e5933000 	ldr	r3, [r3]
30011308:	e1a00003 	mov	r0, r3
3001130c:	ebffee01 	bl	3000cb18 <sys_sem_signal>
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
30011310:	e59f3180 	ldr	r3, [pc, #384]	; 30011498 <event_callback+0x2e4>
30011314:	e5933000 	ldr	r3, [r3]
30011318:	e1a00003 	mov	r0, r3
3001131c:	eb0017a5 	bl	300171b8 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
30011320:	e59f3174 	ldr	r3, [pc, #372]	; 3001149c <event_callback+0x2e8>
30011324:	e5933000 	ldr	r3, [r3]
30011328:	e58d3014 	str	r3, [sp, #20]
3001132c:	ea000036 	b	3001140c <event_callback+0x258>
      if (scb->sem_signalled == 0) {
30011330:	e59d3014 	ldr	r3, [sp, #20]
30011334:	e5933010 	ldr	r3, [r3, #16]
30011338:	e3530000 	cmp	r3, #0
3001133c:	1a00002f 	bne	30011400 <event_callback+0x24c>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
30011340:	e59d3014 	ldr	r3, [sp, #20]
30011344:	e5933004 	ldr	r3, [r3, #4]
30011348:	e3530000 	cmp	r3, #0
3001134c:	0a000013 	beq	300113a0 <event_callback+0x1ec>
30011350:	e59d3014 	ldr	r3, [sp, #20]
30011354:	e5932004 	ldr	r2, [r3, #4]
30011358:	e59d300c 	ldr	r3, [sp, #12]
3001135c:	e2831007 	add	r1, r3, #7
30011360:	e3530000 	cmp	r3, #0
30011364:	b1a03001 	movlt	r3, r1
30011368:	e1a031c3 	asr	r3, r3, #3
3001136c:	e7d23003 	ldrb	r3, [r2, r3]
30011370:	e1a02003 	mov	r2, r3
30011374:	e59d300c 	ldr	r3, [sp, #12]
30011378:	e2033007 	and	r3, r3, #7
3001137c:	e1a03352 	asr	r3, r2, r3
30011380:	e2033001 	and	r3, r3, #1
30011384:	e20330ff 	and	r3, r3, #255	; 0xff
30011388:	e3530000 	cmp	r3, #0
3001138c:	0a000003 	beq	300113a0 <event_callback+0x1ec>
          if (sock->rcvevent)
30011390:	e59d3010 	ldr	r3, [sp, #16]
30011394:	e1d330ba 	ldrh	r3, [r3, #10]
30011398:	e3530000 	cmp	r3, #0
3001139c:	1a00001e 	bne	3001141c <event_callback+0x268>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
300113a0:	e59d3014 	ldr	r3, [sp, #20]
300113a4:	e5933008 	ldr	r3, [r3, #8]
300113a8:	e3530000 	cmp	r3, #0
300113ac:	0a000013 	beq	30011400 <event_callback+0x24c>
300113b0:	e59d3014 	ldr	r3, [sp, #20]
300113b4:	e5932008 	ldr	r2, [r3, #8]
300113b8:	e59d300c 	ldr	r3, [sp, #12]
300113bc:	e2831007 	add	r1, r3, #7
300113c0:	e3530000 	cmp	r3, #0
300113c4:	b1a03001 	movlt	r3, r1
300113c8:	e1a031c3 	asr	r3, r3, #3
300113cc:	e7d23003 	ldrb	r3, [r2, r3]
300113d0:	e1a02003 	mov	r2, r3
300113d4:	e59d300c 	ldr	r3, [sp, #12]
300113d8:	e2033007 	and	r3, r3, #7
300113dc:	e1a03352 	asr	r3, r2, r3
300113e0:	e2033001 	and	r3, r3, #1
300113e4:	e20330ff 	and	r3, r3, #255	; 0xff
300113e8:	e3530000 	cmp	r3, #0
300113ec:	0a000003 	beq	30011400 <event_callback+0x24c>
          if (sock->sendevent)
300113f0:	e59d3010 	ldr	r3, [sp, #16]
300113f4:	e1d330bc 	ldrh	r3, [r3, #12]
300113f8:	e3530000 	cmp	r3, #0
300113fc:	1a000008 	bne	30011424 <event_callback+0x270>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
30011400:	e59d3014 	ldr	r3, [sp, #20]
30011404:	e5933000 	ldr	r3, [r3]
30011408:	e58d3014 	str	r3, [sp, #20]
3001140c:	e59d3014 	ldr	r3, [sp, #20]
30011410:	e3530000 	cmp	r3, #0
30011414:	1affffc5 	bne	30011330 <event_callback+0x17c>
30011418:	ea000002 	b	30011428 <event_callback+0x274>
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
          if (sock->rcvevent)
            break;
3001141c:	e1a00000 	nop			; (mov r0, r0)
30011420:	ea000000 	b	30011428 <event_callback+0x274>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
          if (sock->sendevent)
            break;
30011424:	e1a00000 	nop			; (mov r0, r0)
      }
    }
    if (scb) {
30011428:	e59d3014 	ldr	r3, [sp, #20]
3001142c:	e3530000 	cmp	r3, #0
30011430:	0a00000b 	beq	30011464 <event_callback+0x2b0>
      scb->sem_signalled = 1;
30011434:	e59d3014 	ldr	r3, [sp, #20]
30011438:	e3a02001 	mov	r2, #1
3001143c:	e5832010 	str	r2, [r3, #16]
      sys_sem_signal(selectsem);
30011440:	e59f3050 	ldr	r3, [pc, #80]	; 30011498 <event_callback+0x2e4>
30011444:	e5933000 	ldr	r3, [r3]
30011448:	e1a00003 	mov	r0, r3
3001144c:	ebffedb1 	bl	3000cb18 <sys_sem_signal>
      sys_sem_signal(scb->sem);
30011450:	e59d3014 	ldr	r3, [sp, #20]
30011454:	e5933014 	ldr	r3, [r3, #20]
30011458:	e1a00003 	mov	r0, r3
3001145c:	ebffedad 	bl	3000cb18 <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
30011460:	eaffffaa 	b	30011310 <event_callback+0x15c>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
30011464:	e59f302c 	ldr	r3, [pc, #44]	; 30011498 <event_callback+0x2e4>
30011468:	e5933000 	ldr	r3, [r3]
3001146c:	e1a00003 	mov	r0, r3
30011470:	ebffeda8 	bl	3000cb18 <sys_sem_signal>
      break;
30011474:	e1a00000 	nop			; (mov r0, r0)
30011478:	ea000002 	b	30011488 <event_callback+0x2d4>
    sock = get_socket(s);
    if (!sock) {
      return;
    }
  } else {
    return;
3001147c:	e1a00000 	nop			; (mov r0, r0)
30011480:	ea000000 	b	30011488 <event_callback+0x2d4>
      sys_sem_signal(socksem);
    }

    sock = get_socket(s);
    if (!sock) {
      return;
30011484:	e1a00000 	nop			; (mov r0, r0)
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
}
30011488:	e28dd01c 	add	sp, sp, #28
3001148c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30011490:	e12fff1e 	bx	lr
30011494:	300271fc 	.word	0x300271fc
30011498:	30027200 	.word	0x30027200
3001149c:	300271f8 	.word	0x300271f8

300114a0 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
300114a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300114a4:	e24dd00c 	sub	sp, sp, #12
300114a8:	e58d0004 	str	r0, [sp, #4]
300114ac:	e58d1000 	str	r1, [sp]
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
300114b0:	e59d0004 	ldr	r0, [sp, #4]
300114b4:	ebfffa7e 	bl	3000feb4 <lwip_close>
300114b8:	e1a03000 	mov	r3, r0
}
300114bc:	e1a00003 	mov	r0, r3
300114c0:	e28dd00c 	add	sp, sp, #12
300114c4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300114c8:	e12fff1e 	bx	lr

300114cc <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
300114cc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300114d0:	e24dd02c 	sub	sp, sp, #44	; 0x2c
300114d4:	e58d000c 	str	r0, [sp, #12]
300114d8:	e58d1008 	str	r1, [sp, #8]
300114dc:	e58d2004 	str	r2, [sp, #4]
300114e0:	e5cd3003 	strb	r3, [sp, #3]
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
300114e4:	e59d000c 	ldr	r0, [sp, #12]
300114e8:	ebfff8fa 	bl	3000f8d8 <get_socket>
300114ec:	e1a03000 	mov	r3, r0
300114f0:	e58d3024 	str	r3, [sp, #36]	; 0x24
  if (!sock)
300114f4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300114f8:	e3530000 	cmp	r3, #0
300114fc:	1a000001 	bne	30011508 <lwip_getaddrname+0x3c>
    return -1;
30011500:	e3e03000 	mvn	r3, #0
30011504:	ea000028 	b	300115ac <lwip_getaddrname+0xe0>

  memset(&sin, 0, sizeof(sin));
30011508:	e28d3014 	add	r3, sp, #20
3001150c:	e1a00003 	mov	r0, r3
30011510:	e3a01000 	mov	r1, #0
30011514:	e3a02010 	mov	r2, #16
30011518:	ebffee71 	bl	3000cee4 <__re_memset>
  sin.sin_len = sizeof(sin);
3001151c:	e3a03010 	mov	r3, #16
30011520:	e5cd3014 	strb	r3, [sp, #20]
  sin.sin_family = AF_INET;
30011524:	e3a03002 	mov	r3, #2
30011528:	e5cd3015 	strb	r3, [sp, #21]

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
3001152c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30011530:	e5930000 	ldr	r0, [r3]
30011534:	e28d1010 	add	r1, sp, #16
30011538:	e28d3014 	add	r3, sp, #20
3001153c:	e2832002 	add	r2, r3, #2
30011540:	e5dd3003 	ldrb	r3, [sp, #3]
30011544:	ebffeef0 	bl	3000d10c <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
30011548:	e1dd31b6 	ldrh	r3, [sp, #22]
3001154c:	e1a00003 	mov	r0, r3
30011550:	eb0008d9 	bl	300138bc <htons>
30011554:	e1a03000 	mov	r3, r0
30011558:	e1cd31b6 	strh	r3, [sp, #22]
  sin.sin_addr.s_addr = naddr.addr;
3001155c:	e59d3010 	ldr	r3, [sp, #16]
30011560:	e58d3018 	str	r3, [sp, #24]

  if (*namelen > sizeof(sin))
30011564:	e59d3004 	ldr	r3, [sp, #4]
30011568:	e5933000 	ldr	r3, [r3]
3001156c:	e3530010 	cmp	r3, #16
30011570:	9a000002 	bls	30011580 <lwip_getaddrname+0xb4>
    *namelen = sizeof(sin);
30011574:	e59d3004 	ldr	r3, [sp, #4]
30011578:	e3a02010 	mov	r2, #16
3001157c:	e5832000 	str	r2, [r3]

  SMEMCPY(name, &sin, *namelen);
30011580:	e59d3004 	ldr	r3, [sp, #4]
30011584:	e5933000 	ldr	r3, [r3]
30011588:	e28d2014 	add	r2, sp, #20
3001158c:	e59d0008 	ldr	r0, [sp, #8]
30011590:	e1a01002 	mov	r1, r2
30011594:	e1a02003 	mov	r2, r3
30011598:	ebffee6b 	bl	3000cf4c <__re_memcpy>
  sock_set_errno(sock, 0);
3001159c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300115a0:	e3a02000 	mov	r2, #0
300115a4:	e5832010 	str	r2, [r3, #16]
  return 0;
300115a8:	e3a03000 	mov	r3, #0
}
300115ac:	e1a00003 	mov	r0, r3
300115b0:	e28dd02c 	add	sp, sp, #44	; 0x2c
300115b4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300115b8:	e12fff1e 	bx	lr

300115bc <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
300115bc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300115c0:	e24dd014 	sub	sp, sp, #20
300115c4:	e58d000c 	str	r0, [sp, #12]
300115c8:	e58d1008 	str	r1, [sp, #8]
300115cc:	e58d2004 	str	r2, [sp, #4]
  return lwip_getaddrname(s, name, namelen, 0);
300115d0:	e59d000c 	ldr	r0, [sp, #12]
300115d4:	e59d1008 	ldr	r1, [sp, #8]
300115d8:	e59d2004 	ldr	r2, [sp, #4]
300115dc:	e3a03000 	mov	r3, #0
300115e0:	ebffffb9 	bl	300114cc <lwip_getaddrname>
300115e4:	e1a03000 	mov	r3, r0
}
300115e8:	e1a00003 	mov	r0, r3
300115ec:	e28dd014 	add	sp, sp, #20
300115f0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300115f4:	e12fff1e 	bx	lr

300115f8 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
300115f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300115fc:	e24dd014 	sub	sp, sp, #20
30011600:	e58d000c 	str	r0, [sp, #12]
30011604:	e58d1008 	str	r1, [sp, #8]
30011608:	e58d2004 	str	r2, [sp, #4]
  return lwip_getaddrname(s, name, namelen, 1);
3001160c:	e59d000c 	ldr	r0, [sp, #12]
30011610:	e59d1008 	ldr	r1, [sp, #8]
30011614:	e59d2004 	ldr	r2, [sp, #4]
30011618:	e3a03001 	mov	r3, #1
3001161c:	ebffffaa 	bl	300114cc <lwip_getaddrname>
30011620:	e1a03000 	mov	r3, r0
}
30011624:	e1a00003 	mov	r0, r3
30011628:	e28dd014 	add	sp, sp, #20
3001162c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30011630:	e12fff1e 	bx	lr

30011634 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
30011634:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30011638:	e24dd03c 	sub	sp, sp, #60	; 0x3c
3001163c:	e58d000c 	str	r0, [sp, #12]
30011640:	e58d1008 	str	r1, [sp, #8]
30011644:	e58d2004 	str	r2, [sp, #4]
30011648:	e58d3000 	str	r3, [sp]
  err_t err = ERR_OK;
3001164c:	e3a03000 	mov	r3, #0
30011650:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
  struct lwip_socket *sock = get_socket(s);
30011654:	e59d000c 	ldr	r0, [sp, #12]
30011658:	ebfff89e 	bl	3000f8d8 <get_socket>
3001165c:	e1a03000 	mov	r3, r0
30011660:	e58d3034 	str	r3, [sp, #52]	; 0x34
  struct lwip_setgetsockopt_data data;

  if (!sock)
30011664:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30011668:	e3530000 	cmp	r3, #0
3001166c:	1a000001 	bne	30011678 <lwip_getsockopt+0x44>
    return -1;
30011670:	e3e03000 	mvn	r3, #0
30011674:	ea00009d 	b	300118f0 <lwip_getsockopt+0x2bc>

  if ((NULL == optval) || (NULL == optlen)) {
30011678:	e59d3000 	ldr	r3, [sp]
3001167c:	e3530000 	cmp	r3, #0
30011680:	0a000002 	beq	30011690 <lwip_getsockopt+0x5c>
30011684:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
30011688:	e3530000 	cmp	r3, #0
3001168c:	1a000004 	bne	300116a4 <lwip_getsockopt+0x70>
    sock_set_errno(sock, EFAULT);
30011690:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30011694:	e3a0200e 	mov	r2, #14
30011698:	e5832010 	str	r2, [r3, #16]
    return -1;
3001169c:	e3e03000 	mvn	r3, #0
300116a0:	ea000092 	b	300118f0 <lwip_getsockopt+0x2bc>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
300116a4:	e59d3008 	ldr	r3, [sp, #8]
300116a8:	e3530006 	cmp	r3, #6
300116ac:	0a00004c 	beq	300117e4 <lwip_getsockopt+0x1b0>
300116b0:	e3a02eff 	mov	r2, #4080	; 0xff0
300116b4:	e282200f 	add	r2, r2, #15
300116b8:	e1530002 	cmp	r3, r2
300116bc:	0a000002 	beq	300116cc <lwip_getsockopt+0x98>
300116c0:	e3530000 	cmp	r3, #0
300116c4:	0a000037 	beq	300117a8 <lwip_getsockopt+0x174>
300116c8:	ea00005c 	b	30011840 <lwip_getsockopt+0x20c>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
300116cc:	e59d3004 	ldr	r3, [sp, #4]
300116d0:	e3530020 	cmp	r3, #32
300116d4:	0a000013 	beq	30011728 <lwip_getsockopt+0xf4>
300116d8:	e3530020 	cmp	r3, #32
300116dc:	ca000004 	bgt	300116f4 <lwip_getsockopt+0xc0>
300116e0:	e3530002 	cmp	r3, #2
300116e4:	0a00000f 	beq	30011728 <lwip_getsockopt+0xf4>
300116e8:	e3530008 	cmp	r3, #8
300116ec:	0a00000d 	beq	30011728 <lwip_getsockopt+0xf4>
300116f0:	ea000028 	b	30011798 <lwip_getsockopt+0x164>
300116f4:	e3a02a01 	mov	r2, #4096	; 0x1000
300116f8:	e2822007 	add	r2, r2, #7
300116fc:	e1530002 	cmp	r3, r2
30011700:	ba000024 	blt	30011798 <lwip_getsockopt+0x164>
30011704:	e3a02a01 	mov	r2, #4096	; 0x1000
30011708:	e2822008 	add	r2, r2, #8
3001170c:	e1530002 	cmp	r3, r2
30011710:	da000004 	ble	30011728 <lwip_getsockopt+0xf4>
30011714:	e3a02a01 	mov	r2, #4096	; 0x1000
30011718:	e282200a 	add	r2, r2, #10
3001171c:	e1530002 	cmp	r3, r2
30011720:	0a000007 	beq	30011744 <lwip_getsockopt+0x110>
30011724:	ea00001b 	b	30011798 <lwip_getsockopt+0x164>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
30011728:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3001172c:	e5933000 	ldr	r3, [r3]
30011730:	e3530003 	cmp	r3, #3
30011734:	8a000001 	bhi	30011740 <lwip_getsockopt+0x10c>
        err = EINVAL;
30011738:	e3a03016 	mov	r3, #22
3001173c:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
      }
      break;
30011740:	ea000017 	b	300117a4 <lwip_getsockopt+0x170>

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
30011744:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
30011748:	e5933000 	ldr	r3, [r3]
3001174c:	e3530003 	cmp	r3, #3
30011750:	8a000001 	bhi	3001175c <lwip_getsockopt+0x128>
        err = EINVAL;
30011754:	e3a03016 	mov	r3, #22
30011758:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
3001175c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30011760:	e5933000 	ldr	r3, [r3]
30011764:	e5d33000 	ldrb	r3, [r3]
30011768:	e3530020 	cmp	r3, #32
3001176c:	1a000006 	bne	3001178c <lwip_getsockopt+0x158>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
30011770:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30011774:	e5933000 	ldr	r3, [r3]
30011778:	e5933004 	ldr	r3, [r3, #4]
3001177c:	e5d33010 	ldrb	r3, [r3, #16]
30011780:	e2033002 	and	r3, r3, #2
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
30011784:	e3530000 	cmp	r3, #0
30011788:	0a000001 	beq	30011794 <lwip_getsockopt+0x160>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
3001178c:	e3a03061 	mov	r3, #97	; 0x61
30011790:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
      }
#endif /* LWIP_UDP */
      break;
30011794:	ea000002 	b	300117a4 <lwip_getsockopt+0x170>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
30011798:	e3a0305c 	mov	r3, #92	; 0x5c
3001179c:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
    }  /* switch (optname) */
    break;
300117a0:	ea000028 	b	30011848 <lwip_getsockopt+0x214>
300117a4:	ea000027 	b	30011848 <lwip_getsockopt+0x214>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
300117a8:	e59d3004 	ldr	r3, [sp, #4]
300117ac:	e2433001 	sub	r3, r3, #1
300117b0:	e3530001 	cmp	r3, #1
300117b4:	8a000007 	bhi	300117d8 <lwip_getsockopt+0x1a4>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
300117b8:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
300117bc:	e5933000 	ldr	r3, [r3]
300117c0:	e3530003 	cmp	r3, #3
300117c4:	8a000001 	bhi	300117d0 <lwip_getsockopt+0x19c>
        err = EINVAL;
300117c8:	e3a03016 	mov	r3, #22
300117cc:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
      }
      break;
300117d0:	e1a00000 	nop			; (mov r0, r0)
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
300117d4:	ea00001b 	b	30011848 <lwip_getsockopt+0x214>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
300117d8:	e3a0305c 	mov	r3, #92	; 0x5c
300117dc:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
    }  /* switch (optname) */
    break;
300117e0:	ea000018 	b	30011848 <lwip_getsockopt+0x214>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
300117e4:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
300117e8:	e5933000 	ldr	r3, [r3]
300117ec:	e3530003 	cmp	r3, #3
300117f0:	8a000002 	bhi	30011800 <lwip_getsockopt+0x1cc>
      err = EINVAL;
300117f4:	e3a03016 	mov	r3, #22
300117f8:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
      break;
300117fc:	ea000011 	b	30011848 <lwip_getsockopt+0x214>
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
30011800:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30011804:	e5933000 	ldr	r3, [r3]
30011808:	e5d33000 	ldrb	r3, [r3]
3001180c:	e3530010 	cmp	r3, #16
30011810:	0a000001 	beq	3001181c <lwip_getsockopt+0x1e8>
      return 0;
30011814:	e3a03000 	mov	r3, #0
30011818:	ea000034 	b	300118f0 <lwip_getsockopt+0x2bc>

    switch (optname) {
3001181c:	e59d3004 	ldr	r3, [sp, #4]
30011820:	e2433001 	sub	r3, r3, #1
30011824:	e3530001 	cmp	r3, #1
30011828:	8a000001 	bhi	30011834 <lwip_getsockopt+0x200>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
3001182c:	e1a00000 	nop			; (mov r0, r0)
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
30011830:	ea000004 	b	30011848 <lwip_getsockopt+0x214>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
30011834:	e3a0305c 	mov	r3, #92	; 0x5c
30011838:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
    }  /* switch (optname) */
    break;
3001183c:	ea000001 	b	30011848 <lwip_getsockopt+0x214>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
30011840:	e3a0305c 	mov	r3, #92	; 0x5c
30011844:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
  }  /* switch */

   
  if (err != ERR_OK) {
30011848:	e1dd33d3 	ldrsb	r3, [sp, #51]	; 0x33
3001184c:	e3530000 	cmp	r3, #0
30011850:	0a000004 	beq	30011868 <lwip_getsockopt+0x234>
    sock_set_errno(sock, err);
30011854:	e1dd23d3 	ldrsb	r2, [sp, #51]	; 0x33
30011858:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3001185c:	e5832010 	str	r2, [r3, #16]
    return -1;
30011860:	e3e03000 	mvn	r3, #0
30011864:	ea000021 	b	300118f0 <lwip_getsockopt+0x2bc>
  }

  /* Now do the actual option processing */
  data.sock = sock;
30011868:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3001186c:	e58d3014 	str	r3, [sp, #20]
  data.level = level;
30011870:	e59d3008 	ldr	r3, [sp, #8]
30011874:	e58d301c 	str	r3, [sp, #28]
  data.optname = optname;
30011878:	e59d3004 	ldr	r3, [sp, #4]
3001187c:	e58d3020 	str	r3, [sp, #32]
  data.optval = optval;
30011880:	e59d3000 	ldr	r3, [sp]
30011884:	e58d3024 	str	r3, [sp, #36]	; 0x24
  data.optlen = optlen;
30011888:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3001188c:	e58d3028 	str	r3, [sp, #40]	; 0x28
  data.err = err;
30011890:	e5dd3033 	ldrb	r3, [sp, #51]	; 0x33
30011894:	e5cd302c 	strb	r3, [sp, #44]	; 0x2c
  tcpip_callback(lwip_getsockopt_internal, &data);
30011898:	e28d3014 	add	r3, sp, #20
3001189c:	e59f005c 	ldr	r0, [pc, #92]	; 30011900 <lwip_getsockopt+0x2cc>
300118a0:	e1a01003 	mov	r1, r3
300118a4:	e3a02001 	mov	r2, #1
300118a8:	eb000385 	bl	300126c4 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
300118ac:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
300118b0:	e5933000 	ldr	r3, [r3]
300118b4:	e593300c 	ldr	r3, [r3, #12]
300118b8:	e1a00003 	mov	r0, r3
300118bc:	e3a01000 	mov	r1, #0
300118c0:	ebffec9c 	bl	3000cb38 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
300118c4:	e5dd302c 	ldrb	r3, [sp, #44]	; 0x2c
300118c8:	e5cd3033 	strb	r3, [sp, #51]	; 0x33

  sock_set_errno(sock, err);
300118cc:	e1dd23d3 	ldrsb	r2, [sp, #51]	; 0x33
300118d0:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
300118d4:	e5832010 	str	r2, [r3, #16]
  return err ? -1 : 0;
300118d8:	e1dd33d3 	ldrsb	r3, [sp, #51]	; 0x33
300118dc:	e3530000 	cmp	r3, #0
300118e0:	0a000001 	beq	300118ec <lwip_getsockopt+0x2b8>
300118e4:	e3e03000 	mvn	r3, #0
300118e8:	ea000000 	b	300118f0 <lwip_getsockopt+0x2bc>
300118ec:	e3a03000 	mov	r3, #0
}
300118f0:	e1a00003 	mov	r0, r3
300118f4:	e28dd03c 	add	sp, sp, #60	; 0x3c
300118f8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300118fc:	e12fff1e 	bx	lr
30011900:	30011904 	.word	0x30011904

30011904 <lwip_getsockopt_internal>:

static void
lwip_getsockopt_internal(void *arg)
{
30011904:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30011908:	e24dd024 	sub	sp, sp, #36	; 0x24
3001190c:	e58d0004 	str	r0, [sp, #4]
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);

  data = (struct lwip_setgetsockopt_data*)arg;
30011910:	e59d3004 	ldr	r3, [sp, #4]
30011914:	e58d301c 	str	r3, [sp, #28]
  sock = data->sock;
30011918:	e59d301c 	ldr	r3, [sp, #28]
3001191c:	e5933000 	ldr	r3, [r3]
30011920:	e58d300c 	str	r3, [sp, #12]
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
30011924:	e59d301c 	ldr	r3, [sp, #28]
30011928:	e5933008 	ldr	r3, [r3, #8]
3001192c:	e58d3010 	str	r3, [sp, #16]
  optname = data->optname;
30011930:	e59d301c 	ldr	r3, [sp, #28]
30011934:	e593300c 	ldr	r3, [r3, #12]
30011938:	e58d3014 	str	r3, [sp, #20]
  optval = data->optval;
3001193c:	e59d301c 	ldr	r3, [sp, #28]
30011940:	e5933010 	ldr	r3, [r3, #16]
30011944:	e58d3018 	str	r3, [sp, #24]

  switch (level) {
30011948:	e59d3010 	ldr	r3, [sp, #16]
3001194c:	e3530006 	cmp	r3, #6
30011950:	0a000081 	beq	30011b5c <lwip_getsockopt_internal+0x258>
30011954:	e3a02eff 	mov	r2, #4080	; 0xff0
30011958:	e282200f 	add	r2, r2, #15
3001195c:	e1530002 	cmp	r3, r2
30011960:	0a000002 	beq	30011970 <lwip_getsockopt_internal+0x6c>
30011964:	e3530000 	cmp	r3, #0
30011968:	0a000067 	beq	30011b0c <lwip_getsockopt_internal+0x208>
3001196c:	ea000090 	b	30011bb4 <lwip_getsockopt_internal+0x2b0>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
30011970:	e59d3014 	ldr	r3, [sp, #20]
30011974:	e3530020 	cmp	r3, #32
30011978:	0a000013 	beq	300119cc <lwip_getsockopt_internal+0xc8>
3001197c:	e3530020 	cmp	r3, #32
30011980:	ca000004 	bgt	30011998 <lwip_getsockopt_internal+0x94>
30011984:	e3530002 	cmp	r3, #2
30011988:	0a00000f 	beq	300119cc <lwip_getsockopt_internal+0xc8>
3001198c:	e3530008 	cmp	r3, #8
30011990:	0a00000d 	beq	300119cc <lwip_getsockopt_internal+0xc8>
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
30011994:	ea000086 	b	30011bb4 <lwip_getsockopt_internal+0x2b0>

  switch (level) {
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
30011998:	e3a02a01 	mov	r2, #4096	; 0x1000
3001199c:	e2822008 	add	r2, r2, #8
300119a0:	e1530002 	cmp	r3, r2
300119a4:	0a000012 	beq	300119f4 <lwip_getsockopt_internal+0xf0>
300119a8:	e3a02a01 	mov	r2, #4096	; 0x1000
300119ac:	e282200a 	add	r2, r2, #10
300119b0:	e1530002 	cmp	r3, r2
300119b4:	0a00004b 	beq	30011ae8 <lwip_getsockopt_internal+0x1e4>
300119b8:	e3a02a01 	mov	r2, #4096	; 0x1000
300119bc:	e2822007 	add	r2, r2, #7
300119c0:	e1530002 	cmp	r3, r2
300119c4:	0a000027 	beq	30011a68 <lwip_getsockopt_internal+0x164>
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
300119c8:	ea000079 	b	30011bb4 <lwip_getsockopt_internal+0x2b0>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
300119cc:	e59d3018 	ldr	r3, [sp, #24]
300119d0:	e59d200c 	ldr	r2, [sp, #12]
300119d4:	e5922000 	ldr	r2, [r2]
300119d8:	e5922004 	ldr	r2, [r2, #4]
300119dc:	e1d220b8 	ldrh	r2, [r2, #8]
300119e0:	e1a01002 	mov	r1, r2
300119e4:	e59d2014 	ldr	r2, [sp, #20]
300119e8:	e0012002 	and	r2, r1, r2
300119ec:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
300119f0:	ea000044 	b	30011b08 <lwip_getsockopt_internal+0x204>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
300119f4:	e59d300c 	ldr	r3, [sp, #12]
300119f8:	e5933000 	ldr	r3, [r3]
300119fc:	e5d33000 	ldrb	r3, [r3]
30011a00:	e20330f0 	and	r3, r3, #240	; 0xf0
30011a04:	e3530020 	cmp	r3, #32
30011a08:	0a00000c 	beq	30011a40 <lwip_getsockopt_internal+0x13c>
30011a0c:	e3530040 	cmp	r3, #64	; 0x40
30011a10:	0a000002 	beq	30011a20 <lwip_getsockopt_internal+0x11c>
30011a14:	e3530010 	cmp	r3, #16
30011a18:	0a000004 	beq	30011a30 <lwip_getsockopt_internal+0x12c>
30011a1c:	ea00000b 	b	30011a50 <lwip_getsockopt_internal+0x14c>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
30011a20:	e59d3018 	ldr	r3, [sp, #24]
30011a24:	e3a02003 	mov	r2, #3
30011a28:	e5832000 	str	r2, [r3]
        break;
30011a2c:	ea00000c 	b	30011a64 <lwip_getsockopt_internal+0x160>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
30011a30:	e59d3018 	ldr	r3, [sp, #24]
30011a34:	e3a02001 	mov	r2, #1
30011a38:	e5832000 	str	r2, [r3]
        break;
30011a3c:	ea000008 	b	30011a64 <lwip_getsockopt_internal+0x160>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
30011a40:	e59d3018 	ldr	r3, [sp, #24]
30011a44:	e3a02002 	mov	r2, #2
30011a48:	e5832000 	str	r2, [r3]
        break;
30011a4c:	ea000004 	b	30011a64 <lwip_getsockopt_internal+0x160>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
30011a50:	e59d3018 	ldr	r3, [sp, #24]
30011a54:	e59d200c 	ldr	r2, [sp, #12]
30011a58:	e5922000 	ldr	r2, [r2]
30011a5c:	e5d22000 	ldrb	r2, [r2]
30011a60:	e5832000 	str	r2, [r3]
                    ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
                    s, *(int *)optval));
      }  /* switch (sock->conn->type) */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;
30011a64:	ea000027 	b	30011b08 <lwip_getsockopt_internal+0x204>

    case SO_ERROR:
      if (sock->err == 0) {
30011a68:	e59d300c 	ldr	r3, [sp, #12]
30011a6c:	e5933010 	ldr	r3, [r3, #16]
30011a70:	e3530000 	cmp	r3, #0
30011a74:	1a000013 	bne	30011ac8 <lwip_getsockopt_internal+0x1c4>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
30011a78:	e59d300c 	ldr	r3, [sp, #12]
30011a7c:	e5933000 	ldr	r3, [r3]
30011a80:	e5d33008 	ldrb	r3, [r3, #8]
30011a84:	e1a03c03 	lsl	r3, r3, #24
30011a88:	e1a03c43 	asr	r3, r3, #24
30011a8c:	e2633000 	rsb	r3, r3, #0
30011a90:	e353000e 	cmp	r3, #14
30011a94:	8a000008 	bhi	30011abc <lwip_getsockopt_internal+0x1b8>
30011a98:	e59d300c 	ldr	r3, [sp, #12]
30011a9c:	e5933000 	ldr	r3, [r3]
30011aa0:	e5d33008 	ldrb	r3, [r3, #8]
30011aa4:	e1a03c03 	lsl	r3, r3, #24
30011aa8:	e1a03c43 	asr	r3, r3, #24
30011aac:	e2632000 	rsb	r2, r3, #0
30011ab0:	e59f311c 	ldr	r3, [pc, #284]	; 30011bd4 <lwip_getsockopt_internal+0x2d0>
30011ab4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30011ab8:	ea000000 	b	30011ac0 <lwip_getsockopt_internal+0x1bc>
30011abc:	e3a03005 	mov	r3, #5
30011ac0:	e59d200c 	ldr	r2, [sp, #12]
30011ac4:	e5823010 	str	r3, [r2, #16]
      } 
      *(int *)optval = sock->err;
30011ac8:	e59d3018 	ldr	r3, [sp, #24]
30011acc:	e59d200c 	ldr	r2, [sp, #12]
30011ad0:	e5922010 	ldr	r2, [r2, #16]
30011ad4:	e5832000 	str	r2, [r3]
      sock->err = 0;
30011ad8:	e59d300c 	ldr	r3, [sp, #12]
30011adc:	e3a02000 	mov	r2, #0
30011ae0:	e5832010 	str	r2, [r3, #16]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
30011ae4:	ea000007 	b	30011b08 <lwip_getsockopt_internal+0x204>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
30011ae8:	e59d3018 	ldr	r3, [sp, #24]
30011aec:	e59d200c 	ldr	r2, [sp, #12]
30011af0:	e5922000 	ldr	r2, [r2]
30011af4:	e5922004 	ldr	r2, [r2, #4]
30011af8:	e5d22010 	ldrb	r2, [r2, #16]
30011afc:	e2022001 	and	r2, r2, #1
30011b00:	e5832000 	str	r2, [r3]
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
30011b04:	ea00002a 	b	30011bb4 <lwip_getsockopt_internal+0x2b0>
30011b08:	ea000029 	b	30011bb4 <lwip_getsockopt_internal+0x2b0>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
30011b0c:	e59d3014 	ldr	r3, [sp, #20]
30011b10:	e3530001 	cmp	r3, #1
30011b14:	0a000009 	beq	30011b40 <lwip_getsockopt_internal+0x23c>
30011b18:	e3530002 	cmp	r3, #2
30011b1c:	1a000023 	bne	30011bb0 <lwip_getsockopt_internal+0x2ac>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
30011b20:	e59d3018 	ldr	r3, [sp, #24]
30011b24:	e59d200c 	ldr	r2, [sp, #12]
30011b28:	e5922000 	ldr	r2, [r2]
30011b2c:	e5922004 	ldr	r2, [r2, #4]
30011b30:	e5d2200b 	ldrb	r2, [r2, #11]
30011b34:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
30011b38:	e1a00000 	nop			; (mov r0, r0)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
30011b3c:	ea00001c 	b	30011bb4 <lwip_getsockopt_internal+0x2b0>
      *(int*)optval = sock->conn->pcb.ip->ttl;
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
30011b40:	e59d3018 	ldr	r3, [sp, #24]
30011b44:	e59d200c 	ldr	r2, [sp, #12]
30011b48:	e5922000 	ldr	r2, [r2]
30011b4c:	e5922004 	ldr	r2, [r2, #4]
30011b50:	e5d2200a 	ldrb	r2, [r2, #10]
30011b54:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
30011b58:	ea000015 	b	30011bb4 <lwip_getsockopt_internal+0x2b0>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
30011b5c:	e59d3014 	ldr	r3, [sp, #20]
30011b60:	e3530001 	cmp	r3, #1
30011b64:	0a000002 	beq	30011b74 <lwip_getsockopt_internal+0x270>
30011b68:	e3530002 	cmp	r3, #2
30011b6c:	0a000008 	beq	30011b94 <lwip_getsockopt_internal+0x290>
30011b70:	ea00000f 	b	30011bb4 <lwip_getsockopt_internal+0x2b0>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
30011b74:	e59d3018 	ldr	r3, [sp, #24]
30011b78:	e59d200c 	ldr	r2, [sp, #12]
30011b7c:	e5922000 	ldr	r2, [r2]
30011b80:	e5922004 	ldr	r2, [r2, #4]
30011b84:	e5d2201c 	ldrb	r2, [r2, #28]
30011b88:	e2022040 	and	r2, r2, #64	; 0x40
30011b8c:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
30011b90:	ea000007 	b	30011bb4 <lwip_getsockopt_internal+0x2b0>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
30011b94:	e59d3018 	ldr	r3, [sp, #24]
30011b98:	e59d200c 	ldr	r2, [sp, #12]
30011b9c:	e5922000 	ldr	r2, [r2]
30011ba0:	e5922004 	ldr	r2, [r2, #4]
30011ba4:	e5922098 	ldr	r2, [r2, #152]	; 0x98
30011ba8:	e5832000 	str	r2, [r3]
30011bac:	ea000000 	b	30011bb4 <lwip_getsockopt_internal+0x2b0>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
30011bb0:	e1a00000 	nop			; (mov r0, r0)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
30011bb4:	e59d300c 	ldr	r3, [sp, #12]
30011bb8:	e5933000 	ldr	r3, [r3]
30011bbc:	e593300c 	ldr	r3, [r3, #12]
30011bc0:	e1a00003 	mov	r0, r3
30011bc4:	ebffebd3 	bl	3000cb18 <sys_sem_signal>
}
30011bc8:	e28dd024 	add	sp, sp, #36	; 0x24
30011bcc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30011bd0:	e12fff1e 	bx	lr
30011bd4:	30026498 	.word	0x30026498

30011bd8 <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
30011bd8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30011bdc:	e24dd03c 	sub	sp, sp, #60	; 0x3c
30011be0:	e58d000c 	str	r0, [sp, #12]
30011be4:	e58d1008 	str	r1, [sp, #8]
30011be8:	e58d2004 	str	r2, [sp, #4]
30011bec:	e58d3000 	str	r3, [sp]
  struct lwip_socket *sock = get_socket(s);
30011bf0:	e59d000c 	ldr	r0, [sp, #12]
30011bf4:	ebfff737 	bl	3000f8d8 <get_socket>
30011bf8:	e1a03000 	mov	r3, r0
30011bfc:	e58d3030 	str	r3, [sp, #48]	; 0x30
  int err = ERR_OK;
30011c00:	e3a03000 	mov	r3, #0
30011c04:	e58d3034 	str	r3, [sp, #52]	; 0x34
  struct lwip_setgetsockopt_data data;

  if (!sock)
30011c08:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011c0c:	e3530000 	cmp	r3, #0
30011c10:	1a000001 	bne	30011c1c <lwip_setsockopt+0x44>
    return -1;
30011c14:	e3e03000 	mvn	r3, #0
30011c18:	ea00008b 	b	30011e4c <lwip_setsockopt+0x274>

  if (NULL == optval) {
30011c1c:	e59d3000 	ldr	r3, [sp]
30011c20:	e3530000 	cmp	r3, #0
30011c24:	1a000004 	bne	30011c3c <lwip_setsockopt+0x64>
    sock_set_errno(sock, EFAULT);
30011c28:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011c2c:	e3a0200e 	mov	r2, #14
30011c30:	e5832010 	str	r2, [r3, #16]
    return -1;
30011c34:	e3e03000 	mvn	r3, #0
30011c38:	ea000083 	b	30011e4c <lwip_setsockopt+0x274>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
30011c3c:	e59d3008 	ldr	r3, [sp, #8]
30011c40:	e3530006 	cmp	r3, #6
30011c44:	0a00003b 	beq	30011d38 <lwip_setsockopt+0x160>
30011c48:	e3a02eff 	mov	r2, #4080	; 0xff0
30011c4c:	e282200f 	add	r2, r2, #15
30011c50:	e1530002 	cmp	r3, r2
30011c54:	0a000002 	beq	30011c64 <lwip_setsockopt+0x8c>
30011c58:	e3530000 	cmp	r3, #0
30011c5c:	0a000027 	beq	30011d00 <lwip_setsockopt+0x128>
30011c60:	ea00004a 	b	30011d90 <lwip_setsockopt+0x1b8>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
30011c64:	e59d3004 	ldr	r3, [sp, #4]
30011c68:	e3530020 	cmp	r3, #32
30011c6c:	0a000005 	beq	30011c88 <lwip_setsockopt+0xb0>
30011c70:	e3a02a01 	mov	r2, #4096	; 0x1000
30011c74:	e282200a 	add	r2, r2, #10
30011c78:	e1530002 	cmp	r3, r2
30011c7c:	0a000007 	beq	30011ca0 <lwip_setsockopt+0xc8>
30011c80:	e3530008 	cmp	r3, #8
30011c84:	1a000019 	bne	30011cf0 <lwip_setsockopt+0x118>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
30011c88:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
30011c8c:	e3530003 	cmp	r3, #3
30011c90:	8a000001 	bhi	30011c9c <lwip_setsockopt+0xc4>
        err = EINVAL;
30011c94:	e3a03016 	mov	r3, #22
30011c98:	e58d3034 	str	r3, [sp, #52]	; 0x34
      }
      break;
30011c9c:	ea000016 	b	30011cfc <lwip_setsockopt+0x124>
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
30011ca0:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
30011ca4:	e3530003 	cmp	r3, #3
30011ca8:	8a000001 	bhi	30011cb4 <lwip_setsockopt+0xdc>
        err = EINVAL;
30011cac:	e3a03016 	mov	r3, #22
30011cb0:	e58d3034 	str	r3, [sp, #52]	; 0x34
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
30011cb4:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011cb8:	e5933000 	ldr	r3, [r3]
30011cbc:	e5d33000 	ldrb	r3, [r3]
30011cc0:	e3530020 	cmp	r3, #32
30011cc4:	1a000006 	bne	30011ce4 <lwip_setsockopt+0x10c>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
30011cc8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011ccc:	e5933000 	ldr	r3, [r3]
30011cd0:	e5933004 	ldr	r3, [r3, #4]
30011cd4:	e5d33010 	ldrb	r3, [r3, #16]
30011cd8:	e2033002 	and	r3, r3, #2
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
30011cdc:	e3530000 	cmp	r3, #0
30011ce0:	0a000001 	beq	30011cec <lwip_setsockopt+0x114>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
30011ce4:	e3a03061 	mov	r3, #97	; 0x61
30011ce8:	e58d3034 	str	r3, [sp, #52]	; 0x34
      }
#endif /* LWIP_UDP */
      break;
30011cec:	ea000002 	b	30011cfc <lwip_setsockopt+0x124>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
30011cf0:	e3a0305c 	mov	r3, #92	; 0x5c
30011cf4:	e58d3034 	str	r3, [sp, #52]	; 0x34
    }  /* switch (optname) */
    break;
30011cf8:	ea000026 	b	30011d98 <lwip_setsockopt+0x1c0>
30011cfc:	ea000025 	b	30011d98 <lwip_setsockopt+0x1c0>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
30011d00:	e59d3004 	ldr	r3, [sp, #4]
30011d04:	e2433001 	sub	r3, r3, #1
30011d08:	e3530001 	cmp	r3, #1
30011d0c:	8a000006 	bhi	30011d2c <lwip_setsockopt+0x154>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
30011d10:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
30011d14:	e3530003 	cmp	r3, #3
30011d18:	8a000001 	bhi	30011d24 <lwip_setsockopt+0x14c>
        err = EINVAL;
30011d1c:	e3a03016 	mov	r3, #22
30011d20:	e58d3034 	str	r3, [sp, #52]	; 0x34
      }
      break;
30011d24:	e1a00000 	nop			; (mov r0, r0)
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
30011d28:	ea00001a 	b	30011d98 <lwip_setsockopt+0x1c0>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
30011d2c:	e3a0305c 	mov	r3, #92	; 0x5c
30011d30:	e58d3034 	str	r3, [sp, #52]	; 0x34
    }  /* switch (optname) */
    break;
30011d34:	ea000017 	b	30011d98 <lwip_setsockopt+0x1c0>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
30011d38:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
30011d3c:	e3530003 	cmp	r3, #3
30011d40:	8a000002 	bhi	30011d50 <lwip_setsockopt+0x178>
      err = EINVAL;
30011d44:	e3a03016 	mov	r3, #22
30011d48:	e58d3034 	str	r3, [sp, #52]	; 0x34
      break;
30011d4c:	ea000011 	b	30011d98 <lwip_setsockopt+0x1c0>
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
30011d50:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011d54:	e5933000 	ldr	r3, [r3]
30011d58:	e5d33000 	ldrb	r3, [r3]
30011d5c:	e3530010 	cmp	r3, #16
30011d60:	0a000001 	beq	30011d6c <lwip_setsockopt+0x194>
      return 0;
30011d64:	e3a03000 	mov	r3, #0
30011d68:	ea000037 	b	30011e4c <lwip_setsockopt+0x274>

    switch (optname) {
30011d6c:	e59d3004 	ldr	r3, [sp, #4]
30011d70:	e2433001 	sub	r3, r3, #1
30011d74:	e3530001 	cmp	r3, #1
30011d78:	8a000001 	bhi	30011d84 <lwip_setsockopt+0x1ac>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
30011d7c:	e1a00000 	nop			; (mov r0, r0)
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
30011d80:	ea000004 	b	30011d98 <lwip_setsockopt+0x1c0>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
30011d84:	e3a0305c 	mov	r3, #92	; 0x5c
30011d88:	e58d3034 	str	r3, [sp, #52]	; 0x34
    }  /* switch (optname) */
    break;
30011d8c:	ea000001 	b	30011d98 <lwip_setsockopt+0x1c0>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
30011d90:	e3a0305c 	mov	r3, #92	; 0x5c
30011d94:	e58d3034 	str	r3, [sp, #52]	; 0x34
  }  /* switch (level) */


  if (err != ERR_OK) {
30011d98:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30011d9c:	e3530000 	cmp	r3, #0
30011da0:	0a000004 	beq	30011db8 <lwip_setsockopt+0x1e0>
    sock_set_errno(sock, err);
30011da4:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011da8:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
30011dac:	e5832010 	str	r2, [r3, #16]
    return -1;
30011db0:	e3e03000 	mvn	r3, #0
30011db4:	ea000024 	b	30011e4c <lwip_setsockopt+0x274>
  }


  /* Now do the actual option processing */
  data.sock = sock;
30011db8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011dbc:	e58d3014 	str	r3, [sp, #20]
  data.level = level;
30011dc0:	e59d3008 	ldr	r3, [sp, #8]
30011dc4:	e58d301c 	str	r3, [sp, #28]
  data.optname = optname;
30011dc8:	e59d3004 	ldr	r3, [sp, #4]
30011dcc:	e58d3020 	str	r3, [sp, #32]
  data.optval = (void*)optval;
30011dd0:	e59d3000 	ldr	r3, [sp]
30011dd4:	e58d3024 	str	r3, [sp, #36]	; 0x24
  data.optlen = &optlen;
30011dd8:	e28d3040 	add	r3, sp, #64	; 0x40
30011ddc:	e58d3028 	str	r3, [sp, #40]	; 0x28
  data.err = err;
30011de0:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30011de4:	e20330ff 	and	r3, r3, #255	; 0xff
30011de8:	e5cd302c 	strb	r3, [sp, #44]	; 0x2c
  tcpip_callback(lwip_setsockopt_internal, &data);
30011dec:	e28d3014 	add	r3, sp, #20
30011df0:	e59f0064 	ldr	r0, [pc, #100]	; 30011e5c <lwip_setsockopt+0x284>
30011df4:	e1a01003 	mov	r1, r3
30011df8:	e3a02001 	mov	r2, #1
30011dfc:	eb000230 	bl	300126c4 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
30011e00:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011e04:	e5933000 	ldr	r3, [r3]
30011e08:	e593300c 	ldr	r3, [r3, #12]
30011e0c:	e1a00003 	mov	r0, r3
30011e10:	e3a01000 	mov	r1, #0
30011e14:	ebffeb47 	bl	3000cb38 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
30011e18:	e5dd302c 	ldrb	r3, [sp, #44]	; 0x2c
30011e1c:	e1a03c03 	lsl	r3, r3, #24
30011e20:	e1a03c43 	asr	r3, r3, #24
30011e24:	e58d3034 	str	r3, [sp, #52]	; 0x34

  sock_set_errno(sock, err);
30011e28:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011e2c:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
30011e30:	e5832010 	str	r2, [r3, #16]
  return err ? -1 : 0;
30011e34:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30011e38:	e3530000 	cmp	r3, #0
30011e3c:	0a000001 	beq	30011e48 <lwip_setsockopt+0x270>
30011e40:	e3e03000 	mvn	r3, #0
30011e44:	ea000000 	b	30011e4c <lwip_setsockopt+0x274>
30011e48:	e3a03000 	mov	r3, #0
}
30011e4c:	e1a00003 	mov	r0, r3
30011e50:	e28dd03c 	add	sp, sp, #60	; 0x3c
30011e54:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30011e58:	e12fff1e 	bx	lr
30011e5c:	30011e60 	.word	0x30011e60

30011e60 <lwip_setsockopt_internal>:

static void
lwip_setsockopt_internal(void *arg)
{
30011e60:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30011e64:	e24dd024 	sub	sp, sp, #36	; 0x24
30011e68:	e58d0004 	str	r0, [sp, #4]
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);

  data = (struct lwip_setgetsockopt_data*)arg;
30011e6c:	e59d3004 	ldr	r3, [sp, #4]
30011e70:	e58d301c 	str	r3, [sp, #28]
  sock = data->sock;
30011e74:	e59d301c 	ldr	r3, [sp, #28]
30011e78:	e5933000 	ldr	r3, [r3]
30011e7c:	e58d300c 	str	r3, [sp, #12]
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
30011e80:	e59d301c 	ldr	r3, [sp, #28]
30011e84:	e5933008 	ldr	r3, [r3, #8]
30011e88:	e58d3010 	str	r3, [sp, #16]
  optname = data->optname;
30011e8c:	e59d301c 	ldr	r3, [sp, #28]
30011e90:	e593300c 	ldr	r3, [r3, #12]
30011e94:	e58d3014 	str	r3, [sp, #20]
  optval = data->optval;
30011e98:	e59d301c 	ldr	r3, [sp, #28]
30011e9c:	e5933010 	ldr	r3, [r3, #16]
30011ea0:	e58d3018 	str	r3, [sp, #24]

  switch (level) {
30011ea4:	e59d3010 	ldr	r3, [sp, #16]
30011ea8:	e3530006 	cmp	r3, #6
30011eac:	0a00006a 	beq	3001205c <lwip_setsockopt_internal+0x1fc>
30011eb0:	e3a02eff 	mov	r2, #4080	; 0xff0
30011eb4:	e282200f 	add	r2, r2, #15
30011eb8:	e1530002 	cmp	r3, r2
30011ebc:	0a000002 	beq	30011ecc <lwip_setsockopt_internal+0x6c>
30011ec0:	e3530000 	cmp	r3, #0
30011ec4:	0a00004e 	beq	30012004 <lwip_setsockopt_internal+0x1a4>
30011ec8:	ea00008c 	b	30012100 <lwip_setsockopt_internal+0x2a0>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
30011ecc:	e59d3014 	ldr	r3, [sp, #20]
30011ed0:	e3530020 	cmp	r3, #32
30011ed4:	0a000005 	beq	30011ef0 <lwip_setsockopt_internal+0x90>
30011ed8:	e3a02a01 	mov	r2, #4096	; 0x1000
30011edc:	e282200a 	add	r2, r2, #10
30011ee0:	e1530002 	cmp	r3, r2
30011ee4:	0a00002d 	beq	30011fa0 <lwip_setsockopt_internal+0x140>
30011ee8:	e3530008 	cmp	r3, #8
30011eec:	1a000080 	bne	300120f4 <lwip_setsockopt_internal+0x294>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
30011ef0:	e59d3018 	ldr	r3, [sp, #24]
30011ef4:	e5933000 	ldr	r3, [r3]
30011ef8:	e3530000 	cmp	r3, #0
30011efc:	0a000011 	beq	30011f48 <lwip_setsockopt_internal+0xe8>
        sock->conn->pcb.ip->so_options |= optname;
30011f00:	e59d300c 	ldr	r3, [sp, #12]
30011f04:	e5933000 	ldr	r3, [r3]
30011f08:	e5933004 	ldr	r3, [r3, #4]
30011f0c:	e59d200c 	ldr	r2, [sp, #12]
30011f10:	e5922000 	ldr	r2, [r2]
30011f14:	e5922004 	ldr	r2, [r2, #4]
30011f18:	e1d220b8 	ldrh	r2, [r2, #8]
30011f1c:	e1a01002 	mov	r1, r2
30011f20:	e59d2014 	ldr	r2, [sp, #20]
30011f24:	e1a02802 	lsl	r2, r2, #16
30011f28:	e1a02822 	lsr	r2, r2, #16
30011f2c:	e1812002 	orr	r2, r1, r2
30011f30:	e1a02802 	lsl	r2, r2, #16
30011f34:	e1a02822 	lsr	r2, r2, #16
30011f38:	e1a02802 	lsl	r2, r2, #16
30011f3c:	e1a02822 	lsr	r2, r2, #16
30011f40:	e1c320b8 	strh	r2, [r3, #8]
30011f44:	ea000013 	b	30011f98 <lwip_setsockopt_internal+0x138>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
30011f48:	e59d300c 	ldr	r3, [sp, #12]
30011f4c:	e5933000 	ldr	r3, [r3]
30011f50:	e5933004 	ldr	r3, [r3, #4]
30011f54:	e59d200c 	ldr	r2, [sp, #12]
30011f58:	e5922000 	ldr	r2, [r2]
30011f5c:	e5922004 	ldr	r2, [r2, #4]
30011f60:	e1d220b8 	ldrh	r2, [r2, #8]
30011f64:	e1a01002 	mov	r1, r2
30011f68:	e59d2014 	ldr	r2, [sp, #20]
30011f6c:	e1a02802 	lsl	r2, r2, #16
30011f70:	e1a02822 	lsr	r2, r2, #16
30011f74:	e1e02002 	mvn	r2, r2
30011f78:	e1a02802 	lsl	r2, r2, #16
30011f7c:	e1a02822 	lsr	r2, r2, #16
30011f80:	e0012002 	and	r2, r1, r2
30011f84:	e1a02802 	lsl	r2, r2, #16
30011f88:	e1a02822 	lsr	r2, r2, #16
30011f8c:	e1a02802 	lsl	r2, r2, #16
30011f90:	e1a02822 	lsr	r2, r2, #16
30011f94:	e1c320b8 	strh	r2, [r3, #8]
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
30011f98:	e1a00000 	nop			; (mov r0, r0)
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
30011f9c:	ea000057 	b	30012100 <lwip_setsockopt_internal+0x2a0>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
30011fa0:	e59d3018 	ldr	r3, [sp, #24]
30011fa4:	e5933000 	ldr	r3, [r3]
30011fa8:	e3530000 	cmp	r3, #0
30011fac:	0a00000a 	beq	30011fdc <lwip_setsockopt_internal+0x17c>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
30011fb0:	e59d300c 	ldr	r3, [sp, #12]
30011fb4:	e5933000 	ldr	r3, [r3]
30011fb8:	e5933004 	ldr	r3, [r3, #4]
30011fbc:	e59d200c 	ldr	r2, [sp, #12]
30011fc0:	e5922000 	ldr	r2, [r2]
30011fc4:	e5922004 	ldr	r2, [r2, #4]
30011fc8:	e5d22010 	ldrb	r2, [r2, #16]
30011fcc:	e3822001 	orr	r2, r2, #1
30011fd0:	e20220ff 	and	r2, r2, #255	; 0xff
30011fd4:	e5c32010 	strb	r2, [r3, #16]
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
30011fd8:	ea000048 	b	30012100 <lwip_setsockopt_internal+0x2a0>
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
30011fdc:	e59d300c 	ldr	r3, [sp, #12]
30011fe0:	e5933000 	ldr	r3, [r3]
30011fe4:	e5932004 	ldr	r2, [r3, #4]
30011fe8:	e59d300c 	ldr	r3, [sp, #12]
30011fec:	e5933000 	ldr	r3, [r3]
30011ff0:	e5933004 	ldr	r3, [r3, #4]
30011ff4:	e5d33010 	ldrb	r3, [r3, #16]
30011ff8:	e20330fe 	and	r3, r3, #254	; 0xfe
30011ffc:	e5c23010 	strb	r3, [r2, #16]
      }
      break;
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
30012000:	ea00003e 	b	30012100 <lwip_setsockopt_internal+0x2a0>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
30012004:	e59d3014 	ldr	r3, [sp, #20]
30012008:	e3530001 	cmp	r3, #1
3001200c:	0a00000a 	beq	3001203c <lwip_setsockopt_internal+0x1dc>
30012010:	e3530002 	cmp	r3, #2
30012014:	1a000038 	bne	300120fc <lwip_setsockopt_internal+0x29c>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
30012018:	e59d300c 	ldr	r3, [sp, #12]
3001201c:	e5933000 	ldr	r3, [r3]
30012020:	e5933004 	ldr	r3, [r3, #4]
30012024:	e59d2018 	ldr	r2, [sp, #24]
30012028:	e5922000 	ldr	r2, [r2]
3001202c:	e20220ff 	and	r2, r2, #255	; 0xff
30012030:	e5c3200b 	strb	r2, [r3, #11]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
30012034:	e1a00000 	nop			; (mov r0, r0)
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
30012038:	ea000030 	b	30012100 <lwip_setsockopt_internal+0x2a0>
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
3001203c:	e59d300c 	ldr	r3, [sp, #12]
30012040:	e5933000 	ldr	r3, [r3]
30012044:	e5933004 	ldr	r3, [r3, #4]
30012048:	e59d2018 	ldr	r2, [sp, #24]
3001204c:	e5922000 	ldr	r2, [r2]
30012050:	e20220ff 	and	r2, r2, #255	; 0xff
30012054:	e5c3200a 	strb	r2, [r3, #10]
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
30012058:	ea000028 	b	30012100 <lwip_setsockopt_internal+0x2a0>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
3001205c:	e59d3014 	ldr	r3, [sp, #20]
30012060:	e3530001 	cmp	r3, #1
30012064:	0a000002 	beq	30012074 <lwip_setsockopt_internal+0x214>
30012068:	e3530002 	cmp	r3, #2
3001206c:	0a000019 	beq	300120d8 <lwip_setsockopt_internal+0x278>
30012070:	ea000022 	b	30012100 <lwip_setsockopt_internal+0x2a0>
    case TCP_NODELAY:
      if (*(int*)optval) {
30012074:	e59d3018 	ldr	r3, [sp, #24]
30012078:	e5933000 	ldr	r3, [r3]
3001207c:	e3530000 	cmp	r3, #0
30012080:	0a00000a 	beq	300120b0 <lwip_setsockopt_internal+0x250>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
30012084:	e59d300c 	ldr	r3, [sp, #12]
30012088:	e5933000 	ldr	r3, [r3]
3001208c:	e5933004 	ldr	r3, [r3, #4]
30012090:	e59d200c 	ldr	r2, [sp, #12]
30012094:	e5922000 	ldr	r2, [r2]
30012098:	e5922004 	ldr	r2, [r2, #4]
3001209c:	e5d2201c 	ldrb	r2, [r2, #28]
300120a0:	e3822040 	orr	r2, r2, #64	; 0x40
300120a4:	e20220ff 	and	r2, r2, #255	; 0xff
300120a8:	e5c3201c 	strb	r2, [r3, #28]
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
300120ac:	ea000013 	b	30012100 <lwip_setsockopt_internal+0x2a0>
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
300120b0:	e59d300c 	ldr	r3, [sp, #12]
300120b4:	e5933000 	ldr	r3, [r3]
300120b8:	e5932004 	ldr	r2, [r3, #4]
300120bc:	e59d300c 	ldr	r3, [sp, #12]
300120c0:	e5933000 	ldr	r3, [r3]
300120c4:	e5933004 	ldr	r3, [r3, #4]
300120c8:	e5d3301c 	ldrb	r3, [r3, #28]
300120cc:	e20330bf 	and	r3, r3, #191	; 0xbf
300120d0:	e5c2301c 	strb	r3, [r2, #28]
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
300120d4:	ea000009 	b	30012100 <lwip_setsockopt_internal+0x2a0>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
300120d8:	e59d300c 	ldr	r3, [sp, #12]
300120dc:	e5933000 	ldr	r3, [r3]
300120e0:	e5933004 	ldr	r3, [r3, #4]
300120e4:	e59d2018 	ldr	r2, [sp, #24]
300120e8:	e5922000 	ldr	r2, [r2]
300120ec:	e5832098 	str	r2, [r3, #152]	; 0x98
300120f0:	ea000002 	b	30012100 <lwip_setsockopt_internal+0x2a0>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
300120f4:	e1a00000 	nop			; (mov r0, r0)
300120f8:	ea000000 	b	30012100 <lwip_setsockopt_internal+0x2a0>
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
300120fc:	e1a00000 	nop			; (mov r0, r0)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
30012100:	e59d300c 	ldr	r3, [sp, #12]
30012104:	e5933000 	ldr	r3, [r3]
30012108:	e593300c 	ldr	r3, [r3, #12]
3001210c:	e1a00003 	mov	r0, r3
30012110:	ebffea80 	bl	3000cb18 <sys_sem_signal>
}
30012114:	e28dd024 	add	sp, sp, #36	; 0x24
30012118:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001211c:	e12fff1e 	bx	lr

30012120 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
30012120:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30012124:	e24dd024 	sub	sp, sp, #36	; 0x24
30012128:	e58d000c 	str	r0, [sp, #12]
3001212c:	e58d1008 	str	r1, [sp, #8]
30012130:	e58d2004 	str	r2, [sp, #4]
  struct lwip_socket *sock = get_socket(s);
30012134:	e59d000c 	ldr	r0, [sp, #12]
30012138:	ebfff5e6 	bl	3000f8d8 <get_socket>
3001213c:	e1a03000 	mov	r3, r0
30012140:	e58d3014 	str	r3, [sp, #20]
  u16_t buflen = 0;
30012144:	e3a03000 	mov	r3, #0
30012148:	e1cd31ba 	strh	r3, [sp, #26]

  if (!sock)
3001214c:	e59d3014 	ldr	r3, [sp, #20]
30012150:	e3530000 	cmp	r3, #0
30012154:	1a000001 	bne	30012160 <lwip_ioctl+0x40>
    return -1;
30012158:	e3e03000 	mvn	r3, #0
3001215c:	ea000056 	b	300122bc <lwip_ioctl+0x19c>

  switch (cmd) {
30012160:	e59d2008 	ldr	r2, [sp, #8]
30012164:	e3a03a46 	mov	r3, #286720	; 0x46000
30012168:	e2833e67 	add	r3, r3, #1648	; 0x670
3001216c:	e283313a 	add	r3, r3, #-2147483634	; 0x8000000e
30012170:	e1520003 	cmp	r2, r3
30012174:	0a000031 	beq	30012240 <lwip_ioctl+0x120>
30012178:	e3a03a46 	mov	r3, #286720	; 0x46000
3001217c:	e2833e67 	add	r3, r3, #1648	; 0x670
30012180:	e283313d 	add	r3, r3, #1073741839	; 0x4000000f
30012184:	e1520003 	cmp	r2, r3
30012188:	1a000047 	bne	300122ac <lwip_ioctl+0x18c>
  case FIONREAD:
    if (!argp) {
3001218c:	e59d3004 	ldr	r3, [sp, #4]
30012190:	e3530000 	cmp	r3, #0
30012194:	1a000004 	bne	300121ac <lwip_ioctl+0x8c>
      sock_set_errno(sock, EINVAL);
30012198:	e59d3014 	ldr	r3, [sp, #20]
3001219c:	e3a02016 	mov	r2, #22
300121a0:	e5832010 	str	r2, [r3, #16]
      return -1;
300121a4:	e3e03000 	mvn	r3, #0
300121a8:	ea000043 	b	300122bc <lwip_ioctl+0x19c>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
300121ac:	ebffbd50 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300121b0:	e1a03000 	mov	r3, r0
300121b4:	e58d301c 	str	r3, [sp, #28]
300121b8:	e59d3004 	ldr	r3, [sp, #4]
300121bc:	e59d2014 	ldr	r2, [sp, #20]
300121c0:	e5922000 	ldr	r2, [r2]
300121c4:	e1d221bc 	ldrh	r2, [r2, #28]
300121c8:	e1c320b0 	strh	r2, [r3]
300121cc:	e59d001c 	ldr	r0, [sp, #28]
300121d0:	ebffbd45 	bl	300016ec <HAL_INTR_RESTORE>

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
300121d4:	e59d3014 	ldr	r3, [sp, #20]
300121d8:	e5933004 	ldr	r3, [r3, #4]
300121dc:	e3530000 	cmp	r3, #0
300121e0:	0a000011 	beq	3001222c <lwip_ioctl+0x10c>
      buflen = netbuf_len(sock->lastdata);
300121e4:	e59d3014 	ldr	r3, [sp, #20]
300121e8:	e5933004 	ldr	r3, [r3, #4]
300121ec:	e5933000 	ldr	r3, [r3]
300121f0:	e1d330b8 	ldrh	r3, [r3, #8]
300121f4:	e1cd31ba 	strh	r3, [sp, #26]
      buflen -= sock->lastoffset;
300121f8:	e59d3014 	ldr	r3, [sp, #20]
300121fc:	e1d330b8 	ldrh	r3, [r3, #8]
30012200:	e1dd21ba 	ldrh	r2, [sp, #26]
30012204:	e0633002 	rsb	r3, r3, r2
30012208:	e1cd31ba 	strh	r3, [sp, #26]

      *((u16_t*)argp) += buflen;
3001220c:	e59d3004 	ldr	r3, [sp, #4]
30012210:	e59d2004 	ldr	r2, [sp, #4]
30012214:	e1d210b0 	ldrh	r1, [r2]
30012218:	e1dd21ba 	ldrh	r2, [sp, #26]
3001221c:	e0812002 	add	r2, r1, r2
30012220:	e1a02802 	lsl	r2, r2, #16
30012224:	e1a02822 	lsr	r2, r2, #16
30012228:	e1c320b0 	strh	r2, [r3]
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
3001222c:	e59d3014 	ldr	r3, [sp, #20]
30012230:	e3a02000 	mov	r2, #0
30012234:	e5832010 	str	r2, [r3, #16]
    return 0;
30012238:	e3a03000 	mov	r3, #0
3001223c:	ea00001e 	b	300122bc <lwip_ioctl+0x19c>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
30012240:	e59d3004 	ldr	r3, [sp, #4]
30012244:	e3530000 	cmp	r3, #0
30012248:	0a00000b 	beq	3001227c <lwip_ioctl+0x15c>
3001224c:	e59d3004 	ldr	r3, [sp, #4]
30012250:	e5933000 	ldr	r3, [r3]
30012254:	e3530000 	cmp	r3, #0
30012258:	0a000007 	beq	3001227c <lwip_ioctl+0x15c>
      sock->flags |= O_NONBLOCK;
3001225c:	e59d3014 	ldr	r3, [sp, #20]
30012260:	e1d330be 	ldrh	r3, [r3, #14]
30012264:	e3833b02 	orr	r3, r3, #2048	; 0x800
30012268:	e1a03803 	lsl	r3, r3, #16
3001226c:	e1a02823 	lsr	r2, r3, #16
30012270:	e59d3014 	ldr	r3, [sp, #20]
30012274:	e1c320be 	strh	r2, [r3, #14]
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
    return 0;

  case FIONBIO:
    if (argp && *(u32_t*)argp)
30012278:	ea000006 	b	30012298 <lwip_ioctl+0x178>
      sock->flags |= O_NONBLOCK;
    else
      sock->flags &= ~O_NONBLOCK;
3001227c:	e59d3014 	ldr	r3, [sp, #20]
30012280:	e1d330be 	ldrh	r3, [r3, #14]
30012284:	e3c33b02 	bic	r3, r3, #2048	; 0x800
30012288:	e1a03803 	lsl	r3, r3, #16
3001228c:	e1a03823 	lsr	r3, r3, #16
30012290:	e59d2014 	ldr	r2, [sp, #20]
30012294:	e1c230be 	strh	r3, [r2, #14]
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
30012298:	e59d3014 	ldr	r3, [sp, #20]
3001229c:	e3a02000 	mov	r2, #0
300122a0:	e5832010 	str	r2, [r3, #16]
    return 0;
300122a4:	e3a03000 	mov	r3, #0
300122a8:	ea000003 	b	300122bc <lwip_ioctl+0x19c>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
300122ac:	e59d3014 	ldr	r3, [sp, #20]
300122b0:	e3a02026 	mov	r2, #38	; 0x26
300122b4:	e5832010 	str	r2, [r3, #16]
    return -1;
300122b8:	e3e03000 	mvn	r3, #0
  } /* switch (cmd) */
}
300122bc:	e1a00003 	mov	r0, r3
300122c0:	e28dd024 	add	sp, sp, #36	; 0x24
300122c4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300122c8:	e12fff1e 	bx	lr

300122cc <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
300122cc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300122d0:	e24dd00c 	sub	sp, sp, #12
300122d4:	e58d0004 	str	r0, [sp, #4]
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
300122d8:	eb001509 	bl	30017704 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
300122dc:	e59f3044 	ldr	r3, [pc, #68]	; 30012328 <tcpip_tcp_timer+0x5c>
300122e0:	e5933000 	ldr	r3, [r3]
300122e4:	e3530000 	cmp	r3, #0
300122e8:	1a000003 	bne	300122fc <tcpip_tcp_timer+0x30>
300122ec:	e59f3038 	ldr	r3, [pc, #56]	; 3001232c <tcpip_tcp_timer+0x60>
300122f0:	e5933000 	ldr	r3, [r3]
300122f4:	e3530000 	cmp	r3, #0
300122f8:	0a000004 	beq	30012310 <tcpip_tcp_timer+0x44>
    /* restart timer */
     sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
300122fc:	e3a000fa 	mov	r0, #250	; 0xfa
30012300:	e59f1028 	ldr	r1, [pc, #40]	; 30012330 <tcpip_tcp_timer+0x64>
30012304:	e3a02000 	mov	r2, #0
30012308:	eb0013fe 	bl	30017308 <sys_timeout>
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
3001230c:	ea000002 	b	3001231c <tcpip_tcp_timer+0x50>
    /* restart timer */
     sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
30012310:	e59f301c 	ldr	r3, [pc, #28]	; 30012334 <tcpip_tcp_timer+0x68>
30012314:	e3a02000 	mov	r2, #0
30012318:	e5832000 	str	r2, [r3]
  }
}
3001231c:	e28dd00c 	add	sp, sp, #12
30012320:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30012324:	e12fff1e 	bx	lr
30012328:	3002a6e8 	.word	0x3002a6e8
3001232c:	3002b1c4 	.word	0x3002b1c4
30012330:	300122cc 	.word	0x300122cc
30012334:	30027210 	.word	0x30027210

30012338 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
30012338:	e92d4008 	push	{r3, lr}
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
3001233c:	e59f304c 	ldr	r3, [pc, #76]	; 30012390 <tcp_timer_needed+0x58>
30012340:	e5933000 	ldr	r3, [r3]
30012344:	e3530000 	cmp	r3, #0
30012348:	1a00000e 	bne	30012388 <tcp_timer_needed+0x50>
3001234c:	e59f3040 	ldr	r3, [pc, #64]	; 30012394 <tcp_timer_needed+0x5c>
30012350:	e5933000 	ldr	r3, [r3]
30012354:	e3530000 	cmp	r3, #0
30012358:	1a000003 	bne	3001236c <tcp_timer_needed+0x34>
3001235c:	e59f3034 	ldr	r3, [pc, #52]	; 30012398 <tcp_timer_needed+0x60>
30012360:	e5933000 	ldr	r3, [r3]
30012364:	e3530000 	cmp	r3, #0
30012368:	0a000006 	beq	30012388 <tcp_timer_needed+0x50>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
3001236c:	e59f301c 	ldr	r3, [pc, #28]	; 30012390 <tcp_timer_needed+0x58>
30012370:	e3a02001 	mov	r2, #1
30012374:	e5832000 	str	r2, [r3]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
30012378:	e3a000fa 	mov	r0, #250	; 0xfa
3001237c:	e59f1018 	ldr	r1, [pc, #24]	; 3001239c <tcp_timer_needed+0x64>
30012380:	e3a02000 	mov	r2, #0
30012384:	eb0013df 	bl	30017308 <sys_timeout>
  }
}
30012388:	e8bd4008 	pop	{r3, lr}
3001238c:	e12fff1e 	bx	lr
30012390:	30027210 	.word	0x30027210
30012394:	3002a6e8 	.word	0x3002a6e8
30012398:	3002b1c4 	.word	0x3002b1c4
3001239c:	300122cc 	.word	0x300122cc

300123a0 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
300123a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300123a4:	e24dd00c 	sub	sp, sp, #12
300123a8:	e58d0004 	str	r0, [sp, #4]
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
300123ac:	eb003ce4 	bl	30021744 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
300123b0:	e3a00d4e 	mov	r0, #4992	; 0x1380
300123b4:	e2800008 	add	r0, r0, #8
300123b8:	e59f1010 	ldr	r1, [pc, #16]	; 300123d0 <arp_timer+0x30>
300123bc:	e3a02000 	mov	r2, #0
300123c0:	eb0013d0 	bl	30017308 <sys_timeout>
}
300123c4:	e28dd00c 	add	sp, sp, #12
300123c8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300123cc:	e12fff1e 	bx	lr
300123d0:	300123a0 	.word	0x300123a0

300123d4 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
300123d4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300123d8:	e24dd014 	sub	sp, sp, #20
300123dc:	e58d0004 	str	r0, [sp, #4]

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
300123e0:	e3a00d4e 	mov	r0, #4992	; 0x1380
300123e4:	e2800008 	add	r0, r0, #8
300123e8:	e59f11a4 	ldr	r1, [pc, #420]	; 30012594 <tcpip_thread+0x1c0>
300123ec:	e3a02000 	mov	r2, #0
300123f0:	eb0013c4 	bl	30017308 <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
300123f4:	e59f319c 	ldr	r3, [pc, #412]	; 30012598 <tcpip_thread+0x1c4>
300123f8:	e5933000 	ldr	r3, [r3]
300123fc:	e3530000 	cmp	r3, #0
30012400:	0a000008 	beq	30012428 <tcpip_thread+0x54>
    tcpip_init_done(tcpip_init_done_arg);
30012404:	e59f318c 	ldr	r3, [pc, #396]	; 30012598 <tcpip_thread+0x1c4>
30012408:	e5933000 	ldr	r3, [r3]
3001240c:	e59f2188 	ldr	r2, [pc, #392]	; 3001259c <tcpip_thread+0x1c8>
30012410:	e5922000 	ldr	r2, [r2]
30012414:	e1a00002 	mov	r0, r2
30012418:	e1a0e00f 	mov	lr, pc
3001241c:	e12fff13 	bx	r3
30012420:	ea000000 	b	30012428 <tcpip_thread+0x54>

    default:
      //lwip_printf("\r\n6\r\n");
      break;
    }
  }
30012424:	e1a00000 	nop			; (mov r0, r0)
    tcpip_init_done(tcpip_init_done_arg);
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
30012428:	e59f3170 	ldr	r3, [pc, #368]	; 300125a0 <tcpip_thread+0x1cc>
3001242c:	e5932000 	ldr	r2, [r3]
30012430:	e28d300c 	add	r3, sp, #12
30012434:	e1a00002 	mov	r0, r2
30012438:	e1a01003 	mov	r1, r3
3001243c:	eb001304 	bl	30017054 <sys_mbox_fetch>
    // teset by pegasus
    //if (msg->msg.apimsg->msg.msg.w.dataptr == &htmldata)
    //  acoral_print("\nhtmldata:\n");//*,msg->msg.apimsg->msg.msg.w.dataptr);
    switch (msg->type) {
30012440:	e59d300c 	ldr	r3, [sp, #12]
30012444:	e5d33000 	ldrb	r3, [r3]
30012448:	e3530003 	cmp	r3, #3
3001244c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30012450:	eafffff3 	b	30012424 <tcpip_thread+0x50>
30012454:	30012464 	.word	0x30012464
30012458:	3001248c 	.word	0x3001248c
3001245c:	300124f4 	.word	0x300124f4
30012460:	30012524 	.word	0x30012524
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      //lwip_printf("\r\n1\r\n");
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
30012464:	e59d300c 	ldr	r3, [sp, #12]
30012468:	e5933008 	ldr	r3, [r3, #8]
3001246c:	e5933000 	ldr	r3, [r3]
30012470:	e59d200c 	ldr	r2, [sp, #12]
30012474:	e5922008 	ldr	r2, [r2, #8]
30012478:	e2822004 	add	r2, r2, #4
3001247c:	e1a00002 	mov	r0, r2
30012480:	e1a0e00f 	mov	lr, pc
30012484:	e12fff13 	bx	r3
      //acoral_print("\r\n%x\r\n",msg->msg.apimsg->function);

      //acoral_print("MSG_API:%s",msg->msg.apimsg->msg.w.dataptr);
      
      break;
30012488:	ea000040 	b	30012590 <tcpip_thread+0x1bc>

    case TCPIP_MSG_INPKT:
      //lwip_printf("\r\n2\r\n");
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
3001248c:	e59d300c 	ldr	r3, [sp, #12]
30012490:	e593300c 	ldr	r3, [r3, #12]
30012494:	e5d3302a 	ldrb	r3, [r3, #42]	; 0x2a
30012498:	e2033020 	and	r3, r3, #32
3001249c:	e3530000 	cmp	r3, #0
300124a0:	0a000007 	beq	300124c4 <tcpip_thread+0xf0>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
300124a4:	e59d300c 	ldr	r3, [sp, #12]
300124a8:	e5932008 	ldr	r2, [r3, #8]
300124ac:	e59d300c 	ldr	r3, [sp, #12]
300124b0:	e593300c 	ldr	r3, [r3, #12]
300124b4:	e1a00002 	mov	r0, r2
300124b8:	e1a01003 	mov	r1, r3
300124bc:	eb0043bd 	bl	300233b8 <ethernet_input>
300124c0:	ea000006 	b	300124e0 <tcpip_thread+0x10c>
      } else
#endif /* LWIP_ARP */
      {//acoral_print("\nip_input:222\n");
       ip_input(msg->msg.inp.p, msg->msg.inp.netif);
300124c4:	e59d300c 	ldr	r3, [sp, #12]
300124c8:	e5932008 	ldr	r2, [r3, #8]
300124cc:	e59d300c 	ldr	r3, [sp, #12]
300124d0:	e593300c 	ldr	r3, [r3, #12]
300124d4:	e1a00002 	mov	r0, r2
300124d8:	e1a01003 	mov	r1, r3
300124dc:	eb000790 	bl	30014324 <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
300124e0:	e59d300c 	ldr	r3, [sp, #12]
300124e4:	e3a00008 	mov	r0, #8
300124e8:	e1a01003 	mov	r1, r3
300124ec:	eb000ca4 	bl	30015784 <memp_free>
      break;
300124f0:	ea000026 	b	30012590 <tcpip_thread+0x1bc>
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      //lwip_printf("\r\n4\r\n");
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
300124f4:	e59d300c 	ldr	r3, [sp, #12]
300124f8:	e5933008 	ldr	r3, [r3, #8]
300124fc:	e59d200c 	ldr	r2, [sp, #12]
30012500:	e592200c 	ldr	r2, [r2, #12]
30012504:	e1a00002 	mov	r0, r2
30012508:	e1a0e00f 	mov	lr, pc
3001250c:	e12fff13 	bx	r3
      memp_free(MEMP_TCPIP_MSG_API, msg);
30012510:	e59d300c 	ldr	r3, [sp, #12]
30012514:	e3a00007 	mov	r0, #7
30012518:	e1a01003 	mov	r1, r3
3001251c:	eb000c98 	bl	30015784 <memp_free>
      break;
30012520:	ea00001a 	b	30012590 <tcpip_thread+0x1bc>

    case TCPIP_MSG_TIMEOUT:
      //lwip_printf("\r\n5\r\n");
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
30012524:	e59d300c 	ldr	r3, [sp, #12]
30012528:	e5933008 	ldr	r3, [r3, #8]
3001252c:	e3730001 	cmn	r3, #1
30012530:	0a00000a 	beq	30012560 <tcpip_thread+0x18c>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
30012534:	e59d300c 	ldr	r3, [sp, #12]
30012538:	e5931008 	ldr	r1, [r3, #8]
3001253c:	e59d300c 	ldr	r3, [sp, #12]
30012540:	e593200c 	ldr	r2, [r3, #12]
30012544:	e59d300c 	ldr	r3, [sp, #12]
30012548:	e5933010 	ldr	r3, [r3, #16]
3001254c:	e1a00001 	mov	r0, r1
30012550:	e1a01002 	mov	r1, r2
30012554:	e1a02003 	mov	r2, r3
30012558:	eb00136a 	bl	30017308 <sys_timeout>
3001255c:	ea000006 	b	3001257c <tcpip_thread+0x1a8>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
30012560:	e59d300c 	ldr	r3, [sp, #12]
30012564:	e593200c 	ldr	r2, [r3, #12]
30012568:	e59d300c 	ldr	r3, [sp, #12]
3001256c:	e5933010 	ldr	r3, [r3, #16]
30012570:	e1a00002 	mov	r0, r2
30012574:	e1a01003 	mov	r1, r3
30012578:	eb0013d6 	bl	300174d8 <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
3001257c:	e59d300c 	ldr	r3, [sp, #12]
30012580:	e3a00007 	mov	r0, #7
30012584:	e1a01003 	mov	r1, r3
30012588:	eb000c7d 	bl	30015784 <memp_free>

    default:
      //lwip_printf("\r\n6\r\n");
      break;
    }
  }
3001258c:	eaffffa5 	b	30012428 <tcpip_thread+0x54>
30012590:	eaffffa4 	b	30012428 <tcpip_thread+0x54>
30012594:	300123a0 	.word	0x300123a0
30012598:	30027204 	.word	0x30027204
3001259c:	30027208 	.word	0x30027208
300125a0:	3002720c 	.word	0x3002720c

300125a4 <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
300125a4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300125a8:	e24dd024 	sub	sp, sp, #36	; 0x24
300125ac:	e58d0004 	str	r0, [sp, #4]
300125b0:	e58d1000 	str	r1, [sp]
  struct tcpip_msg *msg;
	//===============
	// test by pegasus
	  struct pbuf *q;
	  int i, plen = p->tot_len;
300125b4:	e59d3004 	ldr	r3, [sp, #4]
300125b8:	e1d330b8 	ldrh	r3, [r3, #8]
300125bc:	e58d3018 	str	r3, [sp, #24]
	  char* dat;
	//===============

   	
		// 调试打印接收信息
		lwip_printf("\r\n********tcpip_input*************\r\n");
300125c0:	e59f00e0 	ldr	r0, [pc, #224]	; 300126a8 <tcpip_input+0x104>
300125c4:	ebffe397 	bl	3000b428 <acoral_print>
		lwip_printf("接收数据长度:%d <--->\r\n",plen);
300125c8:	e59f00dc 	ldr	r0, [pc, #220]	; 300126ac <tcpip_input+0x108>
300125cc:	e59d1018 	ldr	r1, [sp, #24]
300125d0:	ebffe394 	bl	3000b428 <acoral_print>
		for (q = p; q!=NULL; q = q->next)
300125d4:	e59d3004 	ldr	r3, [sp, #4]
300125d8:	e58d3010 	str	r3, [sp, #16]
300125dc:	ea000029 	b	30012688 <tcpip_input+0xe4>
		{
			dat = (char*)q->payload;
300125e0:	e59d3010 	ldr	r3, [sp, #16]
300125e4:	e5933004 	ldr	r3, [r3, #4]
300125e8:	e58d301c 	str	r3, [sp, #28]
			plen= q->len;
300125ec:	e59d3010 	ldr	r3, [sp, #16]
300125f0:	e1d330ba 	ldrh	r3, [r3, #10]
300125f4:	e58d3018 	str	r3, [sp, #24]
			for(i=0;i<plen;i++)
300125f8:	e3a03000 	mov	r3, #0
300125fc:	e58d3014 	str	r3, [sp, #20]
30012600:	ea000017 	b	30012664 <tcpip_input+0xc0>
			{
				lwip_printf("%4x ",dat[i]);
30012604:	e59d2014 	ldr	r2, [sp, #20]
30012608:	e59d301c 	ldr	r3, [sp, #28]
3001260c:	e0823003 	add	r3, r2, r3
30012610:	e5d33000 	ldrb	r3, [r3]
30012614:	e59f0094 	ldr	r0, [pc, #148]	; 300126b0 <tcpip_input+0x10c>
30012618:	e1a01003 	mov	r1, r3
3001261c:	ebffe381 	bl	3000b428 <acoral_print>
				if((i%6)==5) lwip_printf("\r\n");
30012620:	e59d1014 	ldr	r1, [sp, #20]
30012624:	e59f3088 	ldr	r3, [pc, #136]	; 300126b4 <tcpip_input+0x110>
30012628:	e0c20193 	smull	r0, r2, r3, r1
3001262c:	e1a03fc1 	asr	r3, r1, #31
30012630:	e0632002 	rsb	r2, r3, r2
30012634:	e1a03002 	mov	r3, r2
30012638:	e1a03083 	lsl	r3, r3, #1
3001263c:	e0833002 	add	r3, r3, r2
30012640:	e1a03083 	lsl	r3, r3, #1
30012644:	e0632001 	rsb	r2, r3, r1
30012648:	e3520005 	cmp	r2, #5
3001264c:	1a000001 	bne	30012658 <tcpip_input+0xb4>
30012650:	e59f0060 	ldr	r0, [pc, #96]	; 300126b8 <tcpip_input+0x114>
30012654:	ebffe373 	bl	3000b428 <acoral_print>
		lwip_printf("接收数据长度:%d <--->\r\n",plen);
		for (q = p; q!=NULL; q = q->next)
		{
			dat = (char*)q->payload;
			plen= q->len;
			for(i=0;i<plen;i++)
30012658:	e59d3014 	ldr	r3, [sp, #20]
3001265c:	e2833001 	add	r3, r3, #1
30012660:	e58d3014 	str	r3, [sp, #20]
30012664:	e59d2014 	ldr	r2, [sp, #20]
30012668:	e59d3018 	ldr	r3, [sp, #24]
3001266c:	e1520003 	cmp	r2, r3
30012670:	baffffe3 	blt	30012604 <tcpip_input+0x60>
			{
				lwip_printf("%4x ",dat[i]);
				if((i%6)==5) lwip_printf("\r\n");
			}
			lwip_printf("\r\n<*<*<*>*>*>\r\n");
30012674:	e59f0040 	ldr	r0, [pc, #64]	; 300126bc <tcpip_input+0x118>
30012678:	ebffe36a 	bl	3000b428 <acoral_print>

   	
		// 调试打印接收信息
		lwip_printf("\r\n********tcpip_input*************\r\n");
		lwip_printf("接收数据长度:%d <--->\r\n",plen);
		for (q = p; q!=NULL; q = q->next)
3001267c:	e59d3010 	ldr	r3, [sp, #16]
30012680:	e5933000 	ldr	r3, [r3]
30012684:	e58d3010 	str	r3, [sp, #16]
30012688:	e59d3010 	ldr	r3, [sp, #16]
3001268c:	e3530000 	cmp	r3, #0
30012690:	1affffd2 	bne	300125e0 <tcpip_input+0x3c>
				if((i%6)==5) lwip_printf("\r\n");
			}
			lwip_printf("\r\n<*<*<*>*>*>\r\n");

		}
		lwip_printf("\r\n+++++++++++++++++++++\r\n");
30012694:	e59f0024 	ldr	r0, [pc, #36]	; 300126c0 <tcpip_input+0x11c>
30012698:	ebffe362 	bl	3000b428 <acoral_print>
  //     return ERR_MEM;
  //   }
  //   return ERR_OK;
  // }
  // return ERR_VAL;
}
3001269c:	e28dd024 	add	sp, sp, #36	; 0x24
300126a0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300126a4:	e12fff1e 	bx	lr
300126a8:	300264d4 	.word	0x300264d4
300126ac:	300264fc 	.word	0x300264fc
300126b0:	3002651c 	.word	0x3002651c
300126b4:	2aaaaaab 	.word	0x2aaaaaab
300126b8:	30026524 	.word	0x30026524
300126bc:	30026528 	.word	0x30026528
300126c0:	30026538 	.word	0x30026538

300126c4 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
300126c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300126c8:	e24dd01c 	sub	sp, sp, #28
300126cc:	e58d000c 	str	r0, [sp, #12]
300126d0:	e58d1008 	str	r1, [sp, #8]
300126d4:	e1a03002 	mov	r3, r2
300126d8:	e5cd3007 	strb	r3, [sp, #7]
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
300126dc:	e59f30d0 	ldr	r3, [pc, #208]	; 300127b4 <tcpip_callback_with_block+0xf0>
300126e0:	e5933000 	ldr	r3, [r3]
300126e4:	e3530000 	cmp	r3, #0
300126e8:	0a00002a 	beq	30012798 <tcpip_callback_with_block+0xd4>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
300126ec:	e3a00007 	mov	r0, #7
300126f0:	eb000bbe 	bl	300155f0 <memp_malloc>
300126f4:	e1a03000 	mov	r3, r0
300126f8:	e58d3014 	str	r3, [sp, #20]
    if (msg == NULL) {
300126fc:	e59d3014 	ldr	r3, [sp, #20]
30012700:	e3530000 	cmp	r3, #0
30012704:	1a000001 	bne	30012710 <tcpip_callback_with_block+0x4c>
      return ERR_MEM;
30012708:	e3a030ff 	mov	r3, #255	; 0xff
3001270c:	ea000022 	b	3001279c <tcpip_callback_with_block+0xd8>
    }

    msg->type = TCPIP_MSG_CALLBACK;
30012710:	e59d3014 	ldr	r3, [sp, #20]
30012714:	e3a02002 	mov	r2, #2
30012718:	e5c32000 	strb	r2, [r3]
    msg->msg.cb.f = f;
3001271c:	e59d3014 	ldr	r3, [sp, #20]
30012720:	e59d200c 	ldr	r2, [sp, #12]
30012724:	e5832008 	str	r2, [r3, #8]
    msg->msg.cb.ctx = ctx;
30012728:	e59d3014 	ldr	r3, [sp, #20]
3001272c:	e59d2008 	ldr	r2, [sp, #8]
30012730:	e583200c 	str	r2, [r3, #12]
    if (block) {
30012734:	e5dd3007 	ldrb	r3, [sp, #7]
30012738:	e3530000 	cmp	r3, #0
3001273c:	0a000005 	beq	30012758 <tcpip_callback_with_block+0x94>
      sys_mbox_post(mbox, msg);
30012740:	e59f306c 	ldr	r3, [pc, #108]	; 300127b4 <tcpip_callback_with_block+0xf0>
30012744:	e5933000 	ldr	r3, [r3]
30012748:	e1a00003 	mov	r0, r3
3001274c:	e59d1014 	ldr	r1, [sp, #20]
30012750:	ebffe91d 	bl	3000cbcc <sys_mbox_post>
30012754:	ea00000d 	b	30012790 <tcpip_callback_with_block+0xcc>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
30012758:	e59f3054 	ldr	r3, [pc, #84]	; 300127b4 <tcpip_callback_with_block+0xf0>
3001275c:	e5933000 	ldr	r3, [r3]
30012760:	e1a00003 	mov	r0, r3
30012764:	e59d1014 	ldr	r1, [sp, #20]
30012768:	ebffe930 	bl	3000cc30 <sys_mbox_trypost>
3001276c:	e1a03000 	mov	r3, r0
30012770:	e20330ff 	and	r3, r3, #255	; 0xff
30012774:	e3530000 	cmp	r3, #0
30012778:	0a000004 	beq	30012790 <tcpip_callback_with_block+0xcc>
        memp_free(MEMP_TCPIP_MSG_API, msg);
3001277c:	e3a00007 	mov	r0, #7
30012780:	e59d1014 	ldr	r1, [sp, #20]
30012784:	eb000bfe 	bl	30015784 <memp_free>
        return ERR_MEM;
30012788:	e3a030ff 	mov	r3, #255	; 0xff
3001278c:	ea000002 	b	3001279c <tcpip_callback_with_block+0xd8>
      }
    }
    return ERR_OK;
30012790:	e3a03000 	mov	r3, #0
30012794:	ea000000 	b	3001279c <tcpip_callback_with_block+0xd8>
  }
  return ERR_VAL;
30012798:	e3a030f8 	mov	r3, #248	; 0xf8
3001279c:	e1a03c03 	lsl	r3, r3, #24
300127a0:	e1a03c43 	asr	r3, r3, #24
}
300127a4:	e1a00003 	mov	r0, r3
300127a8:	e28dd01c 	add	sp, sp, #28
300127ac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300127b0:	e12fff1e 	bx	lr
300127b4:	3002720c 	.word	0x3002720c

300127b8 <tcpip_timeout>:

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
300127b8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300127bc:	e24dd01c 	sub	sp, sp, #28
300127c0:	e58d000c 	str	r0, [sp, #12]
300127c4:	e58d1008 	str	r1, [sp, #8]
300127c8:	e58d2004 	str	r2, [sp, #4]
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
300127cc:	e59f3094 	ldr	r3, [pc, #148]	; 30012868 <tcpip_timeout+0xb0>
300127d0:	e5933000 	ldr	r3, [r3]
300127d4:	e3530000 	cmp	r3, #0
300127d8:	0a00001b 	beq	3001284c <tcpip_timeout+0x94>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
300127dc:	e3a00007 	mov	r0, #7
300127e0:	eb000b82 	bl	300155f0 <memp_malloc>
300127e4:	e1a03000 	mov	r3, r0
300127e8:	e58d3014 	str	r3, [sp, #20]
    if (msg == NULL) {
300127ec:	e59d3014 	ldr	r3, [sp, #20]
300127f0:	e3530000 	cmp	r3, #0
300127f4:	1a000001 	bne	30012800 <tcpip_timeout+0x48>
      return ERR_MEM;
300127f8:	e3a030ff 	mov	r3, #255	; 0xff
300127fc:	ea000013 	b	30012850 <tcpip_timeout+0x98>
    }

    msg->type = TCPIP_MSG_TIMEOUT;
30012800:	e59d3014 	ldr	r3, [sp, #20]
30012804:	e3a02003 	mov	r2, #3
30012808:	e5c32000 	strb	r2, [r3]
    msg->msg.tmo.msecs = msecs;
3001280c:	e59d3014 	ldr	r3, [sp, #20]
30012810:	e59d200c 	ldr	r2, [sp, #12]
30012814:	e5832008 	str	r2, [r3, #8]
    msg->msg.tmo.h = h;
30012818:	e59d3014 	ldr	r3, [sp, #20]
3001281c:	e59d2008 	ldr	r2, [sp, #8]
30012820:	e583200c 	str	r2, [r3, #12]
    msg->msg.tmo.arg = arg;
30012824:	e59d3014 	ldr	r3, [sp, #20]
30012828:	e59d2004 	ldr	r2, [sp, #4]
3001282c:	e5832010 	str	r2, [r3, #16]
    sys_mbox_post(mbox, msg);
30012830:	e59f3030 	ldr	r3, [pc, #48]	; 30012868 <tcpip_timeout+0xb0>
30012834:	e5933000 	ldr	r3, [r3]
30012838:	e1a00003 	mov	r0, r3
3001283c:	e59d1014 	ldr	r1, [sp, #20]
30012840:	ebffe8e1 	bl	3000cbcc <sys_mbox_post>
    return ERR_OK;
30012844:	e3a03000 	mov	r3, #0
30012848:	ea000000 	b	30012850 <tcpip_timeout+0x98>
  }
  return ERR_VAL;
3001284c:	e3a030f8 	mov	r3, #248	; 0xf8
30012850:	e1a03c03 	lsl	r3, r3, #24
30012854:	e1a03c43 	asr	r3, r3, #24
}
30012858:	e1a00003 	mov	r0, r3
3001285c:	e28dd01c 	add	sp, sp, #28
30012860:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30012864:	e12fff1e 	bx	lr
30012868:	3002720c 	.word	0x3002720c

3001286c <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
3001286c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30012870:	e24dd024 	sub	sp, sp, #36	; 0x24
30012874:	e58d0004 	str	r0, [sp, #4]
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
30012878:	e59f306c 	ldr	r3, [pc, #108]	; 300128ec <tcpip_apimsg+0x80>
3001287c:	e5933000 	ldr	r3, [r3]
30012880:	e3530000 	cmp	r3, #0
30012884:	0a000011 	beq	300128d0 <tcpip_apimsg+0x64>
    msg.type = TCPIP_MSG_API;
30012888:	e3a03000 	mov	r3, #0
3001288c:	e5cd300c 	strb	r3, [sp, #12]
    msg.msg.apimsg = apimsg;
30012890:	e59d3004 	ldr	r3, [sp, #4]
30012894:	e58d3014 	str	r3, [sp, #20]
    //acoral_prints("\r\ntcpip_apimsg_post\r\n");
    sys_mbox_post(mbox, &msg);
30012898:	e59f304c 	ldr	r3, [pc, #76]	; 300128ec <tcpip_apimsg+0x80>
3001289c:	e5932000 	ldr	r2, [r3]
300128a0:	e28d300c 	add	r3, sp, #12
300128a4:	e1a00002 	mov	r0, r2
300128a8:	e1a01003 	mov	r1, r3
300128ac:	ebffe8c6 	bl	3000cbcc <sys_mbox_post>
    //lwip_printf("\r\n %s \r\n====\r\n", apimsg->msg.msg.w.dataptr);
	//acoral_prints("\r\ntcpip_apimsg_op_completed\r\n");    
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
300128b0:	e59d3004 	ldr	r3, [sp, #4]
300128b4:	e5933004 	ldr	r3, [r3, #4]
300128b8:	e593300c 	ldr	r3, [r3, #12]
300128bc:	e1a00003 	mov	r0, r3
300128c0:	e3a01000 	mov	r1, #0
300128c4:	ebffe89b 	bl	3000cb38 <sys_arch_sem_wait>
    return ERR_OK;
300128c8:	e3a03000 	mov	r3, #0
300128cc:	ea000000 	b	300128d4 <tcpip_apimsg+0x68>
  }
  return ERR_VAL;
300128d0:	e3a030f8 	mov	r3, #248	; 0xf8
300128d4:	e1a03c03 	lsl	r3, r3, #24
300128d8:	e1a03c43 	asr	r3, r3, #24
}
300128dc:	e1a00003 	mov	r0, r3
300128e0:	e28dd024 	add	sp, sp, #36	; 0x24
300128e4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300128e8:	e12fff1e 	bx	lr
300128ec:	3002720c 	.word	0x3002720c

300128f0 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
300128f0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300128f4:	e24dd014 	sub	sp, sp, #20
300128f8:	e58d000c 	str	r0, [sp, #12]
300128fc:	e58d1008 	str	r1, [sp, #8]
  lwip_init();
30012900:	eb000abc 	bl	300153f8 <lwip_init>

  tcpip_init_done = initfunc;
30012904:	e59f304c 	ldr	r3, [pc, #76]	; 30012958 <tcpip_init+0x68>
30012908:	e59d200c 	ldr	r2, [sp, #12]
3001290c:	e5832000 	str	r2, [r3]
  tcpip_init_done_arg = arg;
30012910:	e59f3044 	ldr	r3, [pc, #68]	; 3001295c <tcpip_init+0x6c>
30012914:	e59d2008 	ldr	r2, [sp, #8]
30012918:	e5832000 	str	r2, [r3]
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
3001291c:	e3a0000a 	mov	r0, #10
30012920:	ebffe895 	bl	3000cb7c <sys_mbox_new>
30012924:	e1a02000 	mov	r2, r0
30012928:	e59f3030 	ldr	r3, [pc, #48]	; 30012960 <tcpip_init+0x70>
3001292c:	e5832000 	str	r2, [r3]
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
30012930:	e3a03015 	mov	r3, #21
30012934:	e58d3000 	str	r3, [sp]
30012938:	e59f0024 	ldr	r0, [pc, #36]	; 30012964 <tcpip_init+0x74>
3001293c:	e59f1024 	ldr	r1, [pc, #36]	; 30012968 <tcpip_init+0x78>
30012940:	e3a02000 	mov	r2, #0
30012944:	e3a03a01 	mov	r3, #4096	; 0x1000
30012948:	ebffe903 	bl	3000cd5c <sys_thread_new>
}
3001294c:	e28dd014 	add	sp, sp, #20
30012950:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30012954:	e12fff1e 	bx	lr
30012958:	30027204 	.word	0x30027204
3001295c:	30027208 	.word	0x30027208
30012960:	3002720c 	.word	0x3002720c
30012964:	30026554 	.word	0x30026554
30012968:	300123d4 	.word	0x300123d4

3001296c <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
3001296c:	e92d4010 	push	{r4, lr}
30012970:	e24dd038 	sub	sp, sp, #56	; 0x38
30012974:	e58d0014 	str	r0, [sp, #20]
30012978:	e58d1010 	str	r1, [sp, #16]
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  struct ip_addr tmpaddr;
  s16_t hlen;

  ICMP_STATS_INC(icmp.recv);
3001297c:	e59f3720 	ldr	r3, [pc, #1824]	; 300130a4 <icmp_input+0x738>
30012980:	e1d336bc 	ldrh	r3, [r3, #108]	; 0x6c
30012984:	e2833001 	add	r3, r3, #1
30012988:	e1a03803 	lsl	r3, r3, #16
3001298c:	e1a02823 	lsr	r2, r3, #16
30012990:	e59f370c 	ldr	r3, [pc, #1804]	; 300130a4 <icmp_input+0x738>
30012994:	e1c326bc 	strh	r2, [r3, #108]	; 0x6c
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
30012998:	e59d3014 	ldr	r3, [sp, #20]
3001299c:	e5933004 	ldr	r3, [r3, #4]
300129a0:	e58d3028 	str	r3, [sp, #40]	; 0x28
  hlen = IPH_HL(iphdr) * 4;
300129a4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300129a8:	e5d32000 	ldrb	r2, [r3]
300129ac:	e5d33001 	ldrb	r3, [r3, #1]
300129b0:	e1a03403 	lsl	r3, r3, #8
300129b4:	e1833002 	orr	r3, r3, r2
300129b8:	e1a03803 	lsl	r3, r3, #16
300129bc:	e1a03823 	lsr	r3, r3, #16
300129c0:	e1a00003 	mov	r0, r3
300129c4:	eb0003cf 	bl	30013908 <ntohs>
300129c8:	e1a03000 	mov	r3, r0
300129cc:	e1a03423 	lsr	r3, r3, #8
300129d0:	e1a03803 	lsl	r3, r3, #16
300129d4:	e1a03823 	lsr	r3, r3, #16
300129d8:	e203300f 	and	r3, r3, #15
300129dc:	e1a03103 	lsl	r3, r3, #2
300129e0:	e1a03803 	lsl	r3, r3, #16
300129e4:	e1a03823 	lsr	r3, r3, #16
300129e8:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
300129ec:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
300129f0:	e2633000 	rsb	r3, r3, #0
300129f4:	e1a03803 	lsl	r3, r3, #16
300129f8:	e1a03823 	lsr	r3, r3, #16
300129fc:	e1a03803 	lsl	r3, r3, #16
30012a00:	e1a03843 	asr	r3, r3, #16
30012a04:	e59d0014 	ldr	r0, [sp, #20]
30012a08:	e1a01003 	mov	r1, r3
30012a0c:	eb000e62 	bl	3001639c <pbuf_header>
30012a10:	e1a03000 	mov	r3, r0
30012a14:	e3530000 	cmp	r3, #0
30012a18:	1a000181 	bne	30013024 <icmp_input+0x6b8>
30012a1c:	e59d3014 	ldr	r3, [sp, #20]
30012a20:	e1d330b8 	ldrh	r3, [r3, #8]
30012a24:	e3530003 	cmp	r3, #3
30012a28:	9a00017d 	bls	30013024 <icmp_input+0x6b8>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
30012a2c:	e59d3014 	ldr	r3, [sp, #20]
30012a30:	e5933004 	ldr	r3, [r3, #4]
30012a34:	e5d33000 	ldrb	r3, [r3]
30012a38:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
30012a3c:	e5dd3023 	ldrb	r3, [sp, #35]	; 0x23
30012a40:	e3530008 	cmp	r3, #8
30012a44:	1a000162 	bne	30012fd4 <icmp_input+0x668>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
30012a48:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012a4c:	e2833010 	add	r3, r3, #16
30012a50:	e1a00003 	mov	r0, r3
30012a54:	e59d1010 	ldr	r1, [sp, #16]
30012a58:	eb00092d 	bl	30014f14 <ip_addr_isbroadcast>
30012a5c:	e1a03000 	mov	r3, r0
30012a60:	e3530000 	cmp	r3, #0
30012a64:	1a000014 	bne	30012abc <icmp_input+0x150>
30012a68:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012a6c:	e5d32010 	ldrb	r2, [r3, #16]
30012a70:	e5d31011 	ldrb	r1, [r3, #17]
30012a74:	e1a01401 	lsl	r1, r1, #8
30012a78:	e1812002 	orr	r2, r1, r2
30012a7c:	e5d31012 	ldrb	r1, [r3, #18]
30012a80:	e1a01801 	lsl	r1, r1, #16
30012a84:	e1812002 	orr	r2, r1, r2
30012a88:	e5d33013 	ldrb	r3, [r3, #19]
30012a8c:	e1a03c03 	lsl	r3, r3, #24
30012a90:	e1833002 	orr	r3, r3, r2
30012a94:	e1a04003 	mov	r4, r3
30012a98:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
30012a9c:	eb0003b7 	bl	30013980 <ntohl>
30012aa0:	e1a03000 	mov	r3, r0
30012aa4:	e0044003 	and	r4, r4, r3
30012aa8:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
30012aac:	eb0003b3 	bl	30013980 <ntohl>
30012ab0:	e1a03000 	mov	r3, r0
30012ab4:	e1540003 	cmp	r4, r3
30012ab8:	1a000009 	bne	30012ae4 <icmp_input+0x178>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
30012abc:	e59f35e0 	ldr	r3, [pc, #1504]	; 300130a4 <icmp_input+0x738>
30012ac0:	e1d337be 	ldrh	r3, [r3, #126]	; 0x7e
30012ac4:	e2833001 	add	r3, r3, #1
30012ac8:	e1a03803 	lsl	r3, r3, #16
30012acc:	e1a02823 	lsr	r2, r3, #16
30012ad0:	e59f35cc 	ldr	r3, [pc, #1484]	; 300130a4 <icmp_input+0x738>
30012ad4:	e1c327be 	strh	r2, [r3, #126]	; 0x7e
      pbuf_free(p);
30012ad8:	e59d0014 	ldr	r0, [sp, #20]
30012adc:	eb000e93 	bl	30016530 <pbuf_free>
      return;
30012ae0:	ea00016c 	b	30013098 <icmp_input+0x72c>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
30012ae4:	e59d3014 	ldr	r3, [sp, #20]
30012ae8:	e1d330b8 	ldrh	r3, [r3, #8]
30012aec:	e3530007 	cmp	r3, #7
30012af0:	9a00014a 	bls	30013020 <icmp_input+0x6b4>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
30012af4:	e59d0014 	ldr	r0, [sp, #20]
30012af8:	eb00057a 	bl	300140e8 <inet_chksum_pbuf>
30012afc:	e1a03000 	mov	r3, r0
30012b00:	e3530000 	cmp	r3, #0
30012b04:	0a000009 	beq	30012b30 <icmp_input+0x1c4>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
30012b08:	e59d0014 	ldr	r0, [sp, #20]
30012b0c:	eb000e87 	bl	30016530 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
30012b10:	e59f358c 	ldr	r3, [pc, #1420]	; 300130a4 <icmp_input+0x738>
30012b14:	e1d337b2 	ldrh	r3, [r3, #114]	; 0x72
30012b18:	e2833001 	add	r3, r3, #1
30012b1c:	e1a03803 	lsl	r3, r3, #16
30012b20:	e1a02823 	lsr	r2, r3, #16
30012b24:	e59f3578 	ldr	r3, [pc, #1400]	; 300130a4 <icmp_input+0x738>
30012b28:	e1c327b2 	strh	r2, [r3, #114]	; 0x72
      snmp_inc_icmpinerrors();
      return;
30012b2c:	ea000159 	b	30013098 <icmp_input+0x72c>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
30012b30:	e59d0014 	ldr	r0, [sp, #20]
30012b34:	e3a01022 	mov	r1, #34	; 0x22
30012b38:	eb000e17 	bl	3001639c <pbuf_header>
30012b3c:	e1a03000 	mov	r3, r0
30012b40:	e3530000 	cmp	r3, #0
30012b44:	0a00002c 	beq	30012bfc <icmp_input+0x290>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
30012b48:	e1dd32fe 	ldrsh	r3, [sp, #46]	; 0x2e
30012b4c:	e59d0014 	ldr	r0, [sp, #20]
30012b50:	e1a01003 	mov	r1, r3
30012b54:	eb000e10 	bl	3001639c <pbuf_header>
30012b58:	e1a03000 	mov	r3, r0
30012b5c:	e3530000 	cmp	r3, #0
30012b60:	1a000139 	bne	3001304c <icmp_input+0x6e0>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
30012b64:	e59d3014 	ldr	r3, [sp, #20]
30012b68:	e1d330b8 	ldrh	r3, [r3, #8]
30012b6c:	e3a00002 	mov	r0, #2
30012b70:	e1a01003 	mov	r1, r3
30012b74:	e3a02000 	mov	r2, #0
30012b78:	eb000cbd 	bl	30015e74 <pbuf_alloc>
30012b7c:	e1a03000 	mov	r3, r0
30012b80:	e58d3030 	str	r3, [sp, #48]	; 0x30
      if (r == NULL) {
30012b84:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30012b88:	e3530000 	cmp	r3, #0
30012b8c:	0a000130 	beq	30013054 <icmp_input+0x6e8>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
30012b90:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
30012b94:	e59d1014 	ldr	r1, [sp, #20]
30012b98:	eb000f2a 	bl	30016848 <pbuf_copy>
30012b9c:	e1a03000 	mov	r3, r0
30012ba0:	e20330ff 	and	r3, r3, #255	; 0xff
30012ba4:	e3530000 	cmp	r3, #0
30012ba8:	1a00012b 	bne	3001305c <icmp_input+0x6f0>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = r->payload;
30012bac:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30012bb0:	e5933004 	ldr	r3, [r3, #4]
30012bb4:	e58d3028 	str	r3, [sp, #40]	; 0x28
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
30012bb8:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
30012bbc:	e2633000 	rsb	r3, r3, #0
30012bc0:	e1a03803 	lsl	r3, r3, #16
30012bc4:	e1a03823 	lsr	r3, r3, #16
30012bc8:	e1a03803 	lsl	r3, r3, #16
30012bcc:	e1a03843 	asr	r3, r3, #16
30012bd0:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
30012bd4:	e1a01003 	mov	r1, r3
30012bd8:	eb000def 	bl	3001639c <pbuf_header>
30012bdc:	e1a03000 	mov	r3, r0
30012be0:	e3530000 	cmp	r3, #0
30012be4:	1a00011e 	bne	30013064 <icmp_input+0x6f8>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
30012be8:	e59d0014 	ldr	r0, [sp, #20]
30012bec:	eb000e4f 	bl	30016530 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
30012bf0:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30012bf4:	e58d3014 	str	r3, [sp, #20]
30012bf8:	ea000005 	b	30012c14 <icmp_input+0x2a8>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
30012bfc:	e59d0014 	ldr	r0, [sp, #20]
30012c00:	e3e01021 	mvn	r1, #33	; 0x21
30012c04:	eb000de4 	bl	3001639c <pbuf_header>
30012c08:	e1a03000 	mov	r3, r0
30012c0c:	e3530000 	cmp	r3, #0
30012c10:	1a000115 	bne	3001306c <icmp_input+0x700>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
30012c14:	e59d3014 	ldr	r3, [sp, #20]
30012c18:	e5933004 	ldr	r3, [r3, #4]
30012c1c:	e58d3024 	str	r3, [sp, #36]	; 0x24
    tmpaddr.addr = iphdr->src.addr;
30012c20:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012c24:	e5d3200c 	ldrb	r2, [r3, #12]
30012c28:	e5d3100d 	ldrb	r1, [r3, #13]
30012c2c:	e1a01401 	lsl	r1, r1, #8
30012c30:	e1812002 	orr	r2, r1, r2
30012c34:	e5d3100e 	ldrb	r1, [r3, #14]
30012c38:	e1a01801 	lsl	r1, r1, #16
30012c3c:	e1812002 	orr	r2, r1, r2
30012c40:	e5d3300f 	ldrb	r3, [r3, #15]
30012c44:	e1a03c03 	lsl	r3, r3, #24
30012c48:	e1833002 	orr	r3, r3, r2
30012c4c:	e58d301c 	str	r3, [sp, #28]
    iphdr->src.addr = iphdr->dest.addr;
30012c50:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012c54:	e5d32010 	ldrb	r2, [r3, #16]
30012c58:	e5d31011 	ldrb	r1, [r3, #17]
30012c5c:	e1a01401 	lsl	r1, r1, #8
30012c60:	e1812002 	orr	r2, r1, r2
30012c64:	e5d31012 	ldrb	r1, [r3, #18]
30012c68:	e1a01801 	lsl	r1, r1, #16
30012c6c:	e1812002 	orr	r2, r1, r2
30012c70:	e5d33013 	ldrb	r3, [r3, #19]
30012c74:	e1a03c03 	lsl	r3, r3, #24
30012c78:	e1833002 	orr	r3, r3, r2
30012c7c:	e1a02003 	mov	r2, r3
30012c80:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012c84:	e20210ff 	and	r1, r2, #255	; 0xff
30012c88:	e3a00000 	mov	r0, #0
30012c8c:	e1801001 	orr	r1, r0, r1
30012c90:	e5c3100c 	strb	r1, [r3, #12]
30012c94:	e1a01422 	lsr	r1, r2, #8
30012c98:	e20110ff 	and	r1, r1, #255	; 0xff
30012c9c:	e3a00000 	mov	r0, #0
30012ca0:	e1801001 	orr	r1, r0, r1
30012ca4:	e5c3100d 	strb	r1, [r3, #13]
30012ca8:	e1a01822 	lsr	r1, r2, #16
30012cac:	e20110ff 	and	r1, r1, #255	; 0xff
30012cb0:	e3a00000 	mov	r0, #0
30012cb4:	e1801001 	orr	r1, r0, r1
30012cb8:	e5c3100e 	strb	r1, [r3, #14]
30012cbc:	e1a02c22 	lsr	r2, r2, #24
30012cc0:	e3a01000 	mov	r1, #0
30012cc4:	e1812002 	orr	r2, r1, r2
30012cc8:	e5c3200f 	strb	r2, [r3, #15]
    iphdr->dest.addr = tmpaddr.addr;
30012ccc:	e59d201c 	ldr	r2, [sp, #28]
30012cd0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012cd4:	e20210ff 	and	r1, r2, #255	; 0xff
30012cd8:	e3a00000 	mov	r0, #0
30012cdc:	e1801001 	orr	r1, r0, r1
30012ce0:	e5c31010 	strb	r1, [r3, #16]
30012ce4:	e1a01422 	lsr	r1, r2, #8
30012ce8:	e20110ff 	and	r1, r1, #255	; 0xff
30012cec:	e3a00000 	mov	r0, #0
30012cf0:	e1801001 	orr	r1, r0, r1
30012cf4:	e5c31011 	strb	r1, [r3, #17]
30012cf8:	e1a01822 	lsr	r1, r2, #16
30012cfc:	e20110ff 	and	r1, r1, #255	; 0xff
30012d00:	e3a00000 	mov	r0, #0
30012d04:	e1801001 	orr	r1, r0, r1
30012d08:	e5c31012 	strb	r1, [r3, #18]
30012d0c:	e1a02c22 	lsr	r2, r2, #24
30012d10:	e3a01000 	mov	r1, #0
30012d14:	e1812002 	orr	r2, r1, r2
30012d18:	e5c32013 	strb	r2, [r3, #19]
    ICMPH_TYPE_SET(iecho, ICMP_ER);
30012d1c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30012d20:	e5d32000 	ldrb	r2, [r3]
30012d24:	e5d33001 	ldrb	r3, [r3, #1]
30012d28:	e1a03403 	lsl	r3, r3, #8
30012d2c:	e1833002 	orr	r3, r3, r2
30012d30:	e1a03803 	lsl	r3, r3, #16
30012d34:	e1a03823 	lsr	r3, r3, #16
30012d38:	e1a00003 	mov	r0, r3
30012d3c:	eb0002f1 	bl	30013908 <ntohs>
30012d40:	e1a03000 	mov	r3, r0
30012d44:	e20330ff 	and	r3, r3, #255	; 0xff
30012d48:	e1a00003 	mov	r0, r3
30012d4c:	eb0002da 	bl	300138bc <htons>
30012d50:	e1a03000 	mov	r3, r0
30012d54:	e1a02003 	mov	r2, r3
30012d58:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30012d5c:	e20210ff 	and	r1, r2, #255	; 0xff
30012d60:	e3a00000 	mov	r0, #0
30012d64:	e1801001 	orr	r1, r0, r1
30012d68:	e5c31000 	strb	r1, [r3]
30012d6c:	e1a02422 	lsr	r2, r2, #8
30012d70:	e1a02802 	lsl	r2, r2, #16
30012d74:	e1a02822 	lsr	r2, r2, #16
30012d78:	e3a01000 	mov	r1, #0
30012d7c:	e1812002 	orr	r2, r1, r2
30012d80:	e5c32001 	strb	r2, [r3, #1]
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
30012d84:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30012d88:	e5d32002 	ldrb	r2, [r3, #2]
30012d8c:	e5d33003 	ldrb	r3, [r3, #3]
30012d90:	e1a03403 	lsl	r3, r3, #8
30012d94:	e1833002 	orr	r3, r3, r2
30012d98:	e1a03803 	lsl	r3, r3, #16
30012d9c:	e1a04823 	lsr	r4, r3, #16
30012da0:	e3a00b3e 	mov	r0, #63488	; 0xf800
30012da4:	e2400001 	sub	r0, r0, #1
30012da8:	eb0002c3 	bl	300138bc <htons>
30012dac:	e1a03000 	mov	r3, r0
30012db0:	e1540003 	cmp	r4, r3
30012db4:	3a00001b 	bcc	30012e28 <icmp_input+0x4bc>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
30012db8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30012dbc:	e5d32002 	ldrb	r2, [r3, #2]
30012dc0:	e5d33003 	ldrb	r3, [r3, #3]
30012dc4:	e1a03403 	lsl	r3, r3, #8
30012dc8:	e1833002 	orr	r3, r3, r2
30012dcc:	e1a03803 	lsl	r3, r3, #16
30012dd0:	e1a04823 	lsr	r4, r3, #16
30012dd4:	e3a00b02 	mov	r0, #2048	; 0x800
30012dd8:	eb0002b7 	bl	300138bc <htons>
30012ddc:	e1a03000 	mov	r3, r0
30012de0:	e0843003 	add	r3, r4, r3
30012de4:	e1a03803 	lsl	r3, r3, #16
30012de8:	e1a03823 	lsr	r3, r3, #16
30012dec:	e2833001 	add	r3, r3, #1
30012df0:	e1a03803 	lsl	r3, r3, #16
30012df4:	e1a02823 	lsr	r2, r3, #16
30012df8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30012dfc:	e20210ff 	and	r1, r2, #255	; 0xff
30012e00:	e3a00000 	mov	r0, #0
30012e04:	e1801001 	orr	r1, r0, r1
30012e08:	e5c31002 	strb	r1, [r3, #2]
30012e0c:	e1a02422 	lsr	r2, r2, #8
30012e10:	e1a02802 	lsl	r2, r2, #16
30012e14:	e1a02822 	lsr	r2, r2, #16
30012e18:	e3a01000 	mov	r1, #0
30012e1c:	e1812002 	orr	r2, r1, r2
30012e20:	e5c32003 	strb	r2, [r3, #3]
30012e24:	ea000017 	b	30012e88 <icmp_input+0x51c>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
30012e28:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30012e2c:	e5d32002 	ldrb	r2, [r3, #2]
30012e30:	e5d33003 	ldrb	r3, [r3, #3]
30012e34:	e1a03403 	lsl	r3, r3, #8
30012e38:	e1833002 	orr	r3, r3, r2
30012e3c:	e1a03803 	lsl	r3, r3, #16
30012e40:	e1a04823 	lsr	r4, r3, #16
30012e44:	e3a00b02 	mov	r0, #2048	; 0x800
30012e48:	eb00029b 	bl	300138bc <htons>
30012e4c:	e1a03000 	mov	r3, r0
30012e50:	e0843003 	add	r3, r4, r3
30012e54:	e1a03803 	lsl	r3, r3, #16
30012e58:	e1a02823 	lsr	r2, r3, #16
30012e5c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30012e60:	e20210ff 	and	r1, r2, #255	; 0xff
30012e64:	e3a00000 	mov	r0, #0
30012e68:	e1801001 	orr	r1, r0, r1
30012e6c:	e5c31002 	strb	r1, [r3, #2]
30012e70:	e1a02422 	lsr	r2, r2, #8
30012e74:	e1a02802 	lsl	r2, r2, #16
30012e78:	e1a02822 	lsr	r2, r2, #16
30012e7c:	e3a01000 	mov	r1, #0
30012e80:	e1812002 	orr	r2, r1, r2
30012e84:	e5c32003 	strb	r2, [r3, #3]
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
30012e88:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012e8c:	e5d32008 	ldrb	r2, [r3, #8]
30012e90:	e5d33009 	ldrb	r3, [r3, #9]
30012e94:	e1a03403 	lsl	r3, r3, #8
30012e98:	e1833002 	orr	r3, r3, r2
30012e9c:	e1a03803 	lsl	r3, r3, #16
30012ea0:	e1a03823 	lsr	r3, r3, #16
30012ea4:	e1a00003 	mov	r0, r3
30012ea8:	eb000296 	bl	30013908 <ntohs>
30012eac:	e1a03000 	mov	r3, r0
30012eb0:	e1e03c03 	mvn	r3, r3, lsl #24
30012eb4:	e1e03c23 	mvn	r3, r3, lsr #24
30012eb8:	e1a03803 	lsl	r3, r3, #16
30012ebc:	e1a03823 	lsr	r3, r3, #16
30012ec0:	e1a03803 	lsl	r3, r3, #16
30012ec4:	e1a03823 	lsr	r3, r3, #16
30012ec8:	e1a00003 	mov	r0, r3
30012ecc:	eb00027a 	bl	300138bc <htons>
30012ed0:	e1a03000 	mov	r3, r0
30012ed4:	e1a02003 	mov	r2, r3
30012ed8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012edc:	e20210ff 	and	r1, r2, #255	; 0xff
30012ee0:	e3a00000 	mov	r0, #0
30012ee4:	e1801001 	orr	r1, r0, r1
30012ee8:	e5c31008 	strb	r1, [r3, #8]
30012eec:	e1a02422 	lsr	r2, r2, #8
30012ef0:	e1a02802 	lsl	r2, r2, #16
30012ef4:	e1a02822 	lsr	r2, r2, #16
30012ef8:	e3a01000 	mov	r1, #0
30012efc:	e1812002 	orr	r2, r1, r2
30012f00:	e5c32009 	strb	r2, [r3, #9]
    IPH_CHKSUM_SET(iphdr, 0);
30012f04:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012f08:	e3a02000 	mov	r2, #0
30012f0c:	e5c3200a 	strb	r2, [r3, #10]
30012f10:	e3a02000 	mov	r2, #0
30012f14:	e5c3200b 	strb	r2, [r3, #11]
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
30012f18:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
30012f1c:	e3a01014 	mov	r1, #20
30012f20:	eb00044f 	bl	30014064 <inet_chksum>
30012f24:	e1a03000 	mov	r3, r0
30012f28:	e1a02003 	mov	r2, r3
30012f2c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012f30:	e20210ff 	and	r1, r2, #255	; 0xff
30012f34:	e3a00000 	mov	r0, #0
30012f38:	e1801001 	orr	r1, r0, r1
30012f3c:	e5c3100a 	strb	r1, [r3, #10]
30012f40:	e1a02422 	lsr	r2, r2, #8
30012f44:	e1a02802 	lsl	r2, r2, #16
30012f48:	e1a02822 	lsr	r2, r2, #16
30012f4c:	e3a01000 	mov	r1, #0
30012f50:	e1812002 	orr	r2, r1, r2
30012f54:	e5c3200b 	strb	r2, [r3, #11]
#endif /* CHECKSUM_GEN_IP */

    ICMP_STATS_INC(icmp.xmit);
30012f58:	e59f3144 	ldr	r3, [pc, #324]	; 300130a4 <icmp_input+0x738>
30012f5c:	e1d336b8 	ldrh	r3, [r3, #104]	; 0x68
30012f60:	e2833001 	add	r3, r3, #1
30012f64:	e1a03803 	lsl	r3, r3, #16
30012f68:	e1a02823 	lsr	r2, r3, #16
30012f6c:	e59f3130 	ldr	r3, [pc, #304]	; 300130a4 <icmp_input+0x738>
30012f70:	e1c326b8 	strh	r2, [r3, #104]	; 0x68
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
30012f74:	e1dd32fe 	ldrsh	r3, [sp, #46]	; 0x2e
30012f78:	e59d0014 	ldr	r0, [sp, #20]
30012f7c:	e1a01003 	mov	r1, r3
30012f80:	eb000d05 	bl	3001639c <pbuf_header>
30012f84:	e1a03000 	mov	r3, r0
30012f88:	e3530000 	cmp	r3, #0
30012f8c:	1a00001f 	bne	30013010 <icmp_input+0x6a4>
      LWIP_ASSERT("Can't move over header in packet", 0);
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
30012f90:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012f94:	e283300c 	add	r3, r3, #12
30012f98:	e3a02000 	mov	r2, #0
30012f9c:	e58d2000 	str	r2, [sp]
30012fa0:	e3a02001 	mov	r2, #1
30012fa4:	e58d2004 	str	r2, [sp, #4]
30012fa8:	e59d2010 	ldr	r2, [sp, #16]
30012fac:	e58d2008 	str	r2, [sp, #8]
30012fb0:	e59d0014 	ldr	r0, [sp, #20]
30012fb4:	e1a01003 	mov	r1, r3
30012fb8:	e3a02000 	mov	r2, #0
30012fbc:	e3a030ff 	mov	r3, #255	; 0xff
30012fc0:	eb00064c 	bl	300148f8 <ip_output_if>
30012fc4:	e1a03000 	mov	r3, r0
30012fc8:	e20330ff 	and	r3, r3, #255	; 0xff
30012fcc:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
30012fd0:	ea00000f 	b	30013014 <icmp_input+0x6a8>
  default:
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
30012fd4:	e59f30c8 	ldr	r3, [pc, #200]	; 300130a4 <icmp_input+0x738>
30012fd8:	e1d337ba 	ldrh	r3, [r3, #122]	; 0x7a
30012fdc:	e2833001 	add	r3, r3, #1
30012fe0:	e1a03803 	lsl	r3, r3, #16
30012fe4:	e1a02823 	lsr	r2, r3, #16
30012fe8:	e59f30b4 	ldr	r3, [pc, #180]	; 300130a4 <icmp_input+0x738>
30012fec:	e1c327ba 	strh	r2, [r3, #122]	; 0x7a
    ICMP_STATS_INC(icmp.drop);
30012ff0:	e59f30ac 	ldr	r3, [pc, #172]	; 300130a4 <icmp_input+0x738>
30012ff4:	e1d337b0 	ldrh	r3, [r3, #112]	; 0x70
30012ff8:	e2833001 	add	r3, r3, #1
30012ffc:	e1a03803 	lsl	r3, r3, #16
30013000:	e1a02823 	lsr	r2, r3, #16
30013004:	e59f3098 	ldr	r3, [pc, #152]	; 300130a4 <icmp_input+0x738>
30013008:	e1c327b0 	strh	r2, [r3, #112]	; 0x70
3001300c:	ea000000 	b	30013014 <icmp_input+0x6a8>
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
30013010:	e1a00000 	nop			; (mov r0, r0)
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
30013014:	e59d0014 	ldr	r0, [sp, #20]
30013018:	eb000d44 	bl	30016530 <pbuf_free>
  return;
3001301c:	ea00001d 	b	30013098 <icmp_input+0x72c>
      return;
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
30013020:	e1a00000 	nop			; (mov r0, r0)
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
30013024:	e59d0014 	ldr	r0, [sp, #20]
30013028:	eb000d40 	bl	30016530 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
3001302c:	e59f3070 	ldr	r3, [pc, #112]	; 300130a4 <icmp_input+0x738>
30013030:	e1d337b4 	ldrh	r3, [r3, #116]	; 0x74
30013034:	e2833001 	add	r3, r3, #1
30013038:	e1a03803 	lsl	r3, r3, #16
3001303c:	e1a02823 	lsr	r2, r3, #16
30013040:	e59f305c 	ldr	r3, [pc, #92]	; 300130a4 <icmp_input+0x738>
30013044:	e1c327b4 	strh	r2, [r3, #116]	; 0x74
  snmp_inc_icmpinerrors();
  return;
30013048:	ea000012 	b	30013098 <icmp_input+0x72c>
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
3001304c:	e1a00000 	nop			; (mov r0, r0)
30013050:	ea000006 	b	30013070 <icmp_input+0x704>
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
30013054:	e1a00000 	nop			; (mov r0, r0)
30013058:	ea000004 	b	30013070 <icmp_input+0x704>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
3001305c:	e1a00000 	nop			; (mov r0, r0)
30013060:	ea000002 	b	30013070 <icmp_input+0x704>
      }
      iphdr = r->payload;
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
30013064:	e1a00000 	nop			; (mov r0, r0)
30013068:	ea000000 	b	30013070 <icmp_input+0x704>
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
3001306c:	e1a00000 	nop			; (mov r0, r0)
  pbuf_free(p);
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
memerr:
  pbuf_free(p);
30013070:	e59d0014 	ldr	r0, [sp, #20]
30013074:	eb000d2d 	bl	30016530 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
30013078:	e59f3024 	ldr	r3, [pc, #36]	; 300130a4 <icmp_input+0x738>
3001307c:	e1d337be 	ldrh	r3, [r3, #126]	; 0x7e
30013080:	e2833001 	add	r3, r3, #1
30013084:	e1a03803 	lsl	r3, r3, #16
30013088:	e1a02823 	lsr	r2, r3, #16
3001308c:	e59f3010 	ldr	r3, [pc, #16]	; 300130a4 <icmp_input+0x738>
30013090:	e1c327be 	strh	r2, [r3, #126]	; 0x7e
  snmp_inc_icmpinerrors();
  return;
30013094:	e1a00000 	nop			; (mov r0, r0)
}
30013098:	e28dd038 	add	sp, sp, #56	; 0x38
3001309c:	e8bd4010 	pop	{r4, lr}
300130a0:	e12fff1e 	bx	lr
300130a4:	3002b214 	.word	0x3002b214

300130a8 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
300130a8:	e92d4010 	push	{r4, lr}
300130ac:	e24dd020 	sub	sp, sp, #32
300130b0:	e58d000c 	str	r0, [sp, #12]
300130b4:	e1a03001 	mov	r3, r1
300130b8:	e5cd300b 	strb	r3, [sp, #11]
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
300130bc:	e3a00001 	mov	r0, #1
300130c0:	e3a01024 	mov	r1, #36	; 0x24
300130c4:	e3a02000 	mov	r2, #0
300130c8:	eb000b69 	bl	30015e74 <pbuf_alloc>
300130cc:	e1a03000 	mov	r3, r0
300130d0:	e58d3014 	str	r3, [sp, #20]
                 PBUF_RAM);
  if (q == NULL) {
300130d4:	e59d3014 	ldr	r3, [sp, #20]
300130d8:	e3530000 	cmp	r3, #0
300130dc:	0a000081 	beq	300132e8 <icmp_dest_unreach+0x240>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
300130e0:	e59d300c 	ldr	r3, [sp, #12]
300130e4:	e5933004 	ldr	r3, [r3, #4]
300130e8:	e58d3018 	str	r3, [sp, #24]

  idur = q->payload;
300130ec:	e59d3014 	ldr	r3, [sp, #20]
300130f0:	e5933004 	ldr	r3, [r3, #4]
300130f4:	e58d301c 	str	r3, [sp, #28]
  ICMPH_TYPE_SET(idur, ICMP_DUR);
300130f8:	e59d301c 	ldr	r3, [sp, #28]
300130fc:	e5d32000 	ldrb	r2, [r3]
30013100:	e5d33001 	ldrb	r3, [r3, #1]
30013104:	e1a03403 	lsl	r3, r3, #8
30013108:	e1833002 	orr	r3, r3, r2
3001310c:	e1a03803 	lsl	r3, r3, #16
30013110:	e1a03823 	lsr	r3, r3, #16
30013114:	e1a00003 	mov	r0, r3
30013118:	eb0001fa 	bl	30013908 <ntohs>
3001311c:	e1a03000 	mov	r3, r0
30013120:	e1a03803 	lsl	r3, r3, #16
30013124:	e1a03823 	lsr	r3, r3, #16
30013128:	e20330ff 	and	r3, r3, #255	; 0xff
3001312c:	e3833c03 	orr	r3, r3, #768	; 0x300
30013130:	e1a03803 	lsl	r3, r3, #16
30013134:	e1a03823 	lsr	r3, r3, #16
30013138:	e1a03803 	lsl	r3, r3, #16
3001313c:	e1a03823 	lsr	r3, r3, #16
30013140:	e1a00003 	mov	r0, r3
30013144:	eb0001dc 	bl	300138bc <htons>
30013148:	e1a03000 	mov	r3, r0
3001314c:	e1a02003 	mov	r2, r3
30013150:	e59d301c 	ldr	r3, [sp, #28]
30013154:	e20210ff 	and	r1, r2, #255	; 0xff
30013158:	e3a00000 	mov	r0, #0
3001315c:	e1801001 	orr	r1, r0, r1
30013160:	e5c31000 	strb	r1, [r3]
30013164:	e1a02422 	lsr	r2, r2, #8
30013168:	e1a02802 	lsl	r2, r2, #16
3001316c:	e1a02822 	lsr	r2, r2, #16
30013170:	e3a01000 	mov	r1, #0
30013174:	e1812002 	orr	r2, r1, r2
30013178:	e5c32001 	strb	r2, [r3, #1]
  ICMPH_CODE_SET(idur, t);
3001317c:	e5dd400b 	ldrb	r4, [sp, #11]
30013180:	e59d301c 	ldr	r3, [sp, #28]
30013184:	e5d32000 	ldrb	r2, [r3]
30013188:	e5d33001 	ldrb	r3, [r3, #1]
3001318c:	e1a03403 	lsl	r3, r3, #8
30013190:	e1833002 	orr	r3, r3, r2
30013194:	e1a03803 	lsl	r3, r3, #16
30013198:	e1a03823 	lsr	r3, r3, #16
3001319c:	e1a00003 	mov	r0, r3
300131a0:	eb0001d8 	bl	30013908 <ntohs>
300131a4:	e1a03000 	mov	r3, r0
300131a8:	e1a03423 	lsr	r3, r3, #8
300131ac:	e1a03803 	lsl	r3, r3, #16
300131b0:	e1a03823 	lsr	r3, r3, #16
300131b4:	e1a03403 	lsl	r3, r3, #8
300131b8:	e1a03803 	lsl	r3, r3, #16
300131bc:	e1a03823 	lsr	r3, r3, #16
300131c0:	e1a02004 	mov	r2, r4
300131c4:	e1823003 	orr	r3, r2, r3
300131c8:	e1a03803 	lsl	r3, r3, #16
300131cc:	e1a03823 	lsr	r3, r3, #16
300131d0:	e1a03803 	lsl	r3, r3, #16
300131d4:	e1a03823 	lsr	r3, r3, #16
300131d8:	e1a00003 	mov	r0, r3
300131dc:	eb0001b6 	bl	300138bc <htons>
300131e0:	e1a03000 	mov	r3, r0
300131e4:	e1a02003 	mov	r2, r3
300131e8:	e59d301c 	ldr	r3, [sp, #28]
300131ec:	e20210ff 	and	r1, r2, #255	; 0xff
300131f0:	e3a00000 	mov	r0, #0
300131f4:	e1801001 	orr	r1, r0, r1
300131f8:	e5c31000 	strb	r1, [r3]
300131fc:	e1a02422 	lsr	r2, r2, #8
30013200:	e1a02802 	lsl	r2, r2, #16
30013204:	e1a02822 	lsr	r2, r2, #16
30013208:	e3a01000 	mov	r1, #0
3001320c:	e1812002 	orr	r2, r1, r2
30013210:	e5c32001 	strb	r2, [r3, #1]

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
30013214:	e59d3014 	ldr	r3, [sp, #20]
30013218:	e5933004 	ldr	r3, [r3, #4]
3001321c:	e2832008 	add	r2, r3, #8
30013220:	e59d300c 	ldr	r3, [sp, #12]
30013224:	e5933004 	ldr	r3, [r3, #4]
30013228:	e1a00002 	mov	r0, r2
3001322c:	e1a01003 	mov	r1, r3
30013230:	e3a0201c 	mov	r2, #28
30013234:	ebffe744 	bl	3000cf4c <__re_memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
30013238:	e59d301c 	ldr	r3, [sp, #28]
3001323c:	e3a02000 	mov	r2, #0
30013240:	e5c32002 	strb	r2, [r3, #2]
30013244:	e3a02000 	mov	r2, #0
30013248:	e5c32003 	strb	r2, [r3, #3]
  idur->chksum = inet_chksum(idur, q->len);
3001324c:	e59d3014 	ldr	r3, [sp, #20]
30013250:	e1d330ba 	ldrh	r3, [r3, #10]
30013254:	e59d001c 	ldr	r0, [sp, #28]
30013258:	e1a01003 	mov	r1, r3
3001325c:	eb000380 	bl	30014064 <inet_chksum>
30013260:	e1a03000 	mov	r3, r0
30013264:	e1a02003 	mov	r2, r3
30013268:	e59d301c 	ldr	r3, [sp, #28]
3001326c:	e20210ff 	and	r1, r2, #255	; 0xff
30013270:	e3a00000 	mov	r0, #0
30013274:	e1801001 	orr	r1, r0, r1
30013278:	e5c31002 	strb	r1, [r3, #2]
3001327c:	e1a02422 	lsr	r2, r2, #8
30013280:	e1a02802 	lsl	r2, r2, #16
30013284:	e1a02822 	lsr	r2, r2, #16
30013288:	e3a01000 	mov	r1, #0
3001328c:	e1812002 	orr	r2, r1, r2
30013290:	e5c32003 	strb	r2, [r3, #3]
  ICMP_STATS_INC(icmp.xmit);
30013294:	e59f305c 	ldr	r3, [pc, #92]	; 300132f8 <icmp_dest_unreach+0x250>
30013298:	e1d336b8 	ldrh	r3, [r3, #104]	; 0x68
3001329c:	e2833001 	add	r3, r3, #1
300132a0:	e1a03803 	lsl	r3, r3, #16
300132a4:	e1a02823 	lsr	r2, r3, #16
300132a8:	e59f3048 	ldr	r3, [pc, #72]	; 300132f8 <icmp_dest_unreach+0x250>
300132ac:	e1c326b8 	strh	r2, [r3, #104]	; 0x68
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
300132b0:	e59d3018 	ldr	r3, [sp, #24]
300132b4:	e283300c 	add	r3, r3, #12
300132b8:	e3a02000 	mov	r2, #0
300132bc:	e58d2000 	str	r2, [sp]
300132c0:	e3a02001 	mov	r2, #1
300132c4:	e58d2004 	str	r2, [sp, #4]
300132c8:	e59d0014 	ldr	r0, [sp, #20]
300132cc:	e3a01000 	mov	r1, #0
300132d0:	e1a02003 	mov	r2, r3
300132d4:	e3a030ff 	mov	r3, #255	; 0xff
300132d8:	eb0006ea 	bl	30014e88 <ip_output>
  pbuf_free(q);
300132dc:	e59d0014 	ldr	r0, [sp, #20]
300132e0:	eb000c92 	bl	30016530 <pbuf_free>
300132e4:	ea000000 	b	300132ec <icmp_dest_unreach+0x244>
  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
300132e8:	e1a00000 	nop			; (mov r0, r0)
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
300132ec:	e28dd020 	add	sp, sp, #32
300132f0:	e8bd4010 	pop	{r4, lr}
300132f4:	e12fff1e 	bx	lr
300132f8:	3002b214 	.word	0x3002b214

300132fc <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
300132fc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30013300:	e24dd014 	sub	sp, sp, #20
30013304:	e58d0004 	str	r0, [sp, #4]
  struct in_addr val;

  if (inet_aton(cp, &val)) {
30013308:	e28d300c 	add	r3, sp, #12
3001330c:	e59d0004 	ldr	r0, [sp, #4]
30013310:	e1a01003 	mov	r1, r3
30013314:	eb000009 	bl	30013340 <inet_aton>
30013318:	e1a03000 	mov	r3, r0
3001331c:	e3530000 	cmp	r3, #0
30013320:	0a000001 	beq	3001332c <inet_addr+0x30>
    return (val.s_addr);
30013324:	e59d300c 	ldr	r3, [sp, #12]
30013328:	ea000000 	b	30013330 <inet_addr+0x34>
  }
  return (INADDR_NONE);
3001332c:	e3e03000 	mvn	r3, #0
}
30013330:	e1a00003 	mov	r0, r3
30013334:	e28dd014 	add	sp, sp, #20
30013338:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001333c:	e12fff1e 	bx	lr

30013340 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
30013340:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30013344:	e24dd034 	sub	sp, sp, #52	; 0x34
30013348:	e58d0004 	str	r0, [sp, #4]
3001334c:	e58d1000 	str	r1, [sp]
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
30013350:	e28d300c 	add	r3, sp, #12
30013354:	e58d302c 	str	r3, [sp, #44]	; 0x2c

  c = *cp;
30013358:	e59d3004 	ldr	r3, [sp, #4]
3001335c:	e5d33000 	ldrb	r3, [r3]
30013360:	e58d3028 	str	r3, [sp, #40]	; 0x28
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
30013364:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013368:	e20330ff 	and	r3, r3, #255	; 0xff
3001336c:	e353002f 	cmp	r3, #47	; 0x2f
30013370:	9a000003 	bls	30013384 <inet_aton+0x44>
30013374:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013378:	e20330ff 	and	r3, r3, #255	; 0xff
3001337c:	e3530039 	cmp	r3, #57	; 0x39
30013380:	9a000001 	bls	3001338c <inet_aton+0x4c>
      return (0);
30013384:	e3a03000 	mov	r3, #0
30013388:	ea0000e6 	b	30013728 <inet_aton+0x3e8>
    val = 0;
3001338c:	e3a03000 	mov	r3, #0
30013390:	e58d301c 	str	r3, [sp, #28]
    base = 10;
30013394:	e3a0300a 	mov	r3, #10
30013398:	e58d3020 	str	r3, [sp, #32]
    if (c == '0') {
3001339c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300133a0:	e3530030 	cmp	r3, #48	; 0x30
300133a4:	1a000016 	bne	30013404 <inet_aton+0xc4>
      c = *++cp;
300133a8:	e59d3004 	ldr	r3, [sp, #4]
300133ac:	e2833001 	add	r3, r3, #1
300133b0:	e58d3004 	str	r3, [sp, #4]
300133b4:	e59d3004 	ldr	r3, [sp, #4]
300133b8:	e5d33000 	ldrb	r3, [r3]
300133bc:	e58d3028 	str	r3, [sp, #40]	; 0x28
      if (c == 'x' || c == 'X') {
300133c0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300133c4:	e3530078 	cmp	r3, #120	; 0x78
300133c8:	0a000002 	beq	300133d8 <inet_aton+0x98>
300133cc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300133d0:	e3530058 	cmp	r3, #88	; 0x58
300133d4:	1a000008 	bne	300133fc <inet_aton+0xbc>
        base = 16;
300133d8:	e3a03010 	mov	r3, #16
300133dc:	e58d3020 	str	r3, [sp, #32]
        c = *++cp;
300133e0:	e59d3004 	ldr	r3, [sp, #4]
300133e4:	e2833001 	add	r3, r3, #1
300133e8:	e58d3004 	str	r3, [sp, #4]
300133ec:	e59d3004 	ldr	r3, [sp, #4]
300133f0:	e5d33000 	ldrb	r3, [r3]
300133f4:	e58d3028 	str	r3, [sp, #40]	; 0x28
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
300133f8:	ea000001 	b	30013404 <inet_aton+0xc4>
        base = 16;
        c = *++cp;
      } else
        base = 8;
300133fc:	e3a03008 	mov	r3, #8
30013400:	e58d3020 	str	r3, [sp, #32]
    }
    for (;;) {
      if (isdigit(c)) {
30013404:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013408:	e20330ff 	and	r3, r3, #255	; 0xff
3001340c:	e353002f 	cmp	r3, #47	; 0x2f
30013410:	9a000012 	bls	30013460 <inet_aton+0x120>
30013414:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013418:	e20330ff 	and	r3, r3, #255	; 0xff
3001341c:	e3530039 	cmp	r3, #57	; 0x39
30013420:	8a00000e 	bhi	30013460 <inet_aton+0x120>
        val = (val * base) + (int)(c - '0');
30013424:	e59d3020 	ldr	r3, [sp, #32]
30013428:	e59d201c 	ldr	r2, [sp, #28]
3001342c:	e0020293 	mul	r2, r3, r2
30013430:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013434:	e0823003 	add	r3, r2, r3
30013438:	e2433030 	sub	r3, r3, #48	; 0x30
3001343c:	e58d301c 	str	r3, [sp, #28]
        c = *++cp;
30013440:	e59d3004 	ldr	r3, [sp, #4]
30013444:	e2833001 	add	r3, r3, #1
30013448:	e58d3004 	str	r3, [sp, #4]
3001344c:	e59d3004 	ldr	r3, [sp, #4]
30013450:	e5d33000 	ldrb	r3, [r3]
30013454:	e58d3028 	str	r3, [sp, #40]	; 0x28
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
30013458:	e1a00000 	nop			; (mov r0, r0)
      } else if (base == 16 && isxdigit(c)) {
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
3001345c:	eaffffe8 	b	30013404 <inet_aton+0xc4>
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
30013460:	e59d3020 	ldr	r3, [sp, #32]
30013464:	e3530010 	cmp	r3, #16
30013468:	1a000030 	bne	30013530 <inet_aton+0x1f0>
3001346c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013470:	e20330ff 	and	r3, r3, #255	; 0xff
30013474:	e353002f 	cmp	r3, #47	; 0x2f
30013478:	9a000003 	bls	3001348c <inet_aton+0x14c>
3001347c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013480:	e20330ff 	and	r3, r3, #255	; 0xff
30013484:	e3530039 	cmp	r3, #57	; 0x39
30013488:	9a00000f 	bls	300134cc <inet_aton+0x18c>
3001348c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013490:	e20330ff 	and	r3, r3, #255	; 0xff
30013494:	e3530060 	cmp	r3, #96	; 0x60
30013498:	9a000003 	bls	300134ac <inet_aton+0x16c>
3001349c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300134a0:	e20330ff 	and	r3, r3, #255	; 0xff
300134a4:	e3530066 	cmp	r3, #102	; 0x66
300134a8:	9a000007 	bls	300134cc <inet_aton+0x18c>
300134ac:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300134b0:	e20330ff 	and	r3, r3, #255	; 0xff
300134b4:	e3530040 	cmp	r3, #64	; 0x40
300134b8:	9a00001c 	bls	30013530 <inet_aton+0x1f0>
300134bc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300134c0:	e20330ff 	and	r3, r3, #255	; 0xff
300134c4:	e3530046 	cmp	r3, #70	; 0x46
300134c8:	8a000018 	bhi	30013530 <inet_aton+0x1f0>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
300134cc:	e59d301c 	ldr	r3, [sp, #28]
300134d0:	e1a02203 	lsl	r2, r3, #4
300134d4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300134d8:	e283100a 	add	r1, r3, #10
300134dc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300134e0:	e20330ff 	and	r3, r3, #255	; 0xff
300134e4:	e3530060 	cmp	r3, #96	; 0x60
300134e8:	9a000005 	bls	30013504 <inet_aton+0x1c4>
300134ec:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300134f0:	e20330ff 	and	r3, r3, #255	; 0xff
300134f4:	e353007a 	cmp	r3, #122	; 0x7a
300134f8:	8a000001 	bhi	30013504 <inet_aton+0x1c4>
300134fc:	e3a03061 	mov	r3, #97	; 0x61
30013500:	ea000000 	b	30013508 <inet_aton+0x1c8>
30013504:	e3a03041 	mov	r3, #65	; 0x41
30013508:	e0633001 	rsb	r3, r3, r1
3001350c:	e1823003 	orr	r3, r2, r3
30013510:	e58d301c 	str	r3, [sp, #28]
        c = *++cp;
30013514:	e59d3004 	ldr	r3, [sp, #4]
30013518:	e2833001 	add	r3, r3, #1
3001351c:	e58d3004 	str	r3, [sp, #4]
30013520:	e59d3004 	ldr	r3, [sp, #4]
30013524:	e5d33000 	ldrb	r3, [r3]
30013528:	e58d3028 	str	r3, [sp, #40]	; 0x28
      } else
        break;
    }
3001352c:	eaffffb4 	b	30013404 <inet_aton+0xc4>
    if (c == '.') {
30013530:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013534:	e353002e 	cmp	r3, #46	; 0x2e
30013538:	1a000013 	bne	3001358c <inet_aton+0x24c>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
3001353c:	e28d300c 	add	r3, sp, #12
30013540:	e283200c 	add	r2, r3, #12
30013544:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30013548:	e1520003 	cmp	r2, r3
3001354c:	8a000001 	bhi	30013558 <inet_aton+0x218>
        return (0);
30013550:	e3a03000 	mov	r3, #0
30013554:	ea000073 	b	30013728 <inet_aton+0x3e8>
      *pp++ = val;
30013558:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3001355c:	e59d201c 	ldr	r2, [sp, #28]
30013560:	e5832000 	str	r2, [r3]
30013564:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30013568:	e2833004 	add	r3, r3, #4
3001356c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
      c = *++cp;
30013570:	e59d3004 	ldr	r3, [sp, #4]
30013574:	e2833001 	add	r3, r3, #1
30013578:	e58d3004 	str	r3, [sp, #4]
3001357c:	e59d3004 	ldr	r3, [sp, #4]
30013580:	e5d33000 	ldrb	r3, [r3]
30013584:	e58d3028 	str	r3, [sp, #40]	; 0x28
    } else
      break;
  }
30013588:	eaffff75 	b	30013364 <inet_aton+0x24>
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
3001358c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013590:	e3530000 	cmp	r3, #0
30013594:	0a00001d 	beq	30013610 <inet_aton+0x2d0>
30013598:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001359c:	e20330ff 	and	r3, r3, #255	; 0xff
300135a0:	e353001f 	cmp	r3, #31
300135a4:	9a000017 	bls	30013608 <inet_aton+0x2c8>
300135a8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300135ac:	e20330ff 	and	r3, r3, #255	; 0xff
300135b0:	e1a03c03 	lsl	r3, r3, #24
300135b4:	e1a03c43 	asr	r3, r3, #24
300135b8:	e3530000 	cmp	r3, #0
300135bc:	ba000011 	blt	30013608 <inet_aton+0x2c8>
300135c0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300135c4:	e3530020 	cmp	r3, #32
300135c8:	0a000010 	beq	30013610 <inet_aton+0x2d0>
300135cc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300135d0:	e353000c 	cmp	r3, #12
300135d4:	0a00000d 	beq	30013610 <inet_aton+0x2d0>
300135d8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300135dc:	e353000a 	cmp	r3, #10
300135e0:	0a00000a 	beq	30013610 <inet_aton+0x2d0>
300135e4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300135e8:	e353000d 	cmp	r3, #13
300135ec:	0a000007 	beq	30013610 <inet_aton+0x2d0>
300135f0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300135f4:	e3530009 	cmp	r3, #9
300135f8:	0a000004 	beq	30013610 <inet_aton+0x2d0>
300135fc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013600:	e353000b 	cmp	r3, #11
30013604:	0a000001 	beq	30013610 <inet_aton+0x2d0>
    return (0);
30013608:	e3a03000 	mov	r3, #0
3001360c:	ea000045 	b	30013728 <inet_aton+0x3e8>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
30013610:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30013614:	e28d300c 	add	r3, sp, #12
30013618:	e0633002 	rsb	r3, r3, r2
3001361c:	e1a03143 	asr	r3, r3, #2
30013620:	e2833001 	add	r3, r3, #1
30013624:	e58d3024 	str	r3, [sp, #36]	; 0x24
  switch (n) {
30013628:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001362c:	e3530004 	cmp	r3, #4
30013630:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30013634:	ea000032 	b	30013704 <inet_aton+0x3c4>
30013638:	3001364c 	.word	0x3001364c
3001363c:	30013704 	.word	0x30013704
30013640:	30013654 	.word	0x30013654
30013644:	30013684 	.word	0x30013684
30013648:	300136c4 	.word	0x300136c4

  case 0:
    return (0);       /* initial nondigit */
3001364c:	e3a03000 	mov	r3, #0
30013650:	ea000034 	b	30013728 <inet_aton+0x3e8>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
30013654:	e59d201c 	ldr	r2, [sp, #28]
30013658:	e3e034ff 	mvn	r3, #-16777216	; 0xff000000
3001365c:	e1520003 	cmp	r2, r3
30013660:	9a000001 	bls	3001366c <inet_aton+0x32c>
      return (0);
30013664:	e3a03000 	mov	r3, #0
30013668:	ea00002e 	b	30013728 <inet_aton+0x3e8>
    val |= parts[0] << 24;
3001366c:	e59d300c 	ldr	r3, [sp, #12]
30013670:	e1a03c03 	lsl	r3, r3, #24
30013674:	e59d201c 	ldr	r2, [sp, #28]
30013678:	e1823003 	orr	r3, r2, r3
3001367c:	e58d301c 	str	r3, [sp, #28]
    break;
30013680:	ea00001f 	b	30013704 <inet_aton+0x3c4>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
30013684:	e59d201c 	ldr	r2, [sp, #28]
30013688:	e3a03801 	mov	r3, #65536	; 0x10000
3001368c:	e2433001 	sub	r3, r3, #1
30013690:	e1520003 	cmp	r2, r3
30013694:	9a000001 	bls	300136a0 <inet_aton+0x360>
      return (0);
30013698:	e3a03000 	mov	r3, #0
3001369c:	ea000021 	b	30013728 <inet_aton+0x3e8>
    val |= (parts[0] << 24) | (parts[1] << 16);
300136a0:	e59d300c 	ldr	r3, [sp, #12]
300136a4:	e1a02c03 	lsl	r2, r3, #24
300136a8:	e59d3010 	ldr	r3, [sp, #16]
300136ac:	e1a03803 	lsl	r3, r3, #16
300136b0:	e1823003 	orr	r3, r2, r3
300136b4:	e59d201c 	ldr	r2, [sp, #28]
300136b8:	e1823003 	orr	r3, r2, r3
300136bc:	e58d301c 	str	r3, [sp, #28]
    break;
300136c0:	ea00000f 	b	30013704 <inet_aton+0x3c4>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
300136c4:	e59d301c 	ldr	r3, [sp, #28]
300136c8:	e35300ff 	cmp	r3, #255	; 0xff
300136cc:	9a000001 	bls	300136d8 <inet_aton+0x398>
      return (0);
300136d0:	e3a03000 	mov	r3, #0
300136d4:	ea000013 	b	30013728 <inet_aton+0x3e8>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
300136d8:	e59d300c 	ldr	r3, [sp, #12]
300136dc:	e1a02c03 	lsl	r2, r3, #24
300136e0:	e59d3010 	ldr	r3, [sp, #16]
300136e4:	e1a03803 	lsl	r3, r3, #16
300136e8:	e1822003 	orr	r2, r2, r3
300136ec:	e59d3014 	ldr	r3, [sp, #20]
300136f0:	e1a03403 	lsl	r3, r3, #8
300136f4:	e1823003 	orr	r3, r2, r3
300136f8:	e59d201c 	ldr	r2, [sp, #28]
300136fc:	e1823003 	orr	r3, r2, r3
30013700:	e58d301c 	str	r3, [sp, #28]
    break;
  }
  if (addr)
30013704:	e59d3000 	ldr	r3, [sp]
30013708:	e3530000 	cmp	r3, #0
3001370c:	0a000004 	beq	30013724 <inet_aton+0x3e4>
    addr->s_addr = htonl(val);
30013710:	e59d001c 	ldr	r0, [sp, #28]
30013714:	eb000087 	bl	30013938 <htonl>
30013718:	e1a02000 	mov	r2, r0
3001371c:	e59d3000 	ldr	r3, [sp]
30013720:	e5832000 	str	r2, [r3]
  return (1);
30013724:	e3a03001 	mov	r3, #1
}
30013728:	e1a00003 	mov	r0, r3
3001372c:	e28dd034 	add	sp, sp, #52	; 0x34
30013730:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30013734:	e12fff1e 	bx	lr

30013738 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
30013738:	e24dd020 	sub	sp, sp, #32
3001373c:	e58d0004 	str	r0, [sp, #4]
  static char str[16];
  u32_t s_addr = addr.s_addr;
30013740:	e59d3004 	ldr	r3, [sp, #4]
30013744:	e58d3010 	str	r3, [sp, #16]
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
30013748:	e59f3164 	ldr	r3, [pc, #356]	; 300138b4 <inet_ntoa+0x17c>
3001374c:	e58d3014 	str	r3, [sp, #20]
  ap = (u8_t *)&s_addr;
30013750:	e28d3010 	add	r3, sp, #16
30013754:	e58d3018 	str	r3, [sp, #24]
  for(n = 0; n < 4; n++) {
30013758:	e3a03000 	mov	r3, #0
3001375c:	e5cd301e 	strb	r3, [sp, #30]
30013760:	ea000046 	b	30013880 <inet_ntoa+0x148>
    i = 0;
30013764:	e3a03000 	mov	r3, #0
30013768:	e5cd301f 	strb	r3, [sp, #31]
    do {
      rem = *ap % (u8_t)10;
3001376c:	e59d3018 	ldr	r3, [sp, #24]
30013770:	e5d32000 	ldrb	r2, [r3]
30013774:	e59f313c 	ldr	r3, [pc, #316]	; 300138b8 <inet_ntoa+0x180>
30013778:	e0830392 	umull	r0, r3, r2, r3
3001377c:	e1a011a3 	lsr	r1, r3, #3
30013780:	e1a03001 	mov	r3, r1
30013784:	e1a03103 	lsl	r3, r3, #2
30013788:	e0833001 	add	r3, r3, r1
3001378c:	e1a03083 	lsl	r3, r3, #1
30013790:	e0633002 	rsb	r3, r3, r2
30013794:	e5cd301d 	strb	r3, [sp, #29]
      *ap /= (u8_t)10;
30013798:	e59d3018 	ldr	r3, [sp, #24]
3001379c:	e5d32000 	ldrb	r2, [r3]
300137a0:	e59f3110 	ldr	r3, [pc, #272]	; 300138b8 <inet_ntoa+0x180>
300137a4:	e0831392 	umull	r1, r3, r2, r3
300137a8:	e1a031a3 	lsr	r3, r3, #3
300137ac:	e20320ff 	and	r2, r3, #255	; 0xff
300137b0:	e59d3018 	ldr	r3, [sp, #24]
300137b4:	e5c32000 	strb	r2, [r3]
      inv[i++] = '0' + rem;
300137b8:	e5dd101f 	ldrb	r1, [sp, #31]
300137bc:	e5dd301d 	ldrb	r3, [sp, #29]
300137c0:	e2833030 	add	r3, r3, #48	; 0x30
300137c4:	e20320ff 	and	r2, r3, #255	; 0xff
300137c8:	e3e03013 	mvn	r3, #19
300137cc:	e28d0020 	add	r0, sp, #32
300137d0:	e0801001 	add	r1, r0, r1
300137d4:	e0813003 	add	r3, r1, r3
300137d8:	e5c32000 	strb	r2, [r3]
300137dc:	e5dd301f 	ldrb	r3, [sp, #31]
300137e0:	e2833001 	add	r3, r3, #1
300137e4:	e5cd301f 	strb	r3, [sp, #31]
    } while(*ap);
300137e8:	e59d3018 	ldr	r3, [sp, #24]
300137ec:	e5d33000 	ldrb	r3, [r3]
300137f0:	e3530000 	cmp	r3, #0
300137f4:	1affffdc 	bne	3001376c <inet_ntoa+0x34>
    while(i--)
300137f8:	ea00000a 	b	30013828 <inet_ntoa+0xf0>
      *rp++ = inv[i];
300137fc:	e5dd201f 	ldrb	r2, [sp, #31]
30013800:	e3e03013 	mvn	r3, #19
30013804:	e28d1020 	add	r1, sp, #32
30013808:	e0812002 	add	r2, r1, r2
3001380c:	e0823003 	add	r3, r2, r3
30013810:	e5d32000 	ldrb	r2, [r3]
30013814:	e59d3014 	ldr	r3, [sp, #20]
30013818:	e5c32000 	strb	r2, [r3]
3001381c:	e59d3014 	ldr	r3, [sp, #20]
30013820:	e2833001 	add	r3, r3, #1
30013824:	e58d3014 	str	r3, [sp, #20]
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
30013828:	e5dd301f 	ldrb	r3, [sp, #31]
3001382c:	e3530000 	cmp	r3, #0
30013830:	03a03000 	moveq	r3, #0
30013834:	13a03001 	movne	r3, #1
30013838:	e20330ff 	and	r3, r3, #255	; 0xff
3001383c:	e5dd201f 	ldrb	r2, [sp, #31]
30013840:	e2422001 	sub	r2, r2, #1
30013844:	e5cd201f 	strb	r2, [sp, #31]
30013848:	e3530000 	cmp	r3, #0
3001384c:	1affffea 	bne	300137fc <inet_ntoa+0xc4>
      *rp++ = inv[i];
    *rp++ = '.';
30013850:	e59d3014 	ldr	r3, [sp, #20]
30013854:	e3a0202e 	mov	r2, #46	; 0x2e
30013858:	e5c32000 	strb	r2, [r3]
3001385c:	e59d3014 	ldr	r3, [sp, #20]
30013860:	e2833001 	add	r3, r3, #1
30013864:	e58d3014 	str	r3, [sp, #20]
    ap++;
30013868:	e59d3018 	ldr	r3, [sp, #24]
3001386c:	e2833001 	add	r3, r3, #1
30013870:	e58d3018 	str	r3, [sp, #24]
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
30013874:	e5dd301e 	ldrb	r3, [sp, #30]
30013878:	e2833001 	add	r3, r3, #1
3001387c:	e5cd301e 	strb	r3, [sp, #30]
30013880:	e5dd301e 	ldrb	r3, [sp, #30]
30013884:	e3530003 	cmp	r3, #3
30013888:	9affffb5 	bls	30013764 <inet_ntoa+0x2c>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
3001388c:	e59d3014 	ldr	r3, [sp, #20]
30013890:	e2433001 	sub	r3, r3, #1
30013894:	e58d3014 	str	r3, [sp, #20]
30013898:	e59d3014 	ldr	r3, [sp, #20]
3001389c:	e3a02000 	mov	r2, #0
300138a0:	e5c32000 	strb	r2, [r3]
  return str;
300138a4:	e59f3008 	ldr	r3, [pc, #8]	; 300138b4 <inet_ntoa+0x17c>
}
300138a8:	e1a00003 	mov	r0, r3
300138ac:	e28dd020 	add	sp, sp, #32
300138b0:	e12fff1e 	bx	lr
300138b4:	30027214 	.word	0x30027214
300138b8:	cccccccd 	.word	0xcccccccd

300138bc <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
300138bc:	e24dd008 	sub	sp, sp, #8
300138c0:	e1a03000 	mov	r3, r0
300138c4:	e1cd30b6 	strh	r3, [sp, #6]
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
300138c8:	e1dd30b6 	ldrh	r3, [sp, #6]
300138cc:	e1a03403 	lsl	r3, r3, #8
300138d0:	e1a03803 	lsl	r3, r3, #16
300138d4:	e1a02823 	lsr	r2, r3, #16
300138d8:	e1dd30b6 	ldrh	r3, [sp, #6]
300138dc:	e1a03423 	lsr	r3, r3, #8
300138e0:	e1a03803 	lsl	r3, r3, #16
300138e4:	e1a03823 	lsr	r3, r3, #16
300138e8:	e1823003 	orr	r3, r2, r3
300138ec:	e1a03803 	lsl	r3, r3, #16
300138f0:	e1a03823 	lsr	r3, r3, #16
300138f4:	e1a03803 	lsl	r3, r3, #16
300138f8:	e1a03823 	lsr	r3, r3, #16
}
300138fc:	e1a00003 	mov	r0, r3
30013900:	e28dd008 	add	sp, sp, #8
30013904:	e12fff1e 	bx	lr

30013908 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
30013908:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001390c:	e24dd00c 	sub	sp, sp, #12
30013910:	e1a03000 	mov	r3, r0
30013914:	e1cd30b6 	strh	r3, [sp, #6]
  return htons(n);
30013918:	e1dd30b6 	ldrh	r3, [sp, #6]
3001391c:	e1a00003 	mov	r0, r3
30013920:	ebffffe5 	bl	300138bc <htons>
30013924:	e1a03000 	mov	r3, r0
}
30013928:	e1a00003 	mov	r0, r3
3001392c:	e28dd00c 	add	sp, sp, #12
30013930:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30013934:	e12fff1e 	bx	lr

30013938 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
30013938:	e24dd008 	sub	sp, sp, #8
3001393c:	e58d0004 	str	r0, [sp, #4]
  return ((n & 0xff) << 24) |
30013940:	e59d3004 	ldr	r3, [sp, #4]
30013944:	e1a02c03 	lsl	r2, r3, #24
    ((n & 0xff00) << 8) |
30013948:	e59d3004 	ldr	r3, [sp, #4]
3001394c:	e2033cff 	and	r3, r3, #65280	; 0xff00
30013950:	e1a03403 	lsl	r3, r3, #8
30013954:	e1822003 	orr	r2, r2, r3
    ((n & 0xff0000UL) >> 8) |
30013958:	e59d3004 	ldr	r3, [sp, #4]
3001395c:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
30013960:	e1a03423 	lsr	r3, r3, #8
30013964:	e1822003 	orr	r2, r2, r3
    ((n & 0xff000000UL) >> 24);
30013968:	e59d3004 	ldr	r3, [sp, #4]
3001396c:	e1a03c23 	lsr	r3, r3, #24
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
30013970:	e1823003 	orr	r3, r2, r3
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
30013974:	e1a00003 	mov	r0, r3
30013978:	e28dd008 	add	sp, sp, #8
3001397c:	e12fff1e 	bx	lr

30013980 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
30013980:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30013984:	e24dd00c 	sub	sp, sp, #12
30013988:	e58d0004 	str	r0, [sp, #4]
  return htonl(n);
3001398c:	e59d0004 	ldr	r0, [sp, #4]
30013990:	ebffffe8 	bl	30013938 <htonl>
30013994:	e1a03000 	mov	r3, r0
}
30013998:	e1a00003 	mov	r0, r3
3001399c:	e28dd00c 	add	sp, sp, #12
300139a0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300139a4:	e12fff1e 	bx	lr

300139a8 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
300139a8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300139ac:	e24dd01c 	sub	sp, sp, #28
300139b0:	e58d0004 	str	r0, [sp, #4]
300139b4:	e1a03001 	mov	r3, r1
300139b8:	e1cd30b2 	strh	r3, [sp, #2]
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
300139bc:	e3a03000 	mov	r3, #0
300139c0:	e58d300c 	str	r3, [sp, #12]
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
300139c4:	e59d3004 	ldr	r3, [sp, #4]
300139c8:	e58d3014 	str	r3, [sp, #20]
  while (len > 1)
300139cc:	ea000016 	b	30013a2c <lwip_standard_chksum+0x84>
  {
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
300139d0:	e59d3014 	ldr	r3, [sp, #20]
300139d4:	e5d33000 	ldrb	r3, [r3]
300139d8:	e1a03403 	lsl	r3, r3, #8
300139dc:	e1cd31b2 	strh	r3, [sp, #18]
    octetptr++;
300139e0:	e59d3014 	ldr	r3, [sp, #20]
300139e4:	e2833001 	add	r3, r3, #1
300139e8:	e58d3014 	str	r3, [sp, #20]
    /* declare second octet as least significant */
    src |= (*octetptr);
300139ec:	e59d3014 	ldr	r3, [sp, #20]
300139f0:	e5d33000 	ldrb	r3, [r3]
300139f4:	e1a02003 	mov	r2, r3
300139f8:	e1dd31b2 	ldrh	r3, [sp, #18]
300139fc:	e1823003 	orr	r3, r2, r3
30013a00:	e1cd31b2 	strh	r3, [sp, #18]
    octetptr++;
30013a04:	e59d3014 	ldr	r3, [sp, #20]
30013a08:	e2833001 	add	r3, r3, #1
30013a0c:	e58d3014 	str	r3, [sp, #20]
    acc += src;
30013a10:	e1dd31b2 	ldrh	r3, [sp, #18]
30013a14:	e59d200c 	ldr	r2, [sp, #12]
30013a18:	e0823003 	add	r3, r2, r3
30013a1c:	e58d300c 	str	r3, [sp, #12]
    len -= 2;
30013a20:	e1dd30b2 	ldrh	r3, [sp, #2]
30013a24:	e2433002 	sub	r3, r3, #2
30013a28:	e1cd30b2 	strh	r3, [sp, #2]
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1)
30013a2c:	e1dd30b2 	ldrh	r3, [sp, #2]
30013a30:	e3530001 	cmp	r3, #1
30013a34:	8affffe5 	bhi	300139d0 <lwip_standard_chksum+0x28>
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0)
30013a38:	e1dd30b2 	ldrh	r3, [sp, #2]
30013a3c:	e3530000 	cmp	r3, #0
30013a40:	0a000007 	beq	30013a64 <lwip_standard_chksum+0xbc>
  {
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
30013a44:	e59d3014 	ldr	r3, [sp, #20]
30013a48:	e5d33000 	ldrb	r3, [r3]
30013a4c:	e1a03403 	lsl	r3, r3, #8
30013a50:	e1cd31b2 	strh	r3, [sp, #18]
    acc += src;
30013a54:	e1dd31b2 	ldrh	r3, [sp, #18]
30013a58:	e59d200c 	ldr	r2, [sp, #12]
30013a5c:	e0823003 	add	r3, r2, r3
30013a60:	e58d300c 	str	r3, [sp, #12]
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
30013a64:	e59d300c 	ldr	r3, [sp, #12]
30013a68:	e1a02823 	lsr	r2, r3, #16
30013a6c:	e59d300c 	ldr	r3, [sp, #12]
30013a70:	e1a03803 	lsl	r3, r3, #16
30013a74:	e1a03823 	lsr	r3, r3, #16
30013a78:	e0823003 	add	r3, r2, r3
30013a7c:	e58d300c 	str	r3, [sp, #12]
  if ((acc & 0xffff0000) != 0) {
30013a80:	e59d300c 	ldr	r3, [sp, #12]
30013a84:	e1a03823 	lsr	r3, r3, #16
30013a88:	e1a03803 	lsl	r3, r3, #16
30013a8c:	e3530000 	cmp	r3, #0
30013a90:	0a000006 	beq	30013ab0 <lwip_standard_chksum+0x108>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
30013a94:	e59d300c 	ldr	r3, [sp, #12]
30013a98:	e1a02823 	lsr	r2, r3, #16
30013a9c:	e59d300c 	ldr	r3, [sp, #12]
30013aa0:	e1a03803 	lsl	r3, r3, #16
30013aa4:	e1a03823 	lsr	r3, r3, #16
30013aa8:	e0823003 	add	r3, r2, r3
30013aac:	e58d300c 	str	r3, [sp, #12]
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
30013ab0:	e59d300c 	ldr	r3, [sp, #12]
30013ab4:	e1a03803 	lsl	r3, r3, #16
30013ab8:	e1a03823 	lsr	r3, r3, #16
30013abc:	e1a00003 	mov	r0, r3
30013ac0:	ebffff7d 	bl	300138bc <htons>
30013ac4:	e1a03000 	mov	r3, r0
}
30013ac8:	e1a00003 	mov	r0, r3
30013acc:	e28dd01c 	add	sp, sp, #28
30013ad0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30013ad4:	e12fff1e 	bx	lr

30013ad8 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
30013ad8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30013adc:	e24dd024 	sub	sp, sp, #36	; 0x24
30013ae0:	e58d000c 	str	r0, [sp, #12]
30013ae4:	e58d1008 	str	r1, [sp, #8]
30013ae8:	e58d2004 	str	r2, [sp, #4]
30013aec:	e5cd3003 	strb	r3, [sp, #3]
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
30013af0:	e3a03000 	mov	r3, #0
30013af4:	e58d3014 	str	r3, [sp, #20]
  swapped = 0;
30013af8:	e3a03000 	mov	r3, #0
30013afc:	e5cd301f 	strb	r3, [sp, #31]
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
30013b00:	e59d300c 	ldr	r3, [sp, #12]
30013b04:	e58d3018 	str	r3, [sp, #24]
30013b08:	ea00002b 	b	30013bbc <inet_chksum_pseudo+0xe4>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
30013b0c:	e59d3018 	ldr	r3, [sp, #24]
30013b10:	e5932004 	ldr	r2, [r3, #4]
30013b14:	e59d3018 	ldr	r3, [sp, #24]
30013b18:	e1d330ba 	ldrh	r3, [r3, #10]
30013b1c:	e1a00002 	mov	r0, r2
30013b20:	e1a01003 	mov	r1, r3
30013b24:	ebffff9f 	bl	300139a8 <lwip_standard_chksum>
30013b28:	e1a03000 	mov	r3, r0
30013b2c:	e59d2014 	ldr	r2, [sp, #20]
30013b30:	e0823003 	add	r3, r2, r3
30013b34:	e58d3014 	str	r3, [sp, #20]
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    while ((acc >> 16) != 0) {
30013b38:	ea000006 	b	30013b58 <inet_chksum_pseudo+0x80>
      acc = (acc & 0xffffUL) + (acc >> 16);
30013b3c:	e59d3014 	ldr	r3, [sp, #20]
30013b40:	e1a03803 	lsl	r3, r3, #16
30013b44:	e1a03823 	lsr	r3, r3, #16
30013b48:	e59d2014 	ldr	r2, [sp, #20]
30013b4c:	e1a02822 	lsr	r2, r2, #16
30013b50:	e0833002 	add	r3, r3, r2
30013b54:	e58d3014 	str	r3, [sp, #20]
  for(q = p; q != NULL; q = q->next) {
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    while ((acc >> 16) != 0) {
30013b58:	e59d3014 	ldr	r3, [sp, #20]
30013b5c:	e1a03823 	lsr	r3, r3, #16
30013b60:	e3530000 	cmp	r3, #0
30013b64:	1afffff4 	bne	30013b3c <inet_chksum_pseudo+0x64>
      acc = (acc & 0xffffUL) + (acc >> 16);
    }
    if (q->len % 2 != 0) {
30013b68:	e59d3018 	ldr	r3, [sp, #24]
30013b6c:	e1d330ba 	ldrh	r3, [r3, #10]
30013b70:	e2033001 	and	r3, r3, #1
30013b74:	e20330ff 	and	r3, r3, #255	; 0xff
30013b78:	e3530000 	cmp	r3, #0
30013b7c:	0a00000b 	beq	30013bb0 <inet_chksum_pseudo+0xd8>
      swapped = 1 - swapped;
30013b80:	e5dd301f 	ldrb	r3, [sp, #31]
30013b84:	e2633001 	rsb	r3, r3, #1
30013b88:	e5cd301f 	strb	r3, [sp, #31]
      acc = ((acc & 0xff) << 8) | ((acc & 0xff00UL) >> 8);
30013b8c:	e59d3014 	ldr	r3, [sp, #20]
30013b90:	e1a03403 	lsl	r3, r3, #8
30013b94:	e1a03803 	lsl	r3, r3, #16
30013b98:	e1a03823 	lsr	r3, r3, #16
30013b9c:	e59d2014 	ldr	r2, [sp, #20]
30013ba0:	e2022cff 	and	r2, r2, #65280	; 0xff00
30013ba4:	e1a02422 	lsr	r2, r2, #8
30013ba8:	e1833002 	orr	r3, r3, r2
30013bac:	e58d3014 	str	r3, [sp, #20]
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
30013bb0:	e59d3018 	ldr	r3, [sp, #24]
30013bb4:	e5933000 	ldr	r3, [r3]
30013bb8:	e58d3018 	str	r3, [sp, #24]
30013bbc:	e59d3018 	ldr	r3, [sp, #24]
30013bc0:	e3530000 	cmp	r3, #0
30013bc4:	1affffd0 	bne	30013b0c <inet_chksum_pseudo+0x34>
      acc = ((acc & 0xff) << 8) | ((acc & 0xff00UL) >> 8);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
30013bc8:	e5dd301f 	ldrb	r3, [sp, #31]
30013bcc:	e3530000 	cmp	r3, #0
30013bd0:	0a000008 	beq	30013bf8 <inet_chksum_pseudo+0x120>
    acc = ((acc & 0xff) << 8) | ((acc & 0xff00UL) >> 8);
30013bd4:	e59d3014 	ldr	r3, [sp, #20]
30013bd8:	e1a03403 	lsl	r3, r3, #8
30013bdc:	e1a03803 	lsl	r3, r3, #16
30013be0:	e1a03823 	lsr	r3, r3, #16
30013be4:	e59d2014 	ldr	r2, [sp, #20]
30013be8:	e2022cff 	and	r2, r2, #65280	; 0xff00
30013bec:	e1a02422 	lsr	r2, r2, #8
30013bf0:	e1833002 	orr	r3, r3, r2
30013bf4:	e58d3014 	str	r3, [sp, #20]
  }
  acc += (src->addr & 0xffffUL);
30013bf8:	e59d3008 	ldr	r3, [sp, #8]
30013bfc:	e5d32000 	ldrb	r2, [r3]
30013c00:	e5d31001 	ldrb	r1, [r3, #1]
30013c04:	e1a01401 	lsl	r1, r1, #8
30013c08:	e1812002 	orr	r2, r1, r2
30013c0c:	e5d31002 	ldrb	r1, [r3, #2]
30013c10:	e1a01801 	lsl	r1, r1, #16
30013c14:	e1812002 	orr	r2, r1, r2
30013c18:	e5d33003 	ldrb	r3, [r3, #3]
30013c1c:	e1a03c03 	lsl	r3, r3, #24
30013c20:	e1833002 	orr	r3, r3, r2
30013c24:	e1a03803 	lsl	r3, r3, #16
30013c28:	e1a03823 	lsr	r3, r3, #16
30013c2c:	e59d2014 	ldr	r2, [sp, #20]
30013c30:	e0823003 	add	r3, r2, r3
30013c34:	e58d3014 	str	r3, [sp, #20]
  acc += ((src->addr >> 16) & 0xffffUL);
30013c38:	e59d3008 	ldr	r3, [sp, #8]
30013c3c:	e5d32000 	ldrb	r2, [r3]
30013c40:	e5d31001 	ldrb	r1, [r3, #1]
30013c44:	e1a01401 	lsl	r1, r1, #8
30013c48:	e1812002 	orr	r2, r1, r2
30013c4c:	e5d31002 	ldrb	r1, [r3, #2]
30013c50:	e1a01801 	lsl	r1, r1, #16
30013c54:	e1812002 	orr	r2, r1, r2
30013c58:	e5d33003 	ldrb	r3, [r3, #3]
30013c5c:	e1a03c03 	lsl	r3, r3, #24
30013c60:	e1833002 	orr	r3, r3, r2
30013c64:	e1a03823 	lsr	r3, r3, #16
30013c68:	e59d2014 	ldr	r2, [sp, #20]
30013c6c:	e0823003 	add	r3, r2, r3
30013c70:	e58d3014 	str	r3, [sp, #20]
  acc += (dest->addr & 0xffffUL);
30013c74:	e59d3004 	ldr	r3, [sp, #4]
30013c78:	e5d32000 	ldrb	r2, [r3]
30013c7c:	e5d31001 	ldrb	r1, [r3, #1]
30013c80:	e1a01401 	lsl	r1, r1, #8
30013c84:	e1812002 	orr	r2, r1, r2
30013c88:	e5d31002 	ldrb	r1, [r3, #2]
30013c8c:	e1a01801 	lsl	r1, r1, #16
30013c90:	e1812002 	orr	r2, r1, r2
30013c94:	e5d33003 	ldrb	r3, [r3, #3]
30013c98:	e1a03c03 	lsl	r3, r3, #24
30013c9c:	e1833002 	orr	r3, r3, r2
30013ca0:	e1a03803 	lsl	r3, r3, #16
30013ca4:	e1a03823 	lsr	r3, r3, #16
30013ca8:	e59d2014 	ldr	r2, [sp, #20]
30013cac:	e0823003 	add	r3, r2, r3
30013cb0:	e58d3014 	str	r3, [sp, #20]
  acc += ((dest->addr >> 16) & 0xffffUL);
30013cb4:	e59d3004 	ldr	r3, [sp, #4]
30013cb8:	e5d32000 	ldrb	r2, [r3]
30013cbc:	e5d31001 	ldrb	r1, [r3, #1]
30013cc0:	e1a01401 	lsl	r1, r1, #8
30013cc4:	e1812002 	orr	r2, r1, r2
30013cc8:	e5d31002 	ldrb	r1, [r3, #2]
30013ccc:	e1a01801 	lsl	r1, r1, #16
30013cd0:	e1812002 	orr	r2, r1, r2
30013cd4:	e5d33003 	ldrb	r3, [r3, #3]
30013cd8:	e1a03c03 	lsl	r3, r3, #24
30013cdc:	e1833002 	orr	r3, r3, r2
30013ce0:	e1a03823 	lsr	r3, r3, #16
30013ce4:	e59d2014 	ldr	r2, [sp, #20]
30013ce8:	e0823003 	add	r3, r2, r3
30013cec:	e58d3014 	str	r3, [sp, #20]
  acc += (u32_t)htons((u16_t)proto);
30013cf0:	e5dd3003 	ldrb	r3, [sp, #3]
30013cf4:	e1a00003 	mov	r0, r3
30013cf8:	ebfffeef 	bl	300138bc <htons>
30013cfc:	e1a03000 	mov	r3, r0
30013d00:	e59d2014 	ldr	r2, [sp, #20]
30013d04:	e0823003 	add	r3, r2, r3
30013d08:	e58d3014 	str	r3, [sp, #20]
  acc += (u32_t)htons(proto_len);
30013d0c:	e1dd32b8 	ldrh	r3, [sp, #40]	; 0x28
30013d10:	e1a00003 	mov	r0, r3
30013d14:	ebfffee8 	bl	300138bc <htons>
30013d18:	e1a03000 	mov	r3, r0
30013d1c:	e59d2014 	ldr	r2, [sp, #20]
30013d20:	e0823003 	add	r3, r2, r3
30013d24:	e58d3014 	str	r3, [sp, #20]

  while ((acc >> 16) != 0) {
30013d28:	ea000006 	b	30013d48 <inet_chksum_pseudo+0x270>
    acc = (acc & 0xffffUL) + (acc >> 16);
30013d2c:	e59d3014 	ldr	r3, [sp, #20]
30013d30:	e1a03803 	lsl	r3, r3, #16
30013d34:	e1a03823 	lsr	r3, r3, #16
30013d38:	e59d2014 	ldr	r2, [sp, #20]
30013d3c:	e1a02822 	lsr	r2, r2, #16
30013d40:	e0833002 	add	r3, r3, r2
30013d44:	e58d3014 	str	r3, [sp, #20]
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
  acc += (u32_t)htons(proto_len);

  while ((acc >> 16) != 0) {
30013d48:	e59d3014 	ldr	r3, [sp, #20]
30013d4c:	e1a03823 	lsr	r3, r3, #16
30013d50:	e3530000 	cmp	r3, #0
30013d54:	1afffff4 	bne	30013d2c <inet_chksum_pseudo+0x254>
    acc = (acc & 0xffffUL) + (acc >> 16);
  }
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
30013d58:	e59d3014 	ldr	r3, [sp, #20]
30013d5c:	e1a03803 	lsl	r3, r3, #16
30013d60:	e1a03823 	lsr	r3, r3, #16
30013d64:	e1e03003 	mvn	r3, r3
30013d68:	e1a03803 	lsl	r3, r3, #16
30013d6c:	e1a03823 	lsr	r3, r3, #16
}
30013d70:	e1a00003 	mov	r0, r3
30013d74:	e28dd024 	add	sp, sp, #36	; 0x24
30013d78:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30013d7c:	e12fff1e 	bx	lr

30013d80 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
30013d80:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30013d84:	e24dd024 	sub	sp, sp, #36	; 0x24
30013d88:	e58d000c 	str	r0, [sp, #12]
30013d8c:	e58d1008 	str	r1, [sp, #8]
30013d90:	e58d2004 	str	r2, [sp, #4]
30013d94:	e5cd3003 	strb	r3, [sp, #3]
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
30013d98:	e3a03000 	mov	r3, #0
30013d9c:	e58d3014 	str	r3, [sp, #20]
  swapped = 0;
30013da0:	e3a03000 	mov	r3, #0
30013da4:	e5cd301d 	strb	r3, [sp, #29]
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
30013da8:	e59d300c 	ldr	r3, [sp, #12]
30013dac:	e58d3018 	str	r3, [sp, #24]
30013db0:	ea000037 	b	30013e94 <inet_chksum_pseudo_partial+0x114>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
30013db4:	e59d3018 	ldr	r3, [sp, #24]
30013db8:	e1d330ba 	ldrh	r3, [r3, #10]
30013dbc:	e1cd31be 	strh	r3, [sp, #30]
    if (chklen > chksum_len) {
30013dc0:	e1dd21be 	ldrh	r2, [sp, #30]
30013dc4:	e1dd32bc 	ldrh	r3, [sp, #44]	; 0x2c
30013dc8:	e1520003 	cmp	r2, r3
30013dcc:	9a000001 	bls	30013dd8 <inet_chksum_pseudo_partial+0x58>
      chklen = chksum_len;
30013dd0:	e1dd32bc 	ldrh	r3, [sp, #44]	; 0x2c
30013dd4:	e1cd31be 	strh	r3, [sp, #30]
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
30013dd8:	e59d3018 	ldr	r3, [sp, #24]
30013ddc:	e5932004 	ldr	r2, [r3, #4]
30013de0:	e1dd31be 	ldrh	r3, [sp, #30]
30013de4:	e1a00002 	mov	r0, r2
30013de8:	e1a01003 	mov	r1, r3
30013dec:	ebfffeed 	bl	300139a8 <lwip_standard_chksum>
30013df0:	e1a03000 	mov	r3, r0
30013df4:	e59d2014 	ldr	r2, [sp, #20]
30013df8:	e0823003 	add	r3, r2, r3
30013dfc:	e58d3014 	str	r3, [sp, #20]
    chksum_len -= chklen;
30013e00:	e1dd22bc 	ldrh	r2, [sp, #44]	; 0x2c
30013e04:	e1dd31be 	ldrh	r3, [sp, #30]
30013e08:	e0633002 	rsb	r3, r3, r2
30013e0c:	e1cd32bc 	strh	r3, [sp, #44]	; 0x2c
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    while ((acc >> 16) != 0) {
30013e10:	ea000006 	b	30013e30 <inet_chksum_pseudo_partial+0xb0>
      acc = (acc & 0xffffUL) + (acc >> 16);
30013e14:	e59d3014 	ldr	r3, [sp, #20]
30013e18:	e1a03803 	lsl	r3, r3, #16
30013e1c:	e1a03823 	lsr	r3, r3, #16
30013e20:	e59d2014 	ldr	r2, [sp, #20]
30013e24:	e1a02822 	lsr	r2, r2, #16
30013e28:	e0833002 	add	r3, r3, r2
30013e2c:	e58d3014 	str	r3, [sp, #20]
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    while ((acc >> 16) != 0) {
30013e30:	e59d3014 	ldr	r3, [sp, #20]
30013e34:	e1a03823 	lsr	r3, r3, #16
30013e38:	e3530000 	cmp	r3, #0
30013e3c:	1afffff4 	bne	30013e14 <inet_chksum_pseudo_partial+0x94>
      acc = (acc & 0xffffUL) + (acc >> 16);
    }
    if (q->len % 2 != 0) {
30013e40:	e59d3018 	ldr	r3, [sp, #24]
30013e44:	e1d330ba 	ldrh	r3, [r3, #10]
30013e48:	e2033001 	and	r3, r3, #1
30013e4c:	e20330ff 	and	r3, r3, #255	; 0xff
30013e50:	e3530000 	cmp	r3, #0
30013e54:	0a00000b 	beq	30013e88 <inet_chksum_pseudo_partial+0x108>
      swapped = 1 - swapped;
30013e58:	e5dd301d 	ldrb	r3, [sp, #29]
30013e5c:	e2633001 	rsb	r3, r3, #1
30013e60:	e5cd301d 	strb	r3, [sp, #29]
      acc = ((acc & 0xff) << 8) | ((acc & 0xff00UL) >> 8);
30013e64:	e59d3014 	ldr	r3, [sp, #20]
30013e68:	e1a03403 	lsl	r3, r3, #8
30013e6c:	e1a03803 	lsl	r3, r3, #16
30013e70:	e1a03823 	lsr	r3, r3, #16
30013e74:	e59d2014 	ldr	r2, [sp, #20]
30013e78:	e2022cff 	and	r2, r2, #65280	; 0xff00
30013e7c:	e1a02422 	lsr	r2, r2, #8
30013e80:	e1833002 	orr	r3, r3, r2
30013e84:	e58d3014 	str	r3, [sp, #20]
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
30013e88:	e59d3018 	ldr	r3, [sp, #24]
30013e8c:	e5933000 	ldr	r3, [r3]
30013e90:	e58d3018 	str	r3, [sp, #24]
30013e94:	e59d3018 	ldr	r3, [sp, #24]
30013e98:	e3530000 	cmp	r3, #0
30013e9c:	0a000002 	beq	30013eac <inet_chksum_pseudo_partial+0x12c>
30013ea0:	e1dd32bc 	ldrh	r3, [sp, #44]	; 0x2c
30013ea4:	e3530000 	cmp	r3, #0
30013ea8:	1affffc1 	bne	30013db4 <inet_chksum_pseudo_partial+0x34>
      acc = ((acc & 0xff) << 8) | ((acc & 0xff00UL) >> 8);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
30013eac:	e5dd301d 	ldrb	r3, [sp, #29]
30013eb0:	e3530000 	cmp	r3, #0
30013eb4:	0a000008 	beq	30013edc <inet_chksum_pseudo_partial+0x15c>
    acc = ((acc & 0xff) << 8) | ((acc & 0xff00UL) >> 8);
30013eb8:	e59d3014 	ldr	r3, [sp, #20]
30013ebc:	e1a03403 	lsl	r3, r3, #8
30013ec0:	e1a03803 	lsl	r3, r3, #16
30013ec4:	e1a03823 	lsr	r3, r3, #16
30013ec8:	e59d2014 	ldr	r2, [sp, #20]
30013ecc:	e2022cff 	and	r2, r2, #65280	; 0xff00
30013ed0:	e1a02422 	lsr	r2, r2, #8
30013ed4:	e1833002 	orr	r3, r3, r2
30013ed8:	e58d3014 	str	r3, [sp, #20]
  }
  acc += (src->addr & 0xffffUL);
30013edc:	e59d3008 	ldr	r3, [sp, #8]
30013ee0:	e5d32000 	ldrb	r2, [r3]
30013ee4:	e5d31001 	ldrb	r1, [r3, #1]
30013ee8:	e1a01401 	lsl	r1, r1, #8
30013eec:	e1812002 	orr	r2, r1, r2
30013ef0:	e5d31002 	ldrb	r1, [r3, #2]
30013ef4:	e1a01801 	lsl	r1, r1, #16
30013ef8:	e1812002 	orr	r2, r1, r2
30013efc:	e5d33003 	ldrb	r3, [r3, #3]
30013f00:	e1a03c03 	lsl	r3, r3, #24
30013f04:	e1833002 	orr	r3, r3, r2
30013f08:	e1a03803 	lsl	r3, r3, #16
30013f0c:	e1a03823 	lsr	r3, r3, #16
30013f10:	e59d2014 	ldr	r2, [sp, #20]
30013f14:	e0823003 	add	r3, r2, r3
30013f18:	e58d3014 	str	r3, [sp, #20]
  acc += ((src->addr >> 16) & 0xffffUL);
30013f1c:	e59d3008 	ldr	r3, [sp, #8]
30013f20:	e5d32000 	ldrb	r2, [r3]
30013f24:	e5d31001 	ldrb	r1, [r3, #1]
30013f28:	e1a01401 	lsl	r1, r1, #8
30013f2c:	e1812002 	orr	r2, r1, r2
30013f30:	e5d31002 	ldrb	r1, [r3, #2]
30013f34:	e1a01801 	lsl	r1, r1, #16
30013f38:	e1812002 	orr	r2, r1, r2
30013f3c:	e5d33003 	ldrb	r3, [r3, #3]
30013f40:	e1a03c03 	lsl	r3, r3, #24
30013f44:	e1833002 	orr	r3, r3, r2
30013f48:	e1a03823 	lsr	r3, r3, #16
30013f4c:	e59d2014 	ldr	r2, [sp, #20]
30013f50:	e0823003 	add	r3, r2, r3
30013f54:	e58d3014 	str	r3, [sp, #20]
  acc += (dest->addr & 0xffffUL);
30013f58:	e59d3004 	ldr	r3, [sp, #4]
30013f5c:	e5d32000 	ldrb	r2, [r3]
30013f60:	e5d31001 	ldrb	r1, [r3, #1]
30013f64:	e1a01401 	lsl	r1, r1, #8
30013f68:	e1812002 	orr	r2, r1, r2
30013f6c:	e5d31002 	ldrb	r1, [r3, #2]
30013f70:	e1a01801 	lsl	r1, r1, #16
30013f74:	e1812002 	orr	r2, r1, r2
30013f78:	e5d33003 	ldrb	r3, [r3, #3]
30013f7c:	e1a03c03 	lsl	r3, r3, #24
30013f80:	e1833002 	orr	r3, r3, r2
30013f84:	e1a03803 	lsl	r3, r3, #16
30013f88:	e1a03823 	lsr	r3, r3, #16
30013f8c:	e59d2014 	ldr	r2, [sp, #20]
30013f90:	e0823003 	add	r3, r2, r3
30013f94:	e58d3014 	str	r3, [sp, #20]
  acc += ((dest->addr >> 16) & 0xffffUL);
30013f98:	e59d3004 	ldr	r3, [sp, #4]
30013f9c:	e5d32000 	ldrb	r2, [r3]
30013fa0:	e5d31001 	ldrb	r1, [r3, #1]
30013fa4:	e1a01401 	lsl	r1, r1, #8
30013fa8:	e1812002 	orr	r2, r1, r2
30013fac:	e5d31002 	ldrb	r1, [r3, #2]
30013fb0:	e1a01801 	lsl	r1, r1, #16
30013fb4:	e1812002 	orr	r2, r1, r2
30013fb8:	e5d33003 	ldrb	r3, [r3, #3]
30013fbc:	e1a03c03 	lsl	r3, r3, #24
30013fc0:	e1833002 	orr	r3, r3, r2
30013fc4:	e1a03823 	lsr	r3, r3, #16
30013fc8:	e59d2014 	ldr	r2, [sp, #20]
30013fcc:	e0823003 	add	r3, r2, r3
30013fd0:	e58d3014 	str	r3, [sp, #20]
  acc += (u32_t)htons((u16_t)proto);
30013fd4:	e5dd3003 	ldrb	r3, [sp, #3]
30013fd8:	e1a00003 	mov	r0, r3
30013fdc:	ebfffe36 	bl	300138bc <htons>
30013fe0:	e1a03000 	mov	r3, r0
30013fe4:	e59d2014 	ldr	r2, [sp, #20]
30013fe8:	e0823003 	add	r3, r2, r3
30013fec:	e58d3014 	str	r3, [sp, #20]
  acc += (u32_t)htons(proto_len);
30013ff0:	e1dd32b8 	ldrh	r3, [sp, #40]	; 0x28
30013ff4:	e1a00003 	mov	r0, r3
30013ff8:	ebfffe2f 	bl	300138bc <htons>
30013ffc:	e1a03000 	mov	r3, r0
30014000:	e59d2014 	ldr	r2, [sp, #20]
30014004:	e0823003 	add	r3, r2, r3
30014008:	e58d3014 	str	r3, [sp, #20]

  while ((acc >> 16) != 0) {
3001400c:	ea000006 	b	3001402c <inet_chksum_pseudo_partial+0x2ac>
    acc = (acc & 0xffffUL) + (acc >> 16);
30014010:	e59d3014 	ldr	r3, [sp, #20]
30014014:	e1a03803 	lsl	r3, r3, #16
30014018:	e1a03823 	lsr	r3, r3, #16
3001401c:	e59d2014 	ldr	r2, [sp, #20]
30014020:	e1a02822 	lsr	r2, r2, #16
30014024:	e0833002 	add	r3, r3, r2
30014028:	e58d3014 	str	r3, [sp, #20]
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
  acc += (u32_t)htons(proto_len);

  while ((acc >> 16) != 0) {
3001402c:	e59d3014 	ldr	r3, [sp, #20]
30014030:	e1a03823 	lsr	r3, r3, #16
30014034:	e3530000 	cmp	r3, #0
30014038:	1afffff4 	bne	30014010 <inet_chksum_pseudo_partial+0x290>
    acc = (acc & 0xffffUL) + (acc >> 16);
  }
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
3001403c:	e59d3014 	ldr	r3, [sp, #20]
30014040:	e1a03803 	lsl	r3, r3, #16
30014044:	e1a03823 	lsr	r3, r3, #16
30014048:	e1e03003 	mvn	r3, r3
3001404c:	e1a03803 	lsl	r3, r3, #16
30014050:	e1a03823 	lsr	r3, r3, #16
}
30014054:	e1a00003 	mov	r0, r3
30014058:	e28dd024 	add	sp, sp, #36	; 0x24
3001405c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30014060:	e12fff1e 	bx	lr

30014064 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
30014064:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30014068:	e24dd014 	sub	sp, sp, #20
3001406c:	e58d0004 	str	r0, [sp, #4]
30014070:	e1a03001 	mov	r3, r1
30014074:	e1cd30b2 	strh	r3, [sp, #2]
  u32_t acc;

  acc = LWIP_CHKSUM(dataptr, len);
30014078:	e1dd30b2 	ldrh	r3, [sp, #2]
3001407c:	e59d0004 	ldr	r0, [sp, #4]
30014080:	e1a01003 	mov	r1, r3
30014084:	ebfffe47 	bl	300139a8 <lwip_standard_chksum>
30014088:	e1a03000 	mov	r3, r0
3001408c:	e58d300c 	str	r3, [sp, #12]
  while ((acc >> 16) != 0) {
30014090:	ea000006 	b	300140b0 <inet_chksum+0x4c>
    acc = (acc & 0xffff) + (acc >> 16);
30014094:	e59d300c 	ldr	r3, [sp, #12]
30014098:	e1a03803 	lsl	r3, r3, #16
3001409c:	e1a03823 	lsr	r3, r3, #16
300140a0:	e59d200c 	ldr	r2, [sp, #12]
300140a4:	e1a02822 	lsr	r2, r2, #16
300140a8:	e0833002 	add	r3, r3, r2
300140ac:	e58d300c 	str	r3, [sp, #12]
inet_chksum(void *dataptr, u16_t len)
{
  u32_t acc;

  acc = LWIP_CHKSUM(dataptr, len);
  while ((acc >> 16) != 0) {
300140b0:	e59d300c 	ldr	r3, [sp, #12]
300140b4:	e1a03823 	lsr	r3, r3, #16
300140b8:	e3530000 	cmp	r3, #0
300140bc:	1afffff4 	bne	30014094 <inet_chksum+0x30>
    acc = (acc & 0xffff) + (acc >> 16);
  }
  return (u16_t)~(acc & 0xffff);
300140c0:	e59d300c 	ldr	r3, [sp, #12]
300140c4:	e1a03803 	lsl	r3, r3, #16
300140c8:	e1a03823 	lsr	r3, r3, #16
300140cc:	e1e03003 	mvn	r3, r3
300140d0:	e1a03803 	lsl	r3, r3, #16
300140d4:	e1a03823 	lsr	r3, r3, #16
}
300140d8:	e1a00003 	mov	r0, r3
300140dc:	e28dd014 	add	sp, sp, #20
300140e0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300140e4:	e12fff1e 	bx	lr

300140e8 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
300140e8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300140ec:	e24dd01c 	sub	sp, sp, #28
300140f0:	e58d0004 	str	r0, [sp, #4]
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
300140f4:	e3a03000 	mov	r3, #0
300140f8:	e58d300c 	str	r3, [sp, #12]
  swapped = 0;
300140fc:	e3a03000 	mov	r3, #0
30014100:	e5cd3017 	strb	r3, [sp, #23]
  for(q = p; q != NULL; q = q->next) {
30014104:	e59d3004 	ldr	r3, [sp, #4]
30014108:	e58d3010 	str	r3, [sp, #16]
3001410c:	ea000026 	b	300141ac <inet_chksum_pbuf+0xc4>
    acc += LWIP_CHKSUM(q->payload, q->len);
30014110:	e59d3010 	ldr	r3, [sp, #16]
30014114:	e5932004 	ldr	r2, [r3, #4]
30014118:	e59d3010 	ldr	r3, [sp, #16]
3001411c:	e1d330ba 	ldrh	r3, [r3, #10]
30014120:	e1a00002 	mov	r0, r2
30014124:	e1a01003 	mov	r1, r3
30014128:	ebfffe1e 	bl	300139a8 <lwip_standard_chksum>
3001412c:	e1a03000 	mov	r3, r0
30014130:	e59d200c 	ldr	r2, [sp, #12]
30014134:	e0823003 	add	r3, r2, r3
30014138:	e58d300c 	str	r3, [sp, #12]
    while ((acc >> 16) != 0) {
3001413c:	ea000006 	b	3001415c <inet_chksum_pbuf+0x74>
      acc = (acc & 0xffffUL) + (acc >> 16);
30014140:	e59d300c 	ldr	r3, [sp, #12]
30014144:	e1a03803 	lsl	r3, r3, #16
30014148:	e1a03823 	lsr	r3, r3, #16
3001414c:	e59d200c 	ldr	r2, [sp, #12]
30014150:	e1a02822 	lsr	r2, r2, #16
30014154:	e0833002 	add	r3, r3, r2
30014158:	e58d300c 	str	r3, [sp, #12]

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    while ((acc >> 16) != 0) {
3001415c:	e59d300c 	ldr	r3, [sp, #12]
30014160:	e1a03823 	lsr	r3, r3, #16
30014164:	e3530000 	cmp	r3, #0
30014168:	1afffff4 	bne	30014140 <inet_chksum_pbuf+0x58>
      acc = (acc & 0xffffUL) + (acc >> 16);
    }
    if (q->len % 2 != 0) {
3001416c:	e59d3010 	ldr	r3, [sp, #16]
30014170:	e1d330ba 	ldrh	r3, [r3, #10]
30014174:	e2033001 	and	r3, r3, #1
30014178:	e20330ff 	and	r3, r3, #255	; 0xff
3001417c:	e3530000 	cmp	r3, #0
30014180:	0a000006 	beq	300141a0 <inet_chksum_pbuf+0xb8>
      swapped = 1 - swapped;
30014184:	e5dd3017 	ldrb	r3, [sp, #23]
30014188:	e2633001 	rsb	r3, r3, #1
3001418c:	e5cd3017 	strb	r3, [sp, #23]
      acc = (acc & 0x00ffUL << 8) | (acc & 0xff00UL >> 8);
30014190:	e59d300c 	ldr	r3, [sp, #12]
30014194:	e1a03803 	lsl	r3, r3, #16
30014198:	e1a03823 	lsr	r3, r3, #16
3001419c:	e58d300c 	str	r3, [sp, #12]
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
300141a0:	e59d3010 	ldr	r3, [sp, #16]
300141a4:	e5933000 	ldr	r3, [r3]
300141a8:	e58d3010 	str	r3, [sp, #16]
300141ac:	e59d3010 	ldr	r3, [sp, #16]
300141b0:	e3530000 	cmp	r3, #0
300141b4:	1affffd5 	bne	30014110 <inet_chksum_pbuf+0x28>
      swapped = 1 - swapped;
      acc = (acc & 0x00ffUL << 8) | (acc & 0xff00UL >> 8);
    }
  }

  if (swapped) {
300141b8:	e5dd3017 	ldrb	r3, [sp, #23]
300141bc:	e3530000 	cmp	r3, #0
300141c0:	0a000008 	beq	300141e8 <inet_chksum_pbuf+0x100>
    acc = ((acc & 0x00ffUL) << 8) | ((acc & 0xff00UL) >> 8);
300141c4:	e59d300c 	ldr	r3, [sp, #12]
300141c8:	e1a03403 	lsl	r3, r3, #8
300141cc:	e1a03803 	lsl	r3, r3, #16
300141d0:	e1a03823 	lsr	r3, r3, #16
300141d4:	e59d200c 	ldr	r2, [sp, #12]
300141d8:	e2022cff 	and	r2, r2, #65280	; 0xff00
300141dc:	e1a02422 	lsr	r2, r2, #8
300141e0:	e1833002 	orr	r3, r3, r2
300141e4:	e58d300c 	str	r3, [sp, #12]
  }
  return (u16_t)~(acc & 0xffffUL);
300141e8:	e59d300c 	ldr	r3, [sp, #12]
300141ec:	e1a03803 	lsl	r3, r3, #16
300141f0:	e1a03823 	lsr	r3, r3, #16
300141f4:	e1e03003 	mvn	r3, r3
300141f8:	e1a03803 	lsl	r3, r3, #16
300141fc:	e1a03823 	lsr	r3, r3, #16
}
30014200:	e1a00003 	mov	r0, r3
30014204:	e28dd01c 	add	sp, sp, #28
30014208:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001420c:	e12fff1e 	bx	lr

30014210 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
30014210:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30014214:	e24dd014 	sub	sp, sp, #20
30014218:	e58d0004 	str	r0, [sp, #4]
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
3001421c:	e59f30f4 	ldr	r3, [pc, #244]	; 30014318 <ip_route+0x108>
30014220:	e5933000 	ldr	r3, [r3]
30014224:	e58d300c 	str	r3, [sp, #12]
30014228:	ea00001d 	b	300142a4 <ip_route+0x94>
    /* network mask matches? */
    if (netif_is_up(netif)) {
3001422c:	e59d000c 	ldr	r0, [sp, #12]
30014230:	eb000707 	bl	30015e54 <netif_is_up>
30014234:	e1a03000 	mov	r3, r0
30014238:	e3530000 	cmp	r3, #0
3001423c:	0a000015 	beq	30014298 <ip_route+0x88>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
30014240:	e59d3004 	ldr	r3, [sp, #4]
30014244:	e5d32000 	ldrb	r2, [r3]
30014248:	e5d31001 	ldrb	r1, [r3, #1]
3001424c:	e1a01401 	lsl	r1, r1, #8
30014250:	e1812002 	orr	r2, r1, r2
30014254:	e5d31002 	ldrb	r1, [r3, #2]
30014258:	e1a01801 	lsl	r1, r1, #16
3001425c:	e1812002 	orr	r2, r1, r2
30014260:	e5d33003 	ldrb	r3, [r3, #3]
30014264:	e1a03c03 	lsl	r3, r3, #24
30014268:	e1833002 	orr	r3, r3, r2
3001426c:	e1a02003 	mov	r2, r3
30014270:	e59d300c 	ldr	r3, [sp, #12]
30014274:	e5933004 	ldr	r3, [r3, #4]
30014278:	e0222003 	eor	r2, r2, r3
3001427c:	e59d300c 	ldr	r3, [sp, #12]
30014280:	e5933008 	ldr	r3, [r3, #8]
30014284:	e0023003 	and	r3, r2, r3
30014288:	e3530000 	cmp	r3, #0
3001428c:	1a000001 	bne	30014298 <ip_route+0x88>
        /* return netif on which to forward IP packet */
        return netif;
30014290:	e59d300c 	ldr	r3, [sp, #12]
30014294:	ea00001b 	b	30014308 <ip_route+0xf8>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
30014298:	e59d300c 	ldr	r3, [sp, #12]
3001429c:	e5933000 	ldr	r3, [r3]
300142a0:	e58d300c 	str	r3, [sp, #12]
300142a4:	e59d300c 	ldr	r3, [sp, #12]
300142a8:	e3530000 	cmp	r3, #0
300142ac:	1affffde 	bne	3001422c <ip_route+0x1c>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
300142b0:	e59f3064 	ldr	r3, [pc, #100]	; 3001431c <ip_route+0x10c>
300142b4:	e5933000 	ldr	r3, [r3]
300142b8:	e3530000 	cmp	r3, #0
300142bc:	0a000006 	beq	300142dc <ip_route+0xcc>
300142c0:	e59f3054 	ldr	r3, [pc, #84]	; 3001431c <ip_route+0x10c>
300142c4:	e5933000 	ldr	r3, [r3]
300142c8:	e1a00003 	mov	r0, r3
300142cc:	eb0006e0 	bl	30015e54 <netif_is_up>
300142d0:	e1a03000 	mov	r3, r0
300142d4:	e3530000 	cmp	r3, #0
300142d8:	1a000008 	bne	30014300 <ip_route+0xf0>
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
300142dc:	e59f303c 	ldr	r3, [pc, #60]	; 30014320 <ip_route+0x110>
300142e0:	e1d335be 	ldrh	r3, [r3, #94]	; 0x5e
300142e4:	e2833001 	add	r3, r3, #1
300142e8:	e1a03803 	lsl	r3, r3, #16
300142ec:	e1a02823 	lsr	r2, r3, #16
300142f0:	e59f3028 	ldr	r3, [pc, #40]	; 30014320 <ip_route+0x110>
300142f4:	e1c325be 	strh	r2, [r3, #94]	; 0x5e
    snmp_inc_ipoutnoroutes();
    return NULL;
300142f8:	e3a03000 	mov	r3, #0
300142fc:	ea000001 	b	30014308 <ip_route+0xf8>
  }
  /* no matching netif found, use default netif */
  return netif_default;
30014300:	e59f3014 	ldr	r3, [pc, #20]	; 3001431c <ip_route+0x10c>
30014304:	e5933000 	ldr	r3, [r3]
}
30014308:	e1a00003 	mov	r0, r3
3001430c:	e28dd014 	add	sp, sp, #20
30014310:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30014314:	e12fff1e 	bx	lr
30014318:	3002a10c 	.word	0x3002a10c
3001431c:	3002b34c 	.word	0x3002b34c
30014320:	3002b214 	.word	0x3002b214

30014324 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
30014324:	e92d4010 	push	{r4, lr}
30014328:	e24dd018 	sub	sp, sp, #24
3001432c:	e58d0004 	str	r0, [sp, #4]
30014330:	e58d1000 	str	r1, [sp]
  u16_t iphdr_len;
#if LWIP_DHCP
  int check_ip_src=1;
#endif /* LWIP_DHCP */

  IP_STATS_INC(ip.recv);
30014334:	e59f35b4 	ldr	r3, [pc, #1460]	; 300148f0 <ip_input+0x5cc>
30014338:	e1d335b2 	ldrh	r3, [r3, #82]	; 0x52
3001433c:	e2833001 	add	r3, r3, #1
30014340:	e1a03803 	lsl	r3, r3, #16
30014344:	e1a02823 	lsr	r2, r3, #16
30014348:	e59f35a0 	ldr	r3, [pc, #1440]	; 300148f0 <ip_input+0x5cc>
3001434c:	e1c325b2 	strh	r2, [r3, #82]	; 0x52
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
30014350:	e59d3004 	ldr	r3, [sp, #4]
30014354:	e5933004 	ldr	r3, [r3, #4]
30014358:	e58d3008 	str	r3, [sp, #8]
  if (IPH_V(iphdr) != 4) {
3001435c:	e59d3008 	ldr	r3, [sp, #8]
30014360:	e5d32000 	ldrb	r2, [r3]
30014364:	e5d33001 	ldrb	r3, [r3, #1]
30014368:	e1a03403 	lsl	r3, r3, #8
3001436c:	e1833002 	orr	r3, r3, r2
30014370:	e1a03803 	lsl	r3, r3, #16
30014374:	e1a03823 	lsr	r3, r3, #16
30014378:	e1a00003 	mov	r0, r3
3001437c:	ebfffd61 	bl	30013908 <ntohs>
30014380:	e1a03000 	mov	r3, r0
30014384:	e1a03623 	lsr	r3, r3, #12
30014388:	e1a03803 	lsl	r3, r3, #16
3001438c:	e1a03823 	lsr	r3, r3, #16
30014390:	e3530004 	cmp	r3, #4
30014394:	0a000011 	beq	300143e0 <ip_input+0xbc>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
30014398:	e59d0004 	ldr	r0, [sp, #4]
3001439c:	eb000863 	bl	30016530 <pbuf_free>
    IP_STATS_INC(ip.err);
300143a0:	e59f3548 	ldr	r3, [pc, #1352]	; 300148f0 <ip_input+0x5cc>
300143a4:	e1d336b4 	ldrh	r3, [r3, #100]	; 0x64
300143a8:	e2833001 	add	r3, r3, #1
300143ac:	e1a03803 	lsl	r3, r3, #16
300143b0:	e1a02823 	lsr	r2, r3, #16
300143b4:	e59f3534 	ldr	r3, [pc, #1332]	; 300148f0 <ip_input+0x5cc>
300143b8:	e1c326b4 	strh	r2, [r3, #100]	; 0x64
    IP_STATS_INC(ip.drop);
300143bc:	e59f352c 	ldr	r3, [pc, #1324]	; 300148f0 <ip_input+0x5cc>
300143c0:	e1d335b6 	ldrh	r3, [r3, #86]	; 0x56
300143c4:	e2833001 	add	r3, r3, #1
300143c8:	e1a03803 	lsl	r3, r3, #16
300143cc:	e1a02823 	lsr	r2, r3, #16
300143d0:	e59f3518 	ldr	r3, [pc, #1304]	; 300148f0 <ip_input+0x5cc>
300143d4:	e1c325b6 	strh	r2, [r3, #86]	; 0x56
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
300143d8:	e3a03000 	mov	r3, #0
300143dc:	ea00013d 	b	300148d8 <ip_input+0x5b4>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
300143e0:	e59d3008 	ldr	r3, [sp, #8]
300143e4:	e5d32000 	ldrb	r2, [r3]
300143e8:	e5d33001 	ldrb	r3, [r3, #1]
300143ec:	e1a03403 	lsl	r3, r3, #8
300143f0:	e1833002 	orr	r3, r3, r2
300143f4:	e1a03803 	lsl	r3, r3, #16
300143f8:	e1a03823 	lsr	r3, r3, #16
300143fc:	e1a00003 	mov	r0, r3
30014400:	ebfffd40 	bl	30013908 <ntohs>
30014404:	e1a03000 	mov	r3, r0
30014408:	e1a03423 	lsr	r3, r3, #8
3001440c:	e1a03803 	lsl	r3, r3, #16
30014410:	e1a03823 	lsr	r3, r3, #16
30014414:	e203300f 	and	r3, r3, #15
30014418:	e1cd31b0 	strh	r3, [sp, #16]
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
3001441c:	e1dd31b0 	ldrh	r3, [sp, #16]
30014420:	e1a03103 	lsl	r3, r3, #2
30014424:	e1cd31b0 	strh	r3, [sp, #16]
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
30014428:	e59d3008 	ldr	r3, [sp, #8]
3001442c:	e5d32002 	ldrb	r2, [r3, #2]
30014430:	e5d33003 	ldrb	r3, [r3, #3]
30014434:	e1a03403 	lsl	r3, r3, #8
30014438:	e1833002 	orr	r3, r3, r2
3001443c:	e1a03803 	lsl	r3, r3, #16
30014440:	e1a03823 	lsr	r3, r3, #16
30014444:	e1a00003 	mov	r0, r3
30014448:	ebfffd2e 	bl	30013908 <ntohs>
3001444c:	e1a03000 	mov	r3, r0
30014450:	e1cd31b2 	strh	r3, [sp, #18]

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
30014454:	e59d3004 	ldr	r3, [sp, #4]
30014458:	e1d330ba 	ldrh	r3, [r3, #10]
3001445c:	e1dd21b0 	ldrh	r2, [sp, #16]
30014460:	e1520003 	cmp	r2, r3
30014464:	8a000004 	bhi	3001447c <ip_input+0x158>
30014468:	e59d3004 	ldr	r3, [sp, #4]
3001446c:	e1d330b8 	ldrh	r3, [r3, #8]
30014470:	e1dd21b2 	ldrh	r2, [sp, #18]
30014474:	e1520003 	cmp	r2, r3
30014478:	9a000011 	bls	300144c4 <ip_input+0x1a0>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
3001447c:	e59d0004 	ldr	r0, [sp, #4]
30014480:	eb00082a 	bl	30016530 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
30014484:	e59f3464 	ldr	r3, [pc, #1124]	; 300148f0 <ip_input+0x5cc>
30014488:	e1d335ba 	ldrh	r3, [r3, #90]	; 0x5a
3001448c:	e2833001 	add	r3, r3, #1
30014490:	e1a03803 	lsl	r3, r3, #16
30014494:	e1a02823 	lsr	r2, r3, #16
30014498:	e59f3450 	ldr	r3, [pc, #1104]	; 300148f0 <ip_input+0x5cc>
3001449c:	e1c325ba 	strh	r2, [r3, #90]	; 0x5a
    IP_STATS_INC(ip.drop);
300144a0:	e59f3448 	ldr	r3, [pc, #1096]	; 300148f0 <ip_input+0x5cc>
300144a4:	e1d335b6 	ldrh	r3, [r3, #86]	; 0x56
300144a8:	e2833001 	add	r3, r3, #1
300144ac:	e1a03803 	lsl	r3, r3, #16
300144b0:	e1a02823 	lsr	r2, r3, #16
300144b4:	e59f3434 	ldr	r3, [pc, #1076]	; 300148f0 <ip_input+0x5cc>
300144b8:	e1c325b6 	strh	r2, [r3, #86]	; 0x56
    snmp_inc_ipindiscards();
    return ERR_OK;
300144bc:	e3a03000 	mov	r3, #0
300144c0:	ea000104 	b	300148d8 <ip_input+0x5b4>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
300144c4:	e1dd31b0 	ldrh	r3, [sp, #16]
300144c8:	e59d0008 	ldr	r0, [sp, #8]
300144cc:	e1a01003 	mov	r1, r3
300144d0:	ebfffee3 	bl	30014064 <inet_chksum>
300144d4:	e1a03000 	mov	r3, r0
300144d8:	e3530000 	cmp	r3, #0
300144dc:	0a000011 	beq	30014528 <ip_input+0x204>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
300144e0:	e59d0004 	ldr	r0, [sp, #4]
300144e4:	eb000811 	bl	30016530 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
300144e8:	e59f3400 	ldr	r3, [pc, #1024]	; 300148f0 <ip_input+0x5cc>
300144ec:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
300144f0:	e2833001 	add	r3, r3, #1
300144f4:	e1a03803 	lsl	r3, r3, #16
300144f8:	e1a02823 	lsr	r2, r3, #16
300144fc:	e59f33ec 	ldr	r3, [pc, #1004]	; 300148f0 <ip_input+0x5cc>
30014500:	e1c325b8 	strh	r2, [r3, #88]	; 0x58
    IP_STATS_INC(ip.drop);
30014504:	e59f33e4 	ldr	r3, [pc, #996]	; 300148f0 <ip_input+0x5cc>
30014508:	e1d335b6 	ldrh	r3, [r3, #86]	; 0x56
3001450c:	e2833001 	add	r3, r3, #1
30014510:	e1a03803 	lsl	r3, r3, #16
30014514:	e1a02823 	lsr	r2, r3, #16
30014518:	e59f33d0 	ldr	r3, [pc, #976]	; 300148f0 <ip_input+0x5cc>
3001451c:	e1c325b6 	strh	r2, [r3, #86]	; 0x56
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
30014520:	e3a03000 	mov	r3, #0
30014524:	ea0000eb 	b	300148d8 <ip_input+0x5b4>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
30014528:	e1dd31b2 	ldrh	r3, [sp, #18]
3001452c:	e59d0004 	ldr	r0, [sp, #4]
30014530:	e1a01003 	mov	r1, r3
30014534:	eb00073a 	bl	30016224 <pbuf_realloc>
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
30014538:	e3a03001 	mov	r3, #1
3001453c:	e58d3014 	str	r3, [sp, #20]
    netif = inp;
30014540:	e59d3000 	ldr	r3, [sp]
30014544:	e58d300c 	str	r3, [sp, #12]
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
30014548:	e59d000c 	ldr	r0, [sp, #12]
3001454c:	eb000640 	bl	30015e54 <netif_is_up>
30014550:	e1a03000 	mov	r3, r0
30014554:	e3530000 	cmp	r3, #0
30014558:	0a00001f 	beq	300145dc <ip_input+0x2b8>
3001455c:	e59d300c 	ldr	r3, [sp, #12]
30014560:	e2833004 	add	r3, r3, #4
30014564:	e3530000 	cmp	r3, #0
30014568:	0a00001b 	beq	300145dc <ip_input+0x2b8>
3001456c:	e59d300c 	ldr	r3, [sp, #12]
30014570:	e5933004 	ldr	r3, [r3, #4]
30014574:	e3530000 	cmp	r3, #0
30014578:	0a000017 	beq	300145dc <ip_input+0x2b8>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
3001457c:	e59d3008 	ldr	r3, [sp, #8]
30014580:	e5d32010 	ldrb	r2, [r3, #16]
30014584:	e5d31011 	ldrb	r1, [r3, #17]
30014588:	e1a01401 	lsl	r1, r1, #8
3001458c:	e1812002 	orr	r2, r1, r2
30014590:	e5d31012 	ldrb	r1, [r3, #18]
30014594:	e1a01801 	lsl	r1, r1, #16
30014598:	e1812002 	orr	r2, r1, r2
3001459c:	e5d33013 	ldrb	r3, [r3, #19]
300145a0:	e1a03c03 	lsl	r3, r3, #24
300145a4:	e1833002 	orr	r3, r3, r2
300145a8:	e1a02003 	mov	r2, r3
300145ac:	e59d300c 	ldr	r3, [sp, #12]
300145b0:	e5933004 	ldr	r3, [r3, #4]
300145b4:	e1520003 	cmp	r2, r3
300145b8:	0a00001d 	beq	30014634 <ip_input+0x310>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
300145bc:	e59d3008 	ldr	r3, [sp, #8]
300145c0:	e2833010 	add	r3, r3, #16
300145c4:	e1a00003 	mov	r0, r3
300145c8:	e59d100c 	ldr	r1, [sp, #12]
300145cc:	eb000250 	bl	30014f14 <ip_addr_isbroadcast>
300145d0:	e1a03000 	mov	r3, r0
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
300145d4:	e3530000 	cmp	r3, #0
300145d8:	1a000015 	bne	30014634 <ip_input+0x310>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
300145dc:	e59d3014 	ldr	r3, [sp, #20]
300145e0:	e3530000 	cmp	r3, #0
300145e4:	0a000005 	beq	30014600 <ip_input+0x2dc>
        first = 0;
300145e8:	e3a03000 	mov	r3, #0
300145ec:	e58d3014 	str	r3, [sp, #20]
        netif = netif_list;
300145f0:	e59f32fc 	ldr	r3, [pc, #764]	; 300148f4 <ip_input+0x5d0>
300145f4:	e5933000 	ldr	r3, [r3]
300145f8:	e58d300c 	str	r3, [sp, #12]
300145fc:	ea000002 	b	3001460c <ip_input+0x2e8>
      } else {
        netif = netif->next;
30014600:	e59d300c 	ldr	r3, [sp, #12]
30014604:	e5933000 	ldr	r3, [r3]
30014608:	e58d300c 	str	r3, [sp, #12]
      }
      if (netif == inp) {
3001460c:	e59d200c 	ldr	r2, [sp, #12]
30014610:	e59d3000 	ldr	r3, [sp]
30014614:	e1520003 	cmp	r2, r3
30014618:	1a000002 	bne	30014628 <ip_input+0x304>
        netif = netif->next;
3001461c:	e59d300c 	ldr	r3, [sp, #12]
30014620:	e5933000 	ldr	r3, [r3]
30014624:	e58d300c 	str	r3, [sp, #12]
      }
    } while(netif != NULL);
30014628:	e59d300c 	ldr	r3, [sp, #12]
3001462c:	e3530000 	cmp	r3, #0
30014630:	1affffc4 	bne	30014548 <ip_input+0x224>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
30014634:	e59d3008 	ldr	r3, [sp, #8]
30014638:	e283300c 	add	r3, r3, #12
3001463c:	e1a00003 	mov	r0, r3
30014640:	e59d1000 	ldr	r1, [sp]
30014644:	eb000232 	bl	30014f14 <ip_addr_isbroadcast>
30014648:	e1a03000 	mov	r3, r0
3001464c:	e3530000 	cmp	r3, #0
30014650:	1a000014 	bne	300146a8 <ip_input+0x384>
         (ip_addr_ismulticast(&(iphdr->src)))) {
30014654:	e59d3008 	ldr	r3, [sp, #8]
30014658:	e5d3200c 	ldrb	r2, [r3, #12]
3001465c:	e5d3100d 	ldrb	r1, [r3, #13]
30014660:	e1a01401 	lsl	r1, r1, #8
30014664:	e1812002 	orr	r2, r1, r2
30014668:	e5d3100e 	ldrb	r1, [r3, #14]
3001466c:	e1a01801 	lsl	r1, r1, #16
30014670:	e1812002 	orr	r2, r1, r2
30014674:	e5d3300f 	ldrb	r3, [r3, #15]
30014678:	e1a03c03 	lsl	r3, r3, #24
3001467c:	e1833002 	orr	r3, r3, r2
30014680:	e1a04003 	mov	r4, r3
30014684:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
30014688:	ebfffcbc 	bl	30013980 <ntohl>
3001468c:	e1a03000 	mov	r3, r0
30014690:	e0044003 	and	r4, r4, r3
30014694:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
30014698:	ebfffcb8 	bl	30013980 <ntohl>
3001469c:	e1a03000 	mov	r3, r0

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
300146a0:	e1540003 	cmp	r4, r3
300146a4:	1a00000a 	bne	300146d4 <ip_input+0x3b0>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
300146a8:	e59d0004 	ldr	r0, [sp, #4]
300146ac:	eb00079f 	bl	30016530 <pbuf_free>
      IP_STATS_INC(ip.drop);
300146b0:	e59f3238 	ldr	r3, [pc, #568]	; 300148f0 <ip_input+0x5cc>
300146b4:	e1d335b6 	ldrh	r3, [r3, #86]	; 0x56
300146b8:	e2833001 	add	r3, r3, #1
300146bc:	e1a03803 	lsl	r3, r3, #16
300146c0:	e1a02823 	lsr	r2, r3, #16
300146c4:	e59f3224 	ldr	r3, [pc, #548]	; 300148f0 <ip_input+0x5cc>
300146c8:	e1c325b6 	strh	r2, [r3, #86]	; 0x56
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
300146cc:	e3a03000 	mov	r3, #0
300146d0:	ea000080 	b	300148d8 <ip_input+0x5b4>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
300146d4:	e59d300c 	ldr	r3, [sp, #12]
300146d8:	e3530000 	cmp	r3, #0
300146dc:	1a000003 	bne	300146f0 <ip_input+0x3cc>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
300146e0:	e59d0004 	ldr	r0, [sp, #4]
300146e4:	eb000791 	bl	30016530 <pbuf_free>
    return ERR_OK;
300146e8:	e3a03000 	mov	r3, #0
300146ec:	ea000079 	b	300148d8 <ip_input+0x5b4>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
300146f0:	e59d3008 	ldr	r3, [sp, #8]
300146f4:	e5d32006 	ldrb	r2, [r3, #6]
300146f8:	e5d33007 	ldrb	r3, [r3, #7]
300146fc:	e1a03403 	lsl	r3, r3, #8
30014700:	e1833002 	orr	r3, r3, r2
30014704:	e1a03803 	lsl	r3, r3, #16
30014708:	e1a04823 	lsr	r4, r3, #16
3001470c:	e3a00dff 	mov	r0, #16320	; 0x3fc0
30014710:	e280003f 	add	r0, r0, #63	; 0x3f
30014714:	ebfffc68 	bl	300138bc <htons>
30014718:	e1a03000 	mov	r3, r0
3001471c:	e0043003 	and	r3, r4, r3
30014720:	e1a03803 	lsl	r3, r3, #16
30014724:	e1a03823 	lsr	r3, r3, #16
30014728:	e3530000 	cmp	r3, #0
3001472c:	0a000011 	beq	30014778 <ip_input+0x454>
    if (p == NULL) {
      return ERR_OK;
    }
    iphdr = p->payload;
#else /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */
    pbuf_free(p);
30014730:	e59d0004 	ldr	r0, [sp, #4]
30014734:	eb00077d 	bl	30016530 <pbuf_free>
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP packet dropped since it was fragmented (0x%"X16_F") (while IP_REASSEMBLY == 0).\n",
      ntohs(IPH_OFFSET(iphdr))));
    IP_STATS_INC(ip.opterr);
30014738:	e59f31b0 	ldr	r3, [pc, #432]	; 300148f0 <ip_input+0x5cc>
3001473c:	e1d336b2 	ldrh	r3, [r3, #98]	; 0x62
30014740:	e2833001 	add	r3, r3, #1
30014744:	e1a03803 	lsl	r3, r3, #16
30014748:	e1a02823 	lsr	r2, r3, #16
3001474c:	e59f319c 	ldr	r3, [pc, #412]	; 300148f0 <ip_input+0x5cc>
30014750:	e1c326b2 	strh	r2, [r3, #98]	; 0x62
    IP_STATS_INC(ip.drop);
30014754:	e59f3194 	ldr	r3, [pc, #404]	; 300148f0 <ip_input+0x5cc>
30014758:	e1d335b6 	ldrh	r3, [r3, #86]	; 0x56
3001475c:	e2833001 	add	r3, r3, #1
30014760:	e1a03803 	lsl	r3, r3, #16
30014764:	e1a02823 	lsr	r2, r3, #16
30014768:	e59f3180 	ldr	r3, [pc, #384]	; 300148f0 <ip_input+0x5cc>
3001476c:	e1c325b6 	strh	r2, [r3, #86]	; 0x56
    /* unsupported protocol feature */
    snmp_inc_ipinunknownprotos();
    return ERR_OK;
30014770:	e3a03000 	mov	r3, #0
30014774:	ea000057 	b	300148d8 <ip_input+0x5b4>
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
30014778:	e59d0004 	ldr	r0, [sp, #4]
3001477c:	e59d1000 	ldr	r1, [sp]
30014780:	eb0008dc 	bl	30016af8 <raw_input>
30014784:	e1a03000 	mov	r3, r0
30014788:	e3530000 	cmp	r3, #0
3001478c:	1a000050 	bne	300148d4 <ip_input+0x5b0>
#endif /* LWIP_RAW */
  {
    //acoral_print("\nip proto: %d\n",ntohs((iphdr)->_ttl_proto) & 0xff);
    switch (IPH_PROTO(iphdr)) {
30014790:	e59d3008 	ldr	r3, [sp, #8]
30014794:	e5d32008 	ldrb	r2, [r3, #8]
30014798:	e5d33009 	ldrb	r3, [r3, #9]
3001479c:	e1a03403 	lsl	r3, r3, #8
300147a0:	e1833002 	orr	r3, r3, r2
300147a4:	e1a03803 	lsl	r3, r3, #16
300147a8:	e1a03823 	lsr	r3, r3, #16
300147ac:	e1a00003 	mov	r0, r3
300147b0:	ebfffc54 	bl	30013908 <ntohs>
300147b4:	e1a03000 	mov	r3, r0
300147b8:	e20330ff 	and	r3, r3, #255	; 0xff
300147bc:	e3530006 	cmp	r3, #6
300147c0:	0a000008 	beq	300147e8 <ip_input+0x4c4>
300147c4:	e3530011 	cmp	r3, #17
300147c8:	0a000002 	beq	300147d8 <ip_input+0x4b4>
300147cc:	e3530001 	cmp	r3, #1
300147d0:	0a000008 	beq	300147f8 <ip_input+0x4d4>
300147d4:	ea00000b 	b	30014808 <ip_input+0x4e4>
fE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      //acoral_prints("\nUDP\n");
      udp_input(p, inp);
300147d8:	e59d0004 	ldr	r0, [sp, #4]
300147dc:	e59d1000 	ldr	r1, [sp]
300147e0:	eb002d22 	bl	3001fc70 <udp_input>
      break;
300147e4:	ea00003a 	b	300148d4 <ip_input+0x5b0>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      //acoral_print("\nTCP: tot_len:%d, type:%d\n", p->tot_len, p->type);
      tcp_input(p, inp);
300147e8:	e59d0004 	ldr	r0, [sp, #4]
300147ec:	e59d1000 	ldr	r1, [sp]
300147f0:	eb001405 	bl	3001980c <tcp_input>
      //acoral_print("\ni am here.=== %d\n", mytmptest++);
      //pbuf_free(p);
      break;
300147f4:	ea000036 	b	300148d4 <ip_input+0x5b0>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      //acoral_prints("\nICMPS\n");
      icmp_input(p, inp);
300147f8:	e59d0004 	ldr	r0, [sp, #4]
300147fc:	e59d1000 	ldr	r1, [sp]
30014800:	ebfff859 	bl	3001296c <icmp_input>
      //acoral_prints("\nICMPE\n");
      break;
30014804:	ea000032 	b	300148d4 <ip_input+0x5b0>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
30014808:	e59d3008 	ldr	r3, [sp, #8]
3001480c:	e2833010 	add	r3, r3, #16
30014810:	e1a00003 	mov	r0, r3
30014814:	e59d1000 	ldr	r1, [sp]
30014818:	eb0001bd 	bl	30014f14 <ip_addr_isbroadcast>
3001481c:	e1a03000 	mov	r3, r0
30014820:	e3530000 	cmp	r3, #0
30014824:	1a00001a 	bne	30014894 <ip_input+0x570>
          !ip_addr_ismulticast(&(iphdr->dest))) {
30014828:	e59d3008 	ldr	r3, [sp, #8]
3001482c:	e5d32010 	ldrb	r2, [r3, #16]
30014830:	e5d31011 	ldrb	r1, [r3, #17]
30014834:	e1a01401 	lsl	r1, r1, #8
30014838:	e1812002 	orr	r2, r1, r2
3001483c:	e5d31012 	ldrb	r1, [r3, #18]
30014840:	e1a01801 	lsl	r1, r1, #16
30014844:	e1812002 	orr	r2, r1, r2
30014848:	e5d33013 	ldrb	r3, [r3, #19]
3001484c:	e1a03c03 	lsl	r3, r3, #24
30014850:	e1833002 	orr	r3, r3, r2
30014854:	e1a04003 	mov	r4, r3
30014858:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
3001485c:	ebfffc47 	bl	30013980 <ntohl>
30014860:	e1a03000 	mov	r3, r0
30014864:	e0044003 	and	r4, r4, r3
30014868:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
3001486c:	ebfffc43 	bl	30013980 <ntohl>
30014870:	e1a03000 	mov	r3, r0
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
30014874:	e1540003 	cmp	r4, r3
30014878:	0a000005 	beq	30014894 <ip_input+0x570>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
3001487c:	e59d3004 	ldr	r3, [sp, #4]
30014880:	e59d2008 	ldr	r2, [sp, #8]
30014884:	e5832004 	str	r2, [r3, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
30014888:	e59d0004 	ldr	r0, [sp, #4]
3001488c:	e3a01002 	mov	r1, #2
30014890:	ebfffa04 	bl	300130a8 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
30014894:	e59d0004 	ldr	r0, [sp, #4]
30014898:	eb000724 	bl	30016530 <pbuf_free>

      LWIP_DEBUGF(IP_DEBUG | 2, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));

      IP_STATS_INC(ip.proterr);
3001489c:	e59f304c 	ldr	r3, [pc, #76]	; 300148f0 <ip_input+0x5cc>
300148a0:	e1d336b0 	ldrh	r3, [r3, #96]	; 0x60
300148a4:	e2833001 	add	r3, r3, #1
300148a8:	e1a03803 	lsl	r3, r3, #16
300148ac:	e1a02823 	lsr	r2, r3, #16
300148b0:	e59f3038 	ldr	r3, [pc, #56]	; 300148f0 <ip_input+0x5cc>
300148b4:	e1c326b0 	strh	r2, [r3, #96]	; 0x60
      IP_STATS_INC(ip.drop);
300148b8:	e59f3030 	ldr	r3, [pc, #48]	; 300148f0 <ip_input+0x5cc>
300148bc:	e1d335b6 	ldrh	r3, [r3, #86]	; 0x56
300148c0:	e2833001 	add	r3, r3, #1
300148c4:	e1a03803 	lsl	r3, r3, #16
300148c8:	e1a02823 	lsr	r2, r3, #16
300148cc:	e59f301c 	ldr	r3, [pc, #28]	; 300148f0 <ip_input+0x5cc>
300148d0:	e1c325b6 	strh	r2, [r3, #86]	; 0x56
      snmp_inc_ipinunknownprotos();
    }
    
  }
  //acoral_print("\n===  input ok  ===\n");
  return ERR_OK;
300148d4:	e3a03000 	mov	r3, #0
300148d8:	e1a03c03 	lsl	r3, r3, #24
300148dc:	e1a03c43 	asr	r3, r3, #24
}
300148e0:	e1a00003 	mov	r0, r3
300148e4:	e28dd018 	add	sp, sp, #24
300148e8:	e8bd4010 	pop	{r4, lr}
300148ec:	e12fff1e 	bx	lr
300148f0:	3002b214 	.word	0x3002b214
300148f4:	3002a10c 	.word	0x3002a10c

300148f8 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
300148f8:	e92d4010 	push	{r4, lr}
300148fc:	e24dd018 	sub	sp, sp, #24
30014900:	e58d000c 	str	r0, [sp, #12]
30014904:	e58d1008 	str	r1, [sp, #8]
30014908:	e58d2004 	str	r2, [sp, #4]
3001490c:	e5cd3003 	strb	r3, [sp, #3]
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
30014910:	e59d3004 	ldr	r3, [sp, #4]
30014914:	e3530000 	cmp	r3, #0
30014918:	0a000129 	beq	30014dc4 <ip_output_if+0x4cc>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
3001491c:	e59d000c 	ldr	r0, [sp, #12]
30014920:	e3a01014 	mov	r1, #20
30014924:	eb00069c 	bl	3001639c <pbuf_header>
30014928:	e1a03000 	mov	r3, r0
3001492c:	e3530000 	cmp	r3, #0
30014930:	0a000008 	beq	30014958 <ip_output_if+0x60>
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
30014934:	e59f3544 	ldr	r3, [pc, #1348]	; 30014e80 <ip_output_if+0x588>
30014938:	e1d336b4 	ldrh	r3, [r3, #100]	; 0x64
3001493c:	e2833001 	add	r3, r3, #1
30014940:	e1a03803 	lsl	r3, r3, #16
30014944:	e1a02823 	lsr	r2, r3, #16
30014948:	e59f3530 	ldr	r3, [pc, #1328]	; 30014e80 <ip_output_if+0x588>
3001494c:	e1c326b4 	strh	r2, [r3, #100]	; 0x64
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
30014950:	e3a030fe 	mov	r3, #254	; 0xfe
30014954:	ea000143 	b	30014e68 <ip_output_if+0x570>
    }

    iphdr = p->payload;
30014958:	e59d300c 	ldr	r3, [sp, #12]
3001495c:	e5933004 	ldr	r3, [r3, #4]
30014960:	e58d3014 	str	r3, [sp, #20]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
30014964:	e59d3014 	ldr	r3, [sp, #20]
30014968:	e5d32008 	ldrb	r2, [r3, #8]
3001496c:	e5d33009 	ldrb	r3, [r3, #9]
30014970:	e1a03403 	lsl	r3, r3, #8
30014974:	e1833002 	orr	r3, r3, r2
30014978:	e1a03803 	lsl	r3, r3, #16
3001497c:	e1a03823 	lsr	r3, r3, #16
30014980:	e1a00003 	mov	r0, r3
30014984:	ebfffbdf 	bl	30013908 <ntohs>
30014988:	e1a03000 	mov	r3, r0
3001498c:	e1a03803 	lsl	r3, r3, #16
30014990:	e1a03823 	lsr	r3, r3, #16
30014994:	e20330ff 	and	r3, r3, #255	; 0xff
30014998:	e5dd2003 	ldrb	r2, [sp, #3]
3001499c:	e1a02402 	lsl	r2, r2, #8
300149a0:	e1a02802 	lsl	r2, r2, #16
300149a4:	e1a01822 	lsr	r1, r2, #16
300149a8:	e1a02003 	mov	r2, r3
300149ac:	e1a03001 	mov	r3, r1
300149b0:	e1823003 	orr	r3, r2, r3
300149b4:	e1a03803 	lsl	r3, r3, #16
300149b8:	e1a03823 	lsr	r3, r3, #16
300149bc:	e1a03803 	lsl	r3, r3, #16
300149c0:	e1a03823 	lsr	r3, r3, #16
300149c4:	e1a00003 	mov	r0, r3
300149c8:	ebfffbbb 	bl	300138bc <htons>
300149cc:	e1a03000 	mov	r3, r0
300149d0:	e1a02003 	mov	r2, r3
300149d4:	e59d3014 	ldr	r3, [sp, #20]
300149d8:	e20210ff 	and	r1, r2, #255	; 0xff
300149dc:	e3a00000 	mov	r0, #0
300149e0:	e1801001 	orr	r1, r0, r1
300149e4:	e5c31008 	strb	r1, [r3, #8]
300149e8:	e1a02422 	lsr	r2, r2, #8
300149ec:	e1a02802 	lsl	r2, r2, #16
300149f0:	e1a02822 	lsr	r2, r2, #16
300149f4:	e3a01000 	mov	r1, #0
300149f8:	e1812002 	orr	r2, r1, r2
300149fc:	e5c32009 	strb	r2, [r3, #9]
    IPH_PROTO_SET(iphdr, proto);
30014a00:	e5dd4024 	ldrb	r4, [sp, #36]	; 0x24
30014a04:	e59d3014 	ldr	r3, [sp, #20]
30014a08:	e5d32008 	ldrb	r2, [r3, #8]
30014a0c:	e5d33009 	ldrb	r3, [r3, #9]
30014a10:	e1a03403 	lsl	r3, r3, #8
30014a14:	e1833002 	orr	r3, r3, r2
30014a18:	e1a03803 	lsl	r3, r3, #16
30014a1c:	e1a03823 	lsr	r3, r3, #16
30014a20:	e1a00003 	mov	r0, r3
30014a24:	ebfffbb7 	bl	30013908 <ntohs>
30014a28:	e1a03000 	mov	r3, r0
30014a2c:	e1a03423 	lsr	r3, r3, #8
30014a30:	e1a03803 	lsl	r3, r3, #16
30014a34:	e1a03823 	lsr	r3, r3, #16
30014a38:	e1a03403 	lsl	r3, r3, #8
30014a3c:	e1a03803 	lsl	r3, r3, #16
30014a40:	e1a03823 	lsr	r3, r3, #16
30014a44:	e1a02004 	mov	r2, r4
30014a48:	e1823003 	orr	r3, r2, r3
30014a4c:	e1a03803 	lsl	r3, r3, #16
30014a50:	e1a03823 	lsr	r3, r3, #16
30014a54:	e1a03803 	lsl	r3, r3, #16
30014a58:	e1a03823 	lsr	r3, r3, #16
30014a5c:	e1a00003 	mov	r0, r3
30014a60:	ebfffb95 	bl	300138bc <htons>
30014a64:	e1a03000 	mov	r3, r0
30014a68:	e1a02003 	mov	r2, r3
30014a6c:	e59d3014 	ldr	r3, [sp, #20]
30014a70:	e20210ff 	and	r1, r2, #255	; 0xff
30014a74:	e3a00000 	mov	r0, #0
30014a78:	e1801001 	orr	r1, r0, r1
30014a7c:	e5c31008 	strb	r1, [r3, #8]
30014a80:	e1a02422 	lsr	r2, r2, #8
30014a84:	e1a02802 	lsl	r2, r2, #16
30014a88:	e1a02822 	lsr	r2, r2, #16
30014a8c:	e3a01000 	mov	r1, #0
30014a90:	e1812002 	orr	r2, r1, r2
30014a94:	e5c32009 	strb	r2, [r3, #9]

    ip_addr_set(&(iphdr->dest), dest);
30014a98:	e59d3004 	ldr	r3, [sp, #4]
30014a9c:	e3530000 	cmp	r3, #0
30014aa0:	0a00000b 	beq	30014ad4 <ip_output_if+0x1dc>
30014aa4:	e59d3004 	ldr	r3, [sp, #4]
30014aa8:	e5d32000 	ldrb	r2, [r3]
30014aac:	e5d31001 	ldrb	r1, [r3, #1]
30014ab0:	e1a01401 	lsl	r1, r1, #8
30014ab4:	e1812002 	orr	r2, r1, r2
30014ab8:	e5d31002 	ldrb	r1, [r3, #2]
30014abc:	e1a01801 	lsl	r1, r1, #16
30014ac0:	e1812002 	orr	r2, r1, r2
30014ac4:	e5d33003 	ldrb	r3, [r3, #3]
30014ac8:	e1a03c03 	lsl	r3, r3, #24
30014acc:	e1833002 	orr	r3, r3, r2
30014ad0:	ea000000 	b	30014ad8 <ip_output_if+0x1e0>
30014ad4:	e3a03000 	mov	r3, #0
30014ad8:	e59d2014 	ldr	r2, [sp, #20]
30014adc:	e20310ff 	and	r1, r3, #255	; 0xff
30014ae0:	e3a00000 	mov	r0, #0
30014ae4:	e1801001 	orr	r1, r0, r1
30014ae8:	e5c21010 	strb	r1, [r2, #16]
30014aec:	e1a01423 	lsr	r1, r3, #8
30014af0:	e20110ff 	and	r1, r1, #255	; 0xff
30014af4:	e3a00000 	mov	r0, #0
30014af8:	e1801001 	orr	r1, r0, r1
30014afc:	e5c21011 	strb	r1, [r2, #17]
30014b00:	e1a01823 	lsr	r1, r3, #16
30014b04:	e20110ff 	and	r1, r1, #255	; 0xff
30014b08:	e3a00000 	mov	r0, #0
30014b0c:	e1801001 	orr	r1, r0, r1
30014b10:	e5c21012 	strb	r1, [r2, #18]
30014b14:	e1a03c23 	lsr	r3, r3, #24
30014b18:	e3a01000 	mov	r1, #0
30014b1c:	e1813003 	orr	r3, r1, r3
30014b20:	e5c23013 	strb	r3, [r2, #19]

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
30014b24:	e5dd3020 	ldrb	r3, [sp, #32]
30014b28:	e3833c45 	orr	r3, r3, #17664	; 0x4500
30014b2c:	e1a03803 	lsl	r3, r3, #16
30014b30:	e1a03823 	lsr	r3, r3, #16
30014b34:	e1a03803 	lsl	r3, r3, #16
30014b38:	e1a03823 	lsr	r3, r3, #16
30014b3c:	e1a00003 	mov	r0, r3
30014b40:	ebfffb5d 	bl	300138bc <htons>
30014b44:	e1a03000 	mov	r3, r0
30014b48:	e1a02003 	mov	r2, r3
30014b4c:	e59d3014 	ldr	r3, [sp, #20]
30014b50:	e20210ff 	and	r1, r2, #255	; 0xff
30014b54:	e3a00000 	mov	r0, #0
30014b58:	e1801001 	orr	r1, r0, r1
30014b5c:	e5c31000 	strb	r1, [r3]
30014b60:	e1a02422 	lsr	r2, r2, #8
30014b64:	e1a02802 	lsl	r2, r2, #16
30014b68:	e1a02822 	lsr	r2, r2, #16
30014b6c:	e3a01000 	mov	r1, #0
30014b70:	e1812002 	orr	r2, r1, r2
30014b74:	e5c32001 	strb	r2, [r3, #1]
    IPH_LEN_SET(iphdr, htons(p->tot_len));
30014b78:	e59d300c 	ldr	r3, [sp, #12]
30014b7c:	e1d330b8 	ldrh	r3, [r3, #8]
30014b80:	e1a00003 	mov	r0, r3
30014b84:	ebfffb4c 	bl	300138bc <htons>
30014b88:	e1a03000 	mov	r3, r0
30014b8c:	e1a02003 	mov	r2, r3
30014b90:	e59d3014 	ldr	r3, [sp, #20]
30014b94:	e20210ff 	and	r1, r2, #255	; 0xff
30014b98:	e3a00000 	mov	r0, #0
30014b9c:	e1801001 	orr	r1, r0, r1
30014ba0:	e5c31002 	strb	r1, [r3, #2]
30014ba4:	e1a02422 	lsr	r2, r2, #8
30014ba8:	e1a02802 	lsl	r2, r2, #16
30014bac:	e1a02822 	lsr	r2, r2, #16
30014bb0:	e3a01000 	mov	r1, #0
30014bb4:	e1812002 	orr	r2, r1, r2
30014bb8:	e5c32003 	strb	r2, [r3, #3]
    IPH_OFFSET_SET(iphdr, 0);
30014bbc:	e59d3014 	ldr	r3, [sp, #20]
30014bc0:	e3a02000 	mov	r2, #0
30014bc4:	e5c32006 	strb	r2, [r3, #6]
30014bc8:	e3a02000 	mov	r2, #0
30014bcc:	e5c32007 	strb	r2, [r3, #7]
    IPH_ID_SET(iphdr, htons(ip_id));
30014bd0:	e59f32ac 	ldr	r3, [pc, #684]	; 30014e84 <ip_output_if+0x58c>
30014bd4:	e1d330b0 	ldrh	r3, [r3]
30014bd8:	e1a00003 	mov	r0, r3
30014bdc:	ebfffb36 	bl	300138bc <htons>
30014be0:	e1a03000 	mov	r3, r0
30014be4:	e1a02003 	mov	r2, r3
30014be8:	e59d3014 	ldr	r3, [sp, #20]
30014bec:	e20210ff 	and	r1, r2, #255	; 0xff
30014bf0:	e3a00000 	mov	r0, #0
30014bf4:	e1801001 	orr	r1, r0, r1
30014bf8:	e5c31004 	strb	r1, [r3, #4]
30014bfc:	e1a02422 	lsr	r2, r2, #8
30014c00:	e1a02802 	lsl	r2, r2, #16
30014c04:	e1a02822 	lsr	r2, r2, #16
30014c08:	e3a01000 	mov	r1, #0
30014c0c:	e1812002 	orr	r2, r1, r2
30014c10:	e5c32005 	strb	r2, [r3, #5]
    ++ip_id;
30014c14:	e59f3268 	ldr	r3, [pc, #616]	; 30014e84 <ip_output_if+0x58c>
30014c18:	e1d330b0 	ldrh	r3, [r3]
30014c1c:	e2833001 	add	r3, r3, #1
30014c20:	e1a03803 	lsl	r3, r3, #16
30014c24:	e1a02823 	lsr	r2, r3, #16
30014c28:	e59f3254 	ldr	r3, [pc, #596]	; 30014e84 <ip_output_if+0x58c>
30014c2c:	e1c320b0 	strh	r2, [r3]

    if (ip_addr_isany(src)) {
30014c30:	e59d3008 	ldr	r3, [sp, #8]
30014c34:	e3530000 	cmp	r3, #0
30014c38:	0a00000c 	beq	30014c70 <ip_output_if+0x378>
30014c3c:	e59d3008 	ldr	r3, [sp, #8]
30014c40:	e5d32000 	ldrb	r2, [r3]
30014c44:	e5d31001 	ldrb	r1, [r3, #1]
30014c48:	e1a01401 	lsl	r1, r1, #8
30014c4c:	e1812002 	orr	r2, r1, r2
30014c50:	e5d31002 	ldrb	r1, [r3, #2]
30014c54:	e1a01801 	lsl	r1, r1, #16
30014c58:	e1812002 	orr	r2, r1, r2
30014c5c:	e5d33003 	ldrb	r3, [r3, #3]
30014c60:	e1a03c03 	lsl	r3, r3, #24
30014c64:	e1833002 	orr	r3, r3, r2
30014c68:	e3530000 	cmp	r3, #0
30014c6c:	1a00001b 	bne	30014ce0 <ip_output_if+0x3e8>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
30014c70:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30014c74:	e2833004 	add	r3, r3, #4
30014c78:	e3530000 	cmp	r3, #0
30014c7c:	0a000002 	beq	30014c8c <ip_output_if+0x394>
30014c80:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30014c84:	e5933004 	ldr	r3, [r3, #4]
30014c88:	ea000000 	b	30014c90 <ip_output_if+0x398>
30014c8c:	e3a03000 	mov	r3, #0
30014c90:	e59d2014 	ldr	r2, [sp, #20]
30014c94:	e20310ff 	and	r1, r3, #255	; 0xff
30014c98:	e3a00000 	mov	r0, #0
30014c9c:	e1801001 	orr	r1, r0, r1
30014ca0:	e5c2100c 	strb	r1, [r2, #12]
30014ca4:	e1a01423 	lsr	r1, r3, #8
30014ca8:	e20110ff 	and	r1, r1, #255	; 0xff
30014cac:	e3a00000 	mov	r0, #0
30014cb0:	e1801001 	orr	r1, r0, r1
30014cb4:	e5c2100d 	strb	r1, [r2, #13]
30014cb8:	e1a01823 	lsr	r1, r3, #16
30014cbc:	e20110ff 	and	r1, r1, #255	; 0xff
30014cc0:	e3a00000 	mov	r0, #0
30014cc4:	e1801001 	orr	r1, r0, r1
30014cc8:	e5c2100e 	strb	r1, [r2, #14]
30014ccc:	e1a03c23 	lsr	r3, r3, #24
30014cd0:	e3a01000 	mov	r1, #0
30014cd4:	e1813003 	orr	r3, r1, r3
30014cd8:	e5c2300f 	strb	r3, [r2, #15]
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
    ++ip_id;

    if (ip_addr_isany(src)) {
30014cdc:	ea000022 	b	30014d6c <ip_output_if+0x474>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
    } else {
      ip_addr_set(&(iphdr->src), src);
30014ce0:	e59d3008 	ldr	r3, [sp, #8]
30014ce4:	e3530000 	cmp	r3, #0
30014ce8:	0a00000b 	beq	30014d1c <ip_output_if+0x424>
30014cec:	e59d3008 	ldr	r3, [sp, #8]
30014cf0:	e5d32000 	ldrb	r2, [r3]
30014cf4:	e5d31001 	ldrb	r1, [r3, #1]
30014cf8:	e1a01401 	lsl	r1, r1, #8
30014cfc:	e1812002 	orr	r2, r1, r2
30014d00:	e5d31002 	ldrb	r1, [r3, #2]
30014d04:	e1a01801 	lsl	r1, r1, #16
30014d08:	e1812002 	orr	r2, r1, r2
30014d0c:	e5d33003 	ldrb	r3, [r3, #3]
30014d10:	e1a03c03 	lsl	r3, r3, #24
30014d14:	e1833002 	orr	r3, r3, r2
30014d18:	ea000000 	b	30014d20 <ip_output_if+0x428>
30014d1c:	e3a03000 	mov	r3, #0
30014d20:	e59d2014 	ldr	r2, [sp, #20]
30014d24:	e20310ff 	and	r1, r3, #255	; 0xff
30014d28:	e3a00000 	mov	r0, #0
30014d2c:	e1801001 	orr	r1, r0, r1
30014d30:	e5c2100c 	strb	r1, [r2, #12]
30014d34:	e1a01423 	lsr	r1, r3, #8
30014d38:	e20110ff 	and	r1, r1, #255	; 0xff
30014d3c:	e3a00000 	mov	r0, #0
30014d40:	e1801001 	orr	r1, r0, r1
30014d44:	e5c2100d 	strb	r1, [r2, #13]
30014d48:	e1a01823 	lsr	r1, r3, #16
30014d4c:	e20110ff 	and	r1, r1, #255	; 0xff
30014d50:	e3a00000 	mov	r0, #0
30014d54:	e1801001 	orr	r1, r0, r1
30014d58:	e5c2100e 	strb	r1, [r2, #14]
30014d5c:	e1a03c23 	lsr	r3, r3, #24
30014d60:	e3a01000 	mov	r1, #0
30014d64:	e1813003 	orr	r3, r1, r3
30014d68:	e5c2300f 	strb	r3, [r2, #15]
    }

    IPH_CHKSUM_SET(iphdr, 0);
30014d6c:	e59d3014 	ldr	r3, [sp, #20]
30014d70:	e3a02000 	mov	r2, #0
30014d74:	e5c3200a 	strb	r2, [r3, #10]
30014d78:	e3a02000 	mov	r2, #0
30014d7c:	e5c3200b 	strb	r2, [r3, #11]
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
30014d80:	e59d0014 	ldr	r0, [sp, #20]
30014d84:	e3a01014 	mov	r1, #20
30014d88:	ebfffcb5 	bl	30014064 <inet_chksum>
30014d8c:	e1a03000 	mov	r3, r0
30014d90:	e1a02003 	mov	r2, r3
30014d94:	e59d3014 	ldr	r3, [sp, #20]
30014d98:	e20210ff 	and	r1, r2, #255	; 0xff
30014d9c:	e3a00000 	mov	r0, #0
30014da0:	e1801001 	orr	r1, r0, r1
30014da4:	e5c3100a 	strb	r1, [r3, #10]
30014da8:	e1a02422 	lsr	r2, r2, #8
30014dac:	e1a02802 	lsl	r2, r2, #16
30014db0:	e1a02822 	lsr	r2, r2, #16
30014db4:	e3a01000 	mov	r1, #0
30014db8:	e1812002 	orr	r2, r1, r2
30014dbc:	e5c3200b 	strb	r2, [r3, #11]
30014dc0:	ea000005 	b	30014ddc <ip_output_if+0x4e4>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
30014dc4:	e59d300c 	ldr	r3, [sp, #12]
30014dc8:	e5933004 	ldr	r3, [r3, #4]
30014dcc:	e58d3014 	str	r3, [sp, #20]
    dest = &(iphdr->dest);
30014dd0:	e59d3014 	ldr	r3, [sp, #20]
30014dd4:	e2833010 	add	r3, r3, #16
30014dd8:	e58d3004 	str	r3, [sp, #4]
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
30014ddc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30014de0:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
30014de4:	e3530000 	cmp	r3, #0
30014de8:	0a00000d 	beq	30014e24 <ip_output_if+0x52c>
30014dec:	e59d300c 	ldr	r3, [sp, #12]
30014df0:	e1d320b8 	ldrh	r2, [r3, #8]
30014df4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30014df8:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
30014dfc:	e1520003 	cmp	r2, r3
30014e00:	9a000007 	bls	30014e24 <ip_output_if+0x52c>
    return ip_frag(p,netif,dest);
30014e04:	e59d000c 	ldr	r0, [sp, #12]
30014e08:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
30014e0c:	e59d2004 	ldr	r2, [sp, #4]
30014e10:	eb000088 	bl	30015038 <ip_frag>
30014e14:	e1a03000 	mov	r3, r0
30014e18:	e20330ff 	and	r3, r3, #255	; 0xff
30014e1c:	e20330ff 	and	r3, r3, #255	; 0xff
30014e20:	ea000010 	b	30014e68 <ip_output_if+0x570>
#endif

  IP_STATS_INC(ip.xmit);
30014e24:	e59f3054 	ldr	r3, [pc, #84]	; 30014e80 <ip_output_if+0x588>
30014e28:	e1d334be 	ldrh	r3, [r3, #78]	; 0x4e
30014e2c:	e2833001 	add	r3, r3, #1
30014e30:	e1a03803 	lsl	r3, r3, #16
30014e34:	e1a02823 	lsr	r2, r3, #16
30014e38:	e59f3040 	ldr	r3, [pc, #64]	; 30014e80 <ip_output_if+0x588>
30014e3c:	e1c324be 	strh	r2, [r3, #78]	; 0x4e
  LWIP_DEBUGF(IP_DEBUG, ("ip_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], netif->num));
  ip_debug_print(p);

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  //acoral_print("\r\nIpOutPutIf***netif\r\n");
  return netif->output(netif, p, dest);
30014e40:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30014e44:	e5933014 	ldr	r3, [r3, #20]
30014e48:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
30014e4c:	e59d100c 	ldr	r1, [sp, #12]
30014e50:	e59d2004 	ldr	r2, [sp, #4]
30014e54:	e1a0e00f 	mov	lr, pc
30014e58:	e12fff13 	bx	r3
30014e5c:	e1a03000 	mov	r3, r0
30014e60:	e20330ff 	and	r3, r3, #255	; 0xff
30014e64:	e20330ff 	and	r3, r3, #255	; 0xff
30014e68:	e1a03c03 	lsl	r3, r3, #24
30014e6c:	e1a03c43 	asr	r3, r3, #24
}
30014e70:	e1a00003 	mov	r0, r3
30014e74:	e28dd018 	add	sp, sp, #24
30014e78:	e8bd4010 	pop	{r4, lr}
30014e7c:	e12fff1e 	bx	lr
30014e80:	3002b214 	.word	0x3002b214
30014e84:	30027224 	.word	0x30027224

30014e88 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
30014e88:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30014e8c:	e24dd02c 	sub	sp, sp, #44	; 0x2c
30014e90:	e58d001c 	str	r0, [sp, #28]
30014e94:	e58d1018 	str	r1, [sp, #24]
30014e98:	e58d2014 	str	r2, [sp, #20]
30014e9c:	e5cd3013 	strb	r3, [sp, #19]
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
30014ea0:	e59d0014 	ldr	r0, [sp, #20]
30014ea4:	ebfffcd9 	bl	30014210 <ip_route>
30014ea8:	e1a03000 	mov	r3, r0
30014eac:	e58d3024 	str	r3, [sp, #36]	; 0x24
30014eb0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30014eb4:	e3530000 	cmp	r3, #0
30014eb8:	1a000001 	bne	30014ec4 <ip_output+0x3c>
    return ERR_RTE;
30014ebc:	e3a030fd 	mov	r3, #253	; 0xfd
30014ec0:	ea00000d 	b	30014efc <ip_output+0x74>
  }
  //acoral_print("\r\nIP_OUTPUT\r\n");
  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
30014ec4:	e5dd3013 	ldrb	r3, [sp, #19]
30014ec8:	e5dd2030 	ldrb	r2, [sp, #48]	; 0x30
30014ecc:	e58d2000 	str	r2, [sp]
30014ed0:	e5dd2034 	ldrb	r2, [sp, #52]	; 0x34
30014ed4:	e58d2004 	str	r2, [sp, #4]
30014ed8:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30014edc:	e58d2008 	str	r2, [sp, #8]
30014ee0:	e59d001c 	ldr	r0, [sp, #28]
30014ee4:	e59d1018 	ldr	r1, [sp, #24]
30014ee8:	e59d2014 	ldr	r2, [sp, #20]
30014eec:	ebfffe81 	bl	300148f8 <ip_output_if>
30014ef0:	e1a03000 	mov	r3, r0
30014ef4:	e20330ff 	and	r3, r3, #255	; 0xff
30014ef8:	e20330ff 	and	r3, r3, #255	; 0xff
30014efc:	e1a03c03 	lsl	r3, r3, #24
30014f00:	e1a03c43 	asr	r3, r3, #24
}
30014f04:	e1a00003 	mov	r0, r3
30014f08:	e28dd02c 	add	sp, sp, #44	; 0x2c
30014f0c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30014f10:	e12fff1e 	bx	lr

30014f14 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
30014f14:	e24dd010 	sub	sp, sp, #16
30014f18:	e58d0004 	str	r0, [sp, #4]
30014f1c:	e58d1000 	str	r1, [sp]
  u32_t addr2test;

  addr2test = addr->addr;
30014f20:	e59d3004 	ldr	r3, [sp, #4]
30014f24:	e5d32000 	ldrb	r2, [r3]
30014f28:	e5d31001 	ldrb	r1, [r3, #1]
30014f2c:	e1a01401 	lsl	r1, r1, #8
30014f30:	e1812002 	orr	r2, r1, r2
30014f34:	e5d31002 	ldrb	r1, [r3, #2]
30014f38:	e1a01801 	lsl	r1, r1, #16
30014f3c:	e1812002 	orr	r2, r1, r2
30014f40:	e5d33003 	ldrb	r3, [r3, #3]
30014f44:	e1a03c03 	lsl	r3, r3, #24
30014f48:	e1833002 	orr	r3, r3, r2
30014f4c:	e58d300c 	str	r3, [sp, #12]
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
30014f50:	e59d300c 	ldr	r3, [sp, #12]
30014f54:	e3730001 	cmn	r3, #1
30014f58:	0a000002 	beq	30014f68 <ip_addr_isbroadcast+0x54>
30014f5c:	e59d300c 	ldr	r3, [sp, #12]
30014f60:	e3530000 	cmp	r3, #0
30014f64:	1a000001 	bne	30014f70 <ip_addr_isbroadcast+0x5c>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
30014f68:	e3a03001 	mov	r3, #1
30014f6c:	ea00002e 	b	3001502c <ip_addr_isbroadcast+0x118>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
30014f70:	e59d3000 	ldr	r3, [sp]
30014f74:	e5d3302a 	ldrb	r3, [r3, #42]	; 0x2a
30014f78:	e2033002 	and	r3, r3, #2
30014f7c:	e3530000 	cmp	r3, #0
30014f80:	1a000001 	bne	30014f8c <ip_addr_isbroadcast+0x78>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
30014f84:	e3a03000 	mov	r3, #0
30014f88:	ea000027 	b	3001502c <ip_addr_isbroadcast+0x118>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
30014f8c:	e59d3000 	ldr	r3, [sp]
30014f90:	e5932004 	ldr	r2, [r3, #4]
30014f94:	e59d300c 	ldr	r3, [sp, #12]
30014f98:	e1520003 	cmp	r2, r3
30014f9c:	1a000001 	bne	30014fa8 <ip_addr_isbroadcast+0x94>
    return 0;
30014fa0:	e3a03000 	mov	r3, #0
30014fa4:	ea000020 	b	3001502c <ip_addr_isbroadcast+0x118>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
30014fa8:	e59d3004 	ldr	r3, [sp, #4]
30014fac:	e5d32000 	ldrb	r2, [r3]
30014fb0:	e5d31001 	ldrb	r1, [r3, #1]
30014fb4:	e1a01401 	lsl	r1, r1, #8
30014fb8:	e1812002 	orr	r2, r1, r2
30014fbc:	e5d31002 	ldrb	r1, [r3, #2]
30014fc0:	e1a01801 	lsl	r1, r1, #16
30014fc4:	e1812002 	orr	r2, r1, r2
30014fc8:	e5d33003 	ldrb	r3, [r3, #3]
30014fcc:	e1a03c03 	lsl	r3, r3, #24
30014fd0:	e1833002 	orr	r3, r3, r2
30014fd4:	e1a02003 	mov	r2, r3
30014fd8:	e59d3000 	ldr	r3, [sp]
30014fdc:	e5933004 	ldr	r3, [r3, #4]
30014fe0:	e0222003 	eor	r2, r2, r3
30014fe4:	e59d3000 	ldr	r3, [sp]
30014fe8:	e5933008 	ldr	r3, [r3, #8]
30014fec:	e0023003 	and	r3, r2, r3
30014ff0:	e3530000 	cmp	r3, #0
30014ff4:	1a00000b 	bne	30015028 <ip_addr_isbroadcast+0x114>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
30014ff8:	e59d3000 	ldr	r3, [sp]
30014ffc:	e5933008 	ldr	r3, [r3, #8]
30015000:	e1e02003 	mvn	r2, r3
30015004:	e59d300c 	ldr	r3, [sp, #12]
30015008:	e0022003 	and	r2, r2, r3
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
3001500c:	e59d3000 	ldr	r3, [sp]
30015010:	e5933008 	ldr	r3, [r3, #8]
30015014:	e1e03003 	mvn	r3, r3
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
30015018:	e1520003 	cmp	r2, r3
3001501c:	1a000001 	bne	30015028 <ip_addr_isbroadcast+0x114>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
30015020:	e3a03001 	mov	r3, #1
30015024:	ea000000 	b	3001502c <ip_addr_isbroadcast+0x118>
  else
    return 0;
30015028:	e3a03000 	mov	r3, #0
}
3001502c:	e1a00003 	mov	r0, r3
30015030:	e28dd010 	add	sp, sp, #16
30015034:	e12fff1e 	bx	lr

30015038 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
30015038:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001503c:	e24dd034 	sub	sp, sp, #52	; 0x34
30015040:	e58d000c 	str	r0, [sp, #12]
30015044:	e58d1008 	str	r1, [sp, #8]
30015048:	e58d2004 	str	r2, [sp, #4]
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
3001504c:	e59d3008 	ldr	r3, [sp, #8]
30015050:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
30015054:	e1cd32b4 	strh	r3, [sp, #36]	; 0x24
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
30015058:	e3a03014 	mov	r3, #20
3001505c:	e1cd32bc 	strh	r3, [sp, #44]	; 0x2c
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
30015060:	e3a00002 	mov	r0, #2
30015064:	e3a01000 	mov	r1, #0
30015068:	e3a02002 	mov	r2, #2
3001506c:	eb000380 	bl	30015e74 <pbuf_alloc>
30015070:	e1a03000 	mov	r3, r0
30015074:	e58d3010 	str	r3, [sp, #16]
  if (rambuf == NULL) {
30015078:	e59d3010 	ldr	r3, [sp, #16]
3001507c:	e3530000 	cmp	r3, #0
30015080:	1a000001 	bne	3001508c <ip_frag+0x54>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
30015084:	e3a030ff 	mov	r3, #255	; 0xff
30015088:	ea0000d2 	b	300153d8 <ip_frag+0x3a0>
  }
  rambuf->tot_len = rambuf->len = mtu;
3001508c:	e59d3010 	ldr	r3, [sp, #16]
30015090:	e1dd22b4 	ldrh	r2, [sp, #36]	; 0x24
30015094:	e1c320ba 	strh	r2, [r3, #10]
30015098:	e59d3010 	ldr	r3, [sp, #16]
3001509c:	e1d320ba 	ldrh	r2, [r3, #10]
300150a0:	e59d3010 	ldr	r3, [sp, #16]
300150a4:	e1c320b8 	strh	r2, [r3, #8]
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
300150a8:	e59f3340 	ldr	r3, [pc, #832]	; 300153f0 <ip_frag+0x3b8>
300150ac:	e2833003 	add	r3, r3, #3
300150b0:	e3c33003 	bic	r3, r3, #3
300150b4:	e1a02003 	mov	r2, r3
300150b8:	e59d3010 	ldr	r3, [sp, #16]
300150bc:	e5832004 	str	r2, [r3, #4]

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
300150c0:	e59d3010 	ldr	r3, [sp, #16]
300150c4:	e5933004 	ldr	r3, [r3, #4]
300150c8:	e58d3018 	str	r3, [sp, #24]
  SMEMCPY(iphdr, p->payload, IP_HLEN);
300150cc:	e59d300c 	ldr	r3, [sp, #12]
300150d0:	e5933004 	ldr	r3, [r3, #4]
300150d4:	e59d0018 	ldr	r0, [sp, #24]
300150d8:	e1a01003 	mov	r1, r3
300150dc:	e3a02014 	mov	r2, #20
300150e0:	ebffdf99 	bl	3000cf4c <__re_memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
300150e4:	e59d3018 	ldr	r3, [sp, #24]
300150e8:	e5d32006 	ldrb	r2, [r3, #6]
300150ec:	e5d33007 	ldrb	r3, [r3, #7]
300150f0:	e1a03403 	lsl	r3, r3, #8
300150f4:	e1833002 	orr	r3, r3, r2
300150f8:	e1a03803 	lsl	r3, r3, #16
300150fc:	e1a03823 	lsr	r3, r3, #16
30015100:	e1a00003 	mov	r0, r3
30015104:	ebfff9ff 	bl	30013908 <ntohs>
30015108:	e1a03000 	mov	r3, r0
3001510c:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
  ofo = tmp & IP_OFFMASK;
30015110:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
30015114:	e1a03983 	lsl	r3, r3, #19
30015118:	e1a039a3 	lsr	r3, r3, #19
3001511c:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
  omf = tmp & IP_MF;
30015120:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
30015124:	e2033a02 	and	r3, r3, #8192	; 0x2000
30015128:	e1cd32b8 	strh	r3, [sp, #40]	; 0x28

  left = p->tot_len - IP_HLEN;
3001512c:	e59d300c 	ldr	r3, [sp, #12]
30015130:	e1d330b8 	ldrh	r3, [r3, #8]
30015134:	e2433014 	sub	r3, r3, #20
30015138:	e1cd32b0 	strh	r3, [sp, #32]

  nfb = (mtu - IP_HLEN) / 8;
3001513c:	e1dd32b4 	ldrh	r3, [sp, #36]	; 0x24
30015140:	e2433014 	sub	r3, r3, #20
30015144:	e2832007 	add	r2, r3, #7
30015148:	e3530000 	cmp	r3, #0
3001514c:	b1a03002 	movlt	r3, r2
30015150:	e1a031c3 	asr	r3, r3, #3
30015154:	e1cd31be 	strh	r3, [sp, #30]

  while (left) {
30015158:	ea000098 	b	300153c0 <ip_frag+0x388>
    last = (left <= mtu - IP_HLEN);
3001515c:	e1dd22b0 	ldrh	r2, [sp, #32]
30015160:	e1dd32b4 	ldrh	r3, [sp, #36]	; 0x24
30015164:	e2433014 	sub	r3, r3, #20
30015168:	e1520003 	cmp	r2, r3
3001516c:	c3a03000 	movgt	r3, #0
30015170:	d3a03001 	movle	r3, #1
30015174:	e1cd32ba 	strh	r3, [sp, #42]	; 0x2a

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
30015178:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3001517c:	e1a03803 	lsl	r3, r3, #16
30015180:	e1a03823 	lsr	r3, r3, #16
30015184:	e1a03983 	lsl	r3, r3, #19
30015188:	e1a039a3 	lsr	r3, r3, #19
3001518c:	e1dd12b8 	ldrh	r1, [sp, #40]	; 0x28
30015190:	e1a02003 	mov	r2, r3
30015194:	e1a03001 	mov	r3, r1
30015198:	e1823003 	orr	r3, r2, r3
3001519c:	e1a03803 	lsl	r3, r3, #16
300151a0:	e1a03823 	lsr	r3, r3, #16
300151a4:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
    if (!last)
300151a8:	e1dd32ba 	ldrh	r3, [sp, #42]	; 0x2a
300151ac:	e3530000 	cmp	r3, #0
300151b0:	1a000002 	bne	300151c0 <ip_frag+0x188>
      tmp = tmp | IP_MF;
300151b4:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
300151b8:	e3833a02 	orr	r3, r3, #8192	; 0x2000
300151bc:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
300151c0:	e1dd32ba 	ldrh	r3, [sp, #42]	; 0x2a
300151c4:	e3530000 	cmp	r3, #0
300151c8:	1a000004 	bne	300151e0 <ip_frag+0x1a8>
300151cc:	e1dd31be 	ldrh	r3, [sp, #30]
300151d0:	e1a03183 	lsl	r3, r3, #3
300151d4:	e1a03803 	lsl	r3, r3, #16
300151d8:	e1a03823 	lsr	r3, r3, #16
300151dc:	ea000000 	b	300151e4 <ip_frag+0x1ac>
300151e0:	e1dd32b0 	ldrh	r3, [sp, #32]
300151e4:	e1cd32b2 	strh	r3, [sp, #34]	; 0x22

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
300151e8:	e59d3018 	ldr	r3, [sp, #24]
300151ec:	e2831014 	add	r1, r3, #20
300151f0:	e1dd22b2 	ldrh	r2, [sp, #34]	; 0x22
300151f4:	e1dd32bc 	ldrh	r3, [sp, #44]	; 0x2c
300151f8:	e59d000c 	ldr	r0, [sp, #12]
300151fc:	eb0005e7 	bl	300169a0 <pbuf_copy_partial>
30015200:	e1a03000 	mov	r3, r0
30015204:	e1a02003 	mov	r2, r3
30015208:	e1dd32bc 	ldrh	r3, [sp, #44]	; 0x2c
3001520c:	e0823003 	add	r3, r2, r3
30015210:	e1cd32bc 	strh	r3, [sp, #44]	; 0x2c
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
30015214:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
30015218:	e1a00003 	mov	r0, r3
3001521c:	ebfff9a6 	bl	300138bc <htons>
30015220:	e1a03000 	mov	r3, r0
30015224:	e1a02003 	mov	r2, r3
30015228:	e59d3018 	ldr	r3, [sp, #24]
3001522c:	e20210ff 	and	r1, r2, #255	; 0xff
30015230:	e3a00000 	mov	r0, #0
30015234:	e1801001 	orr	r1, r0, r1
30015238:	e5c31006 	strb	r1, [r3, #6]
3001523c:	e1a02422 	lsr	r2, r2, #8
30015240:	e1a02802 	lsl	r2, r2, #16
30015244:	e1a02822 	lsr	r2, r2, #16
30015248:	e3a01000 	mov	r1, #0
3001524c:	e1812002 	orr	r2, r1, r2
30015250:	e5c32007 	strb	r2, [r3, #7]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
30015254:	e1dd32b2 	ldrh	r3, [sp, #34]	; 0x22
30015258:	e2833014 	add	r3, r3, #20
3001525c:	e1a03803 	lsl	r3, r3, #16
30015260:	e1a03823 	lsr	r3, r3, #16
30015264:	e1a00003 	mov	r0, r3
30015268:	ebfff993 	bl	300138bc <htons>
3001526c:	e1a03000 	mov	r3, r0
30015270:	e1a02003 	mov	r2, r3
30015274:	e59d3018 	ldr	r3, [sp, #24]
30015278:	e20210ff 	and	r1, r2, #255	; 0xff
3001527c:	e3a00000 	mov	r0, #0
30015280:	e1801001 	orr	r1, r0, r1
30015284:	e5c31002 	strb	r1, [r3, #2]
30015288:	e1a02422 	lsr	r2, r2, #8
3001528c:	e1a02802 	lsl	r2, r2, #16
30015290:	e1a02822 	lsr	r2, r2, #16
30015294:	e3a01000 	mov	r1, #0
30015298:	e1812002 	orr	r2, r1, r2
3001529c:	e5c32003 	strb	r2, [r3, #3]
    IPH_CHKSUM_SET(iphdr, 0);
300152a0:	e59d3018 	ldr	r3, [sp, #24]
300152a4:	e3a02000 	mov	r2, #0
300152a8:	e5c3200a 	strb	r2, [r3, #10]
300152ac:	e3a02000 	mov	r2, #0
300152b0:	e5c3200b 	strb	r2, [r3, #11]
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
300152b4:	e59d0018 	ldr	r0, [sp, #24]
300152b8:	e3a01014 	mov	r1, #20
300152bc:	ebfffb68 	bl	30014064 <inet_chksum>
300152c0:	e1a03000 	mov	r3, r0
300152c4:	e1a02003 	mov	r2, r3
300152c8:	e59d3018 	ldr	r3, [sp, #24]
300152cc:	e20210ff 	and	r1, r2, #255	; 0xff
300152d0:	e3a00000 	mov	r0, #0
300152d4:	e1801001 	orr	r1, r0, r1
300152d8:	e5c3100a 	strb	r1, [r3, #10]
300152dc:	e1a02422 	lsr	r2, r2, #8
300152e0:	e1a02802 	lsl	r2, r2, #16
300152e4:	e1a02822 	lsr	r2, r2, #16
300152e8:	e3a01000 	mov	r1, #0
300152ec:	e1812002 	orr	r2, r1, r2
300152f0:	e5c3200b 	strb	r2, [r3, #11]

#if IP_FRAG_USES_STATIC_BUF
    if (last)
300152f4:	e1dd32ba 	ldrh	r3, [sp, #42]	; 0x2a
300152f8:	e3530000 	cmp	r3, #0
300152fc:	0a000006 	beq	3001531c <ip_frag+0x2e4>
      pbuf_realloc(rambuf, left + IP_HLEN);
30015300:	e1dd32b0 	ldrh	r3, [sp, #32]
30015304:	e2833014 	add	r3, r3, #20
30015308:	e1a03803 	lsl	r3, r3, #16
3001530c:	e1a03823 	lsr	r3, r3, #16
30015310:	e59d0010 	ldr	r0, [sp, #16]
30015314:	e1a01003 	mov	r1, r3
30015318:	eb0003c1 	bl	30016224 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
3001531c:	e3a00002 	mov	r0, #2
30015320:	e3a01000 	mov	r1, #0
30015324:	e3a02000 	mov	r2, #0
30015328:	eb0002d1 	bl	30015e74 <pbuf_alloc>
3001532c:	e1a03000 	mov	r3, r0
30015330:	e58d3014 	str	r3, [sp, #20]
    if (header != NULL) {
30015334:	e59d3014 	ldr	r3, [sp, #20]
30015338:	e3530000 	cmp	r3, #0
3001533c:	0a00001b 	beq	300153b0 <ip_frag+0x378>
      pbuf_chain(header, rambuf);
30015340:	e59d0014 	ldr	r0, [sp, #20]
30015344:	e59d1010 	ldr	r1, [sp, #16]
30015348:	eb000509 	bl	30016774 <pbuf_chain>
      netif->output(netif, header, dest);
3001534c:	e59d3008 	ldr	r3, [sp, #8]
30015350:	e5933014 	ldr	r3, [r3, #20]
30015354:	e59d0008 	ldr	r0, [sp, #8]
30015358:	e59d1014 	ldr	r1, [sp, #20]
3001535c:	e59d2004 	ldr	r2, [sp, #4]
30015360:	e1a0e00f 	mov	lr, pc
30015364:	e12fff13 	bx	r3
      IPFRAG_STATS_INC(ip_frag.xmit);
30015368:	e59f3084 	ldr	r3, [pc, #132]	; 300153f4 <ip_frag+0x3bc>
3001536c:	e1d333b4 	ldrh	r3, [r3, #52]	; 0x34
30015370:	e2833001 	add	r3, r3, #1
30015374:	e1a03803 	lsl	r3, r3, #16
30015378:	e1a02823 	lsr	r2, r3, #16
3001537c:	e59f3070 	ldr	r3, [pc, #112]	; 300153f4 <ip_frag+0x3bc>
30015380:	e1c323b4 	strh	r2, [r3, #52]	; 0x34
      snmp_inc_ipfragcreates();
      pbuf_free(header);
30015384:	e59d0014 	ldr	r0, [sp, #20]
30015388:	eb000468 	bl	30016530 <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
3001538c:	e1dd22b0 	ldrh	r2, [sp, #32]
30015390:	e1dd32b2 	ldrh	r3, [sp, #34]	; 0x22
30015394:	e0633002 	rsb	r3, r3, r2
30015398:	e1cd32b0 	strh	r3, [sp, #32]
    ofo += nfb;
3001539c:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
300153a0:	e1dd31be 	ldrh	r3, [sp, #30]
300153a4:	e0823003 	add	r3, r2, r3
300153a8:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
300153ac:	ea000003 	b	300153c0 <ip_frag+0x388>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
300153b0:	e59d0010 	ldr	r0, [sp, #16]
300153b4:	eb00045d 	bl	30016530 <pbuf_free>
      return ERR_MEM;
300153b8:	e3a030ff 	mov	r3, #255	; 0xff
300153bc:	ea000005 	b	300153d8 <ip_frag+0x3a0>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
300153c0:	e1dd32b0 	ldrh	r3, [sp, #32]
300153c4:	e3530000 	cmp	r3, #0
300153c8:	1affff63 	bne	3001515c <ip_frag+0x124>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
300153cc:	e59d0010 	ldr	r0, [sp, #16]
300153d0:	eb000456 	bl	30016530 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
300153d4:	e3a03000 	mov	r3, #0
300153d8:	e1a03c03 	lsl	r3, r3, #24
300153dc:	e1a03c43 	asr	r3, r3, #24
}
300153e0:	e1a00003 	mov	r0, r3
300153e4:	e28dd034 	add	sp, sp, #52	; 0x34
300153e8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300153ec:	e12fff1e 	bx	lr
300153f0:	30027228 	.word	0x30027228
300153f4:	3002b214 	.word	0x3002b214

300153f8 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
300153f8:	e92d4008 	push	{r3, lr}
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
300153fc:	ebffdd81 	bl	3000ca08 <sys_init>
  mem_init();
30015400:	eb002e4a 	bl	30020d30 <mem_init>
  memp_init();
30015404:	eb000002 	bl	30015414 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
30015408:	ebffe923 	bl	3000f89c <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
3001540c:	e8bd4008 	pop	{r3, lr}
30015410:	e12fff1e 	bx	lr

30015414 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
30015414:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
30015418:	e24dd00c 	sub	sp, sp, #12
  struct memp *memp;
  u16_t i, j;

#if MEMP_STATS
  for (i = 0; i < MEMP_MAX; ++i) {
3001541c:	e3a03000 	mov	r3, #0
30015420:	e1cd30b4 	strh	r3, [sp, #4]
30015424:	ea000036 	b	30015504 <memp_init+0xf0>
    lwip_stats.memp[i].used = lwip_stats.memp[i].max =
30015428:	e1dd00b4 	ldrh	r0, [sp, #4]
3001542c:	e1dd30b4 	ldrh	r3, [sp, #4]
      lwip_stats.memp[i].err = 0;
30015430:	e1dd20b4 	ldrh	r2, [sp, #4]
  struct memp *memp;
  u16_t i, j;

#if MEMP_STATS
  for (i = 0; i < MEMP_MAX; ++i) {
    lwip_stats.memp[i].used = lwip_stats.memp[i].max =
30015434:	e59fc1a0 	ldr	ip, [pc, #416]	; 300155dc <memp_init+0x1c8>
30015438:	e2824017 	add	r4, r2, #23
3001543c:	e3a0100c 	mov	r1, #12
30015440:	e1a04184 	lsl	r4, r4, #3
30015444:	e084c00c 	add	ip, r4, ip
30015448:	e08c1001 	add	r1, ip, r1
3001544c:	e3a0c000 	mov	ip, #0
30015450:	e1c1c0b0 	strh	ip, [r1]
      lwip_stats.memp[i].err = 0;
30015454:	e59f1180 	ldr	r1, [pc, #384]	; 300155dc <memp_init+0x1c8>
30015458:	e282c017 	add	ip, r2, #23
3001545c:	e3a0200c 	mov	r2, #12
30015460:	e1a0c18c 	lsl	ip, ip, #3
30015464:	e08c1001 	add	r1, ip, r1
30015468:	e0812002 	add	r2, r1, r2
3001546c:	e1d210b0 	ldrh	r1, [r2]
  struct memp *memp;
  u16_t i, j;

#if MEMP_STATS
  for (i = 0; i < MEMP_MAX; ++i) {
    lwip_stats.memp[i].used = lwip_stats.memp[i].max =
30015470:	e59fc164 	ldr	ip, [pc, #356]	; 300155dc <memp_init+0x1c8>
30015474:	e2834017 	add	r4, r3, #23
30015478:	e3a0200a 	mov	r2, #10
3001547c:	e1a04184 	lsl	r4, r4, #3
30015480:	e084c00c 	add	ip, r4, ip
30015484:	e08c2002 	add	r2, ip, r2
30015488:	e1c210b0 	strh	r1, [r2]
3001548c:	e59f2148 	ldr	r2, [pc, #328]	; 300155dc <memp_init+0x1c8>
30015490:	e2831017 	add	r1, r3, #23
30015494:	e3a0300a 	mov	r3, #10
30015498:	e1a01181 	lsl	r1, r1, #3
3001549c:	e0812002 	add	r2, r1, r2
300154a0:	e0823003 	add	r3, r2, r3
300154a4:	e1d320b0 	ldrh	r2, [r3]
300154a8:	e59f112c 	ldr	r1, [pc, #300]	; 300155dc <memp_init+0x1c8>
300154ac:	e2800017 	add	r0, r0, #23
300154b0:	e3a03008 	mov	r3, #8
300154b4:	e1a00180 	lsl	r0, r0, #3
300154b8:	e0801001 	add	r1, r0, r1
300154bc:	e0813003 	add	r3, r1, r3
300154c0:	e1c320b0 	strh	r2, [r3]
      lwip_stats.memp[i].err = 0;
    lwip_stats.memp[i].avail = memp_num[i];
300154c4:	e1dd30b4 	ldrh	r3, [sp, #4]
300154c8:	e1dd10b4 	ldrh	r1, [sp, #4]
300154cc:	e59f210c 	ldr	r2, [pc, #268]	; 300155e0 <memp_init+0x1cc>
300154d0:	e1a01081 	lsl	r1, r1, #1
300154d4:	e0812002 	add	r2, r1, r2
300154d8:	e1d220b0 	ldrh	r2, [r2]
300154dc:	e59f10f8 	ldr	r1, [pc, #248]	; 300155dc <memp_init+0x1c8>
300154e0:	e2830017 	add	r0, r3, #23
300154e4:	e3a03006 	mov	r3, #6
300154e8:	e1a00180 	lsl	r0, r0, #3
300154ec:	e0801001 	add	r1, r0, r1
300154f0:	e0813003 	add	r3, r1, r3
300154f4:	e1c320b0 	strh	r2, [r3]
{
  struct memp *memp;
  u16_t i, j;

#if MEMP_STATS
  for (i = 0; i < MEMP_MAX; ++i) {
300154f8:	e1dd30b4 	ldrh	r3, [sp, #4]
300154fc:	e2833001 	add	r3, r3, #1
30015500:	e1cd30b4 	strh	r3, [sp, #4]
30015504:	e1dd30b4 	ldrh	r3, [sp, #4]
30015508:	e353000c 	cmp	r3, #12
3001550c:	9affffc5 	bls	30015428 <memp_init+0x14>
      lwip_stats.memp[i].err = 0;
    lwip_stats.memp[i].avail = memp_num[i];
  }
#endif /* MEMP_STATS */

  memp = LWIP_MEM_ALIGN(memp_memory);
30015510:	e59f30cc 	ldr	r3, [pc, #204]	; 300155e4 <memp_init+0x1d0>
30015514:	e2833003 	add	r3, r3, #3
30015518:	e3c33003 	bic	r3, r3, #3
3001551c:	e58d3000 	str	r3, [sp]
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
30015520:	e3a03000 	mov	r3, #0
30015524:	e1cd30b4 	strh	r3, [sp, #4]
30015528:	ea000025 	b	300155c4 <memp_init+0x1b0>
    memp_tab[i] = NULL;
3001552c:	e1dd20b4 	ldrh	r2, [sp, #4]
30015530:	e59f30b0 	ldr	r3, [pc, #176]	; 300155e8 <memp_init+0x1d4>
30015534:	e3a01000 	mov	r1, #0
30015538:	e7831102 	str	r1, [r3, r2, lsl #2]
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
3001553c:	e3a03000 	mov	r3, #0
30015540:	e1cd30b6 	strh	r3, [sp, #6]
30015544:	ea000013 	b	30015598 <memp_init+0x184>
      memp->next = memp_tab[i];
30015548:	e1dd20b4 	ldrh	r2, [sp, #4]
3001554c:	e59f3094 	ldr	r3, [pc, #148]	; 300155e8 <memp_init+0x1d4>
30015550:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30015554:	e59d3000 	ldr	r3, [sp]
30015558:	e5832000 	str	r2, [r3]
      memp_tab[i] = memp;
3001555c:	e1dd20b4 	ldrh	r2, [sp, #4]
30015560:	e59f3080 	ldr	r3, [pc, #128]	; 300155e8 <memp_init+0x1d4>
30015564:	e59d1000 	ldr	r1, [sp]
30015568:	e7831102 	str	r1, [r3, r2, lsl #2]
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
3001556c:	e1dd20b4 	ldrh	r2, [sp, #4]
30015570:	e59f3074 	ldr	r3, [pc, #116]	; 300155ec <memp_init+0x1d8>
30015574:	e1a02082 	lsl	r2, r2, #1
30015578:	e0823003 	add	r3, r2, r3
3001557c:	e1d330b0 	ldrh	r3, [r3]
30015580:	e59d2000 	ldr	r2, [sp]
30015584:	e0823003 	add	r3, r2, r3
30015588:	e58d3000 	str	r3, [sp]
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
3001558c:	e1dd30b6 	ldrh	r3, [sp, #6]
30015590:	e2833001 	add	r3, r3, #1
30015594:	e1cd30b6 	strh	r3, [sp, #6]
30015598:	e1dd20b4 	ldrh	r2, [sp, #4]
3001559c:	e59f303c 	ldr	r3, [pc, #60]	; 300155e0 <memp_init+0x1cc>
300155a0:	e1a02082 	lsl	r2, r2, #1
300155a4:	e0823003 	add	r3, r2, r3
300155a8:	e1d330b0 	ldrh	r3, [r3]
300155ac:	e1dd20b6 	ldrh	r2, [sp, #6]
300155b0:	e1520003 	cmp	r2, r3
300155b4:	3affffe3 	bcc	30015548 <memp_init+0x134>
  }
#endif /* MEMP_STATS */

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
300155b8:	e1dd30b4 	ldrh	r3, [sp, #4]
300155bc:	e2833001 	add	r3, r3, #1
300155c0:	e1cd30b4 	strh	r3, [sp, #4]
300155c4:	e1dd30b4 	ldrh	r3, [sp, #4]
300155c8:	e353000c 	cmp	r3, #12
300155cc:	9affffd6 	bls	3001552c <memp_init+0x118>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
300155d0:	e28dd00c 	add	sp, sp, #12
300155d4:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
300155d8:	e12fff1e 	bx	lr
300155dc:	3002b214 	.word	0x3002b214
300155e0:	30026580 	.word	0x30026580
300155e4:	30027838 	.word	0x30027838
300155e8:	30027804 	.word	0x30027804
300155ec:	30026564 	.word	0x30026564

300155f0 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
300155f0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300155f4:	e24dd014 	sub	sp, sp, #20
300155f8:	e1a03000 	mov	r3, r0
300155fc:	e5cd3007 	strb	r3, [sp, #7]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);

  SYS_ARCH_PROTECT(old_level);
30015600:	ebffb03b 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30015604:	e1a03000 	mov	r3, r0
30015608:	e58d300c 	str	r3, [sp, #12]
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
3001560c:	e5dd2007 	ldrb	r2, [sp, #7]
30015610:	e59f3164 	ldr	r3, [pc, #356]	; 3001577c <memp_malloc+0x18c>
30015614:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30015618:	e58d3008 	str	r3, [sp, #8]
  
  if (memp != NULL) {    
3001561c:	e59d3008 	ldr	r3, [sp, #8]
30015620:	e3530000 	cmp	r3, #0
30015624:	0a000039 	beq	30015710 <memp_malloc+0x120>
    memp_tab[type] = memp->next;    
30015628:	e5dd2007 	ldrb	r2, [sp, #7]
3001562c:	e59d3008 	ldr	r3, [sp, #8]
30015630:	e5931000 	ldr	r1, [r3]
30015634:	e59f3140 	ldr	r3, [pc, #320]	; 3001577c <memp_malloc+0x18c>
30015638:	e7831102 	str	r1, [r3, r2, lsl #2]
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
#if MEMP_STATS
    ++lwip_stats.memp[type].used;
3001563c:	e5dd3007 	ldrb	r3, [sp, #7]
30015640:	e59f1138 	ldr	r1, [pc, #312]	; 30015780 <memp_malloc+0x190>
30015644:	e2830017 	add	r0, r3, #23
30015648:	e3a02008 	mov	r2, #8
3001564c:	e1a00180 	lsl	r0, r0, #3
30015650:	e0801001 	add	r1, r0, r1
30015654:	e0812002 	add	r2, r1, r2
30015658:	e1d220b0 	ldrh	r2, [r2]
3001565c:	e2822001 	add	r2, r2, #1
30015660:	e1a02802 	lsl	r2, r2, #16
30015664:	e1a02822 	lsr	r2, r2, #16
30015668:	e59f1110 	ldr	r1, [pc, #272]	; 30015780 <memp_malloc+0x190>
3001566c:	e2830017 	add	r0, r3, #23
30015670:	e3a03008 	mov	r3, #8
30015674:	e1a00180 	lsl	r0, r0, #3
30015678:	e0801001 	add	r1, r0, r1
3001567c:	e0813003 	add	r3, r1, r3
30015680:	e1c320b0 	strh	r2, [r3]
    if (lwip_stats.memp[type].used > lwip_stats.memp[type].max) {
30015684:	e5dd3007 	ldrb	r3, [sp, #7]
30015688:	e59f20f0 	ldr	r2, [pc, #240]	; 30015780 <memp_malloc+0x190>
3001568c:	e2831017 	add	r1, r3, #23
30015690:	e3a03008 	mov	r3, #8
30015694:	e1a01181 	lsl	r1, r1, #3
30015698:	e0812002 	add	r2, r1, r2
3001569c:	e0823003 	add	r3, r2, r3
300156a0:	e1d320b0 	ldrh	r2, [r3]
300156a4:	e5dd3007 	ldrb	r3, [sp, #7]
300156a8:	e59f10d0 	ldr	r1, [pc, #208]	; 30015780 <memp_malloc+0x190>
300156ac:	e2830017 	add	r0, r3, #23
300156b0:	e3a0300a 	mov	r3, #10
300156b4:	e1a00180 	lsl	r0, r0, #3
300156b8:	e0801001 	add	r1, r0, r1
300156bc:	e0813003 	add	r3, r1, r3
300156c0:	e1d330b0 	ldrh	r3, [r3]
300156c4:	e1520003 	cmp	r2, r3
300156c8:	9a000023 	bls	3001575c <memp_malloc+0x16c>
      lwip_stats.memp[type].max = lwip_stats.memp[type].used;
300156cc:	e5dd3007 	ldrb	r3, [sp, #7]
300156d0:	e5dd2007 	ldrb	r2, [sp, #7]
300156d4:	e59f10a4 	ldr	r1, [pc, #164]	; 30015780 <memp_malloc+0x190>
300156d8:	e2820017 	add	r0, r2, #23
300156dc:	e3a02008 	mov	r2, #8
300156e0:	e1a00180 	lsl	r0, r0, #3
300156e4:	e0801001 	add	r1, r0, r1
300156e8:	e0812002 	add	r2, r1, r2
300156ec:	e1d220b0 	ldrh	r2, [r2]
300156f0:	e59f1088 	ldr	r1, [pc, #136]	; 30015780 <memp_malloc+0x190>
300156f4:	e2830017 	add	r0, r3, #23
300156f8:	e3a0300a 	mov	r3, #10
300156fc:	e1a00180 	lsl	r0, r0, #3
30015700:	e0801001 	add	r1, r0, r1
30015704:	e0813003 	add	r3, r1, r3
30015708:	e1c320b0 	strh	r2, [r3]
3001570c:	ea000013 	b	30015760 <memp_malloc+0x170>
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
    memp = (struct memp*)((u8_t*)memp + MEMP_SIZE);
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | 2, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
#if MEMP_STATS
    ++lwip_stats.memp[type].err;
30015710:	e5dd3007 	ldrb	r3, [sp, #7]
30015714:	e59f1064 	ldr	r1, [pc, #100]	; 30015780 <memp_malloc+0x190>
30015718:	e2830017 	add	r0, r3, #23
3001571c:	e3a0200c 	mov	r2, #12
30015720:	e1a00180 	lsl	r0, r0, #3
30015724:	e0801001 	add	r1, r0, r1
30015728:	e0812002 	add	r2, r1, r2
3001572c:	e1d220b0 	ldrh	r2, [r2]
30015730:	e2822001 	add	r2, r2, #1
30015734:	e1a02802 	lsl	r2, r2, #16
30015738:	e1a02822 	lsr	r2, r2, #16
3001573c:	e59f103c 	ldr	r1, [pc, #60]	; 30015780 <memp_malloc+0x190>
30015740:	e2830017 	add	r0, r3, #23
30015744:	e3a0300c 	mov	r3, #12
30015748:	e1a00180 	lsl	r0, r0, #3
3001574c:	e0801001 	add	r1, r0, r1
30015750:	e0813003 	add	r3, r1, r3
30015754:	e1c320b0 	strh	r2, [r3]
30015758:	ea000000 	b	30015760 <memp_malloc+0x170>
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
#if MEMP_STATS
    ++lwip_stats.memp[type].used;
    if (lwip_stats.memp[type].used > lwip_stats.memp[type].max) {
      lwip_stats.memp[type].max = lwip_stats.memp[type].used;
3001575c:	e1a00000 	nop			; (mov r0, r0)
#if MEMP_STATS
    ++lwip_stats.memp[type].err;
#endif /* MEMP_STATS */
  }

  SYS_ARCH_UNPROTECT(old_level);
30015760:	e59d000c 	ldr	r0, [sp, #12]
30015764:	ebffafe0 	bl	300016ec <HAL_INTR_RESTORE>

  return memp;
30015768:	e59d3008 	ldr	r3, [sp, #8]
}
3001576c:	e1a00003 	mov	r0, r3
30015770:	e28dd014 	add	sp, sp, #20
30015774:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30015778:	e12fff1e 	bx	lr
3001577c:	30027804 	.word	0x30027804
30015780:	3002b214 	.word	0x3002b214

30015784 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
30015784:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30015788:	e24dd014 	sub	sp, sp, #20
3001578c:	e1a03000 	mov	r3, r0
30015790:	e58d1000 	str	r1, [sp]
30015794:	e5cd3007 	strb	r3, [sp, #7]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
30015798:	e59d3000 	ldr	r3, [sp]
3001579c:	e3530000 	cmp	r3, #0
300157a0:	0a000022 	beq	30015830 <memp_free+0xac>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)((u8_t*)mem - MEMP_SIZE);
300157a4:	e59d3000 	ldr	r3, [sp]
300157a8:	e58d3008 	str	r3, [sp, #8]

  SYS_ARCH_PROTECT(old_level);
300157ac:	ebffafd0 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300157b0:	e1a03000 	mov	r3, r0
300157b4:	e58d300c 	str	r3, [sp, #12]
  memp_overflow_check_element(memp, memp_sizes[type]);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

#if MEMP_STATS
  lwip_stats.memp[type].used--; 
300157b8:	e5dd3007 	ldrb	r3, [sp, #7]
300157bc:	e59f107c 	ldr	r1, [pc, #124]	; 30015840 <memp_free+0xbc>
300157c0:	e2830017 	add	r0, r3, #23
300157c4:	e3a02008 	mov	r2, #8
300157c8:	e1a00180 	lsl	r0, r0, #3
300157cc:	e0801001 	add	r1, r0, r1
300157d0:	e0812002 	add	r2, r1, r2
300157d4:	e1d220b0 	ldrh	r2, [r2]
300157d8:	e2422001 	sub	r2, r2, #1
300157dc:	e1a02802 	lsl	r2, r2, #16
300157e0:	e1a02822 	lsr	r2, r2, #16
300157e4:	e59f1054 	ldr	r1, [pc, #84]	; 30015840 <memp_free+0xbc>
300157e8:	e2830017 	add	r0, r3, #23
300157ec:	e3a03008 	mov	r3, #8
300157f0:	e1a00180 	lsl	r0, r0, #3
300157f4:	e0801001 	add	r1, r0, r1
300157f8:	e0813003 	add	r3, r1, r3
300157fc:	e1c320b0 	strh	r2, [r3]
#endif /* MEMP_STATS */
  
  memp->next = memp_tab[type]; 
30015800:	e5dd2007 	ldrb	r2, [sp, #7]
30015804:	e59f3038 	ldr	r3, [pc, #56]	; 30015844 <memp_free+0xc0>
30015808:	e7932102 	ldr	r2, [r3, r2, lsl #2]
3001580c:	e59d3008 	ldr	r3, [sp, #8]
30015810:	e5832000 	str	r2, [r3]
  memp_tab[type] = memp;
30015814:	e5dd2007 	ldrb	r2, [sp, #7]
30015818:	e59f3024 	ldr	r3, [pc, #36]	; 30015844 <memp_free+0xc0>
3001581c:	e59d1008 	ldr	r1, [sp, #8]
30015820:	e7831102 	str	r1, [r3, r2, lsl #2]

#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
30015824:	e59d000c 	ldr	r0, [sp, #12]
30015828:	ebffafaf 	bl	300016ec <HAL_INTR_RESTORE>
3001582c:	ea000000 	b	30015834 <memp_free+0xb0>
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
30015830:	e1a00000 	nop			; (mov r0, r0)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
30015834:	e28dd014 	add	sp, sp, #20
30015838:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001583c:	e12fff1e 	bx	lr
30015840:	3002b214 	.word	0x3002b214
30015844:	30027804 	.word	0x30027804

30015848 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
30015848:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001584c:	e24dd014 	sub	sp, sp, #20
30015850:	e58d000c 	str	r0, [sp, #12]
30015854:	e58d1008 	str	r1, [sp, #8]
30015858:	e58d2004 	str	r2, [sp, #4]
3001585c:	e58d3000 	str	r3, [sp]
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
30015860:	e59d300c 	ldr	r3, [sp, #12]
30015864:	e3a02000 	mov	r2, #0
30015868:	e5832004 	str	r2, [r3, #4]
  netif->netmask.addr = 0;
3001586c:	e59d300c 	ldr	r3, [sp, #12]
30015870:	e3a02000 	mov	r2, #0
30015874:	e5832008 	str	r2, [r3, #8]
  netif->gw.addr = 0;
30015878:	e59d300c 	ldr	r3, [sp, #12]
3001587c:	e3a02000 	mov	r2, #0
30015880:	e583200c 	str	r2, [r3, #12]
  netif->flags = 0;
30015884:	e59d300c 	ldr	r3, [sp, #12]
30015888:	e3a02000 	mov	r2, #0
3001588c:	e5c3202a 	strb	r2, [r3, #42]	; 0x2a
#if LWIP_IGMP
  netif->igmp_mac_filter = NULL;
#endif /* LWIP_IGMP */

  /* remember netif specific state information data */
  netif->state = state;
30015890:	e59d300c 	ldr	r3, [sp, #12]
30015894:	e59d2018 	ldr	r2, [sp, #24]
30015898:	e583201c 	str	r2, [r3, #28]
  netif->num = netifnum++;
3001589c:	e59f3094 	ldr	r3, [pc, #148]	; 30015938 <netif_add+0xf0>
300158a0:	e5d33000 	ldrb	r3, [r3]
300158a4:	e59d200c 	ldr	r2, [sp, #12]
300158a8:	e1a01003 	mov	r1, r3
300158ac:	e5c2102d 	strb	r1, [r2, #45]	; 0x2d
300158b0:	e2833001 	add	r3, r3, #1
300158b4:	e20320ff 	and	r2, r3, #255	; 0xff
300158b8:	e59f3078 	ldr	r3, [pc, #120]	; 30015938 <netif_add+0xf0>
300158bc:	e5c32000 	strb	r2, [r3]
  netif->input = input;
300158c0:	e59d300c 	ldr	r3, [sp, #12]
300158c4:	e59d2020 	ldr	r2, [sp, #32]
300158c8:	e5832010 	str	r2, [r3, #16]
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  netif_set_addr(netif, ipaddr, netmask, gw);
300158cc:	e59d000c 	ldr	r0, [sp, #12]
300158d0:	e59d1008 	ldr	r1, [sp, #8]
300158d4:	e59d2004 	ldr	r2, [sp, #4]
300158d8:	e59d3000 	ldr	r3, [sp]
300158dc:	eb000017 	bl	30015940 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
300158e0:	e59d301c 	ldr	r3, [sp, #28]
300158e4:	e59d000c 	ldr	r0, [sp, #12]
300158e8:	e1a0e00f 	mov	lr, pc
300158ec:	e12fff13 	bx	r3
300158f0:	e1a03000 	mov	r3, r0
300158f4:	e20330ff 	and	r3, r3, #255	; 0xff
300158f8:	e3530000 	cmp	r3, #0
300158fc:	0a000001 	beq	30015908 <netif_add+0xc0>
    return NULL;
30015900:	e3a03000 	mov	r3, #0
30015904:	ea000007 	b	30015928 <netif_add+0xe0>
  }

  /* add this netif to the list */
  netif->next = netif_list;
30015908:	e59f302c 	ldr	r3, [pc, #44]	; 3001593c <netif_add+0xf4>
3001590c:	e5932000 	ldr	r2, [r3]
30015910:	e59d300c 	ldr	r3, [sp, #12]
30015914:	e5832000 	str	r2, [r3]
  netif_list = netif;
30015918:	e59f301c 	ldr	r3, [pc, #28]	; 3001593c <netif_add+0xf4>
3001591c:	e59d200c 	ldr	r2, [sp, #12]
30015920:	e5832000 	str	r2, [r3]
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
30015924:	e59d300c 	ldr	r3, [sp, #12]
}
30015928:	e1a00003 	mov	r0, r3
3001592c:	e28dd014 	add	sp, sp, #20
30015930:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30015934:	e12fff1e 	bx	lr
30015938:	30028f50 	.word	0x30028f50
3001593c:	3002a10c 	.word	0x3002a10c

30015940 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
30015940:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30015944:	e24dd014 	sub	sp, sp, #20
30015948:	e58d000c 	str	r0, [sp, #12]
3001594c:	e58d1008 	str	r1, [sp, #8]
30015950:	e58d2004 	str	r2, [sp, #4]
30015954:	e58d3000 	str	r3, [sp]
  netif_set_ipaddr(netif, ipaddr);
30015958:	e59d000c 	ldr	r0, [sp, #12]
3001595c:	e59d1008 	ldr	r1, [sp, #8]
30015960:	eb00006e 	bl	30015b20 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
30015964:	e59d000c 	ldr	r0, [sp, #12]
30015968:	e59d1004 	ldr	r1, [sp, #4]
3001596c:	eb0000ee 	bl	30015d2c <netif_set_netmask>
  netif_set_gw(netif, gw);
30015970:	e59d000c 	ldr	r0, [sp, #12]
30015974:	e59d1000 	ldr	r1, [sp]
30015978:	eb0000d4 	bl	30015cd0 <netif_set_gw>
}
3001597c:	e28dd014 	add	sp, sp, #20
30015980:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30015984:	e12fff1e 	bx	lr

30015988 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
30015988:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001598c:	e24dd014 	sub	sp, sp, #20
30015990:	e58d0004 	str	r0, [sp, #4]
  if ( netif == NULL ) return;
30015994:	e59d3004 	ldr	r3, [sp, #4]
30015998:	e3530000 	cmp	r3, #0
3001599c:	0a000028 	beq	30015a44 <netif_remove+0xbc>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
300159a0:	e59f30b4 	ldr	r3, [pc, #180]	; 30015a5c <netif_remove+0xd4>
300159a4:	e5932000 	ldr	r2, [r3]
300159a8:	e59d3004 	ldr	r3, [sp, #4]
300159ac:	e1520003 	cmp	r2, r3
300159b0:	1a000004 	bne	300159c8 <netif_remove+0x40>
    netif_list = netif->next;
300159b4:	e59d3004 	ldr	r3, [sp, #4]
300159b8:	e5932000 	ldr	r2, [r3]
300159bc:	e59f3098 	ldr	r3, [pc, #152]	; 30015a5c <netif_remove+0xd4>
300159c0:	e5832000 	str	r2, [r3]
300159c4:	ea000016 	b	30015a24 <netif_remove+0x9c>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
300159c8:	e59f308c 	ldr	r3, [pc, #140]	; 30015a5c <netif_remove+0xd4>
300159cc:	e5933000 	ldr	r3, [r3]
300159d0:	e58d300c 	str	r3, [sp, #12]
300159d4:	ea00000c 	b	30015a0c <netif_remove+0x84>
      if (tmpNetif->next == netif) {
300159d8:	e59d300c 	ldr	r3, [sp, #12]
300159dc:	e5932000 	ldr	r2, [r3]
300159e0:	e59d3004 	ldr	r3, [sp, #4]
300159e4:	e1520003 	cmp	r2, r3
300159e8:	1a000004 	bne	30015a00 <netif_remove+0x78>
        tmpNetif->next = netif->next;
300159ec:	e59d3004 	ldr	r3, [sp, #4]
300159f0:	e5932000 	ldr	r2, [r3]
300159f4:	e59d300c 	ldr	r3, [sp, #12]
300159f8:	e5832000 	str	r2, [r3]
        snmp_dec_iflist();
        break;
300159fc:	ea000005 	b	30015a18 <netif_remove+0x90>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
30015a00:	e59d300c 	ldr	r3, [sp, #12]
30015a04:	e5933000 	ldr	r3, [r3]
30015a08:	e58d300c 	str	r3, [sp, #12]
30015a0c:	e59d300c 	ldr	r3, [sp, #12]
30015a10:	e3530000 	cmp	r3, #0
30015a14:	1affffef 	bne	300159d8 <netif_remove+0x50>
        tmpNetif->next = netif->next;
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
30015a18:	e59d300c 	ldr	r3, [sp, #12]
30015a1c:	e3530000 	cmp	r3, #0
30015a20:	0a000009 	beq	30015a4c <netif_remove+0xc4>
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
30015a24:	e59f3034 	ldr	r3, [pc, #52]	; 30015a60 <netif_remove+0xd8>
30015a28:	e5932000 	ldr	r2, [r3]
30015a2c:	e59d3004 	ldr	r3, [sp, #4]
30015a30:	e1520003 	cmp	r2, r3
30015a34:	1a000005 	bne	30015a50 <netif_remove+0xc8>
    /* reset default netif */
    netif_set_default(NULL);
30015a38:	e3a00000 	mov	r0, #0
30015a3c:	eb0000d1 	bl	30015d88 <netif_set_default>
30015a40:	ea000002 	b	30015a50 <netif_remove+0xc8>
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  if ( netif == NULL ) return;
30015a44:	e1a00000 	nop			; (mov r0, r0)
30015a48:	ea000000 	b	30015a50 <netif_remove+0xc8>
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
30015a4c:	e1a00000 	nop			; (mov r0, r0)
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
30015a50:	e28dd014 	add	sp, sp, #20
30015a54:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30015a58:	e12fff1e 	bx	lr
30015a5c:	3002a10c 	.word	0x3002a10c
30015a60:	3002b34c 	.word	0x3002b34c

30015a64 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
30015a64:	e24dd010 	sub	sp, sp, #16
30015a68:	e58d0004 	str	r0, [sp, #4]
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
30015a6c:	e59d3004 	ldr	r3, [sp, #4]
30015a70:	e3530000 	cmp	r3, #0
30015a74:	1a000001 	bne	30015a80 <netif_find+0x1c>
    return NULL;
30015a78:	e3a03000 	mov	r3, #0
30015a7c:	ea000023 	b	30015b10 <netif_find+0xac>
  }

  num = name[2] - '0';
30015a80:	e59d3004 	ldr	r3, [sp, #4]
30015a84:	e2833002 	add	r3, r3, #2
30015a88:	e5d33000 	ldrb	r3, [r3]
30015a8c:	e2433030 	sub	r3, r3, #48	; 0x30
30015a90:	e5cd300f 	strb	r3, [sp, #15]

  for(netif = netif_list; netif != NULL; netif = netif->next) {
30015a94:	e59f3080 	ldr	r3, [pc, #128]	; 30015b1c <netif_find+0xb8>
30015a98:	e5933000 	ldr	r3, [r3]
30015a9c:	e58d3008 	str	r3, [sp, #8]
30015aa0:	ea000016 	b	30015b00 <netif_find+0x9c>
    if (num == netif->num &&
30015aa4:	e59d3008 	ldr	r3, [sp, #8]
30015aa8:	e5d3302d 	ldrb	r3, [r3, #45]	; 0x2d
30015aac:	e5dd200f 	ldrb	r2, [sp, #15]
30015ab0:	e1520003 	cmp	r2, r3
30015ab4:	1a00000e 	bne	30015af4 <netif_find+0x90>
       name[0] == netif->name[0] &&
30015ab8:	e59d3004 	ldr	r3, [sp, #4]
30015abc:	e5d32000 	ldrb	r2, [r3]
30015ac0:	e59d3008 	ldr	r3, [sp, #8]
30015ac4:	e5d3302b 	ldrb	r3, [r3, #43]	; 0x2b
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
30015ac8:	e1520003 	cmp	r2, r3
30015acc:	1a000008 	bne	30015af4 <netif_find+0x90>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
30015ad0:	e59d3004 	ldr	r3, [sp, #4]
30015ad4:	e2833001 	add	r3, r3, #1
30015ad8:	e5d32000 	ldrb	r2, [r3]
30015adc:	e59d3008 	ldr	r3, [sp, #8]
30015ae0:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
30015ae4:	e1520003 	cmp	r2, r3
30015ae8:	1a000001 	bne	30015af4 <netif_find+0x90>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
30015aec:	e59d3008 	ldr	r3, [sp, #8]
30015af0:	ea000006 	b	30015b10 <netif_find+0xac>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
30015af4:	e59d3008 	ldr	r3, [sp, #8]
30015af8:	e5933000 	ldr	r3, [r3]
30015afc:	e58d3008 	str	r3, [sp, #8]
30015b00:	e59d3008 	ldr	r3, [sp, #8]
30015b04:	e3530000 	cmp	r3, #0
30015b08:	1affffe5 	bne	30015aa4 <netif_find+0x40>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
30015b0c:	e3a03000 	mov	r3, #0
}
30015b10:	e1a00003 	mov	r0, r3
30015b14:	e28dd010 	add	sp, sp, #16
30015b18:	e12fff1e 	bx	lr
30015b1c:	3002a10c 	.word	0x3002a10c

30015b20 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
30015b20:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30015b24:	e24dd01c 	sub	sp, sp, #28
30015b28:	e58d0004 	str	r0, [sp, #4]
30015b2c:	e58d1000 	str	r1, [sp]
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
30015b30:	e59d3000 	ldr	r3, [sp]
30015b34:	e5d32000 	ldrb	r2, [r3]
30015b38:	e5d31001 	ldrb	r1, [r3, #1]
30015b3c:	e1a01401 	lsl	r1, r1, #8
30015b40:	e1812002 	orr	r2, r1, r2
30015b44:	e5d31002 	ldrb	r1, [r3, #2]
30015b48:	e1a01801 	lsl	r1, r1, #16
30015b4c:	e1812002 	orr	r2, r1, r2
30015b50:	e5d33003 	ldrb	r3, [r3, #3]
30015b54:	e1a03c03 	lsl	r3, r3, #24
30015b58:	e1833002 	orr	r3, r3, r2
30015b5c:	e1a02003 	mov	r2, r3
30015b60:	e59d3004 	ldr	r3, [sp, #4]
30015b64:	e5933004 	ldr	r3, [r3, #4]
30015b68:	e1520003 	cmp	r2, r3
30015b6c:	0a000040 	beq	30015c74 <netif_set_ipaddr+0x154>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
30015b70:	e59f3150 	ldr	r3, [pc, #336]	; 30015cc8 <netif_set_ipaddr+0x1a8>
30015b74:	e5933000 	ldr	r3, [r3]
30015b78:	e58d300c 	str	r3, [sp, #12]
    while (pcb != NULL) {
30015b7c:	ea000010 	b	30015bc4 <netif_set_ipaddr+0xa4>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
30015b80:	e59d300c 	ldr	r3, [sp, #12]
30015b84:	e5932000 	ldr	r2, [r3]
30015b88:	e59d3004 	ldr	r3, [sp, #4]
30015b8c:	e5933004 	ldr	r3, [r3, #4]
30015b90:	e1520003 	cmp	r2, r3
30015b94:	1a000007 	bne	30015bb8 <netif_set_ipaddr+0x98>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
30015b98:	e59d300c 	ldr	r3, [sp, #12]
30015b9c:	e593300c 	ldr	r3, [r3, #12]
30015ba0:	e58d3014 	str	r3, [sp, #20]
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
30015ba4:	e59d000c 	ldr	r0, [sp, #12]
30015ba8:	eb000786 	bl	300179c8 <tcp_abort>
        pcb = next;
30015bac:	e59d3014 	ldr	r3, [sp, #20]
30015bb0:	e58d300c 	str	r3, [sp, #12]
30015bb4:	ea000002 	b	30015bc4 <netif_set_ipaddr+0xa4>
      } else {
        pcb = pcb->next;
30015bb8:	e59d300c 	ldr	r3, [sp, #12]
30015bbc:	e593300c 	ldr	r3, [r3, #12]
30015bc0:	e58d300c 	str	r3, [sp, #12]
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
30015bc4:	e59d300c 	ldr	r3, [sp, #12]
30015bc8:	e3530000 	cmp	r3, #0
30015bcc:	1affffeb 	bne	30015b80 <netif_set_ipaddr+0x60>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
30015bd0:	e59f30f4 	ldr	r3, [pc, #244]	; 30015ccc <netif_set_ipaddr+0x1ac>
30015bd4:	e5933000 	ldr	r3, [r3]
30015bd8:	e58d3010 	str	r3, [sp, #16]
30015bdc:	ea000021 	b	30015c68 <netif_set_ipaddr+0x148>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
30015be0:	e59d3010 	ldr	r3, [sp, #16]
30015be4:	e3530000 	cmp	r3, #0
30015be8:	0a00001b 	beq	30015c5c <netif_set_ipaddr+0x13c>
30015bec:	e59d3010 	ldr	r3, [sp, #16]
30015bf0:	e5933000 	ldr	r3, [r3]
30015bf4:	e3530000 	cmp	r3, #0
30015bf8:	0a000017 	beq	30015c5c <netif_set_ipaddr+0x13c>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
30015bfc:	e59d3010 	ldr	r3, [sp, #16]
30015c00:	e5932000 	ldr	r2, [r3]
30015c04:	e59d3004 	ldr	r3, [sp, #4]
30015c08:	e5933004 	ldr	r3, [r3, #4]
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
30015c0c:	e1520003 	cmp	r2, r3
30015c10:	1a000011 	bne	30015c5c <netif_set_ipaddr+0x13c>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
30015c14:	e59d3000 	ldr	r3, [sp]
30015c18:	e3530000 	cmp	r3, #0
30015c1c:	0a00000b 	beq	30015c50 <netif_set_ipaddr+0x130>
30015c20:	e59d3000 	ldr	r3, [sp]
30015c24:	e5d32000 	ldrb	r2, [r3]
30015c28:	e5d31001 	ldrb	r1, [r3, #1]
30015c2c:	e1a01401 	lsl	r1, r1, #8
30015c30:	e1812002 	orr	r2, r1, r2
30015c34:	e5d31002 	ldrb	r1, [r3, #2]
30015c38:	e1a01801 	lsl	r1, r1, #16
30015c3c:	e1812002 	orr	r2, r1, r2
30015c40:	e5d33003 	ldrb	r3, [r3, #3]
30015c44:	e1a03c03 	lsl	r3, r3, #24
30015c48:	e1833002 	orr	r3, r3, r2
30015c4c:	ea000000 	b	30015c54 <netif_set_ipaddr+0x134>
30015c50:	e3a03000 	mov	r3, #0
30015c54:	e59d2010 	ldr	r2, [sp, #16]
30015c58:	e5823000 	str	r3, [r2]
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
30015c5c:	e59d3010 	ldr	r3, [sp, #16]
30015c60:	e593300c 	ldr	r3, [r3, #12]
30015c64:	e58d3010 	str	r3, [sp, #16]
30015c68:	e59d3010 	ldr	r3, [sp, #16]
30015c6c:	e3530000 	cmp	r3, #0
30015c70:	1affffda 	bne	30015be0 <netif_set_ipaddr+0xc0>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
30015c74:	e59d3000 	ldr	r3, [sp]
30015c78:	e3530000 	cmp	r3, #0
30015c7c:	0a00000b 	beq	30015cb0 <netif_set_ipaddr+0x190>
30015c80:	e59d3000 	ldr	r3, [sp]
30015c84:	e5d32000 	ldrb	r2, [r3]
30015c88:	e5d31001 	ldrb	r1, [r3, #1]
30015c8c:	e1a01401 	lsl	r1, r1, #8
30015c90:	e1812002 	orr	r2, r1, r2
30015c94:	e5d31002 	ldrb	r1, [r3, #2]
30015c98:	e1a01801 	lsl	r1, r1, #16
30015c9c:	e1812002 	orr	r2, r1, r2
30015ca0:	e5d33003 	ldrb	r3, [r3, #3]
30015ca4:	e1a03c03 	lsl	r3, r3, #24
30015ca8:	e1833002 	orr	r3, r3, r2
30015cac:	ea000000 	b	30015cb4 <netif_set_ipaddr+0x194>
30015cb0:	e3a03000 	mov	r3, #0
30015cb4:	e59d2004 	ldr	r2, [sp, #4]
30015cb8:	e5823004 	str	r3, [r2, #4]
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
30015cbc:	e28dd01c 	add	sp, sp, #28
30015cc0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30015cc4:	e12fff1e 	bx	lr
30015cc8:	3002a6e8 	.word	0x3002a6e8
30015ccc:	3002a728 	.word	0x3002a728

30015cd0 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
30015cd0:	e24dd008 	sub	sp, sp, #8
30015cd4:	e58d0004 	str	r0, [sp, #4]
30015cd8:	e58d1000 	str	r1, [sp]
  ip_addr_set(&(netif->gw), gw);
30015cdc:	e59d3000 	ldr	r3, [sp]
30015ce0:	e3530000 	cmp	r3, #0
30015ce4:	0a00000b 	beq	30015d18 <netif_set_gw+0x48>
30015ce8:	e59d3000 	ldr	r3, [sp]
30015cec:	e5d32000 	ldrb	r2, [r3]
30015cf0:	e5d31001 	ldrb	r1, [r3, #1]
30015cf4:	e1a01401 	lsl	r1, r1, #8
30015cf8:	e1812002 	orr	r2, r1, r2
30015cfc:	e5d31002 	ldrb	r1, [r3, #2]
30015d00:	e1a01801 	lsl	r1, r1, #16
30015d04:	e1812002 	orr	r2, r1, r2
30015d08:	e5d33003 	ldrb	r3, [r3, #3]
30015d0c:	e1a03c03 	lsl	r3, r3, #24
30015d10:	e1833002 	orr	r3, r3, r2
30015d14:	ea000000 	b	30015d1c <netif_set_gw+0x4c>
30015d18:	e3a03000 	mov	r3, #0
30015d1c:	e59d2004 	ldr	r2, [sp, #4]
30015d20:	e582300c 	str	r3, [r2, #12]
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
30015d24:	e28dd008 	add	sp, sp, #8
30015d28:	e12fff1e 	bx	lr

30015d2c <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
30015d2c:	e24dd008 	sub	sp, sp, #8
30015d30:	e58d0004 	str	r0, [sp, #4]
30015d34:	e58d1000 	str	r1, [sp]
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
30015d38:	e59d3000 	ldr	r3, [sp]
30015d3c:	e3530000 	cmp	r3, #0
30015d40:	0a00000b 	beq	30015d74 <netif_set_netmask+0x48>
30015d44:	e59d3000 	ldr	r3, [sp]
30015d48:	e5d32000 	ldrb	r2, [r3]
30015d4c:	e5d31001 	ldrb	r1, [r3, #1]
30015d50:	e1a01401 	lsl	r1, r1, #8
30015d54:	e1812002 	orr	r2, r1, r2
30015d58:	e5d31002 	ldrb	r1, [r3, #2]
30015d5c:	e1a01801 	lsl	r1, r1, #16
30015d60:	e1812002 	orr	r2, r1, r2
30015d64:	e5d33003 	ldrb	r3, [r3, #3]
30015d68:	e1a03c03 	lsl	r3, r3, #24
30015d6c:	e1833002 	orr	r3, r3, r2
30015d70:	ea000000 	b	30015d78 <netif_set_netmask+0x4c>
30015d74:	e3a03000 	mov	r3, #0
30015d78:	e59d2004 	ldr	r2, [sp, #4]
30015d7c:	e5823008 	str	r3, [r2, #8]
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
30015d80:	e28dd008 	add	sp, sp, #8
30015d84:	e12fff1e 	bx	lr

30015d88 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
30015d88:	e24dd008 	sub	sp, sp, #8
30015d8c:	e58d0004 	str	r0, [sp, #4]
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
30015d90:	e59f300c 	ldr	r3, [pc, #12]	; 30015da4 <netif_set_default+0x1c>
30015d94:	e59d2004 	ldr	r2, [sp, #4]
30015d98:	e5832000 	str	r2, [r3]
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
30015d9c:	e28dd008 	add	sp, sp, #8
30015da0:	e12fff1e 	bx	lr
30015da4:	3002b34c 	.word	0x3002b34c

30015da8 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
30015da8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30015dac:	e24dd00c 	sub	sp, sp, #12
30015db0:	e58d0004 	str	r0, [sp, #4]
  if ( !(netif->flags & NETIF_FLAG_UP )) {
30015db4:	e59d3004 	ldr	r3, [sp, #4]
30015db8:	e5d3302a 	ldrb	r3, [r3, #42]	; 0x2a
30015dbc:	e2033001 	and	r3, r3, #1
30015dc0:	e3530000 	cmp	r3, #0
30015dc4:	1a000010 	bne	30015e0c <netif_set_up+0x64>
    netif->flags |= NETIF_FLAG_UP;
30015dc8:	e59d3004 	ldr	r3, [sp, #4]
30015dcc:	e5d3302a 	ldrb	r3, [r3, #42]	; 0x2a
30015dd0:	e3833001 	orr	r3, r3, #1
30015dd4:	e20320ff 	and	r2, r3, #255	; 0xff
30015dd8:	e59d3004 	ldr	r3, [sp, #4]
30015ddc:	e5c3202a 	strb	r2, [r3, #42]	; 0x2a
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
30015de0:	e59d3004 	ldr	r3, [sp, #4]
30015de4:	e5d3302a 	ldrb	r3, [r3, #42]	; 0x2a
30015de8:	e2033020 	and	r3, r3, #32
30015dec:	e3530000 	cmp	r3, #0
30015df0:	0a000005 	beq	30015e0c <netif_set_up+0x64>
      etharp_query(netif, &(netif->ip_addr), NULL);
30015df4:	e59d3004 	ldr	r3, [sp, #4]
30015df8:	e2833004 	add	r3, r3, #4
30015dfc:	e59d0004 	ldr	r0, [sp, #4]
30015e00:	e1a01003 	mov	r1, r3
30015e04:	e3a02000 	mov	r2, #0
30015e08:	eb003367 	bl	30022bac <etharp_query>
    }
#endif /* LWIP_ARP */
    
  }
}
30015e0c:	e28dd00c 	add	sp, sp, #12
30015e10:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30015e14:	e12fff1e 	bx	lr

30015e18 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
30015e18:	e24dd008 	sub	sp, sp, #8
30015e1c:	e58d0004 	str	r0, [sp, #4]
  if ( netif->flags & NETIF_FLAG_UP )
30015e20:	e59d3004 	ldr	r3, [sp, #4]
30015e24:	e5d3302a 	ldrb	r3, [r3, #42]	; 0x2a
30015e28:	e2033001 	and	r3, r3, #1
30015e2c:	e20330ff 	and	r3, r3, #255	; 0xff
30015e30:	e3530000 	cmp	r3, #0
30015e34:	0a000004 	beq	30015e4c <netif_set_down+0x34>
    {
      netif->flags &= ~NETIF_FLAG_UP;
30015e38:	e59d3004 	ldr	r3, [sp, #4]
30015e3c:	e5d3302a 	ldrb	r3, [r3, #42]	; 0x2a
30015e40:	e20330fe 	and	r3, r3, #254	; 0xfe
30015e44:	e59d2004 	ldr	r2, [sp, #4]
30015e48:	e5c2302a 	strb	r3, [r2, #42]	; 0x2a
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
30015e4c:	e28dd008 	add	sp, sp, #8
30015e50:	e12fff1e 	bx	lr

30015e54 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
30015e54:	e24dd008 	sub	sp, sp, #8
30015e58:	e58d0004 	str	r0, [sp, #4]
  return (netif->flags & NETIF_FLAG_UP)?1:0;
30015e5c:	e59d3004 	ldr	r3, [sp, #4]
30015e60:	e5d3302a 	ldrb	r3, [r3, #42]	; 0x2a
30015e64:	e2033001 	and	r3, r3, #1
}
30015e68:	e1a00003 	mov	r0, r3
30015e6c:	e28dd008 	add	sp, sp, #8
30015e70:	e12fff1e 	bx	lr

30015e74 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
30015e74:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30015e78:	e24dd024 	sub	sp, sp, #36	; 0x24
30015e7c:	e1a03002 	mov	r3, r2
30015e80:	e1a02000 	mov	r2, r0
30015e84:	e5cd2007 	strb	r2, [sp, #7]
30015e88:	e1cd10b4 	strh	r1, [sp, #4]
30015e8c:	e5cd3003 	strb	r3, [sp, #3]
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
30015e90:	e3a03000 	mov	r3, #0
30015e94:	e1cd31ba 	strh	r3, [sp, #26]
  switch (layer) {
30015e98:	e5dd3007 	ldrb	r3, [sp, #7]
30015e9c:	e3530003 	cmp	r3, #3
30015ea0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30015ea4:	ea00000d 	b	30015ee0 <pbuf_alloc+0x6c>
30015ea8:	30015eb8 	.word	0x30015eb8
30015eac:	30015ec4 	.word	0x30015ec4
30015eb0:	30015ed0 	.word	0x30015ed0
30015eb4:	30015ee8 	.word	0x30015ee8
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
30015eb8:	e1dd31ba 	ldrh	r3, [sp, #26]
30015ebc:	e2833014 	add	r3, r3, #20
30015ec0:	e1cd31ba 	strh	r3, [sp, #26]
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
30015ec4:	e1dd31ba 	ldrh	r3, [sp, #26]
30015ec8:	e2833014 	add	r3, r3, #20
30015ecc:	e1cd31ba 	strh	r3, [sp, #26]
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
30015ed0:	e1dd31ba 	ldrh	r3, [sp, #26]
30015ed4:	e283300e 	add	r3, r3, #14
30015ed8:	e1cd31ba 	strh	r3, [sp, #26]
    break;
30015edc:	ea000002 	b	30015eec <pbuf_alloc+0x78>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
30015ee0:	e3a03000 	mov	r3, #0
30015ee4:	ea0000ca 	b	30016214 <pbuf_alloc+0x3a0>
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    break;
30015ee8:	e1a00000 	nop			; (mov r0, r0)
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
30015eec:	e5dd3003 	ldrb	r3, [sp, #3]
30015ef0:	e3530003 	cmp	r3, #3
30015ef4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30015ef8:	ea0000bc 	b	300161f0 <pbuf_alloc+0x37c>
30015efc:	300160bc 	.word	0x300160bc
30015f00:	30016188 	.word	0x30016188
30015f04:	30016188 	.word	0x30016188
30015f08:	30015f0c 	.word	0x30015f0c
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
30015f0c:	e3a0000c 	mov	r0, #12
30015f10:	ebfffdb6 	bl	300155f0 <memp_malloc>
30015f14:	e1a03000 	mov	r3, r0
30015f18:	e58d300c 	str	r3, [sp, #12]
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
30015f1c:	e59d300c 	ldr	r3, [sp, #12]
30015f20:	e3530000 	cmp	r3, #0
30015f24:	1a000001 	bne	30015f30 <pbuf_alloc+0xbc>
      return NULL;
30015f28:	e3a03000 	mov	r3, #0
30015f2c:	ea0000b8 	b	30016214 <pbuf_alloc+0x3a0>
    }
    p->type = type;
30015f30:	e59d300c 	ldr	r3, [sp, #12]
30015f34:	e5dd2003 	ldrb	r2, [sp, #3]
30015f38:	e5c3200c 	strb	r2, [r3, #12]
    p->next = NULL;
30015f3c:	e59d300c 	ldr	r3, [sp, #12]
30015f40:	e3a02000 	mov	r2, #0
30015f44:	e5832000 	str	r2, [r3]

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
30015f48:	e1dd31ba 	ldrh	r3, [sp, #26]
30015f4c:	e2832010 	add	r2, r3, #16
30015f50:	e59d300c 	ldr	r3, [sp, #12]
30015f54:	e0823003 	add	r3, r2, r3
30015f58:	e2833003 	add	r3, r3, #3
30015f5c:	e3c33003 	bic	r3, r3, #3
30015f60:	e1a02003 	mov	r2, r3
30015f64:	e59d300c 	ldr	r3, [sp, #12]
30015f68:	e5832004 	str	r2, [r3, #4]
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
30015f6c:	e59d300c 	ldr	r3, [sp, #12]
30015f70:	e1dd20b4 	ldrh	r2, [sp, #4]
30015f74:	e1c320b8 	strh	r2, [r3, #8]
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
30015f78:	e1dd31ba 	ldrh	r3, [sp, #26]
30015f7c:	e2833003 	add	r3, r3, #3
30015f80:	e3c33003 	bic	r3, r3, #3
30015f84:	e26320b8 	rsb	r2, r3, #184	; 0xb8
30015f88:	e1dd30b4 	ldrh	r3, [sp, #4]
30015f8c:	e1520003 	cmp	r2, r3
30015f90:	b1a03002 	movlt	r3, r2
30015f94:	a1a03003 	movge	r3, r3
30015f98:	e1a03803 	lsl	r3, r3, #16
30015f9c:	e1a02823 	lsr	r2, r3, #16
30015fa0:	e59d300c 	ldr	r3, [sp, #12]
30015fa4:	e1c320ba 	strh	r2, [r3, #10]
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
30015fa8:	e59d300c 	ldr	r3, [sp, #12]
30015fac:	e3a02001 	mov	r2, #1
30015fb0:	e1c320be 	strh	r2, [r3, #14]

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
30015fb4:	e59d300c 	ldr	r3, [sp, #12]
30015fb8:	e58d3014 	str	r3, [sp, #20]
    /* remaining length to be allocated */
    rem_len = length - p->len;
30015fbc:	e1dd20b4 	ldrh	r2, [sp, #4]
30015fc0:	e59d300c 	ldr	r3, [sp, #12]
30015fc4:	e1d330ba 	ldrh	r3, [r3, #10]
30015fc8:	e0633002 	rsb	r3, r3, r2
30015fcc:	e58d301c 	str	r3, [sp, #28]
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
30015fd0:	ea000035 	b	300160ac <pbuf_alloc+0x238>
      q = memp_malloc(MEMP_PBUF_POOL);
30015fd4:	e3a0000c 	mov	r0, #12
30015fd8:	ebfffd84 	bl	300155f0 <memp_malloc>
30015fdc:	e1a03000 	mov	r3, r0
30015fe0:	e58d3010 	str	r3, [sp, #16]
      if (q == NULL) {
30015fe4:	e59d3010 	ldr	r3, [sp, #16]
30015fe8:	e3530000 	cmp	r3, #0
30015fec:	1a000003 	bne	30016000 <pbuf_alloc+0x18c>
        /* free chain so far allocated */
        pbuf_free(p);
30015ff0:	e59d000c 	ldr	r0, [sp, #12]
30015ff4:	eb00014d 	bl	30016530 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
30015ff8:	e3a03000 	mov	r3, #0
30015ffc:	ea000084 	b	30016214 <pbuf_alloc+0x3a0>
      }
      q->type = type;
30016000:	e59d3010 	ldr	r3, [sp, #16]
30016004:	e5dd2003 	ldrb	r2, [sp, #3]
30016008:	e5c3200c 	strb	r2, [r3, #12]
      q->flags = 0;
3001600c:	e59d3010 	ldr	r3, [sp, #16]
30016010:	e3a02000 	mov	r2, #0
30016014:	e5c3200d 	strb	r2, [r3, #13]
      q->next = NULL;
30016018:	e59d3010 	ldr	r3, [sp, #16]
3001601c:	e3a02000 	mov	r2, #0
30016020:	e5832000 	str	r2, [r3]
      /* make previous pbuf point to this pbuf */
      r->next = q;
30016024:	e59d3014 	ldr	r3, [sp, #20]
30016028:	e59d2010 	ldr	r2, [sp, #16]
3001602c:	e5832000 	str	r2, [r3]
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
30016030:	e59d301c 	ldr	r3, [sp, #28]
30016034:	e1a03803 	lsl	r3, r3, #16
30016038:	e1a02823 	lsr	r2, r3, #16
3001603c:	e59d3010 	ldr	r3, [sp, #16]
30016040:	e1c320b8 	strh	r2, [r3, #8]
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
30016044:	e59d301c 	ldr	r3, [sp, #28]
30016048:	e1a03803 	lsl	r3, r3, #16
3001604c:	e1a03823 	lsr	r3, r3, #16
30016050:	e35300b7 	cmp	r3, #183	; 0xb7
30016054:	8a000003 	bhi	30016068 <pbuf_alloc+0x1f4>
30016058:	e59d301c 	ldr	r3, [sp, #28]
3001605c:	e1a03803 	lsl	r3, r3, #16
30016060:	e1a03823 	lsr	r3, r3, #16
30016064:	ea000000 	b	3001606c <pbuf_alloc+0x1f8>
30016068:	e3a030b8 	mov	r3, #184	; 0xb8
3001606c:	e59d2010 	ldr	r2, [sp, #16]
30016070:	e1c230ba 	strh	r3, [r2, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
30016074:	e59d3010 	ldr	r3, [sp, #16]
30016078:	e2832010 	add	r2, r3, #16
3001607c:	e59d3010 	ldr	r3, [sp, #16]
30016080:	e5832004 	str	r2, [r3, #4]
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
30016084:	e59d3010 	ldr	r3, [sp, #16]
30016088:	e3a02001 	mov	r2, #1
3001608c:	e1c320be 	strh	r2, [r3, #14]
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
30016090:	e59d3010 	ldr	r3, [sp, #16]
30016094:	e1d330ba 	ldrh	r3, [r3, #10]
30016098:	e59d201c 	ldr	r2, [sp, #28]
3001609c:	e0633002 	rsb	r3, r3, r2
300160a0:	e58d301c 	str	r3, [sp, #28]
      /* remember this pbuf for linkage in next iteration */
      r = q;
300160a4:	e59d3010 	ldr	r3, [sp, #16]
300160a8:	e58d3014 	str	r3, [sp, #20]
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
300160ac:	e59d301c 	ldr	r3, [sp, #28]
300160b0:	e3530000 	cmp	r3, #0
300160b4:	caffffc6 	bgt	30015fd4 <pbuf_alloc+0x160>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
300160b8:	ea00004e 	b	300161f8 <pbuf_alloc+0x384>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
300160bc:	e1dd31ba 	ldrh	r3, [sp, #26]
300160c0:	e2833013 	add	r3, r3, #19
300160c4:	e1a03803 	lsl	r3, r3, #16
300160c8:	e1a03823 	lsr	r3, r3, #16
300160cc:	e1a02003 	mov	r2, r3
300160d0:	e3c23003 	bic	r3, r2, #3
300160d4:	e1a03803 	lsl	r3, r3, #16
300160d8:	e1a03823 	lsr	r3, r3, #16
300160dc:	e1a02003 	mov	r2, r3
300160e0:	e1dd30b4 	ldrh	r3, [sp, #4]
300160e4:	e2833003 	add	r3, r3, #3
300160e8:	e1a03803 	lsl	r3, r3, #16
300160ec:	e1a03823 	lsr	r3, r3, #16
300160f0:	e3c33003 	bic	r3, r3, #3
300160f4:	e1a03803 	lsl	r3, r3, #16
300160f8:	e1a03823 	lsr	r3, r3, #16
300160fc:	e0823003 	add	r3, r2, r3
30016100:	e1a03803 	lsl	r3, r3, #16
30016104:	e1a03823 	lsr	r3, r3, #16
30016108:	e1a00003 	mov	r0, r3
3001610c:	eb002c6c 	bl	300212c4 <mem_malloc>
30016110:	e1a03000 	mov	r3, r0
30016114:	e58d300c 	str	r3, [sp, #12]
    if (p == NULL) {
30016118:	e59d300c 	ldr	r3, [sp, #12]
3001611c:	e3530000 	cmp	r3, #0
30016120:	1a000001 	bne	3001612c <pbuf_alloc+0x2b8>
      return NULL;
30016124:	e3a03000 	mov	r3, #0
30016128:	ea000039 	b	30016214 <pbuf_alloc+0x3a0>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
3001612c:	e1dd31ba 	ldrh	r3, [sp, #26]
30016130:	e2832010 	add	r2, r3, #16
30016134:	e59d300c 	ldr	r3, [sp, #12]
30016138:	e0823003 	add	r3, r2, r3
3001613c:	e2833003 	add	r3, r3, #3
30016140:	e3c33003 	bic	r3, r3, #3
30016144:	e1a02003 	mov	r2, r3
30016148:	e59d300c 	ldr	r3, [sp, #12]
3001614c:	e5832004 	str	r2, [r3, #4]
    p->len = p->tot_len = length;
30016150:	e59d300c 	ldr	r3, [sp, #12]
30016154:	e1dd20b4 	ldrh	r2, [sp, #4]
30016158:	e1c320b8 	strh	r2, [r3, #8]
3001615c:	e59d300c 	ldr	r3, [sp, #12]
30016160:	e1d320b8 	ldrh	r2, [r3, #8]
30016164:	e59d300c 	ldr	r3, [sp, #12]
30016168:	e1c320ba 	strh	r2, [r3, #10]
    p->next = NULL;
3001616c:	e59d300c 	ldr	r3, [sp, #12]
30016170:	e3a02000 	mov	r2, #0
30016174:	e5832000 	str	r2, [r3]
    p->type = type;
30016178:	e59d300c 	ldr	r3, [sp, #12]
3001617c:	e5dd2003 	ldrb	r2, [sp, #3]
30016180:	e5c3200c 	strb	r2, [r3, #12]

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
30016184:	ea00001b 	b	300161f8 <pbuf_alloc+0x384>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
30016188:	e3a0000b 	mov	r0, #11
3001618c:	ebfffd17 	bl	300155f0 <memp_malloc>
30016190:	e1a03000 	mov	r3, r0
30016194:	e58d300c 	str	r3, [sp, #12]
    if (p == NULL) {
30016198:	e59d300c 	ldr	r3, [sp, #12]
3001619c:	e3530000 	cmp	r3, #0
300161a0:	1a000001 	bne	300161ac <pbuf_alloc+0x338>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
300161a4:	e3a03000 	mov	r3, #0
300161a8:	ea000019 	b	30016214 <pbuf_alloc+0x3a0>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
300161ac:	e59d300c 	ldr	r3, [sp, #12]
300161b0:	e3a02000 	mov	r2, #0
300161b4:	e5832004 	str	r2, [r3, #4]
    p->len = p->tot_len = length;
300161b8:	e59d300c 	ldr	r3, [sp, #12]
300161bc:	e1dd20b4 	ldrh	r2, [sp, #4]
300161c0:	e1c320b8 	strh	r2, [r3, #8]
300161c4:	e59d300c 	ldr	r3, [sp, #12]
300161c8:	e1d320b8 	ldrh	r2, [r3, #8]
300161cc:	e59d300c 	ldr	r3, [sp, #12]
300161d0:	e1c320ba 	strh	r2, [r3, #10]
    p->next = NULL;
300161d4:	e59d300c 	ldr	r3, [sp, #12]
300161d8:	e3a02000 	mov	r2, #0
300161dc:	e5832000 	str	r2, [r3]
    p->type = type;
300161e0:	e59d300c 	ldr	r3, [sp, #12]
300161e4:	e5dd2003 	ldrb	r2, [sp, #3]
300161e8:	e5c3200c 	strb	r2, [r3, #12]
    break;
300161ec:	ea000001 	b	300161f8 <pbuf_alloc+0x384>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
300161f0:	e3a03000 	mov	r3, #0
300161f4:	ea000006 	b	30016214 <pbuf_alloc+0x3a0>
  }
  /* set reference count */
  p->ref = 1;
300161f8:	e59d300c 	ldr	r3, [sp, #12]
300161fc:	e3a02001 	mov	r2, #1
30016200:	e1c320be 	strh	r2, [r3, #14]
  /* set flags */
  p->flags = 0;
30016204:	e59d300c 	ldr	r3, [sp, #12]
30016208:	e3a02000 	mov	r2, #0
3001620c:	e5c3200d 	strb	r2, [r3, #13]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
30016210:	e59d300c 	ldr	r3, [sp, #12]
}
30016214:	e1a00003 	mov	r0, r3
30016218:	e28dd024 	add	sp, sp, #36	; 0x24
3001621c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016220:	e12fff1e 	bx	lr

30016224 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
30016224:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30016228:	e24dd01c 	sub	sp, sp, #28
3001622c:	e58d0004 	str	r0, [sp, #4]
30016230:	e1a03001 	mov	r3, r1
30016234:	e1cd30b2 	strh	r3, [sp, #2]
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
30016238:	e59d3004 	ldr	r3, [sp, #4]
3001623c:	e1d330b8 	ldrh	r3, [r3, #8]
30016240:	e1dd20b2 	ldrh	r2, [sp, #2]
30016244:	e1520003 	cmp	r2, r3
30016248:	2a00004f 	bcs	3001638c <pbuf_realloc+0x168>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
3001624c:	e1dd20b2 	ldrh	r2, [sp, #2]
30016250:	e59d3004 	ldr	r3, [sp, #4]
30016254:	e1d330b8 	ldrh	r3, [r3, #8]
30016258:	e0633002 	rsb	r3, r3, r2
3001625c:	e58d3014 	str	r3, [sp, #20]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
30016260:	e1dd30b2 	ldrh	r3, [sp, #2]
30016264:	e1cd31b2 	strh	r3, [sp, #18]
  q = p;
30016268:	e59d3004 	ldr	r3, [sp, #4]
3001626c:	e58d300c 	str	r3, [sp, #12]
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
30016270:	ea000011 	b	300162bc <pbuf_realloc+0x98>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
30016274:	e59d300c 	ldr	r3, [sp, #12]
30016278:	e1d330ba 	ldrh	r3, [r3, #10]
3001627c:	e1dd21b2 	ldrh	r2, [sp, #18]
30016280:	e0633002 	rsb	r3, r3, r2
30016284:	e1cd31b2 	strh	r3, [sp, #18]
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    q->tot_len += (u16_t)grow;
30016288:	e59d300c 	ldr	r3, [sp, #12]
3001628c:	e1d320b8 	ldrh	r2, [r3, #8]
30016290:	e59d3014 	ldr	r3, [sp, #20]
30016294:	e1a03803 	lsl	r3, r3, #16
30016298:	e1a03823 	lsr	r3, r3, #16
3001629c:	e0823003 	add	r3, r2, r3
300162a0:	e1a03803 	lsl	r3, r3, #16
300162a4:	e1a02823 	lsr	r2, r3, #16
300162a8:	e59d300c 	ldr	r3, [sp, #12]
300162ac:	e1c320b8 	strh	r2, [r3, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
300162b0:	e59d300c 	ldr	r3, [sp, #12]
300162b4:	e5933000 	ldr	r3, [r3]
300162b8:	e58d300c 	str	r3, [sp, #12]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
300162bc:	e59d300c 	ldr	r3, [sp, #12]
300162c0:	e1d330ba 	ldrh	r3, [r3, #10]
300162c4:	e1dd21b2 	ldrh	r2, [sp, #18]
300162c8:	e1520003 	cmp	r2, r3
300162cc:	8affffe8 	bhi	30016274 <pbuf_realloc+0x50>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
300162d0:	e59d300c 	ldr	r3, [sp, #12]
300162d4:	e5d3300c 	ldrb	r3, [r3, #12]
300162d8:	e3530000 	cmp	r3, #0
300162dc:	1a000017 	bne	30016340 <pbuf_realloc+0x11c>
300162e0:	e59d300c 	ldr	r3, [sp, #12]
300162e4:	e1d330ba 	ldrh	r3, [r3, #10]
300162e8:	e1dd21b2 	ldrh	r2, [sp, #18]
300162ec:	e1520003 	cmp	r2, r3
300162f0:	0a000012 	beq	30016340 <pbuf_realloc+0x11c>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
300162f4:	e59d300c 	ldr	r3, [sp, #12]
300162f8:	e5933004 	ldr	r3, [r3, #4]
300162fc:	e1a03803 	lsl	r3, r3, #16
30016300:	e1a02823 	lsr	r2, r3, #16
30016304:	e59d300c 	ldr	r3, [sp, #12]
30016308:	e1a03803 	lsl	r3, r3, #16
3001630c:	e1a03823 	lsr	r3, r3, #16
30016310:	e0633002 	rsb	r3, r3, r2
30016314:	e1a03803 	lsl	r3, r3, #16
30016318:	e1a02823 	lsr	r2, r3, #16
3001631c:	e1dd31b2 	ldrh	r3, [sp, #18]
30016320:	e0823003 	add	r3, r2, r3
30016324:	e1a03803 	lsl	r3, r3, #16
30016328:	e1a03823 	lsr	r3, r3, #16
3001632c:	e59d000c 	ldr	r0, [sp, #12]
30016330:	e1a01003 	mov	r1, r3
30016334:	eb002b0d 	bl	30020f70 <mem_realloc>
30016338:	e1a03000 	mov	r3, r0
3001633c:	e58d300c 	str	r3, [sp, #12]
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
30016340:	e59d300c 	ldr	r3, [sp, #12]
30016344:	e1dd21b2 	ldrh	r2, [sp, #18]
30016348:	e1c320ba 	strh	r2, [r3, #10]
  q->tot_len = q->len;
3001634c:	e59d300c 	ldr	r3, [sp, #12]
30016350:	e1d320ba 	ldrh	r2, [r3, #10]
30016354:	e59d300c 	ldr	r3, [sp, #12]
30016358:	e1c320b8 	strh	r2, [r3, #8]

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
3001635c:	e59d300c 	ldr	r3, [sp, #12]
30016360:	e5933000 	ldr	r3, [r3]
30016364:	e3530000 	cmp	r3, #0
30016368:	0a000003 	beq	3001637c <pbuf_realloc+0x158>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
3001636c:	e59d300c 	ldr	r3, [sp, #12]
30016370:	e5933000 	ldr	r3, [r3]
30016374:	e1a00003 	mov	r0, r3
30016378:	eb00006c 	bl	30016530 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
3001637c:	e59d300c 	ldr	r3, [sp, #12]
30016380:	e3a02000 	mov	r2, #0
30016384:	e5832000 	str	r2, [r3]
30016388:	ea000000 	b	30016390 <pbuf_realloc+0x16c>
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
3001638c:	e1a00000 	nop			; (mov r0, r0)
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
30016390:	e28dd01c 	add	sp, sp, #28
30016394:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016398:	e12fff1e 	bx	lr

3001639c <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
3001639c:	e24dd018 	sub	sp, sp, #24
300163a0:	e58d0004 	str	r0, [sp, #4]
300163a4:	e1a03001 	mov	r3, r1
300163a8:	e1cd30b2 	strh	r3, [sp, #2]
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
300163ac:	e1dd30f2 	ldrsh	r3, [sp, #2]
300163b0:	e3530000 	cmp	r3, #0
300163b4:	0a000002 	beq	300163c4 <pbuf_header+0x28>
300163b8:	e59d3004 	ldr	r3, [sp, #4]
300163bc:	e3530000 	cmp	r3, #0
300163c0:	1a000001 	bne	300163cc <pbuf_header+0x30>
    return 0;
300163c4:	e3a03000 	mov	r3, #0
300163c8:	ea000055 	b	30016524 <pbuf_header+0x188>
 
  if (header_size_increment < 0){
300163cc:	e1dd30f2 	ldrsh	r3, [sp, #2]
300163d0:	e3530000 	cmp	r3, #0
300163d4:	aa000005 	bge	300163f0 <pbuf_header+0x54>
    increment_magnitude = -header_size_increment;
300163d8:	e1dd30b2 	ldrh	r3, [sp, #2]
300163dc:	e2633000 	rsb	r3, r3, #0
300163e0:	e1a03803 	lsl	r3, r3, #16
300163e4:	e1a03823 	lsr	r3, r3, #16
300163e8:	e1cd31b6 	strh	r3, [sp, #22]
300163ec:	ea000001 	b	300163f8 <pbuf_header+0x5c>
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
300163f0:	e1dd30b2 	ldrh	r3, [sp, #2]
300163f4:	e1cd31b6 	strh	r3, [sp, #22]
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
300163f8:	e59d3004 	ldr	r3, [sp, #4]
300163fc:	e5d3300c 	ldrb	r3, [r3, #12]
30016400:	e1cd30be 	strh	r3, [sp, #14]
  /* remember current payload pointer */
  payload = p->payload;
30016404:	e59d3004 	ldr	r3, [sp, #4]
30016408:	e5933004 	ldr	r3, [r3, #4]
3001640c:	e58d3010 	str	r3, [sp, #16]

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
30016410:	e1dd30be 	ldrh	r3, [sp, #14]
30016414:	e3530000 	cmp	r3, #0
30016418:	0a000002 	beq	30016428 <pbuf_header+0x8c>
3001641c:	e1dd30be 	ldrh	r3, [sp, #14]
30016420:	e3530003 	cmp	r3, #3
30016424:	1a000012 	bne	30016474 <pbuf_header+0xd8>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
30016428:	e59d3004 	ldr	r3, [sp, #4]
3001642c:	e5932004 	ldr	r2, [r3, #4]
30016430:	e1dd30f2 	ldrsh	r3, [sp, #2]
30016434:	e2633000 	rsb	r3, r3, #0
30016438:	e0822003 	add	r2, r2, r3
3001643c:	e59d3004 	ldr	r3, [sp, #4]
30016440:	e5832004 	str	r2, [r3, #4]
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
30016444:	e59d3004 	ldr	r3, [sp, #4]
30016448:	e5933004 	ldr	r3, [r3, #4]
3001644c:	e1a02003 	mov	r2, r3
30016450:	e59d3004 	ldr	r3, [sp, #4]
30016454:	e2833010 	add	r3, r3, #16
30016458:	e1520003 	cmp	r2, r3
3001645c:	2a00001e 	bcs	300164dc <pbuf_header+0x140>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
30016460:	e59d3004 	ldr	r3, [sp, #4]
30016464:	e59d2010 	ldr	r2, [sp, #16]
30016468:	e5832004 	str	r2, [r3, #4]
      /* bail out unsuccesfully */
      return 1;
3001646c:	e3a03001 	mov	r3, #1
30016470:	ea00002b 	b	30016524 <pbuf_header+0x188>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
30016474:	e1dd30be 	ldrh	r3, [sp, #14]
30016478:	e3530002 	cmp	r3, #2
3001647c:	0a000002 	beq	3001648c <pbuf_header+0xf0>
30016480:	e1dd30be 	ldrh	r3, [sp, #14]
30016484:	e3530001 	cmp	r3, #1
30016488:	1a000011 	bne	300164d4 <pbuf_header+0x138>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
3001648c:	e1dd30f2 	ldrsh	r3, [sp, #2]
30016490:	e3530000 	cmp	r3, #0
30016494:	aa00000c 	bge	300164cc <pbuf_header+0x130>
30016498:	e59d3004 	ldr	r3, [sp, #4]
3001649c:	e1d330ba 	ldrh	r3, [r3, #10]
300164a0:	e1dd21b6 	ldrh	r2, [sp, #22]
300164a4:	e1520003 	cmp	r2, r3
300164a8:	8a000007 	bhi	300164cc <pbuf_header+0x130>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
300164ac:	e59d3004 	ldr	r3, [sp, #4]
300164b0:	e5932004 	ldr	r2, [r3, #4]
300164b4:	e1dd30f2 	ldrsh	r3, [sp, #2]
300164b8:	e2633000 	rsb	r3, r3, #0
300164bc:	e0822003 	add	r2, r2, r3
300164c0:	e59d3004 	ldr	r3, [sp, #4]
300164c4:	e5832004 	str	r2, [r3, #4]
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
300164c8:	ea000004 	b	300164e0 <pbuf_header+0x144>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
300164cc:	e3a03001 	mov	r3, #1
300164d0:	ea000013 	b	30016524 <pbuf_header+0x188>
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
300164d4:	e3a03001 	mov	r3, #1
300164d8:	ea000011 	b	30016524 <pbuf_header+0x188>
  type = p->type;
  /* remember current payload pointer */
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
300164dc:	e1a00000 	nop			; (mov r0, r0)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
300164e0:	e59d3004 	ldr	r3, [sp, #4]
300164e4:	e1d320ba 	ldrh	r2, [r3, #10]
300164e8:	e1dd30b2 	ldrh	r3, [sp, #2]
300164ec:	e0823003 	add	r3, r2, r3
300164f0:	e1a03803 	lsl	r3, r3, #16
300164f4:	e1a02823 	lsr	r2, r3, #16
300164f8:	e59d3004 	ldr	r3, [sp, #4]
300164fc:	e1c320ba 	strh	r2, [r3, #10]
  p->tot_len += header_size_increment;
30016500:	e59d3004 	ldr	r3, [sp, #4]
30016504:	e1d320b8 	ldrh	r2, [r3, #8]
30016508:	e1dd30b2 	ldrh	r3, [sp, #2]
3001650c:	e0823003 	add	r3, r2, r3
30016510:	e1a03803 	lsl	r3, r3, #16
30016514:	e1a02823 	lsr	r2, r3, #16
30016518:	e59d3004 	ldr	r3, [sp, #4]
3001651c:	e1c320b8 	strh	r2, [r3, #8]

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
30016520:	e3a03000 	mov	r3, #0
}
30016524:	e1a00003 	mov	r0, r3
30016528:	e28dd018 	add	sp, sp, #24
3001652c:	e12fff1e 	bx	lr

30016530 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
30016530:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30016534:	e24dd01c 	sub	sp, sp, #28
30016538:	e58d0004 	str	r0, [sp, #4]
  struct pbuf *q;
  u8_t count;
  //static int num_pbuf_realse = 0;  // test for mem release. by pegasus
  

  if (p == NULL) {
3001653c:	e59d3004 	ldr	r3, [sp, #4]
30016540:	e3530000 	cmp	r3, #0
30016544:	1a000001 	bne	30016550 <pbuf_free+0x20>
    LWIP_ASSERT("p != NULL", p != NULL);
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_free(p == NULL) was called.\n"));
    return 0;
30016548:	e3a03000 	mov	r3, #0
3001654c:	ea000039 	b	30016638 <pbuf_free+0x108>

  LWIP_ASSERT("pbuf_free: sane type",
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
30016550:	e3a03000 	mov	r3, #0
30016554:	e5cd3011 	strb	r3, [sp, #17]
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
30016558:	ea000032 	b	30016628 <pbuf_free+0xf8>
    u16_t ref;
    SYS_ARCH_DECL_PROTECT(old_level);
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
3001655c:	ebffac64 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30016560:	e1a03000 	mov	r3, r0
30016564:	e58d3014 	str	r3, [sp, #20]
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
30016568:	e59d3004 	ldr	r3, [sp, #4]
3001656c:	e1d330be 	ldrh	r3, [r3, #14]
30016570:	e2433001 	sub	r3, r3, #1
30016574:	e1a03803 	lsl	r3, r3, #16
30016578:	e1a02823 	lsr	r2, r3, #16
3001657c:	e59d3004 	ldr	r3, [sp, #4]
30016580:	e1c320be 	strh	r2, [r3, #14]
30016584:	e59d3004 	ldr	r3, [sp, #4]
30016588:	e1d330be 	ldrh	r3, [r3, #14]
3001658c:	e1cd31b2 	strh	r3, [sp, #18]
    SYS_ARCH_UNPROTECT(old_level);
30016590:	e59d0014 	ldr	r0, [sp, #20]
30016594:	ebffac54 	bl	300016ec <HAL_INTR_RESTORE>
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
30016598:	e1dd31b2 	ldrh	r3, [sp, #18]
3001659c:	e3530000 	cmp	r3, #0
300165a0:	1a00001e 	bne	30016620 <pbuf_free+0xf0>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
300165a4:	e59d3004 	ldr	r3, [sp, #4]
300165a8:	e5933000 	ldr	r3, [r3]
300165ac:	e58d300c 	str	r3, [sp, #12]
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
300165b0:	e59d3004 	ldr	r3, [sp, #4]
300165b4:	e5d3300c 	ldrb	r3, [r3, #12]
300165b8:	e1cd30ba 	strh	r3, [sp, #10]
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
300165bc:	e1dd30ba 	ldrh	r3, [sp, #10]
300165c0:	e3530003 	cmp	r3, #3
300165c4:	1a000003 	bne	300165d8 <pbuf_free+0xa8>
        memp_free(MEMP_PBUF_POOL, p);
300165c8:	e3a0000c 	mov	r0, #12
300165cc:	e59d1004 	ldr	r1, [sp, #4]
300165d0:	ebfffc6b 	bl	30015784 <memp_free>
300165d4:	ea00000b 	b	30016608 <pbuf_free+0xd8>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
300165d8:	e1dd30ba 	ldrh	r3, [sp, #10]
300165dc:	e3530001 	cmp	r3, #1
300165e0:	0a000002 	beq	300165f0 <pbuf_free+0xc0>
300165e4:	e1dd30ba 	ldrh	r3, [sp, #10]
300165e8:	e3530002 	cmp	r3, #2
300165ec:	1a000003 	bne	30016600 <pbuf_free+0xd0>
        memp_free(MEMP_PBUF, p);
300165f0:	e3a0000b 	mov	r0, #11
300165f4:	e59d1004 	ldr	r1, [sp, #4]
300165f8:	ebfffc61 	bl	30015784 <memp_free>
      type = p->type;
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
        memp_free(MEMP_PBUF_POOL, p);
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
300165fc:	ea000001 	b	30016608 <pbuf_free+0xd8>
        memp_free(MEMP_PBUF, p);
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
30016600:	e59d0004 	ldr	r0, [sp, #4]
30016604:	eb002a04 	bl	30020e1c <mem_free>
      }
      count++;
30016608:	e5dd3011 	ldrb	r3, [sp, #17]
3001660c:	e2833001 	add	r3, r3, #1
30016610:	e5cd3011 	strb	r3, [sp, #17]
      /* proceed to next pbuf */
      p = q;
30016614:	e59d300c 	ldr	r3, [sp, #12]
30016618:	e58d3004 	str	r3, [sp, #4]
3001661c:	ea000001 	b	30016628 <pbuf_free+0xf8>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
30016620:	e3a03000 	mov	r3, #0
30016624:	e58d3004 	str	r3, [sp, #4]
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
30016628:	e59d3004 	ldr	r3, [sp, #4]
3001662c:	e3530000 	cmp	r3, #0
30016630:	1affffc9 	bne	3001655c <pbuf_free+0x2c>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
30016634:	e5dd3011 	ldrb	r3, [sp, #17]
}
30016638:	e1a00003 	mov	r0, r3
3001663c:	e28dd01c 	add	sp, sp, #28
30016640:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016644:	e12fff1e 	bx	lr

30016648 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
30016648:	e24dd010 	sub	sp, sp, #16
3001664c:	e58d0004 	str	r0, [sp, #4]
  u8_t len;

  len = 0;
30016650:	e3a03000 	mov	r3, #0
30016654:	e5cd300f 	strb	r3, [sp, #15]
  while (p != NULL) {
30016658:	ea000005 	b	30016674 <pbuf_clen+0x2c>
    ++len;
3001665c:	e5dd300f 	ldrb	r3, [sp, #15]
30016660:	e2833001 	add	r3, r3, #1
30016664:	e5cd300f 	strb	r3, [sp, #15]
    p = p->next;
30016668:	e59d3004 	ldr	r3, [sp, #4]
3001666c:	e5933000 	ldr	r3, [r3]
30016670:	e58d3004 	str	r3, [sp, #4]
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
30016674:	e59d3004 	ldr	r3, [sp, #4]
30016678:	e3530000 	cmp	r3, #0
3001667c:	1afffff6 	bne	3001665c <pbuf_clen+0x14>
    ++len;
    p = p->next;
  }
  return len;
30016680:	e5dd300f 	ldrb	r3, [sp, #15]
}
30016684:	e1a00003 	mov	r0, r3
30016688:	e28dd010 	add	sp, sp, #16
3001668c:	e12fff1e 	bx	lr

30016690 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
30016690:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30016694:	e24dd014 	sub	sp, sp, #20
30016698:	e58d0004 	str	r0, [sp, #4]
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
3001669c:	e59d3004 	ldr	r3, [sp, #4]
300166a0:	e3530000 	cmp	r3, #0
300166a4:	0a00000b 	beq	300166d8 <pbuf_ref+0x48>
    SYS_ARCH_PROTECT(old_level);
300166a8:	ebffac11 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300166ac:	e1a03000 	mov	r3, r0
300166b0:	e58d300c 	str	r3, [sp, #12]
    ++(p->ref);
300166b4:	e59d3004 	ldr	r3, [sp, #4]
300166b8:	e1d330be 	ldrh	r3, [r3, #14]
300166bc:	e2833001 	add	r3, r3, #1
300166c0:	e1a03803 	lsl	r3, r3, #16
300166c4:	e1a02823 	lsr	r2, r3, #16
300166c8:	e59d3004 	ldr	r3, [sp, #4]
300166cc:	e1c320be 	strh	r2, [r3, #14]
    SYS_ARCH_UNPROTECT(old_level);
300166d0:	e59d000c 	ldr	r0, [sp, #12]
300166d4:	ebffac04 	bl	300016ec <HAL_INTR_RESTORE>
  }
}
300166d8:	e28dd014 	add	sp, sp, #20
300166dc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300166e0:	e12fff1e 	bx	lr

300166e4 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
300166e4:	e24dd010 	sub	sp, sp, #16
300166e8:	e58d0004 	str	r0, [sp, #4]
300166ec:	e58d1000 	str	r1, [sp]

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
300166f0:	e59d3004 	ldr	r3, [sp, #4]
300166f4:	e58d300c 	str	r3, [sp, #12]
300166f8:	ea00000b 	b	3001672c <pbuf_cat+0x48>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
300166fc:	e59d300c 	ldr	r3, [sp, #12]
30016700:	e1d320b8 	ldrh	r2, [r3, #8]
30016704:	e59d3000 	ldr	r3, [sp]
30016708:	e1d330b8 	ldrh	r3, [r3, #8]
3001670c:	e0823003 	add	r3, r2, r3
30016710:	e1a03803 	lsl	r3, r3, #16
30016714:	e1a02823 	lsr	r2, r3, #16
30016718:	e59d300c 	ldr	r3, [sp, #12]
3001671c:	e1c320b8 	strh	r2, [r3, #8]

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
30016720:	e59d300c 	ldr	r3, [sp, #12]
30016724:	e5933000 	ldr	r3, [r3]
30016728:	e58d300c 	str	r3, [sp, #12]
3001672c:	e59d300c 	ldr	r3, [sp, #12]
30016730:	e5933000 	ldr	r3, [r3]
30016734:	e3530000 	cmp	r3, #0
30016738:	1affffef 	bne	300166fc <pbuf_cat+0x18>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
3001673c:	e59d300c 	ldr	r3, [sp, #12]
30016740:	e1d320b8 	ldrh	r2, [r3, #8]
30016744:	e59d3000 	ldr	r3, [sp]
30016748:	e1d330b8 	ldrh	r3, [r3, #8]
3001674c:	e0823003 	add	r3, r2, r3
30016750:	e1a03803 	lsl	r3, r3, #16
30016754:	e1a02823 	lsr	r2, r3, #16
30016758:	e59d300c 	ldr	r3, [sp, #12]
3001675c:	e1c320b8 	strh	r2, [r3, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
30016760:	e59d300c 	ldr	r3, [sp, #12]
30016764:	e59d2000 	ldr	r2, [sp]
30016768:	e5832000 	str	r2, [r3]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
3001676c:	e28dd010 	add	sp, sp, #16
30016770:	e12fff1e 	bx	lr

30016774 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
30016774:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30016778:	e24dd00c 	sub	sp, sp, #12
3001677c:	e58d0004 	str	r0, [sp, #4]
30016780:	e58d1000 	str	r1, [sp]
  pbuf_cat(h, t);
30016784:	e59d0004 	ldr	r0, [sp, #4]
30016788:	e59d1000 	ldr	r1, [sp]
3001678c:	ebffffd4 	bl	300166e4 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
30016790:	e59d0000 	ldr	r0, [sp]
30016794:	ebffffbd 	bl	30016690 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
30016798:	e28dd00c 	add	sp, sp, #12
3001679c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300167a0:	e12fff1e 	bx	lr

300167a4 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
300167a4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300167a8:	e24dd014 	sub	sp, sp, #20
300167ac:	e58d0004 	str	r0, [sp, #4]
  struct pbuf *q;
  u8_t tail_gone = 1;
300167b0:	e3a03001 	mov	r3, #1
300167b4:	e5cd300f 	strb	r3, [sp, #15]
  /* tail */
  q = p->next;
300167b8:	e59d3004 	ldr	r3, [sp, #4]
300167bc:	e5933000 	ldr	r3, [r3]
300167c0:	e58d3008 	str	r3, [sp, #8]
  /* pbuf has successor in chain? */
  if (q != NULL) {
300167c4:	e59d3008 	ldr	r3, [sp, #8]
300167c8:	e3530000 	cmp	r3, #0
300167cc:	0a000013 	beq	30016820 <pbuf_dechain+0x7c>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
300167d0:	e59d3004 	ldr	r3, [sp, #4]
300167d4:	e1d320b8 	ldrh	r2, [r3, #8]
300167d8:	e59d3004 	ldr	r3, [sp, #4]
300167dc:	e1d330ba 	ldrh	r3, [r3, #10]
300167e0:	e0633002 	rsb	r3, r3, r2
300167e4:	e1a03803 	lsl	r3, r3, #16
300167e8:	e1a02823 	lsr	r2, r3, #16
300167ec:	e59d3008 	ldr	r3, [sp, #8]
300167f0:	e1c320b8 	strh	r2, [r3, #8]
    /* decouple pbuf from remainder */
    p->next = NULL;
300167f4:	e59d3004 	ldr	r3, [sp, #4]
300167f8:	e3a02000 	mov	r2, #0
300167fc:	e5832000 	str	r2, [r3]
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
30016800:	e59d3004 	ldr	r3, [sp, #4]
30016804:	e1d320ba 	ldrh	r2, [r3, #10]
30016808:	e59d3004 	ldr	r3, [sp, #4]
3001680c:	e1c320b8 	strh	r2, [r3, #8]
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
30016810:	e59d0008 	ldr	r0, [sp, #8]
30016814:	ebffff45 	bl	30016530 <pbuf_free>
30016818:	e1a03000 	mov	r3, r0
3001681c:	e5cd300f 	strb	r3, [sp, #15]
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  return ((tail_gone > 0) ? NULL : q);
30016820:	e5dd300f 	ldrb	r3, [sp, #15]
30016824:	e3530000 	cmp	r3, #0
30016828:	1a000001 	bne	30016834 <pbuf_dechain+0x90>
3001682c:	e59d3008 	ldr	r3, [sp, #8]
30016830:	ea000000 	b	30016838 <pbuf_dechain+0x94>
30016834:	e3a03000 	mov	r3, #0
}
30016838:	e1a00003 	mov	r0, r3
3001683c:	e28dd014 	add	sp, sp, #20
30016840:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016844:	e12fff1e 	bx	lr

30016848 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
30016848:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001684c:	e24dd014 	sub	sp, sp, #20
30016850:	e58d0004 	str	r0, [sp, #4]
30016854:	e58d1000 	str	r1, [sp]
  u16_t offset_to=0, offset_from=0, len;
30016858:	e3a03000 	mov	r3, #0
3001685c:	e1cd30ba 	strh	r3, [sp, #10]
30016860:	e3a03000 	mov	r3, #0
30016864:	e1cd30bc 	strh	r3, [sp, #12]
  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
30016868:	e59d3004 	ldr	r3, [sp, #4]
3001686c:	e1d330ba 	ldrh	r3, [r3, #10]
30016870:	e1a02003 	mov	r2, r3
30016874:	e1dd30ba 	ldrh	r3, [sp, #10]
30016878:	e0632002 	rsb	r2, r3, r2
3001687c:	e59d3000 	ldr	r3, [sp]
30016880:	e1d330ba 	ldrh	r3, [r3, #10]
30016884:	e1a01003 	mov	r1, r3
30016888:	e1dd30bc 	ldrh	r3, [sp, #12]
3001688c:	e0633001 	rsb	r3, r3, r1
30016890:	e1520003 	cmp	r2, r3
30016894:	ba000005 	blt	300168b0 <pbuf_copy+0x68>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
30016898:	e59d3000 	ldr	r3, [sp]
3001689c:	e1d320ba 	ldrh	r2, [r3, #10]
300168a0:	e1dd30bc 	ldrh	r3, [sp, #12]
300168a4:	e0633002 	rsb	r3, r3, r2
300168a8:	e1cd30be 	strh	r3, [sp, #14]
300168ac:	ea000004 	b	300168c4 <pbuf_copy+0x7c>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
300168b0:	e59d3004 	ldr	r3, [sp, #4]
300168b4:	e1d320ba 	ldrh	r2, [r3, #10]
300168b8:	e1dd30ba 	ldrh	r3, [sp, #10]
300168bc:	e0633002 	rsb	r3, r3, r2
300168c0:	e1cd30be 	strh	r3, [sp, #14]
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
300168c4:	e59d3004 	ldr	r3, [sp, #4]
300168c8:	e5932004 	ldr	r2, [r3, #4]
300168cc:	e1dd30ba 	ldrh	r3, [sp, #10]
300168d0:	e0821003 	add	r1, r2, r3
300168d4:	e59d3000 	ldr	r3, [sp]
300168d8:	e5932004 	ldr	r2, [r3, #4]
300168dc:	e1dd30bc 	ldrh	r3, [sp, #12]
300168e0:	e0822003 	add	r2, r2, r3
300168e4:	e1dd30be 	ldrh	r3, [sp, #14]
300168e8:	e1a00001 	mov	r0, r1
300168ec:	e1a01002 	mov	r1, r2
300168f0:	e1a02003 	mov	r2, r3
300168f4:	ebffd994 	bl	3000cf4c <__re_memcpy>
    offset_to += len;
300168f8:	e1dd20ba 	ldrh	r2, [sp, #10]
300168fc:	e1dd30be 	ldrh	r3, [sp, #14]
30016900:	e0823003 	add	r3, r2, r3
30016904:	e1cd30ba 	strh	r3, [sp, #10]
    offset_from += len;
30016908:	e1dd20bc 	ldrh	r2, [sp, #12]
3001690c:	e1dd30be 	ldrh	r3, [sp, #14]
30016910:	e0823003 	add	r3, r2, r3
30016914:	e1cd30bc 	strh	r3, [sp, #12]
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
30016918:	e59d3004 	ldr	r3, [sp, #4]
3001691c:	e1d330ba 	ldrh	r3, [r3, #10]
30016920:	e1dd20ba 	ldrh	r2, [sp, #10]
30016924:	e1520003 	cmp	r2, r3
30016928:	1a000004 	bne	30016940 <pbuf_copy+0xf8>
      /* on to next p_to (if any) */
      offset_to = 0;
3001692c:	e3a03000 	mov	r3, #0
30016930:	e1cd30ba 	strh	r3, [sp, #10]
      p_to = p_to->next;
30016934:	e59d3004 	ldr	r3, [sp, #4]
30016938:	e5933000 	ldr	r3, [r3]
3001693c:	e58d3004 	str	r3, [sp, #4]
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
30016940:	e59d3000 	ldr	r3, [sp]
30016944:	e1d330ba 	ldrh	r3, [r3, #10]
30016948:	e1dd20bc 	ldrh	r2, [sp, #12]
3001694c:	e1520003 	cmp	r2, r3
30016950:	3a000004 	bcc	30016968 <pbuf_copy+0x120>
      /* on to next p_from (if any) */
      offset_from = 0;
30016954:	e3a03000 	mov	r3, #0
30016958:	e1cd30bc 	strh	r3, [sp, #12]
      p_from = p_from->next;
3001695c:	e59d3000 	ldr	r3, [sp]
30016960:	e5933000 	ldr	r3, [r3]
30016964:	e58d3000 	str	r3, [sp]
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
30016968:	e59d3000 	ldr	r3, [sp]
3001696c:	e3530000 	cmp	r3, #0
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
30016970:	e59d3004 	ldr	r3, [sp, #4]
30016974:	e3530000 	cmp	r3, #0
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
30016978:	e59d3000 	ldr	r3, [sp]
3001697c:	e3530000 	cmp	r3, #0
30016980:	1affffb8 	bne	30016868 <pbuf_copy+0x20>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
30016984:	e3a03000 	mov	r3, #0
30016988:	e1a03c03 	lsl	r3, r3, #24
3001698c:	e1a03c43 	asr	r3, r3, #24
}
30016990:	e1a00003 	mov	r0, r3
30016994:	e28dd014 	add	sp, sp, #20
30016998:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001699c:	e12fff1e 	bx	lr

300169a0 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
300169a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300169a4:	e24dd024 	sub	sp, sp, #36	; 0x24
300169a8:	e58d000c 	str	r0, [sp, #12]
300169ac:	e58d1008 	str	r1, [sp, #8]
300169b0:	e1cd20b6 	strh	r2, [sp, #6]
300169b4:	e1cd30b4 	strh	r3, [sp, #4]
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
300169b8:	e3a03000 	mov	r3, #0
300169bc:	e1cd31be 	strh	r3, [sp, #30]

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);

  left = 0;
300169c0:	e3a03000 	mov	r3, #0
300169c4:	e1cd31ba 	strh	r3, [sp, #26]

  if((buf == NULL) || (dataptr == NULL)) {
300169c8:	e59d300c 	ldr	r3, [sp, #12]
300169cc:	e3530000 	cmp	r3, #0
300169d0:	0a000002 	beq	300169e0 <pbuf_copy_partial+0x40>
300169d4:	e59d3008 	ldr	r3, [sp, #8]
300169d8:	e3530000 	cmp	r3, #0
300169dc:	1a000001 	bne	300169e8 <pbuf_copy_partial+0x48>
    return 0;
300169e0:	e3a03000 	mov	r3, #0
300169e4:	ea00003f 	b	30016ae8 <pbuf_copy_partial+0x148>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
300169e8:	e59d300c 	ldr	r3, [sp, #12]
300169ec:	e58d3014 	str	r3, [sp, #20]
300169f0:	ea000035 	b	30016acc <pbuf_copy_partial+0x12c>
    if ((offset != 0) && (offset >= p->len)) {
300169f4:	e1dd30b4 	ldrh	r3, [sp, #4]
300169f8:	e3530000 	cmp	r3, #0
300169fc:	0a00000a 	beq	30016a2c <pbuf_copy_partial+0x8c>
30016a00:	e59d3014 	ldr	r3, [sp, #20]
30016a04:	e1d330ba 	ldrh	r3, [r3, #10]
30016a08:	e1dd20b4 	ldrh	r2, [sp, #4]
30016a0c:	e1520003 	cmp	r2, r3
30016a10:	3a000005 	bcc	30016a2c <pbuf_copy_partial+0x8c>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
30016a14:	e59d3014 	ldr	r3, [sp, #20]
30016a18:	e1d330ba 	ldrh	r3, [r3, #10]
30016a1c:	e1dd20b4 	ldrh	r2, [sp, #4]
30016a20:	e0633002 	rsb	r3, r3, r2
30016a24:	e1cd30b4 	strh	r3, [sp, #4]
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
30016a28:	ea000024 	b	30016ac0 <pbuf_copy_partial+0x120>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
30016a2c:	e59d3014 	ldr	r3, [sp, #20]
30016a30:	e1d320ba 	ldrh	r2, [r3, #10]
30016a34:	e1dd30b4 	ldrh	r3, [sp, #4]
30016a38:	e0633002 	rsb	r3, r3, r2
30016a3c:	e1cd31bc 	strh	r3, [sp, #28]
      if (buf_copy_len > len)
30016a40:	e1dd21bc 	ldrh	r2, [sp, #28]
30016a44:	e1dd30b6 	ldrh	r3, [sp, #6]
30016a48:	e1520003 	cmp	r2, r3
30016a4c:	9a000001 	bls	30016a58 <pbuf_copy_partial+0xb8>
          buf_copy_len = len;
30016a50:	e1dd30b6 	ldrh	r3, [sp, #6]
30016a54:	e1cd31bc 	strh	r3, [sp, #28]
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
30016a58:	e1dd21ba 	ldrh	r2, [sp, #26]
30016a5c:	e59d3008 	ldr	r3, [sp, #8]
30016a60:	e0821003 	add	r1, r2, r3
30016a64:	e59d3014 	ldr	r3, [sp, #20]
30016a68:	e5932004 	ldr	r2, [r3, #4]
30016a6c:	e1dd30b4 	ldrh	r3, [sp, #4]
30016a70:	e0822003 	add	r2, r2, r3
30016a74:	e1dd31bc 	ldrh	r3, [sp, #28]
30016a78:	e1a00001 	mov	r0, r1
30016a7c:	e1a01002 	mov	r1, r2
30016a80:	e1a02003 	mov	r2, r3
30016a84:	ebffd930 	bl	3000cf4c <__re_memcpy>
      copied_total += buf_copy_len;
30016a88:	e1dd21be 	ldrh	r2, [sp, #30]
30016a8c:	e1dd31bc 	ldrh	r3, [sp, #28]
30016a90:	e0823003 	add	r3, r2, r3
30016a94:	e1cd31be 	strh	r3, [sp, #30]
      left += buf_copy_len;
30016a98:	e1dd21ba 	ldrh	r2, [sp, #26]
30016a9c:	e1dd31bc 	ldrh	r3, [sp, #28]
30016aa0:	e0823003 	add	r3, r2, r3
30016aa4:	e1cd31ba 	strh	r3, [sp, #26]
      len -= buf_copy_len;
30016aa8:	e1dd20b6 	ldrh	r2, [sp, #6]
30016aac:	e1dd31bc 	ldrh	r3, [sp, #28]
30016ab0:	e0633002 	rsb	r3, r3, r2
30016ab4:	e1cd30b6 	strh	r3, [sp, #6]
      offset = 0;
30016ab8:	e3a03000 	mov	r3, #0
30016abc:	e1cd30b4 	strh	r3, [sp, #4]
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
30016ac0:	e59d3014 	ldr	r3, [sp, #20]
30016ac4:	e5933000 	ldr	r3, [r3]
30016ac8:	e58d3014 	str	r3, [sp, #20]
30016acc:	e1dd30b6 	ldrh	r3, [sp, #6]
30016ad0:	e3530000 	cmp	r3, #0
30016ad4:	0a000002 	beq	30016ae4 <pbuf_copy_partial+0x144>
30016ad8:	e59d3014 	ldr	r3, [sp, #20]
30016adc:	e3530000 	cmp	r3, #0
30016ae0:	1affffc3 	bne	300169f4 <pbuf_copy_partial+0x54>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
30016ae4:	e1dd31be 	ldrh	r3, [sp, #30]
}
30016ae8:	e1a00003 	mov	r0, r3
30016aec:	e28dd024 	add	sp, sp, #36	; 0x24
30016af0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016af4:	e12fff1e 	bx	lr

30016af8 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
30016af8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30016afc:	e24dd01c 	sub	sp, sp, #28
30016b00:	e58d0004 	str	r0, [sp, #4]
30016b04:	e58d1000 	str	r1, [sp]
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
30016b08:	e3a03000 	mov	r3, #0
30016b0c:	e5cd3017 	strb	r3, [sp, #23]

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
30016b10:	e59d3004 	ldr	r3, [sp, #4]
30016b14:	e5933004 	ldr	r3, [r3, #4]
30016b18:	e58d3010 	str	r3, [sp, #16]
  proto = IPH_PROTO(iphdr);
30016b1c:	e59d3010 	ldr	r3, [sp, #16]
30016b20:	e5d32008 	ldrb	r2, [r3, #8]
30016b24:	e5d33009 	ldrb	r3, [r3, #9]
30016b28:	e1a03403 	lsl	r3, r3, #8
30016b2c:	e1833002 	orr	r3, r3, r2
30016b30:	e1a03803 	lsl	r3, r3, #16
30016b34:	e1a03823 	lsr	r3, r3, #16
30016b38:	e1a00003 	mov	r0, r3
30016b3c:	ebfff371 	bl	30013908 <ntohs>
30016b40:	e1a03000 	mov	r3, r0
30016b44:	e20330ff 	and	r3, r3, #255	; 0xff
30016b48:	e1cd31b4 	strh	r3, [sp, #20]

  prev = NULL;
30016b4c:	e3a03000 	mov	r3, #0
30016b50:	e58d300c 	str	r3, [sp, #12]
  pcb = raw_pcbs;
30016b54:	e59f30f0 	ldr	r3, [pc, #240]	; 30016c4c <raw_input+0x154>
30016b58:	e5933000 	ldr	r3, [r3]
30016b5c:	e58d3008 	str	r3, [sp, #8]
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
30016b60:	ea00002e 	b	30016c20 <raw_input+0x128>
    if (pcb->protocol == proto) {
30016b64:	e59d3008 	ldr	r3, [sp, #8]
30016b68:	e5d33010 	ldrb	r3, [r3, #16]
30016b6c:	e1a02003 	mov	r2, r3
30016b70:	e1dd31f4 	ldrsh	r3, [sp, #20]
30016b74:	e1520003 	cmp	r2, r3
30016b78:	1a000023 	bne	30016c0c <raw_input+0x114>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
30016b7c:	e59d3008 	ldr	r3, [sp, #8]
30016b80:	e5933014 	ldr	r3, [r3, #20]
30016b84:	e3530000 	cmp	r3, #0
30016b88:	0a00001f 	beq	30016c0c <raw_input+0x114>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
30016b8c:	e59d3008 	ldr	r3, [sp, #8]
30016b90:	e593c014 	ldr	ip, [r3, #20]
30016b94:	e59d3008 	ldr	r3, [sp, #8]
30016b98:	e5932018 	ldr	r2, [r3, #24]
30016b9c:	e59d3010 	ldr	r3, [sp, #16]
30016ba0:	e283300c 	add	r3, r3, #12
30016ba4:	e1a00002 	mov	r0, r2
30016ba8:	e59d1008 	ldr	r1, [sp, #8]
30016bac:	e59d2004 	ldr	r2, [sp, #4]
30016bb0:	e1a0e00f 	mov	lr, pc
30016bb4:	e12fff1c 	bx	ip
30016bb8:	e1a03000 	mov	r3, r0
30016bbc:	e3530000 	cmp	r3, #0
30016bc0:	0a000011 	beq	30016c0c <raw_input+0x114>
        {
          /* receive function ate the packet */
          p = NULL;
30016bc4:	e3a03000 	mov	r3, #0
30016bc8:	e58d3004 	str	r3, [sp, #4]
          eaten = 1;
30016bcc:	e3a03001 	mov	r3, #1
30016bd0:	e5cd3017 	strb	r3, [sp, #23]
          if (prev != NULL) {
30016bd4:	e59d300c 	ldr	r3, [sp, #12]
30016bd8:	e3530000 	cmp	r3, #0
30016bdc:	0a00000a 	beq	30016c0c <raw_input+0x114>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
30016be0:	e59d3008 	ldr	r3, [sp, #8]
30016be4:	e593200c 	ldr	r2, [r3, #12]
30016be8:	e59d300c 	ldr	r3, [sp, #12]
30016bec:	e583200c 	str	r2, [r3, #12]
            pcb->next = raw_pcbs;
30016bf0:	e59f3054 	ldr	r3, [pc, #84]	; 30016c4c <raw_input+0x154>
30016bf4:	e5932000 	ldr	r2, [r3]
30016bf8:	e59d3008 	ldr	r3, [sp, #8]
30016bfc:	e583200c 	str	r2, [r3, #12]
            raw_pcbs = pcb;
30016c00:	e59f3044 	ldr	r3, [pc, #68]	; 30016c4c <raw_input+0x154>
30016c04:	e59d2008 	ldr	r2, [sp, #8]
30016c08:	e5832000 	str	r2, [r3]
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
30016c0c:	e59d3008 	ldr	r3, [sp, #8]
30016c10:	e58d300c 	str	r3, [sp, #12]
    pcb = pcb->next;
30016c14:	e59d3008 	ldr	r3, [sp, #8]
30016c18:	e593300c 	ldr	r3, [r3, #12]
30016c1c:	e58d3008 	str	r3, [sp, #8]

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
30016c20:	e5dd3017 	ldrb	r3, [sp, #23]
30016c24:	e3530000 	cmp	r3, #0
30016c28:	1a000002 	bne	30016c38 <raw_input+0x140>
30016c2c:	e59d3008 	ldr	r3, [sp, #8]
30016c30:	e3530000 	cmp	r3, #0
30016c34:	1affffca 	bne	30016b64 <raw_input+0x6c>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
30016c38:	e5dd3017 	ldrb	r3, [sp, #23]
}
30016c3c:	e1a00003 	mov	r0, r3
30016c40:	e28dd01c 	add	sp, sp, #28
30016c44:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016c48:	e12fff1e 	bx	lr
30016c4c:	30028f54 	.word	0x30028f54

30016c50 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
30016c50:	e24dd008 	sub	sp, sp, #8
30016c54:	e58d0004 	str	r0, [sp, #4]
30016c58:	e58d1000 	str	r1, [sp]
  ip_addr_set(&pcb->local_ip, ipaddr);
30016c5c:	e59d3000 	ldr	r3, [sp]
30016c60:	e3530000 	cmp	r3, #0
30016c64:	0a00000b 	beq	30016c98 <raw_bind+0x48>
30016c68:	e59d3000 	ldr	r3, [sp]
30016c6c:	e5d32000 	ldrb	r2, [r3]
30016c70:	e5d31001 	ldrb	r1, [r3, #1]
30016c74:	e1a01401 	lsl	r1, r1, #8
30016c78:	e1812002 	orr	r2, r1, r2
30016c7c:	e5d31002 	ldrb	r1, [r3, #2]
30016c80:	e1a01801 	lsl	r1, r1, #16
30016c84:	e1812002 	orr	r2, r1, r2
30016c88:	e5d33003 	ldrb	r3, [r3, #3]
30016c8c:	e1a03c03 	lsl	r3, r3, #24
30016c90:	e1833002 	orr	r3, r3, r2
30016c94:	ea000000 	b	30016c9c <raw_bind+0x4c>
30016c98:	e3a03000 	mov	r3, #0
30016c9c:	e59d2004 	ldr	r2, [sp, #4]
30016ca0:	e5823000 	str	r3, [r2]
  return ERR_OK;
30016ca4:	e3a03000 	mov	r3, #0
30016ca8:	e1a03c03 	lsl	r3, r3, #24
30016cac:	e1a03c43 	asr	r3, r3, #24
}
30016cb0:	e1a00003 	mov	r0, r3
30016cb4:	e28dd008 	add	sp, sp, #8
30016cb8:	e12fff1e 	bx	lr

30016cbc <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
30016cbc:	e24dd008 	sub	sp, sp, #8
30016cc0:	e58d0004 	str	r0, [sp, #4]
30016cc4:	e58d1000 	str	r1, [sp]
  ip_addr_set(&pcb->remote_ip, ipaddr);
30016cc8:	e59d3000 	ldr	r3, [sp]
30016ccc:	e3530000 	cmp	r3, #0
30016cd0:	0a00000b 	beq	30016d04 <raw_connect+0x48>
30016cd4:	e59d3000 	ldr	r3, [sp]
30016cd8:	e5d32000 	ldrb	r2, [r3]
30016cdc:	e5d31001 	ldrb	r1, [r3, #1]
30016ce0:	e1a01401 	lsl	r1, r1, #8
30016ce4:	e1812002 	orr	r2, r1, r2
30016ce8:	e5d31002 	ldrb	r1, [r3, #2]
30016cec:	e1a01801 	lsl	r1, r1, #16
30016cf0:	e1812002 	orr	r2, r1, r2
30016cf4:	e5d33003 	ldrb	r3, [r3, #3]
30016cf8:	e1a03c03 	lsl	r3, r3, #24
30016cfc:	e1833002 	orr	r3, r3, r2
30016d00:	ea000000 	b	30016d08 <raw_connect+0x4c>
30016d04:	e3a03000 	mov	r3, #0
30016d08:	e59d2004 	ldr	r2, [sp, #4]
30016d0c:	e5823004 	str	r3, [r2, #4]
  return ERR_OK;
30016d10:	e3a03000 	mov	r3, #0
30016d14:	e1a03c03 	lsl	r3, r3, #24
30016d18:	e1a03c43 	asr	r3, r3, #24
}
30016d1c:	e1a00003 	mov	r0, r3
30016d20:	e28dd008 	add	sp, sp, #8
30016d24:	e12fff1e 	bx	lr

30016d28 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
30016d28:	e24dd010 	sub	sp, sp, #16
30016d2c:	e58d000c 	str	r0, [sp, #12]
30016d30:	e58d1008 	str	r1, [sp, #8]
30016d34:	e58d2004 	str	r2, [sp, #4]
  /* remember recv() callback and user data */
  pcb->recv = recv;
30016d38:	e59d300c 	ldr	r3, [sp, #12]
30016d3c:	e59d2008 	ldr	r2, [sp, #8]
30016d40:	e5832014 	str	r2, [r3, #20]
  pcb->recv_arg = recv_arg;
30016d44:	e59d300c 	ldr	r3, [sp, #12]
30016d48:	e59d2004 	ldr	r2, [sp, #4]
30016d4c:	e5832018 	str	r2, [r3, #24]
}
30016d50:	e28dd010 	add	sp, sp, #16
30016d54:	e12fff1e 	bx	lr

30016d58 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
30016d58:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30016d5c:	e24dd034 	sub	sp, sp, #52	; 0x34
30016d60:	e58d001c 	str	r0, [sp, #28]
30016d64:	e58d1018 	str	r1, [sp, #24]
30016d68:	e58d2014 	str	r2, [sp, #20]
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
30016d6c:	e59d0018 	ldr	r0, [sp, #24]
30016d70:	e3a01014 	mov	r1, #20
30016d74:	ebfffd88 	bl	3001639c <pbuf_header>
30016d78:	e1a03000 	mov	r3, r0
30016d7c:	e3530000 	cmp	r3, #0
30016d80:	0a00000e 	beq	30016dc0 <raw_sendto+0x68>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
30016d84:	e3a00001 	mov	r0, #1
30016d88:	e3a01000 	mov	r1, #0
30016d8c:	e3a02000 	mov	r2, #0
30016d90:	ebfffc37 	bl	30015e74 <pbuf_alloc>
30016d94:	e1a03000 	mov	r3, r0
30016d98:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
30016d9c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30016da0:	e3530000 	cmp	r3, #0
30016da4:	1a000001 	bne	30016db0 <raw_sendto+0x58>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
30016da8:	e3a030ff 	mov	r3, #255	; 0xff
30016dac:	ea000041 	b	30016eb8 <raw_sendto+0x160>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
30016db0:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30016db4:	e59d1018 	ldr	r1, [sp, #24]
30016db8:	ebfffe6d 	bl	30016774 <pbuf_chain>
30016dbc:	ea000009 	b	30016de8 <raw_sendto+0x90>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
30016dc0:	e59d3018 	ldr	r3, [sp, #24]
30016dc4:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    if(pbuf_header(q, -IP_HLEN)) {
30016dc8:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30016dcc:	e3e01013 	mvn	r1, #19
30016dd0:	ebfffd71 	bl	3001639c <pbuf_header>
30016dd4:	e1a03000 	mov	r3, r0
30016dd8:	e3530000 	cmp	r3, #0
30016ddc:	0a000001 	beq	30016de8 <raw_sendto+0x90>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
30016de0:	e3a030ff 	mov	r3, #255	; 0xff
30016de4:	ea000033 	b	30016eb8 <raw_sendto+0x160>
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
30016de8:	e59d0014 	ldr	r0, [sp, #20]
30016dec:	ebfff507 	bl	30014210 <ip_route>
30016df0:	e1a03000 	mov	r3, r0
30016df4:	e58d3024 	str	r3, [sp, #36]	; 0x24
30016df8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30016dfc:	e3530000 	cmp	r3, #0
30016e00:	1a000007 	bne	30016e24 <raw_sendto+0xcc>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
30016e04:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30016e08:	e59d3018 	ldr	r3, [sp, #24]
30016e0c:	e1520003 	cmp	r2, r3
30016e10:	0a000001 	beq	30016e1c <raw_sendto+0xc4>
      pbuf_free(q);
30016e14:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30016e18:	ebfffdc4 	bl	30016530 <pbuf_free>
    }
    return ERR_RTE;
30016e1c:	e3a030fd 	mov	r3, #253	; 0xfd
30016e20:	ea000024 	b	30016eb8 <raw_sendto+0x160>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
30016e24:	e59d301c 	ldr	r3, [sp, #28]
30016e28:	e3530000 	cmp	r3, #0
30016e2c:	0a000003 	beq	30016e40 <raw_sendto+0xe8>
30016e30:	e59d301c 	ldr	r3, [sp, #28]
30016e34:	e5933000 	ldr	r3, [r3]
30016e38:	e3530000 	cmp	r3, #0
30016e3c:	1a000003 	bne	30016e50 <raw_sendto+0xf8>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
30016e40:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30016e44:	e2833004 	add	r3, r3, #4
30016e48:	e58d3028 	str	r3, [sp, #40]	; 0x28
      pbuf_free(q);
    }
    return ERR_RTE;
  }

  if (ip_addr_isany(&pcb->local_ip)) {
30016e4c:	ea000001 	b	30016e58 <raw_sendto+0x100>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
30016e50:	e59d301c 	ldr	r3, [sp, #28]
30016e54:	e58d3028 	str	r3, [sp, #40]	; 0x28
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
30016e58:	e59d301c 	ldr	r3, [sp, #28]
30016e5c:	e5d3300b 	ldrb	r3, [r3, #11]
30016e60:	e59d201c 	ldr	r2, [sp, #28]
30016e64:	e5d2100a 	ldrb	r1, [r2, #10]
30016e68:	e59d201c 	ldr	r2, [sp, #28]
30016e6c:	e5d22010 	ldrb	r2, [r2, #16]
30016e70:	e58d1000 	str	r1, [sp]
30016e74:	e58d2004 	str	r2, [sp, #4]
30016e78:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30016e7c:	e58d2008 	str	r2, [sp, #8]
30016e80:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30016e84:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
30016e88:	e59d2014 	ldr	r2, [sp, #20]
30016e8c:	ebfff699 	bl	300148f8 <ip_output_if>
30016e90:	e1a03000 	mov	r3, r0
30016e94:	e20330ff 	and	r3, r3, #255	; 0xff
30016e98:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
30016e9c:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30016ea0:	e59d3018 	ldr	r3, [sp, #24]
30016ea4:	e1520003 	cmp	r2, r3
30016ea8:	0a000001 	beq	30016eb4 <raw_sendto+0x15c>
    /* free the header */
    pbuf_free(q);
30016eac:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30016eb0:	ebfffd9e 	bl	30016530 <pbuf_free>
  }
  return err;
30016eb4:	e5dd3023 	ldrb	r3, [sp, #35]	; 0x23
30016eb8:	e1a03c03 	lsl	r3, r3, #24
30016ebc:	e1a03c43 	asr	r3, r3, #24
}
30016ec0:	e1a00003 	mov	r0, r3
30016ec4:	e28dd034 	add	sp, sp, #52	; 0x34
30016ec8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016ecc:	e12fff1e 	bx	lr

30016ed0 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
30016ed0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30016ed4:	e24dd00c 	sub	sp, sp, #12
30016ed8:	e58d0004 	str	r0, [sp, #4]
30016edc:	e58d1000 	str	r1, [sp]
  return raw_sendto(pcb, p, &pcb->remote_ip);
30016ee0:	e59d3004 	ldr	r3, [sp, #4]
30016ee4:	e2833004 	add	r3, r3, #4
30016ee8:	e59d0004 	ldr	r0, [sp, #4]
30016eec:	e59d1000 	ldr	r1, [sp]
30016ef0:	e1a02003 	mov	r2, r3
30016ef4:	ebffff97 	bl	30016d58 <raw_sendto>
30016ef8:	e1a03000 	mov	r3, r0
30016efc:	e20330ff 	and	r3, r3, #255	; 0xff
30016f00:	e20330ff 	and	r3, r3, #255	; 0xff
30016f04:	e1a03c03 	lsl	r3, r3, #24
30016f08:	e1a03c43 	asr	r3, r3, #24
}
30016f0c:	e1a00003 	mov	r0, r3
30016f10:	e28dd00c 	add	sp, sp, #12
30016f14:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016f18:	e12fff1e 	bx	lr

30016f1c <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
30016f1c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30016f20:	e24dd014 	sub	sp, sp, #20
30016f24:	e58d0004 	str	r0, [sp, #4]
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
30016f28:	e59f3098 	ldr	r3, [pc, #152]	; 30016fc8 <raw_remove+0xac>
30016f2c:	e5932000 	ldr	r2, [r3]
30016f30:	e59d3004 	ldr	r3, [sp, #4]
30016f34:	e1520003 	cmp	r2, r3
30016f38:	1a000005 	bne	30016f54 <raw_remove+0x38>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
30016f3c:	e59f3084 	ldr	r3, [pc, #132]	; 30016fc8 <raw_remove+0xac>
30016f40:	e5933000 	ldr	r3, [r3]
30016f44:	e593200c 	ldr	r2, [r3, #12]
30016f48:	e59f3078 	ldr	r3, [pc, #120]	; 30016fc8 <raw_remove+0xac>
30016f4c:	e5832000 	str	r2, [r3]
30016f50:	ea000016 	b	30016fb0 <raw_remove+0x94>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
30016f54:	e59f306c 	ldr	r3, [pc, #108]	; 30016fc8 <raw_remove+0xac>
30016f58:	e5933000 	ldr	r3, [r3]
30016f5c:	e58d300c 	str	r3, [sp, #12]
30016f60:	ea00000f 	b	30016fa4 <raw_remove+0x88>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
30016f64:	e59d300c 	ldr	r3, [sp, #12]
30016f68:	e593300c 	ldr	r3, [r3, #12]
30016f6c:	e3530000 	cmp	r3, #0
30016f70:	0a000008 	beq	30016f98 <raw_remove+0x7c>
30016f74:	e59d300c 	ldr	r3, [sp, #12]
30016f78:	e593200c 	ldr	r2, [r3, #12]
30016f7c:	e59d3004 	ldr	r3, [sp, #4]
30016f80:	e1520003 	cmp	r2, r3
30016f84:	1a000003 	bne	30016f98 <raw_remove+0x7c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
30016f88:	e59d3004 	ldr	r3, [sp, #4]
30016f8c:	e593200c 	ldr	r2, [r3, #12]
30016f90:	e59d300c 	ldr	r3, [sp, #12]
30016f94:	e583200c 	str	r2, [r3, #12]
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
30016f98:	e59d300c 	ldr	r3, [sp, #12]
30016f9c:	e593300c 	ldr	r3, [r3, #12]
30016fa0:	e58d300c 	str	r3, [sp, #12]
30016fa4:	e59d300c 	ldr	r3, [sp, #12]
30016fa8:	e3530000 	cmp	r3, #0
30016fac:	1affffec 	bne	30016f64 <raw_remove+0x48>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
30016fb0:	e3a00000 	mov	r0, #0
30016fb4:	e59d1004 	ldr	r1, [sp, #4]
30016fb8:	ebfff9f1 	bl	30015784 <memp_free>
}
30016fbc:	e28dd014 	add	sp, sp, #20
30016fc0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016fc4:	e12fff1e 	bx	lr
30016fc8:	30028f54 	.word	0x30028f54

30016fcc <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
30016fcc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30016fd0:	e24dd014 	sub	sp, sp, #20
30016fd4:	e1a03000 	mov	r3, r0
30016fd8:	e5cd3007 	strb	r3, [sp, #7]
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
30016fdc:	e3a00000 	mov	r0, #0
30016fe0:	ebfff982 	bl	300155f0 <memp_malloc>
30016fe4:	e1a03000 	mov	r3, r0
30016fe8:	e58d300c 	str	r3, [sp, #12]
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
30016fec:	e59d300c 	ldr	r3, [sp, #12]
30016ff0:	e3530000 	cmp	r3, #0
30016ff4:	0a000010 	beq	3001703c <raw_new+0x70>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
30016ff8:	e59d000c 	ldr	r0, [sp, #12]
30016ffc:	e3a01000 	mov	r1, #0
30017000:	e3a0201c 	mov	r2, #28
30017004:	ebffd7b6 	bl	3000cee4 <__re_memset>
    pcb->protocol = proto;
30017008:	e59d300c 	ldr	r3, [sp, #12]
3001700c:	e5dd2007 	ldrb	r2, [sp, #7]
30017010:	e5c32010 	strb	r2, [r3, #16]
    pcb->ttl = RAW_TTL;
30017014:	e59d300c 	ldr	r3, [sp, #12]
30017018:	e3e02000 	mvn	r2, #0
3001701c:	e5c3200b 	strb	r2, [r3, #11]
    pcb->next = raw_pcbs;
30017020:	e59f3028 	ldr	r3, [pc, #40]	; 30017050 <raw_new+0x84>
30017024:	e5932000 	ldr	r2, [r3]
30017028:	e59d300c 	ldr	r3, [sp, #12]
3001702c:	e583200c 	str	r2, [r3, #12]
    raw_pcbs = pcb;
30017030:	e59f3018 	ldr	r3, [pc, #24]	; 30017050 <raw_new+0x84>
30017034:	e59d200c 	ldr	r2, [sp, #12]
30017038:	e5832000 	str	r2, [r3]
  }
  return pcb;
3001703c:	e59d300c 	ldr	r3, [sp, #12]
}
30017040:	e1a00003 	mov	r0, r3
30017044:	e28dd014 	add	sp, sp, #20
30017048:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001704c:	e12fff1e 	bx	lr
30017050:	30028f54 	.word	0x30028f54

30017054 <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
30017054:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30017058:	e24dd024 	sub	sp, sp, #36	; 0x24
3001705c:	e58d0004 	str	r0, [sp, #4]
30017060:	e58d1000 	str	r1, [sp]
30017064:	ea000000 	b	3001706c <sys_mbox_fetch+0x18>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
30017068:	e1a00000 	nop			; (mov r0, r0)
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
3001706c:	ebffd777 	bl	3000ce50 <sys_arch_timeouts>
30017070:	e1a03000 	mov	r3, r0
30017074:	e58d3010 	str	r3, [sp, #16]

  if (!timeouts || !timeouts->next) {
30017078:	e59d3010 	ldr	r3, [sp, #16]
3001707c:	e3530000 	cmp	r3, #0
30017080:	0a000003 	beq	30017094 <sys_mbox_fetch+0x40>
30017084:	e59d3010 	ldr	r3, [sp, #16]
30017088:	e5933000 	ldr	r3, [r3]
3001708c:	e3530000 	cmp	r3, #0
30017090:	1a000006 	bne	300170b0 <sys_mbox_fetch+0x5c>
    UNLOCK_TCPIP_CORE();
    time = sys_arch_mbox_fetch(mbox, msg, 0);
30017094:	e59d0004 	ldr	r0, [sp, #4]
30017098:	e59d1000 	ldr	r1, [sp]
3001709c:	e3a02000 	mov	r2, #0
300170a0:	ebffd6ff 	bl	3000cca4 <sys_arch_mbox_fetch>
300170a4:	e1a03000 	mov	r3, r0
300170a8:	e58d300c 	str	r3, [sp, #12]
  void *arg;

 again:
  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
300170ac:	ea00003e 	b	300171ac <sys_mbox_fetch+0x158>
    UNLOCK_TCPIP_CORE();
    time = sys_arch_mbox_fetch(mbox, msg, 0);
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
300170b0:	e59d3010 	ldr	r3, [sp, #16]
300170b4:	e5933000 	ldr	r3, [r3]
300170b8:	e5933004 	ldr	r3, [r3, #4]
300170bc:	e3530000 	cmp	r3, #0
300170c0:	0a000009 	beq	300170ec <sys_mbox_fetch+0x98>
      UNLOCK_TCPIP_CORE();
      time = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
300170c4:	e59d3010 	ldr	r3, [sp, #16]
300170c8:	e5933000 	ldr	r3, [r3]
300170cc:	e5933004 	ldr	r3, [r3, #4]
300170d0:	e59d0004 	ldr	r0, [sp, #4]
300170d4:	e59d1000 	ldr	r1, [sp]
300170d8:	e1a02003 	mov	r2, r3
300170dc:	ebffd6f0 	bl	3000cca4 <sys_arch_mbox_fetch>
300170e0:	e1a03000 	mov	r3, r0
300170e4:	e58d300c 	str	r3, [sp, #12]
300170e8:	ea000001 	b	300170f4 <sys_mbox_fetch+0xa0>
      LOCK_TCPIP_CORE();
    } else {
      time = SYS_ARCH_TIMEOUT;
300170ec:	e3e03000 	mvn	r3, #0
300170f0:	e58d300c 	str	r3, [sp, #12]
    }

    if (time == SYS_ARCH_TIMEOUT) {
300170f4:	e59d300c 	ldr	r3, [sp, #12]
300170f8:	e3730001 	cmn	r3, #1
300170fc:	1a000017 	bne	30017160 <sys_mbox_fetch+0x10c>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
30017100:	e59d3010 	ldr	r3, [sp, #16]
30017104:	e5933000 	ldr	r3, [r3]
30017108:	e58d3014 	str	r3, [sp, #20]
      timeouts->next = tmptimeout->next;
3001710c:	e59d3014 	ldr	r3, [sp, #20]
30017110:	e5932000 	ldr	r2, [r3]
30017114:	e59d3010 	ldr	r3, [sp, #16]
30017118:	e5832000 	str	r2, [r3]
      h   = tmptimeout->h;
3001711c:	e59d3014 	ldr	r3, [sp, #20]
30017120:	e5933008 	ldr	r3, [r3, #8]
30017124:	e58d3018 	str	r3, [sp, #24]
      arg = tmptimeout->arg;
30017128:	e59d3014 	ldr	r3, [sp, #20]
3001712c:	e593300c 	ldr	r3, [r3, #12]
30017130:	e58d301c 	str	r3, [sp, #28]
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
30017134:	e3a0000a 	mov	r0, #10
30017138:	e59d1014 	ldr	r1, [sp, #20]
3001713c:	ebfff990 	bl	30015784 <memp_free>
      if (h != NULL) {
30017140:	e59d3018 	ldr	r3, [sp, #24]
30017144:	e3530000 	cmp	r3, #0
30017148:	0affffc6 	beq	30017068 <sys_mbox_fetch+0x14>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
3001714c:	e59d3018 	ldr	r3, [sp, #24]
30017150:	e59d001c 	ldr	r0, [sp, #28]
30017154:	e1a0e00f 	mov	lr, pc
30017158:	e12fff13 	bx	r3
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
3001715c:	eaffffc2 	b	3001706c <sys_mbox_fetch+0x18>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time < timeouts->next->time) {
30017160:	e59d3010 	ldr	r3, [sp, #16]
30017164:	e5933000 	ldr	r3, [r3]
30017168:	e5932004 	ldr	r2, [r3, #4]
3001716c:	e59d300c 	ldr	r3, [sp, #12]
30017170:	e1520003 	cmp	r2, r3
30017174:	9a000008 	bls	3001719c <sys_mbox_fetch+0x148>
        timeouts->next->time -= time;
30017178:	e59d3010 	ldr	r3, [sp, #16]
3001717c:	e5933000 	ldr	r3, [r3]
30017180:	e59d2010 	ldr	r2, [sp, #16]
30017184:	e5922000 	ldr	r2, [r2]
30017188:	e5921004 	ldr	r1, [r2, #4]
3001718c:	e59d200c 	ldr	r2, [sp, #12]
30017190:	e0622001 	rsb	r2, r2, r1
30017194:	e5832004 	str	r2, [r3, #4]
30017198:	ea000003 	b	300171ac <sys_mbox_fetch+0x158>
      } else {
        timeouts->next->time = 0;
3001719c:	e59d3010 	ldr	r3, [sp, #16]
300171a0:	e5933000 	ldr	r3, [r3]
300171a4:	e3a02000 	mov	r2, #0
300171a8:	e5832004 	str	r2, [r3, #4]
      }
    }
  }
}
300171ac:	e28dd024 	add	sp, sp, #36	; 0x24
300171b0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300171b4:	e12fff1e 	bx	lr

300171b8 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
300171b8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300171bc:	e24dd024 	sub	sp, sp, #36	; 0x24
300171c0:	e58d0004 	str	r0, [sp, #4]
300171c4:	ea000000 	b	300171cc <sys_sem_wait+0x14>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
300171c8:	e1a00000 	nop			; (mov r0, r0)
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
300171cc:	ebffd71f 	bl	3000ce50 <sys_arch_timeouts>
300171d0:	e1a03000 	mov	r3, r0
300171d4:	e58d3010 	str	r3, [sp, #16]

  if (!timeouts || !timeouts->next) {
300171d8:	e59d3010 	ldr	r3, [sp, #16]
300171dc:	e3530000 	cmp	r3, #0
300171e0:	0a000003 	beq	300171f4 <sys_sem_wait+0x3c>
300171e4:	e59d3010 	ldr	r3, [sp, #16]
300171e8:	e5933000 	ldr	r3, [r3]
300171ec:	e3530000 	cmp	r3, #0
300171f0:	1a000003 	bne	30017204 <sys_sem_wait+0x4c>
    sys_arch_sem_wait(sem, 0);
300171f4:	e59d0004 	ldr	r0, [sp, #4]
300171f8:	e3a01000 	mov	r1, #0
300171fc:	ebffd64d 	bl	3000cb38 <sys_arch_sem_wait>

 again:

  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
30017200:	ea00003d 	b	300172fc <sys_sem_wait+0x144>
    sys_arch_sem_wait(sem, 0);
  } else {
    if (timeouts->next->time > 0) {
30017204:	e59d3010 	ldr	r3, [sp, #16]
30017208:	e5933000 	ldr	r3, [r3]
3001720c:	e5933004 	ldr	r3, [r3, #4]
30017210:	e3530000 	cmp	r3, #0
30017214:	0a000008 	beq	3001723c <sys_sem_wait+0x84>
      time = sys_arch_sem_wait(sem, timeouts->next->time);
30017218:	e59d3010 	ldr	r3, [sp, #16]
3001721c:	e5933000 	ldr	r3, [r3]
30017220:	e5933004 	ldr	r3, [r3, #4]
30017224:	e59d0004 	ldr	r0, [sp, #4]
30017228:	e1a01003 	mov	r1, r3
3001722c:	ebffd641 	bl	3000cb38 <sys_arch_sem_wait>
30017230:	e1a03000 	mov	r3, r0
30017234:	e58d300c 	str	r3, [sp, #12]
30017238:	ea000001 	b	30017244 <sys_sem_wait+0x8c>
    } else {
      time = SYS_ARCH_TIMEOUT;
3001723c:	e3e03000 	mvn	r3, #0
30017240:	e58d300c 	str	r3, [sp, #12]
    }

    if (time == SYS_ARCH_TIMEOUT) {
30017244:	e59d300c 	ldr	r3, [sp, #12]
30017248:	e3730001 	cmn	r3, #1
3001724c:	1a000017 	bne	300172b0 <sys_sem_wait+0xf8>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
30017250:	e59d3010 	ldr	r3, [sp, #16]
30017254:	e5933000 	ldr	r3, [r3]
30017258:	e58d3014 	str	r3, [sp, #20]
      timeouts->next = tmptimeout->next;
3001725c:	e59d3014 	ldr	r3, [sp, #20]
30017260:	e5932000 	ldr	r2, [r3]
30017264:	e59d3010 	ldr	r3, [sp, #16]
30017268:	e5832000 	str	r2, [r3]
      h = tmptimeout->h;
3001726c:	e59d3014 	ldr	r3, [sp, #20]
30017270:	e5933008 	ldr	r3, [r3, #8]
30017274:	e58d3018 	str	r3, [sp, #24]
      arg = tmptimeout->arg;
30017278:	e59d3014 	ldr	r3, [sp, #20]
3001727c:	e593300c 	ldr	r3, [r3, #12]
30017280:	e58d301c 	str	r3, [sp, #28]
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
30017284:	e3a0000a 	mov	r0, #10
30017288:	e59d1014 	ldr	r1, [sp, #20]
3001728c:	ebfff93c 	bl	30015784 <memp_free>
      if (h != NULL) {
30017290:	e59d3018 	ldr	r3, [sp, #24]
30017294:	e3530000 	cmp	r3, #0
30017298:	0affffca 	beq	300171c8 <sys_sem_wait+0x10>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
3001729c:	e59d3018 	ldr	r3, [sp, #24]
300172a0:	e59d001c 	ldr	r0, [sp, #28]
300172a4:	e1a0e00f 	mov	lr, pc
300172a8:	e12fff13 	bx	r3
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
300172ac:	eaffffc6 	b	300171cc <sys_sem_wait+0x14>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time < timeouts->next->time) {
300172b0:	e59d3010 	ldr	r3, [sp, #16]
300172b4:	e5933000 	ldr	r3, [r3]
300172b8:	e5932004 	ldr	r2, [r3, #4]
300172bc:	e59d300c 	ldr	r3, [sp, #12]
300172c0:	e1520003 	cmp	r2, r3
300172c4:	9a000008 	bls	300172ec <sys_sem_wait+0x134>
        timeouts->next->time -= time;
300172c8:	e59d3010 	ldr	r3, [sp, #16]
300172cc:	e5933000 	ldr	r3, [r3]
300172d0:	e59d2010 	ldr	r2, [sp, #16]
300172d4:	e5922000 	ldr	r2, [r2]
300172d8:	e5921004 	ldr	r1, [r2, #4]
300172dc:	e59d200c 	ldr	r2, [sp, #12]
300172e0:	e0622001 	rsb	r2, r2, r1
300172e4:	e5832004 	str	r2, [r3, #4]
300172e8:	ea000003 	b	300172fc <sys_sem_wait+0x144>
      } else {
        timeouts->next->time = 0;
300172ec:	e59d3010 	ldr	r3, [sp, #16]
300172f0:	e5933000 	ldr	r3, [r3]
300172f4:	e3a02000 	mov	r2, #0
300172f8:	e5832004 	str	r2, [r3, #4]
      }
    }
  }
}
300172fc:	e28dd024 	add	sp, sp, #36	; 0x24
30017300:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30017304:	e12fff1e 	bx	lr

30017308 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
30017308:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001730c:	e24dd024 	sub	sp, sp, #36	; 0x24
30017310:	e58d000c 	str	r0, [sp, #12]
30017314:	e58d1008 	str	r1, [sp, #8]
30017318:	e58d2004 	str	r2, [sp, #4]
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
3001731c:	e3a0000a 	mov	r0, #10
30017320:	ebfff8b2 	bl	300155f0 <memp_malloc>
30017324:	e1a03000 	mov	r3, r0
30017328:	e58d3018 	str	r3, [sp, #24]
  if (timeout == NULL) {
3001732c:	e59d3018 	ldr	r3, [sp, #24]
30017330:	e3530000 	cmp	r3, #0
30017334:	0a000061 	beq	300174c0 <sys_timeout+0x1b8>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
    return;
  }
  timeout->next = NULL;
30017338:	e59d3018 	ldr	r3, [sp, #24]
3001733c:	e3a02000 	mov	r2, #0
30017340:	e5832000 	str	r2, [r3]
  timeout->h = h;
30017344:	e59d3018 	ldr	r3, [sp, #24]
30017348:	e59d2008 	ldr	r2, [sp, #8]
3001734c:	e5832008 	str	r2, [r3, #8]
  timeout->arg = arg;
30017350:	e59d3018 	ldr	r3, [sp, #24]
30017354:	e59d2004 	ldr	r2, [sp, #4]
30017358:	e583200c 	str	r2, [r3, #12]
  timeout->time = msecs;
3001735c:	e59d3018 	ldr	r3, [sp, #24]
30017360:	e59d200c 	ldr	r2, [sp, #12]
30017364:	e5832004 	str	r2, [r3, #4]

  timeouts = sys_arch_timeouts();
30017368:	ebffd6b8 	bl	3000ce50 <sys_arch_timeouts>
3001736c:	e1a03000 	mov	r3, r0
30017370:	e58d3014 	str	r3, [sp, #20]

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
30017374:	e59d3014 	ldr	r3, [sp, #20]
30017378:	e3530000 	cmp	r3, #0
3001737c:	0a000051 	beq	300174c8 <sys_timeout+0x1c0>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
    return;
  }

  if (timeouts->next == NULL) {
30017380:	e59d3014 	ldr	r3, [sp, #20]
30017384:	e5933000 	ldr	r3, [r3]
30017388:	e3530000 	cmp	r3, #0
3001738c:	1a000003 	bne	300173a0 <sys_timeout+0x98>
    timeouts->next = timeout;
30017390:	e59d3014 	ldr	r3, [sp, #20]
30017394:	e59d2018 	ldr	r2, [sp, #24]
30017398:	e5832000 	str	r2, [r3]
    return;
3001739c:	ea00004a 	b	300174cc <sys_timeout+0x1c4>
  }

  if (timeouts->next->time > msecs) {
300173a0:	e59d3014 	ldr	r3, [sp, #20]
300173a4:	e5933000 	ldr	r3, [r3]
300173a8:	e5932004 	ldr	r2, [r3, #4]
300173ac:	e59d300c 	ldr	r3, [sp, #12]
300173b0:	e1520003 	cmp	r2, r3
300173b4:	9a00000f 	bls	300173f8 <sys_timeout+0xf0>
    timeouts->next->time -= msecs;
300173b8:	e59d3014 	ldr	r3, [sp, #20]
300173bc:	e5933000 	ldr	r3, [r3]
300173c0:	e59d2014 	ldr	r2, [sp, #20]
300173c4:	e5922000 	ldr	r2, [r2]
300173c8:	e5921004 	ldr	r1, [r2, #4]
300173cc:	e59d200c 	ldr	r2, [sp, #12]
300173d0:	e0622001 	rsb	r2, r2, r1
300173d4:	e5832004 	str	r2, [r3, #4]
    timeout->next = timeouts->next;
300173d8:	e59d3014 	ldr	r3, [sp, #20]
300173dc:	e5932000 	ldr	r2, [r3]
300173e0:	e59d3018 	ldr	r3, [sp, #24]
300173e4:	e5832000 	str	r2, [r3]
    timeouts->next = timeout;
300173e8:	e59d3014 	ldr	r3, [sp, #20]
300173ec:	e59d2018 	ldr	r2, [sp, #24]
300173f0:	e5832000 	str	r2, [r3]
300173f4:	ea000034 	b	300174cc <sys_timeout+0x1c4>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
300173f8:	e59d3014 	ldr	r3, [sp, #20]
300173fc:	e5933000 	ldr	r3, [r3]
30017400:	e58d301c 	str	r3, [sp, #28]
30017404:	ea000029 	b	300174b0 <sys_timeout+0x1a8>
      timeout->time -= t->time;
30017408:	e59d3018 	ldr	r3, [sp, #24]
3001740c:	e5932004 	ldr	r2, [r3, #4]
30017410:	e59d301c 	ldr	r3, [sp, #28]
30017414:	e5933004 	ldr	r3, [r3, #4]
30017418:	e0632002 	rsb	r2, r3, r2
3001741c:	e59d3018 	ldr	r3, [sp, #24]
30017420:	e5832004 	str	r2, [r3, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
30017424:	e59d301c 	ldr	r3, [sp, #28]
30017428:	e5933000 	ldr	r3, [r3]
3001742c:	e3530000 	cmp	r3, #0
30017430:	0a000006 	beq	30017450 <sys_timeout+0x148>
30017434:	e59d301c 	ldr	r3, [sp, #28]
30017438:	e5933000 	ldr	r3, [r3]
3001743c:	e5932004 	ldr	r2, [r3, #4]
30017440:	e59d3018 	ldr	r3, [sp, #24]
30017444:	e5933004 	ldr	r3, [r3, #4]
30017448:	e1520003 	cmp	r2, r3
3001744c:	9a000014 	bls	300174a4 <sys_timeout+0x19c>
        if (t->next != NULL) {
30017450:	e59d301c 	ldr	r3, [sp, #28]
30017454:	e5933000 	ldr	r3, [r3]
30017458:	e3530000 	cmp	r3, #0
3001745c:	0a000008 	beq	30017484 <sys_timeout+0x17c>
          t->next->time -= timeout->time;
30017460:	e59d301c 	ldr	r3, [sp, #28]
30017464:	e5933000 	ldr	r3, [r3]
30017468:	e59d201c 	ldr	r2, [sp, #28]
3001746c:	e5922000 	ldr	r2, [r2]
30017470:	e5921004 	ldr	r1, [r2, #4]
30017474:	e59d2018 	ldr	r2, [sp, #24]
30017478:	e5922004 	ldr	r2, [r2, #4]
3001747c:	e0622001 	rsb	r2, r2, r1
30017480:	e5832004 	str	r2, [r3, #4]
        }
        timeout->next = t->next;
30017484:	e59d301c 	ldr	r3, [sp, #28]
30017488:	e5932000 	ldr	r2, [r3]
3001748c:	e59d3018 	ldr	r3, [sp, #24]
30017490:	e5832000 	str	r2, [r3]
        t->next = timeout;
30017494:	e59d301c 	ldr	r3, [sp, #28]
30017498:	e59d2018 	ldr	r2, [sp, #24]
3001749c:	e5832000 	str	r2, [r3]
        break;
300174a0:	ea000009 	b	300174cc <sys_timeout+0x1c4>
  if (timeouts->next->time > msecs) {
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
300174a4:	e59d301c 	ldr	r3, [sp, #28]
300174a8:	e5933000 	ldr	r3, [r3]
300174ac:	e58d301c 	str	r3, [sp, #28]
300174b0:	e59d301c 	ldr	r3, [sp, #28]
300174b4:	e3530000 	cmp	r3, #0
300174b8:	1affffd2 	bne	30017408 <sys_timeout+0x100>
300174bc:	ea000002 	b	300174cc <sys_timeout+0x1c4>
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
    return;
300174c0:	e1a00000 	nop			; (mov r0, r0)
300174c4:	ea000000 	b	300174cc <sys_timeout+0x1c4>
  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
    return;
300174c8:	e1a00000 	nop			; (mov r0, r0)
        t->next = timeout;
        break;
      }
    }
  }
}
300174cc:	e28dd024 	add	sp, sp, #36	; 0x24
300174d0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300174d4:	e12fff1e 	bx	lr

300174d8 <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
300174d8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300174dc:	e24dd01c 	sub	sp, sp, #28
300174e0:	e58d0004 	str	r0, [sp, #4]
300174e4:	e58d1000 	str	r1, [sp]
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
300174e8:	ebffd658 	bl	3000ce50 <sys_arch_timeouts>
300174ec:	e1a03000 	mov	r3, r0
300174f0:	e58d300c 	str	r3, [sp, #12]

  if (timeouts == NULL) {
300174f4:	e59d300c 	ldr	r3, [sp, #12]
300174f8:	e3530000 	cmp	r3, #0
300174fc:	0a000039 	beq	300175e8 <sys_untimeout+0x110>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
    return;
  }
  if (timeouts->next == NULL) {
30017500:	e59d300c 	ldr	r3, [sp, #12]
30017504:	e5933000 	ldr	r3, [r3]
30017508:	e3530000 	cmp	r3, #0
3001750c:	0a000037 	beq	300175f0 <sys_untimeout+0x118>
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
30017510:	e59d300c 	ldr	r3, [sp, #12]
30017514:	e5933000 	ldr	r3, [r3]
30017518:	e58d3014 	str	r3, [sp, #20]
3001751c:	e3a03000 	mov	r3, #0
30017520:	e58d3010 	str	r3, [sp, #16]
30017524:	ea00002b 	b	300175d8 <sys_untimeout+0x100>
    if ((t->h == h) && (t->arg == arg)) {
30017528:	e59d3014 	ldr	r3, [sp, #20]
3001752c:	e5932008 	ldr	r2, [r3, #8]
30017530:	e59d3004 	ldr	r3, [sp, #4]
30017534:	e1520003 	cmp	r2, r3
30017538:	1a000021 	bne	300175c4 <sys_untimeout+0xec>
3001753c:	e59d3014 	ldr	r3, [sp, #20]
30017540:	e593200c 	ldr	r2, [r3, #12]
30017544:	e59d3000 	ldr	r3, [sp]
30017548:	e1520003 	cmp	r2, r3
3001754c:	1a00001c 	bne	300175c4 <sys_untimeout+0xec>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
30017550:	e59d3010 	ldr	r3, [sp, #16]
30017554:	e3530000 	cmp	r3, #0
30017558:	1a000004 	bne	30017570 <sys_untimeout+0x98>
        timeouts->next = t->next;
3001755c:	e59d3014 	ldr	r3, [sp, #20]
30017560:	e5932000 	ldr	r2, [r3]
30017564:	e59d300c 	ldr	r3, [sp, #12]
30017568:	e5832000 	str	r2, [r3]
3001756c:	ea000003 	b	30017580 <sys_untimeout+0xa8>
      else
        prev_t->next = t->next;
30017570:	e59d3014 	ldr	r3, [sp, #20]
30017574:	e5932000 	ldr	r2, [r3]
30017578:	e59d3010 	ldr	r3, [sp, #16]
3001757c:	e5832000 	str	r2, [r3]
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
30017580:	e59d3014 	ldr	r3, [sp, #20]
30017584:	e5933000 	ldr	r3, [r3]
30017588:	e3530000 	cmp	r3, #0
3001758c:	0a000008 	beq	300175b4 <sys_untimeout+0xdc>
        t->next->time += t->time;
30017590:	e59d3014 	ldr	r3, [sp, #20]
30017594:	e5933000 	ldr	r3, [r3]
30017598:	e59d2014 	ldr	r2, [sp, #20]
3001759c:	e5922000 	ldr	r2, [r2]
300175a0:	e5921004 	ldr	r1, [r2, #4]
300175a4:	e59d2014 	ldr	r2, [sp, #20]
300175a8:	e5922004 	ldr	r2, [r2, #4]
300175ac:	e0812002 	add	r2, r1, r2
300175b0:	e5832004 	str	r2, [r3, #4]
      memp_free(MEMP_SYS_TIMEOUT, t);
300175b4:	e3a0000a 	mov	r0, #10
300175b8:	e59d1014 	ldr	r1, [sp, #20]
300175bc:	ebfff870 	bl	30015784 <memp_free>
      return;
300175c0:	ea00000b 	b	300175f4 <sys_untimeout+0x11c>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
300175c4:	e59d3014 	ldr	r3, [sp, #20]
300175c8:	e58d3010 	str	r3, [sp, #16]
300175cc:	e59d3014 	ldr	r3, [sp, #20]
300175d0:	e5933000 	ldr	r3, [r3]
300175d4:	e58d3014 	str	r3, [sp, #20]
300175d8:	e59d3014 	ldr	r3, [sp, #20]
300175dc:	e3530000 	cmp	r3, #0
300175e0:	1affffd0 	bne	30017528 <sys_untimeout+0x50>
        t->next->time += t->time;
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
300175e4:	ea000002 	b	300175f4 <sys_untimeout+0x11c>

  timeouts = sys_arch_timeouts();

  if (timeouts == NULL) {
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
    return;
300175e8:	e1a00000 	nop			; (mov r0, r0)
300175ec:	ea000000 	b	300175f4 <sys_untimeout+0x11c>
  }
  if (timeouts->next == NULL) {
    return;
300175f0:	e1a00000 	nop			; (mov r0, r0)
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
300175f4:	e28dd01c 	add	sp, sp, #28
300175f8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300175fc:	e12fff1e 	bx	lr

30017600 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
30017600:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30017604:	e24dd014 	sub	sp, sp, #20
30017608:	e58d0004 	str	r0, [sp, #4]
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;
3001760c:	e59d3004 	ldr	r3, [sp, #4]
30017610:	e58d300c 	str	r3, [sp, #12]

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
30017614:	e59d300c 	ldr	r3, [sp, #12]
30017618:	e3a02001 	mov	r2, #1
3001761c:	e1c320b0 	strh	r2, [r3]
  sys_sem_signal(*(sswt_cb->psem));
30017620:	e59d300c 	ldr	r3, [sp, #12]
30017624:	e5933004 	ldr	r3, [r3, #4]
30017628:	e5933000 	ldr	r3, [r3]
3001762c:	e1a00003 	mov	r0, r3
30017630:	ebffd538 	bl	3000cb18 <sys_sem_signal>
}
30017634:	e28dd014 	add	sp, sp, #20
30017638:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001763c:	e12fff1e 	bx	lr

30017640 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
30017640:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30017644:	e24dd014 	sub	sp, sp, #20
30017648:	e58d0004 	str	r0, [sp, #4]
3001764c:	e58d1000 	str	r1, [sp]
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
30017650:	e28d3004 	add	r3, sp, #4
30017654:	e58d300c 	str	r3, [sp, #12]
  sswt_cb.timeflag = 0;
30017658:	e3a03000 	mov	r3, #0
3001765c:	e1cd30b8 	strh	r3, [sp, #8]

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
30017660:	e59d3000 	ldr	r3, [sp]
30017664:	e3530000 	cmp	r3, #0
30017668:	0a000004 	beq	30017680 <sys_sem_wait_timeout+0x40>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
3001766c:	e28d3008 	add	r3, sp, #8
30017670:	e59d0000 	ldr	r0, [sp]
30017674:	e59f1048 	ldr	r1, [pc, #72]	; 300176c4 <sys_sem_wait_timeout+0x84>
30017678:	e1a02003 	mov	r2, r3
3001767c:	ebffff21 	bl	30017308 <sys_timeout>
  }
  sys_sem_wait(sem);
30017680:	e59d3004 	ldr	r3, [sp, #4]
30017684:	e1a00003 	mov	r0, r3
30017688:	ebfffeca 	bl	300171b8 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
3001768c:	e1dd30b8 	ldrh	r3, [sp, #8]
30017690:	e3530000 	cmp	r3, #0
30017694:	0a000001 	beq	300176a0 <sys_sem_wait_timeout+0x60>
    /* timeout */
    return 0;
30017698:	e3a03000 	mov	r3, #0
3001769c:	ea000004 	b	300176b4 <sys_sem_wait_timeout+0x74>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
300176a0:	e28d3008 	add	r3, sp, #8
300176a4:	e59f0018 	ldr	r0, [pc, #24]	; 300176c4 <sys_sem_wait_timeout+0x84>
300176a8:	e1a01003 	mov	r1, r3
300176ac:	ebffff89 	bl	300174d8 <sys_untimeout>
    return 1;
300176b0:	e3a03001 	mov	r3, #1
  }
}
300176b4:	e1a00003 	mov	r0, r3
300176b8:	e28dd014 	add	sp, sp, #20
300176bc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300176c0:	e12fff1e 	bx	lr
300176c4:	30017600 	.word	0x30017600

300176c8 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
300176c8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300176cc:	e24dd014 	sub	sp, sp, #20
300176d0:	e58d0004 	str	r0, [sp, #4]
  sys_sem_t delaysem = sys_sem_new(0);
300176d4:	e3a00000 	mov	r0, #0
300176d8:	ebffd4f9 	bl	3000cac4 <sys_sem_new>
300176dc:	e1a03000 	mov	r3, r0
300176e0:	e58d300c 	str	r3, [sp, #12]

  sys_sem_wait_timeout(delaysem, ms);
300176e4:	e59d000c 	ldr	r0, [sp, #12]
300176e8:	e59d1004 	ldr	r1, [sp, #4]
300176ec:	ebffffd3 	bl	30017640 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
300176f0:	e59d000c 	ldr	r0, [sp, #12]
300176f4:	ebffd4fe 	bl	3000caf4 <sys_sem_free>
}
300176f8:	e28dd014 	add	sp, sp, #20
300176fc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30017700:	e12fff1e 	bx	lr

30017704 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
30017704:	e92d4008 	push	{r3, lr}
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
30017708:	eb0005be 	bl	30018e08 <tcp_fasttmr>

  if (++tcp_timer & 1) {
3001770c:	e59f3034 	ldr	r3, [pc, #52]	; 30017748 <tcp_tmr+0x44>
30017710:	e5d33000 	ldrb	r3, [r3]
30017714:	e2833001 	add	r3, r3, #1
30017718:	e20320ff 	and	r2, r3, #255	; 0xff
3001771c:	e59f3024 	ldr	r3, [pc, #36]	; 30017748 <tcp_tmr+0x44>
30017720:	e5c32000 	strb	r2, [r3]
30017724:	e59f301c 	ldr	r3, [pc, #28]	; 30017748 <tcp_tmr+0x44>
30017728:	e5d33000 	ldrb	r3, [r3]
3001772c:	e2033001 	and	r3, r3, #1
30017730:	e20330ff 	and	r3, r3, #255	; 0xff
30017734:	e3530000 	cmp	r3, #0
30017738:	0a000000 	beq	30017740 <tcp_tmr+0x3c>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
3001773c:	eb0003fc 	bl	30018734 <tcp_slowtmr>
  }
}
30017740:	e8bd4008 	pop	{r3, lr}
30017744:	e12fff1e 	bx	lr
30017748:	30028f58 	.word	0x30028f58

3001774c <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
3001774c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30017750:	e24dd014 	sub	sp, sp, #20
30017754:	e58d0004 	str	r0, [sp, #4]
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
30017758:	e59d3004 	ldr	r3, [sp, #4]
3001775c:	e5d33010 	ldrb	r3, [r3, #16]
30017760:	e3530007 	cmp	r3, #7
30017764:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30017768:	ea000079 	b	30017954 <tcp_close+0x208>
3001776c:	3001778c 	.word	0x3001778c
30017770:	30017860 	.word	0x30017860
30017774:	3001788c 	.word	0x3001788c
30017778:	300178b8 	.word	0x300178b8
3001777c:	300178ec 	.word	0x300178ec
30017780:	30017954 	.word	0x30017954
30017784:	30017954 	.word	0x30017954
30017788:	30017920 	.word	0x30017920
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
3001778c:	e3a03000 	mov	r3, #0
30017790:	e5cd300f 	strb	r3, [sp, #15]
    TCP_RMV(&tcp_bound_pcbs, pcb);
30017794:	e59f321c 	ldr	r3, [pc, #540]	; 300179b8 <tcp_close+0x26c>
30017798:	e5932000 	ldr	r2, [r3]
3001779c:	e59d3004 	ldr	r3, [sp, #4]
300177a0:	e1520003 	cmp	r2, r3
300177a4:	1a000005 	bne	300177c0 <tcp_close+0x74>
300177a8:	e59f3208 	ldr	r3, [pc, #520]	; 300179b8 <tcp_close+0x26c>
300177ac:	e5933000 	ldr	r3, [r3]
300177b0:	e593200c 	ldr	r2, [r3, #12]
300177b4:	e59f31fc 	ldr	r3, [pc, #508]	; 300179b8 <tcp_close+0x26c>
300177b8:	e5832000 	str	r2, [r3]
300177bc:	ea00001e 	b	3001783c <tcp_close+0xf0>
300177c0:	e59f31f0 	ldr	r3, [pc, #496]	; 300179b8 <tcp_close+0x26c>
300177c4:	e5932000 	ldr	r2, [r3]
300177c8:	e59f31ec 	ldr	r3, [pc, #492]	; 300179bc <tcp_close+0x270>
300177cc:	e5832000 	str	r2, [r3]
300177d0:	ea000015 	b	3001782c <tcp_close+0xe0>
300177d4:	e59f31e0 	ldr	r3, [pc, #480]	; 300179bc <tcp_close+0x270>
300177d8:	e5933000 	ldr	r3, [r3]
300177dc:	e593300c 	ldr	r3, [r3, #12]
300177e0:	e3530000 	cmp	r3, #0
300177e4:	0a00000b 	beq	30017818 <tcp_close+0xcc>
300177e8:	e59f31cc 	ldr	r3, [pc, #460]	; 300179bc <tcp_close+0x270>
300177ec:	e5933000 	ldr	r3, [r3]
300177f0:	e593200c 	ldr	r2, [r3, #12]
300177f4:	e59d3004 	ldr	r3, [sp, #4]
300177f8:	e1520003 	cmp	r2, r3
300177fc:	1a000005 	bne	30017818 <tcp_close+0xcc>
30017800:	e59f31b4 	ldr	r3, [pc, #436]	; 300179bc <tcp_close+0x270>
30017804:	e5933000 	ldr	r3, [r3]
30017808:	e59d2004 	ldr	r2, [sp, #4]
3001780c:	e592200c 	ldr	r2, [r2, #12]
30017810:	e583200c 	str	r2, [r3, #12]
30017814:	ea000008 	b	3001783c <tcp_close+0xf0>
30017818:	e59f319c 	ldr	r3, [pc, #412]	; 300179bc <tcp_close+0x270>
3001781c:	e5933000 	ldr	r3, [r3]
30017820:	e593200c 	ldr	r2, [r3, #12]
30017824:	e59f3190 	ldr	r3, [pc, #400]	; 300179bc <tcp_close+0x270>
30017828:	e5832000 	str	r2, [r3]
3001782c:	e59f3188 	ldr	r3, [pc, #392]	; 300179bc <tcp_close+0x270>
30017830:	e5933000 	ldr	r3, [r3]
30017834:	e3530000 	cmp	r3, #0
30017838:	1affffe5 	bne	300177d4 <tcp_close+0x88>
3001783c:	e59d3004 	ldr	r3, [sp, #4]
30017840:	e3a02000 	mov	r2, #0
30017844:	e583200c 	str	r2, [r3, #12]
    memp_free(MEMP_TCP_PCB, pcb);
30017848:	e3a00002 	mov	r0, #2
3001784c:	e59d1004 	ldr	r1, [sp, #4]
30017850:	ebfff7cb 	bl	30015784 <memp_free>
    pcb = NULL;
30017854:	e3a03000 	mov	r3, #0
30017858:	e58d3004 	str	r3, [sp, #4]
    break;
3001785c:	ea000046 	b	3001797c <tcp_close+0x230>
  case LISTEN:
    err = ERR_OK;
30017860:	e3a03000 	mov	r3, #0
30017864:	e5cd300f 	strb	r3, [sp, #15]
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
30017868:	e59f0150 	ldr	r0, [pc, #336]	; 300179c0 <tcp_close+0x274>
3001786c:	e59d1004 	ldr	r1, [sp, #4]
30017870:	eb00076a 	bl	30019620 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
30017874:	e3a00003 	mov	r0, #3
30017878:	e59d1004 	ldr	r1, [sp, #4]
3001787c:	ebfff7c0 	bl	30015784 <memp_free>
    pcb = NULL;
30017880:	e3a03000 	mov	r3, #0
30017884:	e58d3004 	str	r3, [sp, #4]
    break;
30017888:	ea00003b 	b	3001797c <tcp_close+0x230>
  case SYN_SENT:
    err = ERR_OK;
3001788c:	e3a03000 	mov	r3, #0
30017890:	e5cd300f 	strb	r3, [sp, #15]
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
30017894:	e59f0128 	ldr	r0, [pc, #296]	; 300179c4 <tcp_close+0x278>
30017898:	e59d1004 	ldr	r1, [sp, #4]
3001789c:	eb00075f 	bl	30019620 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
300178a0:	e3a00002 	mov	r0, #2
300178a4:	e59d1004 	ldr	r1, [sp, #4]
300178a8:	ebfff7b5 	bl	30015784 <memp_free>
    pcb = NULL;
300178ac:	e3a03000 	mov	r3, #0
300178b0:	e58d3004 	str	r3, [sp, #4]
    snmp_inc_tcpattemptfails();
    break;
300178b4:	ea000030 	b	3001797c <tcp_close+0x230>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
300178b8:	e59d0004 	ldr	r0, [sp, #4]
300178bc:	e3a01001 	mov	r1, #1
300178c0:	eb0017d7 	bl	3001d824 <tcp_send_ctrl>
300178c4:	e1a03000 	mov	r3, r0
300178c8:	e20330ff 	and	r3, r3, #255	; 0xff
300178cc:	e5cd300f 	strb	r3, [sp, #15]
    if (err == ERR_OK) {
300178d0:	e1dd30df 	ldrsb	r3, [sp, #15]
300178d4:	e3530000 	cmp	r3, #0
300178d8:	1a000022 	bne	30017968 <tcp_close+0x21c>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
300178dc:	e59d3004 	ldr	r3, [sp, #4]
300178e0:	e3a02005 	mov	r2, #5
300178e4:	e5c32010 	strb	r2, [r3, #16]
    }
    break;
300178e8:	ea000023 	b	3001797c <tcp_close+0x230>
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
300178ec:	e59d0004 	ldr	r0, [sp, #4]
300178f0:	e3a01001 	mov	r1, #1
300178f4:	eb0017ca 	bl	3001d824 <tcp_send_ctrl>
300178f8:	e1a03000 	mov	r3, r0
300178fc:	e20330ff 	and	r3, r3, #255	; 0xff
30017900:	e5cd300f 	strb	r3, [sp, #15]
    if (err == ERR_OK) {
30017904:	e1dd30df 	ldrsb	r3, [sp, #15]
30017908:	e3530000 	cmp	r3, #0
3001790c:	1a000017 	bne	30017970 <tcp_close+0x224>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
30017910:	e59d3004 	ldr	r3, [sp, #4]
30017914:	e3a02005 	mov	r2, #5
30017918:	e5c32010 	strb	r2, [r3, #16]
    }
    break;
3001791c:	ea000016 	b	3001797c <tcp_close+0x230>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
30017920:	e59d0004 	ldr	r0, [sp, #4]
30017924:	e3a01001 	mov	r1, #1
30017928:	eb0017bd 	bl	3001d824 <tcp_send_ctrl>
3001792c:	e1a03000 	mov	r3, r0
30017930:	e20330ff 	and	r3, r3, #255	; 0xff
30017934:	e5cd300f 	strb	r3, [sp, #15]
    if (err == ERR_OK) {
30017938:	e1dd30df 	ldrsb	r3, [sp, #15]
3001793c:	e3530000 	cmp	r3, #0
30017940:	1a00000c 	bne	30017978 <tcp_close+0x22c>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
30017944:	e59d3004 	ldr	r3, [sp, #4]
30017948:	e3a02009 	mov	r2, #9
3001794c:	e5c32010 	strb	r2, [r3, #16]
    }
    break;
30017950:	ea000009 	b	3001797c <tcp_close+0x230>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
30017954:	e3a03000 	mov	r3, #0
30017958:	e5cd300f 	strb	r3, [sp, #15]
    pcb = NULL;
3001795c:	e3a03000 	mov	r3, #0
30017960:	e58d3004 	str	r3, [sp, #4]
30017964:	ea000004 	b	3001797c <tcp_close+0x230>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
30017968:	e1a00000 	nop			; (mov r0, r0)
3001796c:	ea000002 	b	3001797c <tcp_close+0x230>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
30017970:	e1a00000 	nop			; (mov r0, r0)
30017974:	ea000000 	b	3001797c <tcp_close+0x230>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    }
    break;
30017978:	e1a00000 	nop			; (mov r0, r0)
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
3001797c:	e59d3004 	ldr	r3, [sp, #4]
30017980:	e3530000 	cmp	r3, #0
30017984:	0a000004 	beq	3001799c <tcp_close+0x250>
30017988:	e1dd30df 	ldrsb	r3, [sp, #15]
3001798c:	e3530000 	cmp	r3, #0
30017990:	1a000001 	bne	3001799c <tcp_close+0x250>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
30017994:	e59d0004 	ldr	r0, [sp, #4]
30017998:	eb001a39 	bl	3001e284 <tcp_output>
  }
  return err;
3001799c:	e5dd300f 	ldrb	r3, [sp, #15]
300179a0:	e1a03c03 	lsl	r3, r3, #24
300179a4:	e1a03c43 	asr	r3, r3, #24
}
300179a8:	e1a00003 	mov	r0, r3
300179ac:	e28dd014 	add	sp, sp, #20
300179b0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300179b4:	e12fff1e 	bx	lr
300179b8:	3002b0e8 	.word	0x3002b0e8
300179bc:	3002a838 	.word	0x3002a838
300179c0:	3002a728 	.word	0x3002a728
300179c4:	3002a6e8 	.word	0x3002a6e8

300179c8 <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
300179c8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300179cc:	e24dd034 	sub	sp, sp, #52	; 0x34
300179d0:	e58d000c 	str	r0, [sp, #12]

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
300179d4:	e59d300c 	ldr	r3, [sp, #12]
300179d8:	e5d33010 	ldrb	r3, [r3, #16]
300179dc:	e353000a 	cmp	r3, #10
300179e0:	1a000006 	bne	30017a00 <tcp_abort+0x38>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
300179e4:	e59f0168 	ldr	r0, [pc, #360]	; 30017b54 <tcp_abort+0x18c>
300179e8:	e59d100c 	ldr	r1, [sp, #12]
300179ec:	eb00070b 	bl	30019620 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
300179f0:	e3a00002 	mov	r0, #2
300179f4:	e59d100c 	ldr	r1, [sp, #12]
300179f8:	ebfff761 	bl	30015784 <memp_free>
300179fc:	ea000051 	b	30017b48 <tcp_abort+0x180>
  } else {
    seqno = pcb->snd_nxt;
30017a00:	e59d300c 	ldr	r3, [sp, #12]
30017a04:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30017a08:	e58d301c 	str	r3, [sp, #28]
    ackno = pcb->rcv_nxt;
30017a0c:	e59d300c 	ldr	r3, [sp, #12]
30017a10:	e5933020 	ldr	r3, [r3, #32]
30017a14:	e58d3020 	str	r3, [sp, #32]
    ip_addr_set(&local_ip, &(pcb->local_ip));
30017a18:	e59d300c 	ldr	r3, [sp, #12]
30017a1c:	e3530000 	cmp	r3, #0
30017a20:	0a000002 	beq	30017a30 <tcp_abort+0x68>
30017a24:	e59d300c 	ldr	r3, [sp, #12]
30017a28:	e5933000 	ldr	r3, [r3]
30017a2c:	ea000000 	b	30017a34 <tcp_abort+0x6c>
30017a30:	e3a03000 	mov	r3, #0
30017a34:	e58d3014 	str	r3, [sp, #20]
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
30017a38:	e59d300c 	ldr	r3, [sp, #12]
30017a3c:	e2833004 	add	r3, r3, #4
30017a40:	e3530000 	cmp	r3, #0
30017a44:	0a000002 	beq	30017a54 <tcp_abort+0x8c>
30017a48:	e59d300c 	ldr	r3, [sp, #12]
30017a4c:	e5933004 	ldr	r3, [r3, #4]
30017a50:	ea000000 	b	30017a58 <tcp_abort+0x90>
30017a54:	e3a03000 	mov	r3, #0
30017a58:	e58d3018 	str	r3, [sp, #24]
    local_port = pcb->local_port;
30017a5c:	e59d300c 	ldr	r3, [sp, #12]
30017a60:	e1d331b8 	ldrh	r3, [r3, #24]
30017a64:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
    remote_port = pcb->remote_port;
30017a68:	e59d300c 	ldr	r3, [sp, #12]
30017a6c:	e1d331ba 	ldrh	r3, [r3, #26]
30017a70:	e1cd32b4 	strh	r3, [sp, #36]	; 0x24
#if LWIP_CALLBACK_API
    errf = pcb->errf;
30017a74:	e59d300c 	ldr	r3, [sp, #12]
30017a78:	e5933094 	ldr	r3, [r3, #148]	; 0x94
30017a7c:	e58d3028 	str	r3, [sp, #40]	; 0x28
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
30017a80:	e59d300c 	ldr	r3, [sp, #12]
30017a84:	e5933014 	ldr	r3, [r3, #20]
30017a88:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
30017a8c:	e59f00c4 	ldr	r0, [pc, #196]	; 30017b58 <tcp_abort+0x190>
30017a90:	e59d100c 	ldr	r1, [sp, #12]
30017a94:	eb0006e1 	bl	30019620 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
30017a98:	e59d300c 	ldr	r3, [sp, #12]
30017a9c:	e5933074 	ldr	r3, [r3, #116]	; 0x74
30017aa0:	e3530000 	cmp	r3, #0
30017aa4:	0a000003 	beq	30017ab8 <tcp_abort+0xf0>
      tcp_segs_free(pcb->unacked);
30017aa8:	e59d300c 	ldr	r3, [sp, #12]
30017aac:	e5933074 	ldr	r3, [r3, #116]	; 0x74
30017ab0:	e1a00003 	mov	r0, r3
30017ab4:	eb00051e 	bl	30018f34 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
30017ab8:	e59d300c 	ldr	r3, [sp, #12]
30017abc:	e5933070 	ldr	r3, [r3, #112]	; 0x70
30017ac0:	e3530000 	cmp	r3, #0
30017ac4:	0a000003 	beq	30017ad8 <tcp_abort+0x110>
      tcp_segs_free(pcb->unsent);
30017ac8:	e59d300c 	ldr	r3, [sp, #12]
30017acc:	e5933070 	ldr	r3, [r3, #112]	; 0x70
30017ad0:	e1a00003 	mov	r0, r3
30017ad4:	eb000516 	bl	30018f34 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
30017ad8:	e59d300c 	ldr	r3, [sp, #12]
30017adc:	e5933078 	ldr	r3, [r3, #120]	; 0x78
30017ae0:	e3530000 	cmp	r3, #0
30017ae4:	0a000003 	beq	30017af8 <tcp_abort+0x130>
      tcp_segs_free(pcb->ooseq);
30017ae8:	e59d300c 	ldr	r3, [sp, #12]
30017aec:	e5933078 	ldr	r3, [r3, #120]	; 0x78
30017af0:	e1a00003 	mov	r0, r3
30017af4:	eb00050e 	bl	30018f34 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
30017af8:	e3a00002 	mov	r0, #2
30017afc:	e59d100c 	ldr	r1, [sp, #12]
30017b00:	ebfff71f 	bl	30015784 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
30017b04:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30017b08:	e3530000 	cmp	r3, #0
30017b0c:	0a000004 	beq	30017b24 <tcp_abort+0x15c>
30017b10:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30017b14:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30017b18:	e3e01003 	mvn	r1, #3
30017b1c:	e1a0e00f 	mov	lr, pc
30017b20:	e12fff13 	bx	r3
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
30017b24:	e28d2014 	add	r2, sp, #20
30017b28:	e28d3018 	add	r3, sp, #24
30017b2c:	e1dd12b6 	ldrh	r1, [sp, #38]	; 0x26
30017b30:	e58d1000 	str	r1, [sp]
30017b34:	e1dd12b4 	ldrh	r1, [sp, #36]	; 0x24
30017b38:	e58d1004 	str	r1, [sp, #4]
30017b3c:	e59d001c 	ldr	r0, [sp, #28]
30017b40:	e59d1020 	ldr	r1, [sp, #32]
30017b44:	eb001d05 	bl	3001ef60 <tcp_rst>
  }
}
30017b48:	e28dd034 	add	sp, sp, #52	; 0x34
30017b4c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30017b50:	e12fff1e 	bx	lr
30017b54:	3002b1c4 	.word	0x3002b1c4
30017b58:	3002a6e8 	.word	0x3002a6e8

30017b5c <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
30017b5c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30017b60:	e24dd01c 	sub	sp, sp, #28
30017b64:	e58d000c 	str	r0, [sp, #12]
30017b68:	e58d1008 	str	r1, [sp, #8]
30017b6c:	e1a03002 	mov	r3, r2
30017b70:	e1cd30b6 	strh	r3, [sp, #6]
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);

  if (port == 0) {
30017b74:	e1dd30b6 	ldrh	r3, [sp, #6]
30017b78:	e3530000 	cmp	r3, #0
30017b7c:	1a000002 	bne	30017b8c <tcp_bind+0x30>
    port = tcp_new_port();
30017b80:	eb0001e5 	bl	3001831c <tcp_new_port>
30017b84:	e1a03000 	mov	r3, r0
30017b88:	e1cd30b6 	strh	r3, [sp, #6]
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
30017b8c:	e59f33cc 	ldr	r3, [pc, #972]	; 30017f60 <tcp_bind+0x404>
30017b90:	e5933000 	ldr	r3, [r3]
30017b94:	e58d3014 	str	r3, [sp, #20]
30017b98:	ea00002f 	b	30017c5c <tcp_bind+0x100>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
30017b9c:	e59d3014 	ldr	r3, [sp, #20]
30017ba0:	e1d331b8 	ldrh	r3, [r3, #24]
30017ba4:	e1dd20b6 	ldrh	r2, [sp, #6]
30017ba8:	e1520003 	cmp	r2, r3
30017bac:	1a000027 	bne	30017c50 <tcp_bind+0xf4>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017bb0:	e59d3014 	ldr	r3, [sp, #20]
30017bb4:	e3530000 	cmp	r3, #0
30017bb8:	0a000022 	beq	30017c48 <tcp_bind+0xec>
30017bbc:	e59d3014 	ldr	r3, [sp, #20]
30017bc0:	e5933000 	ldr	r3, [r3]
30017bc4:	e3530000 	cmp	r3, #0
30017bc8:	0a00001e 	beq	30017c48 <tcp_bind+0xec>
30017bcc:	e59d3008 	ldr	r3, [sp, #8]
30017bd0:	e3530000 	cmp	r3, #0
30017bd4:	0a00001b 	beq	30017c48 <tcp_bind+0xec>
          ip_addr_isany(ipaddr) ||
30017bd8:	e59d3008 	ldr	r3, [sp, #8]
30017bdc:	e5d32000 	ldrb	r2, [r3]
30017be0:	e5d31001 	ldrb	r1, [r3, #1]
30017be4:	e1a01401 	lsl	r1, r1, #8
30017be8:	e1812002 	orr	r2, r1, r2
30017bec:	e5d31002 	ldrb	r1, [r3, #2]
30017bf0:	e1a01801 	lsl	r1, r1, #16
30017bf4:	e1812002 	orr	r2, r1, r2
30017bf8:	e5d33003 	ldrb	r3, [r3, #3]
30017bfc:	e1a03c03 	lsl	r3, r3, #24
30017c00:	e1833002 	orr	r3, r3, r2
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017c04:	e3530000 	cmp	r3, #0
30017c08:	0a00000e 	beq	30017c48 <tcp_bind+0xec>
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
30017c0c:	e59d3014 	ldr	r3, [sp, #20]
30017c10:	e5932000 	ldr	r2, [r3]
30017c14:	e59d3008 	ldr	r3, [sp, #8]
30017c18:	e5d31000 	ldrb	r1, [r3]
30017c1c:	e5d30001 	ldrb	r0, [r3, #1]
30017c20:	e1a00400 	lsl	r0, r0, #8
30017c24:	e1801001 	orr	r1, r0, r1
30017c28:	e5d30002 	ldrb	r0, [r3, #2]
30017c2c:	e1a00800 	lsl	r0, r0, #16
30017c30:	e1801001 	orr	r1, r0, r1
30017c34:	e5d33003 	ldrb	r3, [r3, #3]
30017c38:	e1a03c03 	lsl	r3, r3, #24
30017c3c:	e1833001 	orr	r3, r3, r1
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017c40:	e1520003 	cmp	r2, r3
30017c44:	1a000001 	bne	30017c50 <tcp_bind+0xf4>
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
30017c48:	e3a030f6 	mov	r3, #246	; 0xf6
30017c4c:	ea0000bd 	b	30017f48 <tcp_bind+0x3ec>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
30017c50:	e59d3014 	ldr	r3, [sp, #20]
30017c54:	e593300c 	ldr	r3, [r3, #12]
30017c58:	e58d3014 	str	r3, [sp, #20]
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
30017c5c:	e59d3014 	ldr	r3, [sp, #20]
30017c60:	e3530000 	cmp	r3, #0
30017c64:	1affffcc 	bne	30017b9c <tcp_bind+0x40>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
30017c68:	e59f32f4 	ldr	r3, [pc, #756]	; 30017f64 <tcp_bind+0x408>
30017c6c:	e5933000 	ldr	r3, [r3]
30017c70:	e58d3014 	str	r3, [sp, #20]
30017c74:	ea00002f 	b	30017d38 <tcp_bind+0x1dc>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
30017c78:	e59d3014 	ldr	r3, [sp, #20]
30017c7c:	e1d331b8 	ldrh	r3, [r3, #24]
30017c80:	e1dd20b6 	ldrh	r2, [sp, #6]
30017c84:	e1520003 	cmp	r2, r3
30017c88:	1a000027 	bne	30017d2c <tcp_bind+0x1d0>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017c8c:	e59d3014 	ldr	r3, [sp, #20]
30017c90:	e3530000 	cmp	r3, #0
30017c94:	0a000022 	beq	30017d24 <tcp_bind+0x1c8>
30017c98:	e59d3014 	ldr	r3, [sp, #20]
30017c9c:	e5933000 	ldr	r3, [r3]
30017ca0:	e3530000 	cmp	r3, #0
30017ca4:	0a00001e 	beq	30017d24 <tcp_bind+0x1c8>
30017ca8:	e59d3008 	ldr	r3, [sp, #8]
30017cac:	e3530000 	cmp	r3, #0
30017cb0:	0a00001b 	beq	30017d24 <tcp_bind+0x1c8>
          ip_addr_isany(ipaddr) ||
30017cb4:	e59d3008 	ldr	r3, [sp, #8]
30017cb8:	e5d32000 	ldrb	r2, [r3]
30017cbc:	e5d31001 	ldrb	r1, [r3, #1]
30017cc0:	e1a01401 	lsl	r1, r1, #8
30017cc4:	e1812002 	orr	r2, r1, r2
30017cc8:	e5d31002 	ldrb	r1, [r3, #2]
30017ccc:	e1a01801 	lsl	r1, r1, #16
30017cd0:	e1812002 	orr	r2, r1, r2
30017cd4:	e5d33003 	ldrb	r3, [r3, #3]
30017cd8:	e1a03c03 	lsl	r3, r3, #24
30017cdc:	e1833002 	orr	r3, r3, r2
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017ce0:	e3530000 	cmp	r3, #0
30017ce4:	0a00000e 	beq	30017d24 <tcp_bind+0x1c8>
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
30017ce8:	e59d3014 	ldr	r3, [sp, #20]
30017cec:	e5932000 	ldr	r2, [r3]
30017cf0:	e59d3008 	ldr	r3, [sp, #8]
30017cf4:	e5d31000 	ldrb	r1, [r3]
30017cf8:	e5d30001 	ldrb	r0, [r3, #1]
30017cfc:	e1a00400 	lsl	r0, r0, #8
30017d00:	e1801001 	orr	r1, r0, r1
30017d04:	e5d30002 	ldrb	r0, [r3, #2]
30017d08:	e1a00800 	lsl	r0, r0, #16
30017d0c:	e1801001 	orr	r1, r0, r1
30017d10:	e5d33003 	ldrb	r3, [r3, #3]
30017d14:	e1a03c03 	lsl	r3, r3, #24
30017d18:	e1833001 	orr	r3, r3, r1
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017d1c:	e1520003 	cmp	r2, r3
30017d20:	1a000001 	bne	30017d2c <tcp_bind+0x1d0>
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
30017d24:	e3a030f6 	mov	r3, #246	; 0xf6
30017d28:	ea000086 	b	30017f48 <tcp_bind+0x3ec>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
30017d2c:	e59d3014 	ldr	r3, [sp, #20]
30017d30:	e593300c 	ldr	r3, [r3, #12]
30017d34:	e58d3014 	str	r3, [sp, #20]
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
30017d38:	e59d3014 	ldr	r3, [sp, #20]
30017d3c:	e3530000 	cmp	r3, #0
30017d40:	1affffcc 	bne	30017c78 <tcp_bind+0x11c>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
30017d44:	e59f321c 	ldr	r3, [pc, #540]	; 30017f68 <tcp_bind+0x40c>
30017d48:	e5933000 	ldr	r3, [r3]
30017d4c:	e58d3014 	str	r3, [sp, #20]
30017d50:	ea00002f 	b	30017e14 <tcp_bind+0x2b8>
    if (cpcb->local_port == port) {
30017d54:	e59d3014 	ldr	r3, [sp, #20]
30017d58:	e1d331b8 	ldrh	r3, [r3, #24]
30017d5c:	e1dd20b6 	ldrh	r2, [sp, #6]
30017d60:	e1520003 	cmp	r2, r3
30017d64:	1a000027 	bne	30017e08 <tcp_bind+0x2ac>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017d68:	e59d3014 	ldr	r3, [sp, #20]
30017d6c:	e3530000 	cmp	r3, #0
30017d70:	0a000022 	beq	30017e00 <tcp_bind+0x2a4>
30017d74:	e59d3014 	ldr	r3, [sp, #20]
30017d78:	e5933000 	ldr	r3, [r3]
30017d7c:	e3530000 	cmp	r3, #0
30017d80:	0a00001e 	beq	30017e00 <tcp_bind+0x2a4>
30017d84:	e59d3008 	ldr	r3, [sp, #8]
30017d88:	e3530000 	cmp	r3, #0
30017d8c:	0a00001b 	beq	30017e00 <tcp_bind+0x2a4>
          ip_addr_isany(ipaddr) ||
30017d90:	e59d3008 	ldr	r3, [sp, #8]
30017d94:	e5d32000 	ldrb	r2, [r3]
30017d98:	e5d31001 	ldrb	r1, [r3, #1]
30017d9c:	e1a01401 	lsl	r1, r1, #8
30017da0:	e1812002 	orr	r2, r1, r2
30017da4:	e5d31002 	ldrb	r1, [r3, #2]
30017da8:	e1a01801 	lsl	r1, r1, #16
30017dac:	e1812002 	orr	r2, r1, r2
30017db0:	e5d33003 	ldrb	r3, [r3, #3]
30017db4:	e1a03c03 	lsl	r3, r3, #24
30017db8:	e1833002 	orr	r3, r3, r2
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017dbc:	e3530000 	cmp	r3, #0
30017dc0:	0a00000e 	beq	30017e00 <tcp_bind+0x2a4>
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
30017dc4:	e59d3014 	ldr	r3, [sp, #20]
30017dc8:	e5932000 	ldr	r2, [r3]
30017dcc:	e59d3008 	ldr	r3, [sp, #8]
30017dd0:	e5d31000 	ldrb	r1, [r3]
30017dd4:	e5d30001 	ldrb	r0, [r3, #1]
30017dd8:	e1a00400 	lsl	r0, r0, #8
30017ddc:	e1801001 	orr	r1, r0, r1
30017de0:	e5d30002 	ldrb	r0, [r3, #2]
30017de4:	e1a00800 	lsl	r0, r0, #16
30017de8:	e1801001 	orr	r1, r0, r1
30017dec:	e5d33003 	ldrb	r3, [r3, #3]
30017df0:	e1a03c03 	lsl	r3, r3, #24
30017df4:	e1833001 	orr	r3, r3, r1
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017df8:	e1520003 	cmp	r2, r3
30017dfc:	1a000001 	bne	30017e08 <tcp_bind+0x2ac>
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
30017e00:	e3a030f6 	mov	r3, #246	; 0xf6
30017e04:	ea00004f 	b	30017f48 <tcp_bind+0x3ec>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
30017e08:	e59d3014 	ldr	r3, [sp, #20]
30017e0c:	e593300c 	ldr	r3, [r3, #12]
30017e10:	e58d3014 	str	r3, [sp, #20]
30017e14:	e59d3014 	ldr	r3, [sp, #20]
30017e18:	e3530000 	cmp	r3, #0
30017e1c:	1affffcc 	bne	30017d54 <tcp_bind+0x1f8>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
30017e20:	e59f3144 	ldr	r3, [pc, #324]	; 30017f6c <tcp_bind+0x410>
30017e24:	e5933000 	ldr	r3, [r3]
30017e28:	e58d3014 	str	r3, [sp, #20]
30017e2c:	ea000018 	b	30017e94 <tcp_bind+0x338>
    if (cpcb->local_port == port) {
30017e30:	e59d3014 	ldr	r3, [sp, #20]
30017e34:	e1d331b8 	ldrh	r3, [r3, #24]
30017e38:	e1dd20b6 	ldrh	r2, [sp, #6]
30017e3c:	e1520003 	cmp	r2, r3
30017e40:	1a000010 	bne	30017e88 <tcp_bind+0x32c>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
30017e44:	e59d3014 	ldr	r3, [sp, #20]
30017e48:	e5932000 	ldr	r2, [r3]
30017e4c:	e59d3008 	ldr	r3, [sp, #8]
30017e50:	e5d31000 	ldrb	r1, [r3]
30017e54:	e5d30001 	ldrb	r0, [r3, #1]
30017e58:	e1a00400 	lsl	r0, r0, #8
30017e5c:	e1801001 	orr	r1, r0, r1
30017e60:	e5d30002 	ldrb	r0, [r3, #2]
30017e64:	e1a00800 	lsl	r0, r0, #16
30017e68:	e1801001 	orr	r1, r0, r1
30017e6c:	e5d33003 	ldrb	r3, [r3, #3]
30017e70:	e1a03c03 	lsl	r3, r3, #24
30017e74:	e1833001 	orr	r3, r3, r1
30017e78:	e1520003 	cmp	r2, r3
30017e7c:	1a000001 	bne	30017e88 <tcp_bind+0x32c>
        return ERR_USE;
30017e80:	e3a030f6 	mov	r3, #246	; 0xf6
30017e84:	ea00002f 	b	30017f48 <tcp_bind+0x3ec>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
30017e88:	e59d3014 	ldr	r3, [sp, #20]
30017e8c:	e593300c 	ldr	r3, [r3, #12]
30017e90:	e58d3014 	str	r3, [sp, #20]
30017e94:	e59d3014 	ldr	r3, [sp, #20]
30017e98:	e3530000 	cmp	r3, #0
30017e9c:	1affffe3 	bne	30017e30 <tcp_bind+0x2d4>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
30017ea0:	e59d3008 	ldr	r3, [sp, #8]
30017ea4:	e3530000 	cmp	r3, #0
30017ea8:	0a00001a 	beq	30017f18 <tcp_bind+0x3bc>
30017eac:	e59d3008 	ldr	r3, [sp, #8]
30017eb0:	e5d32000 	ldrb	r2, [r3]
30017eb4:	e5d31001 	ldrb	r1, [r3, #1]
30017eb8:	e1a01401 	lsl	r1, r1, #8
30017ebc:	e1812002 	orr	r2, r1, r2
30017ec0:	e5d31002 	ldrb	r1, [r3, #2]
30017ec4:	e1a01801 	lsl	r1, r1, #16
30017ec8:	e1812002 	orr	r2, r1, r2
30017ecc:	e5d33003 	ldrb	r3, [r3, #3]
30017ed0:	e1a03c03 	lsl	r3, r3, #24
30017ed4:	e1833002 	orr	r3, r3, r2
30017ed8:	e3530000 	cmp	r3, #0
30017edc:	0a00000d 	beq	30017f18 <tcp_bind+0x3bc>
    //by pegasus0824
	  //pcb->local_ip = *ipaddr;
    pcb->local_ip.addr = ipaddr->addr;
30017ee0:	e59d3008 	ldr	r3, [sp, #8]
30017ee4:	e5d32000 	ldrb	r2, [r3]
30017ee8:	e5d31001 	ldrb	r1, [r3, #1]
30017eec:	e1a01401 	lsl	r1, r1, #8
30017ef0:	e1812002 	orr	r2, r1, r2
30017ef4:	e5d31002 	ldrb	r1, [r3, #2]
30017ef8:	e1a01801 	lsl	r1, r1, #16
30017efc:	e1812002 	orr	r2, r1, r2
30017f00:	e5d33003 	ldrb	r3, [r3, #3]
30017f04:	e1a03c03 	lsl	r3, r3, #24
30017f08:	e1833002 	orr	r3, r3, r2
30017f0c:	e1a02003 	mov	r2, r3
30017f10:	e59d300c 	ldr	r3, [sp, #12]
30017f14:	e5832000 	str	r2, [r3]
  }
  pcb->local_port = port;
30017f18:	e59d300c 	ldr	r3, [sp, #12]
30017f1c:	e1dd20b6 	ldrh	r2, [sp, #6]
30017f20:	e1c321b8 	strh	r2, [r3, #24]
  TCP_REG(&tcp_bound_pcbs, pcb);
30017f24:	e59f303c 	ldr	r3, [pc, #60]	; 30017f68 <tcp_bind+0x40c>
30017f28:	e5932000 	ldr	r2, [r3]
30017f2c:	e59d300c 	ldr	r3, [sp, #12]
30017f30:	e583200c 	str	r2, [r3, #12]
30017f34:	e59f302c 	ldr	r3, [pc, #44]	; 30017f68 <tcp_bind+0x40c>
30017f38:	e59d200c 	ldr	r2, [sp, #12]
30017f3c:	e5832000 	str	r2, [r3]
30017f40:	ebffe8fc 	bl	30012338 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
30017f44:	e3a03000 	mov	r3, #0
30017f48:	e1a03c03 	lsl	r3, r3, #24
30017f4c:	e1a03c43 	asr	r3, r3, #24
}
30017f50:	e1a00003 	mov	r0, r3
30017f54:	e28dd01c 	add	sp, sp, #28
30017f58:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30017f5c:	e12fff1e 	bx	lr
30017f60:	3002a728 	.word	0x3002a728
30017f64:	3002a6e8 	.word	0x3002a6e8
30017f68:	3002b0e8 	.word	0x3002b0e8
30017f6c:	3002b1c4 	.word	0x3002b1c4

30017f70 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
30017f70:	e24dd010 	sub	sp, sp, #16
30017f74:	e58d000c 	str	r0, [sp, #12]
30017f78:	e58d1008 	str	r1, [sp, #8]
30017f7c:	e1a03002 	mov	r3, r2
30017f80:	e5cd3007 	strb	r3, [sp, #7]
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
30017f84:	e3a030fc 	mov	r3, #252	; 0xfc
30017f88:	e1a03c03 	lsl	r3, r3, #24
30017f8c:	e1a03c43 	asr	r3, r3, #24
}
30017f90:	e1a00003 	mov	r0, r3
30017f94:	e28dd010 	add	sp, sp, #16
30017f98:	e12fff1e 	bx	lr

30017f9c <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
30017f9c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30017fa0:	e24dd014 	sub	sp, sp, #20
30017fa4:	e58d0004 	str	r0, [sp, #4]
30017fa8:	e1a03001 	mov	r3, r1
30017fac:	e5cd3003 	strb	r3, [sp, #3]

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);

  /* already listening? */
  if (pcb->state == LISTEN) {
30017fb0:	e59d3004 	ldr	r3, [sp, #4]
30017fb4:	e5d33010 	ldrb	r3, [r3, #16]
30017fb8:	e3530001 	cmp	r3, #1
30017fbc:	1a000001 	bne	30017fc8 <tcp_listen_with_backlog+0x2c>
    return pcb;
30017fc0:	e59d3004 	ldr	r3, [sp, #4]
30017fc4:	ea00006b 	b	30018178 <tcp_listen_with_backlog+0x1dc>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
30017fc8:	e3a00003 	mov	r0, #3
30017fcc:	ebfff587 	bl	300155f0 <memp_malloc>
30017fd0:	e1a03000 	mov	r3, r0
30017fd4:	e58d300c 	str	r3, [sp, #12]
  if (lpcb == NULL) {
30017fd8:	e59d300c 	ldr	r3, [sp, #12]
30017fdc:	e3530000 	cmp	r3, #0
30017fe0:	1a000001 	bne	30017fec <tcp_listen_with_backlog+0x50>
    return NULL;
30017fe4:	e3a03000 	mov	r3, #0
30017fe8:	ea000062 	b	30018178 <tcp_listen_with_backlog+0x1dc>
  }
  lpcb->callback_arg = pcb->callback_arg;
30017fec:	e59d3004 	ldr	r3, [sp, #4]
30017ff0:	e5932014 	ldr	r2, [r3, #20]
30017ff4:	e59d300c 	ldr	r3, [sp, #12]
30017ff8:	e5832014 	str	r2, [r3, #20]
  lpcb->local_port = pcb->local_port;
30017ffc:	e59d3004 	ldr	r3, [sp, #4]
30018000:	e1d321b8 	ldrh	r2, [r3, #24]
30018004:	e59d300c 	ldr	r3, [sp, #12]
30018008:	e1c321b8 	strh	r2, [r3, #24]
  lpcb->state = LISTEN;
3001800c:	e59d300c 	ldr	r3, [sp, #12]
30018010:	e3a02001 	mov	r2, #1
30018014:	e5c32010 	strb	r2, [r3, #16]
  lpcb->so_options = pcb->so_options;
30018018:	e59d3004 	ldr	r3, [sp, #4]
3001801c:	e1d320b8 	ldrh	r2, [r3, #8]
30018020:	e59d300c 	ldr	r3, [sp, #12]
30018024:	e1c320b8 	strh	r2, [r3, #8]
  lpcb->so_options |= SOF_ACCEPTCONN;
30018028:	e59d300c 	ldr	r3, [sp, #12]
3001802c:	e1d330b8 	ldrh	r3, [r3, #8]
30018030:	e3833002 	orr	r3, r3, #2
30018034:	e1a03803 	lsl	r3, r3, #16
30018038:	e1a02823 	lsr	r2, r3, #16
3001803c:	e59d300c 	ldr	r3, [sp, #12]
30018040:	e1c320b8 	strh	r2, [r3, #8]
  lpcb->ttl = pcb->ttl;
30018044:	e59d3004 	ldr	r3, [sp, #4]
30018048:	e5d3200b 	ldrb	r2, [r3, #11]
3001804c:	e59d300c 	ldr	r3, [sp, #12]
30018050:	e5c3200b 	strb	r2, [r3, #11]
  lpcb->tos = pcb->tos;
30018054:	e59d3004 	ldr	r3, [sp, #4]
30018058:	e5d3200a 	ldrb	r2, [r3, #10]
3001805c:	e59d300c 	ldr	r3, [sp, #12]
30018060:	e5c3200a 	strb	r2, [r3, #10]
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
30018064:	e59d3004 	ldr	r3, [sp, #4]
30018068:	e3530000 	cmp	r3, #0
3001806c:	0a000002 	beq	3001807c <tcp_listen_with_backlog+0xe0>
30018070:	e59d3004 	ldr	r3, [sp, #4]
30018074:	e5933000 	ldr	r3, [r3]
30018078:	ea000000 	b	30018080 <tcp_listen_with_backlog+0xe4>
3001807c:	e3a03000 	mov	r3, #0
30018080:	e59d200c 	ldr	r2, [sp, #12]
30018084:	e5823000 	str	r3, [r2]
  TCP_RMV(&tcp_bound_pcbs, pcb);
30018088:	e59f30f8 	ldr	r3, [pc, #248]	; 30018188 <tcp_listen_with_backlog+0x1ec>
3001808c:	e5932000 	ldr	r2, [r3]
30018090:	e59d3004 	ldr	r3, [sp, #4]
30018094:	e1520003 	cmp	r2, r3
30018098:	1a000005 	bne	300180b4 <tcp_listen_with_backlog+0x118>
3001809c:	e59f30e4 	ldr	r3, [pc, #228]	; 30018188 <tcp_listen_with_backlog+0x1ec>
300180a0:	e5933000 	ldr	r3, [r3]
300180a4:	e593200c 	ldr	r2, [r3, #12]
300180a8:	e59f30d8 	ldr	r3, [pc, #216]	; 30018188 <tcp_listen_with_backlog+0x1ec>
300180ac:	e5832000 	str	r2, [r3]
300180b0:	ea00001e 	b	30018130 <tcp_listen_with_backlog+0x194>
300180b4:	e59f30cc 	ldr	r3, [pc, #204]	; 30018188 <tcp_listen_with_backlog+0x1ec>
300180b8:	e5932000 	ldr	r2, [r3]
300180bc:	e59f30c8 	ldr	r3, [pc, #200]	; 3001818c <tcp_listen_with_backlog+0x1f0>
300180c0:	e5832000 	str	r2, [r3]
300180c4:	ea000015 	b	30018120 <tcp_listen_with_backlog+0x184>
300180c8:	e59f30bc 	ldr	r3, [pc, #188]	; 3001818c <tcp_listen_with_backlog+0x1f0>
300180cc:	e5933000 	ldr	r3, [r3]
300180d0:	e593300c 	ldr	r3, [r3, #12]
300180d4:	e3530000 	cmp	r3, #0
300180d8:	0a00000b 	beq	3001810c <tcp_listen_with_backlog+0x170>
300180dc:	e59f30a8 	ldr	r3, [pc, #168]	; 3001818c <tcp_listen_with_backlog+0x1f0>
300180e0:	e5933000 	ldr	r3, [r3]
300180e4:	e593200c 	ldr	r2, [r3, #12]
300180e8:	e59d3004 	ldr	r3, [sp, #4]
300180ec:	e1520003 	cmp	r2, r3
300180f0:	1a000005 	bne	3001810c <tcp_listen_with_backlog+0x170>
300180f4:	e59f3090 	ldr	r3, [pc, #144]	; 3001818c <tcp_listen_with_backlog+0x1f0>
300180f8:	e5933000 	ldr	r3, [r3]
300180fc:	e59d2004 	ldr	r2, [sp, #4]
30018100:	e592200c 	ldr	r2, [r2, #12]
30018104:	e583200c 	str	r2, [r3, #12]
30018108:	ea000008 	b	30018130 <tcp_listen_with_backlog+0x194>
3001810c:	e59f3078 	ldr	r3, [pc, #120]	; 3001818c <tcp_listen_with_backlog+0x1f0>
30018110:	e5933000 	ldr	r3, [r3]
30018114:	e593200c 	ldr	r2, [r3, #12]
30018118:	e59f306c 	ldr	r3, [pc, #108]	; 3001818c <tcp_listen_with_backlog+0x1f0>
3001811c:	e5832000 	str	r2, [r3]
30018120:	e59f3064 	ldr	r3, [pc, #100]	; 3001818c <tcp_listen_with_backlog+0x1f0>
30018124:	e5933000 	ldr	r3, [r3]
30018128:	e3530000 	cmp	r3, #0
3001812c:	1affffe5 	bne	300180c8 <tcp_listen_with_backlog+0x12c>
30018130:	e59d3004 	ldr	r3, [sp, #4]
30018134:	e3a02000 	mov	r2, #0
30018138:	e583200c 	str	r2, [r3, #12]
  memp_free(MEMP_TCP_PCB, pcb);
3001813c:	e3a00002 	mov	r0, #2
30018140:	e59d1004 	ldr	r1, [sp, #4]
30018144:	ebfff58e 	bl	30015784 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
30018148:	e59d300c 	ldr	r3, [sp, #12]
3001814c:	e59f203c 	ldr	r2, [pc, #60]	; 30018190 <tcp_listen_with_backlog+0x1f4>
30018150:	e583201c 	str	r2, [r3, #28]
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
30018154:	e59f3038 	ldr	r3, [pc, #56]	; 30018194 <tcp_listen_with_backlog+0x1f8>
30018158:	e5932000 	ldr	r2, [r3]
3001815c:	e59d300c 	ldr	r3, [sp, #12]
30018160:	e583200c 	str	r2, [r3, #12]
30018164:	e59f3028 	ldr	r3, [pc, #40]	; 30018194 <tcp_listen_with_backlog+0x1f8>
30018168:	e59d200c 	ldr	r2, [sp, #12]
3001816c:	e5832000 	str	r2, [r3]
30018170:	ebffe870 	bl	30012338 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
30018174:	e59d300c 	ldr	r3, [sp, #12]
}
30018178:	e1a00003 	mov	r0, r3
3001817c:	e28dd014 	add	sp, sp, #20
30018180:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30018184:	e12fff1e 	bx	lr
30018188:	3002b0e8 	.word	0x3002b0e8
3001818c:	3002a838 	.word	0x3002a838
30018190:	30017f70 	.word	0x30017f70
30018194:	3002a728 	.word	0x3002a728

30018198 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
30018198:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001819c:	e24dd00c 	sub	sp, sp, #12
300181a0:	e58d0004 	str	r0, [sp, #4]
300181a4:	e1a03001 	mov	r3, r1
300181a8:	e1cd30b2 	strh	r3, [sp, #2]
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
300181ac:	e59d3004 	ldr	r3, [sp, #4]
300181b0:	e1d332b4 	ldrh	r3, [r3, #36]	; 0x24
300181b4:	e1a02003 	mov	r2, r3
300181b8:	e1dd30b2 	ldrh	r3, [sp, #2]
300181bc:	e0823003 	add	r3, r2, r3
300181c0:	e3530b02 	cmp	r3, #2048	; 0x800
300181c4:	9a000006 	bls	300181e4 <tcp_recved+0x4c>
    pcb->rcv_wnd = TCP_WND;
300181c8:	e59d3004 	ldr	r3, [sp, #4]
300181cc:	e3a02b02 	mov	r2, #2048	; 0x800
300181d0:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
    pcb->rcv_ann_wnd = TCP_WND;
300181d4:	e59d3004 	ldr	r3, [sp, #4]
300181d8:	e3a02b02 	mov	r2, #2048	; 0x800
300181dc:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
300181e0:	ea000011 	b	3001822c <tcp_recved+0x94>
  } else {
    pcb->rcv_wnd += len;
300181e4:	e59d3004 	ldr	r3, [sp, #4]
300181e8:	e1d322b4 	ldrh	r2, [r3, #36]	; 0x24
300181ec:	e1dd30b2 	ldrh	r3, [sp, #2]
300181f0:	e0823003 	add	r3, r2, r3
300181f4:	e1a03803 	lsl	r3, r3, #16
300181f8:	e1a02823 	lsr	r2, r3, #16
300181fc:	e59d3004 	ldr	r3, [sp, #4]
30018200:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
    if (pcb->rcv_wnd >= pcb->mss) {
30018204:	e59d3004 	ldr	r3, [sp, #4]
30018208:	e1d322b4 	ldrh	r2, [r3, #36]	; 0x24
3001820c:	e59d3004 	ldr	r3, [sp, #4]
30018210:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
30018214:	e1520003 	cmp	r2, r3
30018218:	3a000003 	bcc	3001822c <tcp_recved+0x94>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
3001821c:	e59d3004 	ldr	r3, [sp, #4]
30018220:	e1d322b4 	ldrh	r2, [r3, #36]	; 0x24
30018224:	e59d3004 	ldr	r3, [sp, #4]
30018228:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
3001822c:	e59d3004 	ldr	r3, [sp, #4]
30018230:	e5d3301c 	ldrb	r3, [r3, #28]
30018234:	e2033001 	and	r3, r3, #1
30018238:	e3530000 	cmp	r3, #0
3001823c:	1a00001f 	bne	300182c0 <tcp_recved+0x128>
     !(pcb->flags & TF_ACK_NOW)) {
30018240:	e59d3004 	ldr	r3, [sp, #4]
30018244:	e5d3301c 	ldrb	r3, [r3, #28]
30018248:	e2033002 	and	r3, r3, #2
    if (pcb->rcv_wnd >= pcb->mss) {
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
3001824c:	e3530000 	cmp	r3, #0
30018250:	1a00001a 	bne	300182c0 <tcp_recved+0x128>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
30018254:	e59d3004 	ldr	r3, [sp, #4]
30018258:	e5d3301c 	ldrb	r3, [r3, #28]
3001825c:	e2033001 	and	r3, r3, #1
30018260:	e20330ff 	and	r3, r3, #255	; 0xff
30018264:	e3530000 	cmp	r3, #0
30018268:	0a00000d 	beq	300182a4 <tcp_recved+0x10c>
3001826c:	e59d3004 	ldr	r3, [sp, #4]
30018270:	e5d3301c 	ldrb	r3, [r3, #28]
30018274:	e20330fe 	and	r3, r3, #254	; 0xfe
30018278:	e59d2004 	ldr	r2, [sp, #4]
3001827c:	e5c2301c 	strb	r3, [r2, #28]
30018280:	e59d3004 	ldr	r3, [sp, #4]
30018284:	e5d3301c 	ldrb	r3, [r3, #28]
30018288:	e3833002 	orr	r3, r3, #2
3001828c:	e20320ff 	and	r2, r3, #255	; 0xff
30018290:	e59d3004 	ldr	r3, [sp, #4]
30018294:	e5c3201c 	strb	r2, [r3, #28]
30018298:	e59d0004 	ldr	r0, [sp, #4]
3001829c:	eb0017f8 	bl	3001e284 <tcp_output>
    if (pcb->rcv_wnd >= pcb->mss) {
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
300182a0:	ea00001a 	b	30018310 <tcp_recved+0x178>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
300182a4:	e59d3004 	ldr	r3, [sp, #4]
300182a8:	e5d3301c 	ldrb	r3, [r3, #28]
300182ac:	e3833001 	orr	r3, r3, #1
300182b0:	e20320ff 	and	r2, r3, #255	; 0xff
300182b4:	e59d3004 	ldr	r3, [sp, #4]
300182b8:	e5c3201c 	strb	r2, [r3, #28]
    if (pcb->rcv_wnd >= pcb->mss) {
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
300182bc:	ea000013 	b	30018310 <tcp_recved+0x178>
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
300182c0:	e59d3004 	ldr	r3, [sp, #4]
300182c4:	e5d3301c 	ldrb	r3, [r3, #28]
300182c8:	e2033001 	and	r3, r3, #1
300182cc:	e20330ff 	and	r3, r3, #255	; 0xff
300182d0:	e3530000 	cmp	r3, #0
300182d4:	0a00000d 	beq	30018310 <tcp_recved+0x178>
300182d8:	e59d3004 	ldr	r3, [sp, #4]
300182dc:	e1d322b4 	ldrh	r2, [r3, #36]	; 0x24
300182e0:	e3a03fff 	mov	r3, #1020	; 0x3fc
300182e4:	e2833003 	add	r3, r3, #3
300182e8:	e1520003 	cmp	r2, r3
300182ec:	9a000007 	bls	30018310 <tcp_recved+0x178>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
300182f0:	e59d3004 	ldr	r3, [sp, #4]
300182f4:	e5d3301c 	ldrb	r3, [r3, #28]
300182f8:	e3833002 	orr	r3, r3, #2
300182fc:	e20320ff 	and	r2, r3, #255	; 0xff
30018300:	e59d3004 	ldr	r3, [sp, #4]
30018304:	e5c3201c 	strb	r2, [r3, #28]
30018308:	e59d0004 	ldr	r0, [sp, #4]
3001830c:	eb0017dc 	bl	3001e284 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
30018310:	e28dd00c 	add	sp, sp, #12
30018314:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30018318:	e12fff1e 	bx	lr

3001831c <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
3001831c:	e24dd008 	sub	sp, sp, #8
30018320:	ea000004 	b	30018338 <tcp_new_port+0x1c>
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
30018324:	e1a00000 	nop			; (mov r0, r0)
30018328:	ea000002 	b	30018338 <tcp_new_port+0x1c>
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
3001832c:	e1a00000 	nop			; (mov r0, r0)
30018330:	ea000000 	b	30018338 <tcp_new_port+0x1c>
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
30018334:	e1a00000 	nop			; (mov r0, r0)
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
30018338:	e59f310c 	ldr	r3, [pc, #268]	; 3001844c <tcp_new_port+0x130>
3001833c:	e1d330b0 	ldrh	r3, [r3]
30018340:	e2833001 	add	r3, r3, #1
30018344:	e1a03803 	lsl	r3, r3, #16
30018348:	e1a02823 	lsr	r2, r3, #16
3001834c:	e59f30f8 	ldr	r3, [pc, #248]	; 3001844c <tcp_new_port+0x130>
30018350:	e1c320b0 	strh	r2, [r3]
30018354:	e59f30f0 	ldr	r3, [pc, #240]	; 3001844c <tcp_new_port+0x130>
30018358:	e1d330b0 	ldrh	r3, [r3]
3001835c:	e1a03803 	lsl	r3, r3, #16
30018360:	e1a03843 	asr	r3, r3, #16
30018364:	e3530000 	cmp	r3, #0
30018368:	aa000002 	bge	30018378 <tcp_new_port+0x5c>
    port = TCP_LOCAL_PORT_RANGE_START;
3001836c:	e59f30d8 	ldr	r3, [pc, #216]	; 3001844c <tcp_new_port+0x130>
30018370:	e3a02a01 	mov	r2, #4096	; 0x1000
30018374:	e1c320b0 	strh	r2, [r3]
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
30018378:	e59f30d0 	ldr	r3, [pc, #208]	; 30018450 <tcp_new_port+0x134>
3001837c:	e5933000 	ldr	r3, [r3]
30018380:	e58d3004 	str	r3, [sp, #4]
30018384:	ea000008 	b	300183ac <tcp_new_port+0x90>
    if (pcb->local_port == port) {
30018388:	e59d3004 	ldr	r3, [sp, #4]
3001838c:	e1d321b8 	ldrh	r2, [r3, #24]
30018390:	e59f30b4 	ldr	r3, [pc, #180]	; 3001844c <tcp_new_port+0x130>
30018394:	e1d330b0 	ldrh	r3, [r3]
30018398:	e1520003 	cmp	r2, r3
3001839c:	0affffe0 	beq	30018324 <tcp_new_port+0x8>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
300183a0:	e59d3004 	ldr	r3, [sp, #4]
300183a4:	e593300c 	ldr	r3, [r3, #12]
300183a8:	e58d3004 	str	r3, [sp, #4]
300183ac:	e59d3004 	ldr	r3, [sp, #4]
300183b0:	e3530000 	cmp	r3, #0
300183b4:	1afffff3 	bne	30018388 <tcp_new_port+0x6c>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
300183b8:	e59f3094 	ldr	r3, [pc, #148]	; 30018454 <tcp_new_port+0x138>
300183bc:	e5933000 	ldr	r3, [r3]
300183c0:	e58d3004 	str	r3, [sp, #4]
300183c4:	ea000008 	b	300183ec <tcp_new_port+0xd0>
    if (pcb->local_port == port) {
300183c8:	e59d3004 	ldr	r3, [sp, #4]
300183cc:	e1d321b8 	ldrh	r2, [r3, #24]
300183d0:	e59f3074 	ldr	r3, [pc, #116]	; 3001844c <tcp_new_port+0x130>
300183d4:	e1d330b0 	ldrh	r3, [r3]
300183d8:	e1520003 	cmp	r2, r3
300183dc:	0affffd2 	beq	3001832c <tcp_new_port+0x10>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
300183e0:	e59d3004 	ldr	r3, [sp, #4]
300183e4:	e593300c 	ldr	r3, [r3, #12]
300183e8:	e58d3004 	str	r3, [sp, #4]
300183ec:	e59d3004 	ldr	r3, [sp, #4]
300183f0:	e3530000 	cmp	r3, #0
300183f4:	1afffff3 	bne	300183c8 <tcp_new_port+0xac>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
300183f8:	e59f3058 	ldr	r3, [pc, #88]	; 30018458 <tcp_new_port+0x13c>
300183fc:	e5933000 	ldr	r3, [r3]
30018400:	e58d3004 	str	r3, [sp, #4]
30018404:	ea000008 	b	3001842c <tcp_new_port+0x110>
    if (pcb->local_port == port) {
30018408:	e59d3004 	ldr	r3, [sp, #4]
3001840c:	e1d321b8 	ldrh	r2, [r3, #24]
30018410:	e59f3034 	ldr	r3, [pc, #52]	; 3001844c <tcp_new_port+0x130>
30018414:	e1d330b0 	ldrh	r3, [r3]
30018418:	e1520003 	cmp	r2, r3
3001841c:	0affffc4 	beq	30018334 <tcp_new_port+0x18>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
30018420:	e59d3004 	ldr	r3, [sp, #4]
30018424:	e593300c 	ldr	r3, [r3, #12]
30018428:	e58d3004 	str	r3, [sp, #4]
3001842c:	e59d3004 	ldr	r3, [sp, #4]
30018430:	e3530000 	cmp	r3, #0
30018434:	1afffff3 	bne	30018408 <tcp_new_port+0xec>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
30018438:	e59f300c 	ldr	r3, [pc, #12]	; 3001844c <tcp_new_port+0x130>
3001843c:	e1d330b0 	ldrh	r3, [r3]
}
30018440:	e1a00003 	mov	r0, r3
30018444:	e28dd008 	add	sp, sp, #8
30018448:	e12fff1e 	bx	lr
3001844c:	300268d0 	.word	0x300268d0
30018450:	3002a6e8 	.word	0x3002a6e8
30018454:	3002b1c4 	.word	0x3002b1c4
30018458:	3002a728 	.word	0x3002a728

3001845c <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
3001845c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30018460:	e24dd034 	sub	sp, sp, #52	; 0x34
30018464:	e58d001c 	str	r0, [sp, #28]
30018468:	e58d1018 	str	r1, [sp, #24]
3001846c:	e58d3010 	str	r3, [sp, #16]
30018470:	e1cd21b6 	strh	r2, [sp, #22]
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
30018474:	e59d3018 	ldr	r3, [sp, #24]
30018478:	e3530000 	cmp	r3, #0
3001847c:	0a000015 	beq	300184d8 <tcp_connect+0x7c>
    //by pegasus0824
	//pcb->remote_ip = *ipaddr;
    pcb->remote_ip.addr = ipaddr->addr;
30018480:	e59d3018 	ldr	r3, [sp, #24]
30018484:	e5d32000 	ldrb	r2, [r3]
30018488:	e5d31001 	ldrb	r1, [r3, #1]
3001848c:	e1a01401 	lsl	r1, r1, #8
30018490:	e1812002 	orr	r2, r1, r2
30018494:	e5d31002 	ldrb	r1, [r3, #2]
30018498:	e1a01801 	lsl	r1, r1, #16
3001849c:	e1812002 	orr	r2, r1, r2
300184a0:	e5d33003 	ldrb	r3, [r3, #3]
300184a4:	e1a03c03 	lsl	r3, r3, #24
300184a8:	e1833002 	orr	r3, r3, r2
300184ac:	e1a02003 	mov	r2, r3
300184b0:	e59d301c 	ldr	r3, [sp, #28]
300184b4:	e5832004 	str	r2, [r3, #4]
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
300184b8:	e59d301c 	ldr	r3, [sp, #28]
300184bc:	e1dd21b6 	ldrh	r2, [sp, #22]
300184c0:	e1c321ba 	strh	r2, [r3, #26]
  if (pcb->local_port == 0) {
300184c4:	e59d301c 	ldr	r3, [sp, #28]
300184c8:	e1d331b8 	ldrh	r3, [r3, #24]
300184cc:	e3530000 	cmp	r3, #0
300184d0:	0a000002 	beq	300184e0 <tcp_connect+0x84>
300184d4:	ea000006 	b	300184f4 <tcp_connect+0x98>
  if (ipaddr != NULL) {
    //by pegasus0824
	//pcb->remote_ip = *ipaddr;
    pcb->remote_ip.addr = ipaddr->addr;
  } else {
    return ERR_VAL;
300184d8:	e3a030f8 	mov	r3, #248	; 0xf8
300184dc:	ea00008b 	b	30018710 <tcp_connect+0x2b4>
  }
  pcb->remote_port = port;
  if (pcb->local_port == 0) {
    pcb->local_port = tcp_new_port();
300184e0:	ebffff8d 	bl	3001831c <tcp_new_port>
300184e4:	e1a03000 	mov	r3, r0
300184e8:	e1a02003 	mov	r2, r3
300184ec:	e59d301c 	ldr	r3, [sp, #28]
300184f0:	e1c321b8 	strh	r2, [r3, #24]
  }
  iss = tcp_next_iss();
300184f4:	eb000499 	bl	30019760 <tcp_next_iss>
300184f8:	e1a03000 	mov	r3, r0
300184fc:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  pcb->rcv_nxt = 0;
30018500:	e59d301c 	ldr	r3, [sp, #28]
30018504:	e3a02000 	mov	r2, #0
30018508:	e5832020 	str	r2, [r3, #32]
  pcb->snd_nxt = iss;
3001850c:	e59d301c 	ldr	r3, [sp, #28]
30018510:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30018514:	e5832050 	str	r2, [r3, #80]	; 0x50
  pcb->lastack = iss - 1;
30018518:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3001851c:	e2432001 	sub	r2, r3, #1
30018520:	e59d301c 	ldr	r3, [sp, #28]
30018524:	e5832044 	str	r2, [r3, #68]	; 0x44
  pcb->snd_lbb = iss - 1;
30018528:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3001852c:	e2432001 	sub	r2, r3, #1
30018530:	e59d301c 	ldr	r3, [sp, #28]
30018534:	e5832064 	str	r2, [r3, #100]	; 0x64
  pcb->rcv_wnd = TCP_WND;
30018538:	e59d301c 	ldr	r3, [sp, #28]
3001853c:	e3a02b02 	mov	r2, #2048	; 0x800
30018540:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
  pcb->rcv_ann_wnd = TCP_WND;
30018544:	e59d301c 	ldr	r3, [sp, #28]
30018548:	e3a02b02 	mov	r2, #2048	; 0x800
3001854c:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
  pcb->snd_wnd = TCP_WND;
30018550:	e59d301c 	ldr	r3, [sp, #28]
30018554:	e3a02b02 	mov	r2, #2048	; 0x800
30018558:	e1c325b8 	strh	r2, [r3, #88]	; 0x58
  /* The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
3001855c:	e59d301c 	ldr	r3, [sp, #28]
30018560:	e3a02080 	mov	r2, #128	; 0x80
30018564:	e1c323b0 	strh	r2, [r3, #48]	; 0x30
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
30018568:	e59d301c 	ldr	r3, [sp, #28]
3001856c:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
30018570:	e1a00003 	mov	r0, r3
30018574:	e59d1018 	ldr	r1, [sp, #24]
30018578:	eb000485 	bl	30019794 <tcp_eff_send_mss>
3001857c:	e1a03000 	mov	r3, r0
30018580:	e1a02003 	mov	r2, r3
30018584:	e59d301c 	ldr	r3, [sp, #28]
30018588:	e1c323b0 	strh	r2, [r3, #48]	; 0x30
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
3001858c:	e59d301c 	ldr	r3, [sp, #28]
30018590:	e3a02001 	mov	r2, #1
30018594:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
  pcb->ssthresh = pcb->mss * 10;
30018598:	e59d301c 	ldr	r3, [sp, #28]
3001859c:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
300185a0:	e1a02003 	mov	r2, r3
300185a4:	e1a02102 	lsl	r2, r2, #2
300185a8:	e0823003 	add	r3, r2, r3
300185ac:	e1a03083 	lsl	r3, r3, #1
300185b0:	e1a03803 	lsl	r3, r3, #16
300185b4:	e1a02823 	lsr	r2, r3, #16
300185b8:	e59d301c 	ldr	r3, [sp, #28]
300185bc:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
  pcb->state = SYN_SENT;
300185c0:	e59d301c 	ldr	r3, [sp, #28]
300185c4:	e3a02002 	mov	r2, #2
300185c8:	e5c32010 	strb	r2, [r3, #16]
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
300185cc:	e59d301c 	ldr	r3, [sp, #28]
300185d0:	e59d2010 	ldr	r2, [sp, #16]
300185d4:	e5832088 	str	r2, [r3, #136]	; 0x88
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
300185d8:	e59f3148 	ldr	r3, [pc, #328]	; 30018728 <tcp_connect+0x2cc>
300185dc:	e5932000 	ldr	r2, [r3]
300185e0:	e59d301c 	ldr	r3, [sp, #28]
300185e4:	e1520003 	cmp	r2, r3
300185e8:	1a000005 	bne	30018604 <tcp_connect+0x1a8>
300185ec:	e59f3134 	ldr	r3, [pc, #308]	; 30018728 <tcp_connect+0x2cc>
300185f0:	e5933000 	ldr	r3, [r3]
300185f4:	e593200c 	ldr	r2, [r3, #12]
300185f8:	e59f3128 	ldr	r3, [pc, #296]	; 30018728 <tcp_connect+0x2cc>
300185fc:	e5832000 	str	r2, [r3]
30018600:	ea00001e 	b	30018680 <tcp_connect+0x224>
30018604:	e59f311c 	ldr	r3, [pc, #284]	; 30018728 <tcp_connect+0x2cc>
30018608:	e5932000 	ldr	r2, [r3]
3001860c:	e59f3118 	ldr	r3, [pc, #280]	; 3001872c <tcp_connect+0x2d0>
30018610:	e5832000 	str	r2, [r3]
30018614:	ea000015 	b	30018670 <tcp_connect+0x214>
30018618:	e59f310c 	ldr	r3, [pc, #268]	; 3001872c <tcp_connect+0x2d0>
3001861c:	e5933000 	ldr	r3, [r3]
30018620:	e593300c 	ldr	r3, [r3, #12]
30018624:	e3530000 	cmp	r3, #0
30018628:	0a00000b 	beq	3001865c <tcp_connect+0x200>
3001862c:	e59f30f8 	ldr	r3, [pc, #248]	; 3001872c <tcp_connect+0x2d0>
30018630:	e5933000 	ldr	r3, [r3]
30018634:	e593200c 	ldr	r2, [r3, #12]
30018638:	e59d301c 	ldr	r3, [sp, #28]
3001863c:	e1520003 	cmp	r2, r3
30018640:	1a000005 	bne	3001865c <tcp_connect+0x200>
30018644:	e59f30e0 	ldr	r3, [pc, #224]	; 3001872c <tcp_connect+0x2d0>
30018648:	e5933000 	ldr	r3, [r3]
3001864c:	e59d201c 	ldr	r2, [sp, #28]
30018650:	e592200c 	ldr	r2, [r2, #12]
30018654:	e583200c 	str	r2, [r3, #12]
30018658:	ea000008 	b	30018680 <tcp_connect+0x224>
3001865c:	e59f30c8 	ldr	r3, [pc, #200]	; 3001872c <tcp_connect+0x2d0>
30018660:	e5933000 	ldr	r3, [r3]
30018664:	e593200c 	ldr	r2, [r3, #12]
30018668:	e59f30bc 	ldr	r3, [pc, #188]	; 3001872c <tcp_connect+0x2d0>
3001866c:	e5832000 	str	r2, [r3]
30018670:	e59f30b4 	ldr	r3, [pc, #180]	; 3001872c <tcp_connect+0x2d0>
30018674:	e5933000 	ldr	r3, [r3]
30018678:	e3530000 	cmp	r3, #0
3001867c:	1affffe5 	bne	30018618 <tcp_connect+0x1bc>
30018680:	e59d301c 	ldr	r3, [sp, #28]
30018684:	e3a02000 	mov	r2, #0
30018688:	e583200c 	str	r2, [r3, #12]
  TCP_REG(&tcp_active_pcbs, pcb);
3001868c:	e59f309c 	ldr	r3, [pc, #156]	; 30018730 <tcp_connect+0x2d4>
30018690:	e5932000 	ldr	r2, [r3]
30018694:	e59d301c 	ldr	r3, [sp, #28]
30018698:	e583200c 	str	r2, [r3, #12]
3001869c:	e59f308c 	ldr	r3, [pc, #140]	; 30018730 <tcp_connect+0x2d4>
300186a0:	e59d201c 	ldr	r2, [sp, #28]
300186a4:	e5832000 	str	r2, [r3]
300186a8:	ebffe722 	bl	30012338 <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
300186ac:	e3a00781 	mov	r0, #33816576	; 0x2040000
300186b0:	e2800080 	add	r0, r0, #128	; 0x80
300186b4:	ebffec9f 	bl	30013938 <htonl>
300186b8:	e1a03000 	mov	r3, r0
300186bc:	e58d3024 	str	r3, [sp, #36]	; 0x24

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
300186c0:	e28d3024 	add	r3, sp, #36	; 0x24
300186c4:	e3a02000 	mov	r2, #0
300186c8:	e58d2000 	str	r2, [sp]
300186cc:	e58d3004 	str	r3, [sp, #4]
300186d0:	e3a03004 	mov	r3, #4
300186d4:	e58d3008 	str	r3, [sp, #8]
300186d8:	e59d001c 	ldr	r0, [sp, #28]
300186dc:	e3a01000 	mov	r1, #0
300186e0:	e3a02000 	mov	r2, #0
300186e4:	e3a03002 	mov	r3, #2
300186e8:	eb001498 	bl	3001d950 <tcp_enqueue>
300186ec:	e1a03000 	mov	r3, r0
300186f0:	e20330ff 	and	r3, r3, #255	; 0xff
300186f4:	e5cd302b 	strb	r3, [sp, #43]	; 0x2b
  if (ret == ERR_OK) { 
300186f8:	e1dd32db 	ldrsb	r3, [sp, #43]	; 0x2b
300186fc:	e3530000 	cmp	r3, #0
30018700:	1a000001 	bne	3001870c <tcp_connect+0x2b0>
    tcp_output(pcb);
30018704:	e59d001c 	ldr	r0, [sp, #28]
30018708:	eb0016dd 	bl	3001e284 <tcp_output>
  }
  return ret;
3001870c:	e5dd302b 	ldrb	r3, [sp, #43]	; 0x2b
30018710:	e1a03c03 	lsl	r3, r3, #24
30018714:	e1a03c43 	asr	r3, r3, #24
} 
30018718:	e1a00003 	mov	r0, r3
3001871c:	e28dd034 	add	sp, sp, #52	; 0x34
30018720:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30018724:	e12fff1e 	bx	lr
30018728:	3002b0e8 	.word	0x3002b0e8
3001872c:	3002a838 	.word	0x3002a838
30018730:	3002a6e8 	.word	0x3002a6e8

30018734 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
30018734:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30018738:	e24dd014 	sub	sp, sp, #20
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
3001873c:	e3a03000 	mov	r3, #0
30018740:	e5cd300f 	strb	r3, [sp, #15]

  ++tcp_ticks;
30018744:	e59f36a4 	ldr	r3, [pc, #1700]	; 30018df0 <tcp_slowtmr+0x6bc>
30018748:	e5933000 	ldr	r3, [r3]
3001874c:	e2832001 	add	r2, r3, #1
30018750:	e59f3698 	ldr	r3, [pc, #1688]	; 30018df0 <tcp_slowtmr+0x6bc>
30018754:	e5832000 	str	r2, [r3]

  /* Steps through all of the active PCBs. */
  prev = NULL;
30018758:	e3a03000 	mov	r3, #0
3001875c:	e58d3008 	str	r3, [sp, #8]
  pcb = tcp_active_pcbs;
30018760:	e59f368c 	ldr	r3, [pc, #1676]	; 30018df4 <tcp_slowtmr+0x6c0>
30018764:	e5933000 	ldr	r3, [r3]
30018768:	e58d3000 	str	r3, [sp]
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
3001876c:	ea000165 	b	30018d08 <tcp_slowtmr+0x5d4>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
30018770:	e3a03000 	mov	r3, #0
30018774:	e5cd300e 	strb	r3, [sp, #14]

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
30018778:	e59d3000 	ldr	r3, [sp]
3001877c:	e5d33010 	ldrb	r3, [r3, #16]
30018780:	e3530002 	cmp	r3, #2
30018784:	1a000007 	bne	300187a8 <tcp_slowtmr+0x74>
30018788:	e59d3000 	ldr	r3, [sp]
3001878c:	e5d33042 	ldrb	r3, [r3, #66]	; 0x42
30018790:	e3530006 	cmp	r3, #6
30018794:	1a000003 	bne	300187a8 <tcp_slowtmr+0x74>
      ++pcb_remove;
30018798:	e5dd300e 	ldrb	r3, [sp, #14]
3001879c:	e2833001 	add	r3, r3, #1
300187a0:	e5cd300e 	strb	r3, [sp, #14]
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
300187a4:	ea000084 	b	300189bc <tcp_slowtmr+0x288>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
300187a8:	e59d3000 	ldr	r3, [sp]
300187ac:	e5d33042 	ldrb	r3, [r3, #66]	; 0x42
300187b0:	e353000c 	cmp	r3, #12
300187b4:	1a000003 	bne	300187c8 <tcp_slowtmr+0x94>
      ++pcb_remove;
300187b8:	e5dd300e 	ldrb	r3, [sp, #14]
300187bc:	e2833001 	add	r3, r3, #1
300187c0:	e5cd300e 	strb	r3, [sp, #14]
300187c4:	ea00007c 	b	300189bc <tcp_slowtmr+0x288>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
300187c8:	e59d3000 	ldr	r3, [sp]
300187cc:	e5d330a0 	ldrb	r3, [r3, #160]	; 0xa0
300187d0:	e3530000 	cmp	r3, #0
300187d4:	0a00001d 	beq	30018850 <tcp_slowtmr+0x11c>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
300187d8:	e59d3000 	ldr	r3, [sp]
300187dc:	e593309c 	ldr	r3, [r3, #156]	; 0x9c
300187e0:	e2832001 	add	r2, r3, #1
300187e4:	e59d3000 	ldr	r3, [sp]
300187e8:	e583209c 	str	r2, [r3, #156]	; 0x9c
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
300187ec:	e59d3000 	ldr	r3, [sp]
300187f0:	e593209c 	ldr	r2, [r3, #156]	; 0x9c
300187f4:	e59d3000 	ldr	r3, [sp]
300187f8:	e5d330a0 	ldrb	r3, [r3, #160]	; 0xa0
300187fc:	e2433001 	sub	r3, r3, #1
30018800:	e59f15f0 	ldr	r1, [pc, #1520]	; 30018df8 <tcp_slowtmr+0x6c4>
30018804:	e7d13003 	ldrb	r3, [r1, r3]
30018808:	e1520003 	cmp	r2, r3
3001880c:	3a000069 	bcc	300189b8 <tcp_slowtmr+0x284>
          pcb->persist_cnt = 0;
30018810:	e59d3000 	ldr	r3, [sp]
30018814:	e3a02000 	mov	r2, #0
30018818:	e583209c 	str	r2, [r3, #156]	; 0x9c
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
3001881c:	e59d3000 	ldr	r3, [sp]
30018820:	e5d330a0 	ldrb	r3, [r3, #160]	; 0xa0
30018824:	e3530006 	cmp	r3, #6
30018828:	8a000005 	bhi	30018844 <tcp_slowtmr+0x110>
            pcb->persist_backoff++;
3001882c:	e59d3000 	ldr	r3, [sp]
30018830:	e5d330a0 	ldrb	r3, [r3, #160]	; 0xa0
30018834:	e2833001 	add	r3, r3, #1
30018838:	e20320ff 	and	r2, r3, #255	; 0xff
3001883c:	e59d3000 	ldr	r3, [sp]
30018840:	e5c320a0 	strb	r2, [r3, #160]	; 0xa0
          }
          tcp_zero_window_probe(pcb);
30018844:	e59d0000 	ldr	r0, [sp]
30018848:	eb001c04 	bl	3001f860 <tcp_zero_window_probe>
3001884c:	ea00005a 	b	300189bc <tcp_slowtmr+0x288>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
30018850:	e59d3000 	ldr	r3, [sp]
30018854:	e1d332be 	ldrh	r3, [r3, #46]	; 0x2e
30018858:	e1a03803 	lsl	r3, r3, #16
3001885c:	e1a03843 	asr	r3, r3, #16
30018860:	e3530000 	cmp	r3, #0
30018864:	ba000006 	blt	30018884 <tcp_slowtmr+0x150>
          ++pcb->rtime;
30018868:	e59d3000 	ldr	r3, [sp]
3001886c:	e1d332be 	ldrh	r3, [r3, #46]	; 0x2e
30018870:	e2833001 	add	r3, r3, #1
30018874:	e1a03803 	lsl	r3, r3, #16
30018878:	e1a02823 	lsr	r2, r3, #16
3001887c:	e59d3000 	ldr	r3, [sp]
30018880:	e1c322be 	strh	r2, [r3, #46]	; 0x2e

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
30018884:	e59d3000 	ldr	r3, [sp]
30018888:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001888c:	e3530000 	cmp	r3, #0
30018890:	0a000049 	beq	300189bc <tcp_slowtmr+0x288>
30018894:	e59d3000 	ldr	r3, [sp]
30018898:	e1d322be 	ldrh	r2, [r3, #46]	; 0x2e
3001889c:	e59d3000 	ldr	r3, [sp]
300188a0:	e1d334b0 	ldrh	r3, [r3, #64]	; 0x40
300188a4:	e1a02802 	lsl	r2, r2, #16
300188a8:	e1a02842 	asr	r2, r2, #16
300188ac:	e1a03803 	lsl	r3, r3, #16
300188b0:	e1a03843 	asr	r3, r3, #16
300188b4:	e1520003 	cmp	r2, r3
300188b8:	ba00003f 	blt	300189bc <tcp_slowtmr+0x288>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
300188bc:	e59d3000 	ldr	r3, [sp]
300188c0:	e5d33010 	ldrb	r3, [r3, #16]
300188c4:	e3530002 	cmp	r3, #2
300188c8:	0a000016 	beq	30018928 <tcp_slowtmr+0x1f4>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
300188cc:	e59d3000 	ldr	r3, [sp]
300188d0:	e1d333bc 	ldrh	r3, [r3, #60]	; 0x3c
300188d4:	e1a03803 	lsl	r3, r3, #16
300188d8:	e1a03843 	asr	r3, r3, #16
300188dc:	e1a031c3 	asr	r3, r3, #3
300188e0:	e1a03803 	lsl	r3, r3, #16
300188e4:	e1a03823 	lsr	r3, r3, #16
300188e8:	e1a03803 	lsl	r3, r3, #16
300188ec:	e1a02843 	asr	r2, r3, #16
300188f0:	e59d3000 	ldr	r3, [sp]
300188f4:	e1d333be 	ldrh	r3, [r3, #62]	; 0x3e
300188f8:	e1a03803 	lsl	r3, r3, #16
300188fc:	e1a03843 	asr	r3, r3, #16
30018900:	e0822003 	add	r2, r2, r3
30018904:	e59d3000 	ldr	r3, [sp]
30018908:	e5d33042 	ldrb	r3, [r3, #66]	; 0x42
3001890c:	e59f14e8 	ldr	r1, [pc, #1256]	; 30018dfc <tcp_slowtmr+0x6c8>
30018910:	e7d13003 	ldrb	r3, [r1, r3]
30018914:	e1a03312 	lsl	r3, r2, r3
30018918:	e1a03803 	lsl	r3, r3, #16
3001891c:	e1a02823 	lsr	r2, r3, #16
30018920:	e59d3000 	ldr	r3, [sp]
30018924:	e1c324b0 	strh	r2, [r3, #64]	; 0x40
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
30018928:	e59d3000 	ldr	r3, [sp]
3001892c:	e3a02000 	mov	r2, #0
30018930:	e1c322be 	strh	r2, [r3, #46]	; 0x2e

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
30018934:	e59d3000 	ldr	r3, [sp]
30018938:	e1d325b8 	ldrh	r2, [r3, #88]	; 0x58
3001893c:	e59d3000 	ldr	r3, [sp]
30018940:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
30018944:	e1520003 	cmp	r2, r3
30018948:	31a03002 	movcc	r3, r2
3001894c:	e1cd30bc 	strh	r3, [sp, #12]
          pcb->ssthresh = eff_wnd >> 1;
30018950:	e1dd30bc 	ldrh	r3, [sp, #12]
30018954:	e1a030a3 	lsr	r3, r3, #1
30018958:	e1a03803 	lsl	r3, r3, #16
3001895c:	e1a02823 	lsr	r2, r3, #16
30018960:	e59d3000 	ldr	r3, [sp]
30018964:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
          if (pcb->ssthresh < pcb->mss) {
30018968:	e59d3000 	ldr	r3, [sp]
3001896c:	e1d324bc 	ldrh	r2, [r3, #76]	; 0x4c
30018970:	e59d3000 	ldr	r3, [sp]
30018974:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
30018978:	e1520003 	cmp	r2, r3
3001897c:	2a000006 	bcs	3001899c <tcp_slowtmr+0x268>
            pcb->ssthresh = pcb->mss * 2;
30018980:	e59d3000 	ldr	r3, [sp]
30018984:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
30018988:	e1a03083 	lsl	r3, r3, #1
3001898c:	e1a03803 	lsl	r3, r3, #16
30018990:	e1a02823 	lsr	r2, r3, #16
30018994:	e59d3000 	ldr	r3, [sp]
30018998:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
          }
          pcb->cwnd = pcb->mss;
3001899c:	e59d3000 	ldr	r3, [sp]
300189a0:	e1d323b0 	ldrh	r2, [r3, #48]	; 0x30
300189a4:	e59d3000 	ldr	r3, [sp]
300189a8:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
300189ac:	e59d0000 	ldr	r0, [sp]
300189b0:	eb001a4a 	bl	3001f2e0 <tcp_rexmit_rto>
300189b4:	ea000000 	b	300189bc <tcp_slowtmr+0x288>
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
          pcb->persist_cnt = 0;
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
            pcb->persist_backoff++;
          }
          tcp_zero_window_probe(pcb);
300189b8:	e1a00000 	nop			; (mov r0, r0)
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
300189bc:	e59d3000 	ldr	r3, [sp]
300189c0:	e5d33010 	ldrb	r3, [r3, #16]
300189c4:	e3530006 	cmp	r3, #6
300189c8:	1a000009 	bne	300189f4 <tcp_slowtmr+0x2c0>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
300189cc:	e59f341c 	ldr	r3, [pc, #1052]	; 30018df0 <tcp_slowtmr+0x6bc>
300189d0:	e5932000 	ldr	r2, [r3]
300189d4:	e59d3000 	ldr	r3, [sp]
300189d8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
300189dc:	e0633002 	rsb	r3, r3, r2
300189e0:	e3530028 	cmp	r3, #40	; 0x28
300189e4:	9a000002 	bls	300189f4 <tcp_slowtmr+0x2c0>
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
300189e8:	e5dd300e 	ldrb	r3, [sp, #14]
300189ec:	e2833001 	add	r3, r3, #1
300189f0:	e5cd300e 	strb	r3, [sp, #14]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
300189f4:	e59d3000 	ldr	r3, [sp]
300189f8:	e1d330b8 	ldrh	r3, [r3, #8]
300189fc:	e2033008 	and	r3, r3, #8
30018a00:	e3530000 	cmp	r3, #0
30018a04:	0a00003b 	beq	30018af8 <tcp_slowtmr+0x3c4>
       ((pcb->state == ESTABLISHED) || 
30018a08:	e59d3000 	ldr	r3, [sp]
30018a0c:	e5d33010 	ldrb	r3, [r3, #16]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
30018a10:	e3530004 	cmp	r3, #4
30018a14:	0a000003 	beq	30018a28 <tcp_slowtmr+0x2f4>
       ((pcb->state == ESTABLISHED) || 
        (pcb->state == CLOSE_WAIT))) {
30018a18:	e59d3000 	ldr	r3, [sp]
30018a1c:	e5d33010 	ldrb	r3, [r3, #16]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
30018a20:	e3530007 	cmp	r3, #7
30018a24:	1a000033 	bne	30018af8 <tcp_slowtmr+0x3c4>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
30018a28:	e59f33c0 	ldr	r3, [pc, #960]	; 30018df0 <tcp_slowtmr+0x6bc>
30018a2c:	e5932000 	ldr	r2, [r3]
30018a30:	e59d3000 	ldr	r3, [sp]
30018a34:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30018a38:	e0632002 	rsb	r2, r3, r2
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
30018a3c:	e59d3000 	ldr	r3, [sp]
30018a40:	e5933098 	ldr	r3, [r3, #152]	; 0x98
30018a44:	e2833929 	add	r3, r3, #671744	; 0xa4000
30018a48:	e2833ecb 	add	r3, r3, #3248	; 0xcb0
30018a4c:	e2833008 	add	r3, r3, #8
30018a50:	e59f13a8 	ldr	r1, [pc, #936]	; 30018e00 <tcp_slowtmr+0x6cc>
30018a54:	e0830391 	umull	r0, r3, r1, r3
30018a58:	e1a032a3 	lsr	r3, r3, #5
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
30018a5c:	e1520003 	cmp	r2, r3
30018a60:	9a000002 	bls	30018a70 <tcp_slowtmr+0x33c>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
30018a64:	e59d0000 	ldr	r0, [sp]
30018a68:	ebfffbd6 	bl	300179c8 <tcp_abort>
30018a6c:	ea000021 	b	30018af8 <tcp_slowtmr+0x3c4>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
30018a70:	e59f3378 	ldr	r3, [pc, #888]	; 30018df0 <tcp_slowtmr+0x6bc>
30018a74:	e5932000 	ldr	r2, [r3]
30018a78:	e59d3000 	ldr	r3, [sp]
30018a7c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30018a80:	e0631002 	rsb	r1, r3, r2
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
30018a84:	e59d3000 	ldr	r3, [sp]
30018a88:	e5930098 	ldr	r0, [r3, #152]	; 0x98
30018a8c:	e59d3000 	ldr	r3, [sp]
30018a90:	e5d330a1 	ldrb	r3, [r3, #161]	; 0xa1
30018a94:	e1a02003 	mov	r2, r3
30018a98:	e1a03002 	mov	r3, r2
30018a9c:	e1a03283 	lsl	r3, r3, #5
30018aa0:	e0623003 	rsb	r3, r2, r3
30018aa4:	e1a03103 	lsl	r3, r3, #2
30018aa8:	e0833002 	add	r3, r3, r2
30018aac:	e1a02103 	lsl	r2, r3, #2
30018ab0:	e0833002 	add	r3, r3, r2
30018ab4:	e1a02203 	lsl	r2, r3, #4
30018ab8:	e0632002 	rsb	r2, r3, r2
30018abc:	e1a03182 	lsl	r3, r2, #3
30018ac0:	e0802003 	add	r2, r0, r3
              / TCP_SLOW_INTERVAL)
30018ac4:	e59f3334 	ldr	r3, [pc, #820]	; 30018e00 <tcp_slowtmr+0x6cc>
30018ac8:	e0830392 	umull	r0, r3, r2, r3
30018acc:	e1a032a3 	lsr	r3, r3, #5
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
30018ad0:	e1510003 	cmp	r1, r3
30018ad4:	9a000007 	bls	30018af8 <tcp_slowtmr+0x3c4>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
30018ad8:	e59d0000 	ldr	r0, [sp]
30018adc:	eb001a77 	bl	3001f4c0 <tcp_keepalive>
        pcb->keep_cnt_sent++;
30018ae0:	e59d3000 	ldr	r3, [sp]
30018ae4:	e5d330a1 	ldrb	r3, [r3, #161]	; 0xa1
30018ae8:	e2833001 	add	r3, r3, #1
30018aec:	e20320ff 	and	r2, r3, #255	; 0xff
30018af0:	e59d3000 	ldr	r3, [sp]
30018af4:	e5c320a1 	strb	r2, [r3, #161]	; 0xa1

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
30018af8:	e59d3000 	ldr	r3, [sp]
30018afc:	e5933078 	ldr	r3, [r3, #120]	; 0x78
30018b00:	e3530000 	cmp	r3, #0
30018b04:	0a000015 	beq	30018b60 <tcp_slowtmr+0x42c>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
30018b08:	e59f32e0 	ldr	r3, [pc, #736]	; 30018df0 <tcp_slowtmr+0x6bc>
30018b0c:	e5932000 	ldr	r2, [r3]
30018b10:	e59d3000 	ldr	r3, [sp]
30018b14:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30018b18:	e0631002 	rsb	r1, r3, r2
30018b1c:	e59d3000 	ldr	r3, [sp]
30018b20:	e1d334b0 	ldrh	r3, [r3, #64]	; 0x40
30018b24:	e1a03803 	lsl	r3, r3, #16
30018b28:	e1a02843 	asr	r2, r3, #16
30018b2c:	e1a03002 	mov	r3, r2
30018b30:	e1a03083 	lsl	r3, r3, #1
30018b34:	e0833002 	add	r3, r3, r2
30018b38:	e1a03083 	lsl	r3, r3, #1

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
30018b3c:	e1510003 	cmp	r1, r3
30018b40:	3a000006 	bcc	30018b60 <tcp_slowtmr+0x42c>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
30018b44:	e59d3000 	ldr	r3, [sp]
30018b48:	e5933078 	ldr	r3, [r3, #120]	; 0x78
30018b4c:	e1a00003 	mov	r0, r3
30018b50:	eb0000f7 	bl	30018f34 <tcp_segs_free>
      pcb->ooseq = NULL;
30018b54:	e59d3000 	ldr	r3, [sp]
30018b58:	e3a02000 	mov	r2, #0
30018b5c:	e5832078 	str	r2, [r3, #120]	; 0x78
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
30018b60:	e59d3000 	ldr	r3, [sp]
30018b64:	e5d33010 	ldrb	r3, [r3, #16]
30018b68:	e3530003 	cmp	r3, #3
30018b6c:	1a000009 	bne	30018b98 <tcp_slowtmr+0x464>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
30018b70:	e59f3278 	ldr	r3, [pc, #632]	; 30018df0 <tcp_slowtmr+0x6bc>
30018b74:	e5932000 	ldr	r2, [r3]
30018b78:	e59d3000 	ldr	r3, [sp]
30018b7c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30018b80:	e0633002 	rsb	r3, r3, r2
30018b84:	e3530028 	cmp	r3, #40	; 0x28
30018b88:	9a000002 	bls	30018b98 <tcp_slowtmr+0x464>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
30018b8c:	e5dd300e 	ldrb	r3, [sp, #14]
30018b90:	e2833001 	add	r3, r3, #1
30018b94:	e5cd300e 	strb	r3, [sp, #14]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
30018b98:	e59d3000 	ldr	r3, [sp]
30018b9c:	e5d33010 	ldrb	r3, [r3, #16]
30018ba0:	e3530009 	cmp	r3, #9
30018ba4:	1a000009 	bne	30018bd0 <tcp_slowtmr+0x49c>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
30018ba8:	e59f3240 	ldr	r3, [pc, #576]	; 30018df0 <tcp_slowtmr+0x6bc>
30018bac:	e5932000 	ldr	r2, [r3]
30018bb0:	e59d3000 	ldr	r3, [sp]
30018bb4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30018bb8:	e0633002 	rsb	r3, r3, r2
30018bbc:	e35300f0 	cmp	r3, #240	; 0xf0
30018bc0:	9a000002 	bls	30018bd0 <tcp_slowtmr+0x49c>
        ++pcb_remove;
30018bc4:	e5dd300e 	ldrb	r3, [sp, #14]
30018bc8:	e2833001 	add	r3, r3, #1
30018bcc:	e5cd300e 	strb	r3, [sp, #14]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
30018bd0:	e5dd300e 	ldrb	r3, [sp, #14]
30018bd4:	e3530000 	cmp	r3, #0
30018bd8:	0a000022 	beq	30018c68 <tcp_slowtmr+0x534>
      tcp_pcb_purge(pcb);      
30018bdc:	e59d0000 	ldr	r0, [sp]
30018be0:	eb000258 	bl	30019548 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
30018be4:	e59d3008 	ldr	r3, [sp, #8]
30018be8:	e3530000 	cmp	r3, #0
30018bec:	0a000004 	beq	30018c04 <tcp_slowtmr+0x4d0>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
30018bf0:	e59d3000 	ldr	r3, [sp]
30018bf4:	e593200c 	ldr	r2, [r3, #12]
30018bf8:	e59d3008 	ldr	r3, [sp, #8]
30018bfc:	e583200c 	str	r2, [r3, #12]
30018c00:	ea000003 	b	30018c14 <tcp_slowtmr+0x4e0>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
30018c04:	e59d3000 	ldr	r3, [sp]
30018c08:	e593200c 	ldr	r2, [r3, #12]
30018c0c:	e59f31e0 	ldr	r3, [pc, #480]	; 30018df4 <tcp_slowtmr+0x6c0>
30018c10:	e5832000 	str	r2, [r3]
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
30018c14:	e59d3000 	ldr	r3, [sp]
30018c18:	e5933094 	ldr	r3, [r3, #148]	; 0x94
30018c1c:	e3530000 	cmp	r3, #0
30018c20:	0a000007 	beq	30018c44 <tcp_slowtmr+0x510>
30018c24:	e59d3000 	ldr	r3, [sp]
30018c28:	e5933094 	ldr	r3, [r3, #148]	; 0x94
30018c2c:	e59d2000 	ldr	r2, [sp]
30018c30:	e5922014 	ldr	r2, [r2, #20]
30018c34:	e1a00002 	mov	r0, r2
30018c38:	e3e01003 	mvn	r1, #3
30018c3c:	e1a0e00f 	mov	lr, pc
30018c40:	e12fff13 	bx	r3

      pcb2 = pcb->next;
30018c44:	e59d3000 	ldr	r3, [sp]
30018c48:	e593300c 	ldr	r3, [r3, #12]
30018c4c:	e58d3004 	str	r3, [sp, #4]
      memp_free(MEMP_TCP_PCB, pcb);
30018c50:	e3a00002 	mov	r0, #2
30018c54:	e59d1000 	ldr	r1, [sp]
30018c58:	ebfff2c9 	bl	30015784 <memp_free>
      pcb = pcb2;
30018c5c:	e59d3004 	ldr	r3, [sp, #4]
30018c60:	e58d3000 	str	r3, [sp]
30018c64:	ea000027 	b	30018d08 <tcp_slowtmr+0x5d4>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
30018c68:	e59d3000 	ldr	r3, [sp]
30018c6c:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
30018c70:	e2833001 	add	r3, r3, #1
30018c74:	e20320ff 	and	r2, r3, #255	; 0xff
30018c78:	e59d3000 	ldr	r3, [sp]
30018c7c:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
      if (pcb->polltmr >= pcb->pollinterval) {
30018c80:	e59d3000 	ldr	r3, [sp]
30018c84:	e5d3202c 	ldrb	r2, [r3, #44]	; 0x2c
30018c88:	e59d3000 	ldr	r3, [sp]
30018c8c:	e5d3302d 	ldrb	r3, [r3, #45]	; 0x2d
30018c90:	e1520003 	cmp	r2, r3
30018c94:	3a000016 	bcc	30018cf4 <tcp_slowtmr+0x5c0>
        pcb->polltmr = 0;
30018c98:	e59d3000 	ldr	r3, [sp]
30018c9c:	e3a02000 	mov	r2, #0
30018ca0:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
30018ca4:	e59d3000 	ldr	r3, [sp]
30018ca8:	e5933090 	ldr	r3, [r3, #144]	; 0x90
30018cac:	e3530000 	cmp	r3, #0
30018cb0:	0a00000a 	beq	30018ce0 <tcp_slowtmr+0x5ac>
30018cb4:	e59d3000 	ldr	r3, [sp]
30018cb8:	e5933090 	ldr	r3, [r3, #144]	; 0x90
30018cbc:	e59d2000 	ldr	r2, [sp]
30018cc0:	e5922014 	ldr	r2, [r2, #20]
30018cc4:	e1a00002 	mov	r0, r2
30018cc8:	e59d1000 	ldr	r1, [sp]
30018ccc:	e1a0e00f 	mov	lr, pc
30018cd0:	e12fff13 	bx	r3
30018cd4:	e1a03000 	mov	r3, r0
30018cd8:	e20330ff 	and	r3, r3, #255	; 0xff
30018cdc:	e5cd300f 	strb	r3, [sp, #15]
        if (err == ERR_OK) {
30018ce0:	e1dd30df 	ldrsb	r3, [sp, #15]
30018ce4:	e3530000 	cmp	r3, #0
30018ce8:	1a000001 	bne	30018cf4 <tcp_slowtmr+0x5c0>
          tcp_output(pcb);
30018cec:	e59d0000 	ldr	r0, [sp]
30018cf0:	eb001563 	bl	3001e284 <tcp_output>
        }
      }
      
      prev = pcb;
30018cf4:	e59d3000 	ldr	r3, [sp]
30018cf8:	e58d3008 	str	r3, [sp, #8]
      pcb = pcb->next;
30018cfc:	e59d3000 	ldr	r3, [sp]
30018d00:	e593300c 	ldr	r3, [r3, #12]
30018d04:	e58d3000 	str	r3, [sp]
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
30018d08:	e59d3000 	ldr	r3, [sp]
30018d0c:	e3530000 	cmp	r3, #0
30018d10:	1afffe96 	bne	30018770 <tcp_slowtmr+0x3c>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
30018d14:	e3a03000 	mov	r3, #0
30018d18:	e58d3008 	str	r3, [sp, #8]
  pcb = tcp_tw_pcbs;
30018d1c:	e59f30e0 	ldr	r3, [pc, #224]	; 30018e04 <tcp_slowtmr+0x6d0>
30018d20:	e5933000 	ldr	r3, [r3]
30018d24:	e58d3000 	str	r3, [sp]
  while (pcb != NULL) {
30018d28:	ea00002a 	b	30018dd8 <tcp_slowtmr+0x6a4>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    pcb_remove = 0;
30018d2c:	e3a03000 	mov	r3, #0
30018d30:	e5cd300e 	strb	r3, [sp, #14]

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
30018d34:	e59f30b4 	ldr	r3, [pc, #180]	; 30018df0 <tcp_slowtmr+0x6bc>
30018d38:	e5932000 	ldr	r2, [r3]
30018d3c:	e59d3000 	ldr	r3, [sp]
30018d40:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30018d44:	e0633002 	rsb	r3, r3, r2
30018d48:	e35300f0 	cmp	r3, #240	; 0xf0
30018d4c:	9a000002 	bls	30018d5c <tcp_slowtmr+0x628>
      ++pcb_remove;
30018d50:	e5dd300e 	ldrb	r3, [sp, #14]
30018d54:	e2833001 	add	r3, r3, #1
30018d58:	e5cd300e 	strb	r3, [sp, #14]
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
30018d5c:	e5dd300e 	ldrb	r3, [sp, #14]
30018d60:	e3530000 	cmp	r3, #0
30018d64:	0a000016 	beq	30018dc4 <tcp_slowtmr+0x690>
      tcp_pcb_purge(pcb);      
30018d68:	e59d0000 	ldr	r0, [sp]
30018d6c:	eb0001f5 	bl	30019548 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
30018d70:	e59d3008 	ldr	r3, [sp, #8]
30018d74:	e3530000 	cmp	r3, #0
30018d78:	0a000004 	beq	30018d90 <tcp_slowtmr+0x65c>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
30018d7c:	e59d3000 	ldr	r3, [sp]
30018d80:	e593200c 	ldr	r2, [r3, #12]
30018d84:	e59d3008 	ldr	r3, [sp, #8]
30018d88:	e583200c 	str	r2, [r3, #12]
30018d8c:	ea000003 	b	30018da0 <tcp_slowtmr+0x66c>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
30018d90:	e59d3000 	ldr	r3, [sp]
30018d94:	e593200c 	ldr	r2, [r3, #12]
30018d98:	e59f3064 	ldr	r3, [pc, #100]	; 30018e04 <tcp_slowtmr+0x6d0>
30018d9c:	e5832000 	str	r2, [r3]
      }
      pcb2 = pcb->next;
30018da0:	e59d3000 	ldr	r3, [sp]
30018da4:	e593300c 	ldr	r3, [r3, #12]
30018da8:	e58d3004 	str	r3, [sp, #4]
      memp_free(MEMP_TCP_PCB, pcb);
30018dac:	e3a00002 	mov	r0, #2
30018db0:	e59d1000 	ldr	r1, [sp]
30018db4:	ebfff272 	bl	30015784 <memp_free>
      pcb = pcb2;
30018db8:	e59d3004 	ldr	r3, [sp, #4]
30018dbc:	e58d3000 	str	r3, [sp]
30018dc0:	ea000004 	b	30018dd8 <tcp_slowtmr+0x6a4>
    } else {
      prev = pcb;
30018dc4:	e59d3000 	ldr	r3, [sp]
30018dc8:	e58d3008 	str	r3, [sp, #8]
      pcb = pcb->next;
30018dcc:	e59d3000 	ldr	r3, [sp]
30018dd0:	e593300c 	ldr	r3, [r3, #12]
30018dd4:	e58d3000 	str	r3, [sp]

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
30018dd8:	e59d3000 	ldr	r3, [sp]
30018ddc:	e3530000 	cmp	r3, #0
30018de0:	1affffd1 	bne	30018d2c <tcp_slowtmr+0x5f8>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
30018de4:	e28dd014 	add	sp, sp, #20
30018de8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30018dec:	e12fff1e 	bx	lr
30018df0:	3002a724 	.word	0x3002a724
30018df4:	3002a6e8 	.word	0x3002a6e8
30018df8:	300265ac 	.word	0x300265ac
30018dfc:	3002659c 	.word	0x3002659c
30018e00:	10624dd3 	.word	0x10624dd3
30018e04:	3002b1c4 	.word	0x3002b1c4

30018e08 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
30018e08:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30018e0c:	e24dd00c 	sub	sp, sp, #12
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
30018e10:	e59f3118 	ldr	r3, [pc, #280]	; 30018f30 <tcp_fasttmr+0x128>
30018e14:	e5933000 	ldr	r3, [r3]
30018e18:	e58d3000 	str	r3, [sp]
30018e1c:	ea00003d 	b	30018f18 <tcp_fasttmr+0x110>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
30018e20:	e59d3000 	ldr	r3, [sp]
30018e24:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
30018e28:	e3530000 	cmp	r3, #0
30018e2c:	0a000023 	beq	30018ec0 <tcp_fasttmr+0xb8>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
30018e30:	e59d3000 	ldr	r3, [sp]
30018e34:	e5933084 	ldr	r3, [r3, #132]	; 0x84
30018e38:	e3530000 	cmp	r3, #0
30018e3c:	0a00000f 	beq	30018e80 <tcp_fasttmr+0x78>
30018e40:	e59d3000 	ldr	r3, [sp]
30018e44:	e593c084 	ldr	ip, [r3, #132]	; 0x84
30018e48:	e59d3000 	ldr	r3, [sp]
30018e4c:	e5932014 	ldr	r2, [r3, #20]
30018e50:	e59d3000 	ldr	r3, [sp]
30018e54:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
30018e58:	e1a00002 	mov	r0, r2
30018e5c:	e59d1000 	ldr	r1, [sp]
30018e60:	e1a02003 	mov	r2, r3
30018e64:	e3a03000 	mov	r3, #0
30018e68:	e1a0e00f 	mov	lr, pc
30018e6c:	e12fff1c 	bx	ip
30018e70:	e1a03000 	mov	r3, r0
30018e74:	e20330ff 	and	r3, r3, #255	; 0xff
30018e78:	e5cd3007 	strb	r3, [sp, #7]
30018e7c:	ea000009 	b	30018ea8 <tcp_fasttmr+0xa0>
30018e80:	e3a03000 	mov	r3, #0
30018e84:	e5cd3007 	strb	r3, [sp, #7]
30018e88:	e59d3000 	ldr	r3, [sp]
30018e8c:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
30018e90:	e3530000 	cmp	r3, #0
30018e94:	0a000003 	beq	30018ea8 <tcp_fasttmr+0xa0>
30018e98:	e59d3000 	ldr	r3, [sp]
30018e9c:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
30018ea0:	e1a00003 	mov	r0, r3
30018ea4:	ebfff5a1 	bl	30016530 <pbuf_free>
      if (err == ERR_OK) {
30018ea8:	e1dd30d7 	ldrsb	r3, [sp, #7]
30018eac:	e3530000 	cmp	r3, #0
30018eb0:	1a000002 	bne	30018ec0 <tcp_fasttmr+0xb8>
        pcb->refused_data = NULL;
30018eb4:	e59d3000 	ldr	r3, [sp]
30018eb8:	e3a02000 	mov	r2, #0
30018ebc:	e583207c 	str	r2, [r3, #124]	; 0x7c
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
30018ec0:	e59d3000 	ldr	r3, [sp]
30018ec4:	e5d3301c 	ldrb	r3, [r3, #28]
30018ec8:	e2033001 	and	r3, r3, #1
30018ecc:	e20330ff 	and	r3, r3, #255	; 0xff
30018ed0:	e3530000 	cmp	r3, #0
30018ed4:	0a00000c 	beq	30018f0c <tcp_fasttmr+0x104>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
30018ed8:	e59d3000 	ldr	r3, [sp]
30018edc:	e5d3301c 	ldrb	r3, [r3, #28]
30018ee0:	e3833002 	orr	r3, r3, #2
30018ee4:	e20320ff 	and	r2, r3, #255	; 0xff
30018ee8:	e59d3000 	ldr	r3, [sp]
30018eec:	e5c3201c 	strb	r2, [r3, #28]
30018ef0:	e59d0000 	ldr	r0, [sp]
30018ef4:	eb0014e2 	bl	3001e284 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
30018ef8:	e59d3000 	ldr	r3, [sp]
30018efc:	e5d3301c 	ldrb	r3, [r3, #28]
30018f00:	e20330fc 	and	r3, r3, #252	; 0xfc
30018f04:	e59d2000 	ldr	r2, [sp]
30018f08:	e5c2301c 	strb	r3, [r2, #28]
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
30018f0c:	e59d3000 	ldr	r3, [sp]
30018f10:	e593300c 	ldr	r3, [r3, #12]
30018f14:	e58d3000 	str	r3, [sp]
30018f18:	e59d3000 	ldr	r3, [sp]
30018f1c:	e3530000 	cmp	r3, #0
30018f20:	1affffbe 	bne	30018e20 <tcp_fasttmr+0x18>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
30018f24:	e28dd00c 	add	sp, sp, #12
30018f28:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30018f2c:	e12fff1e 	bx	lr
30018f30:	3002a6e8 	.word	0x3002a6e8

30018f34 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
30018f34:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30018f38:	e24dd014 	sub	sp, sp, #20
30018f3c:	e58d0004 	str	r0, [sp, #4]
  u8_t count = 0;
30018f40:	e3a03000 	mov	r3, #0
30018f44:	e5cd300b 	strb	r3, [sp, #11]
  struct tcp_seg *next;
  while (seg != NULL) {
30018f48:	ea00000b 	b	30018f7c <tcp_segs_free+0x48>
    next = seg->next;
30018f4c:	e59d3004 	ldr	r3, [sp, #4]
30018f50:	e5933000 	ldr	r3, [r3]
30018f54:	e58d300c 	str	r3, [sp, #12]
    count += tcp_seg_free(seg);
30018f58:	e59d0004 	ldr	r0, [sp, #4]
30018f5c:	eb00000e 	bl	30018f9c <tcp_seg_free>
30018f60:	e1a03000 	mov	r3, r0
30018f64:	e1a02003 	mov	r2, r3
30018f68:	e5dd300b 	ldrb	r3, [sp, #11]
30018f6c:	e0823003 	add	r3, r2, r3
30018f70:	e5cd300b 	strb	r3, [sp, #11]
    seg = next;
30018f74:	e59d300c 	ldr	r3, [sp, #12]
30018f78:	e58d3004 	str	r3, [sp, #4]
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
30018f7c:	e59d3004 	ldr	r3, [sp, #4]
30018f80:	e3530000 	cmp	r3, #0
30018f84:	1afffff0 	bne	30018f4c <tcp_segs_free+0x18>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
30018f88:	e5dd300b 	ldrb	r3, [sp, #11]
}
30018f8c:	e1a00003 	mov	r0, r3
30018f90:	e28dd014 	add	sp, sp, #20
30018f94:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30018f98:	e12fff1e 	bx	lr

30018f9c <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
30018f9c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30018fa0:	e24dd014 	sub	sp, sp, #20
30018fa4:	e58d0004 	str	r0, [sp, #4]
  u8_t count = 0;
30018fa8:	e3a03000 	mov	r3, #0
30018fac:	e5cd300f 	strb	r3, [sp, #15]
  
  if (seg != NULL) {
30018fb0:	e59d3004 	ldr	r3, [sp, #4]
30018fb4:	e3530000 	cmp	r3, #0
30018fb8:	0a00000c 	beq	30018ff0 <tcp_seg_free+0x54>
    if (seg->p != NULL) {
30018fbc:	e59d3004 	ldr	r3, [sp, #4]
30018fc0:	e5933004 	ldr	r3, [r3, #4]
30018fc4:	e3530000 	cmp	r3, #0
30018fc8:	0a000005 	beq	30018fe4 <tcp_seg_free+0x48>
      count = pbuf_free(seg->p);
30018fcc:	e59d3004 	ldr	r3, [sp, #4]
30018fd0:	e5933004 	ldr	r3, [r3, #4]
30018fd4:	e1a00003 	mov	r0, r3
30018fd8:	ebfff554 	bl	30016530 <pbuf_free>
30018fdc:	e1a03000 	mov	r3, r0
30018fe0:	e5cd300f 	strb	r3, [sp, #15]
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
30018fe4:	e3a00004 	mov	r0, #4
30018fe8:	e59d1004 	ldr	r1, [sp, #4]
30018fec:	ebfff1e4 	bl	30015784 <memp_free>
  }
  return count;
30018ff0:	e5dd300f 	ldrb	r3, [sp, #15]
}
30018ff4:	e1a00003 	mov	r0, r3
30018ff8:	e28dd014 	add	sp, sp, #20
30018ffc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30019000:	e12fff1e 	bx	lr

30019004 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
30019004:	e24dd008 	sub	sp, sp, #8
30019008:	e58d0004 	str	r0, [sp, #4]
3001900c:	e1a03001 	mov	r3, r1
30019010:	e5cd3003 	strb	r3, [sp, #3]
  pcb->prio = prio;
30019014:	e59d3004 	ldr	r3, [sp, #4]
30019018:	e5dd2003 	ldrb	r2, [sp, #3]
3001901c:	e5c32011 	strb	r2, [r3, #17]
}
30019020:	e28dd008 	add	sp, sp, #8
30019024:	e12fff1e 	bx	lr

30019028 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
30019028:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001902c:	e24dd014 	sub	sp, sp, #20
30019030:	e58d0004 	str	r0, [sp, #4]
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
30019034:	e3a00004 	mov	r0, #4
30019038:	ebfff16c 	bl	300155f0 <memp_malloc>
3001903c:	e1a03000 	mov	r3, r0
30019040:	e58d300c 	str	r3, [sp, #12]
  if (cseg == NULL) {
30019044:	e59d300c 	ldr	r3, [sp, #12]
30019048:	e3530000 	cmp	r3, #0
3001904c:	1a000001 	bne	30019058 <tcp_seg_copy+0x30>
    return NULL;
30019050:	e3a03000 	mov	r3, #0
30019054:	ea000008 	b	3001907c <tcp_seg_copy+0x54>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
30019058:	e59d000c 	ldr	r0, [sp, #12]
3001905c:	e59d1004 	ldr	r1, [sp, #4]
30019060:	e3a02014 	mov	r2, #20
30019064:	ebffcfb8 	bl	3000cf4c <__re_memcpy>
  pbuf_ref(cseg->p);
30019068:	e59d300c 	ldr	r3, [sp, #12]
3001906c:	e5933004 	ldr	r3, [r3, #4]
30019070:	e1a00003 	mov	r0, r3
30019074:	ebfff585 	bl	30016690 <pbuf_ref>
  return cseg;
30019078:	e59d300c 	ldr	r3, [sp, #12]
}
3001907c:	e1a00003 	mov	r0, r3
30019080:	e28dd014 	add	sp, sp, #20
30019084:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30019088:	e12fff1e 	bx	lr

3001908c <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
3001908c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30019090:	e24dd014 	sub	sp, sp, #20
30019094:	e58d000c 	str	r0, [sp, #12]
30019098:	e58d1008 	str	r1, [sp, #8]
3001909c:	e58d2004 	str	r2, [sp, #4]
300190a0:	e5cd3003 	strb	r3, [sp, #3]
  arg = arg;
  if (p != NULL) {
300190a4:	e59d3004 	ldr	r3, [sp, #4]
300190a8:	e3530000 	cmp	r3, #0
300190ac:	0a000002 	beq	300190bc <tcp_recv_null+0x30>
    pbuf_free(p);
300190b0:	e59d0004 	ldr	r0, [sp, #4]
300190b4:	ebfff51d 	bl	30016530 <pbuf_free>
300190b8:	ea000008 	b	300190e0 <tcp_recv_null+0x54>
  } else if (err == ERR_OK) {
300190bc:	e1dd30d3 	ldrsb	r3, [sp, #3]
300190c0:	e3530000 	cmp	r3, #0
300190c4:	1a000005 	bne	300190e0 <tcp_recv_null+0x54>
    return tcp_close(pcb);
300190c8:	e59d0008 	ldr	r0, [sp, #8]
300190cc:	ebfff99e 	bl	3001774c <tcp_close>
300190d0:	e1a03000 	mov	r3, r0
300190d4:	e20330ff 	and	r3, r3, #255	; 0xff
300190d8:	e20330ff 	and	r3, r3, #255	; 0xff
300190dc:	ea000000 	b	300190e4 <tcp_recv_null+0x58>
  }
  return ERR_OK;
300190e0:	e3a03000 	mov	r3, #0
300190e4:	e1a03c03 	lsl	r3, r3, #24
300190e8:	e1a03c43 	asr	r3, r3, #24
}
300190ec:	e1a00003 	mov	r0, r3
300190f0:	e28dd014 	add	sp, sp, #20
300190f4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300190f8:	e12fff1e 	bx	lr

300190fc <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
300190fc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30019100:	e24dd01c 	sub	sp, sp, #28
30019104:	e1a03000 	mov	r3, r0
30019108:	e5cd3007 	strb	r3, [sp, #7]
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
3001910c:	e3a0307f 	mov	r3, #127	; 0x7f
30019110:	e5cd3017 	strb	r3, [sp, #23]
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
30019114:	e3a03000 	mov	r3, #0
30019118:	e58d3010 	str	r3, [sp, #16]
  inactive = NULL;
3001911c:	e3a03000 	mov	r3, #0
30019120:	e58d300c 	str	r3, [sp, #12]
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
30019124:	e59f30b4 	ldr	r3, [pc, #180]	; 300191e0 <tcp_kill_prio+0xe4>
30019128:	e5933000 	ldr	r3, [r3]
3001912c:	e58d3008 	str	r3, [sp, #8]
30019130:	ea00001f 	b	300191b4 <tcp_kill_prio+0xb8>
    if (pcb->prio <= prio &&
30019134:	e59d3008 	ldr	r3, [sp, #8]
30019138:	e5d33011 	ldrb	r3, [r3, #17]
3001913c:	e5dd2007 	ldrb	r2, [sp, #7]
30019140:	e1520003 	cmp	r2, r3
30019144:	3a000017 	bcc	300191a8 <tcp_kill_prio+0xac>
       pcb->prio <= mprio &&
30019148:	e59d3008 	ldr	r3, [sp, #8]
3001914c:	e5d33011 	ldrb	r3, [r3, #17]
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
30019150:	e5dd2017 	ldrb	r2, [sp, #23]
30019154:	e1520003 	cmp	r2, r3
30019158:	3a000012 	bcc	300191a8 <tcp_kill_prio+0xac>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
3001915c:	e59f3080 	ldr	r3, [pc, #128]	; 300191e4 <tcp_kill_prio+0xe8>
30019160:	e5932000 	ldr	r2, [r3]
30019164:	e59d3008 	ldr	r3, [sp, #8]
30019168:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3001916c:	e0632002 	rsb	r2, r3, r2
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
30019170:	e59d3010 	ldr	r3, [sp, #16]
30019174:	e1520003 	cmp	r2, r3
30019178:	3a00000a 	bcc	300191a8 <tcp_kill_prio+0xac>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
3001917c:	e59f3060 	ldr	r3, [pc, #96]	; 300191e4 <tcp_kill_prio+0xe8>
30019180:	e5932000 	ldr	r2, [r3]
30019184:	e59d3008 	ldr	r3, [sp, #8]
30019188:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3001918c:	e0633002 	rsb	r3, r3, r2
30019190:	e58d3010 	str	r3, [sp, #16]
      inactive = pcb;
30019194:	e59d3008 	ldr	r3, [sp, #8]
30019198:	e58d300c 	str	r3, [sp, #12]
      mprio = pcb->prio;
3001919c:	e59d3008 	ldr	r3, [sp, #8]
300191a0:	e5d33011 	ldrb	r3, [r3, #17]
300191a4:	e5cd3017 	strb	r3, [sp, #23]
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
300191a8:	e59d3008 	ldr	r3, [sp, #8]
300191ac:	e593300c 	ldr	r3, [r3, #12]
300191b0:	e58d3008 	str	r3, [sp, #8]
300191b4:	e59d3008 	ldr	r3, [sp, #8]
300191b8:	e3530000 	cmp	r3, #0
300191bc:	1affffdc 	bne	30019134 <tcp_kill_prio+0x38>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
300191c0:	e59d300c 	ldr	r3, [sp, #12]
300191c4:	e3530000 	cmp	r3, #0
300191c8:	0a000001 	beq	300191d4 <tcp_kill_prio+0xd8>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
300191cc:	e59d000c 	ldr	r0, [sp, #12]
300191d0:	ebfff9fc 	bl	300179c8 <tcp_abort>
  }      
}
300191d4:	e28dd01c 	add	sp, sp, #28
300191d8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300191dc:	e12fff1e 	bx	lr
300191e0:	3002a6e8 	.word	0x3002a6e8
300191e4:	3002a724 	.word	0x3002a724

300191e8 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
300191e8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300191ec:	e24dd014 	sub	sp, sp, #20
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
300191f0:	e3a03000 	mov	r3, #0
300191f4:	e58d300c 	str	r3, [sp, #12]
  inactive = NULL;
300191f8:	e3a03000 	mov	r3, #0
300191fc:	e58d3008 	str	r3, [sp, #8]
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
30019200:	e59f3080 	ldr	r3, [pc, #128]	; 30019288 <tcp_kill_timewait+0xa0>
30019204:	e5933000 	ldr	r3, [r3]
30019208:	e58d3004 	str	r3, [sp, #4]
3001920c:	ea000012 	b	3001925c <tcp_kill_timewait+0x74>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
30019210:	e59f3074 	ldr	r3, [pc, #116]	; 3001928c <tcp_kill_timewait+0xa4>
30019214:	e5932000 	ldr	r2, [r3]
30019218:	e59d3004 	ldr	r3, [sp, #4]
3001921c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30019220:	e0632002 	rsb	r2, r3, r2
30019224:	e59d300c 	ldr	r3, [sp, #12]
30019228:	e1520003 	cmp	r2, r3
3001922c:	3a000007 	bcc	30019250 <tcp_kill_timewait+0x68>
      inactivity = tcp_ticks - pcb->tmr;
30019230:	e59f3054 	ldr	r3, [pc, #84]	; 3001928c <tcp_kill_timewait+0xa4>
30019234:	e5932000 	ldr	r2, [r3]
30019238:	e59d3004 	ldr	r3, [sp, #4]
3001923c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30019240:	e0633002 	rsb	r3, r3, r2
30019244:	e58d300c 	str	r3, [sp, #12]
      inactive = pcb;
30019248:	e59d3004 	ldr	r3, [sp, #4]
3001924c:	e58d3008 	str	r3, [sp, #8]
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
30019250:	e59d3004 	ldr	r3, [sp, #4]
30019254:	e593300c 	ldr	r3, [r3, #12]
30019258:	e58d3004 	str	r3, [sp, #4]
3001925c:	e59d3004 	ldr	r3, [sp, #4]
30019260:	e3530000 	cmp	r3, #0
30019264:	1affffe9 	bne	30019210 <tcp_kill_timewait+0x28>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
30019268:	e59d3008 	ldr	r3, [sp, #8]
3001926c:	e3530000 	cmp	r3, #0
30019270:	0a000001 	beq	3001927c <tcp_kill_timewait+0x94>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
30019274:	e59d0008 	ldr	r0, [sp, #8]
30019278:	ebfff9d2 	bl	300179c8 <tcp_abort>
  }      
}
3001927c:	e28dd014 	add	sp, sp, #20
30019280:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30019284:	e12fff1e 	bx	lr
30019288:	3002b1c4 	.word	0x3002b1c4
3001928c:	3002a724 	.word	0x3002a724

30019290 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
30019290:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30019294:	e24dd014 	sub	sp, sp, #20
30019298:	e1a03000 	mov	r3, r0
3001929c:	e5cd3007 	strb	r3, [sp, #7]
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
300192a0:	e3a00002 	mov	r0, #2
300192a4:	ebfff0d1 	bl	300155f0 <memp_malloc>
300192a8:	e1a03000 	mov	r3, r0
300192ac:	e58d3008 	str	r3, [sp, #8]
  if (pcb == NULL) {
300192b0:	e59d3008 	ldr	r3, [sp, #8]
300192b4:	e3530000 	cmp	r3, #0
300192b8:	1a00000e 	bne	300192f8 <tcp_alloc+0x68>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
300192bc:	ebffffc9 	bl	300191e8 <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
300192c0:	e3a00002 	mov	r0, #2
300192c4:	ebfff0c9 	bl	300155f0 <memp_malloc>
300192c8:	e1a03000 	mov	r3, r0
300192cc:	e58d3008 	str	r3, [sp, #8]
    if (pcb == NULL) {
300192d0:	e59d3008 	ldr	r3, [sp, #8]
300192d4:	e3530000 	cmp	r3, #0
300192d8:	1a000006 	bne	300192f8 <tcp_alloc+0x68>
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
300192dc:	e5dd3007 	ldrb	r3, [sp, #7]
300192e0:	e1a00003 	mov	r0, r3
300192e4:	ebffff84 	bl	300190fc <tcp_kill_prio>
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
300192e8:	e3a00002 	mov	r0, #2
300192ec:	ebfff0bf 	bl	300155f0 <memp_malloc>
300192f0:	e1a03000 	mov	r3, r0
300192f4:	e58d3008 	str	r3, [sp, #8]
    }
  }
  if (pcb != NULL) {
300192f8:	e59d3008 	ldr	r3, [sp, #8]
300192fc:	e3530000 	cmp	r3, #0
30019300:	0a00004d 	beq	3001943c <tcp_alloc+0x1ac>
    memset(pcb, 0, sizeof(struct tcp_pcb));
30019304:	e59d0008 	ldr	r0, [sp, #8]
30019308:	e3a01000 	mov	r1, #0
3001930c:	e3a020a4 	mov	r2, #164	; 0xa4
30019310:	ebffcef3 	bl	3000cee4 <__re_memset>
    pcb->prio = TCP_PRIO_NORMAL;
30019314:	e59d3008 	ldr	r3, [sp, #8]
30019318:	e3a02040 	mov	r2, #64	; 0x40
3001931c:	e5c32011 	strb	r2, [r3, #17]
    pcb->snd_buf = TCP_SND_BUF;
30019320:	e59d3008 	ldr	r3, [sp, #8]
30019324:	e3a02c01 	mov	r2, #256	; 0x100
30019328:	e1c326ba 	strh	r2, [r3, #106]	; 0x6a
    pcb->snd_queuelen = 0;
3001932c:	e59d3008 	ldr	r3, [sp, #8]
30019330:	e3a02000 	mov	r2, #0
30019334:	e1c326bc 	strh	r2, [r3, #108]	; 0x6c
    pcb->rcv_wnd = TCP_WND;
30019338:	e59d3008 	ldr	r3, [sp, #8]
3001933c:	e3a02b02 	mov	r2, #2048	; 0x800
30019340:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
    pcb->rcv_ann_wnd = TCP_WND;
30019344:	e59d3008 	ldr	r3, [sp, #8]
30019348:	e3a02b02 	mov	r2, #2048	; 0x800
3001934c:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
    pcb->tos = 0;
30019350:	e59d3008 	ldr	r3, [sp, #8]
30019354:	e3a02000 	mov	r2, #0
30019358:	e5c3200a 	strb	r2, [r3, #10]
    pcb->ttl = TCP_TTL;
3001935c:	e59d3008 	ldr	r3, [sp, #8]
30019360:	e3e02000 	mvn	r2, #0
30019364:	e5c3200b 	strb	r2, [r3, #11]
    /* The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
30019368:	e59d3008 	ldr	r3, [sp, #8]
3001936c:	e3a02080 	mov	r2, #128	; 0x80
30019370:	e1c323b0 	strh	r2, [r3, #48]	; 0x30
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
30019374:	e59d3008 	ldr	r3, [sp, #8]
30019378:	e3a02006 	mov	r2, #6
3001937c:	e1c324b0 	strh	r2, [r3, #64]	; 0x40
    pcb->sa = 0;
30019380:	e59d3008 	ldr	r3, [sp, #8]
30019384:	e3a02000 	mov	r2, #0
30019388:	e1c323bc 	strh	r2, [r3, #60]	; 0x3c
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
3001938c:	e59d3008 	ldr	r3, [sp, #8]
30019390:	e3a02006 	mov	r2, #6
30019394:	e1c323be 	strh	r2, [r3, #62]	; 0x3e
    pcb->rtime = -1;
30019398:	e59d3008 	ldr	r3, [sp, #8]
3001939c:	e3e02000 	mvn	r2, #0
300193a0:	e1c322be 	strh	r2, [r3, #46]	; 0x2e
    pcb->cwnd = 1;
300193a4:	e59d3008 	ldr	r3, [sp, #8]
300193a8:	e3a02001 	mov	r2, #1
300193ac:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
    iss = tcp_next_iss();
300193b0:	eb0000ea 	bl	30019760 <tcp_next_iss>
300193b4:	e1a03000 	mov	r3, r0
300193b8:	e58d300c 	str	r3, [sp, #12]
    pcb->snd_wl2 = iss;
300193bc:	e59d3008 	ldr	r3, [sp, #8]
300193c0:	e59d200c 	ldr	r2, [sp, #12]
300193c4:	e5832060 	str	r2, [r3, #96]	; 0x60
    pcb->snd_nxt = iss;
300193c8:	e59d3008 	ldr	r3, [sp, #8]
300193cc:	e59d200c 	ldr	r2, [sp, #12]
300193d0:	e5832050 	str	r2, [r3, #80]	; 0x50
    pcb->snd_max = iss;
300193d4:	e59d3008 	ldr	r3, [sp, #8]
300193d8:	e59d200c 	ldr	r2, [sp, #12]
300193dc:	e5832054 	str	r2, [r3, #84]	; 0x54
    pcb->lastack = iss;
300193e0:	e59d3008 	ldr	r3, [sp, #8]
300193e4:	e59d200c 	ldr	r2, [sp, #12]
300193e8:	e5832044 	str	r2, [r3, #68]	; 0x44
    pcb->snd_lbb = iss;   
300193ec:	e59d3008 	ldr	r3, [sp, #8]
300193f0:	e59d200c 	ldr	r2, [sp, #12]
300193f4:	e5832064 	str	r2, [r3, #100]	; 0x64
    pcb->tmr = tcp_ticks;
300193f8:	e59f3050 	ldr	r3, [pc, #80]	; 30019450 <tcp_alloc+0x1c0>
300193fc:	e5932000 	ldr	r2, [r3]
30019400:	e59d3008 	ldr	r3, [sp, #8]
30019404:	e5832028 	str	r2, [r3, #40]	; 0x28

    pcb->polltmr = 0;
30019408:	e59d3008 	ldr	r3, [sp, #8]
3001940c:	e3a02000 	mov	r2, #0
30019410:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
30019414:	e59d3008 	ldr	r3, [sp, #8]
30019418:	e59f2034 	ldr	r2, [pc, #52]	; 30019454 <tcp_alloc+0x1c4>
3001941c:	e5832084 	str	r2, [r3, #132]	; 0x84
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
30019420:	e59d2008 	ldr	r2, [sp, #8]
30019424:	e3a0386d 	mov	r3, #7143424	; 0x6d0000
30019428:	e2833cdd 	add	r3, r3, #56576	; 0xdd00
3001942c:	e5823098 	str	r3, [r2, #152]	; 0x98
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
30019430:	e59d3008 	ldr	r3, [sp, #8]
30019434:	e3a02000 	mov	r2, #0
30019438:	e5c320a1 	strb	r2, [r3, #161]	; 0xa1
  }
  return pcb;
3001943c:	e59d3008 	ldr	r3, [sp, #8]
}
30019440:	e1a00003 	mov	r0, r3
30019444:	e28dd014 	add	sp, sp, #20
30019448:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001944c:	e12fff1e 	bx	lr
30019450:	3002a724 	.word	0x3002a724
30019454:	3001908c 	.word	0x3001908c

30019458 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
30019458:	e92d4008 	push	{r3, lr}
  return tcp_alloc(TCP_PRIO_NORMAL);
3001945c:	e3a00040 	mov	r0, #64	; 0x40
30019460:	ebffff8a 	bl	30019290 <tcp_alloc>
30019464:	e1a03000 	mov	r3, r0
}
30019468:	e1a00003 	mov	r0, r3
3001946c:	e8bd4008 	pop	{r3, lr}
30019470:	e12fff1e 	bx	lr

30019474 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
30019474:	e24dd008 	sub	sp, sp, #8
30019478:	e58d0004 	str	r0, [sp, #4]
3001947c:	e58d1000 	str	r1, [sp]
  pcb->callback_arg = arg;
30019480:	e59d3004 	ldr	r3, [sp, #4]
30019484:	e59d2000 	ldr	r2, [sp]
30019488:	e5832014 	str	r2, [r3, #20]
}
3001948c:	e28dd008 	add	sp, sp, #8
30019490:	e12fff1e 	bx	lr

30019494 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
30019494:	e24dd008 	sub	sp, sp, #8
30019498:	e58d0004 	str	r0, [sp, #4]
3001949c:	e58d1000 	str	r1, [sp]
  pcb->recv = recv;
300194a0:	e59d3004 	ldr	r3, [sp, #4]
300194a4:	e59d2000 	ldr	r2, [sp]
300194a8:	e5832084 	str	r2, [r3, #132]	; 0x84
}
300194ac:	e28dd008 	add	sp, sp, #8
300194b0:	e12fff1e 	bx	lr

300194b4 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
300194b4:	e24dd008 	sub	sp, sp, #8
300194b8:	e58d0004 	str	r0, [sp, #4]
300194bc:	e58d1000 	str	r1, [sp]
  pcb->sent = sent;
300194c0:	e59d3004 	ldr	r3, [sp, #4]
300194c4:	e59d2000 	ldr	r2, [sp]
300194c8:	e5832080 	str	r2, [r3, #128]	; 0x80
}
300194cc:	e28dd008 	add	sp, sp, #8
300194d0:	e12fff1e 	bx	lr

300194d4 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
300194d4:	e24dd008 	sub	sp, sp, #8
300194d8:	e58d0004 	str	r0, [sp, #4]
300194dc:	e58d1000 	str	r1, [sp]
  pcb->errf = errf;
300194e0:	e59d3004 	ldr	r3, [sp, #4]
300194e4:	e59d2000 	ldr	r2, [sp]
300194e8:	e5832094 	str	r2, [r3, #148]	; 0x94
}
300194ec:	e28dd008 	add	sp, sp, #8
300194f0:	e12fff1e 	bx	lr

300194f4 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
300194f4:	e24dd008 	sub	sp, sp, #8
300194f8:	e58d0004 	str	r0, [sp, #4]
300194fc:	e58d1000 	str	r1, [sp]
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
30019500:	e59d3004 	ldr	r3, [sp, #4]
30019504:	e59d2000 	ldr	r2, [sp]
30019508:	e583201c 	str	r2, [r3, #28]
}
3001950c:	e28dd008 	add	sp, sp, #8
30019510:	e12fff1e 	bx	lr

30019514 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
30019514:	e24dd010 	sub	sp, sp, #16
30019518:	e58d000c 	str	r0, [sp, #12]
3001951c:	e58d1008 	str	r1, [sp, #8]
30019520:	e1a03002 	mov	r3, r2
30019524:	e5cd3007 	strb	r3, [sp, #7]
#if LWIP_CALLBACK_API
  pcb->poll = poll;
30019528:	e59d300c 	ldr	r3, [sp, #12]
3001952c:	e59d2008 	ldr	r2, [sp, #8]
30019530:	e5832090 	str	r2, [r3, #144]	; 0x90
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
30019534:	e59d300c 	ldr	r3, [sp, #12]
30019538:	e5dd2007 	ldrb	r2, [sp, #7]
3001953c:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
}
30019540:	e28dd010 	add	sp, sp, #16
30019544:	e12fff1e 	bx	lr

30019548 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
30019548:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001954c:	e24dd00c 	sub	sp, sp, #12
30019550:	e58d0004 	str	r0, [sp, #4]
  if (pcb->state != CLOSED &&
30019554:	e59d3004 	ldr	r3, [sp, #4]
30019558:	e5d33010 	ldrb	r3, [r3, #16]
3001955c:	e3530000 	cmp	r3, #0
30019560:	0a00002b 	beq	30019614 <tcp_pcb_purge+0xcc>
     pcb->state != TIME_WAIT &&
30019564:	e59d3004 	ldr	r3, [sp, #4]
30019568:	e5d33010 	ldrb	r3, [r3, #16]
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
3001956c:	e353000a 	cmp	r3, #10
30019570:	0a000027 	beq	30019614 <tcp_pcb_purge+0xcc>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
30019574:	e59d3004 	ldr	r3, [sp, #4]
30019578:	e5d33010 	ldrb	r3, [r3, #16]
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
3001957c:	e3530001 	cmp	r3, #1
30019580:	0a000023 	beq	30019614 <tcp_pcb_purge+0xcc>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
30019584:	e59d3004 	ldr	r3, [sp, #4]
30019588:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
3001958c:	e3530000 	cmp	r3, #0
30019590:	0a000006 	beq	300195b0 <tcp_pcb_purge+0x68>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
30019594:	e59d3004 	ldr	r3, [sp, #4]
30019598:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
3001959c:	e1a00003 	mov	r0, r3
300195a0:	ebfff3e2 	bl	30016530 <pbuf_free>
      pcb->refused_data = NULL;
300195a4:	e59d3004 	ldr	r3, [sp, #4]
300195a8:	e3a02000 	mov	r2, #0
300195ac:	e583207c 	str	r2, [r3, #124]	; 0x7c
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
300195b0:	e59d3004 	ldr	r3, [sp, #4]
300195b4:	e3e02000 	mvn	r2, #0
300195b8:	e1c322be 	strh	r2, [r3, #46]	; 0x2e

    tcp_segs_free(pcb->ooseq);
300195bc:	e59d3004 	ldr	r3, [sp, #4]
300195c0:	e5933078 	ldr	r3, [r3, #120]	; 0x78
300195c4:	e1a00003 	mov	r0, r3
300195c8:	ebfffe59 	bl	30018f34 <tcp_segs_free>
    pcb->ooseq = NULL;
300195cc:	e59d3004 	ldr	r3, [sp, #4]
300195d0:	e3a02000 	mov	r2, #0
300195d4:	e5832078 	str	r2, [r3, #120]	; 0x78
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
300195d8:	e59d3004 	ldr	r3, [sp, #4]
300195dc:	e5933070 	ldr	r3, [r3, #112]	; 0x70
300195e0:	e1a00003 	mov	r0, r3
300195e4:	ebfffe52 	bl	30018f34 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
300195e8:	e59d3004 	ldr	r3, [sp, #4]
300195ec:	e5933074 	ldr	r3, [r3, #116]	; 0x74
300195f0:	e1a00003 	mov	r0, r3
300195f4:	ebfffe4e 	bl	30018f34 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
300195f8:	e59d3004 	ldr	r3, [sp, #4]
300195fc:	e3a02000 	mov	r2, #0
30019600:	e5832070 	str	r2, [r3, #112]	; 0x70
30019604:	e59d3004 	ldr	r3, [sp, #4]
30019608:	e5932070 	ldr	r2, [r3, #112]	; 0x70
3001960c:	e59d3004 	ldr	r3, [sp, #4]
30019610:	e5832074 	str	r2, [r3, #116]	; 0x74
  }
}
30019614:	e28dd00c 	add	sp, sp, #12
30019618:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001961c:	e12fff1e 	bx	lr

30019620 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
30019620:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30019624:	e24dd00c 	sub	sp, sp, #12
30019628:	e58d0004 	str	r0, [sp, #4]
3001962c:	e58d1000 	str	r1, [sp]
  TCP_RMV(pcblist, pcb);
30019630:	e59d3004 	ldr	r3, [sp, #4]
30019634:	e5932000 	ldr	r2, [r3]
30019638:	e59d3000 	ldr	r3, [sp]
3001963c:	e1520003 	cmp	r2, r3
30019640:	1a000005 	bne	3001965c <tcp_pcb_remove+0x3c>
30019644:	e59d3004 	ldr	r3, [sp, #4]
30019648:	e5933000 	ldr	r3, [r3]
3001964c:	e593200c 	ldr	r2, [r3, #12]
30019650:	e59d3004 	ldr	r3, [sp, #4]
30019654:	e5832000 	str	r2, [r3]
30019658:	ea00001e 	b	300196d8 <tcp_pcb_remove+0xb8>
3001965c:	e59d3004 	ldr	r3, [sp, #4]
30019660:	e5932000 	ldr	r2, [r3]
30019664:	e59f30f0 	ldr	r3, [pc, #240]	; 3001975c <tcp_pcb_remove+0x13c>
30019668:	e5832000 	str	r2, [r3]
3001966c:	ea000015 	b	300196c8 <tcp_pcb_remove+0xa8>
30019670:	e59f30e4 	ldr	r3, [pc, #228]	; 3001975c <tcp_pcb_remove+0x13c>
30019674:	e5933000 	ldr	r3, [r3]
30019678:	e593300c 	ldr	r3, [r3, #12]
3001967c:	e3530000 	cmp	r3, #0
30019680:	0a00000b 	beq	300196b4 <tcp_pcb_remove+0x94>
30019684:	e59f30d0 	ldr	r3, [pc, #208]	; 3001975c <tcp_pcb_remove+0x13c>
30019688:	e5933000 	ldr	r3, [r3]
3001968c:	e593200c 	ldr	r2, [r3, #12]
30019690:	e59d3000 	ldr	r3, [sp]
30019694:	e1520003 	cmp	r2, r3
30019698:	1a000005 	bne	300196b4 <tcp_pcb_remove+0x94>
3001969c:	e59f30b8 	ldr	r3, [pc, #184]	; 3001975c <tcp_pcb_remove+0x13c>
300196a0:	e5933000 	ldr	r3, [r3]
300196a4:	e59d2000 	ldr	r2, [sp]
300196a8:	e592200c 	ldr	r2, [r2, #12]
300196ac:	e583200c 	str	r2, [r3, #12]
300196b0:	ea000008 	b	300196d8 <tcp_pcb_remove+0xb8>
300196b4:	e59f30a0 	ldr	r3, [pc, #160]	; 3001975c <tcp_pcb_remove+0x13c>
300196b8:	e5933000 	ldr	r3, [r3]
300196bc:	e593200c 	ldr	r2, [r3, #12]
300196c0:	e59f3094 	ldr	r3, [pc, #148]	; 3001975c <tcp_pcb_remove+0x13c>
300196c4:	e5832000 	str	r2, [r3]
300196c8:	e59f308c 	ldr	r3, [pc, #140]	; 3001975c <tcp_pcb_remove+0x13c>
300196cc:	e5933000 	ldr	r3, [r3]
300196d0:	e3530000 	cmp	r3, #0
300196d4:	1affffe5 	bne	30019670 <tcp_pcb_remove+0x50>
300196d8:	e59d3000 	ldr	r3, [sp]
300196dc:	e3a02000 	mov	r2, #0
300196e0:	e583200c 	str	r2, [r3, #12]

  tcp_pcb_purge(pcb);
300196e4:	e59d0000 	ldr	r0, [sp]
300196e8:	ebffff96 	bl	30019548 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
300196ec:	e59d3000 	ldr	r3, [sp]
300196f0:	e5d33010 	ldrb	r3, [r3, #16]
300196f4:	e353000a 	cmp	r3, #10
300196f8:	0a000011 	beq	30019744 <tcp_pcb_remove+0x124>
     pcb->state != LISTEN &&
300196fc:	e59d3000 	ldr	r3, [sp]
30019700:	e5d33010 	ldrb	r3, [r3, #16]
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
30019704:	e3530001 	cmp	r3, #1
30019708:	0a00000d 	beq	30019744 <tcp_pcb_remove+0x124>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
3001970c:	e59d3000 	ldr	r3, [sp]
30019710:	e5d3301c 	ldrb	r3, [r3, #28]
30019714:	e2033001 	and	r3, r3, #1
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
30019718:	e20330ff 	and	r3, r3, #255	; 0xff
3001971c:	e3530000 	cmp	r3, #0
30019720:	0a000007 	beq	30019744 <tcp_pcb_remove+0x124>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
30019724:	e59d3000 	ldr	r3, [sp]
30019728:	e5d3301c 	ldrb	r3, [r3, #28]
3001972c:	e3833002 	orr	r3, r3, #2
30019730:	e20320ff 	and	r2, r3, #255	; 0xff
30019734:	e59d3000 	ldr	r3, [sp]
30019738:	e5c3201c 	strb	r2, [r3, #28]
    tcp_output(pcb);
3001973c:	e59d0000 	ldr	r0, [sp]
30019740:	eb0012cf 	bl	3001e284 <tcp_output>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
30019744:	e59d3000 	ldr	r3, [sp]
30019748:	e3a02000 	mov	r2, #0
3001974c:	e5c32010 	strb	r2, [r3, #16]

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
30019750:	e28dd00c 	add	sp, sp, #12
30019754:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30019758:	e12fff1e 	bx	lr
3001975c:	3002a838 	.word	0x3002a838

30019760 <tcp_next_iss>:
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
30019760:	e59f3024 	ldr	r3, [pc, #36]	; 3001978c <tcp_next_iss+0x2c>
30019764:	e5932000 	ldr	r2, [r3]
30019768:	e59f3020 	ldr	r3, [pc, #32]	; 30019790 <tcp_next_iss+0x30>
3001976c:	e5933000 	ldr	r3, [r3]
30019770:	e0822003 	add	r2, r2, r3
30019774:	e59f3010 	ldr	r3, [pc, #16]	; 3001978c <tcp_next_iss+0x2c>
30019778:	e5832000 	str	r2, [r3]
  return iss;
3001977c:	e59f3008 	ldr	r3, [pc, #8]	; 3001978c <tcp_next_iss+0x2c>
30019780:	e5933000 	ldr	r3, [r3]
}
30019784:	e1a00003 	mov	r0, r3
30019788:	e12fff1e 	bx	lr
3001978c:	300268cc 	.word	0x300268cc
30019790:	3002a724 	.word	0x3002a724

30019794 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
30019794:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30019798:	e24dd014 	sub	sp, sp, #20
3001979c:	e1a03000 	mov	r3, r0
300197a0:	e58d1000 	str	r1, [sp]
300197a4:	e1cd30b6 	strh	r3, [sp, #6]
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
300197a8:	e59d0000 	ldr	r0, [sp]
300197ac:	ebffea97 	bl	30014210 <ip_route>
300197b0:	e1a03000 	mov	r3, r0
300197b4:	e58d300c 	str	r3, [sp, #12]
  if ((outif != NULL) && (outif->mtu != 0)) {
300197b8:	e59d300c 	ldr	r3, [sp, #12]
300197bc:	e3530000 	cmp	r3, #0
300197c0:	0a00000c 	beq	300197f8 <tcp_eff_send_mss+0x64>
300197c4:	e59d300c 	ldr	r3, [sp, #12]
300197c8:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
300197cc:	e3530000 	cmp	r3, #0
300197d0:	0a000008 	beq	300197f8 <tcp_eff_send_mss+0x64>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
300197d4:	e59d300c 	ldr	r3, [sp, #12]
300197d8:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
300197dc:	e2433028 	sub	r3, r3, #40	; 0x28
300197e0:	e1cd30ba 	strh	r3, [sp, #10]
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
300197e4:	e1dd20ba 	ldrh	r2, [sp, #10]
300197e8:	e1dd30b6 	ldrh	r3, [sp, #6]
300197ec:	e1520003 	cmp	r2, r3
300197f0:	31a03002 	movcc	r3, r2
300197f4:	e1cd30b6 	strh	r3, [sp, #6]
  }
  return sendmss;
300197f8:	e1dd30b6 	ldrh	r3, [sp, #6]
}
300197fc:	e1a00003 	mov	r0, r3
30019800:	e28dd014 	add	sp, sp, #20
30019804:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30019808:	e12fff1e 	bx	lr

3001980c <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
3001980c:	e92d4010 	push	{r4, lr}
30019810:	e24dd030 	sub	sp, sp, #48	; 0x30
30019814:	e58d000c 	str	r0, [sp, #12]
30019818:	e58d1008 	str	r1, [sp, #8]
	//===============
	// test by pegasus
		struct pbuf *q;
		int i, plen = p->tot_len;
3001981c:	e59d300c 	ldr	r3, [sp, #12]
30019820:	e1d330b8 	ldrh	r3, [r3, #8]
30019824:	e58d3018 	str	r3, [sp, #24]
  u8_t hdrlen;
  err_t err;

  PERF_START;

  TCP_STATS_INC(tcp.recv);
30019828:	e59f3e08 	ldr	r3, [pc, #3592]	; 3001a638 <tcp_input+0xe2c>
3001982c:	e1d33ab0 	ldrh	r3, [r3, #160]	; 0xa0
30019830:	e2833001 	add	r3, r3, #1
30019834:	e1a03803 	lsl	r3, r3, #16
30019838:	e1a02823 	lsr	r2, r3, #16
3001983c:	e59f3df4 	ldr	r3, [pc, #3572]	; 3001a638 <tcp_input+0xe2c>
30019840:	e1c32ab0 	strh	r2, [r3, #160]	; 0xa0
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
30019844:	e59d300c 	ldr	r3, [sp, #12]
30019848:	e5933004 	ldr	r3, [r3, #4]
3001984c:	e1a02003 	mov	r2, r3
30019850:	e59f3df0 	ldr	r3, [pc, #3568]	; 3001a648 <tcp_input+0xe3c>
30019854:	e5832000 	str	r2, [r3]
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
30019858:	e59d300c 	ldr	r3, [sp, #12]
3001985c:	e5933004 	ldr	r3, [r3, #4]
30019860:	e1a04003 	mov	r4, r3
30019864:	e59f3ddc 	ldr	r3, [pc, #3548]	; 3001a648 <tcp_input+0xe3c>
30019868:	e5933000 	ldr	r3, [r3]
3001986c:	e5d32000 	ldrb	r2, [r3]
30019870:	e5d33001 	ldrb	r3, [r3, #1]
30019874:	e1a03403 	lsl	r3, r3, #8
30019878:	e1833002 	orr	r3, r3, r2
3001987c:	e1a03803 	lsl	r3, r3, #16
30019880:	e1a03823 	lsr	r3, r3, #16
30019884:	e1a00003 	mov	r0, r3
30019888:	ebffe81e 	bl	30013908 <ntohs>
3001988c:	e1a03000 	mov	r3, r0
30019890:	e1a03423 	lsr	r3, r3, #8
30019894:	e1a03803 	lsl	r3, r3, #16
30019898:	e1a03823 	lsr	r3, r3, #16
3001989c:	e203300f 	and	r3, r3, #15
300198a0:	e1a03103 	lsl	r3, r3, #2
300198a4:	e0842003 	add	r2, r4, r3
300198a8:	e59f3d9c 	ldr	r3, [pc, #3484]	; 3001a64c <tcp_input+0xe40>
300198ac:	e5832000 	str	r2, [r3]
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
300198b0:	e59f3d90 	ldr	r3, [pc, #3472]	; 3001a648 <tcp_input+0xe3c>
300198b4:	e5933000 	ldr	r3, [r3]
300198b8:	e5d32000 	ldrb	r2, [r3]
300198bc:	e5d33001 	ldrb	r3, [r3, #1]
300198c0:	e1a03403 	lsl	r3, r3, #8
300198c4:	e1833002 	orr	r3, r3, r2
300198c8:	e1a03803 	lsl	r3, r3, #16
300198cc:	e1a03823 	lsr	r3, r3, #16
300198d0:	e1a00003 	mov	r0, r3
300198d4:	ebffe80b 	bl	30013908 <ntohs>
300198d8:	e1a03000 	mov	r3, r0
300198dc:	e1a03423 	lsr	r3, r3, #8
300198e0:	e1a03803 	lsl	r3, r3, #16
300198e4:	e1a03823 	lsr	r3, r3, #16
300198e8:	e203300f 	and	r3, r3, #15
300198ec:	e1a03103 	lsl	r3, r3, #2
300198f0:	e1a03803 	lsl	r3, r3, #16
300198f4:	e1a03823 	lsr	r3, r3, #16
300198f8:	e2633000 	rsb	r3, r3, #0
300198fc:	e1a03803 	lsl	r3, r3, #16
30019900:	e1a03823 	lsr	r3, r3, #16
30019904:	e1a03803 	lsl	r3, r3, #16
30019908:	e1a03843 	asr	r3, r3, #16
3001990c:	e59d000c 	ldr	r0, [sp, #12]
30019910:	e1a01003 	mov	r1, r3
30019914:	ebfff2a0 	bl	3001639c <pbuf_header>
30019918:	e1a03000 	mov	r3, r0
3001991c:	e3530000 	cmp	r3, #0
30019920:	1a000003 	bne	30019934 <tcp_input+0x128>
30019924:	e59d300c 	ldr	r3, [sp, #12]
30019928:	e1d330b8 	ldrh	r3, [r3, #8]
3001992c:	e3530013 	cmp	r3, #19
30019930:	8a000010 	bhi	30019978 <tcp_input+0x16c>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
30019934:	e59f3cfc 	ldr	r3, [pc, #3324]	; 3001a638 <tcp_input+0xe2c>
30019938:	e1d33ab8 	ldrh	r3, [r3, #168]	; 0xa8
3001993c:	e2833001 	add	r3, r3, #1
30019940:	e1a03803 	lsl	r3, r3, #16
30019944:	e1a02823 	lsr	r2, r3, #16
30019948:	e59f3ce8 	ldr	r3, [pc, #3304]	; 3001a638 <tcp_input+0xe2c>
3001994c:	e1c32ab8 	strh	r2, [r3, #168]	; 0xa8
    TCP_STATS_INC(tcp.drop);
30019950:	e59f3ce0 	ldr	r3, [pc, #3296]	; 3001a638 <tcp_input+0xe2c>
30019954:	e1d33ab4 	ldrh	r3, [r3, #164]	; 0xa4
30019958:	e2833001 	add	r3, r3, #1
3001995c:	e1a03803 	lsl	r3, r3, #16
30019960:	e1a02823 	lsr	r2, r3, #16
30019964:	e59f3ccc 	ldr	r3, [pc, #3276]	; 3001a638 <tcp_input+0xe2c>
30019968:	e1c32ab4 	strh	r2, [r3, #164]	; 0xa4
    snmp_inc_tcpinerrs();
    pbuf_free(p);
3001996c:	e59d000c 	ldr	r0, [sp, #12]
30019970:	ebfff2ee 	bl	30016530 <pbuf_free>
    return;
30019974:	ea000377 	b	3001a758 <tcp_input+0xf4c>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
30019978:	e59f3cc8 	ldr	r3, [pc, #3272]	; 3001a648 <tcp_input+0xe3c>
3001997c:	e5933000 	ldr	r3, [r3]
30019980:	e2833010 	add	r3, r3, #16
30019984:	e1a00003 	mov	r0, r3
30019988:	e59d1008 	ldr	r1, [sp, #8]
3001998c:	ebffed60 	bl	30014f14 <ip_addr_isbroadcast>
30019990:	e1a03000 	mov	r3, r0
30019994:	e3530000 	cmp	r3, #0
30019998:	1a000015 	bne	300199f4 <tcp_input+0x1e8>
      ip_addr_ismulticast(&(iphdr->dest))) {
3001999c:	e59f3ca4 	ldr	r3, [pc, #3236]	; 3001a648 <tcp_input+0xe3c>
300199a0:	e5933000 	ldr	r3, [r3]
300199a4:	e5d32010 	ldrb	r2, [r3, #16]
300199a8:	e5d31011 	ldrb	r1, [r3, #17]
300199ac:	e1a01401 	lsl	r1, r1, #8
300199b0:	e1812002 	orr	r2, r1, r2
300199b4:	e5d31012 	ldrb	r1, [r3, #18]
300199b8:	e1a01801 	lsl	r1, r1, #16
300199bc:	e1812002 	orr	r2, r1, r2
300199c0:	e5d33013 	ldrb	r3, [r3, #19]
300199c4:	e1a03c03 	lsl	r3, r3, #24
300199c8:	e1833002 	orr	r3, r3, r2
300199cc:	e1a04003 	mov	r4, r3
300199d0:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
300199d4:	ebffe7e9 	bl	30013980 <ntohl>
300199d8:	e1a03000 	mov	r3, r0
300199dc:	e0044003 	and	r4, r4, r3
300199e0:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
300199e4:	ebffe7e5 	bl	30013980 <ntohl>
300199e8:	e1a03000 	mov	r3, r0
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
300199ec:	e1540003 	cmp	r4, r3
300199f0:	1a000010 	bne	30019a38 <tcp_input+0x22c>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
300199f4:	e59f3c3c 	ldr	r3, [pc, #3132]	; 3001a638 <tcp_input+0xe2c>
300199f8:	e1d33abe 	ldrh	r3, [r3, #174]	; 0xae
300199fc:	e2833001 	add	r3, r3, #1
30019a00:	e1a03803 	lsl	r3, r3, #16
30019a04:	e1a02823 	lsr	r2, r3, #16
30019a08:	e59f3c28 	ldr	r3, [pc, #3112]	; 3001a638 <tcp_input+0xe2c>
30019a0c:	e1c32abe 	strh	r2, [r3, #174]	; 0xae
    TCP_STATS_INC(tcp.drop);
30019a10:	e59f3c20 	ldr	r3, [pc, #3104]	; 3001a638 <tcp_input+0xe2c>
30019a14:	e1d33ab4 	ldrh	r3, [r3, #164]	; 0xa4
30019a18:	e2833001 	add	r3, r3, #1
30019a1c:	e1a03803 	lsl	r3, r3, #16
30019a20:	e1a02823 	lsr	r2, r3, #16
30019a24:	e59f3c0c 	ldr	r3, [pc, #3084]	; 3001a638 <tcp_input+0xe2c>
30019a28:	e1c32ab4 	strh	r2, [r3, #164]	; 0xa4
    snmp_inc_tcpinerrs();
    pbuf_free(p);
30019a2c:	e59d000c 	ldr	r0, [sp, #12]
30019a30:	ebfff2be 	bl	30016530 <pbuf_free>
    return;
30019a34:	ea000347 	b	3001a758 <tcp_input+0xf4c>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
30019a38:	e59f3c08 	ldr	r3, [pc, #3080]	; 3001a648 <tcp_input+0xe3c>
30019a3c:	e5933000 	ldr	r3, [r3]
30019a40:	e283200c 	add	r2, r3, #12
      (struct ip_addr *)&(iphdr->dest),
30019a44:	e59f3bfc 	ldr	r3, [pc, #3068]	; 3001a648 <tcp_input+0xe3c>
30019a48:	e5933000 	ldr	r3, [r3]
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
30019a4c:	e2833010 	add	r3, r3, #16
30019a50:	e59d100c 	ldr	r1, [sp, #12]
30019a54:	e1d110b8 	ldrh	r1, [r1, #8]
30019a58:	e58d1000 	str	r1, [sp]
30019a5c:	e59d000c 	ldr	r0, [sp, #12]
30019a60:	e1a01002 	mov	r1, r2
30019a64:	e1a02003 	mov	r2, r3
30019a68:	e3a03006 	mov	r3, #6
30019a6c:	ebffe819 	bl	30013ad8 <inet_chksum_pseudo>
30019a70:	e1a03000 	mov	r3, r0
30019a74:	e3530000 	cmp	r3, #0
30019a78:	0a000010 	beq	30019ac0 <tcp_input+0x2b4>
        inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src), (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len)));
#if TCP_DEBUG
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
30019a7c:	e59f3bb4 	ldr	r3, [pc, #2996]	; 3001a638 <tcp_input+0xe2c>
30019a80:	e1d33ab6 	ldrh	r3, [r3, #166]	; 0xa6
30019a84:	e2833001 	add	r3, r3, #1
30019a88:	e1a03803 	lsl	r3, r3, #16
30019a8c:	e1a02823 	lsr	r2, r3, #16
30019a90:	e59f3ba0 	ldr	r3, [pc, #2976]	; 3001a638 <tcp_input+0xe2c>
30019a94:	e1c32ab6 	strh	r2, [r3, #166]	; 0xa6
    TCP_STATS_INC(tcp.drop);
30019a98:	e59f3b98 	ldr	r3, [pc, #2968]	; 3001a638 <tcp_input+0xe2c>
30019a9c:	e1d33ab4 	ldrh	r3, [r3, #164]	; 0xa4
30019aa0:	e2833001 	add	r3, r3, #1
30019aa4:	e1a03803 	lsl	r3, r3, #16
30019aa8:	e1a02823 	lsr	r2, r3, #16
30019aac:	e59f3b84 	ldr	r3, [pc, #2948]	; 3001a638 <tcp_input+0xe2c>
30019ab0:	e1c32ab4 	strh	r2, [r3, #164]	; 0xa4
    snmp_inc_tcpinerrs();
    pbuf_free(p);
30019ab4:	e59d000c 	ldr	r0, [sp, #12]
30019ab8:	ebfff29c 	bl	30016530 <pbuf_free>
    return;
30019abc:	ea000325 	b	3001a758 <tcp_input+0xf4c>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
30019ac0:	e59f3b84 	ldr	r3, [pc, #2948]	; 3001a64c <tcp_input+0xe40>
30019ac4:	e5933000 	ldr	r3, [r3]
30019ac8:	e5d3200c 	ldrb	r2, [r3, #12]
30019acc:	e5d3300d 	ldrb	r3, [r3, #13]
30019ad0:	e1a03403 	lsl	r3, r3, #8
30019ad4:	e1833002 	orr	r3, r3, r2
30019ad8:	e1a03803 	lsl	r3, r3, #16
30019adc:	e1a03823 	lsr	r3, r3, #16
30019ae0:	e1a00003 	mov	r0, r3
30019ae4:	ebffe787 	bl	30013908 <ntohs>
30019ae8:	e1a03000 	mov	r3, r0
30019aec:	e1a03623 	lsr	r3, r3, #12
30019af0:	e1a03803 	lsl	r3, r3, #16
30019af4:	e1a03823 	lsr	r3, r3, #16
30019af8:	e5cd302e 	strb	r3, [sp, #46]	; 0x2e
  if(pbuf_header(p, -(hdrlen * 4))){
30019afc:	e5dd302e 	ldrb	r3, [sp, #46]	; 0x2e
30019b00:	e1a02003 	mov	r2, r3
30019b04:	e1a02702 	lsl	r2, r2, #14
30019b08:	e0633002 	rsb	r3, r3, r2
30019b0c:	e1a03103 	lsl	r3, r3, #2
30019b10:	e1a03803 	lsl	r3, r3, #16
30019b14:	e1a03823 	lsr	r3, r3, #16
30019b18:	e1a03803 	lsl	r3, r3, #16
30019b1c:	e1a03843 	asr	r3, r3, #16
30019b20:	e59d000c 	ldr	r0, [sp, #12]
30019b24:	e1a01003 	mov	r1, r3
30019b28:	ebfff21b 	bl	3001639c <pbuf_header>
30019b2c:	e1a03000 	mov	r3, r0
30019b30:	e3530000 	cmp	r3, #0
30019b34:	0a000010 	beq	30019b7c <tcp_input+0x370>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
30019b38:	e59f3af8 	ldr	r3, [pc, #2808]	; 3001a638 <tcp_input+0xe2c>
30019b3c:	e1d33ab8 	ldrh	r3, [r3, #168]	; 0xa8
30019b40:	e2833001 	add	r3, r3, #1
30019b44:	e1a03803 	lsl	r3, r3, #16
30019b48:	e1a02823 	lsr	r2, r3, #16
30019b4c:	e59f3ae4 	ldr	r3, [pc, #2788]	; 3001a638 <tcp_input+0xe2c>
30019b50:	e1c32ab8 	strh	r2, [r3, #168]	; 0xa8
    TCP_STATS_INC(tcp.drop);
30019b54:	e59f3adc 	ldr	r3, [pc, #2780]	; 3001a638 <tcp_input+0xe2c>
30019b58:	e1d33ab4 	ldrh	r3, [r3, #164]	; 0xa4
30019b5c:	e2833001 	add	r3, r3, #1
30019b60:	e1a03803 	lsl	r3, r3, #16
30019b64:	e1a02823 	lsr	r2, r3, #16
30019b68:	e59f3ac8 	ldr	r3, [pc, #2760]	; 3001a638 <tcp_input+0xe2c>
30019b6c:	e1c32ab4 	strh	r2, [r3, #164]	; 0xa4
    snmp_inc_tcpinerrs();
    pbuf_free(p);
30019b70:	e59d000c 	ldr	r0, [sp, #12]
30019b74:	ebfff26d 	bl	30016530 <pbuf_free>
    return;
30019b78:	ea0002f6 	b	3001a758 <tcp_input+0xf4c>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
30019b7c:	e59f3ac8 	ldr	r3, [pc, #2760]	; 3001a64c <tcp_input+0xe40>
30019b80:	e5934000 	ldr	r4, [r3]
30019b84:	e59f3ac0 	ldr	r3, [pc, #2752]	; 3001a64c <tcp_input+0xe40>
30019b88:	e5933000 	ldr	r3, [r3]
30019b8c:	e5d32000 	ldrb	r2, [r3]
30019b90:	e5d33001 	ldrb	r3, [r3, #1]
30019b94:	e1a03403 	lsl	r3, r3, #8
30019b98:	e1833002 	orr	r3, r3, r2
30019b9c:	e1a03803 	lsl	r3, r3, #16
30019ba0:	e1a03823 	lsr	r3, r3, #16
30019ba4:	e1a00003 	mov	r0, r3
30019ba8:	ebffe756 	bl	30013908 <ntohs>
30019bac:	e1a03000 	mov	r3, r0
30019bb0:	e20320ff 	and	r2, r3, #255	; 0xff
30019bb4:	e3a01000 	mov	r1, #0
30019bb8:	e1812002 	orr	r2, r1, r2
30019bbc:	e5c42000 	strb	r2, [r4]
30019bc0:	e1a03423 	lsr	r3, r3, #8
30019bc4:	e1a03803 	lsl	r3, r3, #16
30019bc8:	e1a03823 	lsr	r3, r3, #16
30019bcc:	e3a02000 	mov	r2, #0
30019bd0:	e1823003 	orr	r3, r2, r3
30019bd4:	e5c43001 	strb	r3, [r4, #1]
  tcphdr->dest = ntohs(tcphdr->dest);
30019bd8:	e59f3a6c 	ldr	r3, [pc, #2668]	; 3001a64c <tcp_input+0xe40>
30019bdc:	e5934000 	ldr	r4, [r3]
30019be0:	e59f3a64 	ldr	r3, [pc, #2660]	; 3001a64c <tcp_input+0xe40>
30019be4:	e5933000 	ldr	r3, [r3]
30019be8:	e5d32002 	ldrb	r2, [r3, #2]
30019bec:	e5d33003 	ldrb	r3, [r3, #3]
30019bf0:	e1a03403 	lsl	r3, r3, #8
30019bf4:	e1833002 	orr	r3, r3, r2
30019bf8:	e1a03803 	lsl	r3, r3, #16
30019bfc:	e1a03823 	lsr	r3, r3, #16
30019c00:	e1a00003 	mov	r0, r3
30019c04:	ebffe73f 	bl	30013908 <ntohs>
30019c08:	e1a03000 	mov	r3, r0
30019c0c:	e20320ff 	and	r2, r3, #255	; 0xff
30019c10:	e3a01000 	mov	r1, #0
30019c14:	e1812002 	orr	r2, r1, r2
30019c18:	e5c42002 	strb	r2, [r4, #2]
30019c1c:	e1a03423 	lsr	r3, r3, #8
30019c20:	e1a03803 	lsl	r3, r3, #16
30019c24:	e1a03823 	lsr	r3, r3, #16
30019c28:	e3a02000 	mov	r2, #0
30019c2c:	e1823003 	orr	r3, r2, r3
30019c30:	e5c43003 	strb	r3, [r4, #3]
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
30019c34:	e59f3a10 	ldr	r3, [pc, #2576]	; 3001a64c <tcp_input+0xe40>
30019c38:	e5934000 	ldr	r4, [r3]
30019c3c:	e59f3a08 	ldr	r3, [pc, #2568]	; 3001a64c <tcp_input+0xe40>
30019c40:	e5933000 	ldr	r3, [r3]
30019c44:	e5d32004 	ldrb	r2, [r3, #4]
30019c48:	e5d31005 	ldrb	r1, [r3, #5]
30019c4c:	e1a01401 	lsl	r1, r1, #8
30019c50:	e1812002 	orr	r2, r1, r2
30019c54:	e5d31006 	ldrb	r1, [r3, #6]
30019c58:	e1a01801 	lsl	r1, r1, #16
30019c5c:	e1812002 	orr	r2, r1, r2
30019c60:	e5d33007 	ldrb	r3, [r3, #7]
30019c64:	e1a03c03 	lsl	r3, r3, #24
30019c68:	e1833002 	orr	r3, r3, r2
30019c6c:	e1a00003 	mov	r0, r3
30019c70:	ebffe742 	bl	30013980 <ntohl>
30019c74:	e1a03000 	mov	r3, r0
30019c78:	e20320ff 	and	r2, r3, #255	; 0xff
30019c7c:	e3a01000 	mov	r1, #0
30019c80:	e1812002 	orr	r2, r1, r2
30019c84:	e5c42004 	strb	r2, [r4, #4]
30019c88:	e1a02423 	lsr	r2, r3, #8
30019c8c:	e20220ff 	and	r2, r2, #255	; 0xff
30019c90:	e3a01000 	mov	r1, #0
30019c94:	e1812002 	orr	r2, r1, r2
30019c98:	e5c42005 	strb	r2, [r4, #5]
30019c9c:	e1a02823 	lsr	r2, r3, #16
30019ca0:	e20220ff 	and	r2, r2, #255	; 0xff
30019ca4:	e3a01000 	mov	r1, #0
30019ca8:	e1812002 	orr	r2, r1, r2
30019cac:	e5c42006 	strb	r2, [r4, #6]
30019cb0:	e1a03c23 	lsr	r3, r3, #24
30019cb4:	e3a02000 	mov	r2, #0
30019cb8:	e1823003 	orr	r3, r2, r3
30019cbc:	e5c43007 	strb	r3, [r4, #7]
30019cc0:	e5d43004 	ldrb	r3, [r4, #4]
30019cc4:	e5d42005 	ldrb	r2, [r4, #5]
30019cc8:	e1a02402 	lsl	r2, r2, #8
30019ccc:	e1823003 	orr	r3, r2, r3
30019cd0:	e5d42006 	ldrb	r2, [r4, #6]
30019cd4:	e1a02802 	lsl	r2, r2, #16
30019cd8:	e1823003 	orr	r3, r2, r3
30019cdc:	e5d42007 	ldrb	r2, [r4, #7]
30019ce0:	e1a02c02 	lsl	r2, r2, #24
30019ce4:	e1823003 	orr	r3, r2, r3
30019ce8:	e1a02003 	mov	r2, r3
30019cec:	e59f3950 	ldr	r3, [pc, #2384]	; 3001a644 <tcp_input+0xe38>
30019cf0:	e5832000 	str	r2, [r3]
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
30019cf4:	e59f3950 	ldr	r3, [pc, #2384]	; 3001a64c <tcp_input+0xe40>
30019cf8:	e5934000 	ldr	r4, [r3]
30019cfc:	e59f3948 	ldr	r3, [pc, #2376]	; 3001a64c <tcp_input+0xe40>
30019d00:	e5933000 	ldr	r3, [r3]
30019d04:	e5d32008 	ldrb	r2, [r3, #8]
30019d08:	e5d31009 	ldrb	r1, [r3, #9]
30019d0c:	e1a01401 	lsl	r1, r1, #8
30019d10:	e1812002 	orr	r2, r1, r2
30019d14:	e5d3100a 	ldrb	r1, [r3, #10]
30019d18:	e1a01801 	lsl	r1, r1, #16
30019d1c:	e1812002 	orr	r2, r1, r2
30019d20:	e5d3300b 	ldrb	r3, [r3, #11]
30019d24:	e1a03c03 	lsl	r3, r3, #24
30019d28:	e1833002 	orr	r3, r3, r2
30019d2c:	e1a00003 	mov	r0, r3
30019d30:	ebffe712 	bl	30013980 <ntohl>
30019d34:	e1a03000 	mov	r3, r0
30019d38:	e20320ff 	and	r2, r3, #255	; 0xff
30019d3c:	e3a01000 	mov	r1, #0
30019d40:	e1812002 	orr	r2, r1, r2
30019d44:	e5c42008 	strb	r2, [r4, #8]
30019d48:	e1a02423 	lsr	r2, r3, #8
30019d4c:	e20220ff 	and	r2, r2, #255	; 0xff
30019d50:	e3a01000 	mov	r1, #0
30019d54:	e1812002 	orr	r2, r1, r2
30019d58:	e5c42009 	strb	r2, [r4, #9]
30019d5c:	e1a02823 	lsr	r2, r3, #16
30019d60:	e20220ff 	and	r2, r2, #255	; 0xff
30019d64:	e3a01000 	mov	r1, #0
30019d68:	e1812002 	orr	r2, r1, r2
30019d6c:	e5c4200a 	strb	r2, [r4, #10]
30019d70:	e1a03c23 	lsr	r3, r3, #24
30019d74:	e3a02000 	mov	r2, #0
30019d78:	e1823003 	orr	r3, r2, r3
30019d7c:	e5c4300b 	strb	r3, [r4, #11]
30019d80:	e5d43008 	ldrb	r3, [r4, #8]
30019d84:	e5d42009 	ldrb	r2, [r4, #9]
30019d88:	e1a02402 	lsl	r2, r2, #8
30019d8c:	e1823003 	orr	r3, r2, r3
30019d90:	e5d4200a 	ldrb	r2, [r4, #10]
30019d94:	e1a02802 	lsl	r2, r2, #16
30019d98:	e1823003 	orr	r3, r2, r3
30019d9c:	e5d4200b 	ldrb	r2, [r4, #11]
30019da0:	e1a02c02 	lsl	r2, r2, #24
30019da4:	e1823003 	orr	r3, r2, r3
30019da8:	e1a02003 	mov	r2, r3
30019dac:	e59f3888 	ldr	r3, [pc, #2184]	; 3001a63c <tcp_input+0xe30>
30019db0:	e5832000 	str	r2, [r3]
  tcphdr->wnd = ntohs(tcphdr->wnd);
30019db4:	e59f3890 	ldr	r3, [pc, #2192]	; 3001a64c <tcp_input+0xe40>
30019db8:	e5934000 	ldr	r4, [r3]
30019dbc:	e59f3888 	ldr	r3, [pc, #2184]	; 3001a64c <tcp_input+0xe40>
30019dc0:	e5933000 	ldr	r3, [r3]
30019dc4:	e5d3200e 	ldrb	r2, [r3, #14]
30019dc8:	e5d3300f 	ldrb	r3, [r3, #15]
30019dcc:	e1a03403 	lsl	r3, r3, #8
30019dd0:	e1833002 	orr	r3, r3, r2
30019dd4:	e1a03803 	lsl	r3, r3, #16
30019dd8:	e1a03823 	lsr	r3, r3, #16
30019ddc:	e1a00003 	mov	r0, r3
30019de0:	ebffe6c8 	bl	30013908 <ntohs>
30019de4:	e1a03000 	mov	r3, r0
30019de8:	e20320ff 	and	r2, r3, #255	; 0xff
30019dec:	e3a01000 	mov	r1, #0
30019df0:	e1812002 	orr	r2, r1, r2
30019df4:	e5c4200e 	strb	r2, [r4, #14]
30019df8:	e1a03423 	lsr	r3, r3, #8
30019dfc:	e1a03803 	lsl	r3, r3, #16
30019e00:	e1a03823 	lsr	r3, r3, #16
30019e04:	e3a02000 	mov	r2, #0
30019e08:	e1823003 	orr	r3, r2, r3
30019e0c:	e5c4300f 	strb	r3, [r4, #15]

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
30019e10:	e59f3834 	ldr	r3, [pc, #2100]	; 3001a64c <tcp_input+0xe40>
30019e14:	e5933000 	ldr	r3, [r3]
30019e18:	e5d3200c 	ldrb	r2, [r3, #12]
30019e1c:	e5d3300d 	ldrb	r3, [r3, #13]
30019e20:	e1a03403 	lsl	r3, r3, #8
30019e24:	e1833002 	orr	r3, r3, r2
30019e28:	e1a03803 	lsl	r3, r3, #16
30019e2c:	e1a03823 	lsr	r3, r3, #16
30019e30:	e1a00003 	mov	r0, r3
30019e34:	ebffe6b3 	bl	30013908 <ntohs>
30019e38:	e1a03000 	mov	r3, r0
30019e3c:	e20330ff 	and	r3, r3, #255	; 0xff
30019e40:	e203303f 	and	r3, r3, #63	; 0x3f
30019e44:	e59f27cc 	ldr	r2, [pc, #1996]	; 3001a618 <tcp_input+0xe0c>
30019e48:	e5c23000 	strb	r3, [r2]
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
30019e4c:	e59d300c 	ldr	r3, [sp, #12]
30019e50:	e1d320b8 	ldrh	r2, [r3, #8]
30019e54:	e59f37bc 	ldr	r3, [pc, #1980]	; 3001a618 <tcp_input+0xe0c>
30019e58:	e5d33000 	ldrb	r3, [r3]
30019e5c:	e2033001 	and	r3, r3, #1
30019e60:	e20330ff 	and	r3, r3, #255	; 0xff
30019e64:	e3530000 	cmp	r3, #0
30019e68:	1a000004 	bne	30019e80 <tcp_input+0x674>
30019e6c:	e59f37a4 	ldr	r3, [pc, #1956]	; 3001a618 <tcp_input+0xe0c>
30019e70:	e5d33000 	ldrb	r3, [r3]
30019e74:	e2033002 	and	r3, r3, #2
30019e78:	e3530000 	cmp	r3, #0
30019e7c:	0a000001 	beq	30019e88 <tcp_input+0x67c>
30019e80:	e3a03001 	mov	r3, #1
30019e84:	ea000000 	b	30019e8c <tcp_input+0x680>
30019e88:	e3a03000 	mov	r3, #0
30019e8c:	e1a03803 	lsl	r3, r3, #16
30019e90:	e1a03823 	lsr	r3, r3, #16
30019e94:	e0823003 	add	r3, r2, r3
30019e98:	e1a03803 	lsl	r3, r3, #16
30019e9c:	e1a02823 	lsr	r2, r3, #16
30019ea0:	e59f3798 	ldr	r3, [pc, #1944]	; 3001a640 <tcp_input+0xe34>
30019ea4:	e1c320b0 	strh	r2, [r3]

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
30019ea8:	e3a03000 	mov	r3, #0
30019eac:	e58d3024 	str	r3, [sp, #36]	; 0x24

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
30019eb0:	e59f3764 	ldr	r3, [pc, #1892]	; 3001a61c <tcp_input+0xe10>
30019eb4:	e5933000 	ldr	r3, [r3]
30019eb8:	e58d3020 	str	r3, [sp, #32]
30019ebc:	ea00004b 	b	30019ff0 <tcp_input+0x7e4>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
30019ec0:	e59d3020 	ldr	r3, [sp, #32]
30019ec4:	e1d321ba 	ldrh	r2, [r3, #26]
30019ec8:	e59f377c 	ldr	r3, [pc, #1916]	; 3001a64c <tcp_input+0xe40>
30019ecc:	e5933000 	ldr	r3, [r3]
30019ed0:	e5d31000 	ldrb	r1, [r3]
30019ed4:	e5d33001 	ldrb	r3, [r3, #1]
30019ed8:	e1a03403 	lsl	r3, r3, #8
30019edc:	e1833001 	orr	r3, r3, r1
30019ee0:	e1a03803 	lsl	r3, r3, #16
30019ee4:	e1a03823 	lsr	r3, r3, #16
30019ee8:	e1520003 	cmp	r2, r3
30019eec:	1a00003a 	bne	30019fdc <tcp_input+0x7d0>
       pcb->local_port == tcphdr->dest &&
30019ef0:	e59d3020 	ldr	r3, [sp, #32]
30019ef4:	e1d321b8 	ldrh	r2, [r3, #24]
30019ef8:	e59f374c 	ldr	r3, [pc, #1868]	; 3001a64c <tcp_input+0xe40>
30019efc:	e5933000 	ldr	r3, [r3]
30019f00:	e5d31002 	ldrb	r1, [r3, #2]
30019f04:	e5d33003 	ldrb	r3, [r3, #3]
30019f08:	e1a03403 	lsl	r3, r3, #8
30019f0c:	e1833001 	orr	r3, r3, r1
30019f10:	e1a03803 	lsl	r3, r3, #16
30019f14:	e1a03823 	lsr	r3, r3, #16
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
30019f18:	e1520003 	cmp	r2, r3
30019f1c:	1a00002e 	bne	30019fdc <tcp_input+0x7d0>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
30019f20:	e59d3020 	ldr	r3, [sp, #32]
30019f24:	e5932004 	ldr	r2, [r3, #4]
30019f28:	e59f3718 	ldr	r3, [pc, #1816]	; 3001a648 <tcp_input+0xe3c>
30019f2c:	e5933000 	ldr	r3, [r3]
30019f30:	e5d3100c 	ldrb	r1, [r3, #12]
30019f34:	e5d3000d 	ldrb	r0, [r3, #13]
30019f38:	e1a00400 	lsl	r0, r0, #8
30019f3c:	e1801001 	orr	r1, r0, r1
30019f40:	e5d3000e 	ldrb	r0, [r3, #14]
30019f44:	e1a00800 	lsl	r0, r0, #16
30019f48:	e1801001 	orr	r1, r0, r1
30019f4c:	e5d3300f 	ldrb	r3, [r3, #15]
30019f50:	e1a03c03 	lsl	r3, r3, #24
30019f54:	e1833001 	orr	r3, r3, r1
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
30019f58:	e1520003 	cmp	r2, r3
30019f5c:	1a00001e 	bne	30019fdc <tcp_input+0x7d0>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
30019f60:	e59d3020 	ldr	r3, [sp, #32]
30019f64:	e5932000 	ldr	r2, [r3]
30019f68:	e59f36d8 	ldr	r3, [pc, #1752]	; 3001a648 <tcp_input+0xe3c>
30019f6c:	e5933000 	ldr	r3, [r3]
30019f70:	e5d31010 	ldrb	r1, [r3, #16]
30019f74:	e5d30011 	ldrb	r0, [r3, #17]
30019f78:	e1a00400 	lsl	r0, r0, #8
30019f7c:	e1801001 	orr	r1, r0, r1
30019f80:	e5d30012 	ldrb	r0, [r3, #18]
30019f84:	e1a00800 	lsl	r0, r0, #16
30019f88:	e1801001 	orr	r1, r0, r1
30019f8c:	e5d33013 	ldrb	r3, [r3, #19]
30019f90:	e1a03c03 	lsl	r3, r3, #24
30019f94:	e1833001 	orr	r3, r3, r1
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
30019f98:	e1520003 	cmp	r2, r3
30019f9c:	1a00000e 	bne	30019fdc <tcp_input+0x7d0>

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
30019fa0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30019fa4:	e3530000 	cmp	r3, #0
30019fa8:	0a000014 	beq	3001a000 <tcp_input+0x7f4>
        prev->next = pcb->next;
30019fac:	e59d3020 	ldr	r3, [sp, #32]
30019fb0:	e593200c 	ldr	r2, [r3, #12]
30019fb4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30019fb8:	e583200c 	str	r2, [r3, #12]
        pcb->next = tcp_active_pcbs;
30019fbc:	e59f3658 	ldr	r3, [pc, #1624]	; 3001a61c <tcp_input+0xe10>
30019fc0:	e5932000 	ldr	r2, [r3]
30019fc4:	e59d3020 	ldr	r3, [sp, #32]
30019fc8:	e583200c 	str	r2, [r3, #12]
        tcp_active_pcbs = pcb;
30019fcc:	e59f3648 	ldr	r3, [pc, #1608]	; 3001a61c <tcp_input+0xe10>
30019fd0:	e59d2020 	ldr	r2, [sp, #32]
30019fd4:	e5832000 	str	r2, [r3]
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
30019fd8:	ea000009 	b	3001a004 <tcp_input+0x7f8>
    }
    prev = pcb;
30019fdc:	e59d3020 	ldr	r3, [sp, #32]
30019fe0:	e58d3024 	str	r3, [sp, #36]	; 0x24
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
30019fe4:	e59d3020 	ldr	r3, [sp, #32]
30019fe8:	e593300c 	ldr	r3, [r3, #12]
30019fec:	e58d3020 	str	r3, [sp, #32]
30019ff0:	e59d3020 	ldr	r3, [sp, #32]
30019ff4:	e3530000 	cmp	r3, #0
30019ff8:	1affffb0 	bne	30019ec0 <tcp_input+0x6b4>
30019ffc:	ea000000 	b	3001a004 <tcp_input+0x7f8>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
3001a000:	e1a00000 	nop			; (mov r0, r0)
    }
    prev = pcb;
  }

  if (pcb == NULL) {
3001a004:	e59d3020 	ldr	r3, [sp, #32]
3001a008:	e3530000 	cmp	r3, #0
3001a00c:	1a00008a 	bne	3001a23c <tcp_input+0xa30>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
3001a010:	e59f3608 	ldr	r3, [pc, #1544]	; 3001a620 <tcp_input+0xe14>
3001a014:	e5933000 	ldr	r3, [r3]
3001a018:	e58d3020 	str	r3, [sp, #32]
3001a01c:	ea00003f 	b	3001a120 <tcp_input+0x914>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
3001a020:	e59d3020 	ldr	r3, [sp, #32]
3001a024:	e1d321ba 	ldrh	r2, [r3, #26]
3001a028:	e59f361c 	ldr	r3, [pc, #1564]	; 3001a64c <tcp_input+0xe40>
3001a02c:	e5933000 	ldr	r3, [r3]
3001a030:	e5d31000 	ldrb	r1, [r3]
3001a034:	e5d33001 	ldrb	r3, [r3, #1]
3001a038:	e1a03403 	lsl	r3, r3, #8
3001a03c:	e1833001 	orr	r3, r3, r1
3001a040:	e1a03803 	lsl	r3, r3, #16
3001a044:	e1a03823 	lsr	r3, r3, #16
3001a048:	e1520003 	cmp	r2, r3
3001a04c:	1a000030 	bne	3001a114 <tcp_input+0x908>
         pcb->local_port == tcphdr->dest &&
3001a050:	e59d3020 	ldr	r3, [sp, #32]
3001a054:	e1d321b8 	ldrh	r2, [r3, #24]
3001a058:	e59f35ec 	ldr	r3, [pc, #1516]	; 3001a64c <tcp_input+0xe40>
3001a05c:	e5933000 	ldr	r3, [r3]
3001a060:	e5d31002 	ldrb	r1, [r3, #2]
3001a064:	e5d33003 	ldrb	r3, [r3, #3]
3001a068:	e1a03403 	lsl	r3, r3, #8
3001a06c:	e1833001 	orr	r3, r3, r1
3001a070:	e1a03803 	lsl	r3, r3, #16
3001a074:	e1a03823 	lsr	r3, r3, #16
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
3001a078:	e1520003 	cmp	r2, r3
3001a07c:	1a000024 	bne	3001a114 <tcp_input+0x908>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
3001a080:	e59d3020 	ldr	r3, [sp, #32]
3001a084:	e5932004 	ldr	r2, [r3, #4]
3001a088:	e59f35b8 	ldr	r3, [pc, #1464]	; 3001a648 <tcp_input+0xe3c>
3001a08c:	e5933000 	ldr	r3, [r3]
3001a090:	e5d3100c 	ldrb	r1, [r3, #12]
3001a094:	e5d3000d 	ldrb	r0, [r3, #13]
3001a098:	e1a00400 	lsl	r0, r0, #8
3001a09c:	e1801001 	orr	r1, r0, r1
3001a0a0:	e5d3000e 	ldrb	r0, [r3, #14]
3001a0a4:	e1a00800 	lsl	r0, r0, #16
3001a0a8:	e1801001 	orr	r1, r0, r1
3001a0ac:	e5d3300f 	ldrb	r3, [r3, #15]
3001a0b0:	e1a03c03 	lsl	r3, r3, #24
3001a0b4:	e1833001 	orr	r3, r3, r1
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
3001a0b8:	e1520003 	cmp	r2, r3
3001a0bc:	1a000014 	bne	3001a114 <tcp_input+0x908>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
3001a0c0:	e59d3020 	ldr	r3, [sp, #32]
3001a0c4:	e5932000 	ldr	r2, [r3]
3001a0c8:	e59f3578 	ldr	r3, [pc, #1400]	; 3001a648 <tcp_input+0xe3c>
3001a0cc:	e5933000 	ldr	r3, [r3]
3001a0d0:	e5d31010 	ldrb	r1, [r3, #16]
3001a0d4:	e5d30011 	ldrb	r0, [r3, #17]
3001a0d8:	e1a00400 	lsl	r0, r0, #8
3001a0dc:	e1801001 	orr	r1, r0, r1
3001a0e0:	e5d30012 	ldrb	r0, [r3, #18]
3001a0e4:	e1a00800 	lsl	r0, r0, #16
3001a0e8:	e1801001 	orr	r1, r0, r1
3001a0ec:	e5d33013 	ldrb	r3, [r3, #19]
3001a0f0:	e1a03c03 	lsl	r3, r3, #24
3001a0f4:	e1833001 	orr	r3, r3, r1
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
3001a0f8:	e1520003 	cmp	r2, r3
3001a0fc:	1a000004 	bne	3001a114 <tcp_input+0x908>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
3001a100:	e59d0020 	ldr	r0, [sp, #32]
3001a104:	eb000275 	bl	3001aae0 <tcp_timewait_input>
        pbuf_free(p);
3001a108:	e59d000c 	ldr	r0, [sp, #12]
3001a10c:	ebfff107 	bl	30016530 <pbuf_free>
        return;
3001a110:	ea000190 	b	3001a758 <tcp_input+0xf4c>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
3001a114:	e59d3020 	ldr	r3, [sp, #32]
3001a118:	e593300c 	ldr	r3, [r3, #12]
3001a11c:	e58d3020 	str	r3, [sp, #32]
3001a120:	e59d3020 	ldr	r3, [sp, #32]
3001a124:	e3530000 	cmp	r3, #0
3001a128:	1affffbc 	bne	3001a020 <tcp_input+0x814>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
3001a12c:	e3a03000 	mov	r3, #0
3001a130:	e58d3024 	str	r3, [sp, #36]	; 0x24
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
3001a134:	e59f34e8 	ldr	r3, [pc, #1256]	; 3001a624 <tcp_input+0xe18>
3001a138:	e5933000 	ldr	r3, [r3]
3001a13c:	e58d3028 	str	r3, [sp, #40]	; 0x28
3001a140:	ea00003a 	b	3001a230 <tcp_input+0xa24>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
3001a144:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001a148:	e3530000 	cmp	r3, #0
3001a14c:	0a000013 	beq	3001a1a0 <tcp_input+0x994>
3001a150:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001a154:	e5933000 	ldr	r3, [r3]
3001a158:	e3530000 	cmp	r3, #0
3001a15c:	0a00000f 	beq	3001a1a0 <tcp_input+0x994>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
3001a160:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001a164:	e5932000 	ldr	r2, [r3]
3001a168:	e59f34d8 	ldr	r3, [pc, #1240]	; 3001a648 <tcp_input+0xe3c>
3001a16c:	e5933000 	ldr	r3, [r3]
3001a170:	e5d31010 	ldrb	r1, [r3, #16]
3001a174:	e5d30011 	ldrb	r0, [r3, #17]
3001a178:	e1a00400 	lsl	r0, r0, #8
3001a17c:	e1801001 	orr	r1, r0, r1
3001a180:	e5d30012 	ldrb	r0, [r3, #18]
3001a184:	e1a00800 	lsl	r0, r0, #16
3001a188:	e1801001 	orr	r1, r0, r1
3001a18c:	e5d33013 	ldrb	r3, [r3, #19]
3001a190:	e1a03c03 	lsl	r3, r3, #24
3001a194:	e1833001 	orr	r3, r3, r1

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
3001a198:	e1520003 	cmp	r2, r3
3001a19c:	1a00001e 	bne	3001a21c <tcp_input+0xa10>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
3001a1a0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001a1a4:	e1d321b8 	ldrh	r2, [r3, #24]
3001a1a8:	e59f349c 	ldr	r3, [pc, #1180]	; 3001a64c <tcp_input+0xe40>
3001a1ac:	e5933000 	ldr	r3, [r3]
3001a1b0:	e5d31002 	ldrb	r1, [r3, #2]
3001a1b4:	e5d33003 	ldrb	r3, [r3, #3]
3001a1b8:	e1a03403 	lsl	r3, r3, #8
3001a1bc:	e1833001 	orr	r3, r3, r1
3001a1c0:	e1a03803 	lsl	r3, r3, #16
3001a1c4:	e1a03823 	lsr	r3, r3, #16

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
3001a1c8:	e1520003 	cmp	r2, r3
3001a1cc:	1a000012 	bne	3001a21c <tcp_input+0xa10>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
3001a1d0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001a1d4:	e3530000 	cmp	r3, #0
3001a1d8:	0a00000a 	beq	3001a208 <tcp_input+0x9fc>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
3001a1dc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001a1e0:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
3001a1e4:	e592200c 	ldr	r2, [r2, #12]
3001a1e8:	e583200c 	str	r2, [r3, #12]
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
3001a1ec:	e59f3430 	ldr	r3, [pc, #1072]	; 3001a624 <tcp_input+0xe18>
3001a1f0:	e5932000 	ldr	r2, [r3]
3001a1f4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001a1f8:	e583200c 	str	r2, [r3, #12]
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
3001a1fc:	e59f3420 	ldr	r3, [pc, #1056]	; 3001a624 <tcp_input+0xe18>
3001a200:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
3001a204:	e5832000 	str	r2, [r3]
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
3001a208:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
3001a20c:	eb000154 	bl	3001a764 <tcp_listen_input>
        pbuf_free(p);
3001a210:	e59d000c 	ldr	r0, [sp, #12]
3001a214:	ebfff0c5 	bl	30016530 <pbuf_free>
        return;
3001a218:	ea00014e 	b	3001a758 <tcp_input+0xf4c>
      }
      prev = (struct tcp_pcb *)lpcb;
3001a21c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001a220:	e58d3024 	str	r3, [sp, #36]	; 0x24
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
3001a224:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001a228:	e593300c 	ldr	r3, [r3, #12]
3001a22c:	e58d3028 	str	r3, [sp, #40]	; 0x28
3001a230:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001a234:	e3530000 	cmp	r3, #0
3001a238:	1affffc1 	bne	3001a144 <tcp_input+0x938>
			lwip_printf("\r\n<*<*<*>*>*>\r\n");

		}
		lwip_printf("\r\n+++++++++++++++++++++\r\n");
		/**/
  if (pcb != NULL) {
3001a23c:	e59d3020 	ldr	r3, [sp, #32]
3001a240:	e3530000 	cmp	r3, #0
3001a244:	0a000101 	beq	3001a650 <tcp_input+0xe44>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
3001a248:	e59f33d8 	ldr	r3, [pc, #984]	; 3001a628 <tcp_input+0xe1c>
3001a24c:	e3a02000 	mov	r2, #0
3001a250:	e5832000 	str	r2, [r3]
    inseg.len = p->tot_len;
3001a254:	e59d300c 	ldr	r3, [sp, #12]
3001a258:	e1d320b8 	ldrh	r2, [r3, #8]
3001a25c:	e59f33c4 	ldr	r3, [pc, #964]	; 3001a628 <tcp_input+0xe1c>
3001a260:	e1c320bc 	strh	r2, [r3, #12]
    inseg.dataptr = p->payload;
3001a264:	e59d300c 	ldr	r3, [sp, #12]
3001a268:	e5932004 	ldr	r2, [r3, #4]
3001a26c:	e59f33b4 	ldr	r3, [pc, #948]	; 3001a628 <tcp_input+0xe1c>
3001a270:	e5832008 	str	r2, [r3, #8]
    inseg.p = p;
3001a274:	e59f33ac 	ldr	r3, [pc, #940]	; 3001a628 <tcp_input+0xe1c>
3001a278:	e59d200c 	ldr	r2, [sp, #12]
3001a27c:	e5832004 	str	r2, [r3, #4]
    inseg.tcphdr = tcphdr;
3001a280:	e59f33c4 	ldr	r3, [pc, #964]	; 3001a64c <tcp_input+0xe40>
3001a284:	e5932000 	ldr	r2, [r3]
3001a288:	e59f3398 	ldr	r3, [pc, #920]	; 3001a628 <tcp_input+0xe1c>
3001a28c:	e5832010 	str	r2, [r3, #16]

    recv_data = NULL;
3001a290:	e59f3394 	ldr	r3, [pc, #916]	; 3001a62c <tcp_input+0xe20>
3001a294:	e3a02000 	mov	r2, #0
3001a298:	e5832000 	str	r2, [r3]
    recv_flags = 0;
3001a29c:	e59f338c 	ldr	r3, [pc, #908]	; 3001a630 <tcp_input+0xe24>
3001a2a0:	e3a02000 	mov	r2, #0
3001a2a4:	e5c32000 	strb	r2, [r3]

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
3001a2a8:	e59d3020 	ldr	r3, [sp, #32]
3001a2ac:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
3001a2b0:	e3530000 	cmp	r3, #0
3001a2b4:	0a00002e 	beq	3001a374 <tcp_input+0xb68>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
3001a2b8:	e59d3020 	ldr	r3, [sp, #32]
3001a2bc:	e5933084 	ldr	r3, [r3, #132]	; 0x84
3001a2c0:	e3530000 	cmp	r3, #0
3001a2c4:	0a00000f 	beq	3001a308 <tcp_input+0xafc>
3001a2c8:	e59d3020 	ldr	r3, [sp, #32]
3001a2cc:	e593c084 	ldr	ip, [r3, #132]	; 0x84
3001a2d0:	e59d3020 	ldr	r3, [sp, #32]
3001a2d4:	e5932014 	ldr	r2, [r3, #20]
3001a2d8:	e59d3020 	ldr	r3, [sp, #32]
3001a2dc:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
3001a2e0:	e1a00002 	mov	r0, r2
3001a2e4:	e59d1020 	ldr	r1, [sp, #32]
3001a2e8:	e1a02003 	mov	r2, r3
3001a2ec:	e3a03000 	mov	r3, #0
3001a2f0:	e1a0e00f 	mov	lr, pc
3001a2f4:	e12fff1c 	bx	ip
3001a2f8:	e1a03000 	mov	r3, r0
3001a2fc:	e20330ff 	and	r3, r3, #255	; 0xff
3001a300:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
3001a304:	ea000009 	b	3001a330 <tcp_input+0xb24>
3001a308:	e3a03000 	mov	r3, #0
3001a30c:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
3001a310:	e59d3020 	ldr	r3, [sp, #32]
3001a314:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
3001a318:	e3530000 	cmp	r3, #0
3001a31c:	0a000003 	beq	3001a330 <tcp_input+0xb24>
3001a320:	e59d3020 	ldr	r3, [sp, #32]
3001a324:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
3001a328:	e1a00003 	mov	r0, r3
3001a32c:	ebfff07f 	bl	30016530 <pbuf_free>
      //lwip_printf("\r\n1111111111\r\n");
      if (err == ERR_OK) {
3001a330:	e1dd32df 	ldrsb	r3, [sp, #47]	; 0x2f
3001a334:	e3530000 	cmp	r3, #0
3001a338:	1a000003 	bne	3001a34c <tcp_input+0xb40>
        pcb->refused_data = NULL;
3001a33c:	e59d3020 	ldr	r3, [sp, #32]
3001a340:	e3a02000 	mov	r2, #0
3001a344:	e583207c 	str	r2, [r3, #124]	; 0x7c
3001a348:	ea000009 	b	3001a374 <tcp_input+0xb68>
      } else {
      	//lwip_printf("\r\n222222\r\n");
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
3001a34c:	e59f32e4 	ldr	r3, [pc, #740]	; 3001a638 <tcp_input+0xe2c>
3001a350:	e1d33ab4 	ldrh	r3, [r3, #164]	; 0xa4
3001a354:	e2833001 	add	r3, r3, #1
3001a358:	e1a03803 	lsl	r3, r3, #16
3001a35c:	e1a02823 	lsr	r2, r3, #16
3001a360:	e59f32d0 	ldr	r3, [pc, #720]	; 3001a638 <tcp_input+0xe2c>
3001a364:	e1c32ab4 	strh	r2, [r3, #164]	; 0xa4
        snmp_inc_tcpinerrs();
        pbuf_free(p);
3001a368:	e59d000c 	ldr	r0, [sp, #12]
3001a36c:	ebfff06f 	bl	30016530 <pbuf_free>
        return;
3001a370:	ea0000f8 	b	3001a758 <tcp_input+0xf4c>
      }
    }

    tcp_input_pcb = pcb;
3001a374:	e59f32b8 	ldr	r3, [pc, #696]	; 3001a634 <tcp_input+0xe28>
3001a378:	e59d2020 	ldr	r2, [sp, #32]
3001a37c:	e5832000 	str	r2, [r3]
    err = tcp_process(pcb);
3001a380:	e59d0020 	ldr	r0, [sp, #32]
3001a384:	eb000204 	bl	3001ab9c <tcp_process>
3001a388:	e1a03000 	mov	r3, r0
3001a38c:	e20330ff 	and	r3, r3, #255	; 0xff
3001a390:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
    tcp_input_pcb = NULL;
3001a394:	e59f3298 	ldr	r3, [pc, #664]	; 3001a634 <tcp_input+0xe28>
3001a398:	e3a02000 	mov	r2, #0
3001a39c:	e5832000 	str	r2, [r3]
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
3001a3a0:	e1dd32df 	ldrsb	r3, [sp, #47]	; 0x2f
3001a3a4:	e3730004 	cmn	r3, #4
3001a3a8:	0a00008e 	beq	3001a5e8 <tcp_input+0xddc>
      if (recv_flags & TF_RESET) {
3001a3ac:	e59f327c 	ldr	r3, [pc, #636]	; 3001a630 <tcp_input+0xe24>
3001a3b0:	e5d33000 	ldrb	r3, [r3]
3001a3b4:	e2033008 	and	r3, r3, #8
3001a3b8:	e3530000 	cmp	r3, #0
3001a3bc:	0a000012 	beq	3001a40c <tcp_input+0xc00>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        //lwip_printf("\r\n33333333333\r\n");
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
3001a3c0:	e59d3020 	ldr	r3, [sp, #32]
3001a3c4:	e5933094 	ldr	r3, [r3, #148]	; 0x94
3001a3c8:	e3530000 	cmp	r3, #0
3001a3cc:	0a000007 	beq	3001a3f0 <tcp_input+0xbe4>
3001a3d0:	e59d3020 	ldr	r3, [sp, #32]
3001a3d4:	e5933094 	ldr	r3, [r3, #148]	; 0x94
3001a3d8:	e59d2020 	ldr	r2, [sp, #32]
3001a3dc:	e5922014 	ldr	r2, [r2, #20]
3001a3e0:	e1a00002 	mov	r0, r2
3001a3e4:	e3e01004 	mvn	r1, #4
3001a3e8:	e1a0e00f 	mov	lr, pc
3001a3ec:	e12fff13 	bx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
3001a3f0:	e59f0224 	ldr	r0, [pc, #548]	; 3001a61c <tcp_input+0xe10>
3001a3f4:	e59d1020 	ldr	r1, [sp, #32]
3001a3f8:	ebfffc88 	bl	30019620 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
3001a3fc:	e3a00002 	mov	r0, #2
3001a400:	e59d1020 	ldr	r1, [sp, #32]
3001a404:	ebffecde 	bl	30015784 <memp_free>
3001a408:	ea000076 	b	3001a5e8 <tcp_input+0xddc>
      } else if (recv_flags & TF_CLOSED) {
3001a40c:	e59f321c 	ldr	r3, [pc, #540]	; 3001a630 <tcp_input+0xe24>
3001a410:	e5d33000 	ldrb	r3, [r3]
3001a414:	e2033010 	and	r3, r3, #16
3001a418:	e3530000 	cmp	r3, #0
3001a41c:	0a000006 	beq	3001a43c <tcp_input+0xc30>
        /* The connection has been closed and we will deallocate the
           PCB. */
        //lwip_printf("\r\n444444444\r\n");
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
3001a420:	e59f01f4 	ldr	r0, [pc, #500]	; 3001a61c <tcp_input+0xe10>
3001a424:	e59d1020 	ldr	r1, [sp, #32]
3001a428:	ebfffc7c 	bl	30019620 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
3001a42c:	e3a00002 	mov	r0, #2
3001a430:	e59d1020 	ldr	r1, [sp, #32]
3001a434:	ebffecd2 	bl	30015784 <memp_free>
3001a438:	ea00006a 	b	3001a5e8 <tcp_input+0xddc>
      } else {
      	//lwip_printf("\r\n555555555555\r\n");
        err = ERR_OK;
3001a43c:	e3a03000 	mov	r3, #0
3001a440:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
3001a444:	e59d3020 	ldr	r3, [sp, #32]
3001a448:	e1d336b8 	ldrh	r3, [r3, #104]	; 0x68
3001a44c:	e3530000 	cmp	r3, #0
3001a450:	0a000010 	beq	3001a498 <tcp_input+0xc8c>
			lwip_printf("\r\n<*<*<*>*>*>\r\n");

		}
		lwip_printf("\r\n+++++++++++++++++++++\r\n");
		/**/
          TCP_EVENT_SENT(pcb, pcb->acked, err);
3001a454:	e59d3020 	ldr	r3, [sp, #32]
3001a458:	e5933080 	ldr	r3, [r3, #128]	; 0x80
3001a45c:	e3530000 	cmp	r3, #0
3001a460:	0a00000c 	beq	3001a498 <tcp_input+0xc8c>
3001a464:	e59d3020 	ldr	r3, [sp, #32]
3001a468:	e5933080 	ldr	r3, [r3, #128]	; 0x80
3001a46c:	e59d2020 	ldr	r2, [sp, #32]
3001a470:	e5921014 	ldr	r1, [r2, #20]
3001a474:	e59d2020 	ldr	r2, [sp, #32]
3001a478:	e1d226b8 	ldrh	r2, [r2, #104]	; 0x68
3001a47c:	e1a00001 	mov	r0, r1
3001a480:	e59d1020 	ldr	r1, [sp, #32]
3001a484:	e1a0e00f 	mov	lr, pc
3001a488:	e12fff13 	bx	r3
3001a48c:	e1a03000 	mov	r3, r0
3001a490:	e20330ff 	and	r3, r3, #255	; 0xff
3001a494:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
        }
      
        if (recv_data != NULL) {
3001a498:	e59f318c 	ldr	r3, [pc, #396]	; 3001a62c <tcp_input+0xe20>
3001a49c:	e5933000 	ldr	r3, [r3]
3001a4a0:	e3530000 	cmp	r3, #0
3001a4a4:	0a000031 	beq	3001a570 <tcp_input+0xd64>
          if(flags & TCP_PSH) {
3001a4a8:	e59f3168 	ldr	r3, [pc, #360]	; 3001a618 <tcp_input+0xe0c>
3001a4ac:	e5d33000 	ldrb	r3, [r3]
3001a4b0:	e2033008 	and	r3, r3, #8
3001a4b4:	e3530000 	cmp	r3, #0
3001a4b8:	0a000007 	beq	3001a4dc <tcp_input+0xcd0>
            recv_data->flags |= PBUF_FLAG_PUSH;
3001a4bc:	e59f3168 	ldr	r3, [pc, #360]	; 3001a62c <tcp_input+0xe20>
3001a4c0:	e5933000 	ldr	r3, [r3]
3001a4c4:	e59f2160 	ldr	r2, [pc, #352]	; 3001a62c <tcp_input+0xe20>
3001a4c8:	e5922000 	ldr	r2, [r2]
3001a4cc:	e5d2200d 	ldrb	r2, [r2, #13]
3001a4d0:	e3822001 	orr	r2, r2, #1
3001a4d4:	e20220ff 	and	r2, r2, #255	; 0xff
3001a4d8:	e5c3200d 	strb	r2, [r3, #13]
          }
		  //lwip_printf("\r\n7777777777\r\n");
          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
3001a4dc:	e59d3020 	ldr	r3, [sp, #32]
3001a4e0:	e5933084 	ldr	r3, [r3, #132]	; 0x84
3001a4e4:	e3530000 	cmp	r3, #0
3001a4e8:	0a00000f 	beq	3001a52c <tcp_input+0xd20>
3001a4ec:	e59d3020 	ldr	r3, [sp, #32]
3001a4f0:	e593c084 	ldr	ip, [r3, #132]	; 0x84
3001a4f4:	e59d3020 	ldr	r3, [sp, #32]
3001a4f8:	e5932014 	ldr	r2, [r3, #20]
3001a4fc:	e59f3128 	ldr	r3, [pc, #296]	; 3001a62c <tcp_input+0xe20>
3001a500:	e5933000 	ldr	r3, [r3]
3001a504:	e1a00002 	mov	r0, r2
3001a508:	e59d1020 	ldr	r1, [sp, #32]
3001a50c:	e1a02003 	mov	r2, r3
3001a510:	e3a03000 	mov	r3, #0
3001a514:	e1a0e00f 	mov	lr, pc
3001a518:	e12fff1c 	bx	ip
3001a51c:	e1a03000 	mov	r3, r0
3001a520:	e20330ff 	and	r3, r3, #255	; 0xff
3001a524:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
3001a528:	ea000009 	b	3001a554 <tcp_input+0xd48>
3001a52c:	e3a03000 	mov	r3, #0
3001a530:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
3001a534:	e59f30f0 	ldr	r3, [pc, #240]	; 3001a62c <tcp_input+0xe20>
3001a538:	e5933000 	ldr	r3, [r3]
3001a53c:	e3530000 	cmp	r3, #0
3001a540:	0a000003 	beq	3001a554 <tcp_input+0xd48>
3001a544:	e59f30e0 	ldr	r3, [pc, #224]	; 3001a62c <tcp_input+0xe20>
3001a548:	e5933000 	ldr	r3, [r3]
3001a54c:	e1a00003 	mov	r0, r3
3001a550:	ebffeff6 	bl	30016530 <pbuf_free>

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
3001a554:	e1dd32df 	ldrsb	r3, [sp, #47]	; 0x2f
3001a558:	e3530000 	cmp	r3, #0
3001a55c:	0a000003 	beq	3001a570 <tcp_input+0xd64>
            pcb->refused_data = recv_data;
3001a560:	e59f30c4 	ldr	r3, [pc, #196]	; 3001a62c <tcp_input+0xe20>
3001a564:	e5932000 	ldr	r2, [r3]
3001a568:	e59d3020 	ldr	r3, [sp, #32]
3001a56c:	e583207c 	str	r2, [r3, #124]	; 0x7c
          }
        }
		//lwip_printf("\r\n888888888\r\n");
        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
3001a570:	e59f30b8 	ldr	r3, [pc, #184]	; 3001a630 <tcp_input+0xe24>
3001a574:	e5d33000 	ldrb	r3, [r3]
3001a578:	e2033020 	and	r3, r3, #32
3001a57c:	e3530000 	cmp	r3, #0
3001a580:	0a000013 	beq	3001a5d4 <tcp_input+0xdc8>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
3001a584:	e59d3020 	ldr	r3, [sp, #32]
3001a588:	e5933084 	ldr	r3, [r3, #132]	; 0x84
3001a58c:	e3530000 	cmp	r3, #0
3001a590:	0a00000d 	beq	3001a5cc <tcp_input+0xdc0>
3001a594:	e59d3020 	ldr	r3, [sp, #32]
3001a598:	e593c084 	ldr	ip, [r3, #132]	; 0x84
3001a59c:	e59d3020 	ldr	r3, [sp, #32]
3001a5a0:	e5933014 	ldr	r3, [r3, #20]
3001a5a4:	e1a00003 	mov	r0, r3
3001a5a8:	e59d1020 	ldr	r1, [sp, #32]
3001a5ac:	e3a02000 	mov	r2, #0
3001a5b0:	e3a03000 	mov	r3, #0
3001a5b4:	e1a0e00f 	mov	lr, pc
3001a5b8:	e12fff1c 	bx	ip
3001a5bc:	e1a03000 	mov	r3, r0
3001a5c0:	e20330ff 	and	r3, r3, #255	; 0xff
3001a5c4:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
3001a5c8:	ea000001 	b	3001a5d4 <tcp_input+0xdc8>
3001a5cc:	e3a03000 	mov	r3, #0
3001a5d0:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
        }
		//lwip_printf("\r\n9999999999999\r\n");
        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
3001a5d4:	e1dd32df 	ldrsb	r3, [sp, #47]	; 0x2f
3001a5d8:	e3530000 	cmp	r3, #0
3001a5dc:	1a000001 	bne	3001a5e8 <tcp_input+0xddc>
        	//lwip_printf("\r\n000000000000\r\n");
            tcp_output(pcb);
3001a5e0:	e59d0020 	ldr	r0, [sp, #32]
3001a5e4:	eb000f26 	bl	3001e284 <tcp_output>
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
3001a5e8:	e59f3038 	ldr	r3, [pc, #56]	; 3001a628 <tcp_input+0xe1c>
3001a5ec:	e5933004 	ldr	r3, [r3, #4]
3001a5f0:	e3530000 	cmp	r3, #0
3001a5f4:	0a000056 	beq	3001a754 <tcp_input+0xf48>
    {
      pbuf_free(inseg.p);
3001a5f8:	e59f3028 	ldr	r3, [pc, #40]	; 3001a628 <tcp_input+0xe1c>
3001a5fc:	e5933004 	ldr	r3, [r3, #4]
3001a600:	e1a00003 	mov	r0, r3
3001a604:	ebffefc9 	bl	30016530 <pbuf_free>
      inseg.p = NULL;
3001a608:	e59f3018 	ldr	r3, [pc, #24]	; 3001a628 <tcp_input+0xe1c>
3001a60c:	e3a02000 	mov	r2, #0
3001a610:	e5832004 	str	r2, [r3, #4]
3001a614:	ea00004f 	b	3001a758 <tcp_input+0xf4c>
3001a618:	30028f80 	.word	0x30028f80
3001a61c:	3002a6e8 	.word	0x3002a6e8
3001a620:	3002b1c4 	.word	0x3002b1c4
3001a624:	3002a728 	.word	0x3002a728
3001a628:	30028f5c 	.word	0x30028f5c
3001a62c:	30028f88 	.word	0x30028f88
3001a630:	30028f84 	.word	0x30028f84
3001a634:	3002a87c 	.word	0x3002a87c
3001a638:	3002b214 	.word	0x3002b214
3001a63c:	30028f7c 	.word	0x30028f7c
3001a640:	30028f82 	.word	0x30028f82
3001a644:	30028f78 	.word	0x30028f78
3001a648:	30028f74 	.word	0x30028f74
3001a64c:	30028f70 	.word	0x30028f70
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
3001a650:	e51f300c 	ldr	r3, [pc, #-12]	; 3001a64c <tcp_input+0xe40>
3001a654:	e5933000 	ldr	r3, [r3]
3001a658:	e5d3200c 	ldrb	r2, [r3, #12]
3001a65c:	e5d3300d 	ldrb	r3, [r3, #13]
3001a660:	e1a03403 	lsl	r3, r3, #8
3001a664:	e1833002 	orr	r3, r3, r2
3001a668:	e1a03803 	lsl	r3, r3, #16
3001a66c:	e1a03823 	lsr	r3, r3, #16
3001a670:	e1a00003 	mov	r0, r3
3001a674:	ebffe4a3 	bl	30013908 <ntohs>
3001a678:	e1a03000 	mov	r3, r0
3001a67c:	e2033004 	and	r3, r3, #4
3001a680:	e3530000 	cmp	r3, #0
3001a684:	1a00002f 	bne	3001a748 <tcp_input+0xf3c>
      TCP_STATS_INC(tcp.proterr);
3001a688:	e51f3058 	ldr	r3, [pc, #-88]	; 3001a638 <tcp_input+0xe2c>
3001a68c:	e1d33abe 	ldrh	r3, [r3, #174]	; 0xae
3001a690:	e2833001 	add	r3, r3, #1
3001a694:	e1a03803 	lsl	r3, r3, #16
3001a698:	e1a02823 	lsr	r2, r3, #16
3001a69c:	e51f306c 	ldr	r3, [pc, #-108]	; 3001a638 <tcp_input+0xe2c>
3001a6a0:	e1c32abe 	strh	r2, [r3, #174]	; 0xae
      TCP_STATS_INC(tcp.drop);
3001a6a4:	e51f3074 	ldr	r3, [pc, #-116]	; 3001a638 <tcp_input+0xe2c>
3001a6a8:	e1d33ab4 	ldrh	r3, [r3, #164]	; 0xa4
3001a6ac:	e2833001 	add	r3, r3, #1
3001a6b0:	e1a03803 	lsl	r3, r3, #16
3001a6b4:	e1a02823 	lsr	r2, r3, #16
3001a6b8:	e51f3088 	ldr	r3, [pc, #-136]	; 3001a638 <tcp_input+0xe2c>
3001a6bc:	e1c32ab4 	strh	r2, [r3, #164]	; 0xa4
      tcp_rst(ackno, seqno + tcplen,
3001a6c0:	e51f308c 	ldr	r3, [pc, #-140]	; 3001a63c <tcp_input+0xe30>
3001a6c4:	e5930000 	ldr	r0, [r3]
3001a6c8:	e51f3090 	ldr	r3, [pc, #-144]	; 3001a640 <tcp_input+0xe34>
3001a6cc:	e1d330b0 	ldrh	r3, [r3]
3001a6d0:	e1a02003 	mov	r2, r3
3001a6d4:	e51f3098 	ldr	r3, [pc, #-152]	; 3001a644 <tcp_input+0xe38>
3001a6d8:	e5933000 	ldr	r3, [r3]
3001a6dc:	e0821003 	add	r1, r2, r3
        &(iphdr->dest), &(iphdr->src),
3001a6e0:	e51f30a0 	ldr	r3, [pc, #-160]	; 3001a648 <tcp_input+0xe3c>
3001a6e4:	e5933000 	ldr	r3, [r3]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
3001a6e8:	e2832010 	add	r2, r3, #16
        &(iphdr->dest), &(iphdr->src),
3001a6ec:	e51f30ac 	ldr	r3, [pc, #-172]	; 3001a648 <tcp_input+0xe3c>
3001a6f0:	e5933000 	ldr	r3, [r3]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
3001a6f4:	e283c00c 	add	ip, r3, #12
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
3001a6f8:	e51f30b4 	ldr	r3, [pc, #-180]	; 3001a64c <tcp_input+0xe40>
3001a6fc:	e5933000 	ldr	r3, [r3]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
3001a700:	e5d3e002 	ldrb	lr, [r3, #2]
3001a704:	e5d33003 	ldrb	r3, [r3, #3]
3001a708:	e1a03403 	lsl	r3, r3, #8
3001a70c:	e183300e 	orr	r3, r3, lr
3001a710:	e1a03803 	lsl	r3, r3, #16
3001a714:	e1a0e823 	lsr	lr, r3, #16
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
3001a718:	e51f30d4 	ldr	r3, [pc, #-212]	; 3001a64c <tcp_input+0xe40>
3001a71c:	e5933000 	ldr	r3, [r3]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
3001a720:	e5d34000 	ldrb	r4, [r3]
3001a724:	e5d33001 	ldrb	r3, [r3, #1]
3001a728:	e1a03403 	lsl	r3, r3, #8
3001a72c:	e1833004 	orr	r3, r3, r4
3001a730:	e1a03803 	lsl	r3, r3, #16
3001a734:	e1a03823 	lsr	r3, r3, #16
3001a738:	e58de000 	str	lr, [sp]
3001a73c:	e58d3004 	str	r3, [sp, #4]
3001a740:	e1a0300c 	mov	r3, ip
3001a744:	eb001205 	bl	3001ef60 <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
3001a748:	e59d000c 	ldr	r0, [sp, #12]
3001a74c:	ebffef77 	bl	30016530 <pbuf_free>
3001a750:	ea000000 	b	3001a758 <tcp_input+0xf4c>

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
    {
      pbuf_free(inseg.p);
      inseg.p = NULL;
3001a754:	e1a00000 	nop			; (mov r0, r0)
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
3001a758:	e28dd030 	add	sp, sp, #48	; 0x30
3001a75c:	e8bd4010 	pop	{r4, lr}
3001a760:	e12fff1e 	bx	lr

3001a764 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
3001a764:	e92d4010 	push	{r4, lr}
3001a768:	e24dd020 	sub	sp, sp, #32
3001a76c:	e58d0014 	str	r0, [sp, #20]
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
3001a770:	e59f3348 	ldr	r3, [pc, #840]	; 3001aac0 <tcp_listen_input+0x35c>
3001a774:	e5d33000 	ldrb	r3, [r3]
3001a778:	e2033010 	and	r3, r3, #16
3001a77c:	e3530000 	cmp	r3, #0
3001a780:	0a000023 	beq	3001a814 <tcp_listen_input+0xb0>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
3001a784:	e59f3338 	ldr	r3, [pc, #824]	; 3001aac4 <tcp_listen_input+0x360>
3001a788:	e5933000 	ldr	r3, [r3]
3001a78c:	e2830001 	add	r0, r3, #1
3001a790:	e59f3330 	ldr	r3, [pc, #816]	; 3001aac8 <tcp_listen_input+0x364>
3001a794:	e1d330b0 	ldrh	r3, [r3]
3001a798:	e1a02003 	mov	r2, r3
3001a79c:	e59f3328 	ldr	r3, [pc, #808]	; 3001aacc <tcp_listen_input+0x368>
3001a7a0:	e5933000 	ldr	r3, [r3]
3001a7a4:	e0821003 	add	r1, r2, r3
      &(iphdr->dest), &(iphdr->src),
3001a7a8:	e59f3320 	ldr	r3, [pc, #800]	; 3001aad0 <tcp_listen_input+0x36c>
3001a7ac:	e5933000 	ldr	r3, [r3]
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
3001a7b0:	e2832010 	add	r2, r3, #16
      &(iphdr->dest), &(iphdr->src),
3001a7b4:	e59f3314 	ldr	r3, [pc, #788]	; 3001aad0 <tcp_listen_input+0x36c>
3001a7b8:	e5933000 	ldr	r3, [r3]
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
3001a7bc:	e283c00c 	add	ip, r3, #12
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
3001a7c0:	e59f330c 	ldr	r3, [pc, #780]	; 3001aad4 <tcp_listen_input+0x370>
3001a7c4:	e5933000 	ldr	r3, [r3]
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
3001a7c8:	e5d3e002 	ldrb	lr, [r3, #2]
3001a7cc:	e5d33003 	ldrb	r3, [r3, #3]
3001a7d0:	e1a03403 	lsl	r3, r3, #8
3001a7d4:	e183300e 	orr	r3, r3, lr
3001a7d8:	e1a03803 	lsl	r3, r3, #16
3001a7dc:	e1a0e823 	lsr	lr, r3, #16
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
3001a7e0:	e59f32ec 	ldr	r3, [pc, #748]	; 3001aad4 <tcp_listen_input+0x370>
3001a7e4:	e5933000 	ldr	r3, [r3]
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
3001a7e8:	e5d34000 	ldrb	r4, [r3]
3001a7ec:	e5d33001 	ldrb	r3, [r3, #1]
3001a7f0:	e1a03403 	lsl	r3, r3, #8
3001a7f4:	e1833004 	orr	r3, r3, r4
3001a7f8:	e1a03803 	lsl	r3, r3, #16
3001a7fc:	e1a03823 	lsr	r3, r3, #16
3001a800:	e58de000 	str	lr, [sp]
3001a804:	e58d3004 	str	r3, [sp, #4]
3001a808:	e1a0300c 	mov	r3, ip
3001a80c:	eb0011d3 	bl	3001ef60 <tcp_rst>
3001a810:	ea0000a3 	b	3001aaa4 <tcp_listen_input+0x340>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
3001a814:	e59f32a4 	ldr	r3, [pc, #676]	; 3001aac0 <tcp_listen_input+0x35c>
3001a818:	e5d33000 	ldrb	r3, [r3]
3001a81c:	e2033002 	and	r3, r3, #2
3001a820:	e3530000 	cmp	r3, #0
3001a824:	0a00009e 	beq	3001aaa4 <tcp_listen_input+0x340>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
3001a828:	e59d3014 	ldr	r3, [sp, #20]
3001a82c:	e5d33011 	ldrb	r3, [r3, #17]
3001a830:	e1a00003 	mov	r0, r3
3001a834:	ebfffa95 	bl	30019290 <tcp_alloc>
3001a838:	e1a03000 	mov	r3, r0
3001a83c:	e58d301c 	str	r3, [sp, #28]
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
3001a840:	e59d301c 	ldr	r3, [sp, #28]
3001a844:	e3530000 	cmp	r3, #0
3001a848:	1a000008 	bne	3001a870 <tcp_listen_input+0x10c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
3001a84c:	e59f3284 	ldr	r3, [pc, #644]	; 3001aad8 <tcp_listen_input+0x374>
3001a850:	e1d33aba 	ldrh	r3, [r3, #170]	; 0xaa
3001a854:	e2833001 	add	r3, r3, #1
3001a858:	e1a03803 	lsl	r3, r3, #16
3001a85c:	e1a02823 	lsr	r2, r3, #16
3001a860:	e59f3270 	ldr	r3, [pc, #624]	; 3001aad8 <tcp_listen_input+0x374>
3001a864:	e1c32aba 	strh	r2, [r3, #170]	; 0xaa
      return ERR_MEM;
3001a868:	e3a030ff 	mov	r3, #255	; 0xff
3001a86c:	ea00008d 	b	3001aaa8 <tcp_listen_input+0x344>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
3001a870:	e59f3258 	ldr	r3, [pc, #600]	; 3001aad0 <tcp_listen_input+0x36c>
3001a874:	e5933000 	ldr	r3, [r3]
3001a878:	e2833010 	add	r3, r3, #16
3001a87c:	e3530000 	cmp	r3, #0
3001a880:	0a00000c 	beq	3001a8b8 <tcp_listen_input+0x154>
3001a884:	e59f3244 	ldr	r3, [pc, #580]	; 3001aad0 <tcp_listen_input+0x36c>
3001a888:	e5933000 	ldr	r3, [r3]
3001a88c:	e5d32010 	ldrb	r2, [r3, #16]
3001a890:	e5d31011 	ldrb	r1, [r3, #17]
3001a894:	e1a01401 	lsl	r1, r1, #8
3001a898:	e1812002 	orr	r2, r1, r2
3001a89c:	e5d31012 	ldrb	r1, [r3, #18]
3001a8a0:	e1a01801 	lsl	r1, r1, #16
3001a8a4:	e1812002 	orr	r2, r1, r2
3001a8a8:	e5d33013 	ldrb	r3, [r3, #19]
3001a8ac:	e1a03c03 	lsl	r3, r3, #24
3001a8b0:	e1833002 	orr	r3, r3, r2
3001a8b4:	ea000000 	b	3001a8bc <tcp_listen_input+0x158>
3001a8b8:	e3a03000 	mov	r3, #0
3001a8bc:	e59d201c 	ldr	r2, [sp, #28]
3001a8c0:	e5823000 	str	r3, [r2]
    npcb->local_port = pcb->local_port;
3001a8c4:	e59d3014 	ldr	r3, [sp, #20]
3001a8c8:	e1d321b8 	ldrh	r2, [r3, #24]
3001a8cc:	e59d301c 	ldr	r3, [sp, #28]
3001a8d0:	e1c321b8 	strh	r2, [r3, #24]
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
3001a8d4:	e59f31f4 	ldr	r3, [pc, #500]	; 3001aad0 <tcp_listen_input+0x36c>
3001a8d8:	e5933000 	ldr	r3, [r3]
3001a8dc:	e283300c 	add	r3, r3, #12
3001a8e0:	e3530000 	cmp	r3, #0
3001a8e4:	0a00000c 	beq	3001a91c <tcp_listen_input+0x1b8>
3001a8e8:	e59f31e0 	ldr	r3, [pc, #480]	; 3001aad0 <tcp_listen_input+0x36c>
3001a8ec:	e5933000 	ldr	r3, [r3]
3001a8f0:	e5d3200c 	ldrb	r2, [r3, #12]
3001a8f4:	e5d3100d 	ldrb	r1, [r3, #13]
3001a8f8:	e1a01401 	lsl	r1, r1, #8
3001a8fc:	e1812002 	orr	r2, r1, r2
3001a900:	e5d3100e 	ldrb	r1, [r3, #14]
3001a904:	e1a01801 	lsl	r1, r1, #16
3001a908:	e1812002 	orr	r2, r1, r2
3001a90c:	e5d3300f 	ldrb	r3, [r3, #15]
3001a910:	e1a03c03 	lsl	r3, r3, #24
3001a914:	e1833002 	orr	r3, r3, r2
3001a918:	ea000000 	b	3001a920 <tcp_listen_input+0x1bc>
3001a91c:	e3a03000 	mov	r3, #0
3001a920:	e59d201c 	ldr	r2, [sp, #28]
3001a924:	e5823004 	str	r3, [r2, #4]
    npcb->remote_port = tcphdr->src;
3001a928:	e59f31a4 	ldr	r3, [pc, #420]	; 3001aad4 <tcp_listen_input+0x370>
3001a92c:	e5933000 	ldr	r3, [r3]
3001a930:	e5d32000 	ldrb	r2, [r3]
3001a934:	e5d33001 	ldrb	r3, [r3, #1]
3001a938:	e1a03403 	lsl	r3, r3, #8
3001a93c:	e1833002 	orr	r3, r3, r2
3001a940:	e1a03803 	lsl	r3, r3, #16
3001a944:	e1a02823 	lsr	r2, r3, #16
3001a948:	e59d301c 	ldr	r3, [sp, #28]
3001a94c:	e1c321ba 	strh	r2, [r3, #26]
    npcb->state = SYN_RCVD;
3001a950:	e59d301c 	ldr	r3, [sp, #28]
3001a954:	e3a02003 	mov	r2, #3
3001a958:	e5c32010 	strb	r2, [r3, #16]
    npcb->rcv_nxt = seqno + 1;
3001a95c:	e59f3168 	ldr	r3, [pc, #360]	; 3001aacc <tcp_listen_input+0x368>
3001a960:	e5933000 	ldr	r3, [r3]
3001a964:	e2832001 	add	r2, r3, #1
3001a968:	e59d301c 	ldr	r3, [sp, #28]
3001a96c:	e5832020 	str	r2, [r3, #32]
    npcb->snd_wnd = tcphdr->wnd;
3001a970:	e59f315c 	ldr	r3, [pc, #348]	; 3001aad4 <tcp_listen_input+0x370>
3001a974:	e5933000 	ldr	r3, [r3]
3001a978:	e5d3200e 	ldrb	r2, [r3, #14]
3001a97c:	e5d3300f 	ldrb	r3, [r3, #15]
3001a980:	e1a03403 	lsl	r3, r3, #8
3001a984:	e1833002 	orr	r3, r3, r2
3001a988:	e1a03803 	lsl	r3, r3, #16
3001a98c:	e1a02823 	lsr	r2, r3, #16
3001a990:	e59d301c 	ldr	r3, [sp, #28]
3001a994:	e1c325b8 	strh	r2, [r3, #88]	; 0x58
    npcb->ssthresh = npcb->snd_wnd;
3001a998:	e59d301c 	ldr	r3, [sp, #28]
3001a99c:	e1d325b8 	ldrh	r2, [r3, #88]	; 0x58
3001a9a0:	e59d301c 	ldr	r3, [sp, #28]
3001a9a4:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
3001a9a8:	e59f311c 	ldr	r3, [pc, #284]	; 3001aacc <tcp_listen_input+0x368>
3001a9ac:	e5933000 	ldr	r3, [r3]
3001a9b0:	e2432001 	sub	r2, r3, #1
3001a9b4:	e59d301c 	ldr	r3, [sp, #28]
3001a9b8:	e583205c 	str	r2, [r3, #92]	; 0x5c
    npcb->callback_arg = pcb->callback_arg;
3001a9bc:	e59d3014 	ldr	r3, [sp, #20]
3001a9c0:	e5932014 	ldr	r2, [r3, #20]
3001a9c4:	e59d301c 	ldr	r3, [sp, #28]
3001a9c8:	e5832014 	str	r2, [r3, #20]
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
3001a9cc:	e59d3014 	ldr	r3, [sp, #20]
3001a9d0:	e593201c 	ldr	r2, [r3, #28]
3001a9d4:	e59d301c 	ldr	r3, [sp, #28]
3001a9d8:	e583208c 	str	r2, [r3, #140]	; 0x8c
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
3001a9dc:	e59d3014 	ldr	r3, [sp, #20]
3001a9e0:	e1d330b8 	ldrh	r3, [r3, #8]
3001a9e4:	e3c33066 	bic	r3, r3, #102	; 0x66
3001a9e8:	e1a03b83 	lsl	r3, r3, #23
3001a9ec:	e1a03ba3 	lsr	r3, r3, #23
3001a9f0:	e59d201c 	ldr	r2, [sp, #28]
3001a9f4:	e1c230b8 	strh	r3, [r2, #8]
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
3001a9f8:	e59f30dc 	ldr	r3, [pc, #220]	; 3001aadc <tcp_listen_input+0x378>
3001a9fc:	e5932000 	ldr	r2, [r3]
3001aa00:	e59d301c 	ldr	r3, [sp, #28]
3001aa04:	e583200c 	str	r2, [r3, #12]
3001aa08:	e59f30cc 	ldr	r3, [pc, #204]	; 3001aadc <tcp_listen_input+0x378>
3001aa0c:	e59d201c 	ldr	r2, [sp, #28]
3001aa10:	e5832000 	str	r2, [r3]
3001aa14:	ebffde47 	bl	30012338 <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
3001aa18:	e59d001c 	ldr	r0, [sp, #28]
3001aa1c:	eb000b0a 	bl	3001d64c <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
3001aa20:	e59d301c 	ldr	r3, [sp, #28]
3001aa24:	e1d323b0 	ldrh	r2, [r3, #48]	; 0x30
3001aa28:	e59d301c 	ldr	r3, [sp, #28]
3001aa2c:	e2833004 	add	r3, r3, #4
3001aa30:	e1a00002 	mov	r0, r2
3001aa34:	e1a01003 	mov	r1, r3
3001aa38:	ebfffb55 	bl	30019794 <tcp_eff_send_mss>
3001aa3c:	e1a03000 	mov	r3, r0
3001aa40:	e1a02003 	mov	r2, r3
3001aa44:	e59d301c 	ldr	r3, [sp, #28]
3001aa48:	e1c323b0 	strh	r2, [r3, #48]	; 0x30
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
3001aa4c:	e3a00781 	mov	r0, #33816576	; 0x2040000
3001aa50:	e2800080 	add	r0, r0, #128	; 0x80
3001aa54:	ebffe3b7 	bl	30013938 <htonl>
3001aa58:	e1a03000 	mov	r3, r0
3001aa5c:	e58d3018 	str	r3, [sp, #24]
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
3001aa60:	e28d3018 	add	r3, sp, #24
3001aa64:	e3a02000 	mov	r2, #0
3001aa68:	e58d2000 	str	r2, [sp]
3001aa6c:	e58d3004 	str	r3, [sp, #4]
3001aa70:	e3a03004 	mov	r3, #4
3001aa74:	e58d3008 	str	r3, [sp, #8]
3001aa78:	e59d001c 	ldr	r0, [sp, #28]
3001aa7c:	e3a01000 	mov	r1, #0
3001aa80:	e3a02000 	mov	r2, #0
3001aa84:	e3a03012 	mov	r3, #18
3001aa88:	eb000bb0 	bl	3001d950 <tcp_enqueue>
    return tcp_output(npcb);
3001aa8c:	e59d001c 	ldr	r0, [sp, #28]
3001aa90:	eb000dfb 	bl	3001e284 <tcp_output>
3001aa94:	e1a03000 	mov	r3, r0
3001aa98:	e20330ff 	and	r3, r3, #255	; 0xff
3001aa9c:	e20330ff 	and	r3, r3, #255	; 0xff
3001aaa0:	ea000000 	b	3001aaa8 <tcp_listen_input+0x344>
  }
  return ERR_OK;
3001aaa4:	e3a03000 	mov	r3, #0
3001aaa8:	e1a03c03 	lsl	r3, r3, #24
3001aaac:	e1a03c43 	asr	r3, r3, #24
}
3001aab0:	e1a00003 	mov	r0, r3
3001aab4:	e28dd020 	add	sp, sp, #32
3001aab8:	e8bd4010 	pop	{r4, lr}
3001aabc:	e12fff1e 	bx	lr
3001aac0:	30028f80 	.word	0x30028f80
3001aac4:	30028f7c 	.word	0x30028f7c
3001aac8:	30028f82 	.word	0x30028f82
3001aacc:	30028f78 	.word	0x30028f78
3001aad0:	30028f74 	.word	0x30028f74
3001aad4:	30028f70 	.word	0x30028f70
3001aad8:	3002b214 	.word	0x3002b214
3001aadc:	3002a6e8 	.word	0x3002a6e8

3001aae0 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
3001aae0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001aae4:	e24dd00c 	sub	sp, sp, #12
3001aae8:	e58d0004 	str	r0, [sp, #4]
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
3001aaec:	e59f30a0 	ldr	r3, [pc, #160]	; 3001ab94 <tcp_timewait_input+0xb4>
3001aaf0:	e1d330b0 	ldrh	r3, [r3]
3001aaf4:	e1a02003 	mov	r2, r3
3001aaf8:	e59f3098 	ldr	r3, [pc, #152]	; 3001ab98 <tcp_timewait_input+0xb8>
3001aafc:	e5933000 	ldr	r3, [r3]
3001ab00:	e0822003 	add	r2, r2, r3
3001ab04:	e59d3004 	ldr	r3, [sp, #4]
3001ab08:	e5933020 	ldr	r3, [r3, #32]
3001ab0c:	e0633002 	rsb	r3, r3, r2
3001ab10:	e3530000 	cmp	r3, #0
3001ab14:	da000007 	ble	3001ab38 <tcp_timewait_input+0x58>
    pcb->rcv_nxt = seqno + tcplen;
3001ab18:	e59f3074 	ldr	r3, [pc, #116]	; 3001ab94 <tcp_timewait_input+0xb4>
3001ab1c:	e1d330b0 	ldrh	r3, [r3]
3001ab20:	e1a02003 	mov	r2, r3
3001ab24:	e59f306c 	ldr	r3, [pc, #108]	; 3001ab98 <tcp_timewait_input+0xb8>
3001ab28:	e5933000 	ldr	r3, [r3]
3001ab2c:	e0822003 	add	r2, r2, r3
3001ab30:	e59d3004 	ldr	r3, [sp, #4]
3001ab34:	e5832020 	str	r2, [r3, #32]
  }
  if (tcplen > 0) {
3001ab38:	e59f3054 	ldr	r3, [pc, #84]	; 3001ab94 <tcp_timewait_input+0xb4>
3001ab3c:	e1d330b0 	ldrh	r3, [r3]
3001ab40:	e3530000 	cmp	r3, #0
3001ab44:	0a000007 	beq	3001ab68 <tcp_timewait_input+0x88>
    tcp_ack_now(pcb);
3001ab48:	e59d3004 	ldr	r3, [sp, #4]
3001ab4c:	e5d3301c 	ldrb	r3, [r3, #28]
3001ab50:	e3833002 	orr	r3, r3, #2
3001ab54:	e20320ff 	and	r2, r3, #255	; 0xff
3001ab58:	e59d3004 	ldr	r3, [sp, #4]
3001ab5c:	e5c3201c 	strb	r2, [r3, #28]
3001ab60:	e59d0004 	ldr	r0, [sp, #4]
3001ab64:	eb000dc6 	bl	3001e284 <tcp_output>
  }
  return tcp_output(pcb);
3001ab68:	e59d0004 	ldr	r0, [sp, #4]
3001ab6c:	eb000dc4 	bl	3001e284 <tcp_output>
3001ab70:	e1a03000 	mov	r3, r0
3001ab74:	e20330ff 	and	r3, r3, #255	; 0xff
3001ab78:	e20330ff 	and	r3, r3, #255	; 0xff
3001ab7c:	e1a03c03 	lsl	r3, r3, #24
3001ab80:	e1a03c43 	asr	r3, r3, #24
}
3001ab84:	e1a00003 	mov	r0, r3
3001ab88:	e28dd00c 	add	sp, sp, #12
3001ab8c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001ab90:	e12fff1e 	bx	lr
3001ab94:	30028f82 	.word	0x30028f82
3001ab98:	30028f78 	.word	0x30028f78

3001ab9c <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
3001ab9c:	e92d4010 	push	{r4, lr}
3001aba0:	e24dd020 	sub	sp, sp, #32
3001aba4:	e58d000c 	str	r0, [sp, #12]
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
3001aba8:	e3a03000 	mov	r3, #0
3001abac:	e5cd301b 	strb	r3, [sp, #27]
  err_t err;
  u8_t accepted_inseq;

  err = ERR_OK;
3001abb0:	e3a03000 	mov	r3, #0
3001abb4:	e5cd301c 	strb	r3, [sp, #28]

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
3001abb8:	e59f3b80 	ldr	r3, [pc, #2944]	; 3001b740 <tcp_process+0xba4>
3001abbc:	e5d33000 	ldrb	r3, [r3]
3001abc0:	e2033004 	and	r3, r3, #4
3001abc4:	e3530000 	cmp	r3, #0
3001abc8:	0a000030 	beq	3001ac90 <tcp_process+0xf4>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
3001abcc:	e59d300c 	ldr	r3, [sp, #12]
3001abd0:	e5d33010 	ldrb	r3, [r3, #16]
3001abd4:	e3530002 	cmp	r3, #2
3001abd8:	1a000008 	bne	3001ac00 <tcp_process+0x64>
      if (ackno == pcb->snd_nxt) {
3001abdc:	e59d300c 	ldr	r3, [sp, #12]
3001abe0:	e5932050 	ldr	r2, [r3, #80]	; 0x50
3001abe4:	e59f3b58 	ldr	r3, [pc, #2904]	; 3001b744 <tcp_process+0xba8>
3001abe8:	e5933000 	ldr	r3, [r3]
3001abec:	e1520003 	cmp	r2, r3
3001abf0:	1a000016 	bne	3001ac50 <tcp_process+0xb4>
        acceptable = 1;
3001abf4:	e3a03001 	mov	r3, #1
3001abf8:	e5cd301b 	strb	r3, [sp, #27]
3001abfc:	ea000014 	b	3001ac54 <tcp_process+0xb8>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
3001ac00:	e59f3b40 	ldr	r3, [pc, #2880]	; 3001b748 <tcp_process+0xbac>
3001ac04:	e5932000 	ldr	r2, [r3]
3001ac08:	e59d300c 	ldr	r3, [sp, #12]
3001ac0c:	e5933020 	ldr	r3, [r3, #32]
3001ac10:	e0633002 	rsb	r3, r3, r2
3001ac14:	e3530000 	cmp	r3, #0
3001ac18:	ba00000d 	blt	3001ac54 <tcp_process+0xb8>
3001ac1c:	e59f3b24 	ldr	r3, [pc, #2852]	; 3001b748 <tcp_process+0xbac>
3001ac20:	e5932000 	ldr	r2, [r3]
3001ac24:	e59d300c 	ldr	r3, [sp, #12]
3001ac28:	e5931020 	ldr	r1, [r3, #32]
3001ac2c:	e59d300c 	ldr	r3, [sp, #12]
3001ac30:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
3001ac34:	e0813003 	add	r3, r1, r3
3001ac38:	e0633002 	rsb	r3, r3, r2
3001ac3c:	e3530000 	cmp	r3, #0
3001ac40:	ca000003 	bgt	3001ac54 <tcp_process+0xb8>
                          pcb->rcv_nxt+pcb->rcv_ann_wnd)) {
        acceptable = 1;
3001ac44:	e3a03001 	mov	r3, #1
3001ac48:	e5cd301b 	strb	r3, [sp, #27]
3001ac4c:	ea000000 	b	3001ac54 <tcp_process+0xb8>
  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
3001ac50:	e1a00000 	nop			; (mov r0, r0)
                          pcb->rcv_nxt+pcb->rcv_ann_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
3001ac54:	e5dd301b 	ldrb	r3, [sp, #27]
3001ac58:	e3530000 	cmp	r3, #0
3001ac5c:	0a000009 	beq	3001ac88 <tcp_process+0xec>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags = TF_RESET;
3001ac60:	e59f3ae4 	ldr	r3, [pc, #2788]	; 3001b74c <tcp_process+0xbb0>
3001ac64:	e3a02008 	mov	r2, #8
3001ac68:	e5c32000 	strb	r2, [r3]
      pcb->flags &= ~TF_ACK_DELAY;
3001ac6c:	e59d300c 	ldr	r3, [sp, #12]
3001ac70:	e5d3301c 	ldrb	r3, [r3, #28]
3001ac74:	e20330fe 	and	r3, r3, #254	; 0xfe
3001ac78:	e59d200c 	ldr	r2, [sp, #12]
3001ac7c:	e5c2301c 	strb	r3, [r2, #28]
      return ERR_RST;
3001ac80:	e3a030fb 	mov	r3, #251	; 0xfb
3001ac84:	ea0002a7 	b	3001b728 <tcp_process+0xb8c>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
3001ac88:	e3a03000 	mov	r3, #0
3001ac8c:	ea0002a5 	b	3001b728 <tcp_process+0xb8c>
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
3001ac90:	e59f3ab8 	ldr	r3, [pc, #2744]	; 3001b750 <tcp_process+0xbb4>
3001ac94:	e5932000 	ldr	r2, [r3]
3001ac98:	e59d300c 	ldr	r3, [sp, #12]
3001ac9c:	e5832028 	str	r2, [r3, #40]	; 0x28
  pcb->keep_cnt_sent = 0;
3001aca0:	e59d300c 	ldr	r3, [sp, #12]
3001aca4:	e3a02000 	mov	r2, #0
3001aca8:	e5c320a1 	strb	r2, [r3, #161]	; 0xa1

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
3001acac:	e59d300c 	ldr	r3, [sp, #12]
3001acb0:	e5d33010 	ldrb	r3, [r3, #16]
3001acb4:	e2433002 	sub	r3, r3, #2
3001acb8:	e3530007 	cmp	r3, #7
3001acbc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3001acc0:	ea000297 	b	3001b724 <tcp_process+0xb88>
3001acc4:	3001ace4 	.word	0x3001ace4
3001acc8:	3001affc 	.word	0x3001affc
3001accc:	3001b1fc 	.word	0x3001b1fc
3001acd0:	3001b260 	.word	0x3001b260
3001acd4:	3001b428 	.word	0x3001b428
3001acd8:	3001b1fc 	.word	0x3001b1fc
3001acdc:	3001b554 	.word	0x3001b554
3001ace0:	3001b694 	.word	0x3001b694
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
3001ace4:	e59f3a54 	ldr	r3, [pc, #2644]	; 3001b740 <tcp_process+0xba4>
3001ace8:	e5d33000 	ldrb	r3, [r3]
3001acec:	e2033010 	and	r3, r3, #16
3001acf0:	e3530000 	cmp	r3, #0
3001acf4:	0a000098 	beq	3001af5c <tcp_process+0x3c0>
3001acf8:	e59f3a40 	ldr	r3, [pc, #2624]	; 3001b740 <tcp_process+0xba4>
3001acfc:	e5d33000 	ldrb	r3, [r3]
3001ad00:	e2033002 	and	r3, r3, #2
3001ad04:	e3530000 	cmp	r3, #0
3001ad08:	0a000093 	beq	3001af5c <tcp_process+0x3c0>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
3001ad0c:	e59d300c 	ldr	r3, [sp, #12]
3001ad10:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001ad14:	e5933010 	ldr	r3, [r3, #16]
3001ad18:	e5d32004 	ldrb	r2, [r3, #4]
3001ad1c:	e5d31005 	ldrb	r1, [r3, #5]
3001ad20:	e1a01401 	lsl	r1, r1, #8
3001ad24:	e1812002 	orr	r2, r1, r2
3001ad28:	e5d31006 	ldrb	r1, [r3, #6]
3001ad2c:	e1a01801 	lsl	r1, r1, #16
3001ad30:	e1812002 	orr	r2, r1, r2
3001ad34:	e5d33007 	ldrb	r3, [r3, #7]
3001ad38:	e1a03c03 	lsl	r3, r3, #24
3001ad3c:	e1833002 	orr	r3, r3, r2
3001ad40:	e1a00003 	mov	r0, r3
3001ad44:	ebffe30d 	bl	30013980 <ntohl>
3001ad48:	e1a03000 	mov	r3, r0
3001ad4c:	e2832001 	add	r2, r3, #1
3001ad50:	e59f39ec 	ldr	r3, [pc, #2540]	; 3001b744 <tcp_process+0xba8>
3001ad54:	e5933000 	ldr	r3, [r3]
  switch (pcb->state) {
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
3001ad58:	e1520003 	cmp	r2, r3
3001ad5c:	1a00007e 	bne	3001af5c <tcp_process+0x3c0>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
3001ad60:	e59d300c 	ldr	r3, [sp, #12]
3001ad64:	e1d336ba 	ldrh	r3, [r3, #106]	; 0x6a
3001ad68:	e2833001 	add	r3, r3, #1
3001ad6c:	e1a03803 	lsl	r3, r3, #16
3001ad70:	e1a02823 	lsr	r2, r3, #16
3001ad74:	e59d300c 	ldr	r3, [sp, #12]
3001ad78:	e1c326ba 	strh	r2, [r3, #106]	; 0x6a
      pcb->rcv_nxt = seqno + 1;
3001ad7c:	e59f39c4 	ldr	r3, [pc, #2500]	; 3001b748 <tcp_process+0xbac>
3001ad80:	e5933000 	ldr	r3, [r3]
3001ad84:	e2832001 	add	r2, r3, #1
3001ad88:	e59d300c 	ldr	r3, [sp, #12]
3001ad8c:	e5832020 	str	r2, [r3, #32]
      pcb->lastack = ackno;
3001ad90:	e59f39ac 	ldr	r3, [pc, #2476]	; 3001b744 <tcp_process+0xba8>
3001ad94:	e5932000 	ldr	r2, [r3]
3001ad98:	e59d300c 	ldr	r3, [sp, #12]
3001ad9c:	e5832044 	str	r2, [r3, #68]	; 0x44
      pcb->snd_wnd = tcphdr->wnd;
3001ada0:	e59f39ac 	ldr	r3, [pc, #2476]	; 3001b754 <tcp_process+0xbb8>
3001ada4:	e5933000 	ldr	r3, [r3]
3001ada8:	e5d3200e 	ldrb	r2, [r3, #14]
3001adac:	e5d3300f 	ldrb	r3, [r3, #15]
3001adb0:	e1a03403 	lsl	r3, r3, #8
3001adb4:	e1833002 	orr	r3, r3, r2
3001adb8:	e1a03803 	lsl	r3, r3, #16
3001adbc:	e1a02823 	lsr	r2, r3, #16
3001adc0:	e59d300c 	ldr	r3, [sp, #12]
3001adc4:	e1c325b8 	strh	r2, [r3, #88]	; 0x58
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
3001adc8:	e59f3978 	ldr	r3, [pc, #2424]	; 3001b748 <tcp_process+0xbac>
3001adcc:	e5933000 	ldr	r3, [r3]
3001add0:	e2432001 	sub	r2, r3, #1
3001add4:	e59d300c 	ldr	r3, [sp, #12]
3001add8:	e583205c 	str	r2, [r3, #92]	; 0x5c
      pcb->state = ESTABLISHED;
3001addc:	e59d300c 	ldr	r3, [sp, #12]
3001ade0:	e3a02004 	mov	r2, #4
3001ade4:	e5c32010 	strb	r2, [r3, #16]

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
3001ade8:	e59d000c 	ldr	r0, [sp, #12]
3001adec:	eb000a16 	bl	3001d64c <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
3001adf0:	e59d300c 	ldr	r3, [sp, #12]
3001adf4:	e1d323b0 	ldrh	r2, [r3, #48]	; 0x30
3001adf8:	e59d300c 	ldr	r3, [sp, #12]
3001adfc:	e2833004 	add	r3, r3, #4
3001ae00:	e1a00002 	mov	r0, r2
3001ae04:	e1a01003 	mov	r1, r3
3001ae08:	ebfffa61 	bl	30019794 <tcp_eff_send_mss>
3001ae0c:	e1a03000 	mov	r3, r0
3001ae10:	e1a02003 	mov	r2, r3
3001ae14:	e59d300c 	ldr	r3, [sp, #12]
3001ae18:	e1c323b0 	strh	r2, [r3, #48]	; 0x30
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
3001ae1c:	e59d300c 	ldr	r3, [sp, #12]
3001ae20:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001ae24:	e1a02003 	mov	r2, r3
3001ae28:	e1a02102 	lsl	r2, r2, #2
3001ae2c:	e0823003 	add	r3, r2, r3
3001ae30:	e1a03083 	lsl	r3, r3, #1
3001ae34:	e1a03803 	lsl	r3, r3, #16
3001ae38:	e1a02823 	lsr	r2, r3, #16
3001ae3c:	e59d300c 	ldr	r3, [sp, #12]
3001ae40:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
3001ae44:	e59d300c 	ldr	r3, [sp, #12]
3001ae48:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
3001ae4c:	e3530001 	cmp	r3, #1
3001ae50:	1a000005 	bne	3001ae6c <tcp_process+0x2d0>
3001ae54:	e59d300c 	ldr	r3, [sp, #12]
3001ae58:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001ae5c:	e1a03083 	lsl	r3, r3, #1
3001ae60:	e1a03803 	lsl	r3, r3, #16
3001ae64:	e1a03823 	lsr	r3, r3, #16
3001ae68:	ea000001 	b	3001ae74 <tcp_process+0x2d8>
3001ae6c:	e59d300c 	ldr	r3, [sp, #12]
3001ae70:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001ae74:	e59d200c 	ldr	r2, [sp, #12]
3001ae78:	e1c234ba 	strh	r3, [r2, #74]	; 0x4a
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
3001ae7c:	e59d300c 	ldr	r3, [sp, #12]
3001ae80:	e1d336bc 	ldrh	r3, [r3, #108]	; 0x6c
3001ae84:	e2433001 	sub	r3, r3, #1
3001ae88:	e1a03803 	lsl	r3, r3, #16
3001ae8c:	e1a02823 	lsr	r2, r3, #16
3001ae90:	e59d300c 	ldr	r3, [sp, #12]
3001ae94:	e1c326bc 	strh	r2, [r3, #108]	; 0x6c
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
3001ae98:	e59d300c 	ldr	r3, [sp, #12]
3001ae9c:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001aea0:	e58d3014 	str	r3, [sp, #20]
      pcb->unacked = rseg->next;
3001aea4:	e59d3014 	ldr	r3, [sp, #20]
3001aea8:	e5932000 	ldr	r2, [r3]
3001aeac:	e59d300c 	ldr	r3, [sp, #12]
3001aeb0:	e5832074 	str	r2, [r3, #116]	; 0x74

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
3001aeb4:	e59d300c 	ldr	r3, [sp, #12]
3001aeb8:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001aebc:	e3530000 	cmp	r3, #0
3001aec0:	1a000003 	bne	3001aed4 <tcp_process+0x338>
        pcb->rtime = -1;
3001aec4:	e59d300c 	ldr	r3, [sp, #12]
3001aec8:	e3e02000 	mvn	r2, #0
3001aecc:	e1c322be 	strh	r2, [r3, #46]	; 0x2e
3001aed0:	ea000005 	b	3001aeec <tcp_process+0x350>
      else {
        pcb->rtime = 0;
3001aed4:	e59d300c 	ldr	r3, [sp, #12]
3001aed8:	e3a02000 	mov	r2, #0
3001aedc:	e1c322be 	strh	r2, [r3, #46]	; 0x2e
        pcb->nrtx = 0;
3001aee0:	e59d300c 	ldr	r3, [sp, #12]
3001aee4:	e3a02000 	mov	r2, #0
3001aee8:	e5c32042 	strb	r2, [r3, #66]	; 0x42
      }

      tcp_seg_free(rseg);
3001aeec:	e59d0014 	ldr	r0, [sp, #20]
3001aef0:	ebfff829 	bl	30018f9c <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
3001aef4:	e59d300c 	ldr	r3, [sp, #12]
3001aef8:	e5933088 	ldr	r3, [r3, #136]	; 0x88
3001aefc:	e3530000 	cmp	r3, #0
3001af00:	0a00000b 	beq	3001af34 <tcp_process+0x398>
3001af04:	e59d300c 	ldr	r3, [sp, #12]
3001af08:	e5933088 	ldr	r3, [r3, #136]	; 0x88
3001af0c:	e59d200c 	ldr	r2, [sp, #12]
3001af10:	e5922014 	ldr	r2, [r2, #20]
3001af14:	e1a00002 	mov	r0, r2
3001af18:	e59d100c 	ldr	r1, [sp, #12]
3001af1c:	e3a02000 	mov	r2, #0
3001af20:	e1a0e00f 	mov	lr, pc
3001af24:	e12fff13 	bx	r3
3001af28:	e1a03000 	mov	r3, r0
3001af2c:	e20330ff 	and	r3, r3, #255	; 0xff
3001af30:	e5cd301c 	strb	r3, [sp, #28]
      tcp_ack_now(pcb);
3001af34:	e59d300c 	ldr	r3, [sp, #12]
3001af38:	e5d3301c 	ldrb	r3, [r3, #28]
3001af3c:	e3833002 	orr	r3, r3, #2
3001af40:	e20320ff 	and	r2, r3, #255	; 0xff
3001af44:	e59d300c 	ldr	r3, [sp, #12]
3001af48:	e5c3201c 	strb	r2, [r3, #28]
3001af4c:	e59d000c 	ldr	r0, [sp, #12]
3001af50:	eb000ccb 	bl	3001e284 <tcp_output>
  switch (pcb->state) {
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
3001af54:	e1a00000 	nop			; (mov r0, r0)
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
3001af58:	ea0001f1 	b	3001b724 <tcp_process+0xb88>
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
3001af5c:	e59f37dc 	ldr	r3, [pc, #2012]	; 3001b740 <tcp_process+0xba4>
3001af60:	e5d33000 	ldrb	r3, [r3]
3001af64:	e2033010 	and	r3, r3, #16
3001af68:	e3530000 	cmp	r3, #0
3001af6c:	0a0001d9 	beq	3001b6d8 <tcp_process+0xb3c>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
3001af70:	e59f37cc 	ldr	r3, [pc, #1996]	; 3001b744 <tcp_process+0xba8>
3001af74:	e5930000 	ldr	r0, [r3]
3001af78:	e59f37d8 	ldr	r3, [pc, #2008]	; 3001b758 <tcp_process+0xbbc>
3001af7c:	e1d330b0 	ldrh	r3, [r3]
3001af80:	e1a02003 	mov	r2, r3
3001af84:	e59f37bc 	ldr	r3, [pc, #1980]	; 3001b748 <tcp_process+0xbac>
3001af88:	e5933000 	ldr	r3, [r3]
3001af8c:	e0821003 	add	r1, r2, r3
3001af90:	e59f37c4 	ldr	r3, [pc, #1988]	; 3001b75c <tcp_process+0xbc0>
3001af94:	e5933000 	ldr	r3, [r3]
3001af98:	e2832010 	add	r2, r3, #16
3001af9c:	e59f37b8 	ldr	r3, [pc, #1976]	; 3001b75c <tcp_process+0xbc0>
3001afa0:	e5933000 	ldr	r3, [r3]
3001afa4:	e283c00c 	add	ip, r3, #12
        tcphdr->dest, tcphdr->src);
3001afa8:	e59f37a4 	ldr	r3, [pc, #1956]	; 3001b754 <tcp_process+0xbb8>
3001afac:	e5933000 	ldr	r3, [r3]
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
3001afb0:	e5d3e002 	ldrb	lr, [r3, #2]
3001afb4:	e5d33003 	ldrb	r3, [r3, #3]
3001afb8:	e1a03403 	lsl	r3, r3, #8
3001afbc:	e183300e 	orr	r3, r3, lr
3001afc0:	e1a03803 	lsl	r3, r3, #16
3001afc4:	e1a0e823 	lsr	lr, r3, #16
        tcphdr->dest, tcphdr->src);
3001afc8:	e59f3784 	ldr	r3, [pc, #1924]	; 3001b754 <tcp_process+0xbb8>
3001afcc:	e5933000 	ldr	r3, [r3]
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
3001afd0:	e5d34000 	ldrb	r4, [r3]
3001afd4:	e5d33001 	ldrb	r3, [r3, #1]
3001afd8:	e1a03403 	lsl	r3, r3, #8
3001afdc:	e1833004 	orr	r3, r3, r4
3001afe0:	e1a03803 	lsl	r3, r3, #16
3001afe4:	e1a03823 	lsr	r3, r3, #16
3001afe8:	e58de000 	str	lr, [sp]
3001afec:	e58d3004 	str	r3, [sp, #4]
3001aff0:	e1a0300c 	mov	r3, ip
3001aff4:	eb000fd9 	bl	3001ef60 <tcp_rst>
        tcphdr->dest, tcphdr->src);
    }
    break;
3001aff8:	ea0001c9 	b	3001b724 <tcp_process+0xb88>
  case SYN_RCVD:
    if (flags & TCP_ACK &&
3001affc:	e59f373c 	ldr	r3, [pc, #1852]	; 3001b740 <tcp_process+0xba4>
3001b000:	e5d33000 	ldrb	r3, [r3]
3001b004:	e2033010 	and	r3, r3, #16
3001b008:	e3530000 	cmp	r3, #0
3001b00c:	0a0001b3 	beq	3001b6e0 <tcp_process+0xb44>
       !(flags & TCP_RST)) {
3001b010:	e59f3728 	ldr	r3, [pc, #1832]	; 3001b740 <tcp_process+0xba4>
3001b014:	e5d33000 	ldrb	r3, [r3]
3001b018:	e2033004 	and	r3, r3, #4
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
3001b01c:	e3530000 	cmp	r3, #0
3001b020:	1a0001b0 	bne	3001b6e8 <tcp_process+0xb4c>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
3001b024:	e59d300c 	ldr	r3, [sp, #12]
3001b028:	e5933044 	ldr	r3, [r3, #68]	; 0x44
3001b02c:	e1e02003 	mvn	r2, r3
3001b030:	e59f370c 	ldr	r3, [pc, #1804]	; 3001b744 <tcp_process+0xba8>
3001b034:	e5933000 	ldr	r3, [r3]
3001b038:	e0823003 	add	r3, r2, r3
3001b03c:	e3530000 	cmp	r3, #0
3001b040:	ba00004a 	blt	3001b170 <tcp_process+0x5d4>
3001b044:	e59f36f8 	ldr	r3, [pc, #1784]	; 3001b744 <tcp_process+0xba8>
3001b048:	e5932000 	ldr	r2, [r3]
3001b04c:	e59d300c 	ldr	r3, [sp, #12]
3001b050:	e5933050 	ldr	r3, [r3, #80]	; 0x50
3001b054:	e0633002 	rsb	r3, r3, r2
3001b058:	e3530000 	cmp	r3, #0
3001b05c:	ca000043 	bgt	3001b170 <tcp_process+0x5d4>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
3001b060:	e59d300c 	ldr	r3, [sp, #12]
3001b064:	e3a02004 	mov	r2, #4
3001b068:	e5c32010 	strb	r2, [r3, #16]
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
3001b06c:	e59d300c 	ldr	r3, [sp, #12]
3001b070:	e593308c 	ldr	r3, [r3, #140]	; 0x8c
3001b074:	e3530000 	cmp	r3, #0
3001b078:	0a00000b 	beq	3001b0ac <tcp_process+0x510>
3001b07c:	e59d300c 	ldr	r3, [sp, #12]
3001b080:	e593308c 	ldr	r3, [r3, #140]	; 0x8c
3001b084:	e59d200c 	ldr	r2, [sp, #12]
3001b088:	e5922014 	ldr	r2, [r2, #20]
3001b08c:	e1a00002 	mov	r0, r2
3001b090:	e59d100c 	ldr	r1, [sp, #12]
3001b094:	e3a02000 	mov	r2, #0
3001b098:	e1a0e00f 	mov	lr, pc
3001b09c:	e12fff13 	bx	r3
3001b0a0:	e1a03000 	mov	r3, r0
3001b0a4:	e20330ff 	and	r3, r3, #255	; 0xff
3001b0a8:	e5cd301c 	strb	r3, [sp, #28]
        if (err != ERR_OK) {
3001b0ac:	e1dd31dc 	ldrsb	r3, [sp, #28]
3001b0b0:	e3530000 	cmp	r3, #0
3001b0b4:	0a000003 	beq	3001b0c8 <tcp_process+0x52c>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
3001b0b8:	e59d000c 	ldr	r0, [sp, #12]
3001b0bc:	ebfff241 	bl	300179c8 <tcp_abort>
          return ERR_ABRT;
3001b0c0:	e3a030fc 	mov	r3, #252	; 0xfc
3001b0c4:	ea000197 	b	3001b728 <tcp_process+0xb8c>
        }
        old_cwnd = pcb->cwnd;
3001b0c8:	e59d300c 	ldr	r3, [sp, #12]
3001b0cc:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
3001b0d0:	e1cd31be 	strh	r3, [sp, #30]
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
3001b0d4:	e59d000c 	ldr	r0, [sp, #12]
3001b0d8:	eb0001a3 	bl	3001b76c <tcp_receive>
3001b0dc:	e1a03000 	mov	r3, r0
3001b0e0:	e5cd301d 	strb	r3, [sp, #29]

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
3001b0e4:	e1dd31be 	ldrh	r3, [sp, #30]
3001b0e8:	e3530001 	cmp	r3, #1
3001b0ec:	1a000005 	bne	3001b108 <tcp_process+0x56c>
3001b0f0:	e59d300c 	ldr	r3, [sp, #12]
3001b0f4:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001b0f8:	e1a03083 	lsl	r3, r3, #1
3001b0fc:	e1a03803 	lsl	r3, r3, #16
3001b100:	e1a03823 	lsr	r3, r3, #16
3001b104:	ea000001 	b	3001b110 <tcp_process+0x574>
3001b108:	e59d300c 	ldr	r3, [sp, #12]
3001b10c:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001b110:	e59d200c 	ldr	r2, [sp, #12]
3001b114:	e1c234ba 	strh	r3, [r2, #74]	; 0x4a

        if ((flags & TCP_FIN) && accepted_inseq) {
3001b118:	e59f3620 	ldr	r3, [pc, #1568]	; 3001b740 <tcp_process+0xba4>
3001b11c:	e5d33000 	ldrb	r3, [r3]
3001b120:	e2033001 	and	r3, r3, #1
3001b124:	e20330ff 	and	r3, r3, #255	; 0xff
3001b128:	e3530000 	cmp	r3, #0
3001b12c:	0a00000d 	beq	3001b168 <tcp_process+0x5cc>
3001b130:	e5dd301d 	ldrb	r3, [sp, #29]
3001b134:	e3530000 	cmp	r3, #0
3001b138:	0a00000a 	beq	3001b168 <tcp_process+0x5cc>
          tcp_ack_now(pcb);
3001b13c:	e59d300c 	ldr	r3, [sp, #12]
3001b140:	e5d3301c 	ldrb	r3, [r3, #28]
3001b144:	e3833002 	orr	r3, r3, #2
3001b148:	e20320ff 	and	r2, r3, #255	; 0xff
3001b14c:	e59d300c 	ldr	r3, [sp, #12]
3001b150:	e5c3201c 	strb	r2, [r3, #28]
3001b154:	e59d000c 	ldr	r0, [sp, #12]
3001b158:	eb000c49 	bl	3001e284 <tcp_output>
          pcb->state = CLOSE_WAIT;
3001b15c:	e59d300c 	ldr	r3, [sp, #12]
3001b160:	e3a02007 	mov	r2, #7
3001b164:	e5c32010 	strb	r2, [r3, #16]
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
3001b168:	e1a00000 	nop			; (mov r0, r0)
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
3001b16c:	ea00016c 	b	3001b724 <tcp_process+0xb88>
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
3001b170:	e59f35cc 	ldr	r3, [pc, #1484]	; 3001b744 <tcp_process+0xba8>
3001b174:	e5930000 	ldr	r0, [r3]
3001b178:	e59f35d8 	ldr	r3, [pc, #1496]	; 3001b758 <tcp_process+0xbbc>
3001b17c:	e1d330b0 	ldrh	r3, [r3]
3001b180:	e1a02003 	mov	r2, r3
3001b184:	e59f35bc 	ldr	r3, [pc, #1468]	; 3001b748 <tcp_process+0xbac>
3001b188:	e5933000 	ldr	r3, [r3]
3001b18c:	e0821003 	add	r1, r2, r3
3001b190:	e59f35c4 	ldr	r3, [pc, #1476]	; 3001b75c <tcp_process+0xbc0>
3001b194:	e5933000 	ldr	r3, [r3]
3001b198:	e2832010 	add	r2, r3, #16
3001b19c:	e59f35b8 	ldr	r3, [pc, #1464]	; 3001b75c <tcp_process+0xbc0>
3001b1a0:	e5933000 	ldr	r3, [r3]
3001b1a4:	e283c00c 	add	ip, r3, #12
                tcphdr->dest, tcphdr->src);
3001b1a8:	e59f35a4 	ldr	r3, [pc, #1444]	; 3001b754 <tcp_process+0xbb8>
3001b1ac:	e5933000 	ldr	r3, [r3]
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
3001b1b0:	e5d3e002 	ldrb	lr, [r3, #2]
3001b1b4:	e5d33003 	ldrb	r3, [r3, #3]
3001b1b8:	e1a03403 	lsl	r3, r3, #8
3001b1bc:	e183300e 	orr	r3, r3, lr
3001b1c0:	e1a03803 	lsl	r3, r3, #16
3001b1c4:	e1a0e823 	lsr	lr, r3, #16
                tcphdr->dest, tcphdr->src);
3001b1c8:	e59f3584 	ldr	r3, [pc, #1412]	; 3001b754 <tcp_process+0xbb8>
3001b1cc:	e5933000 	ldr	r3, [r3]
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
3001b1d0:	e5d34000 	ldrb	r4, [r3]
3001b1d4:	e5d33001 	ldrb	r3, [r3, #1]
3001b1d8:	e1a03403 	lsl	r3, r3, #8
3001b1dc:	e1833004 	orr	r3, r3, r4
3001b1e0:	e1a03803 	lsl	r3, r3, #16
3001b1e4:	e1a03823 	lsr	r3, r3, #16
3001b1e8:	e58de000 	str	lr, [sp]
3001b1ec:	e58d3004 	str	r3, [sp, #4]
3001b1f0:	e1a0300c 	mov	r3, ip
3001b1f4:	eb000f59 	bl	3001ef60 <tcp_rst>
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
3001b1f8:	ea000149 	b	3001b724 <tcp_process+0xb88>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
3001b1fc:	e59d000c 	ldr	r0, [sp, #12]
3001b200:	eb000159 	bl	3001b76c <tcp_receive>
3001b204:	e1a03000 	mov	r3, r0
3001b208:	e5cd301d 	strb	r3, [sp, #29]
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
3001b20c:	e59f352c 	ldr	r3, [pc, #1324]	; 3001b740 <tcp_process+0xba4>
3001b210:	e5d33000 	ldrb	r3, [r3]
3001b214:	e2033001 	and	r3, r3, #1
3001b218:	e20330ff 	and	r3, r3, #255	; 0xff
3001b21c:	e3530000 	cmp	r3, #0
3001b220:	0a000132 	beq	3001b6f0 <tcp_process+0xb54>
3001b224:	e5dd301d 	ldrb	r3, [sp, #29]
3001b228:	e3530000 	cmp	r3, #0
3001b22c:	0a000131 	beq	3001b6f8 <tcp_process+0xb5c>
      tcp_ack_now(pcb);
3001b230:	e59d300c 	ldr	r3, [sp, #12]
3001b234:	e5d3301c 	ldrb	r3, [r3, #28]
3001b238:	e3833002 	orr	r3, r3, #2
3001b23c:	e20320ff 	and	r2, r3, #255	; 0xff
3001b240:	e59d300c 	ldr	r3, [sp, #12]
3001b244:	e5c3201c 	strb	r2, [r3, #28]
3001b248:	e59d000c 	ldr	r0, [sp, #12]
3001b24c:	eb000c0c 	bl	3001e284 <tcp_output>
      pcb->state = CLOSE_WAIT;
3001b250:	e59d300c 	ldr	r3, [sp, #12]
3001b254:	e3a02007 	mov	r2, #7
3001b258:	e5c32010 	strb	r2, [r3, #16]
    }
    break;
3001b25c:	ea000130 	b	3001b724 <tcp_process+0xb88>
  case FIN_WAIT_1:
    tcp_receive(pcb);
3001b260:	e59d000c 	ldr	r0, [sp, #12]
3001b264:	eb000140 	bl	3001b76c <tcp_receive>
    if (flags & TCP_FIN) {
3001b268:	e59f34d0 	ldr	r3, [pc, #1232]	; 3001b740 <tcp_process+0xba4>
3001b26c:	e5d33000 	ldrb	r3, [r3]
3001b270:	e2033001 	and	r3, r3, #1
3001b274:	e20330ff 	and	r3, r3, #255	; 0xff
3001b278:	e3530000 	cmp	r3, #0
3001b27c:	0a00005a 	beq	3001b3ec <tcp_process+0x850>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
3001b280:	e59f34b8 	ldr	r3, [pc, #1208]	; 3001b740 <tcp_process+0xba4>
3001b284:	e5d33000 	ldrb	r3, [r3]
3001b288:	e2033010 	and	r3, r3, #16
3001b28c:	e3530000 	cmp	r3, #0
3001b290:	0a000049 	beq	3001b3bc <tcp_process+0x820>
3001b294:	e59d300c 	ldr	r3, [sp, #12]
3001b298:	e5932050 	ldr	r2, [r3, #80]	; 0x50
3001b29c:	e59f34a0 	ldr	r3, [pc, #1184]	; 3001b744 <tcp_process+0xba8>
3001b2a0:	e5933000 	ldr	r3, [r3]
3001b2a4:	e1520003 	cmp	r2, r3
3001b2a8:	1a000043 	bne	3001b3bc <tcp_process+0x820>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
3001b2ac:	e59d300c 	ldr	r3, [sp, #12]
3001b2b0:	e5d3301c 	ldrb	r3, [r3, #28]
3001b2b4:	e3833002 	orr	r3, r3, #2
3001b2b8:	e20320ff 	and	r2, r3, #255	; 0xff
3001b2bc:	e59d300c 	ldr	r3, [sp, #12]
3001b2c0:	e5c3201c 	strb	r2, [r3, #28]
3001b2c4:	e59d000c 	ldr	r0, [sp, #12]
3001b2c8:	eb000bed 	bl	3001e284 <tcp_output>
        tcp_pcb_purge(pcb);
3001b2cc:	e59d000c 	ldr	r0, [sp, #12]
3001b2d0:	ebfff89c 	bl	30019548 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
3001b2d4:	e59f3484 	ldr	r3, [pc, #1156]	; 3001b760 <tcp_process+0xbc4>
3001b2d8:	e5932000 	ldr	r2, [r3]
3001b2dc:	e59d300c 	ldr	r3, [sp, #12]
3001b2e0:	e1520003 	cmp	r2, r3
3001b2e4:	1a000005 	bne	3001b300 <tcp_process+0x764>
3001b2e8:	e59f3470 	ldr	r3, [pc, #1136]	; 3001b760 <tcp_process+0xbc4>
3001b2ec:	e5933000 	ldr	r3, [r3]
3001b2f0:	e593200c 	ldr	r2, [r3, #12]
3001b2f4:	e59f3464 	ldr	r3, [pc, #1124]	; 3001b760 <tcp_process+0xbc4>
3001b2f8:	e5832000 	str	r2, [r3]
3001b2fc:	ea00001e 	b	3001b37c <tcp_process+0x7e0>
3001b300:	e59f3458 	ldr	r3, [pc, #1112]	; 3001b760 <tcp_process+0xbc4>
3001b304:	e5932000 	ldr	r2, [r3]
3001b308:	e59f3454 	ldr	r3, [pc, #1108]	; 3001b764 <tcp_process+0xbc8>
3001b30c:	e5832000 	str	r2, [r3]
3001b310:	ea000015 	b	3001b36c <tcp_process+0x7d0>
3001b314:	e59f3448 	ldr	r3, [pc, #1096]	; 3001b764 <tcp_process+0xbc8>
3001b318:	e5933000 	ldr	r3, [r3]
3001b31c:	e593300c 	ldr	r3, [r3, #12]
3001b320:	e3530000 	cmp	r3, #0
3001b324:	0a00000b 	beq	3001b358 <tcp_process+0x7bc>
3001b328:	e59f3434 	ldr	r3, [pc, #1076]	; 3001b764 <tcp_process+0xbc8>
3001b32c:	e5933000 	ldr	r3, [r3]
3001b330:	e593200c 	ldr	r2, [r3, #12]
3001b334:	e59d300c 	ldr	r3, [sp, #12]
3001b338:	e1520003 	cmp	r2, r3
3001b33c:	1a000005 	bne	3001b358 <tcp_process+0x7bc>
3001b340:	e59f341c 	ldr	r3, [pc, #1052]	; 3001b764 <tcp_process+0xbc8>
3001b344:	e5933000 	ldr	r3, [r3]
3001b348:	e59d200c 	ldr	r2, [sp, #12]
3001b34c:	e592200c 	ldr	r2, [r2, #12]
3001b350:	e583200c 	str	r2, [r3, #12]
3001b354:	ea000008 	b	3001b37c <tcp_process+0x7e0>
3001b358:	e59f3404 	ldr	r3, [pc, #1028]	; 3001b764 <tcp_process+0xbc8>
3001b35c:	e5933000 	ldr	r3, [r3]
3001b360:	e593200c 	ldr	r2, [r3, #12]
3001b364:	e59f33f8 	ldr	r3, [pc, #1016]	; 3001b764 <tcp_process+0xbc8>
3001b368:	e5832000 	str	r2, [r3]
3001b36c:	e59f33f0 	ldr	r3, [pc, #1008]	; 3001b764 <tcp_process+0xbc8>
3001b370:	e5933000 	ldr	r3, [r3]
3001b374:	e3530000 	cmp	r3, #0
3001b378:	1affffe5 	bne	3001b314 <tcp_process+0x778>
3001b37c:	e59d300c 	ldr	r3, [sp, #12]
3001b380:	e3a02000 	mov	r2, #0
3001b384:	e583200c 	str	r2, [r3, #12]
        pcb->state = TIME_WAIT;
3001b388:	e59d300c 	ldr	r3, [sp, #12]
3001b38c:	e3a0200a 	mov	r2, #10
3001b390:	e5c32010 	strb	r2, [r3, #16]
        TCP_REG(&tcp_tw_pcbs, pcb);
3001b394:	e59f33cc 	ldr	r3, [pc, #972]	; 3001b768 <tcp_process+0xbcc>
3001b398:	e5932000 	ldr	r2, [r3]
3001b39c:	e59d300c 	ldr	r3, [sp, #12]
3001b3a0:	e583200c 	str	r2, [r3, #12]
3001b3a4:	e59f33bc 	ldr	r3, [pc, #956]	; 3001b768 <tcp_process+0xbcc>
3001b3a8:	e59d200c 	ldr	r2, [sp, #12]
3001b3ac:	e5832000 	str	r2, [r3]
3001b3b0:	ebffdbe0 	bl	30012338 <tcp_timer_needed>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
    if (flags & TCP_FIN) {
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
3001b3b4:	e1a00000 	nop			; (mov r0, r0)
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
3001b3b8:	ea0000d9 	b	3001b724 <tcp_process+0xb88>
        tcp_pcb_purge(pcb);
        TCP_RMV(&tcp_active_pcbs, pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
3001b3bc:	e59d300c 	ldr	r3, [sp, #12]
3001b3c0:	e5d3301c 	ldrb	r3, [r3, #28]
3001b3c4:	e3833002 	orr	r3, r3, #2
3001b3c8:	e20320ff 	and	r2, r3, #255	; 0xff
3001b3cc:	e59d300c 	ldr	r3, [sp, #12]
3001b3d0:	e5c3201c 	strb	r2, [r3, #28]
3001b3d4:	e59d000c 	ldr	r0, [sp, #12]
3001b3d8:	eb000ba9 	bl	3001e284 <tcp_output>
        pcb->state = CLOSING;
3001b3dc:	e59d300c 	ldr	r3, [sp, #12]
3001b3e0:	e3a02008 	mov	r2, #8
3001b3e4:	e5c32010 	strb	r2, [r3, #16]
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
3001b3e8:	ea0000cd 	b	3001b724 <tcp_process+0xb88>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
3001b3ec:	e59f334c 	ldr	r3, [pc, #844]	; 3001b740 <tcp_process+0xba4>
3001b3f0:	e5d33000 	ldrb	r3, [r3]
3001b3f4:	e2033010 	and	r3, r3, #16
3001b3f8:	e3530000 	cmp	r3, #0
3001b3fc:	0a0000bf 	beq	3001b700 <tcp_process+0xb64>
3001b400:	e59d300c 	ldr	r3, [sp, #12]
3001b404:	e5932050 	ldr	r2, [r3, #80]	; 0x50
3001b408:	e59f3334 	ldr	r3, [pc, #820]	; 3001b744 <tcp_process+0xba8>
3001b40c:	e5933000 	ldr	r3, [r3]
3001b410:	e1520003 	cmp	r2, r3
3001b414:	1a0000bb 	bne	3001b708 <tcp_process+0xb6c>
      pcb->state = FIN_WAIT_2;
3001b418:	e59d300c 	ldr	r3, [sp, #12]
3001b41c:	e3a02006 	mov	r2, #6
3001b420:	e5c32010 	strb	r2, [r3, #16]
    }
    break;
3001b424:	ea0000be 	b	3001b724 <tcp_process+0xb88>
  case FIN_WAIT_2:
    tcp_receive(pcb);
3001b428:	e59d000c 	ldr	r0, [sp, #12]
3001b42c:	eb0000ce 	bl	3001b76c <tcp_receive>
    if (flags & TCP_FIN) {
3001b430:	e59f3308 	ldr	r3, [pc, #776]	; 3001b740 <tcp_process+0xba4>
3001b434:	e5d33000 	ldrb	r3, [r3]
3001b438:	e2033001 	and	r3, r3, #1
3001b43c:	e20330ff 	and	r3, r3, #255	; 0xff
3001b440:	e3530000 	cmp	r3, #0
3001b444:	0a0000b1 	beq	3001b710 <tcp_process+0xb74>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
3001b448:	e59d300c 	ldr	r3, [sp, #12]
3001b44c:	e5d3301c 	ldrb	r3, [r3, #28]
3001b450:	e3833002 	orr	r3, r3, #2
3001b454:	e20320ff 	and	r2, r3, #255	; 0xff
3001b458:	e59d300c 	ldr	r3, [sp, #12]
3001b45c:	e5c3201c 	strb	r2, [r3, #28]
3001b460:	e59d000c 	ldr	r0, [sp, #12]
3001b464:	eb000b86 	bl	3001e284 <tcp_output>
      tcp_pcb_purge(pcb);
3001b468:	e59d000c 	ldr	r0, [sp, #12]
3001b46c:	ebfff835 	bl	30019548 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
3001b470:	e59f32e8 	ldr	r3, [pc, #744]	; 3001b760 <tcp_process+0xbc4>
3001b474:	e5932000 	ldr	r2, [r3]
3001b478:	e59d300c 	ldr	r3, [sp, #12]
3001b47c:	e1520003 	cmp	r2, r3
3001b480:	1a000005 	bne	3001b49c <tcp_process+0x900>
3001b484:	e59f32d4 	ldr	r3, [pc, #724]	; 3001b760 <tcp_process+0xbc4>
3001b488:	e5933000 	ldr	r3, [r3]
3001b48c:	e593200c 	ldr	r2, [r3, #12]
3001b490:	e59f32c8 	ldr	r3, [pc, #712]	; 3001b760 <tcp_process+0xbc4>
3001b494:	e5832000 	str	r2, [r3]
3001b498:	ea00001e 	b	3001b518 <tcp_process+0x97c>
3001b49c:	e59f32bc 	ldr	r3, [pc, #700]	; 3001b760 <tcp_process+0xbc4>
3001b4a0:	e5932000 	ldr	r2, [r3]
3001b4a4:	e59f32b8 	ldr	r3, [pc, #696]	; 3001b764 <tcp_process+0xbc8>
3001b4a8:	e5832000 	str	r2, [r3]
3001b4ac:	ea000015 	b	3001b508 <tcp_process+0x96c>
3001b4b0:	e59f32ac 	ldr	r3, [pc, #684]	; 3001b764 <tcp_process+0xbc8>
3001b4b4:	e5933000 	ldr	r3, [r3]
3001b4b8:	e593300c 	ldr	r3, [r3, #12]
3001b4bc:	e3530000 	cmp	r3, #0
3001b4c0:	0a00000b 	beq	3001b4f4 <tcp_process+0x958>
3001b4c4:	e59f3298 	ldr	r3, [pc, #664]	; 3001b764 <tcp_process+0xbc8>
3001b4c8:	e5933000 	ldr	r3, [r3]
3001b4cc:	e593200c 	ldr	r2, [r3, #12]
3001b4d0:	e59d300c 	ldr	r3, [sp, #12]
3001b4d4:	e1520003 	cmp	r2, r3
3001b4d8:	1a000005 	bne	3001b4f4 <tcp_process+0x958>
3001b4dc:	e59f3280 	ldr	r3, [pc, #640]	; 3001b764 <tcp_process+0xbc8>
3001b4e0:	e5933000 	ldr	r3, [r3]
3001b4e4:	e59d200c 	ldr	r2, [sp, #12]
3001b4e8:	e592200c 	ldr	r2, [r2, #12]
3001b4ec:	e583200c 	str	r2, [r3, #12]
3001b4f0:	ea000008 	b	3001b518 <tcp_process+0x97c>
3001b4f4:	e59f3268 	ldr	r3, [pc, #616]	; 3001b764 <tcp_process+0xbc8>
3001b4f8:	e5933000 	ldr	r3, [r3]
3001b4fc:	e593200c 	ldr	r2, [r3, #12]
3001b500:	e59f325c 	ldr	r3, [pc, #604]	; 3001b764 <tcp_process+0xbc8>
3001b504:	e5832000 	str	r2, [r3]
3001b508:	e59f3254 	ldr	r3, [pc, #596]	; 3001b764 <tcp_process+0xbc8>
3001b50c:	e5933000 	ldr	r3, [r3]
3001b510:	e3530000 	cmp	r3, #0
3001b514:	1affffe5 	bne	3001b4b0 <tcp_process+0x914>
3001b518:	e59d300c 	ldr	r3, [sp, #12]
3001b51c:	e3a02000 	mov	r2, #0
3001b520:	e583200c 	str	r2, [r3, #12]
      pcb->state = TIME_WAIT;
3001b524:	e59d300c 	ldr	r3, [sp, #12]
3001b528:	e3a0200a 	mov	r2, #10
3001b52c:	e5c32010 	strb	r2, [r3, #16]
      TCP_REG(&tcp_tw_pcbs, pcb);
3001b530:	e59f3230 	ldr	r3, [pc, #560]	; 3001b768 <tcp_process+0xbcc>
3001b534:	e5932000 	ldr	r2, [r3]
3001b538:	e59d300c 	ldr	r3, [sp, #12]
3001b53c:	e583200c 	str	r2, [r3, #12]
3001b540:	e59f3220 	ldr	r3, [pc, #544]	; 3001b768 <tcp_process+0xbcc>
3001b544:	e59d200c 	ldr	r2, [sp, #12]
3001b548:	e5832000 	str	r2, [r3]
3001b54c:	ebffdb79 	bl	30012338 <tcp_timer_needed>
    }
    break;
3001b550:	ea000073 	b	3001b724 <tcp_process+0xb88>
  case CLOSING:
    tcp_receive(pcb);
3001b554:	e59d000c 	ldr	r0, [sp, #12]
3001b558:	eb000083 	bl	3001b76c <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
3001b55c:	e59f31dc 	ldr	r3, [pc, #476]	; 3001b740 <tcp_process+0xba4>
3001b560:	e5d33000 	ldrb	r3, [r3]
3001b564:	e2033010 	and	r3, r3, #16
3001b568:	e3530000 	cmp	r3, #0
3001b56c:	0a000069 	beq	3001b718 <tcp_process+0xb7c>
3001b570:	e59d300c 	ldr	r3, [sp, #12]
3001b574:	e5932050 	ldr	r2, [r3, #80]	; 0x50
3001b578:	e59f31c4 	ldr	r3, [pc, #452]	; 3001b744 <tcp_process+0xba8>
3001b57c:	e5933000 	ldr	r3, [r3]
3001b580:	e1520003 	cmp	r2, r3
3001b584:	1a000065 	bne	3001b720 <tcp_process+0xb84>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
3001b588:	e59d300c 	ldr	r3, [sp, #12]
3001b58c:	e5d3301c 	ldrb	r3, [r3, #28]
3001b590:	e3833002 	orr	r3, r3, #2
3001b594:	e20320ff 	and	r2, r3, #255	; 0xff
3001b598:	e59d300c 	ldr	r3, [sp, #12]
3001b59c:	e5c3201c 	strb	r2, [r3, #28]
3001b5a0:	e59d000c 	ldr	r0, [sp, #12]
3001b5a4:	eb000b36 	bl	3001e284 <tcp_output>
      tcp_pcb_purge(pcb);
3001b5a8:	e59d000c 	ldr	r0, [sp, #12]
3001b5ac:	ebfff7e5 	bl	30019548 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
3001b5b0:	e59f31a8 	ldr	r3, [pc, #424]	; 3001b760 <tcp_process+0xbc4>
3001b5b4:	e5932000 	ldr	r2, [r3]
3001b5b8:	e59d300c 	ldr	r3, [sp, #12]
3001b5bc:	e1520003 	cmp	r2, r3
3001b5c0:	1a000005 	bne	3001b5dc <tcp_process+0xa40>
3001b5c4:	e59f3194 	ldr	r3, [pc, #404]	; 3001b760 <tcp_process+0xbc4>
3001b5c8:	e5933000 	ldr	r3, [r3]
3001b5cc:	e593200c 	ldr	r2, [r3, #12]
3001b5d0:	e59f3188 	ldr	r3, [pc, #392]	; 3001b760 <tcp_process+0xbc4>
3001b5d4:	e5832000 	str	r2, [r3]
3001b5d8:	ea00001e 	b	3001b658 <tcp_process+0xabc>
3001b5dc:	e59f317c 	ldr	r3, [pc, #380]	; 3001b760 <tcp_process+0xbc4>
3001b5e0:	e5932000 	ldr	r2, [r3]
3001b5e4:	e59f3178 	ldr	r3, [pc, #376]	; 3001b764 <tcp_process+0xbc8>
3001b5e8:	e5832000 	str	r2, [r3]
3001b5ec:	ea000015 	b	3001b648 <tcp_process+0xaac>
3001b5f0:	e59f316c 	ldr	r3, [pc, #364]	; 3001b764 <tcp_process+0xbc8>
3001b5f4:	e5933000 	ldr	r3, [r3]
3001b5f8:	e593300c 	ldr	r3, [r3, #12]
3001b5fc:	e3530000 	cmp	r3, #0
3001b600:	0a00000b 	beq	3001b634 <tcp_process+0xa98>
3001b604:	e59f3158 	ldr	r3, [pc, #344]	; 3001b764 <tcp_process+0xbc8>
3001b608:	e5933000 	ldr	r3, [r3]
3001b60c:	e593200c 	ldr	r2, [r3, #12]
3001b610:	e59d300c 	ldr	r3, [sp, #12]
3001b614:	e1520003 	cmp	r2, r3
3001b618:	1a000005 	bne	3001b634 <tcp_process+0xa98>
3001b61c:	e59f3140 	ldr	r3, [pc, #320]	; 3001b764 <tcp_process+0xbc8>
3001b620:	e5933000 	ldr	r3, [r3]
3001b624:	e59d200c 	ldr	r2, [sp, #12]
3001b628:	e592200c 	ldr	r2, [r2, #12]
3001b62c:	e583200c 	str	r2, [r3, #12]
3001b630:	ea000008 	b	3001b658 <tcp_process+0xabc>
3001b634:	e59f3128 	ldr	r3, [pc, #296]	; 3001b764 <tcp_process+0xbc8>
3001b638:	e5933000 	ldr	r3, [r3]
3001b63c:	e593200c 	ldr	r2, [r3, #12]
3001b640:	e59f311c 	ldr	r3, [pc, #284]	; 3001b764 <tcp_process+0xbc8>
3001b644:	e5832000 	str	r2, [r3]
3001b648:	e59f3114 	ldr	r3, [pc, #276]	; 3001b764 <tcp_process+0xbc8>
3001b64c:	e5933000 	ldr	r3, [r3]
3001b650:	e3530000 	cmp	r3, #0
3001b654:	1affffe5 	bne	3001b5f0 <tcp_process+0xa54>
3001b658:	e59d300c 	ldr	r3, [sp, #12]
3001b65c:	e3a02000 	mov	r2, #0
3001b660:	e583200c 	str	r2, [r3, #12]
      pcb->state = TIME_WAIT;
3001b664:	e59d300c 	ldr	r3, [sp, #12]
3001b668:	e3a0200a 	mov	r2, #10
3001b66c:	e5c32010 	strb	r2, [r3, #16]
      TCP_REG(&tcp_tw_pcbs, pcb);
3001b670:	e59f30f0 	ldr	r3, [pc, #240]	; 3001b768 <tcp_process+0xbcc>
3001b674:	e5932000 	ldr	r2, [r3]
3001b678:	e59d300c 	ldr	r3, [sp, #12]
3001b67c:	e583200c 	str	r2, [r3, #12]
3001b680:	e59f30e0 	ldr	r3, [pc, #224]	; 3001b768 <tcp_process+0xbcc>
3001b684:	e59d200c 	ldr	r2, [sp, #12]
3001b688:	e5832000 	str	r2, [r3]
3001b68c:	ebffdb29 	bl	30012338 <tcp_timer_needed>
    }
    break;
3001b690:	ea000023 	b	3001b724 <tcp_process+0xb88>
  case LAST_ACK:
    tcp_receive(pcb);
3001b694:	e59d000c 	ldr	r0, [sp, #12]
3001b698:	eb000033 	bl	3001b76c <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
3001b69c:	e59f309c 	ldr	r3, [pc, #156]	; 3001b740 <tcp_process+0xba4>
3001b6a0:	e5d33000 	ldrb	r3, [r3]
3001b6a4:	e2033010 	and	r3, r3, #16
3001b6a8:	e3530000 	cmp	r3, #0
3001b6ac:	0a00001c 	beq	3001b724 <tcp_process+0xb88>
3001b6b0:	e59d300c 	ldr	r3, [sp, #12]
3001b6b4:	e5932050 	ldr	r2, [r3, #80]	; 0x50
3001b6b8:	e59f3084 	ldr	r3, [pc, #132]	; 3001b744 <tcp_process+0xba8>
3001b6bc:	e5933000 	ldr	r3, [r3]
3001b6c0:	e1520003 	cmp	r2, r3
3001b6c4:	1a000016 	bne	3001b724 <tcp_process+0xb88>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
3001b6c8:	e59f307c 	ldr	r3, [pc, #124]	; 3001b74c <tcp_process+0xbb0>
3001b6cc:	e3a02010 	mov	r2, #16
3001b6d0:	e5c32000 	strb	r2, [r3]
3001b6d4:	ea000012 	b	3001b724 <tcp_process+0xb88>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
3001b6d8:	e1a00000 	nop			; (mov r0, r0)
3001b6dc:	ea000010 	b	3001b724 <tcp_process+0xb88>
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
3001b6e0:	e1a00000 	nop			; (mov r0, r0)
3001b6e4:	ea00000e 	b	3001b724 <tcp_process+0xb88>
3001b6e8:	e1a00000 	nop			; (mov r0, r0)
3001b6ec:	ea00000c 	b	3001b724 <tcp_process+0xb88>
    accepted_inseq = tcp_receive(pcb);
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
3001b6f0:	e1a00000 	nop			; (mov r0, r0)
3001b6f4:	ea00000a 	b	3001b724 <tcp_process+0xb88>
3001b6f8:	e1a00000 	nop			; (mov r0, r0)
3001b6fc:	ea000008 	b	3001b724 <tcp_process+0xb88>
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
3001b700:	e1a00000 	nop			; (mov r0, r0)
3001b704:	ea000006 	b	3001b724 <tcp_process+0xb88>
3001b708:	e1a00000 	nop			; (mov r0, r0)
3001b70c:	ea000004 	b	3001b724 <tcp_process+0xb88>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
3001b710:	e1a00000 	nop			; (mov r0, r0)
3001b714:	ea000002 	b	3001b724 <tcp_process+0xb88>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
3001b718:	e1a00000 	nop			; (mov r0, r0)
3001b71c:	ea000000 	b	3001b724 <tcp_process+0xb88>
3001b720:	e1a00000 	nop			; (mov r0, r0)
    }
    break;
  default:
    break;
  }
  return ERR_OK;
3001b724:	e3a03000 	mov	r3, #0
3001b728:	e1a03c03 	lsl	r3, r3, #24
3001b72c:	e1a03c43 	asr	r3, r3, #24
}
3001b730:	e1a00003 	mov	r0, r3
3001b734:	e28dd020 	add	sp, sp, #32
3001b738:	e8bd4010 	pop	{r4, lr}
3001b73c:	e12fff1e 	bx	lr
3001b740:	30028f80 	.word	0x30028f80
3001b744:	30028f7c 	.word	0x30028f7c
3001b748:	30028f78 	.word	0x30028f78
3001b74c:	30028f84 	.word	0x30028f84
3001b750:	3002a724 	.word	0x3002a724
3001b754:	30028f70 	.word	0x30028f70
3001b758:	30028f82 	.word	0x30028f82
3001b75c:	30028f74 	.word	0x30028f74
3001b760:	3002a6e8 	.word	0x3002a6e8
3001b764:	3002a838 	.word	0x3002a838
3001b768:	3002b1c4 	.word	0x3002b1c4

3001b76c <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
3001b76c:	e92d4070 	push	{r4, r5, r6, lr}
3001b770:	e24dd030 	sub	sp, sp, #48	; 0x30
3001b774:	e58d0004 	str	r0, [sp, #4]
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
3001b778:	e3a03000 	mov	r3, #0
3001b77c:	e5cd3029 	strb	r3, [sp, #41]	; 0x29

  if (flags & TCP_ACK) {
3001b780:	e59f3e50 	ldr	r3, [pc, #3664]	; 3001c5d8 <tcp_receive+0xe6c>
3001b784:	e5d33000 	ldrb	r3, [r3]
3001b788:	e2033010 	and	r3, r3, #16
3001b78c:	e3530000 	cmp	r3, #0
3001b790:	0a000298 	beq	3001c1f8 <tcp_receive+0xa8c>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
3001b794:	e59d3004 	ldr	r3, [sp, #4]
3001b798:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
3001b79c:	e1a02003 	mov	r2, r3
3001b7a0:	e59d3004 	ldr	r3, [sp, #4]
3001b7a4:	e593305c 	ldr	r3, [r3, #92]	; 0x5c
3001b7a8:	e0823003 	add	r3, r2, r3
3001b7ac:	e58d3020 	str	r3, [sp, #32]

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
3001b7b0:	e59d3004 	ldr	r3, [sp, #4]
3001b7b4:	e593205c 	ldr	r2, [r3, #92]	; 0x5c
3001b7b8:	e59f3e38 	ldr	r3, [pc, #3640]	; 3001c5f8 <tcp_receive+0xe8c>
3001b7bc:	e5933000 	ldr	r3, [r3]
3001b7c0:	e0633002 	rsb	r3, r3, r2
3001b7c4:	e3530000 	cmp	r3, #0
3001b7c8:	ba00001e 	blt	3001b848 <tcp_receive+0xdc>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
3001b7cc:	e59d3004 	ldr	r3, [sp, #4]
3001b7d0:	e593205c 	ldr	r2, [r3, #92]	; 0x5c
3001b7d4:	e59f3e1c 	ldr	r3, [pc, #3612]	; 3001c5f8 <tcp_receive+0xe8c>
3001b7d8:	e5933000 	ldr	r3, [r3]

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
3001b7dc:	e1520003 	cmp	r2, r3
3001b7e0:	1a000006 	bne	3001b800 <tcp_receive+0x94>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
3001b7e4:	e59d3004 	ldr	r3, [sp, #4]
3001b7e8:	e5932060 	ldr	r2, [r3, #96]	; 0x60
3001b7ec:	e59f3de8 	ldr	r3, [pc, #3560]	; 3001c5dc <tcp_receive+0xe70>
3001b7f0:	e5933000 	ldr	r3, [r3]
3001b7f4:	e0633002 	rsb	r3, r3, r2

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
3001b7f8:	e3530000 	cmp	r3, #0
3001b7fc:	ba000011 	blt	3001b848 <tcp_receive+0xdc>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
3001b800:	e59d3004 	ldr	r3, [sp, #4]
3001b804:	e5932060 	ldr	r2, [r3, #96]	; 0x60
3001b808:	e59f3dcc 	ldr	r3, [pc, #3532]	; 3001c5dc <tcp_receive+0xe70>
3001b80c:	e5933000 	ldr	r3, [r3]

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
3001b810:	e1520003 	cmp	r2, r3
3001b814:	1a000028 	bne	3001b8bc <tcp_receive+0x150>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
3001b818:	e59f3dc0 	ldr	r3, [pc, #3520]	; 3001c5e0 <tcp_receive+0xe74>
3001b81c:	e5933000 	ldr	r3, [r3]
3001b820:	e5d3200e 	ldrb	r2, [r3, #14]
3001b824:	e5d3300f 	ldrb	r3, [r3, #15]
3001b828:	e1a03403 	lsl	r3, r3, #8
3001b82c:	e1833002 	orr	r3, r3, r2
3001b830:	e1a03803 	lsl	r3, r3, #16
3001b834:	e1a02823 	lsr	r2, r3, #16
3001b838:	e59d3004 	ldr	r3, [sp, #4]
3001b83c:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
3001b840:	e1520003 	cmp	r2, r3
3001b844:	9a00001c 	bls	3001b8bc <tcp_receive+0x150>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
3001b848:	e59f3d90 	ldr	r3, [pc, #3472]	; 3001c5e0 <tcp_receive+0xe74>
3001b84c:	e5933000 	ldr	r3, [r3]
3001b850:	e5d3200e 	ldrb	r2, [r3, #14]
3001b854:	e5d3300f 	ldrb	r3, [r3, #15]
3001b858:	e1a03403 	lsl	r3, r3, #8
3001b85c:	e1833002 	orr	r3, r3, r2
3001b860:	e1a03803 	lsl	r3, r3, #16
3001b864:	e1a02823 	lsr	r2, r3, #16
3001b868:	e59d3004 	ldr	r3, [sp, #4]
3001b86c:	e1c325b8 	strh	r2, [r3, #88]	; 0x58
      pcb->snd_wl1 = seqno;
3001b870:	e59f3d80 	ldr	r3, [pc, #3456]	; 3001c5f8 <tcp_receive+0xe8c>
3001b874:	e5932000 	ldr	r2, [r3]
3001b878:	e59d3004 	ldr	r3, [sp, #4]
3001b87c:	e583205c 	str	r2, [r3, #92]	; 0x5c
      pcb->snd_wl2 = ackno;
3001b880:	e59f3d54 	ldr	r3, [pc, #3412]	; 3001c5dc <tcp_receive+0xe70>
3001b884:	e5932000 	ldr	r2, [r3]
3001b888:	e59d3004 	ldr	r3, [sp, #4]
3001b88c:	e5832060 	str	r2, [r3, #96]	; 0x60
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
3001b890:	e59d3004 	ldr	r3, [sp, #4]
3001b894:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
3001b898:	e3530000 	cmp	r3, #0
3001b89c:	0a000006 	beq	3001b8bc <tcp_receive+0x150>
3001b8a0:	e59d3004 	ldr	r3, [sp, #4]
3001b8a4:	e5d330a0 	ldrb	r3, [r3, #160]	; 0xa0
3001b8a8:	e3530000 	cmp	r3, #0
3001b8ac:	0a000002 	beq	3001b8bc <tcp_receive+0x150>
          pcb->persist_backoff = 0;
3001b8b0:	e59d3004 	ldr	r3, [sp, #4]
3001b8b4:	e3a02000 	mov	r2, #0
3001b8b8:	e5c320a0 	strb	r2, [r3, #160]	; 0xa0
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
3001b8bc:	e59d3004 	ldr	r3, [sp, #4]
3001b8c0:	e5932044 	ldr	r2, [r3, #68]	; 0x44
3001b8c4:	e59f3d10 	ldr	r3, [pc, #3344]	; 3001c5dc <tcp_receive+0xe70>
3001b8c8:	e5933000 	ldr	r3, [r3]
3001b8cc:	e1520003 	cmp	r2, r3
3001b8d0:	1a00006d 	bne	3001ba8c <tcp_receive+0x320>
      pcb->acked = 0;
3001b8d4:	e59d3004 	ldr	r3, [sp, #4]
3001b8d8:	e3a02000 	mov	r2, #0
3001b8dc:	e1c326b8 	strh	r2, [r3, #104]	; 0x68

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
3001b8e0:	e59d3004 	ldr	r3, [sp, #4]
3001b8e4:	e593205c 	ldr	r2, [r3, #92]	; 0x5c
3001b8e8:	e59d3004 	ldr	r3, [sp, #4]
3001b8ec:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
3001b8f0:	e0822003 	add	r2, r2, r3
3001b8f4:	e59d3020 	ldr	r3, [sp, #32]
3001b8f8:	e1520003 	cmp	r2, r3
3001b8fc:	1a000189 	bne	3001bf28 <tcp_receive+0x7bc>
        ++pcb->dupacks;
3001b900:	e59d3004 	ldr	r3, [sp, #4]
3001b904:	e5d33048 	ldrb	r3, [r3, #72]	; 0x48
3001b908:	e2833001 	add	r3, r3, #1
3001b90c:	e20320ff 	and	r2, r3, #255	; 0xff
3001b910:	e59d3004 	ldr	r3, [sp, #4]
3001b914:	e5c32048 	strb	r2, [r3, #72]	; 0x48
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
3001b918:	e59d3004 	ldr	r3, [sp, #4]
3001b91c:	e5d33048 	ldrb	r3, [r3, #72]	; 0x48
3001b920:	e3530002 	cmp	r3, #2
3001b924:	9a000181 	bls	3001bf30 <tcp_receive+0x7c4>
3001b928:	e59d3004 	ldr	r3, [sp, #4]
3001b92c:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001b930:	e3530000 	cmp	r3, #0
3001b934:	0a00017f 	beq	3001bf38 <tcp_receive+0x7cc>
          if (!(pcb->flags & TF_INFR)) {
3001b938:	e59d3004 	ldr	r3, [sp, #4]
3001b93c:	e5d3301c 	ldrb	r3, [r3, #28]
3001b940:	e2033004 	and	r3, r3, #4
3001b944:	e3530000 	cmp	r3, #0
3001b948:	1a00003a 	bne	3001ba38 <tcp_receive+0x2cc>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
3001b94c:	e59d0004 	ldr	r0, [sp, #4]
3001b950:	eb000ea1 	bl	3001f3dc <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
3001b954:	e59d3004 	ldr	r3, [sp, #4]
3001b958:	e1d324ba 	ldrh	r2, [r3, #74]	; 0x4a
3001b95c:	e59d3004 	ldr	r3, [sp, #4]
3001b960:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
3001b964:	e1520003 	cmp	r2, r3
3001b968:	9a000007 	bls	3001b98c <tcp_receive+0x220>
              pcb->ssthresh = pcb->snd_wnd / 2;
3001b96c:	e59d3004 	ldr	r3, [sp, #4]
3001b970:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
3001b974:	e1a030a3 	lsr	r3, r3, #1
3001b978:	e1a03803 	lsl	r3, r3, #16
3001b97c:	e1a02823 	lsr	r2, r3, #16
3001b980:	e59d3004 	ldr	r3, [sp, #4]
3001b984:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
3001b988:	ea000006 	b	3001b9a8 <tcp_receive+0x23c>
            else
              pcb->ssthresh = pcb->cwnd / 2;
3001b98c:	e59d3004 	ldr	r3, [sp, #4]
3001b990:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
3001b994:	e1a030a3 	lsr	r3, r3, #1
3001b998:	e1a03803 	lsl	r3, r3, #16
3001b99c:	e1a02823 	lsr	r2, r3, #16
3001b9a0:	e59d3004 	ldr	r3, [sp, #4]
3001b9a4:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
3001b9a8:	e59d3004 	ldr	r3, [sp, #4]
3001b9ac:	e1d334bc 	ldrh	r3, [r3, #76]	; 0x4c
3001b9b0:	e1a02003 	mov	r2, r3
3001b9b4:	e59d3004 	ldr	r3, [sp, #4]
3001b9b8:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001b9bc:	e1a03083 	lsl	r3, r3, #1
3001b9c0:	e1520003 	cmp	r2, r3
3001b9c4:	aa000006 	bge	3001b9e4 <tcp_receive+0x278>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
3001b9c8:	e59d3004 	ldr	r3, [sp, #4]
3001b9cc:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001b9d0:	e1a03083 	lsl	r3, r3, #1
3001b9d4:	e1a03803 	lsl	r3, r3, #16
3001b9d8:	e1a02823 	lsr	r2, r3, #16
3001b9dc:	e59d3004 	ldr	r3, [sp, #4]
3001b9e0:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
3001b9e4:	e59d3004 	ldr	r3, [sp, #4]
3001b9e8:	e1d324bc 	ldrh	r2, [r3, #76]	; 0x4c
3001b9ec:	e59d3004 	ldr	r3, [sp, #4]
3001b9f0:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001b9f4:	e1a01003 	mov	r1, r3
3001b9f8:	e1a01081 	lsl	r1, r1, #1
3001b9fc:	e0813003 	add	r3, r1, r3
3001ba00:	e1a03803 	lsl	r3, r3, #16
3001ba04:	e1a03823 	lsr	r3, r3, #16
3001ba08:	e0823003 	add	r3, r2, r3
3001ba0c:	e1a03803 	lsl	r3, r3, #16
3001ba10:	e1a02823 	lsr	r2, r3, #16
3001ba14:	e59d3004 	ldr	r3, [sp, #4]
3001ba18:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
            pcb->flags |= TF_INFR;
3001ba1c:	e59d3004 	ldr	r3, [sp, #4]
3001ba20:	e5d3301c 	ldrb	r3, [r3, #28]
3001ba24:	e3833004 	orr	r3, r3, #4
3001ba28:	e20320ff 	and	r2, r3, #255	; 0xff
3001ba2c:	e59d3004 	ldr	r3, [sp, #4]
3001ba30:	e5c3201c 	strb	r2, [r3, #28]
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
3001ba34:	ea000142 	b	3001bf44 <tcp_receive+0x7d8>
            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
            pcb->flags |= TF_INFR;
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
3001ba38:	e59d3004 	ldr	r3, [sp, #4]
3001ba3c:	e1d324ba 	ldrh	r2, [r3, #74]	; 0x4a
3001ba40:	e59d3004 	ldr	r3, [sp, #4]
3001ba44:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001ba48:	e0823003 	add	r3, r2, r3
3001ba4c:	e1a03803 	lsl	r3, r3, #16
3001ba50:	e1a02823 	lsr	r2, r3, #16
3001ba54:	e59d3004 	ldr	r3, [sp, #4]
3001ba58:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
3001ba5c:	e1520003 	cmp	r2, r3
3001ba60:	9a000136 	bls	3001bf40 <tcp_receive+0x7d4>
              pcb->cwnd += pcb->mss;
3001ba64:	e59d3004 	ldr	r3, [sp, #4]
3001ba68:	e1d324ba 	ldrh	r2, [r3, #74]	; 0x4a
3001ba6c:	e59d3004 	ldr	r3, [sp, #4]
3001ba70:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001ba74:	e0823003 	add	r3, r2, r3
3001ba78:	e1a03803 	lsl	r3, r3, #16
3001ba7c:	e1a02823 	lsr	r2, r3, #16
3001ba80:	e59d3004 	ldr	r3, [sp, #4]
3001ba84:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
3001ba88:	ea00012d 	b	3001bf44 <tcp_receive+0x7d8>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
3001ba8c:	e59d3004 	ldr	r3, [sp, #4]
3001ba90:	e5933044 	ldr	r3, [r3, #68]	; 0x44
3001ba94:	e1e02003 	mvn	r2, r3
3001ba98:	e59f3b3c 	ldr	r3, [pc, #2876]	; 3001c5dc <tcp_receive+0xe70>
3001ba9c:	e5933000 	ldr	r3, [r3]
3001baa0:	e0823003 	add	r3, r2, r3
3001baa4:	e3530000 	cmp	r3, #0
3001baa8:	ba0000ed 	blt	3001be64 <tcp_receive+0x6f8>
3001baac:	e59f3b28 	ldr	r3, [pc, #2856]	; 3001c5dc <tcp_receive+0xe70>
3001bab0:	e5932000 	ldr	r2, [r3]
3001bab4:	e59d3004 	ldr	r3, [sp, #4]
3001bab8:	e5933054 	ldr	r3, [r3, #84]	; 0x54
3001babc:	e0633002 	rsb	r3, r3, r2
3001bac0:	e3530000 	cmp	r3, #0
3001bac4:	ca0000e6 	bgt	3001be64 <tcp_receive+0x6f8>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
3001bac8:	e59d3004 	ldr	r3, [sp, #4]
3001bacc:	e5d3301c 	ldrb	r3, [r3, #28]
3001bad0:	e2033004 	and	r3, r3, #4
3001bad4:	e3530000 	cmp	r3, #0
3001bad8:	0a000008 	beq	3001bb00 <tcp_receive+0x394>
        pcb->flags &= ~TF_INFR;
3001badc:	e59d3004 	ldr	r3, [sp, #4]
3001bae0:	e5d3301c 	ldrb	r3, [r3, #28]
3001bae4:	e20330fb 	and	r3, r3, #251	; 0xfb
3001bae8:	e59d2004 	ldr	r2, [sp, #4]
3001baec:	e5c2301c 	strb	r3, [r2, #28]
        pcb->cwnd = pcb->ssthresh;
3001baf0:	e59d3004 	ldr	r3, [sp, #4]
3001baf4:	e1d324bc 	ldrh	r2, [r3, #76]	; 0x4c
3001baf8:	e59d3004 	ldr	r3, [sp, #4]
3001bafc:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
3001bb00:	e59d3004 	ldr	r3, [sp, #4]
3001bb04:	e3a02000 	mov	r2, #0
3001bb08:	e5c32042 	strb	r2, [r3, #66]	; 0x42

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
3001bb0c:	e59d3004 	ldr	r3, [sp, #4]
3001bb10:	e1d333bc 	ldrh	r3, [r3, #60]	; 0x3c
3001bb14:	e1a03803 	lsl	r3, r3, #16
3001bb18:	e1a03843 	asr	r3, r3, #16
3001bb1c:	e1a031c3 	asr	r3, r3, #3
3001bb20:	e1a03803 	lsl	r3, r3, #16
3001bb24:	e1a03823 	lsr	r3, r3, #16
3001bb28:	e1a03803 	lsl	r3, r3, #16
3001bb2c:	e1a02823 	lsr	r2, r3, #16
3001bb30:	e59d3004 	ldr	r3, [sp, #4]
3001bb34:	e1d333be 	ldrh	r3, [r3, #62]	; 0x3e
3001bb38:	e1a03803 	lsl	r3, r3, #16
3001bb3c:	e1a03823 	lsr	r3, r3, #16
3001bb40:	e0823003 	add	r3, r2, r3
3001bb44:	e1a03803 	lsl	r3, r3, #16
3001bb48:	e1a03823 	lsr	r3, r3, #16
3001bb4c:	e1a02003 	mov	r2, r3
3001bb50:	e59d3004 	ldr	r3, [sp, #4]
3001bb54:	e1c324b0 	strh	r2, [r3, #64]	; 0x40

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
3001bb58:	e59f3a7c 	ldr	r3, [pc, #2684]	; 3001c5dc <tcp_receive+0xe70>
3001bb5c:	e5933000 	ldr	r3, [r3]
3001bb60:	e1a03803 	lsl	r3, r3, #16
3001bb64:	e1a02823 	lsr	r2, r3, #16
3001bb68:	e59d3004 	ldr	r3, [sp, #4]
3001bb6c:	e5933044 	ldr	r3, [r3, #68]	; 0x44
3001bb70:	e1a03803 	lsl	r3, r3, #16
3001bb74:	e1a03823 	lsr	r3, r3, #16
3001bb78:	e0633002 	rsb	r3, r3, r2
3001bb7c:	e1a03803 	lsl	r3, r3, #16
3001bb80:	e1a02823 	lsr	r2, r3, #16
3001bb84:	e59d3004 	ldr	r3, [sp, #4]
3001bb88:	e1c326b8 	strh	r2, [r3, #104]	; 0x68

      pcb->snd_buf += pcb->acked;
3001bb8c:	e59d3004 	ldr	r3, [sp, #4]
3001bb90:	e1d326ba 	ldrh	r2, [r3, #106]	; 0x6a
3001bb94:	e59d3004 	ldr	r3, [sp, #4]
3001bb98:	e1d336b8 	ldrh	r3, [r3, #104]	; 0x68
3001bb9c:	e0823003 	add	r3, r2, r3
3001bba0:	e1a03803 	lsl	r3, r3, #16
3001bba4:	e1a02823 	lsr	r2, r3, #16
3001bba8:	e59d3004 	ldr	r3, [sp, #4]
3001bbac:	e1c326ba 	strh	r2, [r3, #106]	; 0x6a

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
3001bbb0:	e59d3004 	ldr	r3, [sp, #4]
3001bbb4:	e3a02000 	mov	r2, #0
3001bbb8:	e5c32048 	strb	r2, [r3, #72]	; 0x48
      pcb->lastack = ackno;
3001bbbc:	e59f3a18 	ldr	r3, [pc, #2584]	; 3001c5dc <tcp_receive+0xe70>
3001bbc0:	e5932000 	ldr	r2, [r3]
3001bbc4:	e59d3004 	ldr	r3, [sp, #4]
3001bbc8:	e5832044 	str	r2, [r3, #68]	; 0x44

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
3001bbcc:	e59d3004 	ldr	r3, [sp, #4]
3001bbd0:	e5d33010 	ldrb	r3, [r3, #16]
3001bbd4:	e3530003 	cmp	r3, #3
3001bbd8:	9a00004b 	bls	3001bd0c <tcp_receive+0x5a0>
        if (pcb->cwnd < pcb->ssthresh) {
3001bbdc:	e59d3004 	ldr	r3, [sp, #4]
3001bbe0:	e1d324ba 	ldrh	r2, [r3, #74]	; 0x4a
3001bbe4:	e59d3004 	ldr	r3, [sp, #4]
3001bbe8:	e1d334bc 	ldrh	r3, [r3, #76]	; 0x4c
3001bbec:	e1520003 	cmp	r2, r3
3001bbf0:	2a000014 	bcs	3001bc48 <tcp_receive+0x4dc>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
3001bbf4:	e59d3004 	ldr	r3, [sp, #4]
3001bbf8:	e1d324ba 	ldrh	r2, [r3, #74]	; 0x4a
3001bbfc:	e59d3004 	ldr	r3, [sp, #4]
3001bc00:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001bc04:	e0823003 	add	r3, r2, r3
3001bc08:	e1a03803 	lsl	r3, r3, #16
3001bc0c:	e1a02823 	lsr	r2, r3, #16
3001bc10:	e59d3004 	ldr	r3, [sp, #4]
3001bc14:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
3001bc18:	e1520003 	cmp	r2, r3
3001bc1c:	9a00003c 	bls	3001bd14 <tcp_receive+0x5a8>
            pcb->cwnd += pcb->mss;
3001bc20:	e59d3004 	ldr	r3, [sp, #4]
3001bc24:	e1d324ba 	ldrh	r2, [r3, #74]	; 0x4a
3001bc28:	e59d3004 	ldr	r3, [sp, #4]
3001bc2c:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001bc30:	e0823003 	add	r3, r2, r3
3001bc34:	e1a03803 	lsl	r3, r3, #16
3001bc38:	e1a02823 	lsr	r2, r3, #16
3001bc3c:	e59d3004 	ldr	r3, [sp, #4]
3001bc40:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
3001bc44:	ea000035 	b	3001bd20 <tcp_receive+0x5b4>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
            pcb->cwnd += pcb->mss;
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
3001bc48:	e59d3004 	ldr	r3, [sp, #4]
3001bc4c:	e1d344ba 	ldrh	r4, [r3, #74]	; 0x4a
3001bc50:	e59d3004 	ldr	r3, [sp, #4]
3001bc54:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001bc58:	e59d2004 	ldr	r2, [sp, #4]
3001bc5c:	e1d223b0 	ldrh	r2, [r2, #48]	; 0x30
3001bc60:	e0020293 	mul	r2, r3, r2
3001bc64:	e59d3004 	ldr	r3, [sp, #4]
3001bc68:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
3001bc6c:	e1a00002 	mov	r0, r2
3001bc70:	e1a01003 	mov	r1, r3
3001bc74:	eb00266f 	bl	30025638 <__aeabi_idiv>
3001bc78:	e1a03000 	mov	r3, r0
3001bc7c:	e1a03803 	lsl	r3, r3, #16
3001bc80:	e1a03823 	lsr	r3, r3, #16
3001bc84:	e0843003 	add	r3, r4, r3
3001bc88:	e1cd32ba 	strh	r3, [sp, #42]	; 0x2a
          if (new_cwnd > pcb->cwnd) {
3001bc8c:	e59d3004 	ldr	r3, [sp, #4]
3001bc90:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
3001bc94:	e1dd22ba 	ldrh	r2, [sp, #42]	; 0x2a
3001bc98:	e1520003 	cmp	r2, r3
3001bc9c:	9a00001e 	bls	3001bd1c <tcp_receive+0x5b0>
            pcb->cwnd = new_cwnd;
3001bca0:	e59d3004 	ldr	r3, [sp, #4]
3001bca4:	e1dd22ba 	ldrh	r2, [sp, #42]	; 0x2a
3001bca8:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
3001bcac:	ea00001b 	b	3001bd20 <tcp_receive+0x5b4>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
3001bcb0:	e59d3004 	ldr	r3, [sp, #4]
3001bcb4:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001bcb8:	e58d3008 	str	r3, [sp, #8]
        pcb->unacked = pcb->unacked->next;
3001bcbc:	e59d3004 	ldr	r3, [sp, #4]
3001bcc0:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001bcc4:	e5932000 	ldr	r2, [r3]
3001bcc8:	e59d3004 	ldr	r3, [sp, #4]
3001bccc:	e5832074 	str	r2, [r3, #116]	; 0x74

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
        pcb->snd_queuelen -= pbuf_clen(next->p);
3001bcd0:	e59d3004 	ldr	r3, [sp, #4]
3001bcd4:	e1d346bc 	ldrh	r4, [r3, #108]	; 0x6c
3001bcd8:	e59d3008 	ldr	r3, [sp, #8]
3001bcdc:	e5933004 	ldr	r3, [r3, #4]
3001bce0:	e1a00003 	mov	r0, r3
3001bce4:	ebffea57 	bl	30016648 <pbuf_clen>
3001bce8:	e1a03000 	mov	r3, r0
3001bcec:	e0633004 	rsb	r3, r3, r4
3001bcf0:	e1a03803 	lsl	r3, r3, #16
3001bcf4:	e1a02823 	lsr	r2, r3, #16
3001bcf8:	e59d3004 	ldr	r3, [sp, #4]
3001bcfc:	e1c326bc 	strh	r2, [r3, #108]	; 0x6c
        tcp_seg_free(next);
3001bd00:	e59d0008 	ldr	r0, [sp, #8]
3001bd04:	ebfff4a4 	bl	30018f9c <tcp_seg_free>
3001bd08:	ea000004 	b	3001bd20 <tcp_receive+0x5b4>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
3001bd0c:	e1a00000 	nop			; (mov r0, r0)
3001bd10:	ea000002 	b	3001bd20 <tcp_receive+0x5b4>
3001bd14:	e1a00000 	nop			; (mov r0, r0)
3001bd18:	ea000000 	b	3001bd20 <tcp_receive+0x5b4>
3001bd1c:	e1a00000 	nop			; (mov r0, r0)
3001bd20:	e59d3004 	ldr	r3, [sp, #4]
3001bd24:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001bd28:	e3530000 	cmp	r3, #0
3001bd2c:	0a00003c 	beq	3001be24 <tcp_receive+0x6b8>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
3001bd30:	e59d3004 	ldr	r3, [sp, #4]
3001bd34:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001bd38:	e5933010 	ldr	r3, [r3, #16]
3001bd3c:	e5d32004 	ldrb	r2, [r3, #4]
3001bd40:	e5d31005 	ldrb	r1, [r3, #5]
3001bd44:	e1a01401 	lsl	r1, r1, #8
3001bd48:	e1812002 	orr	r2, r1, r2
3001bd4c:	e5d31006 	ldrb	r1, [r3, #6]
3001bd50:	e1a01801 	lsl	r1, r1, #16
3001bd54:	e1812002 	orr	r2, r1, r2
3001bd58:	e5d33007 	ldrb	r3, [r3, #7]
3001bd5c:	e1a03c03 	lsl	r3, r3, #24
3001bd60:	e1833002 	orr	r3, r3, r2
3001bd64:	e1a00003 	mov	r0, r3
3001bd68:	ebffdf04 	bl	30013980 <ntohl>
3001bd6c:	e1a04000 	mov	r4, r0
3001bd70:	e59d3004 	ldr	r3, [sp, #4]
3001bd74:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001bd78:	e1d330bc 	ldrh	r3, [r3, #12]
3001bd7c:	e1a05003 	mov	r5, r3
3001bd80:	e59d3004 	ldr	r3, [sp, #4]
3001bd84:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001bd88:	e5933010 	ldr	r3, [r3, #16]
3001bd8c:	e5d3200c 	ldrb	r2, [r3, #12]
3001bd90:	e5d3300d 	ldrb	r3, [r3, #13]
3001bd94:	e1a03403 	lsl	r3, r3, #8
3001bd98:	e1833002 	orr	r3, r3, r2
3001bd9c:	e1a03803 	lsl	r3, r3, #16
3001bda0:	e1a03823 	lsr	r3, r3, #16
3001bda4:	e1a00003 	mov	r0, r3
3001bda8:	ebffded6 	bl	30013908 <ntohs>
3001bdac:	e1a03000 	mov	r3, r0
3001bdb0:	e2033001 	and	r3, r3, #1
3001bdb4:	e20330ff 	and	r3, r3, #255	; 0xff
3001bdb8:	e3530000 	cmp	r3, #0
3001bdbc:	1a00000e 	bne	3001bdfc <tcp_receive+0x690>
3001bdc0:	e59d3004 	ldr	r3, [sp, #4]
3001bdc4:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001bdc8:	e5933010 	ldr	r3, [r3, #16]
3001bdcc:	e5d3200c 	ldrb	r2, [r3, #12]
3001bdd0:	e5d3300d 	ldrb	r3, [r3, #13]
3001bdd4:	e1a03403 	lsl	r3, r3, #8
3001bdd8:	e1833002 	orr	r3, r3, r2
3001bddc:	e1a03803 	lsl	r3, r3, #16
3001bde0:	e1a03823 	lsr	r3, r3, #16
3001bde4:	e1a00003 	mov	r0, r3
3001bde8:	ebffdec6 	bl	30013908 <ntohs>
3001bdec:	e1a03000 	mov	r3, r0
3001bdf0:	e2033002 	and	r3, r3, #2
3001bdf4:	e3530000 	cmp	r3, #0
3001bdf8:	0a000001 	beq	3001be04 <tcp_receive+0x698>
3001bdfc:	e3a03001 	mov	r3, #1
3001be00:	ea000000 	b	3001be08 <tcp_receive+0x69c>
3001be04:	e3a03000 	mov	r3, #0
3001be08:	e0853003 	add	r3, r5, r3
3001be0c:	e0842003 	add	r2, r4, r3
3001be10:	e59f37c4 	ldr	r3, [pc, #1988]	; 3001c5dc <tcp_receive+0xe70>
3001be14:	e5933000 	ldr	r3, [r3]
3001be18:	e0633002 	rsb	r3, r3, r2
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
3001be1c:	e3530000 	cmp	r3, #0
3001be20:	daffffa2 	ble	3001bcb0 <tcp_receive+0x544>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
3001be24:	e59d3004 	ldr	r3, [sp, #4]
3001be28:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001be2c:	e3530000 	cmp	r3, #0
3001be30:	1a000003 	bne	3001be44 <tcp_receive+0x6d8>
        pcb->rtime = -1;
3001be34:	e59d3004 	ldr	r3, [sp, #4]
3001be38:	e3e02000 	mvn	r2, #0
3001be3c:	e1c322be 	strh	r2, [r3, #46]	; 0x2e
3001be40:	ea000002 	b	3001be50 <tcp_receive+0x6e4>
      else
        pcb->rtime = 0;
3001be44:	e59d3004 	ldr	r3, [sp, #4]
3001be48:	e3a02000 	mov	r2, #0
3001be4c:	e1c322be 	strh	r2, [r3, #46]	; 0x2e

      pcb->polltmr = 0;
3001be50:	e59d3004 	ldr	r3, [sp, #4]
3001be54:	e3a02000 	mov	r2, #0
3001be58:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
3001be5c:	e1a00000 	nop			; (mov r0, r0)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
3001be60:	ea000037 	b	3001bf44 <tcp_receive+0x7d8>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
3001be64:	e59d3004 	ldr	r3, [sp, #4]
3001be68:	e3a02000 	mov	r2, #0
3001be6c:	e1c326b8 	strh	r2, [r3, #104]	; 0x68
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
3001be70:	ea000033 	b	3001bf44 <tcp_receive+0x7d8>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
3001be74:	e59d3004 	ldr	r3, [sp, #4]
3001be78:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001be7c:	e58d3008 	str	r3, [sp, #8]
      pcb->unsent = pcb->unsent->next;
3001be80:	e59d3004 	ldr	r3, [sp, #4]
3001be84:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001be88:	e5932000 	ldr	r2, [r3]
3001be8c:	e59d3004 	ldr	r3, [sp, #4]
3001be90:	e5832070 	str	r2, [r3, #112]	; 0x70
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
      pcb->snd_queuelen -= pbuf_clen(next->p);
3001be94:	e59d3004 	ldr	r3, [sp, #4]
3001be98:	e1d346bc 	ldrh	r4, [r3, #108]	; 0x6c
3001be9c:	e59d3008 	ldr	r3, [sp, #8]
3001bea0:	e5933004 	ldr	r3, [r3, #4]
3001bea4:	e1a00003 	mov	r0, r3
3001bea8:	ebffe9e6 	bl	30016648 <pbuf_clen>
3001beac:	e1a03000 	mov	r3, r0
3001beb0:	e0633004 	rsb	r3, r3, r4
3001beb4:	e1a03803 	lsl	r3, r3, #16
3001beb8:	e1a02823 	lsr	r2, r3, #16
3001bebc:	e59d3004 	ldr	r3, [sp, #4]
3001bec0:	e1c326bc 	strh	r2, [r3, #108]	; 0x6c
      tcp_seg_free(next);
3001bec4:	e59d0008 	ldr	r0, [sp, #8]
3001bec8:	ebfff433 	bl	30018f9c <tcp_seg_free>
      if (pcb->snd_queuelen != 0) {
        LWIP_ASSERT("tcp_receive: valid queue length",
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
3001becc:	e59d3004 	ldr	r3, [sp, #4]
3001bed0:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001bed4:	e3530000 	cmp	r3, #0
3001bed8:	0a000019 	beq	3001bf44 <tcp_receive+0x7d8>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
3001bedc:	e59d3004 	ldr	r3, [sp, #4]
3001bee0:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001bee4:	e5933010 	ldr	r3, [r3, #16]
3001bee8:	e5d32004 	ldrb	r2, [r3, #4]
3001beec:	e5d31005 	ldrb	r1, [r3, #5]
3001bef0:	e1a01401 	lsl	r1, r1, #8
3001bef4:	e1812002 	orr	r2, r1, r2
3001bef8:	e5d31006 	ldrb	r1, [r3, #6]
3001befc:	e1a01801 	lsl	r1, r1, #16
3001bf00:	e1812002 	orr	r2, r1, r2
3001bf04:	e5d33007 	ldrb	r3, [r3, #7]
3001bf08:	e1a03c03 	lsl	r3, r3, #24
3001bf0c:	e1833002 	orr	r3, r3, r2
3001bf10:	e1a00003 	mov	r0, r3
3001bf14:	ebffde87 	bl	30013938 <htonl>
3001bf18:	e1a02000 	mov	r2, r0
3001bf1c:	e59d3004 	ldr	r3, [sp, #4]
3001bf20:	e5832050 	str	r2, [r3, #80]	; 0x50
3001bf24:	ea000006 	b	3001bf44 <tcp_receive+0x7d8>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
3001bf28:	e1a00000 	nop			; (mov r0, r0)
3001bf2c:	ea000004 	b	3001bf44 <tcp_receive+0x7d8>
3001bf30:	e1a00000 	nop			; (mov r0, r0)
3001bf34:	ea000002 	b	3001bf44 <tcp_receive+0x7d8>
3001bf38:	e1a00000 	nop			; (mov r0, r0)
3001bf3c:	ea000000 	b	3001bf44 <tcp_receive+0x7d8>
3001bf40:	e1a00000 	nop			; (mov r0, r0)
3001bf44:	e59d3004 	ldr	r3, [sp, #4]
3001bf48:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001bf4c:	e3530000 	cmp	r3, #0
3001bf50:	0a000043 	beq	3001c064 <tcp_receive+0x8f8>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
3001bf54:	e59f3680 	ldr	r3, [pc, #1664]	; 3001c5dc <tcp_receive+0xe70>
3001bf58:	e5934000 	ldr	r4, [r3]
3001bf5c:	e59d3004 	ldr	r3, [sp, #4]
3001bf60:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001bf64:	e5933010 	ldr	r3, [r3, #16]
3001bf68:	e5d32004 	ldrb	r2, [r3, #4]
3001bf6c:	e5d31005 	ldrb	r1, [r3, #5]
3001bf70:	e1a01401 	lsl	r1, r1, #8
3001bf74:	e1812002 	orr	r2, r1, r2
3001bf78:	e5d31006 	ldrb	r1, [r3, #6]
3001bf7c:	e1a01801 	lsl	r1, r1, #16
3001bf80:	e1812002 	orr	r2, r1, r2
3001bf84:	e5d33007 	ldrb	r3, [r3, #7]
3001bf88:	e1a03c03 	lsl	r3, r3, #24
3001bf8c:	e1833002 	orr	r3, r3, r2
3001bf90:	e1a00003 	mov	r0, r3
3001bf94:	ebffde79 	bl	30013980 <ntohl>
3001bf98:	e1a05000 	mov	r5, r0
3001bf9c:	e59d3004 	ldr	r3, [sp, #4]
3001bfa0:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001bfa4:	e1d330bc 	ldrh	r3, [r3, #12]
3001bfa8:	e1a06003 	mov	r6, r3
3001bfac:	e59d3004 	ldr	r3, [sp, #4]
3001bfb0:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001bfb4:	e5933010 	ldr	r3, [r3, #16]
3001bfb8:	e5d3200c 	ldrb	r2, [r3, #12]
3001bfbc:	e5d3300d 	ldrb	r3, [r3, #13]
3001bfc0:	e1a03403 	lsl	r3, r3, #8
3001bfc4:	e1833002 	orr	r3, r3, r2
3001bfc8:	e1a03803 	lsl	r3, r3, #16
3001bfcc:	e1a03823 	lsr	r3, r3, #16
3001bfd0:	e1a00003 	mov	r0, r3
3001bfd4:	ebffde4b 	bl	30013908 <ntohs>
3001bfd8:	e1a03000 	mov	r3, r0
3001bfdc:	e2033001 	and	r3, r3, #1
3001bfe0:	e20330ff 	and	r3, r3, #255	; 0xff
3001bfe4:	e3530000 	cmp	r3, #0
3001bfe8:	1a00000e 	bne	3001c028 <tcp_receive+0x8bc>
3001bfec:	e59d3004 	ldr	r3, [sp, #4]
3001bff0:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001bff4:	e5933010 	ldr	r3, [r3, #16]
3001bff8:	e5d3200c 	ldrb	r2, [r3, #12]
3001bffc:	e5d3300d 	ldrb	r3, [r3, #13]
3001c000:	e1a03403 	lsl	r3, r3, #8
3001c004:	e1833002 	orr	r3, r3, r2
3001c008:	e1a03803 	lsl	r3, r3, #16
3001c00c:	e1a03823 	lsr	r3, r3, #16
3001c010:	e1a00003 	mov	r0, r3
3001c014:	ebffde3b 	bl	30013908 <ntohs>
3001c018:	e1a03000 	mov	r3, r0
3001c01c:	e2033002 	and	r3, r3, #2
3001c020:	e3530000 	cmp	r3, #0
3001c024:	0a000001 	beq	3001c030 <tcp_receive+0x8c4>
3001c028:	e3a03001 	mov	r3, #1
3001c02c:	ea000000 	b	3001c034 <tcp_receive+0x8c8>
3001c030:	e3a03000 	mov	r3, #0
3001c034:	e0863003 	add	r3, r6, r3
3001c038:	e0853003 	add	r3, r5, r3
3001c03c:	e0633004 	rsb	r3, r3, r4
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
3001c040:	e3530000 	cmp	r3, #0
3001c044:	ba000006 	blt	3001c064 <tcp_receive+0x8f8>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
3001c048:	e59f358c 	ldr	r3, [pc, #1420]	; 3001c5dc <tcp_receive+0xe70>
3001c04c:	e5932000 	ldr	r2, [r3]
3001c050:	e59d3004 	ldr	r3, [sp, #4]
3001c054:	e5933054 	ldr	r3, [r3, #84]	; 0x54
3001c058:	e0633002 	rsb	r3, r3, r2
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
3001c05c:	e3530000 	cmp	r3, #0
3001c060:	daffff83 	ble	3001be74 <tcp_receive+0x708>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
3001c064:	e59d3004 	ldr	r3, [sp, #4]
3001c068:	e5933034 	ldr	r3, [r3, #52]	; 0x34
3001c06c:	e3530000 	cmp	r3, #0
3001c070:	0a000060 	beq	3001c1f8 <tcp_receive+0xa8c>
3001c074:	e59d3004 	ldr	r3, [sp, #4]
3001c078:	e5932038 	ldr	r2, [r3, #56]	; 0x38
3001c07c:	e59f3558 	ldr	r3, [pc, #1368]	; 3001c5dc <tcp_receive+0xe70>
3001c080:	e5933000 	ldr	r3, [r3]
3001c084:	e0633002 	rsb	r3, r3, r2
3001c088:	e3530000 	cmp	r3, #0
3001c08c:	aa000059 	bge	3001c1f8 <tcp_receive+0xa8c>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
3001c090:	e59f354c 	ldr	r3, [pc, #1356]	; 3001c5e4 <tcp_receive+0xe78>
3001c094:	e5933000 	ldr	r3, [r3]
3001c098:	e1a03803 	lsl	r3, r3, #16
3001c09c:	e1a02823 	lsr	r2, r3, #16
3001c0a0:	e59d3004 	ldr	r3, [sp, #4]
3001c0a4:	e5933034 	ldr	r3, [r3, #52]	; 0x34
3001c0a8:	e1a03803 	lsl	r3, r3, #16
3001c0ac:	e1a03823 	lsr	r3, r3, #16
3001c0b0:	e0633002 	rsb	r3, r3, r2
3001c0b4:	e1a03803 	lsl	r3, r3, #16
3001c0b8:	e1a03823 	lsr	r3, r3, #16
3001c0bc:	e1cd31be 	strh	r3, [sp, #30]

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
3001c0c0:	e1dd21be 	ldrh	r2, [sp, #30]
3001c0c4:	e59d3004 	ldr	r3, [sp, #4]
3001c0c8:	e1d333bc 	ldrh	r3, [r3, #60]	; 0x3c
3001c0cc:	e1a03803 	lsl	r3, r3, #16
3001c0d0:	e1a03843 	asr	r3, r3, #16
3001c0d4:	e1a031c3 	asr	r3, r3, #3
3001c0d8:	e1a03803 	lsl	r3, r3, #16
3001c0dc:	e1a03823 	lsr	r3, r3, #16
3001c0e0:	e1a03803 	lsl	r3, r3, #16
3001c0e4:	e1a03823 	lsr	r3, r3, #16
3001c0e8:	e0633002 	rsb	r3, r3, r2
3001c0ec:	e1a03803 	lsl	r3, r3, #16
3001c0f0:	e1a03823 	lsr	r3, r3, #16
3001c0f4:	e1cd31be 	strh	r3, [sp, #30]
      pcb->sa += m;
3001c0f8:	e59d3004 	ldr	r3, [sp, #4]
3001c0fc:	e1d333bc 	ldrh	r3, [r3, #60]	; 0x3c
3001c100:	e1a03803 	lsl	r3, r3, #16
3001c104:	e1a02823 	lsr	r2, r3, #16
3001c108:	e1dd31be 	ldrh	r3, [sp, #30]
3001c10c:	e0823003 	add	r3, r2, r3
3001c110:	e1a03803 	lsl	r3, r3, #16
3001c114:	e1a03823 	lsr	r3, r3, #16
3001c118:	e1a02003 	mov	r2, r3
3001c11c:	e59d3004 	ldr	r3, [sp, #4]
3001c120:	e1c323bc 	strh	r2, [r3, #60]	; 0x3c
      if (m < 0) {
3001c124:	e1dd31fe 	ldrsh	r3, [sp, #30]
3001c128:	e3530000 	cmp	r3, #0
3001c12c:	aa000002 	bge	3001c13c <tcp_receive+0x9d0>
        m = -m;
3001c130:	e1dd31be 	ldrh	r3, [sp, #30]
3001c134:	e2633000 	rsb	r3, r3, #0
3001c138:	e1cd31be 	strh	r3, [sp, #30]
      }
      m = m - (pcb->sv >> 2);
3001c13c:	e1dd21be 	ldrh	r2, [sp, #30]
3001c140:	e59d3004 	ldr	r3, [sp, #4]
3001c144:	e1d333be 	ldrh	r3, [r3, #62]	; 0x3e
3001c148:	e1a03803 	lsl	r3, r3, #16
3001c14c:	e1a03843 	asr	r3, r3, #16
3001c150:	e1a03143 	asr	r3, r3, #2
3001c154:	e1a03803 	lsl	r3, r3, #16
3001c158:	e1a03823 	lsr	r3, r3, #16
3001c15c:	e1a03803 	lsl	r3, r3, #16
3001c160:	e1a03823 	lsr	r3, r3, #16
3001c164:	e0633002 	rsb	r3, r3, r2
3001c168:	e1a03803 	lsl	r3, r3, #16
3001c16c:	e1a03823 	lsr	r3, r3, #16
3001c170:	e1cd31be 	strh	r3, [sp, #30]
      pcb->sv += m;
3001c174:	e59d3004 	ldr	r3, [sp, #4]
3001c178:	e1d333be 	ldrh	r3, [r3, #62]	; 0x3e
3001c17c:	e1a03803 	lsl	r3, r3, #16
3001c180:	e1a02823 	lsr	r2, r3, #16
3001c184:	e1dd31be 	ldrh	r3, [sp, #30]
3001c188:	e0823003 	add	r3, r2, r3
3001c18c:	e1a03803 	lsl	r3, r3, #16
3001c190:	e1a03823 	lsr	r3, r3, #16
3001c194:	e1a02003 	mov	r2, r3
3001c198:	e59d3004 	ldr	r3, [sp, #4]
3001c19c:	e1c323be 	strh	r2, [r3, #62]	; 0x3e
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
3001c1a0:	e59d3004 	ldr	r3, [sp, #4]
3001c1a4:	e1d333bc 	ldrh	r3, [r3, #60]	; 0x3c
3001c1a8:	e1a03803 	lsl	r3, r3, #16
3001c1ac:	e1a03843 	asr	r3, r3, #16
3001c1b0:	e1a031c3 	asr	r3, r3, #3
3001c1b4:	e1a03803 	lsl	r3, r3, #16
3001c1b8:	e1a03823 	lsr	r3, r3, #16
3001c1bc:	e1a03803 	lsl	r3, r3, #16
3001c1c0:	e1a02823 	lsr	r2, r3, #16
3001c1c4:	e59d3004 	ldr	r3, [sp, #4]
3001c1c8:	e1d333be 	ldrh	r3, [r3, #62]	; 0x3e
3001c1cc:	e1a03803 	lsl	r3, r3, #16
3001c1d0:	e1a03823 	lsr	r3, r3, #16
3001c1d4:	e0823003 	add	r3, r2, r3
3001c1d8:	e1a03803 	lsl	r3, r3, #16
3001c1dc:	e1a03823 	lsr	r3, r3, #16
3001c1e0:	e1a02003 	mov	r2, r3
3001c1e4:	e59d3004 	ldr	r3, [sp, #4]
3001c1e8:	e1c324b0 	strh	r2, [r3, #64]	; 0x40

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
3001c1ec:	e59d3004 	ldr	r3, [sp, #4]
3001c1f0:	e3a02000 	mov	r2, #0
3001c1f4:	e5832034 	str	r2, [r3, #52]	; 0x34
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
3001c1f8:	e59f33e8 	ldr	r3, [pc, #1000]	; 3001c5e8 <tcp_receive+0xe7c>
3001c1fc:	e1d330b0 	ldrh	r3, [r3]
3001c200:	e3530000 	cmp	r3, #0
3001c204:	0a0004ee 	beq	3001d5c4 <tcp_receive+0x1e58>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
3001c208:	e59d3004 	ldr	r3, [sp, #4]
3001c20c:	e5932020 	ldr	r2, [r3, #32]
3001c210:	e59f33e0 	ldr	r3, [pc, #992]	; 3001c5f8 <tcp_receive+0xe8c>
3001c214:	e5933000 	ldr	r3, [r3]
3001c218:	e1e03003 	mvn	r3, r3
3001c21c:	e0823003 	add	r3, r2, r3
3001c220:	e3530000 	cmp	r3, #0
3001c224:	ba000082 	blt	3001c434 <tcp_receive+0xcc8>
3001c228:	e59d3004 	ldr	r3, [sp, #4]
3001c22c:	e5932020 	ldr	r2, [r3, #32]
3001c230:	e59f33b0 	ldr	r3, [pc, #944]	; 3001c5e8 <tcp_receive+0xe7c>
3001c234:	e1d330b0 	ldrh	r3, [r3]
3001c238:	e1a01003 	mov	r1, r3
3001c23c:	e59f33b4 	ldr	r3, [pc, #948]	; 3001c5f8 <tcp_receive+0xe8c>
3001c240:	e5933000 	ldr	r3, [r3]
3001c244:	e0813003 	add	r3, r1, r3
3001c248:	e0633002 	rsb	r3, r3, r2
3001c24c:	e2833001 	add	r3, r3, #1
3001c250:	e3530000 	cmp	r3, #0
3001c254:	ca000076 	bgt	3001c434 <tcp_receive+0xcc8>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
3001c258:	e59d3004 	ldr	r3, [sp, #4]
3001c25c:	e5932020 	ldr	r2, [r3, #32]
3001c260:	e59f3390 	ldr	r3, [pc, #912]	; 3001c5f8 <tcp_receive+0xe8c>
3001c264:	e5933000 	ldr	r3, [r3]
3001c268:	e0633002 	rsb	r3, r3, r2
3001c26c:	e58d3018 	str	r3, [sp, #24]
      p = inseg.p;
3001c270:	e59f337c 	ldr	r3, [pc, #892]	; 3001c5f4 <tcp_receive+0xe88>
3001c274:	e5933004 	ldr	r3, [r3, #4]
3001c278:	e58d3014 	str	r3, [sp, #20]
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
3001c27c:	e59f3370 	ldr	r3, [pc, #880]	; 3001c5f4 <tcp_receive+0xe88>
3001c280:	e5933004 	ldr	r3, [r3, #4]
3001c284:	e1d330ba 	ldrh	r3, [r3, #10]
3001c288:	e1a02003 	mov	r2, r3
3001c28c:	e59d3018 	ldr	r3, [sp, #24]
3001c290:	e1520003 	cmp	r2, r3
3001c294:	aa000028 	bge	3001c33c <tcp_receive+0xbd0>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
3001c298:	e59f3354 	ldr	r3, [pc, #852]	; 3001c5f4 <tcp_receive+0xe88>
3001c29c:	e5933004 	ldr	r3, [r3, #4]
3001c2a0:	e1d320b8 	ldrh	r2, [r3, #8]
3001c2a4:	e59d3018 	ldr	r3, [sp, #24]
3001c2a8:	e1a03803 	lsl	r3, r3, #16
3001c2ac:	e1a03823 	lsr	r3, r3, #16
3001c2b0:	e0633002 	rsb	r3, r3, r2
3001c2b4:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
        while (p->len < off) {
3001c2b8:	ea00000d 	b	3001c2f4 <tcp_receive+0xb88>
          off -= p->len;
3001c2bc:	e59d3014 	ldr	r3, [sp, #20]
3001c2c0:	e1d330ba 	ldrh	r3, [r3, #10]
3001c2c4:	e59d2018 	ldr	r2, [sp, #24]
3001c2c8:	e0633002 	rsb	r3, r3, r2
3001c2cc:	e58d3018 	str	r3, [sp, #24]
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
3001c2d0:	e59d3014 	ldr	r3, [sp, #20]
3001c2d4:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
3001c2d8:	e1c320b8 	strh	r2, [r3, #8]
          p->len = 0;
3001c2dc:	e59d3014 	ldr	r3, [sp, #20]
3001c2e0:	e3a02000 	mov	r2, #0
3001c2e4:	e1c320ba 	strh	r2, [r3, #10]
          p = p->next;
3001c2e8:	e59d3014 	ldr	r3, [sp, #20]
3001c2ec:	e5933000 	ldr	r3, [r3]
3001c2f0:	e58d3014 	str	r3, [sp, #20]
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
3001c2f4:	e59d3014 	ldr	r3, [sp, #20]
3001c2f8:	e1d330ba 	ldrh	r3, [r3, #10]
3001c2fc:	e1a02003 	mov	r2, r3
3001c300:	e59d3018 	ldr	r3, [sp, #24]
3001c304:	e1520003 	cmp	r2, r3
3001c308:	baffffeb 	blt	3001c2bc <tcp_receive+0xb50>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
3001c30c:	e59d3018 	ldr	r3, [sp, #24]
3001c310:	e1a03803 	lsl	r3, r3, #16
3001c314:	e1a03823 	lsr	r3, r3, #16
3001c318:	e2633000 	rsb	r3, r3, #0
3001c31c:	e1a03803 	lsl	r3, r3, #16
3001c320:	e1a03823 	lsr	r3, r3, #16
3001c324:	e1a03803 	lsl	r3, r3, #16
3001c328:	e1a03843 	asr	r3, r3, #16
3001c32c:	e59d0014 	ldr	r0, [sp, #20]
3001c330:	e1a01003 	mov	r1, r3
3001c334:	ebffe818 	bl	3001639c <pbuf_header>
3001c338:	ea00000c 	b	3001c370 <tcp_receive+0xc04>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
3001c33c:	e59f32b0 	ldr	r3, [pc, #688]	; 3001c5f4 <tcp_receive+0xe88>
3001c340:	e5932004 	ldr	r2, [r3, #4]
3001c344:	e59d3018 	ldr	r3, [sp, #24]
3001c348:	e1a03803 	lsl	r3, r3, #16
3001c34c:	e1a03823 	lsr	r3, r3, #16
3001c350:	e2633000 	rsb	r3, r3, #0
3001c354:	e1a03803 	lsl	r3, r3, #16
3001c358:	e1a03823 	lsr	r3, r3, #16
3001c35c:	e1a03803 	lsl	r3, r3, #16
3001c360:	e1a03843 	asr	r3, r3, #16
3001c364:	e1a00002 	mov	r0, r2
3001c368:	e1a01003 	mov	r1, r3
3001c36c:	ebffe80a 	bl	3001639c <pbuf_header>
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
3001c370:	e59d3014 	ldr	r3, [sp, #20]
3001c374:	e5932004 	ldr	r2, [r3, #4]
3001c378:	e59f3274 	ldr	r3, [pc, #628]	; 3001c5f4 <tcp_receive+0xe88>
3001c37c:	e5832008 	str	r2, [r3, #8]
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
3001c380:	e59f326c 	ldr	r3, [pc, #620]	; 3001c5f4 <tcp_receive+0xe88>
3001c384:	e1d320bc 	ldrh	r2, [r3, #12]
3001c388:	e59f3268 	ldr	r3, [pc, #616]	; 3001c5f8 <tcp_receive+0xe8c>
3001c38c:	e5933000 	ldr	r3, [r3]
3001c390:	e1a03803 	lsl	r3, r3, #16
3001c394:	e1a01823 	lsr	r1, r3, #16
3001c398:	e59d3004 	ldr	r3, [sp, #4]
3001c39c:	e5933020 	ldr	r3, [r3, #32]
3001c3a0:	e1a03803 	lsl	r3, r3, #16
3001c3a4:	e1a03823 	lsr	r3, r3, #16
3001c3a8:	e0633001 	rsb	r3, r3, r1
3001c3ac:	e1a03803 	lsl	r3, r3, #16
3001c3b0:	e1a03823 	lsr	r3, r3, #16
3001c3b4:	e0823003 	add	r3, r2, r3
3001c3b8:	e1a03803 	lsl	r3, r3, #16
3001c3bc:	e1a02823 	lsr	r2, r3, #16
3001c3c0:	e59f322c 	ldr	r3, [pc, #556]	; 3001c5f4 <tcp_receive+0xe88>
3001c3c4:	e1c320bc 	strh	r2, [r3, #12]
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
3001c3c8:	e59f3224 	ldr	r3, [pc, #548]	; 3001c5f4 <tcp_receive+0xe88>
3001c3cc:	e5933010 	ldr	r3, [r3, #16]
3001c3d0:	e59d2004 	ldr	r2, [sp, #4]
3001c3d4:	e5921020 	ldr	r1, [r2, #32]
3001c3d8:	e59f2218 	ldr	r2, [pc, #536]	; 3001c5f8 <tcp_receive+0xe8c>
3001c3dc:	e5821000 	str	r1, [r2]
3001c3e0:	e59f2210 	ldr	r2, [pc, #528]	; 3001c5f8 <tcp_receive+0xe8c>
3001c3e4:	e5922000 	ldr	r2, [r2]
3001c3e8:	e20210ff 	and	r1, r2, #255	; 0xff
3001c3ec:	e3a00000 	mov	r0, #0
3001c3f0:	e1801001 	orr	r1, r0, r1
3001c3f4:	e5c31004 	strb	r1, [r3, #4]
3001c3f8:	e1a01422 	lsr	r1, r2, #8
3001c3fc:	e20110ff 	and	r1, r1, #255	; 0xff
3001c400:	e3a00000 	mov	r0, #0
3001c404:	e1801001 	orr	r1, r0, r1
3001c408:	e5c31005 	strb	r1, [r3, #5]
3001c40c:	e1a01822 	lsr	r1, r2, #16
3001c410:	e20110ff 	and	r1, r1, #255	; 0xff
3001c414:	e3a00000 	mov	r0, #0
3001c418:	e1801001 	orr	r1, r0, r1
3001c41c:	e5c31006 	strb	r1, [r3, #6]
3001c420:	e1a02c22 	lsr	r2, r2, #24
3001c424:	e3a01000 	mov	r1, #0
3001c428:	e1812002 	orr	r2, r1, r2
3001c42c:	e5c32007 	strb	r2, [r3, #7]
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
3001c430:	ea00000e 	b	3001c470 <tcp_receive+0xd04>
      inseg.dataptr = p->payload;
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
3001c434:	e59f31bc 	ldr	r3, [pc, #444]	; 3001c5f8 <tcp_receive+0xe8c>
3001c438:	e5932000 	ldr	r2, [r3]
3001c43c:	e59d3004 	ldr	r3, [sp, #4]
3001c440:	e5933020 	ldr	r3, [r3, #32]
3001c444:	e0633002 	rsb	r3, r3, r2
3001c448:	e3530000 	cmp	r3, #0
3001c44c:	aa000007 	bge	3001c470 <tcp_receive+0xd04>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
3001c450:	e59d3004 	ldr	r3, [sp, #4]
3001c454:	e5d3301c 	ldrb	r3, [r3, #28]
3001c458:	e3833002 	orr	r3, r3, #2
3001c45c:	e20320ff 	and	r2, r3, #255	; 0xff
3001c460:	e59d3004 	ldr	r3, [sp, #4]
3001c464:	e5c3201c 	strb	r2, [r3, #28]
3001c468:	e59d0004 	ldr	r0, [sp, #4]
3001c46c:	eb000784 	bl	3001e284 <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
3001c470:	e59f3180 	ldr	r3, [pc, #384]	; 3001c5f8 <tcp_receive+0xe8c>
3001c474:	e5932000 	ldr	r2, [r3]
3001c478:	e59d3004 	ldr	r3, [sp, #4]
3001c47c:	e5933020 	ldr	r3, [r3, #32]
3001c480:	e0633002 	rsb	r3, r3, r2
3001c484:	e3530000 	cmp	r3, #0
3001c488:	ba000432 	blt	3001d558 <tcp_receive+0x1dec>
3001c48c:	e59f3164 	ldr	r3, [pc, #356]	; 3001c5f8 <tcp_receive+0xe8c>
3001c490:	e5932000 	ldr	r2, [r3]
3001c494:	e59d3004 	ldr	r3, [sp, #4]
3001c498:	e5931020 	ldr	r1, [r3, #32]
3001c49c:	e59d3004 	ldr	r3, [sp, #4]
3001c4a0:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
3001c4a4:	e0813003 	add	r3, r1, r3
3001c4a8:	e0633002 	rsb	r3, r3, r2
3001c4ac:	e2833001 	add	r3, r3, #1
3001c4b0:	e3530000 	cmp	r3, #0
3001c4b4:	ca000427 	bgt	3001d558 <tcp_receive+0x1dec>
                        pcb->rcv_nxt + pcb->rcv_ann_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
3001c4b8:	e59d3004 	ldr	r3, [sp, #4]
3001c4bc:	e5932020 	ldr	r2, [r3, #32]
3001c4c0:	e59f3130 	ldr	r3, [pc, #304]	; 3001c5f8 <tcp_receive+0xe8c>
3001c4c4:	e5933000 	ldr	r3, [r3]
3001c4c8:	e1520003 	cmp	r2, r3
3001c4cc:	1a000246 	bne	3001cdec <tcp_receive+0x1680>
        accepted_inseq = 1; 
3001c4d0:	e3a03001 	mov	r3, #1
3001c4d4:	e5cd3029 	strb	r3, [sp, #41]	; 0x29
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
3001c4d8:	e59d3004 	ldr	r3, [sp, #4]
3001c4dc:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c4e0:	e3530000 	cmp	r3, #0
3001c4e4:	0a00006b 	beq	3001c698 <tcp_receive+0xf2c>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
3001c4e8:	e59d3004 	ldr	r3, [sp, #4]
3001c4ec:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c4f0:	e5933010 	ldr	r3, [r3, #16]
3001c4f4:	e5d32004 	ldrb	r2, [r3, #4]
3001c4f8:	e5d31005 	ldrb	r1, [r3, #5]
3001c4fc:	e1a01401 	lsl	r1, r1, #8
3001c500:	e1812002 	orr	r2, r1, r2
3001c504:	e5d31006 	ldrb	r1, [r3, #6]
3001c508:	e1a01801 	lsl	r1, r1, #16
3001c50c:	e1812002 	orr	r2, r1, r2
3001c510:	e5d33007 	ldrb	r3, [r3, #7]
3001c514:	e1a03c03 	lsl	r3, r3, #24
3001c518:	e1833002 	orr	r3, r3, r2
3001c51c:	e1a02003 	mov	r2, r3
3001c520:	e59f30cc 	ldr	r3, [pc, #204]	; 3001c5f4 <tcp_receive+0xe88>
3001c524:	e1d330bc 	ldrh	r3, [r3, #12]
3001c528:	e1a01003 	mov	r1, r3
3001c52c:	e59f30c4 	ldr	r3, [pc, #196]	; 3001c5f8 <tcp_receive+0xe8c>
3001c530:	e5933000 	ldr	r3, [r3]
3001c534:	e0813003 	add	r3, r1, r3
3001c538:	e0633002 	rsb	r3, r3, r2
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
3001c53c:	e3530000 	cmp	r3, #0
3001c540:	ca000054 	bgt	3001c698 <tcp_receive+0xf2c>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
3001c544:	e59d3004 	ldr	r3, [sp, #4]
3001c548:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c54c:	e1d330bc 	ldrh	r3, [r3, #12]
3001c550:	e3530000 	cmp	r3, #0
3001c554:	0a000028 	beq	3001c5fc <tcp_receive+0xe90>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
3001c558:	e59d3004 	ldr	r3, [sp, #4]
3001c55c:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c560:	e5933010 	ldr	r3, [r3, #16]
3001c564:	e5d32004 	ldrb	r2, [r3, #4]
3001c568:	e5d31005 	ldrb	r1, [r3, #5]
3001c56c:	e1a01401 	lsl	r1, r1, #8
3001c570:	e1812002 	orr	r2, r1, r2
3001c574:	e5d31006 	ldrb	r1, [r3, #6]
3001c578:	e1a01801 	lsl	r1, r1, #16
3001c57c:	e1812002 	orr	r2, r1, r2
3001c580:	e5d33007 	ldrb	r3, [r3, #7]
3001c584:	e1a03c03 	lsl	r3, r3, #24
3001c588:	e1833002 	orr	r3, r3, r2
3001c58c:	e1a03803 	lsl	r3, r3, #16
3001c590:	e1a02823 	lsr	r2, r3, #16
3001c594:	e59f305c 	ldr	r3, [pc, #92]	; 3001c5f8 <tcp_receive+0xe8c>
3001c598:	e5933000 	ldr	r3, [r3]
3001c59c:	e1a03803 	lsl	r3, r3, #16
3001c5a0:	e1a03823 	lsr	r3, r3, #16
3001c5a4:	e0633002 	rsb	r3, r3, r2
3001c5a8:	e1a03803 	lsl	r3, r3, #16
3001c5ac:	e1a02823 	lsr	r2, r3, #16
3001c5b0:	e59f303c 	ldr	r3, [pc, #60]	; 3001c5f4 <tcp_receive+0xe88>
3001c5b4:	e1c320bc 	strh	r2, [r3, #12]
            pbuf_realloc(inseg.p, inseg.len);
3001c5b8:	e59f3034 	ldr	r3, [pc, #52]	; 3001c5f4 <tcp_receive+0xe88>
3001c5bc:	e5932004 	ldr	r2, [r3, #4]
3001c5c0:	e59f302c 	ldr	r3, [pc, #44]	; 3001c5f4 <tcp_receive+0xe88>
3001c5c4:	e1d330bc 	ldrh	r3, [r3, #12]
3001c5c8:	e1a00002 	mov	r0, r2
3001c5cc:	e1a01003 	mov	r1, r3
3001c5d0:	ebffe713 	bl	30016224 <pbuf_realloc>
3001c5d4:	ea00002f 	b	3001c698 <tcp_receive+0xf2c>
3001c5d8:	30028f80 	.word	0x30028f80
3001c5dc:	30028f7c 	.word	0x30028f7c
3001c5e0:	30028f70 	.word	0x30028f70
3001c5e4:	3002a724 	.word	0x3002a724
3001c5e8:	30028f82 	.word	0x30028f82
3001c5ec:	30028f88 	.word	0x30028f88
3001c5f0:	30028f84 	.word	0x30028f84
3001c5f4:	30028f5c 	.word	0x30028f5c
3001c5f8:	30028f78 	.word	0x30028f78
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
3001c5fc:	e51f3010 	ldr	r3, [pc, #-16]	; 3001c5f4 <tcp_receive+0xe88>
3001c600:	e5933010 	ldr	r3, [r3, #16]
3001c604:	e5d3200c 	ldrb	r2, [r3, #12]
3001c608:	e5d3300d 	ldrb	r3, [r3, #13]
3001c60c:	e1a03403 	lsl	r3, r3, #8
3001c610:	e1833002 	orr	r3, r3, r2
3001c614:	e1a03803 	lsl	r3, r3, #16
3001c618:	e1a03823 	lsr	r3, r3, #16
3001c61c:	e1a00003 	mov	r0, r3
3001c620:	ebffdcb8 	bl	30013908 <ntohs>
3001c624:	e1a03000 	mov	r3, r0
3001c628:	e1a04003 	mov	r4, r3
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
3001c62c:	e59d3004 	ldr	r3, [sp, #4]
3001c630:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c634:	e5933010 	ldr	r3, [r3, #16]
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
3001c638:	e5d3200c 	ldrb	r2, [r3, #12]
3001c63c:	e5d3300d 	ldrb	r3, [r3, #13]
3001c640:	e1a03403 	lsl	r3, r3, #8
3001c644:	e1833002 	orr	r3, r3, r2
3001c648:	e1a03803 	lsl	r3, r3, #16
3001c64c:	e1a03823 	lsr	r3, r3, #16
3001c650:	e1a00003 	mov	r0, r3
3001c654:	ebffdcab 	bl	30013908 <ntohs>
3001c658:	e1a03000 	mov	r3, r0
3001c65c:	e0243003 	eor	r3, r4, r3
3001c660:	e2033003 	and	r3, r3, #3
3001c664:	e3530000 	cmp	r3, #0
3001c668:	1a00000a 	bne	3001c698 <tcp_receive+0xf2c>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
3001c66c:	e59d3004 	ldr	r3, [sp, #4]
3001c670:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c674:	e58d302c 	str	r3, [sp, #44]	; 0x2c
              pcb->ooseq = pcb->ooseq->next;
3001c678:	e59d3004 	ldr	r3, [sp, #4]
3001c67c:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c680:	e5932000 	ldr	r2, [r3]
3001c684:	e59d3004 	ldr	r3, [sp, #4]
3001c688:	e5832078 	str	r2, [r3, #120]	; 0x78
              memp_free(MEMP_TCP_SEG, old_ooseq);
3001c68c:	e3a00004 	mov	r0, #4
3001c690:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
3001c694:	ebffe43a 	bl	30015784 <memp_free>
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
3001c698:	e51f30ac 	ldr	r3, [pc, #-172]	; 3001c5f4 <tcp_receive+0xe88>
3001c69c:	e1d340bc 	ldrh	r4, [r3, #12]
3001c6a0:	e51f30b4 	ldr	r3, [pc, #-180]	; 3001c5f4 <tcp_receive+0xe88>
3001c6a4:	e5933010 	ldr	r3, [r3, #16]
3001c6a8:	e5d3200c 	ldrb	r2, [r3, #12]
3001c6ac:	e5d3300d 	ldrb	r3, [r3, #13]
3001c6b0:	e1a03403 	lsl	r3, r3, #8
3001c6b4:	e1833002 	orr	r3, r3, r2
3001c6b8:	e1a03803 	lsl	r3, r3, #16
3001c6bc:	e1a03823 	lsr	r3, r3, #16
3001c6c0:	e1a00003 	mov	r0, r3
3001c6c4:	ebffdc8f 	bl	30013908 <ntohs>
3001c6c8:	e1a03000 	mov	r3, r0
3001c6cc:	e2033001 	and	r3, r3, #1
3001c6d0:	e20330ff 	and	r3, r3, #255	; 0xff
3001c6d4:	e3530000 	cmp	r3, #0
3001c6d8:	1a00000d 	bne	3001c714 <tcp_receive+0xfa8>
3001c6dc:	e51f30f0 	ldr	r3, [pc, #-240]	; 3001c5f4 <tcp_receive+0xe88>
3001c6e0:	e5933010 	ldr	r3, [r3, #16]
3001c6e4:	e5d3200c 	ldrb	r2, [r3, #12]
3001c6e8:	e5d3300d 	ldrb	r3, [r3, #13]
3001c6ec:	e1a03403 	lsl	r3, r3, #8
3001c6f0:	e1833002 	orr	r3, r3, r2
3001c6f4:	e1a03803 	lsl	r3, r3, #16
3001c6f8:	e1a03823 	lsr	r3, r3, #16
3001c6fc:	e1a00003 	mov	r0, r3
3001c700:	ebffdc80 	bl	30013908 <ntohs>
3001c704:	e1a03000 	mov	r3, r0
3001c708:	e2033002 	and	r3, r3, #2
3001c70c:	e3530000 	cmp	r3, #0
3001c710:	0a000001 	beq	3001c71c <tcp_receive+0xfb0>
3001c714:	e3a03001 	mov	r3, #1
3001c718:	ea000000 	b	3001c720 <tcp_receive+0xfb4>
3001c71c:	e3a03000 	mov	r3, #0
3001c720:	e1a03803 	lsl	r3, r3, #16
3001c724:	e1a03823 	lsr	r3, r3, #16
3001c728:	e0843003 	add	r3, r4, r3
3001c72c:	e1a03803 	lsl	r3, r3, #16
3001c730:	e1a02823 	lsr	r2, r3, #16
3001c734:	e51f3154 	ldr	r3, [pc, #-340]	; 3001c5e8 <tcp_receive+0xe7c>
3001c738:	e1c320b0 	strh	r2, [r3]

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
3001c73c:	e59d3004 	ldr	r3, [sp, #4]
3001c740:	e5d33010 	ldrb	r3, [r3, #16]
3001c744:	e3530007 	cmp	r3, #7
3001c748:	0a000006 	beq	3001c768 <tcp_receive+0xffc>
          pcb->rcv_nxt += tcplen;
3001c74c:	e59d3004 	ldr	r3, [sp, #4]
3001c750:	e5932020 	ldr	r2, [r3, #32]
3001c754:	e51f3174 	ldr	r3, [pc, #-372]	; 3001c5e8 <tcp_receive+0xe7c>
3001c758:	e1d330b0 	ldrh	r3, [r3]
3001c75c:	e0822003 	add	r2, r2, r3
3001c760:	e59d3004 	ldr	r3, [sp, #4]
3001c764:	e5832020 	str	r2, [r3, #32]
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
3001c768:	e59d3004 	ldr	r3, [sp, #4]
3001c76c:	e1d322b4 	ldrh	r2, [r3, #36]	; 0x24
3001c770:	e51f3190 	ldr	r3, [pc, #-400]	; 3001c5e8 <tcp_receive+0xe7c>
3001c774:	e1d330b0 	ldrh	r3, [r3]
3001c778:	e1520003 	cmp	r2, r3
3001c77c:	2a000003 	bcs	3001c790 <tcp_receive+0x1024>
          pcb->rcv_wnd = 0;
3001c780:	e59d3004 	ldr	r3, [sp, #4]
3001c784:	e3a02000 	mov	r2, #0
3001c788:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
3001c78c:	ea000008 	b	3001c7b4 <tcp_receive+0x1048>
        } else {
          pcb->rcv_wnd -= tcplen;
3001c790:	e59d3004 	ldr	r3, [sp, #4]
3001c794:	e1d322b4 	ldrh	r2, [r3, #36]	; 0x24
3001c798:	e51f31b8 	ldr	r3, [pc, #-440]	; 3001c5e8 <tcp_receive+0xe7c>
3001c79c:	e1d330b0 	ldrh	r3, [r3]
3001c7a0:	e0633002 	rsb	r3, r3, r2
3001c7a4:	e1a03803 	lsl	r3, r3, #16
3001c7a8:	e1a02823 	lsr	r2, r3, #16
3001c7ac:	e59d3004 	ldr	r3, [sp, #4]
3001c7b0:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
        }

        if (pcb->rcv_ann_wnd < tcplen) {
3001c7b4:	e59d3004 	ldr	r3, [sp, #4]
3001c7b8:	e1d322b6 	ldrh	r2, [r3, #38]	; 0x26
3001c7bc:	e51f31dc 	ldr	r3, [pc, #-476]	; 3001c5e8 <tcp_receive+0xe7c>
3001c7c0:	e1d330b0 	ldrh	r3, [r3]
3001c7c4:	e1520003 	cmp	r2, r3
3001c7c8:	2a000003 	bcs	3001c7dc <tcp_receive+0x1070>
          pcb->rcv_ann_wnd = 0;
3001c7cc:	e59d3004 	ldr	r3, [sp, #4]
3001c7d0:	e3a02000 	mov	r2, #0
3001c7d4:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
3001c7d8:	ea000008 	b	3001c800 <tcp_receive+0x1094>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
3001c7dc:	e59d3004 	ldr	r3, [sp, #4]
3001c7e0:	e1d322b6 	ldrh	r2, [r3, #38]	; 0x26
3001c7e4:	e51f3204 	ldr	r3, [pc, #-516]	; 3001c5e8 <tcp_receive+0xe7c>
3001c7e8:	e1d330b0 	ldrh	r3, [r3]
3001c7ec:	e0633002 	rsb	r3, r3, r2
3001c7f0:	e1a03803 	lsl	r3, r3, #16
3001c7f4:	e1a02823 	lsr	r2, r3, #16
3001c7f8:	e59d3004 	ldr	r3, [sp, #4]
3001c7fc:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
3001c800:	e51f3214 	ldr	r3, [pc, #-532]	; 3001c5f4 <tcp_receive+0xe88>
3001c804:	e5933004 	ldr	r3, [r3, #4]
3001c808:	e1d330b8 	ldrh	r3, [r3, #8]
3001c80c:	e3530000 	cmp	r3, #0
3001c810:	0a000006 	beq	3001c830 <tcp_receive+0x10c4>
          recv_data = inseg.p;
3001c814:	e51f3228 	ldr	r3, [pc, #-552]	; 3001c5f4 <tcp_receive+0xe88>
3001c818:	e5932004 	ldr	r2, [r3, #4]
3001c81c:	e51f3238 	ldr	r3, [pc, #-568]	; 3001c5ec <tcp_receive+0xe80>
3001c820:	e5832000 	str	r2, [r3]
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
3001c824:	e51f3238 	ldr	r3, [pc, #-568]	; 3001c5f4 <tcp_receive+0xe88>
3001c828:	e3a02000 	mov	r2, #0
3001c82c:	e5832004 	str	r2, [r3, #4]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
3001c830:	e51f3244 	ldr	r3, [pc, #-580]	; 3001c5f4 <tcp_receive+0xe88>
3001c834:	e5933010 	ldr	r3, [r3, #16]
3001c838:	e5d3200c 	ldrb	r2, [r3, #12]
3001c83c:	e5d3300d 	ldrb	r3, [r3, #13]
3001c840:	e1a03403 	lsl	r3, r3, #8
3001c844:	e1833002 	orr	r3, r3, r2
3001c848:	e1a03803 	lsl	r3, r3, #16
3001c84c:	e1a03823 	lsr	r3, r3, #16
3001c850:	e1a00003 	mov	r0, r3
3001c854:	ebffdc2b 	bl	30013908 <ntohs>
3001c858:	e1a03000 	mov	r3, r0
3001c85c:	e2033001 	and	r3, r3, #1
3001c860:	e20330ff 	and	r3, r3, #255	; 0xff
3001c864:	e3530000 	cmp	r3, #0
3001c868:	0a00012d 	beq	3001cd24 <tcp_receive+0x15b8>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
3001c86c:	e51f3284 	ldr	r3, [pc, #-644]	; 3001c5f0 <tcp_receive+0xe84>
3001c870:	e3a02020 	mov	r2, #32
3001c874:	e5c32000 	strb	r2, [r3]
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
3001c878:	ea00012a 	b	3001cd28 <tcp_receive+0x15bc>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
3001c87c:	e59d3004 	ldr	r3, [sp, #4]
3001c880:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c884:	e58d3010 	str	r3, [sp, #16]
          seqno = pcb->ooseq->tcphdr->seqno;
3001c888:	e59d3004 	ldr	r3, [sp, #4]
3001c88c:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c890:	e5933010 	ldr	r3, [r3, #16]
3001c894:	e5d32004 	ldrb	r2, [r3, #4]
3001c898:	e5d31005 	ldrb	r1, [r3, #5]
3001c89c:	e1a01401 	lsl	r1, r1, #8
3001c8a0:	e1812002 	orr	r2, r1, r2
3001c8a4:	e5d31006 	ldrb	r1, [r3, #6]
3001c8a8:	e1a01801 	lsl	r1, r1, #16
3001c8ac:	e1812002 	orr	r2, r1, r2
3001c8b0:	e5d33007 	ldrb	r3, [r3, #7]
3001c8b4:	e1a03c03 	lsl	r3, r3, #24
3001c8b8:	e1833002 	orr	r3, r3, r2
3001c8bc:	e1a02003 	mov	r2, r3
3001c8c0:	e51f32d0 	ldr	r3, [pc, #-720]	; 3001c5f8 <tcp_receive+0xe8c>
3001c8c4:	e5832000 	str	r2, [r3]

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
3001c8c8:	e59d3004 	ldr	r3, [sp, #4]
3001c8cc:	e5934020 	ldr	r4, [r3, #32]
3001c8d0:	e59d3010 	ldr	r3, [sp, #16]
3001c8d4:	e1d330bc 	ldrh	r3, [r3, #12]
3001c8d8:	e1a05003 	mov	r5, r3
3001c8dc:	e59d3010 	ldr	r3, [sp, #16]
3001c8e0:	e5933010 	ldr	r3, [r3, #16]
3001c8e4:	e5d3200c 	ldrb	r2, [r3, #12]
3001c8e8:	e5d3300d 	ldrb	r3, [r3, #13]
3001c8ec:	e1a03403 	lsl	r3, r3, #8
3001c8f0:	e1833002 	orr	r3, r3, r2
3001c8f4:	e1a03803 	lsl	r3, r3, #16
3001c8f8:	e1a03823 	lsr	r3, r3, #16
3001c8fc:	e1a00003 	mov	r0, r3
3001c900:	ebffdc00 	bl	30013908 <ntohs>
3001c904:	e1a03000 	mov	r3, r0
3001c908:	e2033001 	and	r3, r3, #1
3001c90c:	e20330ff 	and	r3, r3, #255	; 0xff
3001c910:	e3530000 	cmp	r3, #0
3001c914:	1a00000d 	bne	3001c950 <tcp_receive+0x11e4>
3001c918:	e59d3010 	ldr	r3, [sp, #16]
3001c91c:	e5933010 	ldr	r3, [r3, #16]
3001c920:	e5d3200c 	ldrb	r2, [r3, #12]
3001c924:	e5d3300d 	ldrb	r3, [r3, #13]
3001c928:	e1a03403 	lsl	r3, r3, #8
3001c92c:	e1833002 	orr	r3, r3, r2
3001c930:	e1a03803 	lsl	r3, r3, #16
3001c934:	e1a03823 	lsr	r3, r3, #16
3001c938:	e1a00003 	mov	r0, r3
3001c93c:	ebffdbf1 	bl	30013908 <ntohs>
3001c940:	e1a03000 	mov	r3, r0
3001c944:	e2033002 	and	r3, r3, #2
3001c948:	e3530000 	cmp	r3, #0
3001c94c:	0a000001 	beq	3001c958 <tcp_receive+0x11ec>
3001c950:	e3a03001 	mov	r3, #1
3001c954:	ea000000 	b	3001c95c <tcp_receive+0x11f0>
3001c958:	e3a03000 	mov	r3, #0
3001c95c:	e0853003 	add	r3, r5, r3
3001c960:	e0842003 	add	r2, r4, r3
3001c964:	e59d3004 	ldr	r3, [sp, #4]
3001c968:	e5832020 	str	r2, [r3, #32]
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
3001c96c:	e59d3004 	ldr	r3, [sp, #4]
3001c970:	e1d332b4 	ldrh	r3, [r3, #36]	; 0x24
3001c974:	e1a04003 	mov	r4, r3
3001c978:	e59d3010 	ldr	r3, [sp, #16]
3001c97c:	e1d330bc 	ldrh	r3, [r3, #12]
3001c980:	e1a05003 	mov	r5, r3
3001c984:	e59d3010 	ldr	r3, [sp, #16]
3001c988:	e5933010 	ldr	r3, [r3, #16]
3001c98c:	e5d3200c 	ldrb	r2, [r3, #12]
3001c990:	e5d3300d 	ldrb	r3, [r3, #13]
3001c994:	e1a03403 	lsl	r3, r3, #8
3001c998:	e1833002 	orr	r3, r3, r2
3001c99c:	e1a03803 	lsl	r3, r3, #16
3001c9a0:	e1a03823 	lsr	r3, r3, #16
3001c9a4:	e1a00003 	mov	r0, r3
3001c9a8:	ebffdbd6 	bl	30013908 <ntohs>
3001c9ac:	e1a03000 	mov	r3, r0
3001c9b0:	e2033001 	and	r3, r3, #1
3001c9b4:	e20330ff 	and	r3, r3, #255	; 0xff
3001c9b8:	e3530000 	cmp	r3, #0
3001c9bc:	1a00000d 	bne	3001c9f8 <tcp_receive+0x128c>
3001c9c0:	e59d3010 	ldr	r3, [sp, #16]
3001c9c4:	e5933010 	ldr	r3, [r3, #16]
3001c9c8:	e5d3200c 	ldrb	r2, [r3, #12]
3001c9cc:	e5d3300d 	ldrb	r3, [r3, #13]
3001c9d0:	e1a03403 	lsl	r3, r3, #8
3001c9d4:	e1833002 	orr	r3, r3, r2
3001c9d8:	e1a03803 	lsl	r3, r3, #16
3001c9dc:	e1a03823 	lsr	r3, r3, #16
3001c9e0:	e1a00003 	mov	r0, r3
3001c9e4:	ebffdbc7 	bl	30013908 <ntohs>
3001c9e8:	e1a03000 	mov	r3, r0
3001c9ec:	e2033002 	and	r3, r3, #2
3001c9f0:	e3530000 	cmp	r3, #0
3001c9f4:	0a000001 	beq	3001ca00 <tcp_receive+0x1294>
3001c9f8:	e3a03001 	mov	r3, #1
3001c9fc:	ea000000 	b	3001ca04 <tcp_receive+0x1298>
3001ca00:	e3a03000 	mov	r3, #0
3001ca04:	e0853003 	add	r3, r5, r3
3001ca08:	e1540003 	cmp	r4, r3
3001ca0c:	aa000003 	bge	3001ca20 <tcp_receive+0x12b4>
            pcb->rcv_wnd = 0;
3001ca10:	e59d3004 	ldr	r3, [sp, #4]
3001ca14:	e3a02000 	mov	r2, #0
3001ca18:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
3001ca1c:	ea00002d 	b	3001cad8 <tcp_receive+0x136c>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
3001ca20:	e59d3004 	ldr	r3, [sp, #4]
3001ca24:	e1d342b4 	ldrh	r4, [r3, #36]	; 0x24
3001ca28:	e59d3010 	ldr	r3, [sp, #16]
3001ca2c:	e1d350bc 	ldrh	r5, [r3, #12]
3001ca30:	e59d3010 	ldr	r3, [sp, #16]
3001ca34:	e5933010 	ldr	r3, [r3, #16]
3001ca38:	e5d3200c 	ldrb	r2, [r3, #12]
3001ca3c:	e5d3300d 	ldrb	r3, [r3, #13]
3001ca40:	e1a03403 	lsl	r3, r3, #8
3001ca44:	e1833002 	orr	r3, r3, r2
3001ca48:	e1a03803 	lsl	r3, r3, #16
3001ca4c:	e1a03823 	lsr	r3, r3, #16
3001ca50:	e1a00003 	mov	r0, r3
3001ca54:	ebffdbab 	bl	30013908 <ntohs>
3001ca58:	e1a03000 	mov	r3, r0
3001ca5c:	e2033001 	and	r3, r3, #1
3001ca60:	e20330ff 	and	r3, r3, #255	; 0xff
3001ca64:	e3530000 	cmp	r3, #0
3001ca68:	1a00000d 	bne	3001caa4 <tcp_receive+0x1338>
3001ca6c:	e59d3010 	ldr	r3, [sp, #16]
3001ca70:	e5933010 	ldr	r3, [r3, #16]
3001ca74:	e5d3200c 	ldrb	r2, [r3, #12]
3001ca78:	e5d3300d 	ldrb	r3, [r3, #13]
3001ca7c:	e1a03403 	lsl	r3, r3, #8
3001ca80:	e1833002 	orr	r3, r3, r2
3001ca84:	e1a03803 	lsl	r3, r3, #16
3001ca88:	e1a03823 	lsr	r3, r3, #16
3001ca8c:	e1a00003 	mov	r0, r3
3001ca90:	ebffdb9c 	bl	30013908 <ntohs>
3001ca94:	e1a03000 	mov	r3, r0
3001ca98:	e2033002 	and	r3, r3, #2
3001ca9c:	e3530000 	cmp	r3, #0
3001caa0:	0a000001 	beq	3001caac <tcp_receive+0x1340>
3001caa4:	e3a03001 	mov	r3, #1
3001caa8:	ea000000 	b	3001cab0 <tcp_receive+0x1344>
3001caac:	e3a03000 	mov	r3, #0
3001cab0:	e1a03803 	lsl	r3, r3, #16
3001cab4:	e1a03823 	lsr	r3, r3, #16
3001cab8:	e0853003 	add	r3, r5, r3
3001cabc:	e1a03803 	lsl	r3, r3, #16
3001cac0:	e1a03823 	lsr	r3, r3, #16
3001cac4:	e0633004 	rsb	r3, r3, r4
3001cac8:	e1a03803 	lsl	r3, r3, #16
3001cacc:	e1a02823 	lsr	r2, r3, #16
3001cad0:	e59d3004 	ldr	r3, [sp, #4]
3001cad4:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
3001cad8:	e59d3004 	ldr	r3, [sp, #4]
3001cadc:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
3001cae0:	e1a04003 	mov	r4, r3
3001cae4:	e59d3010 	ldr	r3, [sp, #16]
3001cae8:	e1d330bc 	ldrh	r3, [r3, #12]
3001caec:	e1a05003 	mov	r5, r3
3001caf0:	e59d3010 	ldr	r3, [sp, #16]
3001caf4:	e5933010 	ldr	r3, [r3, #16]
3001caf8:	e5d3200c 	ldrb	r2, [r3, #12]
3001cafc:	e5d3300d 	ldrb	r3, [r3, #13]
3001cb00:	e1a03403 	lsl	r3, r3, #8
3001cb04:	e1833002 	orr	r3, r3, r2
3001cb08:	e1a03803 	lsl	r3, r3, #16
3001cb0c:	e1a03823 	lsr	r3, r3, #16
3001cb10:	e1a00003 	mov	r0, r3
3001cb14:	ebffdb7b 	bl	30013908 <ntohs>
3001cb18:	e1a03000 	mov	r3, r0
3001cb1c:	e2033001 	and	r3, r3, #1
3001cb20:	e20330ff 	and	r3, r3, #255	; 0xff
3001cb24:	e3530000 	cmp	r3, #0
3001cb28:	1a00000d 	bne	3001cb64 <tcp_receive+0x13f8>
3001cb2c:	e59d3010 	ldr	r3, [sp, #16]
3001cb30:	e5933010 	ldr	r3, [r3, #16]
3001cb34:	e5d3200c 	ldrb	r2, [r3, #12]
3001cb38:	e5d3300d 	ldrb	r3, [r3, #13]
3001cb3c:	e1a03403 	lsl	r3, r3, #8
3001cb40:	e1833002 	orr	r3, r3, r2
3001cb44:	e1a03803 	lsl	r3, r3, #16
3001cb48:	e1a03823 	lsr	r3, r3, #16
3001cb4c:	e1a00003 	mov	r0, r3
3001cb50:	ebffdb6c 	bl	30013908 <ntohs>
3001cb54:	e1a03000 	mov	r3, r0
3001cb58:	e2033002 	and	r3, r3, #2
3001cb5c:	e3530000 	cmp	r3, #0
3001cb60:	0a000001 	beq	3001cb6c <tcp_receive+0x1400>
3001cb64:	e3a03001 	mov	r3, #1
3001cb68:	ea000000 	b	3001cb70 <tcp_receive+0x1404>
3001cb6c:	e3a03000 	mov	r3, #0
3001cb70:	e0853003 	add	r3, r5, r3
3001cb74:	e1540003 	cmp	r4, r3
3001cb78:	aa000003 	bge	3001cb8c <tcp_receive+0x1420>
            pcb->rcv_ann_wnd = 0;
3001cb7c:	e59d3004 	ldr	r3, [sp, #4]
3001cb80:	e3a02000 	mov	r2, #0
3001cb84:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
3001cb88:	ea00002d 	b	3001cc44 <tcp_receive+0x14d8>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
3001cb8c:	e59d3004 	ldr	r3, [sp, #4]
3001cb90:	e1d342b6 	ldrh	r4, [r3, #38]	; 0x26
3001cb94:	e59d3010 	ldr	r3, [sp, #16]
3001cb98:	e1d350bc 	ldrh	r5, [r3, #12]
3001cb9c:	e59d3010 	ldr	r3, [sp, #16]
3001cba0:	e5933010 	ldr	r3, [r3, #16]
3001cba4:	e5d3200c 	ldrb	r2, [r3, #12]
3001cba8:	e5d3300d 	ldrb	r3, [r3, #13]
3001cbac:	e1a03403 	lsl	r3, r3, #8
3001cbb0:	e1833002 	orr	r3, r3, r2
3001cbb4:	e1a03803 	lsl	r3, r3, #16
3001cbb8:	e1a03823 	lsr	r3, r3, #16
3001cbbc:	e1a00003 	mov	r0, r3
3001cbc0:	ebffdb50 	bl	30013908 <ntohs>
3001cbc4:	e1a03000 	mov	r3, r0
3001cbc8:	e2033001 	and	r3, r3, #1
3001cbcc:	e20330ff 	and	r3, r3, #255	; 0xff
3001cbd0:	e3530000 	cmp	r3, #0
3001cbd4:	1a00000d 	bne	3001cc10 <tcp_receive+0x14a4>
3001cbd8:	e59d3010 	ldr	r3, [sp, #16]
3001cbdc:	e5933010 	ldr	r3, [r3, #16]
3001cbe0:	e5d3200c 	ldrb	r2, [r3, #12]
3001cbe4:	e5d3300d 	ldrb	r3, [r3, #13]
3001cbe8:	e1a03403 	lsl	r3, r3, #8
3001cbec:	e1833002 	orr	r3, r3, r2
3001cbf0:	e1a03803 	lsl	r3, r3, #16
3001cbf4:	e1a03823 	lsr	r3, r3, #16
3001cbf8:	e1a00003 	mov	r0, r3
3001cbfc:	ebffdb41 	bl	30013908 <ntohs>
3001cc00:	e1a03000 	mov	r3, r0
3001cc04:	e2033002 	and	r3, r3, #2
3001cc08:	e3530000 	cmp	r3, #0
3001cc0c:	0a000001 	beq	3001cc18 <tcp_receive+0x14ac>
3001cc10:	e3a03001 	mov	r3, #1
3001cc14:	ea000000 	b	3001cc1c <tcp_receive+0x14b0>
3001cc18:	e3a03000 	mov	r3, #0
3001cc1c:	e1a03803 	lsl	r3, r3, #16
3001cc20:	e1a03823 	lsr	r3, r3, #16
3001cc24:	e0853003 	add	r3, r5, r3
3001cc28:	e1a03803 	lsl	r3, r3, #16
3001cc2c:	e1a03823 	lsr	r3, r3, #16
3001cc30:	e0633004 	rsb	r3, r3, r4
3001cc34:	e1a03803 	lsl	r3, r3, #16
3001cc38:	e1a02823 	lsr	r2, r3, #16
3001cc3c:	e59d3004 	ldr	r3, [sp, #4]
3001cc40:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
          }

          if (cseg->p->tot_len > 0) {
3001cc44:	e59d3010 	ldr	r3, [sp, #16]
3001cc48:	e5933004 	ldr	r3, [r3, #4]
3001cc4c:	e1d330b8 	ldrh	r3, [r3, #8]
3001cc50:	e3530000 	cmp	r3, #0
3001cc54:	0a000012 	beq	3001cca4 <tcp_receive+0x1538>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
3001cc58:	e51f3674 	ldr	r3, [pc, #-1652]	; 3001c5ec <tcp_receive+0xe80>
3001cc5c:	e5933000 	ldr	r3, [r3]
3001cc60:	e3530000 	cmp	r3, #0
3001cc64:	0a000007 	beq	3001cc88 <tcp_receive+0x151c>
              pbuf_cat(recv_data, cseg->p);
3001cc68:	e51f3684 	ldr	r3, [pc, #-1668]	; 3001c5ec <tcp_receive+0xe80>
3001cc6c:	e5932000 	ldr	r2, [r3]
3001cc70:	e59d3010 	ldr	r3, [sp, #16]
3001cc74:	e5933004 	ldr	r3, [r3, #4]
3001cc78:	e1a00002 	mov	r0, r2
3001cc7c:	e1a01003 	mov	r1, r3
3001cc80:	ebffe697 	bl	300166e4 <pbuf_cat>
3001cc84:	ea000003 	b	3001cc98 <tcp_receive+0x152c>
            } else {
              recv_data = cseg->p;
3001cc88:	e59d3010 	ldr	r3, [sp, #16]
3001cc8c:	e5932004 	ldr	r2, [r3, #4]
3001cc90:	e51f36ac 	ldr	r3, [pc, #-1708]	; 3001c5ec <tcp_receive+0xe80>
3001cc94:	e5832000 	str	r2, [r3]
            }
            cseg->p = NULL;
3001cc98:	e59d3010 	ldr	r3, [sp, #16]
3001cc9c:	e3a02000 	mov	r2, #0
3001cca0:	e5832004 	str	r2, [r3, #4]
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
3001cca4:	e59d3010 	ldr	r3, [sp, #16]
3001cca8:	e5933010 	ldr	r3, [r3, #16]
3001ccac:	e5d3200c 	ldrb	r2, [r3, #12]
3001ccb0:	e5d3300d 	ldrb	r3, [r3, #13]
3001ccb4:	e1a03403 	lsl	r3, r3, #8
3001ccb8:	e1833002 	orr	r3, r3, r2
3001ccbc:	e1a03803 	lsl	r3, r3, #16
3001ccc0:	e1a03823 	lsr	r3, r3, #16
3001ccc4:	e1a00003 	mov	r0, r3
3001ccc8:	ebffdb0e 	bl	30013908 <ntohs>
3001cccc:	e1a03000 	mov	r3, r0
3001ccd0:	e2033001 	and	r3, r3, #1
3001ccd4:	e20330ff 	and	r3, r3, #255	; 0xff
3001ccd8:	e3530000 	cmp	r3, #0
3001ccdc:	0a000009 	beq	3001cd08 <tcp_receive+0x159c>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
3001cce0:	e51f36f8 	ldr	r3, [pc, #-1784]	; 3001c5f0 <tcp_receive+0xe84>
3001cce4:	e3a02020 	mov	r2, #32
3001cce8:	e5c32000 	strb	r2, [r3]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
3001ccec:	e59d3004 	ldr	r3, [sp, #4]
3001ccf0:	e5d33010 	ldrb	r3, [r3, #16]
3001ccf4:	e3530004 	cmp	r3, #4
3001ccf8:	1a000002 	bne	3001cd08 <tcp_receive+0x159c>
              pcb->state = CLOSE_WAIT;
3001ccfc:	e59d3004 	ldr	r3, [sp, #4]
3001cd00:	e3a02007 	mov	r2, #7
3001cd04:	e5c32010 	strb	r2, [r3, #16]
            } 
          }


          pcb->ooseq = cseg->next;
3001cd08:	e59d3010 	ldr	r3, [sp, #16]
3001cd0c:	e5932000 	ldr	r2, [r3]
3001cd10:	e59d3004 	ldr	r3, [sp, #4]
3001cd14:	e5832078 	str	r2, [r3, #120]	; 0x78
          tcp_seg_free(cseg);
3001cd18:	e59d0010 	ldr	r0, [sp, #16]
3001cd1c:	ebfff09e 	bl	30018f9c <tcp_seg_free>
3001cd20:	ea000000 	b	3001cd28 <tcp_receive+0x15bc>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
3001cd24:	e1a00000 	nop			; (mov r0, r0)
3001cd28:	e59d3004 	ldr	r3, [sp, #4]
3001cd2c:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001cd30:	e3530000 	cmp	r3, #0
3001cd34:	0a000011 	beq	3001cd80 <tcp_receive+0x1614>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
3001cd38:	e59d3004 	ldr	r3, [sp, #4]
3001cd3c:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001cd40:	e5933010 	ldr	r3, [r3, #16]
3001cd44:	e5d32004 	ldrb	r2, [r3, #4]
3001cd48:	e5d31005 	ldrb	r1, [r3, #5]
3001cd4c:	e1a01401 	lsl	r1, r1, #8
3001cd50:	e1812002 	orr	r2, r1, r2
3001cd54:	e5d31006 	ldrb	r1, [r3, #6]
3001cd58:	e1a01801 	lsl	r1, r1, #16
3001cd5c:	e1812002 	orr	r2, r1, r2
3001cd60:	e5d33007 	ldrb	r3, [r3, #7]
3001cd64:	e1a03c03 	lsl	r3, r3, #24
3001cd68:	e1833002 	orr	r3, r3, r2
3001cd6c:	e1a02003 	mov	r2, r3
3001cd70:	e59d3004 	ldr	r3, [sp, #4]
3001cd74:	e5933020 	ldr	r3, [r3, #32]
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
3001cd78:	e1520003 	cmp	r2, r3
3001cd7c:	0afffebe 	beq	3001c87c <tcp_receive+0x1110>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
3001cd80:	e59d3004 	ldr	r3, [sp, #4]
3001cd84:	e5d3301c 	ldrb	r3, [r3, #28]
3001cd88:	e2033001 	and	r3, r3, #1
3001cd8c:	e20330ff 	and	r3, r3, #255	; 0xff
3001cd90:	e3530000 	cmp	r3, #0
3001cd94:	0a00000d 	beq	3001cdd0 <tcp_receive+0x1664>
3001cd98:	e59d3004 	ldr	r3, [sp, #4]
3001cd9c:	e5d3301c 	ldrb	r3, [r3, #28]
3001cda0:	e20330fe 	and	r3, r3, #254	; 0xfe
3001cda4:	e59d2004 	ldr	r2, [sp, #4]
3001cda8:	e5c2301c 	strb	r3, [r2, #28]
3001cdac:	e59d3004 	ldr	r3, [sp, #4]
3001cdb0:	e5d3301c 	ldrb	r3, [r3, #28]
3001cdb4:	e3833002 	orr	r3, r3, #2
3001cdb8:	e20320ff 	and	r2, r3, #255	; 0xff
3001cdbc:	e59d3004 	ldr	r3, [sp, #4]
3001cdc0:	e5c3201c 	strb	r2, [r3, #28]
3001cdc4:	e59d0004 	ldr	r0, [sp, #4]
3001cdc8:	eb00052d 	bl	3001e284 <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
3001cdcc:	ea000218 	b	3001d634 <tcp_receive+0x1ec8>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
3001cdd0:	e59d3004 	ldr	r3, [sp, #4]
3001cdd4:	e5d3301c 	ldrb	r3, [r3, #28]
3001cdd8:	e3833001 	orr	r3, r3, #1
3001cddc:	e20320ff 	and	r2, r3, #255	; 0xff
3001cde0:	e59d3004 	ldr	r3, [sp, #4]
3001cde4:	e5c3201c 	strb	r2, [r3, #28]
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
3001cde8:	ea000211 	b	3001d634 <tcp_receive+0x1ec8>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
3001cdec:	e59d3004 	ldr	r3, [sp, #4]
3001cdf0:	e5d3301c 	ldrb	r3, [r3, #28]
3001cdf4:	e3833002 	orr	r3, r3, #2
3001cdf8:	e20320ff 	and	r2, r3, #255	; 0xff
3001cdfc:	e59d3004 	ldr	r3, [sp, #4]
3001ce00:	e5c3201c 	strb	r2, [r3, #28]
3001ce04:	e59d0004 	ldr	r0, [sp, #4]
3001ce08:	eb00051d 	bl	3001e284 <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
3001ce0c:	e59d3004 	ldr	r3, [sp, #4]
3001ce10:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001ce14:	e3530000 	cmp	r3, #0
3001ce18:	1a000005 	bne	3001ce34 <tcp_receive+0x16c8>
          pcb->ooseq = tcp_seg_copy(&inseg);
3001ce1c:	e51f0830 	ldr	r0, [pc, #-2096]	; 3001c5f4 <tcp_receive+0xe88>
3001ce20:	ebfff080 	bl	30019028 <tcp_seg_copy>
3001ce24:	e1a02000 	mov	r2, r0
3001ce28:	e59d3004 	ldr	r3, [sp, #4]
3001ce2c:	e5832078 	str	r2, [r3, #120]	; 0x78
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
3001ce30:	ea0001ff 	b	3001d634 <tcp_receive+0x1ec8>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
3001ce34:	e3a03000 	mov	r3, #0
3001ce38:	e58d300c 	str	r3, [sp, #12]
          for(next = pcb->ooseq; next != NULL; next = next->next) {
3001ce3c:	e59d3004 	ldr	r3, [sp, #4]
3001ce40:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001ce44:	e58d3008 	str	r3, [sp, #8]
3001ce48:	ea0001ad 	b	3001d504 <tcp_receive+0x1d98>
            if (seqno == next->tcphdr->seqno) {
3001ce4c:	e59d3008 	ldr	r3, [sp, #8]
3001ce50:	e5933010 	ldr	r3, [r3, #16]
3001ce54:	e5d32004 	ldrb	r2, [r3, #4]
3001ce58:	e5d31005 	ldrb	r1, [r3, #5]
3001ce5c:	e1a01401 	lsl	r1, r1, #8
3001ce60:	e1812002 	orr	r2, r1, r2
3001ce64:	e5d31006 	ldrb	r1, [r3, #6]
3001ce68:	e1a01801 	lsl	r1, r1, #16
3001ce6c:	e1812002 	orr	r2, r1, r2
3001ce70:	e5d33007 	ldrb	r3, [r3, #7]
3001ce74:	e1a03c03 	lsl	r3, r3, #24
3001ce78:	e1833002 	orr	r3, r3, r2
3001ce7c:	e1a02003 	mov	r2, r3
3001ce80:	e51f3890 	ldr	r3, [pc, #-2192]	; 3001c5f8 <tcp_receive+0xe8c>
3001ce84:	e5933000 	ldr	r3, [r3]
3001ce88:	e1520003 	cmp	r2, r3
3001ce8c:	1a000057 	bne	3001cff0 <tcp_receive+0x1884>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
3001ce90:	e51f38a4 	ldr	r3, [pc, #-2212]	; 3001c5f4 <tcp_receive+0xe88>
3001ce94:	e1d320bc 	ldrh	r2, [r3, #12]
3001ce98:	e59d3008 	ldr	r3, [sp, #8]
3001ce9c:	e1d330bc 	ldrh	r3, [r3, #12]
3001cea0:	e1520003 	cmp	r2, r3
3001cea4:	9a00019a 	bls	3001d514 <tcp_receive+0x1da8>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
3001cea8:	e51f08bc 	ldr	r0, [pc, #-2236]	; 3001c5f4 <tcp_receive+0xe88>
3001ceac:	ebfff05d 	bl	30019028 <tcp_seg_copy>
3001ceb0:	e1a03000 	mov	r3, r0
3001ceb4:	e58d3010 	str	r3, [sp, #16]
                if (cseg != NULL) {
3001ceb8:	e59d3010 	ldr	r3, [sp, #16]
3001cebc:	e3530000 	cmp	r3, #0
3001cec0:	0a00000d 	beq	3001cefc <tcp_receive+0x1790>
                  cseg->next = next->next;
3001cec4:	e59d3008 	ldr	r3, [sp, #8]
3001cec8:	e5932000 	ldr	r2, [r3]
3001cecc:	e59d3010 	ldr	r3, [sp, #16]
3001ced0:	e5832000 	str	r2, [r3]
                  if (prev != NULL) {
3001ced4:	e59d300c 	ldr	r3, [sp, #12]
3001ced8:	e3530000 	cmp	r3, #0
3001cedc:	0a000003 	beq	3001cef0 <tcp_receive+0x1784>
                    prev->next = cseg;
3001cee0:	e59d300c 	ldr	r3, [sp, #12]
3001cee4:	e59d2010 	ldr	r2, [sp, #16]
3001cee8:	e5832000 	str	r2, [r3]
3001ceec:	ea000002 	b	3001cefc <tcp_receive+0x1790>
                  } else {
                    pcb->ooseq = cseg;
3001cef0:	e59d3004 	ldr	r3, [sp, #4]
3001cef4:	e59d2010 	ldr	r2, [sp, #16]
3001cef8:	e5832078 	str	r2, [r3, #120]	; 0x78
                  }
                }
                tcp_seg_free(next);
3001cefc:	e59d0008 	ldr	r0, [sp, #8]
3001cf00:	ebfff025 	bl	30018f9c <tcp_seg_free>
                if (cseg->next != NULL) {
3001cf04:	e59d3010 	ldr	r3, [sp, #16]
3001cf08:	e5933000 	ldr	r3, [r3]
3001cf0c:	e3530000 	cmp	r3, #0
3001cf10:	0a000181 	beq	3001d51c <tcp_receive+0x1db0>
                  next = cseg->next;
3001cf14:	e59d3010 	ldr	r3, [sp, #16]
3001cf18:	e5933000 	ldr	r3, [r3]
3001cf1c:	e58d3008 	str	r3, [sp, #8]
                  if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
3001cf20:	e59d3010 	ldr	r3, [sp, #16]
3001cf24:	e1d330bc 	ldrh	r3, [r3, #12]
3001cf28:	e1a02003 	mov	r2, r3
3001cf2c:	e51f393c 	ldr	r3, [pc, #-2364]	; 3001c5f8 <tcp_receive+0xe8c>
3001cf30:	e5933000 	ldr	r3, [r3]
3001cf34:	e0822003 	add	r2, r2, r3
3001cf38:	e59d3008 	ldr	r3, [sp, #8]
3001cf3c:	e5933010 	ldr	r3, [r3, #16]
3001cf40:	e5d31004 	ldrb	r1, [r3, #4]
3001cf44:	e5d30005 	ldrb	r0, [r3, #5]
3001cf48:	e1a00400 	lsl	r0, r0, #8
3001cf4c:	e1801001 	orr	r1, r0, r1
3001cf50:	e5d30006 	ldrb	r0, [r3, #6]
3001cf54:	e1a00800 	lsl	r0, r0, #16
3001cf58:	e1801001 	orr	r1, r0, r1
3001cf5c:	e5d33007 	ldrb	r3, [r3, #7]
3001cf60:	e1a03c03 	lsl	r3, r3, #24
3001cf64:	e1833001 	orr	r3, r3, r1
3001cf68:	e0633002 	rsb	r3, r3, r2
3001cf6c:	e3530000 	cmp	r3, #0
3001cf70:	da00016b 	ble	3001d524 <tcp_receive+0x1db8>
                    /* We need to trim the incoming segment. */
                    cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
3001cf74:	e59d3008 	ldr	r3, [sp, #8]
3001cf78:	e5933010 	ldr	r3, [r3, #16]
3001cf7c:	e5d32004 	ldrb	r2, [r3, #4]
3001cf80:	e5d31005 	ldrb	r1, [r3, #5]
3001cf84:	e1a01401 	lsl	r1, r1, #8
3001cf88:	e1812002 	orr	r2, r1, r2
3001cf8c:	e5d31006 	ldrb	r1, [r3, #6]
3001cf90:	e1a01801 	lsl	r1, r1, #16
3001cf94:	e1812002 	orr	r2, r1, r2
3001cf98:	e5d33007 	ldrb	r3, [r3, #7]
3001cf9c:	e1a03c03 	lsl	r3, r3, #24
3001cfa0:	e1833002 	orr	r3, r3, r2
3001cfa4:	e1a03803 	lsl	r3, r3, #16
3001cfa8:	e1a02823 	lsr	r2, r3, #16
3001cfac:	e51f39bc 	ldr	r3, [pc, #-2492]	; 3001c5f8 <tcp_receive+0xe8c>
3001cfb0:	e5933000 	ldr	r3, [r3]
3001cfb4:	e1a03803 	lsl	r3, r3, #16
3001cfb8:	e1a03823 	lsr	r3, r3, #16
3001cfbc:	e0633002 	rsb	r3, r3, r2
3001cfc0:	e1a03803 	lsl	r3, r3, #16
3001cfc4:	e1a02823 	lsr	r2, r3, #16
3001cfc8:	e59d3010 	ldr	r3, [sp, #16]
3001cfcc:	e1c320bc 	strh	r2, [r3, #12]
                    pbuf_realloc(cseg->p, cseg->len);
3001cfd0:	e59d3010 	ldr	r3, [sp, #16]
3001cfd4:	e5932004 	ldr	r2, [r3, #4]
3001cfd8:	e59d3010 	ldr	r3, [sp, #16]
3001cfdc:	e1d330bc 	ldrh	r3, [r3, #12]
3001cfe0:	e1a00002 	mov	r0, r2
3001cfe4:	e1a01003 	mov	r1, r3
3001cfe8:	ebffe48d 	bl	30016224 <pbuf_realloc>
                  }
                }
                break;
3001cfec:	ea000157 	b	3001d550 <tcp_receive+0x1de4>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
3001cff0:	e59d300c 	ldr	r3, [sp, #12]
3001cff4:	e3530000 	cmp	r3, #0
3001cff8:	1a000051 	bne	3001d144 <tcp_receive+0x19d8>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
3001cffc:	e51f3a0c 	ldr	r3, [pc, #-2572]	; 3001c5f8 <tcp_receive+0xe8c>
3001d000:	e5932000 	ldr	r2, [r3]
3001d004:	e59d3008 	ldr	r3, [sp, #8]
3001d008:	e5933010 	ldr	r3, [r3, #16]
3001d00c:	e5d31004 	ldrb	r1, [r3, #4]
3001d010:	e5d30005 	ldrb	r0, [r3, #5]
3001d014:	e1a00400 	lsl	r0, r0, #8
3001d018:	e1801001 	orr	r1, r0, r1
3001d01c:	e5d30006 	ldrb	r0, [r3, #6]
3001d020:	e1a00800 	lsl	r0, r0, #16
3001d024:	e1801001 	orr	r1, r0, r1
3001d028:	e5d33007 	ldrb	r3, [r3, #7]
3001d02c:	e1a03c03 	lsl	r3, r3, #24
3001d030:	e1833001 	orr	r3, r3, r1
3001d034:	e0633002 	rsb	r3, r3, r2
3001d038:	e3530000 	cmp	r3, #0
3001d03c:	aa0000d8 	bge	3001d3a4 <tcp_receive+0x1c38>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
3001d040:	e51f3a54 	ldr	r3, [pc, #-2644]	; 3001c5f4 <tcp_receive+0xe88>
3001d044:	e1d330bc 	ldrh	r3, [r3, #12]
3001d048:	e1a02003 	mov	r2, r3
3001d04c:	e51f3a5c 	ldr	r3, [pc, #-2652]	; 3001c5f8 <tcp_receive+0xe8c>
3001d050:	e5933000 	ldr	r3, [r3]
3001d054:	e0822003 	add	r2, r2, r3
3001d058:	e59d3008 	ldr	r3, [sp, #8]
3001d05c:	e5933010 	ldr	r3, [r3, #16]
3001d060:	e5d31004 	ldrb	r1, [r3, #4]
3001d064:	e5d30005 	ldrb	r0, [r3, #5]
3001d068:	e1a00400 	lsl	r0, r0, #8
3001d06c:	e1801001 	orr	r1, r0, r1
3001d070:	e5d30006 	ldrb	r0, [r3, #6]
3001d074:	e1a00800 	lsl	r0, r0, #16
3001d078:	e1801001 	orr	r1, r0, r1
3001d07c:	e5d33007 	ldrb	r3, [r3, #7]
3001d080:	e1a03c03 	lsl	r3, r3, #24
3001d084:	e1833001 	orr	r3, r3, r1
3001d088:	e0633002 	rsb	r3, r3, r2
3001d08c:	e3530000 	cmp	r3, #0
3001d090:	da00001d 	ble	3001d10c <tcp_receive+0x19a0>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
3001d094:	e59d3008 	ldr	r3, [sp, #8]
3001d098:	e5933010 	ldr	r3, [r3, #16]
3001d09c:	e5d32004 	ldrb	r2, [r3, #4]
3001d0a0:	e5d31005 	ldrb	r1, [r3, #5]
3001d0a4:	e1a01401 	lsl	r1, r1, #8
3001d0a8:	e1812002 	orr	r2, r1, r2
3001d0ac:	e5d31006 	ldrb	r1, [r3, #6]
3001d0b0:	e1a01801 	lsl	r1, r1, #16
3001d0b4:	e1812002 	orr	r2, r1, r2
3001d0b8:	e5d33007 	ldrb	r3, [r3, #7]
3001d0bc:	e1a03c03 	lsl	r3, r3, #24
3001d0c0:	e1833002 	orr	r3, r3, r2
3001d0c4:	e1a03803 	lsl	r3, r3, #16
3001d0c8:	e1a02823 	lsr	r2, r3, #16
3001d0cc:	e51f3adc 	ldr	r3, [pc, #-2780]	; 3001c5f8 <tcp_receive+0xe8c>
3001d0d0:	e5933000 	ldr	r3, [r3]
3001d0d4:	e1a03803 	lsl	r3, r3, #16
3001d0d8:	e1a03823 	lsr	r3, r3, #16
3001d0dc:	e0633002 	rsb	r3, r3, r2
3001d0e0:	e1a03803 	lsl	r3, r3, #16
3001d0e4:	e1a02823 	lsr	r2, r3, #16
3001d0e8:	e51f3afc 	ldr	r3, [pc, #-2812]	; 3001c5f4 <tcp_receive+0xe88>
3001d0ec:	e1c320bc 	strh	r2, [r3, #12]
                    pbuf_realloc(inseg.p, inseg.len);
3001d0f0:	e51f3b04 	ldr	r3, [pc, #-2820]	; 3001c5f4 <tcp_receive+0xe88>
3001d0f4:	e5932004 	ldr	r2, [r3, #4]
3001d0f8:	e51f3b0c 	ldr	r3, [pc, #-2828]	; 3001c5f4 <tcp_receive+0xe88>
3001d0fc:	e1d330bc 	ldrh	r3, [r3, #12]
3001d100:	e1a00002 	mov	r0, r2
3001d104:	e1a01003 	mov	r1, r3
3001d108:	ebffe445 	bl	30016224 <pbuf_realloc>
                  }
                  cseg = tcp_seg_copy(&inseg);
3001d10c:	e51f0b20 	ldr	r0, [pc, #-2848]	; 3001c5f4 <tcp_receive+0xe88>
3001d110:	ebffefc4 	bl	30019028 <tcp_seg_copy>
3001d114:	e1a03000 	mov	r3, r0
3001d118:	e58d3010 	str	r3, [sp, #16]
                  if (cseg != NULL) {
3001d11c:	e59d3010 	ldr	r3, [sp, #16]
3001d120:	e3530000 	cmp	r3, #0
3001d124:	0a000100 	beq	3001d52c <tcp_receive+0x1dc0>
                    cseg->next = next;
3001d128:	e59d3010 	ldr	r3, [sp, #16]
3001d12c:	e59d2008 	ldr	r2, [sp, #8]
3001d130:	e5832000 	str	r2, [r3]
                    pcb->ooseq = cseg;
3001d134:	e59d3004 	ldr	r3, [sp, #4]
3001d138:	e59d2010 	ldr	r2, [sp, #16]
3001d13c:	e5832078 	str	r2, [r3, #120]	; 0x78
                  }
                  break;
3001d140:	ea000102 	b	3001d550 <tcp_receive+0x1de4>
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
3001d144:	e59d300c 	ldr	r3, [sp, #12]
3001d148:	e5933010 	ldr	r3, [r3, #16]
3001d14c:	e5d32004 	ldrb	r2, [r3, #4]
3001d150:	e5d31005 	ldrb	r1, [r3, #5]
3001d154:	e1a01401 	lsl	r1, r1, #8
3001d158:	e1812002 	orr	r2, r1, r2
3001d15c:	e5d31006 	ldrb	r1, [r3, #6]
3001d160:	e1a01801 	lsl	r1, r1, #16
3001d164:	e1812002 	orr	r2, r1, r2
3001d168:	e5d33007 	ldrb	r3, [r3, #7]
3001d16c:	e1a03c03 	lsl	r3, r3, #24
3001d170:	e1833002 	orr	r3, r3, r2
3001d174:	e1e02003 	mvn	r2, r3
3001d178:	e51f3b88 	ldr	r3, [pc, #-2952]	; 3001c5f8 <tcp_receive+0xe8c>
3001d17c:	e5933000 	ldr	r3, [r3]
3001d180:	e0823003 	add	r3, r2, r3
3001d184:	e3530000 	cmp	r3, #0
3001d188:	ba000086 	blt	3001d3a8 <tcp_receive+0x1c3c>
3001d18c:	e51f3b9c 	ldr	r3, [pc, #-2972]	; 3001c5f8 <tcp_receive+0xe8c>
3001d190:	e5932000 	ldr	r2, [r3]
3001d194:	e59d3008 	ldr	r3, [sp, #8]
3001d198:	e5933010 	ldr	r3, [r3, #16]
3001d19c:	e5d31004 	ldrb	r1, [r3, #4]
3001d1a0:	e5d30005 	ldrb	r0, [r3, #5]
3001d1a4:	e1a00400 	lsl	r0, r0, #8
3001d1a8:	e1801001 	orr	r1, r0, r1
3001d1ac:	e5d30006 	ldrb	r0, [r3, #6]
3001d1b0:	e1a00800 	lsl	r0, r0, #16
3001d1b4:	e1801001 	orr	r1, r0, r1
3001d1b8:	e5d33007 	ldrb	r3, [r3, #7]
3001d1bc:	e1a03c03 	lsl	r3, r3, #24
3001d1c0:	e1833001 	orr	r3, r3, r1
3001d1c4:	e0633002 	rsb	r3, r3, r2
3001d1c8:	e2833001 	add	r3, r3, #1
3001d1cc:	e3530000 	cmp	r3, #0
3001d1d0:	ca000074 	bgt	3001d3a8 <tcp_receive+0x1c3c>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
3001d1d4:	e51f3be8 	ldr	r3, [pc, #-3048]	; 3001c5f4 <tcp_receive+0xe88>
3001d1d8:	e1d330bc 	ldrh	r3, [r3, #12]
3001d1dc:	e1a02003 	mov	r2, r3
3001d1e0:	e51f3bf0 	ldr	r3, [pc, #-3056]	; 3001c5f8 <tcp_receive+0xe8c>
3001d1e4:	e5933000 	ldr	r3, [r3]
3001d1e8:	e0822003 	add	r2, r2, r3
3001d1ec:	e59d3008 	ldr	r3, [sp, #8]
3001d1f0:	e5933010 	ldr	r3, [r3, #16]
3001d1f4:	e5d31004 	ldrb	r1, [r3, #4]
3001d1f8:	e5d30005 	ldrb	r0, [r3, #5]
3001d1fc:	e1a00400 	lsl	r0, r0, #8
3001d200:	e1801001 	orr	r1, r0, r1
3001d204:	e5d30006 	ldrb	r0, [r3, #6]
3001d208:	e1a00800 	lsl	r0, r0, #16
3001d20c:	e1801001 	orr	r1, r0, r1
3001d210:	e5d33007 	ldrb	r3, [r3, #7]
3001d214:	e1a03c03 	lsl	r3, r3, #24
3001d218:	e1833001 	orr	r3, r3, r1
3001d21c:	e0633002 	rsb	r3, r3, r2
3001d220:	e3530000 	cmp	r3, #0
3001d224:	da00001d 	ble	3001d2a0 <tcp_receive+0x1b34>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
3001d228:	e59d3008 	ldr	r3, [sp, #8]
3001d22c:	e5933010 	ldr	r3, [r3, #16]
3001d230:	e5d32004 	ldrb	r2, [r3, #4]
3001d234:	e5d31005 	ldrb	r1, [r3, #5]
3001d238:	e1a01401 	lsl	r1, r1, #8
3001d23c:	e1812002 	orr	r2, r1, r2
3001d240:	e5d31006 	ldrb	r1, [r3, #6]
3001d244:	e1a01801 	lsl	r1, r1, #16
3001d248:	e1812002 	orr	r2, r1, r2
3001d24c:	e5d33007 	ldrb	r3, [r3, #7]
3001d250:	e1a03c03 	lsl	r3, r3, #24
3001d254:	e1833002 	orr	r3, r3, r2
3001d258:	e1a03803 	lsl	r3, r3, #16
3001d25c:	e1a02823 	lsr	r2, r3, #16
3001d260:	e51f3c70 	ldr	r3, [pc, #-3184]	; 3001c5f8 <tcp_receive+0xe8c>
3001d264:	e5933000 	ldr	r3, [r3]
3001d268:	e1a03803 	lsl	r3, r3, #16
3001d26c:	e1a03823 	lsr	r3, r3, #16
3001d270:	e0633002 	rsb	r3, r3, r2
3001d274:	e1a03803 	lsl	r3, r3, #16
3001d278:	e1a02823 	lsr	r2, r3, #16
3001d27c:	e51f3c90 	ldr	r3, [pc, #-3216]	; 3001c5f4 <tcp_receive+0xe88>
3001d280:	e1c320bc 	strh	r2, [r3, #12]
                  pbuf_realloc(inseg.p, inseg.len);
3001d284:	e51f3c98 	ldr	r3, [pc, #-3224]	; 3001c5f4 <tcp_receive+0xe88>
3001d288:	e5932004 	ldr	r2, [r3, #4]
3001d28c:	e51f3ca0 	ldr	r3, [pc, #-3232]	; 3001c5f4 <tcp_receive+0xe88>
3001d290:	e1d330bc 	ldrh	r3, [r3, #12]
3001d294:	e1a00002 	mov	r0, r2
3001d298:	e1a01003 	mov	r1, r3
3001d29c:	ebffe3e0 	bl	30016224 <pbuf_realloc>
                }

                cseg = tcp_seg_copy(&inseg);
3001d2a0:	e51f0cb4 	ldr	r0, [pc, #-3252]	; 3001c5f4 <tcp_receive+0xe88>
3001d2a4:	ebffef5f 	bl	30019028 <tcp_seg_copy>
3001d2a8:	e1a03000 	mov	r3, r0
3001d2ac:	e58d3010 	str	r3, [sp, #16]
                if (cseg != NULL) {
3001d2b0:	e59d3010 	ldr	r3, [sp, #16]
3001d2b4:	e3530000 	cmp	r3, #0
3001d2b8:	0a00009d 	beq	3001d534 <tcp_receive+0x1dc8>
                  cseg->next = next;
3001d2bc:	e59d3010 	ldr	r3, [sp, #16]
3001d2c0:	e59d2008 	ldr	r2, [sp, #8]
3001d2c4:	e5832000 	str	r2, [r3]
                  prev->next = cseg;
3001d2c8:	e59d300c 	ldr	r3, [sp, #12]
3001d2cc:	e59d2010 	ldr	r2, [sp, #16]
3001d2d0:	e5832000 	str	r2, [r3]
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
3001d2d4:	e59d300c 	ldr	r3, [sp, #12]
3001d2d8:	e5933010 	ldr	r3, [r3, #16]
3001d2dc:	e5d32004 	ldrb	r2, [r3, #4]
3001d2e0:	e5d31005 	ldrb	r1, [r3, #5]
3001d2e4:	e1a01401 	lsl	r1, r1, #8
3001d2e8:	e1812002 	orr	r2, r1, r2
3001d2ec:	e5d31006 	ldrb	r1, [r3, #6]
3001d2f0:	e1a01801 	lsl	r1, r1, #16
3001d2f4:	e1812002 	orr	r2, r1, r2
3001d2f8:	e5d33007 	ldrb	r3, [r3, #7]
3001d2fc:	e1a03c03 	lsl	r3, r3, #24
3001d300:	e1833002 	orr	r3, r3, r2
3001d304:	e1a02003 	mov	r2, r3
3001d308:	e59d300c 	ldr	r3, [sp, #12]
3001d30c:	e1d330bc 	ldrh	r3, [r3, #12]
3001d310:	e0822003 	add	r2, r2, r3
3001d314:	e51f3d24 	ldr	r3, [pc, #-3364]	; 3001c5f8 <tcp_receive+0xe8c>
3001d318:	e5933000 	ldr	r3, [r3]
3001d31c:	e0633002 	rsb	r3, r3, r2
3001d320:	e3530000 	cmp	r3, #0
3001d324:	da000084 	ble	3001d53c <tcp_receive+0x1dd0>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
3001d328:	e51f3d38 	ldr	r3, [pc, #-3384]	; 3001c5f8 <tcp_receive+0xe8c>
3001d32c:	e5933000 	ldr	r3, [r3]
3001d330:	e1a03803 	lsl	r3, r3, #16
3001d334:	e1a02823 	lsr	r2, r3, #16
3001d338:	e59d300c 	ldr	r3, [sp, #12]
3001d33c:	e5933010 	ldr	r3, [r3, #16]
3001d340:	e5d31004 	ldrb	r1, [r3, #4]
3001d344:	e5d30005 	ldrb	r0, [r3, #5]
3001d348:	e1a00400 	lsl	r0, r0, #8
3001d34c:	e1801001 	orr	r1, r0, r1
3001d350:	e5d30006 	ldrb	r0, [r3, #6]
3001d354:	e1a00800 	lsl	r0, r0, #16
3001d358:	e1801001 	orr	r1, r0, r1
3001d35c:	e5d33007 	ldrb	r3, [r3, #7]
3001d360:	e1a03c03 	lsl	r3, r3, #24
3001d364:	e1833001 	orr	r3, r3, r1
3001d368:	e1a03803 	lsl	r3, r3, #16
3001d36c:	e1a03823 	lsr	r3, r3, #16
3001d370:	e0633002 	rsb	r3, r3, r2
3001d374:	e1a03803 	lsl	r3, r3, #16
3001d378:	e1a02823 	lsr	r2, r3, #16
3001d37c:	e59d300c 	ldr	r3, [sp, #12]
3001d380:	e1c320bc 	strh	r2, [r3, #12]
                    pbuf_realloc(prev->p, prev->len);
3001d384:	e59d300c 	ldr	r3, [sp, #12]
3001d388:	e5932004 	ldr	r2, [r3, #4]
3001d38c:	e59d300c 	ldr	r3, [sp, #12]
3001d390:	e1d330bc 	ldrh	r3, [r3, #12]
3001d394:	e1a00002 	mov	r0, r2
3001d398:	e1a01003 	mov	r1, r3
3001d39c:	ebffe3a0 	bl	30016224 <pbuf_realloc>
                  }
                }
                break;
3001d3a0:	ea00006a 	b	3001d550 <tcp_receive+0x1de4>
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    cseg->next = next;
                    pcb->ooseq = cseg;
                  }
                  break;
3001d3a4:	e1a00000 	nop			; (mov r0, r0)
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
3001d3a8:	e59d3008 	ldr	r3, [sp, #8]
3001d3ac:	e5933000 	ldr	r3, [r3]
3001d3b0:	e3530000 	cmp	r3, #0
3001d3b4:	1a00004d 	bne	3001d4f0 <tcp_receive+0x1d84>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
3001d3b8:	e51f3dc8 	ldr	r3, [pc, #-3528]	; 3001c5f8 <tcp_receive+0xe8c>
3001d3bc:	e5932000 	ldr	r2, [r3]
3001d3c0:	e59d3008 	ldr	r3, [sp, #8]
3001d3c4:	e5933010 	ldr	r3, [r3, #16]
3001d3c8:	e5d31004 	ldrb	r1, [r3, #4]
3001d3cc:	e5d30005 	ldrb	r0, [r3, #5]
3001d3d0:	e1a00400 	lsl	r0, r0, #8
3001d3d4:	e1801001 	orr	r1, r0, r1
3001d3d8:	e5d30006 	ldrb	r0, [r3, #6]
3001d3dc:	e1a00800 	lsl	r0, r0, #16
3001d3e0:	e1801001 	orr	r1, r0, r1
3001d3e4:	e5d33007 	ldrb	r3, [r3, #7]
3001d3e8:	e1a03c03 	lsl	r3, r3, #24
3001d3ec:	e1833001 	orr	r3, r3, r1
3001d3f0:	e0633002 	rsb	r3, r3, r2
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
3001d3f4:	e3530000 	cmp	r3, #0
3001d3f8:	da00003c 	ble	3001d4f0 <tcp_receive+0x1d84>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
3001d3fc:	e51f0e10 	ldr	r0, [pc, #-3600]	; 3001c5f4 <tcp_receive+0xe88>
3001d400:	ebffef08 	bl	30019028 <tcp_seg_copy>
3001d404:	e1a02000 	mov	r2, r0
3001d408:	e59d3008 	ldr	r3, [sp, #8]
3001d40c:	e5832000 	str	r2, [r3]
                if (next->next != NULL) {
3001d410:	e59d3008 	ldr	r3, [sp, #8]
3001d414:	e5933000 	ldr	r3, [r3]
3001d418:	e3530000 	cmp	r3, #0
3001d41c:	0a000048 	beq	3001d544 <tcp_receive+0x1dd8>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
3001d420:	e59d3008 	ldr	r3, [sp, #8]
3001d424:	e5933010 	ldr	r3, [r3, #16]
3001d428:	e5d32004 	ldrb	r2, [r3, #4]
3001d42c:	e5d31005 	ldrb	r1, [r3, #5]
3001d430:	e1a01401 	lsl	r1, r1, #8
3001d434:	e1812002 	orr	r2, r1, r2
3001d438:	e5d31006 	ldrb	r1, [r3, #6]
3001d43c:	e1a01801 	lsl	r1, r1, #16
3001d440:	e1812002 	orr	r2, r1, r2
3001d444:	e5d33007 	ldrb	r3, [r3, #7]
3001d448:	e1a03c03 	lsl	r3, r3, #24
3001d44c:	e1833002 	orr	r3, r3, r2
3001d450:	e1a02003 	mov	r2, r3
3001d454:	e59d3008 	ldr	r3, [sp, #8]
3001d458:	e1d330bc 	ldrh	r3, [r3, #12]
3001d45c:	e0822003 	add	r2, r2, r3
3001d460:	e51f3e70 	ldr	r3, [pc, #-3696]	; 3001c5f8 <tcp_receive+0xe8c>
3001d464:	e5933000 	ldr	r3, [r3]
3001d468:	e0633002 	rsb	r3, r3, r2
3001d46c:	e3530000 	cmp	r3, #0
3001d470:	da000035 	ble	3001d54c <tcp_receive+0x1de0>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
3001d474:	e51f3e84 	ldr	r3, [pc, #-3716]	; 3001c5f8 <tcp_receive+0xe8c>
3001d478:	e5933000 	ldr	r3, [r3]
3001d47c:	e1a03803 	lsl	r3, r3, #16
3001d480:	e1a02823 	lsr	r2, r3, #16
3001d484:	e59d3008 	ldr	r3, [sp, #8]
3001d488:	e5933010 	ldr	r3, [r3, #16]
3001d48c:	e5d31004 	ldrb	r1, [r3, #4]
3001d490:	e5d30005 	ldrb	r0, [r3, #5]
3001d494:	e1a00400 	lsl	r0, r0, #8
3001d498:	e1801001 	orr	r1, r0, r1
3001d49c:	e5d30006 	ldrb	r0, [r3, #6]
3001d4a0:	e1a00800 	lsl	r0, r0, #16
3001d4a4:	e1801001 	orr	r1, r0, r1
3001d4a8:	e5d33007 	ldrb	r3, [r3, #7]
3001d4ac:	e1a03c03 	lsl	r3, r3, #24
3001d4b0:	e1833001 	orr	r3, r3, r1
3001d4b4:	e1a03803 	lsl	r3, r3, #16
3001d4b8:	e1a03823 	lsr	r3, r3, #16
3001d4bc:	e0633002 	rsb	r3, r3, r2
3001d4c0:	e1a03803 	lsl	r3, r3, #16
3001d4c4:	e1a02823 	lsr	r2, r3, #16
3001d4c8:	e59d3008 	ldr	r3, [sp, #8]
3001d4cc:	e1c320bc 	strh	r2, [r3, #12]
                    pbuf_realloc(next->p, next->len);
3001d4d0:	e59d3008 	ldr	r3, [sp, #8]
3001d4d4:	e5932004 	ldr	r2, [r3, #4]
3001d4d8:	e59d3008 	ldr	r3, [sp, #8]
3001d4dc:	e1d330bc 	ldrh	r3, [r3, #12]
3001d4e0:	e1a00002 	mov	r0, r2
3001d4e4:	e1a01003 	mov	r1, r3
3001d4e8:	ebffe34d 	bl	30016224 <pbuf_realloc>
                  }
                }
                break;
3001d4ec:	ea000017 	b	3001d550 <tcp_receive+0x1de4>
              }
            }
            prev = next;
3001d4f0:	e59d3008 	ldr	r3, [sp, #8]
3001d4f4:	e58d300c 	str	r3, [sp, #12]
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
3001d4f8:	e59d3008 	ldr	r3, [sp, #8]
3001d4fc:	e5933000 	ldr	r3, [r3]
3001d500:	e58d3008 	str	r3, [sp, #8]
3001d504:	e59d3008 	ldr	r3, [sp, #8]
3001d508:	e3530000 	cmp	r3, #0
3001d50c:	1afffe4e 	bne	3001ce4c <tcp_receive+0x16e0>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
3001d510:	ea000047 	b	3001d634 <tcp_receive+0x1ec8>
                break;
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
3001d514:	e1a00000 	nop			; (mov r0, r0)
3001d518:	ea00000c 	b	3001d550 <tcp_receive+0x1de4>
                    /* We need to trim the incoming segment. */
                    cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
                    pbuf_realloc(cseg->p, cseg->len);
                  }
                }
                break;
3001d51c:	e1a00000 	nop			; (mov r0, r0)
3001d520:	ea00000a 	b	3001d550 <tcp_receive+0x1de4>
3001d524:	e1a00000 	nop			; (mov r0, r0)
3001d528:	ea000008 	b	3001d550 <tcp_receive+0x1de4>
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    cseg->next = next;
                    pcb->ooseq = cseg;
                  }
                  break;
3001d52c:	e1a00000 	nop			; (mov r0, r0)
3001d530:	ea000006 	b	3001d550 <tcp_receive+0x1de4>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
                    pbuf_realloc(prev->p, prev->len);
                  }
                }
                break;
3001d534:	e1a00000 	nop			; (mov r0, r0)
3001d538:	ea000004 	b	3001d550 <tcp_receive+0x1de4>
3001d53c:	e1a00000 	nop			; (mov r0, r0)
3001d540:	ea000002 	b	3001d550 <tcp_receive+0x1de4>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
                    pbuf_realloc(next->p, next->len);
                  }
                }
                break;
3001d544:	e1a00000 	nop			; (mov r0, r0)
3001d548:	ea000000 	b	3001d550 <tcp_receive+0x1de4>
3001d54c:	e1a00000 	nop			; (mov r0, r0)
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
3001d550:	e1a00000 	nop			; (mov r0, r0)
3001d554:	ea000036 	b	3001d634 <tcp_receive+0x1ec8>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
3001d558:	e51f3f68 	ldr	r3, [pc, #-3944]	; 3001c5f8 <tcp_receive+0xe8c>
3001d55c:	e5932000 	ldr	r2, [r3]
3001d560:	e59d3004 	ldr	r3, [sp, #4]
3001d564:	e5933020 	ldr	r3, [r3, #32]
3001d568:	e0633002 	rsb	r3, r3, r2
3001d56c:	e3530000 	cmp	r3, #0
3001d570:	ba00000a 	blt	3001d5a0 <tcp_receive+0x1e34>
3001d574:	e51f3f84 	ldr	r3, [pc, #-3972]	; 3001c5f8 <tcp_receive+0xe8c>
3001d578:	e5932000 	ldr	r2, [r3]
3001d57c:	e59d3004 	ldr	r3, [sp, #4]
3001d580:	e5931020 	ldr	r1, [r3, #32]
3001d584:	e59d3004 	ldr	r3, [sp, #4]
3001d588:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
3001d58c:	e0813003 	add	r3, r1, r3
3001d590:	e0633002 	rsb	r3, r3, r2
3001d594:	e2833001 	add	r3, r3, #1
3001d598:	e3530000 	cmp	r3, #0
3001d59c:	da000023 	ble	3001d630 <tcp_receive+0x1ec4>
                          pcb->rcv_nxt + pcb->rcv_ann_wnd-1)){
        tcp_ack_now(pcb);
3001d5a0:	e59d3004 	ldr	r3, [sp, #4]
3001d5a4:	e5d3301c 	ldrb	r3, [r3, #28]
3001d5a8:	e3833002 	orr	r3, r3, #2
3001d5ac:	e20320ff 	and	r2, r3, #255	; 0xff
3001d5b0:	e59d3004 	ldr	r3, [sp, #4]
3001d5b4:	e5c3201c 	strb	r2, [r3, #28]
3001d5b8:	e59d0004 	ldr	r0, [sp, #4]
3001d5bc:	eb000330 	bl	3001e284 <tcp_output>
3001d5c0:	ea00001b 	b	3001d634 <tcp_receive+0x1ec8>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
3001d5c4:	e59f307c 	ldr	r3, [pc, #124]	; 3001d648 <tcp_receive+0x1edc>
3001d5c8:	e5932000 	ldr	r2, [r3]
3001d5cc:	e59d3004 	ldr	r3, [sp, #4]
3001d5d0:	e5933020 	ldr	r3, [r3, #32]
3001d5d4:	e0633002 	rsb	r3, r3, r2
3001d5d8:	e3530000 	cmp	r3, #0
3001d5dc:	ba00000a 	blt	3001d60c <tcp_receive+0x1ea0>
3001d5e0:	e59f3060 	ldr	r3, [pc, #96]	; 3001d648 <tcp_receive+0x1edc>
3001d5e4:	e5932000 	ldr	r2, [r3]
3001d5e8:	e59d3004 	ldr	r3, [sp, #4]
3001d5ec:	e5931020 	ldr	r1, [r3, #32]
3001d5f0:	e59d3004 	ldr	r3, [sp, #4]
3001d5f4:	e1d332b4 	ldrh	r3, [r3, #36]	; 0x24
3001d5f8:	e0813003 	add	r3, r1, r3
3001d5fc:	e0633002 	rsb	r3, r3, r2
3001d600:	e2833001 	add	r3, r3, #1
3001d604:	e3530000 	cmp	r3, #0
3001d608:	da000009 	ble	3001d634 <tcp_receive+0x1ec8>
      tcp_ack_now(pcb);
3001d60c:	e59d3004 	ldr	r3, [sp, #4]
3001d610:	e5d3301c 	ldrb	r3, [r3, #28]
3001d614:	e3833002 	orr	r3, r3, #2
3001d618:	e20320ff 	and	r2, r3, #255	; 0xff
3001d61c:	e59d3004 	ldr	r3, [sp, #4]
3001d620:	e5c3201c 	strb	r2, [r3, #28]
3001d624:	e59d0004 	ldr	r0, [sp, #4]
3001d628:	eb000315 	bl	3001e284 <tcp_output>
3001d62c:	ea000000 	b	3001d634 <tcp_receive+0x1ec8>

      }
    } else {
      if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                          pcb->rcv_nxt + pcb->rcv_ann_wnd-1)){
        tcp_ack_now(pcb);
3001d630:	e1a00000 	nop			; (mov r0, r0)
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
  return accepted_inseq;
3001d634:	e5dd3029 	ldrb	r3, [sp, #41]	; 0x29
}
3001d638:	e1a00003 	mov	r0, r3
3001d63c:	e28dd030 	add	sp, sp, #48	; 0x30
3001d640:	e8bd4070 	pop	{r4, r5, r6, lr}
3001d644:	e12fff1e 	bx	lr
3001d648:	30028f78 	.word	0x30028f78

3001d64c <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
3001d64c:	e92d4010 	push	{r4, lr}
3001d650:	e24dd018 	sub	sp, sp, #24
3001d654:	e58d0004 	str	r0, [sp, #4]
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
3001d658:	e59f31c0 	ldr	r3, [pc, #448]	; 3001d820 <tcp_parseopt+0x1d4>
3001d65c:	e5933000 	ldr	r3, [r3]
3001d660:	e2833014 	add	r3, r3, #20
3001d664:	e58d3010 	str	r3, [sp, #16]

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
3001d668:	e59f31b0 	ldr	r3, [pc, #432]	; 3001d820 <tcp_parseopt+0x1d4>
3001d66c:	e5933000 	ldr	r3, [r3]
3001d670:	e5d3200c 	ldrb	r2, [r3, #12]
3001d674:	e5d3300d 	ldrb	r3, [r3, #13]
3001d678:	e1a03403 	lsl	r3, r3, #8
3001d67c:	e1833002 	orr	r3, r3, r2
3001d680:	e1a03803 	lsl	r3, r3, #16
3001d684:	e1a03823 	lsr	r3, r3, #16
3001d688:	e1a00003 	mov	r0, r3
3001d68c:	ebffd89d 	bl	30013908 <ntohs>
3001d690:	e1a03000 	mov	r3, r0
3001d694:	e1a03623 	lsr	r3, r3, #12
3001d698:	e1a03803 	lsl	r3, r3, #16
3001d69c:	e1a03823 	lsr	r3, r3, #16
3001d6a0:	e3530005 	cmp	r3, #5
3001d6a4:	9a00005a 	bls	3001d814 <tcp_parseopt+0x1c8>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
3001d6a8:	e3a03000 	mov	r3, #0
3001d6ac:	e5cd300f 	strb	r3, [sp, #15]
3001d6b0:	ea000040 	b	3001d7b8 <tcp_parseopt+0x16c>
      opt = opts[c];
3001d6b4:	e5dd200f 	ldrb	r2, [sp, #15]
3001d6b8:	e59d3010 	ldr	r3, [sp, #16]
3001d6bc:	e0823003 	add	r3, r2, r3
3001d6c0:	e5d33000 	ldrb	r3, [r3]
3001d6c4:	e5cd3015 	strb	r3, [sp, #21]
      if (opt == 0x00) {
3001d6c8:	e5dd3015 	ldrb	r3, [sp, #21]
3001d6cc:	e3530000 	cmp	r3, #0
3001d6d0:	0a00004c 	beq	3001d808 <tcp_parseopt+0x1bc>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
3001d6d4:	e5dd3015 	ldrb	r3, [sp, #21]
3001d6d8:	e3530001 	cmp	r3, #1
3001d6dc:	1a000003 	bne	3001d6f0 <tcp_parseopt+0xa4>
        ++c;
3001d6e0:	e5dd300f 	ldrb	r3, [sp, #15]
3001d6e4:	e2833001 	add	r3, r3, #1
3001d6e8:	e5cd300f 	strb	r3, [sp, #15]
3001d6ec:	ea000031 	b	3001d7b8 <tcp_parseopt+0x16c>
        /* NOP option. */
      } else if (opt == 0x02 &&
3001d6f0:	e5dd3015 	ldrb	r3, [sp, #21]
3001d6f4:	e3530002 	cmp	r3, #2
3001d6f8:	1a00001f 	bne	3001d77c <tcp_parseopt+0x130>
        opts[c + 1] == 0x04) {
3001d6fc:	e5dd300f 	ldrb	r3, [sp, #15]
3001d700:	e2832001 	add	r2, r3, #1
3001d704:	e59d3010 	ldr	r3, [sp, #16]
3001d708:	e0823003 	add	r3, r2, r3
3001d70c:	e5d33000 	ldrb	r3, [r3]
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
        /* NOP option. */
      } else if (opt == 0x02 &&
3001d710:	e3530004 	cmp	r3, #4
3001d714:	1a000018 	bne	3001d77c <tcp_parseopt+0x130>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
3001d718:	e5dd300f 	ldrb	r3, [sp, #15]
3001d71c:	e2832002 	add	r2, r3, #2
3001d720:	e59d3010 	ldr	r3, [sp, #16]
3001d724:	e0823003 	add	r3, r2, r3
3001d728:	e5d33000 	ldrb	r3, [r3]
3001d72c:	e1a03403 	lsl	r3, r3, #8
3001d730:	e1a03803 	lsl	r3, r3, #16
3001d734:	e1a02823 	lsr	r2, r3, #16
3001d738:	e5dd300f 	ldrb	r3, [sp, #15]
3001d73c:	e2831003 	add	r1, r3, #3
3001d740:	e59d3010 	ldr	r3, [sp, #16]
3001d744:	e0813003 	add	r3, r1, r3
3001d748:	e5d33000 	ldrb	r3, [r3]
3001d74c:	e1823003 	orr	r3, r2, r3
3001d750:	e1a03803 	lsl	r3, r3, #16
3001d754:	e1a03823 	lsr	r3, r3, #16
3001d758:	e1cd31b6 	strh	r3, [sp, #22]
        pcb->mss = mss > TCP_MSS? TCP_MSS: mss;
3001d75c:	e1dd31b6 	ldrh	r3, [sp, #22]
3001d760:	e3530080 	cmp	r3, #128	; 0x80
3001d764:	23a03080 	movcs	r3, #128	; 0x80
3001d768:	e1a03803 	lsl	r3, r3, #16
3001d76c:	e1a02823 	lsr	r2, r3, #16
3001d770:	e59d3004 	ldr	r3, [sp, #4]
3001d774:	e1c323b0 	strh	r2, [r3, #48]	; 0x30

        /* And we are done processing options. */
        break;
3001d778:	ea000025 	b	3001d814 <tcp_parseopt+0x1c8>
      } else {
        if (opts[c + 1] == 0) {
3001d77c:	e5dd300f 	ldrb	r3, [sp, #15]
3001d780:	e2832001 	add	r2, r3, #1
3001d784:	e59d3010 	ldr	r3, [sp, #16]
3001d788:	e0823003 	add	r3, r2, r3
3001d78c:	e5d33000 	ldrb	r3, [r3]
3001d790:	e3530000 	cmp	r3, #0
3001d794:	0a00001d 	beq	3001d810 <tcp_parseopt+0x1c4>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
3001d798:	e5dd300f 	ldrb	r3, [sp, #15]
3001d79c:	e2832001 	add	r2, r3, #1
3001d7a0:	e59d3010 	ldr	r3, [sp, #16]
3001d7a4:	e0823003 	add	r3, r2, r3
3001d7a8:	e5d32000 	ldrb	r2, [r3]
3001d7ac:	e5dd300f 	ldrb	r3, [sp, #15]
3001d7b0:	e0823003 	add	r3, r2, r3
3001d7b4:	e5cd300f 	strb	r3, [sp, #15]

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
3001d7b8:	e5dd400f 	ldrb	r4, [sp, #15]
3001d7bc:	e59f305c 	ldr	r3, [pc, #92]	; 3001d820 <tcp_parseopt+0x1d4>
3001d7c0:	e5933000 	ldr	r3, [r3]
3001d7c4:	e5d3200c 	ldrb	r2, [r3, #12]
3001d7c8:	e5d3300d 	ldrb	r3, [r3, #13]
3001d7cc:	e1a03403 	lsl	r3, r3, #8
3001d7d0:	e1833002 	orr	r3, r3, r2
3001d7d4:	e1a03803 	lsl	r3, r3, #16
3001d7d8:	e1a03823 	lsr	r3, r3, #16
3001d7dc:	e1a00003 	mov	r0, r3
3001d7e0:	ebffd848 	bl	30013908 <ntohs>
3001d7e4:	e1a03000 	mov	r3, r0
3001d7e8:	e1a03623 	lsr	r3, r3, #12
3001d7ec:	e1a03803 	lsl	r3, r3, #16
3001d7f0:	e1a03823 	lsr	r3, r3, #16
3001d7f4:	e2433005 	sub	r3, r3, #5
3001d7f8:	e1a03103 	lsl	r3, r3, #2
3001d7fc:	e1540003 	cmp	r4, r3
3001d800:	baffffab 	blt	3001d6b4 <tcp_parseopt+0x68>
3001d804:	ea000002 	b	3001d814 <tcp_parseopt+0x1c8>
      opt = opts[c];
      if (opt == 0x00) {
        /* End of options. */
        break;
3001d808:	e1a00000 	nop			; (mov r0, r0)
3001d80c:	ea000000 	b	3001d814 <tcp_parseopt+0x1c8>
        break;
      } else {
        if (opts[c + 1] == 0) {
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          break;
3001d810:	e1a00000 	nop			; (mov r0, r0)
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
3001d814:	e28dd018 	add	sp, sp, #24
3001d818:	e8bd4010 	pop	{r4, lr}
3001d81c:	e12fff1e 	bx	lr
3001d820:	30028f70 	.word	0x30028f70

3001d824 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
3001d824:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001d828:	e24dd01c 	sub	sp, sp, #28
3001d82c:	e58d0014 	str	r0, [sp, #20]
3001d830:	e1a03001 	mov	r3, r1
3001d834:	e5cd3013 	strb	r3, [sp, #19]
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
3001d838:	e5dd3013 	ldrb	r3, [sp, #19]
3001d83c:	e3a02001 	mov	r2, #1
3001d840:	e58d2000 	str	r2, [sp]
3001d844:	e3a02000 	mov	r2, #0
3001d848:	e58d2004 	str	r2, [sp, #4]
3001d84c:	e3a02000 	mov	r2, #0
3001d850:	e58d2008 	str	r2, [sp, #8]
3001d854:	e59d0014 	ldr	r0, [sp, #20]
3001d858:	e3a01000 	mov	r1, #0
3001d85c:	e3a02000 	mov	r2, #0
3001d860:	eb00003a 	bl	3001d950 <tcp_enqueue>
3001d864:	e1a03000 	mov	r3, r0
3001d868:	e20330ff 	and	r3, r3, #255	; 0xff
3001d86c:	e20330ff 	and	r3, r3, #255	; 0xff
3001d870:	e1a03c03 	lsl	r3, r3, #24
3001d874:	e1a03c43 	asr	r3, r3, #24
}
3001d878:	e1a00003 	mov	r0, r3
3001d87c:	e28dd01c 	add	sp, sp, #28
3001d880:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001d884:	e12fff1e 	bx	lr

3001d888 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
3001d888:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001d88c:	e24dd024 	sub	sp, sp, #36	; 0x24
3001d890:	e58d001c 	str	r0, [sp, #28]
3001d894:	e58d1018 	str	r1, [sp, #24]
3001d898:	e1cd21b6 	strh	r2, [sp, #22]
3001d89c:	e5cd3015 	strb	r3, [sp, #21]
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
3001d8a0:	e59d301c 	ldr	r3, [sp, #28]
3001d8a4:	e5d33010 	ldrb	r3, [r3, #16]
3001d8a8:	e3530004 	cmp	r3, #4
3001d8ac:	0a00000b 	beq	3001d8e0 <tcp_write+0x58>
     pcb->state == CLOSE_WAIT ||
3001d8b0:	e59d301c 	ldr	r3, [sp, #28]
3001d8b4:	e5d33010 	ldrb	r3, [r3, #16]
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
3001d8b8:	e3530007 	cmp	r3, #7
3001d8bc:	0a000007 	beq	3001d8e0 <tcp_write+0x58>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
3001d8c0:	e59d301c 	ldr	r3, [sp, #28]
3001d8c4:	e5d33010 	ldrb	r3, [r3, #16]
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
3001d8c8:	e3530002 	cmp	r3, #2
3001d8cc:	0a000003 	beq	3001d8e0 <tcp_write+0x58>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
3001d8d0:	e59d301c 	ldr	r3, [sp, #28]
3001d8d4:	e5d33010 	ldrb	r3, [r3, #16]
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
3001d8d8:	e3530003 	cmp	r3, #3
3001d8dc:	1a000014 	bne	3001d934 <tcp_write+0xac>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
3001d8e0:	e1dd31b6 	ldrh	r3, [sp, #22]
3001d8e4:	e3530000 	cmp	r3, #0
3001d8e8:	0a00000f 	beq	3001d92c <tcp_write+0xa4>
      //acoral_prints("\r\ntcp_write\r\n");
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
3001d8ec:	e1dd31b6 	ldrh	r3, [sp, #22]
3001d8f0:	e5dd2015 	ldrb	r2, [sp, #21]
3001d8f4:	e58d2000 	str	r2, [sp]
3001d8f8:	e3a02000 	mov	r2, #0
3001d8fc:	e58d2004 	str	r2, [sp, #4]
3001d900:	e3a02000 	mov	r2, #0
3001d904:	e58d2008 	str	r2, [sp, #8]
3001d908:	e59d001c 	ldr	r0, [sp, #28]
3001d90c:	e59d1018 	ldr	r1, [sp, #24]
3001d910:	e1a02003 	mov	r2, r3
3001d914:	e3a03000 	mov	r3, #0
3001d918:	eb00000c 	bl	3001d950 <tcp_enqueue>
3001d91c:	e1a03000 	mov	r3, r0
3001d920:	e20330ff 	and	r3, r3, #255	; 0xff
3001d924:	e20330ff 	and	r3, r3, #255	; 0xff
3001d928:	ea000002 	b	3001d938 <tcp_write+0xb0>
    }
    return ERR_OK;
3001d92c:	e3a03000 	mov	r3, #0
3001d930:	ea000000 	b	3001d938 <tcp_write+0xb0>
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
3001d934:	e3a030f9 	mov	r3, #249	; 0xf9
3001d938:	e1a03c03 	lsl	r3, r3, #24
3001d93c:	e1a03c43 	asr	r3, r3, #24
  }
}
3001d940:	e1a00003 	mov	r0, r3
3001d944:	e28dd024 	add	sp, sp, #36	; 0x24
3001d948:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001d94c:	e12fff1e 	bx	lr

3001d950 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
3001d950:	e92d4030 	push	{r4, r5, lr}
3001d954:	e24dd034 	sub	sp, sp, #52	; 0x34
3001d958:	e58d000c 	str	r0, [sp, #12]
3001d95c:	e58d1008 	str	r1, [sp, #8]
3001d960:	e1cd20b6 	strh	r2, [sp, #6]
3001d964:	e5cd3005 	strb	r3, [sp, #5]
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
3001d968:	e59d300c 	ldr	r3, [sp, #12]
3001d96c:	e1d336ba 	ldrh	r3, [r3, #106]	; 0x6a
3001d970:	e1dd20b6 	ldrh	r2, [sp, #6]
3001d974:	e1520003 	cmp	r2, r3
3001d978:	9a000008 	bls	3001d9a0 <tcp_enqueue+0x50>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
3001d97c:	e59d300c 	ldr	r3, [sp, #12]
3001d980:	e5d3301c 	ldrb	r3, [r3, #28]
3001d984:	e1e03c83 	mvn	r3, r3, lsl #25
3001d988:	e1e03ca3 	mvn	r3, r3, lsr #25
3001d98c:	e20320ff 	and	r2, r3, #255	; 0xff
3001d990:	e59d300c 	ldr	r3, [sp, #12]
3001d994:	e5c3201c 	strb	r2, [r3, #28]
    return ERR_MEM;
3001d998:	e3a030ff 	mov	r3, #255	; 0xff
3001d99c:	ea000231 	b	3001e268 <tcp_enqueue+0x918>
  }
  left = len;
3001d9a0:	e1dd30b6 	ldrh	r3, [sp, #6]
3001d9a4:	e1cd32b4 	strh	r3, [sp, #36]	; 0x24
  ptr = arg;
3001d9a8:	e59d3008 	ldr	r3, [sp, #8]
3001d9ac:	e58d3028 	str	r3, [sp, #40]	; 0x28

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
3001d9b0:	e59d300c 	ldr	r3, [sp, #12]
3001d9b4:	e5933064 	ldr	r3, [r3, #100]	; 0x64
3001d9b8:	e58d3020 	str	r3, [sp, #32]

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
3001d9bc:	e59d300c 	ldr	r3, [sp, #12]
3001d9c0:	e1d336bc 	ldrh	r3, [r3, #108]	; 0x6c
3001d9c4:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
3001d9c8:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3001d9cc:	e3530007 	cmp	r3, #7
3001d9d0:	8a000004 	bhi	3001d9e8 <tcp_enqueue+0x98>
3001d9d4:	e1dd22be 	ldrh	r2, [sp, #46]	; 0x2e
3001d9d8:	e3a03cff 	mov	r3, #65280	; 0xff00
3001d9dc:	e28330fc 	add	r3, r3, #252	; 0xfc
3001d9e0:	e1520003 	cmp	r2, r3
3001d9e4:	9a00000f 	bls	3001da28 <tcp_enqueue+0xd8>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
3001d9e8:	e59f3890 	ldr	r3, [pc, #2192]	; 3001e280 <tcp_enqueue+0x930>
3001d9ec:	e1d33aba 	ldrh	r3, [r3, #170]	; 0xaa
3001d9f0:	e2833001 	add	r3, r3, #1
3001d9f4:	e1a03803 	lsl	r3, r3, #16
3001d9f8:	e1a02823 	lsr	r2, r3, #16
3001d9fc:	e59f387c 	ldr	r3, [pc, #2172]	; 3001e280 <tcp_enqueue+0x930>
3001da00:	e1c32aba 	strh	r2, [r3, #170]	; 0xaa
    pcb->flags |= TF_NAGLEMEMERR;
3001da04:	e59d300c 	ldr	r3, [sp, #12]
3001da08:	e5d3301c 	ldrb	r3, [r3, #28]
3001da0c:	e1e03c83 	mvn	r3, r3, lsl #25
3001da10:	e1e03ca3 	mvn	r3, r3, lsr #25
3001da14:	e20320ff 	and	r2, r3, #255	; 0xff
3001da18:	e59d300c 	ldr	r3, [sp, #12]
3001da1c:	e5c3201c 	strb	r2, [r3, #28]
    return ERR_MEM;
3001da20:	e3a030ff 	mov	r3, #255	; 0xff
3001da24:	ea00020f 	b	3001e268 <tcp_enqueue+0x918>
      pcb->unacked == NULL && pcb->unsent == NULL);
  }

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
3001da28:	e3a03000 	mov	r3, #0
3001da2c:	e58d3014 	str	r3, [sp, #20]
3001da30:	e59d3014 	ldr	r3, [sp, #20]
3001da34:	e58d301c 	str	r3, [sp, #28]
3001da38:	e59d301c 	ldr	r3, [sp, #28]
3001da3c:	e58d3018 	str	r3, [sp, #24]
  seglen = 0;
3001da40:	e3a03000 	mov	r3, #0
3001da44:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
  while (queue == NULL || left > 0) {
3001da48:	ea000174 	b	3001e020 <tcp_enqueue+0x6d0>

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
3001da4c:	e59d300c 	ldr	r3, [sp, #12]
3001da50:	e1d323b0 	ldrh	r2, [r3, #48]	; 0x30
3001da54:	e1dd32b4 	ldrh	r3, [sp, #36]	; 0x24
3001da58:	e1520003 	cmp	r2, r3
3001da5c:	31a03002 	movcc	r3, r2
3001da60:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
3001da64:	e3a00004 	mov	r0, #4
3001da68:	ebffdee0 	bl	300155f0 <memp_malloc>
3001da6c:	e1a03000 	mov	r3, r0
3001da70:	e58d3014 	str	r3, [sp, #20]
    if (seg == NULL) {
3001da74:	e59d3014 	ldr	r3, [sp, #20]
3001da78:	e3530000 	cmp	r3, #0
3001da7c:	0a0001de 	beq	3001e1fc <tcp_enqueue+0x8ac>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
3001da80:	e59d3014 	ldr	r3, [sp, #20]
3001da84:	e3a02000 	mov	r2, #0
3001da88:	e5832000 	str	r2, [r3]
    seg->p = NULL;
3001da8c:	e59d3014 	ldr	r3, [sp, #20]
3001da90:	e3a02000 	mov	r2, #0
3001da94:	e5832004 	str	r2, [r3, #4]

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
3001da98:	e59d301c 	ldr	r3, [sp, #28]
3001da9c:	e3530000 	cmp	r3, #0
3001daa0:	1a000002 	bne	3001dab0 <tcp_enqueue+0x160>
      queue = seg;
3001daa4:	e59d3014 	ldr	r3, [sp, #20]
3001daa8:	e58d301c 	str	r3, [sp, #28]
3001daac:	ea000002 	b	3001dabc <tcp_enqueue+0x16c>
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
      useg->next = seg;
3001dab0:	e59d3018 	ldr	r3, [sp, #24]
3001dab4:	e59d2014 	ldr	r2, [sp, #20]
3001dab8:	e5832000 	str	r2, [r3]
    }
    /* remember last segment of to-be-queued data for next iteration */
    useg = seg;
3001dabc:	e59d3014 	ldr	r3, [sp, #20]
3001dac0:	e58d3018 	str	r3, [sp, #24]
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
3001dac4:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
3001dac8:	e3530000 	cmp	r3, #0
3001dacc:	0a00001a 	beq	3001db3c <tcp_enqueue+0x1ec>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
3001dad0:	e5dd3048 	ldrb	r3, [sp, #72]	; 0x48
3001dad4:	e3a00000 	mov	r0, #0
3001dad8:	e1a01003 	mov	r1, r3
3001dadc:	e3a02000 	mov	r2, #0
3001dae0:	ebffe0e3 	bl	30015e74 <pbuf_alloc>
3001dae4:	e1a02000 	mov	r2, r0
3001dae8:	e59d3014 	ldr	r3, [sp, #20]
3001daec:	e5832004 	str	r2, [r3, #4]
3001daf0:	e59d3014 	ldr	r3, [sp, #20]
3001daf4:	e5933004 	ldr	r3, [r3, #4]
3001daf8:	e3530000 	cmp	r3, #0
3001dafc:	0a0001c0 	beq	3001e204 <tcp_enqueue+0x8b4>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
3001db00:	e59d3014 	ldr	r3, [sp, #20]
3001db04:	e5933004 	ldr	r3, [r3, #4]
3001db08:	e1a00003 	mov	r0, r3
3001db0c:	ebffe2cd 	bl	30016648 <pbuf_clen>
3001db10:	e1a03000 	mov	r3, r0
3001db14:	e1a02003 	mov	r2, r3
3001db18:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3001db1c:	e0823003 	add	r3, r2, r3
3001db20:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
      seg->dataptr = seg->p->payload;
3001db24:	e59d3014 	ldr	r3, [sp, #20]
3001db28:	e5933004 	ldr	r3, [r3, #4]
3001db2c:	e5932004 	ldr	r2, [r3, #4]
3001db30:	e59d3014 	ldr	r3, [sp, #20]
3001db34:	e5832008 	str	r2, [r3, #8]
3001db38:	ea00005b 	b	3001dcac <tcp_enqueue+0x35c>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
3001db3c:	e5dd3040 	ldrb	r3, [sp, #64]	; 0x40
3001db40:	e2033001 	and	r3, r3, #1
3001db44:	e20330ff 	and	r3, r3, #255	; 0xff
3001db48:	e3530000 	cmp	r3, #0
3001db4c:	0a000025 	beq	3001dbe8 <tcp_enqueue+0x298>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
3001db50:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3001db54:	e3a00000 	mov	r0, #0
3001db58:	e1a01003 	mov	r1, r3
3001db5c:	e3a02000 	mov	r2, #0
3001db60:	ebffe0c3 	bl	30015e74 <pbuf_alloc>
3001db64:	e1a02000 	mov	r2, r0
3001db68:	e59d3014 	ldr	r3, [sp, #20]
3001db6c:	e5832004 	str	r2, [r3, #4]
3001db70:	e59d3014 	ldr	r3, [sp, #20]
3001db74:	e5933004 	ldr	r3, [r3, #4]
3001db78:	e3530000 	cmp	r3, #0
3001db7c:	0a0001a2 	beq	3001e20c <tcp_enqueue+0x8bc>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
3001db80:	e59d3014 	ldr	r3, [sp, #20]
3001db84:	e5933004 	ldr	r3, [r3, #4]
3001db88:	e1a00003 	mov	r0, r3
3001db8c:	ebffe2ad 	bl	30016648 <pbuf_clen>
3001db90:	e1a03000 	mov	r3, r0
3001db94:	e1a02003 	mov	r2, r3
3001db98:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3001db9c:	e0823003 	add	r3, r2, r3
3001dba0:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
      if (arg != NULL) {
3001dba4:	e59d3008 	ldr	r3, [sp, #8]
3001dba8:	e3530000 	cmp	r3, #0
3001dbac:	0a000007 	beq	3001dbd0 <tcp_enqueue+0x280>
        MEMCPY(seg->p->payload, ptr, seglen);
3001dbb0:	e59d3014 	ldr	r3, [sp, #20]
3001dbb4:	e5933004 	ldr	r3, [r3, #4]
3001dbb8:	e5932004 	ldr	r2, [r3, #4]
3001dbbc:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3001dbc0:	e1a00002 	mov	r0, r2
3001dbc4:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3001dbc8:	e1a02003 	mov	r2, r3
3001dbcc:	ebffbcde 	bl	3000cf4c <__re_memcpy>
      }
      seg->dataptr = seg->p->payload;
3001dbd0:	e59d3014 	ldr	r3, [sp, #20]
3001dbd4:	e5933004 	ldr	r3, [r3, #4]
3001dbd8:	e5932004 	ldr	r2, [r3, #4]
3001dbdc:	e59d3014 	ldr	r3, [sp, #20]
3001dbe0:	e5832008 	str	r2, [r3, #8]
3001dbe4:	ea000030 	b	3001dcac <tcp_enqueue+0x35c>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
3001dbe8:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3001dbec:	e3a00000 	mov	r0, #0
3001dbf0:	e1a01003 	mov	r1, r3
3001dbf4:	e3a02001 	mov	r2, #1
3001dbf8:	ebffe09d 	bl	30015e74 <pbuf_alloc>
3001dbfc:	e1a03000 	mov	r3, r0
3001dc00:	e58d3010 	str	r3, [sp, #16]
3001dc04:	e59d3010 	ldr	r3, [sp, #16]
3001dc08:	e3530000 	cmp	r3, #0
3001dc0c:	0a000180 	beq	3001e214 <tcp_enqueue+0x8c4>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
3001dc10:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3001dc14:	e2833001 	add	r3, r3, #1
3001dc18:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
      /* reference the non-volatile payload data */
      p->payload = ptr;
3001dc1c:	e59d3010 	ldr	r3, [sp, #16]
3001dc20:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
3001dc24:	e5832004 	str	r2, [r3, #4]
      seg->dataptr = ptr;
3001dc28:	e59d3014 	ldr	r3, [sp, #20]
3001dc2c:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
3001dc30:	e5832008 	str	r2, [r3, #8]

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
3001dc34:	e3a00000 	mov	r0, #0
3001dc38:	e3a01000 	mov	r1, #0
3001dc3c:	e3a02000 	mov	r2, #0
3001dc40:	ebffe08b 	bl	30015e74 <pbuf_alloc>
3001dc44:	e1a02000 	mov	r2, r0
3001dc48:	e59d3014 	ldr	r3, [sp, #20]
3001dc4c:	e5832004 	str	r2, [r3, #4]
3001dc50:	e59d3014 	ldr	r3, [sp, #20]
3001dc54:	e5933004 	ldr	r3, [r3, #4]
3001dc58:	e3530000 	cmp	r3, #0
3001dc5c:	1a000002 	bne	3001dc6c <tcp_enqueue+0x31c>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
3001dc60:	e59d0010 	ldr	r0, [sp, #16]
3001dc64:	ebffe231 	bl	30016530 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
3001dc68:	ea00016a 	b	3001e218 <tcp_enqueue+0x8c8>
      }
      queuelen += pbuf_clen(seg->p);
3001dc6c:	e59d3014 	ldr	r3, [sp, #20]
3001dc70:	e5933004 	ldr	r3, [r3, #4]
3001dc74:	e1a00003 	mov	r0, r3
3001dc78:	ebffe272 	bl	30016648 <pbuf_clen>
3001dc7c:	e1a03000 	mov	r3, r0
3001dc80:	e1a02003 	mov	r2, r3
3001dc84:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3001dc88:	e0823003 	add	r3, r2, r3
3001dc8c:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
3001dc90:	e59d3014 	ldr	r3, [sp, #20]
3001dc94:	e5933004 	ldr	r3, [r3, #4]
3001dc98:	e1a00003 	mov	r0, r3
3001dc9c:	e59d1010 	ldr	r1, [sp, #16]
3001dca0:	ebffe28f 	bl	300166e4 <pbuf_cat>
      p = NULL;
3001dca4:	e3a03000 	mov	r3, #0
3001dca8:	e58d3010 	str	r3, [sp, #16]
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
3001dcac:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3001dcb0:	e3530008 	cmp	r3, #8
3001dcb4:	8a000157 	bhi	3001e218 <tcp_enqueue+0x8c8>
3001dcb8:	e1dd22be 	ldrh	r2, [sp, #46]	; 0x2e
3001dcbc:	e3a03cff 	mov	r3, #65280	; 0xff00
3001dcc0:	e28330fc 	add	r3, r3, #252	; 0xfc
3001dcc4:	e1520003 	cmp	r2, r3
3001dcc8:	8a000152 	bhi	3001e218 <tcp_enqueue+0x8c8>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
3001dccc:	e59d3014 	ldr	r3, [sp, #20]
3001dcd0:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
3001dcd4:	e1c320bc 	strh	r2, [r3, #12]

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
3001dcd8:	e59d3014 	ldr	r3, [sp, #20]
3001dcdc:	e5933004 	ldr	r3, [r3, #4]
3001dce0:	e1a00003 	mov	r0, r3
3001dce4:	e3a01014 	mov	r1, #20
3001dce8:	ebffe1ab 	bl	3001639c <pbuf_header>
3001dcec:	e1a03000 	mov	r3, r0
3001dcf0:	e3530000 	cmp	r3, #0
3001dcf4:	0a000007 	beq	3001dd18 <tcp_enqueue+0x3c8>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
3001dcf8:	e59f3580 	ldr	r3, [pc, #1408]	; 3001e280 <tcp_enqueue+0x930>
3001dcfc:	e1d33bb2 	ldrh	r3, [r3, #178]	; 0xb2
3001dd00:	e2833001 	add	r3, r3, #1
3001dd04:	e1a03803 	lsl	r3, r3, #16
3001dd08:	e1a02823 	lsr	r2, r3, #16
3001dd0c:	e59f356c 	ldr	r3, [pc, #1388]	; 3001e280 <tcp_enqueue+0x930>
3001dd10:	e1c32bb2 	strh	r2, [r3, #178]	; 0xb2
      goto memerr;
3001dd14:	ea00013f 	b	3001e218 <tcp_enqueue+0x8c8>
    }
    seg->tcphdr = seg->p->payload;
3001dd18:	e59d3014 	ldr	r3, [sp, #20]
3001dd1c:	e5933004 	ldr	r3, [r3, #4]
3001dd20:	e5933004 	ldr	r3, [r3, #4]
3001dd24:	e1a02003 	mov	r2, r3
3001dd28:	e59d3014 	ldr	r3, [sp, #20]
3001dd2c:	e5832010 	str	r2, [r3, #16]
    seg->tcphdr->src = htons(pcb->local_port);
3001dd30:	e59d3014 	ldr	r3, [sp, #20]
3001dd34:	e5934010 	ldr	r4, [r3, #16]
3001dd38:	e59d300c 	ldr	r3, [sp, #12]
3001dd3c:	e1d331b8 	ldrh	r3, [r3, #24]
3001dd40:	e1a00003 	mov	r0, r3
3001dd44:	ebffd6dc 	bl	300138bc <htons>
3001dd48:	e1a03000 	mov	r3, r0
3001dd4c:	e20320ff 	and	r2, r3, #255	; 0xff
3001dd50:	e3a01000 	mov	r1, #0
3001dd54:	e1812002 	orr	r2, r1, r2
3001dd58:	e5c42000 	strb	r2, [r4]
3001dd5c:	e1a03423 	lsr	r3, r3, #8
3001dd60:	e1a03803 	lsl	r3, r3, #16
3001dd64:	e1a03823 	lsr	r3, r3, #16
3001dd68:	e3a02000 	mov	r2, #0
3001dd6c:	e1823003 	orr	r3, r2, r3
3001dd70:	e5c43001 	strb	r3, [r4, #1]
    seg->tcphdr->dest = htons(pcb->remote_port);
3001dd74:	e59d3014 	ldr	r3, [sp, #20]
3001dd78:	e5934010 	ldr	r4, [r3, #16]
3001dd7c:	e59d300c 	ldr	r3, [sp, #12]
3001dd80:	e1d331ba 	ldrh	r3, [r3, #26]
3001dd84:	e1a00003 	mov	r0, r3
3001dd88:	ebffd6cb 	bl	300138bc <htons>
3001dd8c:	e1a03000 	mov	r3, r0
3001dd90:	e20320ff 	and	r2, r3, #255	; 0xff
3001dd94:	e3a01000 	mov	r1, #0
3001dd98:	e1812002 	orr	r2, r1, r2
3001dd9c:	e5c42002 	strb	r2, [r4, #2]
3001dda0:	e1a03423 	lsr	r3, r3, #8
3001dda4:	e1a03803 	lsl	r3, r3, #16
3001dda8:	e1a03823 	lsr	r3, r3, #16
3001ddac:	e3a02000 	mov	r2, #0
3001ddb0:	e1823003 	orr	r3, r2, r3
3001ddb4:	e5c43003 	strb	r3, [r4, #3]
    seg->tcphdr->seqno = htonl(seqno);
3001ddb8:	e59d3014 	ldr	r3, [sp, #20]
3001ddbc:	e5934010 	ldr	r4, [r3, #16]
3001ddc0:	e59d0020 	ldr	r0, [sp, #32]
3001ddc4:	ebffd6db 	bl	30013938 <htonl>
3001ddc8:	e1a03000 	mov	r3, r0
3001ddcc:	e20320ff 	and	r2, r3, #255	; 0xff
3001ddd0:	e3a01000 	mov	r1, #0
3001ddd4:	e1812002 	orr	r2, r1, r2
3001ddd8:	e5c42004 	strb	r2, [r4, #4]
3001dddc:	e1a02423 	lsr	r2, r3, #8
3001dde0:	e20220ff 	and	r2, r2, #255	; 0xff
3001dde4:	e3a01000 	mov	r1, #0
3001dde8:	e1812002 	orr	r2, r1, r2
3001ddec:	e5c42005 	strb	r2, [r4, #5]
3001ddf0:	e1a02823 	lsr	r2, r3, #16
3001ddf4:	e20220ff 	and	r2, r2, #255	; 0xff
3001ddf8:	e3a01000 	mov	r1, #0
3001ddfc:	e1812002 	orr	r2, r1, r2
3001de00:	e5c42006 	strb	r2, [r4, #6]
3001de04:	e1a03c23 	lsr	r3, r3, #24
3001de08:	e3a02000 	mov	r2, #0
3001de0c:	e1823003 	orr	r3, r2, r3
3001de10:	e5c43007 	strb	r3, [r4, #7]
    seg->tcphdr->urgp = 0;
3001de14:	e59d3014 	ldr	r3, [sp, #20]
3001de18:	e5933010 	ldr	r3, [r3, #16]
3001de1c:	e3a02000 	mov	r2, #0
3001de20:	e5c32012 	strb	r2, [r3, #18]
3001de24:	e3a02000 	mov	r2, #0
3001de28:	e5c32013 	strb	r2, [r3, #19]
    TCPH_FLAGS_SET(seg->tcphdr, flags);
3001de2c:	e59d3014 	ldr	r3, [sp, #20]
3001de30:	e5934010 	ldr	r4, [r3, #16]
3001de34:	e59d3014 	ldr	r3, [sp, #20]
3001de38:	e5933010 	ldr	r3, [r3, #16]
3001de3c:	e5d3200c 	ldrb	r2, [r3, #12]
3001de40:	e5d3300d 	ldrb	r3, [r3, #13]
3001de44:	e1a03403 	lsl	r3, r3, #8
3001de48:	e1833002 	orr	r3, r3, r2
3001de4c:	e1a03803 	lsl	r3, r3, #16
3001de50:	e1a03823 	lsr	r3, r3, #16
3001de54:	e1a00003 	mov	r0, r3
3001de58:	ebffd6aa 	bl	30013908 <ntohs>
3001de5c:	e1a03000 	mov	r3, r0
3001de60:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3001de64:	e1a03803 	lsl	r3, r3, #16
3001de68:	e1a03823 	lsr	r3, r3, #16
3001de6c:	e5dd2005 	ldrb	r2, [sp, #5]
3001de70:	e1833002 	orr	r3, r3, r2
3001de74:	e1a03803 	lsl	r3, r3, #16
3001de78:	e1a03823 	lsr	r3, r3, #16
3001de7c:	e1a00003 	mov	r0, r3
3001de80:	ebffd68d 	bl	300138bc <htons>
3001de84:	e1a03000 	mov	r3, r0
3001de88:	e20320ff 	and	r2, r3, #255	; 0xff
3001de8c:	e3a01000 	mov	r1, #0
3001de90:	e1812002 	orr	r2, r1, r2
3001de94:	e5c4200c 	strb	r2, [r4, #12]
3001de98:	e1a03423 	lsr	r3, r3, #8
3001de9c:	e1a03803 	lsl	r3, r3, #16
3001dea0:	e1a03823 	lsr	r3, r3, #16
3001dea4:	e3a02000 	mov	r2, #0
3001dea8:	e1823003 	orr	r3, r2, r3
3001deac:	e5c4300d 	strb	r3, [r4, #13]
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
3001deb0:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
3001deb4:	e3530000 	cmp	r3, #0
3001deb8:	1a00001e 	bne	3001df38 <tcp_enqueue+0x5e8>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
3001debc:	e59d3014 	ldr	r3, [sp, #20]
3001dec0:	e5934010 	ldr	r4, [r3, #16]
3001dec4:	e59d3014 	ldr	r3, [sp, #20]
3001dec8:	e5933010 	ldr	r3, [r3, #16]
3001decc:	e5d3200c 	ldrb	r2, [r3, #12]
3001ded0:	e5d3300d 	ldrb	r3, [r3, #13]
3001ded4:	e1a03403 	lsl	r3, r3, #8
3001ded8:	e1833002 	orr	r3, r3, r2
3001dedc:	e1a03803 	lsl	r3, r3, #16
3001dee0:	e1a03823 	lsr	r3, r3, #16
3001dee4:	e1a00003 	mov	r0, r3
3001dee8:	ebffd686 	bl	30013908 <ntohs>
3001deec:	e1a03000 	mov	r3, r0
3001def0:	e203303f 	and	r3, r3, #63	; 0x3f
3001def4:	e3833a05 	orr	r3, r3, #20480	; 0x5000
3001def8:	e1a03803 	lsl	r3, r3, #16
3001defc:	e1a03823 	lsr	r3, r3, #16
3001df00:	e1a00003 	mov	r0, r3
3001df04:	ebffd66c 	bl	300138bc <htons>
3001df08:	e1a03000 	mov	r3, r0
3001df0c:	e20320ff 	and	r2, r3, #255	; 0xff
3001df10:	e3a01000 	mov	r1, #0
3001df14:	e1812002 	orr	r2, r1, r2
3001df18:	e5c4200c 	strb	r2, [r4, #12]
3001df1c:	e1a03423 	lsr	r3, r3, #8
3001df20:	e1a03803 	lsl	r3, r3, #16
3001df24:	e1a03823 	lsr	r3, r3, #16
3001df28:	e3a02000 	mov	r2, #0
3001df2c:	e1823003 	orr	r3, r2, r3
3001df30:	e5c4300d 	strb	r3, [r4, #13]
3001df34:	ea00002d 	b	3001dff0 <tcp_enqueue+0x6a0>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
3001df38:	e59d3014 	ldr	r3, [sp, #20]
3001df3c:	e5934010 	ldr	r4, [r3, #16]
3001df40:	e5dd3048 	ldrb	r3, [sp, #72]	; 0x48
3001df44:	e1a03123 	lsr	r3, r3, #2
3001df48:	e20330ff 	and	r3, r3, #255	; 0xff
3001df4c:	e2833005 	add	r3, r3, #5
3001df50:	e1a03803 	lsl	r3, r3, #16
3001df54:	e1a03823 	lsr	r3, r3, #16
3001df58:	e1a03603 	lsl	r3, r3, #12
3001df5c:	e1a03803 	lsl	r3, r3, #16
3001df60:	e1a05823 	lsr	r5, r3, #16
3001df64:	e59d3014 	ldr	r3, [sp, #20]
3001df68:	e5933010 	ldr	r3, [r3, #16]
3001df6c:	e5d3200c 	ldrb	r2, [r3, #12]
3001df70:	e5d3300d 	ldrb	r3, [r3, #13]
3001df74:	e1a03403 	lsl	r3, r3, #8
3001df78:	e1833002 	orr	r3, r3, r2
3001df7c:	e1a03803 	lsl	r3, r3, #16
3001df80:	e1a03823 	lsr	r3, r3, #16
3001df84:	e1a00003 	mov	r0, r3
3001df88:	ebffd65e 	bl	30013908 <ntohs>
3001df8c:	e1a03000 	mov	r3, r0
3001df90:	e203303f 	and	r3, r3, #63	; 0x3f
3001df94:	e1853003 	orr	r3, r5, r3
3001df98:	e1a03803 	lsl	r3, r3, #16
3001df9c:	e1a03823 	lsr	r3, r3, #16
3001dfa0:	e1a00003 	mov	r0, r3
3001dfa4:	ebffd644 	bl	300138bc <htons>
3001dfa8:	e1a03000 	mov	r3, r0
3001dfac:	e20320ff 	and	r2, r3, #255	; 0xff
3001dfb0:	e3a01000 	mov	r1, #0
3001dfb4:	e1812002 	orr	r2, r1, r2
3001dfb8:	e5c4200c 	strb	r2, [r4, #12]
3001dfbc:	e1a03423 	lsr	r3, r3, #8
3001dfc0:	e1a03803 	lsl	r3, r3, #16
3001dfc4:	e1a03823 	lsr	r3, r3, #16
3001dfc8:	e3a02000 	mov	r2, #0
3001dfcc:	e1823003 	orr	r3, r2, r3
3001dfd0:	e5c4300d 	strb	r3, [r4, #13]
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
3001dfd4:	e59d3014 	ldr	r3, [sp, #20]
3001dfd8:	e5932008 	ldr	r2, [r3, #8]
3001dfdc:	e5dd3048 	ldrb	r3, [sp, #72]	; 0x48
3001dfe0:	e1a00002 	mov	r0, r2
3001dfe4:	e59d1044 	ldr	r1, [sp, #68]	; 0x44
3001dfe8:	e1a02003 	mov	r2, r3
3001dfec:	ebffbbd6 	bl	3000cf4c <__re_memcpy>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
3001dff0:	e1dd22b4 	ldrh	r2, [sp, #36]	; 0x24
3001dff4:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3001dff8:	e0633002 	rsb	r3, r3, r2
3001dffc:	e1cd32b4 	strh	r3, [sp, #36]	; 0x24
    seqno += seglen;
3001e000:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3001e004:	e59d2020 	ldr	r2, [sp, #32]
3001e008:	e0823003 	add	r3, r2, r3
3001e00c:	e58d3020 	str	r3, [sp, #32]
    ptr = (void *)((u8_t *)ptr + seglen);
3001e010:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3001e014:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
3001e018:	e0823003 	add	r3, r2, r3
3001e01c:	e58d3028 	str	r3, [sp, #40]	; 0x28

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
3001e020:	e59d301c 	ldr	r3, [sp, #28]
3001e024:	e3530000 	cmp	r3, #0
3001e028:	0afffe87 	beq	3001da4c <tcp_enqueue+0xfc>
3001e02c:	e1dd32b4 	ldrh	r3, [sp, #36]	; 0x24
3001e030:	e3530000 	cmp	r3, #0
3001e034:	1afffe84 	bne	3001da4c <tcp_enqueue+0xfc>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
3001e038:	e59d300c 	ldr	r3, [sp, #12]
3001e03c:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001e040:	e3530000 	cmp	r3, #0
3001e044:	1a000002 	bne	3001e054 <tcp_enqueue+0x704>
    useg = NULL;
3001e048:	e3a03000 	mov	r3, #0
3001e04c:	e58d3018 	str	r3, [sp, #24]
3001e050:	ea00000a 	b	3001e080 <tcp_enqueue+0x730>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
3001e054:	e59d300c 	ldr	r3, [sp, #12]
3001e058:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001e05c:	e58d3018 	str	r3, [sp, #24]
3001e060:	ea000002 	b	3001e070 <tcp_enqueue+0x720>
3001e064:	e59d3018 	ldr	r3, [sp, #24]
3001e068:	e5933000 	ldr	r3, [r3]
3001e06c:	e58d3018 	str	r3, [sp, #24]
3001e070:	e59d3018 	ldr	r3, [sp, #24]
3001e074:	e5933000 	ldr	r3, [r3]
3001e078:	e3530000 	cmp	r3, #0
3001e07c:	1afffff8 	bne	3001e064 <tcp_enqueue+0x714>
    }
    memp_free(MEMP_TCP_SEG, queue);
  }
  else {*/
    /* empty list */
    if (useg == NULL) {
3001e080:	e59d3018 	ldr	r3, [sp, #24]
3001e084:	e3530000 	cmp	r3, #0
3001e088:	1a000003 	bne	3001e09c <tcp_enqueue+0x74c>
      /* initialize list with this segment */
      pcb->unsent = queue;
3001e08c:	e59d300c 	ldr	r3, [sp, #12]
3001e090:	e59d201c 	ldr	r2, [sp, #28]
3001e094:	e5832070 	str	r2, [r3, #112]	; 0x70
3001e098:	ea000002 	b	3001e0a8 <tcp_enqueue+0x758>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
3001e09c:	e59d3018 	ldr	r3, [sp, #24]
3001e0a0:	e59d201c 	ldr	r2, [sp, #28]
3001e0a4:	e5832000 	str	r2, [r3]
    }
 // }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
3001e0a8:	e5dd3005 	ldrb	r3, [sp, #5]
3001e0ac:	e2033002 	and	r3, r3, #2
3001e0b0:	e3530000 	cmp	r3, #0
3001e0b4:	1a000004 	bne	3001e0cc <tcp_enqueue+0x77c>
3001e0b8:	e5dd3005 	ldrb	r3, [sp, #5]
3001e0bc:	e2033001 	and	r3, r3, #1
3001e0c0:	e20330ff 	and	r3, r3, #255	; 0xff
3001e0c4:	e3530000 	cmp	r3, #0
3001e0c8:	0a000002 	beq	3001e0d8 <tcp_enqueue+0x788>
    ++len;
3001e0cc:	e1dd30b6 	ldrh	r3, [sp, #6]
3001e0d0:	e2833001 	add	r3, r3, #1
3001e0d4:	e1cd30b6 	strh	r3, [sp, #6]
  }
  if (flags & TCP_FIN) {
3001e0d8:	e5dd3005 	ldrb	r3, [sp, #5]
3001e0dc:	e2033001 	and	r3, r3, #1
3001e0e0:	e20330ff 	and	r3, r3, #255	; 0xff
3001e0e4:	e3530000 	cmp	r3, #0
3001e0e8:	0a000005 	beq	3001e104 <tcp_enqueue+0x7b4>
    pcb->flags |= TF_FIN;
3001e0ec:	e59d300c 	ldr	r3, [sp, #12]
3001e0f0:	e5d3301c 	ldrb	r3, [r3, #28]
3001e0f4:	e3833020 	orr	r3, r3, #32
3001e0f8:	e20320ff 	and	r2, r3, #255	; 0xff
3001e0fc:	e59d300c 	ldr	r3, [sp, #12]
3001e100:	e5c3201c 	strb	r2, [r3, #28]
  }
  pcb->snd_lbb += len;
3001e104:	e59d300c 	ldr	r3, [sp, #12]
3001e108:	e5932064 	ldr	r2, [r3, #100]	; 0x64
3001e10c:	e1dd30b6 	ldrh	r3, [sp, #6]
3001e110:	e0822003 	add	r2, r2, r3
3001e114:	e59d300c 	ldr	r3, [sp, #12]
3001e118:	e5832064 	str	r2, [r3, #100]	; 0x64

  pcb->snd_buf -= len;
3001e11c:	e59d300c 	ldr	r3, [sp, #12]
3001e120:	e1d326ba 	ldrh	r2, [r3, #106]	; 0x6a
3001e124:	e1dd30b6 	ldrh	r3, [sp, #6]
3001e128:	e0633002 	rsb	r3, r3, r2
3001e12c:	e1a03803 	lsl	r3, r3, #16
3001e130:	e1a02823 	lsr	r2, r3, #16
3001e134:	e59d300c 	ldr	r3, [sp, #12]
3001e138:	e1c326ba 	strh	r2, [r3, #106]	; 0x6a

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
3001e13c:	e59d300c 	ldr	r3, [sp, #12]
3001e140:	e1dd22be 	ldrh	r2, [sp, #46]	; 0x2e
3001e144:	e1c326bc 	strh	r2, [r3, #108]	; 0x6c
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
3001e148:	e59d3014 	ldr	r3, [sp, #20]
3001e14c:	e3530000 	cmp	r3, #0
3001e150:	0a000027 	beq	3001e1f4 <tcp_enqueue+0x8a4>
3001e154:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3001e158:	e3530000 	cmp	r3, #0
3001e15c:	0a000024 	beq	3001e1f4 <tcp_enqueue+0x8a4>
3001e160:	e59d3014 	ldr	r3, [sp, #20]
3001e164:	e5933010 	ldr	r3, [r3, #16]
3001e168:	e3530000 	cmp	r3, #0
3001e16c:	0a000020 	beq	3001e1f4 <tcp_enqueue+0x8a4>
3001e170:	e5dd3040 	ldrb	r3, [sp, #64]	; 0x40
3001e174:	e2033002 	and	r3, r3, #2
3001e178:	e3530000 	cmp	r3, #0
3001e17c:	1a00001c 	bne	3001e1f4 <tcp_enqueue+0x8a4>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
3001e180:	e59d3014 	ldr	r3, [sp, #20]
3001e184:	e5934010 	ldr	r4, [r3, #16]
3001e188:	e59d3014 	ldr	r3, [sp, #20]
3001e18c:	e5933010 	ldr	r3, [r3, #16]
3001e190:	e5d3200c 	ldrb	r2, [r3, #12]
3001e194:	e5d3300d 	ldrb	r3, [r3, #13]
3001e198:	e1a03403 	lsl	r3, r3, #8
3001e19c:	e1833002 	orr	r3, r3, r2
3001e1a0:	e1a03803 	lsl	r3, r3, #16
3001e1a4:	e1a03823 	lsr	r3, r3, #16
3001e1a8:	e1a00003 	mov	r0, r3
3001e1ac:	ebffd5d5 	bl	30013908 <ntohs>
3001e1b0:	e1a03000 	mov	r3, r0
3001e1b4:	e3833008 	orr	r3, r3, #8
3001e1b8:	e1a03803 	lsl	r3, r3, #16
3001e1bc:	e1a03823 	lsr	r3, r3, #16
3001e1c0:	e1a00003 	mov	r0, r3
3001e1c4:	ebffd5bc 	bl	300138bc <htons>
3001e1c8:	e1a03000 	mov	r3, r0
3001e1cc:	e20320ff 	and	r2, r3, #255	; 0xff
3001e1d0:	e3a01000 	mov	r1, #0
3001e1d4:	e1812002 	orr	r2, r1, r2
3001e1d8:	e5c4200c 	strb	r2, [r4, #12]
3001e1dc:	e1a03423 	lsr	r3, r3, #8
3001e1e0:	e1a03803 	lsl	r3, r3, #16
3001e1e4:	e1a03823 	lsr	r3, r3, #16
3001e1e8:	e3a02000 	mov	r2, #0
3001e1ec:	e1823003 	orr	r3, r2, r3
3001e1f0:	e5c4300d 	strb	r3, [r4, #13]
  }

  return ERR_OK;
3001e1f4:	e3a03000 	mov	r3, #0
3001e1f8:	ea00001a 	b	3001e268 <tcp_enqueue+0x918>

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
    if (seg == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
3001e1fc:	e1a00000 	nop			; (mov r0, r0)
3001e200:	ea000004 	b	3001e218 <tcp_enqueue+0x8c8>
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
        goto memerr;
3001e204:	e1a00000 	nop			; (mov r0, r0)
3001e208:	ea000002 	b	3001e218 <tcp_enqueue+0x8c8>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
3001e20c:	e1a00000 	nop			; (mov r0, r0)
3001e210:	ea000000 	b	3001e218 <tcp_enqueue+0x8c8>
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
3001e214:	e1a00000 	nop			; (mov r0, r0)
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
3001e218:	e59d300c 	ldr	r3, [sp, #12]
3001e21c:	e5d3301c 	ldrb	r3, [r3, #28]
3001e220:	e1e03c83 	mvn	r3, r3, lsl #25
3001e224:	e1e03ca3 	mvn	r3, r3, lsr #25
3001e228:	e20320ff 	and	r2, r3, #255	; 0xff
3001e22c:	e59d300c 	ldr	r3, [sp, #12]
3001e230:	e5c3201c 	strb	r2, [r3, #28]
  TCP_STATS_INC(tcp.memerr);
3001e234:	e59f3044 	ldr	r3, [pc, #68]	; 3001e280 <tcp_enqueue+0x930>
3001e238:	e1d33aba 	ldrh	r3, [r3, #170]	; 0xaa
3001e23c:	e2833001 	add	r3, r3, #1
3001e240:	e1a03803 	lsl	r3, r3, #16
3001e244:	e1a02823 	lsr	r2, r3, #16
3001e248:	e59f3030 	ldr	r3, [pc, #48]	; 3001e280 <tcp_enqueue+0x930>
3001e24c:	e1c32aba 	strh	r2, [r3, #170]	; 0xaa

  if (queue != NULL) {
3001e250:	e59d301c 	ldr	r3, [sp, #28]
3001e254:	e3530000 	cmp	r3, #0
3001e258:	0a000001 	beq	3001e264 <tcp_enqueue+0x914>
    tcp_segs_free(queue);
3001e25c:	e59d001c 	ldr	r0, [sp, #28]
3001e260:	ebffeb33 	bl	30018f34 <tcp_segs_free>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
3001e264:	e3a030ff 	mov	r3, #255	; 0xff
3001e268:	e1a03c03 	lsl	r3, r3, #24
3001e26c:	e1a03c43 	asr	r3, r3, #24
}
3001e270:	e1a00003 	mov	r0, r3
3001e274:	e28dd034 	add	sp, sp, #52	; 0x34
3001e278:	e8bd4030 	pop	{r4, r5, lr}
3001e27c:	e12fff1e 	bx	lr
3001e280:	3002b214 	.word	0x3002b214

3001e284 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
3001e284:	e92d4030 	push	{r4, r5, lr}
3001e288:	e24dd02c 	sub	sp, sp, #44	; 0x2c
3001e28c:	e58d000c 	str	r0, [sp, #12]

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
3001e290:	e59f3998 	ldr	r3, [pc, #2456]	; 3001ec30 <tcp_output+0x9ac>
3001e294:	e5932000 	ldr	r2, [r3]
3001e298:	e59d300c 	ldr	r3, [sp, #12]
3001e29c:	e1520003 	cmp	r2, r3
3001e2a0:	1a000001 	bne	3001e2ac <tcp_output+0x28>
    //acoral_prints("\r\n==output--0\r\n");
    return ERR_OK;
3001e2a4:	e3a03000 	mov	r3, #0
3001e2a8:	ea00025a 	b	3001ec18 <tcp_output+0x994>
  }
  //acoral_prints("\r\n==output--1\r\n");
  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
3001e2ac:	e59d300c 	ldr	r3, [sp, #12]
3001e2b0:	e1d324ba 	ldrh	r2, [r3, #74]	; 0x4a
3001e2b4:	e59d300c 	ldr	r3, [sp, #12]
3001e2b8:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
3001e2bc:	e1520003 	cmp	r2, r3
3001e2c0:	31a03002 	movcc	r3, r2
3001e2c4:	e1a03803 	lsl	r3, r3, #16
3001e2c8:	e1a03823 	lsr	r3, r3, #16
3001e2cc:	e58d3024 	str	r3, [sp, #36]	; 0x24

  seg = pcb->unsent;
3001e2d0:	e59d300c 	ldr	r3, [sp, #12]
3001e2d4:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001e2d8:	e58d301c 	str	r3, [sp, #28]

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
3001e2dc:	e59d300c 	ldr	r3, [sp, #12]
3001e2e0:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001e2e4:	e58d3020 	str	r3, [sp, #32]
  if (useg != NULL) {
3001e2e8:	e59d3020 	ldr	r3, [sp, #32]
3001e2ec:	e3530000 	cmp	r3, #0
3001e2f0:	0a000007 	beq	3001e314 <tcp_output+0x90>
    //acoral_prints("\r\n==output--2\r\n");
    for (; useg->next != NULL; useg = useg->next);
3001e2f4:	ea000002 	b	3001e304 <tcp_output+0x80>
3001e2f8:	e59d3020 	ldr	r3, [sp, #32]
3001e2fc:	e5933000 	ldr	r3, [r3]
3001e300:	e58d3020 	str	r3, [sp, #32]
3001e304:	e59d3020 	ldr	r3, [sp, #32]
3001e308:	e5933000 	ldr	r3, [r3]
3001e30c:	e3530000 	cmp	r3, #0
3001e310:	1afffff8 	bne	3001e2f8 <tcp_output+0x74>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
3001e314:	e59d300c 	ldr	r3, [sp, #12]
3001e318:	e5d3301c 	ldrb	r3, [r3, #28]
3001e31c:	e2033002 	and	r3, r3, #2
3001e320:	e3530000 	cmp	r3, #0
3001e324:	0a0001f0 	beq	3001eaec <tcp_output+0x868>
3001e328:	e59d301c 	ldr	r3, [sp, #28]
3001e32c:	e3530000 	cmp	r3, #0
3001e330:	0a000017 	beq	3001e394 <tcp_output+0x110>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
3001e334:	e59d301c 	ldr	r3, [sp, #28]
3001e338:	e5933010 	ldr	r3, [r3, #16]
3001e33c:	e5d32004 	ldrb	r2, [r3, #4]
3001e340:	e5d31005 	ldrb	r1, [r3, #5]
3001e344:	e1a01401 	lsl	r1, r1, #8
3001e348:	e1812002 	orr	r2, r1, r2
3001e34c:	e5d31006 	ldrb	r1, [r3, #6]
3001e350:	e1a01801 	lsl	r1, r1, #16
3001e354:	e1812002 	orr	r2, r1, r2
3001e358:	e5d33007 	ldrb	r3, [r3, #7]
3001e35c:	e1a03c03 	lsl	r3, r3, #24
3001e360:	e1833002 	orr	r3, r3, r2
3001e364:	e1a00003 	mov	r0, r3
3001e368:	ebffd584 	bl	30013980 <ntohl>
3001e36c:	e1a02000 	mov	r2, r0
3001e370:	e59d300c 	ldr	r3, [sp, #12]
3001e374:	e5933044 	ldr	r3, [r3, #68]	; 0x44
3001e378:	e0632002 	rsb	r2, r3, r2
3001e37c:	e59d301c 	ldr	r3, [sp, #28]
3001e380:	e1d330bc 	ldrh	r3, [r3, #12]
3001e384:	e0822003 	add	r2, r2, r3
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
3001e388:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001e38c:	e1520003 	cmp	r2, r3
3001e390:	9a0001d5 	bls	3001eaec <tcp_output+0x868>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
3001e394:	e3a00001 	mov	r0, #1
3001e398:	e3a01014 	mov	r1, #20
3001e39c:	e3a02000 	mov	r2, #0
3001e3a0:	ebffdeb3 	bl	30015e74 <pbuf_alloc>
3001e3a4:	e1a03000 	mov	r3, r0
3001e3a8:	e58d3014 	str	r3, [sp, #20]
    //acoral_prints("\r\n==output--3\r\n");
    if (p == NULL) {
3001e3ac:	e59d3014 	ldr	r3, [sp, #20]
3001e3b0:	e3530000 	cmp	r3, #0
3001e3b4:	1a000001 	bne	3001e3c0 <tcp_output+0x13c>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
3001e3b8:	e3a030fe 	mov	r3, #254	; 0xfe
3001e3bc:	ea000215 	b	3001ec18 <tcp_output+0x994>
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
3001e3c0:	e59d300c 	ldr	r3, [sp, #12]
3001e3c4:	e5d3301c 	ldrb	r3, [r3, #28]
3001e3c8:	e20330fc 	and	r3, r3, #252	; 0xfc
3001e3cc:	e59d200c 	ldr	r2, [sp, #12]
3001e3d0:	e5c2301c 	strb	r3, [r2, #28]

    tcphdr = p->payload;
3001e3d4:	e59d3014 	ldr	r3, [sp, #20]
3001e3d8:	e5933004 	ldr	r3, [r3, #4]
3001e3dc:	e58d3018 	str	r3, [sp, #24]
    tcphdr->src = htons(pcb->local_port);
3001e3e0:	e59d300c 	ldr	r3, [sp, #12]
3001e3e4:	e1d331b8 	ldrh	r3, [r3, #24]
3001e3e8:	e1a00003 	mov	r0, r3
3001e3ec:	ebffd532 	bl	300138bc <htons>
3001e3f0:	e1a03000 	mov	r3, r0
3001e3f4:	e1a02003 	mov	r2, r3
3001e3f8:	e59d3018 	ldr	r3, [sp, #24]
3001e3fc:	e20210ff 	and	r1, r2, #255	; 0xff
3001e400:	e3a00000 	mov	r0, #0
3001e404:	e1801001 	orr	r1, r0, r1
3001e408:	e5c31000 	strb	r1, [r3]
3001e40c:	e1a02422 	lsr	r2, r2, #8
3001e410:	e1a02802 	lsl	r2, r2, #16
3001e414:	e1a02822 	lsr	r2, r2, #16
3001e418:	e3a01000 	mov	r1, #0
3001e41c:	e1812002 	orr	r2, r1, r2
3001e420:	e5c32001 	strb	r2, [r3, #1]
    tcphdr->dest = htons(pcb->remote_port);
3001e424:	e59d300c 	ldr	r3, [sp, #12]
3001e428:	e1d331ba 	ldrh	r3, [r3, #26]
3001e42c:	e1a00003 	mov	r0, r3
3001e430:	ebffd521 	bl	300138bc <htons>
3001e434:	e1a03000 	mov	r3, r0
3001e438:	e1a02003 	mov	r2, r3
3001e43c:	e59d3018 	ldr	r3, [sp, #24]
3001e440:	e20210ff 	and	r1, r2, #255	; 0xff
3001e444:	e3a00000 	mov	r0, #0
3001e448:	e1801001 	orr	r1, r0, r1
3001e44c:	e5c31002 	strb	r1, [r3, #2]
3001e450:	e1a02422 	lsr	r2, r2, #8
3001e454:	e1a02802 	lsl	r2, r2, #16
3001e458:	e1a02822 	lsr	r2, r2, #16
3001e45c:	e3a01000 	mov	r1, #0
3001e460:	e1812002 	orr	r2, r1, r2
3001e464:	e5c32003 	strb	r2, [r3, #3]
    tcphdr->seqno = htonl(pcb->snd_nxt);
3001e468:	e59d300c 	ldr	r3, [sp, #12]
3001e46c:	e5933050 	ldr	r3, [r3, #80]	; 0x50
3001e470:	e1a00003 	mov	r0, r3
3001e474:	ebffd52f 	bl	30013938 <htonl>
3001e478:	e1a02000 	mov	r2, r0
3001e47c:	e59d3018 	ldr	r3, [sp, #24]
3001e480:	e20210ff 	and	r1, r2, #255	; 0xff
3001e484:	e3a00000 	mov	r0, #0
3001e488:	e1801001 	orr	r1, r0, r1
3001e48c:	e5c31004 	strb	r1, [r3, #4]
3001e490:	e1a01422 	lsr	r1, r2, #8
3001e494:	e20110ff 	and	r1, r1, #255	; 0xff
3001e498:	e3a00000 	mov	r0, #0
3001e49c:	e1801001 	orr	r1, r0, r1
3001e4a0:	e5c31005 	strb	r1, [r3, #5]
3001e4a4:	e1a01822 	lsr	r1, r2, #16
3001e4a8:	e20110ff 	and	r1, r1, #255	; 0xff
3001e4ac:	e3a00000 	mov	r0, #0
3001e4b0:	e1801001 	orr	r1, r0, r1
3001e4b4:	e5c31006 	strb	r1, [r3, #6]
3001e4b8:	e1a02c22 	lsr	r2, r2, #24
3001e4bc:	e3a01000 	mov	r1, #0
3001e4c0:	e1812002 	orr	r2, r1, r2
3001e4c4:	e5c32007 	strb	r2, [r3, #7]
    tcphdr->ackno = htonl(pcb->rcv_nxt);
3001e4c8:	e59d300c 	ldr	r3, [sp, #12]
3001e4cc:	e5933020 	ldr	r3, [r3, #32]
3001e4d0:	e1a00003 	mov	r0, r3
3001e4d4:	ebffd517 	bl	30013938 <htonl>
3001e4d8:	e1a02000 	mov	r2, r0
3001e4dc:	e59d3018 	ldr	r3, [sp, #24]
3001e4e0:	e20210ff 	and	r1, r2, #255	; 0xff
3001e4e4:	e3a00000 	mov	r0, #0
3001e4e8:	e1801001 	orr	r1, r0, r1
3001e4ec:	e5c31008 	strb	r1, [r3, #8]
3001e4f0:	e1a01422 	lsr	r1, r2, #8
3001e4f4:	e20110ff 	and	r1, r1, #255	; 0xff
3001e4f8:	e3a00000 	mov	r0, #0
3001e4fc:	e1801001 	orr	r1, r0, r1
3001e500:	e5c31009 	strb	r1, [r3, #9]
3001e504:	e1a01822 	lsr	r1, r2, #16
3001e508:	e20110ff 	and	r1, r1, #255	; 0xff
3001e50c:	e3a00000 	mov	r0, #0
3001e510:	e1801001 	orr	r1, r0, r1
3001e514:	e5c3100a 	strb	r1, [r3, #10]
3001e518:	e1a02c22 	lsr	r2, r2, #24
3001e51c:	e3a01000 	mov	r1, #0
3001e520:	e1812002 	orr	r2, r1, r2
3001e524:	e5c3200b 	strb	r2, [r3, #11]
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
3001e528:	e59d3018 	ldr	r3, [sp, #24]
3001e52c:	e5d3200c 	ldrb	r2, [r3, #12]
3001e530:	e5d3300d 	ldrb	r3, [r3, #13]
3001e534:	e1a03403 	lsl	r3, r3, #8
3001e538:	e1833002 	orr	r3, r3, r2
3001e53c:	e1a03803 	lsl	r3, r3, #16
3001e540:	e1a03823 	lsr	r3, r3, #16
3001e544:	e1a00003 	mov	r0, r3
3001e548:	ebffd4ee 	bl	30013908 <ntohs>
3001e54c:	e1a03000 	mov	r3, r0
3001e550:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3001e554:	e1a03803 	lsl	r3, r3, #16
3001e558:	e1a03823 	lsr	r3, r3, #16
3001e55c:	e3833010 	orr	r3, r3, #16
3001e560:	e1a03803 	lsl	r3, r3, #16
3001e564:	e1a03823 	lsr	r3, r3, #16
3001e568:	e1a00003 	mov	r0, r3
3001e56c:	ebffd4d2 	bl	300138bc <htons>
3001e570:	e1a03000 	mov	r3, r0
3001e574:	e1a02003 	mov	r2, r3
3001e578:	e59d3018 	ldr	r3, [sp, #24]
3001e57c:	e20210ff 	and	r1, r2, #255	; 0xff
3001e580:	e3a00000 	mov	r0, #0
3001e584:	e1801001 	orr	r1, r0, r1
3001e588:	e5c3100c 	strb	r1, [r3, #12]
3001e58c:	e1a02422 	lsr	r2, r2, #8
3001e590:	e1a02802 	lsl	r2, r2, #16
3001e594:	e1a02822 	lsr	r2, r2, #16
3001e598:	e3a01000 	mov	r1, #0
3001e59c:	e1812002 	orr	r2, r1, r2
3001e5a0:	e5c3200d 	strb	r2, [r3, #13]
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
3001e5a4:	e59d300c 	ldr	r3, [sp, #12]
3001e5a8:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
3001e5ac:	e1a00003 	mov	r0, r3
3001e5b0:	ebffd4c1 	bl	300138bc <htons>
3001e5b4:	e1a03000 	mov	r3, r0
3001e5b8:	e1a02003 	mov	r2, r3
3001e5bc:	e59d3018 	ldr	r3, [sp, #24]
3001e5c0:	e20210ff 	and	r1, r2, #255	; 0xff
3001e5c4:	e3a00000 	mov	r0, #0
3001e5c8:	e1801001 	orr	r1, r0, r1
3001e5cc:	e5c3100e 	strb	r1, [r3, #14]
3001e5d0:	e1a02422 	lsr	r2, r2, #8
3001e5d4:	e1a02802 	lsl	r2, r2, #16
3001e5d8:	e1a02822 	lsr	r2, r2, #16
3001e5dc:	e3a01000 	mov	r1, #0
3001e5e0:	e1812002 	orr	r2, r1, r2
3001e5e4:	e5c3200f 	strb	r2, [r3, #15]
    tcphdr->urgp = 0;
3001e5e8:	e59d3018 	ldr	r3, [sp, #24]
3001e5ec:	e3a02000 	mov	r2, #0
3001e5f0:	e5c32012 	strb	r2, [r3, #18]
3001e5f4:	e3a02000 	mov	r2, #0
3001e5f8:	e5c32013 	strb	r2, [r3, #19]
    TCPH_HDRLEN_SET(tcphdr, 5);
3001e5fc:	e59d3018 	ldr	r3, [sp, #24]
3001e600:	e5d3200c 	ldrb	r2, [r3, #12]
3001e604:	e5d3300d 	ldrb	r3, [r3, #13]
3001e608:	e1a03403 	lsl	r3, r3, #8
3001e60c:	e1833002 	orr	r3, r3, r2
3001e610:	e1a03803 	lsl	r3, r3, #16
3001e614:	e1a03823 	lsr	r3, r3, #16
3001e618:	e1a00003 	mov	r0, r3
3001e61c:	ebffd4b9 	bl	30013908 <ntohs>
3001e620:	e1a03000 	mov	r3, r0
3001e624:	e203303f 	and	r3, r3, #63	; 0x3f
3001e628:	e3833a05 	orr	r3, r3, #20480	; 0x5000
3001e62c:	e1a03803 	lsl	r3, r3, #16
3001e630:	e1a03823 	lsr	r3, r3, #16
3001e634:	e1a00003 	mov	r0, r3
3001e638:	ebffd49f 	bl	300138bc <htons>
3001e63c:	e1a03000 	mov	r3, r0
3001e640:	e1a02003 	mov	r2, r3
3001e644:	e59d3018 	ldr	r3, [sp, #24]
3001e648:	e20210ff 	and	r1, r2, #255	; 0xff
3001e64c:	e3a00000 	mov	r0, #0
3001e650:	e1801001 	orr	r1, r0, r1
3001e654:	e5c3100c 	strb	r1, [r3, #12]
3001e658:	e1a02422 	lsr	r2, r2, #8
3001e65c:	e1a02802 	lsl	r2, r2, #16
3001e660:	e1a02822 	lsr	r2, r2, #16
3001e664:	e3a01000 	mov	r1, #0
3001e668:	e1812002 	orr	r2, r1, r2
3001e66c:	e5c3200d 	strb	r2, [r3, #13]

    tcphdr->chksum = 0;
3001e670:	e59d3018 	ldr	r3, [sp, #24]
3001e674:	e3a02000 	mov	r2, #0
3001e678:	e5c32010 	strb	r2, [r3, #16]
3001e67c:	e3a02000 	mov	r2, #0
3001e680:	e5c32011 	strb	r2, [r3, #17]
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
3001e684:	e59d200c 	ldr	r2, [sp, #12]
3001e688:	e59d300c 	ldr	r3, [sp, #12]
3001e68c:	e2833004 	add	r3, r3, #4
3001e690:	e59d1014 	ldr	r1, [sp, #20]
3001e694:	e1d110b8 	ldrh	r1, [r1, #8]
3001e698:	e58d1000 	str	r1, [sp]
3001e69c:	e59d0014 	ldr	r0, [sp, #20]
3001e6a0:	e1a01002 	mov	r1, r2
3001e6a4:	e1a02003 	mov	r2, r3
3001e6a8:	e3a03006 	mov	r3, #6
3001e6ac:	ebffd509 	bl	30013ad8 <inet_chksum_pseudo>
3001e6b0:	e1a03000 	mov	r3, r0
3001e6b4:	e1a02003 	mov	r2, r3
3001e6b8:	e59d3018 	ldr	r3, [sp, #24]
3001e6bc:	e20210ff 	and	r1, r2, #255	; 0xff
3001e6c0:	e3a00000 	mov	r0, #0
3001e6c4:	e1801001 	orr	r1, r0, r1
3001e6c8:	e5c31010 	strb	r1, [r3, #16]
3001e6cc:	e1a02422 	lsr	r2, r2, #8
3001e6d0:	e1a02802 	lsl	r2, r2, #16
3001e6d4:	e1a02822 	lsr	r2, r2, #16
3001e6d8:	e3a01000 	mov	r1, #0
3001e6dc:	e1812002 	orr	r2, r1, r2
3001e6e0:	e5c32011 	strb	r2, [r3, #17]
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
3001e6e4:	e59d100c 	ldr	r1, [sp, #12]
3001e6e8:	e59d300c 	ldr	r3, [sp, #12]
3001e6ec:	e2832004 	add	r2, r3, #4
3001e6f0:	e59d300c 	ldr	r3, [sp, #12]
3001e6f4:	e5d3300b 	ldrb	r3, [r3, #11]
3001e6f8:	e59d000c 	ldr	r0, [sp, #12]
3001e6fc:	e5d0000a 	ldrb	r0, [r0, #10]
3001e700:	e58d0000 	str	r0, [sp]
3001e704:	e3a00006 	mov	r0, #6
3001e708:	e58d0004 	str	r0, [sp, #4]
3001e70c:	e59d0014 	ldr	r0, [sp, #20]
3001e710:	ebffd9dc 	bl	30014e88 <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
3001e714:	e59d0014 	ldr	r0, [sp, #20]
3001e718:	ebffdf84 	bl	30016530 <pbuf_free>
    //acoral_prints("\r\n==output--4\r\n");
    return ERR_OK;
3001e71c:	e3a03000 	mov	r3, #0
3001e720:	ea00013c 	b	3001ec18 <tcp_output+0x994>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
3001e724:	e59d300c 	ldr	r3, [sp, #12]
3001e728:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001e72c:	e3530000 	cmp	r3, #0
3001e730:	0a00000d 	beq	3001e76c <tcp_output+0x4e8>
3001e734:	e59d300c 	ldr	r3, [sp, #12]
3001e738:	e5d3301c 	ldrb	r3, [r3, #28]
3001e73c:	e2033040 	and	r3, r3, #64	; 0x40
3001e740:	e3530000 	cmp	r3, #0
3001e744:	1a000008 	bne	3001e76c <tcp_output+0x4e8>
3001e748:	e59d300c 	ldr	r3, [sp, #12]
3001e74c:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001e750:	e3530000 	cmp	r3, #0
3001e754:	0a000006 	beq	3001e774 <tcp_output+0x4f0>
3001e758:	e59d300c 	ldr	r3, [sp, #12]
3001e75c:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001e760:	e5933000 	ldr	r3, [r3]
3001e764:	e3530000 	cmp	r3, #0
3001e768:	0a000001 	beq	3001e774 <tcp_output+0x4f0>
3001e76c:	e3a03001 	mov	r3, #1
3001e770:	ea000000 	b	3001e778 <tcp_output+0x4f4>
3001e774:	e3a03000 	mov	r3, #0
3001e778:	e3530000 	cmp	r3, #0
3001e77c:	1a000004 	bne	3001e794 <tcp_output+0x510>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
3001e780:	e59d300c 	ldr	r3, [sp, #12]
3001e784:	e5d3301c 	ldrb	r3, [r3, #28]
3001e788:	e20330a0 	and	r3, r3, #160	; 0xa0
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
3001e78c:	e3530000 	cmp	r3, #0
3001e790:	0a0000f1 	beq	3001eb5c <tcp_output+0x8d8>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */
	//acoral_prints("\r\n==output--7\r\n");
    pcb->unsent = seg->next;
3001e794:	e59d301c 	ldr	r3, [sp, #28]
3001e798:	e5932000 	ldr	r2, [r3]
3001e79c:	e59d300c 	ldr	r3, [sp, #12]
3001e7a0:	e5832070 	str	r2, [r3, #112]	; 0x70

    if (pcb->state != SYN_SENT) {
3001e7a4:	e59d300c 	ldr	r3, [sp, #12]
3001e7a8:	e5d33010 	ldrb	r3, [r3, #16]
3001e7ac:	e3530002 	cmp	r3, #2
3001e7b0:	0a000021 	beq	3001e83c <tcp_output+0x5b8>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
3001e7b4:	e59d301c 	ldr	r3, [sp, #28]
3001e7b8:	e5934010 	ldr	r4, [r3, #16]
3001e7bc:	e59d301c 	ldr	r3, [sp, #28]
3001e7c0:	e5933010 	ldr	r3, [r3, #16]
3001e7c4:	e5d3200c 	ldrb	r2, [r3, #12]
3001e7c8:	e5d3300d 	ldrb	r3, [r3, #13]
3001e7cc:	e1a03403 	lsl	r3, r3, #8
3001e7d0:	e1833002 	orr	r3, r3, r2
3001e7d4:	e1a03803 	lsl	r3, r3, #16
3001e7d8:	e1a03823 	lsr	r3, r3, #16
3001e7dc:	e1a00003 	mov	r0, r3
3001e7e0:	ebffd448 	bl	30013908 <ntohs>
3001e7e4:	e1a03000 	mov	r3, r0
3001e7e8:	e3833010 	orr	r3, r3, #16
3001e7ec:	e1a03803 	lsl	r3, r3, #16
3001e7f0:	e1a03823 	lsr	r3, r3, #16
3001e7f4:	e1a00003 	mov	r0, r3
3001e7f8:	ebffd42f 	bl	300138bc <htons>
3001e7fc:	e1a03000 	mov	r3, r0
3001e800:	e20320ff 	and	r2, r3, #255	; 0xff
3001e804:	e3a01000 	mov	r1, #0
3001e808:	e1812002 	orr	r2, r1, r2
3001e80c:	e5c4200c 	strb	r2, [r4, #12]
3001e810:	e1a03423 	lsr	r3, r3, #8
3001e814:	e1a03803 	lsl	r3, r3, #16
3001e818:	e1a03823 	lsr	r3, r3, #16
3001e81c:	e3a02000 	mov	r2, #0
3001e820:	e1823003 	orr	r3, r2, r3
3001e824:	e5c4300d 	strb	r3, [r4, #13]
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
3001e828:	e59d300c 	ldr	r3, [sp, #12]
3001e82c:	e5d3301c 	ldrb	r3, [r3, #28]
3001e830:	e20330fc 	and	r3, r3, #252	; 0xfc
3001e834:	e59d200c 	ldr	r2, [sp, #12]
3001e838:	e5c2301c 	strb	r3, [r2, #28]
    }
	//acoral_print("\r\ntOutS\r\n");
    tcp_output_segment(seg, pcb);
3001e83c:	e59d001c 	ldr	r0, [sp, #28]
3001e840:	e59d100c 	ldr	r1, [sp, #12]
3001e844:	eb0000fb 	bl	3001ec38 <tcp_output_segment>
    //acoral_print("\r\ntOutE\r\n");
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
3001e848:	e59d301c 	ldr	r3, [sp, #28]
3001e84c:	e5933010 	ldr	r3, [r3, #16]
3001e850:	e5d32004 	ldrb	r2, [r3, #4]
3001e854:	e5d31005 	ldrb	r1, [r3, #5]
3001e858:	e1a01401 	lsl	r1, r1, #8
3001e85c:	e1812002 	orr	r2, r1, r2
3001e860:	e5d31006 	ldrb	r1, [r3, #6]
3001e864:	e1a01801 	lsl	r1, r1, #16
3001e868:	e1812002 	orr	r2, r1, r2
3001e86c:	e5d33007 	ldrb	r3, [r3, #7]
3001e870:	e1a03c03 	lsl	r3, r3, #24
3001e874:	e1833002 	orr	r3, r3, r2
3001e878:	e1a00003 	mov	r0, r3
3001e87c:	ebffd43f 	bl	30013980 <ntohl>
3001e880:	e1a04000 	mov	r4, r0
3001e884:	e59d301c 	ldr	r3, [sp, #28]
3001e888:	e1d330bc 	ldrh	r3, [r3, #12]
3001e88c:	e1a05003 	mov	r5, r3
3001e890:	e59d301c 	ldr	r3, [sp, #28]
3001e894:	e5933010 	ldr	r3, [r3, #16]
3001e898:	e5d3200c 	ldrb	r2, [r3, #12]
3001e89c:	e5d3300d 	ldrb	r3, [r3, #13]
3001e8a0:	e1a03403 	lsl	r3, r3, #8
3001e8a4:	e1833002 	orr	r3, r3, r2
3001e8a8:	e1a03803 	lsl	r3, r3, #16
3001e8ac:	e1a03823 	lsr	r3, r3, #16
3001e8b0:	e1a00003 	mov	r0, r3
3001e8b4:	ebffd413 	bl	30013908 <ntohs>
3001e8b8:	e1a03000 	mov	r3, r0
3001e8bc:	e2033001 	and	r3, r3, #1
3001e8c0:	e20330ff 	and	r3, r3, #255	; 0xff
3001e8c4:	e3530000 	cmp	r3, #0
3001e8c8:	1a00000d 	bne	3001e904 <tcp_output+0x680>
3001e8cc:	e59d301c 	ldr	r3, [sp, #28]
3001e8d0:	e5933010 	ldr	r3, [r3, #16]
3001e8d4:	e5d3200c 	ldrb	r2, [r3, #12]
3001e8d8:	e5d3300d 	ldrb	r3, [r3, #13]
3001e8dc:	e1a03403 	lsl	r3, r3, #8
3001e8e0:	e1833002 	orr	r3, r3, r2
3001e8e4:	e1a03803 	lsl	r3, r3, #16
3001e8e8:	e1a03823 	lsr	r3, r3, #16
3001e8ec:	e1a00003 	mov	r0, r3
3001e8f0:	ebffd404 	bl	30013908 <ntohs>
3001e8f4:	e1a03000 	mov	r3, r0
3001e8f8:	e2033002 	and	r3, r3, #2
3001e8fc:	e3530000 	cmp	r3, #0
3001e900:	0a000001 	beq	3001e90c <tcp_output+0x688>
3001e904:	e3a03001 	mov	r3, #1
3001e908:	ea000000 	b	3001e910 <tcp_output+0x68c>
3001e90c:	e3a03000 	mov	r3, #0
3001e910:	e0853003 	add	r3, r5, r3
3001e914:	e0842003 	add	r2, r4, r3
3001e918:	e59d300c 	ldr	r3, [sp, #12]
3001e91c:	e5832050 	str	r2, [r3, #80]	; 0x50
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
3001e920:	e59d300c 	ldr	r3, [sp, #12]
3001e924:	e5932054 	ldr	r2, [r3, #84]	; 0x54
3001e928:	e59d300c 	ldr	r3, [sp, #12]
3001e92c:	e5933050 	ldr	r3, [r3, #80]	; 0x50
3001e930:	e0633002 	rsb	r3, r3, r2
3001e934:	e3530000 	cmp	r3, #0
3001e938:	aa000003 	bge	3001e94c <tcp_output+0x6c8>
      pcb->snd_max = pcb->snd_nxt;
3001e93c:	e59d300c 	ldr	r3, [sp, #12]
3001e940:	e5932050 	ldr	r2, [r3, #80]	; 0x50
3001e944:	e59d300c 	ldr	r3, [sp, #12]
3001e948:	e5832054 	str	r2, [r3, #84]	; 0x54
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
3001e94c:	e59d301c 	ldr	r3, [sp, #28]
3001e950:	e1d330bc 	ldrh	r3, [r3, #12]
3001e954:	e1a04003 	mov	r4, r3
3001e958:	e59d301c 	ldr	r3, [sp, #28]
3001e95c:	e5933010 	ldr	r3, [r3, #16]
3001e960:	e5d3200c 	ldrb	r2, [r3, #12]
3001e964:	e5d3300d 	ldrb	r3, [r3, #13]
3001e968:	e1a03403 	lsl	r3, r3, #8
3001e96c:	e1833002 	orr	r3, r3, r2
3001e970:	e1a03803 	lsl	r3, r3, #16
3001e974:	e1a03823 	lsr	r3, r3, #16
3001e978:	e1a00003 	mov	r0, r3
3001e97c:	ebffd3e1 	bl	30013908 <ntohs>
3001e980:	e1a03000 	mov	r3, r0
3001e984:	e2033001 	and	r3, r3, #1
3001e988:	e20330ff 	and	r3, r3, #255	; 0xff
3001e98c:	e3530000 	cmp	r3, #0
3001e990:	1a00000d 	bne	3001e9cc <tcp_output+0x748>
3001e994:	e59d301c 	ldr	r3, [sp, #28]
3001e998:	e5933010 	ldr	r3, [r3, #16]
3001e99c:	e5d3200c 	ldrb	r2, [r3, #12]
3001e9a0:	e5d3300d 	ldrb	r3, [r3, #13]
3001e9a4:	e1a03403 	lsl	r3, r3, #8
3001e9a8:	e1833002 	orr	r3, r3, r2
3001e9ac:	e1a03803 	lsl	r3, r3, #16
3001e9b0:	e1a03823 	lsr	r3, r3, #16
3001e9b4:	e1a00003 	mov	r0, r3
3001e9b8:	ebffd3d2 	bl	30013908 <ntohs>
3001e9bc:	e1a03000 	mov	r3, r0
3001e9c0:	e2033002 	and	r3, r3, #2
3001e9c4:	e3530000 	cmp	r3, #0
3001e9c8:	0a000001 	beq	3001e9d4 <tcp_output+0x750>
3001e9cc:	e3a03001 	mov	r3, #1
3001e9d0:	ea000000 	b	3001e9d8 <tcp_output+0x754>
3001e9d4:	e3a03000 	mov	r3, #0
3001e9d8:	e0843003 	add	r3, r4, r3
3001e9dc:	e3530000 	cmp	r3, #0
3001e9e0:	da00003c 	ble	3001ead8 <tcp_output+0x854>
      seg->next = NULL;
3001e9e4:	e59d301c 	ldr	r3, [sp, #28]
3001e9e8:	e3a02000 	mov	r2, #0
3001e9ec:	e5832000 	str	r2, [r3]
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
3001e9f0:	e59d300c 	ldr	r3, [sp, #12]
3001e9f4:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001e9f8:	e3530000 	cmp	r3, #0
3001e9fc:	1a000005 	bne	3001ea18 <tcp_output+0x794>
        pcb->unacked = seg;
3001ea00:	e59d300c 	ldr	r3, [sp, #12]
3001ea04:	e59d201c 	ldr	r2, [sp, #28]
3001ea08:	e5832074 	str	r2, [r3, #116]	; 0x74
        useg = seg;
3001ea0c:	e59d301c 	ldr	r3, [sp, #28]
3001ea10:	e58d3020 	str	r3, [sp, #32]
          seg->next = pcb->unacked;
          pcb->unacked = seg;
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
          useg = useg->next;
3001ea14:	ea000031 	b	3001eae0 <tcp_output+0x85c>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
3001ea18:	e59d301c 	ldr	r3, [sp, #28]
3001ea1c:	e5933010 	ldr	r3, [r3, #16]
3001ea20:	e5d32004 	ldrb	r2, [r3, #4]
3001ea24:	e5d31005 	ldrb	r1, [r3, #5]
3001ea28:	e1a01401 	lsl	r1, r1, #8
3001ea2c:	e1812002 	orr	r2, r1, r2
3001ea30:	e5d31006 	ldrb	r1, [r3, #6]
3001ea34:	e1a01801 	lsl	r1, r1, #16
3001ea38:	e1812002 	orr	r2, r1, r2
3001ea3c:	e5d33007 	ldrb	r3, [r3, #7]
3001ea40:	e1a03c03 	lsl	r3, r3, #24
3001ea44:	e1833002 	orr	r3, r3, r2
3001ea48:	e1a00003 	mov	r0, r3
3001ea4c:	ebffd3cb 	bl	30013980 <ntohl>
3001ea50:	e1a04000 	mov	r4, r0
3001ea54:	e59d3020 	ldr	r3, [sp, #32]
3001ea58:	e5933010 	ldr	r3, [r3, #16]
3001ea5c:	e5d32004 	ldrb	r2, [r3, #4]
3001ea60:	e5d31005 	ldrb	r1, [r3, #5]
3001ea64:	e1a01401 	lsl	r1, r1, #8
3001ea68:	e1812002 	orr	r2, r1, r2
3001ea6c:	e5d31006 	ldrb	r1, [r3, #6]
3001ea70:	e1a01801 	lsl	r1, r1, #16
3001ea74:	e1812002 	orr	r2, r1, r2
3001ea78:	e5d33007 	ldrb	r3, [r3, #7]
3001ea7c:	e1a03c03 	lsl	r3, r3, #24
3001ea80:	e1833002 	orr	r3, r3, r2
3001ea84:	e1a00003 	mov	r0, r3
3001ea88:	ebffd3bc 	bl	30013980 <ntohl>
3001ea8c:	e1a03000 	mov	r3, r0
3001ea90:	e0633004 	rsb	r3, r3, r4
3001ea94:	e3530000 	cmp	r3, #0
3001ea98:	aa000007 	bge	3001eabc <tcp_output+0x838>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
3001ea9c:	e59d300c 	ldr	r3, [sp, #12]
3001eaa0:	e5932074 	ldr	r2, [r3, #116]	; 0x74
3001eaa4:	e59d301c 	ldr	r3, [sp, #28]
3001eaa8:	e5832000 	str	r2, [r3]
          pcb->unacked = seg;
3001eaac:	e59d300c 	ldr	r3, [sp, #12]
3001eab0:	e59d201c 	ldr	r2, [sp, #28]
3001eab4:	e5832074 	str	r2, [r3, #116]	; 0x74
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
          useg = useg->next;
3001eab8:	ea000008 	b	3001eae0 <tcp_output+0x85c>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
          pcb->unacked = seg;
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
3001eabc:	e59d3020 	ldr	r3, [sp, #32]
3001eac0:	e59d201c 	ldr	r2, [sp, #28]
3001eac4:	e5832000 	str	r2, [r3]
          useg = useg->next;
3001eac8:	e59d3020 	ldr	r3, [sp, #32]
3001eacc:	e5933000 	ldr	r3, [r3]
3001ead0:	e58d3020 	str	r3, [sp, #32]
3001ead4:	ea000001 	b	3001eae0 <tcp_output+0x85c>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
3001ead8:	e59d001c 	ldr	r0, [sp, #28]
3001eadc:	ebffe92e 	bl	30018f9c <tcp_seg_free>
    }
    seg = pcb->unsent;
3001eae0:	e59d300c 	ldr	r3, [sp, #12]
3001eae4:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001eae8:	e58d301c 	str	r3, [sp, #28]
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  //acoral_prints("\r\n==output--5\r\n");
  while (seg != NULL &&
3001eaec:	e59d301c 	ldr	r3, [sp, #28]
3001eaf0:	e3530000 	cmp	r3, #0
3001eaf4:	0a000019 	beq	3001eb60 <tcp_output+0x8dc>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
3001eaf8:	e59d301c 	ldr	r3, [sp, #28]
3001eafc:	e5933010 	ldr	r3, [r3, #16]
3001eb00:	e5d32004 	ldrb	r2, [r3, #4]
3001eb04:	e5d31005 	ldrb	r1, [r3, #5]
3001eb08:	e1a01401 	lsl	r1, r1, #8
3001eb0c:	e1812002 	orr	r2, r1, r2
3001eb10:	e5d31006 	ldrb	r1, [r3, #6]
3001eb14:	e1a01801 	lsl	r1, r1, #16
3001eb18:	e1812002 	orr	r2, r1, r2
3001eb1c:	e5d33007 	ldrb	r3, [r3, #7]
3001eb20:	e1a03c03 	lsl	r3, r3, #24
3001eb24:	e1833002 	orr	r3, r3, r2
3001eb28:	e1a00003 	mov	r0, r3
3001eb2c:	ebffd393 	bl	30013980 <ntohl>
3001eb30:	e1a02000 	mov	r2, r0
3001eb34:	e59d300c 	ldr	r3, [sp, #12]
3001eb38:	e5933044 	ldr	r3, [r3, #68]	; 0x44
3001eb3c:	e0632002 	rsb	r2, r3, r2
3001eb40:	e59d301c 	ldr	r3, [sp, #28]
3001eb44:	e1d330bc 	ldrh	r3, [r3, #12]
3001eb48:	e0822003 	add	r2, r2, r3
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  //acoral_prints("\r\n==output--5\r\n");
  while (seg != NULL &&
3001eb4c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001eb50:	e1520003 	cmp	r2, r3
3001eb54:	9afffef2 	bls	3001e724 <tcp_output+0x4a0>
3001eb58:	ea000000 	b	3001eb60 <tcp_output+0x8dc>
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      //acoral_prints("\r\n==output--6\r\n");
      break;
3001eb5c:	e1a00000 	nop			; (mov r0, r0)
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
  //acoral_prints("\r\n==output--8\r\n");
  if (seg != NULL && pcb->persist_backoff == 0 && 
3001eb60:	e59d301c 	ldr	r3, [sp, #28]
3001eb64:	e3530000 	cmp	r3, #0
3001eb68:	0a000024 	beq	3001ec00 <tcp_output+0x97c>
3001eb6c:	e59d300c 	ldr	r3, [sp, #12]
3001eb70:	e5d330a0 	ldrb	r3, [r3, #160]	; 0xa0
3001eb74:	e3530000 	cmp	r3, #0
3001eb78:	1a000020 	bne	3001ec00 <tcp_output+0x97c>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
3001eb7c:	e59d301c 	ldr	r3, [sp, #28]
3001eb80:	e5933010 	ldr	r3, [r3, #16]
3001eb84:	e5d32004 	ldrb	r2, [r3, #4]
3001eb88:	e5d31005 	ldrb	r1, [r3, #5]
3001eb8c:	e1a01401 	lsl	r1, r1, #8
3001eb90:	e1812002 	orr	r2, r1, r2
3001eb94:	e5d31006 	ldrb	r1, [r3, #6]
3001eb98:	e1a01801 	lsl	r1, r1, #16
3001eb9c:	e1812002 	orr	r2, r1, r2
3001eba0:	e5d33007 	ldrb	r3, [r3, #7]
3001eba4:	e1a03c03 	lsl	r3, r3, #24
3001eba8:	e1833002 	orr	r3, r3, r2
3001ebac:	e1a00003 	mov	r0, r3
3001ebb0:	ebffd372 	bl	30013980 <ntohl>
3001ebb4:	e1a02000 	mov	r2, r0
3001ebb8:	e59d300c 	ldr	r3, [sp, #12]
3001ebbc:	e5933044 	ldr	r3, [r3, #68]	; 0x44
3001ebc0:	e0632002 	rsb	r2, r3, r2
3001ebc4:	e59d301c 	ldr	r3, [sp, #28]
3001ebc8:	e1d330bc 	ldrh	r3, [r3, #12]
3001ebcc:	e0822003 	add	r2, r2, r3
3001ebd0:	e59d300c 	ldr	r3, [sp, #12]
3001ebd4:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
  //acoral_prints("\r\n==output--8\r\n");
  if (seg != NULL && pcb->persist_backoff == 0 && 
3001ebd8:	e1520003 	cmp	r2, r3
3001ebdc:	9a000007 	bls	3001ec00 <tcp_output+0x97c>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    acoral_prints("\r\n==output--9\r\n");
3001ebe0:	e59f004c 	ldr	r0, [pc, #76]	; 3001ec34 <tcp_output+0x9b0>
3001ebe4:	ebffb232 	bl	3000b4b4 <acoral_prints>
    pcb->persist_cnt = 0;
3001ebe8:	e59d300c 	ldr	r3, [sp, #12]
3001ebec:	e3a02000 	mov	r2, #0
3001ebf0:	e583209c 	str	r2, [r3, #156]	; 0x9c
    pcb->persist_backoff = 1;
3001ebf4:	e59d300c 	ldr	r3, [sp, #12]
3001ebf8:	e3a02001 	mov	r2, #1
3001ebfc:	e5c320a0 	strb	r2, [r3, #160]	; 0xa0
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
3001ec00:	e59d300c 	ldr	r3, [sp, #12]
3001ec04:	e5d3301c 	ldrb	r3, [r3, #28]
3001ec08:	e203307f 	and	r3, r3, #127	; 0x7f
3001ec0c:	e59d200c 	ldr	r2, [sp, #12]
3001ec10:	e5c2301c 	strb	r3, [r2, #28]
  return ERR_OK;
3001ec14:	e3a03000 	mov	r3, #0
3001ec18:	e1a03c03 	lsl	r3, r3, #24
3001ec1c:	e1a03c43 	asr	r3, r3, #24
}
3001ec20:	e1a00003 	mov	r0, r3
3001ec24:	e28dd02c 	add	sp, sp, #44	; 0x2c
3001ec28:	e8bd4030 	pop	{r4, r5, lr}
3001ec2c:	e12fff1e 	bx	lr
3001ec30:	3002a87c 	.word	0x3002a87c
3001ec34:	300265b4 	.word	0x300265b4

3001ec38 <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
3001ec38:	e92d4010 	push	{r4, lr}
3001ec3c:	e24dd018 	sub	sp, sp, #24
3001ec40:	e58d000c 	str	r0, [sp, #12]
3001ec44:	e58d1008 	str	r1, [sp, #8]
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
3001ec48:	e59d300c 	ldr	r3, [sp, #12]
3001ec4c:	e5934010 	ldr	r4, [r3, #16]
3001ec50:	e59d3008 	ldr	r3, [sp, #8]
3001ec54:	e5933020 	ldr	r3, [r3, #32]
3001ec58:	e1a00003 	mov	r0, r3
3001ec5c:	ebffd335 	bl	30013938 <htonl>
3001ec60:	e1a03000 	mov	r3, r0
3001ec64:	e20320ff 	and	r2, r3, #255	; 0xff
3001ec68:	e3a01000 	mov	r1, #0
3001ec6c:	e1812002 	orr	r2, r1, r2
3001ec70:	e5c42008 	strb	r2, [r4, #8]
3001ec74:	e1a02423 	lsr	r2, r3, #8
3001ec78:	e20220ff 	and	r2, r2, #255	; 0xff
3001ec7c:	e3a01000 	mov	r1, #0
3001ec80:	e1812002 	orr	r2, r1, r2
3001ec84:	e5c42009 	strb	r2, [r4, #9]
3001ec88:	e1a02823 	lsr	r2, r3, #16
3001ec8c:	e20220ff 	and	r2, r2, #255	; 0xff
3001ec90:	e3a01000 	mov	r1, #0
3001ec94:	e1812002 	orr	r2, r1, r2
3001ec98:	e5c4200a 	strb	r2, [r4, #10]
3001ec9c:	e1a03c23 	lsr	r3, r3, #24
3001eca0:	e3a02000 	mov	r2, #0
3001eca4:	e1823003 	orr	r3, r2, r3
3001eca8:	e5c4300b 	strb	r3, [r4, #11]

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
3001ecac:	e59d300c 	ldr	r3, [sp, #12]
3001ecb0:	e5934010 	ldr	r4, [r3, #16]
3001ecb4:	e59d3008 	ldr	r3, [sp, #8]
3001ecb8:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
3001ecbc:	e1a00003 	mov	r0, r3
3001ecc0:	ebffd2fd 	bl	300138bc <htons>
3001ecc4:	e1a03000 	mov	r3, r0
3001ecc8:	e20320ff 	and	r2, r3, #255	; 0xff
3001eccc:	e3a01000 	mov	r1, #0
3001ecd0:	e1812002 	orr	r2, r1, r2
3001ecd4:	e5c4200e 	strb	r2, [r4, #14]
3001ecd8:	e1a03423 	lsr	r3, r3, #8
3001ecdc:	e1a03803 	lsl	r3, r3, #16
3001ece0:	e1a03823 	lsr	r3, r3, #16
3001ece4:	e3a02000 	mov	r2, #0
3001ece8:	e1823003 	orr	r3, r2, r3
3001ecec:	e5c4300f 	strb	r3, [r4, #15]

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
3001ecf0:	e59d3008 	ldr	r3, [sp, #8]
3001ecf4:	e3530000 	cmp	r3, #0
3001ecf8:	0a000003 	beq	3001ed0c <tcp_output_segment+0xd4>
3001ecfc:	e59d3008 	ldr	r3, [sp, #8]
3001ed00:	e5933000 	ldr	r3, [r3]
3001ed04:	e3530000 	cmp	r3, #0
3001ed08:	1a000012 	bne	3001ed58 <tcp_output_segment+0x120>
    netif = ip_route(&(pcb->remote_ip));
3001ed0c:	e59d3008 	ldr	r3, [sp, #8]
3001ed10:	e2833004 	add	r3, r3, #4
3001ed14:	e1a00003 	mov	r0, r3
3001ed18:	ebffd53c 	bl	30014210 <ip_route>
3001ed1c:	e1a03000 	mov	r3, r0
3001ed20:	e58d3014 	str	r3, [sp, #20]
    if (netif == NULL) {
3001ed24:	e59d3014 	ldr	r3, [sp, #20]
3001ed28:	e3530000 	cmp	r3, #0
3001ed2c:	0a000085 	beq	3001ef48 <tcp_output_segment+0x310>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
3001ed30:	e59d3014 	ldr	r3, [sp, #20]
3001ed34:	e2833004 	add	r3, r3, #4
3001ed38:	e3530000 	cmp	r3, #0
3001ed3c:	0a000002 	beq	3001ed4c <tcp_output_segment+0x114>
3001ed40:	e59d3014 	ldr	r3, [sp, #20]
3001ed44:	e5933004 	ldr	r3, [r3, #4]
3001ed48:	ea000000 	b	3001ed50 <tcp_output_segment+0x118>
3001ed4c:	e3a03000 	mov	r3, #0
3001ed50:	e59d2008 	ldr	r2, [sp, #8]
3001ed54:	e5823000 	str	r3, [r2]
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
3001ed58:	e59d3008 	ldr	r3, [sp, #8]
3001ed5c:	e1d332be 	ldrh	r3, [r3, #46]	; 0x2e
3001ed60:	e1a03803 	lsl	r3, r3, #16
3001ed64:	e1a03843 	asr	r3, r3, #16
3001ed68:	e3730001 	cmn	r3, #1
3001ed6c:	1a000002 	bne	3001ed7c <tcp_output_segment+0x144>
    pcb->rtime = 0;
3001ed70:	e59d3008 	ldr	r3, [sp, #8]
3001ed74:	e3a02000 	mov	r2, #0
3001ed78:	e1c322be 	strh	r2, [r3, #46]	; 0x2e

  if (pcb->rttest == 0) {
3001ed7c:	e59d3008 	ldr	r3, [sp, #8]
3001ed80:	e5933034 	ldr	r3, [r3, #52]	; 0x34
3001ed84:	e3530000 	cmp	r3, #0
3001ed88:	1a000014 	bne	3001ede0 <tcp_output_segment+0x1a8>
    pcb->rttest = tcp_ticks;
3001ed8c:	e59f31c4 	ldr	r3, [pc, #452]	; 3001ef58 <tcp_output_segment+0x320>
3001ed90:	e5932000 	ldr	r2, [r3]
3001ed94:	e59d3008 	ldr	r3, [sp, #8]
3001ed98:	e5832034 	str	r2, [r3, #52]	; 0x34
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
3001ed9c:	e59d300c 	ldr	r3, [sp, #12]
3001eda0:	e5933010 	ldr	r3, [r3, #16]
3001eda4:	e5d32004 	ldrb	r2, [r3, #4]
3001eda8:	e5d31005 	ldrb	r1, [r3, #5]
3001edac:	e1a01401 	lsl	r1, r1, #8
3001edb0:	e1812002 	orr	r2, r1, r2
3001edb4:	e5d31006 	ldrb	r1, [r3, #6]
3001edb8:	e1a01801 	lsl	r1, r1, #16
3001edbc:	e1812002 	orr	r2, r1, r2
3001edc0:	e5d33007 	ldrb	r3, [r3, #7]
3001edc4:	e1a03c03 	lsl	r3, r3, #24
3001edc8:	e1833002 	orr	r3, r3, r2
3001edcc:	e1a00003 	mov	r0, r3
3001edd0:	ebffd2ea 	bl	30013980 <ntohl>
3001edd4:	e1a02000 	mov	r2, r0
3001edd8:	e59d3008 	ldr	r3, [sp, #8]
3001eddc:	e5832038 	str	r2, [r3, #56]	; 0x38
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
3001ede0:	e59d300c 	ldr	r3, [sp, #12]
3001ede4:	e5933010 	ldr	r3, [r3, #16]
3001ede8:	e1a03803 	lsl	r3, r3, #16
3001edec:	e1a02823 	lsr	r2, r3, #16
3001edf0:	e59d300c 	ldr	r3, [sp, #12]
3001edf4:	e5933004 	ldr	r3, [r3, #4]
3001edf8:	e5933004 	ldr	r3, [r3, #4]
3001edfc:	e1a03803 	lsl	r3, r3, #16
3001ee00:	e1a03823 	lsr	r3, r3, #16
3001ee04:	e0633002 	rsb	r3, r3, r2
3001ee08:	e1cd31b2 	strh	r3, [sp, #18]

  seg->p->len -= len;
3001ee0c:	e59d300c 	ldr	r3, [sp, #12]
3001ee10:	e5933004 	ldr	r3, [r3, #4]
3001ee14:	e59d200c 	ldr	r2, [sp, #12]
3001ee18:	e5922004 	ldr	r2, [r2, #4]
3001ee1c:	e1d210ba 	ldrh	r1, [r2, #10]
3001ee20:	e1dd21b2 	ldrh	r2, [sp, #18]
3001ee24:	e0622001 	rsb	r2, r2, r1
3001ee28:	e1a02802 	lsl	r2, r2, #16
3001ee2c:	e1a02822 	lsr	r2, r2, #16
3001ee30:	e1c320ba 	strh	r2, [r3, #10]
  seg->p->tot_len -= len;
3001ee34:	e59d300c 	ldr	r3, [sp, #12]
3001ee38:	e5933004 	ldr	r3, [r3, #4]
3001ee3c:	e59d200c 	ldr	r2, [sp, #12]
3001ee40:	e5922004 	ldr	r2, [r2, #4]
3001ee44:	e1d210b8 	ldrh	r1, [r2, #8]
3001ee48:	e1dd21b2 	ldrh	r2, [sp, #18]
3001ee4c:	e0622001 	rsb	r2, r2, r1
3001ee50:	e1a02802 	lsl	r2, r2, #16
3001ee54:	e1a02822 	lsr	r2, r2, #16
3001ee58:	e1c320b8 	strh	r2, [r3, #8]

  seg->p->payload = seg->tcphdr;
3001ee5c:	e59d300c 	ldr	r3, [sp, #12]
3001ee60:	e5933004 	ldr	r3, [r3, #4]
3001ee64:	e59d200c 	ldr	r2, [sp, #12]
3001ee68:	e5922010 	ldr	r2, [r2, #16]
3001ee6c:	e5832004 	str	r2, [r3, #4]

  seg->tcphdr->chksum = 0;
3001ee70:	e59d300c 	ldr	r3, [sp, #12]
3001ee74:	e5933010 	ldr	r3, [r3, #16]
3001ee78:	e3a02000 	mov	r2, #0
3001ee7c:	e5c32010 	strb	r2, [r3, #16]
3001ee80:	e3a02000 	mov	r2, #0
3001ee84:	e5c32011 	strb	r2, [r3, #17]
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
3001ee88:	e59d300c 	ldr	r3, [sp, #12]
3001ee8c:	e5934010 	ldr	r4, [r3, #16]
3001ee90:	e59d300c 	ldr	r3, [sp, #12]
3001ee94:	e5931004 	ldr	r1, [r3, #4]
3001ee98:	e59d2008 	ldr	r2, [sp, #8]
3001ee9c:	e59d3008 	ldr	r3, [sp, #8]
3001eea0:	e2833004 	add	r3, r3, #4
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
3001eea4:	e59d000c 	ldr	r0, [sp, #12]
3001eea8:	e5900004 	ldr	r0, [r0, #4]

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
3001eeac:	e1d000b8 	ldrh	r0, [r0, #8]
3001eeb0:	e58d0000 	str	r0, [sp]
3001eeb4:	e1a00001 	mov	r0, r1
3001eeb8:	e1a01002 	mov	r1, r2
3001eebc:	e1a02003 	mov	r2, r3
3001eec0:	e3a03006 	mov	r3, #6
3001eec4:	ebffd303 	bl	30013ad8 <inet_chksum_pseudo>
3001eec8:	e1a03000 	mov	r3, r0
3001eecc:	e20320ff 	and	r2, r3, #255	; 0xff
3001eed0:	e3a01000 	mov	r1, #0
3001eed4:	e1812002 	orr	r2, r1, r2
3001eed8:	e5c42010 	strb	r2, [r4, #16]
3001eedc:	e1a03423 	lsr	r3, r3, #8
3001eee0:	e1a03803 	lsl	r3, r3, #16
3001eee4:	e1a03823 	lsr	r3, r3, #16
3001eee8:	e3a02000 	mov	r2, #0
3001eeec:	e1823003 	orr	r3, r2, r3
3001eef0:	e5c43011 	strb	r3, [r4, #17]
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
3001eef4:	e59f3060 	ldr	r3, [pc, #96]	; 3001ef5c <tcp_output_segment+0x324>
3001eef8:	e1d339bc 	ldrh	r3, [r3, #156]	; 0x9c
3001eefc:	e2833001 	add	r3, r3, #1
3001ef00:	e1a03803 	lsl	r3, r3, #16
3001ef04:	e1a02823 	lsr	r2, r3, #16
3001ef08:	e59f304c 	ldr	r3, [pc, #76]	; 3001ef5c <tcp_output_segment+0x324>
3001ef0c:	e1c329bc 	strh	r2, [r3, #156]	; 0x9c
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  //acoral_print("\r\ntOutS-S1\r\n");
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
3001ef10:	e59d300c 	ldr	r3, [sp, #12]
3001ef14:	e5930004 	ldr	r0, [r3, #4]
3001ef18:	e59d1008 	ldr	r1, [sp, #8]
3001ef1c:	e59d3008 	ldr	r3, [sp, #8]
3001ef20:	e2832004 	add	r2, r3, #4
3001ef24:	e59d3008 	ldr	r3, [sp, #8]
3001ef28:	e5d3300b 	ldrb	r3, [r3, #11]
3001ef2c:	e59dc008 	ldr	ip, [sp, #8]
3001ef30:	e5dcc00a 	ldrb	ip, [ip, #10]
3001ef34:	e58dc000 	str	ip, [sp]
3001ef38:	e3a0c006 	mov	ip, #6
3001ef3c:	e58dc004 	str	ip, [sp, #4]
3001ef40:	ebffd7d0 	bl	30014e88 <ip_output>
3001ef44:	ea000000 	b	3001ef4c <tcp_output_segment+0x314>
  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    netif = ip_route(&(pcb->remote_ip));
    if (netif == NULL) {
      return;
3001ef48:	e1a00000 	nop			; (mov r0, r0)
  //acoral_print("\r\ntOutS-S1\r\n");
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
  //acoral_print("\r\ntOutE-S1\r\n");
#endif /* LWIP_NETIF_HWADDRHINT*/
}
3001ef4c:	e28dd018 	add	sp, sp, #24
3001ef50:	e8bd4010 	pop	{r4, lr}
3001ef54:	e12fff1e 	bx	lr
3001ef58:	3002a724 	.word	0x3002a724
3001ef5c:	3002b214 	.word	0x3002b214

3001ef60 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
3001ef60:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001ef64:	e24dd024 	sub	sp, sp, #36	; 0x24
3001ef68:	e58d0014 	str	r0, [sp, #20]
3001ef6c:	e58d1010 	str	r1, [sp, #16]
3001ef70:	e58d200c 	str	r2, [sp, #12]
3001ef74:	e58d3008 	str	r3, [sp, #8]
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
3001ef78:	e3a00001 	mov	r0, #1
3001ef7c:	e3a01014 	mov	r1, #20
3001ef80:	e3a02000 	mov	r2, #0
3001ef84:	ebffdbba 	bl	30015e74 <pbuf_alloc>
3001ef88:	e1a03000 	mov	r3, r0
3001ef8c:	e58d3018 	str	r3, [sp, #24]
  if (p == NULL) {
3001ef90:	e59d3018 	ldr	r3, [sp, #24]
3001ef94:	e3530000 	cmp	r3, #0
3001ef98:	0a0000cb 	beq	3001f2cc <tcp_rst+0x36c>
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
3001ef9c:	e59d3018 	ldr	r3, [sp, #24]
3001efa0:	e5933004 	ldr	r3, [r3, #4]
3001efa4:	e58d301c 	str	r3, [sp, #28]
  tcphdr->src = htons(local_port);
3001efa8:	e1dd32b8 	ldrh	r3, [sp, #40]	; 0x28
3001efac:	e1a00003 	mov	r0, r3
3001efb0:	ebffd241 	bl	300138bc <htons>
3001efb4:	e1a03000 	mov	r3, r0
3001efb8:	e1a02003 	mov	r2, r3
3001efbc:	e59d301c 	ldr	r3, [sp, #28]
3001efc0:	e20210ff 	and	r1, r2, #255	; 0xff
3001efc4:	e3a00000 	mov	r0, #0
3001efc8:	e1801001 	orr	r1, r0, r1
3001efcc:	e5c31000 	strb	r1, [r3]
3001efd0:	e1a02422 	lsr	r2, r2, #8
3001efd4:	e1a02802 	lsl	r2, r2, #16
3001efd8:	e1a02822 	lsr	r2, r2, #16
3001efdc:	e3a01000 	mov	r1, #0
3001efe0:	e1812002 	orr	r2, r1, r2
3001efe4:	e5c32001 	strb	r2, [r3, #1]
  tcphdr->dest = htons(remote_port);
3001efe8:	e1dd32bc 	ldrh	r3, [sp, #44]	; 0x2c
3001efec:	e1a00003 	mov	r0, r3
3001eff0:	ebffd231 	bl	300138bc <htons>
3001eff4:	e1a03000 	mov	r3, r0
3001eff8:	e1a02003 	mov	r2, r3
3001effc:	e59d301c 	ldr	r3, [sp, #28]
3001f000:	e20210ff 	and	r1, r2, #255	; 0xff
3001f004:	e3a00000 	mov	r0, #0
3001f008:	e1801001 	orr	r1, r0, r1
3001f00c:	e5c31002 	strb	r1, [r3, #2]
3001f010:	e1a02422 	lsr	r2, r2, #8
3001f014:	e1a02802 	lsl	r2, r2, #16
3001f018:	e1a02822 	lsr	r2, r2, #16
3001f01c:	e3a01000 	mov	r1, #0
3001f020:	e1812002 	orr	r2, r1, r2
3001f024:	e5c32003 	strb	r2, [r3, #3]
  tcphdr->seqno = htonl(seqno);
3001f028:	e59d0014 	ldr	r0, [sp, #20]
3001f02c:	ebffd241 	bl	30013938 <htonl>
3001f030:	e1a02000 	mov	r2, r0
3001f034:	e59d301c 	ldr	r3, [sp, #28]
3001f038:	e20210ff 	and	r1, r2, #255	; 0xff
3001f03c:	e3a00000 	mov	r0, #0
3001f040:	e1801001 	orr	r1, r0, r1
3001f044:	e5c31004 	strb	r1, [r3, #4]
3001f048:	e1a01422 	lsr	r1, r2, #8
3001f04c:	e20110ff 	and	r1, r1, #255	; 0xff
3001f050:	e3a00000 	mov	r0, #0
3001f054:	e1801001 	orr	r1, r0, r1
3001f058:	e5c31005 	strb	r1, [r3, #5]
3001f05c:	e1a01822 	lsr	r1, r2, #16
3001f060:	e20110ff 	and	r1, r1, #255	; 0xff
3001f064:	e3a00000 	mov	r0, #0
3001f068:	e1801001 	orr	r1, r0, r1
3001f06c:	e5c31006 	strb	r1, [r3, #6]
3001f070:	e1a02c22 	lsr	r2, r2, #24
3001f074:	e3a01000 	mov	r1, #0
3001f078:	e1812002 	orr	r2, r1, r2
3001f07c:	e5c32007 	strb	r2, [r3, #7]
  tcphdr->ackno = htonl(ackno);
3001f080:	e59d0010 	ldr	r0, [sp, #16]
3001f084:	ebffd22b 	bl	30013938 <htonl>
3001f088:	e1a02000 	mov	r2, r0
3001f08c:	e59d301c 	ldr	r3, [sp, #28]
3001f090:	e20210ff 	and	r1, r2, #255	; 0xff
3001f094:	e3a00000 	mov	r0, #0
3001f098:	e1801001 	orr	r1, r0, r1
3001f09c:	e5c31008 	strb	r1, [r3, #8]
3001f0a0:	e1a01422 	lsr	r1, r2, #8
3001f0a4:	e20110ff 	and	r1, r1, #255	; 0xff
3001f0a8:	e3a00000 	mov	r0, #0
3001f0ac:	e1801001 	orr	r1, r0, r1
3001f0b0:	e5c31009 	strb	r1, [r3, #9]
3001f0b4:	e1a01822 	lsr	r1, r2, #16
3001f0b8:	e20110ff 	and	r1, r1, #255	; 0xff
3001f0bc:	e3a00000 	mov	r0, #0
3001f0c0:	e1801001 	orr	r1, r0, r1
3001f0c4:	e5c3100a 	strb	r1, [r3, #10]
3001f0c8:	e1a02c22 	lsr	r2, r2, #24
3001f0cc:	e3a01000 	mov	r1, #0
3001f0d0:	e1812002 	orr	r2, r1, r2
3001f0d4:	e5c3200b 	strb	r2, [r3, #11]
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
3001f0d8:	e59d301c 	ldr	r3, [sp, #28]
3001f0dc:	e5d3200c 	ldrb	r2, [r3, #12]
3001f0e0:	e5d3300d 	ldrb	r3, [r3, #13]
3001f0e4:	e1a03403 	lsl	r3, r3, #8
3001f0e8:	e1833002 	orr	r3, r3, r2
3001f0ec:	e1a03803 	lsl	r3, r3, #16
3001f0f0:	e1a03823 	lsr	r3, r3, #16
3001f0f4:	e1a00003 	mov	r0, r3
3001f0f8:	ebffd202 	bl	30013908 <ntohs>
3001f0fc:	e1a03000 	mov	r3, r0
3001f100:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3001f104:	e1a03803 	lsl	r3, r3, #16
3001f108:	e1a03823 	lsr	r3, r3, #16
3001f10c:	e3833014 	orr	r3, r3, #20
3001f110:	e1a03803 	lsl	r3, r3, #16
3001f114:	e1a03823 	lsr	r3, r3, #16
3001f118:	e1a00003 	mov	r0, r3
3001f11c:	ebffd1e6 	bl	300138bc <htons>
3001f120:	e1a03000 	mov	r3, r0
3001f124:	e1a02003 	mov	r2, r3
3001f128:	e59d301c 	ldr	r3, [sp, #28]
3001f12c:	e20210ff 	and	r1, r2, #255	; 0xff
3001f130:	e3a00000 	mov	r0, #0
3001f134:	e1801001 	orr	r1, r0, r1
3001f138:	e5c3100c 	strb	r1, [r3, #12]
3001f13c:	e1a02422 	lsr	r2, r2, #8
3001f140:	e1a02802 	lsl	r2, r2, #16
3001f144:	e1a02822 	lsr	r2, r2, #16
3001f148:	e3a01000 	mov	r1, #0
3001f14c:	e1812002 	orr	r2, r1, r2
3001f150:	e5c3200d 	strb	r2, [r3, #13]
  tcphdr->wnd = htons(TCP_WND);
3001f154:	e3a00b02 	mov	r0, #2048	; 0x800
3001f158:	ebffd1d7 	bl	300138bc <htons>
3001f15c:	e1a03000 	mov	r3, r0
3001f160:	e1a02003 	mov	r2, r3
3001f164:	e59d301c 	ldr	r3, [sp, #28]
3001f168:	e20210ff 	and	r1, r2, #255	; 0xff
3001f16c:	e3a00000 	mov	r0, #0
3001f170:	e1801001 	orr	r1, r0, r1
3001f174:	e5c3100e 	strb	r1, [r3, #14]
3001f178:	e1a02422 	lsr	r2, r2, #8
3001f17c:	e1a02802 	lsl	r2, r2, #16
3001f180:	e1a02822 	lsr	r2, r2, #16
3001f184:	e3a01000 	mov	r1, #0
3001f188:	e1812002 	orr	r2, r1, r2
3001f18c:	e5c3200f 	strb	r2, [r3, #15]
  tcphdr->urgp = 0;
3001f190:	e59d301c 	ldr	r3, [sp, #28]
3001f194:	e3a02000 	mov	r2, #0
3001f198:	e5c32012 	strb	r2, [r3, #18]
3001f19c:	e3a02000 	mov	r2, #0
3001f1a0:	e5c32013 	strb	r2, [r3, #19]
  TCPH_HDRLEN_SET(tcphdr, 5);
3001f1a4:	e59d301c 	ldr	r3, [sp, #28]
3001f1a8:	e5d3200c 	ldrb	r2, [r3, #12]
3001f1ac:	e5d3300d 	ldrb	r3, [r3, #13]
3001f1b0:	e1a03403 	lsl	r3, r3, #8
3001f1b4:	e1833002 	orr	r3, r3, r2
3001f1b8:	e1a03803 	lsl	r3, r3, #16
3001f1bc:	e1a03823 	lsr	r3, r3, #16
3001f1c0:	e1a00003 	mov	r0, r3
3001f1c4:	ebffd1cf 	bl	30013908 <ntohs>
3001f1c8:	e1a03000 	mov	r3, r0
3001f1cc:	e203303f 	and	r3, r3, #63	; 0x3f
3001f1d0:	e3833a05 	orr	r3, r3, #20480	; 0x5000
3001f1d4:	e1a03803 	lsl	r3, r3, #16
3001f1d8:	e1a03823 	lsr	r3, r3, #16
3001f1dc:	e1a00003 	mov	r0, r3
3001f1e0:	ebffd1b5 	bl	300138bc <htons>
3001f1e4:	e1a03000 	mov	r3, r0
3001f1e8:	e1a02003 	mov	r2, r3
3001f1ec:	e59d301c 	ldr	r3, [sp, #28]
3001f1f0:	e20210ff 	and	r1, r2, #255	; 0xff
3001f1f4:	e3a00000 	mov	r0, #0
3001f1f8:	e1801001 	orr	r1, r0, r1
3001f1fc:	e5c3100c 	strb	r1, [r3, #12]
3001f200:	e1a02422 	lsr	r2, r2, #8
3001f204:	e1a02802 	lsl	r2, r2, #16
3001f208:	e1a02822 	lsr	r2, r2, #16
3001f20c:	e3a01000 	mov	r1, #0
3001f210:	e1812002 	orr	r2, r1, r2
3001f214:	e5c3200d 	strb	r2, [r3, #13]

  tcphdr->chksum = 0;
3001f218:	e59d301c 	ldr	r3, [sp, #28]
3001f21c:	e3a02000 	mov	r2, #0
3001f220:	e5c32010 	strb	r2, [r3, #16]
3001f224:	e3a02000 	mov	r2, #0
3001f228:	e5c32011 	strb	r2, [r3, #17]
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
3001f22c:	e59d3018 	ldr	r3, [sp, #24]
3001f230:	e1d330b8 	ldrh	r3, [r3, #8]
3001f234:	e58d3000 	str	r3, [sp]
3001f238:	e59d0018 	ldr	r0, [sp, #24]
3001f23c:	e59d100c 	ldr	r1, [sp, #12]
3001f240:	e59d2008 	ldr	r2, [sp, #8]
3001f244:	e3a03006 	mov	r3, #6
3001f248:	ebffd222 	bl	30013ad8 <inet_chksum_pseudo>
3001f24c:	e1a03000 	mov	r3, r0
3001f250:	e1a02003 	mov	r2, r3
3001f254:	e59d301c 	ldr	r3, [sp, #28]
3001f258:	e20210ff 	and	r1, r2, #255	; 0xff
3001f25c:	e3a00000 	mov	r0, #0
3001f260:	e1801001 	orr	r1, r0, r1
3001f264:	e5c31010 	strb	r1, [r3, #16]
3001f268:	e1a02422 	lsr	r2, r2, #8
3001f26c:	e1a02802 	lsl	r2, r2, #16
3001f270:	e1a02822 	lsr	r2, r2, #16
3001f274:	e3a01000 	mov	r1, #0
3001f278:	e1812002 	orr	r2, r1, r2
3001f27c:	e5c32011 	strb	r2, [r3, #17]
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
3001f280:	e59f3054 	ldr	r3, [pc, #84]	; 3001f2dc <tcp_rst+0x37c>
3001f284:	e1d339bc 	ldrh	r3, [r3, #156]	; 0x9c
3001f288:	e2833001 	add	r3, r3, #1
3001f28c:	e1a03803 	lsl	r3, r3, #16
3001f290:	e1a02823 	lsr	r2, r3, #16
3001f294:	e59f3040 	ldr	r3, [pc, #64]	; 3001f2dc <tcp_rst+0x37c>
3001f298:	e1c329bc 	strh	r2, [r3, #156]	; 0x9c
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
3001f29c:	e3a03000 	mov	r3, #0
3001f2a0:	e58d3000 	str	r3, [sp]
3001f2a4:	e3a03006 	mov	r3, #6
3001f2a8:	e58d3004 	str	r3, [sp, #4]
3001f2ac:	e59d0018 	ldr	r0, [sp, #24]
3001f2b0:	e59d100c 	ldr	r1, [sp, #12]
3001f2b4:	e59d2008 	ldr	r2, [sp, #8]
3001f2b8:	e3a030ff 	mov	r3, #255	; 0xff
3001f2bc:	ebffd6f1 	bl	30014e88 <ip_output>
  pbuf_free(p);
3001f2c0:	e59d0018 	ldr	r0, [sp, #24]
3001f2c4:	ebffdc99 	bl	30016530 <pbuf_free>
3001f2c8:	ea000000 	b	3001f2d0 <tcp_rst+0x370>
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
3001f2cc:	e1a00000 	nop			; (mov r0, r0)
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
3001f2d0:	e28dd024 	add	sp, sp, #36	; 0x24
3001f2d4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001f2d8:	e12fff1e 	bx	lr
3001f2dc:	3002b214 	.word	0x3002b214

3001f2e0 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
3001f2e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001f2e4:	e24dd014 	sub	sp, sp, #20
3001f2e8:	e58d0004 	str	r0, [sp, #4]
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
3001f2ec:	e59d3004 	ldr	r3, [sp, #4]
3001f2f0:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001f2f4:	e3530000 	cmp	r3, #0
3001f2f8:	0a000033 	beq	3001f3cc <tcp_rexmit_rto+0xec>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
3001f2fc:	e59d3004 	ldr	r3, [sp, #4]
3001f300:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001f304:	e58d300c 	str	r3, [sp, #12]
3001f308:	ea000002 	b	3001f318 <tcp_rexmit_rto+0x38>
3001f30c:	e59d300c 	ldr	r3, [sp, #12]
3001f310:	e5933000 	ldr	r3, [r3]
3001f314:	e58d300c 	str	r3, [sp, #12]
3001f318:	e59d300c 	ldr	r3, [sp, #12]
3001f31c:	e5933000 	ldr	r3, [r3]
3001f320:	e3530000 	cmp	r3, #0
3001f324:	1afffff8 	bne	3001f30c <tcp_rexmit_rto+0x2c>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
3001f328:	e59d3004 	ldr	r3, [sp, #4]
3001f32c:	e5932070 	ldr	r2, [r3, #112]	; 0x70
3001f330:	e59d300c 	ldr	r3, [sp, #12]
3001f334:	e5832000 	str	r2, [r3]
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
3001f338:	e59d3004 	ldr	r3, [sp, #4]
3001f33c:	e5932074 	ldr	r2, [r3, #116]	; 0x74
3001f340:	e59d3004 	ldr	r3, [sp, #4]
3001f344:	e5832070 	str	r2, [r3, #112]	; 0x70
  /* unacked queue is now empty */
  pcb->unacked = NULL;
3001f348:	e59d3004 	ldr	r3, [sp, #4]
3001f34c:	e3a02000 	mov	r2, #0
3001f350:	e5832074 	str	r2, [r3, #116]	; 0x74

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
3001f354:	e59d3004 	ldr	r3, [sp, #4]
3001f358:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001f35c:	e5933010 	ldr	r3, [r3, #16]
3001f360:	e5d32004 	ldrb	r2, [r3, #4]
3001f364:	e5d31005 	ldrb	r1, [r3, #5]
3001f368:	e1a01401 	lsl	r1, r1, #8
3001f36c:	e1812002 	orr	r2, r1, r2
3001f370:	e5d31006 	ldrb	r1, [r3, #6]
3001f374:	e1a01801 	lsl	r1, r1, #16
3001f378:	e1812002 	orr	r2, r1, r2
3001f37c:	e5d33007 	ldrb	r3, [r3, #7]
3001f380:	e1a03c03 	lsl	r3, r3, #24
3001f384:	e1833002 	orr	r3, r3, r2
3001f388:	e1a00003 	mov	r0, r3
3001f38c:	ebffd17b 	bl	30013980 <ntohl>
3001f390:	e1a02000 	mov	r2, r0
3001f394:	e59d3004 	ldr	r3, [sp, #4]
3001f398:	e5832050 	str	r2, [r3, #80]	; 0x50
  /* increment number of retransmissions */
  ++pcb->nrtx;
3001f39c:	e59d3004 	ldr	r3, [sp, #4]
3001f3a0:	e5d33042 	ldrb	r3, [r3, #66]	; 0x42
3001f3a4:	e2833001 	add	r3, r3, #1
3001f3a8:	e20320ff 	and	r2, r3, #255	; 0xff
3001f3ac:	e59d3004 	ldr	r3, [sp, #4]
3001f3b0:	e5c32042 	strb	r2, [r3, #66]	; 0x42

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
3001f3b4:	e59d3004 	ldr	r3, [sp, #4]
3001f3b8:	e3a02000 	mov	r2, #0
3001f3bc:	e5832034 	str	r2, [r3, #52]	; 0x34

  /* Do the actual retransmission */
  tcp_output(pcb);
3001f3c0:	e59d0004 	ldr	r0, [sp, #4]
3001f3c4:	ebfffbae 	bl	3001e284 <tcp_output>
3001f3c8:	ea000000 	b	3001f3d0 <tcp_rexmit_rto+0xf0>
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
3001f3cc:	e1a00000 	nop			; (mov r0, r0)
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
}
3001f3d0:	e28dd014 	add	sp, sp, #20
3001f3d4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001f3d8:	e12fff1e 	bx	lr

3001f3dc <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
3001f3dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001f3e0:	e24dd014 	sub	sp, sp, #20
3001f3e4:	e58d0004 	str	r0, [sp, #4]
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
3001f3e8:	e59d3004 	ldr	r3, [sp, #4]
3001f3ec:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001f3f0:	e3530000 	cmp	r3, #0
3001f3f4:	0a00002d 	beq	3001f4b0 <tcp_rexmit+0xd4>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
3001f3f8:	e59d3004 	ldr	r3, [sp, #4]
3001f3fc:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001f400:	e5933000 	ldr	r3, [r3]
3001f404:	e58d300c 	str	r3, [sp, #12]
  pcb->unacked->next = pcb->unsent;
3001f408:	e59d3004 	ldr	r3, [sp, #4]
3001f40c:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001f410:	e59d2004 	ldr	r2, [sp, #4]
3001f414:	e5922070 	ldr	r2, [r2, #112]	; 0x70
3001f418:	e5832000 	str	r2, [r3]
  pcb->unsent = pcb->unacked;
3001f41c:	e59d3004 	ldr	r3, [sp, #4]
3001f420:	e5932074 	ldr	r2, [r3, #116]	; 0x74
3001f424:	e59d3004 	ldr	r3, [sp, #4]
3001f428:	e5832070 	str	r2, [r3, #112]	; 0x70
  pcb->unacked = seg;
3001f42c:	e59d3004 	ldr	r3, [sp, #4]
3001f430:	e59d200c 	ldr	r2, [sp, #12]
3001f434:	e5832074 	str	r2, [r3, #116]	; 0x74

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
3001f438:	e59d3004 	ldr	r3, [sp, #4]
3001f43c:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001f440:	e5933010 	ldr	r3, [r3, #16]
3001f444:	e5d32004 	ldrb	r2, [r3, #4]
3001f448:	e5d31005 	ldrb	r1, [r3, #5]
3001f44c:	e1a01401 	lsl	r1, r1, #8
3001f450:	e1812002 	orr	r2, r1, r2
3001f454:	e5d31006 	ldrb	r1, [r3, #6]
3001f458:	e1a01801 	lsl	r1, r1, #16
3001f45c:	e1812002 	orr	r2, r1, r2
3001f460:	e5d33007 	ldrb	r3, [r3, #7]
3001f464:	e1a03c03 	lsl	r3, r3, #24
3001f468:	e1833002 	orr	r3, r3, r2
3001f46c:	e1a00003 	mov	r0, r3
3001f470:	ebffd142 	bl	30013980 <ntohl>
3001f474:	e1a02000 	mov	r2, r0
3001f478:	e59d3004 	ldr	r3, [sp, #4]
3001f47c:	e5832050 	str	r2, [r3, #80]	; 0x50

  ++pcb->nrtx;
3001f480:	e59d3004 	ldr	r3, [sp, #4]
3001f484:	e5d33042 	ldrb	r3, [r3, #66]	; 0x42
3001f488:	e2833001 	add	r3, r3, #1
3001f48c:	e20320ff 	and	r2, r3, #255	; 0xff
3001f490:	e59d3004 	ldr	r3, [sp, #4]
3001f494:	e5c32042 	strb	r2, [r3, #66]	; 0x42

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
3001f498:	e59d3004 	ldr	r3, [sp, #4]
3001f49c:	e3a02000 	mov	r2, #0
3001f4a0:	e5832034 	str	r2, [r3, #52]	; 0x34

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
3001f4a4:	e59d0004 	ldr	r0, [sp, #4]
3001f4a8:	ebfffb75 	bl	3001e284 <tcp_output>
3001f4ac:	ea000000 	b	3001f4b4 <tcp_rexmit+0xd8>
tcp_rexmit(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
3001f4b0:	e1a00000 	nop			; (mov r0, r0)
  pcb->rttest = 0;

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
}
3001f4b4:	e28dd014 	add	sp, sp, #20
3001f4b8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001f4bc:	e12fff1e 	bx	lr

3001f4c0 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
3001f4c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001f4c4:	e24dd01c 	sub	sp, sp, #28
3001f4c8:	e58d000c 	str	r0, [sp, #12]
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
3001f4cc:	e3a00001 	mov	r0, #1
3001f4d0:	e3a01014 	mov	r1, #20
3001f4d4:	e3a02000 	mov	r2, #0
3001f4d8:	ebffda65 	bl	30015e74 <pbuf_alloc>
3001f4dc:	e1a03000 	mov	r3, r0
3001f4e0:	e58d3010 	str	r3, [sp, #16]
   
  if(p == NULL) {
3001f4e4:	e59d3010 	ldr	r3, [sp, #16]
3001f4e8:	e3530000 	cmp	r3, #0
3001f4ec:	0a0000d6 	beq	3001f84c <tcp_keepalive+0x38c>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
3001f4f0:	e59d3010 	ldr	r3, [sp, #16]
3001f4f4:	e5933004 	ldr	r3, [r3, #4]
3001f4f8:	e58d3014 	str	r3, [sp, #20]
  tcphdr->src = htons(pcb->local_port);
3001f4fc:	e59d300c 	ldr	r3, [sp, #12]
3001f500:	e1d331b8 	ldrh	r3, [r3, #24]
3001f504:	e1a00003 	mov	r0, r3
3001f508:	ebffd0eb 	bl	300138bc <htons>
3001f50c:	e1a03000 	mov	r3, r0
3001f510:	e1a02003 	mov	r2, r3
3001f514:	e59d3014 	ldr	r3, [sp, #20]
3001f518:	e20210ff 	and	r1, r2, #255	; 0xff
3001f51c:	e3a00000 	mov	r0, #0
3001f520:	e1801001 	orr	r1, r0, r1
3001f524:	e5c31000 	strb	r1, [r3]
3001f528:	e1a02422 	lsr	r2, r2, #8
3001f52c:	e1a02802 	lsl	r2, r2, #16
3001f530:	e1a02822 	lsr	r2, r2, #16
3001f534:	e3a01000 	mov	r1, #0
3001f538:	e1812002 	orr	r2, r1, r2
3001f53c:	e5c32001 	strb	r2, [r3, #1]
  tcphdr->dest = htons(pcb->remote_port);
3001f540:	e59d300c 	ldr	r3, [sp, #12]
3001f544:	e1d331ba 	ldrh	r3, [r3, #26]
3001f548:	e1a00003 	mov	r0, r3
3001f54c:	ebffd0da 	bl	300138bc <htons>
3001f550:	e1a03000 	mov	r3, r0
3001f554:	e1a02003 	mov	r2, r3
3001f558:	e59d3014 	ldr	r3, [sp, #20]
3001f55c:	e20210ff 	and	r1, r2, #255	; 0xff
3001f560:	e3a00000 	mov	r0, #0
3001f564:	e1801001 	orr	r1, r0, r1
3001f568:	e5c31002 	strb	r1, [r3, #2]
3001f56c:	e1a02422 	lsr	r2, r2, #8
3001f570:	e1a02802 	lsl	r2, r2, #16
3001f574:	e1a02822 	lsr	r2, r2, #16
3001f578:	e3a01000 	mov	r1, #0
3001f57c:	e1812002 	orr	r2, r1, r2
3001f580:	e5c32003 	strb	r2, [r3, #3]
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
3001f584:	e59d300c 	ldr	r3, [sp, #12]
3001f588:	e5933050 	ldr	r3, [r3, #80]	; 0x50
3001f58c:	e2433001 	sub	r3, r3, #1
3001f590:	e1a00003 	mov	r0, r3
3001f594:	ebffd0e7 	bl	30013938 <htonl>
3001f598:	e1a02000 	mov	r2, r0
3001f59c:	e59d3014 	ldr	r3, [sp, #20]
3001f5a0:	e20210ff 	and	r1, r2, #255	; 0xff
3001f5a4:	e3a00000 	mov	r0, #0
3001f5a8:	e1801001 	orr	r1, r0, r1
3001f5ac:	e5c31004 	strb	r1, [r3, #4]
3001f5b0:	e1a01422 	lsr	r1, r2, #8
3001f5b4:	e20110ff 	and	r1, r1, #255	; 0xff
3001f5b8:	e3a00000 	mov	r0, #0
3001f5bc:	e1801001 	orr	r1, r0, r1
3001f5c0:	e5c31005 	strb	r1, [r3, #5]
3001f5c4:	e1a01822 	lsr	r1, r2, #16
3001f5c8:	e20110ff 	and	r1, r1, #255	; 0xff
3001f5cc:	e3a00000 	mov	r0, #0
3001f5d0:	e1801001 	orr	r1, r0, r1
3001f5d4:	e5c31006 	strb	r1, [r3, #6]
3001f5d8:	e1a02c22 	lsr	r2, r2, #24
3001f5dc:	e3a01000 	mov	r1, #0
3001f5e0:	e1812002 	orr	r2, r1, r2
3001f5e4:	e5c32007 	strb	r2, [r3, #7]
  tcphdr->ackno = htonl(pcb->rcv_nxt);
3001f5e8:	e59d300c 	ldr	r3, [sp, #12]
3001f5ec:	e5933020 	ldr	r3, [r3, #32]
3001f5f0:	e1a00003 	mov	r0, r3
3001f5f4:	ebffd0cf 	bl	30013938 <htonl>
3001f5f8:	e1a02000 	mov	r2, r0
3001f5fc:	e59d3014 	ldr	r3, [sp, #20]
3001f600:	e20210ff 	and	r1, r2, #255	; 0xff
3001f604:	e3a00000 	mov	r0, #0
3001f608:	e1801001 	orr	r1, r0, r1
3001f60c:	e5c31008 	strb	r1, [r3, #8]
3001f610:	e1a01422 	lsr	r1, r2, #8
3001f614:	e20110ff 	and	r1, r1, #255	; 0xff
3001f618:	e3a00000 	mov	r0, #0
3001f61c:	e1801001 	orr	r1, r0, r1
3001f620:	e5c31009 	strb	r1, [r3, #9]
3001f624:	e1a01822 	lsr	r1, r2, #16
3001f628:	e20110ff 	and	r1, r1, #255	; 0xff
3001f62c:	e3a00000 	mov	r0, #0
3001f630:	e1801001 	orr	r1, r0, r1
3001f634:	e5c3100a 	strb	r1, [r3, #10]
3001f638:	e1a02c22 	lsr	r2, r2, #24
3001f63c:	e3a01000 	mov	r1, #0
3001f640:	e1812002 	orr	r2, r1, r2
3001f644:	e5c3200b 	strb	r2, [r3, #11]
  TCPH_FLAGS_SET(tcphdr, 0);
3001f648:	e59d3014 	ldr	r3, [sp, #20]
3001f64c:	e5d3200c 	ldrb	r2, [r3, #12]
3001f650:	e5d3300d 	ldrb	r3, [r3, #13]
3001f654:	e1a03403 	lsl	r3, r3, #8
3001f658:	e1833002 	orr	r3, r3, r2
3001f65c:	e1a03803 	lsl	r3, r3, #16
3001f660:	e1a03823 	lsr	r3, r3, #16
3001f664:	e1a00003 	mov	r0, r3
3001f668:	ebffd0a6 	bl	30013908 <ntohs>
3001f66c:	e1a03000 	mov	r3, r0
3001f670:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3001f674:	e1a03803 	lsl	r3, r3, #16
3001f678:	e1a03823 	lsr	r3, r3, #16
3001f67c:	e1a00003 	mov	r0, r3
3001f680:	ebffd08d 	bl	300138bc <htons>
3001f684:	e1a03000 	mov	r3, r0
3001f688:	e1a02003 	mov	r2, r3
3001f68c:	e59d3014 	ldr	r3, [sp, #20]
3001f690:	e20210ff 	and	r1, r2, #255	; 0xff
3001f694:	e3a00000 	mov	r0, #0
3001f698:	e1801001 	orr	r1, r0, r1
3001f69c:	e5c3100c 	strb	r1, [r3, #12]
3001f6a0:	e1a02422 	lsr	r2, r2, #8
3001f6a4:	e1a02802 	lsl	r2, r2, #16
3001f6a8:	e1a02822 	lsr	r2, r2, #16
3001f6ac:	e3a01000 	mov	r1, #0
3001f6b0:	e1812002 	orr	r2, r1, r2
3001f6b4:	e5c3200d 	strb	r2, [r3, #13]
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
3001f6b8:	e59d300c 	ldr	r3, [sp, #12]
3001f6bc:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
3001f6c0:	e1a00003 	mov	r0, r3
3001f6c4:	ebffd07c 	bl	300138bc <htons>
3001f6c8:	e1a03000 	mov	r3, r0
3001f6cc:	e1a02003 	mov	r2, r3
3001f6d0:	e59d3014 	ldr	r3, [sp, #20]
3001f6d4:	e20210ff 	and	r1, r2, #255	; 0xff
3001f6d8:	e3a00000 	mov	r0, #0
3001f6dc:	e1801001 	orr	r1, r0, r1
3001f6e0:	e5c3100e 	strb	r1, [r3, #14]
3001f6e4:	e1a02422 	lsr	r2, r2, #8
3001f6e8:	e1a02802 	lsl	r2, r2, #16
3001f6ec:	e1a02822 	lsr	r2, r2, #16
3001f6f0:	e3a01000 	mov	r1, #0
3001f6f4:	e1812002 	orr	r2, r1, r2
3001f6f8:	e5c3200f 	strb	r2, [r3, #15]
  tcphdr->urgp = 0;
3001f6fc:	e59d3014 	ldr	r3, [sp, #20]
3001f700:	e3a02000 	mov	r2, #0
3001f704:	e5c32012 	strb	r2, [r3, #18]
3001f708:	e3a02000 	mov	r2, #0
3001f70c:	e5c32013 	strb	r2, [r3, #19]
  TCPH_HDRLEN_SET(tcphdr, 5);
3001f710:	e59d3014 	ldr	r3, [sp, #20]
3001f714:	e5d3200c 	ldrb	r2, [r3, #12]
3001f718:	e5d3300d 	ldrb	r3, [r3, #13]
3001f71c:	e1a03403 	lsl	r3, r3, #8
3001f720:	e1833002 	orr	r3, r3, r2
3001f724:	e1a03803 	lsl	r3, r3, #16
3001f728:	e1a03823 	lsr	r3, r3, #16
3001f72c:	e1a00003 	mov	r0, r3
3001f730:	ebffd074 	bl	30013908 <ntohs>
3001f734:	e1a03000 	mov	r3, r0
3001f738:	e203303f 	and	r3, r3, #63	; 0x3f
3001f73c:	e3833a05 	orr	r3, r3, #20480	; 0x5000
3001f740:	e1a03803 	lsl	r3, r3, #16
3001f744:	e1a03823 	lsr	r3, r3, #16
3001f748:	e1a00003 	mov	r0, r3
3001f74c:	ebffd05a 	bl	300138bc <htons>
3001f750:	e1a03000 	mov	r3, r0
3001f754:	e1a02003 	mov	r2, r3
3001f758:	e59d3014 	ldr	r3, [sp, #20]
3001f75c:	e20210ff 	and	r1, r2, #255	; 0xff
3001f760:	e3a00000 	mov	r0, #0
3001f764:	e1801001 	orr	r1, r0, r1
3001f768:	e5c3100c 	strb	r1, [r3, #12]
3001f76c:	e1a02422 	lsr	r2, r2, #8
3001f770:	e1a02802 	lsl	r2, r2, #16
3001f774:	e1a02822 	lsr	r2, r2, #16
3001f778:	e3a01000 	mov	r1, #0
3001f77c:	e1812002 	orr	r2, r1, r2
3001f780:	e5c3200d 	strb	r2, [r3, #13]

  tcphdr->chksum = 0;
3001f784:	e59d3014 	ldr	r3, [sp, #20]
3001f788:	e3a02000 	mov	r2, #0
3001f78c:	e5c32010 	strb	r2, [r3, #16]
3001f790:	e3a02000 	mov	r2, #0
3001f794:	e5c32011 	strb	r2, [r3, #17]
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
3001f798:	e59d200c 	ldr	r2, [sp, #12]
3001f79c:	e59d300c 	ldr	r3, [sp, #12]
3001f7a0:	e2833004 	add	r3, r3, #4
3001f7a4:	e59d1010 	ldr	r1, [sp, #16]
3001f7a8:	e1d110b8 	ldrh	r1, [r1, #8]
3001f7ac:	e58d1000 	str	r1, [sp]
3001f7b0:	e59d0010 	ldr	r0, [sp, #16]
3001f7b4:	e1a01002 	mov	r1, r2
3001f7b8:	e1a02003 	mov	r2, r3
3001f7bc:	e3a03006 	mov	r3, #6
3001f7c0:	ebffd0c4 	bl	30013ad8 <inet_chksum_pseudo>
3001f7c4:	e1a03000 	mov	r3, r0
3001f7c8:	e1a02003 	mov	r2, r3
3001f7cc:	e59d3014 	ldr	r3, [sp, #20]
3001f7d0:	e20210ff 	and	r1, r2, #255	; 0xff
3001f7d4:	e3a00000 	mov	r0, #0
3001f7d8:	e1801001 	orr	r1, r0, r1
3001f7dc:	e5c31010 	strb	r1, [r3, #16]
3001f7e0:	e1a02422 	lsr	r2, r2, #8
3001f7e4:	e1a02802 	lsl	r2, r2, #16
3001f7e8:	e1a02822 	lsr	r2, r2, #16
3001f7ec:	e3a01000 	mov	r1, #0
3001f7f0:	e1812002 	orr	r2, r1, r2
3001f7f4:	e5c32011 	strb	r2, [r3, #17]
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
3001f7f8:	e59f305c 	ldr	r3, [pc, #92]	; 3001f85c <tcp_keepalive+0x39c>
3001f7fc:	e1d339bc 	ldrh	r3, [r3, #156]	; 0x9c
3001f800:	e2833001 	add	r3, r3, #1
3001f804:	e1a03803 	lsl	r3, r3, #16
3001f808:	e1a02823 	lsr	r2, r3, #16
3001f80c:	e59f3048 	ldr	r3, [pc, #72]	; 3001f85c <tcp_keepalive+0x39c>
3001f810:	e1c329bc 	strh	r2, [r3, #156]	; 0x9c
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
3001f814:	e59d100c 	ldr	r1, [sp, #12]
3001f818:	e59d300c 	ldr	r3, [sp, #12]
3001f81c:	e2832004 	add	r2, r3, #4
3001f820:	e59d300c 	ldr	r3, [sp, #12]
3001f824:	e5d3300b 	ldrb	r3, [r3, #11]
3001f828:	e3a00000 	mov	r0, #0
3001f82c:	e58d0000 	str	r0, [sp]
3001f830:	e3a00006 	mov	r0, #6
3001f834:	e58d0004 	str	r0, [sp, #4]
3001f838:	e59d0010 	ldr	r0, [sp, #16]
3001f83c:	ebffd591 	bl	30014e88 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
3001f840:	e59d0010 	ldr	r0, [sp, #16]
3001f844:	ebffdb39 	bl	30016530 <pbuf_free>
3001f848:	ea000000 	b	3001f850 <tcp_keepalive+0x390>
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
   
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
3001f84c:	e1a00000 	nop			; (mov r0, r0)

  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
3001f850:	e28dd01c 	add	sp, sp, #28
3001f854:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001f858:	e12fff1e 	bx	lr
3001f85c:	3002b214 	.word	0x3002b214

3001f860 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
3001f860:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001f864:	e24dd024 	sub	sp, sp, #36	; 0x24
3001f868:	e58d000c 	str	r0, [sp, #12]
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
3001f86c:	e59d300c 	ldr	r3, [sp, #12]
3001f870:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001f874:	e58d301c 	str	r3, [sp, #28]

  if(seg == NULL)
3001f878:	e59d301c 	ldr	r3, [sp, #28]
3001f87c:	e3530000 	cmp	r3, #0
3001f880:	1a000002 	bne	3001f890 <tcp_zero_window_probe+0x30>
    seg = pcb->unsent;
3001f884:	e59d300c 	ldr	r3, [sp, #12]
3001f888:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001f88c:	e58d301c 	str	r3, [sp, #28]

  if(seg == NULL)
3001f890:	e59d301c 	ldr	r3, [sp, #28]
3001f894:	e3530000 	cmp	r3, #0
3001f898:	0a0000ed 	beq	3001fc54 <tcp_zero_window_probe+0x3f4>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
3001f89c:	e3a00001 	mov	r0, #1
3001f8a0:	e3a01015 	mov	r1, #21
3001f8a4:	e3a02000 	mov	r2, #0
3001f8a8:	ebffd971 	bl	30015e74 <pbuf_alloc>
3001f8ac:	e1a03000 	mov	r3, r0
3001f8b0:	e58d3014 	str	r3, [sp, #20]
   
  if(p == NULL) {
3001f8b4:	e59d3014 	ldr	r3, [sp, #20]
3001f8b8:	e3530000 	cmp	r3, #0
3001f8bc:	0a0000e6 	beq	3001fc5c <tcp_zero_window_probe+0x3fc>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
3001f8c0:	e59d3014 	ldr	r3, [sp, #20]
3001f8c4:	e5933004 	ldr	r3, [r3, #4]
3001f8c8:	e58d3018 	str	r3, [sp, #24]
  tcphdr->src = htons(pcb->local_port);
3001f8cc:	e59d300c 	ldr	r3, [sp, #12]
3001f8d0:	e1d331b8 	ldrh	r3, [r3, #24]
3001f8d4:	e1a00003 	mov	r0, r3
3001f8d8:	ebffcff7 	bl	300138bc <htons>
3001f8dc:	e1a03000 	mov	r3, r0
3001f8e0:	e1a02003 	mov	r2, r3
3001f8e4:	e59d3018 	ldr	r3, [sp, #24]
3001f8e8:	e20210ff 	and	r1, r2, #255	; 0xff
3001f8ec:	e3a00000 	mov	r0, #0
3001f8f0:	e1801001 	orr	r1, r0, r1
3001f8f4:	e5c31000 	strb	r1, [r3]
3001f8f8:	e1a02422 	lsr	r2, r2, #8
3001f8fc:	e1a02802 	lsl	r2, r2, #16
3001f900:	e1a02822 	lsr	r2, r2, #16
3001f904:	e3a01000 	mov	r1, #0
3001f908:	e1812002 	orr	r2, r1, r2
3001f90c:	e5c32001 	strb	r2, [r3, #1]
  tcphdr->dest = htons(pcb->remote_port);
3001f910:	e59d300c 	ldr	r3, [sp, #12]
3001f914:	e1d331ba 	ldrh	r3, [r3, #26]
3001f918:	e1a00003 	mov	r0, r3
3001f91c:	ebffcfe6 	bl	300138bc <htons>
3001f920:	e1a03000 	mov	r3, r0
3001f924:	e1a02003 	mov	r2, r3
3001f928:	e59d3018 	ldr	r3, [sp, #24]
3001f92c:	e20210ff 	and	r1, r2, #255	; 0xff
3001f930:	e3a00000 	mov	r0, #0
3001f934:	e1801001 	orr	r1, r0, r1
3001f938:	e5c31002 	strb	r1, [r3, #2]
3001f93c:	e1a02422 	lsr	r2, r2, #8
3001f940:	e1a02802 	lsl	r2, r2, #16
3001f944:	e1a02822 	lsr	r2, r2, #16
3001f948:	e3a01000 	mov	r1, #0
3001f94c:	e1812002 	orr	r2, r1, r2
3001f950:	e5c32003 	strb	r2, [r3, #3]
  tcphdr->seqno = seg->tcphdr->seqno;
3001f954:	e59d301c 	ldr	r3, [sp, #28]
3001f958:	e5933010 	ldr	r3, [r3, #16]
3001f95c:	e5d32004 	ldrb	r2, [r3, #4]
3001f960:	e5d31005 	ldrb	r1, [r3, #5]
3001f964:	e1a01401 	lsl	r1, r1, #8
3001f968:	e1812002 	orr	r2, r1, r2
3001f96c:	e5d31006 	ldrb	r1, [r3, #6]
3001f970:	e1a01801 	lsl	r1, r1, #16
3001f974:	e1812002 	orr	r2, r1, r2
3001f978:	e5d33007 	ldrb	r3, [r3, #7]
3001f97c:	e1a03c03 	lsl	r3, r3, #24
3001f980:	e1833002 	orr	r3, r3, r2
3001f984:	e1a02003 	mov	r2, r3
3001f988:	e59d3018 	ldr	r3, [sp, #24]
3001f98c:	e20210ff 	and	r1, r2, #255	; 0xff
3001f990:	e3a00000 	mov	r0, #0
3001f994:	e1801001 	orr	r1, r0, r1
3001f998:	e5c31004 	strb	r1, [r3, #4]
3001f99c:	e1a01422 	lsr	r1, r2, #8
3001f9a0:	e20110ff 	and	r1, r1, #255	; 0xff
3001f9a4:	e3a00000 	mov	r0, #0
3001f9a8:	e1801001 	orr	r1, r0, r1
3001f9ac:	e5c31005 	strb	r1, [r3, #5]
3001f9b0:	e1a01822 	lsr	r1, r2, #16
3001f9b4:	e20110ff 	and	r1, r1, #255	; 0xff
3001f9b8:	e3a00000 	mov	r0, #0
3001f9bc:	e1801001 	orr	r1, r0, r1
3001f9c0:	e5c31006 	strb	r1, [r3, #6]
3001f9c4:	e1a02c22 	lsr	r2, r2, #24
3001f9c8:	e3a01000 	mov	r1, #0
3001f9cc:	e1812002 	orr	r2, r1, r2
3001f9d0:	e5c32007 	strb	r2, [r3, #7]
  tcphdr->ackno = htonl(pcb->rcv_nxt);
3001f9d4:	e59d300c 	ldr	r3, [sp, #12]
3001f9d8:	e5933020 	ldr	r3, [r3, #32]
3001f9dc:	e1a00003 	mov	r0, r3
3001f9e0:	ebffcfd4 	bl	30013938 <htonl>
3001f9e4:	e1a02000 	mov	r2, r0
3001f9e8:	e59d3018 	ldr	r3, [sp, #24]
3001f9ec:	e20210ff 	and	r1, r2, #255	; 0xff
3001f9f0:	e3a00000 	mov	r0, #0
3001f9f4:	e1801001 	orr	r1, r0, r1
3001f9f8:	e5c31008 	strb	r1, [r3, #8]
3001f9fc:	e1a01422 	lsr	r1, r2, #8
3001fa00:	e20110ff 	and	r1, r1, #255	; 0xff
3001fa04:	e3a00000 	mov	r0, #0
3001fa08:	e1801001 	orr	r1, r0, r1
3001fa0c:	e5c31009 	strb	r1, [r3, #9]
3001fa10:	e1a01822 	lsr	r1, r2, #16
3001fa14:	e20110ff 	and	r1, r1, #255	; 0xff
3001fa18:	e3a00000 	mov	r0, #0
3001fa1c:	e1801001 	orr	r1, r0, r1
3001fa20:	e5c3100a 	strb	r1, [r3, #10]
3001fa24:	e1a02c22 	lsr	r2, r2, #24
3001fa28:	e3a01000 	mov	r1, #0
3001fa2c:	e1812002 	orr	r2, r1, r2
3001fa30:	e5c3200b 	strb	r2, [r3, #11]
  TCPH_FLAGS_SET(tcphdr, 0);
3001fa34:	e59d3018 	ldr	r3, [sp, #24]
3001fa38:	e5d3200c 	ldrb	r2, [r3, #12]
3001fa3c:	e5d3300d 	ldrb	r3, [r3, #13]
3001fa40:	e1a03403 	lsl	r3, r3, #8
3001fa44:	e1833002 	orr	r3, r3, r2
3001fa48:	e1a03803 	lsl	r3, r3, #16
3001fa4c:	e1a03823 	lsr	r3, r3, #16
3001fa50:	e1a00003 	mov	r0, r3
3001fa54:	ebffcfab 	bl	30013908 <ntohs>
3001fa58:	e1a03000 	mov	r3, r0
3001fa5c:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3001fa60:	e1a03803 	lsl	r3, r3, #16
3001fa64:	e1a03823 	lsr	r3, r3, #16
3001fa68:	e1a00003 	mov	r0, r3
3001fa6c:	ebffcf92 	bl	300138bc <htons>
3001fa70:	e1a03000 	mov	r3, r0
3001fa74:	e1a02003 	mov	r2, r3
3001fa78:	e59d3018 	ldr	r3, [sp, #24]
3001fa7c:	e20210ff 	and	r1, r2, #255	; 0xff
3001fa80:	e3a00000 	mov	r0, #0
3001fa84:	e1801001 	orr	r1, r0, r1
3001fa88:	e5c3100c 	strb	r1, [r3, #12]
3001fa8c:	e1a02422 	lsr	r2, r2, #8
3001fa90:	e1a02802 	lsl	r2, r2, #16
3001fa94:	e1a02822 	lsr	r2, r2, #16
3001fa98:	e3a01000 	mov	r1, #0
3001fa9c:	e1812002 	orr	r2, r1, r2
3001faa0:	e5c3200d 	strb	r2, [r3, #13]
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
3001faa4:	e59d300c 	ldr	r3, [sp, #12]
3001faa8:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
3001faac:	e1a00003 	mov	r0, r3
3001fab0:	ebffcf81 	bl	300138bc <htons>
3001fab4:	e1a03000 	mov	r3, r0
3001fab8:	e1a02003 	mov	r2, r3
3001fabc:	e59d3018 	ldr	r3, [sp, #24]
3001fac0:	e20210ff 	and	r1, r2, #255	; 0xff
3001fac4:	e3a00000 	mov	r0, #0
3001fac8:	e1801001 	orr	r1, r0, r1
3001facc:	e5c3100e 	strb	r1, [r3, #14]
3001fad0:	e1a02422 	lsr	r2, r2, #8
3001fad4:	e1a02802 	lsl	r2, r2, #16
3001fad8:	e1a02822 	lsr	r2, r2, #16
3001fadc:	e3a01000 	mov	r1, #0
3001fae0:	e1812002 	orr	r2, r1, r2
3001fae4:	e5c3200f 	strb	r2, [r3, #15]
  tcphdr->urgp = 0;
3001fae8:	e59d3018 	ldr	r3, [sp, #24]
3001faec:	e3a02000 	mov	r2, #0
3001faf0:	e5c32012 	strb	r2, [r3, #18]
3001faf4:	e3a02000 	mov	r2, #0
3001faf8:	e5c32013 	strb	r2, [r3, #19]
  TCPH_HDRLEN_SET(tcphdr, 5);
3001fafc:	e59d3018 	ldr	r3, [sp, #24]
3001fb00:	e5d3200c 	ldrb	r2, [r3, #12]
3001fb04:	e5d3300d 	ldrb	r3, [r3, #13]
3001fb08:	e1a03403 	lsl	r3, r3, #8
3001fb0c:	e1833002 	orr	r3, r3, r2
3001fb10:	e1a03803 	lsl	r3, r3, #16
3001fb14:	e1a03823 	lsr	r3, r3, #16
3001fb18:	e1a00003 	mov	r0, r3
3001fb1c:	ebffcf79 	bl	30013908 <ntohs>
3001fb20:	e1a03000 	mov	r3, r0
3001fb24:	e203303f 	and	r3, r3, #63	; 0x3f
3001fb28:	e3833a05 	orr	r3, r3, #20480	; 0x5000
3001fb2c:	e1a03803 	lsl	r3, r3, #16
3001fb30:	e1a03823 	lsr	r3, r3, #16
3001fb34:	e1a00003 	mov	r0, r3
3001fb38:	ebffcf5f 	bl	300138bc <htons>
3001fb3c:	e1a03000 	mov	r3, r0
3001fb40:	e1a02003 	mov	r2, r3
3001fb44:	e59d3018 	ldr	r3, [sp, #24]
3001fb48:	e20210ff 	and	r1, r2, #255	; 0xff
3001fb4c:	e3a00000 	mov	r0, #0
3001fb50:	e1801001 	orr	r1, r0, r1
3001fb54:	e5c3100c 	strb	r1, [r3, #12]
3001fb58:	e1a02422 	lsr	r2, r2, #8
3001fb5c:	e1a02802 	lsl	r2, r2, #16
3001fb60:	e1a02822 	lsr	r2, r2, #16
3001fb64:	e3a01000 	mov	r1, #0
3001fb68:	e1812002 	orr	r2, r1, r2
3001fb6c:	e5c3200d 	strb	r2, [r3, #13]

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
3001fb70:	e59d3014 	ldr	r3, [sp, #20]
3001fb74:	e5933004 	ldr	r3, [r3, #4]
3001fb78:	e2833014 	add	r3, r3, #20
3001fb7c:	e59d201c 	ldr	r2, [sp, #28]
3001fb80:	e5922008 	ldr	r2, [r2, #8]
3001fb84:	e5d22000 	ldrb	r2, [r2]
3001fb88:	e5c32000 	strb	r2, [r3]

  tcphdr->chksum = 0;
3001fb8c:	e59d3018 	ldr	r3, [sp, #24]
3001fb90:	e3a02000 	mov	r2, #0
3001fb94:	e5c32010 	strb	r2, [r3, #16]
3001fb98:	e3a02000 	mov	r2, #0
3001fb9c:	e5c32011 	strb	r2, [r3, #17]
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
3001fba0:	e59d200c 	ldr	r2, [sp, #12]
3001fba4:	e59d300c 	ldr	r3, [sp, #12]
3001fba8:	e2833004 	add	r3, r3, #4
3001fbac:	e59d1014 	ldr	r1, [sp, #20]
3001fbb0:	e1d110b8 	ldrh	r1, [r1, #8]
3001fbb4:	e58d1000 	str	r1, [sp]
3001fbb8:	e59d0014 	ldr	r0, [sp, #20]
3001fbbc:	e1a01002 	mov	r1, r2
3001fbc0:	e1a02003 	mov	r2, r3
3001fbc4:	e3a03006 	mov	r3, #6
3001fbc8:	ebffcfc2 	bl	30013ad8 <inet_chksum_pseudo>
3001fbcc:	e1a03000 	mov	r3, r0
3001fbd0:	e1a02003 	mov	r2, r3
3001fbd4:	e59d3018 	ldr	r3, [sp, #24]
3001fbd8:	e20210ff 	and	r1, r2, #255	; 0xff
3001fbdc:	e3a00000 	mov	r0, #0
3001fbe0:	e1801001 	orr	r1, r0, r1
3001fbe4:	e5c31010 	strb	r1, [r3, #16]
3001fbe8:	e1a02422 	lsr	r2, r2, #8
3001fbec:	e1a02802 	lsl	r2, r2, #16
3001fbf0:	e1a02822 	lsr	r2, r2, #16
3001fbf4:	e3a01000 	mov	r1, #0
3001fbf8:	e1812002 	orr	r2, r1, r2
3001fbfc:	e5c32011 	strb	r2, [r3, #17]
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
3001fc00:	e59f3064 	ldr	r3, [pc, #100]	; 3001fc6c <tcp_zero_window_probe+0x40c>
3001fc04:	e1d339bc 	ldrh	r3, [r3, #156]	; 0x9c
3001fc08:	e2833001 	add	r3, r3, #1
3001fc0c:	e1a03803 	lsl	r3, r3, #16
3001fc10:	e1a02823 	lsr	r2, r3, #16
3001fc14:	e59f3050 	ldr	r3, [pc, #80]	; 3001fc6c <tcp_zero_window_probe+0x40c>
3001fc18:	e1c329bc 	strh	r2, [r3, #156]	; 0x9c
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
3001fc1c:	e59d100c 	ldr	r1, [sp, #12]
3001fc20:	e59d300c 	ldr	r3, [sp, #12]
3001fc24:	e2832004 	add	r2, r3, #4
3001fc28:	e59d300c 	ldr	r3, [sp, #12]
3001fc2c:	e5d3300b 	ldrb	r3, [r3, #11]
3001fc30:	e3a00000 	mov	r0, #0
3001fc34:	e58d0000 	str	r0, [sp]
3001fc38:	e3a00006 	mov	r0, #6
3001fc3c:	e58d0004 	str	r0, [sp, #4]
3001fc40:	e59d0014 	ldr	r0, [sp, #20]
3001fc44:	ebffd48f 	bl	30014e88 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
3001fc48:	e59d0014 	ldr	r0, [sp, #20]
3001fc4c:	ebffda37 	bl	30016530 <pbuf_free>
3001fc50:	ea000002 	b	3001fc60 <tcp_zero_window_probe+0x400>

  if(seg == NULL)
    seg = pcb->unsent;

  if(seg == NULL)
    return;
3001fc54:	e1a00000 	nop			; (mov r0, r0)
3001fc58:	ea000000 	b	3001fc60 <tcp_zero_window_probe+0x400>

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
   
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
3001fc5c:	e1a00000 	nop			; (mov r0, r0)
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
3001fc60:	e28dd024 	add	sp, sp, #36	; 0x24
3001fc64:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001fc68:	e12fff1e 	bx	lr
3001fc6c:	3002b214 	.word	0x3002b214

3001fc70 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
3001fc70:	e92d4010 	push	{r4, lr}
3001fc74:	e24dd030 	sub	sp, sp, #48	; 0x30
3001fc78:	e58d000c 	str	r0, [sp, #12]
3001fc7c:	e58d1008 	str	r1, [sp, #8]
  u8_t local_match;

  PERF_START;

  //acoral_prints("\nudp: udp_input \n");
  UDP_STATS_INC(udp.recv);
3001fc80:	e59f3654 	ldr	r3, [pc, #1620]	; 300202dc <udp_input+0x66c>
3001fc84:	e1d338b6 	ldrh	r3, [r3, #134]	; 0x86
3001fc88:	e2833001 	add	r3, r3, #1
3001fc8c:	e1a03803 	lsl	r3, r3, #16
3001fc90:	e1a02823 	lsr	r2, r3, #16
3001fc94:	e59f3640 	ldr	r3, [pc, #1600]	; 300202dc <udp_input+0x66c>
3001fc98:	e1c328b6 	strh	r2, [r3, #134]	; 0x86

  iphdr = p->payload;
3001fc9c:	e59d300c 	ldr	r3, [sp, #12]
3001fca0:	e5933004 	ldr	r3, [r3, #4]
3001fca4:	e58d3024 	str	r3, [sp, #36]	; 0x24

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
3001fca8:	e59d300c 	ldr	r3, [sp, #12]
3001fcac:	e1d330b8 	ldrh	r3, [r3, #8]
3001fcb0:	e1a04003 	mov	r4, r3
3001fcb4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001fcb8:	e5d32000 	ldrb	r2, [r3]
3001fcbc:	e5d33001 	ldrb	r3, [r3, #1]
3001fcc0:	e1a03403 	lsl	r3, r3, #8
3001fcc4:	e1833002 	orr	r3, r3, r2
3001fcc8:	e1a03803 	lsl	r3, r3, #16
3001fccc:	e1a03823 	lsr	r3, r3, #16
3001fcd0:	e1a00003 	mov	r0, r3
3001fcd4:	ebffcf0b 	bl	30013908 <ntohs>
3001fcd8:	e1a03000 	mov	r3, r0
3001fcdc:	e1a03423 	lsr	r3, r3, #8
3001fce0:	e1a03803 	lsl	r3, r3, #16
3001fce4:	e1a03823 	lsr	r3, r3, #16
3001fce8:	e203300f 	and	r3, r3, #15
3001fcec:	e2833002 	add	r3, r3, #2
3001fcf0:	e1a03103 	lsl	r3, r3, #2
3001fcf4:	e1540003 	cmp	r4, r3
3001fcf8:	ba00001b 	blt	3001fd6c <udp_input+0xfc>
3001fcfc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001fd00:	e5d32000 	ldrb	r2, [r3]
3001fd04:	e5d33001 	ldrb	r3, [r3, #1]
3001fd08:	e1a03403 	lsl	r3, r3, #8
3001fd0c:	e1833002 	orr	r3, r3, r2
3001fd10:	e1a03803 	lsl	r3, r3, #16
3001fd14:	e1a03823 	lsr	r3, r3, #16
3001fd18:	e1a00003 	mov	r0, r3
3001fd1c:	ebffcef9 	bl	30013908 <ntohs>
3001fd20:	e1a03000 	mov	r3, r0
3001fd24:	e1a03423 	lsr	r3, r3, #8
3001fd28:	e1a03803 	lsl	r3, r3, #16
3001fd2c:	e1a03823 	lsr	r3, r3, #16
3001fd30:	e203300f 	and	r3, r3, #15
3001fd34:	e1a03103 	lsl	r3, r3, #2
3001fd38:	e1a03803 	lsl	r3, r3, #16
3001fd3c:	e1a03823 	lsr	r3, r3, #16
3001fd40:	e2633000 	rsb	r3, r3, #0
3001fd44:	e1a03803 	lsl	r3, r3, #16
3001fd48:	e1a03823 	lsr	r3, r3, #16
3001fd4c:	e1a03803 	lsl	r3, r3, #16
3001fd50:	e1a03843 	asr	r3, r3, #16
3001fd54:	e59d000c 	ldr	r0, [sp, #12]
3001fd58:	e1a01003 	mov	r1, r3
3001fd5c:	ebffd98e 	bl	3001639c <pbuf_header>
3001fd60:	e1a03000 	mov	r3, r0
3001fd64:	e3530000 	cmp	r3, #0
3001fd68:	0a000010 	beq	3001fdb0 <udp_input+0x140>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
3001fd6c:	e59f3568 	ldr	r3, [pc, #1384]	; 300202dc <udp_input+0x66c>
3001fd70:	e1d338be 	ldrh	r3, [r3, #142]	; 0x8e
3001fd74:	e2833001 	add	r3, r3, #1
3001fd78:	e1a03803 	lsl	r3, r3, #16
3001fd7c:	e1a02823 	lsr	r2, r3, #16
3001fd80:	e59f3554 	ldr	r3, [pc, #1364]	; 300202dc <udp_input+0x66c>
3001fd84:	e1c328be 	strh	r2, [r3, #142]	; 0x8e
    UDP_STATS_INC(udp.drop);
3001fd88:	e59f354c 	ldr	r3, [pc, #1356]	; 300202dc <udp_input+0x66c>
3001fd8c:	e1d338ba 	ldrh	r3, [r3, #138]	; 0x8a
3001fd90:	e2833001 	add	r3, r3, #1
3001fd94:	e1a03803 	lsl	r3, r3, #16
3001fd98:	e1a02823 	lsr	r2, r3, #16
3001fd9c:	e59f3538 	ldr	r3, [pc, #1336]	; 300202dc <udp_input+0x66c>
3001fda0:	e1c328ba 	strh	r2, [r3, #138]	; 0x8a
    snmp_inc_udpinerrors();
    pbuf_free(p);
3001fda4:	e59d000c 	ldr	r0, [sp, #12]
3001fda8:	ebffd9e0 	bl	30016530 <pbuf_free>
    //acoral_prints("\nudp: udp is error in len\n");
    goto end;
3001fdac:	ea000147 	b	300202d0 <udp_input+0x660>
  }

  udphdr = (struct udp_hdr *)p->payload;
3001fdb0:	e59d300c 	ldr	r3, [sp, #12]
3001fdb4:	e5933004 	ldr	r3, [r3, #4]
3001fdb8:	e58d3014 	str	r3, [sp, #20]

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
3001fdbc:	e59d3014 	ldr	r3, [sp, #20]
3001fdc0:	e5d32000 	ldrb	r2, [r3]
3001fdc4:	e5d33001 	ldrb	r3, [r3, #1]
3001fdc8:	e1a03403 	lsl	r3, r3, #8
3001fdcc:	e1833002 	orr	r3, r3, r2
3001fdd0:	e1a03803 	lsl	r3, r3, #16
3001fdd4:	e1a03823 	lsr	r3, r3, #16
3001fdd8:	e1a00003 	mov	r0, r3
3001fddc:	ebffcec9 	bl	30013908 <ntohs>
3001fde0:	e1a03000 	mov	r3, r0
3001fde4:	e1cd32ba 	strh	r3, [sp, #42]	; 0x2a
  dest = ntohs(udphdr->dest);
3001fde8:	e59d3014 	ldr	r3, [sp, #20]
3001fdec:	e5d32002 	ldrb	r2, [r3, #2]
3001fdf0:	e5d33003 	ldrb	r3, [r3, #3]
3001fdf4:	e1a03403 	lsl	r3, r3, #8
3001fdf8:	e1833002 	orr	r3, r3, r2
3001fdfc:	e1a03803 	lsl	r3, r3, #16
3001fe00:	e1a03823 	lsr	r3, r3, #16
3001fe04:	e1a00003 	mov	r0, r3
3001fe08:	ebffcebe 	bl	30013908 <ntohs>
3001fe0c:	e1a03000 	mov	r3, r0
3001fe10:	e1cd32bc 	strh	r3, [sp, #44]	; 0x2c
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
3001fe14:	e3a03000 	mov	r3, #0
3001fe18:	e58d301c 	str	r3, [sp, #28]
    local_match = 0;
3001fe1c:	e3a03000 	mov	r3, #0
3001fe20:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
    uncon_pcb = NULL;
3001fe24:	e3a03000 	mov	r3, #0
3001fe28:	e58d3020 	str	r3, [sp, #32]
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    //acoral_prints("\nudp: start find pcb\n");
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
3001fe2c:	e59f34ac 	ldr	r3, [pc, #1196]	; 300202e0 <udp_input+0x670>
3001fe30:	e5933000 	ldr	r3, [r3]
3001fe34:	e58d3018 	str	r3, [sp, #24]
3001fe38:	ea00006b 	b	3001ffec <udp_input+0x37c>
      local_match = 0;
3001fe3c:	e3a03000 	mov	r3, #0
3001fe40:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
3001fe44:	e59d3018 	ldr	r3, [sp, #24]
3001fe48:	e1d331b2 	ldrh	r3, [r3, #18]
3001fe4c:	e1dd22bc 	ldrh	r2, [sp, #44]	; 0x2c
3001fe50:	e1520003 	cmp	r2, r3
3001fe54:	1a000029 	bne	3001ff00 <udp_input+0x290>
          (ip_addr_isany(&pcb->local_ip) ||
3001fe58:	e59d3018 	ldr	r3, [sp, #24]
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
3001fe5c:	e3530000 	cmp	r3, #0
3001fe60:	0a00001a 	beq	3001fed0 <udp_input+0x260>
          (ip_addr_isany(&pcb->local_ip) ||
3001fe64:	e59d3018 	ldr	r3, [sp, #24]
3001fe68:	e5933000 	ldr	r3, [r3]
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
3001fe6c:	e3530000 	cmp	r3, #0
3001fe70:	0a000016 	beq	3001fed0 <udp_input+0x260>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
3001fe74:	e59d3018 	ldr	r3, [sp, #24]
3001fe78:	e5932000 	ldr	r2, [r3]
3001fe7c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001fe80:	e5d31010 	ldrb	r1, [r3, #16]
3001fe84:	e5d30011 	ldrb	r0, [r3, #17]
3001fe88:	e1a00400 	lsl	r0, r0, #8
3001fe8c:	e1801001 	orr	r1, r0, r1
3001fe90:	e5d30012 	ldrb	r0, [r3, #18]
3001fe94:	e1a00800 	lsl	r0, r0, #16
3001fe98:	e1801001 	orr	r1, r0, r1
3001fe9c:	e5d33013 	ldrb	r3, [r3, #19]
3001fea0:	e1a03c03 	lsl	r3, r3, #24
3001fea4:	e1833001 	orr	r3, r3, r1
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
3001fea8:	e1520003 	cmp	r2, r3
3001feac:	0a000007 	beq	3001fed0 <udp_input+0x260>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
3001feb0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001feb4:	e2833010 	add	r3, r3, #16
3001feb8:	e1a00003 	mov	r0, r3
3001febc:	e59d1008 	ldr	r1, [sp, #8]
3001fec0:	ebffd413 	bl	30014f14 <ip_addr_isbroadcast>
3001fec4:	e1a03000 	mov	r3, r0
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
3001fec8:	e3530000 	cmp	r3, #0
3001fecc:	0a00000b 	beq	3001ff00 <udp_input+0x290>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
3001fed0:	e3a03001 	mov	r3, #1
3001fed4:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
        if ((uncon_pcb == NULL) && 
3001fed8:	e59d3020 	ldr	r3, [sp, #32]
3001fedc:	e3530000 	cmp	r3, #0
3001fee0:	1a000006 	bne	3001ff00 <udp_input+0x290>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
3001fee4:	e59d3018 	ldr	r3, [sp, #24]
3001fee8:	e5d33010 	ldrb	r3, [r3, #16]
3001feec:	e2033004 	and	r3, r3, #4
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
3001fef0:	e3530000 	cmp	r3, #0
3001fef4:	1a000001 	bne	3001ff00 <udp_input+0x290>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
3001fef8:	e59d3018 	ldr	r3, [sp, #24]
3001fefc:	e58d3020 	str	r3, [sp, #32]
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
3001ff00:	e5dd302f 	ldrb	r3, [sp, #47]	; 0x2f
3001ff04:	e3530000 	cmp	r3, #0
3001ff08:	0a000032 	beq	3001ffd8 <udp_input+0x368>
          (pcb->remote_port == src) &&
3001ff0c:	e59d3018 	ldr	r3, [sp, #24]
3001ff10:	e1d331b4 	ldrh	r3, [r3, #20]
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
3001ff14:	e1dd22ba 	ldrh	r2, [sp, #42]	; 0x2a
3001ff18:	e1520003 	cmp	r2, r3
3001ff1c:	1a00002d 	bne	3001ffd8 <udp_input+0x368>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
3001ff20:	e59d3018 	ldr	r3, [sp, #24]
3001ff24:	e2833004 	add	r3, r3, #4
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
3001ff28:	e3530000 	cmp	r3, #0
3001ff2c:	0a000012 	beq	3001ff7c <udp_input+0x30c>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
3001ff30:	e59d3018 	ldr	r3, [sp, #24]
3001ff34:	e5933004 	ldr	r3, [r3, #4]
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
3001ff38:	e3530000 	cmp	r3, #0
3001ff3c:	0a00000e 	beq	3001ff7c <udp_input+0x30c>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
3001ff40:	e59d3018 	ldr	r3, [sp, #24]
3001ff44:	e5932004 	ldr	r2, [r3, #4]
3001ff48:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001ff4c:	e5d3100c 	ldrb	r1, [r3, #12]
3001ff50:	e5d3000d 	ldrb	r0, [r3, #13]
3001ff54:	e1a00400 	lsl	r0, r0, #8
3001ff58:	e1801001 	orr	r1, r0, r1
3001ff5c:	e5d3000e 	ldrb	r0, [r3, #14]
3001ff60:	e1a00800 	lsl	r0, r0, #16
3001ff64:	e1801001 	orr	r1, r0, r1
3001ff68:	e5d3300f 	ldrb	r3, [r3, #15]
3001ff6c:	e1a03c03 	lsl	r3, r3, #24
3001ff70:	e1833001 	orr	r3, r3, r1
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
3001ff74:	e1520003 	cmp	r2, r3
3001ff78:	1a000016 	bne	3001ffd8 <udp_input+0x368>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
3001ff7c:	e59d301c 	ldr	r3, [sp, #28]
3001ff80:	e3530000 	cmp	r3, #0
3001ff84:	0a00000b 	beq	3001ffb8 <udp_input+0x348>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
3001ff88:	e59d3018 	ldr	r3, [sp, #24]
3001ff8c:	e593200c 	ldr	r2, [r3, #12]
3001ff90:	e59d301c 	ldr	r3, [sp, #28]
3001ff94:	e583200c 	str	r2, [r3, #12]
          pcb->next = udp_pcbs;
3001ff98:	e59f3340 	ldr	r3, [pc, #832]	; 300202e0 <udp_input+0x670>
3001ff9c:	e5932000 	ldr	r2, [r3]
3001ffa0:	e59d3018 	ldr	r3, [sp, #24]
3001ffa4:	e583200c 	str	r2, [r3, #12]
          udp_pcbs = pcb;
3001ffa8:	e59f3330 	ldr	r3, [pc, #816]	; 300202e0 <udp_input+0x670>
3001ffac:	e59d2018 	ldr	r2, [sp, #24]
3001ffb0:	e5832000 	str	r2, [r3]
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
3001ffb4:	ea00000f 	b	3001fff8 <udp_input+0x388>
             found faster next time */
          prev->next = pcb->next;
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
3001ffb8:	e59f331c 	ldr	r3, [pc, #796]	; 300202dc <udp_input+0x66c>
3001ffbc:	e1d339ba 	ldrh	r3, [r3, #154]	; 0x9a
3001ffc0:	e2833001 	add	r3, r3, #1
3001ffc4:	e1a03803 	lsl	r3, r3, #16
3001ffc8:	e1a02823 	lsr	r2, r3, #16
3001ffcc:	e59f3308 	ldr	r3, [pc, #776]	; 300202dc <udp_input+0x66c>
3001ffd0:	e1c329ba 	strh	r2, [r3, #154]	; 0x9a
        }
        break;
3001ffd4:	ea000007 	b	3001fff8 <udp_input+0x388>
      }
      prev = pcb;
3001ffd8:	e59d3018 	ldr	r3, [sp, #24]
3001ffdc:	e58d301c 	str	r3, [sp, #28]
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    //acoral_prints("\nudp: start find pcb\n");
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
3001ffe0:	e59d3018 	ldr	r3, [sp, #24]
3001ffe4:	e593300c 	ldr	r3, [r3, #12]
3001ffe8:	e58d3018 	str	r3, [sp, #24]
3001ffec:	e59d3018 	ldr	r3, [sp, #24]
3001fff0:	e3530000 	cmp	r3, #0
3001fff4:	1affff90 	bne	3001fe3c <udp_input+0x1cc>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
3001fff8:	e59d3018 	ldr	r3, [sp, #24]
3001fffc:	e3530000 	cmp	r3, #0
30020000:	1a000001 	bne	3002000c <udp_input+0x39c>
      pcb = uncon_pcb;
30020004:	e59d3020 	ldr	r3, [sp, #32]
30020008:	e58d3018 	str	r3, [sp, #24]
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
3002000c:	e59d3018 	ldr	r3, [sp, #24]
30020010:	e3530000 	cmp	r3, #0
30020014:	1a00000e 	bne	30020054 <udp_input+0x3e4>
30020018:	e59d3008 	ldr	r3, [sp, #8]
3002001c:	e5932004 	ldr	r2, [r3, #4]
30020020:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30020024:	e5d31010 	ldrb	r1, [r3, #16]
30020028:	e5d30011 	ldrb	r0, [r3, #17]
3002002c:	e1a00400 	lsl	r0, r0, #8
30020030:	e1801001 	orr	r1, r0, r1
30020034:	e5d30012 	ldrb	r0, [r3, #18]
30020038:	e1a00800 	lsl	r0, r0, #16
3002003c:	e1801001 	orr	r1, r0, r1
30020040:	e5d33013 	ldrb	r3, [r3, #19]
30020044:	e1a03c03 	lsl	r3, r3, #24
30020048:	e1833001 	orr	r3, r3, r1
3002004c:	e1520003 	cmp	r2, r3
30020050:	1a00009c 	bne	300202c8 <udp_input+0x658>
    acoral_prints("\nudp:pub is not null\n");
30020054:	e59f0288 	ldr	r0, [pc, #648]	; 300202e4 <udp_input+0x674>
30020058:	ebffad15 	bl	3000b4b4 <acoral_prints>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
3002005c:	e59d3014 	ldr	r3, [sp, #20]
30020060:	e5d32006 	ldrb	r2, [r3, #6]
30020064:	e5d33007 	ldrb	r3, [r3, #7]
30020068:	e1a03403 	lsl	r3, r3, #8
3002006c:	e1833002 	orr	r3, r3, r2
30020070:	e1a03803 	lsl	r3, r3, #16
30020074:	e1a03823 	lsr	r3, r3, #16
30020078:	e3530000 	cmp	r3, #0
3002007c:	0a00001f 	beq	30020100 <udp_input+0x490>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
30020080:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30020084:	e283200c 	add	r2, r3, #12
30020088:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3002008c:	e2833010 	add	r3, r3, #16
30020090:	e59d100c 	ldr	r1, [sp, #12]
30020094:	e1d110b8 	ldrh	r1, [r1, #8]
30020098:	e58d1000 	str	r1, [sp]
3002009c:	e59d000c 	ldr	r0, [sp, #12]
300200a0:	e1a01002 	mov	r1, r2
300200a4:	e1a02003 	mov	r2, r3
300200a8:	e3a03011 	mov	r3, #17
300200ac:	ebffce89 	bl	30013ad8 <inet_chksum_pseudo>
300200b0:	e1a03000 	mov	r3, r0
300200b4:	e3530000 	cmp	r3, #0
300200b8:	0a000010 	beq	30020100 <udp_input+0x490>
                               (struct ip_addr *)&(iphdr->dest),
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
300200bc:	e59f3218 	ldr	r3, [pc, #536]	; 300202dc <udp_input+0x66c>
300200c0:	e1d338bc 	ldrh	r3, [r3, #140]	; 0x8c
300200c4:	e2833001 	add	r3, r3, #1
300200c8:	e1a03803 	lsl	r3, r3, #16
300200cc:	e1a02823 	lsr	r2, r3, #16
300200d0:	e59f3204 	ldr	r3, [pc, #516]	; 300202dc <udp_input+0x66c>
300200d4:	e1c328bc 	strh	r2, [r3, #140]	; 0x8c
          UDP_STATS_INC(udp.drop);
300200d8:	e59f31fc 	ldr	r3, [pc, #508]	; 300202dc <udp_input+0x66c>
300200dc:	e1d338ba 	ldrh	r3, [r3, #138]	; 0x8a
300200e0:	e2833001 	add	r3, r3, #1
300200e4:	e1a03803 	lsl	r3, r3, #16
300200e8:	e1a02823 	lsr	r2, r3, #16
300200ec:	e59f31e8 	ldr	r3, [pc, #488]	; 300202dc <udp_input+0x66c>
300200f0:	e1c328ba 	strh	r2, [r3, #138]	; 0x8a
          snmp_inc_udpinerrors();
          pbuf_free(p);
300200f4:	e59d000c 	ldr	r0, [sp, #12]
300200f8:	ebffd90c 	bl	30016530 <pbuf_free>
          goto end;
300200fc:	ea000073 	b	300202d0 <udp_input+0x660>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
30020100:	e59d000c 	ldr	r0, [sp, #12]
30020104:	e3e01007 	mvn	r1, #7
30020108:	ebffd8a3 	bl	3001639c <pbuf_header>
3002010c:	e1a03000 	mov	r3, r0
30020110:	e3530000 	cmp	r3, #0
30020114:	0a000009 	beq	30020140 <udp_input+0x4d0>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      UDP_STATS_INC(udp.drop);
30020118:	e59f31bc 	ldr	r3, [pc, #444]	; 300202dc <udp_input+0x66c>
3002011c:	e1d338ba 	ldrh	r3, [r3, #138]	; 0x8a
30020120:	e2833001 	add	r3, r3, #1
30020124:	e1a03803 	lsl	r3, r3, #16
30020128:	e1a02823 	lsr	r2, r3, #16
3002012c:	e59f31a8 	ldr	r3, [pc, #424]	; 300202dc <udp_input+0x66c>
30020130:	e1c328ba 	strh	r2, [r3, #138]	; 0x8a
      snmp_inc_udpinerrors();
      pbuf_free(p);
30020134:	e59d000c 	ldr	r0, [sp, #12]
30020138:	ebffd8fc 	bl	30016530 <pbuf_free>
      goto end;
3002013c:	ea000063 	b	300202d0 <udp_input+0x660>
    }
    if (pcb != NULL) {
30020140:	e59d3018 	ldr	r3, [sp, #24]
30020144:	e3530000 	cmp	r3, #0
30020148:	0a000014 	beq	300201a0 <udp_input+0x530>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
3002014c:	e59d3018 	ldr	r3, [sp, #24]
30020150:	e5933018 	ldr	r3, [r3, #24]
30020154:	e3530000 	cmp	r3, #0
30020158:	0a00000d 	beq	30020194 <udp_input+0x524>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
3002015c:	e59d3018 	ldr	r3, [sp, #24]
30020160:	e593c018 	ldr	ip, [r3, #24]
30020164:	e59d3018 	ldr	r3, [sp, #24]
30020168:	e593201c 	ldr	r2, [r3, #28]
3002016c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30020170:	e283300c 	add	r3, r3, #12
30020174:	e1dd12ba 	ldrh	r1, [sp, #42]	; 0x2a
30020178:	e58d1000 	str	r1, [sp]
3002017c:	e1a00002 	mov	r0, r2
30020180:	e59d1018 	ldr	r1, [sp, #24]
30020184:	e59d200c 	ldr	r2, [sp, #12]
30020188:	e1a0e00f 	mov	lr, pc
3002018c:	e12fff1c 	bx	ip
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
30020190:	ea00004e 	b	300202d0 <udp_input+0x660>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
30020194:	e59d000c 	ldr	r0, [sp, #12]
30020198:	ebffd8e4 	bl	30016530 <pbuf_free>
        goto end;
3002019c:	ea00004b 	b	300202d0 <udp_input+0x660>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
300201a0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300201a4:	e2833010 	add	r3, r3, #16
300201a8:	e1a00003 	mov	r0, r3
300201ac:	e59d1008 	ldr	r1, [sp, #8]
300201b0:	ebffd357 	bl	30014f14 <ip_addr_isbroadcast>
300201b4:	e1a03000 	mov	r3, r0
300201b8:	e3530000 	cmp	r3, #0
300201bc:	1a000030 	bne	30020284 <udp_input+0x614>
          !ip_addr_ismulticast(&iphdr->dest)) {
300201c0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300201c4:	e5d32010 	ldrb	r2, [r3, #16]
300201c8:	e5d31011 	ldrb	r1, [r3, #17]
300201cc:	e1a01401 	lsl	r1, r1, #8
300201d0:	e1812002 	orr	r2, r1, r2
300201d4:	e5d31012 	ldrb	r1, [r3, #18]
300201d8:	e1a01801 	lsl	r1, r1, #16
300201dc:	e1812002 	orr	r2, r1, r2
300201e0:	e5d33013 	ldrb	r3, [r3, #19]
300201e4:	e1a03c03 	lsl	r3, r3, #24
300201e8:	e1833002 	orr	r3, r3, r2
300201ec:	e1a04003 	mov	r4, r3
300201f0:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
300201f4:	ebffcde1 	bl	30013980 <ntohl>
300201f8:	e1a03000 	mov	r3, r0
300201fc:	e0044003 	and	r4, r4, r3
30020200:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
30020204:	ebffcddd 	bl	30013980 <ntohl>
30020208:	e1a03000 	mov	r3, r0
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
3002020c:	e1540003 	cmp	r4, r3
30020210:	0a00001b 	beq	30020284 <udp_input+0x614>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
30020214:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30020218:	e5d32000 	ldrb	r2, [r3]
3002021c:	e5d33001 	ldrb	r3, [r3, #1]
30020220:	e1a03403 	lsl	r3, r3, #8
30020224:	e1833002 	orr	r3, r3, r2
30020228:	e1a03803 	lsl	r3, r3, #16
3002022c:	e1a03823 	lsr	r3, r3, #16
30020230:	e1a00003 	mov	r0, r3
30020234:	ebffcdb3 	bl	30013908 <ntohs>
30020238:	e1a03000 	mov	r3, r0
3002023c:	e1a03423 	lsr	r3, r3, #8
30020240:	e1a03803 	lsl	r3, r3, #16
30020244:	e1a03823 	lsr	r3, r3, #16
30020248:	e203300f 	and	r3, r3, #15
3002024c:	e2833002 	add	r3, r3, #2
30020250:	e1a03803 	lsl	r3, r3, #16
30020254:	e1a03823 	lsr	r3, r3, #16
30020258:	e1a03103 	lsl	r3, r3, #2
3002025c:	e1a03803 	lsl	r3, r3, #16
30020260:	e1a03823 	lsr	r3, r3, #16
30020264:	e1a03803 	lsl	r3, r3, #16
30020268:	e1a03843 	asr	r3, r3, #16
3002026c:	e59d000c 	ldr	r0, [sp, #12]
30020270:	e1a01003 	mov	r1, r3
30020274:	ebffd848 	bl	3001639c <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
30020278:	e59d000c 	ldr	r0, [sp, #12]
3002027c:	e3a01003 	mov	r1, #3
30020280:	ebffcb88 	bl	300130a8 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
30020284:	e59f3050 	ldr	r3, [pc, #80]	; 300202dc <udp_input+0x66c>
30020288:	e1d339b4 	ldrh	r3, [r3, #148]	; 0x94
3002028c:	e2833001 	add	r3, r3, #1
30020290:	e1a03803 	lsl	r3, r3, #16
30020294:	e1a02823 	lsr	r2, r3, #16
30020298:	e59f303c 	ldr	r3, [pc, #60]	; 300202dc <udp_input+0x66c>
3002029c:	e1c329b4 	strh	r2, [r3, #148]	; 0x94
      UDP_STATS_INC(udp.drop);
300202a0:	e59f3034 	ldr	r3, [pc, #52]	; 300202dc <udp_input+0x66c>
300202a4:	e1d338ba 	ldrh	r3, [r3, #138]	; 0x8a
300202a8:	e2833001 	add	r3, r3, #1
300202ac:	e1a03803 	lsl	r3, r3, #16
300202b0:	e1a02823 	lsr	r2, r3, #16
300202b4:	e59f3020 	ldr	r3, [pc, #32]	; 300202dc <udp_input+0x66c>
300202b8:	e1c328ba 	strh	r2, [r3, #138]	; 0x8a
      snmp_inc_udpnoports();
      pbuf_free(p);
300202bc:	e59d000c 	ldr	r0, [sp, #12]
300202c0:	ebffd89a 	bl	30016530 <pbuf_free>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
300202c4:	ea000001 	b	300202d0 <udp_input+0x660>
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
  	//acoral_prints("\nudp: pcb is null\n");
    pbuf_free(p);
300202c8:	e59d000c 	ldr	r0, [sp, #12]
300202cc:	ebffd897 	bl	30016530 <pbuf_free>
  }
end:
  PERF_STOP("udp_input");
}
300202d0:	e28dd030 	add	sp, sp, #48	; 0x30
300202d4:	e8bd4010 	pop	{r4, lr}
300202d8:	e12fff1e 	bx	lr
300202dc:	3002b214 	.word	0x3002b214
300202e0:	3002a6ec 	.word	0x3002a6ec
300202e4:	300265c4 	.word	0x300265c4

300202e8 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
300202e8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300202ec:	e24dd00c 	sub	sp, sp, #12
300202f0:	e58d0004 	str	r0, [sp, #4]
300202f4:	e58d1000 	str	r1, [sp]
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
300202f8:	e59d3004 	ldr	r3, [sp, #4]
300202fc:	e2832004 	add	r2, r3, #4
30020300:	e59d3004 	ldr	r3, [sp, #4]
30020304:	e1d331b4 	ldrh	r3, [r3, #20]
30020308:	e59d0004 	ldr	r0, [sp, #4]
3002030c:	e59d1000 	ldr	r1, [sp]
30020310:	eb000008 	bl	30020338 <udp_sendto>
30020314:	e1a03000 	mov	r3, r0
30020318:	e20330ff 	and	r3, r3, #255	; 0xff
3002031c:	e20330ff 	and	r3, r3, #255	; 0xff
30020320:	e1a03c03 	lsl	r3, r3, #24
30020324:	e1a03c43 	asr	r3, r3, #24
}
30020328:	e1a00003 	mov	r0, r3
3002032c:	e28dd00c 	add	sp, sp, #12
30020330:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30020334:	e12fff1e 	bx	lr

30020338 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
30020338:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002033c:	e24dd024 	sub	sp, sp, #36	; 0x24
30020340:	e58d0014 	str	r0, [sp, #20]
30020344:	e58d1010 	str	r1, [sp, #16]
30020348:	e58d200c 	str	r2, [sp, #12]
3002034c:	e1cd30ba 	strh	r3, [sp, #10]

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
30020350:	e59d000c 	ldr	r0, [sp, #12]
30020354:	ebffcfad 	bl	30014210 <ip_route>
30020358:	e1a03000 	mov	r3, r0
3002035c:	e58d301c 	str	r3, [sp, #28]
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
30020360:	e59d301c 	ldr	r3, [sp, #28]
30020364:	e3530000 	cmp	r3, #0
30020368:	1a000008 	bne	30020390 <udp_sendto+0x58>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
3002036c:	e59f305c 	ldr	r3, [pc, #92]	; 300203d0 <udp_sendto+0x98>
30020370:	e1d339b2 	ldrh	r3, [r3, #146]	; 0x92
30020374:	e2833001 	add	r3, r3, #1
30020378:	e1a03803 	lsl	r3, r3, #16
3002037c:	e1a02823 	lsr	r2, r3, #16
30020380:	e59f3048 	ldr	r3, [pc, #72]	; 300203d0 <udp_sendto+0x98>
30020384:	e1c329b2 	strh	r2, [r3, #146]	; 0x92
    return ERR_RTE;
30020388:	e3a030fd 	mov	r3, #253	; 0xfd
3002038c:	ea000009 	b	300203b8 <udp_sendto+0x80>
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
30020390:	e1dd30ba 	ldrh	r3, [sp, #10]
30020394:	e59d201c 	ldr	r2, [sp, #28]
30020398:	e58d2000 	str	r2, [sp]
3002039c:	e59d0014 	ldr	r0, [sp, #20]
300203a0:	e59d1010 	ldr	r1, [sp, #16]
300203a4:	e59d200c 	ldr	r2, [sp, #12]
300203a8:	eb000009 	bl	300203d4 <udp_sendto_if>
300203ac:	e1a03000 	mov	r3, r0
300203b0:	e20330ff 	and	r3, r3, #255	; 0xff
300203b4:	e20330ff 	and	r3, r3, #255	; 0xff
300203b8:	e1a03c03 	lsl	r3, r3, #24
300203bc:	e1a03c43 	asr	r3, r3, #24
}
300203c0:	e1a00003 	mov	r0, r3
300203c4:	e28dd024 	add	sp, sp, #36	; 0x24
300203c8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300203cc:	e12fff1e 	bx	lr
300203d0:	3002b214 	.word	0x3002b214

300203d4 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
300203d4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300203d8:	e24dd034 	sub	sp, sp, #52	; 0x34
300203dc:	e58d001c 	str	r0, [sp, #28]
300203e0:	e58d1018 	str	r1, [sp, #24]
300203e4:	e58d2014 	str	r2, [sp, #20]
300203e8:	e1cd31b2 	strh	r3, [sp, #18]
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
300203ec:	e59d301c 	ldr	r3, [sp, #28]
300203f0:	e1d331b2 	ldrh	r3, [r3, #18]
300203f4:	e3530000 	cmp	r3, #0
300203f8:	1a00000e 	bne	30020438 <udp_sendto_if+0x64>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
300203fc:	e59d201c 	ldr	r2, [sp, #28]
30020400:	e59d301c 	ldr	r3, [sp, #28]
30020404:	e1d331b2 	ldrh	r3, [r3, #18]
30020408:	e59d001c 	ldr	r0, [sp, #28]
3002040c:	e1a01002 	mov	r1, r2
30020410:	e1a02003 	mov	r2, r3
30020414:	eb0000c4 	bl	3002072c <udp_bind>
30020418:	e1a03000 	mov	r3, r0
3002041c:	e20330ff 	and	r3, r3, #255	; 0xff
30020420:	e5cd302b 	strb	r3, [sp, #43]	; 0x2b
    if (err != ERR_OK) {
30020424:	e1dd32db 	ldrsb	r3, [sp, #43]	; 0x2b
30020428:	e3530000 	cmp	r3, #0
3002042c:	0a000001 	beq	30020438 <udp_sendto_if+0x64>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: forced port bind failed\n"));
      return err;
30020430:	e5dd302b 	ldrb	r3, [sp, #43]	; 0x2b
30020434:	ea0000b5 	b	30020710 <udp_sendto_if+0x33c>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
30020438:	e59d0018 	ldr	r0, [sp, #24]
3002043c:	e3a01008 	mov	r1, #8
30020440:	ebffd7d5 	bl	3001639c <pbuf_header>
30020444:	e1a03000 	mov	r3, r0
30020448:	e3530000 	cmp	r3, #0
3002044c:	0a00000e 	beq	3002048c <udp_sendto_if+0xb8>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
30020450:	e3a00001 	mov	r0, #1
30020454:	e3a01008 	mov	r1, #8
30020458:	e3a02000 	mov	r2, #0
3002045c:	ebffd684 	bl	30015e74 <pbuf_alloc>
30020460:	e1a03000 	mov	r3, r0
30020464:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
30020468:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3002046c:	e3530000 	cmp	r3, #0
30020470:	1a000001 	bne	3002047c <udp_sendto_if+0xa8>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
30020474:	e3a030ff 	mov	r3, #255	; 0xff
30020478:	ea0000a4 	b	30020710 <udp_sendto_if+0x33c>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
3002047c:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30020480:	e59d1018 	ldr	r1, [sp, #24]
30020484:	ebffd8ba 	bl	30016774 <pbuf_chain>
30020488:	ea000001 	b	30020494 <udp_sendto_if+0xc0>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
3002048c:	e59d3018 	ldr	r3, [sp, #24]
30020490:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
30020494:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30020498:	e5933004 	ldr	r3, [r3, #4]
3002049c:	e58d3020 	str	r3, [sp, #32]
  udphdr->src = htons(pcb->local_port);
300204a0:	e59d301c 	ldr	r3, [sp, #28]
300204a4:	e1d331b2 	ldrh	r3, [r3, #18]
300204a8:	e1a00003 	mov	r0, r3
300204ac:	ebffcd02 	bl	300138bc <htons>
300204b0:	e1a03000 	mov	r3, r0
300204b4:	e1a02003 	mov	r2, r3
300204b8:	e59d3020 	ldr	r3, [sp, #32]
300204bc:	e20210ff 	and	r1, r2, #255	; 0xff
300204c0:	e3a00000 	mov	r0, #0
300204c4:	e1801001 	orr	r1, r0, r1
300204c8:	e5c31000 	strb	r1, [r3]
300204cc:	e1a02422 	lsr	r2, r2, #8
300204d0:	e1a02802 	lsl	r2, r2, #16
300204d4:	e1a02822 	lsr	r2, r2, #16
300204d8:	e3a01000 	mov	r1, #0
300204dc:	e1812002 	orr	r2, r1, r2
300204e0:	e5c32001 	strb	r2, [r3, #1]
  udphdr->dest = htons(dst_port);
300204e4:	e1dd31b2 	ldrh	r3, [sp, #18]
300204e8:	e1a00003 	mov	r0, r3
300204ec:	ebffccf2 	bl	300138bc <htons>
300204f0:	e1a03000 	mov	r3, r0
300204f4:	e1a02003 	mov	r2, r3
300204f8:	e59d3020 	ldr	r3, [sp, #32]
300204fc:	e20210ff 	and	r1, r2, #255	; 0xff
30020500:	e3a00000 	mov	r0, #0
30020504:	e1801001 	orr	r1, r0, r1
30020508:	e5c31002 	strb	r1, [r3, #2]
3002050c:	e1a02422 	lsr	r2, r2, #8
30020510:	e1a02802 	lsl	r2, r2, #16
30020514:	e1a02822 	lsr	r2, r2, #16
30020518:	e3a01000 	mov	r1, #0
3002051c:	e1812002 	orr	r2, r1, r2
30020520:	e5c32003 	strb	r2, [r3, #3]
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
30020524:	e59d3020 	ldr	r3, [sp, #32]
30020528:	e3a02000 	mov	r2, #0
3002052c:	e5c32006 	strb	r2, [r3, #6]
30020530:	e3a02000 	mov	r2, #0
30020534:	e5c32007 	strb	r2, [r3, #7]

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
30020538:	e59d301c 	ldr	r3, [sp, #28]
3002053c:	e3530000 	cmp	r3, #0
30020540:	0a000003 	beq	30020554 <udp_sendto_if+0x180>
30020544:	e59d301c 	ldr	r3, [sp, #28]
30020548:	e5933000 	ldr	r3, [r3]
3002054c:	e3530000 	cmp	r3, #0
30020550:	1a000003 	bne	30020564 <udp_sendto_if+0x190>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
30020554:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30020558:	e2833004 	add	r3, r3, #4
3002055c:	e58d3024 	str	r3, [sp, #36]	; 0x24
  udphdr->dest = htons(dst_port);
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
30020560:	ea000011 	b	300205ac <udp_sendto_if+0x1d8>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
30020564:	e59d301c 	ldr	r3, [sp, #28]
30020568:	e5932000 	ldr	r2, [r3]
3002056c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30020570:	e5933004 	ldr	r3, [r3, #4]
30020574:	e1520003 	cmp	r2, r3
30020578:	0a000009 	beq	300205a4 <udp_sendto_if+0x1d0>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
3002057c:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30020580:	e59d3018 	ldr	r3, [sp, #24]
30020584:	e1520003 	cmp	r2, r3
30020588:	0a000003 	beq	3002059c <udp_sendto_if+0x1c8>
        /* free the header pbuf */
        pbuf_free(q);
3002058c:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30020590:	ebffd7e6 	bl	30016530 <pbuf_free>
        q = NULL;
30020594:	e3a03000 	mov	r3, #0
30020598:	e58d302c 	str	r3, [sp, #44]	; 0x2c
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
3002059c:	e3a030f8 	mov	r3, #248	; 0xf8
300205a0:	ea00005a 	b	30020710 <udp_sendto_if+0x33c>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
300205a4:	e59d301c 	ldr	r3, [sp, #28]
300205a8:	e58d3024 	str	r3, [sp, #36]	; 0x24
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
300205ac:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300205b0:	e1d330b8 	ldrh	r3, [r3, #8]
300205b4:	e1a00003 	mov	r0, r3
300205b8:	ebffccbf 	bl	300138bc <htons>
300205bc:	e1a03000 	mov	r3, r0
300205c0:	e1a02003 	mov	r2, r3
300205c4:	e59d3020 	ldr	r3, [sp, #32]
300205c8:	e20210ff 	and	r1, r2, #255	; 0xff
300205cc:	e3a00000 	mov	r0, #0
300205d0:	e1801001 	orr	r1, r0, r1
300205d4:	e5c31004 	strb	r1, [r3, #4]
300205d8:	e1a02422 	lsr	r2, r2, #8
300205dc:	e1a02802 	lsl	r2, r2, #16
300205e0:	e1a02822 	lsr	r2, r2, #16
300205e4:	e3a01000 	mov	r1, #0
300205e8:	e1812002 	orr	r2, r1, r2
300205ec:	e5c32005 	strb	r2, [r3, #5]
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
300205f0:	e59d301c 	ldr	r3, [sp, #28]
300205f4:	e5d33010 	ldrb	r3, [r3, #16]
300205f8:	e2033001 	and	r3, r3, #1
300205fc:	e3530000 	cmp	r3, #0
30020600:	1a000022 	bne	30020690 <udp_sendto_if+0x2bc>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
30020604:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30020608:	e1d330b8 	ldrh	r3, [r3, #8]
3002060c:	e58d3000 	str	r3, [sp]
30020610:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30020614:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
30020618:	e59d2014 	ldr	r2, [sp, #20]
3002061c:	e3a03011 	mov	r3, #17
30020620:	ebffcd2c 	bl	30013ad8 <inet_chksum_pseudo>
30020624:	e1a03000 	mov	r3, r0
30020628:	e1a02003 	mov	r2, r3
3002062c:	e59d3020 	ldr	r3, [sp, #32]
30020630:	e20210ff 	and	r1, r2, #255	; 0xff
30020634:	e3a00000 	mov	r0, #0
30020638:	e1801001 	orr	r1, r0, r1
3002063c:	e5c31006 	strb	r1, [r3, #6]
30020640:	e1a02422 	lsr	r2, r2, #8
30020644:	e1a02802 	lsl	r2, r2, #16
30020648:	e1a02822 	lsr	r2, r2, #16
3002064c:	e3a01000 	mov	r1, #0
30020650:	e1812002 	orr	r2, r1, r2
30020654:	e5c32007 	strb	r2, [r3, #7]
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
30020658:	e59d3020 	ldr	r3, [sp, #32]
3002065c:	e5d32006 	ldrb	r2, [r3, #6]
30020660:	e5d33007 	ldrb	r3, [r3, #7]
30020664:	e1a03403 	lsl	r3, r3, #8
30020668:	e1833002 	orr	r3, r3, r2
3002066c:	e1a03803 	lsl	r3, r3, #16
30020670:	e1a03823 	lsr	r3, r3, #16
30020674:	e3530000 	cmp	r3, #0
30020678:	1a000004 	bne	30020690 <udp_sendto_if+0x2bc>
3002067c:	e59d3020 	ldr	r3, [sp, #32]
30020680:	e3e02000 	mvn	r2, #0
30020684:	e5c32006 	strb	r2, [r3, #6]
30020688:	e3e02000 	mvn	r2, #0
3002068c:	e5c32007 	strb	r2, [r3, #7]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
30020690:	e59d301c 	ldr	r3, [sp, #28]
30020694:	e5d3300b 	ldrb	r3, [r3, #11]
30020698:	e59d201c 	ldr	r2, [sp, #28]
3002069c:	e5d2200a 	ldrb	r2, [r2, #10]
300206a0:	e58d2000 	str	r2, [sp]
300206a4:	e3a02011 	mov	r2, #17
300206a8:	e58d2004 	str	r2, [sp, #4]
300206ac:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
300206b0:	e58d2008 	str	r2, [sp, #8]
300206b4:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
300206b8:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
300206bc:	e59d2014 	ldr	r2, [sp, #20]
300206c0:	ebffd08c 	bl	300148f8 <ip_output_if>
300206c4:	e1a03000 	mov	r3, r0
300206c8:	e20330ff 	and	r3, r3, #255	; 0xff
300206cc:	e5cd302b 	strb	r3, [sp, #43]	; 0x2b
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
300206d0:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
300206d4:	e59d3018 	ldr	r3, [sp, #24]
300206d8:	e1520003 	cmp	r2, r3
300206dc:	0a000003 	beq	300206f0 <udp_sendto_if+0x31c>
    /* free the header pbuf */
    pbuf_free(q);
300206e0:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
300206e4:	ebffd791 	bl	30016530 <pbuf_free>
    q = NULL;
300206e8:	e3a03000 	mov	r3, #0
300206ec:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
300206f0:	e59f3030 	ldr	r3, [pc, #48]	; 30020728 <udp_sendto_if+0x354>
300206f4:	e1d338b2 	ldrh	r3, [r3, #130]	; 0x82
300206f8:	e2833001 	add	r3, r3, #1
300206fc:	e1a03803 	lsl	r3, r3, #16
30020700:	e1a02823 	lsr	r2, r3, #16
30020704:	e59f301c 	ldr	r3, [pc, #28]	; 30020728 <udp_sendto_if+0x354>
30020708:	e1c328b2 	strh	r2, [r3, #130]	; 0x82
  return err;
3002070c:	e5dd302b 	ldrb	r3, [sp, #43]	; 0x2b
30020710:	e1a03c03 	lsl	r3, r3, #24
30020714:	e1a03c43 	asr	r3, r3, #24
}
30020718:	e1a00003 	mov	r0, r3
3002071c:	e28dd034 	add	sp, sp, #52	; 0x34
30020720:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30020724:	e12fff1e 	bx	lr
30020728:	3002b214 	.word	0x3002b214

3002072c <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
3002072c:	e24dd018 	sub	sp, sp, #24
30020730:	e58d000c 	str	r0, [sp, #12]
30020734:	e58d1008 	str	r1, [sp, #8]
30020738:	e1a03002 	mov	r3, r2
3002073c:	e1cd30b6 	strh	r3, [sp, #6]

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
30020740:	e3a03000 	mov	r3, #0
30020744:	e5cd3017 	strb	r3, [sp, #23]
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
30020748:	e59f3160 	ldr	r3, [pc, #352]	; 300208b0 <udp_bind+0x184>
3002074c:	e5933000 	ldr	r3, [r3]
30020750:	e58d3010 	str	r3, [sp, #16]
30020754:	ea000008 	b	3002077c <udp_bind+0x50>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
30020758:	e59d200c 	ldr	r2, [sp, #12]
3002075c:	e59d3010 	ldr	r3, [sp, #16]
30020760:	e1520003 	cmp	r2, r3
30020764:	1a000001 	bne	30020770 <udp_bind+0x44>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
30020768:	e3a03001 	mov	r3, #1
3002076c:	e5cd3017 	strb	r3, [sp, #23]
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
30020770:	e59d3010 	ldr	r3, [sp, #16]
30020774:	e593300c 	ldr	r3, [r3, #12]
30020778:	e58d3010 	str	r3, [sp, #16]
3002077c:	e59d3010 	ldr	r3, [sp, #16]
30020780:	e3530000 	cmp	r3, #0
30020784:	1afffff3 	bne	30020758 <udp_bind+0x2c>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
30020788:	e59d3008 	ldr	r3, [sp, #8]
3002078c:	e3530000 	cmp	r3, #0
30020790:	0a00000b 	beq	300207c4 <udp_bind+0x98>
30020794:	e59d3008 	ldr	r3, [sp, #8]
30020798:	e5d32000 	ldrb	r2, [r3]
3002079c:	e5d31001 	ldrb	r1, [r3, #1]
300207a0:	e1a01401 	lsl	r1, r1, #8
300207a4:	e1812002 	orr	r2, r1, r2
300207a8:	e5d31002 	ldrb	r1, [r3, #2]
300207ac:	e1a01801 	lsl	r1, r1, #16
300207b0:	e1812002 	orr	r2, r1, r2
300207b4:	e5d33003 	ldrb	r3, [r3, #3]
300207b8:	e1a03c03 	lsl	r3, r3, #24
300207bc:	e1833002 	orr	r3, r3, r2
300207c0:	ea000000 	b	300207c8 <udp_bind+0x9c>
300207c4:	e3a03000 	mov	r3, #0
300207c8:	e59d200c 	ldr	r2, [sp, #12]
300207cc:	e5823000 	str	r3, [r2]

  /* no port specified? */
  if (port == 0) {
300207d0:	e1dd30b6 	ldrh	r3, [sp, #6]
300207d4:	e3530000 	cmp	r3, #0
300207d8:	1a000021 	bne	30020864 <udp_bind+0x138>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
300207dc:	e3a03a01 	mov	r3, #4096	; 0x1000
300207e0:	e1cd30b6 	strh	r3, [sp, #6]
    ipcb = udp_pcbs;
300207e4:	e59f30c4 	ldr	r3, [pc, #196]	; 300208b0 <udp_bind+0x184>
300207e8:	e5933000 	ldr	r3, [r3]
300207ec:	e58d3010 	str	r3, [sp, #16]
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
300207f0:	ea00000e 	b	30020830 <udp_bind+0x104>
      if (ipcb->local_port == port) {
300207f4:	e59d3010 	ldr	r3, [sp, #16]
300207f8:	e1d331b2 	ldrh	r3, [r3, #18]
300207fc:	e1dd20b6 	ldrh	r2, [sp, #6]
30020800:	e1520003 	cmp	r2, r3
30020804:	1a000006 	bne	30020824 <udp_bind+0xf8>
        /* port is already used by another udp_pcb */
        port++;
30020808:	e1dd30b6 	ldrh	r3, [sp, #6]
3002080c:	e2833001 	add	r3, r3, #1
30020810:	e1cd30b6 	strh	r3, [sp, #6]
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
30020814:	e59f3094 	ldr	r3, [pc, #148]	; 300208b0 <udp_bind+0x184>
30020818:	e5933000 	ldr	r3, [r3]
3002081c:	e58d3010 	str	r3, [sp, #16]
30020820:	ea000002 	b	30020830 <udp_bind+0x104>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
30020824:	e59d3010 	ldr	r3, [sp, #16]
30020828:	e593300c 	ldr	r3, [r3, #12]
3002082c:	e58d3010 	str	r3, [sp, #16]
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
30020830:	e59d3010 	ldr	r3, [sp, #16]
30020834:	e3530000 	cmp	r3, #0
30020838:	0a000004 	beq	30020850 <udp_bind+0x124>
3002083c:	e1dd20b6 	ldrh	r2, [sp, #6]
30020840:	e3a03c7f 	mov	r3, #32512	; 0x7f00
30020844:	e28330ff 	add	r3, r3, #255	; 0xff
30020848:	e1520003 	cmp	r2, r3
3002084c:	1affffe8 	bne	300207f4 <udp_bind+0xc8>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
30020850:	e59d3010 	ldr	r3, [sp, #16]
30020854:	e3530000 	cmp	r3, #0
30020858:	0a000001 	beq	30020864 <udp_bind+0x138>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
3002085c:	e3a030f6 	mov	r3, #246	; 0xf6
30020860:	ea00000d 	b	3002089c <udp_bind+0x170>
    }
  }
  pcb->local_port = port;
30020864:	e59d300c 	ldr	r3, [sp, #12]
30020868:	e1dd20b6 	ldrh	r2, [sp, #6]
3002086c:	e1c321b2 	strh	r2, [r3, #18]
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
30020870:	e5dd3017 	ldrb	r3, [sp, #23]
30020874:	e3530000 	cmp	r3, #0
30020878:	1a000006 	bne	30020898 <udp_bind+0x16c>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
3002087c:	e59f302c 	ldr	r3, [pc, #44]	; 300208b0 <udp_bind+0x184>
30020880:	e5932000 	ldr	r2, [r3]
30020884:	e59d300c 	ldr	r3, [sp, #12]
30020888:	e583200c 	str	r2, [r3, #12]
    udp_pcbs = pcb;
3002088c:	e59f301c 	ldr	r3, [pc, #28]	; 300208b0 <udp_bind+0x184>
30020890:	e59d200c 	ldr	r2, [sp, #12]
30020894:	e5832000 	str	r2, [r3]
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
30020898:	e3a03000 	mov	r3, #0
3002089c:	e1a03c03 	lsl	r3, r3, #24
300208a0:	e1a03c43 	asr	r3, r3, #24
}
300208a4:	e1a00003 	mov	r0, r3
300208a8:	e28dd018 	add	sp, sp, #24
300208ac:	e12fff1e 	bx	lr
300208b0:	3002a6ec 	.word	0x3002a6ec

300208b4 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
300208b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300208b8:	e24dd01c 	sub	sp, sp, #28
300208bc:	e58d000c 	str	r0, [sp, #12]
300208c0:	e58d1008 	str	r1, [sp, #8]
300208c4:	e1a03002 	mov	r3, r2
300208c8:	e1cd30b6 	strh	r3, [sp, #6]
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
300208cc:	e59d300c 	ldr	r3, [sp, #12]
300208d0:	e1d331b2 	ldrh	r3, [r3, #18]
300208d4:	e3530000 	cmp	r3, #0
300208d8:	1a00000e 	bne	30020918 <udp_connect+0x64>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
300208dc:	e59d200c 	ldr	r2, [sp, #12]
300208e0:	e59d300c 	ldr	r3, [sp, #12]
300208e4:	e1d331b2 	ldrh	r3, [r3, #18]
300208e8:	e59d000c 	ldr	r0, [sp, #12]
300208ec:	e1a01002 	mov	r1, r2
300208f0:	e1a02003 	mov	r2, r3
300208f4:	ebffff8c 	bl	3002072c <udp_bind>
300208f8:	e1a03000 	mov	r3, r0
300208fc:	e20330ff 	and	r3, r3, #255	; 0xff
30020900:	e5cd3017 	strb	r3, [sp, #23]
    if (err != ERR_OK)
30020904:	e1dd31d7 	ldrsb	r3, [sp, #23]
30020908:	e3530000 	cmp	r3, #0
3002090c:	0a000001 	beq	30020918 <udp_connect+0x64>
      return err;
30020910:	e5dd3017 	ldrb	r3, [sp, #23]
30020914:	ea000032 	b	300209e4 <udp_connect+0x130>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
30020918:	e59d3008 	ldr	r3, [sp, #8]
3002091c:	e3530000 	cmp	r3, #0
30020920:	0a00000b 	beq	30020954 <udp_connect+0xa0>
30020924:	e59d3008 	ldr	r3, [sp, #8]
30020928:	e5d32000 	ldrb	r2, [r3]
3002092c:	e5d31001 	ldrb	r1, [r3, #1]
30020930:	e1a01401 	lsl	r1, r1, #8
30020934:	e1812002 	orr	r2, r1, r2
30020938:	e5d31002 	ldrb	r1, [r3, #2]
3002093c:	e1a01801 	lsl	r1, r1, #16
30020940:	e1812002 	orr	r2, r1, r2
30020944:	e5d33003 	ldrb	r3, [r3, #3]
30020948:	e1a03c03 	lsl	r3, r3, #24
3002094c:	e1833002 	orr	r3, r3, r2
30020950:	ea000000 	b	30020958 <udp_connect+0xa4>
30020954:	e3a03000 	mov	r3, #0
30020958:	e59d200c 	ldr	r2, [sp, #12]
3002095c:	e5823004 	str	r3, [r2, #4]
  pcb->remote_port = port;
30020960:	e59d300c 	ldr	r3, [sp, #12]
30020964:	e1dd20b6 	ldrh	r2, [sp, #6]
30020968:	e1c321b4 	strh	r2, [r3, #20]
  pcb->flags |= UDP_FLAGS_CONNECTED;
3002096c:	e59d300c 	ldr	r3, [sp, #12]
30020970:	e5d33010 	ldrb	r3, [r3, #16]
30020974:	e3833004 	orr	r3, r3, #4
30020978:	e20320ff 	and	r2, r3, #255	; 0xff
3002097c:	e59d300c 	ldr	r3, [sp, #12]
30020980:	e5c32010 	strb	r2, [r3, #16]
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
30020984:	e59f3070 	ldr	r3, [pc, #112]	; 300209fc <udp_connect+0x148>
30020988:	e5933000 	ldr	r3, [r3]
3002098c:	e58d3010 	str	r3, [sp, #16]
30020990:	ea000008 	b	300209b8 <udp_connect+0x104>
    if (pcb == ipcb) {
30020994:	e59d200c 	ldr	r2, [sp, #12]
30020998:	e59d3010 	ldr	r3, [sp, #16]
3002099c:	e1520003 	cmp	r2, r3
300209a0:	1a000001 	bne	300209ac <udp_connect+0xf8>
      /* already on the list, just return */
      return ERR_OK;
300209a4:	e3a03000 	mov	r3, #0
300209a8:	ea00000d 	b	300209e4 <udp_connect+0x130>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
300209ac:	e59d3010 	ldr	r3, [sp, #16]
300209b0:	e593300c 	ldr	r3, [r3, #12]
300209b4:	e58d3010 	str	r3, [sp, #16]
300209b8:	e59d3010 	ldr	r3, [sp, #16]
300209bc:	e3530000 	cmp	r3, #0
300209c0:	1afffff3 	bne	30020994 <udp_connect+0xe0>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
300209c4:	e59f3030 	ldr	r3, [pc, #48]	; 300209fc <udp_connect+0x148>
300209c8:	e5932000 	ldr	r2, [r3]
300209cc:	e59d300c 	ldr	r3, [sp, #12]
300209d0:	e583200c 	str	r2, [r3, #12]
  udp_pcbs = pcb;
300209d4:	e59f3020 	ldr	r3, [pc, #32]	; 300209fc <udp_connect+0x148>
300209d8:	e59d200c 	ldr	r2, [sp, #12]
300209dc:	e5832000 	str	r2, [r3]
  return ERR_OK;
300209e0:	e3a03000 	mov	r3, #0
300209e4:	e1a03c03 	lsl	r3, r3, #24
300209e8:	e1a03c43 	asr	r3, r3, #24
}
300209ec:	e1a00003 	mov	r0, r3
300209f0:	e28dd01c 	add	sp, sp, #28
300209f4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300209f8:	e12fff1e 	bx	lr
300209fc:	3002a6ec 	.word	0x3002a6ec

30020a00 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
30020a00:	e24dd008 	sub	sp, sp, #8
30020a04:	e58d0004 	str	r0, [sp, #4]
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
30020a08:	e59f3058 	ldr	r3, [pc, #88]	; 30020a68 <udp_disconnect+0x68>
30020a0c:	e5d32000 	ldrb	r2, [r3]
30020a10:	e5d31001 	ldrb	r1, [r3, #1]
30020a14:	e1a01401 	lsl	r1, r1, #8
30020a18:	e1812002 	orr	r2, r1, r2
30020a1c:	e5d31002 	ldrb	r1, [r3, #2]
30020a20:	e1a01801 	lsl	r1, r1, #16
30020a24:	e1812002 	orr	r2, r1, r2
30020a28:	e5d33003 	ldrb	r3, [r3, #3]
30020a2c:	e1a03c03 	lsl	r3, r3, #24
30020a30:	e1833002 	orr	r3, r3, r2
30020a34:	e1a02003 	mov	r2, r3
30020a38:	e59d3004 	ldr	r3, [sp, #4]
30020a3c:	e5832004 	str	r2, [r3, #4]
  pcb->remote_port = 0;
30020a40:	e59d3004 	ldr	r3, [sp, #4]
30020a44:	e3a02000 	mov	r2, #0
30020a48:	e1c321b4 	strh	r2, [r3, #20]
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
30020a4c:	e59d3004 	ldr	r3, [sp, #4]
30020a50:	e5d33010 	ldrb	r3, [r3, #16]
30020a54:	e20330fb 	and	r3, r3, #251	; 0xfb
30020a58:	e59d2004 	ldr	r2, [sp, #4]
30020a5c:	e5c23010 	strb	r3, [r2, #16]
}
30020a60:	e28dd008 	add	sp, sp, #8
30020a64:	e12fff1e 	bx	lr
30020a68:	3002655c 	.word	0x3002655c

30020a6c <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
30020a6c:	e24dd010 	sub	sp, sp, #16
30020a70:	e58d000c 	str	r0, [sp, #12]
30020a74:	e58d1008 	str	r1, [sp, #8]
30020a78:	e58d2004 	str	r2, [sp, #4]
  /* remember recv() callback and user data */
  pcb->recv = recv;
30020a7c:	e59d300c 	ldr	r3, [sp, #12]
30020a80:	e59d2008 	ldr	r2, [sp, #8]
30020a84:	e5832018 	str	r2, [r3, #24]
  pcb->recv_arg = recv_arg;
30020a88:	e59d300c 	ldr	r3, [sp, #12]
30020a8c:	e59d2004 	ldr	r2, [sp, #4]
30020a90:	e583201c 	str	r2, [r3, #28]
}
30020a94:	e28dd010 	add	sp, sp, #16
30020a98:	e12fff1e 	bx	lr

30020a9c <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
30020a9c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30020aa0:	e24dd014 	sub	sp, sp, #20
30020aa4:	e58d0004 	str	r0, [sp, #4]
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
30020aa8:	e59f3098 	ldr	r3, [pc, #152]	; 30020b48 <udp_remove+0xac>
30020aac:	e5932000 	ldr	r2, [r3]
30020ab0:	e59d3004 	ldr	r3, [sp, #4]
30020ab4:	e1520003 	cmp	r2, r3
30020ab8:	1a000005 	bne	30020ad4 <udp_remove+0x38>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
30020abc:	e59f3084 	ldr	r3, [pc, #132]	; 30020b48 <udp_remove+0xac>
30020ac0:	e5933000 	ldr	r3, [r3]
30020ac4:	e593200c 	ldr	r2, [r3, #12]
30020ac8:	e59f3078 	ldr	r3, [pc, #120]	; 30020b48 <udp_remove+0xac>
30020acc:	e5832000 	str	r2, [r3]
30020ad0:	ea000016 	b	30020b30 <udp_remove+0x94>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
30020ad4:	e59f306c 	ldr	r3, [pc, #108]	; 30020b48 <udp_remove+0xac>
30020ad8:	e5933000 	ldr	r3, [r3]
30020adc:	e58d300c 	str	r3, [sp, #12]
30020ae0:	ea00000f 	b	30020b24 <udp_remove+0x88>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
30020ae4:	e59d300c 	ldr	r3, [sp, #12]
30020ae8:	e593300c 	ldr	r3, [r3, #12]
30020aec:	e3530000 	cmp	r3, #0
30020af0:	0a000008 	beq	30020b18 <udp_remove+0x7c>
30020af4:	e59d300c 	ldr	r3, [sp, #12]
30020af8:	e593200c 	ldr	r2, [r3, #12]
30020afc:	e59d3004 	ldr	r3, [sp, #4]
30020b00:	e1520003 	cmp	r2, r3
30020b04:	1a000003 	bne	30020b18 <udp_remove+0x7c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
30020b08:	e59d3004 	ldr	r3, [sp, #4]
30020b0c:	e593200c 	ldr	r2, [r3, #12]
30020b10:	e59d300c 	ldr	r3, [sp, #12]
30020b14:	e583200c 	str	r2, [r3, #12]
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
30020b18:	e59d300c 	ldr	r3, [sp, #12]
30020b1c:	e593300c 	ldr	r3, [r3, #12]
30020b20:	e58d300c 	str	r3, [sp, #12]
30020b24:	e59d300c 	ldr	r3, [sp, #12]
30020b28:	e3530000 	cmp	r3, #0
30020b2c:	1affffec 	bne	30020ae4 <udp_remove+0x48>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
30020b30:	e3a00001 	mov	r0, #1
30020b34:	e59d1004 	ldr	r1, [sp, #4]
30020b38:	ebffd311 	bl	30015784 <memp_free>
}
30020b3c:	e28dd014 	add	sp, sp, #20
30020b40:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30020b44:	e12fff1e 	bx	lr
30020b48:	3002a6ec 	.word	0x3002a6ec

30020b4c <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
30020b4c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30020b50:	e24dd00c 	sub	sp, sp, #12
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
30020b54:	e3a00001 	mov	r0, #1
30020b58:	ebffd2a4 	bl	300155f0 <memp_malloc>
30020b5c:	e1a03000 	mov	r3, r0
30020b60:	e58d3004 	str	r3, [sp, #4]
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
30020b64:	e59d3004 	ldr	r3, [sp, #4]
30020b68:	e3530000 	cmp	r3, #0
30020b6c:	0a000006 	beq	30020b8c <udp_new+0x40>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
30020b70:	e59d0004 	ldr	r0, [sp, #4]
30020b74:	e3a01000 	mov	r1, #0
30020b78:	e3a02020 	mov	r2, #32
30020b7c:	ebffb0d8 	bl	3000cee4 <__re_memset>
    pcb->ttl = UDP_TTL;
30020b80:	e59d3004 	ldr	r3, [sp, #4]
30020b84:	e3e02000 	mvn	r2, #0
30020b88:	e5c3200b 	strb	r2, [r3, #11]
  }
  return pcb;
30020b8c:	e59d3004 	ldr	r3, [sp, #4]
}
30020b90:	e1a00003 	mov	r0, r3
30020b94:	e28dd00c 	add	sp, sp, #12
30020b98:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30020b9c:	e12fff1e 	bx	lr

30020ba0 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
30020ba0:	e24dd010 	sub	sp, sp, #16
30020ba4:	e58d0004 	str	r0, [sp, #4]
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = (struct mem *)&ram[mem->next];
30020ba8:	e59f3174 	ldr	r3, [pc, #372]	; 30020d24 <plug_holes+0x184>
30020bac:	e5933000 	ldr	r3, [r3]
30020bb0:	e1a02003 	mov	r2, r3
30020bb4:	e59d3004 	ldr	r3, [sp, #4]
30020bb8:	e1d330b0 	ldrh	r3, [r3]
30020bbc:	e0823003 	add	r3, r2, r3
30020bc0:	e58d3008 	str	r3, [sp, #8]
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
30020bc4:	e59d2004 	ldr	r2, [sp, #4]
30020bc8:	e59d3008 	ldr	r3, [sp, #8]
30020bcc:	e1520003 	cmp	r2, r3
30020bd0:	0a000025 	beq	30020c6c <plug_holes+0xcc>
30020bd4:	e59d3008 	ldr	r3, [sp, #8]
30020bd8:	e5d33004 	ldrb	r3, [r3, #4]
30020bdc:	e3530000 	cmp	r3, #0
30020be0:	1a000021 	bne	30020c6c <plug_holes+0xcc>
30020be4:	e59d2008 	ldr	r2, [sp, #8]
30020be8:	e59f3138 	ldr	r3, [pc, #312]	; 30020d28 <plug_holes+0x188>
30020bec:	e5933000 	ldr	r3, [r3]
30020bf0:	e1520003 	cmp	r2, r3
30020bf4:	0a00001c 	beq	30020c6c <plug_holes+0xcc>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
30020bf8:	e59f312c 	ldr	r3, [pc, #300]	; 30020d2c <plug_holes+0x18c>
30020bfc:	e5932000 	ldr	r2, [r3]
30020c00:	e59d3008 	ldr	r3, [sp, #8]
30020c04:	e1520003 	cmp	r2, r3
30020c08:	1a000002 	bne	30020c18 <plug_holes+0x78>
      lfree = mem;
30020c0c:	e59f3118 	ldr	r3, [pc, #280]	; 30020d2c <plug_holes+0x18c>
30020c10:	e59d2004 	ldr	r2, [sp, #4]
30020c14:	e5832000 	str	r2, [r3]
    }
    mem->next = nmem->next;
30020c18:	e59d3008 	ldr	r3, [sp, #8]
30020c1c:	e1d320b0 	ldrh	r2, [r3]
30020c20:	e59d3004 	ldr	r3, [sp, #4]
30020c24:	e1c320b0 	strh	r2, [r3]
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
30020c28:	e59f30f4 	ldr	r3, [pc, #244]	; 30020d24 <plug_holes+0x184>
30020c2c:	e5933000 	ldr	r3, [r3]
30020c30:	e1a02003 	mov	r2, r3
30020c34:	e59d3008 	ldr	r3, [sp, #8]
30020c38:	e1d330b0 	ldrh	r3, [r3]
30020c3c:	e0823003 	add	r3, r2, r3
30020c40:	e59d2004 	ldr	r2, [sp, #4]
30020c44:	e1a02802 	lsl	r2, r2, #16
30020c48:	e1a01822 	lsr	r1, r2, #16
30020c4c:	e59f20d0 	ldr	r2, [pc, #208]	; 30020d24 <plug_holes+0x184>
30020c50:	e5922000 	ldr	r2, [r2]
30020c54:	e1a02802 	lsl	r2, r2, #16
30020c58:	e1a02822 	lsr	r2, r2, #16
30020c5c:	e0622001 	rsb	r2, r2, r1
30020c60:	e1a02802 	lsl	r2, r2, #16
30020c64:	e1a02822 	lsr	r2, r2, #16
30020c68:	e1c320b2 	strh	r2, [r3, #2]
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
30020c6c:	e59f30b0 	ldr	r3, [pc, #176]	; 30020d24 <plug_holes+0x184>
30020c70:	e5933000 	ldr	r3, [r3]
30020c74:	e1a02003 	mov	r2, r3
30020c78:	e59d3004 	ldr	r3, [sp, #4]
30020c7c:	e1d330b2 	ldrh	r3, [r3, #2]
30020c80:	e0823003 	add	r3, r2, r3
30020c84:	e58d300c 	str	r3, [sp, #12]
  if (pmem != mem && pmem->used == 0) {
30020c88:	e59d200c 	ldr	r2, [sp, #12]
30020c8c:	e59d3004 	ldr	r3, [sp, #4]
30020c90:	e1520003 	cmp	r2, r3
30020c94:	0a000020 	beq	30020d1c <plug_holes+0x17c>
30020c98:	e59d300c 	ldr	r3, [sp, #12]
30020c9c:	e5d33004 	ldrb	r3, [r3, #4]
30020ca0:	e3530000 	cmp	r3, #0
30020ca4:	1a00001c 	bne	30020d1c <plug_holes+0x17c>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
30020ca8:	e59f307c 	ldr	r3, [pc, #124]	; 30020d2c <plug_holes+0x18c>
30020cac:	e5932000 	ldr	r2, [r3]
30020cb0:	e59d3004 	ldr	r3, [sp, #4]
30020cb4:	e1520003 	cmp	r2, r3
30020cb8:	1a000002 	bne	30020cc8 <plug_holes+0x128>
      lfree = pmem;
30020cbc:	e59f3068 	ldr	r3, [pc, #104]	; 30020d2c <plug_holes+0x18c>
30020cc0:	e59d200c 	ldr	r2, [sp, #12]
30020cc4:	e5832000 	str	r2, [r3]
    }
    pmem->next = mem->next;
30020cc8:	e59d3004 	ldr	r3, [sp, #4]
30020ccc:	e1d320b0 	ldrh	r2, [r3]
30020cd0:	e59d300c 	ldr	r3, [sp, #12]
30020cd4:	e1c320b0 	strh	r2, [r3]
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
30020cd8:	e59f3044 	ldr	r3, [pc, #68]	; 30020d24 <plug_holes+0x184>
30020cdc:	e5933000 	ldr	r3, [r3]
30020ce0:	e1a02003 	mov	r2, r3
30020ce4:	e59d3004 	ldr	r3, [sp, #4]
30020ce8:	e1d330b0 	ldrh	r3, [r3]
30020cec:	e0823003 	add	r3, r2, r3
30020cf0:	e59d200c 	ldr	r2, [sp, #12]
30020cf4:	e1a02802 	lsl	r2, r2, #16
30020cf8:	e1a01822 	lsr	r1, r2, #16
30020cfc:	e59f2020 	ldr	r2, [pc, #32]	; 30020d24 <plug_holes+0x184>
30020d00:	e5922000 	ldr	r2, [r2]
30020d04:	e1a02802 	lsl	r2, r2, #16
30020d08:	e1a02822 	lsr	r2, r2, #16
30020d0c:	e0622001 	rsb	r2, r2, r1
30020d10:	e1a02802 	lsl	r2, r2, #16
30020d14:	e1a02822 	lsr	r2, r2, #16
30020d18:	e1c320b2 	strh	r2, [r3, #2]
  }
}
30020d1c:	e28dd010 	add	sp, sp, #16
30020d20:	e12fff1e 	bx	lr
30020d24:	30029fa0 	.word	0x30029fa0
30020d28:	30029fa4 	.word	0x30029fa4
30020d2c:	30029fa8 	.word	0x30029fa8

30020d30 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
30020d30:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30020d34:	e24dd00c 	sub	sp, sp, #12

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
30020d38:	e59f30c4 	ldr	r3, [pc, #196]	; 30020e04 <mem_init+0xd4>
30020d3c:	e2833003 	add	r3, r3, #3
30020d40:	e3c33003 	bic	r3, r3, #3
30020d44:	e1a02003 	mov	r2, r3
30020d48:	e59f30b8 	ldr	r3, [pc, #184]	; 30020e08 <mem_init+0xd8>
30020d4c:	e5832000 	str	r2, [r3]
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
30020d50:	e59f30b0 	ldr	r3, [pc, #176]	; 30020e08 <mem_init+0xd8>
30020d54:	e5933000 	ldr	r3, [r3]
30020d58:	e58d3004 	str	r3, [sp, #4]
  mem->next = MEM_SIZE_ALIGNED;
30020d5c:	e59d3004 	ldr	r3, [sp, #4]
30020d60:	e3a02a01 	mov	r2, #4096	; 0x1000
30020d64:	e1c320b0 	strh	r2, [r3]
  mem->prev = 0;
30020d68:	e59d3004 	ldr	r3, [sp, #4]
30020d6c:	e3a02000 	mov	r2, #0
30020d70:	e1c320b2 	strh	r2, [r3, #2]
  mem->used = 0;
30020d74:	e59d3004 	ldr	r3, [sp, #4]
30020d78:	e3a02000 	mov	r2, #0
30020d7c:	e5c32004 	strb	r2, [r3, #4]
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
30020d80:	e59f3080 	ldr	r3, [pc, #128]	; 30020e08 <mem_init+0xd8>
30020d84:	e5933000 	ldr	r3, [r3]
30020d88:	e2832a01 	add	r2, r3, #4096	; 0x1000
30020d8c:	e59f3078 	ldr	r3, [pc, #120]	; 30020e0c <mem_init+0xdc>
30020d90:	e5832000 	str	r2, [r3]
  ram_end->used = 1;
30020d94:	e59f3070 	ldr	r3, [pc, #112]	; 30020e0c <mem_init+0xdc>
30020d98:	e5933000 	ldr	r3, [r3]
30020d9c:	e3a02001 	mov	r2, #1
30020da0:	e5c32004 	strb	r2, [r3, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
30020da4:	e59f3060 	ldr	r3, [pc, #96]	; 30020e0c <mem_init+0xdc>
30020da8:	e5933000 	ldr	r3, [r3]
30020dac:	e3a02a01 	mov	r2, #4096	; 0x1000
30020db0:	e1c320b0 	strh	r2, [r3]
  ram_end->prev = MEM_SIZE_ALIGNED;
30020db4:	e59f3050 	ldr	r3, [pc, #80]	; 30020e0c <mem_init+0xdc>
30020db8:	e5933000 	ldr	r3, [r3]
30020dbc:	e3a02a01 	mov	r2, #4096	; 0x1000
30020dc0:	e1c320b2 	strh	r2, [r3, #2]

  mem_sem = sys_sem_new(1);
30020dc4:	e3a00001 	mov	r0, #1
30020dc8:	ebffaf3d 	bl	3000cac4 <sys_sem_new>
30020dcc:	e1a02000 	mov	r2, r0
30020dd0:	e59f3038 	ldr	r3, [pc, #56]	; 30020e10 <mem_init+0xe0>
30020dd4:	e5832000 	str	r2, [r3]

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
30020dd8:	e59f3028 	ldr	r3, [pc, #40]	; 30020e08 <mem_init+0xd8>
30020ddc:	e5933000 	ldr	r3, [r3]
30020de0:	e1a02003 	mov	r2, r3
30020de4:	e59f3028 	ldr	r3, [pc, #40]	; 30020e14 <mem_init+0xe4>
30020de8:	e5832000 	str	r2, [r3]

#if MEM_STATS
  lwip_stats.mem.avail = MEM_SIZE_ALIGNED;
30020dec:	e59f3024 	ldr	r3, [pc, #36]	; 30020e18 <mem_init+0xe8>
30020df0:	e3a02a01 	mov	r2, #4096	; 0x1000
30020df4:	e1c32bb6 	strh	r2, [r3, #182]	; 0xb6
#endif /* MEM_STATS */
}
30020df8:	e28dd00c 	add	sp, sp, #12
30020dfc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30020e00:	e12fff1e 	bx	lr
30020e04:	30028f8c 	.word	0x30028f8c
30020e08:	30029fa0 	.word	0x30029fa0
30020e0c:	30029fa4 	.word	0x30029fa4
30020e10:	30029fac 	.word	0x30029fac
30020e14:	30029fa8 	.word	0x30029fa8
30020e18:	3002b214 	.word	0x3002b214

30020e1c <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
30020e1c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30020e20:	e24dd014 	sub	sp, sp, #20
30020e24:	e58d0004 	str	r0, [sp, #4]
  struct mem *mem;

  if (rmem == NULL) {
30020e28:	e59d3004 	ldr	r3, [sp, #4]
30020e2c:	e3530000 	cmp	r3, #0
30020e30:	0a000045 	beq	30020f4c <mem_free+0x130>
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
30020e34:	e59f3120 	ldr	r3, [pc, #288]	; 30020f5c <mem_free+0x140>
30020e38:	e5933000 	ldr	r3, [r3]
30020e3c:	e1a00003 	mov	r0, r3
30020e40:	e3a01000 	mov	r1, #0
30020e44:	ebffaf3b 	bl	3000cb38 <sys_arch_sem_wait>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
30020e48:	e59d2004 	ldr	r2, [sp, #4]
30020e4c:	e59f310c 	ldr	r3, [pc, #268]	; 30020f60 <mem_free+0x144>
30020e50:	e5933000 	ldr	r3, [r3]
30020e54:	e1520003 	cmp	r2, r3
30020e58:	3a000004 	bcc	30020e70 <mem_free+0x54>
30020e5c:	e59d2004 	ldr	r2, [sp, #4]
30020e60:	e59f30fc 	ldr	r3, [pc, #252]	; 30020f64 <mem_free+0x148>
30020e64:	e5933000 	ldr	r3, [r3]
30020e68:	e1520003 	cmp	r2, r3
30020e6c:	3a00000b 	bcc	30020ea0 <mem_free+0x84>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_free: illegal memory\n"));
#if MEM_STATS
    ++lwip_stats.mem.err;
30020e70:	e59f30f0 	ldr	r3, [pc, #240]	; 30020f68 <mem_free+0x14c>
30020e74:	e1d33bbc 	ldrh	r3, [r3, #188]	; 0xbc
30020e78:	e2833001 	add	r3, r3, #1
30020e7c:	e1a03803 	lsl	r3, r3, #16
30020e80:	e1a02823 	lsr	r2, r3, #16
30020e84:	e59f30dc 	ldr	r3, [pc, #220]	; 30020f68 <mem_free+0x14c>
30020e88:	e1c32bbc 	strh	r2, [r3, #188]	; 0xbc
#endif /* MEM_STATS */
    sys_sem_signal(mem_sem);
30020e8c:	e59f30c8 	ldr	r3, [pc, #200]	; 30020f5c <mem_free+0x140>
30020e90:	e5933000 	ldr	r3, [r3]
30020e94:	e1a00003 	mov	r0, r3
30020e98:	ebffaf1e 	bl	3000cb18 <sys_sem_signal>
    return;
30020e9c:	ea00002b 	b	30020f50 <mem_free+0x134>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
30020ea0:	e59d3004 	ldr	r3, [sp, #4]
30020ea4:	e2433008 	sub	r3, r3, #8
30020ea8:	e58d300c 	str	r3, [sp, #12]
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
30020eac:	e59d300c 	ldr	r3, [sp, #12]
30020eb0:	e3a02000 	mov	r2, #0
30020eb4:	e5c32004 	strb	r2, [r3, #4]

  if (mem < lfree) {
30020eb8:	e59f30ac 	ldr	r3, [pc, #172]	; 30020f6c <mem_free+0x150>
30020ebc:	e5933000 	ldr	r3, [r3]
30020ec0:	e59d200c 	ldr	r2, [sp, #12]
30020ec4:	e1520003 	cmp	r2, r3
30020ec8:	2a000002 	bcs	30020ed8 <mem_free+0xbc>
    /* the newly freed struct is now the lowest */
    lfree = mem;
30020ecc:	e59f3098 	ldr	r3, [pc, #152]	; 30020f6c <mem_free+0x150>
30020ed0:	e59d200c 	ldr	r2, [sp, #12]
30020ed4:	e5832000 	str	r2, [r3]
  }

#if MEM_STATS
  lwip_stats.mem.used -= mem->next - ((u8_t *)mem - ram);
30020ed8:	e59f3088 	ldr	r3, [pc, #136]	; 30020f68 <mem_free+0x14c>
30020edc:	e1d32bb8 	ldrh	r2, [r3, #184]	; 0xb8
30020ee0:	e59d300c 	ldr	r3, [sp, #12]
30020ee4:	e1a03803 	lsl	r3, r3, #16
30020ee8:	e1a01823 	lsr	r1, r3, #16
30020eec:	e59f306c 	ldr	r3, [pc, #108]	; 30020f60 <mem_free+0x144>
30020ef0:	e5933000 	ldr	r3, [r3]
30020ef4:	e1a03803 	lsl	r3, r3, #16
30020ef8:	e1a03823 	lsr	r3, r3, #16
30020efc:	e0633001 	rsb	r3, r3, r1
30020f00:	e1a03803 	lsl	r3, r3, #16
30020f04:	e1a01823 	lsr	r1, r3, #16
30020f08:	e59d300c 	ldr	r3, [sp, #12]
30020f0c:	e1d330b0 	ldrh	r3, [r3]
30020f10:	e0633001 	rsb	r3, r3, r1
30020f14:	e1a03803 	lsl	r3, r3, #16
30020f18:	e1a03823 	lsr	r3, r3, #16
30020f1c:	e0823003 	add	r3, r2, r3
30020f20:	e1a03803 	lsl	r3, r3, #16
30020f24:	e1a02823 	lsr	r2, r3, #16
30020f28:	e59f3038 	ldr	r3, [pc, #56]	; 30020f68 <mem_free+0x14c>
30020f2c:	e1c32bb8 	strh	r2, [r3, #184]	; 0xb8
#endif /* MEM_STATS */

  /* finally, see if prev or next are free also */
  plug_holes(mem);
30020f30:	e59d000c 	ldr	r0, [sp, #12]
30020f34:	ebffff19 	bl	30020ba0 <plug_holes>
  sys_sem_signal(mem_sem);
30020f38:	e59f301c 	ldr	r3, [pc, #28]	; 30020f5c <mem_free+0x140>
30020f3c:	e5933000 	ldr	r3, [r3]
30020f40:	e1a00003 	mov	r0, r3
30020f44:	ebffaef3 	bl	3000cb18 <sys_sem_signal>
30020f48:	ea000000 	b	30020f50 <mem_free+0x134>
{
  struct mem *mem;

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
30020f4c:	e1a00000 	nop			; (mov r0, r0)
#endif /* MEM_STATS */

  /* finally, see if prev or next are free also */
  plug_holes(mem);
  sys_sem_signal(mem_sem);
}
30020f50:	e28dd014 	add	sp, sp, #20
30020f54:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30020f58:	e12fff1e 	bx	lr
30020f5c:	30029fac 	.word	0x30029fac
30020f60:	30029fa0 	.word	0x30029fa0
30020f64:	30029fa4 	.word	0x30029fa4
30020f68:	3002b214 	.word	0x3002b214
30020f6c:	30029fa8 	.word	0x30029fa8

30020f70 <mem_realloc>:
 *                equal to the previous size)
 * @return for compatibility reasons: is always == rmem, at the moment
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
30020f70:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30020f74:	e24dd024 	sub	sp, sp, #36	; 0x24
30020f78:	e58d0004 	str	r0, [sp, #4]
30020f7c:	e1a03001 	mov	r3, r1
30020f80:	e1cd30b2 	strh	r3, [sp, #2]
  mem_size_t ptr, ptr2;
  struct mem *mem, *mem2;

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
30020f84:	e1dd30b2 	ldrh	r3, [sp, #2]
30020f88:	e2833003 	add	r3, r3, #3
30020f8c:	e1a03803 	lsl	r3, r3, #16
30020f90:	e1a03823 	lsr	r3, r3, #16
30020f94:	e3c33003 	bic	r3, r3, #3
30020f98:	e1cd30b2 	strh	r3, [sp, #2]

  if(newsize < MIN_SIZE_ALIGNED) {
30020f9c:	e1dd30b2 	ldrh	r3, [sp, #2]
30020fa0:	e353000b 	cmp	r3, #11
30020fa4:	8a000001 	bhi	30020fb0 <mem_realloc+0x40>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
30020fa8:	e3a0300c 	mov	r3, #12
30020fac:	e1cd30b2 	strh	r3, [sp, #2]
  }

  if (newsize > MEM_SIZE_ALIGNED) {
30020fb0:	e1dd30b2 	ldrh	r3, [sp, #2]
30020fb4:	e3530a01 	cmp	r3, #4096	; 0x1000
30020fb8:	9a000001 	bls	30020fc4 <mem_realloc+0x54>
    return NULL;
30020fbc:	e3a03000 	mov	r3, #0
30020fc0:	ea0000b6 	b	300212a0 <mem_realloc+0x330>
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
30020fc4:	e59d2004 	ldr	r2, [sp, #4]
30020fc8:	e59f32e0 	ldr	r3, [pc, #736]	; 300212b0 <mem_realloc+0x340>
30020fcc:	e5933000 	ldr	r3, [r3]
30020fd0:	e1520003 	cmp	r2, r3
30020fd4:	3a000004 	bcc	30020fec <mem_realloc+0x7c>
30020fd8:	e59d2004 	ldr	r2, [sp, #4]
30020fdc:	e59f32d0 	ldr	r3, [pc, #720]	; 300212b4 <mem_realloc+0x344>
30020fe0:	e5933000 	ldr	r3, [r3]
30020fe4:	e1520003 	cmp	r2, r3
30020fe8:	3a000001 	bcc	30020ff4 <mem_realloc+0x84>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_realloc: illegal memory\n"));
    return rmem;
30020fec:	e59d3004 	ldr	r3, [sp, #4]
30020ff0:	ea0000aa 	b	300212a0 <mem_realloc+0x330>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
30020ff4:	e59d3004 	ldr	r3, [sp, #4]
30020ff8:	e2433008 	sub	r3, r3, #8
30020ffc:	e58d3014 	str	r3, [sp, #20]
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
30021000:	e59d3014 	ldr	r3, [sp, #20]
30021004:	e1a03803 	lsl	r3, r3, #16
30021008:	e1a02823 	lsr	r2, r3, #16
3002100c:	e59f329c 	ldr	r3, [pc, #668]	; 300212b0 <mem_realloc+0x340>
30021010:	e5933000 	ldr	r3, [r3]
30021014:	e1a03803 	lsl	r3, r3, #16
30021018:	e1a03823 	lsr	r3, r3, #16
3002101c:	e0633002 	rsb	r3, r3, r2
30021020:	e1cd31b0 	strh	r3, [sp, #16]

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
30021024:	e59d3014 	ldr	r3, [sp, #20]
30021028:	e1d320b0 	ldrh	r2, [r3]
3002102c:	e1dd31b0 	ldrh	r3, [sp, #16]
30021030:	e0633002 	rsb	r3, r3, r2
30021034:	e1a03803 	lsl	r3, r3, #16
30021038:	e1a03823 	lsr	r3, r3, #16
3002103c:	e2433008 	sub	r3, r3, #8
30021040:	e1cd30be 	strh	r3, [sp, #14]
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  if (newsize > size) {
30021044:	e1dd20b2 	ldrh	r2, [sp, #2]
30021048:	e1dd30be 	ldrh	r3, [sp, #14]
3002104c:	e1520003 	cmp	r2, r3
30021050:	9a000001 	bls	3002105c <mem_realloc+0xec>
    /* not supported */
    return NULL;
30021054:	e3a03000 	mov	r3, #0
30021058:	ea000090 	b	300212a0 <mem_realloc+0x330>
  }
  if (newsize == size) {
3002105c:	e1dd20b2 	ldrh	r2, [sp, #2]
30021060:	e1dd30be 	ldrh	r3, [sp, #14]
30021064:	e1520003 	cmp	r2, r3
30021068:	1a000001 	bne	30021074 <mem_realloc+0x104>
    /* No change in size, simply return */
    return rmem;
3002106c:	e59d3004 	ldr	r3, [sp, #4]
30021070:	ea00008a 	b	300212a0 <mem_realloc+0x330>
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
30021074:	e59f323c 	ldr	r3, [pc, #572]	; 300212b8 <mem_realloc+0x348>
30021078:	e5933000 	ldr	r3, [r3]
3002107c:	e1a00003 	mov	r0, r3
30021080:	e3a01000 	mov	r1, #0
30021084:	ebffaeab 	bl	3000cb38 <sys_arch_sem_wait>

#if MEM_STATS
  lwip_stats.mem.used -= (size - newsize);
30021088:	e59f322c 	ldr	r3, [pc, #556]	; 300212bc <mem_realloc+0x34c>
3002108c:	e1d32bb8 	ldrh	r2, [r3, #184]	; 0xb8
30021090:	e1dd10b2 	ldrh	r1, [sp, #2]
30021094:	e1dd30be 	ldrh	r3, [sp, #14]
30021098:	e0633001 	rsb	r3, r3, r1
3002109c:	e1a03803 	lsl	r3, r3, #16
300210a0:	e1a03823 	lsr	r3, r3, #16
300210a4:	e0823003 	add	r3, r2, r3
300210a8:	e1a03803 	lsl	r3, r3, #16
300210ac:	e1a02823 	lsr	r2, r3, #16
300210b0:	e59f3204 	ldr	r3, [pc, #516]	; 300212bc <mem_realloc+0x34c>
300210b4:	e1c32bb8 	strh	r2, [r3, #184]	; 0xb8
#endif /* MEM_STATS */

  mem2 = (struct mem *)&ram[mem->next];
300210b8:	e59f31f0 	ldr	r3, [pc, #496]	; 300212b0 <mem_realloc+0x340>
300210bc:	e5933000 	ldr	r3, [r3]
300210c0:	e1a02003 	mov	r2, r3
300210c4:	e59d3014 	ldr	r3, [sp, #20]
300210c8:	e1d330b0 	ldrh	r3, [r3]
300210cc:	e0823003 	add	r3, r2, r3
300210d0:	e58d3018 	str	r3, [sp, #24]
  if(mem2->used == 0) {
300210d4:	e59d3018 	ldr	r3, [sp, #24]
300210d8:	e5d33004 	ldrb	r3, [r3, #4]
300210dc:	e3530000 	cmp	r3, #0
300210e0:	1a000034 	bne	300211b8 <mem_realloc+0x248>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
300210e4:	e59d3018 	ldr	r3, [sp, #24]
300210e8:	e1d330b0 	ldrh	r3, [r3]
300210ec:	e1cd31be 	strh	r3, [sp, #30]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
300210f0:	e1dd21b0 	ldrh	r2, [sp, #16]
300210f4:	e1dd30b2 	ldrh	r3, [sp, #2]
300210f8:	e0823003 	add	r3, r2, r3
300210fc:	e1a03803 	lsl	r3, r3, #16
30021100:	e1a03823 	lsr	r3, r3, #16
30021104:	e2833008 	add	r3, r3, #8
30021108:	e1cd31b2 	strh	r3, [sp, #18]
    if (lfree == mem2) {
3002110c:	e59f31ac 	ldr	r3, [pc, #428]	; 300212c0 <mem_realloc+0x350>
30021110:	e5932000 	ldr	r2, [r3]
30021114:	e59d3018 	ldr	r3, [sp, #24]
30021118:	e1520003 	cmp	r2, r3
3002111c:	1a000006 	bne	3002113c <mem_realloc+0x1cc>
      lfree = (struct mem *)&ram[ptr2];
30021120:	e59f3188 	ldr	r3, [pc, #392]	; 300212b0 <mem_realloc+0x340>
30021124:	e5933000 	ldr	r3, [r3]
30021128:	e1a02003 	mov	r2, r3
3002112c:	e1dd31b2 	ldrh	r3, [sp, #18]
30021130:	e0822003 	add	r2, r2, r3
30021134:	e59f3184 	ldr	r3, [pc, #388]	; 300212c0 <mem_realloc+0x350>
30021138:	e5832000 	str	r2, [r3]
    }
    mem2 = (struct mem *)&ram[ptr2];
3002113c:	e59f316c 	ldr	r3, [pc, #364]	; 300212b0 <mem_realloc+0x340>
30021140:	e5933000 	ldr	r3, [r3]
30021144:	e1a02003 	mov	r2, r3
30021148:	e1dd31b2 	ldrh	r3, [sp, #18]
3002114c:	e0823003 	add	r3, r2, r3
30021150:	e58d3018 	str	r3, [sp, #24]
    mem2->used = 0;
30021154:	e59d3018 	ldr	r3, [sp, #24]
30021158:	e3a02000 	mov	r2, #0
3002115c:	e5c32004 	strb	r2, [r3, #4]
    /* restore the next pointer */
    mem2->next = next;
30021160:	e59d3018 	ldr	r3, [sp, #24]
30021164:	e1dd21be 	ldrh	r2, [sp, #30]
30021168:	e1c320b0 	strh	r2, [r3]
    /* link it back to mem */
    mem2->prev = ptr;
3002116c:	e59d3018 	ldr	r3, [sp, #24]
30021170:	e1dd21b0 	ldrh	r2, [sp, #16]
30021174:	e1c320b2 	strh	r2, [r3, #2]
    /* link mem to it */
    mem->next = ptr2;
30021178:	e59d3014 	ldr	r3, [sp, #20]
3002117c:	e1dd21b2 	ldrh	r2, [sp, #18]
30021180:	e1c320b0 	strh	r2, [r3]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
30021184:	e59d3018 	ldr	r3, [sp, #24]
30021188:	e1d330b0 	ldrh	r3, [r3]
3002118c:	e3530a01 	cmp	r3, #4096	; 0x1000
30021190:	0a00003c 	beq	30021288 <mem_realloc+0x318>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
30021194:	e59f3114 	ldr	r3, [pc, #276]	; 300212b0 <mem_realloc+0x340>
30021198:	e5933000 	ldr	r3, [r3]
3002119c:	e1a02003 	mov	r2, r3
300211a0:	e59d3018 	ldr	r3, [sp, #24]
300211a4:	e1d330b0 	ldrh	r3, [r3]
300211a8:	e0823003 	add	r3, r2, r3
300211ac:	e1dd21b2 	ldrh	r2, [sp, #18]
300211b0:	e1c320b2 	strh	r2, [r3, #2]
300211b4:	ea000034 	b	3002128c <mem_realloc+0x31c>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
300211b8:	e1dd30b2 	ldrh	r3, [sp, #2]
300211bc:	e2832014 	add	r2, r3, #20
300211c0:	e1dd30be 	ldrh	r3, [sp, #14]
300211c4:	e1520003 	cmp	r2, r3
300211c8:	8a00002f 	bhi	3002128c <mem_realloc+0x31c>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
300211cc:	e1dd21b0 	ldrh	r2, [sp, #16]
300211d0:	e1dd30b2 	ldrh	r3, [sp, #2]
300211d4:	e0823003 	add	r3, r2, r3
300211d8:	e1a03803 	lsl	r3, r3, #16
300211dc:	e1a03823 	lsr	r3, r3, #16
300211e0:	e2833008 	add	r3, r3, #8
300211e4:	e1cd31b2 	strh	r3, [sp, #18]
    mem2 = (struct mem *)&ram[ptr2];
300211e8:	e59f30c0 	ldr	r3, [pc, #192]	; 300212b0 <mem_realloc+0x340>
300211ec:	e5933000 	ldr	r3, [r3]
300211f0:	e1a02003 	mov	r2, r3
300211f4:	e1dd31b2 	ldrh	r3, [sp, #18]
300211f8:	e0823003 	add	r3, r2, r3
300211fc:	e58d3018 	str	r3, [sp, #24]
    if (mem2 < lfree) {
30021200:	e59f30b8 	ldr	r3, [pc, #184]	; 300212c0 <mem_realloc+0x350>
30021204:	e5933000 	ldr	r3, [r3]
30021208:	e59d2018 	ldr	r2, [sp, #24]
3002120c:	e1520003 	cmp	r2, r3
30021210:	2a000002 	bcs	30021220 <mem_realloc+0x2b0>
      lfree = mem2;
30021214:	e59f30a4 	ldr	r3, [pc, #164]	; 300212c0 <mem_realloc+0x350>
30021218:	e59d2018 	ldr	r2, [sp, #24]
3002121c:	e5832000 	str	r2, [r3]
    }
    mem2->used = 0;
30021220:	e59d3018 	ldr	r3, [sp, #24]
30021224:	e3a02000 	mov	r2, #0
30021228:	e5c32004 	strb	r2, [r3, #4]
    mem2->next = mem->next;
3002122c:	e59d3014 	ldr	r3, [sp, #20]
30021230:	e1d320b0 	ldrh	r2, [r3]
30021234:	e59d3018 	ldr	r3, [sp, #24]
30021238:	e1c320b0 	strh	r2, [r3]
    mem2->prev = ptr;
3002123c:	e59d3018 	ldr	r3, [sp, #24]
30021240:	e1dd21b0 	ldrh	r2, [sp, #16]
30021244:	e1c320b2 	strh	r2, [r3, #2]
    mem->next = ptr2;
30021248:	e59d3014 	ldr	r3, [sp, #20]
3002124c:	e1dd21b2 	ldrh	r2, [sp, #18]
30021250:	e1c320b0 	strh	r2, [r3]
    if (mem2->next != MEM_SIZE_ALIGNED) {
30021254:	e59d3018 	ldr	r3, [sp, #24]
30021258:	e1d330b0 	ldrh	r3, [r3]
3002125c:	e3530a01 	cmp	r3, #4096	; 0x1000
30021260:	0a000009 	beq	3002128c <mem_realloc+0x31c>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
30021264:	e59f3044 	ldr	r3, [pc, #68]	; 300212b0 <mem_realloc+0x340>
30021268:	e5933000 	ldr	r3, [r3]
3002126c:	e1a02003 	mov	r2, r3
30021270:	e59d3018 	ldr	r3, [sp, #24]
30021274:	e1d330b0 	ldrh	r3, [r3]
30021278:	e0823003 	add	r3, r2, r3
3002127c:	e1dd21b2 	ldrh	r2, [sp, #18]
30021280:	e1c320b2 	strh	r2, [r3, #2]
30021284:	ea000000 	b	3002128c <mem_realloc+0x31c>
    mem->next = ptr2;
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
30021288:	e1a00000 	nop			; (mov r0, r0)
    next struct mem is used but size between mem and mem2 is not big enough
    to create another struct mem
    -> don't do anyhting. 
    -> the remaining space stays unused since it is too small
  } */
  sys_sem_signal(mem_sem);
3002128c:	e59f3024 	ldr	r3, [pc, #36]	; 300212b8 <mem_realloc+0x348>
30021290:	e5933000 	ldr	r3, [r3]
30021294:	e1a00003 	mov	r0, r3
30021298:	ebffae1e 	bl	3000cb18 <sys_sem_signal>
  return rmem;
3002129c:	e59d3004 	ldr	r3, [sp, #4]
}
300212a0:	e1a00003 	mov	r0, r3
300212a4:	e28dd024 	add	sp, sp, #36	; 0x24
300212a8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300212ac:	e12fff1e 	bx	lr
300212b0:	30029fa0 	.word	0x30029fa0
300212b4:	30029fa4 	.word	0x30029fa4
300212b8:	30029fac 	.word	0x30029fac
300212bc:	3002b214 	.word	0x3002b214
300212c0:	30029fa8 	.word	0x30029fa8

300212c4 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
300212c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300212c8:	e24dd01c 	sub	sp, sp, #28
300212cc:	e1a03000 	mov	r3, r0
300212d0:	e1cd30b6 	strh	r3, [sp, #6]
  mem_size_t ptr, ptr2;
  struct mem *mem, *mem2;

  if (size == 0) {
300212d4:	e1dd30b6 	ldrh	r3, [sp, #6]
300212d8:	e3530000 	cmp	r3, #0
300212dc:	1a000001 	bne	300212e8 <mem_malloc+0x24>
    return NULL;
300212e0:	e3a03000 	mov	r3, #0
300212e4:	ea0000d9 	b	30021650 <mem_malloc+0x38c>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
300212e8:	e1dd30b6 	ldrh	r3, [sp, #6]
300212ec:	e2833003 	add	r3, r3, #3
300212f0:	e1a03803 	lsl	r3, r3, #16
300212f4:	e1a03823 	lsr	r3, r3, #16
300212f8:	e3c33003 	bic	r3, r3, #3
300212fc:	e1cd30b6 	strh	r3, [sp, #6]

  if(size < MIN_SIZE_ALIGNED) {
30021300:	e1dd30b6 	ldrh	r3, [sp, #6]
30021304:	e353000b 	cmp	r3, #11
30021308:	8a000001 	bhi	30021314 <mem_malloc+0x50>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
3002130c:	e3a0300c 	mov	r3, #12
30021310:	e1cd30b6 	strh	r3, [sp, #6]
  }

  if (size > MEM_SIZE_ALIGNED) {
30021314:	e1dd30b6 	ldrh	r3, [sp, #6]
30021318:	e3530a01 	cmp	r3, #4096	; 0x1000
3002131c:	9a000001 	bls	30021328 <mem_malloc+0x64>
    return NULL;
30021320:	e3a03000 	mov	r3, #0
30021324:	ea0000c9 	b	30021650 <mem_malloc+0x38c>
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
30021328:	e59f3330 	ldr	r3, [pc, #816]	; 30021660 <mem_malloc+0x39c>
3002132c:	e5933000 	ldr	r3, [r3]
30021330:	e1a00003 	mov	r0, r3
30021334:	e3a01000 	mov	r1, #0
30021338:	ebffadfe 	bl	3000cb38 <sys_arch_sem_wait>

  /* Scan through the heap searching for a free block that is big enough,
   * beginning with the lowest free block.
   */
  for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
3002133c:	e59f3320 	ldr	r3, [pc, #800]	; 30021664 <mem_malloc+0x3a0>
30021340:	e5933000 	ldr	r3, [r3]
30021344:	e1a03803 	lsl	r3, r3, #16
30021348:	e1a02823 	lsr	r2, r3, #16
3002134c:	e59f3314 	ldr	r3, [pc, #788]	; 30021668 <mem_malloc+0x3a4>
30021350:	e5933000 	ldr	r3, [r3]
30021354:	e1a03803 	lsl	r3, r3, #16
30021358:	e1a03823 	lsr	r3, r3, #16
3002135c:	e0633002 	rsb	r3, r3, r2
30021360:	e1cd30bc 	strh	r3, [sp, #12]
30021364:	ea0000a8 	b	3002160c <mem_malloc+0x348>
       ptr = ((struct mem *)&ram[ptr])->next) {
    mem = (struct mem *)&ram[ptr];
30021368:	e59f32f8 	ldr	r3, [pc, #760]	; 30021668 <mem_malloc+0x3a4>
3002136c:	e5933000 	ldr	r3, [r3]
30021370:	e1a02003 	mov	r2, r3
30021374:	e1dd30bc 	ldrh	r3, [sp, #12]
30021378:	e0823003 	add	r3, r2, r3
3002137c:	e58d3010 	str	r3, [sp, #16]

    if ((!mem->used) &&
30021380:	e59d3010 	ldr	r3, [sp, #16]
30021384:	e5d33004 	ldrb	r3, [r3, #4]
30021388:	e3530000 	cmp	r3, #0
3002138c:	1a000097 	bne	300215f0 <mem_malloc+0x32c>
        (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
30021390:	e59d3010 	ldr	r3, [sp, #16]
30021394:	e1d330b0 	ldrh	r3, [r3]
30021398:	e1a02003 	mov	r2, r3
3002139c:	e1dd30bc 	ldrh	r3, [sp, #12]
300213a0:	e0633002 	rsb	r3, r3, r2
300213a4:	e2432008 	sub	r2, r3, #8
300213a8:	e1dd30b6 	ldrh	r3, [sp, #6]
   */
  for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
       ptr = ((struct mem *)&ram[ptr])->next) {
    mem = (struct mem *)&ram[ptr];

    if ((!mem->used) &&
300213ac:	e1520003 	cmp	r2, r3
300213b0:	3a00008e 	bcc	300215f0 <mem_malloc+0x32c>
        (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
      /* mem is not used and at least perfect fit is possible:
       * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

      if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
300213b4:	e59d3010 	ldr	r3, [sp, #16]
300213b8:	e1d330b0 	ldrh	r3, [r3]
300213bc:	e1a02003 	mov	r2, r3
300213c0:	e1dd30bc 	ldrh	r3, [sp, #12]
300213c4:	e0633002 	rsb	r3, r3, r2
300213c8:	e2432008 	sub	r2, r3, #8
300213cc:	e1dd30b6 	ldrh	r3, [sp, #6]
300213d0:	e2833014 	add	r3, r3, #20
300213d4:	e1520003 	cmp	r2, r3
300213d8:	3a00003e 	bcc	300214d8 <mem_malloc+0x214>
         * struct mem would fit in but no data between mem2 and mem2->next
         * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
         *       region that couldn't hold data, but when mem->next gets freed,
         *       the 2 regions would be combined, resulting in more free memory
         */
        ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
300213dc:	e1dd20bc 	ldrh	r2, [sp, #12]
300213e0:	e1dd30b6 	ldrh	r3, [sp, #6]
300213e4:	e0823003 	add	r3, r2, r3
300213e8:	e1a03803 	lsl	r3, r3, #16
300213ec:	e1a03823 	lsr	r3, r3, #16
300213f0:	e2833008 	add	r3, r3, #8
300213f4:	e1cd30be 	strh	r3, [sp, #14]
        /* create mem2 struct */
        mem2 = (struct mem *)&ram[ptr2];
300213f8:	e59f3268 	ldr	r3, [pc, #616]	; 30021668 <mem_malloc+0x3a4>
300213fc:	e5933000 	ldr	r3, [r3]
30021400:	e1a02003 	mov	r2, r3
30021404:	e1dd30be 	ldrh	r3, [sp, #14]
30021408:	e0823003 	add	r3, r2, r3
3002140c:	e58d3014 	str	r3, [sp, #20]
        mem2->used = 0;
30021410:	e59d3014 	ldr	r3, [sp, #20]
30021414:	e3a02000 	mov	r2, #0
30021418:	e5c32004 	strb	r2, [r3, #4]
        mem2->next = mem->next;
3002141c:	e59d3010 	ldr	r3, [sp, #16]
30021420:	e1d320b0 	ldrh	r2, [r3]
30021424:	e59d3014 	ldr	r3, [sp, #20]
30021428:	e1c320b0 	strh	r2, [r3]
        mem2->prev = ptr;
3002142c:	e59d3014 	ldr	r3, [sp, #20]
30021430:	e1dd20bc 	ldrh	r2, [sp, #12]
30021434:	e1c320b2 	strh	r2, [r3, #2]
        /* and insert it between mem and mem->next */
        mem->next = ptr2;
30021438:	e59d3010 	ldr	r3, [sp, #16]
3002143c:	e1dd20be 	ldrh	r2, [sp, #14]
30021440:	e1c320b0 	strh	r2, [r3]
        mem->used = 1;
30021444:	e59d3010 	ldr	r3, [sp, #16]
30021448:	e3a02001 	mov	r2, #1
3002144c:	e5c32004 	strb	r2, [r3, #4]

        if (mem2->next != MEM_SIZE_ALIGNED) {
30021450:	e59d3014 	ldr	r3, [sp, #20]
30021454:	e1d330b0 	ldrh	r3, [r3]
30021458:	e3530a01 	cmp	r3, #4096	; 0x1000
3002145c:	0a000007 	beq	30021480 <mem_malloc+0x1bc>
          ((struct mem *)&ram[mem2->next])->prev = ptr2;
30021460:	e59f3200 	ldr	r3, [pc, #512]	; 30021668 <mem_malloc+0x3a4>
30021464:	e5933000 	ldr	r3, [r3]
30021468:	e1a02003 	mov	r2, r3
3002146c:	e59d3014 	ldr	r3, [sp, #20]
30021470:	e1d330b0 	ldrh	r3, [r3]
30021474:	e0823003 	add	r3, r2, r3
30021478:	e1dd20be 	ldrh	r2, [sp, #14]
3002147c:	e1c320b2 	strh	r2, [r3, #2]
        }
#if MEM_STATS
        lwip_stats.mem.used += (size + SIZEOF_STRUCT_MEM);
30021480:	e59f31e4 	ldr	r3, [pc, #484]	; 3002166c <mem_malloc+0x3a8>
30021484:	e1d32bb8 	ldrh	r2, [r3, #184]	; 0xb8
30021488:	e1dd30b6 	ldrh	r3, [sp, #6]
3002148c:	e0823003 	add	r3, r2, r3
30021490:	e1a03803 	lsl	r3, r3, #16
30021494:	e1a03823 	lsr	r3, r3, #16
30021498:	e2833008 	add	r3, r3, #8
3002149c:	e1a03803 	lsl	r3, r3, #16
300214a0:	e1a02823 	lsr	r2, r3, #16
300214a4:	e59f31c0 	ldr	r3, [pc, #448]	; 3002166c <mem_malloc+0x3a8>
300214a8:	e1c32bb8 	strh	r2, [r3, #184]	; 0xb8
        if (lwip_stats.mem.max < lwip_stats.mem.used) {
300214ac:	e59f31b8 	ldr	r3, [pc, #440]	; 3002166c <mem_malloc+0x3a8>
300214b0:	e1d32bba 	ldrh	r2, [r3, #186]	; 0xba
300214b4:	e59f31b0 	ldr	r3, [pc, #432]	; 3002166c <mem_malloc+0x3a8>
300214b8:	e1d33bb8 	ldrh	r3, [r3, #184]	; 0xb8
300214bc:	e1520003 	cmp	r2, r3
300214c0:	2a000028 	bcs	30021568 <mem_malloc+0x2a4>
          lwip_stats.mem.max = lwip_stats.mem.used;
300214c4:	e59f31a0 	ldr	r3, [pc, #416]	; 3002166c <mem_malloc+0x3a8>
300214c8:	e1d32bb8 	ldrh	r2, [r3, #184]	; 0xb8
300214cc:	e59f3198 	ldr	r3, [pc, #408]	; 3002166c <mem_malloc+0x3a8>
300214d0:	e1c32bba 	strh	r2, [r3, #186]	; 0xba
300214d4:	ea000024 	b	3002156c <mem_malloc+0x2a8>
         * take care of this).
         * -> near fit or excact fit: do not split, no mem2 creation
         * also can't move mem->next directly behind mem, since mem->next
         * will always be used at this point!
         */
        mem->used = 1;
300214d8:	e59d3010 	ldr	r3, [sp, #16]
300214dc:	e3a02001 	mov	r2, #1
300214e0:	e5c32004 	strb	r2, [r3, #4]
#if MEM_STATS
        lwip_stats.mem.used += mem->next - ((u8_t *)mem - ram);
300214e4:	e59f3180 	ldr	r3, [pc, #384]	; 3002166c <mem_malloc+0x3a8>
300214e8:	e1d32bb8 	ldrh	r2, [r3, #184]	; 0xb8
300214ec:	e59d3010 	ldr	r3, [sp, #16]
300214f0:	e1d310b0 	ldrh	r1, [r3]
300214f4:	e59f316c 	ldr	r3, [pc, #364]	; 30021668 <mem_malloc+0x3a4>
300214f8:	e5933000 	ldr	r3, [r3]
300214fc:	e1a03803 	lsl	r3, r3, #16
30021500:	e1a00823 	lsr	r0, r3, #16
30021504:	e59d3010 	ldr	r3, [sp, #16]
30021508:	e1a03803 	lsl	r3, r3, #16
3002150c:	e1a03823 	lsr	r3, r3, #16
30021510:	e0633000 	rsb	r3, r3, r0
30021514:	e1a03803 	lsl	r3, r3, #16
30021518:	e1a03823 	lsr	r3, r3, #16
3002151c:	e0813003 	add	r3, r1, r3
30021520:	e1a03803 	lsl	r3, r3, #16
30021524:	e1a03823 	lsr	r3, r3, #16
30021528:	e0823003 	add	r3, r2, r3
3002152c:	e1a03803 	lsl	r3, r3, #16
30021530:	e1a02823 	lsr	r2, r3, #16
30021534:	e59f3130 	ldr	r3, [pc, #304]	; 3002166c <mem_malloc+0x3a8>
30021538:	e1c32bb8 	strh	r2, [r3, #184]	; 0xb8
        if (lwip_stats.mem.max < lwip_stats.mem.used) {
3002153c:	e59f3128 	ldr	r3, [pc, #296]	; 3002166c <mem_malloc+0x3a8>
30021540:	e1d32bba 	ldrh	r2, [r3, #186]	; 0xba
30021544:	e59f3120 	ldr	r3, [pc, #288]	; 3002166c <mem_malloc+0x3a8>
30021548:	e1d33bb8 	ldrh	r3, [r3, #184]	; 0xb8
3002154c:	e1520003 	cmp	r2, r3
30021550:	2a000005 	bcs	3002156c <mem_malloc+0x2a8>
          lwip_stats.mem.max = lwip_stats.mem.used;
30021554:	e59f3110 	ldr	r3, [pc, #272]	; 3002166c <mem_malloc+0x3a8>
30021558:	e1d32bb8 	ldrh	r2, [r3, #184]	; 0xb8
3002155c:	e59f3108 	ldr	r3, [pc, #264]	; 3002166c <mem_malloc+0x3a8>
30021560:	e1c32bba 	strh	r2, [r3, #186]	; 0xba
30021564:	ea000000 	b	3002156c <mem_malloc+0x2a8>
          ((struct mem *)&ram[mem2->next])->prev = ptr2;
        }
#if MEM_STATS
        lwip_stats.mem.used += (size + SIZEOF_STRUCT_MEM);
        if (lwip_stats.mem.max < lwip_stats.mem.used) {
          lwip_stats.mem.max = lwip_stats.mem.used;
30021568:	e1a00000 	nop			; (mov r0, r0)
          lwip_stats.mem.max = lwip_stats.mem.used;
        }
#endif /* MEM_STATS */
      }

      if (mem == lfree) {
3002156c:	e59f30f0 	ldr	r3, [pc, #240]	; 30021664 <mem_malloc+0x3a0>
30021570:	e5933000 	ldr	r3, [r3]
30021574:	e59d2010 	ldr	r2, [sp, #16]
30021578:	e1520003 	cmp	r2, r3
3002157c:	1a000014 	bne	300215d4 <mem_malloc+0x310>
        /* Find next free block after mem and update lowest free pointer */
        while (lfree->used && lfree != ram_end) {
30021580:	ea000008 	b	300215a8 <mem_malloc+0x2e4>
          lfree = (struct mem *)&ram[lfree->next];
30021584:	e59f30dc 	ldr	r3, [pc, #220]	; 30021668 <mem_malloc+0x3a4>
30021588:	e5933000 	ldr	r3, [r3]
3002158c:	e1a02003 	mov	r2, r3
30021590:	e59f30cc 	ldr	r3, [pc, #204]	; 30021664 <mem_malloc+0x3a0>
30021594:	e5933000 	ldr	r3, [r3]
30021598:	e1d330b0 	ldrh	r3, [r3]
3002159c:	e0822003 	add	r2, r2, r3
300215a0:	e59f30bc 	ldr	r3, [pc, #188]	; 30021664 <mem_malloc+0x3a0>
300215a4:	e5832000 	str	r2, [r3]
#endif /* MEM_STATS */
      }

      if (mem == lfree) {
        /* Find next free block after mem and update lowest free pointer */
        while (lfree->used && lfree != ram_end) {
300215a8:	e59f30b4 	ldr	r3, [pc, #180]	; 30021664 <mem_malloc+0x3a0>
300215ac:	e5933000 	ldr	r3, [r3]
300215b0:	e5d33004 	ldrb	r3, [r3, #4]
300215b4:	e3530000 	cmp	r3, #0
300215b8:	0a000005 	beq	300215d4 <mem_malloc+0x310>
300215bc:	e59f30a0 	ldr	r3, [pc, #160]	; 30021664 <mem_malloc+0x3a0>
300215c0:	e5932000 	ldr	r2, [r3]
300215c4:	e59f30a4 	ldr	r3, [pc, #164]	; 30021670 <mem_malloc+0x3ac>
300215c8:	e5933000 	ldr	r3, [r3]
300215cc:	e1520003 	cmp	r2, r3
300215d0:	1affffeb 	bne	30021584 <mem_malloc+0x2c0>
          lfree = (struct mem *)&ram[lfree->next];
        }
        LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
      }
      sys_sem_signal(mem_sem);
300215d4:	e59f3084 	ldr	r3, [pc, #132]	; 30021660 <mem_malloc+0x39c>
300215d8:	e5933000 	ldr	r3, [r3]
300215dc:	e1a00003 	mov	r0, r3
300215e0:	ebffad4c 	bl	3000cb18 <sys_sem_signal>
      LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
       (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
      LWIP_ASSERT("mem_malloc: sanity check alignment",
        (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

      return (u8_t *)mem + SIZEOF_STRUCT_MEM;
300215e4:	e59d3010 	ldr	r3, [sp, #16]
300215e8:	e2833008 	add	r3, r3, #8
300215ec:	ea000017 	b	30021650 <mem_malloc+0x38c>

  /* Scan through the heap searching for a free block that is big enough,
   * beginning with the lowest free block.
   */
  for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
       ptr = ((struct mem *)&ram[ptr])->next) {
300215f0:	e59f3070 	ldr	r3, [pc, #112]	; 30021668 <mem_malloc+0x3a4>
300215f4:	e5933000 	ldr	r3, [r3]
300215f8:	e1a02003 	mov	r2, r3
300215fc:	e1dd30bc 	ldrh	r3, [sp, #12]
30021600:	e0823003 	add	r3, r2, r3
30021604:	e1d330b0 	ldrh	r3, [r3]
30021608:	e1cd30bc 	strh	r3, [sp, #12]
  sys_arch_sem_wait(mem_sem, 0);

  /* Scan through the heap searching for a free block that is big enough,
   * beginning with the lowest free block.
   */
  for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
3002160c:	e1dd20bc 	ldrh	r2, [sp, #12]
30021610:	e1dd30b6 	ldrh	r3, [sp, #6]
30021614:	e2633a01 	rsb	r3, r3, #4096	; 0x1000
30021618:	e1520003 	cmp	r2, r3
3002161c:	baffff51 	blt	30021368 <mem_malloc+0xa4>
      return (u8_t *)mem + SIZEOF_STRUCT_MEM;
    }
  }
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
#if MEM_STATS
  ++lwip_stats.mem.err;
30021620:	e59f3044 	ldr	r3, [pc, #68]	; 3002166c <mem_malloc+0x3a8>
30021624:	e1d33bbc 	ldrh	r3, [r3, #188]	; 0xbc
30021628:	e2833001 	add	r3, r3, #1
3002162c:	e1a03803 	lsl	r3, r3, #16
30021630:	e1a02823 	lsr	r2, r3, #16
30021634:	e59f3030 	ldr	r3, [pc, #48]	; 3002166c <mem_malloc+0x3a8>
30021638:	e1c32bbc 	strh	r2, [r3, #188]	; 0xbc
#endif /* MEM_STATS */
  sys_sem_signal(mem_sem);
3002163c:	e59f301c 	ldr	r3, [pc, #28]	; 30021660 <mem_malloc+0x39c>
30021640:	e5933000 	ldr	r3, [r3]
30021644:	e1a00003 	mov	r0, r3
30021648:	ebffad32 	bl	3000cb18 <sys_sem_signal>
  return NULL;
3002164c:	e3a03000 	mov	r3, #0
}
30021650:	e1a00003 	mov	r0, r3
30021654:	e28dd01c 	add	sp, sp, #28
30021658:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002165c:	e12fff1e 	bx	lr
30021660:	30029fac 	.word	0x30029fac
30021664:	30029fa8 	.word	0x30029fa8
30021668:	30029fa0 	.word	0x30029fa0
3002166c:	3002b214 	.word	0x3002b214
30021670:	30029fa4 	.word	0x30029fa4

30021674 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
30021674:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30021678:	e24dd014 	sub	sp, sp, #20
3002167c:	e1a02000 	mov	r2, r0
30021680:	e1a03001 	mov	r3, r1
30021684:	e1cd20b6 	strh	r2, [sp, #6]
30021688:	e1cd30b4 	strh	r3, [sp, #4]
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
3002168c:	e1dd30b6 	ldrh	r3, [sp, #6]
30021690:	e1dd20b4 	ldrh	r2, [sp, #4]
30021694:	e0030392 	mul	r3, r2, r3
30021698:	e1a03803 	lsl	r3, r3, #16
3002169c:	e1a03823 	lsr	r3, r3, #16
300216a0:	e1a00003 	mov	r0, r3
300216a4:	ebffff06 	bl	300212c4 <mem_malloc>
300216a8:	e1a03000 	mov	r3, r0
300216ac:	e58d300c 	str	r3, [sp, #12]
  if (p) {
300216b0:	e59d300c 	ldr	r3, [sp, #12]
300216b4:	e3530000 	cmp	r3, #0
300216b8:	0a000006 	beq	300216d8 <mem_calloc+0x64>
    /* zero the memory */
    memset(p, 0, count * size);
300216bc:	e1dd30b6 	ldrh	r3, [sp, #6]
300216c0:	e1dd20b4 	ldrh	r2, [sp, #4]
300216c4:	e0030392 	mul	r3, r2, r3
300216c8:	e59d000c 	ldr	r0, [sp, #12]
300216cc:	e3a01000 	mov	r1, #0
300216d0:	e1a02003 	mov	r2, r3
300216d4:	ebffae02 	bl	3000cee4 <__re_memset>
  }
  return p;
300216d8:	e59d300c 	ldr	r3, [sp, #12]
}
300216dc:	e1a00003 	mov	r0, r3
300216e0:	e28dd014 	add	sp, sp, #20
300216e4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300216e8:	e12fff1e 	bx	lr

300216ec <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
300216ec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300216f0:	e24dd014 	sub	sp, sp, #20
300216f4:	e58d0004 	str	r0, [sp, #4]
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
300216f8:	ea00000b 	b	3002172c <free_etharp_q+0x40>
    r = q;
300216fc:	e59d3004 	ldr	r3, [sp, #4]
30021700:	e58d300c 	str	r3, [sp, #12]
    q = q->next;
30021704:	e59d3004 	ldr	r3, [sp, #4]
30021708:	e5933000 	ldr	r3, [r3]
3002170c:	e58d3004 	str	r3, [sp, #4]
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
30021710:	e59d300c 	ldr	r3, [sp, #12]
30021714:	e5933004 	ldr	r3, [r3, #4]
30021718:	e1a00003 	mov	r0, r3
3002171c:	ebffd383 	bl	30016530 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
30021720:	e3a00009 	mov	r0, #9
30021724:	e59d100c 	ldr	r1, [sp, #12]
30021728:	ebffd015 	bl	30015784 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
3002172c:	e59d3004 	ldr	r3, [sp, #4]
30021730:	e3530000 	cmp	r3, #0
30021734:	1afffff0 	bne	300216fc <free_etharp_q+0x10>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
30021738:	e28dd014 	add	sp, sp, #20
3002173c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30021740:	e12fff1e 	bx	lr

30021744 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
30021744:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30021748:	e24dd00c 	sub	sp, sp, #12
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
3002174c:	e3a03000 	mov	r3, #0
30021750:	e5cd3007 	strb	r3, [sp, #7]
30021754:	ea000070 	b	3002191c <etharp_tmr+0x1d8>
    arp_table[i].ctime++;
30021758:	e5dd2007 	ldrb	r2, [sp, #7]
3002175c:	e59f01d0 	ldr	r0, [pc, #464]	; 30021934 <etharp_tmr+0x1f0>
30021760:	e3a01008 	mov	r1, #8
30021764:	e1a03002 	mov	r3, r2
30021768:	e1a03103 	lsl	r3, r3, #2
3002176c:	e0833002 	add	r3, r3, r2
30021770:	e1a03103 	lsl	r3, r3, #2
30021774:	e0833000 	add	r3, r3, r0
30021778:	e0833001 	add	r3, r3, r1
3002177c:	e5d33007 	ldrb	r3, [r3, #7]
30021780:	e2833001 	add	r3, r3, #1
30021784:	e20310ff 	and	r1, r3, #255	; 0xff
30021788:	e59fc1a4 	ldr	ip, [pc, #420]	; 30021934 <etharp_tmr+0x1f0>
3002178c:	e3a00008 	mov	r0, #8
30021790:	e1a03002 	mov	r3, r2
30021794:	e1a03103 	lsl	r3, r3, #2
30021798:	e0833002 	add	r3, r3, r2
3002179c:	e1a03103 	lsl	r3, r3, #2
300217a0:	e083300c 	add	r3, r3, ip
300217a4:	e0833000 	add	r3, r3, r0
300217a8:	e1a02001 	mov	r2, r1
300217ac:	e5c32007 	strb	r2, [r3, #7]
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
300217b0:	e5dd2007 	ldrb	r2, [sp, #7]
300217b4:	e59f0178 	ldr	r0, [pc, #376]	; 30021934 <etharp_tmr+0x1f0>
300217b8:	e3a01008 	mov	r1, #8
300217bc:	e1a03002 	mov	r3, r2
300217c0:	e1a03103 	lsl	r3, r3, #2
300217c4:	e0833002 	add	r3, r3, r2
300217c8:	e1a03103 	lsl	r3, r3, #2
300217cc:	e0833000 	add	r3, r3, r0
300217d0:	e0833001 	add	r3, r3, r1
300217d4:	e5d33006 	ldrb	r3, [r3, #6]
300217d8:	e3530002 	cmp	r3, #2
300217dc:	1a00000b 	bne	30021810 <etharp_tmr+0xcc>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
300217e0:	e5dd2007 	ldrb	r2, [sp, #7]
300217e4:	e59f0148 	ldr	r0, [pc, #328]	; 30021934 <etharp_tmr+0x1f0>
300217e8:	e3a01008 	mov	r1, #8
300217ec:	e1a03002 	mov	r3, r2
300217f0:	e1a03103 	lsl	r3, r3, #2
300217f4:	e0833002 	add	r3, r3, r2
300217f8:	e1a03103 	lsl	r3, r3, #2
300217fc:	e0833000 	add	r3, r3, r0
30021800:	e0833001 	add	r3, r3, r1
30021804:	e5d33007 	ldrb	r3, [r3, #7]

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
30021808:	e35300ef 	cmp	r3, #239	; 0xef
3002180c:	8a000017 	bhi	30021870 <etharp_tmr+0x12c>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
30021810:	e5dd2007 	ldrb	r2, [sp, #7]
30021814:	e59f0118 	ldr	r0, [pc, #280]	; 30021934 <etharp_tmr+0x1f0>
30021818:	e3a01008 	mov	r1, #8
3002181c:	e1a03002 	mov	r3, r2
30021820:	e1a03103 	lsl	r3, r3, #2
30021824:	e0833002 	add	r3, r3, r2
30021828:	e1a03103 	lsl	r3, r3, #2
3002182c:	e0833000 	add	r3, r3, r0
30021830:	e0833001 	add	r3, r3, r1
30021834:	e5d33006 	ldrb	r3, [r3, #6]

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
30021838:	e3530001 	cmp	r3, #1
3002183c:	1a000033 	bne	30021910 <etharp_tmr+0x1cc>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
         (arp_table[i].ctime >= ARP_MAXPENDING))) {
30021840:	e5dd2007 	ldrb	r2, [sp, #7]
30021844:	e59f00e8 	ldr	r0, [pc, #232]	; 30021934 <etharp_tmr+0x1f0>
30021848:	e3a01008 	mov	r1, #8
3002184c:	e1a03002 	mov	r3, r2
30021850:	e1a03103 	lsl	r3, r3, #2
30021854:	e0833002 	add	r3, r3, r2
30021858:	e1a03103 	lsl	r3, r3, #2
3002185c:	e0833000 	add	r3, r3, r0
30021860:	e0833001 	add	r3, r3, r1
30021864:	e5d33007 	ldrb	r3, [r3, #7]

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
30021868:	e3530001 	cmp	r3, #1
3002186c:	9a000027 	bls	30021910 <etharp_tmr+0x1cc>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
30021870:	e5dd2007 	ldrb	r2, [sp, #7]
30021874:	e59f10b8 	ldr	r1, [pc, #184]	; 30021934 <etharp_tmr+0x1f0>
30021878:	e1a03002 	mov	r3, r2
3002187c:	e1a03103 	lsl	r3, r3, #2
30021880:	e0833002 	add	r3, r3, r2
30021884:	e1a03103 	lsl	r3, r3, #2
30021888:	e0833001 	add	r3, r3, r1
3002188c:	e5933000 	ldr	r3, [r3]
30021890:	e3530000 	cmp	r3, #0
30021894:	0a000012 	beq	300218e4 <etharp_tmr+0x1a0>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
30021898:	e5dd2007 	ldrb	r2, [sp, #7]
3002189c:	e59f1090 	ldr	r1, [pc, #144]	; 30021934 <etharp_tmr+0x1f0>
300218a0:	e1a03002 	mov	r3, r2
300218a4:	e1a03103 	lsl	r3, r3, #2
300218a8:	e0833002 	add	r3, r3, r2
300218ac:	e1a03103 	lsl	r3, r3, #2
300218b0:	e0833001 	add	r3, r3, r1
300218b4:	e5933000 	ldr	r3, [r3]
300218b8:	e1a00003 	mov	r0, r3
300218bc:	ebffff8a 	bl	300216ec <free_etharp_q>
        arp_table[i].q = NULL;
300218c0:	e5dd2007 	ldrb	r2, [sp, #7]
300218c4:	e59f1068 	ldr	r1, [pc, #104]	; 30021934 <etharp_tmr+0x1f0>
300218c8:	e1a03002 	mov	r3, r2
300218cc:	e1a03103 	lsl	r3, r3, #2
300218d0:	e0833002 	add	r3, r3, r2
300218d4:	e1a03103 	lsl	r3, r3, #2
300218d8:	e0833001 	add	r3, r3, r1
300218dc:	e3a02000 	mov	r2, #0
300218e0:	e5832000 	str	r2, [r3]
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
300218e4:	e5dd2007 	ldrb	r2, [sp, #7]
300218e8:	e59f0044 	ldr	r0, [pc, #68]	; 30021934 <etharp_tmr+0x1f0>
300218ec:	e3a01008 	mov	r1, #8
300218f0:	e1a03002 	mov	r3, r2
300218f4:	e1a03103 	lsl	r3, r3, #2
300218f8:	e0833002 	add	r3, r3, r2
300218fc:	e1a03103 	lsl	r3, r3, #2
30021900:	e0833000 	add	r3, r3, r0
30021904:	e0833001 	add	r3, r3, r1
30021908:	e3a02000 	mov	r2, #0
3002190c:	e5c32006 	strb	r2, [r3, #6]
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
30021910:	e5dd3007 	ldrb	r3, [sp, #7]
30021914:	e2833001 	add	r3, r3, #1
30021918:	e5cd3007 	strb	r3, [sp, #7]
3002191c:	e5dd3007 	ldrb	r3, [sp, #7]
30021920:	e3530009 	cmp	r3, #9
30021924:	9affff8b 	bls	30021758 <etharp_tmr+0x14>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
30021928:	e28dd00c 	add	sp, sp, #12
3002192c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30021930:	e12fff1e 	bx	lr
30021934:	30029fb0 	.word	0x30029fb0

30021938 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
30021938:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002193c:	e24dd014 	sub	sp, sp, #20
30021940:	e58d0004 	str	r0, [sp, #4]
30021944:	e1a03001 	mov	r3, r1
30021948:	e5cd3003 	strb	r3, [sp, #3]
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
3002194c:	e3a0300a 	mov	r3, #10
30021950:	e5cd3008 	strb	r3, [sp, #8]
30021954:	e3a0300a 	mov	r3, #10
30021958:	e5cd3009 	strb	r3, [sp, #9]
  s8_t empty = ARP_TABLE_SIZE;
3002195c:	e3a0300a 	mov	r3, #10
30021960:	e5cd300a 	strb	r3, [sp, #10]
  u8_t i = 0, age_pending = 0, age_stable = 0;
30021964:	e3a03000 	mov	r3, #0
30021968:	e5cd300b 	strb	r3, [sp, #11]
3002196c:	e3a03000 	mov	r3, #0
30021970:	e5cd300c 	strb	r3, [sp, #12]
30021974:	e3a03000 	mov	r3, #0
30021978:	e5cd300d 	strb	r3, [sp, #13]
#if ARP_QUEUEING
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
3002197c:	e3a0300a 	mov	r3, #10
30021980:	e5cd300e 	strb	r3, [sp, #14]
  /* its age */
  u8_t age_queue = 0;
30021984:	e3a03000 	mov	r3, #0
30021988:	e5cd300f 	strb	r3, [sp, #15]
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
3002198c:	e59d3004 	ldr	r3, [sp, #4]
30021990:	e3530000 	cmp	r3, #0
30021994:	0a000031 	beq	30021a60 <find_entry+0x128>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
30021998:	e59f35e4 	ldr	r3, [pc, #1508]	; 30021f84 <find_entry+0x64c>
3002199c:	e5d33000 	ldrb	r3, [r3]
300219a0:	e1a02003 	mov	r2, r3
300219a4:	e59f05dc 	ldr	r0, [pc, #1500]	; 30021f88 <find_entry+0x650>
300219a8:	e3a01008 	mov	r1, #8
300219ac:	e1a03002 	mov	r3, r2
300219b0:	e1a03103 	lsl	r3, r3, #2
300219b4:	e0833002 	add	r3, r3, r2
300219b8:	e1a03103 	lsl	r3, r3, #2
300219bc:	e0833000 	add	r3, r3, r0
300219c0:	e0833001 	add	r3, r3, r1
300219c4:	e5d33006 	ldrb	r3, [r3, #6]
300219c8:	e3530002 	cmp	r3, #2
300219cc:	1a000023 	bne	30021a60 <find_entry+0x128>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
300219d0:	e59d3004 	ldr	r3, [sp, #4]
300219d4:	e5d32000 	ldrb	r2, [r3]
300219d8:	e5d31001 	ldrb	r1, [r3, #1]
300219dc:	e1a01401 	lsl	r1, r1, #8
300219e0:	e1812002 	orr	r2, r1, r2
300219e4:	e5d31002 	ldrb	r1, [r3, #2]
300219e8:	e1a01801 	lsl	r1, r1, #16
300219ec:	e1812002 	orr	r2, r1, r2
300219f0:	e5d33003 	ldrb	r3, [r3, #3]
300219f4:	e1a03c03 	lsl	r3, r3, #24
300219f8:	e1833002 	orr	r3, r3, r2
300219fc:	e1a01003 	mov	r1, r3
30021a00:	e59f357c 	ldr	r3, [pc, #1404]	; 30021f84 <find_entry+0x64c>
30021a04:	e5d33000 	ldrb	r3, [r3]
30021a08:	e1a02003 	mov	r2, r3
30021a0c:	e59fc574 	ldr	ip, [pc, #1396]	; 30021f88 <find_entry+0x650>
30021a10:	e3a00004 	mov	r0, #4
30021a14:	e1a03002 	mov	r3, r2
30021a18:	e1a03103 	lsl	r3, r3, #2
30021a1c:	e0833002 	add	r3, r3, r2
30021a20:	e1a03103 	lsl	r3, r3, #2
30021a24:	e083300c 	add	r3, r3, ip
30021a28:	e0833000 	add	r3, r3, r0
30021a2c:	e5933000 	ldr	r3, [r3]
30021a30:	e1510003 	cmp	r1, r3
30021a34:	1a000009 	bne	30021a60 <find_entry+0x128>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
30021a38:	e59f354c 	ldr	r3, [pc, #1356]	; 30021f8c <find_entry+0x654>
30021a3c:	e1d333b2 	ldrh	r3, [r3, #50]	; 0x32
30021a40:	e2833001 	add	r3, r3, #1
30021a44:	e1a03803 	lsl	r3, r3, #16
30021a48:	e1a02823 	lsr	r2, r3, #16
30021a4c:	e59f3538 	ldr	r3, [pc, #1336]	; 30021f8c <find_entry+0x654>
30021a50:	e1c323b2 	strh	r2, [r3, #50]	; 0x32
        return etharp_cached_entry;
30021a54:	e59f3528 	ldr	r3, [pc, #1320]	; 30021f84 <find_entry+0x64c>
30021a58:	e5d33000 	ldrb	r3, [r3]
30021a5c:	ea000142 	b	30021f6c <find_entry+0x634>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
30021a60:	e3a03000 	mov	r3, #0
30021a64:	e5cd300b 	strb	r3, [sp, #11]
30021a68:	ea0000ca 	b	30021d98 <find_entry+0x460>
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
30021a6c:	e1dd30da 	ldrsb	r3, [sp, #10]
30021a70:	e353000a 	cmp	r3, #10
30021a74:	1a00000e 	bne	30021ab4 <find_entry+0x17c>
30021a78:	e5dd200b 	ldrb	r2, [sp, #11]
30021a7c:	e59f0504 	ldr	r0, [pc, #1284]	; 30021f88 <find_entry+0x650>
30021a80:	e3a01008 	mov	r1, #8
30021a84:	e1a03002 	mov	r3, r2
30021a88:	e1a03103 	lsl	r3, r3, #2
30021a8c:	e0833002 	add	r3, r3, r2
30021a90:	e1a03103 	lsl	r3, r3, #2
30021a94:	e0833000 	add	r3, r3, r0
30021a98:	e0833001 	add	r3, r3, r1
30021a9c:	e5d33006 	ldrb	r3, [r3, #6]
30021aa0:	e3530000 	cmp	r3, #0
30021aa4:	1a000002 	bne	30021ab4 <find_entry+0x17c>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
30021aa8:	e5dd300b 	ldrb	r3, [sp, #11]
30021aac:	e5cd300a 	strb	r3, [sp, #10]
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
30021ab0:	ea0000b5 	b	30021d8c <find_entry+0x454>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
30021ab4:	e5dd200b 	ldrb	r2, [sp, #11]
30021ab8:	e59f04c8 	ldr	r0, [pc, #1224]	; 30021f88 <find_entry+0x650>
30021abc:	e3a01008 	mov	r1, #8
30021ac0:	e1a03002 	mov	r3, r2
30021ac4:	e1a03103 	lsl	r3, r3, #2
30021ac8:	e0833002 	add	r3, r3, r2
30021acc:	e1a03103 	lsl	r3, r3, #2
30021ad0:	e0833000 	add	r3, r3, r0
30021ad4:	e0833001 	add	r3, r3, r1
30021ad8:	e5d33006 	ldrb	r3, [r3, #6]
30021adc:	e3530001 	cmp	r3, #1
30021ae0:	1a00005f 	bne	30021c64 <find_entry+0x32c>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
30021ae4:	e59d3004 	ldr	r3, [sp, #4]
30021ae8:	e3530000 	cmp	r3, #0
30021aec:	0a00001c 	beq	30021b64 <find_entry+0x22c>
30021af0:	e59d3004 	ldr	r3, [sp, #4]
30021af4:	e5d32000 	ldrb	r2, [r3]
30021af8:	e5d31001 	ldrb	r1, [r3, #1]
30021afc:	e1a01401 	lsl	r1, r1, #8
30021b00:	e1812002 	orr	r2, r1, r2
30021b04:	e5d31002 	ldrb	r1, [r3, #2]
30021b08:	e1a01801 	lsl	r1, r1, #16
30021b0c:	e1812002 	orr	r2, r1, r2
30021b10:	e5d33003 	ldrb	r3, [r3, #3]
30021b14:	e1a03c03 	lsl	r3, r3, #24
30021b18:	e1833002 	orr	r3, r3, r2
30021b1c:	e1a01003 	mov	r1, r3
30021b20:	e5dd200b 	ldrb	r2, [sp, #11]
30021b24:	e59fc45c 	ldr	ip, [pc, #1116]	; 30021f88 <find_entry+0x650>
30021b28:	e3a00004 	mov	r0, #4
30021b2c:	e1a03002 	mov	r3, r2
30021b30:	e1a03103 	lsl	r3, r3, #2
30021b34:	e0833002 	add	r3, r3, r2
30021b38:	e1a03103 	lsl	r3, r3, #2
30021b3c:	e083300c 	add	r3, r3, ip
30021b40:	e0833000 	add	r3, r3, r0
30021b44:	e5933000 	ldr	r3, [r3]
30021b48:	e1510003 	cmp	r1, r3
30021b4c:	1a000004 	bne	30021b64 <find_entry+0x22c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
30021b50:	e59f342c 	ldr	r3, [pc, #1068]	; 30021f84 <find_entry+0x64c>
30021b54:	e5dd200b 	ldrb	r2, [sp, #11]
30021b58:	e5c32000 	strb	r2, [r3]
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
30021b5c:	e5dd300b 	ldrb	r3, [sp, #11]
30021b60:	ea000101 	b	30021f6c <find_entry+0x634>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
30021b64:	e5dd200b 	ldrb	r2, [sp, #11]
30021b68:	e59f1418 	ldr	r1, [pc, #1048]	; 30021f88 <find_entry+0x650>
30021b6c:	e1a03002 	mov	r3, r2
30021b70:	e1a03103 	lsl	r3, r3, #2
30021b74:	e0833002 	add	r3, r3, r2
30021b78:	e1a03103 	lsl	r3, r3, #2
30021b7c:	e0833001 	add	r3, r3, r1
30021b80:	e5933000 	ldr	r3, [r3]
30021b84:	e3530000 	cmp	r3, #0
30021b88:	0a00001a 	beq	30021bf8 <find_entry+0x2c0>
        if (arp_table[i].ctime >= age_queue) {
30021b8c:	e5dd200b 	ldrb	r2, [sp, #11]
30021b90:	e59f03f0 	ldr	r0, [pc, #1008]	; 30021f88 <find_entry+0x650>
30021b94:	e3a01008 	mov	r1, #8
30021b98:	e1a03002 	mov	r3, r2
30021b9c:	e1a03103 	lsl	r3, r3, #2
30021ba0:	e0833002 	add	r3, r3, r2
30021ba4:	e1a03103 	lsl	r3, r3, #2
30021ba8:	e0833000 	add	r3, r3, r0
30021bac:	e0833001 	add	r3, r3, r1
30021bb0:	e5d33007 	ldrb	r3, [r3, #7]
30021bb4:	e5dd200f 	ldrb	r2, [sp, #15]
30021bb8:	e1520003 	cmp	r2, r3
30021bbc:	8a00006f 	bhi	30021d80 <find_entry+0x448>
          old_queue = i;
30021bc0:	e5dd300b 	ldrb	r3, [sp, #11]
30021bc4:	e5cd300e 	strb	r3, [sp, #14]
          age_queue = arp_table[i].ctime;
30021bc8:	e5dd200b 	ldrb	r2, [sp, #11]
30021bcc:	e59f03b4 	ldr	r0, [pc, #948]	; 30021f88 <find_entry+0x650>
30021bd0:	e3a01008 	mov	r1, #8
30021bd4:	e1a03002 	mov	r3, r2
30021bd8:	e1a03103 	lsl	r3, r3, #2
30021bdc:	e0833002 	add	r3, r3, r2
30021be0:	e1a03103 	lsl	r3, r3, #2
30021be4:	e0833000 	add	r3, r3, r0
30021be8:	e0833001 	add	r3, r3, r1
30021bec:	e5d33007 	ldrb	r3, [r3, #7]
30021bf0:	e5cd300f 	strb	r3, [sp, #15]
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
          old_pending = i;
          age_pending = arp_table[i].ctime;
30021bf4:	ea000064 	b	30021d8c <find_entry+0x454>
          age_queue = arp_table[i].ctime;
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
30021bf8:	e5dd200b 	ldrb	r2, [sp, #11]
30021bfc:	e59f0384 	ldr	r0, [pc, #900]	; 30021f88 <find_entry+0x650>
30021c00:	e3a01008 	mov	r1, #8
30021c04:	e1a03002 	mov	r3, r2
30021c08:	e1a03103 	lsl	r3, r3, #2
30021c0c:	e0833002 	add	r3, r3, r2
30021c10:	e1a03103 	lsl	r3, r3, #2
30021c14:	e0833000 	add	r3, r3, r0
30021c18:	e0833001 	add	r3, r3, r1
30021c1c:	e5d33007 	ldrb	r3, [r3, #7]
30021c20:	e5dd200c 	ldrb	r2, [sp, #12]
30021c24:	e1520003 	cmp	r2, r3
30021c28:	8a000056 	bhi	30021d88 <find_entry+0x450>
          old_pending = i;
30021c2c:	e5dd300b 	ldrb	r3, [sp, #11]
30021c30:	e5cd3008 	strb	r3, [sp, #8]
          age_pending = arp_table[i].ctime;
30021c34:	e5dd200b 	ldrb	r2, [sp, #11]
30021c38:	e59f0348 	ldr	r0, [pc, #840]	; 30021f88 <find_entry+0x650>
30021c3c:	e3a01008 	mov	r1, #8
30021c40:	e1a03002 	mov	r3, r2
30021c44:	e1a03103 	lsl	r3, r3, #2
30021c48:	e0833002 	add	r3, r3, r2
30021c4c:	e1a03103 	lsl	r3, r3, #2
30021c50:	e0833000 	add	r3, r3, r0
30021c54:	e0833001 	add	r3, r3, r1
30021c58:	e5d33007 	ldrb	r3, [r3, #7]
30021c5c:	e5cd300c 	strb	r3, [sp, #12]
30021c60:	ea000049 	b	30021d8c <find_entry+0x454>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
30021c64:	e5dd200b 	ldrb	r2, [sp, #11]
30021c68:	e59f0318 	ldr	r0, [pc, #792]	; 30021f88 <find_entry+0x650>
30021c6c:	e3a01008 	mov	r1, #8
30021c70:	e1a03002 	mov	r3, r2
30021c74:	e1a03103 	lsl	r3, r3, #2
30021c78:	e0833002 	add	r3, r3, r2
30021c7c:	e1a03103 	lsl	r3, r3, #2
30021c80:	e0833000 	add	r3, r3, r0
30021c84:	e0833001 	add	r3, r3, r1
30021c88:	e5d33006 	ldrb	r3, [r3, #6]
30021c8c:	e3530002 	cmp	r3, #2
30021c90:	1a00003d 	bne	30021d8c <find_entry+0x454>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
30021c94:	e59d3004 	ldr	r3, [sp, #4]
30021c98:	e3530000 	cmp	r3, #0
30021c9c:	0a00001c 	beq	30021d14 <find_entry+0x3dc>
30021ca0:	e59d3004 	ldr	r3, [sp, #4]
30021ca4:	e5d32000 	ldrb	r2, [r3]
30021ca8:	e5d31001 	ldrb	r1, [r3, #1]
30021cac:	e1a01401 	lsl	r1, r1, #8
30021cb0:	e1812002 	orr	r2, r1, r2
30021cb4:	e5d31002 	ldrb	r1, [r3, #2]
30021cb8:	e1a01801 	lsl	r1, r1, #16
30021cbc:	e1812002 	orr	r2, r1, r2
30021cc0:	e5d33003 	ldrb	r3, [r3, #3]
30021cc4:	e1a03c03 	lsl	r3, r3, #24
30021cc8:	e1833002 	orr	r3, r3, r2
30021ccc:	e1a01003 	mov	r1, r3
30021cd0:	e5dd200b 	ldrb	r2, [sp, #11]
30021cd4:	e59fc2ac 	ldr	ip, [pc, #684]	; 30021f88 <find_entry+0x650>
30021cd8:	e3a00004 	mov	r0, #4
30021cdc:	e1a03002 	mov	r3, r2
30021ce0:	e1a03103 	lsl	r3, r3, #2
30021ce4:	e0833002 	add	r3, r3, r2
30021ce8:	e1a03103 	lsl	r3, r3, #2
30021cec:	e083300c 	add	r3, r3, ip
30021cf0:	e0833000 	add	r3, r3, r0
30021cf4:	e5933000 	ldr	r3, [r3]
30021cf8:	e1510003 	cmp	r1, r3
30021cfc:	1a000004 	bne	30021d14 <find_entry+0x3dc>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
30021d00:	e59f327c 	ldr	r3, [pc, #636]	; 30021f84 <find_entry+0x64c>
30021d04:	e5dd200b 	ldrb	r2, [sp, #11]
30021d08:	e5c32000 	strb	r2, [r3]
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
30021d0c:	e5dd300b 	ldrb	r3, [sp, #11]
30021d10:	ea000095 	b	30021f6c <find_entry+0x634>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
30021d14:	e5dd200b 	ldrb	r2, [sp, #11]
30021d18:	e59f0268 	ldr	r0, [pc, #616]	; 30021f88 <find_entry+0x650>
30021d1c:	e3a01008 	mov	r1, #8
30021d20:	e1a03002 	mov	r3, r2
30021d24:	e1a03103 	lsl	r3, r3, #2
30021d28:	e0833002 	add	r3, r3, r2
30021d2c:	e1a03103 	lsl	r3, r3, #2
30021d30:	e0833000 	add	r3, r3, r0
30021d34:	e0833001 	add	r3, r3, r1
30021d38:	e5d33007 	ldrb	r3, [r3, #7]
30021d3c:	e5dd200d 	ldrb	r2, [sp, #13]
30021d40:	e1520003 	cmp	r2, r3
30021d44:	8a000010 	bhi	30021d8c <find_entry+0x454>
        old_stable = i;
30021d48:	e5dd300b 	ldrb	r3, [sp, #11]
30021d4c:	e5cd3009 	strb	r3, [sp, #9]
        age_stable = arp_table[i].ctime;
30021d50:	e5dd200b 	ldrb	r2, [sp, #11]
30021d54:	e59f022c 	ldr	r0, [pc, #556]	; 30021f88 <find_entry+0x650>
30021d58:	e3a01008 	mov	r1, #8
30021d5c:	e1a03002 	mov	r3, r2
30021d60:	e1a03103 	lsl	r3, r3, #2
30021d64:	e0833002 	add	r3, r3, r2
30021d68:	e1a03103 	lsl	r3, r3, #2
30021d6c:	e0833000 	add	r3, r3, r0
30021d70:	e0833001 	add	r3, r3, r1
30021d74:	e5d33007 	ldrb	r3, [r3, #7]
30021d78:	e5cd300d 	strb	r3, [sp, #13]
30021d7c:	ea000002 	b	30021d8c <find_entry+0x454>
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
          old_pending = i;
          age_pending = arp_table[i].ctime;
30021d80:	e1a00000 	nop			; (mov r0, r0)
30021d84:	ea000000 	b	30021d8c <find_entry+0x454>
30021d88:	e1a00000 	nop			; (mov r0, r0)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
30021d8c:	e5dd300b 	ldrb	r3, [sp, #11]
30021d90:	e2833001 	add	r3, r3, #1
30021d94:	e5cd300b 	strb	r3, [sp, #11]
30021d98:	e5dd300b 	ldrb	r3, [sp, #11]
30021d9c:	e3530009 	cmp	r3, #9
30021da0:	9affff31 	bls	30021a6c <find_entry+0x134>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
30021da4:	e1dd30da 	ldrsb	r3, [sp, #10]
30021da8:	e353000a 	cmp	r3, #10
30021dac:	1a000003 	bne	30021dc0 <find_entry+0x488>
30021db0:	e5dd3003 	ldrb	r3, [sp, #3]
30021db4:	e2033001 	and	r3, r3, #1
30021db8:	e3530000 	cmp	r3, #0
30021dbc:	0a000003 	beq	30021dd0 <find_entry+0x498>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
30021dc0:	e5dd3003 	ldrb	r3, [sp, #3]
30021dc4:	e2033002 	and	r3, r3, #2
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
30021dc8:	e3530000 	cmp	r3, #0
30021dcc:	0a000001 	beq	30021dd8 <find_entry+0x4a0>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
30021dd0:	e3a030ff 	mov	r3, #255	; 0xff
30021dd4:	ea000064 	b	30021f6c <find_entry+0x634>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
30021dd8:	e1dd30da 	ldrsb	r3, [sp, #10]
30021ddc:	e3530009 	cmp	r3, #9
30021de0:	ca000002 	bgt	30021df0 <find_entry+0x4b8>
    i = empty;
30021de4:	e5dd300a 	ldrb	r3, [sp, #10]
30021de8:	e5cd300b 	strb	r3, [sp, #11]
30021dec:	ea000026 	b	30021e8c <find_entry+0x554>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
30021df0:	e1dd30d9 	ldrsb	r3, [sp, #9]
30021df4:	e3530009 	cmp	r3, #9
30021df8:	ca000002 	bgt	30021e08 <find_entry+0x4d0>
    /* recycle oldest stable*/
    i = old_stable;
30021dfc:	e5dd3009 	ldrb	r3, [sp, #9]
30021e00:	e5cd300b 	strb	r3, [sp, #11]
30021e04:	ea000020 	b	30021e8c <find_entry+0x554>
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
30021e08:	e1dd30d8 	ldrsb	r3, [sp, #8]
30021e0c:	e3530009 	cmp	r3, #9
30021e10:	ca000002 	bgt	30021e20 <find_entry+0x4e8>
    /* recycle oldest pending */
    i = old_pending;
30021e14:	e5dd3008 	ldrb	r3, [sp, #8]
30021e18:	e5cd300b 	strb	r3, [sp, #11]
30021e1c:	ea00001a 	b	30021e8c <find_entry+0x554>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
30021e20:	e1dd30de 	ldrsb	r3, [sp, #14]
30021e24:	e3530009 	cmp	r3, #9
30021e28:	ca000015 	bgt	30021e84 <find_entry+0x54c>
    /* recycle oldest pending */
    i = old_queue;
30021e2c:	e5dd300e 	ldrb	r3, [sp, #14]
30021e30:	e5cd300b 	strb	r3, [sp, #11]
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
30021e34:	e5dd200b 	ldrb	r2, [sp, #11]
30021e38:	e59f1148 	ldr	r1, [pc, #328]	; 30021f88 <find_entry+0x650>
30021e3c:	e1a03002 	mov	r3, r2
30021e40:	e1a03103 	lsl	r3, r3, #2
30021e44:	e0833002 	add	r3, r3, r2
30021e48:	e1a03103 	lsl	r3, r3, #2
30021e4c:	e0833001 	add	r3, r3, r1
30021e50:	e5933000 	ldr	r3, [r3]
30021e54:	e1a00003 	mov	r0, r3
30021e58:	ebfffe23 	bl	300216ec <free_etharp_q>
    arp_table[i].q = NULL;
30021e5c:	e5dd200b 	ldrb	r2, [sp, #11]
30021e60:	e59f1120 	ldr	r1, [pc, #288]	; 30021f88 <find_entry+0x650>
30021e64:	e1a03002 	mov	r3, r2
30021e68:	e1a03103 	lsl	r3, r3, #2
30021e6c:	e0833002 	add	r3, r3, r2
30021e70:	e1a03103 	lsl	r3, r3, #2
30021e74:	e0833001 	add	r3, r3, r1
30021e78:	e3a02000 	mov	r2, #0
30021e7c:	e5832000 	str	r2, [r3]
30021e80:	ea000001 	b	30021e8c <find_entry+0x554>
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
30021e84:	e3a030ff 	mov	r3, #255	; 0xff
30021e88:	ea000037 	b	30021f6c <find_entry+0x634>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
30021e8c:	e5dd200b 	ldrb	r2, [sp, #11]
30021e90:	e59f00f0 	ldr	r0, [pc, #240]	; 30021f88 <find_entry+0x650>
30021e94:	e3a01008 	mov	r1, #8
30021e98:	e1a03002 	mov	r3, r2
30021e9c:	e1a03103 	lsl	r3, r3, #2
30021ea0:	e0833002 	add	r3, r3, r2
30021ea4:	e1a03103 	lsl	r3, r3, #2
30021ea8:	e0833000 	add	r3, r3, r0
30021eac:	e0833001 	add	r3, r3, r1
30021eb0:	e3a02000 	mov	r2, #0
30021eb4:	e5c32006 	strb	r2, [r3, #6]

  /* IP address given? */
  if (ipaddr != NULL) {
30021eb8:	e59d3004 	ldr	r3, [sp, #4]
30021ebc:	e3530000 	cmp	r3, #0
30021ec0:	0a00001a 	beq	30021f30 <find_entry+0x5f8>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
30021ec4:	e5dd100b 	ldrb	r1, [sp, #11]
30021ec8:	e59d3004 	ldr	r3, [sp, #4]
30021ecc:	e3530000 	cmp	r3, #0
30021ed0:	0a00000c 	beq	30021f08 <find_entry+0x5d0>
30021ed4:	e59d3004 	ldr	r3, [sp, #4]
30021ed8:	e5d32000 	ldrb	r2, [r3]
30021edc:	e5d30001 	ldrb	r0, [r3, #1]
30021ee0:	e1a00400 	lsl	r0, r0, #8
30021ee4:	e1802002 	orr	r2, r0, r2
30021ee8:	e5d30002 	ldrb	r0, [r3, #2]
30021eec:	e1a00800 	lsl	r0, r0, #16
30021ef0:	e1802002 	orr	r2, r0, r2
30021ef4:	e5d33003 	ldrb	r3, [r3, #3]
30021ef8:	e1a03c03 	lsl	r3, r3, #24
30021efc:	e1833002 	orr	r3, r3, r2
30021f00:	e1a02003 	mov	r2, r3
30021f04:	ea000000 	b	30021f0c <find_entry+0x5d4>
30021f08:	e3a02000 	mov	r2, #0
30021f0c:	e59fc074 	ldr	ip, [pc, #116]	; 30021f88 <find_entry+0x650>
30021f10:	e3a00004 	mov	r0, #4
30021f14:	e1a03001 	mov	r3, r1
30021f18:	e1a03103 	lsl	r3, r3, #2
30021f1c:	e0833001 	add	r3, r3, r1
30021f20:	e1a03103 	lsl	r3, r3, #2
30021f24:	e083300c 	add	r3, r3, ip
30021f28:	e0833000 	add	r3, r3, r0
30021f2c:	e5832000 	str	r2, [r3]
  }
  arp_table[i].ctime = 0;
30021f30:	e5dd200b 	ldrb	r2, [sp, #11]
30021f34:	e59f004c 	ldr	r0, [pc, #76]	; 30021f88 <find_entry+0x650>
30021f38:	e3a01008 	mov	r1, #8
30021f3c:	e1a03002 	mov	r3, r2
30021f40:	e1a03103 	lsl	r3, r3, #2
30021f44:	e0833002 	add	r3, r3, r2
30021f48:	e1a03103 	lsl	r3, r3, #2
30021f4c:	e0833000 	add	r3, r3, r0
30021f50:	e0833001 	add	r3, r3, r1
30021f54:	e3a02000 	mov	r2, #0
30021f58:	e5c32007 	strb	r2, [r3, #7]
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
30021f5c:	e59f3020 	ldr	r3, [pc, #32]	; 30021f84 <find_entry+0x64c>
30021f60:	e5dd200b 	ldrb	r2, [sp, #11]
30021f64:	e5c32000 	strb	r2, [r3]
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
30021f68:	e5dd300b 	ldrb	r3, [sp, #11]
30021f6c:	e1a03c03 	lsl	r3, r3, #24
30021f70:	e1a03c43 	asr	r3, r3, #24
}
30021f74:	e1a00003 	mov	r0, r3
30021f78:	e28dd014 	add	sp, sp, #20
30021f7c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30021f80:	e12fff1e 	bx	lr
30021f84:	3002a078 	.word	0x3002a078
30021f88:	30029fb0 	.word	0x30029fb0
30021f8c:	3002b214 	.word	0x3002b214

30021f90 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
30021f90:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30021f94:	e24dd01c 	sub	sp, sp, #28
30021f98:	e58d000c 	str	r0, [sp, #12]
30021f9c:	e58d1008 	str	r1, [sp, #8]
30021fa0:	e58d2004 	str	r2, [sp, #4]
30021fa4:	e58d3000 	str	r3, [sp]
  struct eth_hdr *ethhdr = p->payload;
30021fa8:	e59d3008 	ldr	r3, [sp, #8]
30021fac:	e5933004 	ldr	r3, [r3, #4]
30021fb0:	e58d3010 	str	r3, [sp, #16]
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
30021fb4:	e3a03006 	mov	r3, #6
30021fb8:	e5cd3017 	strb	r3, [sp, #23]
  while(k > 0) {
30021fbc:	ea000011 	b	30022008 <etharp_send_ip+0x78>
    k--;
30021fc0:	e5dd3017 	ldrb	r3, [sp, #23]
30021fc4:	e2433001 	sub	r3, r3, #1
30021fc8:	e5cd3017 	strb	r3, [sp, #23]
    ethhdr->dest.addr[k] = dst->addr[k];
30021fcc:	e5dd3017 	ldrb	r3, [sp, #23]
30021fd0:	e5dd2017 	ldrb	r2, [sp, #23]
30021fd4:	e59d1000 	ldr	r1, [sp]
30021fd8:	e7d11002 	ldrb	r1, [r1, r2]
30021fdc:	e59d2010 	ldr	r2, [sp, #16]
30021fe0:	e7c21003 	strb	r1, [r2, r3]
    ethhdr->src.addr[k]  = src->addr[k];
30021fe4:	e5dd0017 	ldrb	r0, [sp, #23]
30021fe8:	e5dd3017 	ldrb	r3, [sp, #23]
30021fec:	e59d2004 	ldr	r2, [sp, #4]
30021ff0:	e7d22003 	ldrb	r2, [r2, r3]
30021ff4:	e59d1010 	ldr	r1, [sp, #16]
30021ff8:	e3a03006 	mov	r3, #6
30021ffc:	e0801001 	add	r1, r0, r1
30022000:	e0813003 	add	r3, r1, r3
30022004:	e5c32000 	strb	r2, [r3]
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
30022008:	e5dd3017 	ldrb	r3, [sp, #23]
3002200c:	e3530000 	cmp	r3, #0
30022010:	1affffea 	bne	30021fc0 <etharp_send_ip+0x30>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
30022014:	e3a00b02 	mov	r0, #2048	; 0x800
30022018:	ebffc627 	bl	300138bc <htons>
3002201c:	e1a03000 	mov	r3, r0
30022020:	e1a02003 	mov	r2, r3
30022024:	e59d3010 	ldr	r3, [sp, #16]
30022028:	e20210ff 	and	r1, r2, #255	; 0xff
3002202c:	e3a00000 	mov	r0, #0
30022030:	e1801001 	orr	r1, r0, r1
30022034:	e5c3100c 	strb	r1, [r3, #12]
30022038:	e1a02422 	lsr	r2, r2, #8
3002203c:	e1a02802 	lsl	r2, r2, #16
30022040:	e1a02822 	lsr	r2, r2, #16
30022044:	e3a01000 	mov	r1, #0
30022048:	e1812002 	orr	r2, r1, r2
3002204c:	e5c3200d 	strb	r2, [r3, #13]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
30022050:	e59d300c 	ldr	r3, [sp, #12]
30022054:	e5933018 	ldr	r3, [r3, #24]
30022058:	e59d000c 	ldr	r0, [sp, #12]
3002205c:	e59d1008 	ldr	r1, [sp, #8]
30022060:	e1a0e00f 	mov	lr, pc
30022064:	e12fff13 	bx	r3
30022068:	e1a03000 	mov	r3, r0
3002206c:	e20330ff 	and	r3, r3, #255	; 0xff
30022070:	e20330ff 	and	r3, r3, #255	; 0xff
30022074:	e1a03c03 	lsl	r3, r3, #24
30022078:	e1a03c43 	asr	r3, r3, #24
}
3002207c:	e1a00003 	mov	r0, r3
30022080:	e28dd01c 	add	sp, sp, #28
30022084:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30022088:	e12fff1e 	bx	lr

3002208c <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
3002208c:	e92d4010 	push	{r4, lr}
30022090:	e24dd020 	sub	sp, sp, #32
30022094:	e58d000c 	str	r0, [sp, #12]
30022098:	e58d1008 	str	r1, [sp, #8]
3002209c:	e58d2004 	str	r2, [sp, #4]
300220a0:	e5cd3003 	strb	r3, [sp, #3]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
300220a4:	e59d3008 	ldr	r3, [sp, #8]
300220a8:	e3530000 	cmp	r3, #0
300220ac:	0a000027 	beq	30022150 <update_arp_entry+0xc4>
300220b0:	e59d3008 	ldr	r3, [sp, #8]
300220b4:	e5d32000 	ldrb	r2, [r3]
300220b8:	e5d31001 	ldrb	r1, [r3, #1]
300220bc:	e1a01401 	lsl	r1, r1, #8
300220c0:	e1812002 	orr	r2, r1, r2
300220c4:	e5d31002 	ldrb	r1, [r3, #2]
300220c8:	e1a01801 	lsl	r1, r1, #16
300220cc:	e1812002 	orr	r2, r1, r2
300220d0:	e5d33003 	ldrb	r3, [r3, #3]
300220d4:	e1a03c03 	lsl	r3, r3, #24
300220d8:	e1833002 	orr	r3, r3, r2
300220dc:	e3530000 	cmp	r3, #0
300220e0:	0a00001a 	beq	30022150 <update_arp_entry+0xc4>
      ip_addr_isbroadcast(ipaddr, netif) ||
300220e4:	e59d0008 	ldr	r0, [sp, #8]
300220e8:	e59d100c 	ldr	r1, [sp, #12]
300220ec:	ebffcb88 	bl	30014f14 <ip_addr_isbroadcast>
300220f0:	e1a03000 	mov	r3, r0
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
300220f4:	e3530000 	cmp	r3, #0
300220f8:	1a000014 	bne	30022150 <update_arp_entry+0xc4>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
300220fc:	e59d3008 	ldr	r3, [sp, #8]
30022100:	e5d32000 	ldrb	r2, [r3]
30022104:	e5d31001 	ldrb	r1, [r3, #1]
30022108:	e1a01401 	lsl	r1, r1, #8
3002210c:	e1812002 	orr	r2, r1, r2
30022110:	e5d31002 	ldrb	r1, [r3, #2]
30022114:	e1a01801 	lsl	r1, r1, #16
30022118:	e1812002 	orr	r2, r1, r2
3002211c:	e5d33003 	ldrb	r3, [r3, #3]
30022120:	e1a03c03 	lsl	r3, r3, #24
30022124:	e1833002 	orr	r3, r3, r2
30022128:	e1a04003 	mov	r4, r3
3002212c:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
30022130:	ebffc612 	bl	30013980 <ntohl>
30022134:	e1a03000 	mov	r3, r0
30022138:	e0044003 	and	r4, r4, r3
3002213c:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
30022140:	ebffc60e 	bl	30013980 <ntohl>
30022144:	e1a03000 	mov	r3, r0
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
30022148:	e1540003 	cmp	r4, r3
3002214c:	1a000001 	bne	30022158 <update_arp_entry+0xcc>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
30022150:	e3a030f7 	mov	r3, #247	; 0xf7
30022154:	ea000073 	b	30022328 <update_arp_entry+0x29c>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
30022158:	e5dd3003 	ldrb	r3, [sp, #3]
3002215c:	e59d0008 	ldr	r0, [sp, #8]
30022160:	e1a01003 	mov	r1, r3
30022164:	ebfffdf3 	bl	30021938 <find_entry>
30022168:	e1a03000 	mov	r3, r0
3002216c:	e20330ff 	and	r3, r3, #255	; 0xff
30022170:	e5cd3016 	strb	r3, [sp, #22]
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
30022174:	e1dd31d6 	ldrsb	r3, [sp, #22]
30022178:	e3530000 	cmp	r3, #0
3002217c:	aa000001 	bge	30022188 <update_arp_entry+0xfc>
    return (err_t)i;
30022180:	e5dd3016 	ldrb	r3, [sp, #22]
30022184:	ea000067 	b	30022328 <update_arp_entry+0x29c>
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
30022188:	e1dd21d6 	ldrsb	r2, [sp, #22]
3002218c:	e59f01ac 	ldr	r0, [pc, #428]	; 30022340 <update_arp_entry+0x2b4>
30022190:	e3a01008 	mov	r1, #8
30022194:	e1a03002 	mov	r3, r2
30022198:	e1a03103 	lsl	r3, r3, #2
3002219c:	e0833002 	add	r3, r3, r2
300221a0:	e1a03103 	lsl	r3, r3, #2
300221a4:	e0833000 	add	r3, r3, r0
300221a8:	e0833001 	add	r3, r3, r1
300221ac:	e3a02002 	mov	r2, #2
300221b0:	e5c32006 	strb	r2, [r3, #6]
  /* record network interface */
  arp_table[i].netif = netif;
300221b4:	e1dd21d6 	ldrsb	r2, [sp, #22]
300221b8:	e59f0180 	ldr	r0, [pc, #384]	; 30022340 <update_arp_entry+0x2b4>
300221bc:	e3a01010 	mov	r1, #16
300221c0:	e1a03002 	mov	r3, r2
300221c4:	e1a03103 	lsl	r3, r3, #2
300221c8:	e0833002 	add	r3, r3, r2
300221cc:	e1a03103 	lsl	r3, r3, #2
300221d0:	e0833000 	add	r3, r3, r0
300221d4:	e0833001 	add	r3, r3, r1
300221d8:	e59d200c 	ldr	r2, [sp, #12]
300221dc:	e5832000 	str	r2, [r3]
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
300221e0:	e3a03006 	mov	r3, #6
300221e4:	e5cd3017 	strb	r3, [sp, #23]
  while (k > 0) {
300221e8:	ea000012 	b	30022238 <update_arp_entry+0x1ac>
    k--;
300221ec:	e5dd3017 	ldrb	r3, [sp, #23]
300221f0:	e2433001 	sub	r3, r3, #1
300221f4:	e5cd3017 	strb	r3, [sp, #23]
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
300221f8:	e1dd21d6 	ldrsb	r2, [sp, #22]
300221fc:	e5dd4017 	ldrb	r4, [sp, #23]
30022200:	e5dd3017 	ldrb	r3, [sp, #23]
30022204:	e59d1004 	ldr	r1, [sp, #4]
30022208:	e7d11003 	ldrb	r1, [r1, r3]
3002220c:	e59fc12c 	ldr	ip, [pc, #300]	; 30022340 <update_arp_entry+0x2b4>
30022210:	e3a00008 	mov	r0, #8
30022214:	e1a03002 	mov	r3, r2
30022218:	e1a03103 	lsl	r3, r3, #2
3002221c:	e0833002 	add	r3, r3, r2
30022220:	e1a03103 	lsl	r3, r3, #2
30022224:	e0833004 	add	r3, r3, r4
30022228:	e083300c 	add	r3, r3, ip
3002222c:	e0833000 	add	r3, r3, r0
30022230:	e1a02001 	mov	r2, r1
30022234:	e5c32000 	strb	r2, [r3]
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
30022238:	e5dd3017 	ldrb	r3, [sp, #23]
3002223c:	e3530000 	cmp	r3, #0
30022240:	1affffe9 	bne	300221ec <update_arp_entry+0x160>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
30022244:	e1dd21d6 	ldrsb	r2, [sp, #22]
30022248:	e59f00f0 	ldr	r0, [pc, #240]	; 30022340 <update_arp_entry+0x2b4>
3002224c:	e3a01008 	mov	r1, #8
30022250:	e1a03002 	mov	r3, r2
30022254:	e1a03103 	lsl	r3, r3, #2
30022258:	e0833002 	add	r3, r3, r2
3002225c:	e1a03103 	lsl	r3, r3, #2
30022260:	e0833000 	add	r3, r3, r0
30022264:	e0833001 	add	r3, r3, r1
30022268:	e3a02000 	mov	r2, #0
3002226c:	e5c32007 	strb	r2, [r3, #7]
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
30022270:	ea000021 	b	300222fc <update_arp_entry+0x270>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
30022274:	e1dd21d6 	ldrsb	r2, [sp, #22]
30022278:	e59f10c0 	ldr	r1, [pc, #192]	; 30022340 <update_arp_entry+0x2b4>
3002227c:	e1a03002 	mov	r3, r2
30022280:	e1a03103 	lsl	r3, r3, #2
30022284:	e0833002 	add	r3, r3, r2
30022288:	e1a03103 	lsl	r3, r3, #2
3002228c:	e0833001 	add	r3, r3, r1
30022290:	e5933000 	ldr	r3, [r3]
30022294:	e58d301c 	str	r3, [sp, #28]
    /* pop first item off the queue */
    arp_table[i].q = q->next;
30022298:	e1dd21d6 	ldrsb	r2, [sp, #22]
3002229c:	e59d301c 	ldr	r3, [sp, #28]
300222a0:	e5931000 	ldr	r1, [r3]
300222a4:	e59f0094 	ldr	r0, [pc, #148]	; 30022340 <update_arp_entry+0x2b4>
300222a8:	e1a03002 	mov	r3, r2
300222ac:	e1a03103 	lsl	r3, r3, #2
300222b0:	e0833002 	add	r3, r3, r2
300222b4:	e1a03103 	lsl	r3, r3, #2
300222b8:	e0833000 	add	r3, r3, r0
300222bc:	e5831000 	str	r1, [r3]
    /* get the packet pointer */
    p = q->p;
300222c0:	e59d301c 	ldr	r3, [sp, #28]
300222c4:	e5933004 	ldr	r3, [r3, #4]
300222c8:	e58d3018 	str	r3, [sp, #24]
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
300222cc:	e3a00009 	mov	r0, #9
300222d0:	e59d101c 	ldr	r1, [sp, #28]
300222d4:	ebffcd2a 	bl	30015784 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
300222d8:	e59d300c 	ldr	r3, [sp, #12]
300222dc:	e2833021 	add	r3, r3, #33	; 0x21
300222e0:	e59d000c 	ldr	r0, [sp, #12]
300222e4:	e59d1018 	ldr	r1, [sp, #24]
300222e8:	e1a02003 	mov	r2, r3
300222ec:	e59d3004 	ldr	r3, [sp, #4]
300222f0:	ebffff26 	bl	30021f90 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
300222f4:	e59d0018 	ldr	r0, [sp, #24]
300222f8:	ebffd08c 	bl	30016530 <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
300222fc:	e1dd21d6 	ldrsb	r2, [sp, #22]
30022300:	e59f1038 	ldr	r1, [pc, #56]	; 30022340 <update_arp_entry+0x2b4>
30022304:	e1a03002 	mov	r3, r2
30022308:	e1a03103 	lsl	r3, r3, #2
3002230c:	e0833002 	add	r3, r3, r2
30022310:	e1a03103 	lsl	r3, r3, #2
30022314:	e0833001 	add	r3, r3, r1
30022318:	e5933000 	ldr	r3, [r3]
3002231c:	e3530000 	cmp	r3, #0
30022320:	1affffd3 	bne	30022274 <update_arp_entry+0x1e8>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
30022324:	e3a03000 	mov	r3, #0
30022328:	e1a03c03 	lsl	r3, r3, #24
3002232c:	e1a03c43 	asr	r3, r3, #24
}
30022330:	e1a00003 	mov	r0, r3
30022334:	e28dd020 	add	sp, sp, #32
30022338:	e8bd4010 	pop	{r4, lr}
3002233c:	e12fff1e 	bx	lr
30022340:	30029fb0 	.word	0x30029fb0

30022344 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
30022344:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30022348:	e24dd01c 	sub	sp, sp, #28
3002234c:	e58d000c 	str	r0, [sp, #12]
30022350:	e58d1008 	str	r1, [sp, #8]
30022354:	e58d2004 	str	r2, [sp, #4]
30022358:	e58d3000 	str	r3, [sp]
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
3002235c:	e59d0008 	ldr	r0, [sp, #8]
30022360:	e3a01002 	mov	r1, #2
30022364:	ebfffd73 	bl	30021938 <find_entry>
30022368:	e1a03000 	mov	r3, r0
3002236c:	e20330ff 	and	r3, r3, #255	; 0xff
30022370:	e5cd3017 	strb	r3, [sp, #23]
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
30022374:	e1dd31d7 	ldrsb	r3, [sp, #23]
30022378:	e3530000 	cmp	r3, #0
3002237c:	ba000021 	blt	30022408 <etharp_find_addr+0xc4>
30022380:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022384:	e59f0098 	ldr	r0, [pc, #152]	; 30022424 <etharp_find_addr+0xe0>
30022388:	e3a01008 	mov	r1, #8
3002238c:	e1a03002 	mov	r3, r2
30022390:	e1a03103 	lsl	r3, r3, #2
30022394:	e0833002 	add	r3, r3, r2
30022398:	e1a03103 	lsl	r3, r3, #2
3002239c:	e0833000 	add	r3, r3, r0
300223a0:	e0833001 	add	r3, r3, r1
300223a4:	e5d33006 	ldrb	r3, [r3, #6]
300223a8:	e3530002 	cmp	r3, #2
300223ac:	1a000015 	bne	30022408 <etharp_find_addr+0xc4>
      *eth_ret = &arp_table[i].ethaddr;
300223b0:	e1dd21d7 	ldrsb	r2, [sp, #23]
300223b4:	e1a03002 	mov	r3, r2
300223b8:	e1a03103 	lsl	r3, r3, #2
300223bc:	e0833002 	add	r3, r3, r2
300223c0:	e1a03103 	lsl	r3, r3, #2
300223c4:	e2832008 	add	r2, r3, #8
300223c8:	e59f3054 	ldr	r3, [pc, #84]	; 30022424 <etharp_find_addr+0xe0>
300223cc:	e0822003 	add	r2, r2, r3
300223d0:	e59d3004 	ldr	r3, [sp, #4]
300223d4:	e5832000 	str	r2, [r3]
      *ip_ret = &arp_table[i].ipaddr;
300223d8:	e1dd21d7 	ldrsb	r2, [sp, #23]
300223dc:	e1a03002 	mov	r3, r2
300223e0:	e1a03103 	lsl	r3, r3, #2
300223e4:	e0833002 	add	r3, r3, r2
300223e8:	e1a02103 	lsl	r2, r3, #2
300223ec:	e59f3030 	ldr	r3, [pc, #48]	; 30022424 <etharp_find_addr+0xe0>
300223f0:	e0823003 	add	r3, r2, r3
300223f4:	e2832004 	add	r2, r3, #4
300223f8:	e59d3000 	ldr	r3, [sp]
300223fc:	e5832000 	str	r2, [r3]
      return i;
30022400:	e5dd3017 	ldrb	r3, [sp, #23]
30022404:	ea000000 	b	3002240c <etharp_find_addr+0xc8>
  }
  return -1;
30022408:	e3a030ff 	mov	r3, #255	; 0xff
3002240c:	e1a03c03 	lsl	r3, r3, #24
30022410:	e1a03c43 	asr	r3, r3, #24
}
30022414:	e1a00003 	mov	r0, r3
30022418:	e28dd01c 	add	sp, sp, #28
3002241c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30022420:	e12fff1e 	bx	lr
30022424:	30029fb0 	.word	0x30029fb0

30022428 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
30022428:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002242c:	e24dd014 	sub	sp, sp, #20
30022430:	e58d0004 	str	r0, [sp, #4]
30022434:	e58d1000 	str	r1, [sp]
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
30022438:	e59d3000 	ldr	r3, [sp]
3002243c:	e5933004 	ldr	r3, [r3, #4]
30022440:	e58d300c 	str	r3, [sp, #12]
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
30022444:	e59d300c 	ldr	r3, [sp, #12]
30022448:	e5d3201a 	ldrb	r2, [r3, #26]
3002244c:	e5d3101b 	ldrb	r1, [r3, #27]
30022450:	e1a01401 	lsl	r1, r1, #8
30022454:	e1812002 	orr	r2, r1, r2
30022458:	e5d3101c 	ldrb	r1, [r3, #28]
3002245c:	e1a01801 	lsl	r1, r1, #16
30022460:	e1812002 	orr	r2, r1, r2
30022464:	e5d3301d 	ldrb	r3, [r3, #29]
30022468:	e1a03c03 	lsl	r3, r3, #24
3002246c:	e1833002 	orr	r3, r3, r2
30022470:	e1a02003 	mov	r2, r3
30022474:	e59d3004 	ldr	r3, [sp, #4]
30022478:	e5933004 	ldr	r3, [r3, #4]
3002247c:	e0222003 	eor	r2, r2, r3
30022480:	e59d3004 	ldr	r3, [sp, #4]
30022484:	e5933008 	ldr	r3, [r3, #8]
30022488:	e0023003 	and	r3, r2, r3
3002248c:	e3530000 	cmp	r3, #0
30022490:	1a000009 	bne	300224bc <etharp_ip_input+0x94>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
30022494:	e59d300c 	ldr	r3, [sp, #12]
30022498:	e283201a 	add	r2, r3, #26
3002249c:	e59d300c 	ldr	r3, [sp, #12]
300224a0:	e2833006 	add	r3, r3, #6
300224a4:	e59d0004 	ldr	r0, [sp, #4]
300224a8:	e1a01002 	mov	r1, r2
300224ac:	e1a02003 	mov	r2, r3
300224b0:	e3a03000 	mov	r3, #0
300224b4:	ebfffef4 	bl	3002208c <update_arp_entry>
300224b8:	ea000000 	b	300224c0 <etharp_ip_input+0x98>
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
    /* do nothing */
    return;
300224bc:	e1a00000 	nop			; (mov r0, r0)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
}
300224c0:	e28dd014 	add	sp, sp, #20
300224c4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300224c8:	e12fff1e 	bx	lr

300224cc <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
300224cc:	e92d4010 	push	{r4, lr}
300224d0:	e24dd020 	sub	sp, sp, #32
300224d4:	e58d000c 	str	r0, [sp, #12]
300224d8:	e58d1008 	str	r1, [sp, #8]
300224dc:	e58d2004 	str	r2, [sp, #4]

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
300224e0:	e59d3004 	ldr	r3, [sp, #4]
300224e4:	e1d330ba 	ldrh	r3, [r3, #10]
300224e8:	e3530029 	cmp	r3, #41	; 0x29
300224ec:	8a000010 	bhi	30022534 <etharp_arp_input+0x68>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
300224f0:	e59f3410 	ldr	r3, [pc, #1040]	; 30022908 <etharp_arp_input+0x43c>
300224f4:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
300224f8:	e2833001 	add	r3, r3, #1
300224fc:	e1a03803 	lsl	r3, r3, #16
30022500:	e1a02823 	lsr	r2, r3, #16
30022504:	e59f33fc 	ldr	r3, [pc, #1020]	; 30022908 <etharp_arp_input+0x43c>
30022508:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
    ETHARP_STATS_INC(etharp.drop);
3002250c:	e59f33f4 	ldr	r3, [pc, #1012]	; 30022908 <etharp_arp_input+0x43c>
30022510:	e1d332b2 	ldrh	r3, [r3, #34]	; 0x22
30022514:	e2833001 	add	r3, r3, #1
30022518:	e1a03803 	lsl	r3, r3, #16
3002251c:	e1a02823 	lsr	r2, r3, #16
30022520:	e59f33e0 	ldr	r3, [pc, #992]	; 30022908 <etharp_arp_input+0x43c>
30022524:	e1c322b2 	strh	r2, [r3, #34]	; 0x22
    pbuf_free(p);
30022528:	e59d0004 	ldr	r0, [sp, #4]
3002252c:	ebffcfff 	bl	30016530 <pbuf_free>
    return;
30022530:	ea0000f1 	b	300228fc <etharp_arp_input+0x430>
  }

  hdr = p->payload;
30022534:	e59d3004 	ldr	r3, [sp, #4]
30022538:	e5933004 	ldr	r3, [r3, #4]
3002253c:	e58d3018 	str	r3, [sp, #24]

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
30022540:	e59d3018 	ldr	r3, [sp, #24]
30022544:	e5d3200e 	ldrb	r2, [r3, #14]
30022548:	e5d3300f 	ldrb	r3, [r3, #15]
3002254c:	e1a03403 	lsl	r3, r3, #8
30022550:	e1833002 	orr	r3, r3, r2
30022554:	e1a03803 	lsl	r3, r3, #16
30022558:	e1a04823 	lsr	r4, r3, #16
3002255c:	e3a00001 	mov	r0, #1
30022560:	ebffc4d5 	bl	300138bc <htons>
30022564:	e1a03000 	mov	r3, r0
30022568:	e1540003 	cmp	r4, r3
3002256c:	1a000025 	bne	30022608 <etharp_arp_input+0x13c>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
30022570:	e59d3018 	ldr	r3, [sp, #24]
30022574:	e5d32012 	ldrb	r2, [r3, #18]
30022578:	e5d33013 	ldrb	r3, [r3, #19]
3002257c:	e1a03403 	lsl	r3, r3, #8
30022580:	e1833002 	orr	r3, r3, r2
30022584:	e1a03803 	lsl	r3, r3, #16
30022588:	e1a04823 	lsr	r4, r3, #16
3002258c:	e3a00c06 	mov	r0, #1536	; 0x600
30022590:	e2800004 	add	r0, r0, #4
30022594:	ebffc4c8 	bl	300138bc <htons>
30022598:	e1a03000 	mov	r3, r0
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
3002259c:	e1540003 	cmp	r4, r3
300225a0:	1a000018 	bne	30022608 <etharp_arp_input+0x13c>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
300225a4:	e59d3018 	ldr	r3, [sp, #24]
300225a8:	e5d32010 	ldrb	r2, [r3, #16]
300225ac:	e5d33011 	ldrb	r3, [r3, #17]
300225b0:	e1a03403 	lsl	r3, r3, #8
300225b4:	e1833002 	orr	r3, r3, r2
300225b8:	e1a03803 	lsl	r3, r3, #16
300225bc:	e1a04823 	lsr	r4, r3, #16
300225c0:	e3a00b02 	mov	r0, #2048	; 0x800
300225c4:	ebffc4bc 	bl	300138bc <htons>
300225c8:	e1a03000 	mov	r3, r0
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
300225cc:	e1540003 	cmp	r4, r3
300225d0:	1a00000c 	bne	30022608 <etharp_arp_input+0x13c>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
300225d4:	e59d3018 	ldr	r3, [sp, #24]
300225d8:	e5d3200c 	ldrb	r2, [r3, #12]
300225dc:	e5d3300d 	ldrb	r3, [r3, #13]
300225e0:	e1a03403 	lsl	r3, r3, #8
300225e4:	e1833002 	orr	r3, r3, r2
300225e8:	e1a03803 	lsl	r3, r3, #16
300225ec:	e1a04823 	lsr	r4, r3, #16
300225f0:	e3a00b02 	mov	r0, #2048	; 0x800
300225f4:	e2800006 	add	r0, r0, #6
300225f8:	ebffc4af 	bl	300138bc <htons>
300225fc:	e1a03000 	mov	r3, r0
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
30022600:	e1540003 	cmp	r4, r3
30022604:	0a000010 	beq	3002264c <etharp_arp_input+0x180>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
30022608:	e59f32f8 	ldr	r3, [pc, #760]	; 30022908 <etharp_arp_input+0x43c>
3002260c:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
30022610:	e2833001 	add	r3, r3, #1
30022614:	e1a03803 	lsl	r3, r3, #16
30022618:	e1a02823 	lsr	r2, r3, #16
3002261c:	e59f32e4 	ldr	r3, [pc, #740]	; 30022908 <etharp_arp_input+0x43c>
30022620:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
    ETHARP_STATS_INC(etharp.drop);
30022624:	e59f32dc 	ldr	r3, [pc, #732]	; 30022908 <etharp_arp_input+0x43c>
30022628:	e1d332b2 	ldrh	r3, [r3, #34]	; 0x22
3002262c:	e2833001 	add	r3, r3, #1
30022630:	e1a03803 	lsl	r3, r3, #16
30022634:	e1a02823 	lsr	r2, r3, #16
30022638:	e59f32c8 	ldr	r3, [pc, #712]	; 30022908 <etharp_arp_input+0x43c>
3002263c:	e1c322b2 	strh	r2, [r3, #34]	; 0x22
    pbuf_free(p);
30022640:	e59d0004 	ldr	r0, [sp, #4]
30022644:	ebffcfb9 	bl	30016530 <pbuf_free>
    return;
30022648:	ea0000ab 	b	300228fc <etharp_arp_input+0x430>
  }
  ETHARP_STATS_INC(etharp.recv);
3002264c:	e59f32b4 	ldr	r3, [pc, #692]	; 30022908 <etharp_arp_input+0x43c>
30022650:	e1d331be 	ldrh	r3, [r3, #30]
30022654:	e2833001 	add	r3, r3, #1
30022658:	e1a03803 	lsl	r3, r3, #16
3002265c:	e1a02823 	lsr	r2, r3, #16
30022660:	e59f32a0 	ldr	r3, [pc, #672]	; 30022908 <etharp_arp_input+0x43c>
30022664:	e1c321be 	strh	r2, [r3, #30]
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
30022668:	e59d3018 	ldr	r3, [sp, #24]
3002266c:	e283301c 	add	r3, r3, #28
30022670:	e28d2014 	add	r2, sp, #20
30022674:	e1a00002 	mov	r0, r2
30022678:	e1a01003 	mov	r1, r3
3002267c:	e3a02004 	mov	r2, #4
30022680:	ebffaa31 	bl	3000cf4c <__re_memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
30022684:	e59d3018 	ldr	r3, [sp, #24]
30022688:	e2833026 	add	r3, r3, #38	; 0x26
3002268c:	e28d2010 	add	r2, sp, #16
30022690:	e1a00002 	mov	r0, r2
30022694:	e1a01003 	mov	r1, r3
30022698:	e3a02004 	mov	r2, #4
3002269c:	ebffaa2a 	bl	3000cf4c <__re_memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
300226a0:	e59d300c 	ldr	r3, [sp, #12]
300226a4:	e5933004 	ldr	r3, [r3, #4]
300226a8:	e3530000 	cmp	r3, #0
300226ac:	1a000002 	bne	300226bc <etharp_arp_input+0x1f0>
    for_us = 0;
300226b0:	e3a03000 	mov	r3, #0
300226b4:	e5cd301f 	strb	r3, [sp, #31]
300226b8:	ea000006 	b	300226d8 <etharp_arp_input+0x20c>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
300226bc:	e59d2010 	ldr	r2, [sp, #16]
300226c0:	e59d300c 	ldr	r3, [sp, #12]
300226c4:	e5933004 	ldr	r3, [r3, #4]
300226c8:	e1520003 	cmp	r2, r3
300226cc:	13a03000 	movne	r3, #0
300226d0:	03a03001 	moveq	r3, #1
300226d4:	e5cd301f 	strb	r3, [sp, #31]
  }

  /* ARP message directed to us? */
  if (for_us) {
300226d8:	e5dd301f 	ldrb	r3, [sp, #31]
300226dc:	e3530000 	cmp	r3, #0
300226e0:	0a000008 	beq	30022708 <etharp_arp_input+0x23c>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
300226e4:	e59d3018 	ldr	r3, [sp, #24]
300226e8:	e2833016 	add	r3, r3, #22
300226ec:	e28d2014 	add	r2, sp, #20
300226f0:	e59d000c 	ldr	r0, [sp, #12]
300226f4:	e1a01002 	mov	r1, r2
300226f8:	e1a02003 	mov	r2, r3
300226fc:	e3a03001 	mov	r3, #1
30022700:	ebfffe61 	bl	3002208c <update_arp_entry>
30022704:	ea000007 	b	30022728 <etharp_arp_input+0x25c>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
30022708:	e59d3018 	ldr	r3, [sp, #24]
3002270c:	e2833016 	add	r3, r3, #22
30022710:	e28d2014 	add	r2, sp, #20
30022714:	e59d000c 	ldr	r0, [sp, #12]
30022718:	e1a01002 	mov	r1, r2
3002271c:	e1a02003 	mov	r2, r3
30022720:	e3a03000 	mov	r3, #0
30022724:	ebfffe58 	bl	3002208c <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
30022728:	e59d3018 	ldr	r3, [sp, #24]
3002272c:	e5d32014 	ldrb	r2, [r3, #20]
30022730:	e5d33015 	ldrb	r3, [r3, #21]
30022734:	e1a03403 	lsl	r3, r3, #8
30022738:	e1833002 	orr	r3, r3, r2
3002273c:	e1a03803 	lsl	r3, r3, #16
30022740:	e1a03823 	lsr	r3, r3, #16
30022744:	e1a00003 	mov	r0, r3
30022748:	ebffc45b 	bl	300138bc <htons>
3002274c:	e1a03000 	mov	r3, r0
30022750:	e3530001 	cmp	r3, #1
30022754:	0a000002 	beq	30022764 <etharp_arp_input+0x298>
30022758:	e3530002 	cmp	r3, #2
3002275c:	0a000061 	beq	300228e8 <etharp_arp_input+0x41c>
30022760:	ea000058 	b	300228c8 <etharp_arp_input+0x3fc>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
30022764:	e5dd301f 	ldrb	r3, [sp, #31]
30022768:	e3530000 	cmp	r3, #0
3002276c:	0a00005f 	beq	300228f0 <etharp_arp_input+0x424>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
30022770:	e3a00002 	mov	r0, #2
30022774:	ebffc450 	bl	300138bc <htons>
30022778:	e1a03000 	mov	r3, r0
3002277c:	e1a02003 	mov	r2, r3
30022780:	e59d3018 	ldr	r3, [sp, #24]
30022784:	e20210ff 	and	r1, r2, #255	; 0xff
30022788:	e3a00000 	mov	r0, #0
3002278c:	e1801001 	orr	r1, r0, r1
30022790:	e5c31014 	strb	r1, [r3, #20]
30022794:	e1a02422 	lsr	r2, r2, #8
30022798:	e1a02802 	lsl	r2, r2, #16
3002279c:	e1a02822 	lsr	r2, r2, #16
300227a0:	e3a01000 	mov	r1, #0
300227a4:	e1812002 	orr	r2, r1, r2
300227a8:	e5c32015 	strb	r2, [r3, #21]
	  
	  //by pegasus0824
      //hdr->dipaddr = hdr->sipaddr;
      //hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
	  SMEMCPY(&hdr->dipaddr, &hdr->sipaddr, sizeof(sipaddr));
300227ac:	e59d3018 	ldr	r3, [sp, #24]
300227b0:	e2832026 	add	r2, r3, #38	; 0x26
300227b4:	e59d3018 	ldr	r3, [sp, #24]
300227b8:	e283301c 	add	r3, r3, #28
300227bc:	e1a00002 	mov	r0, r2
300227c0:	e1a01003 	mov	r1, r3
300227c4:	e3a02004 	mov	r2, #4
300227c8:	ebffa9df 	bl	3000cf4c <__re_memcpy>
	  SMEMCPY(&hdr->sipaddr, (struct ip_addr2 *)&netif->ip_addr, sizeof(dipaddr));
300227cc:	e59d3018 	ldr	r3, [sp, #24]
300227d0:	e283201c 	add	r2, r3, #28
300227d4:	e59d300c 	ldr	r3, [sp, #12]
300227d8:	e2833004 	add	r3, r3, #4
300227dc:	e1a00002 	mov	r0, r2
300227e0:	e1a01003 	mov	r1, r3
300227e4:	e3a02004 	mov	r2, #4
300227e8:	ebffa9d7 	bl	3000cf4c <__re_memcpy>

     
	  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
      i = ETHARP_HWADDR_LEN;
300227ec:	e3a03006 	mov	r3, #6
300227f0:	e5cd301e 	strb	r3, [sp, #30]
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
300227f4:	ea000029 	b	300228a0 <etharp_arp_input+0x3d4>
        i--;
300227f8:	e5dd301e 	ldrb	r3, [sp, #30]
300227fc:	e2433001 	sub	r3, r3, #1
30022800:	e5cd301e 	strb	r3, [sp, #30]
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
30022804:	e5dd001e 	ldrb	r0, [sp, #30]
30022808:	e5dd101e 	ldrb	r1, [sp, #30]
3002280c:	e59d2018 	ldr	r2, [sp, #24]
30022810:	e3a03016 	mov	r3, #22
30022814:	e0812002 	add	r2, r1, r2
30022818:	e0823003 	add	r3, r2, r3
3002281c:	e5d32000 	ldrb	r2, [r3]
30022820:	e59d1018 	ldr	r1, [sp, #24]
30022824:	e3a03020 	mov	r3, #32
30022828:	e0801001 	add	r1, r0, r1
3002282c:	e0813003 	add	r3, r1, r3
30022830:	e5c32000 	strb	r2, [r3]
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
30022834:	e5dd301e 	ldrb	r3, [sp, #30]
30022838:	e5dd001e 	ldrb	r0, [sp, #30]
3002283c:	e59d1018 	ldr	r1, [sp, #24]
30022840:	e3a02016 	mov	r2, #22
30022844:	e0801001 	add	r1, r0, r1
30022848:	e0812002 	add	r2, r1, r2
3002284c:	e5d21000 	ldrb	r1, [r2]
30022850:	e59d2018 	ldr	r2, [sp, #24]
30022854:	e7c21003 	strb	r1, [r2, r3]
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
30022858:	e5dd001e 	ldrb	r0, [sp, #30]
3002285c:	e5dd301e 	ldrb	r3, [sp, #30]
30022860:	e59d2008 	ldr	r2, [sp, #8]
30022864:	e7d22003 	ldrb	r2, [r2, r3]
30022868:	e59d1018 	ldr	r1, [sp, #24]
3002286c:	e3a03016 	mov	r3, #22
30022870:	e0801001 	add	r1, r0, r1
30022874:	e0813003 	add	r3, r1, r3
30022878:	e5c32000 	strb	r2, [r3]
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
3002287c:	e5dd001e 	ldrb	r0, [sp, #30]
30022880:	e5dd301e 	ldrb	r3, [sp, #30]
30022884:	e59d2008 	ldr	r2, [sp, #8]
30022888:	e7d22003 	ldrb	r2, [r2, r3]
3002288c:	e59d1018 	ldr	r1, [sp, #24]
30022890:	e3a03006 	mov	r3, #6
30022894:	e0801001 	add	r1, r0, r1
30022898:	e0813003 	add	r3, r1, r3
3002289c:	e5c32000 	strb	r2, [r3]
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
300228a0:	e5dd301e 	ldrb	r3, [sp, #30]
300228a4:	e3530000 	cmp	r3, #0
300228a8:	1affffd2 	bne	300227f8 <etharp_arp_input+0x32c>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
300228ac:	e59d300c 	ldr	r3, [sp, #12]
300228b0:	e5933018 	ldr	r3, [r3, #24]
300228b4:	e59d000c 	ldr	r0, [sp, #12]
300228b8:	e59d1004 	ldr	r1, [sp, #4]
300228bc:	e1a0e00f 	mov	lr, pc
300228c0:	e12fff13 	bx	r3
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
300228c4:	ea00000a 	b	300228f4 <etharp_arp_input+0x428>
    dhcp_arp_reply(netif, &sipaddr);
#endif
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
300228c8:	e59f3038 	ldr	r3, [pc, #56]	; 30022908 <etharp_arp_input+0x43c>
300228cc:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
300228d0:	e2833001 	add	r3, r3, #1
300228d4:	e1a03803 	lsl	r3, r3, #16
300228d8:	e1a02823 	lsr	r2, r3, #16
300228dc:	e59f3024 	ldr	r3, [pc, #36]	; 30022908 <etharp_arp_input+0x43c>
300228e0:	e1c323b0 	strh	r2, [r3, #48]	; 0x30
300228e4:	ea000002 	b	300228f4 <etharp_arp_input+0x428>
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
#endif
    break;
300228e8:	e1a00000 	nop			; (mov r0, r0)
300228ec:	ea000000 	b	300228f4 <etharp_arp_input+0x428>
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
300228f0:	e1a00000 	nop			; (mov r0, r0)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
300228f4:	e59d0004 	ldr	r0, [sp, #4]
300228f8:	ebffcf0c 	bl	30016530 <pbuf_free>
}
300228fc:	e28dd020 	add	sp, sp, #32
30022900:	e8bd4010 	pop	{r4, lr}
30022904:	e12fff1e 	bx	lr
30022908:	3002b214 	.word	0x3002b214

3002290c <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
3002290c:	e92d4010 	push	{r4, lr}
30022910:	e24dd020 	sub	sp, sp, #32
30022914:	e58d000c 	str	r0, [sp, #12]
30022918:	e58d1008 	str	r1, [sp, #8]
3002291c:	e58d2004 	str	r2, [sp, #4]
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
30022920:	e59d0008 	ldr	r0, [sp, #8]
30022924:	e3a0100e 	mov	r1, #14
30022928:	ebffce9b 	bl	3001639c <pbuf_header>
3002292c:	e1a03000 	mov	r3, r0
30022930:	e3530000 	cmp	r3, #0
30022934:	0a000008 	beq	3002295c <etharp_output+0x50>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
30022938:	e59f3264 	ldr	r3, [pc, #612]	; 30022ba4 <etharp_output+0x298>
3002293c:	e1d330bc 	ldrh	r3, [r3, #12]
30022940:	e2833001 	add	r3, r3, #1
30022944:	e1a03803 	lsl	r3, r3, #16
30022948:	e1a02823 	lsr	r2, r3, #16
3002294c:	e59f3250 	ldr	r3, [pc, #592]	; 30022ba4 <etharp_output+0x298>
30022950:	e1c320bc 	strh	r2, [r3, #12]
    return ERR_BUF;
30022954:	e3a030fe 	mov	r3, #254	; 0xfe
30022958:	ea00008b 	b	30022b8c <etharp_output+0x280>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
3002295c:	e3a03000 	mov	r3, #0
30022960:	e58d301c 	str	r3, [sp, #28]
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
30022964:	e59d0004 	ldr	r0, [sp, #4]
30022968:	e59d100c 	ldr	r1, [sp, #12]
3002296c:	ebffc968 	bl	30014f14 <ip_addr_isbroadcast>
30022970:	e1a03000 	mov	r3, r0
30022974:	e3530000 	cmp	r3, #0
30022978:	0a000002 	beq	30022988 <etharp_output+0x7c>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
3002297c:	e59f3224 	ldr	r3, [pc, #548]	; 30022ba8 <etharp_output+0x29c>
30022980:	e58d301c 	str	r3, [sp, #28]
30022984:	ea000076 	b	30022b64 <etharp_output+0x258>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
30022988:	e59d3004 	ldr	r3, [sp, #4]
3002298c:	e5d32000 	ldrb	r2, [r3]
30022990:	e5d31001 	ldrb	r1, [r3, #1]
30022994:	e1a01401 	lsl	r1, r1, #8
30022998:	e1812002 	orr	r2, r1, r2
3002299c:	e5d31002 	ldrb	r1, [r3, #2]
300229a0:	e1a01801 	lsl	r1, r1, #16
300229a4:	e1812002 	orr	r2, r1, r2
300229a8:	e5d33003 	ldrb	r3, [r3, #3]
300229ac:	e1a03c03 	lsl	r3, r3, #24
300229b0:	e1833002 	orr	r3, r3, r2
300229b4:	e1a04003 	mov	r4, r3
300229b8:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
300229bc:	ebffc3ef 	bl	30013980 <ntohl>
300229c0:	e1a03000 	mov	r3, r0
300229c4:	e0044003 	and	r4, r4, r3
300229c8:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
300229cc:	ebffc3eb 	bl	30013980 <ntohl>
300229d0:	e1a03000 	mov	r3, r0
300229d4:	e1540003 	cmp	r4, r3
300229d8:	1a00003b 	bne	30022acc <etharp_output+0x1c0>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
300229dc:	e3a03001 	mov	r3, #1
300229e0:	e5cd3014 	strb	r3, [sp, #20]
    mcastaddr.addr[1] = 0x00;
300229e4:	e3a03000 	mov	r3, #0
300229e8:	e5cd3015 	strb	r3, [sp, #21]
    mcastaddr.addr[2] = 0x5e;
300229ec:	e3a0305e 	mov	r3, #94	; 0x5e
300229f0:	e5cd3016 	strb	r3, [sp, #22]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
300229f4:	e59d3004 	ldr	r3, [sp, #4]
300229f8:	e5d32000 	ldrb	r2, [r3]
300229fc:	e5d31001 	ldrb	r1, [r3, #1]
30022a00:	e1a01401 	lsl	r1, r1, #8
30022a04:	e1812002 	orr	r2, r1, r2
30022a08:	e5d31002 	ldrb	r1, [r3, #2]
30022a0c:	e1a01801 	lsl	r1, r1, #16
30022a10:	e1812002 	orr	r2, r1, r2
30022a14:	e5d33003 	ldrb	r3, [r3, #3]
30022a18:	e1a03c03 	lsl	r3, r3, #24
30022a1c:	e1833002 	orr	r3, r3, r2
30022a20:	e1a00003 	mov	r0, r3
30022a24:	ebffc3d5 	bl	30013980 <ntohl>
30022a28:	e1a03000 	mov	r3, r0
30022a2c:	e1a03823 	lsr	r3, r3, #16
30022a30:	e20330ff 	and	r3, r3, #255	; 0xff
30022a34:	e203307f 	and	r3, r3, #127	; 0x7f
30022a38:	e5cd3017 	strb	r3, [sp, #23]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
30022a3c:	e59d3004 	ldr	r3, [sp, #4]
30022a40:	e5d32000 	ldrb	r2, [r3]
30022a44:	e5d31001 	ldrb	r1, [r3, #1]
30022a48:	e1a01401 	lsl	r1, r1, #8
30022a4c:	e1812002 	orr	r2, r1, r2
30022a50:	e5d31002 	ldrb	r1, [r3, #2]
30022a54:	e1a01801 	lsl	r1, r1, #16
30022a58:	e1812002 	orr	r2, r1, r2
30022a5c:	e5d33003 	ldrb	r3, [r3, #3]
30022a60:	e1a03c03 	lsl	r3, r3, #24
30022a64:	e1833002 	orr	r3, r3, r2
30022a68:	e1a00003 	mov	r0, r3
30022a6c:	ebffc3c3 	bl	30013980 <ntohl>
30022a70:	e1a03000 	mov	r3, r0
30022a74:	e1a03423 	lsr	r3, r3, #8
30022a78:	e20330ff 	and	r3, r3, #255	; 0xff
30022a7c:	e5cd3018 	strb	r3, [sp, #24]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
30022a80:	e59d3004 	ldr	r3, [sp, #4]
30022a84:	e5d32000 	ldrb	r2, [r3]
30022a88:	e5d31001 	ldrb	r1, [r3, #1]
30022a8c:	e1a01401 	lsl	r1, r1, #8
30022a90:	e1812002 	orr	r2, r1, r2
30022a94:	e5d31002 	ldrb	r1, [r3, #2]
30022a98:	e1a01801 	lsl	r1, r1, #16
30022a9c:	e1812002 	orr	r2, r1, r2
30022aa0:	e5d33003 	ldrb	r3, [r3, #3]
30022aa4:	e1a03c03 	lsl	r3, r3, #24
30022aa8:	e1833002 	orr	r3, r3, r2
30022aac:	e1a00003 	mov	r0, r3
30022ab0:	ebffc3b2 	bl	30013980 <ntohl>
30022ab4:	e1a03000 	mov	r3, r0
30022ab8:	e20330ff 	and	r3, r3, #255	; 0xff
30022abc:	e5cd3019 	strb	r3, [sp, #25]
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
30022ac0:	e28d3014 	add	r3, sp, #20
30022ac4:	e58d301c 	str	r3, [sp, #28]
30022ac8:	ea000025 	b	30022b64 <etharp_output+0x258>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
30022acc:	e59d3004 	ldr	r3, [sp, #4]
30022ad0:	e5d32000 	ldrb	r2, [r3]
30022ad4:	e5d31001 	ldrb	r1, [r3, #1]
30022ad8:	e1a01401 	lsl	r1, r1, #8
30022adc:	e1812002 	orr	r2, r1, r2
30022ae0:	e5d31002 	ldrb	r1, [r3, #2]
30022ae4:	e1a01801 	lsl	r1, r1, #16
30022ae8:	e1812002 	orr	r2, r1, r2
30022aec:	e5d33003 	ldrb	r3, [r3, #3]
30022af0:	e1a03c03 	lsl	r3, r3, #24
30022af4:	e1833002 	orr	r3, r3, r2
30022af8:	e1a02003 	mov	r2, r3
30022afc:	e59d300c 	ldr	r3, [sp, #12]
30022b00:	e5933004 	ldr	r3, [r3, #4]
30022b04:	e0222003 	eor	r2, r2, r3
30022b08:	e59d300c 	ldr	r3, [sp, #12]
30022b0c:	e5933008 	ldr	r3, [r3, #8]
30022b10:	e0023003 	and	r3, r2, r3
30022b14:	e3530000 	cmp	r3, #0
30022b18:	0a000009 	beq	30022b44 <etharp_output+0x238>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
30022b1c:	e59d300c 	ldr	r3, [sp, #12]
30022b20:	e593300c 	ldr	r3, [r3, #12]
30022b24:	e3530000 	cmp	r3, #0
30022b28:	0a000003 	beq	30022b3c <etharp_output+0x230>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
30022b2c:	e59d300c 	ldr	r3, [sp, #12]
30022b30:	e283300c 	add	r3, r3, #12
30022b34:	e58d3004 	str	r3, [sp, #4]
30022b38:	ea000001 	b	30022b44 <etharp_output+0x238>
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
30022b3c:	e3a030fd 	mov	r3, #253	; 0xfd
30022b40:	ea000011 	b	30022b8c <etharp_output+0x280>
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
30022b44:	e59d000c 	ldr	r0, [sp, #12]
30022b48:	e59d1004 	ldr	r1, [sp, #4]
30022b4c:	e59d2008 	ldr	r2, [sp, #8]
30022b50:	eb000015 	bl	30022bac <etharp_query>
30022b54:	e1a03000 	mov	r3, r0
30022b58:	e20330ff 	and	r3, r3, #255	; 0xff
30022b5c:	e20330ff 	and	r3, r3, #255	; 0xff
30022b60:	ea000009 	b	30022b8c <etharp_output+0x280>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
30022b64:	e59d300c 	ldr	r3, [sp, #12]
30022b68:	e2833021 	add	r3, r3, #33	; 0x21
30022b6c:	e59d000c 	ldr	r0, [sp, #12]
30022b70:	e59d1008 	ldr	r1, [sp, #8]
30022b74:	e1a02003 	mov	r2, r3
30022b78:	e59d301c 	ldr	r3, [sp, #28]
30022b7c:	ebfffd03 	bl	30021f90 <etharp_send_ip>
30022b80:	e1a03000 	mov	r3, r0
30022b84:	e20330ff 	and	r3, r3, #255	; 0xff
30022b88:	e20330ff 	and	r3, r3, #255	; 0xff
30022b8c:	e1a03c03 	lsl	r3, r3, #24
30022b90:	e1a03c43 	asr	r3, r3, #24
}
30022b94:	e1a00003 	mov	r0, r3
30022b98:	e28dd020 	add	sp, sp, #32
30022b9c:	e8bd4010 	pop	{r4, lr}
30022ba0:	e12fff1e 	bx	lr
30022ba4:	3002b214 	.word	0x3002b214
30022ba8:	300265dc 	.word	0x300265dc

30022bac <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
30022bac:	e92d4010 	push	{r4, lr}
30022bb0:	e24dd028 	sub	sp, sp, #40	; 0x28
30022bb4:	e58d000c 	str	r0, [sp, #12]
30022bb8:	e58d1008 	str	r1, [sp, #8]
30022bbc:	e58d2004 	str	r2, [sp, #4]
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
30022bc0:	e59d300c 	ldr	r3, [sp, #12]
30022bc4:	e2833021 	add	r3, r3, #33	; 0x21
30022bc8:	e58d3010 	str	r3, [sp, #16]
  err_t result = ERR_MEM;
30022bcc:	e3e03000 	mvn	r3, #0
30022bd0:	e5cd3016 	strb	r3, [sp, #22]
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
30022bd4:	e59d0008 	ldr	r0, [sp, #8]
30022bd8:	e59d100c 	ldr	r1, [sp, #12]
30022bdc:	ebffc8cc 	bl	30014f14 <ip_addr_isbroadcast>
30022be0:	e1a03000 	mov	r3, r0
30022be4:	e3530000 	cmp	r3, #0
30022be8:	1a000024 	bne	30022c80 <etharp_query+0xd4>
      ip_addr_ismulticast(ipaddr) ||
30022bec:	e59d3008 	ldr	r3, [sp, #8]
30022bf0:	e5d32000 	ldrb	r2, [r3]
30022bf4:	e5d31001 	ldrb	r1, [r3, #1]
30022bf8:	e1a01401 	lsl	r1, r1, #8
30022bfc:	e1812002 	orr	r2, r1, r2
30022c00:	e5d31002 	ldrb	r1, [r3, #2]
30022c04:	e1a01801 	lsl	r1, r1, #16
30022c08:	e1812002 	orr	r2, r1, r2
30022c0c:	e5d33003 	ldrb	r3, [r3, #3]
30022c10:	e1a03c03 	lsl	r3, r3, #24
30022c14:	e1833002 	orr	r3, r3, r2
30022c18:	e1a04003 	mov	r4, r3
30022c1c:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
30022c20:	ebffc356 	bl	30013980 <ntohl>
30022c24:	e1a03000 	mov	r3, r0
30022c28:	e0044003 	and	r4, r4, r3
30022c2c:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
30022c30:	ebffc352 	bl	30013980 <ntohl>
30022c34:	e1a03000 	mov	r3, r0
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
30022c38:	e1540003 	cmp	r4, r3
30022c3c:	0a00000f 	beq	30022c80 <etharp_query+0xd4>
30022c40:	e59d3008 	ldr	r3, [sp, #8]
30022c44:	e3530000 	cmp	r3, #0
30022c48:	0a00000c 	beq	30022c80 <etharp_query+0xd4>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
30022c4c:	e59d3008 	ldr	r3, [sp, #8]
30022c50:	e5d32000 	ldrb	r2, [r3]
30022c54:	e5d31001 	ldrb	r1, [r3, #1]
30022c58:	e1a01401 	lsl	r1, r1, #8
30022c5c:	e1812002 	orr	r2, r1, r2
30022c60:	e5d31002 	ldrb	r1, [r3, #2]
30022c64:	e1a01801 	lsl	r1, r1, #16
30022c68:	e1812002 	orr	r2, r1, r2
30022c6c:	e5d33003 	ldrb	r3, [r3, #3]
30022c70:	e1a03c03 	lsl	r3, r3, #24
30022c74:	e1833002 	orr	r3, r3, r2
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
30022c78:	e3530000 	cmp	r3, #0
30022c7c:	1a000001 	bne	30022c88 <etharp_query+0xdc>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
30022c80:	e3a030f7 	mov	r3, #247	; 0xf7
30022c84:	ea0000e5 	b	30023020 <etharp_query+0x474>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
30022c88:	e59d0008 	ldr	r0, [sp, #8]
30022c8c:	e3a01001 	mov	r1, #1
30022c90:	ebfffb28 	bl	30021938 <find_entry>
30022c94:	e1a03000 	mov	r3, r0
30022c98:	e20330ff 	and	r3, r3, #255	; 0xff
30022c9c:	e5cd3017 	strb	r3, [sp, #23]
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
30022ca0:	e1dd31d7 	ldrsb	r3, [sp, #23]
30022ca4:	e3530000 	cmp	r3, #0
30022ca8:	aa00000b 	bge	30022cdc <etharp_query+0x130>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
30022cac:	e59d3004 	ldr	r3, [sp, #4]
30022cb0:	e3530000 	cmp	r3, #0
30022cb4:	0a000006 	beq	30022cd4 <etharp_query+0x128>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
30022cb8:	e59f3378 	ldr	r3, [pc, #888]	; 30023038 <etharp_query+0x48c>
30022cbc:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
30022cc0:	e2833001 	add	r3, r3, #1
30022cc4:	e1a03803 	lsl	r3, r3, #16
30022cc8:	e1a02823 	lsr	r2, r3, #16
30022ccc:	e59f3364 	ldr	r3, [pc, #868]	; 30023038 <etharp_query+0x48c>
30022cd0:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
    }
    return (err_t)i;
30022cd4:	e5dd3017 	ldrb	r3, [sp, #23]
30022cd8:	ea0000d0 	b	30023020 <etharp_query+0x474>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
30022cdc:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022ce0:	e59f0354 	ldr	r0, [pc, #852]	; 3002303c <etharp_query+0x490>
30022ce4:	e3a01008 	mov	r1, #8
30022ce8:	e1a03002 	mov	r3, r2
30022cec:	e1a03103 	lsl	r3, r3, #2
30022cf0:	e0833002 	add	r3, r3, r2
30022cf4:	e1a03103 	lsl	r3, r3, #2
30022cf8:	e0833000 	add	r3, r3, r0
30022cfc:	e0833001 	add	r3, r3, r1
30022d00:	e5d33006 	ldrb	r3, [r3, #6]
30022d04:	e3530000 	cmp	r3, #0
30022d08:	1a00000a 	bne	30022d38 <etharp_query+0x18c>
    arp_table[i].state = ETHARP_STATE_PENDING;
30022d0c:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022d10:	e59f0324 	ldr	r0, [pc, #804]	; 3002303c <etharp_query+0x490>
30022d14:	e3a01008 	mov	r1, #8
30022d18:	e1a03002 	mov	r3, r2
30022d1c:	e1a03103 	lsl	r3, r3, #2
30022d20:	e0833002 	add	r3, r3, r2
30022d24:	e1a03103 	lsl	r3, r3, #2
30022d28:	e0833000 	add	r3, r3, r0
30022d2c:	e0833001 	add	r3, r3, r1
30022d30:	e3a02001 	mov	r2, #1
30022d34:	e5c32006 	strb	r2, [r3, #6]
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
30022d38:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022d3c:	e59f02f8 	ldr	r0, [pc, #760]	; 3002303c <etharp_query+0x490>
30022d40:	e3a01008 	mov	r1, #8
30022d44:	e1a03002 	mov	r3, r2
30022d48:	e1a03103 	lsl	r3, r3, #2
30022d4c:	e0833002 	add	r3, r3, r2
30022d50:	e1a03103 	lsl	r3, r3, #2
30022d54:	e0833000 	add	r3, r3, r0
30022d58:	e0833001 	add	r3, r3, r1
30022d5c:	e5d33006 	ldrb	r3, [r3, #6]
30022d60:	e3530001 	cmp	r3, #1
30022d64:	0a000002 	beq	30022d74 <etharp_query+0x1c8>
30022d68:	e59d3004 	ldr	r3, [sp, #4]
30022d6c:	e3530000 	cmp	r3, #0
30022d70:	1a000005 	bne	30022d8c <etharp_query+0x1e0>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
30022d74:	e59d000c 	ldr	r0, [sp, #12]
30022d78:	e59d1008 	ldr	r1, [sp, #8]
30022d7c:	eb00016c 	bl	30023334 <etharp_request>
30022d80:	e1a03000 	mov	r3, r0
30022d84:	e20330ff 	and	r3, r3, #255	; 0xff
30022d88:	e5cd3016 	strb	r3, [sp, #22]
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
30022d8c:	e59d3004 	ldr	r3, [sp, #4]
30022d90:	e3530000 	cmp	r3, #0
30022d94:	0a0000a0 	beq	3002301c <etharp_query+0x470>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
30022d98:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022d9c:	e59f0298 	ldr	r0, [pc, #664]	; 3002303c <etharp_query+0x490>
30022da0:	e3a01008 	mov	r1, #8
30022da4:	e1a03002 	mov	r3, r2
30022da8:	e1a03103 	lsl	r3, r3, #2
30022dac:	e0833002 	add	r3, r3, r2
30022db0:	e1a03103 	lsl	r3, r3, #2
30022db4:	e0833000 	add	r3, r3, r0
30022db8:	e0833001 	add	r3, r3, r1
30022dbc:	e5d33006 	ldrb	r3, [r3, #6]
30022dc0:	e3530002 	cmp	r3, #2
30022dc4:	1a00000f 	bne	30022e08 <etharp_query+0x25c>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
30022dc8:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022dcc:	e1a03002 	mov	r3, r2
30022dd0:	e1a03103 	lsl	r3, r3, #2
30022dd4:	e0833002 	add	r3, r3, r2
30022dd8:	e1a03103 	lsl	r3, r3, #2
30022ddc:	e2832008 	add	r2, r3, #8
30022de0:	e59f3254 	ldr	r3, [pc, #596]	; 3002303c <etharp_query+0x490>
30022de4:	e0823003 	add	r3, r2, r3
30022de8:	e59d000c 	ldr	r0, [sp, #12]
30022dec:	e59d1004 	ldr	r1, [sp, #4]
30022df0:	e59d2010 	ldr	r2, [sp, #16]
30022df4:	ebfffc65 	bl	30021f90 <etharp_send_ip>
30022df8:	e1a03000 	mov	r3, r0
30022dfc:	e20330ff 	and	r3, r3, #255	; 0xff
30022e00:	e5cd3016 	strb	r3, [sp, #22]
30022e04:	ea000084 	b	3002301c <etharp_query+0x470>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
30022e08:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022e0c:	e59f0228 	ldr	r0, [pc, #552]	; 3002303c <etharp_query+0x490>
30022e10:	e3a01008 	mov	r1, #8
30022e14:	e1a03002 	mov	r3, r2
30022e18:	e1a03103 	lsl	r3, r3, #2
30022e1c:	e0833002 	add	r3, r3, r2
30022e20:	e1a03103 	lsl	r3, r3, #2
30022e24:	e0833000 	add	r3, r3, r0
30022e28:	e0833001 	add	r3, r3, r1
30022e2c:	e5d33006 	ldrb	r3, [r3, #6]
30022e30:	e3530001 	cmp	r3, #1
30022e34:	1a000078 	bne	3002301c <etharp_query+0x470>
#if ARP_QUEUEING /* queue the given q packet */
      struct pbuf *p;
      int copy_needed = 0;
30022e38:	e3a03000 	mov	r3, #0
30022e3c:	e58d301c 	str	r3, [sp, #28]
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
30022e40:	e59d3004 	ldr	r3, [sp, #4]
30022e44:	e58d3018 	str	r3, [sp, #24]
      while (p) {
30022e48:	ea000009 	b	30022e74 <etharp_query+0x2c8>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
        if(p->type != PBUF_ROM) {
30022e4c:	e59d3018 	ldr	r3, [sp, #24]
30022e50:	e5d3300c 	ldrb	r3, [r3, #12]
30022e54:	e3530001 	cmp	r3, #1
30022e58:	0a000002 	beq	30022e68 <etharp_query+0x2bc>
          copy_needed = 1;
30022e5c:	e3a03001 	mov	r3, #1
30022e60:	e58d301c 	str	r3, [sp, #28]
          break;
30022e64:	ea000005 	b	30022e80 <etharp_query+0x2d4>
        }
        p = p->next;
30022e68:	e59d3018 	ldr	r3, [sp, #24]
30022e6c:	e5933000 	ldr	r3, [r3]
30022e70:	e58d3018 	str	r3, [sp, #24]
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
30022e74:	e59d3018 	ldr	r3, [sp, #24]
30022e78:	e3530000 	cmp	r3, #0
30022e7c:	1afffff2 	bne	30022e4c <etharp_query+0x2a0>
          copy_needed = 1;
          break;
        }
        p = p->next;
      }
      if(copy_needed) {
30022e80:	e59d301c 	ldr	r3, [sp, #28]
30022e84:	e3530000 	cmp	r3, #0
30022e88:	0a000016 	beq	30022ee8 <etharp_query+0x33c>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
30022e8c:	e59d3018 	ldr	r3, [sp, #24]
30022e90:	e1d330b8 	ldrh	r3, [r3, #8]
30022e94:	e3a00003 	mov	r0, #3
30022e98:	e1a01003 	mov	r1, r3
30022e9c:	e3a02000 	mov	r2, #0
30022ea0:	ebffcbf3 	bl	30015e74 <pbuf_alloc>
30022ea4:	e1a03000 	mov	r3, r0
30022ea8:	e58d3018 	str	r3, [sp, #24]
        if(p != NULL) {
30022eac:	e59d3018 	ldr	r3, [sp, #24]
30022eb0:	e3530000 	cmp	r3, #0
30022eb4:	0a000010 	beq	30022efc <etharp_query+0x350>
          if (pbuf_copy(p, q) != ERR_OK) {
30022eb8:	e59d0018 	ldr	r0, [sp, #24]
30022ebc:	e59d1004 	ldr	r1, [sp, #4]
30022ec0:	ebffce60 	bl	30016848 <pbuf_copy>
30022ec4:	e1a03000 	mov	r3, r0
30022ec8:	e20330ff 	and	r3, r3, #255	; 0xff
30022ecc:	e3530000 	cmp	r3, #0
30022ed0:	0a00000b 	beq	30022f04 <etharp_query+0x358>
            pbuf_free(p);
30022ed4:	e59d0018 	ldr	r0, [sp, #24]
30022ed8:	ebffcd94 	bl	30016530 <pbuf_free>
            p = NULL;
30022edc:	e3a03000 	mov	r3, #0
30022ee0:	e58d3018 	str	r3, [sp, #24]
30022ee4:	ea000007 	b	30022f08 <etharp_query+0x35c>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
30022ee8:	e59d3004 	ldr	r3, [sp, #4]
30022eec:	e58d3018 	str	r3, [sp, #24]
        pbuf_ref(p);
30022ef0:	e59d0018 	ldr	r0, [sp, #24]
30022ef4:	ebffcde5 	bl	30016690 <pbuf_ref>
30022ef8:	ea000002 	b	30022f08 <etharp_query+0x35c>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
        if(p != NULL) {
          if (pbuf_copy(p, q) != ERR_OK) {
            pbuf_free(p);
            p = NULL;
30022efc:	e1a00000 	nop			; (mov r0, r0)
30022f00:	ea000000 	b	30022f08 <etharp_query+0x35c>
30022f04:	e1a00000 	nop			; (mov r0, r0)
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
      }
      /* packet could be taken over? */
      if (p != NULL) {
30022f08:	e59d3018 	ldr	r3, [sp, #24]
30022f0c:	e3530000 	cmp	r3, #0
30022f10:	0a00003a 	beq	30023000 <etharp_query+0x454>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
30022f14:	e3a00009 	mov	r0, #9
30022f18:	ebffc9b4 	bl	300155f0 <memp_malloc>
30022f1c:	e1a03000 	mov	r3, r0
30022f20:	e58d3020 	str	r3, [sp, #32]
        if (new_entry != NULL) {
30022f24:	e59d3020 	ldr	r3, [sp, #32]
30022f28:	e3530000 	cmp	r3, #0
30022f2c:	0a000030 	beq	30022ff4 <etharp_query+0x448>
          new_entry->next = 0;
30022f30:	e59d3020 	ldr	r3, [sp, #32]
30022f34:	e3a02000 	mov	r2, #0
30022f38:	e5832000 	str	r2, [r3]
          new_entry->p = p;
30022f3c:	e59d3020 	ldr	r3, [sp, #32]
30022f40:	e59d2018 	ldr	r2, [sp, #24]
30022f44:	e5832004 	str	r2, [r3, #4]
          if(arp_table[i].q != NULL) {
30022f48:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022f4c:	e59f10e8 	ldr	r1, [pc, #232]	; 3002303c <etharp_query+0x490>
30022f50:	e1a03002 	mov	r3, r2
30022f54:	e1a03103 	lsl	r3, r3, #2
30022f58:	e0833002 	add	r3, r3, r2
30022f5c:	e1a03103 	lsl	r3, r3, #2
30022f60:	e0833001 	add	r3, r3, r1
30022f64:	e5933000 	ldr	r3, [r3]
30022f68:	e3530000 	cmp	r3, #0
30022f6c:	0a000014 	beq	30022fc4 <etharp_query+0x418>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
30022f70:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022f74:	e59f10c0 	ldr	r1, [pc, #192]	; 3002303c <etharp_query+0x490>
30022f78:	e1a03002 	mov	r3, r2
30022f7c:	e1a03103 	lsl	r3, r3, #2
30022f80:	e0833002 	add	r3, r3, r2
30022f84:	e1a03103 	lsl	r3, r3, #2
30022f88:	e0833001 	add	r3, r3, r1
30022f8c:	e5933000 	ldr	r3, [r3]
30022f90:	e58d3024 	str	r3, [sp, #36]	; 0x24
            while (r->next != NULL) {
30022f94:	ea000002 	b	30022fa4 <etharp_query+0x3f8>
              r = r->next;
30022f98:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30022f9c:	e5933000 	ldr	r3, [r3]
30022fa0:	e58d3024 	str	r3, [sp, #36]	; 0x24
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
30022fa4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30022fa8:	e5933000 	ldr	r3, [r3]
30022fac:	e3530000 	cmp	r3, #0
30022fb0:	1afffff8 	bne	30022f98 <etharp_query+0x3ec>
              r = r->next;
            }
            r->next = new_entry;
30022fb4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30022fb8:	e59d2020 	ldr	r2, [sp, #32]
30022fbc:	e5832000 	str	r2, [r3]
30022fc0:	ea000008 	b	30022fe8 <etharp_query+0x43c>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
30022fc4:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022fc8:	e59f106c 	ldr	r1, [pc, #108]	; 3002303c <etharp_query+0x490>
30022fcc:	e1a03002 	mov	r3, r2
30022fd0:	e1a03103 	lsl	r3, r3, #2
30022fd4:	e0833002 	add	r3, r3, r2
30022fd8:	e1a03103 	lsl	r3, r3, #2
30022fdc:	e0833001 	add	r3, r3, r1
30022fe0:	e59d2020 	ldr	r2, [sp, #32]
30022fe4:	e5832000 	str	r2, [r3]
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
30022fe8:	e3a03000 	mov	r3, #0
30022fec:	e5cd3016 	strb	r3, [sp, #22]
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
30022ff0:	ea000009 	b	3002301c <etharp_query+0x470>
30022ff4:	e59d0018 	ldr	r0, [sp, #24]
30022ff8:	ebffcd4c 	bl	30016530 <pbuf_free>
30022ffc:	ea000006 	b	3002301c <etharp_query+0x470>
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
          /* { result == ERR_MEM } through initialization */
        }
      } else {
        ETHARP_STATS_INC(etharp.memerr);
30023000:	e59f3030 	ldr	r3, [pc, #48]	; 30023038 <etharp_query+0x48c>
30023004:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
30023008:	e2833001 	add	r3, r3, #1
3002300c:	e1a03803 	lsl	r3, r3, #16
30023010:	e1a02823 	lsr	r2, r3, #16
30023014:	e59f301c 	ldr	r3, [pc, #28]	; 30023038 <etharp_query+0x48c>
30023018:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
      /* { result == ERR_MEM } through initialization */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
3002301c:	e5dd3016 	ldrb	r3, [sp, #22]
30023020:	e1a03c03 	lsl	r3, r3, #24
30023024:	e1a03c43 	asr	r3, r3, #24
}
30023028:	e1a00003 	mov	r0, r3
3002302c:	e28dd028 	add	sp, sp, #40	; 0x28
30023030:	e8bd4010 	pop	{r4, lr}
30023034:	e12fff1e 	bx	lr
30023038:	3002b214 	.word	0x3002b214
3002303c:	30029fb0 	.word	0x30029fb0

30023040 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const struct ip_addr *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const struct ip_addr *ipdst_addr,
           const u16_t opcode)
{
30023040:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023044:	e24dd024 	sub	sp, sp, #36	; 0x24
30023048:	e58d000c 	str	r0, [sp, #12]
3002304c:	e58d1008 	str	r1, [sp, #8]
30023050:	e58d2004 	str	r2, [sp, #4]
30023054:	e58d3000 	str	r3, [sp]
  struct pbuf *p;
  err_t result = ERR_OK;
30023058:	e3a03000 	mov	r3, #0
3002305c:	e5cd301a 	strb	r3, [sp, #26]
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
30023060:	e3a00002 	mov	r0, #2
30023064:	e3a0102a 	mov	r1, #42	; 0x2a
30023068:	e3a02000 	mov	r2, #0
3002306c:	ebffcb80 	bl	30015e74 <pbuf_alloc>
30023070:	e1a03000 	mov	r3, r0
30023074:	e58d3014 	str	r3, [sp, #20]
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
30023078:	e59d3014 	ldr	r3, [sp, #20]
3002307c:	e3530000 	cmp	r3, #0
30023080:	1a000008 	bne	300230a8 <etharp_raw+0x68>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
30023084:	e59f32a4 	ldr	r3, [pc, #676]	; 30023330 <etharp_raw+0x2f0>
30023088:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
3002308c:	e2833001 	add	r3, r3, #1
30023090:	e1a03803 	lsl	r3, r3, #16
30023094:	e1a02823 	lsr	r2, r3, #16
30023098:	e59f3290 	ldr	r3, [pc, #656]	; 30023330 <etharp_raw+0x2f0>
3002309c:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
    return ERR_MEM;
300230a0:	e3a030ff 	mov	r3, #255	; 0xff
300230a4:	ea00009b 	b	30023318 <etharp_raw+0x2d8>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
300230a8:	e59d3014 	ldr	r3, [sp, #20]
300230ac:	e5933004 	ldr	r3, [r3, #4]
300230b0:	e58d301c 	str	r3, [sp, #28]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
300230b4:	e1dd33b4 	ldrh	r3, [sp, #52]	; 0x34
300230b8:	e1a00003 	mov	r0, r3
300230bc:	ebffc1fe 	bl	300138bc <htons>
300230c0:	e1a03000 	mov	r3, r0
300230c4:	e1a02003 	mov	r2, r3
300230c8:	e59d301c 	ldr	r3, [sp, #28]
300230cc:	e20210ff 	and	r1, r2, #255	; 0xff
300230d0:	e3a00000 	mov	r0, #0
300230d4:	e1801001 	orr	r1, r0, r1
300230d8:	e5c31014 	strb	r1, [r3, #20]
300230dc:	e1a02422 	lsr	r2, r2, #8
300230e0:	e1a02802 	lsl	r2, r2, #16
300230e4:	e1a02822 	lsr	r2, r2, #16
300230e8:	e3a01000 	mov	r1, #0
300230ec:	e1812002 	orr	r2, r1, r2
300230f0:	e5c32015 	strb	r2, [r3, #21]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
300230f4:	e3a03006 	mov	r3, #6
300230f8:	e5cd301b 	strb	r3, [sp, #27]
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
300230fc:	ea000023 	b	30023190 <etharp_raw+0x150>
    k--;
30023100:	e5dd301b 	ldrb	r3, [sp, #27]
30023104:	e2433001 	sub	r3, r3, #1
30023108:	e5cd301b 	strb	r3, [sp, #27]
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
3002310c:	e5dd001b 	ldrb	r0, [sp, #27]
30023110:	e5dd301b 	ldrb	r3, [sp, #27]
30023114:	e59d2000 	ldr	r2, [sp]
30023118:	e7d22003 	ldrb	r2, [r2, r3]
3002311c:	e59d101c 	ldr	r1, [sp, #28]
30023120:	e3a03016 	mov	r3, #22
30023124:	e0801001 	add	r1, r0, r1
30023128:	e0813003 	add	r3, r1, r3
3002312c:	e5c32000 	strb	r2, [r3]
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
30023130:	e5dd001b 	ldrb	r0, [sp, #27]
30023134:	e5dd301b 	ldrb	r3, [sp, #27]
30023138:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
3002313c:	e7d22003 	ldrb	r2, [r2, r3]
30023140:	e59d101c 	ldr	r1, [sp, #28]
30023144:	e3a03020 	mov	r3, #32
30023148:	e0801001 	add	r1, r0, r1
3002314c:	e0813003 	add	r3, r1, r3
30023150:	e5c32000 	strb	r2, [r3]
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
30023154:	e5dd301b 	ldrb	r3, [sp, #27]
30023158:	e5dd201b 	ldrb	r2, [sp, #27]
3002315c:	e59d1004 	ldr	r1, [sp, #4]
30023160:	e7d11002 	ldrb	r1, [r1, r2]
30023164:	e59d201c 	ldr	r2, [sp, #28]
30023168:	e7c21003 	strb	r1, [r2, r3]
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
3002316c:	e5dd001b 	ldrb	r0, [sp, #27]
30023170:	e5dd301b 	ldrb	r3, [sp, #27]
30023174:	e59d2008 	ldr	r2, [sp, #8]
30023178:	e7d22003 	ldrb	r2, [r2, r3]
3002317c:	e59d101c 	ldr	r1, [sp, #28]
30023180:	e3a03006 	mov	r3, #6
30023184:	e0801001 	add	r1, r0, r1
30023188:	e0813003 	add	r3, r1, r3
3002318c:	e5c32000 	strb	r2, [r3]
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
30023190:	e5dd301b 	ldrb	r3, [sp, #27]
30023194:	e3530000 	cmp	r3, #0
30023198:	1affffd8 	bne	30023100 <etharp_raw+0xc0>
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  //by pegasus0824
  //hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  //hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  SMEMCPY(&hdr->sipaddr, (struct ip_addr2 *)ipsrc_addr, sizeof(hdr->sipaddr));
3002319c:	e59d301c 	ldr	r3, [sp, #28]
300231a0:	e283301c 	add	r3, r3, #28
300231a4:	e1a00003 	mov	r0, r3
300231a8:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
300231ac:	e3a02004 	mov	r2, #4
300231b0:	ebffa765 	bl	3000cf4c <__re_memcpy>
  SMEMCPY(&hdr->dipaddr, (struct ip_addr2 *)ipdst_addr, sizeof(hdr->dipaddr));
300231b4:	e59d301c 	ldr	r3, [sp, #28]
300231b8:	e2833026 	add	r3, r3, #38	; 0x26
300231bc:	e1a00003 	mov	r0, r3
300231c0:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
300231c4:	e3a02004 	mov	r2, #4
300231c8:	ebffa75f 	bl	3000cf4c <__re_memcpy>


  hdr->hwtype = htons(HWTYPE_ETHERNET);
300231cc:	e3a00001 	mov	r0, #1
300231d0:	ebffc1b9 	bl	300138bc <htons>
300231d4:	e1a03000 	mov	r3, r0
300231d8:	e1a02003 	mov	r2, r3
300231dc:	e59d301c 	ldr	r3, [sp, #28]
300231e0:	e20210ff 	and	r1, r2, #255	; 0xff
300231e4:	e3a00000 	mov	r0, #0
300231e8:	e1801001 	orr	r1, r0, r1
300231ec:	e5c3100e 	strb	r1, [r3, #14]
300231f0:	e1a02422 	lsr	r2, r2, #8
300231f4:	e1a02802 	lsl	r2, r2, #16
300231f8:	e1a02822 	lsr	r2, r2, #16
300231fc:	e3a01000 	mov	r1, #0
30023200:	e1812002 	orr	r2, r1, r2
30023204:	e5c3200f 	strb	r2, [r3, #15]
  hdr->proto = htons(ETHTYPE_IP);
30023208:	e3a00b02 	mov	r0, #2048	; 0x800
3002320c:	ebffc1aa 	bl	300138bc <htons>
30023210:	e1a03000 	mov	r3, r0
30023214:	e1a02003 	mov	r2, r3
30023218:	e59d301c 	ldr	r3, [sp, #28]
3002321c:	e20210ff 	and	r1, r2, #255	; 0xff
30023220:	e3a00000 	mov	r0, #0
30023224:	e1801001 	orr	r1, r0, r1
30023228:	e5c31010 	strb	r1, [r3, #16]
3002322c:	e1a02422 	lsr	r2, r2, #8
30023230:	e1a02802 	lsl	r2, r2, #16
30023234:	e1a02822 	lsr	r2, r2, #16
30023238:	e3a01000 	mov	r1, #0
3002323c:	e1812002 	orr	r2, r1, r2
30023240:	e5c32011 	strb	r2, [r3, #17]
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
30023244:	e3a00c06 	mov	r0, #1536	; 0x600
30023248:	e2800004 	add	r0, r0, #4
3002324c:	ebffc19a 	bl	300138bc <htons>
30023250:	e1a03000 	mov	r3, r0
30023254:	e1a02003 	mov	r2, r3
30023258:	e59d301c 	ldr	r3, [sp, #28]
3002325c:	e20210ff 	and	r1, r2, #255	; 0xff
30023260:	e3a00000 	mov	r0, #0
30023264:	e1801001 	orr	r1, r0, r1
30023268:	e5c31012 	strb	r1, [r3, #18]
3002326c:	e1a02422 	lsr	r2, r2, #8
30023270:	e1a02802 	lsl	r2, r2, #16
30023274:	e1a02822 	lsr	r2, r2, #16
30023278:	e3a01000 	mov	r1, #0
3002327c:	e1812002 	orr	r2, r1, r2
30023280:	e5c32013 	strb	r2, [r3, #19]

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
30023284:	e3a00b02 	mov	r0, #2048	; 0x800
30023288:	e2800006 	add	r0, r0, #6
3002328c:	ebffc18a 	bl	300138bc <htons>
30023290:	e1a03000 	mov	r3, r0
30023294:	e1a02003 	mov	r2, r3
30023298:	e59d301c 	ldr	r3, [sp, #28]
3002329c:	e20210ff 	and	r1, r2, #255	; 0xff
300232a0:	e3a00000 	mov	r0, #0
300232a4:	e1801001 	orr	r1, r0, r1
300232a8:	e5c3100c 	strb	r1, [r3, #12]
300232ac:	e1a02422 	lsr	r2, r2, #8
300232b0:	e1a02802 	lsl	r2, r2, #16
300232b4:	e1a02822 	lsr	r2, r2, #16
300232b8:	e3a01000 	mov	r1, #0
300232bc:	e1812002 	orr	r2, r1, r2
300232c0:	e5c3200d 	strb	r2, [r3, #13]
  /* send ARP query */
  result = netif->linkoutput(netif, p);
300232c4:	e59d300c 	ldr	r3, [sp, #12]
300232c8:	e5933018 	ldr	r3, [r3, #24]
300232cc:	e59d000c 	ldr	r0, [sp, #12]
300232d0:	e59d1014 	ldr	r1, [sp, #20]
300232d4:	e1a0e00f 	mov	lr, pc
300232d8:	e12fff13 	bx	r3
300232dc:	e1a03000 	mov	r3, r0
300232e0:	e20330ff 	and	r3, r3, #255	; 0xff
300232e4:	e5cd301a 	strb	r3, [sp, #26]
  ETHARP_STATS_INC(etharp.xmit);
300232e8:	e59f3040 	ldr	r3, [pc, #64]	; 30023330 <etharp_raw+0x2f0>
300232ec:	e1d331ba 	ldrh	r3, [r3, #26]
300232f0:	e2833001 	add	r3, r3, #1
300232f4:	e1a03803 	lsl	r3, r3, #16
300232f8:	e1a02823 	lsr	r2, r3, #16
300232fc:	e59f302c 	ldr	r3, [pc, #44]	; 30023330 <etharp_raw+0x2f0>
30023300:	e1c321ba 	strh	r2, [r3, #26]
  /* free ARP query packet */
  pbuf_free(p);
30023304:	e59d0014 	ldr	r0, [sp, #20]
30023308:	ebffcc88 	bl	30016530 <pbuf_free>
  p = NULL;
3002330c:	e3a03000 	mov	r3, #0
30023310:	e58d3014 	str	r3, [sp, #20]
  /* could not allocate pbuf for ARP request */

  return result;
30023314:	e5dd301a 	ldrb	r3, [sp, #26]
30023318:	e1a03c03 	lsl	r3, r3, #24
3002331c:	e1a03c43 	asr	r3, r3, #24
}
30023320:	e1a00003 	mov	r0, r3
30023324:	e28dd024 	add	sp, sp, #36	; 0x24
30023328:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002332c:	e12fff1e 	bx	lr
30023330:	3002b214 	.word	0x3002b214

30023334 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
30023334:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023338:	e24dd01c 	sub	sp, sp, #28
3002333c:	e58d0014 	str	r0, [sp, #20]
30023340:	e58d1010 	str	r1, [sp, #16]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
30023344:	e59d3014 	ldr	r3, [sp, #20]
30023348:	e2833021 	add	r3, r3, #33	; 0x21
3002334c:	e1a02003 	mov	r2, r3
30023350:	e59d3014 	ldr	r3, [sp, #20]
30023354:	e2833021 	add	r3, r3, #33	; 0x21
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
30023358:	e59d1014 	ldr	r1, [sp, #20]
3002335c:	e2811004 	add	r1, r1, #4
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
30023360:	e58d1000 	str	r1, [sp]
30023364:	e59f1044 	ldr	r1, [pc, #68]	; 300233b0 <etharp_request+0x7c>
30023368:	e58d1004 	str	r1, [sp, #4]
3002336c:	e59d1010 	ldr	r1, [sp, #16]
30023370:	e58d1008 	str	r1, [sp, #8]
30023374:	e3a01001 	mov	r1, #1
30023378:	e58d100c 	str	r1, [sp, #12]
3002337c:	e59d0014 	ldr	r0, [sp, #20]
30023380:	e1a01002 	mov	r1, r2
30023384:	e59f2028 	ldr	r2, [pc, #40]	; 300233b4 <etharp_request+0x80>
30023388:	ebffff2c 	bl	30023040 <etharp_raw>
3002338c:	e1a03000 	mov	r3, r0
30023390:	e20330ff 	and	r3, r3, #255	; 0xff
30023394:	e20330ff 	and	r3, r3, #255	; 0xff
30023398:	e1a03c03 	lsl	r3, r3, #24
3002339c:	e1a03c43 	asr	r3, r3, #24
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
300233a0:	e1a00003 	mov	r0, r3
300233a4:	e28dd01c 	add	sp, sp, #28
300233a8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300233ac:	e12fff1e 	bx	lr
300233b0:	300265e4 	.word	0x300265e4
300233b4:	300265dc 	.word	0x300265dc

300233b8 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
300233b8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300233bc:	e24dd014 	sub	sp, sp, #20
300233c0:	e58d0004 	str	r0, [sp, #4]
300233c4:	e58d1000 	str	r1, [sp]
  struct eth_hdr* ethhdr;

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
300233c8:	e59d3004 	ldr	r3, [sp, #4]
300233cc:	e5933004 	ldr	r3, [r3, #4]
300233d0:	e58d300c 	str	r3, [sp, #12]
  
  switch (htons(ethhdr->type)) {
300233d4:	e59d300c 	ldr	r3, [sp, #12]
300233d8:	e5d3200c 	ldrb	r2, [r3, #12]
300233dc:	e5d3300d 	ldrb	r3, [r3, #13]
300233e0:	e1a03403 	lsl	r3, r3, #8
300233e4:	e1833002 	orr	r3, r3, r2
300233e8:	e1a03803 	lsl	r3, r3, #16
300233ec:	e1a03823 	lsr	r3, r3, #16
300233f0:	e1a00003 	mov	r0, r3
300233f4:	ebffc130 	bl	300138bc <htons>
300233f8:	e1a03000 	mov	r3, r0
300233fc:	e1a02003 	mov	r2, r3
30023400:	e3520b02 	cmp	r2, #2048	; 0x800
30023404:	0a000004 	beq	3002341c <ethernet_input+0x64>
30023408:	e3a03b02 	mov	r3, #2048	; 0x800
3002340c:	e2833006 	add	r3, r3, #6
30023410:	e1520003 	cmp	r2, r3
30023414:	0a000012 	beq	30023464 <ethernet_input+0xac>
30023418:	ea000018 	b	30023480 <ethernet_input+0xc8>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
3002341c:	e59d0000 	ldr	r0, [sp]
30023420:	e59d1004 	ldr	r1, [sp, #4]
30023424:	ebfffbff 	bl	30022428 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
30023428:	e59d0004 	ldr	r0, [sp, #4]
3002342c:	e3e0100d 	mvn	r1, #13
30023430:	ebffcbd9 	bl	3001639c <pbuf_header>
30023434:	e1a03000 	mov	r3, r0
30023438:	e3530000 	cmp	r3, #0
3002343c:	0a000004 	beq	30023454 <ethernet_input+0x9c>
        LWIP_ASSERT("Can't move over header in packet", 0);
        pbuf_free(p);
30023440:	e59d0004 	ldr	r0, [sp, #4]
30023444:	ebffcc39 	bl	30016530 <pbuf_free>
        p = NULL;
30023448:	e3a03000 	mov	r3, #0
3002344c:	e58d3004 	str	r3, [sp, #4]
      } else {
		//acoral_prints("\nip_input:ethernet_input_enter\n");
        ip_input(p, netif);
        //acoral_prints("\nip_input:ethernet_input_exit\n");
      }
      break;
30023450:	ea00000e 	b	30023490 <ethernet_input+0xd8>
        LWIP_ASSERT("Can't move over header in packet", 0);
        pbuf_free(p);
        p = NULL;
      } else {
		//acoral_prints("\nip_input:ethernet_input_enter\n");
        ip_input(p, netif);
30023454:	e59d0004 	ldr	r0, [sp, #4]
30023458:	e59d1000 	ldr	r1, [sp]
3002345c:	ebffc3b0 	bl	30014324 <ip_input>
        //acoral_prints("\nip_input:ethernet_input_exit\n");
      }
      break;
30023460:	ea00000a 	b	30023490 <ethernet_input+0xd8>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
30023464:	e59d3000 	ldr	r3, [sp]
30023468:	e2833021 	add	r3, r3, #33	; 0x21
3002346c:	e59d0000 	ldr	r0, [sp]
30023470:	e1a01003 	mov	r1, r3
30023474:	e59d2004 	ldr	r2, [sp, #4]
30023478:	ebfffc13 	bl	300224cc <etharp_arp_input>
      break;
3002347c:	ea000003 	b	30023490 <ethernet_input+0xd8>
      pppoe_data_input(netif, p);
      break;
#endif /* PPPOE_SUPPORT */

    default:
      pbuf_free(p);
30023480:	e59d0004 	ldr	r0, [sp, #4]
30023484:	ebffcc29 	bl	30016530 <pbuf_free>
      p = NULL;
30023488:	e3a03000 	mov	r3, #0
3002348c:	e58d3004 	str	r3, [sp, #4]
      break;
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
30023490:	e3a03000 	mov	r3, #0
30023494:	e1a03c03 	lsl	r3, r3, #24
30023498:	e1a03c43 	asr	r3, r3, #24
}
3002349c:	e1a00003 	mov	r0, r3
300234a0:	e28dd014 	add	sp, sp, #20
300234a4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300234a8:	e12fff1e 	bx	lr

300234ac <low_level_init>:
 * @param netif the already initialized lwip network interface structure
 *        for this ethernetif
 */
static void
low_level_init(struct netif *netif)
{
300234ac:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300234b0:	e24dd00c 	sub	sp, sp, #12
300234b4:	e58d0004 	str	r0, [sp, #4]
	/* set MAC hardware address length */
	netif->hwaddr_len = ETHARP_HWADDR_LEN;
300234b8:	e59d3004 	ldr	r3, [sp, #4]
300234bc:	e3a02006 	mov	r2, #6
300234c0:	e5c32020 	strb	r2, [r3, #32]

	/* set MAC hardware address */
	/* MAC地址 */
	netif->hwaddr[0] = 0x00;
300234c4:	e59d3004 	ldr	r3, [sp, #4]
300234c8:	e3a02000 	mov	r2, #0
300234cc:	e5c32021 	strb	r2, [r3, #33]	; 0x21
	netif->hwaddr[1] = 0x11;
300234d0:	e59d3004 	ldr	r3, [sp, #4]
300234d4:	e3a02011 	mov	r2, #17
300234d8:	e5c32022 	strb	r2, [r3, #34]	; 0x22
	netif->hwaddr[2] = 0x22;
300234dc:	e59d3004 	ldr	r3, [sp, #4]
300234e0:	e3a02022 	mov	r2, #34	; 0x22
300234e4:	e5c32023 	strb	r2, [r3, #35]	; 0x23
	netif->hwaddr[3] = 0x33;
300234e8:	e59d3004 	ldr	r3, [sp, #4]
300234ec:	e3a02033 	mov	r2, #51	; 0x33
300234f0:	e5c32024 	strb	r2, [r3, #36]	; 0x24
	netif->hwaddr[4] = 0x44;     
300234f4:	e59d3004 	ldr	r3, [sp, #4]
300234f8:	e3a02044 	mov	r2, #68	; 0x44
300234fc:	e5c32025 	strb	r2, [r3, #37]	; 0x25
	netif->hwaddr[5] = 0x55;
30023500:	e59d3004 	ldr	r3, [sp, #4]
30023504:	e3a02055 	mov	r2, #85	; 0x55
30023508:	e5c32026 	strb	r2, [r3, #38]	; 0x26

	/* maximum transfer unit */
	/* 最大传输单元 */
	netif->mtu = 1500;
3002350c:	e59d2004 	ldr	r2, [sp, #4]
30023510:	e3a03e5d 	mov	r3, #1488	; 0x5d0
30023514:	e283300c 	add	r3, r3, #12
30023518:	e1c232b8 	strh	r3, [r2, #40]	; 0x28
  
	/* device capabilities */
	/* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
	netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
3002351c:	e59d3004 	ldr	r3, [sp, #4]
30023520:	e3a02032 	mov	r2, #50	; 0x32
30023524:	e5c3202a 	strb	r2, [r3, #42]	; 0x2a
	/* 初始化enc28j60 */
	
	// pegasus0809
	// hw_init(netif->hwaddr);
		
	dm9000_id = acoral_dev_open("netdev");
30023528:	e59f0064 	ldr	r0, [pc, #100]	; 30023594 <low_level_init+0xe8>
3002352c:	eb0003e4 	bl	300244c4 <acoral_dev_open>
30023530:	e1a02000 	mov	r2, r0
30023534:	e59f305c 	ldr	r3, [pc, #92]	; 30023598 <low_level_init+0xec>
30023538:	e5832000 	str	r2, [r3]
	if (dm9000_id == ACORAL_DEV_ERR_ID)
3002353c:	e59f3054 	ldr	r3, [pc, #84]	; 30023598 <low_level_init+0xec>
30023540:	e5933000 	ldr	r3, [r3]
30023544:	e3730001 	cmn	r3, #1
30023548:	1a000005 	bne	30023564 <low_level_init+0xb8>
	{
		acoral_printerr("ERROR: the dm9000 id %d", dm9000_id);
3002354c:	e59f3044 	ldr	r3, [pc, #68]	; 30023598 <low_level_init+0xec>
30023550:	e5933000 	ldr	r3, [r3]
30023554:	e59f0040 	ldr	r0, [pc, #64]	; 3002359c <low_level_init+0xf0>
30023558:	e1a01003 	mov	r1, r3
3002355c:	ebff9fb1 	bl	3000b428 <acoral_print>
		return;
30023560:	ea000008 	b	30023588 <low_level_init+0xdc>
	}
	acoral_dev_config(dm9000_id, NET_DEV_INIT, netif->hwaddr, 0);
30023564:	e59f302c 	ldr	r3, [pc, #44]	; 30023598 <low_level_init+0xec>
30023568:	e5932000 	ldr	r2, [r3]
3002356c:	e59d3004 	ldr	r3, [sp, #4]
30023570:	e2833021 	add	r3, r3, #33	; 0x21
30023574:	e1a00002 	mov	r0, r2
30023578:	e3a01001 	mov	r1, #1
3002357c:	e1a02003 	mov	r2, r3
30023580:	e3a03000 	mov	r3, #0
30023584:	eb00043f 	bl	30024688 <acoral_dev_config>
}
30023588:	e28dd00c 	add	sp, sp, #12
3002358c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023590:	e12fff1e 	bx	lr
30023594:	300265ec 	.word	0x300265ec
30023598:	300268d4 	.word	0x300268d4
3002359c:	300265f4 	.word	0x300265f4

300235a0 <low_level_output>:
 *       to become availale since the stack doesn't retry to send a packet
 *       dropped because of memory failure (except for the TCP timers).
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
300235a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300235a4:	e24dd014 	sub	sp, sp, #20
300235a8:	e58d000c 	str	r0, [sp, #12]
300235ac:	e58d1008 	str	r1, [sp, #8]
#if ETH_PAD_SIZE
	pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
#endif
	//acoral_prints("\r\nlowLOutput=sta\r\n");
	//hw_sendPacket(p);
	acoral_dev_write(dm9000_id, p, 0, 0, 0);
300235b0:	e59f3054 	ldr	r3, [pc, #84]	; 3002360c <low_level_output+0x6c>
300235b4:	e5933000 	ldr	r3, [r3]
300235b8:	e3a02000 	mov	r2, #0
300235bc:	e58d2000 	str	r2, [sp]
300235c0:	e1a00003 	mov	r0, r3
300235c4:	e59d1008 	ldr	r1, [sp, #8]
300235c8:	e3a02000 	mov	r2, #0
300235cc:	e3a03000 	mov	r3, #0
300235d0:	eb0003e0 	bl	30024558 <acoral_dev_write>
	//acoral_prints("\r\nlowLOutput=end\r\n");
#if ETH_PAD_SIZE
	pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
#endif
  
	LINK_STATS_INC(link.xmit);
300235d4:	e59f3034 	ldr	r3, [pc, #52]	; 30023610 <low_level_output+0x70>
300235d8:	e1d330b0 	ldrh	r3, [r3]
300235dc:	e2833001 	add	r3, r3, #1
300235e0:	e1a03803 	lsl	r3, r3, #16
300235e4:	e1a02823 	lsr	r2, r3, #16
300235e8:	e59f3020 	ldr	r3, [pc, #32]	; 30023610 <low_level_output+0x70>
300235ec:	e1c320b0 	strh	r2, [r3]

	return ERR_OK;
300235f0:	e3a03000 	mov	r3, #0
300235f4:	e1a03c03 	lsl	r3, r3, #24
300235f8:	e1a03c43 	asr	r3, r3, #24
}
300235fc:	e1a00003 	mov	r0, r3
30023600:	e28dd014 	add	sp, sp, #20
30023604:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023608:	e12fff1e 	bx	lr
3002360c:	300268d4 	.word	0x300268d4
30023610:	3002b214 	.word	0x3002b214

30023614 <ethernetif_input>:
 * the appropriate input function is called.
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
void ethernetif_input(void *arg)
{
30023614:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023618:	e24dd024 	sub	sp, sp, #36	; 0x24
3002361c:	e58d000c 	str	r0, [sp, #12]
	acoral_u32    flag = 0;
30023620:	e3a03000 	mov	r3, #0
30023624:	e58d3014 	str	r3, [sp, #20]
	struct eth_hdr *ethhdr;
	struct pbuf *p;
	
	struct netif *netif = (struct netif *)arg;
30023628:	e59d300c 	ldr	r3, [sp, #12]
3002362c:	e58d301c 	str	r3, [sp, #28]
	
	do
	{
		/* move received packet into a new pbuf */
		//p = hw_getPacket(/*netif,*/ &flag);
		acoral_dev_read(dm9000_id, &p, 0, 0,0);
30023630:	e59f30e0 	ldr	r3, [pc, #224]	; 30023718 <ethernetif_input+0x104>
30023634:	e5932000 	ldr	r2, [r3]
30023638:	e28d3010 	add	r3, sp, #16
3002363c:	e3a01000 	mov	r1, #0
30023640:	e58d1000 	str	r1, [sp]
30023644:	e1a00002 	mov	r0, r2
30023648:	e1a01003 	mov	r1, r3
3002364c:	e3a02000 	mov	r2, #0
30023650:	e3a03000 	mov	r3, #0
30023654:	eb0003e5 	bl	300245f0 <acoral_dev_read>
		
		/* no packet could be read, silently ignore this */
		if (p == NULL) 
30023658:	e59d3010 	ldr	r3, [sp, #16]
3002365c:	e3530000 	cmp	r3, #0
30023660:	1a000000 	bne	30023668 <ethernetif_input+0x54>
			continue;
30023664:	ea00002a 	b	30023714 <ethernetif_input+0x100>
		//acoral_prints("received\n");
		/* points to packet payload, which starts with an Ethernet header */
		ethhdr = p->payload;
30023668:	e59d3010 	ldr	r3, [sp, #16]
3002366c:	e5933004 	ldr	r3, [r3, #4]
30023670:	e58d3018 	str	r3, [sp, #24]

		switch (htons(ethhdr->type)) 
30023674:	e59d3018 	ldr	r3, [sp, #24]
30023678:	e5d3200c 	ldrb	r2, [r3, #12]
3002367c:	e5d3300d 	ldrb	r3, [r3, #13]
30023680:	e1a03403 	lsl	r3, r3, #8
30023684:	e1833002 	orr	r3, r3, r2
30023688:	e1a03803 	lsl	r3, r3, #16
3002368c:	e1a03823 	lsr	r3, r3, #16
30023690:	e1a00003 	mov	r0, r3
30023694:	ebffc088 	bl	300138bc <htons>
30023698:	e1a03000 	mov	r3, r0
3002369c:	e1a02003 	mov	r2, r3
300236a0:	e3520b02 	cmp	r2, #2048	; 0x800
300236a4:	0a000003 	beq	300236b8 <ethernetif_input+0xa4>
300236a8:	e3a03b02 	mov	r3, #2048	; 0x800
300236ac:	e2833006 	add	r3, r3, #6
300236b0:	e1520003 	cmp	r2, r3
300236b4:	1a000010 	bne	300236fc <ethernetif_input+0xe8>
			/* PPPoE packet? */
			case ETHTYPE_PPPOEDISC:
			case ETHTYPE_PPPOE:
			#endif /* PPPOE_SUPPORT */
			/* full packet send to tcpip_thread to process */
			if (netif->input(p, netif)!=ERR_OK)
300236b8:	e59d301c 	ldr	r3, [sp, #28]
300236bc:	e5933010 	ldr	r3, [r3, #16]
300236c0:	e59d2010 	ldr	r2, [sp, #16]
300236c4:	e1a00002 	mov	r0, r2
300236c8:	e59d101c 	ldr	r1, [sp, #28]
300236cc:	e1a0e00f 	mov	lr, pc
300236d0:	e12fff13 	bx	r3
300236d4:	e1a03000 	mov	r3, r0
300236d8:	e20330ff 	and	r3, r3, #255	; 0xff
300236dc:	e3530000 	cmp	r3, #0
300236e0:	0a000004 	beq	300236f8 <ethernetif_input+0xe4>
			{ 
				
				LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
				pbuf_free(p);
300236e4:	e59d3010 	ldr	r3, [sp, #16]
300236e8:	e1a00003 	mov	r0, r3
300236ec:	ebffcb8f 	bl	30016530 <pbuf_free>
                               // acoral_delay_self(400); 
				p = NULL;
300236f0:	e3a03000 	mov	r3, #0
300236f4:	e58d3010 	str	r3, [sp, #16]
			}
			break;
300236f8:	ea000005 	b	30023714 <ethernetif_input+0x100>

		    default:
			pbuf_free(p);
300236fc:	e59d3010 	ldr	r3, [sp, #16]
30023700:	e1a00003 	mov	r0, r3
30023704:	ebffcb89 	bl	30016530 <pbuf_free>
			p = NULL;
30023708:	e3a03000 	mov	r3, #0
3002370c:	e58d3010 	str	r3, [sp, #16]
			break;
		}
	}while(1);
30023710:	eaffffc6 	b	30023630 <ethernetif_input+0x1c>
30023714:	eaffffc5 	b	30023630 <ethernetif_input+0x1c>
30023718:	300268d4 	.word	0x300268d4

3002371c <ethernetif_init>:
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t 
ethernetif_init(struct netif *netif)
{
3002371c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023720:	e24dd014 	sub	sp, sp, #20
30023724:	e58d0004 	str	r0, [sp, #4]
	struct ethernetif *ethernetif;


	LWIP_ASSERT("netif != NULL", (netif != NULL));
    
	ethernetif = mem_malloc(sizeof(struct ethernetif));
30023728:	e3a00004 	mov	r0, #4
3002372c:	ebfff6e4 	bl	300212c4 <mem_malloc>
30023730:	e1a03000 	mov	r3, r0
30023734:	e58d300c 	str	r3, [sp, #12]
	if (ethernetif == NULL) 
30023738:	e59d300c 	ldr	r3, [sp, #12]
3002373c:	e3530000 	cmp	r3, #0
30023740:	1a000001 	bne	3002374c <ethernetif_init+0x30>
	{
		LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
		return ERR_MEM;
30023744:	e3a030ff 	mov	r3, #255	; 0xff
30023748:	ea000016 	b	300237a8 <ethernetif_init+0x8c>
     * of bits per second.
     */
	//下面这句不知为什么,先注释掉
	//NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, ???);

	netif->state = ethernetif;
3002374c:	e59d3004 	ldr	r3, [sp, #4]
30023750:	e59d200c 	ldr	r2, [sp, #12]
30023754:	e583201c 	str	r2, [r3, #28]
	netif->name[0] = IFNAME0;
30023758:	e59d3004 	ldr	r3, [sp, #4]
3002375c:	e3a02065 	mov	r2, #101	; 0x65
30023760:	e5c3202b 	strb	r2, [r3, #43]	; 0x2b
	netif->name[1] = IFNAME1;
30023764:	e59d3004 	ldr	r3, [sp, #4]
30023768:	e3a0206e 	mov	r2, #110	; 0x6e
3002376c:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
	/* We directly use etharp_output() here to save a function call.
     * You can instead declare your own function an call etharp_output()
     * from it if you have to do some checks before sending (e.g. if link
     * is available...) 
	 */
	netif->output = etharp_output;
30023770:	e59d3004 	ldr	r3, [sp, #4]
30023774:	e59f2044 	ldr	r2, [pc, #68]	; 300237c0 <ethernetif_init+0xa4>
30023778:	e5832014 	str	r2, [r3, #20]
	netif->linkoutput = low_level_output;
3002377c:	e59d3004 	ldr	r3, [sp, #4]
30023780:	e59f203c 	ldr	r2, [pc, #60]	; 300237c4 <ethernetif_init+0xa8>
30023784:	e5832018 	str	r2, [r3, #24]
  
	ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
30023788:	e59d3004 	ldr	r3, [sp, #4]
3002378c:	e2833021 	add	r3, r3, #33	; 0x21
30023790:	e1a02003 	mov	r2, r3
30023794:	e59d300c 	ldr	r3, [sp, #12]
30023798:	e5832000 	str	r2, [r3]
  
	/* initialize the hardware */
	low_level_init(netif);
3002379c:	e59d0004 	ldr	r0, [sp, #4]
300237a0:	ebffff41 	bl	300234ac <low_level_init>

	return ERR_OK;
300237a4:	e3a03000 	mov	r3, #0
300237a8:	e1a03c03 	lsl	r3, r3, #24
300237ac:	e1a03c43 	asr	r3, r3, #24
}
300237b0:	e1a00003 	mov	r0, r3
300237b4:	e28dd014 	add	sp, sp, #20
300237b8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300237bc:	e12fff1e 	bx	lr
300237c0:	3002290c 	.word	0x3002290c
300237c4:	300235a0 	.word	0x300235a0

300237c8 <dummy>:
#include"acoral.h"
#include"../include/shell.h"
void dummy(void *args){
300237c8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300237cc:	e24dd014 	sub	sp, sp, #20
300237d0:	e58d0004 	str	r0, [sp, #4]
	int i=0;
300237d4:	e3a03000 	mov	r3, #0
300237d8:	e58d300c 	str	r3, [sp, #12]
	while(1){
		i++;
300237dc:	e59d300c 	ldr	r3, [sp, #12]
300237e0:	e2833001 	add	r3, r3, #1
300237e4:	e58d300c 	str	r3, [sp, #12]
//		LedControl(i);
		acoral_delay_self(1000);
300237e8:	e3a00ffa 	mov	r0, #1000	; 0x3e8
300237ec:	ebff7c5e 	bl	3000296c <acoral_delay_self>
	}
300237f0:	eafffff9 	b	300237dc <dummy+0x14>

300237f4 <user_main>:
#endif
#ifdef CFG_WEB_SERVER
	user_httpd();
#endif
//	acoral_create_thread(dummy,256,NULL,NULL,20,0);
}
300237f4:	e12fff1e 	bx	lr

300237f8 <parse_args>:
	PS_STRING,
	PS_ESCAPE
};

void parse_args(acoral_char *argstr, acoral_32 *argc_p, acoral_char **argv, acoral_char** resid,enum parse_state *stacked)
{
300237f8:	e24dd018 	sub	sp, sp, #24
300237fc:	e58d000c 	str	r0, [sp, #12]
30023800:	e58d1008 	str	r1, [sp, #8]
30023804:	e58d2004 	str	r2, [sp, #4]
30023808:	e58d3000 	str	r3, [sp]
	acoral_32 argc = 0;
3002380c:	e3a03000 	mov	r3, #0
30023810:	e58d3010 	str	r3, [sp, #16]
	acoral_char c;
	enum parse_state newState;
	enum parse_state stacked_state=*stacked;
30023814:	e59d3018 	ldr	r3, [sp, #24]
30023818:	e5d33000 	ldrb	r3, [r3]
3002381c:	e5cd3016 	strb	r3, [sp, #22]
	enum parse_state lastState = PS_WHITESPACE;
30023820:	e3a03000 	mov	r3, #0
30023824:	e5cd3017 	strb	r3, [sp, #23]

	while ((c = *argstr) != 0&&argc<MAX_ARGS_NUM) {
30023828:	ea000059 	b	30023994 <parse_args+0x19c>

		if (c == ';' && lastState != PS_STRING && lastState != PS_ESCAPE)
3002382c:	e5dd3014 	ldrb	r3, [sp, #20]
30023830:	e353003b 	cmp	r3, #59	; 0x3b
30023834:	1a000005 	bne	30023850 <parse_args+0x58>
30023838:	e5dd3017 	ldrb	r3, [sp, #23]
3002383c:	e3530002 	cmp	r3, #2
30023840:	0a000002 	beq	30023850 <parse_args+0x58>
30023844:	e5dd3017 	ldrb	r3, [sp, #23]
30023848:	e3530003 	cmp	r3, #3
3002384c:	1a00005a 	bne	300239bc <parse_args+0x1c4>
			break;

		if (lastState == PS_ESCAPE) {
30023850:	e5dd3017 	ldrb	r3, [sp, #23]
30023854:	e3530003 	cmp	r3, #3
30023858:	1a000002 	bne	30023868 <parse_args+0x70>
			newState = stacked_state;
3002385c:	e5dd3016 	ldrb	r3, [sp, #22]
30023860:	e5cd3015 	strb	r3, [sp, #21]
30023864:	ea000045 	b	30023980 <parse_args+0x188>
		} else if (lastState == PS_STRING) {
30023868:	e5dd3017 	ldrb	r3, [sp, #23]
3002386c:	e3530002 	cmp	r3, #2
30023870:	1a00000b 	bne	300238a4 <parse_args+0xac>
			if (c == '"') {
30023874:	e5dd3014 	ldrb	r3, [sp, #20]
30023878:	e3530022 	cmp	r3, #34	; 0x22
3002387c:	1a000005 	bne	30023898 <parse_args+0xa0>
				newState = PS_WHITESPACE;
30023880:	e3a03000 	mov	r3, #0
30023884:	e5cd3015 	strb	r3, [sp, #21]
				*argstr = 0;
30023888:	e59d300c 	ldr	r3, [sp, #12]
3002388c:	e3a02000 	mov	r2, #0
30023890:	e5c32000 	strb	r2, [r3]
			} else {
				newState = PS_STRING;
30023894:	ea000039 	b	30023980 <parse_args+0x188>
30023898:	e3a03002 	mov	r3, #2
3002389c:	e5cd3015 	strb	r3, [sp, #21]
300238a0:	ea000036 	b	30023980 <parse_args+0x188>
			}
		} else if ((c == ' ') || (c == '\t')) {
300238a4:	e5dd3014 	ldrb	r3, [sp, #20]
300238a8:	e3530020 	cmp	r3, #32
300238ac:	0a000002 	beq	300238bc <parse_args+0xc4>
300238b0:	e5dd3014 	ldrb	r3, [sp, #20]
300238b4:	e3530009 	cmp	r3, #9
300238b8:	1a000005 	bne	300238d4 <parse_args+0xdc>
			*argstr = 0;
300238bc:	e59d300c 	ldr	r3, [sp, #12]
300238c0:	e3a02000 	mov	r2, #0
300238c4:	e5c32000 	strb	r2, [r3]
			newState = PS_WHITESPACE;
300238c8:	e3a03000 	mov	r3, #0
300238cc:	e5cd3015 	strb	r3, [sp, #21]
				newState = PS_WHITESPACE;
				*argstr = 0;
			} else {
				newState = PS_STRING;
			}
		} else if ((c == ' ') || (c == '\t')) {
300238d0:	ea00002a 	b	30023980 <parse_args+0x188>
			*argstr = 0;
			newState = PS_WHITESPACE;
		} else if (c == '"') {
300238d4:	e5dd3014 	ldrb	r3, [sp, #20]
300238d8:	e3530022 	cmp	r3, #34	; 0x22
300238dc:	1a000011 	bne	30023928 <parse_args+0x130>
			newState = PS_STRING;
300238e0:	e3a03002 	mov	r3, #2
300238e4:	e5cd3015 	strb	r3, [sp, #21]
			*argstr++ = 0;
300238e8:	e59d300c 	ldr	r3, [sp, #12]
300238ec:	e3a02000 	mov	r2, #0
300238f0:	e5c32000 	strb	r2, [r3]
300238f4:	e59d300c 	ldr	r3, [sp, #12]
300238f8:	e2833001 	add	r3, r3, #1
300238fc:	e58d300c 	str	r3, [sp, #12]
			argv[argc++] = argstr;
30023900:	e59d3010 	ldr	r3, [sp, #16]
30023904:	e1a02103 	lsl	r2, r3, #2
30023908:	e59d3004 	ldr	r3, [sp, #4]
3002390c:	e0823003 	add	r3, r2, r3
30023910:	e59d200c 	ldr	r2, [sp, #12]
30023914:	e5832000 	str	r2, [r3]
30023918:	e59d3010 	ldr	r3, [sp, #16]
3002391c:	e2833001 	add	r3, r3, #1
30023920:	e58d3010 	str	r3, [sp, #16]
30023924:	ea000015 	b	30023980 <parse_args+0x188>
		} else if (c == '\\') {
30023928:	e5dd3014 	ldrb	r3, [sp, #20]
3002392c:	e353005c 	cmp	r3, #92	; 0x5c
30023930:	1a000004 	bne	30023948 <parse_args+0x150>
			stacked_state = lastState;
30023934:	e5dd3017 	ldrb	r3, [sp, #23]
30023938:	e5cd3016 	strb	r3, [sp, #22]
			newState = PS_ESCAPE;
3002393c:	e3a03003 	mov	r3, #3
30023940:	e5cd3015 	strb	r3, [sp, #21]
30023944:	ea00000d 	b	30023980 <parse_args+0x188>
		} else {
			if (lastState == PS_WHITESPACE) {
30023948:	e5dd3017 	ldrb	r3, [sp, #23]
3002394c:	e3530000 	cmp	r3, #0
30023950:	1a000008 	bne	30023978 <parse_args+0x180>
				argv[argc++] = argstr;
30023954:	e59d3010 	ldr	r3, [sp, #16]
30023958:	e1a02103 	lsl	r2, r3, #2
3002395c:	e59d3004 	ldr	r3, [sp, #4]
30023960:	e0823003 	add	r3, r2, r3
30023964:	e59d200c 	ldr	r2, [sp, #12]
30023968:	e5832000 	str	r2, [r3]
3002396c:	e59d3010 	ldr	r3, [sp, #16]
30023970:	e2833001 	add	r3, r3, #1
30023974:	e58d3010 	str	r3, [sp, #16]
			}
			newState = PS_TOKEN;
30023978:	e3a03001 	mov	r3, #1
3002397c:	e5cd3015 	strb	r3, [sp, #21]
		}

		lastState = newState;
30023980:	e5dd3015 	ldrb	r3, [sp, #21]
30023984:	e5cd3017 	strb	r3, [sp, #23]
		argstr++;
30023988:	e59d300c 	ldr	r3, [sp, #12]
3002398c:	e2833001 	add	r3, r3, #1
30023990:	e58d300c 	str	r3, [sp, #12]
	acoral_char c;
	enum parse_state newState;
	enum parse_state stacked_state=*stacked;
	enum parse_state lastState = PS_WHITESPACE;

	while ((c = *argstr) != 0&&argc<MAX_ARGS_NUM) {
30023994:	e59d300c 	ldr	r3, [sp, #12]
30023998:	e5d33000 	ldrb	r3, [r3]
3002399c:	e5cd3014 	strb	r3, [sp, #20]
300239a0:	e5dd3014 	ldrb	r3, [sp, #20]
300239a4:	e3530000 	cmp	r3, #0
300239a8:	0a000004 	beq	300239c0 <parse_args+0x1c8>
300239ac:	e59d3010 	ldr	r3, [sp, #16]
300239b0:	e3530007 	cmp	r3, #7
300239b4:	daffff9c 	ble	3002382c <parse_args+0x34>
300239b8:	ea000000 	b	300239c0 <parse_args+0x1c8>

		if (c == ';' && lastState != PS_STRING && lastState != PS_ESCAPE)
			break;
300239bc:	e1a00000 	nop			; (mov r0, r0)

		lastState = newState;
		argstr++;
	}

	argv[argc] = NULL;
300239c0:	e59d3010 	ldr	r3, [sp, #16]
300239c4:	e1a02103 	lsl	r2, r3, #2
300239c8:	e59d3004 	ldr	r3, [sp, #4]
300239cc:	e0823003 	add	r3, r2, r3
300239d0:	e3a02000 	mov	r2, #0
300239d4:	e5832000 	str	r2, [r3]
	if (argc_p != NULL)
300239d8:	e59d3008 	ldr	r3, [sp, #8]
300239dc:	e3530000 	cmp	r3, #0
300239e0:	0a000002 	beq	300239f0 <parse_args+0x1f8>
		*argc_p = argc;
300239e4:	e59d3008 	ldr	r3, [sp, #8]
300239e8:	e59d2010 	ldr	r2, [sp, #16]
300239ec:	e5832000 	str	r2, [r3]

	if (*argstr == ';') {
300239f0:	e59d300c 	ldr	r3, [sp, #12]
300239f4:	e5d33000 	ldrb	r3, [r3]
300239f8:	e353003b 	cmp	r3, #59	; 0x3b
300239fc:	1a000005 	bne	30023a18 <parse_args+0x220>
		*argstr++ = '\0';
30023a00:	e59d300c 	ldr	r3, [sp, #12]
30023a04:	e3a02000 	mov	r2, #0
30023a08:	e5c32000 	strb	r2, [r3]
30023a0c:	e59d300c 	ldr	r3, [sp, #12]
30023a10:	e2833001 	add	r3, r3, #1
30023a14:	e58d300c 	str	r3, [sp, #12]
	}
	*resid = argstr;
30023a18:	e59d3000 	ldr	r3, [sp]
30023a1c:	e59d200c 	ldr	r2, [sp, #12]
30023a20:	e5832000 	str	r2, [r3]
	*stacked=stacked_state;
30023a24:	e59d3018 	ldr	r3, [sp, #24]
30023a28:	e5dd2016 	ldrb	r2, [sp, #22]
30023a2c:	e5c32000 	strb	r2, [r3]
}
30023a30:	e28dd018 	add	sp, sp, #24
30023a34:	e12fff1e 	bx	lr

30023a38 <add_command>:

void add_command(acoral_shell_cmd_t *cmd)
{
30023a38:	e24dd008 	sub	sp, sp, #8
30023a3c:	e58d0004 	str	r0, [sp, #4]
	if (head_cmd == NULL) {
30023a40:	e59f304c 	ldr	r3, [pc, #76]	; 30023a94 <add_command+0x5c>
30023a44:	e5933000 	ldr	r3, [r3]
30023a48:	e3530000 	cmp	r3, #0
30023a4c:	1a000007 	bne	30023a70 <add_command+0x38>
		head_cmd = tail_cmd = cmd;
30023a50:	e59f3040 	ldr	r3, [pc, #64]	; 30023a98 <add_command+0x60>
30023a54:	e59d2004 	ldr	r2, [sp, #4]
30023a58:	e5832000 	str	r2, [r3]
30023a5c:	e59f3034 	ldr	r3, [pc, #52]	; 30023a98 <add_command+0x60>
30023a60:	e5932000 	ldr	r2, [r3]
30023a64:	e59f3028 	ldr	r3, [pc, #40]	; 30023a94 <add_command+0x5c>
30023a68:	e5832000 	str	r2, [r3]
30023a6c:	ea000006 	b	30023a8c <add_command+0x54>
	} else {
		tail_cmd->next = cmd;
30023a70:	e59f3020 	ldr	r3, [pc, #32]	; 30023a98 <add_command+0x60>
30023a74:	e5933000 	ldr	r3, [r3]
30023a78:	e59d2004 	ldr	r2, [sp, #4]
30023a7c:	e583200c 	str	r2, [r3, #12]
		tail_cmd = cmd;
30023a80:	e59f3010 	ldr	r3, [pc, #16]	; 30023a98 <add_command+0x60>
30023a84:	e59d2004 	ldr	r2, [sp, #4]
30023a88:	e5832000 	str	r2, [r3]
	}
}
30023a8c:	e28dd008 	add	sp, sp, #8
30023a90:	e12fff1e 	bx	lr
30023a94:	3002a880 	.word	0x3002a880
30023a98:	3002b378 	.word	0x3002b378

30023a9c <find_cmd>:

acoral_shell_cmd_t *find_cmd(acoral_char *cmdname)
{
30023a9c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023aa0:	e24dd014 	sub	sp, sp, #20
30023aa4:	e58d0004 	str	r0, [sp, #4]
	acoral_shell_cmd_t *curr;
	curr =head_cmd;
30023aa8:	e59f305c 	ldr	r3, [pc, #92]	; 30023b0c <find_cmd+0x70>
30023aac:	e5933000 	ldr	r3, [r3]
30023ab0:	e58d300c 	str	r3, [sp, #12]
	while(curr != NULL) {
30023ab4:	ea00000c 	b	30023aec <find_cmd+0x50>
		if (acoral_str_cmp(curr->name, cmdname) == 0)
30023ab8:	e59d300c 	ldr	r3, [sp, #12]
30023abc:	e5933000 	ldr	r3, [r3]
30023ac0:	e1a00003 	mov	r0, r3
30023ac4:	e59d1004 	ldr	r1, [sp, #4]
30023ac8:	ebff9fc8 	bl	3000b9f0 <acoral_str_cmp>
30023acc:	e1a03000 	mov	r3, r0
30023ad0:	e3530000 	cmp	r3, #0
30023ad4:	1a000001 	bne	30023ae0 <find_cmd+0x44>
			return curr;
30023ad8:	e59d300c 	ldr	r3, [sp, #12]
30023adc:	ea000006 	b	30023afc <find_cmd+0x60>
		curr = curr->next;
30023ae0:	e59d300c 	ldr	r3, [sp, #12]
30023ae4:	e593300c 	ldr	r3, [r3, #12]
30023ae8:	e58d300c 	str	r3, [sp, #12]

acoral_shell_cmd_t *find_cmd(acoral_char *cmdname)
{
	acoral_shell_cmd_t *curr;
	curr =head_cmd;
	while(curr != NULL) {
30023aec:	e59d300c 	ldr	r3, [sp, #12]
30023af0:	e3530000 	cmp	r3, #0
30023af4:	1affffef 	bne	30023ab8 <find_cmd+0x1c>
		if (acoral_str_cmp(curr->name, cmdname) == 0)
			return curr;
		curr = curr->next;
	}
	return NULL;
30023af8:	e3a03000 	mov	r3, #0
}
30023afc:	e1a00003 	mov	r0, r3
30023b00:	e28dd014 	add	sp, sp, #20
30023b04:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023b08:	e12fff1e 	bx	lr
30023b0c:	3002a880 	.word	0x3002a880

30023b10 <execmd>:

void execmd(acoral_32 argc,acoral_char **argv)
{
30023b10:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023b14:	e24dd014 	sub	sp, sp, #20
30023b18:	e58d0004 	str	r0, [sp, #4]
30023b1c:	e58d1000 	str	r1, [sp]
	acoral_shell_cmd_t *cmd = find_cmd(argv[0]);
30023b20:	e59d3000 	ldr	r3, [sp]
30023b24:	e5933000 	ldr	r3, [r3]
30023b28:	e1a00003 	mov	r0, r3
30023b2c:	ebffffda 	bl	30023a9c <find_cmd>
30023b30:	e1a03000 	mov	r3, r0
30023b34:	e58d300c 	str	r3, [sp, #12]
	if (cmd == NULL) {
30023b38:	e59d300c 	ldr	r3, [sp, #12]
30023b3c:	e3530000 	cmp	r3, #0
30023b40:	1a000007 	bne	30023b64 <execmd+0x54>
		acoral_print("Could not found '%s' command\r\n", argv[0]);
30023b44:	e59d3000 	ldr	r3, [sp]
30023b48:	e5933000 	ldr	r3, [r3]
30023b4c:	e59f0034 	ldr	r0, [pc, #52]	; 30023b88 <execmd+0x78>
30023b50:	e1a01003 	mov	r1, r3
30023b54:	ebff9e33 	bl	3000b428 <acoral_print>
		acoral_print("you can type 'help'\r\n"); 
30023b58:	e59f002c 	ldr	r0, [pc, #44]	; 30023b8c <execmd+0x7c>
30023b5c:	ebff9e31 	bl	3000b428 <acoral_print>
		return;
30023b60:	ea000005 	b	30023b7c <execmd+0x6c>
	}
	cmd->exe(argc, argv);
30023b64:	e59d300c 	ldr	r3, [sp, #12]
30023b68:	e5933004 	ldr	r3, [r3, #4]
30023b6c:	e59d0004 	ldr	r0, [sp, #4]
30023b70:	e59d1000 	ldr	r1, [sp]
30023b74:	e1a0e00f 	mov	lr, pc
30023b78:	e12fff13 	bx	r3
}
30023b7c:	e28dd014 	add	sp, sp, #20
30023b80:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023b84:	e12fff1e 	bx	lr
30023b88:	3002660c 	.word	0x3002660c
30023b8c:	3002662c 	.word	0x3002662c

30023b90 <cmd_exe>:


void cmd_exe(acoral_char *buf){
30023b90:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023b94:	e24dd044 	sub	sp, sp, #68	; 0x44
30023b98:	e58d000c 	str	r0, [sp, #12]
	acoral_32 argc;
	acoral_char *argv[MAX_ARGS_NUM];
	acoral_char *resid;
	enum parse_state stacked_state;
	while (*buf) {
30023b9c:	ea000015 	b	30023bf8 <cmd_exe+0x68>
		acoral_memset(argv, 0, sizeof(argv));
30023ba0:	e28d301c 	add	r3, sp, #28
30023ba4:	e1a00003 	mov	r0, r3
30023ba8:	e3a01000 	mov	r1, #0
30023bac:	e3a02020 	mov	r2, #32
30023bb0:	ebffa227 	bl	3000c454 <acoral_memset>
		parse_args(buf, &argc, argv, &resid,&stacked_state);
30023bb4:	e28d103c 	add	r1, sp, #60	; 0x3c
30023bb8:	e28d201c 	add	r2, sp, #28
30023bbc:	e28d3018 	add	r3, sp, #24
30023bc0:	e28d0017 	add	r0, sp, #23
30023bc4:	e58d0000 	str	r0, [sp]
30023bc8:	e59d000c 	ldr	r0, [sp, #12]
30023bcc:	ebffff09 	bl	300237f8 <parse_args>
		if (argc > 0)
30023bd0:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30023bd4:	e3530000 	cmp	r3, #0
30023bd8:	da000004 	ble	30023bf0 <cmd_exe+0x60>
			execmd(argc, (const acoral_char **)argv);
30023bdc:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
30023be0:	e28d301c 	add	r3, sp, #28
30023be4:	e1a00002 	mov	r0, r2
30023be8:	e1a01003 	mov	r1, r3
30023bec:	ebffffc7 	bl	30023b10 <execmd>
		buf = resid;
30023bf0:	e59d3018 	ldr	r3, [sp, #24]
30023bf4:	e58d300c 	str	r3, [sp, #12]
void cmd_exe(acoral_char *buf){
	acoral_32 argc;
	acoral_char *argv[MAX_ARGS_NUM];
	acoral_char *resid;
	enum parse_state stacked_state;
	while (*buf) {
30023bf8:	e59d300c 	ldr	r3, [sp, #12]
30023bfc:	e5d33000 	ldrb	r3, [r3]
30023c00:	e3530000 	cmp	r3, #0
30023c04:	1affffe5 	bne	30023ba0 <cmd_exe+0x10>
		parse_args(buf, &argc, argv, &resid,&stacked_state);
		if (argc > 0)
			execmd(argc, (const acoral_char **)argv);
		buf = resid;
	}	
}
30023c08:	e28dd044 	add	sp, sp, #68	; 0x44
30023c0c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023c10:	e12fff1e 	bx	lr

30023c14 <echo>:

void echo(acoral_char c){
30023c14:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023c18:	e24dd00c 	sub	sp, sp, #12
30023c1c:	e1a03000 	mov	r3, r0
30023c20:	e5cd3007 	strb	r3, [sp, #7]
	acoral_putchar(c);
30023c24:	e5dd3007 	ldrb	r3, [sp, #7]
30023c28:	e1a00003 	mov	r0, r3
30023c2c:	ebff9e4b 	bl	3000b560 <acoral_putchar>
}
30023c30:	e28dd00c 	add	sp, sp, #12
30023c34:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023c38:	e12fff1e 	bx	lr

30023c3c <get_cmd>:

void get_cmd(acoral_char *cmd_buf){
30023c3c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023c40:	e24dd024 	sub	sp, sp, #36	; 0x24
30023c44:	e58d000c 	str	r0, [sp, #12]
	acoral_u32 cur_pos;
	acoral_char c;
	acoral_u8 IsEcho=0;
30023c48:	e3a03000 	mov	r3, #0
30023c4c:	e5cd3016 	strb	r3, [sp, #22]
	acoral_id console_id;
	console_id=acoral_cur_thread->console_id;
30023c50:	e59f31a8 	ldr	r3, [pc, #424]	; 30023e00 <get_cmd+0x1c4>
30023c54:	e5933000 	ldr	r3, [r3]
30023c58:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
30023c5c:	e58d301c 	str	r3, [sp, #28]
	acoral_dev_config(console_id,CONSOLE_ECHO,&IsEcho,0);
30023c60:	e28d3016 	add	r3, sp, #22
30023c64:	e59d001c 	ldr	r0, [sp, #28]
30023c68:	e3a01001 	mov	r1, #1
30023c6c:	e1a02003 	mov	r2, r3
30023c70:	e3a03000 	mov	r3, #0
30023c74:	eb000283 	bl	30024688 <acoral_dev_config>
	cur_pos=0;
30023c78:	e3a03000 	mov	r3, #0
30023c7c:	e58d3018 	str	r3, [sp, #24]
30023c80:	ea000000 	b	30023c88 <get_cmd+0x4c>
						echo(c);
					cur_pos++;
				}
				break;
		}
	}
30023c84:	e1a00000 	nop			; (mov r0, r0)
	acoral_id console_id;
	console_id=acoral_cur_thread->console_id;
	acoral_dev_config(console_id,CONSOLE_ECHO,&IsEcho,0);
	cur_pos=0;
	while(1){
		while(acoral_dev_read(console_id,&c,1,0,0)<1);
30023c88:	e28d3017 	add	r3, sp, #23
30023c8c:	e3a02000 	mov	r2, #0
30023c90:	e58d2000 	str	r2, [sp]
30023c94:	e59d001c 	ldr	r0, [sp, #28]
30023c98:	e1a01003 	mov	r1, r3
30023c9c:	e3a02001 	mov	r2, #1
30023ca0:	e3a03000 	mov	r3, #0
30023ca4:	eb000251 	bl	300245f0 <acoral_dev_read>
30023ca8:	e1a03000 	mov	r3, r0
30023cac:	e3530000 	cmp	r3, #0
30023cb0:	dafffff4 	ble	30023c88 <get_cmd+0x4c>
		switch (c) {
30023cb4:	e5dd3017 	ldrb	r3, [sp, #23]
30023cb8:	e353000a 	cmp	r3, #10
30023cbc:	0a000028 	beq	30023d64 <get_cmd+0x128>
30023cc0:	e353000a 	cmp	r3, #10
30023cc4:	ca000007 	bgt	30023ce8 <get_cmd+0xac>
30023cc8:	e3530000 	cmp	r3, #0
30023ccc:	0a000024 	beq	30023d64 <get_cmd+0x128>
30023cd0:	e3530000 	cmp	r3, #0
30023cd4:	ba000036 	blt	30023db4 <get_cmd+0x178>
30023cd8:	e2433006 	sub	r3, r3, #6
30023cdc:	e3530002 	cmp	r3, #2
30023ce0:	8a000033 	bhi	30023db4 <get_cmd+0x178>
30023ce4:	ea000009 	b	30023d10 <get_cmd+0xd4>
30023ce8:	e3530018 	cmp	r3, #24
30023cec:	0a00002d 	beq	30023da8 <get_cmd+0x16c>
30023cf0:	e3530018 	cmp	r3, #24
30023cf4:	ca000002 	bgt	30023d04 <get_cmd+0xc8>
30023cf8:	e353000d 	cmp	r3, #13
30023cfc:	0a000018 	beq	30023d64 <get_cmd+0x128>
30023d00:	ea00002b 	b	30023db4 <get_cmd+0x178>
30023d04:	e243307e 	sub	r3, r3, #126	; 0x7e
30023d08:	e3530001 	cmp	r3, #1
30023d0c:	8a000028 	bhi	30023db4 <get_cmd+0x178>
			case 0x08:
			case 0x06:
			case 0x07:
			case 0x7E:
			case 0x7F:
				if (cur_pos) {
30023d10:	e59d3018 	ldr	r3, [sp, #24]
30023d14:	e3530000 	cmp	r3, #0
30023d18:	0a00000b 	beq	30023d4c <get_cmd+0x110>
					cur_pos--;
30023d1c:	e59d3018 	ldr	r3, [sp, #24]
30023d20:	e2433001 	sub	r3, r3, #1
30023d24:	e58d3018 	str	r3, [sp, #24]
					if(IsEcho){
30023d28:	e5dd3016 	ldrb	r3, [sp, #22]
30023d2c:	e3530000 	cmp	r3, #0
30023d30:	0a000005 	beq	30023d4c <get_cmd+0x110>
						echo(0x08);
30023d34:	e3a00008 	mov	r0, #8
30023d38:	ebffffb5 	bl	30023c14 <echo>
						echo(' ');
30023d3c:	e3a00020 	mov	r0, #32
30023d40:	ebffffb3 	bl	30023c14 <echo>
						echo(0x08);
30023d44:	e3a00008 	mov	r0, #8
30023d48:	ebffffb1 	bl	30023c14 <echo>
					}
				}
				cmd_buf[cur_pos] = '\0';
30023d4c:	e59d200c 	ldr	r2, [sp, #12]
30023d50:	e59d3018 	ldr	r3, [sp, #24]
30023d54:	e0823003 	add	r3, r2, r3
30023d58:	e3a02000 	mov	r2, #0
30023d5c:	e5c32000 	strb	r2, [r3]
				break;
30023d60:	ea000025 	b	30023dfc <get_cmd+0x1c0>
			case '\r':
			case '\n':
			case '\0':
				echo('\r');
30023d64:	e3a0000d 	mov	r0, #13
30023d68:	ebffffa9 	bl	30023c14 <echo>
				echo('\n');
30023d6c:	e3a0000a 	mov	r0, #10
30023d70:	ebffffa7 	bl	30023c14 <echo>
				cmd_buf[cur_pos]='\0';
30023d74:	e59d200c 	ldr	r2, [sp, #12]
30023d78:	e59d3018 	ldr	r3, [sp, #24]
30023d7c:	e0823003 	add	r3, r2, r3
30023d80:	e3a02000 	mov	r2, #0
30023d84:	e5c32000 	strb	r2, [r3]
				acoral_dev_config(console_id,CONSOLE_BUF_CLEAR,NULL,0);
30023d88:	e59d001c 	ldr	r0, [sp, #28]
30023d8c:	e3a01004 	mov	r1, #4
30023d90:	e3a02000 	mov	r2, #0
30023d94:	e3a03000 	mov	r3, #0
30023d98:	eb00023a 	bl	30024688 <acoral_dev_config>
					cur_pos++;
				}
				break;
		}
	}
}
30023d9c:	e28dd024 	add	sp, sp, #36	; 0x24
30023da0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023da4:	e12fff1e 	bx	lr
				echo('\n');
				cmd_buf[cur_pos]='\0';
				acoral_dev_config(console_id,CONSOLE_BUF_CLEAR,NULL,0);
				return;
			case 'x'-'a'+1:
				cur_pos = 0;
30023da8:	e3a03000 	mov	r3, #0
30023dac:	e58d3018 	str	r3, [sp, #24]
				break;
30023db0:	ea000011 	b	30023dfc <get_cmd+0x1c0>

			default:
				if (cur_pos < BUF_SIZE) {
30023db4:	e59d3018 	ldr	r3, [sp, #24]
30023db8:	e353007f 	cmp	r3, #127	; 0x7f
30023dbc:	8affffb0 	bhi	30023c84 <get_cmd+0x48>
					cmd_buf[cur_pos] = c;
30023dc0:	e59d200c 	ldr	r2, [sp, #12]
30023dc4:	e59d3018 	ldr	r3, [sp, #24]
30023dc8:	e0823003 	add	r3, r2, r3
30023dcc:	e5dd2017 	ldrb	r2, [sp, #23]
30023dd0:	e5c32000 	strb	r2, [r3]
					if(IsEcho)
30023dd4:	e5dd3016 	ldrb	r3, [sp, #22]
30023dd8:	e3530000 	cmp	r3, #0
30023ddc:	0a000002 	beq	30023dec <get_cmd+0x1b0>
						echo(c);
30023de0:	e5dd3017 	ldrb	r3, [sp, #23]
30023de4:	e1a00003 	mov	r0, r3
30023de8:	ebffff89 	bl	30023c14 <echo>
					cur_pos++;
30023dec:	e59d3018 	ldr	r3, [sp, #24]
30023df0:	e2833001 	add	r3, r3, #1
30023df4:	e58d3018 	str	r3, [sp, #24]
				}
				break;
		}
	}
30023df8:	eaffffa2 	b	30023c88 <get_cmd+0x4c>
30023dfc:	eaffffa1 	b	30023c88 <get_cmd+0x4c>
30023e00:	3002b350 	.word	0x3002b350

30023e04 <acoral_shell_init>:
}

#define SHELL_STACK_SIZE 1024
void acoral_shell_init(){
30023e04:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023e08:	e24dd01c 	sub	sp, sp, #28
	acoral_comm_policy_data_t data;
	head_cmd=NULL;
30023e0c:	e59f3070 	ldr	r3, [pc, #112]	; 30023e84 <acoral_shell_init+0x80>
30023e10:	e3a02000 	mov	r2, #0
30023e14:	e5832000 	str	r2, [r3]
	tail_cmd=NULL;
30023e18:	e59f3068 	ldr	r3, [pc, #104]	; 30023e88 <acoral_shell_init+0x84>
30023e1c:	e3a02000 	mov	r2, #0
30023e20:	e5832000 	str	r2, [r3]
	cmd_init();
30023e24:	eb000094 	bl	3002407c <cmd_init>
#ifdef CFG_UART_SHELL
	data.cpu=acoral_current_cpu;
30023e28:	e3a03000 	mov	r3, #0
30023e2c:	e5cd3014 	strb	r3, [sp, #20]
	data.prio=ACORAL_TMP_PRIO;
30023e30:	e3a03045 	mov	r3, #69	; 0x45
30023e34:	e5cd3015 	strb	r3, [sp, #21]
	data.prio_type=ACORAL_ABSOLUTE_PRIO;
30023e38:	e3a03004 	mov	r3, #4
30023e3c:	e5cd3016 	strb	r3, [sp, #22]
	acoral_create_thread_ext(acoral_shell_enter,SHELL_STACK_SIZE,(void *)acoral_cur_thread->console_id,"shell",NULL,ACORAL_SCHED_POLICY_COMM,&data);
30023e40:	e59f3044 	ldr	r3, [pc, #68]	; 30023e8c <acoral_shell_init+0x88>
30023e44:	e5933000 	ldr	r3, [r3]
30023e48:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
30023e4c:	e3a02000 	mov	r2, #0
30023e50:	e58d2000 	str	r2, [sp]
30023e54:	e3a02015 	mov	r2, #21
30023e58:	e58d2004 	str	r2, [sp, #4]
30023e5c:	e28d2014 	add	r2, sp, #20
30023e60:	e58d2008 	str	r2, [sp, #8]
30023e64:	e59f0024 	ldr	r0, [pc, #36]	; 30023e90 <acoral_shell_init+0x8c>
30023e68:	e3a01b01 	mov	r1, #1024	; 0x400
30023e6c:	e1a02003 	mov	r2, r3
30023e70:	e59f301c 	ldr	r3, [pc, #28]	; 30023e94 <acoral_shell_init+0x90>
30023e74:	ebff7774 	bl	30001c4c <create_thread_ext>
#endif
}
30023e78:	e28dd01c 	add	sp, sp, #28
30023e7c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023e80:	e12fff1e 	bx	lr
30023e84:	3002a880 	.word	0x3002a880
30023e88:	3002b378 	.word	0x3002b378
30023e8c:	3002b350 	.word	0x3002b350
30023e90:	30023ebc 	.word	0x30023ebc
30023e94:	30026644 	.word	0x30026644

30023e98 <acoral_shell_exit>:

void acoral_shell_exit(void *ptr){
30023e98:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023e9c:	e24dd00c 	sub	sp, sp, #12
30023ea0:	e58d0004 	str	r0, [sp, #4]
	acoral_free(ptr);
30023ea4:	e59d0004 	ldr	r0, [sp, #4]
30023ea8:	ebff89fa 	bl	30006698 <buddy_free>
	acoral_thread_exit();
30023eac:	ebff7aed 	bl	30002a68 <acoral_thread_exit>
}
30023eb0:	e28dd00c 	add	sp, sp, #12
30023eb4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023eb8:	e12fff1e 	bx	lr

30023ebc <acoral_shell_enter>:

void acoral_shell_enter(void *args){
30023ebc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023ec0:	e24dd014 	sub	sp, sp, #20
30023ec4:	e58d0004 	str	r0, [sp, #4]
	acoral_char *cmd_buf;
	acoral_set_thread_console((acoral_id)args);
30023ec8:	e59d3004 	ldr	r3, [sp, #4]
30023ecc:	e1a00003 	mov	r0, r3
30023ed0:	ebff7c13 	bl	30002f24 <acoral_set_thread_console>
	if(acoral_cur_thread->console_id<0){
30023ed4:	e59f306c 	ldr	r3, [pc, #108]	; 30023f48 <acoral_shell_enter+0x8c>
30023ed8:	e5933000 	ldr	r3, [r3]
30023edc:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
30023ee0:	e3530000 	cmp	r3, #0
30023ee4:	aa000004 	bge	30023efc <acoral_shell_enter+0x40>
		acoral_prints("The thread have no Console\n");
30023ee8:	e59f005c 	ldr	r0, [pc, #92]	; 30023f4c <acoral_shell_enter+0x90>
30023eec:	ebff9d70 	bl	3000b4b4 <acoral_prints>
		acoral_prints("aCoral:>");
		get_cmd(cmd_buf);
		if(cmd_buf[0])
			cmd_exe(cmd_buf);
	}
}
30023ef0:	e28dd014 	add	sp, sp, #20
30023ef4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023ef8:	e12fff1e 	bx	lr
	acoral_set_thread_console((acoral_id)args);
	if(acoral_cur_thread->console_id<0){
		acoral_prints("The thread have no Console\n");
		return;
	}
	cmd_buf=acoral_malloc(sizeof(BUF_SIZE));
30023efc:	e3a00004 	mov	r0, #4
30023f00:	ebff89ac 	bl	300065b8 <buddy_malloc>
30023f04:	e1a03000 	mov	r3, r0
30023f08:	e58d300c 	str	r3, [sp, #12]
30023f0c:	ea000000 	b	30023f14 <acoral_shell_enter+0x58>
		acoral_prints("\r\n");
		acoral_prints("aCoral:>");
		get_cmd(cmd_buf);
		if(cmd_buf[0])
			cmd_exe(cmd_buf);
	}
30023f10:	e1a00000 	nop			; (mov r0, r0)
		acoral_prints("The thread have no Console\n");
		return;
	}
	cmd_buf=acoral_malloc(sizeof(BUF_SIZE));
	while(1){
		acoral_prints("\r\n");
30023f14:	e59f0034 	ldr	r0, [pc, #52]	; 30023f50 <acoral_shell_enter+0x94>
30023f18:	ebff9d65 	bl	3000b4b4 <acoral_prints>
		acoral_prints("aCoral:>");
30023f1c:	e59f0030 	ldr	r0, [pc, #48]	; 30023f54 <acoral_shell_enter+0x98>
30023f20:	ebff9d63 	bl	3000b4b4 <acoral_prints>
		get_cmd(cmd_buf);
30023f24:	e59d000c 	ldr	r0, [sp, #12]
30023f28:	ebffff43 	bl	30023c3c <get_cmd>
		if(cmd_buf[0])
30023f2c:	e59d300c 	ldr	r3, [sp, #12]
30023f30:	e5d33000 	ldrb	r3, [r3]
30023f34:	e3530000 	cmp	r3, #0
30023f38:	0afffff4 	beq	30023f10 <acoral_shell_enter+0x54>
			cmd_exe(cmd_buf);
30023f3c:	e59d000c 	ldr	r0, [sp, #12]
30023f40:	ebffff12 	bl	30023b90 <cmd_exe>
	}
30023f44:	eafffff2 	b	30023f14 <acoral_shell_enter+0x58>
30023f48:	3002b350 	.word	0x3002b350
30023f4c:	3002664c 	.word	0x3002664c
30023f50:	30026668 	.word	0x30026668
30023f54:	3002666c 	.word	0x3002666c

30023f58 <malloc_scan>:
#include<kernel.h>
#include"../include/shell.h"
#include"console.h"
void malloc_scan(acoral_32 argc,acoral_char **argv){
30023f58:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023f5c:	e24dd00c 	sub	sp, sp, #12
30023f60:	e58d0004 	str	r0, [sp, #4]
30023f64:	e58d1000 	str	r1, [sp]
	acoral_mem_scan();
30023f68:	ebff85a1 	bl	300055f4 <buddy_scan>
}
30023f6c:	e28dd00c 	add	sp, sp, #12
30023f70:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023f74:	e12fff1e 	bx	lr

30023f78 <malloc_scan2>:
	malloc_scan,
	"View the first Level Memory Managment Info",
	NULL
};

void malloc_scan2(acoral_32 argc,acoral_char **argv){
30023f78:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023f7c:	e24dd00c 	sub	sp, sp, #12
30023f80:	e58d0004 	str	r0, [sp, #4]
30023f84:	e58d1000 	str	r1, [sp]
	acoral_mem_scan2();
30023f88:	ebff8c8a 	bl	300071b8 <v_mem_scan>
}
30023f8c:	e28dd00c 	add	sp, sp, #12
30023f90:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023f94:	e12fff1e 	bx	lr

30023f98 <help>:
	"View the seconde Level Memory Managment Info",
	NULL
};

extern acoral_shell_cmd_t *head_cmd;
void help(acoral_32 argc,acoral_char **argv){
30023f98:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023f9c:	e24dd014 	sub	sp, sp, #20
30023fa0:	e58d0004 	str	r0, [sp, #4]
30023fa4:	e58d1000 	str	r1, [sp]
	acoral_shell_cmd_t *curr;
	curr =head_cmd;
30023fa8:	e59f304c 	ldr	r3, [pc, #76]	; 30023ffc <help+0x64>
30023fac:	e5933000 	ldr	r3, [r3]
30023fb0:	e58d300c 	str	r3, [sp, #12]
	while(curr != NULL) {
30023fb4:	ea00000a 	b	30023fe4 <help+0x4c>
		acoral_print("%s  %s\n",curr->name,curr->comment);
30023fb8:	e59d300c 	ldr	r3, [sp, #12]
30023fbc:	e5932000 	ldr	r2, [r3]
30023fc0:	e59d300c 	ldr	r3, [sp, #12]
30023fc4:	e5933008 	ldr	r3, [r3, #8]
30023fc8:	e59f0030 	ldr	r0, [pc, #48]	; 30024000 <help+0x68>
30023fcc:	e1a01002 	mov	r1, r2
30023fd0:	e1a02003 	mov	r2, r3
30023fd4:	ebff9d13 	bl	3000b428 <acoral_print>
		curr = curr->next;
30023fd8:	e59d300c 	ldr	r3, [sp, #12]
30023fdc:	e593300c 	ldr	r3, [r3, #12]
30023fe0:	e58d300c 	str	r3, [sp, #12]

extern acoral_shell_cmd_t *head_cmd;
void help(acoral_32 argc,acoral_char **argv){
	acoral_shell_cmd_t *curr;
	curr =head_cmd;
	while(curr != NULL) {
30023fe4:	e59d300c 	ldr	r3, [sp, #12]
30023fe8:	e3530000 	cmp	r3, #0
30023fec:	1afffff1 	bne	30023fb8 <help+0x20>
		acoral_print("%s  %s\n",curr->name,curr->comment);
		curr = curr->next;
	}
}
30023ff0:	e28dd014 	add	sp, sp, #20
30023ff4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023ff8:	e12fff1e 	bx	lr
30023ffc:	3002a880 	.word	0x3002a880
30024000:	300266e8 	.word	0x300266e8

30024004 <exit>:
	help,
	"View all Shell Command info",
	NULL
};

void exit(acoral_32 argc,acoral_char **argv){
30024004:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30024008:	e24dd00c 	sub	sp, sp, #12
3002400c:	e58d0004 	str	r0, [sp, #4]
30024010:	e58d1000 	str	r1, [sp]
	acoral_dev_config(acoral_cur_thread->console_id,CONSOLE_EXIT,NULL,0);
30024014:	e59f3034 	ldr	r3, [pc, #52]	; 30024050 <exit+0x4c>
30024018:	e5933000 	ldr	r3, [r3]
3002401c:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
30024020:	e1a00003 	mov	r0, r3
30024024:	e3a01003 	mov	r1, #3
30024028:	e3a02000 	mov	r2, #0
3002402c:	e3a03000 	mov	r3, #0
30024030:	eb000194 	bl	30024688 <acoral_dev_config>
	acoral_shell_exit((void *)argv[0]);
30024034:	e59d3000 	ldr	r3, [sp]
30024038:	e5933000 	ldr	r3, [r3]
3002403c:	e1a00003 	mov	r0, r3
30024040:	ebffff94 	bl	30023e98 <acoral_shell_exit>
}
30024044:	e28dd00c 	add	sp, sp, #12
30024048:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002404c:	e12fff1e 	bx	lr
30024050:	3002b350 	.word	0x3002b350

30024054 <spg>:
	"exit",
	exit,
	"Exit Shell",
	NULL
};
void spg(acoral_32 argc,acoral_char **argv){
30024054:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30024058:	e24dd00c 	sub	sp, sp, #12
3002405c:	e58d0004 	str	r0, [sp, #4]
30024060:	e58d1000 	str	r1, [sp]
	acoral_prints("SPGGOGOGO!!!");
30024064:	e59f000c 	ldr	r0, [pc, #12]	; 30024078 <spg+0x24>
30024068:	ebff9d11 	bl	3000b4b4 <acoral_prints>
}
3002406c:	e28dd00c 	add	sp, sp, #12
30024070:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30024074:	e12fff1e 	bx	lr
30024078:	30026728 	.word	0x30026728

3002407c <cmd_init>:
};
#endif

extern acoral_shell_cmd_t dt_cmd;
extern fs_cmd_init();
void cmd_init(){
3002407c:	e92d4008 	push	{r3, lr}
	add_command(&mem_cmd);
30024080:	e59f0028 	ldr	r0, [pc, #40]	; 300240b0 <cmd_init+0x34>
30024084:	ebfffe6b 	bl	30023a38 <add_command>
	//add_command(&mem2_cmd);
	add_command(&dt_cmd);
30024088:	e59f0024 	ldr	r0, [pc, #36]	; 300240b4 <cmd_init+0x38>
3002408c:	ebfffe69 	bl	30023a38 <add_command>
	add_command(&spg_cmd);
30024090:	e59f0020 	ldr	r0, [pc, #32]	; 300240b8 <cmd_init+0x3c>
30024094:	ebfffe67 	bl	30023a38 <add_command>
#ifdef CFG_PM
	add_command(&suspend_cmd);
#endif
	add_command(&exit_cmd);
30024098:	e59f001c 	ldr	r0, [pc, #28]	; 300240bc <cmd_init+0x40>
3002409c:	ebfffe65 	bl	30023a38 <add_command>
	add_command(&help_cmd);
300240a0:	e59f0018 	ldr	r0, [pc, #24]	; 300240c0 <cmd_init+0x44>
300240a4:	ebfffe63 	bl	30023a38 <add_command>
#ifdef CFG_SHELL_FS_CMD
	fs_cmd_init();
#endif

}
300240a8:	e8bd4008 	pop	{r3, lr}
300240ac:	e12fff1e 	bx	lr
300240b0:	300268d8 	.word	0x300268d8
300240b4:	30026928 	.word	0x30026928
300240b8:	30026918 	.word	0x30026918
300240bc:	30026908 	.word	0x30026908
300240c0:	300268f8 	.word	0x300268f8

300240c4 <display_thread>:
#include<thread.h>
#include<policy.h>
#include<hal.h>
#include"../include/shell.h"
void display_thread(acoral_32 argc,acoral_char **argv){
300240c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300240c8:	e24dd01c 	sub	sp, sp, #28
300240cc:	e58d0004 	str	r0, [sp, #4]
300240d0:	e58d1000 	str	r1, [sp]
	acoral_sr cpu_sr;	
	acoral_list_t *head,*tmp;
	acoral_thread_t * thread;
	head=&acoral_threads_queue.head;
300240d4:	e59f31b4 	ldr	r3, [pc, #436]	; 30024290 <display_thread+0x1cc>
300240d8:	e58d300c 	str	r3, [sp, #12]
	acoral_prints("\t\tSystem Thread Information\r\n");
300240dc:	e59f01b0 	ldr	r0, [pc, #432]	; 30024294 <display_thread+0x1d0>
300240e0:	ebff9cf3 	bl	3000b4b4 <acoral_prints>
	acoral_prints("------------------------------------------------------\r\n");
300240e4:	e59f01ac 	ldr	r0, [pc, #428]	; 30024298 <display_thread+0x1d4>
300240e8:	ebff9cf1 	bl	3000b4b4 <acoral_prints>
	acoral_prints("Name\t\tType\t\tConsole\t\tState\r\n");
300240ec:	e59f01a8 	ldr	r0, [pc, #424]	; 3002429c <display_thread+0x1d8>
300240f0:	ebff9cef 	bl	3000b4b4 <acoral_prints>
	HAL_ENTER_CRITICAL();
300240f4:	ebff757e 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300240f8:	e1a03000 	mov	r3, r0
300240fc:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&acoral_threads_queue.head.lock);
	for(tmp=head->next;tmp!=head;tmp=tmp->next){
30024100:	e59d300c 	ldr	r3, [sp, #12]
30024104:	e5933000 	ldr	r3, [r3]
30024108:	e58d3010 	str	r3, [sp, #16]
3002410c:	ea000054 	b	30024264 <display_thread+0x1a0>
		thread=list_entry(tmp,acoral_thread_t,global_list);
30024110:	e59d3010 	ldr	r3, [sp, #16]
30024114:	e2433028 	sub	r3, r3, #40	; 0x28
30024118:	e58d3014 	str	r3, [sp, #20]
		acoral_print("%s\t\t",thread->name);
3002411c:	e59d3014 	ldr	r3, [sp, #20]
30024120:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30024124:	e59f0174 	ldr	r0, [pc, #372]	; 300242a0 <display_thread+0x1dc>
30024128:	e1a01003 	mov	r1, r3
3002412c:	ebff9cbd 	bl	3000b428 <acoral_print>
		switch(thread->policy){
30024130:	e59d3014 	ldr	r3, [sp, #20]
30024134:	e5d3300c 	ldrb	r3, [r3, #12]
30024138:	e2433015 	sub	r3, r3, #21
3002413c:	e3530004 	cmp	r3, #4
30024140:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30024144:	ea000012 	b	30024194 <display_thread+0xd0>
30024148:	3002415c 	.word	0x3002415c
3002414c:	30024174 	.word	0x30024174
30024150:	30024180 	.word	0x30024180
30024154:	30024168 	.word	0x30024168
30024158:	3002418c 	.word	0x3002418c
			case ACORAL_SCHED_POLICY_COMM:
				acoral_prints("Common\t\t");
3002415c:	e59f0140 	ldr	r0, [pc, #320]	; 300242a4 <display_thread+0x1e0>
30024160:	ebff9cd3 	bl	3000b4b4 <acoral_prints>
				break;
30024164:	ea00000a 	b	30024194 <display_thread+0xd0>
			case ACORAL_SCHED_POLICY_SLICE:
				acoral_prints("Slice\t\t");
30024168:	e59f0138 	ldr	r0, [pc, #312]	; 300242a8 <display_thread+0x1e4>
3002416c:	ebff9cd0 	bl	3000b4b4 <acoral_prints>
				break;
30024170:	ea000007 	b	30024194 <display_thread+0xd0>
			case ACORAL_SCHED_POLICY_PERIOD:
				acoral_prints("Period\t\t");
30024174:	e59f0130 	ldr	r0, [pc, #304]	; 300242ac <display_thread+0x1e8>
30024178:	ebff9ccd 	bl	3000b4b4 <acoral_prints>
				break;
3002417c:	ea000004 	b	30024194 <display_thread+0xd0>
			case ACORAL_SCHED_POLICY_RM:
				acoral_prints("RM\t\t");
30024180:	e59f0128 	ldr	r0, [pc, #296]	; 300242b0 <display_thread+0x1ec>
30024184:	ebff9cca 	bl	3000b4b4 <acoral_prints>
				break;
30024188:	ea000001 	b	30024194 <display_thread+0xd0>
			case ACORAL_SCHED_POLICY_POSIX:
				acoral_prints("Posix\t\t");
3002418c:	e59f0120 	ldr	r0, [pc, #288]	; 300242b4 <display_thread+0x1f0>
30024190:	ebff9cc7 	bl	3000b4b4 <acoral_prints>
			default:
				break;
		}
		acoral_print("%d\t\t",thread->console_id);
30024194:	e59d3014 	ldr	r3, [sp, #20]
30024198:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
3002419c:	e59f0114 	ldr	r0, [pc, #276]	; 300242b8 <display_thread+0x1f4>
300241a0:	e1a01003 	mov	r1, r3
300241a4:	ebff9c9f 	bl	3000b428 <acoral_print>
		if(thread->state&ACORAL_THREAD_STATE_RUNNING)
300241a8:	e59d3014 	ldr	r3, [sp, #20]
300241ac:	e5d33004 	ldrb	r3, [r3, #4]
300241b0:	e2033004 	and	r3, r3, #4
300241b4:	e3530000 	cmp	r3, #0
300241b8:	0a000002 	beq	300241c8 <display_thread+0x104>
				acoral_prints("Running\t\t");
300241bc:	e59f00f8 	ldr	r0, [pc, #248]	; 300242bc <display_thread+0x1f8>
300241c0:	ebff9cbb 	bl	3000b4b4 <acoral_prints>
300241c4:	ea000021 	b	30024250 <display_thread+0x18c>
		else if(thread->state&ACORAL_THREAD_STATE_READY)
300241c8:	e59d3014 	ldr	r3, [sp, #20]
300241cc:	e5d33004 	ldrb	r3, [r3, #4]
300241d0:	e2033001 	and	r3, r3, #1
300241d4:	e20330ff 	and	r3, r3, #255	; 0xff
300241d8:	e3530000 	cmp	r3, #0
300241dc:	0a000002 	beq	300241ec <display_thread+0x128>
				acoral_prints("Ready\t\t");
300241e0:	e59f00d8 	ldr	r0, [pc, #216]	; 300242c0 <display_thread+0x1fc>
300241e4:	ebff9cb2 	bl	3000b4b4 <acoral_prints>
300241e8:	ea000018 	b	30024250 <display_thread+0x18c>
		else if(thread->state&ACORAL_THREAD_STATE_DELAY)
300241ec:	e59d3014 	ldr	r3, [sp, #20]
300241f0:	e5d33004 	ldrb	r3, [r3, #4]
300241f4:	e2033020 	and	r3, r3, #32
300241f8:	e3530000 	cmp	r3, #0
300241fc:	0a000002 	beq	3002420c <display_thread+0x148>
				acoral_prints("Delay\t\t");
30024200:	e59f00bc 	ldr	r0, [pc, #188]	; 300242c4 <display_thread+0x200>
30024204:	ebff9caa 	bl	3000b4b4 <acoral_prints>
30024208:	ea000010 	b	30024250 <display_thread+0x18c>
		else if(thread->state&ACORAL_THREAD_STATE_SUSPEND)
3002420c:	e59d3014 	ldr	r3, [sp, #20]
30024210:	e5d33004 	ldrb	r3, [r3, #4]
30024214:	e2033002 	and	r3, r3, #2
30024218:	e3530000 	cmp	r3, #0
3002421c:	0a000002 	beq	3002422c <display_thread+0x168>
				acoral_prints("Sleep\t\t");
30024220:	e59f00a0 	ldr	r0, [pc, #160]	; 300242c8 <display_thread+0x204>
30024224:	ebff9ca2 	bl	3000b4b4 <acoral_prints>
30024228:	ea000008 	b	30024250 <display_thread+0x18c>
		else if(thread->state==ACORAL_THREAD_STATE_EXIT)
3002422c:	e59d3014 	ldr	r3, [sp, #20]
30024230:	e5d33004 	ldrb	r3, [r3, #4]
30024234:	e3530008 	cmp	r3, #8
30024238:	1a000002 	bne	30024248 <display_thread+0x184>
				acoral_prints("Freeze\t\t");
3002423c:	e59f0088 	ldr	r0, [pc, #136]	; 300242cc <display_thread+0x208>
30024240:	ebff9c9b 	bl	3000b4b4 <acoral_prints>
30024244:	ea000001 	b	30024250 <display_thread+0x18c>
		else
				acoral_prints("Error\t\t");
30024248:	e59f0080 	ldr	r0, [pc, #128]	; 300242d0 <display_thread+0x20c>
3002424c:	ebff9c98 	bl	3000b4b4 <acoral_prints>
		acoral_prints("\r\n");
30024250:	e59f007c 	ldr	r0, [pc, #124]	; 300242d4 <display_thread+0x210>
30024254:	ebff9c96 	bl	3000b4b4 <acoral_prints>
	acoral_prints("\t\tSystem Thread Information\r\n");
	acoral_prints("------------------------------------------------------\r\n");
	acoral_prints("Name\t\tType\t\tConsole\t\tState\r\n");
	HAL_ENTER_CRITICAL();
	acoral_spin_lock(&acoral_threads_queue.head.lock);
	for(tmp=head->next;tmp!=head;tmp=tmp->next){
30024258:	e59d3010 	ldr	r3, [sp, #16]
3002425c:	e5933000 	ldr	r3, [r3]
30024260:	e58d3010 	str	r3, [sp, #16]
30024264:	e59d2010 	ldr	r2, [sp, #16]
30024268:	e59d300c 	ldr	r3, [sp, #12]
3002426c:	e1520003 	cmp	r2, r3
30024270:	1affffa6 	bne	30024110 <display_thread+0x4c>
				acoral_prints("Freeze\t\t");
		else
				acoral_prints("Error\t\t");
		acoral_prints("\r\n");
	}
	acoral_prints("------------------------------------------------------\r\n");
30024274:	e59f001c 	ldr	r0, [pc, #28]	; 30024298 <display_thread+0x1d4>
30024278:	ebff9c8d 	bl	3000b4b4 <acoral_prints>
	acoral_spin_unlock(&acoral_threads_queue.head.lock);
	HAL_EXIT_CRITICAL();
3002427c:	e59d0008 	ldr	r0, [sp, #8]
30024280:	ebff7519 	bl	300016ec <HAL_INTR_RESTORE>
}
30024284:	e28dd01c 	add	sp, sp, #28
30024288:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002428c:	e12fff1e 	bx	lr
30024290:	3002a79c 	.word	0x3002a79c
30024294:	30026748 	.word	0x30026748
30024298:	30026768 	.word	0x30026768
3002429c:	300267a4 	.word	0x300267a4
300242a0:	300267c4 	.word	0x300267c4
300242a4:	300267cc 	.word	0x300267cc
300242a8:	300267d8 	.word	0x300267d8
300242ac:	300267e0 	.word	0x300267e0
300242b0:	300267ec 	.word	0x300267ec
300242b4:	300267f4 	.word	0x300267f4
300242b8:	300267fc 	.word	0x300267fc
300242bc:	30026804 	.word	0x30026804
300242c0:	30026810 	.word	0x30026810
300242c4:	30026818 	.word	0x30026818
300242c8:	30026820 	.word	0x30026820
300242cc:	30026828 	.word	0x30026828
300242d0:	30026834 	.word	0x30026834
300242d4:	3002683c 	.word	0x3002683c

300242d8 <acoral_get_drv_ctrl_by_name>:
#define DRV_MAIN_ID_SHIFT 5
#define DRV_MAIN_ID(id) (id>>DRV_MAIN_ID_SHIFT)
#define DRV_CHK_ID(id) (DRV_MAIN_ID(id)>=0&&DRV_MAIN_ID(id)<ACORAL_DEV_NUM)
acoral_pool_ctrl_t acoral_drv_pool_ctrl;
acoral_drv_ctrl_t *drv_table[ACORAL_DEV_NUM];
acoral_drv_ctrl_t *acoral_get_drv_ctrl_by_name(acoral_char *name){
300242d8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300242dc:	e24dd014 	sub	sp, sp, #20
300242e0:	e58d0004 	str	r0, [sp, #4]
  	acoral_u32 i;
	acoral_drv_ctrl_t *ctrl;
	for(i=0;i<ACORAL_DEV_NUM;i++){
300242e4:	e3a03000 	mov	r3, #0
300242e8:	e58d3008 	str	r3, [sp, #8]
300242ec:	ea000013 	b	30024340 <acoral_get_drv_ctrl_by_name+0x68>
	  	ctrl=drv_table[i];	    
300242f0:	e59d2008 	ldr	r2, [sp, #8]
300242f4:	e59f3064 	ldr	r3, [pc, #100]	; 30024360 <acoral_get_drv_ctrl_by_name+0x88>
300242f8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300242fc:	e58d300c 	str	r3, [sp, #12]
		if(ctrl!=NULL&&!acoral_str_cmp(ctrl->name,name))
30024300:	e59d300c 	ldr	r3, [sp, #12]
30024304:	e3530000 	cmp	r3, #0
30024308:	0a000009 	beq	30024334 <acoral_get_drv_ctrl_by_name+0x5c>
3002430c:	e59d300c 	ldr	r3, [sp, #12]
30024310:	e593300c 	ldr	r3, [r3, #12]
30024314:	e1a00003 	mov	r0, r3
30024318:	e59d1004 	ldr	r1, [sp, #4]
3002431c:	ebff9db3 	bl	3000b9f0 <acoral_str_cmp>
30024320:	e1a03000 	mov	r3, r0
30024324:	e3530000 	cmp	r3, #0
30024328:	1a000001 	bne	30024334 <acoral_get_drv_ctrl_by_name+0x5c>
		   return ctrl;
3002432c:	e59d300c 	ldr	r3, [sp, #12]
30024330:	ea000006 	b	30024350 <acoral_get_drv_ctrl_by_name+0x78>
acoral_pool_ctrl_t acoral_drv_pool_ctrl;
acoral_drv_ctrl_t *drv_table[ACORAL_DEV_NUM];
acoral_drv_ctrl_t *acoral_get_drv_ctrl_by_name(acoral_char *name){
  	acoral_u32 i;
	acoral_drv_ctrl_t *ctrl;
	for(i=0;i<ACORAL_DEV_NUM;i++){
30024334:	e59d3008 	ldr	r3, [sp, #8]
30024338:	e2833001 	add	r3, r3, #1
3002433c:	e58d3008 	str	r3, [sp, #8]
30024340:	e59d3008 	ldr	r3, [sp, #8]
30024344:	e3530013 	cmp	r3, #19
30024348:	9affffe8 	bls	300242f0 <acoral_get_drv_ctrl_by_name+0x18>
	  	ctrl=drv_table[i];	    
		if(ctrl!=NULL&&!acoral_str_cmp(ctrl->name,name))
		   return ctrl;
	}
	return NULL;
3002434c:	e3a03000 	mov	r3, #0
}
30024350:	e1a00003 	mov	r0, r3
30024354:	e28dd014 	add	sp, sp, #20
30024358:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002435c:	e12fff1e 	bx	lr
30024360:	3002a0bc 	.word	0x3002a0bc

30024364 <acoral_drv_register>:

acoral_err acoral_drv_register(acoral_dev_ops_t *ops,acoral_char *name){
30024364:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30024368:	e24dd01c 	sub	sp, sp, #28
3002436c:	e58d0004 	str	r0, [sp, #4]
30024370:	e58d1000 	str	r1, [sp]
	acoral_u32 i;
	acoral_drv_ctrl_t *tmp,*ctrl;
	ctrl=acoral_alloc_drv();
30024374:	eb000107 	bl	30024798 <acoral_alloc_drv>
30024378:	e1a03000 	mov	r3, r0
3002437c:	e58d3014 	str	r3, [sp, #20]
	if(ctrl==NULL)
30024380:	e59d3014 	ldr	r3, [sp, #20]
30024384:	e3530000 	cmp	r3, #0
30024388:	1a000001 	bne	30024394 <acoral_drv_register+0x30>
		return ACORAL_ERR_NO_DRV_RES;
3002438c:	e3a03005 	mov	r3, #5
30024390:	ea000024 	b	30024428 <acoral_drv_register+0xc4>
	ctrl->name=name;
30024394:	e59d3014 	ldr	r3, [sp, #20]
30024398:	e59d2000 	ldr	r2, [sp]
3002439c:	e583200c 	str	r2, [r3, #12]
	ctrl->ops=ops;
300243a0:	e59d3014 	ldr	r3, [sp, #20]
300243a4:	e59d2004 	ldr	r2, [sp, #4]
300243a8:	e5832004 	str	r2, [r3, #4]
	for(i=0;i<ACORAL_DEV_NUM;i++){
300243ac:	e3a03000 	mov	r3, #0
300243b0:	e58d300c 	str	r3, [sp, #12]
300243b4:	ea000012 	b	30024404 <acoral_drv_register+0xa0>
	  	tmp=drv_table[i];	    
300243b8:	e59d200c 	ldr	r2, [sp, #12]
300243bc:	e59f3074 	ldr	r3, [pc, #116]	; 30024438 <acoral_drv_register+0xd4>
300243c0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300243c4:	e58d3010 	str	r3, [sp, #16]
		if(tmp==NULL){
300243c8:	e59d3010 	ldr	r3, [sp, #16]
300243cc:	e3530000 	cmp	r3, #0
300243d0:	1a000008 	bne	300243f8 <acoral_drv_register+0x94>
			drv_table[i]=ctrl;
300243d4:	e59d200c 	ldr	r2, [sp, #12]
300243d8:	e59f3058 	ldr	r3, [pc, #88]	; 30024438 <acoral_drv_register+0xd4>
300243dc:	e59d1014 	ldr	r1, [sp, #20]
300243e0:	e7831102 	str	r1, [r3, r2, lsl #2]
			ctrl->drv_id=i<<DRV_MAIN_ID_SHIFT;
300243e4:	e59d300c 	ldr	r3, [sp, #12]
300243e8:	e1a02283 	lsl	r2, r3, #5
300243ec:	e59d3014 	ldr	r3, [sp, #20]
300243f0:	e5832008 	str	r2, [r3, #8]
			break;
300243f4:	ea000005 	b	30024410 <acoral_drv_register+0xac>
	ctrl=acoral_alloc_drv();
	if(ctrl==NULL)
		return ACORAL_ERR_NO_DRV_RES;
	ctrl->name=name;
	ctrl->ops=ops;
	for(i=0;i<ACORAL_DEV_NUM;i++){
300243f8:	e59d300c 	ldr	r3, [sp, #12]
300243fc:	e2833001 	add	r3, r3, #1
30024400:	e58d300c 	str	r3, [sp, #12]
30024404:	e59d300c 	ldr	r3, [sp, #12]
30024408:	e3530013 	cmp	r3, #19
3002440c:	9affffe9 	bls	300243b8 <acoral_drv_register+0x54>
			drv_table[i]=ctrl;
			ctrl->drv_id=i<<DRV_MAIN_ID_SHIFT;
			break;
		}
	}
	if(i==ACORAL_DEV_NUM)
30024410:	e59d300c 	ldr	r3, [sp, #12]
30024414:	e3530014 	cmp	r3, #20
30024418:	1a000001 	bne	30024424 <acoral_drv_register+0xc0>
		return ACORAL_ERR_DRV_FULL;
3002441c:	e3a03005 	mov	r3, #5
30024420:	ea000000 	b	30024428 <acoral_drv_register+0xc4>
	return 0;
30024424:	e3a03000 	mov	r3, #0
}
30024428:	e1a00003 	mov	r0, r3
3002442c:	e28dd01c 	add	sp, sp, #28
30024430:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30024434:	e12fff1e 	bx	lr
30024438:	3002a0bc 	.word	0x3002a0bc

3002443c <acoral_drv_unregister>:

void acoral_drv_unregister(acoral_id res_id){
3002443c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30024440:	e24dd014 	sub	sp, sp, #20
30024444:	e58d0004 	str	r0, [sp, #4]
	acoral_drv_ctrl_t *ctrl=(acoral_drv_ctrl_t *)acoral_get_res_by_id(res_id);
30024448:	e59d0004 	ldr	r0, [sp, #4]
3002444c:	ebff7d07 	bl	30003870 <acoral_get_res_by_id>
30024450:	e1a03000 	mov	r3, r0
30024454:	e58d300c 	str	r3, [sp, #12]
	if(ctrl->ops!=NULL&&ctrl->ops->close!=NULL)
30024458:	e59d300c 	ldr	r3, [sp, #12]
3002445c:	e5933004 	ldr	r3, [r3, #4]
30024460:	e3530000 	cmp	r3, #0
30024464:	0a000009 	beq	30024490 <acoral_drv_unregister+0x54>
30024468:	e59d300c 	ldr	r3, [sp, #12]
3002446c:	e5933004 	ldr	r3, [r3, #4]
30024470:	e5933010 	ldr	r3, [r3, #16]
30024474:	e3530000 	cmp	r3, #0
30024478:	0a000004 	beq	30024490 <acoral_drv_unregister+0x54>
		ctrl->ops->close();
3002447c:	e59d300c 	ldr	r3, [sp, #12]
30024480:	e5933004 	ldr	r3, [r3, #4]
30024484:	e5933010 	ldr	r3, [r3, #16]
30024488:	e1a0e00f 	mov	lr, pc
3002448c:	e12fff13 	bx	r3
	drv_table[DRV_MAIN_ID(ctrl->drv_id)]=NULL;
30024490:	e59d300c 	ldr	r3, [sp, #12]
30024494:	e5933008 	ldr	r3, [r3, #8]
30024498:	e1a022a3 	lsr	r2, r3, #5
3002449c:	e59f301c 	ldr	r3, [pc, #28]	; 300244c0 <acoral_drv_unregister+0x84>
300244a0:	e3a01000 	mov	r1, #0
300244a4:	e7831102 	str	r1, [r3, r2, lsl #2]
	acoral_release_res((acoral_res_t *)ctrl);
300244a8:	e59d300c 	ldr	r3, [sp, #12]
300244ac:	e1a00003 	mov	r0, r3
300244b0:	ebff7c5a 	bl	30003620 <acoral_release_res>
}
300244b4:	e28dd014 	add	sp, sp, #20
300244b8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300244bc:	e12fff1e 	bx	lr
300244c0:	3002a0bc 	.word	0x3002a0bc

300244c4 <acoral_dev_open>:

acoral_id acoral_dev_open(acoral_char *name){
300244c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300244c8:	e24dd014 	sub	sp, sp, #20
300244cc:	e58d0004 	str	r0, [sp, #4]
	acoral_drv_ctrl_t *ctrl=acoral_get_drv_ctrl_by_name(name);
300244d0:	e59d0004 	ldr	r0, [sp, #4]
300244d4:	ebffff7f 	bl	300242d8 <acoral_get_drv_ctrl_by_name>
300244d8:	e1a03000 	mov	r3, r0
300244dc:	e58d300c 	str	r3, [sp, #12]
	if(ctrl==NULL)
300244e0:	e59d300c 	ldr	r3, [sp, #12]
300244e4:	e3530000 	cmp	r3, #0
300244e8:	1a000001 	bne	300244f4 <acoral_dev_open+0x30>
		return ACORAL_DEV_ERR_ID;
300244ec:	e3e03000 	mvn	r3, #0
300244f0:	ea000014 	b	30024548 <acoral_dev_open+0x84>
	if(ctrl->ops!=NULL&&ctrl->ops->open!=NULL){
300244f4:	e59d300c 	ldr	r3, [sp, #12]
300244f8:	e5933004 	ldr	r3, [r3, #4]
300244fc:	e3530000 	cmp	r3, #0
30024500:	0a00000e 	beq	30024540 <acoral_dev_open+0x7c>
30024504:	e59d300c 	ldr	r3, [sp, #12]
30024508:	e5933004 	ldr	r3, [r3, #4]
3002450c:	e5933000 	ldr	r3, [r3]
30024510:	e3530000 	cmp	r3, #0
30024514:	0a000009 	beq	30024540 <acoral_dev_open+0x7c>
		if(ctrl->ops->open()!=0)
30024518:	e59d300c 	ldr	r3, [sp, #12]
3002451c:	e5933004 	ldr	r3, [r3, #4]
30024520:	e5933000 	ldr	r3, [r3]
30024524:	e1a0e00f 	mov	lr, pc
30024528:	e12fff13 	bx	r3
3002452c:	e1a03000 	mov	r3, r0
30024530:	e3530000 	cmp	r3, #0
30024534:	0a000001 	beq	30024540 <acoral_dev_open+0x7c>
			return ACORAL_DEV_ERR_ID;
30024538:	e3e03000 	mvn	r3, #0
3002453c:	ea000001 	b	30024548 <acoral_dev_open+0x84>
	}
	return ctrl->res.id;
30024540:	e59d300c 	ldr	r3, [sp, #12]
30024544:	e5933000 	ldr	r3, [r3]
}
30024548:	e1a00003 	mov	r0, r3
3002454c:	e28dd014 	add	sp, sp, #20
30024550:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30024554:	e12fff1e 	bx	lr

30024558 <acoral_dev_write>:

acoral_32 acoral_dev_write(acoral_id id,void *data,acoral_size size,acoral_size offset,acoral_time time_out){
30024558:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002455c:	e24dd01c 	sub	sp, sp, #28
30024560:	e58d000c 	str	r0, [sp, #12]
30024564:	e58d1008 	str	r1, [sp, #8]
30024568:	e58d2004 	str	r2, [sp, #4]
3002456c:	e58d3000 	str	r3, [sp]
	acoral_drv_ctrl_t *ctrl=(acoral_drv_ctrl_t *)acoral_get_res_by_id(id);
30024570:	e59d000c 	ldr	r0, [sp, #12]
30024574:	ebff7cbd 	bl	30003870 <acoral_get_res_by_id>
30024578:	e1a03000 	mov	r3, r0
3002457c:	e58d3014 	str	r3, [sp, #20]
	if(ctrl!=NULL&&ctrl->ops!=NULL&&ctrl->ops->write!=NULL)
30024580:	e59d3014 	ldr	r3, [sp, #20]
30024584:	e3530000 	cmp	r3, #0
30024588:	0a000013 	beq	300245dc <acoral_dev_write+0x84>
3002458c:	e59d3014 	ldr	r3, [sp, #20]
30024590:	e5933004 	ldr	r3, [r3, #4]
30024594:	e3530000 	cmp	r3, #0
30024598:	0a00000f 	beq	300245dc <acoral_dev_write+0x84>
3002459c:	e59d3014 	ldr	r3, [sp, #20]
300245a0:	e5933004 	ldr	r3, [r3, #4]
300245a4:	e5933008 	ldr	r3, [r3, #8]
300245a8:	e3530000 	cmp	r3, #0
300245ac:	0a00000a 	beq	300245dc <acoral_dev_write+0x84>
		return ctrl->ops->write(data,size,offset,time_out);
300245b0:	e59d3014 	ldr	r3, [sp, #20]
300245b4:	e5933004 	ldr	r3, [r3, #4]
300245b8:	e593c008 	ldr	ip, [r3, #8]
300245bc:	e59d0008 	ldr	r0, [sp, #8]
300245c0:	e59d1004 	ldr	r1, [sp, #4]
300245c4:	e59d2000 	ldr	r2, [sp]
300245c8:	e59d3020 	ldr	r3, [sp, #32]
300245cc:	e1a0e00f 	mov	lr, pc
300245d0:	e12fff1c 	bx	ip
300245d4:	e1a03000 	mov	r3, r0
300245d8:	ea000000 	b	300245e0 <acoral_dev_write+0x88>
	return 0;
300245dc:	e3a03000 	mov	r3, #0
}
300245e0:	e1a00003 	mov	r0, r3
300245e4:	e28dd01c 	add	sp, sp, #28
300245e8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300245ec:	e12fff1e 	bx	lr

300245f0 <acoral_dev_read>:

acoral_32 acoral_dev_read(acoral_id id,void *data,acoral_size size,acoral_size offset,acoral_time time_out){
300245f0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300245f4:	e24dd01c 	sub	sp, sp, #28
300245f8:	e58d000c 	str	r0, [sp, #12]
300245fc:	e58d1008 	str	r1, [sp, #8]
30024600:	e58d2004 	str	r2, [sp, #4]
30024604:	e58d3000 	str	r3, [sp]
	acoral_drv_ctrl_t *ctrl=(acoral_drv_ctrl_t *)acoral_get_res_by_id(id);
30024608:	e59d000c 	ldr	r0, [sp, #12]
3002460c:	ebff7c97 	bl	30003870 <acoral_get_res_by_id>
30024610:	e1a03000 	mov	r3, r0
30024614:	e58d3014 	str	r3, [sp, #20]
	if(ctrl!=NULL&&ctrl->ops!=NULL&&ctrl->ops->read!=NULL)
30024618:	e59d3014 	ldr	r3, [sp, #20]
3002461c:	e3530000 	cmp	r3, #0
30024620:	0a000013 	beq	30024674 <acoral_dev_read+0x84>
30024624:	e59d3014 	ldr	r3, [sp, #20]
30024628:	e5933004 	ldr	r3, [r3, #4]
3002462c:	e3530000 	cmp	r3, #0
30024630:	0a00000f 	beq	30024674 <acoral_dev_read+0x84>
30024634:	e59d3014 	ldr	r3, [sp, #20]
30024638:	e5933004 	ldr	r3, [r3, #4]
3002463c:	e5933004 	ldr	r3, [r3, #4]
30024640:	e3530000 	cmp	r3, #0
30024644:	0a00000a 	beq	30024674 <acoral_dev_read+0x84>
		return ctrl->ops->read(data,size,offset,time_out);
30024648:	e59d3014 	ldr	r3, [sp, #20]
3002464c:	e5933004 	ldr	r3, [r3, #4]
30024650:	e593c004 	ldr	ip, [r3, #4]
30024654:	e59d0008 	ldr	r0, [sp, #8]
30024658:	e59d1004 	ldr	r1, [sp, #4]
3002465c:	e59d2000 	ldr	r2, [sp]
30024660:	e59d3020 	ldr	r3, [sp, #32]
30024664:	e1a0e00f 	mov	lr, pc
30024668:	e12fff1c 	bx	ip
3002466c:	e1a03000 	mov	r3, r0
30024670:	ea000000 	b	30024678 <acoral_dev_read+0x88>
	return 0;
30024674:	e3a03000 	mov	r3, #0
}
30024678:	e1a00003 	mov	r0, r3
3002467c:	e28dd01c 	add	sp, sp, #28
30024680:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30024684:	e12fff1e 	bx	lr

30024688 <acoral_dev_config>:

acoral_32 acoral_dev_config(acoral_id id,acoral_u32 cmd,void *data,acoral_time tm_out){
30024688:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002468c:	e24dd01c 	sub	sp, sp, #28
30024690:	e58d000c 	str	r0, [sp, #12]
30024694:	e58d1008 	str	r1, [sp, #8]
30024698:	e58d2004 	str	r2, [sp, #4]
3002469c:	e58d3000 	str	r3, [sp]
	acoral_drv_ctrl_t *ctrl=(acoral_drv_ctrl_t *)acoral_get_res_by_id(id);
300246a0:	e59d000c 	ldr	r0, [sp, #12]
300246a4:	ebff7c71 	bl	30003870 <acoral_get_res_by_id>
300246a8:	e1a03000 	mov	r3, r0
300246ac:	e58d3014 	str	r3, [sp, #20]
	if(ctrl!=NULL&&ctrl->ops!=NULL&&ctrl->ops->config!=NULL)
300246b0:	e59d3014 	ldr	r3, [sp, #20]
300246b4:	e3530000 	cmp	r3, #0
300246b8:	0a000012 	beq	30024708 <acoral_dev_config+0x80>
300246bc:	e59d3014 	ldr	r3, [sp, #20]
300246c0:	e5933004 	ldr	r3, [r3, #4]
300246c4:	e3530000 	cmp	r3, #0
300246c8:	0a00000e 	beq	30024708 <acoral_dev_config+0x80>
300246cc:	e59d3014 	ldr	r3, [sp, #20]
300246d0:	e5933004 	ldr	r3, [r3, #4]
300246d4:	e593300c 	ldr	r3, [r3, #12]
300246d8:	e3530000 	cmp	r3, #0
300246dc:	0a000009 	beq	30024708 <acoral_dev_config+0x80>
		return ctrl->ops->config(cmd,data,tm_out);
300246e0:	e59d3014 	ldr	r3, [sp, #20]
300246e4:	e5933004 	ldr	r3, [r3, #4]
300246e8:	e593300c 	ldr	r3, [r3, #12]
300246ec:	e59d0008 	ldr	r0, [sp, #8]
300246f0:	e59d1004 	ldr	r1, [sp, #4]
300246f4:	e59d2000 	ldr	r2, [sp]
300246f8:	e1a0e00f 	mov	lr, pc
300246fc:	e12fff13 	bx	r3
30024700:	e1a03000 	mov	r3, r0
30024704:	ea000000 	b	3002470c <acoral_dev_config+0x84>
	return 0;	
30024708:	e3a03000 	mov	r3, #0
}
3002470c:	e1a00003 	mov	r0, r3
30024710:	e28dd01c 	add	sp, sp, #28
30024714:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30024718:	e12fff1e 	bx	lr

3002471c <acoral_dev_close>:
acoral_32 acoral_dev_close(acoral_id id){
3002471c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30024720:	e24dd014 	sub	sp, sp, #20
30024724:	e58d0004 	str	r0, [sp, #4]
	acoral_drv_ctrl_t *ctrl=(acoral_drv_ctrl_t *)acoral_get_res_by_id(id);
30024728:	e59d0004 	ldr	r0, [sp, #4]
3002472c:	ebff7c4f 	bl	30003870 <acoral_get_res_by_id>
30024730:	e1a03000 	mov	r3, r0
30024734:	e58d300c 	str	r3, [sp, #12]
	if(ctrl!=NULL&&ctrl->ops!=NULL&&ctrl->ops->close!=NULL)
30024738:	e59d300c 	ldr	r3, [sp, #12]
3002473c:	e3530000 	cmp	r3, #0
30024740:	0a00000f 	beq	30024784 <acoral_dev_close+0x68>
30024744:	e59d300c 	ldr	r3, [sp, #12]
30024748:	e5933004 	ldr	r3, [r3, #4]
3002474c:	e3530000 	cmp	r3, #0
30024750:	0a00000b 	beq	30024784 <acoral_dev_close+0x68>
30024754:	e59d300c 	ldr	r3, [sp, #12]
30024758:	e5933004 	ldr	r3, [r3, #4]
3002475c:	e5933010 	ldr	r3, [r3, #16]
30024760:	e3530000 	cmp	r3, #0
30024764:	0a000006 	beq	30024784 <acoral_dev_close+0x68>
		return ctrl->ops->close();
30024768:	e59d300c 	ldr	r3, [sp, #12]
3002476c:	e5933004 	ldr	r3, [r3, #4]
30024770:	e5933010 	ldr	r3, [r3, #16]
30024774:	e1a0e00f 	mov	lr, pc
30024778:	e12fff13 	bx	r3
3002477c:	e1a03000 	mov	r3, r0
30024780:	ea000000 	b	30024788 <acoral_dev_close+0x6c>
	return 0;
30024784:	e3a03000 	mov	r3, #0
}
30024788:	e1a00003 	mov	r0, r3
3002478c:	e28dd014 	add	sp, sp, #20
30024790:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30024794:	e12fff1e 	bx	lr

30024798 <acoral_alloc_drv>:

acoral_drv_ctrl_t *acoral_alloc_drv(){
30024798:	e92d4008 	push	{r3, lr}
  	return (acoral_drv_ctrl_t *)acoral_get_res(&acoral_drv_pool_ctrl);
3002479c:	e59f0010 	ldr	r0, [pc, #16]	; 300247b4 <acoral_alloc_drv+0x1c>
300247a0:	ebff7b53 	bl	300034f4 <acoral_get_res>
300247a4:	e1a03000 	mov	r3, r0
}
300247a8:	e1a00003 	mov	r0, r3
300247ac:	e8bd4008 	pop	{r3, lr}
300247b0:	e12fff1e 	bx	lr
300247b4:	3002a764 	.word	0x3002a764

300247b8 <acoral_drv_pool_init>:


void acoral_drv_pool_init(){
300247b8:	e92d4008 	push	{r3, lr}
	acoral_drv_pool_ctrl.type=ACORAL_RES_DRIVER;
300247bc:	e59f3038 	ldr	r3, [pc, #56]	; 300247fc <acoral_drv_pool_init+0x44>
300247c0:	e3a02004 	mov	r2, #4
300247c4:	e5832000 	str	r2, [r3]
	acoral_drv_pool_ctrl.size=sizeof(acoral_drv_ctrl_t);
300247c8:	e59f302c 	ldr	r3, [pc, #44]	; 300247fc <acoral_drv_pool_init+0x44>
300247cc:	e3a02010 	mov	r2, #16
300247d0:	e5832004 	str	r2, [r3, #4]
	acoral_drv_pool_ctrl.num_per_pool=10;
300247d4:	e59f3020 	ldr	r3, [pc, #32]	; 300247fc <acoral_drv_pool_init+0x44>
300247d8:	e3a0200a 	mov	r2, #10
300247dc:	e5832008 	str	r2, [r3, #8]
	acoral_drv_pool_ctrl.max_pools=3;
300247e0:	e59f3014 	ldr	r3, [pc, #20]	; 300247fc <acoral_drv_pool_init+0x44>
300247e4:	e3a02003 	mov	r2, #3
300247e8:	e5832010 	str	r2, [r3, #16]
	acoral_pool_ctrl_init(&acoral_drv_pool_ctrl);
300247ec:	e59f0008 	ldr	r0, [pc, #8]	; 300247fc <acoral_drv_pool_init+0x44>
300247f0:	ebff7c9e 	bl	30003a70 <acoral_pool_ctrl_init>
}
300247f4:	e8bd4008 	pop	{r3, lr}
300247f8:	e12fff1e 	bx	lr
300247fc:	3002a764 	.word	0x3002a764

30024800 <acoral_drv_sys_init>:

void acoral_drv_sys_init(){
30024800:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30024804:	e24dd00c 	sub	sp, sp, #12
	acoral_u32 i;
	for(i=0;i<ACORAL_DEV_NUM;i++)
30024808:	e3a03000 	mov	r3, #0
3002480c:	e58d3004 	str	r3, [sp, #4]
30024810:	ea000006 	b	30024830 <acoral_drv_sys_init+0x30>
	  	drv_table[i]=NULL;	    
30024814:	e59d2004 	ldr	r2, [sp, #4]
30024818:	e59f3030 	ldr	r3, [pc, #48]	; 30024850 <acoral_drv_sys_init+0x50>
3002481c:	e3a01000 	mov	r1, #0
30024820:	e7831102 	str	r1, [r3, r2, lsl #2]
	acoral_pool_ctrl_init(&acoral_drv_pool_ctrl);
}

void acoral_drv_sys_init(){
	acoral_u32 i;
	for(i=0;i<ACORAL_DEV_NUM;i++)
30024824:	e59d3004 	ldr	r3, [sp, #4]
30024828:	e2833001 	add	r3, r3, #1
3002482c:	e58d3004 	str	r3, [sp, #4]
30024830:	e59d3004 	ldr	r3, [sp, #4]
30024834:	e3530013 	cmp	r3, #19
30024838:	9afffff5 	bls	30024814 <acoral_drv_sys_init+0x14>
	  	drv_table[i]=NULL;	    
	acoral_drv_pool_init();
3002483c:	ebffffdd 	bl	300247b8 <acoral_drv_pool_init>
	brd_driver_init();
30024840:	eb000003 	bl	30024854 <brd_driver_init>
}
30024844:	e28dd00c 	add	sp, sp, #12
30024848:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002484c:	e12fff1e 	bx	lr
30024850:	3002a0bc 	.word	0x3002a0bc

30024854 <brd_driver_init>:
#include<autocfg.h>
void brd_driver_init(){
30024854:	e92d4008 	push	{r3, lr}
#ifdef CFG_DRV_CON_UART
	con_uart_init();
30024858:	eb00008a 	bl	30024a88 <con_uart_init>
#ifdef CFG_DRV_TS
	ts_init();
#endif

#ifdef CFG_DRV_NET_DM9000
	dm9000_init();
3002485c:	eb000316 	bl	300254bc <dm9000_init>
#endif
}
30024860:	e8bd4008 	pop	{r3, lr}
30024864:	e12fff1e 	bx	lr

30024868 <uart_write>:
#define put_char(ch) uart_write(ch)
#define get_char(ch) uart_read(ch)
acoral_dev_ops_t console_ops;
void uart_init();

void uart_write(acoral_u8 ch){
30024868:	e24dd008 	sub	sp, sp, #8
3002486c:	e1a03000 	mov	r3, r0
30024870:	e5cd3007 	strb	r3, [sp, #7]
	while(!(rUTRSTAT0 & 0x4));
30024874:	e3a03205 	mov	r3, #1342177280	; 0x50000000
30024878:	e2833010 	add	r3, r3, #16
3002487c:	e5933000 	ldr	r3, [r3]
30024880:	e2033004 	and	r3, r3, #4
30024884:	e3530000 	cmp	r3, #0
30024888:	0afffff9 	beq	30024874 <uart_write+0xc>
	WrUTXH0(ch);
3002488c:	e3a03205 	mov	r3, #1342177280	; 0x50000000
30024890:	e2833020 	add	r3, r3, #32
30024894:	e5dd2007 	ldrb	r2, [sp, #7]
30024898:	e5c32000 	strb	r2, [r3]
}
3002489c:	e28dd008 	add	sp, sp, #8
300248a0:	e12fff1e 	bx	lr

300248a4 <uart_read>:

void uart_read(acoral_char *ch){
300248a4:	e24dd008 	sub	sp, sp, #8
300248a8:	e58d0004 	str	r0, [sp, #4]
	while(!(rUTRSTAT0 & 0x1));
300248ac:	e3a03205 	mov	r3, #1342177280	; 0x50000000
300248b0:	e2833010 	add	r3, r3, #16
300248b4:	e5933000 	ldr	r3, [r3]
300248b8:	e2033001 	and	r3, r3, #1
300248bc:	e3530000 	cmp	r3, #0
300248c0:	0afffff9 	beq	300248ac <uart_read+0x8>
	*ch=RdURXH0();
300248c4:	e3a03205 	mov	r3, #1342177280	; 0x50000000
300248c8:	e2833024 	add	r3, r3, #36	; 0x24
300248cc:	e5d33000 	ldrb	r3, [r3]
300248d0:	e20320ff 	and	r2, r3, #255	; 0xff
300248d4:	e59d3004 	ldr	r3, [sp, #4]
300248d8:	e5c32000 	strb	r2, [r3]
}
300248dc:	e28dd008 	add	sp, sp, #8
300248e0:	e12fff1e 	bx	lr

300248e4 <console_write>:

acoral_32 console_write(void *data,acoral_u32 size,acoral_time tm_out){
300248e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300248e8:	e24dd01c 	sub	sp, sp, #28
300248ec:	e58d000c 	str	r0, [sp, #12]
300248f0:	e58d1008 	str	r1, [sp, #8]
300248f4:	e58d2004 	str	r2, [sp, #4]
	acoral_u32 i;
  	char p;
	for(i=0;i<size;i++){
300248f8:	e3a03000 	mov	r3, #0
300248fc:	e58d3010 	str	r3, [sp, #16]
30024900:	ea00000f 	b	30024944 <console_write+0x60>
		p=*((acoral_char *)data+i);
30024904:	e59d200c 	ldr	r2, [sp, #12]
30024908:	e59d3010 	ldr	r3, [sp, #16]
3002490c:	e0823003 	add	r3, r2, r3
30024910:	e5d33000 	ldrb	r3, [r3]
30024914:	e5cd3017 	strb	r3, [sp, #23]
		if(p=='\n')
30024918:	e5dd3017 	ldrb	r3, [sp, #23]
3002491c:	e353000a 	cmp	r3, #10
30024920:	1a000001 	bne	3002492c <console_write+0x48>
			put_char('\r');
30024924:	e3a0000d 	mov	r0, #13
30024928:	ebffffce 	bl	30024868 <uart_write>
		put_char(p);
3002492c:	e5dd3017 	ldrb	r3, [sp, #23]
30024930:	e1a00003 	mov	r0, r3
30024934:	ebffffcb 	bl	30024868 <uart_write>
}

acoral_32 console_write(void *data,acoral_u32 size,acoral_time tm_out){
	acoral_u32 i;
  	char p;
	for(i=0;i<size;i++){
30024938:	e59d3010 	ldr	r3, [sp, #16]
3002493c:	e2833001 	add	r3, r3, #1
30024940:	e58d3010 	str	r3, [sp, #16]
30024944:	e59d2010 	ldr	r2, [sp, #16]
30024948:	e59d3008 	ldr	r3, [sp, #8]
3002494c:	e1520003 	cmp	r2, r3
30024950:	3affffeb 	bcc	30024904 <console_write+0x20>
		p=*((acoral_char *)data+i);
		if(p=='\n')
			put_char('\r');
		put_char(p);
	}
}
30024954:	e28dd01c 	add	sp, sp, #28
30024958:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002495c:	e12fff1e 	bx	lr

30024960 <console_read>:

acoral_32 console_read(void *data,acoral_size size,acoral_size offset,acoral_time tm_out){
30024960:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30024964:	e24dd01c 	sub	sp, sp, #28
30024968:	e58d000c 	str	r0, [sp, #12]
3002496c:	e58d1008 	str	r1, [sp, #8]
30024970:	e58d2004 	str	r2, [sp, #4]
30024974:	e58d3000 	str	r3, [sp]
	acoral_u32 i;
  	acoral_char *p;
	for(i=0;i<size;i++){
30024978:	e3a03000 	mov	r3, #0
3002497c:	e58d3010 	str	r3, [sp, #16]
30024980:	ea000008 	b	300249a8 <console_read+0x48>
		p=(acoral_char *)data+i;
30024984:	e59d200c 	ldr	r2, [sp, #12]
30024988:	e59d3010 	ldr	r3, [sp, #16]
3002498c:	e0823003 	add	r3, r2, r3
30024990:	e58d3014 	str	r3, [sp, #20]
		get_char(p);
30024994:	e59d0014 	ldr	r0, [sp, #20]
30024998:	ebffffc1 	bl	300248a4 <uart_read>
}

acoral_32 console_read(void *data,acoral_size size,acoral_size offset,acoral_time tm_out){
	acoral_u32 i;
  	acoral_char *p;
	for(i=0;i<size;i++){
3002499c:	e59d3010 	ldr	r3, [sp, #16]
300249a0:	e2833001 	add	r3, r3, #1
300249a4:	e58d3010 	str	r3, [sp, #16]
300249a8:	e59d2010 	ldr	r2, [sp, #16]
300249ac:	e59d3008 	ldr	r3, [sp, #8]
300249b0:	e1520003 	cmp	r2, r3
300249b4:	3afffff2 	bcc	30024984 <console_read+0x24>
		p=(acoral_char *)data+i;
		get_char(p);
	}
	return size;
300249b8:	e59d3008 	ldr	r3, [sp, #8]
}
300249bc:	e1a00003 	mov	r0, r3
300249c0:	e28dd01c 	add	sp, sp, #28
300249c4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300249c8:	e12fff1e 	bx	lr

300249cc <console_config>:

acoral_32 console_config(acoral_u32 cmd,void *data,acoral_time time_out){
300249cc:	e24dd010 	sub	sp, sp, #16
300249d0:	e58d000c 	str	r0, [sp, #12]
300249d4:	e58d1008 	str	r1, [sp, #8]
300249d8:	e58d2004 	str	r2, [sp, #4]
	switch(cmd){
300249dc:	e59d300c 	ldr	r3, [sp, #12]
300249e0:	e3530001 	cmp	r3, #1
300249e4:	1a000002 	bne	300249f4 <console_config+0x28>
		case CONSOLE_ECHO:
			*(acoral_u8 *)data=1;
300249e8:	e59d3008 	ldr	r3, [sp, #8]
300249ec:	e3a02001 	mov	r2, #1
300249f0:	e5c32000 	strb	r2, [r3]
		default:
			break;
	}		
}
300249f4:	e28dd010 	add	sp, sp, #16
300249f8:	e12fff1e 	bx	lr

300249fc <console_open>:

acoral_32 console_open(){
300249fc:	e92d4008 	push	{r3, lr}
	uart_init();
30024a00:	eb000003 	bl	30024a14 <uart_init>
	return 0;
30024a04:	e3a03000 	mov	r3, #0
}
30024a08:	e1a00003 	mov	r0, r3
30024a0c:	e8bd4008 	pop	{r3, lr}
30024a10:	e12fff1e 	bx	lr

30024a14 <uart_init>:

void uart_init(){
	rUCON0=0x245;	
30024a14:	e3a02245 	mov	r2, #1342177284	; 0x50000004
30024a18:	e3a03f91 	mov	r3, #580	; 0x244
30024a1c:	e2833001 	add	r3, r3, #1
30024a20:	e5823000 	str	r3, [r2]
	rULCON0=0x3;	
30024a24:	e3a03205 	mov	r3, #1342177280	; 0x50000000
30024a28:	e3a02003 	mov	r2, #3
30024a2c:	e5832000 	str	r2, [r3]
	rUFCON0=0x0;	
30024a30:	e3a03285 	mov	r3, #1342177288	; 0x50000008
30024a34:	e3a02000 	mov	r2, #0
30024a38:	e5832000 	str	r2, [r3]
	rUMCON0=0x0;	
30024a3c:	e3a032c5 	mov	r3, #1342177292	; 0x5000000c
30024a40:	e3a02000 	mov	r2, #0
30024a44:	e5832000 	str	r2, [r3]
	rUBRDIV0=(PCLK /(CFG_BAUD_RATE * 16))-1;
30024a48:	e3a03205 	mov	r3, #1342177280	; 0x50000000
30024a4c:	e2833028 	add	r3, r3, #40	; 0x28
30024a50:	e3a0201a 	mov	r2, #26
30024a54:	e5832000 	str	r2, [r3]
    rGPHCON = 0x0016faaa;
30024a58:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30024a5c:	e2822070 	add	r2, r2, #112	; 0x70
30024a60:	e3a0395b 	mov	r3, #1490944	; 0x16c000
30024a64:	e2833dea 	add	r3, r3, #14976	; 0x3a80
30024a68:	e283302a 	add	r3, r3, #42	; 0x2a
30024a6c:	e5823000 	str	r3, [r2]
	rGPHUP  = 0x7ff;    /* The pull up function is disabled GPH[10:0]*/
30024a70:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30024a74:	e2833078 	add	r3, r3, #120	; 0x78
30024a78:	e3a02e7f 	mov	r2, #2032	; 0x7f0
30024a7c:	e282200f 	add	r2, r2, #15
30024a80:	e5832000 	str	r2, [r3]
}
30024a84:	e12fff1e 	bx	lr

30024a88 <con_uart_init>:

void con_uart_init(){
30024a88:	e92d4008 	push	{r3, lr}
	console_ops.open=console_open;
30024a8c:	e59f203c 	ldr	r2, [pc, #60]	; 30024ad0 <con_uart_init+0x48>
30024a90:	e59f303c 	ldr	r3, [pc, #60]	; 30024ad4 <con_uart_init+0x4c>
30024a94:	e5832000 	str	r2, [r3]
	console_ops.write=console_write;
30024a98:	e59f2038 	ldr	r2, [pc, #56]	; 30024ad8 <con_uart_init+0x50>
30024a9c:	e59f3030 	ldr	r3, [pc, #48]	; 30024ad4 <con_uart_init+0x4c>
30024aa0:	e5832008 	str	r2, [r3, #8]
	console_ops.read=console_read;
30024aa4:	e59f3028 	ldr	r3, [pc, #40]	; 30024ad4 <con_uart_init+0x4c>
30024aa8:	e59f202c 	ldr	r2, [pc, #44]	; 30024adc <con_uart_init+0x54>
30024aac:	e5832004 	str	r2, [r3, #4]
	console_ops.config=console_config;
30024ab0:	e59f301c 	ldr	r3, [pc, #28]	; 30024ad4 <con_uart_init+0x4c>
30024ab4:	e59f2024 	ldr	r2, [pc, #36]	; 30024ae0 <con_uart_init+0x58>
30024ab8:	e583200c 	str	r2, [r3, #12]
  	acoral_drv_register(&console_ops,"console");
30024abc:	e59f0010 	ldr	r0, [pc, #16]	; 30024ad4 <con_uart_init+0x4c>
30024ac0:	e59f101c 	ldr	r1, [pc, #28]	; 30024ae4 <con_uart_init+0x5c>
30024ac4:	ebfffe26 	bl	30024364 <acoral_drv_register>
}
30024ac8:	e8bd4008 	pop	{r3, lr}
30024acc:	e12fff1e 	bx	lr
30024ad0:	300249fc 	.word	0x300249fc
30024ad4:	3002a81c 	.word	0x3002a81c
30024ad8:	300248e4 	.word	0x300248e4
30024adc:	30024960 	.word	0x30024960
30024ae0:	300249cc 	.word	0x300249cc
30024ae4:	3002685c 	.word	0x3002685c

30024ae8 <udelay>:
/*===========================
 *
 *  时延函数
 */
void udelay(u32_t t)
{
30024ae8:	e24dd010 	sub	sp, sp, #16
30024aec:	e58d0004 	str	r0, [sp, #4]
   u32_t i;
   for(;t>0;t--)
30024af0:	ea00000b 	b	30024b24 <udelay+0x3c>
   {
     for(i=0;i<100;i++){}
30024af4:	e3a03000 	mov	r3, #0
30024af8:	e58d300c 	str	r3, [sp, #12]
30024afc:	ea000002 	b	30024b0c <udelay+0x24>
30024b00:	e59d300c 	ldr	r3, [sp, #12]
30024b04:	e2833001 	add	r3, r3, #1
30024b08:	e58d300c 	str	r3, [sp, #12]
30024b0c:	e59d300c 	ldr	r3, [sp, #12]
30024b10:	e3530063 	cmp	r3, #99	; 0x63
30024b14:	9afffff9 	bls	30024b00 <udelay+0x18>
 *  时延函数
 */
void udelay(u32_t t)
{
   u32_t i;
   for(;t>0;t--)
30024b18:	e59d3004 	ldr	r3, [sp, #4]
30024b1c:	e2433001 	sub	r3, r3, #1
30024b20:	e58d3004 	str	r3, [sp, #4]
30024b24:	e59d3004 	ldr	r3, [sp, #4]
30024b28:	e3530000 	cmp	r3, #0
30024b2c:	1afffff0 	bne	30024af4 <udelay+0xc>
   {
     for(i=0;i<100;i++){}
   }
}
30024b30:	e28dd010 	add	sp, sp, #16
30024b34:	e12fff1e 	bx	lr

30024b38 <Eint7_ISR>:
/*===========================
 *
 *   中断处理函数
 */
void Eint7_ISR(acoral_vector vector)
{
30024b38:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30024b3c:	e24dd00c 	sub	sp, sp, #12
30024b40:	e58d0004 	str	r0, [sp, #4]
	acoral_prints("in DM9000 interuption\n");
30024b44:	e59f0080 	ldr	r0, [pc, #128]	; 30024bcc <Eint7_ISR+0x94>
30024b48:	ebff9a59 	bl	3000b4b4 <acoral_prints>
	rEINTMSK |=(1<<vector);
30024b4c:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30024b50:	e28330a4 	add	r3, r3, #164	; 0xa4
30024b54:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30024b58:	e28220a4 	add	r2, r2, #164	; 0xa4
30024b5c:	e5921000 	ldr	r1, [r2]
30024b60:	e3a00001 	mov	r0, #1
30024b64:	e59d2004 	ldr	r2, [sp, #4]
30024b68:	e1a02210 	lsl	r2, r0, r2
30024b6c:	e1812002 	orr	r2, r1, r2
30024b70:	e5832000 	str	r2, [r3]
	
	//ethernetif_input(&dm9000);
	acoral_sem_post(&dm9k_recv_sem);
30024b74:	e59f0054 	ldr	r0, [pc, #84]	; 30024bd0 <Eint7_ISR+0x98>
30024b78:	ebff8bb7 	bl	30007a5c <acoral_sem_post>
		Printf("%x ",Buffer[i]);
		if((i%5)==4) Printf("\r\n");
	}
*/
    
	rEINTPND |= 0x1<<7;
30024b7c:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30024b80:	e28330a8 	add	r3, r3, #168	; 0xa8
30024b84:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30024b88:	e28220a8 	add	r2, r2, #168	; 0xa8
30024b8c:	e5922000 	ldr	r2, [r2]
30024b90:	e3822080 	orr	r2, r2, #128	; 0x80
30024b94:	e5832000 	str	r2, [r3]
	ClearPending(0x1<<4);
30024b98:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30024b9c:	e3a02010 	mov	r2, #16
30024ba0:	e5832000 	str	r2, [r3]
30024ba4:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30024ba8:	e2833010 	add	r3, r3, #16
30024bac:	e3a02010 	mov	r2, #16
30024bb0:	e5832000 	str	r2, [r3]
30024bb4:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30024bb8:	e2833010 	add	r3, r3, #16
30024bbc:	e5933000 	ldr	r3, [r3]
	

}
30024bc0:	e28dd00c 	add	sp, sp, #12
30024bc4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30024bc8:	e12fff1e 	bx	lr
30024bcc:	30026864 	.word	0x30026864
30024bd0:	3002a07c 	.word	0x3002a07c

30024bd4 <IOSetInit>:
/*==========================
 *
 * s3c2440 中断相关寄存器初始化
 */
void IOSetInit(void)
{
30024bd4:	e92d4008 	push	{r3, lr}
	acoral_intr_set_type(IRQ_EINT7,ACORAL_EXPERT_INTR);
30024bd8:	e3a00007 	mov	r0, #7
30024bdc:	e3a01002 	mov	r1, #2
30024be0:	ebff7de2 	bl	30004370 <acoral_intr_set_type>
	acoral_intr_attach(IRQ_EINT7,Eint7_ISR);
30024be4:	e3a00007 	mov	r0, #7
30024be8:	e59f10a8 	ldr	r1, [pc, #168]	; 30024c98 <IOSetInit+0xc4>
30024bec:	ebff7c5e 	bl	30003d6c <acoral_intr_attach>
	
	rGPFCON  = (rGPFCON & (~(0x03<<14))) | (0x02<<14);	       
30024bf0:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30024bf4:	e2833050 	add	r3, r3, #80	; 0x50
30024bf8:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30024bfc:	e2822050 	add	r2, r2, #80	; 0x50
30024c00:	e5922000 	ldr	r2, [r2]
30024c04:	e3c22903 	bic	r2, r2, #49152	; 0xc000
30024c08:	e3822902 	orr	r2, r2, #32768	; 0x8000
30024c0c:	e5832000 	str	r2, [r3]
	rEXTINT0 = (rEXTINT0 & (~(0x07<<28))) | (0x01<<28);
30024c10:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30024c14:	e2833088 	add	r3, r3, #136	; 0x88
30024c18:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30024c1c:	e2822088 	add	r2, r2, #136	; 0x88
30024c20:	e5922000 	ldr	r2, [r2]
30024c24:	e3c22207 	bic	r2, r2, #1879048192	; 0x70000000
30024c28:	e3822201 	orr	r2, r2, #268435456	; 0x10000000
30024c2c:	e5832000 	str	r2, [r3]
	rEINTMSK = rEINTMSK & (~(0x01<<7));         
30024c30:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30024c34:	e28330a4 	add	r3, r3, #164	; 0xa4
30024c38:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30024c3c:	e28220a4 	add	r2, r2, #164	; 0xa4
30024c40:	e5922000 	ldr	r2, [r2]
30024c44:	e3c22080 	bic	r2, r2, #128	; 0x80
30024c48:	e5832000 	str	r2, [r3]
	
	ClearPending((0x1<<4));
30024c4c:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30024c50:	e3a02010 	mov	r2, #16
30024c54:	e5832000 	str	r2, [r3]
30024c58:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30024c5c:	e2833010 	add	r3, r3, #16
30024c60:	e3a02010 	mov	r2, #16
30024c64:	e5832000 	str	r2, [r3]
30024c68:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30024c6c:	e2833010 	add	r3, r3, #16
30024c70:	e5933000 	ldr	r3, [r3]
	rINTMSK  = rINTMSK & (~(0x1<<4));
30024c74:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30024c78:	e2833008 	add	r3, r3, #8
30024c7c:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
30024c80:	e2822008 	add	r2, r2, #8
30024c84:	e5922000 	ldr	r2, [r2]
30024c88:	e3c22010 	bic	r2, r2, #16
30024c8c:	e5832000 	str	r2, [r3]
}
30024c90:	e8bd4008 	pop	{r3, lr}
30024c94:	e12fff1e 	bx	lr
30024c98:	30024b38 	.word	0x30024b38

30024c9c <dm9000_reg_write>:
/*======================
 *
 *  寄存器写数据
 */
void dm9000_reg_write(u16_t reg, u16_t data)
{  
30024c9c:	e24dd008 	sub	sp, sp, #8
30024ca0:	e1a02000 	mov	r2, r0
30024ca4:	e1a03001 	mov	r3, r1
30024ca8:	e1cd20b6 	strh	r2, [sp, #6]
30024cac:	e1cd30b4 	strh	r3, [sp, #4]
//	udelay(20);
	DM_ADD = reg;
30024cb0:	e3a03202 	mov	r3, #536870912	; 0x20000000
30024cb4:	e2833c03 	add	r3, r3, #768	; 0x300
30024cb8:	e1dd20b6 	ldrh	r2, [sp, #6]
30024cbc:	e1c320b0 	strh	r2, [r3]
//	udelay(20);
	DM_CMD = data;
30024cc0:	e3a03202 	mov	r3, #536870912	; 0x20000000
30024cc4:	e2833fc1 	add	r3, r3, #772	; 0x304
30024cc8:	e1dd20b4 	ldrh	r2, [sp, #4]
30024ccc:	e1c320b0 	strh	r2, [r3]
	
}
30024cd0:	e28dd008 	add	sp, sp, #8
30024cd4:	e12fff1e 	bx	lr

30024cd8 <dm9000_reg_read>:
/*======================
 *
 *  寄存器读数据 8bit
 */
u8_t dm9000_reg_read(u16_t reg)
{
30024cd8:	e24dd008 	sub	sp, sp, #8
30024cdc:	e1a03000 	mov	r3, r0
30024ce0:	e1cd30b6 	strh	r3, [sp, #6]
  //  udelay(20);
    DM_ADD = reg;
30024ce4:	e3a03202 	mov	r3, #536870912	; 0x20000000
30024ce8:	e2833c03 	add	r3, r3, #768	; 0x300
30024cec:	e1dd20b6 	ldrh	r2, [sp, #6]
30024cf0:	e1c320b0 	strh	r2, [r3]
  //  udelay(20);
    return DM_CMD;
30024cf4:	e3a03202 	mov	r3, #536870912	; 0x20000000
30024cf8:	e2833fc1 	add	r3, r3, #772	; 0x304
30024cfc:	e1d330b0 	ldrh	r3, [r3]
30024d00:	e1a03803 	lsl	r3, r3, #16
30024d04:	e1a03823 	lsr	r3, r3, #16
30024d08:	e20330ff 	and	r3, r3, #255	; 0xff
}
30024d0c:	e1a00003 	mov	r0, r3
30024d10:	e28dd008 	add	sp, sp, #8
30024d14:	e12fff1e 	bx	lr

30024d18 <dm9000_reg_read16>:
/*=====================
 *
 *  寄存器读数据 16bit
 */
u16_t dm9000_reg_read16(u16_t reg)
{
30024d18:	e24dd008 	sub	sp, sp, #8
30024d1c:	e1a03000 	mov	r3, r0
30024d20:	e1cd30b6 	strh	r3, [sp, #6]
  //  udelay(20);
    DM_ADD = reg;
30024d24:	e3a03202 	mov	r3, #536870912	; 0x20000000
30024d28:	e2833c03 	add	r3, r3, #768	; 0x300
30024d2c:	e1dd20b6 	ldrh	r2, [sp, #6]
30024d30:	e1c320b0 	strh	r2, [r3]
  //  udelay(20);
    return DM_CMD;
30024d34:	e3a03202 	mov	r3, #536870912	; 0x20000000
30024d38:	e2833fc1 	add	r3, r3, #772	; 0x304
30024d3c:	e1d330b0 	ldrh	r3, [r3]
30024d40:	e1a03803 	lsl	r3, r3, #16
30024d44:	e1a03823 	lsr	r3, r3, #16
}
30024d48:	e1a00003 	mov	r0, r3
30024d4c:	e28dd008 	add	sp, sp, #8
30024d50:	e12fff1e 	bx	lr

30024d54 <hw_init>:
/*================================
 *
 *  dm9000 网卡初始化
 */
void hw_init(u8_t * mac_addr)
{
30024d54:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30024d58:	e24dd014 	sub	sp, sp, #20
30024d5c:	e58d0004 	str	r0, [sp, #4]
	u32_t i;
	IOSetInit();  
30024d60:	ebffff9b 	bl	30024bd4 <IOSetInit>
	
	dm9000_reg_write(DM9000_GPCR, 0x01);
30024d64:	e3a0001e 	mov	r0, #30
30024d68:	e3a01001 	mov	r1, #1
30024d6c:	ebffffca 	bl	30024c9c <dm9000_reg_write>
	dm9000_reg_write(DM9000_GPR,  0x00);
30024d70:	e3a0001f 	mov	r0, #31
30024d74:	e3a01000 	mov	r1, #0
30024d78:	ebffffc7 	bl	30024c9c <dm9000_reg_write>
	udelay(5000);					
30024d7c:	e3a00d4e 	mov	r0, #4992	; 0x1380
30024d80:	e2800008 	add	r0, r0, #8
30024d84:	ebffff57 	bl	30024ae8 <udelay>
	
	dm9000_reg_write(DM9000_NCR,  0x03);
30024d88:	e3a00000 	mov	r0, #0
30024d8c:	e3a01003 	mov	r1, #3
30024d90:	ebffffc1 	bl	30024c9c <dm9000_reg_write>
	udelay(3000);			
30024d94:	e3a00ebb 	mov	r0, #2992	; 0xbb0
30024d98:	e2800008 	add	r0, r0, #8
30024d9c:	ebffff51 	bl	30024ae8 <udelay>
	dm9000_reg_write(DM9000_NCR,  0x00);
30024da0:	e3a00000 	mov	r0, #0
30024da4:	e3a01000 	mov	r1, #0
30024da8:	ebffffbb 	bl	30024c9c <dm9000_reg_write>
	dm9000_reg_write(DM9000_NCR,  0x03);
30024dac:	e3a00000 	mov	r0, #0
30024db0:	e3a01003 	mov	r1, #3
30024db4:	ebffffb8 	bl	30024c9c <dm9000_reg_write>
	udelay(3000);
30024db8:	e3a00ebb 	mov	r0, #2992	; 0xbb0
30024dbc:	e2800008 	add	r0, r0, #8
30024dc0:	ebffff48 	bl	30024ae8 <udelay>
	dm9000_reg_write(DM9000_NCR,  0x00);
30024dc4:	e3a00000 	mov	r0, #0
30024dc8:	e3a01000 	mov	r1, #0
30024dcc:	ebffffb2 	bl	30024c9c <dm9000_reg_write>
	
	
	dm9000_reg_write(DM9000_NSR,  0x2c);
30024dd0:	e3a00001 	mov	r0, #1
30024dd4:	e3a0102c 	mov	r1, #44	; 0x2c
30024dd8:	ebffffaf 	bl	30024c9c <dm9000_reg_write>
	dm9000_reg_write(DM9000_ISR,  0xbf);
30024ddc:	e3a000fe 	mov	r0, #254	; 0xfe
30024de0:	e3a010bf 	mov	r1, #191	; 0xbf
30024de4:	ebffffac 	bl	30024c9c <dm9000_reg_write>
	
    dm9000_reg_write(DM9000_RCR,  0x39);
30024de8:	e3a00005 	mov	r0, #5
30024dec:	e3a01039 	mov	r1, #57	; 0x39
30024df0:	ebffffa9 	bl	30024c9c <dm9000_reg_write>
    dm9000_reg_write(DM9000_TCR,  0x00);
30024df4:	e3a00002 	mov	r0, #2
30024df8:	e3a01000 	mov	r1, #0
30024dfc:	ebffffa6 	bl	30024c9c <dm9000_reg_write>
    dm9000_reg_write(DM9000_BPTR, 0x3f);
30024e00:	e3a00008 	mov	r0, #8
30024e04:	e3a0103f 	mov	r1, #63	; 0x3f
30024e08:	ebffffa3 	bl	30024c9c <dm9000_reg_write>
    dm9000_reg_write(DM9000_FCTR, 0x38);
30024e0c:	e3a00009 	mov	r0, #9
30024e10:	e3a01038 	mov	r1, #56	; 0x38
30024e14:	ebffffa0 	bl	30024c9c <dm9000_reg_write>
    dm9000_reg_write(DM9000_FCR,  0xff);
30024e18:	e3a0000a 	mov	r0, #10
30024e1c:	e3a010ff 	mov	r1, #255	; 0xff
30024e20:	ebffff9d 	bl	30024c9c <dm9000_reg_write>
    dm9000_reg_write(DM9000_SMCR, 0x00);	
30024e24:	e3a0002f 	mov	r0, #47	; 0x2f
30024e28:	e3a01000 	mov	r1, #0
30024e2c:	ebffff9a 	bl	30024c9c <dm9000_reg_write>
    
	for(i=0; i<6; i++)
30024e30:	e3a03000 	mov	r3, #0
30024e34:	e58d300c 	str	r3, [sp, #12]
30024e38:	ea00000f 	b	30024e7c <hw_init+0x128>
		dm9000_reg_write(DM9000_PAR + i, mac_addr[i]);
30024e3c:	e59d300c 	ldr	r3, [sp, #12]
30024e40:	e1a03803 	lsl	r3, r3, #16
30024e44:	e1a03823 	lsr	r3, r3, #16
30024e48:	e2833010 	add	r3, r3, #16
30024e4c:	e1a03803 	lsl	r3, r3, #16
30024e50:	e1a02823 	lsr	r2, r3, #16
30024e54:	e59d1004 	ldr	r1, [sp, #4]
30024e58:	e59d300c 	ldr	r3, [sp, #12]
30024e5c:	e0813003 	add	r3, r1, r3
30024e60:	e5d33000 	ldrb	r3, [r3]
30024e64:	e1a00002 	mov	r0, r2
30024e68:	e1a01003 	mov	r1, r3
30024e6c:	ebffff8a 	bl	30024c9c <dm9000_reg_write>
    dm9000_reg_write(DM9000_BPTR, 0x3f);
    dm9000_reg_write(DM9000_FCTR, 0x38);
    dm9000_reg_write(DM9000_FCR,  0xff);
    dm9000_reg_write(DM9000_SMCR, 0x00);	
    
	for(i=0; i<6; i++)
30024e70:	e59d300c 	ldr	r3, [sp, #12]
30024e74:	e2833001 	add	r3, r3, #1
30024e78:	e58d300c 	str	r3, [sp, #12]
30024e7c:	e59d300c 	ldr	r3, [sp, #12]
30024e80:	e3530005 	cmp	r3, #5
30024e84:	9affffec 	bls	30024e3c <hw_init+0xe8>
		dm9000_reg_write(DM9000_PAR + i, mac_addr[i]);
	
	dm9000_reg_write(DM9000_NSR,  0x2c);
30024e88:	e3a00001 	mov	r0, #1
30024e8c:	e3a0102c 	mov	r1, #44	; 0x2c
30024e90:	ebffff81 	bl	30024c9c <dm9000_reg_write>
	dm9000_reg_write(DM9000_ISR,  0x3f);
30024e94:	e3a000fe 	mov	r0, #254	; 0xfe
30024e98:	e3a0103f 	mov	r1, #63	; 0x3f
30024e9c:	ebffff7e 	bl	30024c9c <dm9000_reg_write>
	dm9000_reg_write(DM9000_IMR, 0x81);
30024ea0:	e3a000ff 	mov	r0, #255	; 0xff
30024ea4:	e3a01081 	mov	r1, #129	; 0x81
30024ea8:	ebffff7b 	bl	30024c9c <dm9000_reg_write>
	udelay(10000);
30024eac:	e3a00c27 	mov	r0, #9984	; 0x2700
30024eb0:	e2800010 	add	r0, r0, #16
30024eb4:	ebffff0b 	bl	30024ae8 <udelay>
	acoral_prints("\r\nDM9000 init");
30024eb8:	e59f000c 	ldr	r0, [pc, #12]	; 30024ecc <hw_init+0x178>
30024ebc:	ebff997c 	bl	3000b4b4 <acoral_prints>
}
30024ec0:	e28dd014 	add	sp, sp, #20
30024ec4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30024ec8:	e12fff1e 	bx	lr
30024ecc:	3002687c 	.word	0x3002687c

30024ed0 <hw_sendPacket>:
/*================================
 *
 *  数据发送函数
 */
void   hw_sendPacket(struct pbuf *p)
{
30024ed0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30024ed4:	e24dd024 	sub	sp, sp, #36	; 0x24
30024ed8:	e58d0004 	str	r0, [sp, #4]
	u16_t tmp;
	u8_t* dat;
	u8_t data;;

	
	dm9000_reg_write(DM9000_IMR,0x80);
30024edc:	e3a000ff 	mov	r0, #255	; 0xff
30024ee0:	e3a01080 	mov	r1, #128	; 0x80
30024ee4:	ebffff6c 	bl	30024c9c <dm9000_reg_write>
	//if (p->tot_len > 1514)
	//	return;

/**/
	// 写帧长
	len = p->tot_len;
30024ee8:	e59d3004 	ldr	r3, [sp, #4]
30024eec:	e1d330b8 	ldrh	r3, [r3, #8]
30024ef0:	e58d300c 	str	r3, [sp, #12]
	dm9000_reg_write(DM9000_TXPLH, (len>>8) & 0x0ff);
30024ef4:	e59d300c 	ldr	r3, [sp, #12]
30024ef8:	e1a03423 	lsr	r3, r3, #8
30024efc:	e1a03803 	lsl	r3, r3, #16
30024f00:	e1a03823 	lsr	r3, r3, #16
30024f04:	e20330ff 	and	r3, r3, #255	; 0xff
30024f08:	e3a000fd 	mov	r0, #253	; 0xfd
30024f0c:	e1a01003 	mov	r1, r3
30024f10:	ebffff61 	bl	30024c9c <dm9000_reg_write>
	dm9000_reg_write(DM9000_TXPLL, len & 0x0ff);
30024f14:	e59d300c 	ldr	r3, [sp, #12]
30024f18:	e1a03803 	lsl	r3, r3, #16
30024f1c:	e1a03823 	lsr	r3, r3, #16
30024f20:	e20330ff 	and	r3, r3, #255	; 0xff
30024f24:	e3a000fc 	mov	r0, #252	; 0xfc
30024f28:	e1a01003 	mov	r1, r3
30024f2c:	ebffff5a 	bl	30024c9c <dm9000_reg_write>
	
	// 发送数据
	DM_ADD = DM9000_MWCMD;
30024f30:	e3a03202 	mov	r3, #536870912	; 0x20000000
30024f34:	e2833c03 	add	r3, r3, #768	; 0x300
30024f38:	e3a020f8 	mov	r2, #248	; 0xf8
30024f3c:	e1c320b0 	strh	r2, [r3]
	for(q = p; q != NULL; q = q->next)
30024f40:	e59d3004 	ldr	r3, [sp, #4]
30024f44:	e58d3008 	str	r3, [sp, #8]
30024f48:	ea000030 	b	30025010 <hw_sendPacket+0x140>
	{
		dat = (u8_t*) q->payload;
30024f4c:	e59d3008 	ldr	r3, [sp, #8]
30024f50:	e5933004 	ldr	r3, [r3, #4]
30024f54:	e58d3018 	str	r3, [sp, #24]
		len = q->len;
30024f58:	e59d3008 	ldr	r3, [sp, #8]
30024f5c:	e1d330ba 	ldrh	r3, [r3, #10]
30024f60:	e58d300c 	str	r3, [sp, #12]
		for(i=0; i < (len); i+=2)
30024f64:	e3a03000 	mov	r3, #0
30024f68:	e58d3010 	str	r3, [sp, #16]
30024f6c:	ea000020 	b	30024ff4 <hw_sendPacket+0x124>
		{
			//udelay(20);
			udelay(1);
30024f70:	e3a00001 	mov	r0, #1
30024f74:	ebfffedb 	bl	30024ae8 <udelay>
			tmp = 0x0;
30024f78:	e3a03000 	mov	r3, #0
30024f7c:	e1cd31b6 	strh	r3, [sp, #22]
			tmp |= *dat;
30024f80:	e59d3018 	ldr	r3, [sp, #24]
30024f84:	e5d33000 	ldrb	r3, [r3]
30024f88:	e1a02003 	mov	r2, r3
30024f8c:	e1dd31b6 	ldrh	r3, [sp, #22]
30024f90:	e1823003 	orr	r3, r2, r3
30024f94:	e1cd31b6 	strh	r3, [sp, #22]
			dat++;
30024f98:	e59d3018 	ldr	r3, [sp, #24]
30024f9c:	e2833001 	add	r3, r3, #1
30024fa0:	e58d3018 	str	r3, [sp, #24]
			tmp |= *dat<< 8;
30024fa4:	e59d3018 	ldr	r3, [sp, #24]
30024fa8:	e5d33000 	ldrb	r3, [r3]
30024fac:	e1a03403 	lsl	r3, r3, #8
30024fb0:	e1a03803 	lsl	r3, r3, #16
30024fb4:	e1a02823 	lsr	r2, r3, #16
30024fb8:	e1dd31b6 	ldrh	r3, [sp, #22]
30024fbc:	e1823003 	orr	r3, r2, r3
30024fc0:	e1a03803 	lsl	r3, r3, #16
30024fc4:	e1a03823 	lsr	r3, r3, #16
30024fc8:	e1cd31b6 	strh	r3, [sp, #22]
			dat ++;
30024fcc:	e59d3018 	ldr	r3, [sp, #24]
30024fd0:	e2833001 	add	r3, r3, #1
30024fd4:	e58d3018 	str	r3, [sp, #24]
			DM_CMD = tmp;
30024fd8:	e3a03202 	mov	r3, #536870912	; 0x20000000
30024fdc:	e2833fc1 	add	r3, r3, #772	; 0x304
30024fe0:	e1dd21b6 	ldrh	r2, [sp, #22]
30024fe4:	e1c320b0 	strh	r2, [r3]
	DM_ADD = DM9000_MWCMD;
	for(q = p; q != NULL; q = q->next)
	{
		dat = (u8_t*) q->payload;
		len = q->len;
		for(i=0; i < (len); i+=2)
30024fe8:	e59d3010 	ldr	r3, [sp, #16]
30024fec:	e2833002 	add	r3, r3, #2
30024ff0:	e58d3010 	str	r3, [sp, #16]
30024ff4:	e59d2010 	ldr	r2, [sp, #16]
30024ff8:	e59d300c 	ldr	r3, [sp, #12]
30024ffc:	e1520003 	cmp	r2, r3
30025000:	3affffda 	bcc	30024f70 <hw_sendPacket+0xa0>
	dm9000_reg_write(DM9000_TXPLH, (len>>8) & 0x0ff);
	dm9000_reg_write(DM9000_TXPLL, len & 0x0ff);
	
	// 发送数据
	DM_ADD = DM9000_MWCMD;
	for(q = p; q != NULL; q = q->next)
30025004:	e59d3008 	ldr	r3, [sp, #8]
30025008:	e5933000 	ldr	r3, [r3]
3002500c:	e58d3008 	str	r3, [sp, #8]
30025010:	e59d3008 	ldr	r3, [sp, #8]
30025014:	e3530000 	cmp	r3, #0
30025018:	1affffcb 	bne	30024f4c <hw_sendPacket+0x7c>
			DM_CMD = tmp;
		}
	}

	//发送到网络
	dm9000_reg_write(DM9000_TCR, 0x01);	
3002501c:	e3a00002 	mov	r0, #2
30025020:	e3a01001 	mov	r1, #1
30025024:	ebffff1c 	bl	30024c9c <dm9000_reg_write>
30025028:	ea000000 	b	30025030 <hw_sendPacket+0x160>
	while(1)
	{
		udelay(1000);
		data = dm9000_reg_read(DM9000_TCR);//DM9000_NSR
		if((data&0x01) == 0x00) break;
	}
3002502c:	e1a00000 	nop			; (mov r0, r0)
	//发送到网络
	dm9000_reg_write(DM9000_TCR, 0x01);	
	//等待发送完毕
	while(1)
	{
		udelay(1000);
30025030:	e3a00ffa 	mov	r0, #1000	; 0x3e8
30025034:	ebfffeab 	bl	30024ae8 <udelay>
		data = dm9000_reg_read(DM9000_TCR);//DM9000_NSR
30025038:	e3a00002 	mov	r0, #2
3002503c:	ebffff25 	bl	30024cd8 <dm9000_reg_read>
30025040:	e1a03000 	mov	r3, r0
30025044:	e5cd301f 	strb	r3, [sp, #31]
		if((data&0x01) == 0x00) break;
30025048:	e5dd301f 	ldrb	r3, [sp, #31]
3002504c:	e2033001 	and	r3, r3, #1
30025050:	e3530000 	cmp	r3, #0
30025054:	1afffff4 	bne	3002502c <hw_sendPacket+0x15c>
	}
	dm9000_reg_write(DM9000_NSR, 0x2c);	
30025058:	e3a00001 	mov	r0, #1
3002505c:	e3a0102c 	mov	r1, #44	; 0x2c
30025060:	ebffff0d 	bl	30024c9c <dm9000_reg_write>

		}
		Printf("\r\n+++++++++++++++++++++\r\n");
	*/		

    dm9000_reg_write(DM9000_IMR, 0x81);	
30025064:	e3a000ff 	mov	r0, #255	; 0xff
30025068:	e3a01081 	mov	r1, #129	; 0x81
3002506c:	ebffff0a 	bl	30024c9c <dm9000_reg_write>

}
30025070:	e28dd024 	add	sp, sp, #36	; 0x24
30025074:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30025078:	e12fff1e 	bx	lr

3002507c <hw_getPacket>:
/*================================
 *
 *  数据接收函数
 */
struct pbuf* hw_getPacket (/*struct netif *netif,*/ u32_t* flag)
{
3002507c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30025080:	e24dd02c 	sub	sp, sp, #44	; 0x2c
30025084:	e58d0004 	str	r0, [sp, #4]
	u8_t* dat;
	
	// test for mem alloc. by pegasus
	//static int num_pbuf_alloc = 0;	
	
	ready = 0;						
30025088:	e3a03000 	mov	r3, #0
3002508c:	e5cd301f 	strb	r3, [sp, #31]
	status = 0;					
30025090:	e3a03000 	mov	r3, #0
30025094:	e1cd31b8 	strh	r3, [sp, #24]
	len = 0; 				
30025098:	e3a03000 	mov	r3, #0
3002509c:	e1cd31ba 	strh	r3, [sp, #26]
	*flag = 0;
300250a0:	e59d3004 	ldr	r3, [sp, #4]
300250a4:	e3a02000 	mov	r2, #0
300250a8:	e5832000 	str	r2, [r3]
	
 	if(dm9000_reg_read(DM9000_ISR) & 0x01)          
300250ac:	e3a000fe 	mov	r0, #254	; 0xfe
300250b0:	ebffff08 	bl	30024cd8 <dm9000_reg_read>
300250b4:	e1a03000 	mov	r3, r0
300250b8:	e2033001 	and	r3, r3, #1
300250bc:	e20330ff 	and	r3, r3, #255	; 0xff
300250c0:	e3530000 	cmp	r3, #0
300250c4:	0a000002 	beq	300250d4 <hw_getPacket+0x58>
    {
        dm9000_reg_write(DM9000_ISR, 0x01);	
300250c8:	e3a000fe 	mov	r0, #254	; 0xfe
300250cc:	e3a01001 	mov	r1, #1
300250d0:	ebfffef1 	bl	30024c9c <dm9000_reg_write>
    }


	ready = dm9000_reg_read16(DM9000_MRCMDX); 
300250d4:	e3a000f0 	mov	r0, #240	; 0xf0
300250d8:	ebffff0e 	bl	30024d18 <dm9000_reg_read16>
300250dc:	e1a03000 	mov	r3, r0
300250e0:	e5cd301f 	strb	r3, [sp, #31]
    ready = dm9000_reg_read16(DM9000_MRCMDX);
300250e4:	e3a000f0 	mov	r0, #240	; 0xf0
300250e8:	ebffff0a 	bl	30024d18 <dm9000_reg_read16>
300250ec:	e1a03000 	mov	r3, r0
300250f0:	e5cd301f 	strb	r3, [sp, #31]
 
 	if ( (ready&0x0ff) > 0x01)
300250f4:	e5dd301f 	ldrb	r3, [sp, #31]
300250f8:	e3530001 	cmp	r3, #1
300250fc:	9a00000d 	bls	30025138 <hw_getPacket+0xbc>
 	{
 		dm9000_reg_write(DM9000_RCR,  0x39);	//接收控制
30025100:	e3a00005 	mov	r0, #5
30025104:	e3a01039 	mov	r1, #57	; 0x39
30025108:	ebfffee3 	bl	30024c9c <dm9000_reg_write>
 		dm9000_reg_write(DM9000_ISR,  0x3f);	//清除所有中断标志位
3002510c:	e3a000fe 	mov	r0, #254	; 0xfe
30025110:	e3a0103f 	mov	r1, #63	; 0x3f
30025114:	ebfffee0 	bl	30024c9c <dm9000_reg_write>
 		dm9000_reg_write(DM9000_IMR, 0x81);		//中断使能
30025118:	e3a000ff 	mov	r0, #255	; 0xff
3002511c:	e3a01081 	mov	r1, #129	; 0x81
30025120:	ebfffedd 	bl	30024c9c <dm9000_reg_write>
 		*flag = 0;
30025124:	e59d3004 	ldr	r3, [sp, #4]
30025128:	e3a02000 	mov	r2, #0
3002512c:	e5832000 	str	r2, [r3]
 		return NULL;
30025130:	e3a03000 	mov	r3, #0
30025134:	ea000099 	b	300253a0 <hw_getPacket+0x324>
 	}
 	
 	if ((ready & 0x001) == 0x00)
30025138:	e5dd301f 	ldrb	r3, [sp, #31]
3002513c:	e2033001 	and	r3, r3, #1
30025140:	e3530000 	cmp	r3, #0
30025144:	1a000004 	bne	3002515c <hw_getPacket+0xe0>
 	{
 		*flag = 0;
30025148:	e59d3004 	ldr	r3, [sp, #4]
3002514c:	e3a02000 	mov	r2, #0
30025150:	e5832000 	str	r2, [r3]
 		return NULL;
30025154:	e3a03000 	mov	r3, #0
30025158:	ea000090 	b	300253a0 <hw_getPacket+0x324>
 	}


    DM_ADD=DM9000_MRCMD;
3002515c:	e3a03202 	mov	r3, #536870912	; 0x20000000
30025160:	e2833c03 	add	r3, r3, #768	; 0x300
30025164:	e3a020f2 	mov	r2, #242	; 0xf2
30025168:	e1c320b0 	strh	r2, [r3]
    status = DM_CMD;
3002516c:	e3a03202 	mov	r3, #536870912	; 0x20000000
30025170:	e2833fc1 	add	r3, r3, #772	; 0x304
30025174:	e1d330b0 	ldrh	r3, [r3]
30025178:	e1cd31b8 	strh	r3, [sp, #24]
    len = DM_CMD;
3002517c:	e3a03202 	mov	r3, #536870912	; 0x20000000
30025180:	e2833fc1 	add	r3, r3, #772	; 0x304
30025184:	e1d330b0 	ldrh	r3, [r3]
30025188:	e1cd31ba 	strh	r3, [sp, #26]
    if((len < 1522) || (len > 0x40))
3002518c:	e1dd21ba 	ldrh	r2, [sp, #26]
30025190:	e3a03e5f 	mov	r3, #1520	; 0x5f0
30025194:	e2833001 	add	r3, r3, #1
30025198:	e1520003 	cmp	r2, r3
3002519c:	9a000002 	bls	300251ac <hw_getPacket+0x130>
300251a0:	e1dd31ba 	ldrh	r3, [sp, #26]
300251a4:	e3530040 	cmp	r3, #64	; 0x40
300251a8:	9a000068 	bls	30025350 <hw_getPacket+0x2d4>
    	#if ETH_PAD_SIZE
       		pbuf_header(p, -ETH_PAD_SIZE);
       	#endif
       	
       	//alocate a pbuf chain of pbufs from the pool
       	p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
300251ac:	e1dd31ba 	ldrh	r3, [sp, #26]
300251b0:	e3a00003 	mov	r0, #3
300251b4:	e1a01003 	mov	r1, r3
300251b8:	e3a02003 	mov	r2, #3
300251bc:	ebffc32c 	bl	30015e74 <pbuf_alloc>
300251c0:	e1a03000 	mov	r3, r0
300251c4:	e58d300c 	str	r3, [sp, #12]
       	
       	if (p == NULL)
300251c8:	e59d300c 	ldr	r3, [sp, #12]
300251cc:	e3530000 	cmp	r3, #0
300251d0:	1a000022 	bne	30025260 <hw_getPacket+0x1e4>
       	{
       	    LINK_STATS_INC(link.memerr);
300251d4:	e59f31d4 	ldr	r3, [pc, #468]	; 300253b0 <hw_getPacket+0x334>
300251d8:	e1d330be 	ldrh	r3, [r3, #14]
300251dc:	e2833001 	add	r3, r3, #1
300251e0:	e1a03803 	lsl	r3, r3, #16
300251e4:	e1a02823 	lsr	r2, r3, #16
300251e8:	e59f31c0 	ldr	r3, [pc, #448]	; 300253b0 <hw_getPacket+0x334>
300251ec:	e1c320be 	strh	r2, [r3, #14]
    		LINK_STATS_INC(link.drop);
300251f0:	e59f31b8 	ldr	r3, [pc, #440]	; 300253b0 <hw_getPacket+0x334>
300251f4:	e1d330b8 	ldrh	r3, [r3, #8]
300251f8:	e2833001 	add	r3, r3, #1
300251fc:	e1a03803 	lsl	r3, r3, #16
30025200:	e1a02823 	lsr	r2, r3, #16
30025204:	e59f31a4 	ldr	r3, [pc, #420]	; 300253b0 <hw_getPacket+0x334>
30025208:	e1c320b8 	strh	r2, [r3, #8]
    		
			/* dump the err data */
			for(i=0; i < len; i+=2) // 16 bit mode
3002520c:	e3a03000 	mov	r3, #0
30025210:	e1cd31b4 	strh	r3, [sp, #20]
30025214:	ea000008 	b	3002523c <hw_getPacket+0x1c0>
   		 	{
    			//udelay(20);
    			udelay(1);
30025218:	e3a00001 	mov	r0, #1
3002521c:	ebfffe31 	bl	30024ae8 <udelay>
       			tmp = DM_CMD;
30025220:	e3a03202 	mov	r3, #536870912	; 0x20000000
30025224:	e2833fc1 	add	r3, r3, #772	; 0x304
30025228:	e1d330b0 	ldrh	r3, [r3]
3002522c:	e1cd31b6 	strh	r3, [sp, #22]
       	{
       	    LINK_STATS_INC(link.memerr);
    		LINK_STATS_INC(link.drop);
    		
			/* dump the err data */
			for(i=0; i < len; i+=2) // 16 bit mode
30025230:	e1dd31b4 	ldrh	r3, [sp, #20]
30025234:	e2833002 	add	r3, r3, #2
30025238:	e1cd31b4 	strh	r3, [sp, #20]
3002523c:	e1dd21b4 	ldrh	r2, [sp, #20]
30025240:	e1dd31ba 	ldrh	r3, [sp, #26]
30025244:	e1520003 	cmp	r2, r3
30025248:	3afffff2 	bcc	30025218 <hw_getPacket+0x19c>
    			//udelay(20);
    			udelay(1);
       			tmp = DM_CMD;
    		}
    		
       		*flag = 1;
3002524c:	e59d3004 	ldr	r3, [sp, #4]
30025250:	e3a02001 	mov	r2, #1
30025254:	e5832000 	str	r2, [r3]
       		return p;
30025258:	e59d300c 	ldr	r3, [sp, #12]
3002525c:	ea00004f 	b	300253a0 <hw_getPacket+0x324>
       	}
       	// test for mem alloc. by pegasus
       	//acoral_print("\nnum_pbuf_alloc == %d \n", ++num_pbuf_alloc);
       	
       	for (q = p; q != NULL; q = q->next)
30025260:	e59d300c 	ldr	r3, [sp, #12]
30025264:	e58d3010 	str	r3, [sp, #16]
30025268:	ea000029 	b	30025314 <hw_getPacket+0x298>
       	{
       		dat = (u8_t*)q->payload;
3002526c:	e59d3010 	ldr	r3, [sp, #16]
30025270:	e5933004 	ldr	r3, [r3, #4]
30025274:	e58d3024 	str	r3, [sp, #36]	; 0x24
       		plen= q->len;
30025278:	e59d3010 	ldr	r3, [sp, #16]
3002527c:	e1d330ba 	ldrh	r3, [r3, #10]
30025280:	e1cd31bc 	strh	r3, [sp, #28]
       		
        	for(i=0; i < plen; i+=2) // 16 bit mode
30025284:	e3a03000 	mov	r3, #0
30025288:	e1cd31b4 	strh	r3, [sp, #20]
3002528c:	ea000019 	b	300252f8 <hw_getPacket+0x27c>
        	{
           	    udelay(1);
30025290:	e3a00001 	mov	r0, #1
30025294:	ebfffe13 	bl	30024ae8 <udelay>
            	tmp = DM_CMD;
30025298:	e3a03202 	mov	r3, #536870912	; 0x20000000
3002529c:	e2833fc1 	add	r3, r3, #772	; 0x304
300252a0:	e1d330b0 	ldrh	r3, [r3]
300252a4:	e1cd31b6 	strh	r3, [sp, #22]
            	*dat++ = tmp & 0x0ff;
300252a8:	e1dd31b6 	ldrh	r3, [sp, #22]
300252ac:	e20320ff 	and	r2, r3, #255	; 0xff
300252b0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300252b4:	e5c32000 	strb	r2, [r3]
300252b8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300252bc:	e2833001 	add	r3, r3, #1
300252c0:	e58d3024 	str	r3, [sp, #36]	; 0x24
            	*dat++ = (tmp >> 8) & 0x0ff;
300252c4:	e1dd31b6 	ldrh	r3, [sp, #22]
300252c8:	e1a03423 	lsr	r3, r3, #8
300252cc:	e1a03803 	lsl	r3, r3, #16
300252d0:	e1a03823 	lsr	r3, r3, #16
300252d4:	e20320ff 	and	r2, r3, #255	; 0xff
300252d8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300252dc:	e5c32000 	strb	r2, [r3]
300252e0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300252e4:	e2833001 	add	r3, r3, #1
300252e8:	e58d3024 	str	r3, [sp, #36]	; 0x24
       	for (q = p; q != NULL; q = q->next)
       	{
       		dat = (u8_t*)q->payload;
       		plen= q->len;
       		
        	for(i=0; i < plen; i+=2) // 16 bit mode
300252ec:	e1dd31b4 	ldrh	r3, [sp, #20]
300252f0:	e2833002 	add	r3, r3, #2
300252f4:	e1cd31b4 	strh	r3, [sp, #20]
300252f8:	e1dd21b4 	ldrh	r2, [sp, #20]
300252fc:	e1dd31bc 	ldrh	r3, [sp, #28]
30025300:	e1520003 	cmp	r2, r3
30025304:	3affffe1 	bcc	30025290 <hw_getPacket+0x214>
       		return p;
       	}
       	// test for mem alloc. by pegasus
       	//acoral_print("\nnum_pbuf_alloc == %d \n", ++num_pbuf_alloc);
       	
       	for (q = p; q != NULL; q = q->next)
30025308:	e59d3010 	ldr	r3, [sp, #16]
3002530c:	e5933000 	ldr	r3, [r3]
30025310:	e58d3010 	str	r3, [sp, #16]
30025314:	e59d3010 	ldr	r3, [sp, #16]
30025318:	e3530000 	cmp	r3, #0
3002531c:	1affffd2 	bne	3002526c <hw_getPacket+0x1f0>
				
		#if ETH_PAD_SIZE
			pbuf_header(p, ETH_PAD_SIZE);
		#endif

		LINK_STATS_INC(link.recv);
30025320:	e59f3088 	ldr	r3, [pc, #136]	; 300253b0 <hw_getPacket+0x334>
30025324:	e1d330b4 	ldrh	r3, [r3, #4]
30025328:	e2833001 	add	r3, r3, #1
3002532c:	e1a03803 	lsl	r3, r3, #16
30025330:	e1a02823 	lsr	r2, r3, #16
30025334:	e59f3074 	ldr	r3, [pc, #116]	; 300253b0 <hw_getPacket+0x334>
30025338:	e1c320b4 	strh	r2, [r3, #4]
		*flag = 1;
3002533c:	e59d3004 	ldr	r3, [sp, #4]
30025340:	e3a02001 	mov	r2, #1
30025344:	e5832000 	str	r2, [r3]
		return p;
30025348:	e59d300c 	ldr	r3, [sp, #12]
3002534c:	ea000013 	b	300253a0 <hw_getPacket+0x324>
	}
	
	/* dump the err data */
	for(i=0; i < len; i+=2) // 16 bit mode
30025350:	e3a03000 	mov	r3, #0
30025354:	e1cd31b4 	strh	r3, [sp, #20]
30025358:	ea000008 	b	30025380 <hw_getPacket+0x304>
    {
    	udelay(20);
3002535c:	e3a00014 	mov	r0, #20
30025360:	ebfffde0 	bl	30024ae8 <udelay>
       	tmp = DM_CMD;
30025364:	e3a03202 	mov	r3, #536870912	; 0x20000000
30025368:	e2833fc1 	add	r3, r3, #772	; 0x304
3002536c:	e1d330b0 	ldrh	r3, [r3]
30025370:	e1cd31b6 	strh	r3, [sp, #22]
		*flag = 1;
		return p;
	}
	
	/* dump the err data */
	for(i=0; i < len; i+=2) // 16 bit mode
30025374:	e1dd31b4 	ldrh	r3, [sp, #20]
30025378:	e2833002 	add	r3, r3, #2
3002537c:	e1cd31b4 	strh	r3, [sp, #20]
30025380:	e1dd21b4 	ldrh	r2, [sp, #20]
30025384:	e1dd31ba 	ldrh	r3, [sp, #26]
30025388:	e1520003 	cmp	r2, r3
3002538c:	3afffff2 	bcc	3002535c <hw_getPacket+0x2e0>
    {
    	udelay(20);
       	tmp = DM_CMD;
    }
	*flag = 1;
30025390:	e59d3004 	ldr	r3, [sp, #4]
30025394:	e3a02001 	mov	r2, #1
30025398:	e5832000 	str	r2, [r3]
    return NULL;
3002539c:	e3a03000 	mov	r3, #0
}
300253a0:	e1a00003 	mov	r0, r3
300253a4:	e28dd02c 	add	sp, sp, #44	; 0x2c
300253a8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300253ac:	e12fff1e 	bx	lr
300253b0:	3002b214 	.word	0x3002b214

300253b4 <hw_dm9k_config>:

/**/


acoral_32 hw_dm9k_config(acoral_u32 cmd,void *data,acoral_time tm_out)
{
300253b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300253b8:	e24dd014 	sub	sp, sp, #20
300253bc:	e58d000c 	str	r0, [sp, #12]
300253c0:	e58d1008 	str	r1, [sp, #8]
300253c4:	e58d2004 	str	r2, [sp, #4]
	if (cmd == NET_DEV_INIT)
300253c8:	e59d300c 	ldr	r3, [sp, #12]
300253cc:	e3530001 	cmp	r3, #1
300253d0:	1a000002 	bne	300253e0 <hw_dm9k_config+0x2c>
	{
		hw_init((u8_t*)data);
300253d4:	e59d3008 	ldr	r3, [sp, #8]
300253d8:	e1a00003 	mov	r0, r3
300253dc:	ebfffe5c 	bl	30024d54 <hw_init>
	}
	acoral_sem_init(&dm9k_recv_sem, 0);
300253e0:	e59f0018 	ldr	r0, [pc, #24]	; 30025400 <hw_dm9k_config+0x4c>
300253e4:	e3a01000 	mov	r1, #0
300253e8:	ebff889c 	bl	30007660 <acoral_sem_init>
	return 0;
300253ec:	e3a03000 	mov	r3, #0
}
300253f0:	e1a00003 	mov	r0, r3
300253f4:	e28dd014 	add	sp, sp, #20
300253f8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300253fc:	e12fff1e 	bx	lr
30025400:	3002a07c 	.word	0x3002a07c

30025404 <hw_dm9k_read>:

acoral_32 hw_dm9k_read (void *data,acoral_size size,acoral_size offset,acoral_time tm_out)
{
30025404:	e92d4010 	push	{r4, lr}
30025408:	e24dd010 	sub	sp, sp, #16
3002540c:	e58d000c 	str	r0, [sp, #12]
30025410:	e58d1008 	str	r1, [sp, #8]
30025414:	e58d2004 	str	r2, [sp, #4]
30025418:	e58d3000 	str	r3, [sp]
	if (flag == 0){
3002541c:	e59f3058 	ldr	r3, [pc, #88]	; 3002547c <hw_dm9k_read+0x78>
30025420:	e5933000 	ldr	r3, [r3]
30025424:	e3530000 	cmp	r3, #0
30025428:	1a000009 	bne	30025454 <hw_dm9k_read+0x50>
		 rEINTMSK &=~(1<<7);
3002542c:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30025430:	e28330a4 	add	r3, r3, #164	; 0xa4
30025434:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30025438:	e28220a4 	add	r2, r2, #164	; 0xa4
3002543c:	e5922000 	ldr	r2, [r2]
30025440:	e3c22080 	bic	r2, r2, #128	; 0x80
30025444:	e5832000 	str	r2, [r3]
		 acoral_sem_pend(&dm9k_recv_sem, 0);
30025448:	e59f0030 	ldr	r0, [pc, #48]	; 30025480 <hw_dm9k_read+0x7c>
3002544c:	e3a01000 	mov	r1, #0
30025450:	ebff8916 	bl	300078b0 <acoral_sem_pend>
	}
	*(void **)data = (void*)hw_getPacket (/*struct netif *netif,*/ &flag);
30025454:	e59d400c 	ldr	r4, [sp, #12]
30025458:	e59f001c 	ldr	r0, [pc, #28]	; 3002547c <hw_dm9k_read+0x78>
3002545c:	ebffff06 	bl	3002507c <hw_getPacket>
30025460:	e1a03000 	mov	r3, r0
30025464:	e5843000 	str	r3, [r4]
	
	return 0;
30025468:	e3a03000 	mov	r3, #0
}
3002546c:	e1a00003 	mov	r0, r3
30025470:	e28dd010 	add	sp, sp, #16
30025474:	e8bd4010 	pop	{r4, lr}
30025478:	e12fff1e 	bx	lr
3002547c:	3002a0a0 	.word	0x3002a0a0
30025480:	3002a07c 	.word	0x3002a07c

30025484 <hw_dm9k_write>:

acoral_32 hw_dm9k_write(void *data,acoral_size size,acoral_size offset,acoral_time tm_out)
{
30025484:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30025488:	e24dd014 	sub	sp, sp, #20
3002548c:	e58d000c 	str	r0, [sp, #12]
30025490:	e58d1008 	str	r1, [sp, #8]
30025494:	e58d2004 	str	r2, [sp, #4]
30025498:	e58d3000 	str	r3, [sp]
	hw_sendPacket((struct pbuf *)data);
3002549c:	e59d300c 	ldr	r3, [sp, #12]
300254a0:	e1a00003 	mov	r0, r3
300254a4:	ebfffe89 	bl	30024ed0 <hw_sendPacket>
	return 0;
300254a8:	e3a03000 	mov	r3, #0
}
300254ac:	e1a00003 	mov	r0, r3
300254b0:	e28dd014 	add	sp, sp, #20
300254b4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300254b8:	e12fff1e 	bx	lr

300254bc <dm9000_init>:

void dm9000_init(){
300254bc:	e92d4008 	push	{r3, lr}
	//acoral_prints("\r\ndm9kinit\r\n");
	hw_dm9k_ops.write  = hw_dm9k_write;
300254c0:	e59f3048 	ldr	r3, [pc, #72]	; 30025510 <dm9000_init+0x54>
300254c4:	e59f2048 	ldr	r2, [pc, #72]	; 30025514 <dm9000_init+0x58>
300254c8:	e5832008 	str	r2, [r3, #8]
	hw_dm9k_ops.read   = hw_dm9k_read;
300254cc:	e59f303c 	ldr	r3, [pc, #60]	; 30025510 <dm9000_init+0x54>
300254d0:	e59f2040 	ldr	r2, [pc, #64]	; 30025518 <dm9000_init+0x5c>
300254d4:	e5832004 	str	r2, [r3, #4]
	hw_dm9k_ops.config = hw_dm9k_config;
300254d8:	e59f3030 	ldr	r3, [pc, #48]	; 30025510 <dm9000_init+0x54>
300254dc:	e59f2038 	ldr	r2, [pc, #56]	; 3002551c <dm9000_init+0x60>
300254e0:	e583200c 	str	r2, [r3, #12]
	hw_dm9k_ops.open   = NULL;
300254e4:	e59f3024 	ldr	r3, [pc, #36]	; 30025510 <dm9000_init+0x54>
300254e8:	e3a02000 	mov	r2, #0
300254ec:	e5832000 	str	r2, [r3]
	hw_dm9k_ops.close  = NULL;
300254f0:	e59f3018 	ldr	r3, [pc, #24]	; 30025510 <dm9000_init+0x54>
300254f4:	e3a02000 	mov	r2, #0
300254f8:	e5832010 	str	r2, [r3, #16]
  	acoral_drv_register(&hw_dm9k_ops,"netdev");
300254fc:	e59f000c 	ldr	r0, [pc, #12]	; 30025510 <dm9000_init+0x54>
30025500:	e59f1018 	ldr	r1, [pc, #24]	; 30025520 <dm9000_init+0x64>
30025504:	ebfffb96 	bl	30024364 <acoral_drv_register>
}
30025508:	e8bd4008 	pop	{r3, lr}
3002550c:	e12fff1e 	bx	lr
30025510:	3002b0ec 	.word	0x3002b0ec
30025514:	30025484 	.word	0x30025484
30025518:	30025404 	.word	0x30025404
3002551c:	300253b4 	.word	0x300253b4
30025520:	3002688c 	.word	0x3002688c

30025524 <__aeabi_uidiv>:
30025524:	e2512001 	subs	r2, r1, #1
30025528:	012fff1e 	bxeq	lr
3002552c:	3a000036 	bcc	3002560c <__aeabi_uidiv+0xe8>
30025530:	e1500001 	cmp	r0, r1
30025534:	9a000022 	bls	300255c4 <__aeabi_uidiv+0xa0>
30025538:	e1110002 	tst	r1, r2
3002553c:	0a000023 	beq	300255d0 <__aeabi_uidiv+0xac>
30025540:	e311020e 	tst	r1, #-536870912	; 0xe0000000
30025544:	01a01181 	lsleq	r1, r1, #3
30025548:	03a03008 	moveq	r3, #8
3002554c:	13a03001 	movne	r3, #1
30025550:	e3510201 	cmp	r1, #268435456	; 0x10000000
30025554:	31510000 	cmpcc	r1, r0
30025558:	31a01201 	lslcc	r1, r1, #4
3002555c:	31a03203 	lslcc	r3, r3, #4
30025560:	3afffffa 	bcc	30025550 <__aeabi_uidiv+0x2c>
30025564:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
30025568:	31510000 	cmpcc	r1, r0
3002556c:	31a01081 	lslcc	r1, r1, #1
30025570:	31a03083 	lslcc	r3, r3, #1
30025574:	3afffffa 	bcc	30025564 <__aeabi_uidiv+0x40>
30025578:	e3a02000 	mov	r2, #0
3002557c:	e1500001 	cmp	r0, r1
30025580:	20400001 	subcs	r0, r0, r1
30025584:	21822003 	orrcs	r2, r2, r3
30025588:	e15000a1 	cmp	r0, r1, lsr #1
3002558c:	204000a1 	subcs	r0, r0, r1, lsr #1
30025590:	218220a3 	orrcs	r2, r2, r3, lsr #1
30025594:	e1500121 	cmp	r0, r1, lsr #2
30025598:	20400121 	subcs	r0, r0, r1, lsr #2
3002559c:	21822123 	orrcs	r2, r2, r3, lsr #2
300255a0:	e15001a1 	cmp	r0, r1, lsr #3
300255a4:	204001a1 	subcs	r0, r0, r1, lsr #3
300255a8:	218221a3 	orrcs	r2, r2, r3, lsr #3
300255ac:	e3500000 	cmp	r0, #0
300255b0:	11b03223 	lsrsne	r3, r3, #4
300255b4:	11a01221 	lsrne	r1, r1, #4
300255b8:	1affffef 	bne	3002557c <__aeabi_uidiv+0x58>
300255bc:	e1a00002 	mov	r0, r2
300255c0:	e12fff1e 	bx	lr
300255c4:	03a00001 	moveq	r0, #1
300255c8:	13a00000 	movne	r0, #0
300255cc:	e12fff1e 	bx	lr
300255d0:	e3510801 	cmp	r1, #65536	; 0x10000
300255d4:	21a01821 	lsrcs	r1, r1, #16
300255d8:	23a02010 	movcs	r2, #16
300255dc:	33a02000 	movcc	r2, #0
300255e0:	e3510c01 	cmp	r1, #256	; 0x100
300255e4:	21a01421 	lsrcs	r1, r1, #8
300255e8:	22822008 	addcs	r2, r2, #8
300255ec:	e3510010 	cmp	r1, #16
300255f0:	21a01221 	lsrcs	r1, r1, #4
300255f4:	22822004 	addcs	r2, r2, #4
300255f8:	e3510004 	cmp	r1, #4
300255fc:	82822003 	addhi	r2, r2, #3
30025600:	908220a1 	addls	r2, r2, r1, lsr #1
30025604:	e1a00230 	lsr	r0, r0, r2
30025608:	e12fff1e 	bx	lr
3002560c:	e3500000 	cmp	r0, #0
30025610:	13e00000 	mvnne	r0, #0
30025614:	ea000059 	b	30025780 <__aeabi_idiv0>

30025618 <__aeabi_uidivmod>:
30025618:	e3510000 	cmp	r1, #0
3002561c:	0afffffa 	beq	3002560c <__aeabi_uidiv+0xe8>
30025620:	e92d4003 	push	{r0, r1, lr}
30025624:	ebffffbe 	bl	30025524 <__aeabi_uidiv>
30025628:	e8bd4006 	pop	{r1, r2, lr}
3002562c:	e0030092 	mul	r3, r2, r0
30025630:	e0411003 	sub	r1, r1, r3
30025634:	e12fff1e 	bx	lr

30025638 <__aeabi_idiv>:
30025638:	e3510000 	cmp	r1, #0
3002563c:	0a000043 	beq	30025750 <.divsi3_nodiv0+0x110>

30025640 <.divsi3_nodiv0>:
30025640:	e020c001 	eor	ip, r0, r1
30025644:	42611000 	rsbmi	r1, r1, #0
30025648:	e2512001 	subs	r2, r1, #1
3002564c:	0a000027 	beq	300256f0 <.divsi3_nodiv0+0xb0>
30025650:	e1b03000 	movs	r3, r0
30025654:	42603000 	rsbmi	r3, r0, #0
30025658:	e1530001 	cmp	r3, r1
3002565c:	9a000026 	bls	300256fc <.divsi3_nodiv0+0xbc>
30025660:	e1110002 	tst	r1, r2
30025664:	0a000028 	beq	3002570c <.divsi3_nodiv0+0xcc>
30025668:	e311020e 	tst	r1, #-536870912	; 0xe0000000
3002566c:	01a01181 	lsleq	r1, r1, #3
30025670:	03a02008 	moveq	r2, #8
30025674:	13a02001 	movne	r2, #1
30025678:	e3510201 	cmp	r1, #268435456	; 0x10000000
3002567c:	31510003 	cmpcc	r1, r3
30025680:	31a01201 	lslcc	r1, r1, #4
30025684:	31a02202 	lslcc	r2, r2, #4
30025688:	3afffffa 	bcc	30025678 <.divsi3_nodiv0+0x38>
3002568c:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
30025690:	31510003 	cmpcc	r1, r3
30025694:	31a01081 	lslcc	r1, r1, #1
30025698:	31a02082 	lslcc	r2, r2, #1
3002569c:	3afffffa 	bcc	3002568c <.divsi3_nodiv0+0x4c>
300256a0:	e3a00000 	mov	r0, #0
300256a4:	e1530001 	cmp	r3, r1
300256a8:	20433001 	subcs	r3, r3, r1
300256ac:	21800002 	orrcs	r0, r0, r2
300256b0:	e15300a1 	cmp	r3, r1, lsr #1
300256b4:	204330a1 	subcs	r3, r3, r1, lsr #1
300256b8:	218000a2 	orrcs	r0, r0, r2, lsr #1
300256bc:	e1530121 	cmp	r3, r1, lsr #2
300256c0:	20433121 	subcs	r3, r3, r1, lsr #2
300256c4:	21800122 	orrcs	r0, r0, r2, lsr #2
300256c8:	e15301a1 	cmp	r3, r1, lsr #3
300256cc:	204331a1 	subcs	r3, r3, r1, lsr #3
300256d0:	218001a2 	orrcs	r0, r0, r2, lsr #3
300256d4:	e3530000 	cmp	r3, #0
300256d8:	11b02222 	lsrsne	r2, r2, #4
300256dc:	11a01221 	lsrne	r1, r1, #4
300256e0:	1affffef 	bne	300256a4 <.divsi3_nodiv0+0x64>
300256e4:	e35c0000 	cmp	ip, #0
300256e8:	42600000 	rsbmi	r0, r0, #0
300256ec:	e12fff1e 	bx	lr
300256f0:	e13c0000 	teq	ip, r0
300256f4:	42600000 	rsbmi	r0, r0, #0
300256f8:	e12fff1e 	bx	lr
300256fc:	33a00000 	movcc	r0, #0
30025700:	01a00fcc 	asreq	r0, ip, #31
30025704:	03800001 	orreq	r0, r0, #1
30025708:	e12fff1e 	bx	lr
3002570c:	e3510801 	cmp	r1, #65536	; 0x10000
30025710:	21a01821 	lsrcs	r1, r1, #16
30025714:	23a02010 	movcs	r2, #16
30025718:	33a02000 	movcc	r2, #0
3002571c:	e3510c01 	cmp	r1, #256	; 0x100
30025720:	21a01421 	lsrcs	r1, r1, #8
30025724:	22822008 	addcs	r2, r2, #8
30025728:	e3510010 	cmp	r1, #16
3002572c:	21a01221 	lsrcs	r1, r1, #4
30025730:	22822004 	addcs	r2, r2, #4
30025734:	e3510004 	cmp	r1, #4
30025738:	82822003 	addhi	r2, r2, #3
3002573c:	908220a1 	addls	r2, r2, r1, lsr #1
30025740:	e35c0000 	cmp	ip, #0
30025744:	e1a00233 	lsr	r0, r3, r2
30025748:	42600000 	rsbmi	r0, r0, #0
3002574c:	e12fff1e 	bx	lr
30025750:	e3500000 	cmp	r0, #0
30025754:	c3e00102 	mvngt	r0, #-2147483648	; 0x80000000
30025758:	b3a00102 	movlt	r0, #-2147483648	; 0x80000000
3002575c:	ea000007 	b	30025780 <__aeabi_idiv0>

30025760 <__aeabi_idivmod>:
30025760:	e3510000 	cmp	r1, #0
30025764:	0afffff9 	beq	30025750 <.divsi3_nodiv0+0x110>
30025768:	e92d4003 	push	{r0, r1, lr}
3002576c:	ebffffb3 	bl	30025640 <.divsi3_nodiv0>
30025770:	e8bd4006 	pop	{r1, r2, lr}
30025774:	e0030092 	mul	r3, r2, r0
30025778:	e0411003 	sub	r1, r1, r3
3002577c:	e12fff1e 	bx	lr

30025780 <__aeabi_idiv0>:
30025780:	e12fff1e 	bx	lr

30025784 <__aeabi_frsub>:
30025784:	e2200102 	eor	r0, r0, #-2147483648	; 0x80000000
30025788:	ea000000 	b	30025790 <__addsf3>

3002578c <__aeabi_fsub>:
3002578c:	e2211102 	eor	r1, r1, #-2147483648	; 0x80000000

30025790 <__addsf3>:
30025790:	e1b02080 	lsls	r2, r0, #1
30025794:	11b03081 	lslsne	r3, r1, #1
30025798:	11320003 	teqne	r2, r3
3002579c:	11f0cc42 	mvnsne	ip, r2, asr #24
300257a0:	11f0cc43 	mvnsne	ip, r3, asr #24
300257a4:	0a000047 	beq	300258c8 <__addsf3+0x138>
300257a8:	e1a02c22 	lsr	r2, r2, #24
300257ac:	e0723c23 	rsbs	r3, r2, r3, lsr #24
300257b0:	c0822003 	addgt	r2, r2, r3
300257b4:	c0201001 	eorgt	r1, r0, r1
300257b8:	c0210000 	eorgt	r0, r1, r0
300257bc:	c0201001 	eorgt	r1, r0, r1
300257c0:	b2633000 	rsblt	r3, r3, #0
300257c4:	e3530019 	cmp	r3, #25
300257c8:	812fff1e 	bxhi	lr
300257cc:	e3100102 	tst	r0, #-2147483648	; 0x80000000
300257d0:	e3800502 	orr	r0, r0, #8388608	; 0x800000
300257d4:	e3c004ff 	bic	r0, r0, #-16777216	; 0xff000000
300257d8:	12600000 	rsbne	r0, r0, #0
300257dc:	e3110102 	tst	r1, #-2147483648	; 0x80000000
300257e0:	e3811502 	orr	r1, r1, #8388608	; 0x800000
300257e4:	e3c114ff 	bic	r1, r1, #-16777216	; 0xff000000
300257e8:	12611000 	rsbne	r1, r1, #0
300257ec:	e1320003 	teq	r2, r3
300257f0:	0a00002e 	beq	300258b0 <__addsf3+0x120>
300257f4:	e2422001 	sub	r2, r2, #1
300257f8:	e0900351 	adds	r0, r0, r1, asr r3
300257fc:	e2633020 	rsb	r3, r3, #32
30025800:	e1a01311 	lsl	r1, r1, r3
30025804:	e2003102 	and	r3, r0, #-2147483648	; 0x80000000
30025808:	5a000001 	bpl	30025814 <__addsf3+0x84>
3002580c:	e2711000 	rsbs	r1, r1, #0
30025810:	e2e00000 	rsc	r0, r0, #0
30025814:	e3500502 	cmp	r0, #8388608	; 0x800000
30025818:	3a00000b 	bcc	3002584c <__addsf3+0xbc>
3002581c:	e3500401 	cmp	r0, #16777216	; 0x1000000
30025820:	3a000004 	bcc	30025838 <__addsf3+0xa8>
30025824:	e1b000a0 	lsrs	r0, r0, #1
30025828:	e1a01061 	rrx	r1, r1
3002582c:	e2822001 	add	r2, r2, #1
30025830:	e35200fe 	cmp	r2, #254	; 0xfe
30025834:	2a000038 	bcs	3002591c <__addsf3+0x18c>
30025838:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
3002583c:	e0a00b82 	adc	r0, r0, r2, lsl #23
30025840:	03c00001 	biceq	r0, r0, #1
30025844:	e1800003 	orr	r0, r0, r3
30025848:	e12fff1e 	bx	lr
3002584c:	e1b01081 	lsls	r1, r1, #1
30025850:	e0a00000 	adc	r0, r0, r0
30025854:	e3100502 	tst	r0, #8388608	; 0x800000
30025858:	e2422001 	sub	r2, r2, #1
3002585c:	1afffff5 	bne	30025838 <__addsf3+0xa8>
30025860:	e1b0c620 	lsrs	ip, r0, #12
30025864:	01a00600 	lsleq	r0, r0, #12
30025868:	0242200c 	subeq	r2, r2, #12
3002586c:	e31008ff 	tst	r0, #16711680	; 0xff0000
30025870:	01a00400 	lsleq	r0, r0, #8
30025874:	02422008 	subeq	r2, r2, #8
30025878:	e310060f 	tst	r0, #15728640	; 0xf00000
3002587c:	01a00200 	lsleq	r0, r0, #4
30025880:	02422004 	subeq	r2, r2, #4
30025884:	e3100503 	tst	r0, #12582912	; 0xc00000
30025888:	01a00100 	lsleq	r0, r0, #2
3002588c:	02422002 	subeq	r2, r2, #2
30025890:	e3500502 	cmp	r0, #8388608	; 0x800000
30025894:	31a00080 	lslcc	r0, r0, #1
30025898:	e2d22000 	sbcs	r2, r2, #0
3002589c:	a0800b82 	addge	r0, r0, r2, lsl #23
300258a0:	b2622000 	rsblt	r2, r2, #0
300258a4:	a1800003 	orrge	r0, r0, r3
300258a8:	b1830230 	orrlt	r0, r3, r0, lsr r2
300258ac:	e12fff1e 	bx	lr
300258b0:	e3320000 	teq	r2, #0
300258b4:	e2211502 	eor	r1, r1, #8388608	; 0x800000
300258b8:	02200502 	eoreq	r0, r0, #8388608	; 0x800000
300258bc:	02822001 	addeq	r2, r2, #1
300258c0:	12433001 	subne	r3, r3, #1
300258c4:	eaffffca 	b	300257f4 <__addsf3+0x64>
300258c8:	e1a03081 	lsl	r3, r1, #1
300258cc:	e1f0cc42 	mvns	ip, r2, asr #24
300258d0:	11f0cc43 	mvnsne	ip, r3, asr #24
300258d4:	0a000013 	beq	30025928 <__addsf3+0x198>
300258d8:	e1320003 	teq	r2, r3
300258dc:	0a000002 	beq	300258ec <__addsf3+0x15c>
300258e0:	e3320000 	teq	r2, #0
300258e4:	01a00001 	moveq	r0, r1
300258e8:	e12fff1e 	bx	lr
300258ec:	e1300001 	teq	r0, r1
300258f0:	13a00000 	movne	r0, #0
300258f4:	112fff1e 	bxne	lr
300258f8:	e31204ff 	tst	r2, #-16777216	; 0xff000000
300258fc:	1a000002 	bne	3002590c <__addsf3+0x17c>
30025900:	e1b00080 	lsls	r0, r0, #1
30025904:	23800102 	orrcs	r0, r0, #-2147483648	; 0x80000000
30025908:	e12fff1e 	bx	lr
3002590c:	e2922402 	adds	r2, r2, #33554432	; 0x2000000
30025910:	32800502 	addcc	r0, r0, #8388608	; 0x800000
30025914:	312fff1e 	bxcc	lr
30025918:	e2003102 	and	r3, r0, #-2147483648	; 0x80000000
3002591c:	e383047f 	orr	r0, r3, #2130706432	; 0x7f000000
30025920:	e3800502 	orr	r0, r0, #8388608	; 0x800000
30025924:	e12fff1e 	bx	lr
30025928:	e1f02c42 	mvns	r2, r2, asr #24
3002592c:	11a00001 	movne	r0, r1
30025930:	01f03c43 	mvnseq	r3, r3, asr #24
30025934:	11a01000 	movne	r1, r0
30025938:	e1b02480 	lsls	r2, r0, #9
3002593c:	01b03481 	lslseq	r3, r1, #9
30025940:	01300001 	teqeq	r0, r1
30025944:	13800501 	orrne	r0, r0, #4194304	; 0x400000
30025948:	e12fff1e 	bx	lr

3002594c <__aeabi_ui2f>:
3002594c:	e3a03000 	mov	r3, #0
30025950:	ea000001 	b	3002595c <__aeabi_i2f+0x8>

30025954 <__aeabi_i2f>:
30025954:	e2103102 	ands	r3, r0, #-2147483648	; 0x80000000
30025958:	42600000 	rsbmi	r0, r0, #0
3002595c:	e1b0c000 	movs	ip, r0
30025960:	012fff1e 	bxeq	lr
30025964:	e383344b 	orr	r3, r3, #1258291200	; 0x4b000000
30025968:	e1a01000 	mov	r1, r0
3002596c:	e3a00000 	mov	r0, #0
30025970:	ea00000f 	b	300259b4 <__aeabi_l2f+0x30>

30025974 <__aeabi_ul2f>:
30025974:	e1902001 	orrs	r2, r0, r1
30025978:	012fff1e 	bxeq	lr
3002597c:	e3a03000 	mov	r3, #0
30025980:	ea000005 	b	3002599c <__aeabi_l2f+0x18>

30025984 <__aeabi_l2f>:
30025984:	e1902001 	orrs	r2, r0, r1
30025988:	012fff1e 	bxeq	lr
3002598c:	e2113102 	ands	r3, r1, #-2147483648	; 0x80000000
30025990:	5a000001 	bpl	3002599c <__aeabi_l2f+0x18>
30025994:	e2700000 	rsbs	r0, r0, #0
30025998:	e2e11000 	rsc	r1, r1, #0
3002599c:	e1b0c001 	movs	ip, r1
300259a0:	01a0c000 	moveq	ip, r0
300259a4:	01a01000 	moveq	r1, r0
300259a8:	03a00000 	moveq	r0, #0
300259ac:	e383345b 	orr	r3, r3, #1526726656	; 0x5b000000
300259b0:	02433201 	subeq	r3, r3, #268435456	; 0x10000000
300259b4:	e2433502 	sub	r3, r3, #8388608	; 0x800000
300259b8:	e3a02017 	mov	r2, #23
300259bc:	e35c0801 	cmp	ip, #65536	; 0x10000
300259c0:	21a0c82c 	lsrcs	ip, ip, #16
300259c4:	22422010 	subcs	r2, r2, #16
300259c8:	e35c0c01 	cmp	ip, #256	; 0x100
300259cc:	21a0c42c 	lsrcs	ip, ip, #8
300259d0:	22422008 	subcs	r2, r2, #8
300259d4:	e35c0010 	cmp	ip, #16
300259d8:	21a0c22c 	lsrcs	ip, ip, #4
300259dc:	22422004 	subcs	r2, r2, #4
300259e0:	e35c0004 	cmp	ip, #4
300259e4:	22422002 	subcs	r2, r2, #2
300259e8:	304220ac 	subcc	r2, r2, ip, lsr #1
300259ec:	e05221ac 	subs	r2, r2, ip, lsr #3
300259f0:	e0433b82 	sub	r3, r3, r2, lsl #23
300259f4:	ba000006 	blt	30025a14 <__aeabi_l2f+0x90>
300259f8:	e0833211 	add	r3, r3, r1, lsl r2
300259fc:	e1a0c210 	lsl	ip, r0, r2
30025a00:	e2622020 	rsb	r2, r2, #32
30025a04:	e35c0102 	cmp	ip, #-2147483648	; 0x80000000
30025a08:	e0a30230 	adc	r0, r3, r0, lsr r2
30025a0c:	03c00001 	biceq	r0, r0, #1
30025a10:	e12fff1e 	bx	lr
30025a14:	e2822020 	add	r2, r2, #32
30025a18:	e1a0c211 	lsl	ip, r1, r2
30025a1c:	e2622020 	rsb	r2, r2, #32
30025a20:	e190008c 	orrs	r0, r0, ip, lsl #1
30025a24:	e0a30231 	adc	r0, r3, r1, lsr r2
30025a28:	01c00fac 	biceq	r0, r0, ip, lsr #31
30025a2c:	e12fff1e 	bx	lr

30025a30 <__aeabi_fmul>:
30025a30:	e3a0c0ff 	mov	ip, #255	; 0xff
30025a34:	e01c2ba0 	ands	r2, ip, r0, lsr #23
30025a38:	101c3ba1 	andsne	r3, ip, r1, lsr #23
30025a3c:	1132000c 	teqne	r2, ip
30025a40:	1133000c 	teqne	r3, ip
30025a44:	0a00003e 	beq	30025b44 <__aeabi_fmul+0x114>
30025a48:	e0822003 	add	r2, r2, r3
30025a4c:	e020c001 	eor	ip, r0, r1
30025a50:	e1b00480 	lsls	r0, r0, #9
30025a54:	11b01481 	lslsne	r1, r1, #9
30025a58:	0a000010 	beq	30025aa0 <__aeabi_fmul+0x70>
30025a5c:	e3a03302 	mov	r3, #134217728	; 0x8000000
30025a60:	e18302a0 	orr	r0, r3, r0, lsr #5
30025a64:	e18312a1 	orr	r1, r3, r1, lsr #5
30025a68:	e0813190 	umull	r3, r1, r0, r1
30025a6c:	e20c0102 	and	r0, ip, #-2147483648	; 0x80000000
30025a70:	e3510502 	cmp	r1, #8388608	; 0x800000
30025a74:	31a01081 	lslcc	r1, r1, #1
30025a78:	31811fa3 	orrcc	r1, r1, r3, lsr #31
30025a7c:	31a03083 	lslcc	r3, r3, #1
30025a80:	e1800001 	orr	r0, r0, r1
30025a84:	e2c2207f 	sbc	r2, r2, #127	; 0x7f
30025a88:	e35200fd 	cmp	r2, #253	; 0xfd
30025a8c:	8a00000f 	bhi	30025ad0 <__aeabi_fmul+0xa0>
30025a90:	e3530102 	cmp	r3, #-2147483648	; 0x80000000
30025a94:	e0a00b82 	adc	r0, r0, r2, lsl #23
30025a98:	03c00001 	biceq	r0, r0, #1
30025a9c:	e12fff1e 	bx	lr
30025aa0:	e3300000 	teq	r0, #0
30025aa4:	e20cc102 	and	ip, ip, #-2147483648	; 0x80000000
30025aa8:	01a01481 	lsleq	r1, r1, #9
30025aac:	e18c04a0 	orr	r0, ip, r0, lsr #9
30025ab0:	e18004a1 	orr	r0, r0, r1, lsr #9
30025ab4:	e252207f 	subs	r2, r2, #127	; 0x7f
30025ab8:	c27230ff 	rsbsgt	r3, r2, #255	; 0xff
30025abc:	c1800b82 	orrgt	r0, r0, r2, lsl #23
30025ac0:	c12fff1e 	bxgt	lr
30025ac4:	e3800502 	orr	r0, r0, #8388608	; 0x800000
30025ac8:	e3a03000 	mov	r3, #0
30025acc:	e2522001 	subs	r2, r2, #1
30025ad0:	ca000035 	bgt	30025bac <__aeabi_fmul+0x17c>
30025ad4:	e3720019 	cmn	r2, #25
30025ad8:	d2000102 	andle	r0, r0, #-2147483648	; 0x80000000
30025adc:	d12fff1e 	bxle	lr
30025ae0:	e2622000 	rsb	r2, r2, #0
30025ae4:	e1b01080 	lsls	r1, r0, #1
30025ae8:	e1a01231 	lsr	r1, r1, r2
30025aec:	e2622020 	rsb	r2, r2, #32
30025af0:	e1a0c210 	lsl	ip, r0, r2
30025af4:	e1b00061 	rrxs	r0, r1
30025af8:	e2a00000 	adc	r0, r0, #0
30025afc:	e193308c 	orrs	r3, r3, ip, lsl #1
30025b00:	01c00fac 	biceq	r0, r0, ip, lsr #31
30025b04:	e12fff1e 	bx	lr
30025b08:	e3320000 	teq	r2, #0
30025b0c:	e200c102 	and	ip, r0, #-2147483648	; 0x80000000
30025b10:	01a00080 	lsleq	r0, r0, #1
30025b14:	03100502 	tsteq	r0, #8388608	; 0x800000
30025b18:	02422001 	subeq	r2, r2, #1
30025b1c:	0afffffb 	beq	30025b10 <__aeabi_fmul+0xe0>
30025b20:	e180000c 	orr	r0, r0, ip
30025b24:	e3330000 	teq	r3, #0
30025b28:	e201c102 	and	ip, r1, #-2147483648	; 0x80000000
30025b2c:	01a01081 	lsleq	r1, r1, #1
30025b30:	03110502 	tsteq	r1, #8388608	; 0x800000
30025b34:	02433001 	subeq	r3, r3, #1
30025b38:	0afffffb 	beq	30025b2c <__aeabi_fmul+0xfc>
30025b3c:	e181100c 	orr	r1, r1, ip
30025b40:	eaffffc0 	b	30025a48 <__aeabi_fmul+0x18>
30025b44:	e00c3ba1 	and	r3, ip, r1, lsr #23
30025b48:	e132000c 	teq	r2, ip
30025b4c:	1133000c 	teqne	r3, ip
30025b50:	0a000005 	beq	30025b6c <__aeabi_fmul+0x13c>
30025b54:	e3d0c102 	bics	ip, r0, #-2147483648	; 0x80000000
30025b58:	13d1c102 	bicsne	ip, r1, #-2147483648	; 0x80000000
30025b5c:	1affffe9 	bne	30025b08 <__aeabi_fmul+0xd8>
30025b60:	e0200001 	eor	r0, r0, r1
30025b64:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
30025b68:	e12fff1e 	bx	lr
30025b6c:	e3300000 	teq	r0, #0
30025b70:	13300102 	teqne	r0, #-2147483648	; 0x80000000
30025b74:	01a00001 	moveq	r0, r1
30025b78:	13310000 	teqne	r1, #0
30025b7c:	13310102 	teqne	r1, #-2147483648	; 0x80000000
30025b80:	0a00000d 	beq	30025bbc <__aeabi_fmul+0x18c>
30025b84:	e132000c 	teq	r2, ip
30025b88:	1a000001 	bne	30025b94 <__aeabi_fmul+0x164>
30025b8c:	e1b02480 	lsls	r2, r0, #9
30025b90:	1a000009 	bne	30025bbc <__aeabi_fmul+0x18c>
30025b94:	e133000c 	teq	r3, ip
30025b98:	1a000002 	bne	30025ba8 <__aeabi_fmul+0x178>
30025b9c:	e1b03481 	lsls	r3, r1, #9
30025ba0:	11a00001 	movne	r0, r1
30025ba4:	1a000004 	bne	30025bbc <__aeabi_fmul+0x18c>
30025ba8:	e0200001 	eor	r0, r0, r1
30025bac:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
30025bb0:	e380047f 	orr	r0, r0, #2130706432	; 0x7f000000
30025bb4:	e3800502 	orr	r0, r0, #8388608	; 0x800000
30025bb8:	e12fff1e 	bx	lr
30025bbc:	e380047f 	orr	r0, r0, #2130706432	; 0x7f000000
30025bc0:	e3800503 	orr	r0, r0, #12582912	; 0xc00000
30025bc4:	e12fff1e 	bx	lr

30025bc8 <__aeabi_fdiv>:
30025bc8:	e3a0c0ff 	mov	ip, #255	; 0xff
30025bcc:	e01c2ba0 	ands	r2, ip, r0, lsr #23
30025bd0:	101c3ba1 	andsne	r3, ip, r1, lsr #23
30025bd4:	1132000c 	teqne	r2, ip
30025bd8:	1133000c 	teqne	r3, ip
30025bdc:	0a00003a 	beq	30025ccc <__aeabi_fdiv+0x104>
30025be0:	e0422003 	sub	r2, r2, r3
30025be4:	e020c001 	eor	ip, r0, r1
30025be8:	e1b01481 	lsls	r1, r1, #9
30025bec:	e1a00480 	lsl	r0, r0, #9
30025bf0:	0a00001c 	beq	30025c68 <__aeabi_fdiv+0xa0>
30025bf4:	e3a03201 	mov	r3, #268435456	; 0x10000000
30025bf8:	e1831221 	orr	r1, r3, r1, lsr #4
30025bfc:	e1833220 	orr	r3, r3, r0, lsr #4
30025c00:	e20c0102 	and	r0, ip, #-2147483648	; 0x80000000
30025c04:	e1530001 	cmp	r3, r1
30025c08:	31a03083 	lslcc	r3, r3, #1
30025c0c:	e2a2207d 	adc	r2, r2, #125	; 0x7d
30025c10:	e3a0c502 	mov	ip, #8388608	; 0x800000
30025c14:	e1530001 	cmp	r3, r1
30025c18:	20433001 	subcs	r3, r3, r1
30025c1c:	2180000c 	orrcs	r0, r0, ip
30025c20:	e15300a1 	cmp	r3, r1, lsr #1
30025c24:	204330a1 	subcs	r3, r3, r1, lsr #1
30025c28:	218000ac 	orrcs	r0, r0, ip, lsr #1
30025c2c:	e1530121 	cmp	r3, r1, lsr #2
30025c30:	20433121 	subcs	r3, r3, r1, lsr #2
30025c34:	2180012c 	orrcs	r0, r0, ip, lsr #2
30025c38:	e15301a1 	cmp	r3, r1, lsr #3
30025c3c:	204331a1 	subcs	r3, r3, r1, lsr #3
30025c40:	218001ac 	orrcs	r0, r0, ip, lsr #3
30025c44:	e1b03203 	lsls	r3, r3, #4
30025c48:	11b0c22c 	lsrsne	ip, ip, #4
30025c4c:	1afffff0 	bne	30025c14 <__aeabi_fdiv+0x4c>
30025c50:	e35200fd 	cmp	r2, #253	; 0xfd
30025c54:	8affff9d 	bhi	30025ad0 <__aeabi_fmul+0xa0>
30025c58:	e1530001 	cmp	r3, r1
30025c5c:	e0a00b82 	adc	r0, r0, r2, lsl #23
30025c60:	03c00001 	biceq	r0, r0, #1
30025c64:	e12fff1e 	bx	lr
30025c68:	e20cc102 	and	ip, ip, #-2147483648	; 0x80000000
30025c6c:	e18c04a0 	orr	r0, ip, r0, lsr #9
30025c70:	e292207f 	adds	r2, r2, #127	; 0x7f
30025c74:	c27230ff 	rsbsgt	r3, r2, #255	; 0xff
30025c78:	c1800b82 	orrgt	r0, r0, r2, lsl #23
30025c7c:	c12fff1e 	bxgt	lr
30025c80:	e3800502 	orr	r0, r0, #8388608	; 0x800000
30025c84:	e3a03000 	mov	r3, #0
30025c88:	e2522001 	subs	r2, r2, #1
30025c8c:	eaffff8f 	b	30025ad0 <__aeabi_fmul+0xa0>
30025c90:	e3320000 	teq	r2, #0
30025c94:	e200c102 	and	ip, r0, #-2147483648	; 0x80000000
30025c98:	01a00080 	lsleq	r0, r0, #1
30025c9c:	03100502 	tsteq	r0, #8388608	; 0x800000
30025ca0:	02422001 	subeq	r2, r2, #1
30025ca4:	0afffffb 	beq	30025c98 <__aeabi_fdiv+0xd0>
30025ca8:	e180000c 	orr	r0, r0, ip
30025cac:	e3330000 	teq	r3, #0
30025cb0:	e201c102 	and	ip, r1, #-2147483648	; 0x80000000
30025cb4:	01a01081 	lsleq	r1, r1, #1
30025cb8:	03110502 	tsteq	r1, #8388608	; 0x800000
30025cbc:	02433001 	subeq	r3, r3, #1
30025cc0:	0afffffb 	beq	30025cb4 <__aeabi_fdiv+0xec>
30025cc4:	e181100c 	orr	r1, r1, ip
30025cc8:	eaffffc4 	b	30025be0 <__aeabi_fdiv+0x18>
30025ccc:	e00c3ba1 	and	r3, ip, r1, lsr #23
30025cd0:	e132000c 	teq	r2, ip
30025cd4:	1a000005 	bne	30025cf0 <__aeabi_fdiv+0x128>
30025cd8:	e1b02480 	lsls	r2, r0, #9
30025cdc:	1affffb6 	bne	30025bbc <__aeabi_fmul+0x18c>
30025ce0:	e133000c 	teq	r3, ip
30025ce4:	1affffaf 	bne	30025ba8 <__aeabi_fmul+0x178>
30025ce8:	e1a00001 	mov	r0, r1
30025cec:	eaffffb2 	b	30025bbc <__aeabi_fmul+0x18c>
30025cf0:	e133000c 	teq	r3, ip
30025cf4:	1a000003 	bne	30025d08 <__aeabi_fdiv+0x140>
30025cf8:	e1b03481 	lsls	r3, r1, #9
30025cfc:	0affff97 	beq	30025b60 <__aeabi_fmul+0x130>
30025d00:	e1a00001 	mov	r0, r1
30025d04:	eaffffac 	b	30025bbc <__aeabi_fmul+0x18c>
30025d08:	e3d0c102 	bics	ip, r0, #-2147483648	; 0x80000000
30025d0c:	13d1c102 	bicsne	ip, r1, #-2147483648	; 0x80000000
30025d10:	1affffde 	bne	30025c90 <__aeabi_fdiv+0xc8>
30025d14:	e3d02102 	bics	r2, r0, #-2147483648	; 0x80000000
30025d18:	1affffa2 	bne	30025ba8 <__aeabi_fmul+0x178>
30025d1c:	e3d13102 	bics	r3, r1, #-2147483648	; 0x80000000
30025d20:	1affff8e 	bne	30025b60 <__aeabi_fmul+0x130>
30025d24:	eaffffa4 	b	30025bbc <__aeabi_fmul+0x18c>

30025d28 <__gesf2>:
30025d28:	e3e0c000 	mvn	ip, #0
30025d2c:	ea000002 	b	30025d3c <__cmpsf2+0x4>

30025d30 <__lesf2>:
30025d30:	e3a0c001 	mov	ip, #1
30025d34:	ea000000 	b	30025d3c <__cmpsf2+0x4>

30025d38 <__cmpsf2>:
30025d38:	e3a0c001 	mov	ip, #1
30025d3c:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
30025d40:	e1a02080 	lsl	r2, r0, #1
30025d44:	e1a03081 	lsl	r3, r1, #1
30025d48:	e1f0cc42 	mvns	ip, r2, asr #24
30025d4c:	11f0cc43 	mvnsne	ip, r3, asr #24
30025d50:	0a000007 	beq	30025d74 <__cmpsf2+0x3c>
30025d54:	e28dd004 	add	sp, sp, #4
30025d58:	e192c0a3 	orrs	ip, r2, r3, lsr #1
30025d5c:	11300001 	teqne	r0, r1
30025d60:	50520003 	subspl	r0, r2, r3
30025d64:	81a00fc1 	asrhi	r0, r1, #31
30025d68:	31e00fc1 	mvncc	r0, r1, asr #31
30025d6c:	13800001 	orrne	r0, r0, #1
30025d70:	e12fff1e 	bx	lr
30025d74:	e1f0cc42 	mvns	ip, r2, asr #24
30025d78:	1a000001 	bne	30025d84 <__cmpsf2+0x4c>
30025d7c:	e1b0c480 	lsls	ip, r0, #9
30025d80:	1a000003 	bne	30025d94 <__cmpsf2+0x5c>
30025d84:	e1f0cc43 	mvns	ip, r3, asr #24
30025d88:	1afffff1 	bne	30025d54 <__cmpsf2+0x1c>
30025d8c:	e1b0c481 	lsls	ip, r1, #9
30025d90:	0affffef 	beq	30025d54 <__cmpsf2+0x1c>
30025d94:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
30025d98:	e12fff1e 	bx	lr

30025d9c <__aeabi_cfrcmple>:
30025d9c:	e1a0c000 	mov	ip, r0
30025da0:	e1a00001 	mov	r0, r1
30025da4:	e1a0100c 	mov	r1, ip
30025da8:	eaffffff 	b	30025dac <__aeabi_cfcmpeq>

30025dac <__aeabi_cfcmpeq>:
30025dac:	e92d400f 	push	{r0, r1, r2, r3, lr}
30025db0:	ebffffe0 	bl	30025d38 <__cmpsf2>
30025db4:	e3500000 	cmp	r0, #0
30025db8:	43700000 	cmnmi	r0, #0
30025dbc:	e8bd400f 	pop	{r0, r1, r2, r3, lr}
30025dc0:	e12fff1e 	bx	lr

30025dc4 <__aeabi_fcmpeq>:
30025dc4:	e52de008 	str	lr, [sp, #-8]!
30025dc8:	ebfffff7 	bl	30025dac <__aeabi_cfcmpeq>
30025dcc:	03a00001 	moveq	r0, #1
30025dd0:	13a00000 	movne	r0, #0
30025dd4:	e49de008 	ldr	lr, [sp], #8
30025dd8:	e12fff1e 	bx	lr

30025ddc <__aeabi_fcmplt>:
30025ddc:	e52de008 	str	lr, [sp, #-8]!
30025de0:	ebfffff1 	bl	30025dac <__aeabi_cfcmpeq>
30025de4:	33a00001 	movcc	r0, #1
30025de8:	23a00000 	movcs	r0, #0
30025dec:	e49de008 	ldr	lr, [sp], #8
30025df0:	e12fff1e 	bx	lr

30025df4 <__aeabi_fcmple>:
30025df4:	e52de008 	str	lr, [sp, #-8]!
30025df8:	ebffffeb 	bl	30025dac <__aeabi_cfcmpeq>
30025dfc:	93a00001 	movls	r0, #1
30025e00:	83a00000 	movhi	r0, #0
30025e04:	e49de008 	ldr	lr, [sp], #8
30025e08:	e12fff1e 	bx	lr

30025e0c <__aeabi_fcmpge>:
30025e0c:	e52de008 	str	lr, [sp, #-8]!
30025e10:	ebffffe1 	bl	30025d9c <__aeabi_cfrcmple>
30025e14:	93a00001 	movls	r0, #1
30025e18:	83a00000 	movhi	r0, #0
30025e1c:	e49de008 	ldr	lr, [sp], #8
30025e20:	e12fff1e 	bx	lr

30025e24 <__aeabi_fcmpgt>:
30025e24:	e52de008 	str	lr, [sp, #-8]!
30025e28:	ebffffdb 	bl	30025d9c <__aeabi_cfrcmple>
30025e2c:	33a00001 	movcc	r0, #1
30025e30:	23a00000 	movcs	r0, #0
30025e34:	e49de008 	ldr	lr, [sp], #8
30025e38:	e12fff1e 	bx	lr
30025e3c:	72724544 	.word	0x72724544
30025e40:	0000000a 	.word	0x0000000a
30025e44:	69206e69 	.word	0x69206e69
30025e48:	2074696e 	.word	0x2074696e
30025e4c:	00677073 	.word	0x00677073
30025e50:	6d656164 	.word	0x6d656164
30025e54:	00006e6f 	.word	0x00006e6f
30025e58:	736e6f63 	.word	0x736e6f63
30025e5c:	00656c6f 	.word	0x00656c6f
30025e60:	6c6c6568 	.word	0x6c6c6568
30025e64:	7073206f 	.word	0x7073206f
30025e68:	00000067 	.word	0x00000067
30025e6c:	656c6469 	.word	0x656c6469
30025e70:	00000000 	.word	0x00000000
30025e74:	69206e69 	.word	0x69206e69
30025e78:	0074696e 	.word	0x0074696e
30025e7c:	74696e69 	.word	0x74696e69
30025e80:	00000000 	.word	0x00000000
30025e84:	6f6c6c41 	.word	0x6f6c6c41
30025e88:	68742063 	.word	0x68742063
30025e8c:	64616572 	.word	0x64616572
30025e90:	2073253a 	.word	0x2073253a
30025e94:	6c696166 	.word	0x6c696166
30025e98:	0000000a 	.word	0x0000000a
30025e9c:	74206f4e 	.word	0x74206f4e
30025ea0:	61657268 	.word	0x61657268
30025ea4:	6f702064 	.word	0x6f702064
30025ea8:	7963696c 	.word	0x7963696c
30025eac:	70757320 	.word	0x70757320
30025eb0:	74726f70 	.word	0x74726f70
30025eb4:	0a64253a 	.word	0x0a64253a
30025eb8:	00000000 	.word	0x00000000
30025ebc:	65657341 	.word	0x65657341
30025ec0:	493a7472 	.word	0x493a7472
30025ec4:	6573206e 	.word	0x6573206e
30025ec8:	7463656c 	.word	0x7463656c
30025ecc:	72687420 	.word	0x72687420
30025ed0:	00646165 	.word	0x00646165
30025ed4:	6f6c6c41 	.word	0x6f6c6c41
30025ed8:	68742063 	.word	0x68742063
30025edc:	64616572 	.word	0x64616572
30025ee0:	2073253a 	.word	0x2073253a
30025ee4:	6c696166 	.word	0x6c696166
30025ee8:	0000000a 	.word	0x0000000a
30025eec:	74206f4e 	.word	0x74206f4e
30025ef0:	61657268 	.word	0x61657268
30025ef4:	74732064 	.word	0x74732064
30025ef8:	3a6b6361 	.word	0x3a6b6361
30025efc:	000a7325 	.word	0x000a7325
30025f00:	6d6d6f63 	.word	0x6d6d6f63
30025f04:	00000000 	.word	0x00000000
30025f08:	20736552 	.word	0x20736552
30025f0c:	656c6552 	.word	0x656c6552
30025f10:	0a657361 	.word	0x0a657361
30025f14:	00000000 	.word	0x00000000
30025f18:	20736552 	.word	0x20736552
30025f1c:	656c6572 	.word	0x656c6572
30025f20:	20657361 	.word	0x20657361
30025f24:	0a727245 	.word	0x0a727245
30025f28:	00000000 	.word	0x00000000
30025f2c:	20727245 	.word	0x20727245
30025f30:	0a736552 	.word	0x0a736552
30025f34:	00000000 	.word	0x00000000
30025f38:	000a7325 	.word	0x000a7325
30025f3c:	20727245 	.word	0x20727245
30025f40:	27736572 	.word	0x27736572
30025f44:	64692073 	.word	0x64692073
30025f48:	0a78253a 	.word	0x0a78253a
30025f4c:	00000000 	.word	0x00000000
30025f50:	65637845 	.word	0x65637845
30025f54:	6f697470 	.word	0x6f697470
30025f58:	636f206e 	.word	0x636f206e
30025f5c:	0a727563 	.word	0x0a727563
30025f60:	00000000 	.word	0x00000000
30025f64:	2a2a2a2a 	.word	0x2a2a2a2a
30025f68:	2a2a2a2a 	.word	0x2a2a2a2a
30025f6c:	2a2a2a2a 	.word	0x2a2a2a2a
30025f70:	2a2a2a2a 	.word	0x2a2a2a2a
30025f74:	000a2a2a 	.word	0x000a2a2a
30025f78:	3a555043 	.word	0x3a555043
30025f7c:	000a6425 	.word	0x000a6425
30025f80:	65726854 	.word	0x65726854
30025f84:	6e206461 	.word	0x6e206461
30025f88:	3a656d61 	.word	0x3a656d61
30025f8c:	000a7325 	.word	0x000a7325
30025f90:	65726854 	.word	0x65726854
30025f94:	70206461 	.word	0x70206461
30025f98:	3a6f6972 	.word	0x3a6f6972
30025f9c:	000a6425 	.word	0x000a6425
30025fa0:	65726854 	.word	0x65726854
30025fa4:	73206461 	.word	0x73206461
30025fa8:	6b636174 	.word	0x6b636174
30025fac:	7a69735f 	.word	0x7a69735f
30025fb0:	64253a65 	.word	0x64253a65
30025fb4:	0000000a 	.word	0x0000000a
30025fb8:	65726854 	.word	0x65726854
30025fbc:	73206461 	.word	0x73206461
30025fc0:	6b636174 	.word	0x6b636174
30025fc4:	7475625f 	.word	0x7475625f
30025fc8:	3a6d6f74 	.word	0x3a6d6f74
30025fcc:	78257830 	.word	0x78257830
30025fd0:	0000000a 	.word	0x0000000a
30025fd4:	65726854 	.word	0x65726854
30025fd8:	73206461 	.word	0x73206461
30025fdc:	6b636174 	.word	0x6b636174
30025fe0:	2578303a 	.word	0x2578303a
30025fe4:	00000a78 	.word	0x00000a78
30025fe8:	303a6350 	.word	0x303a6350
30025fec:	0a782578 	.word	0x0a782578
30025ff0:	00000000 	.word	0x00000000
30025ff4:	63617453 	.word	0x63617453
30025ff8:	78303a6b 	.word	0x78303a6b
30025ffc:	000a7825 	.word	0x000a7825
30026000:	74206e69 	.word	0x74206e69
30026004:	20656d69 	.word	0x20656d69
30026008:	6c616564 	.word	0x6c616564
3002600c:	00000000 	.word	0x00000000
30026010:	74206e69 	.word	0x74206e69
30026014:	20656d69 	.word	0x20656d69
30026018:	6c616564 	.word	0x6c616564
3002601c:	726f6620 	.word	0x726f6620
30026020:	00000000 	.word	0x00000000
30026024:	74206e69 	.word	0x74206e69
30026028:	6f656d69 	.word	0x6f656d69
3002602c:	64207475 	.word	0x64207475
30026030:	006c6165 	.word	0x006c6165
30026034:	6574756d 	.word	0x6574756d
30026038:	554e2078 	.word	0x554e2078
3002603c:	000a4c4c 	.word	0x000a4c4c
30026040:	6574756d 	.word	0x6574756d
30026044:	72702078 	.word	0x72702078
30026048:	65206f69 	.word	0x65206f69
3002604c:	000a7272 	.word	0x000a7272
30026050:	6576654c 	.word	0x6576654c
30026054:	0d64256c 	.word	0x0d64256c
30026058:	0000000a 	.word	0x0000000a
3002605c:	6d746962 	.word	0x6d746962
30026060:	003a7061 	.word	0x003a7061
30026064:	00207825 	.word	0x00207825
30026068:	00000a0d 	.word	0x00000a0d
3002606c:	65657246 	.word	0x65657246
30026070:	6f6c4220 	.word	0x6f6c4220
30026074:	68206b63 	.word	0x68206b63
30026078:	3a646165 	.word	0x3a646165
3002607c:	0a0d6425 	.word	0x0a0d6425
30026080:	00000000 	.word	0x00000000
30026084:	65657246 	.word	0x65657246
30026088:	6d654d20 	.word	0x6d654d20
3002608c:	6f6c4220 	.word	0x6f6c4220
30026090:	4e206b63 	.word	0x4e206b63
30026094:	65626d75 	.word	0x65626d75
30026098:	64253a72 	.word	0x64253a72
3002609c:	00000a0d 	.word	0x00000a0d
300260a0:	61766e49 	.word	0x61766e49
300260a4:	2064696c 	.word	0x2064696c
300260a8:	65657246 	.word	0x65657246
300260ac:	64644120 	.word	0x64644120
300260b0:	73736572 	.word	0x73736572
300260b4:	2578303a 	.word	0x2578303a
300260b8:	00000a78 	.word	0x00000a78
300260bc:	72646441 	.word	0x72646441
300260c0:	3a737365 	.word	0x3a737365
300260c4:	78257830 	.word	0x78257830
300260c8:	76616820 	.word	0x76616820
300260cc:	65622065 	.word	0x65622065
300260d0:	66206e65 	.word	0x66206e65
300260d4:	64656572 	.word	0x64656572
300260d8:	0000000a 	.word	0x0000000a
300260dc:	20727245 	.word	0x20727245
300260e0:	72646461 	.word	0x72646461
300260e4:	20737365 	.word	0x20737365
300260e8:	30207369 	.word	0x30207369
300260ec:	2c782578 	.word	0x2c782578
300260f0:	657a6973 	.word	0x657a6973
300260f4:	6f687320 	.word	0x6f687320
300260f8:	20646c75 	.word	0x20646c75
300260fc:	20746f6e 	.word	0x20746f6e
30026100:	30206562 	.word	0x30206562
30026104:	00000000 	.word	0x00000000
30026108:	61766e49 	.word	0x61766e49
3002610c:	6564696c 	.word	0x6564696c
30026110:	65724620 	.word	0x65724620
30026114:	64612065 	.word	0x64612065
30026118:	73657264 	.word	0x73657264
3002611c:	78303a73 	.word	0x78303a73
30026120:	000a7825 	.word	0x000a7825
30026124:	72646441 	.word	0x72646441
30026128:	3a737365 	.word	0x3a737365
3002612c:	78257830 	.word	0x78257830
30026130:	76616820 	.word	0x76616820
30026134:	65622065 	.word	0x65622065
30026138:	66206e65 	.word	0x66206e65
3002613c:	64656572 	.word	0x64656572
30026140:	0000000a 	.word	0x0000000a
30026144:	20727265 	.word	0x20727265
30026148:	72646461 	.word	0x72646461
3002614c:	20737365 	.word	0x20737365
30026150:	30207369 	.word	0x30207369
30026154:	2c782578 	.word	0x2c782578
30026158:	657a6973 	.word	0x657a6973
3002615c:	6f687320 	.word	0x6f687320
30026160:	20646c75 	.word	0x20646c75
30026164:	20746f6e 	.word	0x20746f6e
30026168:	30206562 	.word	0x30206562
3002616c:	00000000 	.word	0x00000000
30026170:	206d654d 	.word	0x206d654d
30026174:	74696e49 	.word	0x74696e49
30026178:	72724520 	.word	0x72724520
3002617c:	6f732c20 	.word	0x6f732c20
30026180:	206f6e20 	.word	0x206f6e20
30026184:	206d656d 	.word	0x206d656d
30026188:	63617073 	.word	0x63617073
3002618c:	6f742065 	.word	0x6f742065
30026190:	6c616d20 	.word	0x6c616d20
30026194:	0d636f6c 	.word	0x0d636f6c
30026198:	0000000a 	.word	0x0000000a
3002619c:	20727245 	.word	0x20727245
300261a0:	72646461 	.word	0x72646461
300261a4:	20737365 	.word	0x20737365
300261a8:	30207369 	.word	0x30207369
300261ac:	2c782578 	.word	0x2c782578
300261b0:	657a6973 	.word	0x657a6973
300261b4:	6f687320 	.word	0x6f687320
300261b8:	20646c75 	.word	0x20646c75
300261bc:	20746f6e 	.word	0x20746f6e
300261c0:	30206562 	.word	0x30206562
300261c4:	00000a0d 	.word	0x00000a0d
300261c8:	20656854 	.word	0x20656854
300261cc:	72646461 	.word	0x72646461
300261d0:	20737365 	.word	0x20737365
300261d4:	30207369 	.word	0x30207369
300261d8:	2c782578 	.word	0x2c782578
300261dc:	20656874 	.word	0x20656874
300261e0:	636f6c62 	.word	0x636f6c62
300261e4:	7369206b 	.word	0x7369206b
300261e8:	65737520 	.word	0x65737520
300261ec:	6e612064 	.word	0x6e612064
300261f0:	74692064 	.word	0x74692064
300261f4:	73207327 	.word	0x73207327
300261f8:	20657a69 	.word	0x20657a69
300261fc:	25207369 	.word	0x25207369
30026200:	000a0d64 	.word	0x000a0d64
30026204:	20656854 	.word	0x20656854
30026208:	72646461 	.word	0x72646461
3002620c:	20737365 	.word	0x20737365
30026210:	30207369 	.word	0x30207369
30026214:	2c782578 	.word	0x2c782578
30026218:	20656874 	.word	0x20656874
3002621c:	636f6c62 	.word	0x636f6c62
30026220:	7369206b 	.word	0x7369206b
30026224:	756e7520 	.word	0x756e7520
30026228:	20646573 	.word	0x20646573
3002622c:	20646e61 	.word	0x20646e61
30026230:	73277469 	.word	0x73277469
30026234:	7a697320 	.word	0x7a697320
30026238:	73692065 	.word	0x73692065
3002623c:	0d642520 	.word	0x0d642520
30026240:	0000000a 	.word	0x0000000a
30026244:	20727245 	.word	0x20727245
30026248:	206d6553 	.word	0x206d6553
3002624c:	74736f70 	.word	0x74736f70
30026250:	0000000a 	.word	0x0000000a
30026254:	2064690a 	.word	0x2064690a
30026258:	6425203d 	.word	0x6425203d
3002625c:	00000000 	.word	0x00000000
30026260:	6177200a 	.word	0x6177200a
30026264:	74207469 	.word	0x74207469
30026268:	61657268 	.word	0x61657268
3002626c:	6d207364 	.word	0x6d207364
30026270:	3d206d75 	.word	0x3d206d75
30026274:	00642520 	.word	0x00642520
30026278:	6c206f4e 	.word	0x6c206f4e
3002627c:	6c657665 	.word	0x6c657665
30026280:	656d2032 	.word	0x656d2032
30026284:	7073206d 	.word	0x7073206d
30026288:	20656361 	.word	0x20656361
3002628c:	20726f66 	.word	0x20726f66
30026290:	76697270 	.word	0x76697270
30026294:	5f657461 	.word	0x5f657461
30026298:	61746164 	.word	0x61746164
3002629c:	0a73253a 	.word	0x0a73253a
300262a0:	00000000 	.word	0x00000000
300262a4:	74204d52 	.word	0x74204d52
300262a8:	61657268 	.word	0x61657268
300262ac:	73252064 	.word	0x73252064
300262b0:	72724520 	.word	0x72724520
300262b4:	6972502c 	.word	0x6972502c
300262b8:	7369206f 	.word	0x7369206f
300262bc:	746f6e20 	.word	0x746f6e20
300262c0:	6f6e6520 	.word	0x6f6e6520
300262c4:	0a686775 	.word	0x0a686775
300262c8:	00000000 	.word	0x00000000
300262cc:	63736944 	.word	0x63736944
300262d0:	20647261 	.word	0x20647261
300262d4:	65726874 	.word	0x65726874
300262d8:	25206461 	.word	0x25206461
300262dc:	00000a73 	.word	0x00000a73
300262e0:	00006d72 	.word	0x00006d72
300262e4:	6c206f4e 	.word	0x6c206f4e
300262e8:	6c657665 	.word	0x6c657665
300262ec:	656d2032 	.word	0x656d2032
300262f0:	7073206d 	.word	0x7073206d
300262f4:	20656361 	.word	0x20656361
300262f8:	20726f66 	.word	0x20726f66
300262fc:	76697270 	.word	0x76697270
30026300:	5f657461 	.word	0x5f657461
30026304:	61746164 	.word	0x61746164
30026308:	0a73253a 	.word	0x0a73253a
3002630c:	00000000 	.word	0x00000000
30026310:	74206f4e 	.word	0x74206f4e
30026314:	61657268 	.word	0x61657268
30026318:	74732064 	.word	0x74732064
3002631c:	3a6b6361 	.word	0x3a6b6361
30026320:	000a7325 	.word	0x000a7325
30026324:	70206e69 	.word	0x70206e69
30026328:	6f697265 	.word	0x6f697265
3002632c:	68742064 	.word	0x68742064
30026330:	64616572 	.word	0x64616572
30026334:	61656420 	.word	0x61656420
30026338:	0000006c 	.word	0x0000006c
3002633c:	70206e69 	.word	0x70206e69
30026340:	6f697265 	.word	0x6f697265
30026344:	68742064 	.word	0x68742064
30026348:	64616572 	.word	0x64616572
3002634c:	61656420 	.word	0x61656420
30026350:	0000206c 	.word	0x0000206c
30026354:	69726570 	.word	0x69726570
30026358:	0000646f 	.word	0x0000646f
3002635c:	6c206f4e 	.word	0x6c206f4e
30026360:	6c657665 	.word	0x6c657665
30026364:	656d2032 	.word	0x656d2032
30026368:	7073206d 	.word	0x7073206d
3002636c:	20656361 	.word	0x20656361
30026370:	20726f66 	.word	0x20726f66
30026374:	76697270 	.word	0x76697270
30026378:	5f657461 	.word	0x5f657461
3002637c:	61746164 	.word	0x61746164
30026380:	0a73253a 	.word	0x0a73253a
30026384:	00000000 	.word	0x00000000
30026388:	74206f4e 	.word	0x74206f4e
3002638c:	61657268 	.word	0x61657268
30026390:	74732064 	.word	0x74732064
30026394:	3a6b6361 	.word	0x3a6b6361
30026398:	000a7325 	.word	0x000a7325
3002639c:	63696c73 	.word	0x63696c73
300263a0:	00000065 	.word	0x00000065
300263a4:	6f6c6c41 	.word	0x6f6c6c41
300263a8:	6f502063 	.word	0x6f502063
300263ac:	20786973 	.word	0x20786973
300263b0:	65726874 	.word	0x65726874
300263b4:	66206461 	.word	0x66206461
300263b8:	0a6c6961 	.word	0x0a6c6961
300263bc:	00000000 	.word	0x00000000
300263c0:	6d206f4e 	.word	0x6d206f4e
300263c4:	73206d65 	.word	0x73206d65
300263c8:	65636170 	.word	0x65636170
300263cc:	726f6620 	.word	0x726f6620
300263d0:	736f7020 	.word	0x736f7020
300263d4:	70207869 	.word	0x70207869
300263d8:	61766972 	.word	0x61766972
300263dc:	645f6574 	.word	0x645f6574
300263e0:	3a617461 	.word	0x3a617461
300263e4:	000a7325 	.word	0x000a7325
300263e8:	74206f4e 	.word	0x74206f4e
300263ec:	61657268 	.word	0x61657268
300263f0:	74732064 	.word	0x74732064
300263f4:	3a6b6361 	.word	0x3a6b6361
300263f8:	000a7325 	.word	0x000a7325
300263fc:	69736f70 	.word	0x69736f70
30026400:	00000078 	.word	0x00000078
30026404:	74666f73 	.word	0x74666f73
30026408:	616c6564 	.word	0x616c6564
3002640c:	00000079 	.word	0x00000079

30026410 <small_digits>:
30026410:	33323130 37363534 62613938 66656463     0123456789abcdef
30026420:	6a696867 6e6d6c6b 7271706f 76757473     ghijklmnopqrstuv
30026430:	7a797877 00000000                       wxyz....

30026438 <large_digits>:
30026438:	33323130 37363534 42413938 46454443     0123456789ABCDEF
30026448:	4a494847 4e4d4c4b 5251504f 56555453     GHIJKLMNOPQRSTUV
30026458:	5a595857 00000000 4c554e3c 00003e4c     WXYZ....<NULL>..
30026468:	736e6f63 00656c6f 63610a0d 6c61726f     console...acoral
30026478:	74656e5f 69776c5f 6e695f70 6d0d7469     _net_lwip_init.m
30026488:	00000000 76636552 61746144 00000000     ....RecvData....

30026498 <err_to_errno_table>:
30026498:	00000000 0000000c 00000069 00000071     ........i...q...
300264a8:	00000067 00000068 0000006c 0000006b     g...h...l...k...
300264b8:	00000016 00000005 00000062 ffffffff     ........b.......
300264c8:	ffffffff 0000006e 00000073 2a2a0a0d     ....n...s.....**
300264d8:	2a2a2a2a 63742a2a 5f706970 75706e69     ******tcpip_inpu
300264e8:	2a2a2a74 2a2a2a2a 2a2a2a2a 0a0d2a2a     t*************..
300264f8:	00000000 e6a58ee6 95e6b694 ae8de6b0     ................
30026508:	e5bf95e9 253aa6ba 2d3c2064 0d3e2d2d     ......:%d <--->.
30026518:	0000000a 20783425 00000000 00000a0d     ....%4x ........
30026528:	2a3c0a0d 2a3c2a3c 2a3e2a3e 000a0d3e     ..<*<*<*>*>*>...
30026538:	2b2b0a0d 2b2b2b2b 2b2b2b2b 2b2b2b2b     ..++++++++++++++
30026548:	2b2b2b2b 0d2b2b2b 0000000a 69706374     +++++++.....tcpi
30026558:	00000070                                p...

3002655c <ip_addr_any>:
3002655c:	00000000                                ....

30026560 <ip_addr_broadcast>:
30026560:	ffffffff                                ....

30026564 <memp_sizes>:
30026564:	0020001c 002000a4 00100014 0014002c     .. ... .....,...
30026574:	00080014 00100010 000000c8              ............

30026580 <memp_num>:
30026580:	00040004 00080005 00020010 00080004     ................
30026590:	001e0008 00100003 00000010              ............

3002659c <tcp_backoff>:
3002659c:	04030201 07070605 07070707 00000007     ................

300265ac <tcp_persist_backoff>:
300265ac:	180c0603 00786030 3d3d0a0d 7074756f     ....0`x...==outp
300265bc:	2d2d7475 000a0d39 7064750a 6275703a     ut--9....udp:pub
300265cc:	20736920 20746f6e 6c6c756e 0000000a      is not null....

300265dc <ethbroadcast>:
300265dc:	ffffffff 0000ffff                       ........

300265e4 <ethzero>:
	...
300265ec:	6474656e 00007665 4f525245 74203a52     netdev..ERROR: t
300265fc:	64206568 3030396d 64692030 00642520     he dm9000 id %d.
3002660c:	6c756f43 6f6e2064 6f662074 20646e75     Could not found 
3002661c:	27732527 6d6f6320 646e616d 00000a0d     '%s' command....
3002662c:	20756f79 206e6163 65707974 65682720     you can type 'he
3002663c:	0d27706c 0000000a 6c656873 0000006c     lp'.....shell...
3002664c:	20656854 65726874 68206461 20657661     The thread have 
3002665c:	43206f6e 6f736e6f 000a656c 00000a0d     no Console......
3002666c:	726f4361 3e3a6c61 00000000 736d656d     aCoral:>....mems
3002667c:	006e6163 77656956 65687420 72696620     can.View the fir
3002668c:	4c207473 6c657665 6d654d20 2079726f     st Level Memory 
3002669c:	616e614d 6e656d67 6e492074 00006f66     Managment Info..
300266ac:	736d656d 326e6163 00000000 77656956     memscan2....View
300266bc:	65687420 63657320 65646e6f 76654c20      the seconde Lev
300266cc:	4d206c65 726f6d65 614d2079 6d67616e     el Memory Managm
300266dc:	20746e65 6f666e49 00000000 20207325     ent Info....%s  
300266ec:	000a7325 706c6568 00000000 77656956     %s..help....View
300266fc:	6c6c6120 65685320 43206c6c 616d6d6f      all Shell Comma
3002670c:	6920646e 006f666e 74697865 00000000     nd info.exit....
3002671c:	74697845 65685320 00006c6c 47475053     Exit Shell..SPGG
3002672c:	474f474f 2121214f 00000000 00677073     OGOGO!!!....spg.
3002673c:	74736145 65207265 00006767 79530909     Easter egg....Sy
3002674c:	6d657473 72685420 20646165 6f666e49     stem Thread Info
3002675c:	74616d72 0d6e6f69 0000000a 2d2d2d2d     rmation.....----
3002676c:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
3002677c:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
3002678c:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
3002679c:	0a0d2d2d 00000000 656d614e 79540909     --......Name..Ty
300267ac:	09096570 736e6f43 09656c6f 61745309     pe..Console..Sta
300267bc:	0a0d6574 00000000 09097325 00000000     te......%s......
300267cc:	6d6d6f43 09096e6f 00000000 63696c53     Common......Slic
300267dc:	00090965 69726550 0909646f 00000000     e...Period......
300267ec:	09094d52 00000000 69736f50 00090978     RM......Posix...
300267fc:	09096425 00000000 6e6e7552 09676e69     %d......Running.
3002680c:	00000009 64616552 00090979 616c6544     ....Ready...Dela
3002681c:	00090979 65656c53 00090970 65657246     y...Sleep...Free
3002682c:	0909657a 00000000 6f727245 00090972     ze......Error...
3002683c:	00000a0d 00007464 77656956 6c6c6120     ....dt..View all
3002684c:	72687420 20646165 6f666e69 00000000      thread info....
3002685c:	736e6f63 00656c6f 44206e69 3030394d     console.in DM900
3002686c:	6e692030 75726574 6f697470 00000a6e     0 interuption...
3002687c:	4d440a0d 30303039 696e6920 00000074     ..DM9000 init...
3002688c:	6474656e 00007665                       netdev..
