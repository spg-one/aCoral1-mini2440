
acoral.elf:     file format elf32-littlearm


Disassembly of section .text:

30000000 <__ENTRY>:
30000000:	ea000015 	b	3000005c <ResetHandler>
30000004:	ea00000d 	b	30000040 <HandleUndef>
30000008:	ea00000d 	b	30000044 <HandleSWI>
3000000c:	ea00000e 	b	3000004c <HandlePabort>
30000010:	ea00000c 	b	30000048 <HandleDabort>
30000014:	eafffffe 	b	30000014 <__ENTRY+0x14>
30000018:	ea000007 	b	3000003c <HandleIRQ>
3000001c:	ea000005 	b	30000038 <HandleFIQ>
	...
30000028:	30000000 	.word	0x30000000
3000002c:	00000988 	.word	0x00000988
30000030:	00000000 	.word	0x00000000
30000034:	eafffffe 	b	30000034 <__ENTRY+0x34>

30000038 <HandleFIQ>:
30000038:	e59ff244 	ldr	pc, [pc, #580]	; 30000284 <mem_cfg_val+0x34>

3000003c <HandleIRQ>:
3000003c:	e59ff244 	ldr	pc, [pc, #580]	; 30000288 <mem_cfg_val+0x38>

30000040 <HandleUndef>:
30000040:	e59ff244 	ldr	pc, [pc, #580]	; 3000028c <mem_cfg_val+0x3c>

30000044 <HandleSWI>:
30000044:	e59ff240 	ldr	pc, [pc, #576]	; 3000028c <mem_cfg_val+0x3c>

30000048 <HandleDabort>:
30000048:	e59ff23c 	ldr	pc, [pc, #572]	; 3000028c <mem_cfg_val+0x3c>

3000004c <HandlePabort>:
3000004c:	e59ff238 	ldr	pc, [pc, #568]	; 3000028c <mem_cfg_val+0x3c>

30000050 <_text_start>:
30000050:	30000000 	.word	0x30000000

30000054 <_bss_start>:
30000054:	300c9a98 	.word	0x300c9a98

30000058 <_bss_end>:
30000058:	302f7e6c 	.word	0x302f7e6c

3000005c <ResetHandler>:
3000005c:	e3a01453 	mov	r1, #1392508928	; 0x53000000
30000060:	e3a02000 	mov	r2, #0
30000064:	e5812000 	str	r2, [r1]
30000068:	e3a0144a 	mov	r1, #1241513984	; 0x4a000000
3000006c:	e3e02000 	mvn	r2, #0
30000070:	e5812008 	str	r2, [r1, #8]
30000074:	e59f2214 	ldr	r2, [pc, #532]	; 30000290 <mem_cfg_val+0x40>
30000078:	e581201c 	str	r2, [r1, #28]
3000007c:	e3a01313 	mov	r1, #1275068416	; 0x4c000000
30000080:	e3e024ff 	mvn	r2, #-16777216	; 0xff000000
30000084:	e5812000 	str	r2, [r1]
30000088:	e3a01313 	mov	r1, #1275068416	; 0x4c000000
3000008c:	e3a02005 	mov	r2, #5
30000090:	e5812014 	str	r2, [r1, #20]
30000094:	ee111f10 	mrc	15, 0, r1, cr1, cr0, {0}
30000098:	e3811103 	orr	r1, r1, #-1073741824	; 0xc0000000
3000009c:	ee011f10 	mcr	15, 0, r1, cr1, cr0, {0}
300000a0:	e3a01313 	mov	r1, #1275068416	; 0x4c000000
300000a4:	e59f21e8 	ldr	r2, [pc, #488]	; 30000294 <mem_cfg_val+0x44>
300000a8:	e5812004 	str	r2, [r1, #4]
300000ac:	eb000058 	bl	30000214 <memsetup>
300000b0:	eb00003e 	bl	300001b0 <InitStacks>
300000b4:	e24f00bc 	sub	r0, pc, #188	; 0xbc
300000b8:	e51f1070 	ldr	r1, [pc, #-112]	; 30000050 <_text_start>
300000bc:	e1500001 	cmp	r0, r1
300000c0:	1b000004 	blne	300000d8 <copy_self>
300000c4:	e51f0078 	ldr	r0, [pc, #-120]	; 30000054 <_bss_start>
300000c8:	e51f1078 	ldr	r1, [pc, #-120]	; 30000058 <_bss_end>
300000cc:	eb000059 	bl	30000238 <mem_clear>
300000d0:	e59ff1ac 	ldr	pc, [pc, #428]	; 30000284 <mem_cfg_val+0x34>
300000d4:	eafffffe 	b	300000d4 <ResetHandler+0x78>

300000d8 <copy_self>:
300000d8:	e3a011b1 	mov	r1, #1073741868	; 0x4000002c
300000dc:	e3a00000 	mov	r0, #0
300000e0:	e5810000 	str	r0, [r1]
300000e4:	e3a0102c 	mov	r1, #44	; 0x2c
300000e8:	e5910000 	ldr	r0, [r1]
300000ec:	e3500000 	cmp	r0, #0
300000f0:	1a000003 	bne	30000104 <copy_from_rom>
300000f4:	e59f019c 	ldr	r0, [pc, #412]	; 30000298 <mem_cfg_val+0x48>
300000f8:	e3a011b1 	mov	r1, #1073741868	; 0x4000002c
300000fc:	e5810000 	str	r0, [r1]
30000100:	ea000006 	b	30000120 <copy_from_nand>

30000104 <copy_from_rom>:
30000104:	e51f10bc 	ldr	r1, [pc, #-188]	; 30000050 <_text_start>
30000108:	e51f30bc 	ldr	r3, [pc, #-188]	; 30000054 <_bss_start>
3000010c:	e4902004 	ldr	r2, [r0], #4
30000110:	e4812004 	str	r2, [r1], #4
30000114:	e1510003 	cmp	r1, r3
30000118:	bafffff9 	blt	30000104 <copy_from_rom>
3000011c:	e1a0f00e 	mov	pc, lr

30000120 <copy_from_nand>:
30000120:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30000124:	eb000316 	bl	30000d84 <nand_init>
30000128:	e51f00e0 	ldr	r0, [pc, #-224]	; 30000050 <_text_start>
3000012c:	e3a01000 	mov	r1, #0
30000130:	e51f30e4 	ldr	r3, [pc, #-228]	; 30000054 <_bss_start>
30000134:	e0432000 	sub	r2, r3, r0
30000138:	eb000420 	bl	300011c0 <nand_read>
3000013c:	e3500000 	cmp	r0, #0
30000140:	0a000007 	beq	30000164 <ok_nand_read>

30000144 <bad_nand_read>:
30000144:	e59f0150 	ldr	r0, [pc, #336]	; 3000029c <mem_cfg_val+0x4c>
30000148:	e3a01a01 	mov	r1, #4096	; 0x1000
3000014c:	e5801000 	str	r1, [r0]
30000150:	e59f0148 	ldr	r0, [pc, #328]	; 300002a0 <mem_cfg_val+0x50>
30000154:	e3a01000 	mov	r1, #0
30000158:	e5801000 	str	r1, [r0]
3000015c:	eafffffe 	b	3000015c <bad_nand_read+0x18>
30000160:	eafffff7 	b	30000144 <bad_nand_read>

30000164 <ok_nand_read>:
30000164:	e3a00000 	mov	r0, #0
30000168:	e51f1120 	ldr	r1, [pc, #-288]	; 30000050 <_text_start>
3000016c:	e3a02c02 	mov	r2, #512	; 0x200

30000170 <go_next>:
30000170:	e4903004 	ldr	r3, [r0], #4
30000174:	e4914004 	ldr	r4, [r1], #4
30000178:	e1530004 	cmp	r3, r4
3000017c:	1a000002 	bne	3000018c <notmatch>
30000180:	e1500002 	cmp	r0, r2
30000184:	0a000008 	beq	300001ac <out>
30000188:	eafffff8 	b	30000170 <go_next>

3000018c <notmatch>:
3000018c:	e59f0108 	ldr	r0, [pc, #264]	; 3000029c <mem_cfg_val+0x4c>
30000190:	e3a01b01 	mov	r1, #1024	; 0x400
30000194:	e5801000 	str	r1, [r0]
30000198:	e59f0100 	ldr	r0, [pc, #256]	; 300002a0 <mem_cfg_val+0x50>
3000019c:	e3a01000 	mov	r1, #0
300001a0:	e5801000 	str	r1, [r0]
300001a4:	eafffffe 	b	300001a4 <notmatch+0x18>
300001a8:	eafffff7 	b	3000018c <notmatch>

300001ac <out>:
300001ac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)

300001b0 <InitStacks>:
300001b0:	e1a0200e 	mov	r2, lr
300001b4:	e10f0000 	mrs	r0, CPSR
300001b8:	e3c0001f 	bic	r0, r0, #31
300001bc:	e38010db 	orr	r1, r0, #219	; 0xdb
300001c0:	e12ff001 	msr	CPSR_fsxc, r1
300001c4:	e59fd0d8 	ldr	sp, [pc, #216]	; 300002a4 <mem_cfg_val+0x54>
300001c8:	e38010d7 	orr	r1, r0, #215	; 0xd7
300001cc:	e12ff001 	msr	CPSR_fsxc, r1
300001d0:	e59fd0d0 	ldr	sp, [pc, #208]	; 300002a8 <mem_cfg_val+0x58>
300001d4:	e38010d2 	orr	r1, r0, #210	; 0xd2
300001d8:	e12ff001 	msr	CPSR_fsxc, r1
300001dc:	e59fd0c8 	ldr	sp, [pc, #200]	; 300002ac <mem_cfg_val+0x5c>
300001e0:	e38010d1 	orr	r1, r0, #209	; 0xd1
300001e4:	e12ff001 	msr	CPSR_fsxc, r1
300001e8:	e59fd0c0 	ldr	sp, [pc, #192]	; 300002b0 <mem_cfg_val+0x60>
300001ec:	e3c000df 	bic	r0, r0, #223	; 0xdf
300001f0:	e3801013 	orr	r1, r0, #19
300001f4:	e12ff001 	msr	CPSR_fsxc, r1
300001f8:	e59fd0b4 	ldr	sp, [pc, #180]	; 300002b4 <mem_cfg_val+0x64>
300001fc:	e10f0000 	mrs	r0, CPSR
30000200:	e3c0001f 	bic	r0, r0, #31
30000204:	e38010df 	orr	r1, r0, #223	; 0xdf
30000208:	e12ff001 	msr	CPSR_fsxc, r1
3000020c:	e59fd0a4 	ldr	sp, [pc, #164]	; 300002b8 <mem_cfg_val+0x68>
30000210:	e1a0f002 	mov	pc, r2

30000214 <memsetup>:
30000214:	e3a01312 	mov	r1, #1207959552	; 0x48000000
30000218:	e28f2030 	add	r2, pc, #48	; 0x30
3000021c:	e1a00000 	nop			; (mov r0, r0)
30000220:	e2813034 	add	r3, r1, #52	; 0x34
30000224:	e4924004 	ldr	r4, [r2], #4
30000228:	e4814004 	str	r4, [r1], #4
3000022c:	e1510003 	cmp	r1, r3
30000230:	1afffffb 	bne	30000224 <memsetup+0x10>
30000234:	e1a0f00e 	mov	pc, lr

30000238 <mem_clear>:
30000238:	e3a02000 	mov	r2, #0
3000023c:	e4802004 	str	r2, [r0], #4
30000240:	e1500001 	cmp	r0, r1
30000244:	bafffffc 	blt	3000023c <mem_clear+0x4>
30000248:	e1a0f00e 	mov	pc, lr
3000024c:	e1a00000 	nop			; (mov r0, r0)

30000250 <mem_cfg_val>:
30000250:	22111110 	.word	0x22111110
30000254:	00000700 	.word	0x00000700
30000258:	00000700 	.word	0x00000700
3000025c:	00000700 	.word	0x00000700
30000260:	00000700 	.word	0x00000700
30000264:	00000700 	.word	0x00000700
30000268:	00000700 	.word	0x00000700
3000026c:	00018009 	.word	0x00018009
30000270:	00018009 	.word	0x00018009
30000274:	008e04eb 	.word	0x008e04eb
30000278:	000000b2 	.word	0x000000b2
3000027c:	00000030 	.word	0x00000030
30000280:	00000030 	.word	0x00000030
30000284:	30001a8c 	.word	0x30001a8c
30000288:	3000166c 	.word	0x3000166c
3000028c:	300016a8 	.word	0x300016a8
30000290:	000007ff 	.word	0x000007ff
30000294:	0007f021 	.word	0x0007f021
30000298:	00000988 	.word	0x00000988
3000029c:	56000010 	.word	0x56000010
300002a0:	56000014 	.word	0x56000014
300002a4:	33fffc00 	.word	0x33fffc00
300002a8:	33fffd00 	.word	0x33fffd00
300002ac:	33ffff00 	.word	0x33ffff00
300002b0:	33ffff00 	.word	0x33ffff00
300002b4:	33fffb00 	.word	0x33fffb00
300002b8:	33fff900 	.word	0x33fff900
300002bc:	e1a00000 	nop			; (mov r0, r0)

300002c0 <hal_stack_init>:
	acoral_u32 r12;
	acoral_u32 lr;
	acoral_u32 pc;
}hal_ctx_t;

void hal_stack_init(acoral_u32 **stk,void (*route)(),void (*exit)(),void *args){
300002c0:	e24dd018 	sub	sp, sp, #24
300002c4:	e58d000c 	str	r0, [sp, #12]
300002c8:	e58d1008 	str	r1, [sp, #8]
300002cc:	e58d2004 	str	r2, [sp, #4]
300002d0:	e58d3000 	str	r3, [sp]
	hal_ctx_t *ctx=(hal_ctx_t *)*stk;	
300002d4:	e59d300c 	ldr	r3, [sp, #12]
300002d8:	e5933000 	ldr	r3, [r3]
300002dc:	e58d3014 	str	r3, [sp, #20]
	ctx--;
300002e0:	e59d3014 	ldr	r3, [sp, #20]
300002e4:	e2433040 	sub	r3, r3, #64	; 0x40
300002e8:	e58d3014 	str	r3, [sp, #20]
	ctx=(hal_ctx_t *)((acoral_u32 *)ctx+1);
300002ec:	e59d3014 	ldr	r3, [sp, #20]
300002f0:	e2833004 	add	r3, r3, #4
300002f4:	e58d3014 	str	r3, [sp, #20]
	ctx->r0=(acoral_u32)args;
300002f8:	e59d2000 	ldr	r2, [sp]
300002fc:	e59d3014 	ldr	r3, [sp, #20]
30000300:	e5832004 	str	r2, [r3, #4]
	ctx->r1=1;
30000304:	e59d3014 	ldr	r3, [sp, #20]
30000308:	e3a02001 	mov	r2, #1
3000030c:	e5832008 	str	r2, [r3, #8]
	ctx->r2=2;
30000310:	e59d3014 	ldr	r3, [sp, #20]
30000314:	e3a02002 	mov	r2, #2
30000318:	e583200c 	str	r2, [r3, #12]
	ctx->r3=3;
3000031c:	e59d3014 	ldr	r3, [sp, #20]
30000320:	e3a02003 	mov	r2, #3
30000324:	e5832010 	str	r2, [r3, #16]
	ctx->r4=4;
30000328:	e59d3014 	ldr	r3, [sp, #20]
3000032c:	e3a02004 	mov	r2, #4
30000330:	e5832014 	str	r2, [r3, #20]
	ctx->r5=5;
30000334:	e59d3014 	ldr	r3, [sp, #20]
30000338:	e3a02005 	mov	r2, #5
3000033c:	e5832018 	str	r2, [r3, #24]
	ctx->r6=6;
30000340:	e59d3014 	ldr	r3, [sp, #20]
30000344:	e3a02006 	mov	r2, #6
30000348:	e583201c 	str	r2, [r3, #28]
	ctx->r7=7;
3000034c:	e59d3014 	ldr	r3, [sp, #20]
30000350:	e3a02007 	mov	r2, #7
30000354:	e5832020 	str	r2, [r3, #32]
	ctx->r8=8;
30000358:	e59d3014 	ldr	r3, [sp, #20]
3000035c:	e3a02008 	mov	r2, #8
30000360:	e5832024 	str	r2, [r3, #36]	; 0x24
	ctx->r9=9;
30000364:	e59d3014 	ldr	r3, [sp, #20]
30000368:	e3a02009 	mov	r2, #9
3000036c:	e5832028 	str	r2, [r3, #40]	; 0x28
	ctx->r10=10;
30000370:	e59d3014 	ldr	r3, [sp, #20]
30000374:	e3a0200a 	mov	r2, #10
30000378:	e583202c 	str	r2, [r3, #44]	; 0x2c
	ctx->r11=11;
3000037c:	e59d3014 	ldr	r3, [sp, #20]
30000380:	e3a0200b 	mov	r2, #11
30000384:	e5832030 	str	r2, [r3, #48]	; 0x30
	ctx->r12=12;
30000388:	e59d3014 	ldr	r3, [sp, #20]
3000038c:	e3a0200c 	mov	r2, #12
30000390:	e5832034 	str	r2, [r3, #52]	; 0x34
	ctx->lr=(acoral_u32)exit;
30000394:	e59d2004 	ldr	r2, [sp, #4]
30000398:	e59d3014 	ldr	r3, [sp, #20]
3000039c:	e5832038 	str	r2, [r3, #56]	; 0x38
	ctx->pc=(acoral_u32)route;
300003a0:	e59d2008 	ldr	r2, [sp, #8]
300003a4:	e59d3014 	ldr	r3, [sp, #20]
300003a8:	e583203c 	str	r2, [r3, #60]	; 0x3c
	ctx->cpsr=0x0000001fL;
300003ac:	e59d3014 	ldr	r3, [sp, #20]
300003b0:	e3a0201f 	mov	r2, #31
300003b4:	e5832000 	str	r2, [r3]
    *stk=(acoral_u32 *)ctx;
300003b8:	e59d2014 	ldr	r2, [sp, #20]
300003bc:	e59d300c 	ldr	r3, [sp, #12]
300003c0:	e5832000 	str	r2, [r3]
}
300003c4:	e28dd018 	add	sp, sp, #24
300003c8:	e12fff1e 	bx	lr

300003cc <hal_all_entry>:
#include<acoral.h>
#include<hal_2440_cfg.h>
#include<hal_2440_c.h>
void hal_all_entry(acoral_vector vector){
300003cc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300003d0:	e24dd014 	sub	sp, sp, #20
300003d4:	e58d0004 	str	r0, [sp, #4]
    unsigned long eint;
    unsigned long irq=4;
300003d8:	e3a03004 	mov	r3, #4
300003dc:	e58d300c 	str	r3, [sp, #12]
    if(vector==4||vector==5){
300003e0:	e59d3004 	ldr	r3, [sp, #4]
300003e4:	e3530004 	cmp	r3, #4
300003e8:	0a000002 	beq	300003f8 <hal_all_entry+0x2c>
300003ec:	e59d3004 	ldr	r3, [sp, #4]
300003f0:	e3530005 	cmp	r3, #5
300003f4:	1a000016 	bne	30000454 <hal_all_entry+0x88>
    	eint=rEINTPND;
300003f8:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300003fc:	e28330a8 	add	r3, r3, #168	; 0xa8
30000400:	e5933000 	ldr	r3, [r3]
30000404:	e58d3008 	str	r3, [sp, #8]
    	for(;irq<24;irq++){
30000408:	ea00000e 	b	30000448 <hal_all_entry+0x7c>
      		 if(eint & (1<<irq)){
3000040c:	e59d300c 	ldr	r3, [sp, #12]
30000410:	e3a02001 	mov	r2, #1
30000414:	e1a03312 	lsl	r3, r2, r3
30000418:	e1a02003 	mov	r2, r3
3000041c:	e59d3008 	ldr	r3, [sp, #8]
30000420:	e0023003 	and	r3, r2, r3
30000424:	e3530000 	cmp	r3, #0
30000428:	0a000003 	beq	3000043c <hal_all_entry+0x70>
           		acoral_intr_entry(irq);
3000042c:	e59d300c 	ldr	r3, [sp, #12]
30000430:	e1a00003 	mov	r0, r3
30000434:	eb000efa 	bl	30004024 <acoral_intr_entry>
           		return;
30000438:	ea000012 	b	30000488 <hal_all_entry+0xbc>
void hal_all_entry(acoral_vector vector){
    unsigned long eint;
    unsigned long irq=4;
    if(vector==4||vector==5){
    	eint=rEINTPND;
    	for(;irq<24;irq++){
3000043c:	e59d300c 	ldr	r3, [sp, #12]
30000440:	e2833001 	add	r3, r3, #1
30000444:	e58d300c 	str	r3, [sp, #12]
30000448:	e59d300c 	ldr	r3, [sp, #12]
3000044c:	e3530017 	cmp	r3, #23
30000450:	9affffed 	bls	3000040c <hal_all_entry+0x40>
           		acoral_intr_entry(irq);
           		return;
           	 }
    	}
    }
    if(vector>5)
30000454:	e59d3004 	ldr	r3, [sp, #4]
30000458:	e3530005 	cmp	r3, #5
3000045c:	da000002 	ble	3000046c <hal_all_entry+0xa0>
    	vector+=18;
30000460:	e59d3004 	ldr	r3, [sp, #4]
30000464:	e2833012 	add	r3, r3, #18
30000468:	e58d3004 	str	r3, [sp, #4]
    if(vector==4)
3000046c:	e59d3004 	ldr	r3, [sp, #4]
30000470:	e3530004 	cmp	r3, #4
30000474:	1a000001 	bne	30000480 <hal_all_entry+0xb4>
    	acoral_prints("DErr\n");
30000478:	e59f0014 	ldr	r0, [pc, #20]	; 30000494 <hal_all_entry+0xc8>
3000047c:	eb002b92 	bl	3000b2cc <acoral_prints>
    acoral_intr_entry(vector);
30000480:	e59d0004 	ldr	r0, [sp, #4]
30000484:	eb000ee6 	bl	30004024 <acoral_intr_entry>
}
30000488:	e28dd014 	add	sp, sp, #20
3000048c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30000490:	e12fff1e 	bx	lr
30000494:	30045064 	.word	0x30045064

30000498 <hal_intr_unmask>:

static void hal_intr_unmask(acoral_vector vector){
30000498:	e24dd008 	sub	sp, sp, #8
3000049c:	e58d0004 	str	r0, [sp, #4]
          if((vector>3) && (vector<8)){
300004a0:	e59d3004 	ldr	r3, [sp, #4]
300004a4:	e3530003 	cmp	r3, #3
300004a8:	da000010 	ble	300004f0 <hal_intr_unmask+0x58>
300004ac:	e59d3004 	ldr	r3, [sp, #4]
300004b0:	e3530007 	cmp	r3, #7
300004b4:	ca00000d 	bgt	300004f0 <hal_intr_unmask+0x58>
               rEINTMSK &=~(1<<vector);
300004b8:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300004bc:	e28330a4 	add	r3, r3, #164	; 0xa4
300004c0:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300004c4:	e28220a4 	add	r2, r2, #164	; 0xa4
300004c8:	e5921000 	ldr	r1, [r2]
300004cc:	e3a00001 	mov	r0, #1
300004d0:	e59d2004 	ldr	r2, [sp, #4]
300004d4:	e1a02210 	lsl	r2, r0, r2
300004d8:	e1e02002 	mvn	r2, r2
300004dc:	e0012002 	and	r2, r1, r2
300004e0:	e5832000 	str	r2, [r3]
               vector = 4;
300004e4:	e3a03004 	mov	r3, #4
300004e8:	e58d3004 	str	r3, [sp, #4]
    	acoral_prints("DErr\n");
    acoral_intr_entry(vector);
}

static void hal_intr_unmask(acoral_vector vector){
          if((vector>3) && (vector<8)){
300004ec:	ea000019 	b	30000558 <hal_intr_unmask+0xc0>
               rEINTMSK &=~(1<<vector);
               vector = 4;
           }
         else if((vector>7) && (vector<24)){
300004f0:	e59d3004 	ldr	r3, [sp, #4]
300004f4:	e3530007 	cmp	r3, #7
300004f8:	da000010 	ble	30000540 <hal_intr_unmask+0xa8>
300004fc:	e59d3004 	ldr	r3, [sp, #4]
30000500:	e3530017 	cmp	r3, #23
30000504:	ca00000d 	bgt	30000540 <hal_intr_unmask+0xa8>
               rEINTMSK &=~(1<<vector);
30000508:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3000050c:	e28330a4 	add	r3, r3, #164	; 0xa4
30000510:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30000514:	e28220a4 	add	r2, r2, #164	; 0xa4
30000518:	e5921000 	ldr	r1, [r2]
3000051c:	e3a00001 	mov	r0, #1
30000520:	e59d2004 	ldr	r2, [sp, #4]
30000524:	e1a02210 	lsl	r2, r0, r2
30000528:	e1e02002 	mvn	r2, r2
3000052c:	e0012002 	and	r2, r1, r2
30000530:	e5832000 	str	r2, [r3]
               vector = 5;
30000534:	e3a03005 	mov	r3, #5
30000538:	e58d3004 	str	r3, [sp, #4]
static void hal_intr_unmask(acoral_vector vector){
          if((vector>3) && (vector<8)){
               rEINTMSK &=~(1<<vector);
               vector = 4;
           }
         else if((vector>7) && (vector<24)){
3000053c:	ea000005 	b	30000558 <hal_intr_unmask+0xc0>
               rEINTMSK &=~(1<<vector);
               vector = 5;
           }
         else if(vector > 23)
30000540:	e59d3004 	ldr	r3, [sp, #4]
30000544:	e3530017 	cmp	r3, #23
30000548:	da000002 	ble	30000558 <hal_intr_unmask+0xc0>
               vector -= 18; 
3000054c:	e59d3004 	ldr	r3, [sp, #4]
30000550:	e2433012 	sub	r3, r3, #18
30000554:	e58d3004 	str	r3, [sp, #4]

         rINTMSK &=~(1<<vector);			/*开启中断*/
30000558:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3000055c:	e2833008 	add	r3, r3, #8
30000560:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
30000564:	e2822008 	add	r2, r2, #8
30000568:	e5921000 	ldr	r1, [r2]
3000056c:	e3a00001 	mov	r0, #1
30000570:	e59d2004 	ldr	r2, [sp, #4]
30000574:	e1a02210 	lsl	r2, r0, r2
30000578:	e1e02002 	mvn	r2, r2
3000057c:	e0012002 	and	r2, r1, r2
30000580:	e5832000 	str	r2, [r3]
}
30000584:	e28dd008 	add	sp, sp, #8
30000588:	e12fff1e 	bx	lr

3000058c <hal_intr_mask>:

static void hal_intr_mask(acoral_vector vector){
3000058c:	e24dd008 	sub	sp, sp, #8
30000590:	e58d0004 	str	r0, [sp, #4]

         if((vector>3) && (vector<8)){
30000594:	e59d3004 	ldr	r3, [sp, #4]
30000598:	e3530003 	cmp	r3, #3
3000059c:	da00000f 	ble	300005e0 <hal_intr_mask+0x54>
300005a0:	e59d3004 	ldr	r3, [sp, #4]
300005a4:	e3530007 	cmp	r3, #7
300005a8:	ca00000c 	bgt	300005e0 <hal_intr_mask+0x54>
               rEINTMSK |=(1<<vector);
300005ac:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300005b0:	e28330a4 	add	r3, r3, #164	; 0xa4
300005b4:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300005b8:	e28220a4 	add	r2, r2, #164	; 0xa4
300005bc:	e5921000 	ldr	r1, [r2]
300005c0:	e3a00001 	mov	r0, #1
300005c4:	e59d2004 	ldr	r2, [sp, #4]
300005c8:	e1a02210 	lsl	r2, r0, r2
300005cc:	e1812002 	orr	r2, r1, r2
300005d0:	e5832000 	str	r2, [r3]
               vector = 4;
300005d4:	e3a03004 	mov	r3, #4
300005d8:	e58d3004 	str	r3, [sp, #4]
         rINTMSK &=~(1<<vector);			/*开启中断*/
}

static void hal_intr_mask(acoral_vector vector){

         if((vector>3) && (vector<8)){
300005dc:	ea000018 	b	30000644 <hal_intr_mask+0xb8>
               rEINTMSK |=(1<<vector);
               vector = 4;
           }
         else if((vector>7) && (vector<24)){
300005e0:	e59d3004 	ldr	r3, [sp, #4]
300005e4:	e3530007 	cmp	r3, #7
300005e8:	da00000f 	ble	3000062c <hal_intr_mask+0xa0>
300005ec:	e59d3004 	ldr	r3, [sp, #4]
300005f0:	e3530017 	cmp	r3, #23
300005f4:	ca00000c 	bgt	3000062c <hal_intr_mask+0xa0>
               rEINTMSK |=(1<<vector);
300005f8:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300005fc:	e28330a4 	add	r3, r3, #164	; 0xa4
30000600:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30000604:	e28220a4 	add	r2, r2, #164	; 0xa4
30000608:	e5921000 	ldr	r1, [r2]
3000060c:	e3a00001 	mov	r0, #1
30000610:	e59d2004 	ldr	r2, [sp, #4]
30000614:	e1a02210 	lsl	r2, r0, r2
30000618:	e1812002 	orr	r2, r1, r2
3000061c:	e5832000 	str	r2, [r3]
               vector = 5;
30000620:	e3a03005 	mov	r3, #5
30000624:	e58d3004 	str	r3, [sp, #4]

         if((vector>3) && (vector<8)){
               rEINTMSK |=(1<<vector);
               vector = 4;
           }
         else if((vector>7) && (vector<24)){
30000628:	ea000005 	b	30000644 <hal_intr_mask+0xb8>
               rEINTMSK |=(1<<vector);
               vector = 5;
           }
         else if(vector > 23)
3000062c:	e59d3004 	ldr	r3, [sp, #4]
30000630:	e3530017 	cmp	r3, #23
30000634:	da000002 	ble	30000644 <hal_intr_mask+0xb8>
               vector -= 18; 
30000638:	e59d3004 	ldr	r3, [sp, #4]
3000063c:	e2433012 	sub	r3, r3, #18
30000640:	e58d3004 	str	r3, [sp, #4]

         rINTMSK |= (1<<vector);
30000644:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30000648:	e2833008 	add	r3, r3, #8
3000064c:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
30000650:	e2822008 	add	r2, r2, #8
30000654:	e5921000 	ldr	r1, [r2]
30000658:	e3a00001 	mov	r0, #1
3000065c:	e59d2004 	ldr	r2, [sp, #4]
30000660:	e1a02210 	lsl	r2, r0, r2
30000664:	e1812002 	orr	r2, r1, r2
30000668:	e5832000 	str	r2, [r3]
}
3000066c:	e28dd008 	add	sp, sp, #8
30000670:	e12fff1e 	bx	lr

30000674 <hal_intr_ack>:

static void hal_intr_ack(acoral_u32 vector){
30000674:	e24dd008 	sub	sp, sp, #8
30000678:	e58d0004 	str	r0, [sp, #4]

        if((vector>3) && (vector<8)){
3000067c:	e59d3004 	ldr	r3, [sp, #4]
30000680:	e3530003 	cmp	r3, #3
30000684:	9a000010 	bls	300006cc <hal_intr_ack+0x58>
30000688:	e59d3004 	ldr	r3, [sp, #4]
3000068c:	e3530007 	cmp	r3, #7
30000690:	8a00000d 	bhi	300006cc <hal_intr_ack+0x58>
               rEINTPND &= ~(1<<vector);
30000694:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30000698:	e28330a8 	add	r3, r3, #168	; 0xa8
3000069c:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300006a0:	e28220a8 	add	r2, r2, #168	; 0xa8
300006a4:	e5921000 	ldr	r1, [r2]
300006a8:	e59d2004 	ldr	r2, [sp, #4]
300006ac:	e3a00001 	mov	r0, #1
300006b0:	e1a02210 	lsl	r2, r0, r2
300006b4:	e1e02002 	mvn	r2, r2
300006b8:	e0012002 	and	r2, r1, r2
300006bc:	e5832000 	str	r2, [r3]
               vector = 4;
300006c0:	e3a03004 	mov	r3, #4
300006c4:	e58d3004 	str	r3, [sp, #4]
         rINTMSK |= (1<<vector);
}

static void hal_intr_ack(acoral_u32 vector){

        if((vector>3) && (vector<8)){
300006c8:	ea000019 	b	30000734 <hal_intr_ack+0xc0>
               rEINTPND &= ~(1<<vector);
               vector = 4;
           }
        else if((vector>7) && (vector<24)){
300006cc:	e59d3004 	ldr	r3, [sp, #4]
300006d0:	e3530007 	cmp	r3, #7
300006d4:	9a000010 	bls	3000071c <hal_intr_ack+0xa8>
300006d8:	e59d3004 	ldr	r3, [sp, #4]
300006dc:	e3530017 	cmp	r3, #23
300006e0:	8a00000d 	bhi	3000071c <hal_intr_ack+0xa8>
               rEINTPND &= ~(1<<vector);
300006e4:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300006e8:	e28330a8 	add	r3, r3, #168	; 0xa8
300006ec:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300006f0:	e28220a8 	add	r2, r2, #168	; 0xa8
300006f4:	e5921000 	ldr	r1, [r2]
300006f8:	e59d2004 	ldr	r2, [sp, #4]
300006fc:	e3a00001 	mov	r0, #1
30000700:	e1a02210 	lsl	r2, r0, r2
30000704:	e1e02002 	mvn	r2, r2
30000708:	e0012002 	and	r2, r1, r2
3000070c:	e5832000 	str	r2, [r3]
               vector = 5;
30000710:	e3a03005 	mov	r3, #5
30000714:	e58d3004 	str	r3, [sp, #4]

        if((vector>3) && (vector<8)){
               rEINTPND &= ~(1<<vector);
               vector = 4;
           }
        else if((vector>7) && (vector<24)){
30000718:	ea000005 	b	30000734 <hal_intr_ack+0xc0>
               rEINTPND &= ~(1<<vector);
               vector = 5;
           }
        else if(vector > 23)
3000071c:	e59d3004 	ldr	r3, [sp, #4]
30000720:	e3530017 	cmp	r3, #23
30000724:	9a000002 	bls	30000734 <hal_intr_ack+0xc0>
               vector -= 18;
30000728:	e59d3004 	ldr	r3, [sp, #4]
3000072c:	e2433012 	sub	r3, r3, #18
30000730:	e58d3004 	str	r3, [sp, #4]
   
        
        rSRCPND = 1<<vector;
30000734:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30000738:	e59d2004 	ldr	r2, [sp, #4]
3000073c:	e3a01001 	mov	r1, #1
30000740:	e1a02211 	lsl	r2, r1, r2
30000744:	e5832000 	str	r2, [r3]
		rINTPND = 1<<vector;		
30000748:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3000074c:	e2833010 	add	r3, r3, #16
30000750:	e59d2004 	ldr	r2, [sp, #4]
30000754:	e3a01001 	mov	r1, #1
30000758:	e1a02211 	lsl	r2, r1, r2
3000075c:	e5832000 	str	r2, [r3]
}
30000760:	e28dd008 	add	sp, sp, #8
30000764:	e12fff1e 	bx	lr

30000768 <hal_intr_init>:

void hal_intr_init(){
30000768:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000076c:	e24dd00c 	sub	sp, sp, #12
	acoral_u32 i;
    /*配置中断管脚*/

	/*中断触发模式*/
	rEXTINT0 = 0x22222222;		/* EINT[7:0]*/
30000770:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30000774:	e2822088 	add	r2, r2, #136	; 0x88
30000778:	e3a03c22 	mov	r3, #8704	; 0x2200
3000077c:	e2833022 	add	r3, r3, #34	; 0x22
30000780:	e1833803 	orr	r3, r3, r3, lsl #16
30000784:	e5823000 	str	r3, [r2]
    rEXTINT1 = 0x22222222;		/* EINT[15:8]*/
30000788:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3000078c:	e282208c 	add	r2, r2, #140	; 0x8c
30000790:	e3a03c22 	mov	r3, #8704	; 0x2200
30000794:	e2833022 	add	r3, r3, #34	; 0x22
30000798:	e1833803 	orr	r3, r3, r3, lsl #16
3000079c:	e5823000 	str	r3, [r2]
    rEXTINT2 = 0x22222222;		/* EINT[23:16]*/
300007a0:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300007a4:	e2822090 	add	r2, r2, #144	; 0x90
300007a8:	e3a03c22 	mov	r3, #8704	; 0x2200
300007ac:	e2833022 	add	r3, r3, #34	; 0x22
300007b0:	e1833803 	orr	r3, r3, r3, lsl #16
300007b4:	e5823000 	str	r3, [r2]

  	rPRIORITY = 0x00000000;		/* 使用默认的固定的优先级*/
300007b8:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
300007bc:	e283300c 	add	r3, r3, #12
300007c0:	e3a02000 	mov	r2, #0
300007c4:	e5832000 	str	r2, [r3]
	rINTMOD = 0x00000000;		/* 所有中断均为IRQ中断*/
300007c8:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
300007cc:	e2833004 	add	r3, r3, #4
300007d0:	e3a02000 	mov	r2, #0
300007d4:	e5832000 	str	r2, [r3]
    rEINTMSK= 0xffffffff;      /*屏蔽所有外部中断*/
300007d8:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300007dc:	e28330a4 	add	r3, r3, #164	; 0xa4
300007e0:	e3e02000 	mvn	r2, #0
300007e4:	e5832000 	str	r2, [r3]
    rINTMSK = 0xffffffff;       /*屏蔽所有中断*/
300007e8:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
300007ec:	e2833008 	add	r3, r3, #8
300007f0:	e3e02000 	mvn	r2, #0
300007f4:	e5832000 	str	r2, [r3]

	for(i=HAL_INTR_MIN;i<=HAL_INTR_MAX;i++){
300007f8:	e3a03000 	mov	r3, #0
300007fc:	e58d3004 	str	r3, [sp, #4]
30000800:	ea00000e 	b	30000840 <hal_intr_init+0xd8>
		acoral_set_intr_enter(i,hal_intr_ack);
30000804:	e59d0004 	ldr	r0, [sp, #4]
30000808:	e59f1048 	ldr	r1, [pc, #72]	; 30000858 <hal_intr_init+0xf0>
3000080c:	eb000e91 	bl	30004258 <acoral_set_intr_enter>
		acoral_set_intr_exit(i,NULL);
30000810:	e59d0004 	ldr	r0, [sp, #4]
30000814:	e3a01000 	mov	r1, #0
30000818:	eb000ea1 	bl	300042a4 <acoral_set_intr_exit>
		acoral_set_intr_mask(i,hal_intr_mask);
3000081c:	e59d0004 	ldr	r0, [sp, #4]
30000820:	e59f1034 	ldr	r1, [pc, #52]	; 3000085c <hal_intr_init+0xf4>
30000824:	eb000eb1 	bl	300042f0 <acoral_set_intr_mask>
		acoral_set_intr_unmask(i,hal_intr_unmask);
30000828:	e59d0004 	ldr	r0, [sp, #4]
3000082c:	e59f102c 	ldr	r1, [pc, #44]	; 30000860 <hal_intr_init+0xf8>
30000830:	eb000ec1 	bl	3000433c <acoral_set_intr_unmask>
  	rPRIORITY = 0x00000000;		/* 使用默认的固定的优先级*/
	rINTMOD = 0x00000000;		/* 所有中断均为IRQ中断*/
    rEINTMSK= 0xffffffff;      /*屏蔽所有外部中断*/
    rINTMSK = 0xffffffff;       /*屏蔽所有中断*/

	for(i=HAL_INTR_MIN;i<=HAL_INTR_MAX;i++){
30000834:	e59d3004 	ldr	r3, [sp, #4]
30000838:	e2833001 	add	r3, r3, #1
3000083c:	e58d3004 	str	r3, [sp, #4]
30000840:	e59d3004 	ldr	r3, [sp, #4]
30000844:	e3530031 	cmp	r3, #49	; 0x31
30000848:	9affffed 	bls	30000804 <hal_intr_init+0x9c>
		acoral_set_intr_enter(i,hal_intr_ack);
		acoral_set_intr_exit(i,NULL);
		acoral_set_intr_mask(i,hal_intr_mask);
		acoral_set_intr_unmask(i,hal_intr_unmask);
	}
}
3000084c:	e28dd00c 	add	sp, sp, #12
30000850:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30000854:	e12fff1e 	bx	lr
30000858:	30000674 	.word	0x30000674
3000085c:	3000058c 	.word	0x3000058c
30000860:	30000498 	.word	0x30000498

30000864 <hal_ticks_init>:
/****************************************
*****这个函数的作用是初始化滴答时钟数据**
****************相关数据*****************
*****************************************/
void hal_ticks_init(){
  	rTCON = rTCON & (~0xf) ;	/* clear manual update bit, stop Timer0*/
30000864:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30000868:	e2833008 	add	r3, r3, #8
3000086c:	e3a02451 	mov	r2, #1358954496	; 0x51000000
30000870:	e2822008 	add	r2, r2, #8
30000874:	e5922000 	ldr	r2, [r2]
30000878:	e3c2200f 	bic	r2, r2, #15
3000087c:	e5832000 	str	r2, [r3]
    rTCFG0 &= 0xFFFF00;
30000880:	e3a02451 	mov	r2, #1358954496	; 0x51000000
30000884:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30000888:	e5933000 	ldr	r3, [r3]
3000088c:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
30000890:	e3c330ff 	bic	r3, r3, #255	; 0xff
30000894:	e5823000 	str	r3, [r2]
 	rTCFG0 |= 0xF9;				/* prescaler等于249*/
30000898:	e3a03451 	mov	r3, #1358954496	; 0x51000000
3000089c:	e3a02451 	mov	r2, #1358954496	; 0x51000000
300008a0:	e5922000 	ldr	r2, [r2]
300008a4:	e38220f9 	orr	r2, r2, #249	; 0xf9
300008a8:	e5832000 	str	r2, [r3]
 	rTCFG1 &= ~0x0000F;   
300008ac:	e3a03451 	mov	r3, #1358954496	; 0x51000000
300008b0:	e2833004 	add	r3, r3, #4
300008b4:	e3a02451 	mov	r2, #1358954496	; 0x51000000
300008b8:	e2822004 	add	r2, r2, #4
300008bc:	e5922000 	ldr	r2, [r2]
300008c0:	e3c2200f 	bic	r2, r2, #15
300008c4:	e5832000 	str	r2, [r3]
 	rTCFG1 |= 0x2;			   /*divider等于8，则设置定时器4的时钟频率为25kHz*/
300008c8:	e3a03451 	mov	r3, #1358954496	; 0x51000000
300008cc:	e2833004 	add	r3, r3, #4
300008d0:	e3a02451 	mov	r2, #1358954496	; 0x51000000
300008d4:	e2822004 	add	r2, r2, #4
300008d8:	e5922000 	ldr	r2, [r2]
300008dc:	e3822002 	orr	r2, r2, #2
300008e0:	e5832000 	str	r2, [r3]

   	rTCNTB0 = PCLK /(8*(249+1)*ACORAL_TICKS_PER_SEC);
300008e4:	e3a03451 	mov	r3, #1358954496	; 0x51000000
300008e8:	e283300c 	add	r3, r3, #12
300008ec:	e3a020fa 	mov	r2, #250	; 0xfa
300008f0:	e5832000 	str	r2, [r3]
   	rTCON = rTCON & (~0xf) |0x02;              	/* updata*/
300008f4:	e3a03451 	mov	r3, #1358954496	; 0x51000000
300008f8:	e2833008 	add	r3, r3, #8
300008fc:	e3a02451 	mov	r2, #1358954496	; 0x51000000
30000900:	e2822008 	add	r2, r2, #8
30000904:	e5922000 	ldr	r2, [r2]
30000908:	e3c2200f 	bic	r2, r2, #15
3000090c:	e3822002 	orr	r2, r2, #2
30000910:	e5832000 	str	r2, [r3]
	rTCON = rTCON & (~0xf) |0x09; 			/* star*/
30000914:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30000918:	e2833008 	add	r3, r3, #8
3000091c:	e3a02451 	mov	r2, #1358954496	; 0x51000000
30000920:	e2822008 	add	r2, r2, #8
30000924:	e5922000 	ldr	r2, [r2]
30000928:	e3c2200f 	bic	r2, r2, #15
3000092c:	e3822009 	orr	r2, r2, #9
30000930:	e5832000 	str	r2, [r3]
}
30000934:	e12fff1e 	bx	lr

30000938 <hal_ticks_delay>:

acoral_u32 hal_ticks_delay(){
30000938:	e24dd008 	sub	sp, sp, #8
	acoral_u32 initial;
	acoral_u32 current;
	initial=rTCNTB0;
3000093c:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30000940:	e283300c 	add	r3, r3, #12
30000944:	e5933000 	ldr	r3, [r3]
30000948:	e58d3000 	str	r3, [sp]
	current=rTCNTO0;
3000094c:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30000950:	e2833014 	add	r3, r3, #20
30000954:	e5933000 	ldr	r3, [r3]
30000958:	e58d3004 	str	r3, [sp, #4]
	return (initial-current);
3000095c:	e59d2000 	ldr	r2, [sp]
30000960:	e59d3004 	ldr	r3, [sp, #4]
30000964:	e0633002 	rsb	r3, r3, r2
}
30000968:	e1a00003 	mov	r0, r3
3000096c:	e28dd008 	add	sp, sp, #8
30000970:	e12fff1e 	bx	lr

30000974 <hal_mem_init>:
#include"hal_2440_cfg.h"
extern acoral_u32 MMU_base[];
extern acoral_u32 __ENTRY[];
static void hal_mmu_init(void);

void hal_mem_init(){
30000974:	e92d4008 	push	{r3, lr}
  	hal_mmu_init();
30000978:	eb000022 	bl	30000a08 <hal_mmu_init>
}
3000097c:	e8bd4008 	pop	{r3, lr}
30000980:	e12fff1e 	bx	lr

30000984 <flush_cache>:

void flush_cache(){
30000984:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30000988:	e24dd00c 	sub	sp, sp, #12
    acoral_32 i,j;
    MMU_DisableDCache();
3000098c:	eb0002c6 	bl	300014ac <MMU_DisableDCache>
    MMU_DisableICache();
30000990:	eb0002bd 	bl	3000148c <MMU_DisableICache>
    /*If write-back is used,the DCache should be cleared.*/
    for(i=0;i<64;i++)
30000994:	e3a03000 	mov	r3, #0
30000998:	e58d3000 	str	r3, [sp]
3000099c:	ea000012 	b	300009ec <flush_cache+0x68>
    	for(j=0;j<8;j++)
300009a0:	e3a03000 	mov	r3, #0
300009a4:	e58d3004 	str	r3, [sp, #4]
300009a8:	ea000009 	b	300009d4 <flush_cache+0x50>
    	    MMU_CleanInvalidateDCacheIndex((i<<26)|(j<<5));
300009ac:	e59d3000 	ldr	r3, [sp]
300009b0:	e1a02d03 	lsl	r2, r3, #26
300009b4:	e59d3004 	ldr	r3, [sp, #4]
300009b8:	e1a03283 	lsl	r3, r3, #5
300009bc:	e1823003 	orr	r3, r2, r3
300009c0:	e1a00003 	mov	r0, r3
300009c4:	eb0002e2 	bl	30001554 <MMU_CleanInvalidateDCacheIndex>
    acoral_32 i,j;
    MMU_DisableDCache();
    MMU_DisableICache();
    /*If write-back is used,the DCache should be cleared.*/
    for(i=0;i<64;i++)
    	for(j=0;j<8;j++)
300009c8:	e59d3004 	ldr	r3, [sp, #4]
300009cc:	e2833001 	add	r3, r3, #1
300009d0:	e58d3004 	str	r3, [sp, #4]
300009d4:	e59d3004 	ldr	r3, [sp, #4]
300009d8:	e3530007 	cmp	r3, #7
300009dc:	dafffff2 	ble	300009ac <flush_cache+0x28>
void flush_cache(){
    acoral_32 i,j;
    MMU_DisableDCache();
    MMU_DisableICache();
    /*If write-back is used,the DCache should be cleared.*/
    for(i=0;i<64;i++)
300009e0:	e59d3000 	ldr	r3, [sp]
300009e4:	e2833001 	add	r3, r3, #1
300009e8:	e58d3000 	str	r3, [sp]
300009ec:	e59d3000 	ldr	r3, [sp]
300009f0:	e353003f 	cmp	r3, #63	; 0x3f
300009f4:	daffffe9 	ble	300009a0 <flush_cache+0x1c>
    	for(j=0;j<8;j++)
    	    MMU_CleanInvalidateDCacheIndex((i<<26)|(j<<5));
    MMU_InvalidateICache();
300009f8:	eb0002c5 	bl	30001514 <MMU_InvalidateICache>

}
300009fc:	e28dd00c 	add	sp, sp, #12
30000a00:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30000a04:	e12fff1e 	bx	lr

30000a08 <hal_mmu_init>:
static void hal_mmu_init(void)
{
30000a08:	e92d4008 	push	{r3, lr}
    /*The current stack and code area can't be re-mapped in this routine.*/
    /*If you want memory map mapped freely, your own sophiscated MMU*/
    /*initialization code is needed.*/
    /*===================================================================*/

    flush_cache(); 
30000a0c:	ebffffdc 	bl	30000984 <flush_cache>
    MMU_DisableMMU();
30000a10:	eb0002b5 	bl	300014ec <MMU_DisableMMU>
    MMU_InvalidateTLB();
30000a14:	eb0002d2 	bl	30001564 <MMU_InvalidateTLB>
    /*hal_mmu_setmtt(acoral_32 vaddrStart,acoral_32 vaddrEnd,acoral_32 paddrStart,acoral_32 attr)*/
    /*hal_mmu_setmtt(0x00000000,0x07f00000,0x00000000,RW_CNB);  bank0*/
    hal_mmu_setmtt(0x00000000,0x03f00000,(acoral_32)__ENTRY,RW_CB);  /*bank0*/
30000a18:	e59f31d8 	ldr	r3, [pc, #472]	; 30000bf8 <hal_mmu_init+0x1f0>
30000a1c:	e3a00000 	mov	r0, #0
30000a20:	e3a0163f 	mov	r1, #66060288	; 0x3f00000
30000a24:	e1a02003 	mov	r2, r3
30000a28:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000a2c:	e283300e 	add	r3, r3, #14
30000a30:	eb000073 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x04000000,0x07f00000,0,RW_NCNB);  			/*bank0*/
30000a34:	e3a00301 	mov	r0, #67108864	; 0x4000000
30000a38:	e3a0167f 	mov	r1, #133169152	; 0x7f00000
30000a3c:	e3a02000 	mov	r2, #0
30000a40:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000a44:	e2833002 	add	r3, r3, #2
30000a48:	eb00006d 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x08000000,0x0ff00000,0x08000000,RW_CNB);  /*bank1*/
30000a4c:	e3a00302 	mov	r0, #134217728	; 0x8000000
30000a50:	e3a016ff 	mov	r1, #267386880	; 0xff00000
30000a54:	e3a02302 	mov	r2, #134217728	; 0x8000000
30000a58:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000a5c:	e283300a 	add	r3, r3, #10
30000a60:	eb000067 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x10000000,0x17f00000,0x10000000,RW_NCNB); /*bank2*/
30000a64:	e3a00201 	mov	r0, #268435456	; 0x10000000
30000a68:	e3a0155f 	mov	r1, #398458880	; 0x17c00000
30000a6c:	e2811603 	add	r1, r1, #3145728	; 0x300000
30000a70:	e3a02201 	mov	r2, #268435456	; 0x10000000
30000a74:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000a78:	e2833002 	add	r3, r3, #2
30000a7c:	eb000060 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x18000000,0x1ff00000,0x18000000,RW_NCNB); /*bank3*/
30000a80:	e3a00306 	mov	r0, #402653184	; 0x18000000
30000a84:	e3a0157f 	mov	r1, #532676608	; 0x1fc00000
30000a88:	e2811603 	add	r1, r1, #3145728	; 0x300000
30000a8c:	e3a02306 	mov	r2, #402653184	; 0x18000000
30000a90:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000a94:	e2833002 	add	r3, r3, #2
30000a98:	eb000059 	bl	30000c04 <hal_mmu_setmtt>
    /*hal_mmu_setmtt(0x20000000,0x27f00000,0x20000000,RW_CB); bank4*/
    hal_mmu_setmtt(0x20000000,0x27f00000,0x20000000,RW_NCNB); /*bank4 for STRATA Flash*/
30000a9c:	e3a00202 	mov	r0, #536870912	; 0x20000000
30000aa0:	e3a0159f 	mov	r1, #666894336	; 0x27c00000
30000aa4:	e2811603 	add	r1, r1, #3145728	; 0x300000
30000aa8:	e3a02202 	mov	r2, #536870912	; 0x20000000
30000aac:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000ab0:	e2833002 	add	r3, r3, #2
30000ab4:	eb000052 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x28000000,0x2ff00000,0x28000000,RW_NCNB); /*bank5*/
30000ab8:	e3a0030a 	mov	r0, #671088640	; 0x28000000
30000abc:	e3a015bf 	mov	r1, #801112064	; 0x2fc00000
30000ac0:	e2811603 	add	r1, r1, #3145728	; 0x300000
30000ac4:	e3a0230a 	mov	r2, #671088640	; 0x28000000
30000ac8:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000acc:	e2833002 	add	r3, r3, #2
30000ad0:	eb00004b 	bl	30000c04 <hal_mmu_setmtt>
    /*30f00000->30100000, 31000000->30200000*/
    hal_mmu_setmtt(0x30000000,0x30100000,0x30000000,RW_CNB);	  /*bank6-1*/
30000ad4:	e3a00203 	mov	r0, #805306368	; 0x30000000
30000ad8:	e3a01203 	mov	r1, #805306368	; 0x30000000
30000adc:	e2811601 	add	r1, r1, #1048576	; 0x100000
30000ae0:	e3a02203 	mov	r2, #805306368	; 0x30000000
30000ae4:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000ae8:	e283300a 	add	r3, r3, #10
30000aec:	eb000044 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x30200000,0x33e00000,0x30200000,RW_CNB); /*bank6-2*/
30000af0:	e3a00203 	mov	r0, #805306368	; 0x30000000
30000af4:	e2800602 	add	r0, r0, #2097152	; 0x200000
30000af8:	e3a015cf 	mov	r1, #868220928	; 0x33c00000
30000afc:	e2811602 	add	r1, r1, #2097152	; 0x200000
30000b00:	e3a02203 	mov	r2, #805306368	; 0x30000000
30000b04:	e2822602 	add	r2, r2, #2097152	; 0x200000
30000b08:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000b0c:	e283300a 	add	r3, r3, #10
30000b10:	eb00003b 	bl	30000c04 <hal_mmu_setmtt>
    /**/
    hal_mmu_setmtt(0x33f00000,0x33f00000,0x33f00000,RW_NCNB);   /*bank6-3*/
30000b14:	e3a005cf 	mov	r0, #868220928	; 0x33c00000
30000b18:	e2800603 	add	r0, r0, #3145728	; 0x300000
30000b1c:	e3a015cf 	mov	r1, #868220928	; 0x33c00000
30000b20:	e2811603 	add	r1, r1, #3145728	; 0x300000
30000b24:	e3a025cf 	mov	r2, #868220928	; 0x33c00000
30000b28:	e2822603 	add	r2, r2, #3145728	; 0x300000
30000b2c:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000b30:	e2833002 	add	r3, r3, #2
30000b34:	eb000032 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x38000000,0x3ff00000,0x38000000,RW_NCNB); /*bank7*/
30000b38:	e3a0030e 	mov	r0, #939524096	; 0x38000000
30000b3c:	e3a015ff 	mov	r1, #1069547520	; 0x3fc00000
30000b40:	e2811603 	add	r1, r1, #3145728	; 0x300000
30000b44:	e3a0230e 	mov	r2, #939524096	; 0x38000000
30000b48:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000b4c:	e2833002 	add	r3, r3, #2
30000b50:	eb00002b 	bl	30000c04 <hal_mmu_setmtt>

    hal_mmu_setmtt(0x40000000,0x47f00000,0x40000000,RW_NCNB); /*SFR*/
30000b54:	e3a00101 	mov	r0, #1073741824	; 0x40000000
30000b58:	e3a01447 	mov	r1, #1191182336	; 0x47000000
30000b5c:	e281160f 	add	r1, r1, #15728640	; 0xf00000
30000b60:	e3a02101 	mov	r2, #1073741824	; 0x40000000
30000b64:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000b68:	e2833002 	add	r3, r3, #2
30000b6c:	eb000024 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x48000000,0x5af00000,0x48000000,RW_NCNB); /*SFR*/
30000b70:	e3a00312 	mov	r0, #1207959552	; 0x48000000
30000b74:	e3a0145a 	mov	r1, #1509949440	; 0x5a000000
30000b78:	e281160f 	add	r1, r1, #15728640	; 0xf00000
30000b7c:	e3a02312 	mov	r2, #1207959552	; 0x48000000
30000b80:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000b84:	e2833002 	add	r3, r3, #2
30000b88:	eb00001d 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x5b000000,0x5b000000,0x5b000000,RW_NCNB); /*SFR*/
30000b8c:	e3a0045b 	mov	r0, #1526726656	; 0x5b000000
30000b90:	e3a0145b 	mov	r1, #1526726656	; 0x5b000000
30000b94:	e3a0245b 	mov	r2, #1526726656	; 0x5b000000
30000b98:	e3a03ec1 	mov	r3, #3088	; 0xc10
30000b9c:	e2833002 	add	r3, r3, #2
30000ba0:	eb000017 	bl	30000c04 <hal_mmu_setmtt>
    hal_mmu_setmtt(0x5b100000,0xfff00000,0x5b100000,RW_FAULT);/*not used*/
30000ba4:	e3a0045b 	mov	r0, #1526726656	; 0x5b000000
30000ba8:	e2800601 	add	r0, r0, #1048576	; 0x100000
30000bac:	e3a01102 	mov	r1, #-2147483648	; 0x80000000
30000bb0:	e1a015c1 	asr	r1, r1, #11
30000bb4:	e3a0245b 	mov	r2, #1526726656	; 0x5b000000
30000bb8:	e2822601 	add	r2, r2, #1048576	; 0x100000
30000bbc:	e3a03ec3 	mov	r3, #3120	; 0xc30
30000bc0:	e2833002 	add	r3, r3, #2
30000bc4:	eb00000e 	bl	30000c04 <hal_mmu_setmtt>


    MMU_SetTTBase(&MMU_base);
30000bc8:	e59f002c 	ldr	r0, [pc, #44]	; 30000bfc <hal_mmu_init+0x1f4>
30000bcc:	eb00024a 	bl	300014fc <MMU_SetTTBase>
    MMU_SetDomain(0x55555550|DOMAIN1_ATTR|DOMAIN0_ATTR);
30000bd0:	e59f0028 	ldr	r0, [pc, #40]	; 30000c00 <hal_mmu_init+0x1f8>
30000bd4:	eb00024a 	bl	30001504 <MMU_SetDomain>
    	/*DOMAIN1: no_access, DOMAIN0,2~15=client(AP is checked)*/
    MMU_SetProcessId(0x0);
30000bd8:	e3a00000 	mov	r0, #0
30000bdc:	eb000268 	bl	30001584 <MMU_SetProcessId>
    MMU_EnableAlignFault();
30000be0:	eb000235 	bl	300014bc <MMU_EnableAlignFault>
    MMU_EnableMMU();
30000be4:	eb00023c 	bl	300014dc <MMU_EnableMMU>
    MMU_EnableICache();
30000be8:	eb000223 	bl	3000147c <MMU_EnableICache>
    MMU_EnableDCache(); /*DCache should be turned on after MMU is turned on.*/
30000bec:	eb00022a 	bl	3000149c <MMU_EnableDCache>
}
30000bf0:	e8bd4008 	pop	{r3, lr}
30000bf4:	e12fff1e 	bx	lr
30000bf8:	30000000 	.word	0x30000000
30000bfc:	33f00000 	.word	0x33f00000
30000c00:	55555551 	.word	0x55555551

30000c04 <hal_mmu_setmtt>:


void hal_mmu_setmtt(acoral_32 vaddrStart,acoral_32 vaddrEnd,acoral_32 paddrStart,acoral_32 attr)
{
30000c04:	e24dd020 	sub	sp, sp, #32
30000c08:	e58d000c 	str	r0, [sp, #12]
30000c0c:	e58d1008 	str	r1, [sp, #8]
30000c10:	e58d2004 	str	r2, [sp, #4]
30000c14:	e58d3000 	str	r3, [sp]
    volatile acoral_u32 *pTT;
    volatile acoral_32 i,nSec;
    pTT=MMU_base+(vaddrStart>>20);
30000c18:	e59f208c 	ldr	r2, [pc, #140]	; 30000cac <hal_mmu_setmtt+0xa8>
30000c1c:	e59d300c 	ldr	r3, [sp, #12]
30000c20:	e1a03a43 	asr	r3, r3, #20
30000c24:	e1a03103 	lsl	r3, r3, #2
30000c28:	e0823003 	add	r3, r2, r3
30000c2c:	e58d301c 	str	r3, [sp, #28]
    nSec=(vaddrEnd>>20)-(vaddrStart>>20);
30000c30:	e59d3008 	ldr	r3, [sp, #8]
30000c34:	e1a02a43 	asr	r2, r3, #20
30000c38:	e59d300c 	ldr	r3, [sp, #12]
30000c3c:	e1a03a43 	asr	r3, r3, #20
30000c40:	e0633002 	rsb	r3, r3, r2
30000c44:	e58d3014 	str	r3, [sp, #20]
    for(i=0;i<=nSec;i++)*pTT++=attr |(((paddrStart>>20)+i)<<20);
30000c48:	e3a03000 	mov	r3, #0
30000c4c:	e58d3018 	str	r3, [sp, #24]
30000c50:	ea00000f 	b	30000c94 <hal_mmu_setmtt+0x90>
30000c54:	e59d3004 	ldr	r3, [sp, #4]
30000c58:	e1a02a43 	asr	r2, r3, #20
30000c5c:	e59d3018 	ldr	r3, [sp, #24]
30000c60:	e0823003 	add	r3, r2, r3
30000c64:	e1a02a03 	lsl	r2, r3, #20
30000c68:	e59d3000 	ldr	r3, [sp]
30000c6c:	e1823003 	orr	r3, r2, r3
30000c70:	e1a02003 	mov	r2, r3
30000c74:	e59d301c 	ldr	r3, [sp, #28]
30000c78:	e5832000 	str	r2, [r3]
30000c7c:	e59d301c 	ldr	r3, [sp, #28]
30000c80:	e2833004 	add	r3, r3, #4
30000c84:	e58d301c 	str	r3, [sp, #28]
30000c88:	e59d3018 	ldr	r3, [sp, #24]
30000c8c:	e2833001 	add	r3, r3, #1
30000c90:	e58d3018 	str	r3, [sp, #24]
30000c94:	e59d2018 	ldr	r2, [sp, #24]
30000c98:	e59d3014 	ldr	r3, [sp, #20]
30000c9c:	e1520003 	cmp	r2, r3
30000ca0:	daffffeb 	ble	30000c54 <hal_mmu_setmtt+0x50>
}
30000ca4:	e28dd020 	add	sp, sp, #32
30000ca8:	e12fff1e 	bx	lr
30000cac:	33f00000 	.word	0x33f00000

30000cb0 <nand_wait>:

void nand_init(void);
int nand_read(unsigned char *buf, unsigned long start_addr, int size);

static void nand_wait(void)
{
30000cb0:	e24dd008 	sub	sp, sp, #8
  int i;
  while (!(NFSTAT & NFSTAT_BUSY))
30000cb4:	ea000008 	b	30000cdc <nand_wait+0x2c>
   for (i=0; i<10; i++);
30000cb8:	e3a03000 	mov	r3, #0
30000cbc:	e58d3004 	str	r3, [sp, #4]
30000cc0:	ea000002 	b	30000cd0 <nand_wait+0x20>
30000cc4:	e59d3004 	ldr	r3, [sp, #4]
30000cc8:	e2833001 	add	r3, r3, #1
30000ccc:	e58d3004 	str	r3, [sp, #4]
30000cd0:	e59d3004 	ldr	r3, [sp, #4]
30000cd4:	e3530009 	cmp	r3, #9
30000cd8:	dafffff9 	ble	30000cc4 <nand_wait+0x14>
int nand_read(unsigned char *buf, unsigned long start_addr, int size);

static void nand_wait(void)
{
  int i;
  while (!(NFSTAT & NFSTAT_BUSY))
30000cdc:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000ce0:	e2833020 	add	r3, r3, #32
30000ce4:	e5d33000 	ldrb	r3, [r3]
30000ce8:	e20330ff 	and	r3, r3, #255	; 0xff
30000cec:	e2033004 	and	r3, r3, #4
30000cf0:	e3530000 	cmp	r3, #0
30000cf4:	0affffef 	beq	30000cb8 <nand_wait+0x8>
   for (i=0; i<10; i++);
}
30000cf8:	e28dd008 	add	sp, sp, #8
30000cfc:	e12fff1e 	bx	lr

30000d00 <nand_reset>:


static void nand_reset(){
30000d00:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30000d04:	e24dd00c 	sub	sp, sp, #12
   int i;

   nand_select();
30000d08:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000d0c:	e2833004 	add	r3, r3, #4
30000d10:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
30000d14:	e2822004 	add	r2, r2, #4
30000d18:	e5922000 	ldr	r2, [r2]
30000d1c:	e3c22002 	bic	r2, r2, #2
30000d20:	e5832000 	str	r2, [r3]
   NFCMD=NAND_CMD_RESET;
30000d24:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000d28:	e2833008 	add	r3, r3, #8
30000d2c:	e3e02000 	mvn	r2, #0
30000d30:	e5c32000 	strb	r2, [r3]
   for(i=0;i<10;i++);  
30000d34:	e3a03000 	mov	r3, #0
30000d38:	e58d3004 	str	r3, [sp, #4]
30000d3c:	ea000002 	b	30000d4c <nand_reset+0x4c>
30000d40:	e59d3004 	ldr	r3, [sp, #4]
30000d44:	e2833001 	add	r3, r3, #1
30000d48:	e58d3004 	str	r3, [sp, #4]
30000d4c:	e59d3004 	ldr	r3, [sp, #4]
30000d50:	e3530009 	cmp	r3, #9
30000d54:	dafffff9 	ble	30000d40 <nand_reset+0x40>
   nand_wait();  
30000d58:	ebffffd4 	bl	30000cb0 <nand_wait>
   nand_deselect();
30000d5c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000d60:	e2833004 	add	r3, r3, #4
30000d64:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
30000d68:	e2822004 	add	r2, r2, #4
30000d6c:	e5922000 	ldr	r2, [r2]
30000d70:	e3822002 	orr	r2, r2, #2
30000d74:	e5832000 	str	r2, [r3]
}
30000d78:	e28dd00c 	add	sp, sp, #12
30000d7c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30000d80:	e12fff1e 	bx	lr

30000d84 <nand_init>:


void nand_init(void){
30000d84:	e92d4008 	push	{r3, lr}
   

    NFCONF=(7<<12)|(7<<8)|(7<<4)|(0<<0);
30000d88:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
30000d8c:	e3a03c77 	mov	r3, #30464	; 0x7700
30000d90:	e2833070 	add	r3, r3, #112	; 0x70
30000d94:	e5823000 	str	r3, [r2]
    NFCONT=(1<<4)|(0<<1)|(1<<0);
30000d98:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000d9c:	e2833004 	add	r3, r3, #4
30000da0:	e3a02011 	mov	r2, #17
30000da4:	e5832000 	str	r2, [r3]
    
    nand_reset();
30000da8:	ebffffd4 	bl	30000d00 <nand_reset>
}
30000dac:	e8bd4008 	pop	{r3, lr}
30000db0:	e12fff1e 	bx	lr

30000db4 <is_bad_block>:
    int bad_block_offset;
};


static int is_bad_block(struct boot_nand_t * nand, unsigned long i)
{
30000db4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30000db8:	e24dd014 	sub	sp, sp, #20
30000dbc:	e58d0004 	str	r0, [sp, #4]
30000dc0:	e58d1000 	str	r1, [sp]
	unsigned char data;
	unsigned long page_num;

	nand_clear_RnB();
30000dc4:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000dc8:	e2833020 	add	r3, r3, #32
30000dcc:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
30000dd0:	e2822020 	add	r2, r2, #32
30000dd4:	e5d22000 	ldrb	r2, [r2]
30000dd8:	e20220ff 	and	r2, r2, #255	; 0xff
30000ddc:	e3822004 	orr	r2, r2, #4
30000de0:	e20220ff 	and	r2, r2, #255	; 0xff
30000de4:	e5c32000 	strb	r2, [r3]
	if (nand->page_size == 512) {
30000de8:	e59d3004 	ldr	r3, [sp, #4]
30000dec:	e5933000 	ldr	r3, [r3]
30000df0:	e3530c02 	cmp	r3, #512	; 0x200
30000df4:	1a00001d 	bne	30000e70 <is_bad_block+0xbc>
		NFCMD = NAND_CMD_READOOB; /* 0x50 */
30000df8:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000dfc:	e2833008 	add	r3, r3, #8
30000e00:	e3a02050 	mov	r2, #80	; 0x50
30000e04:	e5c32000 	strb	r2, [r3]
		NFADDR = nand->bad_block_offset & 0xf;
30000e08:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000e0c:	e283300c 	add	r3, r3, #12
30000e10:	e59d2004 	ldr	r2, [sp, #4]
30000e14:	e5922008 	ldr	r2, [r2, #8]
30000e18:	e20220ff 	and	r2, r2, #255	; 0xff
30000e1c:	e202200f 	and	r2, r2, #15
30000e20:	e5c32000 	strb	r2, [r3]
		NFADDR = (i >> 9) & 0xff;
30000e24:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000e28:	e283300c 	add	r3, r3, #12
30000e2c:	e59d2000 	ldr	r2, [sp]
30000e30:	e1a024a2 	lsr	r2, r2, #9
30000e34:	e20220ff 	and	r2, r2, #255	; 0xff
30000e38:	e5c32000 	strb	r2, [r3]
		NFADDR = (i >> 17) & 0xff;
30000e3c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000e40:	e283300c 	add	r3, r3, #12
30000e44:	e59d2000 	ldr	r2, [sp]
30000e48:	e1a028a2 	lsr	r2, r2, #17
30000e4c:	e20220ff 	and	r2, r2, #255	; 0xff
30000e50:	e5c32000 	strb	r2, [r3]
		NFADDR = (i >> 25) & 0xff;
30000e54:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000e58:	e283300c 	add	r3, r3, #12
30000e5c:	e59d2000 	ldr	r2, [sp]
30000e60:	e1a02ca2 	lsr	r2, r2, #25
30000e64:	e20220ff 	and	r2, r2, #255	; 0xff
30000e68:	e5c32000 	strb	r2, [r3]
30000e6c:	ea00002f 	b	30000f30 <is_bad_block+0x17c>
	} else if (nand->page_size == 2048) {
30000e70:	e59d3004 	ldr	r3, [sp, #4]
30000e74:	e5933000 	ldr	r3, [r3]
30000e78:	e3530b02 	cmp	r3, #2048	; 0x800
30000e7c:	1a000029 	bne	30000f28 <is_bad_block+0x174>
		page_num = i >> 11; /* addr / 2048 */
30000e80:	e59d3000 	ldr	r3, [sp]
30000e84:	e1a035a3 	lsr	r3, r3, #11
30000e88:	e58d300c 	str	r3, [sp, #12]
		NFCMD = NAND_CMD_READ0;
30000e8c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000e90:	e2833008 	add	r3, r3, #8
30000e94:	e3a02000 	mov	r2, #0
30000e98:	e5c32000 	strb	r2, [r3]
		NFADDR = nand->bad_block_offset & 0xff;
30000e9c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000ea0:	e283300c 	add	r3, r3, #12
30000ea4:	e59d2004 	ldr	r2, [sp, #4]
30000ea8:	e5922008 	ldr	r2, [r2, #8]
30000eac:	e20220ff 	and	r2, r2, #255	; 0xff
30000eb0:	e5c32000 	strb	r2, [r3]
		NFADDR = (nand->bad_block_offset >> 8) & 0xff;
30000eb4:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000eb8:	e283300c 	add	r3, r3, #12
30000ebc:	e59d2004 	ldr	r2, [sp, #4]
30000ec0:	e5922008 	ldr	r2, [r2, #8]
30000ec4:	e1a02442 	asr	r2, r2, #8
30000ec8:	e20220ff 	and	r2, r2, #255	; 0xff
30000ecc:	e5c32000 	strb	r2, [r3]
		NFADDR = page_num & 0xff;
30000ed0:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000ed4:	e283300c 	add	r3, r3, #12
30000ed8:	e59d200c 	ldr	r2, [sp, #12]
30000edc:	e20220ff 	and	r2, r2, #255	; 0xff
30000ee0:	e5c32000 	strb	r2, [r3]
		NFADDR = (page_num >> 8) & 0xff;
30000ee4:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000ee8:	e283300c 	add	r3, r3, #12
30000eec:	e59d200c 	ldr	r2, [sp, #12]
30000ef0:	e1a02422 	lsr	r2, r2, #8
30000ef4:	e20220ff 	and	r2, r2, #255	; 0xff
30000ef8:	e5c32000 	strb	r2, [r3]
		NFADDR = (page_num >> 16) & 0xff;
30000efc:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000f00:	e283300c 	add	r3, r3, #12
30000f04:	e59d200c 	ldr	r2, [sp, #12]
30000f08:	e1a02822 	lsr	r2, r2, #16
30000f0c:	e20220ff 	and	r2, r2, #255	; 0xff
30000f10:	e5c32000 	strb	r2, [r3]
		NFCMD = NAND_CMD_READSTART;
30000f14:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000f18:	e2833008 	add	r3, r3, #8
30000f1c:	e3a02030 	mov	r2, #48	; 0x30
30000f20:	e5c32000 	strb	r2, [r3]
30000f24:	ea000001 	b	30000f30 <is_bad_block+0x17c>
	} else {
		return -1;
30000f28:	e3e03000 	mvn	r3, #0
30000f2c:	ea00000a 	b	30000f5c <is_bad_block+0x1a8>
	}
	nand_wait();
30000f30:	ebffff5e 	bl	30000cb0 <nand_wait>
	data = (NFDATA & 0xff);
30000f34:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000f38:	e2833010 	add	r3, r3, #16
30000f3c:	e5d33000 	ldrb	r3, [r3]
30000f40:	e5cd300b 	strb	r3, [sp, #11]
	if (data != 0xff)
30000f44:	e5dd300b 	ldrb	r3, [sp, #11]
30000f48:	e35300ff 	cmp	r3, #255	; 0xff
30000f4c:	0a000001 	beq	30000f58 <is_bad_block+0x1a4>
		return 1;
30000f50:	e3a03001 	mov	r3, #1
30000f54:	ea000000 	b	30000f5c <is_bad_block+0x1a8>

	return 0;
30000f58:	e3a03000 	mov	r3, #0
}
30000f5c:	e1a00003 	mov	r0, r3
30000f60:	e28dd014 	add	sp, sp, #20
30000f64:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30000f68:	e12fff1e 	bx	lr

30000f6c <nand_read_page>:

static int nand_read_page(struct boot_nand_t * nand, unsigned char *buf, unsigned long addr)
{
30000f6c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30000f70:	e24dd024 	sub	sp, sp, #36	; 0x24
30000f74:	e58d000c 	str	r0, [sp, #12]
30000f78:	e58d1008 	str	r1, [sp, #8]
30000f7c:	e58d2004 	str	r2, [sp, #4]
	unsigned short *ptr16 = (unsigned short *)buf;
30000f80:	e59d3008 	ldr	r3, [sp, #8]
30000f84:	e58d3014 	str	r3, [sp, #20]
	unsigned int i, page_num;

	nand_clear_RnB();
30000f88:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000f8c:	e2833020 	add	r3, r3, #32
30000f90:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
30000f94:	e2822020 	add	r2, r2, #32
30000f98:	e5d22000 	ldrb	r2, [r2]
30000f9c:	e20220ff 	and	r2, r2, #255	; 0xff
30000fa0:	e3822004 	orr	r2, r2, #4
30000fa4:	e20220ff 	and	r2, r2, #255	; 0xff
30000fa8:	e5c32000 	strb	r2, [r3]

	NFCMD = NAND_CMD_READ0;
30000fac:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000fb0:	e2833008 	add	r3, r3, #8
30000fb4:	e3a02000 	mov	r2, #0
30000fb8:	e5c32000 	strb	r2, [r3]

	if (nand->page_size == 512) {
30000fbc:	e59d300c 	ldr	r3, [sp, #12]
30000fc0:	e5933000 	ldr	r3, [r3]
30000fc4:	e3530c02 	cmp	r3, #512	; 0x200
30000fc8:	1a000017 	bne	3000102c <nand_read_page+0xc0>
		/* Write Address */
		NFADDR = addr & 0xff;
30000fcc:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000fd0:	e283300c 	add	r3, r3, #12
30000fd4:	e59d2004 	ldr	r2, [sp, #4]
30000fd8:	e20220ff 	and	r2, r2, #255	; 0xff
30000fdc:	e5c32000 	strb	r2, [r3]
		NFADDR = (addr >> 9) & 0xff;
30000fe0:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000fe4:	e283300c 	add	r3, r3, #12
30000fe8:	e59d2004 	ldr	r2, [sp, #4]
30000fec:	e1a024a2 	lsr	r2, r2, #9
30000ff0:	e20220ff 	and	r2, r2, #255	; 0xff
30000ff4:	e5c32000 	strb	r2, [r3]
		NFADDR = (addr >> 17) & 0xff;
30000ff8:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30000ffc:	e283300c 	add	r3, r3, #12
30001000:	e59d2004 	ldr	r2, [sp, #4]
30001004:	e1a028a2 	lsr	r2, r2, #17
30001008:	e20220ff 	and	r2, r2, #255	; 0xff
3000100c:	e5c32000 	strb	r2, [r3]
		NFADDR = (addr >> 25) & 0xff;
30001010:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001014:	e283300c 	add	r3, r3, #12
30001018:	e59d2004 	ldr	r2, [sp, #4]
3000101c:	e1a02ca2 	lsr	r2, r2, #25
30001020:	e20220ff 	and	r2, r2, #255	; 0xff
30001024:	e5c32000 	strb	r2, [r3]
30001028:	ea000026 	b	300010c8 <nand_read_page+0x15c>
	} else if (nand->page_size == 2048) {
3000102c:	e59d300c 	ldr	r3, [sp, #12]
30001030:	e5933000 	ldr	r3, [r3]
30001034:	e3530b02 	cmp	r3, #2048	; 0x800
30001038:	1a000020 	bne	300010c0 <nand_read_page+0x154>
		page_num = addr >> 11; /* addr / 2048 */
3000103c:	e59d3004 	ldr	r3, [sp, #4]
30001040:	e1a035a3 	lsr	r3, r3, #11
30001044:	e58d301c 	str	r3, [sp, #28]
		/* Write Address */
		NFADDR = 0;
30001048:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
3000104c:	e283300c 	add	r3, r3, #12
30001050:	e3a02000 	mov	r2, #0
30001054:	e5c32000 	strb	r2, [r3]
		NFADDR = 0;
30001058:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
3000105c:	e283300c 	add	r3, r3, #12
30001060:	e3a02000 	mov	r2, #0
30001064:	e5c32000 	strb	r2, [r3]
		NFADDR = page_num & 0xff;
30001068:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
3000106c:	e283300c 	add	r3, r3, #12
30001070:	e59d201c 	ldr	r2, [sp, #28]
30001074:	e20220ff 	and	r2, r2, #255	; 0xff
30001078:	e5c32000 	strb	r2, [r3]
		NFADDR = (page_num >> 8) & 0xff;
3000107c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001080:	e283300c 	add	r3, r3, #12
30001084:	e59d201c 	ldr	r2, [sp, #28]
30001088:	e1a02422 	lsr	r2, r2, #8
3000108c:	e20220ff 	and	r2, r2, #255	; 0xff
30001090:	e5c32000 	strb	r2, [r3]
		NFADDR = (page_num >> 16) & 0xff;
30001094:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001098:	e283300c 	add	r3, r3, #12
3000109c:	e59d201c 	ldr	r2, [sp, #28]
300010a0:	e1a02822 	lsr	r2, r2, #16
300010a4:	e20220ff 	and	r2, r2, #255	; 0xff
300010a8:	e5c32000 	strb	r2, [r3]
		NFCMD = NAND_CMD_READSTART;
300010ac:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
300010b0:	e2833008 	add	r3, r3, #8
300010b4:	e3a02030 	mov	r2, #48	; 0x30
300010b8:	e5c32000 	strb	r2, [r3]
300010bc:	ea000001 	b	300010c8 <nand_read_page+0x15c>
	} else {
		return -1;
300010c0:	e3e03000 	mvn	r3, #0
300010c4:	ea000019 	b	30001130 <nand_read_page+0x1c4>
	}
	nand_wait();
300010c8:	ebfffef8 	bl	30000cb0 <nand_wait>
	for (i = 0; i < (nand->page_size>>1); i++) {
300010cc:	e3a03000 	mov	r3, #0
300010d0:	e58d3018 	str	r3, [sp, #24]
300010d4:	ea00000c 	b	3000110c <nand_read_page+0x1a0>
		*ptr16 = NFDATA16;
300010d8:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
300010dc:	e2833010 	add	r3, r3, #16
300010e0:	e1d330b0 	ldrh	r3, [r3]
300010e4:	e1a03803 	lsl	r3, r3, #16
300010e8:	e1a02823 	lsr	r2, r3, #16
300010ec:	e59d3014 	ldr	r3, [sp, #20]
300010f0:	e1c320b0 	strh	r2, [r3]
		ptr16++;
300010f4:	e59d3014 	ldr	r3, [sp, #20]
300010f8:	e2833002 	add	r3, r3, #2
300010fc:	e58d3014 	str	r3, [sp, #20]
		NFCMD = NAND_CMD_READSTART;
	} else {
		return -1;
	}
	nand_wait();
	for (i = 0; i < (nand->page_size>>1); i++) {
30001100:	e59d3018 	ldr	r3, [sp, #24]
30001104:	e2833001 	add	r3, r3, #1
30001108:	e58d3018 	str	r3, [sp, #24]
3000110c:	e59d300c 	ldr	r3, [sp, #12]
30001110:	e5933000 	ldr	r3, [r3]
30001114:	e1a030c3 	asr	r3, r3, #1
30001118:	e1a02003 	mov	r2, r3
3000111c:	e59d3018 	ldr	r3, [sp, #24]
30001120:	e1520003 	cmp	r2, r3
30001124:	8affffeb 	bhi	300010d8 <nand_read_page+0x16c>
		*ptr16 = NFDATA16;
		ptr16++;
	}

	return nand->page_size;
30001128:	e59d300c 	ldr	r3, [sp, #12]
3000112c:	e5933000 	ldr	r3, [r3]
}
30001130:	e1a00003 	mov	r0, r3
30001134:	e28dd024 	add	sp, sp, #36	; 0x24
30001138:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000113c:	e12fff1e 	bx	lr

30001140 <nand_read_id>:


static unsigned short nand_read_id()
{
30001140:	e24dd008 	sub	sp, sp, #8
	unsigned short res = 0;
30001144:	e3a03000 	mov	r3, #0
30001148:	e1cd30b6 	strh	r3, [sp, #6]
	NFCMD = NAND_CMD_READID;
3000114c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001150:	e2833008 	add	r3, r3, #8
30001154:	e3e0206f 	mvn	r2, #111	; 0x6f
30001158:	e5c32000 	strb	r2, [r3]
	NFADDR = 0;
3000115c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001160:	e283300c 	add	r3, r3, #12
30001164:	e3a02000 	mov	r2, #0
30001168:	e5c32000 	strb	r2, [r3]
	res = NFDATA;
3000116c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001170:	e2833010 	add	r3, r3, #16
30001174:	e5d33000 	ldrb	r3, [r3]
30001178:	e20330ff 	and	r3, r3, #255	; 0xff
3000117c:	e1cd30b6 	strh	r3, [sp, #6]
	res = (res << 8) | NFDATA;
30001180:	e1dd30b6 	ldrh	r3, [sp, #6]
30001184:	e1a03403 	lsl	r3, r3, #8
30001188:	e1a03803 	lsl	r3, r3, #16
3000118c:	e1a02823 	lsr	r2, r3, #16
30001190:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001194:	e2833010 	add	r3, r3, #16
30001198:	e5d33000 	ldrb	r3, [r3]
3000119c:	e20330ff 	and	r3, r3, #255	; 0xff
300011a0:	e1823003 	orr	r3, r2, r3
300011a4:	e1a03803 	lsl	r3, r3, #16
300011a8:	e1a03823 	lsr	r3, r3, #16
300011ac:	e1cd30b6 	strh	r3, [sp, #6]
	return res;
300011b0:	e1dd30b6 	ldrh	r3, [sp, #6]
}
300011b4:	e1a00003 	mov	r0, r3
300011b8:	e28dd008 	add	sp, sp, #8
300011bc:	e12fff1e 	bx	lr

300011c0 <nand_read>:



int nand_read(unsigned char *buf, unsigned long start_addr, int size)
{
300011c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300011c4:	e24dd02c 	sub	sp, sp, #44	; 0x2c
300011c8:	e58d000c 	str	r0, [sp, #12]
300011cc:	e58d1008 	str	r1, [sp, #8]
300011d0:	e58d2004 	str	r2, [sp, #4]
	int i, j;
	unsigned short nand_id;
	struct boot_nand_t nand;

	
	nand_select();
300011d4:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
300011d8:	e2833004 	add	r3, r3, #4
300011dc:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
300011e0:	e2822004 	add	r2, r2, #4
300011e4:	e5922000 	ldr	r2, [r2]
300011e8:	e3c22002 	bic	r2, r2, #2
300011ec:	e5832000 	str	r2, [r3]
	nand_clear_RnB();
300011f0:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
300011f4:	e2833020 	add	r3, r3, #32
300011f8:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
300011fc:	e2822020 	add	r2, r2, #32
30001200:	e5d22000 	ldrb	r2, [r2]
30001204:	e20220ff 	and	r2, r2, #255	; 0xff
30001208:	e3822004 	orr	r2, r2, #4
3000120c:	e20220ff 	and	r2, r2, #255	; 0xff
30001210:	e5c32000 	strb	r2, [r3]
	
	for (i = 0; i < 10; i++);
30001214:	e3a03000 	mov	r3, #0
30001218:	e58d301c 	str	r3, [sp, #28]
3000121c:	ea000002 	b	3000122c <nand_read+0x6c>
30001220:	e59d301c 	ldr	r3, [sp, #28]
30001224:	e2833001 	add	r3, r3, #1
30001228:	e58d301c 	str	r3, [sp, #28]
3000122c:	e59d301c 	ldr	r3, [sp, #28]
30001230:	e3530009 	cmp	r3, #9
30001234:	dafffff9 	ble	30001220 <nand_read+0x60>

	nand_id = nand_read_id();	
30001238:	ebffffc0 	bl	30001140 <nand_read_id>
3000123c:	e1a03000 	mov	r3, r0
30001240:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26

       if (nand_id == 0xec76 ||		/* Samsung K91208 */
30001244:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
30001248:	e3a03b3b 	mov	r3, #60416	; 0xec00
3000124c:	e2833076 	add	r3, r3, #118	; 0x76
30001250:	e1520003 	cmp	r2, r3
30001254:	0a000004 	beq	3000126c <nand_read+0xac>
30001258:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
3000125c:	e3a03cad 	mov	r3, #44288	; 0xad00
30001260:	e2833076 	add	r3, r3, #118	; 0x76
30001264:	e1520003 	cmp	r2, r3
30001268:	1a000006 	bne	30001288 <nand_read+0xc8>
           nand_id == 0xad76 ) {	/*Hynix HY27US08121A*/
		nand.page_size = 512;
3000126c:	e3a03c02 	mov	r3, #512	; 0x200
30001270:	e58d3010 	str	r3, [sp, #16]
		nand.block_size = 16 * 1024;
30001274:	e3a03901 	mov	r3, #16384	; 0x4000
30001278:	e58d3014 	str	r3, [sp, #20]
		nand.bad_block_offset = 5;
3000127c:	e3a03005 	mov	r3, #5
30001280:	e58d3018 	str	r3, [sp, #24]
	
	for (i = 0; i < 10; i++);

	nand_id = nand_read_id();	

       if (nand_id == 0xec76 ||		/* Samsung K91208 */
30001284:	ea000017 	b	300012e8 <nand_read+0x128>
           nand_id == 0xad76 ) {	/*Hynix HY27US08121A*/
		nand.page_size = 512;
		nand.block_size = 16 * 1024;
		nand.bad_block_offset = 5;
	} 
        else if (nand_id == 0xecf1 ||	/* Samsung K9F1G08U0B */
30001288:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
3000128c:	e3a03ced 	mov	r3, #60672	; 0xed00
30001290:	e243300f 	sub	r3, r3, #15
30001294:	e1520003 	cmp	r2, r3
30001298:	0a000009 	beq	300012c4 <nand_read+0x104>
3000129c:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
300012a0:	e3a03b3b 	mov	r3, #60416	; 0xec00
300012a4:	e28330da 	add	r3, r3, #218	; 0xda
300012a8:	e1520003 	cmp	r2, r3
300012ac:	0a000004 	beq	300012c4 <nand_read+0x104>
300012b0:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
300012b4:	e3a03ced 	mov	r3, #60672	; 0xed00
300012b8:	e243302d 	sub	r3, r3, #45	; 0x2d
300012bc:	e1520003 	cmp	r2, r3
300012c0:	1a000006 	bne	300012e0 <nand_read+0x120>
		   nand_id == 0xecda ||	/* Samsung K9F2G08U0B */
		   nand_id == 0xecd3 )	{ /* Samsung K9K8G08 */
		nand.page_size = 2048;
300012c4:	e3a03b02 	mov	r3, #2048	; 0x800
300012c8:	e58d3010 	str	r3, [sp, #16]
		nand.block_size = 128 * 1024;
300012cc:	e3a03802 	mov	r3, #131072	; 0x20000
300012d0:	e58d3014 	str	r3, [sp, #20]
		nand.bad_block_offset = nand.page_size;
300012d4:	e59d3010 	ldr	r3, [sp, #16]
300012d8:	e58d3018 	str	r3, [sp, #24]
           nand_id == 0xad76 ) {	/*Hynix HY27US08121A*/
		nand.page_size = 512;
		nand.block_size = 16 * 1024;
		nand.bad_block_offset = 5;
	} 
        else if (nand_id == 0xecf1 ||	/* Samsung K9F1G08U0B */
300012dc:	ea000001 	b	300012e8 <nand_read+0x128>
		nand.page_size = 2048;
		nand.block_size = 128 * 1024;
		nand.bad_block_offset = nand.page_size;
	} 
        else {
		return -1; 
300012e0:	e3e03000 	mvn	r3, #0
300012e4:	ea000060 	b	3000146c <nand_read+0x2ac>
	}

         if ((start_addr & (nand.block_size-1)))
300012e8:	e59d3014 	ldr	r3, [sp, #20]
300012ec:	e2433001 	sub	r3, r3, #1
300012f0:	e1a02003 	mov	r2, r3
300012f4:	e59d3008 	ldr	r3, [sp, #8]
300012f8:	e0023003 	and	r3, r2, r3
300012fc:	e3530000 	cmp	r3, #0
30001300:	0a000001 	beq	3000130c <nand_read+0x14c>
		return -1;	
30001304:	e3e03000 	mvn	r3, #0
30001308:	ea000057 	b	3000146c <nand_read+0x2ac>
        
        if(size & (nand.page_size-1)){
3000130c:	e59d3010 	ldr	r3, [sp, #16]
30001310:	e2432001 	sub	r2, r3, #1
30001314:	e59d3004 	ldr	r3, [sp, #4]
30001318:	e0023003 	and	r3, r2, r3
3000131c:	e3530000 	cmp	r3, #0
30001320:	0a000007 	beq	30001344 <nand_read+0x184>
             size=(size+nand.page_size-1) & (~(nand.page_size-1));
30001324:	e59d2010 	ldr	r2, [sp, #16]
30001328:	e59d3004 	ldr	r3, [sp, #4]
3000132c:	e0823003 	add	r3, r2, r3
30001330:	e2432001 	sub	r2, r3, #1
30001334:	e59d3010 	ldr	r3, [sp, #16]
30001338:	e2633000 	rsb	r3, r3, #0
3000133c:	e0023003 	and	r3, r2, r3
30001340:	e58d3004 	str	r3, [sp, #4]
        }

        if ((size & (nand.page_size-1)))
30001344:	e59d3010 	ldr	r3, [sp, #16]
30001348:	e2432001 	sub	r2, r3, #1
3000134c:	e59d3004 	ldr	r3, [sp, #4]
30001350:	e0023003 	and	r3, r2, r3
30001354:	e3530000 	cmp	r3, #0
30001358:	0a000001 	beq	30001364 <nand_read+0x1a4>
		return -1;
3000135c:	e3e03000 	mvn	r3, #0
30001360:	ea000041 	b	3000146c <nand_read+0x2ac>

	for (i=start_addr; i < (start_addr + size);) {
30001364:	e59d3008 	ldr	r3, [sp, #8]
30001368:	e58d301c 	str	r3, [sp, #28]
3000136c:	ea000030 	b	30001434 <nand_read+0x274>

		if ((i & (nand.block_size-1))== 0) {
30001370:	e59d3014 	ldr	r3, [sp, #20]
30001374:	e2432001 	sub	r2, r3, #1
30001378:	e59d301c 	ldr	r3, [sp, #28]
3000137c:	e0023003 	and	r3, r2, r3
30001380:	e3530000 	cmp	r3, #0
30001384:	1a00001a 	bne	300013f4 <nand_read+0x234>
			if (is_bad_block(&nand, i) || is_bad_block(&nand, i + nand.page_size)) {
30001388:	e59d301c 	ldr	r3, [sp, #28]
3000138c:	e28d2010 	add	r2, sp, #16
30001390:	e1a00002 	mov	r0, r2
30001394:	e1a01003 	mov	r1, r3
30001398:	ebfffe85 	bl	30000db4 <is_bad_block>
3000139c:	e1a03000 	mov	r3, r0
300013a0:	e3530000 	cmp	r3, #0
300013a4:	1a000009 	bne	300013d0 <nand_read+0x210>
300013a8:	e59d2010 	ldr	r2, [sp, #16]
300013ac:	e59d301c 	ldr	r3, [sp, #28]
300013b0:	e0823003 	add	r3, r2, r3
300013b4:	e28d2010 	add	r2, sp, #16
300013b8:	e1a00002 	mov	r0, r2
300013bc:	e1a01003 	mov	r1, r3
300013c0:	ebfffe7b 	bl	30000db4 <is_bad_block>
300013c4:	e1a03000 	mov	r3, r0
300013c8:	e3530000 	cmp	r3, #0
300013cc:	0a000008 	beq	300013f4 <nand_read+0x234>
				i += nand.block_size;
300013d0:	e59d3014 	ldr	r3, [sp, #20]
300013d4:	e59d201c 	ldr	r2, [sp, #28]
300013d8:	e0823003 	add	r3, r2, r3
300013dc:	e58d301c 	str	r3, [sp, #28]
				size += nand.block_size;
300013e0:	e59d3014 	ldr	r3, [sp, #20]
300013e4:	e59d2004 	ldr	r2, [sp, #4]
300013e8:	e0823003 	add	r3, r2, r3
300013ec:	e58d3004 	str	r3, [sp, #4]
				continue;
300013f0:	ea00000f 	b	30001434 <nand_read+0x274>
			}
		}

		j = nand_read_page(&nand, buf, i);
300013f4:	e59d301c 	ldr	r3, [sp, #28]
300013f8:	e28d2010 	add	r2, sp, #16
300013fc:	e1a00002 	mov	r0, r2
30001400:	e59d100c 	ldr	r1, [sp, #12]
30001404:	e1a02003 	mov	r2, r3
30001408:	ebfffed7 	bl	30000f6c <nand_read_page>
3000140c:	e1a03000 	mov	r3, r0
30001410:	e58d3020 	str	r3, [sp, #32]
		i += j;
30001414:	e59d201c 	ldr	r2, [sp, #28]
30001418:	e59d3020 	ldr	r3, [sp, #32]
3000141c:	e0823003 	add	r3, r2, r3
30001420:	e58d301c 	str	r3, [sp, #28]
		buf += j;
30001424:	e59d3020 	ldr	r3, [sp, #32]
30001428:	e59d200c 	ldr	r2, [sp, #12]
3000142c:	e0823003 	add	r3, r2, r3
30001430:	e58d300c 	str	r3, [sp, #12]
        }

        if ((size & (nand.page_size-1)))
		return -1;

	for (i=start_addr; i < (start_addr + size);) {
30001434:	e59d201c 	ldr	r2, [sp, #28]
30001438:	e59d1004 	ldr	r1, [sp, #4]
3000143c:	e59d3008 	ldr	r3, [sp, #8]
30001440:	e0813003 	add	r3, r1, r3
30001444:	e1520003 	cmp	r2, r3
30001448:	3affffc8 	bcc	30001370 <nand_read+0x1b0>
		i += j;
		buf += j;
	}


	nand_deselect();
3000144c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
30001450:	e2833004 	add	r3, r3, #4
30001454:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
30001458:	e2822004 	add	r2, r2, #4
3000145c:	e5922000 	ldr	r2, [r2]
30001460:	e3822002 	orr	r2, r2, #2
30001464:	e5832000 	str	r2, [r3]

	return 0;
30001468:	e3a03000 	mov	r3, #0
}
3000146c:	e1a00003 	mov	r0, r3
30001470:	e28dd02c 	add	sp, sp, #44	; 0x2c
30001474:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001478:	e12fff1e 	bx	lr

3000147c <MMU_EnableICache>:
3000147c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
30001480:	e3800a01 	orr	r0, r0, #4096	; 0x1000
30001484:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
30001488:	e1a0f00e 	mov	pc, lr

3000148c <MMU_DisableICache>:
3000148c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
30001490:	e3c00a01 	bic	r0, r0, #4096	; 0x1000
30001494:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
30001498:	e1a0f00e 	mov	pc, lr

3000149c <MMU_EnableDCache>:
3000149c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
300014a0:	e3800004 	orr	r0, r0, #4
300014a4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
300014a8:	e1a0f00e 	mov	pc, lr

300014ac <MMU_DisableDCache>:
300014ac:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
300014b0:	e3c00004 	bic	r0, r0, #4
300014b4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
300014b8:	e1a0f00e 	mov	pc, lr

300014bc <MMU_EnableAlignFault>:
300014bc:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
300014c0:	e3800002 	orr	r0, r0, #2
300014c4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
300014c8:	e1a0f00e 	mov	pc, lr

300014cc <MMU_DisableAlignFault>:
300014cc:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
300014d0:	e3c00002 	bic	r0, r0, #2
300014d4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
300014d8:	e1a0f00e 	mov	pc, lr

300014dc <MMU_EnableMMU>:
300014dc:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
300014e0:	e3800001 	orr	r0, r0, #1
300014e4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
300014e8:	e1a0f00e 	mov	pc, lr

300014ec <MMU_DisableMMU>:
300014ec:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
300014f0:	e3c00001 	bic	r0, r0, #1
300014f4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
300014f8:	e1a0f00e 	mov	pc, lr

300014fc <MMU_SetTTBase>:
300014fc:	ee020f10 	mcr	15, 0, r0, cr2, cr0, {0}
30001500:	e1a0f00e 	mov	pc, lr

30001504 <MMU_SetDomain>:
30001504:	ee030f10 	mcr	15, 0, r0, cr3, cr0, {0}
30001508:	e1a0f00e 	mov	pc, lr

3000150c <MMU_InvalidateIDCache>:
3000150c:	ee070f17 	mcr	15, 0, r0, cr7, cr7, {0}
30001510:	e1a0f00e 	mov	pc, lr

30001514 <MMU_InvalidateICache>:
30001514:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
30001518:	e1a0f00e 	mov	pc, lr

3000151c <MMU_InvalidateICacheMVA>:
3000151c:	ee070f35 	mcr	15, 0, r0, cr7, cr5, {1}
30001520:	e1a0f00e 	mov	pc, lr

30001524 <MMU_PrefetchICacheMVA>:
30001524:	ee070f3d 	mcr	15, 0, r0, cr7, cr13, {1}
30001528:	e1a0f00e 	mov	pc, lr

3000152c <MMU_InvalidateDCache>:
3000152c:	ee070f16 	mcr	15, 0, r0, cr7, cr6, {0}
30001530:	e1a0f00e 	mov	pc, lr

30001534 <MMU_InvalidateDCacheMVA>:
30001534:	ee070f36 	mcr	15, 0, r0, cr7, cr6, {1}
30001538:	e1a0f00e 	mov	pc, lr

3000153c <MMU_CleanDCacheMVA>:
3000153c:	ee070f3a 	mcr	15, 0, r0, cr7, cr10, {1}
30001540:	e1a0f00e 	mov	pc, lr

30001544 <MMU_CleanInvalidateDCacheMVA>:
30001544:	ee070f3e 	mcr	15, 0, r0, cr7, cr14, {1}
30001548:	e1a0f00e 	mov	pc, lr

3000154c <MMU_CleanDCacheIndex>:
3000154c:	ee070f5a 	mcr	15, 0, r0, cr7, cr10, {2}
30001550:	e1a0f00e 	mov	pc, lr

30001554 <MMU_CleanInvalidateDCacheIndex>:
30001554:	ee070f5e 	mcr	15, 0, r0, cr7, cr14, {2}
30001558:	e1a0f00e 	mov	pc, lr

3000155c <MMU_WaitForInterrupt>:
3000155c:	ee070f90 	mcr	15, 0, r0, cr7, cr0, {4}
30001560:	e1a0f00e 	mov	pc, lr

30001564 <MMU_InvalidateTLB>:
30001564:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
30001568:	e1a0f00e 	mov	pc, lr

3000156c <MMU_InvalidateITLB>:
3000156c:	ee080f15 	mcr	15, 0, r0, cr8, cr5, {0}
30001570:	e1a0f00e 	mov	pc, lr

30001574 <MMU_InvalidateITLBMVA>:
30001574:	ee080f35 	mcr	15, 0, r0, cr8, cr5, {1}
30001578:	e1a0f00e 	mov	pc, lr

3000157c <MMU_InvalidateDTLB>:
3000157c:	ee080f16 	mcr	15, 0, r0, cr8, cr6, {0}
30001580:	e1a0f00e 	mov	pc, lr

30001584 <MMU_SetProcessId>:
30001584:	ee0d0f10 	mcr	15, 0, r0, cr13, cr0, {0}
30001588:	e1a0f00e 	mov	pc, lr

3000158c <HAL_SWITCH_TO>:
3000158c:	e590d000 	ldr	sp, [r0]
30001590:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
30001594:	e129f000 	msr	CPSR_fc, r0
30001598:	e8bddfff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}

3000159c <HAL_INTR_SWITCH_TO>:
3000159c:	e92d5ffe 	push	{r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
300015a0:	e59f20c0 	ldr	r2, [pc, #192]	; 30001668 <HAL_CONTEXT_SWITCH+0x24>
300015a4:	e242203c 	sub	r2, r2, #60	; 0x3c
300015a8:	e590c000 	ldr	ip, [r0]
300015ac:	e8bc0ff8 	ldm	ip!, {r3, r4, r5, r6, r7, r8, r9, sl, fp}
300015b0:	e8a20ff8 	stmia	r2!, {r3, r4, r5, r6, r7, r8, r9, sl, fp}
300015b4:	e8bc00f8 	ldm	ip!, {r3, r4, r5, r6, r7}
300015b8:	e8a200f8 	stmia	r2!, {r3, r4, r5, r6, r7}
300015bc:	e8fc4000 	ldm	ip!, {lr}^
300015c0:	e8bc0008 	ldm	ip!, {r3}
300015c4:	e2833004 	add	r3, r3, #4
300015c8:	e8a20008 	stmia	r2!, {r3}
300015cc:	e92c1000 	stmdb	ip!, {ip}
300015d0:	e8fc2000 	ldm	ip!, {sp}^
300015d4:	e1a00000 	nop			; (mov r0, r0)
300015d8:	e8bd9ffe 	pop	{r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}

300015dc <HAL_INTR_CTX_SWITCH>:
300015dc:	e92d5ffc 	push	{r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
300015e0:	e59f2080 	ldr	r2, [pc, #128]	; 30001668 <HAL_CONTEXT_SWITCH+0x24>
300015e4:	e93207f8 	ldmdb	r2!, {r3, r4, r5, r6, r7, r8, r9, sl}
300015e8:	e24aa004 	sub	sl, sl, #4
300015ec:	e1a0b00d 	mov	fp, sp
300015f0:	e96b2000 	stmdb	fp!, {sp}^
300015f4:	e8bb1000 	ldm	fp!, {ip}
300015f8:	e92c0400 	stmdb	ip!, {sl}
300015fc:	e96c4000 	stmdb	ip!, {lr}^
30001600:	e92c03f8 	stmdb	ip!, {r3, r4, r5, r6, r7, r8, r9}
30001604:	e93203f8 	ldmdb	r2!, {r3, r4, r5, r6, r7, r8, r9}
30001608:	e92c03f8 	stmdb	ip!, {r3, r4, r5, r6, r7, r8, r9}
3000160c:	e580c000 	str	ip, [r0]
30001610:	e591c000 	ldr	ip, [r1]
30001614:	e8bc0ff8 	ldm	ip!, {r3, r4, r5, r6, r7, r8, r9, sl, fp}
30001618:	e8a20ff8 	stmia	r2!, {r3, r4, r5, r6, r7, r8, r9, sl, fp}
3000161c:	e8bc00f8 	ldm	ip!, {r3, r4, r5, r6, r7}
30001620:	e8a200f8 	stmia	r2!, {r3, r4, r5, r6, r7}
30001624:	e8fc4000 	ldm	ip!, {lr}^
30001628:	e8bc0008 	ldm	ip!, {r3}
3000162c:	e2833004 	add	r3, r3, #4
30001630:	e8a20008 	stmia	r2!, {r3}
30001634:	e92c1000 	stmdb	ip!, {ip}
30001638:	e8fc2000 	ldm	ip!, {sp}^
3000163c:	e1a00000 	nop			; (mov r0, r0)
30001640:	e8bd9ffc 	pop	{r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}

30001644 <HAL_CONTEXT_SWITCH>:
30001644:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001648:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
3000164c:	e10f4000 	mrs	r4, CPSR
30001650:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
30001654:	e580d000 	str	sp, [r0]
30001658:	e591d000 	ldr	sp, [r1]
3000165c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
30001660:	e129f000 	msr	CPSR_fc, r0
30001664:	e8bddfff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
30001668:	33ffff00 	.word	0x33ffff00

3000166c <HAL_INTR_ENTRY>:
3000166c:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
30001670:	e14f1000 	mrs	r1, SPSR
30001674:	e52d1004 	push	{r1}		; (str r1, [sp, #-4]!)
30001678:	e321f093 	msr	CPSR_c, #147	; 0x93
3000167c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001680:	e59f008c 	ldr	r0, [pc, #140]	; 30001714 <HAL_INTR_DISABLE_SAVE+0x20>
30001684:	e5900000 	ldr	r0, [r0]
30001688:	e1a0e00f 	mov	lr, pc
3000168c:	e59ff084 	ldr	pc, [pc, #132]	; 30001718 <HAL_INTR_DISABLE_SAVE+0x24>
30001690:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001694:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
30001698:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
3000169c:	e16ff000 	msr	SPSR_fsxc, r0
300016a0:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
300016a4:	e25ef004 	subs	pc, lr, #4

300016a8 <EXP_HANDLER>:
300016a8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300016ac:	e1a0000d 	mov	r0, sp
300016b0:	e9602000 	stmdb	r0!, {sp}^
300016b4:	e8b00002 	ldm	r0!, {r1}
300016b8:	e1a0000e 	mov	r0, lr
300016bc:	eb000b43 	bl	300043d0 <acoral_fault_entry>
300016c0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300016c4:	e25ef000 	subs	pc, lr, #0

300016c8 <HAL_INTR_ENABLE>:
300016c8:	e10f0000 	mrs	r0, CPSR
300016cc:	e3c000c0 	bic	r0, r0, #192	; 0xc0
300016d0:	e12ff000 	msr	CPSR_fsxc, r0
300016d4:	e1a0f00e 	mov	pc, lr

300016d8 <HAL_INTR_DISABLE>:
300016d8:	e10f0000 	mrs	r0, CPSR
300016dc:	e1a01000 	mov	r1, r0
300016e0:	e38110c0 	orr	r1, r1, #192	; 0xc0
300016e4:	e12ff001 	msr	CPSR_fsxc, r1
300016e8:	e1a0f00e 	mov	pc, lr

300016ec <HAL_INTR_RESTORE>:
300016ec:	e121f000 	msr	CPSR_c, r0
300016f0:	e1a0f00e 	mov	pc, lr

300016f4 <HAL_INTR_DISABLE_SAVE>:
300016f4:	e10f0000 	mrs	r0, CPSR
300016f8:	e38010c0 	orr	r1, r0, #192	; 0xc0
300016fc:	e121f001 	msr	CPSR_c, r1
30001700:	e10f1000 	mrs	r1, CPSR
30001704:	e20110c0 	and	r1, r1, #192	; 0xc0
30001708:	e35100c0 	cmp	r1, #192	; 0xc0
3000170c:	1afffff8 	bne	300016f4 <HAL_INTR_DISABLE_SAVE>
30001710:	e1a0f00e 	mov	pc, lr
30001714:	4a000014 	.word	0x4a000014
30001718:	300003cc 	.word	0x300003cc

3000171c <hal_intr_nesting_init_comm>:
acoral_u32 intr_nesting[HAL_MAX_CPU];
/*===========================                                                                                                                 
*initialize the nesting      
*中断嵌套初始化
*===========================*/
void hal_intr_nesting_init_comm(){
3000171c:	e24dd008 	sub	sp, sp, #8
	acoral_u32 i;
	for(i=0;i<HAL_MAX_CPU;i++)
30001720:	e3a03000 	mov	r3, #0
30001724:	e58d3004 	str	r3, [sp, #4]
30001728:	ea000006 	b	30001748 <hal_intr_nesting_init_comm+0x2c>
	  	intr_nesting[i]=0;
3000172c:	e59d2004 	ldr	r2, [sp, #4]
30001730:	e59f3024 	ldr	r3, [pc, #36]	; 3000175c <hal_intr_nesting_init_comm+0x40>
30001734:	e3a01000 	mov	r1, #0
30001738:	e7831102 	str	r1, [r3, r2, lsl #2]
*initialize the nesting      
*中断嵌套初始化
*===========================*/
void hal_intr_nesting_init_comm(){
	acoral_u32 i;
	for(i=0;i<HAL_MAX_CPU;i++)
3000173c:	e59d3004 	ldr	r3, [sp, #4]
30001740:	e2833001 	add	r3, r3, #1
30001744:	e58d3004 	str	r3, [sp, #4]
30001748:	e59d3004 	ldr	r3, [sp, #4]
3000174c:	e3530000 	cmp	r3, #0
30001750:	0afffff5 	beq	3000172c <hal_intr_nesting_init_comm+0x10>
	  	intr_nesting[i]=0;
}
30001754:	e28dd008 	add	sp, sp, #8
30001758:	e12fff1e 	bx	lr
3000175c:	302be6a4 	.word	0x302be6a4

30001760 <hal_get_intr_nesting_comm>:
/*===========================                                                                                                                 
*Get the nesting      
*获取当前CPU的中断嵌套数
*===========================*/
acoral_u32 hal_get_intr_nesting_comm(){
    return intr_nesting[acoral_current_cpu];
30001760:	e59f3008 	ldr	r3, [pc, #8]	; 30001770 <hal_get_intr_nesting_comm+0x10>
30001764:	e5933000 	ldr	r3, [r3]
}
30001768:	e1a00003 	mov	r0, r3
3000176c:	e12fff1e 	bx	lr
30001770:	302be6a4 	.word	0x302be6a4

30001774 <hal_intr_nesting_dec_comm>:

/*===========================                                                                                                                 
*Decrise the nesting      
*减少当前CPU中断嵌套数
*===========================*/
void hal_intr_nesting_dec_comm(){
30001774:	e24dd008 	sub	sp, sp, #8
    acoral_u8 cpu;
    cpu=acoral_current_cpu;
30001778:	e3a03000 	mov	r3, #0
3000177c:	e5cd3007 	strb	r3, [sp, #7]
    if(intr_nesting[cpu]>0)
30001780:	e5dd2007 	ldrb	r2, [sp, #7]
30001784:	e59f3028 	ldr	r3, [pc, #40]	; 300017b4 <hal_intr_nesting_dec_comm+0x40>
30001788:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3000178c:	e3530000 	cmp	r3, #0
30001790:	0a000005 	beq	300017ac <hal_intr_nesting_dec_comm+0x38>
	intr_nesting[cpu]--;
30001794:	e5dd3007 	ldrb	r3, [sp, #7]
30001798:	e59f2014 	ldr	r2, [pc, #20]	; 300017b4 <hal_intr_nesting_dec_comm+0x40>
3000179c:	e7922103 	ldr	r2, [r2, r3, lsl #2]
300017a0:	e2421001 	sub	r1, r2, #1
300017a4:	e59f2008 	ldr	r2, [pc, #8]	; 300017b4 <hal_intr_nesting_dec_comm+0x40>
300017a8:	e7821103 	str	r1, [r2, r3, lsl #2]
}
300017ac:	e28dd008 	add	sp, sp, #8
300017b0:	e12fff1e 	bx	lr
300017b4:	302be6a4 	.word	0x302be6a4

300017b8 <hal_intr_nesting_inc_comm>:
/*===========================                                                                                                                 
*Incrise the nesting        
*增加中断嵌套数
*===========================*/
void hal_intr_nesting_inc_comm(){
    intr_nesting[acoral_current_cpu]++;
300017b8:	e59f3010 	ldr	r3, [pc, #16]	; 300017d0 <hal_intr_nesting_inc_comm+0x18>
300017bc:	e5933000 	ldr	r3, [r3]
300017c0:	e2832001 	add	r2, r3, #1
300017c4:	e59f3004 	ldr	r3, [pc, #4]	; 300017d0 <hal_intr_nesting_inc_comm+0x18>
300017c8:	e5832000 	str	r2, [r3]
}
300017cc:	e12fff1e 	bx	lr
300017d0:	302be6a4 	.word	0x302be6a4

300017d4 <hal_sched_bridge_comm>:

void hal_sched_bridge_comm(){
300017d4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300017d8:	e24dd00c 	sub	sp, sp, #12
  	acoral_sr cpu_sr;
	HAL_ENTER_CRITICAL();
300017dc:	ebffffc4 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300017e0:	e1a03000 	mov	r3, r0
300017e4:	e58d3004 	str	r3, [sp, #4]
	acoral_real_sched();
300017e8:	eb00032c 	bl	300024a0 <acoral_real_sched>
	HAL_EXIT_CRITICAL();
300017ec:	e59d0004 	ldr	r0, [sp, #4]
300017f0:	ebffffbd 	bl	300016ec <HAL_INTR_RESTORE>
}
300017f4:	e28dd00c 	add	sp, sp, #12
300017f8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300017fc:	e12fff1e 	bx	lr

30001800 <hal_intr_exit_bridge_comm>:

void hal_intr_exit_bridge_comm(){
30001800:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001804:	e24dd00c 	sub	sp, sp, #12
  	acoral_sr cpu_sr;
	HAL_ENTER_CRITICAL();
30001808:	ebffffb9 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000180c:	e1a03000 	mov	r3, r0
30001810:	e58d3004 	str	r3, [sp, #4]
	acoral_real_intr_sched();
30001814:	eb00034c 	bl	3000254c <acoral_real_intr_sched>
	HAL_EXIT_CRITICAL();
30001818:	e59d0004 	ldr	r0, [sp, #4]
3000181c:	ebffffb2 	bl	300016ec <HAL_INTR_RESTORE>
}
30001820:	e28dd00c 	add	sp, sp, #12
30001824:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001828:	e12fff1e 	bx	lr

3000182c <hal_atomic_add_comm>:

void hal_atomic_add_comm(int i, acoral_atomic_t *v)
{
3000182c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001830:	e24dd014 	sub	sp, sp, #20
30001834:	e58d0004 	str	r0, [sp, #4]
30001838:	e58d1000 	str	r1, [sp]
		acoral_sr sr;
		sr=HAL_INTR_DISABLE_SAVE();
3000183c:	ebffffac 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30001840:	e1a03000 	mov	r3, r0
30001844:	e58d300c 	str	r3, [sp, #12]
		v->val=v->val+i;
30001848:	e59d3000 	ldr	r3, [sp]
3000184c:	e5932000 	ldr	r2, [r3]
30001850:	e59d3004 	ldr	r3, [sp, #4]
30001854:	e0822003 	add	r2, r2, r3
30001858:	e59d3000 	ldr	r3, [sp]
3000185c:	e5832000 	str	r2, [r3]
		HAL_INTR_RESTORE(sr);
30001860:	e59d000c 	ldr	r0, [sp, #12]
30001864:	ebffffa0 	bl	300016ec <HAL_INTR_RESTORE>
}
30001868:	e28dd014 	add	sp, sp, #20
3000186c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001870:	e12fff1e 	bx	lr

30001874 <hal_atomic_sub_comm>:

void hal_atomic_sub_comm(int i, acoral_atomic_t *v)
{
30001874:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001878:	e24dd014 	sub	sp, sp, #20
3000187c:	e58d0004 	str	r0, [sp, #4]
30001880:	e58d1000 	str	r1, [sp]
	acoral_sr sr;
	sr=HAL_INTR_DISABLE_SAVE();
30001884:	ebffff9a 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30001888:	e1a03000 	mov	r3, r0
3000188c:	e58d300c 	str	r3, [sp, #12]
	v->val=v->val-i;
30001890:	e59d3000 	ldr	r3, [sp]
30001894:	e5932000 	ldr	r2, [r3]
30001898:	e59d3004 	ldr	r3, [sp, #4]
3000189c:	e0632002 	rsb	r2, r3, r2
300018a0:	e59d3000 	ldr	r3, [sp]
300018a4:	e5832000 	str	r2, [r3]
	HAL_INTR_RESTORE(sr);
300018a8:	e59d000c 	ldr	r0, [sp, #12]
300018ac:	ebffff8e 	bl	300016ec <HAL_INTR_RESTORE>
}
300018b0:	e28dd014 	add	sp, sp, #20
300018b4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300018b8:	e12fff1e 	bx	lr

300018bc <idle>:
extern volatile acoral_u32 idle_count[HAL_MAX_CPU];
/*================================
 *      idle thread
 *       空闲进程
 *================================*/
void idle(void *args){
300018bc:	e24dd008 	sub	sp, sp, #8
300018c0:	e58d0004 	str	r0, [sp, #4]
	while(1){
#ifdef CFG_STAT
		idle_count[acoral_current_cpu]++;
#endif
	}
300018c4:	eafffffe 	b	300018c4 <idle+0x8>

300018c8 <daem>:

/*================================
 *      resouce collection function
 *           资源回收函数
 *================================*/
void daem(void *args){
300018c8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300018cc:	e24dd024 	sub	sp, sp, #36	; 0x24
300018d0:	e58d0004 	str	r0, [sp, #4]
	acoral_sr cpu_sr;
	acoral_thread_t * thread;
	acoral_list_t *head,*tmp,*tmp1;
	head=&acoral_res_release_queue.head;
300018d4:	e59f30b8 	ldr	r3, [pc, #184]	; 30001994 <daem+0xcc>
300018d8:	e58d3014 	str	r3, [sp, #20]
	while(1){
		for(tmp=head->next;tmp!=head;){
300018dc:	e59d3014 	ldr	r3, [sp, #20]
300018e0:	e5933000 	ldr	r3, [r3]
300018e4:	e58d3018 	str	r3, [sp, #24]
300018e8:	ea000023 	b	3000197c <daem+0xb4>
			tmp1=tmp->next;
300018ec:	e59d3018 	ldr	r3, [sp, #24]
300018f0:	e5933000 	ldr	r3, [r3]
300018f4:	e58d301c 	str	r3, [sp, #28]
			HAL_ENTER_CRITICAL();
300018f8:	ebffff7d 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300018fc:	e1a03000 	mov	r3, r0
30001900:	e58d300c 	str	r3, [sp, #12]
			thread=list_entry(tmp,acoral_thread_t,waiting);
30001904:	e59d3018 	ldr	r3, [sp, #24]
30001908:	e2433020 	sub	r3, r3, #32
3000190c:	e58d3010 	str	r3, [sp, #16]
			/*如果线程资源已经不在使用，即release状态则释放*/
			acoral_spin_lock(&head->lock);/**/
			acoral_spin_lock(&tmp->lock);/**/
			acoral_list_del(tmp);/**/
30001910:	e59d0018 	ldr	r0, [sp, #24]
30001914:	eb0021ca 	bl	3000a044 <acoral_list_del>
			acoral_spin_unlock(&tmp->lock);/**/
			acoral_spin_unlock(&head->lock);/**/
			HAL_EXIT_CRITICAL();
30001918:	e59d000c 	ldr	r0, [sp, #12]
3000191c:	ebffff72 	bl	300016ec <HAL_INTR_RESTORE>
			tmp=tmp1;	
30001920:	e59d301c 	ldr	r3, [sp, #28]
30001924:	e58d3018 	str	r3, [sp, #24]
			if(thread->state==ACORAL_THREAD_STATE_RELEASE){
30001928:	e59d3010 	ldr	r3, [sp, #16]
3000192c:	e5d33004 	ldrb	r3, [r3, #4]
30001930:	e3530010 	cmp	r3, #16
30001934:	1a000003 	bne	30001948 <daem+0x80>
				acoral_release_thread((acoral_res_t *)thread);
30001938:	e59d3010 	ldr	r3, [sp, #16]
3000193c:	e1a00003 	mov	r0, r3
30001940:	eb00037d 	bl	3000273c <acoral_release_thread>
30001944:	ea00000c 	b	3000197c <daem+0xb4>
			}else{
				HAL_ENTER_CRITICAL();
30001948:	ebffff69 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000194c:	e1a03000 	mov	r3, r0
30001950:	e58d300c 	str	r3, [sp, #12]
				acoral_spin_lock(&head->lock);/**/
				tmp1=head->prev;
30001954:	e59d3014 	ldr	r3, [sp, #20]
30001958:	e5933004 	ldr	r3, [r3, #4]
3000195c:	e58d301c 	str	r3, [sp, #28]
				acoral_spin_lock(&tmp1->lock);/**/
				acoral_list_add2_tail(&thread->waiting,head);/**/
30001960:	e59d3010 	ldr	r3, [sp, #16]
30001964:	e2833020 	add	r3, r3, #32
30001968:	e1a00003 	mov	r0, r3
3000196c:	e59d1014 	ldr	r1, [sp, #20]
30001970:	eb0021a0 	bl	30009ff8 <acoral_list_add2_tail>
				acoral_spin_unlock(&tmp1->lock);/**/
				acoral_spin_unlock(&head->lock);/**/
				HAL_EXIT_CRITICAL();
30001974:	e59d000c 	ldr	r0, [sp, #12]
30001978:	ebffff5b 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sr cpu_sr;
	acoral_thread_t * thread;
	acoral_list_t *head,*tmp,*tmp1;
	head=&acoral_res_release_queue.head;
	while(1){
		for(tmp=head->next;tmp!=head;){
3000197c:	e59d2018 	ldr	r2, [sp, #24]
30001980:	e59d3014 	ldr	r3, [sp, #20]
30001984:	e1520003 	cmp	r2, r3
30001988:	1affffd7 	bne	300018ec <daem+0x24>
				acoral_spin_unlock(&tmp1->lock);/**/
				acoral_spin_unlock(&head->lock);/**/
				HAL_EXIT_CRITICAL();
			}
		}
		acoral_suspend_self();
3000198c:	eb000394 	bl	300027e4 <acoral_suspend_self>
	}
30001990:	eaffffd1 	b	300018dc <daem+0x14>
30001994:	3012aca0 	.word	0x3012aca0

30001998 <init>:
#define DAEM_STACK_SIZE 512
#else
#define DAEM_STACK_SIZE 256
#endif
acoral_thread_t *thread;
void init(void *args){
30001998:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000199c:	e24dd024 	sub	sp, sp, #36	; 0x24
300019a0:	e58d0014 	str	r0, [sp, #20]
	acoral_comm_policy_data_t data;
	acoral_ticks_init();
300019a4:	eb000ae9 	bl	30004550 <acoral_ticks_init>
	/*ticks中断初始化函数*/
	acoral_start_sched=true;
300019a8:	e59f30c4 	ldr	r3, [pc, #196]	; 30001a74 <init+0xdc>
300019ac:	e3a02001 	mov	r2, #1
300019b0:	e5832000 	str	r2, [r3]
	/*软件延时初始化函数*/
#ifdef CFG_SOFT_DELAY
	soft_delay_init();
300019b4:	eb002014 	bl	30009a0c <soft_delay_init>
#ifdef CFG_STAT
	/*内核统计相关数据初始化*/
	stat_init();
#endif
	/*创建后台服务进程*/
  	acoral_init_list(&acoral_res_release_queue.head);
300019b8:	e59f30b8 	ldr	r3, [pc, #184]	; 30001a78 <init+0xe0>
300019bc:	e59f20b4 	ldr	r2, [pc, #180]	; 30001a78 <init+0xe0>
300019c0:	e5832000 	str	r2, [r3]
300019c4:	e59f30ac 	ldr	r3, [pc, #172]	; 30001a78 <init+0xe0>
300019c8:	e59f20a8 	ldr	r2, [pc, #168]	; 30001a78 <init+0xe0>
300019cc:	e5832004 	str	r2, [r3, #4]
  	acoral_spin_init(&acoral_res_release_queue.head.lock);
	data.cpu=acoral_current_cpu;
300019d0:	e3a03000 	mov	r3, #0
300019d4:	e5cd301c 	strb	r3, [sp, #28]
	data.prio=ACORAL_DAEMON_PRIO;
300019d8:	e3a0307f 	mov	r3, #127	; 0x7f
300019dc:	e5cd301d 	strb	r3, [sp, #29]
	data.prio_type=ACORAL_ABSOLUTE_PRIO;
300019e0:	e3a03004 	mov	r3, #4
300019e4:	e5cd301e 	strb	r3, [sp, #30]
	daemon_id=acoral_create_thread_ext(daem,DAEM_STACK_SIZE,NULL,"daemon",NULL,ACORAL_SCHED_POLICY_COMM,&data);
300019e8:	e3a03000 	mov	r3, #0
300019ec:	e58d3000 	str	r3, [sp]
300019f0:	e3a03015 	mov	r3, #21
300019f4:	e58d3004 	str	r3, [sp, #4]
300019f8:	e28d301c 	add	r3, sp, #28
300019fc:	e58d3008 	str	r3, [sp, #8]
30001a00:	e59f0074 	ldr	r0, [pc, #116]	; 30001a7c <init+0xe4>
30001a04:	e3a01c01 	mov	r1, #256	; 0x100
30001a08:	e3a02000 	mov	r2, #0
30001a0c:	e59f306c 	ldr	r3, [pc, #108]	; 30001a80 <init+0xe8>
30001a10:	eb000087 	bl	30001c34 <create_thread_ext>
30001a14:	e1a02000 	mov	r2, r0
30001a18:	e59f3064 	ldr	r3, [pc, #100]	; 30001a84 <init+0xec>
30001a1c:	e5832000 	str	r2, [r3]
	thread=(acoral_thread_t *)acoral_get_res_by_id(daemon_id);
30001a20:	e59f305c 	ldr	r3, [pc, #92]	; 30001a84 <init+0xec>
30001a24:	e5933000 	ldr	r3, [r3]
30001a28:	e1a00003 	mov	r0, r3
30001a2c:	eb000795 	bl	30003888 <acoral_get_res_by_id>
30001a30:	e1a03000 	mov	r3, r0
30001a34:	e1a02003 	mov	r2, r3
30001a38:	e59f3048 	ldr	r3, [pc, #72]	; 30001a88 <init+0xf0>
30001a3c:	e5832000 	str	r2, [r3]
	if(daemon_id==-1)
30001a40:	e59f303c 	ldr	r3, [pc, #60]	; 30001a84 <init+0xec>
30001a44:	e5933000 	ldr	r3, [r3]
30001a48:	e3730001 	cmn	r3, #1
30001a4c:	1a000000 	bne	30001a54 <init+0xbc>
		while(1);
30001a50:	eafffffe 	b	30001a50 <init+0xb8>
	/*应用级相关服务初始化,应用级不要使用延时函数，没有效果的*/
#ifdef CFG_SHELL
	acoral_shell_init();
30001a54:	eb00abc3 	bl	3002c968 <acoral_shell_init>
#endif
	plugin_init();
30001a58:	eb002b2f 	bl	3000c71c <plugin_init>
	app_enter_policy_init();
30001a5c:	eb000147 	bl	30001f80 <app_enter_policy_init>
	user_main();
30001a60:	eb00aa37 	bl	3002c344 <user_main>
#ifdef CFG_TEST
	test_init();
#endif
	app_exit_policy_init();
30001a64:	eb000149 	bl	30001f90 <app_exit_policy_init>
}
30001a68:	e28dd024 	add	sp, sp, #36	; 0x24
30001a6c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001a70:	e12fff1e 	bx	lr
30001a74:	300c9a98 	.word	0x300c9a98
30001a78:	3012aca0 	.word	0x3012aca0
30001a7c:	300018c8 	.word	0x300018c8
30001a80:	3004506c 	.word	0x3004506c
30001a84:	3012ac88 	.word	0x3012ac88
30001a88:	300eab44 	.word	0x300eab44

30001a8c <acoral_start>:
acoral_thread_t orig_thread;
/*================================
 * Entry c function of start.S 
 *       c语言初始化入口函数
 *================================*/
void acoral_start(){
30001a8c:	e92d4008 	push	{r3, lr}
		acoral_follow_cpu_start();
	}
	core_cpu=0;
	HAL_CORE_CPU_INIT();
#endif
	orig_thread.console_id=ACORAL_DEV_ERR_ID;
30001a90:	e59f3030 	ldr	r3, [pc, #48]	; 30001ac8 <acoral_start+0x3c>
30001a94:	e3e02000 	mvn	r2, #0
30001a98:	e583204c 	str	r2, [r3, #76]	; 0x4c
	acoral_set_orig_thread(&orig_thread);
30001a9c:	e59f0024 	ldr	r0, [pc, #36]	; 30001ac8 <acoral_start+0x3c>
30001aa0:	eb00015a 	bl	30002010 <acoral_set_orig_thread>
	/*板子初始化*/
	HAL_BOARD_INIT();

	/*内核模块初始化*/
	acoral_module_init();
30001aa4:	eb000058 	bl	30001c0c <acoral_module_init>

	/*串口终端应该初始化好了，将根线程的终端id设置为串口终端*/
#ifdef CFG_DRIVER
	orig_thread.console_id=acoral_dev_open("console");;
30001aa8:	e59f001c 	ldr	r0, [pc, #28]	; 30001acc <acoral_start+0x40>
30001aac:	eb00facc 	bl	300405e4 <acoral_dev_open>
30001ab0:	e1a02000 	mov	r2, r0
30001ab4:	e59f300c 	ldr	r3, [pc, #12]	; 30001ac8 <acoral_start+0x3c>
30001ab8:	e583204c 	str	r2, [r3, #76]	; 0x4c
	/*cmp初始化*/
    	acoral_cmp_init();
#endif

	/*主cpu开始函数*/
	acoral_core_cpu_start();
30001abc:	eb000003 	bl	30001ad0 <acoral_core_cpu_start>
}
30001ac0:	e8bd4008 	pop	{r3, lr}
30001ac4:	e12fff1e 	bx	lr
30001ac8:	300eab7c 	.word	0x300eab7c
30001acc:	30045074 	.word	0x30045074

30001ad0 <acoral_core_cpu_start>:
/*================================
 *  the primary cpu core start function 
 *      主cpu core的开始函数
 *================================*/
#define IDLE_STACK_SIZE 128
void acoral_core_cpu_start(){
30001ad0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001ad4:	e24dd01c 	sub	sp, sp, #28
	acoral_comm_policy_data_t data;
	/*创建空闲线程*/
	acoral_start_sched=false;
30001ad8:	e59f30cc 	ldr	r3, [pc, #204]	; 30001bac <acoral_core_cpu_start+0xdc>
30001adc:	e3a02000 	mov	r2, #0
30001ae0:	e5832000 	str	r2, [r3]
	data.cpu=acoral_current_cpu;
30001ae4:	e3a03000 	mov	r3, #0
30001ae8:	e5cd3014 	strb	r3, [sp, #20]
	data.prio=ACORAL_IDLE_PRIO;
30001aec:	e3e0307d 	mvn	r3, #125	; 0x7d
30001af0:	e5cd3015 	strb	r3, [sp, #21]
	data.prio_type=ACORAL_ABSOLUTE_PRIO;
30001af4:	e3a03004 	mov	r3, #4
30001af8:	e5cd3016 	strb	r3, [sp, #22]
	idle_id=acoral_create_thread_ext(idle,IDLE_STACK_SIZE,NULL,"idle",NULL,ACORAL_SCHED_POLICY_COMM,&data);
30001afc:	e3a03000 	mov	r3, #0
30001b00:	e58d3000 	str	r3, [sp]
30001b04:	e3a03015 	mov	r3, #21
30001b08:	e58d3004 	str	r3, [sp, #4]
30001b0c:	e28d3014 	add	r3, sp, #20
30001b10:	e58d3008 	str	r3, [sp, #8]
30001b14:	e59f0094 	ldr	r0, [pc, #148]	; 30001bb0 <acoral_core_cpu_start+0xe0>
30001b18:	e3a01080 	mov	r1, #128	; 0x80
30001b1c:	e3a02000 	mov	r2, #0
30001b20:	e59f308c 	ldr	r3, [pc, #140]	; 30001bb4 <acoral_core_cpu_start+0xe4>
30001b24:	eb000042 	bl	30001c34 <create_thread_ext>
30001b28:	e1a02000 	mov	r2, r0
30001b2c:	e59f3084 	ldr	r3, [pc, #132]	; 30001bb8 <acoral_core_cpu_start+0xe8>
30001b30:	e5832000 	str	r2, [r3]
	if(idle_id==-1)
30001b34:	e59f307c 	ldr	r3, [pc, #124]	; 30001bb8 <acoral_core_cpu_start+0xe8>
30001b38:	e5933000 	ldr	r3, [r3]
30001b3c:	e3730001 	cmn	r3, #1
30001b40:	1a000000 	bne	30001b48 <acoral_core_cpu_start+0x78>
		while(1);
30001b44:	eafffffe 	b	30001b44 <acoral_core_cpu_start+0x74>
	/*创建初始化线程,这个调用层次比较多，需要多谢堆栈*/
	data.prio=ACORAL_INIT_PRIO;
30001b48:	e3a03000 	mov	r3, #0
30001b4c:	e5cd3015 	strb	r3, [sp, #21]
	/*动态堆栈*/
	init_id=acoral_create_thread_ext(init,ACORAL_TEST_STACK_SIZE,"in init","init",NULL,ACORAL_SCHED_POLICY_COMM,&data);
30001b50:	e3a03000 	mov	r3, #0
30001b54:	e58d3000 	str	r3, [sp]
30001b58:	e3a03015 	mov	r3, #21
30001b5c:	e58d3004 	str	r3, [sp, #4]
30001b60:	e28d3014 	add	r3, sp, #20
30001b64:	e58d3008 	str	r3, [sp, #8]
30001b68:	e59f004c 	ldr	r0, [pc, #76]	; 30001bbc <acoral_core_cpu_start+0xec>
30001b6c:	e3a01c02 	mov	r1, #512	; 0x200
30001b70:	e59f2048 	ldr	r2, [pc, #72]	; 30001bc0 <acoral_core_cpu_start+0xf0>
30001b74:	e59f3048 	ldr	r3, [pc, #72]	; 30001bc4 <acoral_core_cpu_start+0xf4>
30001b78:	eb00002d 	bl	30001c34 <create_thread_ext>
30001b7c:	e1a02000 	mov	r2, r0
30001b80:	e59f3040 	ldr	r3, [pc, #64]	; 30001bc8 <acoral_core_cpu_start+0xf8>
30001b84:	e5832000 	str	r2, [r3]
	if(init_id==-1)
30001b88:	e59f3038 	ldr	r3, [pc, #56]	; 30001bc8 <acoral_core_cpu_start+0xf8>
30001b8c:	e5933000 	ldr	r3, [r3]
30001b90:	e3730001 	cmn	r3, #1
30001b94:	1a000000 	bne	30001b9c <acoral_core_cpu_start+0xcc>
		while(1);
30001b98:	eafffffe 	b	30001b98 <acoral_core_cpu_start+0xc8>
	acoral_start_os();
30001b9c:	eb00000a 	bl	30001bcc <acoral_start_os>
}
30001ba0:	e28dd01c 	add	sp, sp, #28
30001ba4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001ba8:	e12fff1e 	bx	lr
30001bac:	300c9a98 	.word	0x300c9a98
30001bb0:	300018bc 	.word	0x300018bc
30001bb4:	3004507c 	.word	0x3004507c
30001bb8:	3012d6a4 	.word	0x3012d6a4
30001bbc:	30001998 	.word	0x30001998
30001bc0:	30045084 	.word	0x30045084
30001bc4:	3004508c 	.word	0x3004508c
30001bc8:	3012d71c 	.word	0x3012d71c

30001bcc <acoral_start_os>:

void acoral_start_os(){
30001bcc:	e92d4008 	push	{r3, lr}
	acoral_sched_init();
30001bd0:	eb0000f2 	bl	30001fa0 <acoral_sched_init>
	acoral_select_thread();
30001bd4:	eb000287 	bl	300025f8 <acoral_select_thread>
	acoral_set_running_thread(acoral_ready_thread);
30001bd8:	e59f3024 	ldr	r3, [pc, #36]	; 30001c04 <acoral_start_os+0x38>
30001bdc:	e5933000 	ldr	r3, [r3]
30001be0:	e1a00003 	mov	r0, r3
30001be4:	eb000111 	bl	30002030 <acoral_set_running_thread>
	HAL_START_OS(&acoral_cur_thread->stack);
30001be8:	e59f3018 	ldr	r3, [pc, #24]	; 30001c08 <acoral_start_os+0x3c>
30001bec:	e5933000 	ldr	r3, [r3]
30001bf0:	e2833034 	add	r3, r3, #52	; 0x34
30001bf4:	e1a00003 	mov	r0, r3
30001bf8:	ebfffe63 	bl	3000158c <HAL_SWITCH_TO>
}
30001bfc:	e8bd4008 	pop	{r3, lr}
30001c00:	e12fff1e 	bx	lr
30001c04:	302be26c 	.word	0x302be26c
30001c08:	302be818 	.word	0x302be818

30001c0c <acoral_module_init>:

/*================================
 *  the subsystem init of the kernel
 *     内核各模块初始化
 *================================*/
void acoral_module_init(){
30001c0c:	e92d4008 	push	{r3, lr}
	/*中断系统初始化*/
	acoral_intr_sys_init();
30001c10:	eb00082f 	bl	30003cd4 <acoral_intr_sys_init>
	/*内存管理系统初始化*/
	acoral_mem_sys_init();
30001c14:	eb000b9d 	bl	30004a90 <acoral_mem_sys_init>
	/*资源管理系统初始化*/
	acoral_res_sys_init();
30001c18:	eb000809 	bl	30003c44 <acoral_res_sys_init>
	/*驱动管理系统初始化*/
	/*线程管理系统初始化*/
	acoral_thread_sys_init();
30001c1c:	eb0004db 	bl	30002f90 <acoral_thread_sys_init>
	/*时钟管理系统初始化*/
	acoral_time_sys_init();
30001c20:	eb000a2e 	bl	300044e0 <acoral_time_sys_init>
	/*事件管理系统初始化,这个必须要，因为内存管理系统用到了*/
	acoral_evt_sys_init();
30001c24:	eb000bd6 	bl	30004b84 <acoral_evt_sys_init>
	/*消息管理系统初始化*/
#ifdef CFG_DRIVER
	acoral_drv_sys_init();
30001c28:	eb00fb3c 	bl	30040920 <acoral_drv_sys_init>
#endif
}
30001c2c:	e8bd4008 	pop	{r3, lr}
30001c30:	e12fff1e 	bx	lr

30001c34 <create_thread_ext>:
#include<queue.h>
#include<thread.h>
#include<print.h>
#include<policy.h>
acoral_queue_t policy_list;
acoral_id create_thread_ext(void (*route)(void *args),acoral_u32 stack_size,void *args,acoral_char *name,void *stack,acoral_u32 sched_policy,void *data){
30001c34:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001c38:	e24dd024 	sub	sp, sp, #36	; 0x24
30001c3c:	e58d0014 	str	r0, [sp, #20]
30001c40:	e58d1010 	str	r1, [sp, #16]
30001c44:	e58d200c 	str	r2, [sp, #12]
30001c48:	e58d3008 	str	r3, [sp, #8]
	acoral_thread_t *thread;
        /*分配tcb数据块*/
	thread=acoral_alloc_thread();
30001c4c:	eb000407 	bl	30002c70 <acoral_alloc_thread>
30001c50:	e1a03000 	mov	r3, r0
30001c54:	e58d301c 	str	r3, [sp, #28]
	if(NULL==thread){
30001c58:	e59d301c 	ldr	r3, [sp, #28]
30001c5c:	e3530000 	cmp	r3, #0
30001c60:	1a000004 	bne	30001c78 <create_thread_ext+0x44>
		acoral_printerr("Alloc thread:%s fail\n",name);
30001c64:	e59f0098 	ldr	r0, [pc, #152]	; 30001d04 <create_thread_ext+0xd0>
30001c68:	e59d1008 	ldr	r1, [sp, #8]
30001c6c:	eb002573 	bl	3000b240 <acoral_print>
		acoral_printk("No Mem Space or Beyond the max thread\n");
		return -1;
30001c70:	e3e03000 	mvn	r3, #0
30001c74:	ea00001e 	b	30001cf4 <create_thread_ext+0xc0>
	}
	thread->name=name;
30001c78:	e59d301c 	ldr	r3, [sp, #28]
30001c7c:	e59d2008 	ldr	r2, [sp, #8]
30001c80:	e5832048 	str	r2, [r3, #72]	; 0x48
	stack_size=stack_size&(~3);
30001c84:	e59d3010 	ldr	r3, [sp, #16]
30001c88:	e3c33003 	bic	r3, r3, #3
30001c8c:	e58d3010 	str	r3, [sp, #16]
	thread->stack_size=stack_size;
30001c90:	e59d301c 	ldr	r3, [sp, #28]
30001c94:	e59d2010 	ldr	r2, [sp, #16]
30001c98:	e583203c 	str	r2, [r3, #60]	; 0x3c
	if(stack!=NULL)
30001c9c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30001ca0:	e3530000 	cmp	r3, #0
30001ca4:	0a000003 	beq	30001cb8 <create_thread_ext+0x84>
		thread->stack_buttom=(acoral_u32 *)stack;
30001ca8:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30001cac:	e59d301c 	ldr	r3, [sp, #28]
30001cb0:	e5832038 	str	r2, [r3, #56]	; 0x38
30001cb4:	ea000002 	b	30001cc4 <create_thread_ext+0x90>
	else
		thread->stack_buttom=NULL;
30001cb8:	e59d301c 	ldr	r3, [sp, #28]
30001cbc:	e3a02000 	mov	r2, #0
30001cc0:	e5832038 	str	r2, [r3, #56]	; 0x38
	thread->policy=sched_policy;
30001cc4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30001cc8:	e20320ff 	and	r2, r3, #255	; 0xff
30001ccc:	e59d301c 	ldr	r3, [sp, #28]
30001cd0:	e5c3200c 	strb	r2, [r3, #12]
	return acoral_policy_thread_init(sched_policy,thread,route,args,data);
30001cd4:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30001cd8:	e58d3000 	str	r3, [sp]
30001cdc:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30001ce0:	e59d101c 	ldr	r1, [sp, #28]
30001ce4:	e59d2014 	ldr	r2, [sp, #20]
30001ce8:	e59d300c 	ldr	r3, [sp, #12]
30001cec:	eb000025 	bl	30001d88 <acoral_policy_thread_init>
30001cf0:	e1a03000 	mov	r3, r0
}
30001cf4:	e1a00003 	mov	r0, r3
30001cf8:	e28dd024 	add	sp, sp, #36	; 0x24
30001cfc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001d00:	e12fff1e 	bx	lr
30001d04:	30045094 	.word	0x30045094

30001d08 <acoral_get_policy_ctrl>:

acoral_sched_policy_t *acoral_get_policy_ctrl(acoral_u8 type){
30001d08:	e24dd018 	sub	sp, sp, #24
30001d0c:	e1a03000 	mov	r3, r0
30001d10:	e5cd3007 	strb	r3, [sp, #7]
	acoral_list_t   *tmp,*head;
	acoral_sched_policy_t  *policy_ctrl;
	head=&policy_list.head;
30001d14:	e59f3068 	ldr	r3, [pc, #104]	; 30001d84 <acoral_get_policy_ctrl+0x7c>
30001d18:	e58d3010 	str	r3, [sp, #16]
	tmp=head;
30001d1c:	e59d3010 	ldr	r3, [sp, #16]
30001d20:	e58d300c 	str	r3, [sp, #12]
	for(tmp=head->next;tmp!=head;tmp=tmp->next){
30001d24:	e59d3010 	ldr	r3, [sp, #16]
30001d28:	e5933000 	ldr	r3, [r3]
30001d2c:	e58d300c 	str	r3, [sp, #12]
30001d30:	ea00000b 	b	30001d64 <acoral_get_policy_ctrl+0x5c>
		policy_ctrl=list_entry(tmp,acoral_sched_policy_t,list);
30001d34:	e59d300c 	ldr	r3, [sp, #12]
30001d38:	e58d3014 	str	r3, [sp, #20]
		if(policy_ctrl->type==type)
30001d3c:	e59d3014 	ldr	r3, [sp, #20]
30001d40:	e5d33008 	ldrb	r3, [r3, #8]
30001d44:	e5dd2007 	ldrb	r2, [sp, #7]
30001d48:	e1520003 	cmp	r2, r3
30001d4c:	1a000001 	bne	30001d58 <acoral_get_policy_ctrl+0x50>
			return policy_ctrl;
30001d50:	e59d3014 	ldr	r3, [sp, #20]
30001d54:	ea000007 	b	30001d78 <acoral_get_policy_ctrl+0x70>
acoral_sched_policy_t *acoral_get_policy_ctrl(acoral_u8 type){
	acoral_list_t   *tmp,*head;
	acoral_sched_policy_t  *policy_ctrl;
	head=&policy_list.head;
	tmp=head;
	for(tmp=head->next;tmp!=head;tmp=tmp->next){
30001d58:	e59d300c 	ldr	r3, [sp, #12]
30001d5c:	e5933000 	ldr	r3, [r3]
30001d60:	e58d300c 	str	r3, [sp, #12]
30001d64:	e59d200c 	ldr	r2, [sp, #12]
30001d68:	e59d3010 	ldr	r3, [sp, #16]
30001d6c:	e1520003 	cmp	r2, r3
30001d70:	1affffef 	bne	30001d34 <acoral_get_policy_ctrl+0x2c>
		policy_ctrl=list_entry(tmp,acoral_sched_policy_t,list);
		if(policy_ctrl->type==type)
			return policy_ctrl;
	}
	return NULL;
30001d74:	e3a03000 	mov	r3, #0
}
30001d78:	e1a00003 	mov	r0, r3
30001d7c:	e28dd018 	add	sp, sp, #24
30001d80:	e12fff1e 	bx	lr
30001d84:	3012d6ac 	.word	0x3012d6ac

30001d88 <acoral_policy_thread_init>:

acoral_id acoral_policy_thread_init(acoral_u32 policy,acoral_thread_t *thread,void (*route)(void *args),void *args,void *data){
30001d88:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001d8c:	e24dd01c 	sub	sp, sp, #28
30001d90:	e58d000c 	str	r0, [sp, #12]
30001d94:	e58d1008 	str	r1, [sp, #8]
30001d98:	e58d2004 	str	r2, [sp, #4]
30001d9c:	e58d3000 	str	r3, [sp]
	acoral_sr cpu_sr;
	acoral_sched_policy_t   *policy_ctrl;
	policy_ctrl=acoral_get_policy_ctrl(policy);	
30001da0:	e59d300c 	ldr	r3, [sp, #12]
30001da4:	e20330ff 	and	r3, r3, #255	; 0xff
30001da8:	e1a00003 	mov	r0, r3
30001dac:	ebffffd5 	bl	30001d08 <acoral_get_policy_ctrl>
30001db0:	e1a03000 	mov	r3, r0
30001db4:	e58d3014 	str	r3, [sp, #20]
	if(policy_ctrl==NULL||policy_ctrl->policy_thread_init==NULL){
30001db8:	e59d3014 	ldr	r3, [sp, #20]
30001dbc:	e3530000 	cmp	r3, #0
30001dc0:	0a000003 	beq	30001dd4 <acoral_policy_thread_init+0x4c>
30001dc4:	e59d3014 	ldr	r3, [sp, #20]
30001dc8:	e593300c 	ldr	r3, [r3, #12]
30001dcc:	e3530000 	cmp	r3, #0
30001dd0:	1a00000e 	bne	30001e10 <acoral_policy_thread_init+0x88>
		HAL_ENTER_CRITICAL();
30001dd4:	ebfffe46 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30001dd8:	e1a03000 	mov	r3, r0
30001ddc:	e58d3010 	str	r3, [sp, #16]
		acoral_release_res((acoral_res_t *)thread);
30001de0:	e59d3008 	ldr	r3, [sp, #8]
30001de4:	e1a00003 	mov	r0, r3
30001de8:	eb000612 	bl	30003638 <acoral_release_res>
		HAL_EXIT_CRITICAL();
30001dec:	e59d0010 	ldr	r0, [sp, #16]
30001df0:	ebfffe3d 	bl	300016ec <HAL_INTR_RESTORE>
		acoral_printerr("No thread policy support:%d\n",thread->policy);
30001df4:	e59d3008 	ldr	r3, [sp, #8]
30001df8:	e5d3300c 	ldrb	r3, [r3, #12]
30001dfc:	e59f0040 	ldr	r0, [pc, #64]	; 30001e44 <acoral_policy_thread_init+0xbc>
30001e00:	e1a01003 	mov	r1, r3
30001e04:	eb00250d 	bl	3000b240 <acoral_print>
		return -1;
30001e08:	e3e03000 	mvn	r3, #0
30001e0c:	ea000008 	b	30001e34 <acoral_policy_thread_init+0xac>
	}
	return policy_ctrl->policy_thread_init(thread,route,args,data);
30001e10:	e59d3014 	ldr	r3, [sp, #20]
30001e14:	e593c00c 	ldr	ip, [r3, #12]
30001e18:	e59d0008 	ldr	r0, [sp, #8]
30001e1c:	e59d1004 	ldr	r1, [sp, #4]
30001e20:	e59d2000 	ldr	r2, [sp]
30001e24:	e59d3020 	ldr	r3, [sp, #32]
30001e28:	e1a0e00f 	mov	lr, pc
30001e2c:	e12fff1c 	bx	ip
30001e30:	e1a03000 	mov	r3, r0
}
30001e34:	e1a00003 	mov	r0, r3
30001e38:	e28dd01c 	add	sp, sp, #28
30001e3c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001e40:	e12fff1e 	bx	lr
30001e44:	300450ac 	.word	0x300450ac

30001e48 <acoral_register_sched_policy>:

void acoral_register_sched_policy(acoral_sched_policy_t *policy){
30001e48:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001e4c:	e24dd00c 	sub	sp, sp, #12
30001e50:	e58d0004 	str	r0, [sp, #4]
	acoral_list_add2_tail(&policy->list,&policy_list.head);
30001e54:	e59d3004 	ldr	r3, [sp, #4]
30001e58:	e1a00003 	mov	r0, r3
30001e5c:	e59f100c 	ldr	r1, [pc, #12]	; 30001e70 <acoral_register_sched_policy+0x28>
30001e60:	eb002064 	bl	30009ff8 <acoral_list_add2_tail>
}
30001e64:	e28dd00c 	add	sp, sp, #12
30001e68:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001e6c:	e12fff1e 	bx	lr
30001e70:	3012d6ac 	.word	0x3012d6ac

30001e74 <acoral_policy_delay_deal>:

void acoral_policy_delay_deal(){
30001e74:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001e78:	e24dd014 	sub	sp, sp, #20
	acoral_list_t   *tmp,*head;
	acoral_sched_policy_t  *policy_ctrl;
	head=&policy_list.head;
30001e7c:	e59f3068 	ldr	r3, [pc, #104]	; 30001eec <acoral_policy_delay_deal+0x78>
30001e80:	e58d3008 	str	r3, [sp, #8]
	tmp=head;
30001e84:	e59d3008 	ldr	r3, [sp, #8]
30001e88:	e58d3004 	str	r3, [sp, #4]
	for(tmp=head->next;tmp!=head;tmp=tmp->next){
30001e8c:	e59d3008 	ldr	r3, [sp, #8]
30001e90:	e5933000 	ldr	r3, [r3]
30001e94:	e58d3004 	str	r3, [sp, #4]
30001e98:	ea00000c 	b	30001ed0 <acoral_policy_delay_deal+0x5c>
		policy_ctrl=list_entry(tmp,acoral_sched_policy_t,list);
30001e9c:	e59d3004 	ldr	r3, [sp, #4]
30001ea0:	e58d300c 	str	r3, [sp, #12]
		if(policy_ctrl->delay_deal!=NULL)
30001ea4:	e59d300c 	ldr	r3, [sp, #12]
30001ea8:	e5933014 	ldr	r3, [r3, #20]
30001eac:	e3530000 	cmp	r3, #0
30001eb0:	0a000003 	beq	30001ec4 <acoral_policy_delay_deal+0x50>
			policy_ctrl->delay_deal();
30001eb4:	e59d300c 	ldr	r3, [sp, #12]
30001eb8:	e5933014 	ldr	r3, [r3, #20]
30001ebc:	e1a0e00f 	mov	lr, pc
30001ec0:	e12fff13 	bx	r3
void acoral_policy_delay_deal(){
	acoral_list_t   *tmp,*head;
	acoral_sched_policy_t  *policy_ctrl;
	head=&policy_list.head;
	tmp=head;
	for(tmp=head->next;tmp!=head;tmp=tmp->next){
30001ec4:	e59d3004 	ldr	r3, [sp, #4]
30001ec8:	e5933000 	ldr	r3, [r3]
30001ecc:	e58d3004 	str	r3, [sp, #4]
30001ed0:	e59d2004 	ldr	r2, [sp, #4]
30001ed4:	e59d3008 	ldr	r3, [sp, #8]
30001ed8:	e1520003 	cmp	r2, r3
30001edc:	1affffee 	bne	30001e9c <acoral_policy_delay_deal+0x28>
		policy_ctrl=list_entry(tmp,acoral_sched_policy_t,list);
		if(policy_ctrl->delay_deal!=NULL)
			policy_ctrl->delay_deal();
	}
}
30001ee0:	e28dd014 	add	sp, sp, #20
30001ee4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001ee8:	e12fff1e 	bx	lr
30001eec:	3012d6ac 	.word	0x3012d6ac

30001ef0 <acoral_policy_thread_release>:

void acoral_policy_thread_release(acoral_thread_t *thread){
30001ef0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30001ef4:	e24dd014 	sub	sp, sp, #20
30001ef8:	e58d0004 	str	r0, [sp, #4]
	acoral_sched_policy_t   *policy_ctrl;
	policy_ctrl=acoral_get_policy_ctrl(thread->policy);
30001efc:	e59d3004 	ldr	r3, [sp, #4]
30001f00:	e5d3300c 	ldrb	r3, [r3, #12]
30001f04:	e1a00003 	mov	r0, r3
30001f08:	ebffff7e 	bl	30001d08 <acoral_get_policy_ctrl>
30001f0c:	e1a03000 	mov	r3, r0
30001f10:	e58d300c 	str	r3, [sp, #12]
	if(policy_ctrl->policy_thread_release!=NULL)
30001f14:	e59d300c 	ldr	r3, [sp, #12]
30001f18:	e5933010 	ldr	r3, [r3, #16]
30001f1c:	e3530000 	cmp	r3, #0
30001f20:	0a000004 	beq	30001f38 <acoral_policy_thread_release+0x48>
		policy_ctrl->policy_thread_release(thread);
30001f24:	e59d300c 	ldr	r3, [sp, #12]
30001f28:	e5933010 	ldr	r3, [r3, #16]
30001f2c:	e59d0004 	ldr	r0, [sp, #4]
30001f30:	e1a0e00f 	mov	lr, pc
30001f34:	e12fff13 	bx	r3
}
30001f38:	e28dd014 	add	sp, sp, #20
30001f3c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30001f40:	e12fff1e 	bx	lr

30001f44 <acoral_sched_policy_init>:


void acoral_sched_policy_init(){
30001f44:	e92d4008 	push	{r3, lr}
	acoral_list_init(&policy_list.head);
30001f48:	e59f302c 	ldr	r3, [pc, #44]	; 30001f7c <acoral_sched_policy_init+0x38>
30001f4c:	e59f2028 	ldr	r2, [pc, #40]	; 30001f7c <acoral_sched_policy_init+0x38>
30001f50:	e5832000 	str	r2, [r3]
30001f54:	e59f3020 	ldr	r3, [pc, #32]	; 30001f7c <acoral_sched_policy_init+0x38>
30001f58:	e59f201c 	ldr	r2, [pc, #28]	; 30001f7c <acoral_sched_policy_init+0x38>
30001f5c:	e5832004 	str	r2, [r3, #4]
	comm_policy_init();
30001f60:	eb000483 	bl	30003174 <comm_policy_init>
#ifdef CFG_THRD_SLICE
	slice_policy_init();
30001f64:	eb001d0d 	bl	300093a0 <slice_policy_init>
#endif
#ifdef CFG_THRD_PERIOD
	period_policy_init();
30001f68:	eb001c4f 	bl	300090ac <period_policy_init>
#endif
#ifdef CFG_THRD_RM
	rm_policy_init();
30001f6c:	eb001ac6 	bl	30008a8c <rm_policy_init>
#endif
#ifdef CFG_THRD_POSIX
	posix_policy_init();
30001f70:	eb001e57 	bl	300098d4 <posix_policy_init>
#endif
}
30001f74:	e8bd4008 	pop	{r3, lr}
30001f78:	e12fff1e 	bx	lr
30001f7c:	3012d6ac 	.word	0x3012d6ac

30001f80 <app_enter_policy_init>:

void app_enter_policy_init(){
30001f80:	e92d4008 	push	{r3, lr}
#ifdef CFG_THRD_RM
	rm_init();
30001f84:	eb001a9b 	bl	300089f8 <rm_init>
#endif
}
30001f88:	e8bd4008 	pop	{r3, lr}
30001f8c:	e12fff1e 	bx	lr

30001f90 <app_exit_policy_init>:

void app_exit_policy_init(){
30001f90:	e92d4008 	push	{r3, lr}
#ifdef CFG_THRD_RM
	rm_end();
30001f94:	eb001ad5 	bl	30008af0 <rm_end>
#endif
}
30001f98:	e8bd4008 	pop	{r3, lr}
30001f9c:	e12fff1e 	bx	lr

30001fa0 <acoral_sched_init>:
#include<lsched.h>
acoral_u8 need_sched[HAL_MAX_CPU];
acoral_u8 sched_lock[HAL_MAX_CPU];
acoral_thread_t *running_thread[HAL_MAX_CPU],*ready_thread[HAL_MAX_CPU];
static acoral_rdy_queue_t acoral_ready_queues[HAL_MAX_CPU];
void acoral_sched_init(){
30001fa0:	e24dd008 	sub	sp, sp, #8
	acoral_u8 i;
	for(i=0;i<HAL_MAX_CPU;i++){
30001fa4:	e3a03000 	mov	r3, #0
30001fa8:	e5cd3007 	strb	r3, [sp, #7]
30001fac:	ea000008 	b	30001fd4 <acoral_sched_init+0x34>
		sched_lock[acoral_current_cpu]=0;
30001fb0:	e59f3030 	ldr	r3, [pc, #48]	; 30001fe8 <acoral_sched_init+0x48>
30001fb4:	e3a02000 	mov	r2, #0
30001fb8:	e5c32000 	strb	r2, [r3]
		need_sched[acoral_current_cpu]=0;
30001fbc:	e59f3028 	ldr	r3, [pc, #40]	; 30001fec <acoral_sched_init+0x4c>
30001fc0:	e3a02000 	mov	r2, #0
30001fc4:	e5c32000 	strb	r2, [r3]
acoral_u8 sched_lock[HAL_MAX_CPU];
acoral_thread_t *running_thread[HAL_MAX_CPU],*ready_thread[HAL_MAX_CPU];
static acoral_rdy_queue_t acoral_ready_queues[HAL_MAX_CPU];
void acoral_sched_init(){
	acoral_u8 i;
	for(i=0;i<HAL_MAX_CPU;i++){
30001fc8:	e5dd3007 	ldrb	r3, [sp, #7]
30001fcc:	e2833001 	add	r3, r3, #1
30001fd0:	e5cd3007 	strb	r3, [sp, #7]
30001fd4:	e5dd3007 	ldrb	r3, [sp, #7]
30001fd8:	e3530000 	cmp	r3, #0
30001fdc:	0afffff3 	beq	30001fb0 <acoral_sched_init+0x10>
		sched_lock[acoral_current_cpu]=0;
		need_sched[acoral_current_cpu]=0;
	}
}
30001fe0:	e28dd008 	add	sp, sp, #8
30001fe4:	e12fff1e 	bx	lr
30001fe8:	300ea488 	.word	0x300ea488
30001fec:	302bf848 	.word	0x302bf848

30001ff0 <acoral_sched_unlock>:

void acoral_sched_unlock(){
30001ff0:	e92d4008 	push	{r3, lr}
	sched_lock[acoral_current_cpu]=0;	
30001ff4:	e59f3010 	ldr	r3, [pc, #16]	; 3000200c <acoral_sched_unlock+0x1c>
30001ff8:	e3a02000 	mov	r2, #0
30001ffc:	e5c32000 	strb	r2, [r3]
	acoral_sched();
30002000:	eb000106 	bl	30002420 <acoral_sched>
}
30002004:	e8bd4008 	pop	{r3, lr}
30002008:	e12fff1e 	bx	lr
3000200c:	300ea488 	.word	0x300ea488

30002010 <acoral_set_orig_thread>:

void acoral_set_orig_thread(acoral_thread_t *thread){
30002010:	e24dd008 	sub	sp, sp, #8
30002014:	e58d0004 	str	r0, [sp, #4]
  	running_thread[acoral_current_cpu]=thread;
30002018:	e59f300c 	ldr	r3, [pc, #12]	; 3000202c <acoral_set_orig_thread+0x1c>
3000201c:	e59d2004 	ldr	r2, [sp, #4]
30002020:	e5832000 	str	r2, [r3]
}
30002024:	e28dd008 	add	sp, sp, #8
30002028:	e12fff1e 	bx	lr
3000202c:	302be818 	.word	0x302be818

30002030 <acoral_set_running_thread>:

void acoral_set_running_thread(acoral_thread_t *thread){
30002030:	e24dd008 	sub	sp, sp, #8
30002034:	e58d0004 	str	r0, [sp, #4]
  	running_thread[acoral_current_cpu]->state&=~ACORAL_THREAD_STATE_RUNNING;
30002038:	e59f3040 	ldr	r3, [pc, #64]	; 30002080 <acoral_set_running_thread+0x50>
3000203c:	e5932000 	ldr	r2, [r3]
30002040:	e59f3038 	ldr	r3, [pc, #56]	; 30002080 <acoral_set_running_thread+0x50>
30002044:	e5933000 	ldr	r3, [r3]
30002048:	e5d33004 	ldrb	r3, [r3, #4]
3000204c:	e20330fb 	and	r3, r3, #251	; 0xfb
30002050:	e5c23004 	strb	r3, [r2, #4]
	thread->state|=ACORAL_THREAD_STATE_RUNNING;
30002054:	e59d3004 	ldr	r3, [sp, #4]
30002058:	e5d33004 	ldrb	r3, [r3, #4]
3000205c:	e3833004 	orr	r3, r3, #4
30002060:	e20320ff 	and	r2, r3, #255	; 0xff
30002064:	e59d3004 	ldr	r3, [sp, #4]
30002068:	e5c32004 	strb	r2, [r3, #4]
  	running_thread[acoral_current_cpu]=thread;
3000206c:	e59f300c 	ldr	r3, [pc, #12]	; 30002080 <acoral_set_running_thread+0x50>
30002070:	e59d2004 	ldr	r2, [sp, #4]
30002074:	e5832000 	str	r2, [r3]
}
30002078:	e28dd008 	add	sp, sp, #8
3000207c:	e12fff1e 	bx	lr
30002080:	302be818 	.word	0x302be818

30002084 <acoral_thread_runqueue_init>:

/*================================
 * func: init acoral_ready_queues 
 *    初始化各个核上的就绪队列 
 *================================*/
void acoral_thread_runqueue_init(){
30002084:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002088:	e24dd014 	sub	sp, sp, #20
	acoral_prio_array_t *array;
	acoral_rdy_queue_t *rdy_queue;
	acoral_u8 cpu;
	/*初始化每个核上的优先级队列*/
	for(cpu=0;cpu<HAL_MAX_CPU;cpu++){
3000208c:	e3a03000 	mov	r3, #0
30002090:	e5cd300f 	strb	r3, [sp, #15]
30002094:	ea000013 	b	300020e8 <acoral_thread_runqueue_init+0x64>
		rdy_queue=acoral_ready_queues+cpu;
30002098:	e5dd200f 	ldrb	r2, [sp, #15]
3000209c:	e1a03002 	mov	r3, r2
300020a0:	e1a03183 	lsl	r3, r3, #3
300020a4:	e0623003 	rsb	r3, r2, r3
300020a8:	e1a03183 	lsl	r3, r3, #3
300020ac:	e0833002 	add	r3, r3, r2
300020b0:	e1a02183 	lsl	r2, r3, #3
300020b4:	e0632002 	rsb	r2, r3, r2
300020b8:	e1a03102 	lsl	r3, r2, #2
300020bc:	e1a02003 	mov	r2, r3
300020c0:	e59f3038 	ldr	r3, [pc, #56]	; 30002100 <acoral_thread_runqueue_init+0x7c>
300020c4:	e0823003 	add	r3, r2, r3
300020c8:	e58d3008 	str	r3, [sp, #8]
		array=&rdy_queue->array;
300020cc:	e59d3008 	ldr	r3, [sp, #8]
300020d0:	e58d3004 	str	r3, [sp, #4]
		acoral_prio_queue_init(array);
300020d4:	e59d0004 	ldr	r0, [sp, #4]
300020d8:	eb001f81 	bl	30009ee4 <acoral_prio_queue_init>
void acoral_thread_runqueue_init(){
	acoral_prio_array_t *array;
	acoral_rdy_queue_t *rdy_queue;
	acoral_u8 cpu;
	/*初始化每个核上的优先级队列*/
	for(cpu=0;cpu<HAL_MAX_CPU;cpu++){
300020dc:	e5dd300f 	ldrb	r3, [sp, #15]
300020e0:	e2833001 	add	r3, r3, #1
300020e4:	e5cd300f 	strb	r3, [sp, #15]
300020e8:	e5dd300f 	ldrb	r3, [sp, #15]
300020ec:	e3530000 	cmp	r3, #0
300020f0:	0affffe8 	beq	30002098 <acoral_thread_runqueue_init+0x14>
		rdy_queue=acoral_ready_queues+cpu;
		array=&rdy_queue->array;
		acoral_prio_queue_init(array);
	}

}
300020f4:	e28dd014 	add	sp, sp, #20
300020f8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300020fc:	e12fff1e 	bx	lr
30002100:	300c9a9c 	.word	0x300c9a9c

30002104 <acoral_get_idlest_cpu>:

/*================================
 *      Get the idlest core 
 *     获取最空闲的cpu核 
 *================================*/
acoral_u32 acoral_get_idlest_cpu(){
30002104:	e24dd010 	sub	sp, sp, #16
  	acoral_u32 cpu,i,count=-1;
30002108:	e3e03000 	mvn	r3, #0
3000210c:	e58d3008 	str	r3, [sp, #8]
	acoral_rdy_queue_t *rdy_queue;
  	for(i=0;i<HAL_MAX_CPU;i++){
30002110:	e3a03000 	mov	r3, #0
30002114:	e58d3004 	str	r3, [sp, #4]
30002118:	ea000019 	b	30002184 <acoral_get_idlest_cpu+0x80>
	    rdy_queue=acoral_ready_queues+i;
3000211c:	e59d2004 	ldr	r2, [sp, #4]
30002120:	e1a03002 	mov	r3, r2
30002124:	e1a03183 	lsl	r3, r3, #3
30002128:	e0623003 	rsb	r3, r2, r3
3000212c:	e1a03183 	lsl	r3, r3, #3
30002130:	e0833002 	add	r3, r3, r2
30002134:	e1a02183 	lsl	r2, r3, #3
30002138:	e0632002 	rsb	r2, r3, r2
3000213c:	e1a03102 	lsl	r3, r2, #2
30002140:	e1a02003 	mov	r2, r3
30002144:	e59f3054 	ldr	r3, [pc, #84]	; 300021a0 <acoral_get_idlest_cpu+0x9c>
30002148:	e0823003 	add	r3, r2, r3
3000214c:	e58d300c 	str	r3, [sp, #12]
	    if(count>rdy_queue->array.num){
30002150:	e59d300c 	ldr	r3, [sp, #12]
30002154:	e5932000 	ldr	r2, [r3]
30002158:	e59d3008 	ldr	r3, [sp, #8]
3000215c:	e1520003 	cmp	r2, r3
30002160:	2a000004 	bcs	30002178 <acoral_get_idlest_cpu+0x74>
	      	count=rdy_queue->array.num;
30002164:	e59d300c 	ldr	r3, [sp, #12]
30002168:	e5933000 	ldr	r3, [r3]
3000216c:	e58d3008 	str	r3, [sp, #8]
		cpu=i;
30002170:	e59d3004 	ldr	r3, [sp, #4]
30002174:	e58d3000 	str	r3, [sp]
 *     获取最空闲的cpu核 
 *================================*/
acoral_u32 acoral_get_idlest_cpu(){
  	acoral_u32 cpu,i,count=-1;
	acoral_rdy_queue_t *rdy_queue;
  	for(i=0;i<HAL_MAX_CPU;i++){
30002178:	e59d3004 	ldr	r3, [sp, #4]
3000217c:	e2833001 	add	r3, r3, #1
30002180:	e58d3004 	str	r3, [sp, #4]
30002184:	e59d3004 	ldr	r3, [sp, #4]
30002188:	e3530000 	cmp	r3, #0
3000218c:	0affffe2 	beq	3000211c <acoral_get_idlest_cpu+0x18>
	    if(count>rdy_queue->array.num){
	      	count=rdy_queue->array.num;
		cpu=i;
	    }
	}
	return cpu;
30002190:	e59d3000 	ldr	r3, [sp]
}
30002194:	e1a00003 	mov	r0, r3
30002198:	e28dd010 	add	sp, sp, #16
3000219c:	e12fff1e 	bx	lr
300021a0:	300c9a9c 	.word	0x300c9a9c

300021a4 <acoral_get_idle_maskcpu>:

acoral_u32 acoral_get_idle_maskcpu(acoral_u32 cpu_mask){
300021a4:	e24dd018 	sub	sp, sp, #24
300021a8:	e58d0004 	str	r0, [sp, #4]
  	acoral_u32 cpu,i,count=-1;
300021ac:	e3e03000 	mvn	r3, #0
300021b0:	e58d3010 	str	r3, [sp, #16]
	acoral_rdy_queue_t *rdy_queue;
  	for(i=0,cpu=0;i<HAL_MAX_CPU;i++){
300021b4:	e3a03000 	mov	r3, #0
300021b8:	e58d300c 	str	r3, [sp, #12]
300021bc:	e3a03000 	mov	r3, #0
300021c0:	e58d3008 	str	r3, [sp, #8]
300021c4:	ea000021 	b	30002250 <acoral_get_idle_maskcpu+0xac>
	    rdy_queue=acoral_ready_queues+i;
300021c8:	e59d200c 	ldr	r2, [sp, #12]
300021cc:	e1a03002 	mov	r3, r2
300021d0:	e1a03183 	lsl	r3, r3, #3
300021d4:	e0623003 	rsb	r3, r2, r3
300021d8:	e1a03183 	lsl	r3, r3, #3
300021dc:	e0833002 	add	r3, r3, r2
300021e0:	e1a02183 	lsl	r2, r3, #3
300021e4:	e0632002 	rsb	r2, r3, r2
300021e8:	e1a03102 	lsl	r3, r2, #2
300021ec:	e1a02003 	mov	r2, r3
300021f0:	e59f3074 	ldr	r3, [pc, #116]	; 3000226c <acoral_get_idle_maskcpu+0xc8>
300021f4:	e0823003 	add	r3, r2, r3
300021f8:	e58d3014 	str	r3, [sp, #20]
	    if(count>rdy_queue->array.num&&(1<<i&cpu_mask)){
300021fc:	e59d3014 	ldr	r3, [sp, #20]
30002200:	e5932000 	ldr	r2, [r3]
30002204:	e59d3010 	ldr	r3, [sp, #16]
30002208:	e1520003 	cmp	r2, r3
3000220c:	2a00000c 	bcs	30002244 <acoral_get_idle_maskcpu+0xa0>
30002210:	e59d300c 	ldr	r3, [sp, #12]
30002214:	e3a02001 	mov	r2, #1
30002218:	e1a03312 	lsl	r3, r2, r3
3000221c:	e1a02003 	mov	r2, r3
30002220:	e59d3004 	ldr	r3, [sp, #4]
30002224:	e0023003 	and	r3, r2, r3
30002228:	e3530000 	cmp	r3, #0
3000222c:	0a000004 	beq	30002244 <acoral_get_idle_maskcpu+0xa0>
	      	count=rdy_queue->array.num;
30002230:	e59d3014 	ldr	r3, [sp, #20]
30002234:	e5933000 	ldr	r3, [r3]
30002238:	e58d3010 	str	r3, [sp, #16]
		cpu=i;
3000223c:	e59d300c 	ldr	r3, [sp, #12]
30002240:	e58d3008 	str	r3, [sp, #8]
}

acoral_u32 acoral_get_idle_maskcpu(acoral_u32 cpu_mask){
  	acoral_u32 cpu,i,count=-1;
	acoral_rdy_queue_t *rdy_queue;
  	for(i=0,cpu=0;i<HAL_MAX_CPU;i++){
30002244:	e59d300c 	ldr	r3, [sp, #12]
30002248:	e2833001 	add	r3, r3, #1
3000224c:	e58d300c 	str	r3, [sp, #12]
30002250:	e59d300c 	ldr	r3, [sp, #12]
30002254:	e3530000 	cmp	r3, #0
30002258:	0affffda 	beq	300021c8 <acoral_get_idle_maskcpu+0x24>
	    if(count>rdy_queue->array.num&&(1<<i&cpu_mask)){
	      	count=rdy_queue->array.num;
		cpu=i;
	    }
	}
	return cpu;
3000225c:	e59d3008 	ldr	r3, [sp, #8]
}
30002260:	e1a00003 	mov	r0, r3
30002264:	e28dd018 	add	sp, sp, #24
30002268:	e12fff1e 	bx	lr
3000226c:	300c9a9c 	.word	0x300c9a9c

30002270 <acoral_rdyqueue_add>:

/*================================
 * func: add thread to acoral_ready_queues
 *    将线程挂到就绪队列上
 *================================*/
void acoral_rdyqueue_add(acoral_thread_t *thread){
30002270:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002274:	e24dd014 	sub	sp, sp, #20
30002278:	e58d0004 	str	r0, [sp, #4]
	acoral_rdy_queue_t *rdy_queue;
	acoral_u8 cpu;
	cpu=thread->cpu;
3000227c:	e59d3004 	ldr	r3, [sp, #4]
30002280:	e5d33006 	ldrb	r3, [r3, #6]
30002284:	e5cd300f 	strb	r3, [sp, #15]
	rdy_queue=acoral_ready_queues+cpu;
30002288:	e5dd200f 	ldrb	r2, [sp, #15]
3000228c:	e1a03002 	mov	r3, r2
30002290:	e1a03183 	lsl	r3, r3, #3
30002294:	e0623003 	rsb	r3, r2, r3
30002298:	e1a03183 	lsl	r3, r3, #3
3000229c:	e0833002 	add	r3, r3, r2
300022a0:	e1a02183 	lsl	r2, r3, #3
300022a4:	e0632002 	rsb	r2, r3, r2
300022a8:	e1a03102 	lsl	r3, r2, #2
300022ac:	e1a02003 	mov	r2, r3
300022b0:	e59f308c 	ldr	r3, [pc, #140]	; 30002344 <acoral_rdyqueue_add+0xd4>
300022b4:	e0823003 	add	r3, r2, r3
300022b8:	e58d3008 	str	r3, [sp, #8]
	acoral_prio_queue_add(&rdy_queue->array,thread->prio,&thread->ready);
300022bc:	e59d1008 	ldr	r1, [sp, #8]
300022c0:	e59d3004 	ldr	r3, [sp, #4]
300022c4:	e5d33005 	ldrb	r3, [r3, #5]
300022c8:	e1a02003 	mov	r2, r3
300022cc:	e59d3004 	ldr	r3, [sp, #4]
300022d0:	e2833010 	add	r3, r3, #16
300022d4:	e1a00001 	mov	r0, r1
300022d8:	e1a01002 	mov	r1, r2
300022dc:	e1a02003 	mov	r2, r3
300022e0:	eb001eaa 	bl	30009d90 <acoral_prio_queue_add>
	thread->state&=~ACORAL_THREAD_STATE_SUSPEND;
300022e4:	e59d3004 	ldr	r3, [sp, #4]
300022e8:	e5d33004 	ldrb	r3, [r3, #4]
300022ec:	e20330fd 	and	r3, r3, #253	; 0xfd
300022f0:	e59d2004 	ldr	r2, [sp, #4]
300022f4:	e5c23004 	strb	r3, [r2, #4]
	thread->state|=ACORAL_THREAD_STATE_READY;
300022f8:	e59d3004 	ldr	r3, [sp, #4]
300022fc:	e5d33004 	ldrb	r3, [r3, #4]
30002300:	e3833001 	orr	r3, r3, #1
30002304:	e20320ff 	and	r2, r3, #255	; 0xff
30002308:	e59d3004 	ldr	r3, [sp, #4]
3000230c:	e5c32004 	strb	r2, [r3, #4]
	thread->res.id=thread->res.id|cpu<<ACORAL_RES_CPU_BIT;
30002310:	e59d3004 	ldr	r3, [sp, #4]
30002314:	e5932000 	ldr	r2, [r3]
30002318:	e5dd300f 	ldrb	r3, [sp, #15]
3000231c:	e1a03c03 	lsl	r3, r3, #24
30002320:	e1822003 	orr	r2, r2, r3
30002324:	e59d3004 	ldr	r3, [sp, #4]
30002328:	e5832000 	str	r2, [r3]
	acoral_set_need_sched(true);
3000232c:	e59f3014 	ldr	r3, [pc, #20]	; 30002348 <acoral_rdyqueue_add+0xd8>
30002330:	e3a02001 	mov	r2, #1
30002334:	e5c32000 	strb	r2, [r3]
}
30002338:	e28dd014 	add	sp, sp, #20
3000233c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002340:	e12fff1e 	bx	lr
30002344:	300c9a9c 	.word	0x300c9a9c
30002348:	302bf848 	.word	0x302bf848

3000234c <acoral_rdyqueue_del>:

/*================================
 * func: remove thread from acoral_ready_queues 
 *    将线程从就绪队列上取下
 *================================*/
void acoral_rdyqueue_del(acoral_thread_t *thread){
3000234c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002350:	e24dd014 	sub	sp, sp, #20
30002354:	e58d0004 	str	r0, [sp, #4]
	acoral_8 cpu;
	acoral_rdy_queue_t *rdy_queue;
	cpu=thread->cpu;
30002358:	e59d3004 	ldr	r3, [sp, #4]
3000235c:	e5d33006 	ldrb	r3, [r3, #6]
30002360:	e5cd300b 	strb	r3, [sp, #11]
	rdy_queue=acoral_ready_queues+cpu;
30002364:	e1dd20db 	ldrsb	r2, [sp, #11]
30002368:	e1a03002 	mov	r3, r2
3000236c:	e1a03183 	lsl	r3, r3, #3
30002370:	e0623003 	rsb	r3, r2, r3
30002374:	e1a03183 	lsl	r3, r3, #3
30002378:	e0833002 	add	r3, r3, r2
3000237c:	e1a02183 	lsl	r2, r3, #3
30002380:	e0632002 	rsb	r2, r3, r2
30002384:	e1a03102 	lsl	r3, r2, #2
30002388:	e1a02003 	mov	r2, r3
3000238c:	e59f3084 	ldr	r3, [pc, #132]	; 30002418 <acoral_rdyqueue_del+0xcc>
30002390:	e0823003 	add	r3, r2, r3
30002394:	e58d300c 	str	r3, [sp, #12]
        acoral_prio_queue_del(&rdy_queue->array,thread->prio,&thread->ready);
30002398:	e59d100c 	ldr	r1, [sp, #12]
3000239c:	e59d3004 	ldr	r3, [sp, #4]
300023a0:	e5d33005 	ldrb	r3, [r3, #5]
300023a4:	e1a02003 	mov	r2, r3
300023a8:	e59d3004 	ldr	r3, [sp, #4]
300023ac:	e2833010 	add	r3, r3, #16
300023b0:	e1a00001 	mov	r0, r1
300023b4:	e1a01002 	mov	r1, r2
300023b8:	e1a02003 	mov	r2, r3
300023bc:	eb001e95 	bl	30009e18 <acoral_prio_queue_del>
	thread->state&=~ACORAL_THREAD_STATE_READY;
300023c0:	e59d3004 	ldr	r3, [sp, #4]
300023c4:	e5d33004 	ldrb	r3, [r3, #4]
300023c8:	e20330fe 	and	r3, r3, #254	; 0xfe
300023cc:	e59d2004 	ldr	r2, [sp, #4]
300023d0:	e5c23004 	strb	r3, [r2, #4]
	thread->state&=~ACORAL_THREAD_STATE_RUNNING;
300023d4:	e59d3004 	ldr	r3, [sp, #4]
300023d8:	e5d33004 	ldrb	r3, [r3, #4]
300023dc:	e20330fb 	and	r3, r3, #251	; 0xfb
300023e0:	e59d2004 	ldr	r2, [sp, #4]
300023e4:	e5c23004 	strb	r3, [r2, #4]
	thread->state|=ACORAL_THREAD_STATE_SUSPEND;
300023e8:	e59d3004 	ldr	r3, [sp, #4]
300023ec:	e5d33004 	ldrb	r3, [r3, #4]
300023f0:	e3833002 	orr	r3, r3, #2
300023f4:	e20320ff 	and	r2, r3, #255	; 0xff
300023f8:	e59d3004 	ldr	r3, [sp, #4]
300023fc:	e5c32004 	strb	r2, [r3, #4]
	/*设置线程所在的核可调度*/
	acoral_set_need_sched(true);
30002400:	e59f3014 	ldr	r3, [pc, #20]	; 3000241c <acoral_rdyqueue_del+0xd0>
30002404:	e3a02001 	mov	r2, #1
30002408:	e5c32000 	strb	r2, [r3]
}
3000240c:	e28dd014 	add	sp, sp, #20
30002410:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002414:	e12fff1e 	bx	lr
30002418:	300c9a9c 	.word	0x300c9a9c
3000241c:	302bf848 	.word	0x302bf848

30002420 <acoral_sched>:

/*================================
 * func: sched thread in acoral
 *         调度线程
 *================================*/
void acoral_sched(){
30002420:	e92d4008 	push	{r3, lr}
	/*如果不需要调度，则返回*/
	if(!acoral_need_sched)
30002424:	e59f3068 	ldr	r3, [pc, #104]	; 30002494 <acoral_sched+0x74>
30002428:	e5d33000 	ldrb	r3, [r3]
3000242c:	e3530000 	cmp	r3, #0
30002430:	0a00000e 	beq	30002470 <acoral_sched+0x50>
		return;

	if(acoral_intr_nesting)
30002434:	ebfffcc9 	bl	30001760 <hal_get_intr_nesting_comm>
30002438:	e1a03000 	mov	r3, r0
3000243c:	e3530000 	cmp	r3, #0
30002440:	1a00000c 	bne	30002478 <acoral_sched+0x58>
		return;

	if(acoral_sched_is_lock)
30002444:	e59f304c 	ldr	r3, [pc, #76]	; 30002498 <acoral_sched+0x78>
30002448:	e5d33000 	ldrb	r3, [r3]
3000244c:	e3530000 	cmp	r3, #0
30002450:	1a00000a 	bne	30002480 <acoral_sched+0x60>
		return;
	/*如果还没有开始调度，则返回*/
	if(!acoral_start_sched)
30002454:	e59f3040 	ldr	r3, [pc, #64]	; 3000249c <acoral_sched+0x7c>
30002458:	e5933000 	ldr	r3, [r3]
3000245c:	e3530000 	cmp	r3, #0
30002460:	0a000008 	beq	30002488 <acoral_sched+0x68>
	  	return;
	/*这个函数进行简单处理后会直接或间接调用acoral_real_sched,或者acoral_real_intr_sched*/
	HAL_SCHED_BRIDGE(); 
30002464:	ebfffcda 	bl	300017d4 <hal_sched_bridge_comm>
	return;
30002468:	e1a00000 	nop			; (mov r0, r0)
3000246c:	ea000006 	b	3000248c <acoral_sched+0x6c>
 *         调度线程
 *================================*/
void acoral_sched(){
	/*如果不需要调度，则返回*/
	if(!acoral_need_sched)
		return;
30002470:	e1a00000 	nop			; (mov r0, r0)
30002474:	ea000004 	b	3000248c <acoral_sched+0x6c>

	if(acoral_intr_nesting)
		return;
30002478:	e1a00000 	nop			; (mov r0, r0)
3000247c:	ea000002 	b	3000248c <acoral_sched+0x6c>

	if(acoral_sched_is_lock)
		return;
30002480:	e1a00000 	nop			; (mov r0, r0)
30002484:	ea000000 	b	3000248c <acoral_sched+0x6c>
	/*如果还没有开始调度，则返回*/
	if(!acoral_start_sched)
	  	return;
30002488:	e1a00000 	nop			; (mov r0, r0)
	/*这个函数进行简单处理后会直接或间接调用acoral_real_sched,或者acoral_real_intr_sched*/
	HAL_SCHED_BRIDGE(); 
	return;
}
3000248c:	e8bd4008 	pop	{r3, lr}
30002490:	e12fff1e 	bx	lr
30002494:	302bf848 	.word	0x302bf848
30002498:	300ea488 	.word	0x300ea488
3000249c:	300c9a98 	.word	0x300c9a98

300024a0 <acoral_real_sched>:
/*================================
 * func: sched thread in acoral
 *        进程上下文调度实现
 *        这个函数必须是原子操作
 *================================*/
void acoral_real_sched(){
300024a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300024a4:	e24dd00c 	sub	sp, sp, #12
	acoral_thread_t *prev;
	acoral_thread_t *next;
	acoral_set_need_sched(false);
300024a8:	e59f3090 	ldr	r3, [pc, #144]	; 30002540 <acoral_real_sched+0xa0>
300024ac:	e3a02000 	mov	r2, #0
300024b0:	e5c32000 	strb	r2, [r3]
	prev=acoral_cur_thread;
300024b4:	e59f3088 	ldr	r3, [pc, #136]	; 30002544 <acoral_real_sched+0xa4>
300024b8:	e5933000 	ldr	r3, [r3]
300024bc:	e58d3000 	str	r3, [sp]
	/*选择最高优先级线程*/
	acoral_select_thread();
300024c0:	eb00004c 	bl	300025f8 <acoral_select_thread>
	next=acoral_ready_thread;
300024c4:	e59f307c 	ldr	r3, [pc, #124]	; 30002548 <acoral_real_sched+0xa8>
300024c8:	e5933000 	ldr	r3, [r3]
300024cc:	e58d3004 	str	r3, [sp, #4]
	if(prev!=next){
300024d0:	e59d2000 	ldr	r2, [sp]
300024d4:	e59d3004 	ldr	r3, [sp, #4]
300024d8:	e1520003 	cmp	r2, r3
300024dc:	0a000014 	beq	30002534 <acoral_real_sched+0x94>
	    acoral_set_running_thread(next);
300024e0:	e59d0004 	ldr	r0, [sp, #4]
300024e4:	ebfffed1 	bl	30002030 <acoral_set_running_thread>
	    if(prev->state==ACORAL_THREAD_STATE_EXIT){
300024e8:	e59d3000 	ldr	r3, [sp]
300024ec:	e5d33004 	ldrb	r3, [r3, #4]
300024f0:	e3530008 	cmp	r3, #8
300024f4:	1a000007 	bne	30002518 <acoral_real_sched+0x78>
		  prev->state=ACORAL_THREAD_STATE_RELEASE;
300024f8:	e59d3000 	ldr	r3, [sp]
300024fc:	e3a02010 	mov	r2, #16
30002500:	e5c32004 	strb	r2, [r3, #4]
  		  HAL_SWITCH_TO(&next->stack);
30002504:	e59d3004 	ldr	r3, [sp, #4]
30002508:	e2833034 	add	r3, r3, #52	; 0x34
3000250c:	e1a00003 	mov	r0, r3
30002510:	ebfffc1d 	bl	3000158c <HAL_SWITCH_TO>
		  return;
30002514:	ea000006 	b	30002534 <acoral_real_sched+0x94>
  		  HAL_MOVE_SWITCH_TO(&prev->move_lock,0,&next->stack);
		  return;
	    }
#endif
	    /*线程切换*/
	    HAL_CONTEXT_SWITCH(&prev->stack,&next->stack);
30002518:	e59d3000 	ldr	r3, [sp]
3000251c:	e2832034 	add	r2, r3, #52	; 0x34
30002520:	e59d3004 	ldr	r3, [sp, #4]
30002524:	e2833034 	add	r3, r3, #52	; 0x34
30002528:	e1a00002 	mov	r0, r2
3000252c:	e1a01003 	mov	r1, r3
30002530:	ebfffc43 	bl	30001644 <HAL_CONTEXT_SWITCH>
	}
}
30002534:	e28dd00c 	add	sp, sp, #12
30002538:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000253c:	e12fff1e 	bx	lr
30002540:	302bf848 	.word	0x302bf848
30002544:	302be818 	.word	0x302be818
30002548:	302be26c 	.word	0x302be26c

3000254c <acoral_real_intr_sched>:
/*================================
 * func: sched thread in acoral
 *        中断上下文调度实现
 *        这个函数必须是原子操作
 *================================*/
void acoral_real_intr_sched(){
3000254c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002550:	e24dd00c 	sub	sp, sp, #12
	acoral_thread_t *prev;
	acoral_thread_t *next;
	acoral_set_need_sched(false);
30002554:	e59f3090 	ldr	r3, [pc, #144]	; 300025ec <acoral_real_intr_sched+0xa0>
30002558:	e3a02000 	mov	r2, #0
3000255c:	e5c32000 	strb	r2, [r3]
	prev=acoral_cur_thread;
30002560:	e59f3088 	ldr	r3, [pc, #136]	; 300025f0 <acoral_real_intr_sched+0xa4>
30002564:	e5933000 	ldr	r3, [r3]
30002568:	e58d3000 	str	r3, [sp]
	/*选择最高优先级线程*/
	acoral_select_thread();
3000256c:	eb000021 	bl	300025f8 <acoral_select_thread>
	next=acoral_ready_thread;
30002570:	e59f307c 	ldr	r3, [pc, #124]	; 300025f4 <acoral_real_intr_sched+0xa8>
30002574:	e5933000 	ldr	r3, [r3]
30002578:	e58d3004 	str	r3, [sp, #4]
	if(prev!=next){
3000257c:	e59d2000 	ldr	r2, [sp]
30002580:	e59d3004 	ldr	r3, [sp, #4]
30002584:	e1520003 	cmp	r2, r3
30002588:	0a000014 	beq	300025e0 <acoral_real_intr_sched+0x94>
	    acoral_set_running_thread(next);
3000258c:	e59d0004 	ldr	r0, [sp, #4]
30002590:	ebfffea6 	bl	30002030 <acoral_set_running_thread>
	    if(prev->state==ACORAL_THREAD_STATE_EXIT){
30002594:	e59d3000 	ldr	r3, [sp]
30002598:	e5d33004 	ldrb	r3, [r3, #4]
3000259c:	e3530008 	cmp	r3, #8
300025a0:	1a000007 	bne	300025c4 <acoral_real_intr_sched+0x78>
		  prev->state=ACORAL_THREAD_STATE_RELEASE;
300025a4:	e59d3000 	ldr	r3, [sp]
300025a8:	e3a02010 	mov	r2, #16
300025ac:	e5c32004 	strb	r2, [r3, #4]
  		  HAL_INTR_SWITCH_TO(&next->stack);
300025b0:	e59d3004 	ldr	r3, [sp, #4]
300025b4:	e2833034 	add	r3, r3, #52	; 0x34
300025b8:	e1a00003 	mov	r0, r3
300025bc:	ebfffbf6 	bl	3000159c <HAL_INTR_SWITCH_TO>
		  return;
300025c0:	ea000006 	b	300025e0 <acoral_real_intr_sched+0x94>
  		  HAL_MOVE_SWITCH_TO(&prev->move_lock,0,&next->stack);
		  return;
	    }
#endif
	    /*线程切换*/
	    HAL_INTR_CTX_SWITCH(&prev->stack,&next->stack);
300025c4:	e59d3000 	ldr	r3, [sp]
300025c8:	e2832034 	add	r2, r3, #52	; 0x34
300025cc:	e59d3004 	ldr	r3, [sp, #4]
300025d0:	e2833034 	add	r3, r3, #52	; 0x34
300025d4:	e1a00002 	mov	r0, r2
300025d8:	e1a01003 	mov	r1, r3
300025dc:	ebfffbfe 	bl	300015dc <HAL_INTR_CTX_SWITCH>
	}
}
300025e0:	e28dd00c 	add	sp, sp, #12
300025e4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300025e8:	e12fff1e 	bx	lr
300025ec:	302bf848 	.word	0x302bf848
300025f0:	302be818 	.word	0x302be818
300025f4:	302be26c 	.word	0x302be26c

300025f8 <acoral_select_thread>:

/*================================
 * func: sched thread in acoral
 *     选择优先级最高的线程
 *================================*/
void acoral_select_thread(){
300025f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300025fc:	e24dd024 	sub	sp, sp, #36	; 0x24
	acoral_rdy_queue_t *rdy_queue;
	acoral_prio_array_t *array;
	acoral_list_t *head;
	acoral_thread_t *thread;
	acoral_queue_t *queue;
	cpu=acoral_current_cpu;
30002600:	e3a03000 	mov	r3, #0
30002604:	e5cd3007 	strb	r3, [sp, #7]
	rdy_queue=acoral_ready_queues+cpu;
30002608:	e5dd2007 	ldrb	r2, [sp, #7]
3000260c:	e1a03002 	mov	r3, r2
30002610:	e1a03183 	lsl	r3, r3, #3
30002614:	e0623003 	rsb	r3, r2, r3
30002618:	e1a03183 	lsl	r3, r3, #3
3000261c:	e0833002 	add	r3, r3, r2
30002620:	e1a02183 	lsl	r2, r3, #3
30002624:	e0632002 	rsb	r2, r3, r2
30002628:	e1a03102 	lsl	r3, r2, #2
3000262c:	e1a02003 	mov	r2, r3
30002630:	e59f3084 	ldr	r3, [pc, #132]	; 300026bc <acoral_select_thread+0xc4>
30002634:	e0823003 	add	r3, r2, r3
30002638:	e58d300c 	str	r3, [sp, #12]
	array=&rdy_queue->array;
3000263c:	e59d300c 	ldr	r3, [sp, #12]
30002640:	e58d3010 	str	r3, [sp, #16]
	/*找出就绪队列中优先级最高的线程的优先级*/
	index = acoral_get_highprio(array);
30002644:	e59d0010 	ldr	r0, [sp, #16]
30002648:	eb001e18 	bl	30009eb0 <acoral_get_highprio>
3000264c:	e1a03000 	mov	r3, r0
30002650:	e58d3008 	str	r3, [sp, #8]
	queue = array->queue + index;
30002654:	e59d3010 	ldr	r3, [sp, #16]
30002658:	e2831018 	add	r1, r3, #24
3000265c:	e59d2008 	ldr	r2, [sp, #8]
30002660:	e1a03002 	mov	r3, r2
30002664:	e1a03083 	lsl	r3, r3, #1
30002668:	e0833002 	add	r3, r3, r2
3000266c:	e1a03103 	lsl	r3, r3, #2
30002670:	e0813003 	add	r3, r1, r3
30002674:	e58d301c 	str	r3, [sp, #28]
	head=&queue->head;
30002678:	e59d301c 	ldr	r3, [sp, #28]
3000267c:	e58d3014 	str	r3, [sp, #20]
	thread=list_entry(head->next, acoral_thread_t, ready);
30002680:	e59d3014 	ldr	r3, [sp, #20]
30002684:	e5933000 	ldr	r3, [r3]
30002688:	e2433010 	sub	r3, r3, #16
3000268c:	e58d3018 	str	r3, [sp, #24]
	ACORAL_ASSERT(thread,"Aseert:In select thread");
30002690:	e59d2018 	ldr	r2, [sp, #24]
30002694:	e59f3024 	ldr	r3, [pc, #36]	; 300026c0 <acoral_select_thread+0xc8>
30002698:	e1a00002 	mov	r0, r2
3000269c:	e1a01003 	mov	r1, r3
300026a0:	eb00056b 	bl	30003c54 <acoral_assert_res>
	acoral_set_ready_thread(thread);
300026a4:	e59f3018 	ldr	r3, [pc, #24]	; 300026c4 <acoral_select_thread+0xcc>
300026a8:	e59d2018 	ldr	r2, [sp, #24]
300026ac:	e5832000 	str	r2, [r3]
}
300026b0:	e28dd024 	add	sp, sp, #36	; 0x24
300026b4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300026b8:	e12fff1e 	bx	lr
300026bc:	300c9a9c 	.word	0x300c9a9c
300026c0:	300450cc 	.word	0x300450cc
300026c4:	302be26c 	.word	0x302be26c

300026c8 <acoral_release_thread1>:
 * func: release thread in acoral
 *	
 *   thread     
 *    
 *================================*/
void acoral_release_thread1(acoral_thread_t *thread){
300026c8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300026cc:	e24dd01c 	sub	sp, sp, #28
300026d0:	e58d0004 	str	r0, [sp, #4]
	acoral_list_t *head,*tmp;
	acoral_thread_t *daem;
	thread->state=ACORAL_THREAD_STATE_EXIT;
300026d4:	e59d3004 	ldr	r3, [sp, #4]
300026d8:	e3a02008 	mov	r2, #8
300026dc:	e5c32004 	strb	r2, [r3, #4]
	head=&acoral_res_release_queue.head;
300026e0:	e59f304c 	ldr	r3, [pc, #76]	; 30002734 <acoral_release_thread1+0x6c>
300026e4:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&head->lock);
	tmp=head->prev;
300026e8:	e59d300c 	ldr	r3, [sp, #12]
300026ec:	e5933004 	ldr	r3, [r3, #4]
300026f0:	e58d3010 	str	r3, [sp, #16]
	if(tmp!=head)
		acoral_spin_lock(&tmp->lock);
	acoral_list_add2_tail(&thread->waiting,head);
300026f4:	e59d3004 	ldr	r3, [sp, #4]
300026f8:	e2833020 	add	r3, r3, #32
300026fc:	e1a00003 	mov	r0, r3
30002700:	e59d100c 	ldr	r1, [sp, #12]
30002704:	eb001e3b 	bl	30009ff8 <acoral_list_add2_tail>
	if(tmp!=head)
		acoral_spin_unlock(&tmp->lock);
	acoral_spin_unlock(&head->lock);
	daem=(acoral_thread_t *)acoral_get_res_by_id(daemon_id);
30002708:	e59f3028 	ldr	r3, [pc, #40]	; 30002738 <acoral_release_thread1+0x70>
3000270c:	e5933000 	ldr	r3, [r3]
30002710:	e1a00003 	mov	r0, r3
30002714:	eb00045b 	bl	30003888 <acoral_get_res_by_id>
30002718:	e1a03000 	mov	r3, r0
3000271c:	e58d3014 	str	r3, [sp, #20]
	acoral_rdy_thread(daem);
30002720:	e59d0014 	ldr	r0, [sp, #20]
30002724:	eb000117 	bl	30002b88 <acoral_rdy_thread>
}
30002728:	e28dd01c 	add	sp, sp, #28
3000272c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002730:	e12fff1e 	bx	lr
30002734:	3012aca0 	.word	0x3012aca0
30002738:	3012ac88 	.word	0x3012ac88

3000273c <acoral_release_thread>:
/*================================
 * func: release thread in acoral
 *	
 *   thread     
 *================================*/
void acoral_release_thread(acoral_res_t *res){
3000273c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002740:	e24dd014 	sub	sp, sp, #20
30002744:	e58d0004 	str	r0, [sp, #4]
	acoral_thread_t *thread;
	thread=(acoral_thread_t *)res;
30002748:	e59d3004 	ldr	r3, [sp, #4]
3000274c:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&acoral_threads_queue.head.lock);
	acoral_list_del(&thread->global_list);
30002750:	e59d300c 	ldr	r3, [sp, #12]
30002754:	e2833028 	add	r3, r3, #40	; 0x28
30002758:	e1a00003 	mov	r0, r3
3000275c:	eb001e38 	bl	3000a044 <acoral_list_del>
	acoral_spin_unlock(&acoral_threads_queue.head.lock);
#ifdef CFG_TEST
	acoral_print("Release %s thread\n",thread->name);
#endif
	acoral_policy_thread_release(thread);
30002760:	e59d000c 	ldr	r0, [sp, #12]
30002764:	ebfffde1 	bl	30001ef0 <acoral_policy_thread_release>
  	acoral_free((void *)thread->stack_buttom);
30002768:	e59d300c 	ldr	r3, [sp, #12]
3000276c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
30002770:	e1a00003 	mov	r0, r3
30002774:	eb000f4b 	bl	300064a8 <buddy_free>
	acoral_release_res((acoral_res_t *)thread);
30002778:	e59d300c 	ldr	r3, [sp, #12]
3000277c:	e1a00003 	mov	r0, r3
30002780:	eb0003ac 	bl	30003638 <acoral_release_res>
}
30002784:	e28dd014 	add	sp, sp, #20
30002788:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000278c:	e12fff1e 	bx	lr

30002790 <acoral_suspend_thread>:
 * func: suspend thread in acoral
 *         	
 * thread(TCB) 	
 *================================*/

void acoral_suspend_thread(acoral_thread_t *thread){
30002790:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002794:	e24dd014 	sub	sp, sp, #20
30002798:	e58d0004 	str	r0, [sp, #4]
	acoral_sr cpu_sr;
	acoral_8 cpu;
	if(!(ACORAL_THREAD_STATE_READY&thread->state))
3000279c:	e59d3004 	ldr	r3, [sp, #4]
300027a0:	e5d33004 	ldrb	r3, [r3, #4]
300027a4:	e2033001 	and	r3, r3, #1
300027a8:	e3530000 	cmp	r3, #0
300027ac:	0a000008 	beq	300027d4 <acoral_suspend_thread+0x44>
	if(cpu!=acoral_current_cpu){
	  	acoral_ipi_cmd_send(cpu,ACORAL_IPI_THREAD_SUSPEND,thread->res.id,NULL);
		return;
	}
#endif
	HAL_ENTER_CRITICAL();
300027b0:	ebfffbcf 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300027b4:	e1a03000 	mov	r3, r0
300027b8:	e58d3008 	str	r3, [sp, #8]
	/**/
	acoral_rdyqueue_del(thread);
300027bc:	e59d0004 	ldr	r0, [sp, #4]
300027c0:	ebfffee1 	bl	3000234c <acoral_rdyqueue_del>
	HAL_EXIT_CRITICAL();
300027c4:	e59d0008 	ldr	r0, [sp, #8]
300027c8:	ebfffbc7 	bl	300016ec <HAL_INTR_RESTORE>
	/**/
	acoral_sched();
300027cc:	ebffff13 	bl	30002420 <acoral_sched>
300027d0:	ea000000 	b	300027d8 <acoral_suspend_thread+0x48>

void acoral_suspend_thread(acoral_thread_t *thread){
	acoral_sr cpu_sr;
	acoral_8 cpu;
	if(!(ACORAL_THREAD_STATE_READY&thread->state))
		return;
300027d4:	e1a00000 	nop			; (mov r0, r0)
	/**/
	acoral_rdyqueue_del(thread);
	HAL_EXIT_CRITICAL();
	/**/
	acoral_sched();
}
300027d8:	e28dd014 	add	sp, sp, #20
300027dc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300027e0:	e12fff1e 	bx	lr

300027e4 <acoral_suspend_self>:

/*================================
 * func: suspend thread in acoral
 *      	
 *================================*/
void acoral_suspend_self(){
300027e4:	e92d4008 	push	{r3, lr}
	acoral_suspend_thread(acoral_cur_thread);
300027e8:	e59f3010 	ldr	r3, [pc, #16]	; 30002800 <acoral_suspend_self+0x1c>
300027ec:	e5933000 	ldr	r3, [r3]
300027f0:	e1a00003 	mov	r0, r3
300027f4:	ebffffe5 	bl	30002790 <acoral_suspend_thread>
}
300027f8:	e8bd4008 	pop	{r3, lr}
300027fc:	e12fff1e 	bx	lr
30002800:	302be818 	.word	0x302be818

30002804 <acoral_suspend_thread_by_id>:
 * func: suspend thread in acoral
 *      ID	
 *      thread_idID
 *================================*/

void acoral_suspend_thread_by_id(acoral_u32 thread_id){
30002804:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002808:	e24dd014 	sub	sp, sp, #20
3000280c:	e58d0004 	str	r0, [sp, #4]
	acoral_thread_t *thread=(acoral_thread_t *)acoral_get_res_by_id(thread_id);
30002810:	e59d3004 	ldr	r3, [sp, #4]
30002814:	e1a00003 	mov	r0, r3
30002818:	eb00041a 	bl	30003888 <acoral_get_res_by_id>
3000281c:	e1a03000 	mov	r3, r0
30002820:	e58d300c 	str	r3, [sp, #12]
	acoral_suspend_thread(thread);
30002824:	e59d000c 	ldr	r0, [sp, #12]
30002828:	ebffffd8 	bl	30002790 <acoral_suspend_thread>
}
3000282c:	e28dd014 	add	sp, sp, #20
30002830:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002834:	e12fff1e 	bx	lr

30002838 <acoral_resume_thread_by_id>:
 * func: resume thread in acoral
 *         	
 *   thread_idID
 *================================*/

void acoral_resume_thread_by_id(acoral_u32 thread_id){
30002838:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000283c:	e24dd014 	sub	sp, sp, #20
30002840:	e58d0004 	str	r0, [sp, #4]
	acoral_thread_t *thread=(acoral_thread_t *)acoral_get_res_by_id(thread_id);
30002844:	e59d3004 	ldr	r3, [sp, #4]
30002848:	e1a00003 	mov	r0, r3
3000284c:	eb00040d 	bl	30003888 <acoral_get_res_by_id>
30002850:	e1a03000 	mov	r3, r0
30002854:	e58d300c 	str	r3, [sp, #12]
	acoral_resume_thread(thread);
30002858:	e59d000c 	ldr	r0, [sp, #12]
3000285c:	eb000002 	bl	3000286c <acoral_resume_thread>
}
30002860:	e28dd014 	add	sp, sp, #20
30002864:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002868:	e12fff1e 	bx	lr

3000286c <acoral_resume_thread>:
/*================================
 * func: resume thread in acoral
 *         	
 * thread(TCB) 	
 *================================*/
void acoral_resume_thread(acoral_thread_t *thread){
3000286c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002870:	e24dd014 	sub	sp, sp, #20
30002874:	e58d0004 	str	r0, [sp, #4]
	acoral_sr cpu_sr;
	acoral_8 cpu;
	if(!(thread->state&ACORAL_THREAD_STATE_SUSPEND))
30002878:	e59d3004 	ldr	r3, [sp, #4]
3000287c:	e5d33004 	ldrb	r3, [r3, #4]
30002880:	e2033002 	and	r3, r3, #2
30002884:	e3530000 	cmp	r3, #0
30002888:	0a000008 	beq	300028b0 <acoral_resume_thread+0x44>
	if(cpu!=acoral_current_cpu){
	  	acoral_ipi_cmd_send(cpu,ACORAL_IPI_THREAD_RESUME,thread->res.id,NULL);
		return;
	}
#endif
	HAL_ENTER_CRITICAL();
3000288c:	ebfffb98 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30002890:	e1a03000 	mov	r3, r0
30002894:	e58d3008 	str	r3, [sp, #8]
	/**/
	acoral_rdyqueue_add(thread);
30002898:	e59d0004 	ldr	r0, [sp, #4]
3000289c:	ebfffe73 	bl	30002270 <acoral_rdyqueue_add>
	HAL_EXIT_CRITICAL();
300028a0:	e59d0008 	ldr	r0, [sp, #8]
300028a4:	ebfffb90 	bl	300016ec <HAL_INTR_RESTORE>
	/**/
	acoral_sched();
300028a8:	ebfffedc 	bl	30002420 <acoral_sched>
300028ac:	ea000000 	b	300028b4 <acoral_resume_thread+0x48>
 *================================*/
void acoral_resume_thread(acoral_thread_t *thread){
	acoral_sr cpu_sr;
	acoral_8 cpu;
	if(!(thread->state&ACORAL_THREAD_STATE_SUSPEND))
		return;
300028b0:	e1a00000 	nop			; (mov r0, r0)
	/**/
	acoral_rdyqueue_add(thread);
	HAL_EXIT_CRITICAL();
	/**/
	acoral_sched();
}
300028b4:	e28dd014 	add	sp, sp, #20
300028b8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300028bc:	e12fff1e 	bx	lr

300028c0 <acoral_delay_thread>:
 *         	
 * thread(TCB) 	
 * timems	
 *      
 *================================*/
static void acoral_delay_thread(acoral_thread_t* thread,acoral_time time){
300028c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300028c4:	e24dd014 	sub	sp, sp, #20
300028c8:	e58d0004 	str	r0, [sp, #4]
300028cc:	e58d1000 	str	r1, [sp]
	acoral_u32 real_ticks;
	if(!acoral_list_empty(&thread->waiting)){
300028d0:	e59d3004 	ldr	r3, [sp, #4]
300028d4:	e5932020 	ldr	r2, [r3, #32]
300028d8:	e59d3004 	ldr	r3, [sp, #4]
300028dc:	e2833020 	add	r3, r3, #32
300028e0:	e1520003 	cmp	r2, r3
300028e4:	1a000012 	bne	30002934 <acoral_delay_thread+0x74>
		return;
	}
#endif
	/*timeticks*/
	/*real_ticks=time*ACORAL_TICKS_PER_SEC/1000;*/
	real_ticks = TIME_TO_TICKS(time);
300028e8:	e59d2000 	ldr	r2, [sp]
300028ec:	e1a03002 	mov	r3, r2
300028f0:	e1a03103 	lsl	r3, r3, #2
300028f4:	e0833002 	add	r3, r3, r2
300028f8:	e1a02103 	lsl	r2, r3, #2
300028fc:	e0833002 	add	r3, r3, r2
30002900:	e1a03103 	lsl	r3, r3, #2
30002904:	e1a02003 	mov	r2, r3
30002908:	e59f3034 	ldr	r3, [pc, #52]	; 30002944 <acoral_delay_thread+0x84>
3000290c:	e0831392 	umull	r1, r3, r2, r3
30002910:	e1a03323 	lsr	r3, r3, #6
30002914:	e58d300c 	str	r3, [sp, #12]
	thread->delay=real_ticks;
30002918:	e59d200c 	ldr	r2, [sp, #12]
3000291c:	e59d3004 	ldr	r3, [sp, #4]
30002920:	e5832040 	str	r2, [r3, #64]	; 0x40
	/**/
	acoral_delayqueue_add(&time_delay_queue,thread);
30002924:	e59f001c 	ldr	r0, [pc, #28]	; 30002948 <acoral_delay_thread+0x88>
30002928:	e59d1004 	ldr	r1, [sp, #4]
3000292c:	eb000729 	bl	300045d8 <acoral_delayqueue_add>
30002930:	ea000000 	b	30002938 <acoral_delay_thread+0x78>
 *      
 *================================*/
static void acoral_delay_thread(acoral_thread_t* thread,acoral_time time){
	acoral_u32 real_ticks;
	if(!acoral_list_empty(&thread->waiting)){
		return;	
30002934:	e1a00000 	nop			; (mov r0, r0)
	/*real_ticks=time*ACORAL_TICKS_PER_SEC/1000;*/
	real_ticks = TIME_TO_TICKS(time);
	thread->delay=real_ticks;
	/**/
	acoral_delayqueue_add(&time_delay_queue,thread);
}
30002938:	e28dd014 	add	sp, sp, #20
3000293c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002940:	e12fff1e 	bx	lr
30002944:	10624dd3 	.word	0x10624dd3
30002948:	3012d720 	.word	0x3012d720

3000294c <acoral_delay_thread_by_id>:
 *         	
 * thread_idID 	
 * timems	
 *      
 *================================*/
static void acoral_delay_thread_by_id(acoral_time time,acoral_id thread_id){
3000294c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002950:	e24dd014 	sub	sp, sp, #20
30002954:	e58d0004 	str	r0, [sp, #4]
30002958:	e58d1000 	str	r1, [sp]
	acoral_thread_t *thread=(acoral_thread_t *)acoral_get_res_by_id(thread_id);
3000295c:	e59d0000 	ldr	r0, [sp]
30002960:	eb0003c8 	bl	30003888 <acoral_get_res_by_id>
30002964:	e1a03000 	mov	r3, r0
30002968:	e58d300c 	str	r3, [sp, #12]
	acoral_delay_thread(thread,time);
3000296c:	e59d000c 	ldr	r0, [sp, #12]
30002970:	e59d1004 	ldr	r1, [sp, #4]
30002974:	ebffffd1 	bl	300028c0 <acoral_delay_thread>
}
30002978:	e28dd014 	add	sp, sp, #20
3000297c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002980:	e12fff1e 	bx	lr

30002984 <acoral_delay_self>:
/*================================
 * func: delay current thread in acoral
 *         	
 * timems	
 *================================*/
void acoral_delay_self(acoral_time time){
30002984:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002988:	e24dd00c 	sub	sp, sp, #12
3000298c:	e58d0004 	str	r0, [sp, #4]
	acoral_delay_thread(acoral_cur_thread,time);
30002990:	e59f3018 	ldr	r3, [pc, #24]	; 300029b0 <acoral_delay_self+0x2c>
30002994:	e5933000 	ldr	r3, [r3]
30002998:	e1a00003 	mov	r0, r3
3000299c:	e59d1004 	ldr	r1, [sp, #4]
300029a0:	ebffffc6 	bl	300028c0 <acoral_delay_thread>
}
300029a4:	e28dd00c 	add	sp, sp, #12
300029a8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300029ac:	e12fff1e 	bx	lr
300029b0:	302be818 	.word	0x302be818

300029b4 <acoral_kill_thread>:
/*================================
 * func: kill thread in acoral
 *         	
 * thread(TCB) 	
 *================================*/
void acoral_kill_thread(acoral_thread_t *thread){
300029b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300029b8:	e24dd01c 	sub	sp, sp, #28
300029bc:	e58d0004 	str	r0, [sp, #4]
	if(cpu!=acoral_current_cpu){
	  	acoral_ipi_cmd_send(cpu,ACORAL_IPI_THREAD_KILL,thread->res.id,NULL);
		return;
	}
#endif
	HAL_ENTER_CRITICAL();
300029c0:	ebfffb4b 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300029c4:	e1a03000 	mov	r3, r0
300029c8:	e58d300c 	str	r3, [sp, #12]
        /*	*/
        /*	*/
	if(thread->state&ACORAL_THREAD_STATE_SUSPEND){
300029cc:	e59d3004 	ldr	r3, [sp, #4]
300029d0:	e5d33004 	ldrb	r3, [r3, #4]
300029d4:	e2033002 	and	r3, r3, #2
300029d8:	e3530000 	cmp	r3, #0
300029dc:	0a000011 	beq	30002a28 <acoral_kill_thread+0x74>
		evt=thread->evt;
300029e0:	e59d3004 	ldr	r3, [sp, #4]
300029e4:	e5933030 	ldr	r3, [r3, #48]	; 0x30
300029e8:	e58d3014 	str	r3, [sp, #20]
		/**/
		if(thread->state&ACORAL_THREAD_STATE_DELAY){
300029ec:	e59d3004 	ldr	r3, [sp, #4]
300029f0:	e5d33004 	ldrb	r3, [r3, #4]
300029f4:	e2033020 	and	r3, r3, #32
300029f8:	e3530000 	cmp	r3, #0
300029fc:	0a000004 	beq	30002a14 <acoral_kill_thread+0x60>
			acoral_spin_lock(&thread->waiting.prev->lock);
			acoral_spin_lock(&thread->waiting.lock);
			acoral_list_del(&thread->waiting);
30002a00:	e59d3004 	ldr	r3, [sp, #4]
30002a04:	e2833020 	add	r3, r3, #32
30002a08:	e1a00003 	mov	r0, r3
30002a0c:	eb001d8c 	bl	3000a044 <acoral_list_del>
30002a10:	ea000004 	b	30002a28 <acoral_kill_thread+0x74>
			acoral_spin_unlock(&thread->waiting.lock);
			acoral_spin_unlock(&thread->waiting.prev->lock);
		}else
		{
			/**/
			if(evt!=NULL){
30002a14:	e59d3014 	ldr	r3, [sp, #20]
30002a18:	e3530000 	cmp	r3, #0
30002a1c:	0a000001 	beq	30002a28 <acoral_kill_thread+0x74>
				acoral_spin_lock(&evt->spin_lock);
				acoral_evt_queue_del(thread);
30002a20:	e59d0004 	ldr	r0, [sp, #4]
30002a24:	eb0008d7 	bl	30004d88 <acoral_evt_queue_del>
				acoral_spin_unlock(&evt->spin_lock);
			}
		}
	}
	acoral_unrdy_thread(thread);
30002a28:	e59d0004 	ldr	r0, [sp, #4]
30002a2c:	eb000064 	bl	30002bc4 <acoral_unrdy_thread>
	acoral_release_thread1(thread);
30002a30:	e59d0004 	ldr	r0, [sp, #4]
30002a34:	ebffff23 	bl	300026c8 <acoral_release_thread1>
      	HAL_EXIT_CRITICAL();
30002a38:	e59d000c 	ldr	r0, [sp, #12]
30002a3c:	ebfffb2a 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sched();
30002a40:	ebfffe76 	bl	30002420 <acoral_sched>
}
30002a44:	e28dd01c 	add	sp, sp, #28
30002a48:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002a4c:	e12fff1e 	bx	lr

30002a50 <acoral_kill_thread_by_id>:
/*================================
 * func: kill thread in acoral
 *         	
 * thread_idID 	
 *================================*/
void acoral_kill_thread_by_id(acoral_id id){
30002a50:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002a54:	e24dd014 	sub	sp, sp, #20
30002a58:	e58d0004 	str	r0, [sp, #4]
	acoral_thread_t *thread;
	thread=(acoral_thread_t *)acoral_get_res_by_id(id);
30002a5c:	e59d0004 	ldr	r0, [sp, #4]
30002a60:	eb000388 	bl	30003888 <acoral_get_res_by_id>
30002a64:	e1a03000 	mov	r3, r0
30002a68:	e58d300c 	str	r3, [sp, #12]
	acoral_kill_thread(thread);
30002a6c:	e59d000c 	ldr	r0, [sp, #12]
30002a70:	ebffffcf 	bl	300029b4 <acoral_kill_thread>
}
30002a74:	e28dd014 	add	sp, sp, #20
30002a78:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002a7c:	e12fff1e 	bx	lr

30002a80 <acoral_thread_exit>:

/*================================
 * func: kill current thread in acoral
 *         	
 *================================*/
void acoral_thread_exit(){
30002a80:	e92d4008 	push	{r3, lr}
        acoral_kill_thread(acoral_cur_thread);
30002a84:	e59f3010 	ldr	r3, [pc, #16]	; 30002a9c <acoral_thread_exit+0x1c>
30002a88:	e5933000 	ldr	r3, [r3]
30002a8c:	e1a00003 	mov	r0, r3
30002a90:	ebffffc7 	bl	300029b4 <acoral_kill_thread>
}
30002a94:	e8bd4008 	pop	{r3, lr}
30002a98:	e12fff1e 	bx	lr
30002a9c:	302be818 	.word	0x302be818

30002aa0 <acoral_thread_change_prio>:

/*===========================
 *    change thread's prio
 *    
 *===========================*/
void acoral_thread_change_prio(acoral_thread_t* thread, acoral_u32 prio){
30002aa0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002aa4:	e24dd014 	sub	sp, sp, #20
30002aa8:	e58d0004 	str	r0, [sp, #4]
30002aac:	e58d1000 	str	r1, [sp]
	if(cpu!=acoral_current_cpu){
	  	acoral_ipi_cmd_send(cpu,ACORAL_IPI_THREAD_CHG_PRIO,thread->res.id,(void *)prio);
		return;
	}
#endif
	HAL_ENTER_CRITICAL();
30002ab0:	ebfffb0f 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30002ab4:	e1a03000 	mov	r3, r0
30002ab8:	e58d3008 	str	r3, [sp, #8]
	if(thread->state&ACORAL_THREAD_STATE_READY){
30002abc:	e59d3004 	ldr	r3, [sp, #4]
30002ac0:	e5d33004 	ldrb	r3, [r3, #4]
30002ac4:	e2033001 	and	r3, r3, #1
30002ac8:	e20330ff 	and	r3, r3, #255	; 0xff
30002acc:	e3530000 	cmp	r3, #0
30002ad0:	0a000008 	beq	30002af8 <acoral_thread_change_prio+0x58>
		acoral_rdyqueue_del(thread);
30002ad4:	e59d0004 	ldr	r0, [sp, #4]
30002ad8:	ebfffe1b 	bl	3000234c <acoral_rdyqueue_del>
		thread->prio = prio;
30002adc:	e59d3000 	ldr	r3, [sp]
30002ae0:	e20320ff 	and	r2, r3, #255	; 0xff
30002ae4:	e59d3004 	ldr	r3, [sp, #4]
30002ae8:	e5c32005 	strb	r2, [r3, #5]
		acoral_rdyqueue_add(thread);
30002aec:	e59d0004 	ldr	r0, [sp, #4]
30002af0:	ebfffdde 	bl	30002270 <acoral_rdyqueue_add>
30002af4:	ea000003 	b	30002b08 <acoral_thread_change_prio+0x68>
	}else
		thread->prio = prio;
30002af8:	e59d3000 	ldr	r3, [sp]
30002afc:	e20320ff 	and	r2, r3, #255	; 0xff
30002b00:	e59d3004 	ldr	r3, [sp, #4]
30002b04:	e5c32005 	strb	r2, [r3, #5]
	HAL_EXIT_CRITICAL();
30002b08:	e59d0008 	ldr	r0, [sp, #8]
30002b0c:	ebfffaf6 	bl	300016ec <HAL_INTR_RESTORE>
}
30002b10:	e28dd014 	add	sp, sp, #20
30002b14:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002b18:	e12fff1e 	bx	lr

30002b1c <acoral_change_prio_self>:

/*===========================
 *    change current thread's prio
 *    
 *===========================*/
void acoral_change_prio_self(acoral_u32 prio){
30002b1c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002b20:	e24dd00c 	sub	sp, sp, #12
30002b24:	e58d0004 	str	r0, [sp, #4]
	acoral_thread_change_prio(acoral_cur_thread, prio);
30002b28:	e59f3018 	ldr	r3, [pc, #24]	; 30002b48 <acoral_change_prio_self+0x2c>
30002b2c:	e5933000 	ldr	r3, [r3]
30002b30:	e1a00003 	mov	r0, r3
30002b34:	e59d1004 	ldr	r1, [sp, #4]
30002b38:	ebffffd8 	bl	30002aa0 <acoral_thread_change_prio>
}
30002b3c:	e28dd00c 	add	sp, sp, #12
30002b40:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002b44:	e12fff1e 	bx	lr
30002b48:	302be818 	.word	0x302be818

30002b4c <acoral_thread_change_prio_by_id>:

/*===========================
 *    change thread's prio
 *    ID
 *===========================*/
void acoral_thread_change_prio_by_id(acoral_u32 thread_id, acoral_u32 prio){
30002b4c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002b50:	e24dd014 	sub	sp, sp, #20
30002b54:	e58d0004 	str	r0, [sp, #4]
30002b58:	e58d1000 	str	r1, [sp]
	acoral_thread_t *thread=(acoral_thread_t *)acoral_get_res_by_id(thread_id);
30002b5c:	e59d3004 	ldr	r3, [sp, #4]
30002b60:	e1a00003 	mov	r0, r3
30002b64:	eb000347 	bl	30003888 <acoral_get_res_by_id>
30002b68:	e1a03000 	mov	r3, r0
30002b6c:	e58d300c 	str	r3, [sp, #12]
	acoral_thread_change_prio(thread, prio);
30002b70:	e59d000c 	ldr	r0, [sp, #12]
30002b74:	e59d1000 	ldr	r1, [sp]
30002b78:	ebffffc8 	bl	30002aa0 <acoral_thread_change_prio>
}
30002b7c:	e28dd014 	add	sp, sp, #20
30002b80:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002b84:	e12fff1e 	bx	lr

30002b88 <acoral_rdy_thread>:
 * func: ready thread in acoral
 *  ,
 * thread(TCB) 	
 *================================*/

void acoral_rdy_thread(acoral_thread_t *thread){
30002b88:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002b8c:	e24dd014 	sub	sp, sp, #20
30002b90:	e58d0004 	str	r0, [sp, #4]
	acoral_8 cpu;
	if(!(ACORAL_THREAD_STATE_SUSPEND&thread->state))
30002b94:	e59d3004 	ldr	r3, [sp, #4]
30002b98:	e5d33004 	ldrb	r3, [r3, #4]
30002b9c:	e2033002 	and	r3, r3, #2
30002ba0:	e3530000 	cmp	r3, #0
30002ba4:	0a000002 	beq	30002bb4 <acoral_rdy_thread+0x2c>
	  	acoral_ipi_cmd_send(cpu,ACORAL_IPI_THREAD_RESUME,thread->res.id,NULL);
		return;
	}
#endif
	/**/
	acoral_rdyqueue_add(thread);
30002ba8:	e59d0004 	ldr	r0, [sp, #4]
30002bac:	ebfffdaf 	bl	30002270 <acoral_rdyqueue_add>
30002bb0:	ea000000 	b	30002bb8 <acoral_rdy_thread+0x30>
 *================================*/

void acoral_rdy_thread(acoral_thread_t *thread){
	acoral_8 cpu;
	if(!(ACORAL_THREAD_STATE_SUSPEND&thread->state))
		return;
30002bb4:	e1a00000 	nop			; (mov r0, r0)
		return;
	}
#endif
	/**/
	acoral_rdyqueue_add(thread);
}
30002bb8:	e28dd014 	add	sp, sp, #20
30002bbc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002bc0:	e12fff1e 	bx	lr

30002bc4 <acoral_unrdy_thread>:
 *     ,
 * thread(TCB) 	
 *
 *================================*/

void acoral_unrdy_thread(acoral_thread_t *thread){
30002bc4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002bc8:	e24dd014 	sub	sp, sp, #20
30002bcc:	e58d0004 	str	r0, [sp, #4]
	acoral_8 cpu;
	if(!(ACORAL_THREAD_STATE_READY&thread->state))
30002bd0:	e59d3004 	ldr	r3, [sp, #4]
30002bd4:	e5d33004 	ldrb	r3, [r3, #4]
30002bd8:	e2033001 	and	r3, r3, #1
30002bdc:	e3530000 	cmp	r3, #0
30002be0:	0a000002 	beq	30002bf0 <acoral_unrdy_thread+0x2c>
	  	acoral_ipi_cmd_send(cpu,ACORAL_IPI_THREAD_SUSPEND,thread->res.id,NULL);
		return;
	}
#endif
	/**/
	acoral_rdyqueue_del(thread);
30002be4:	e59d0004 	ldr	r0, [sp, #4]
30002be8:	ebfffdd7 	bl	3000234c <acoral_rdyqueue_del>
30002bec:	ea000000 	b	30002bf4 <acoral_unrdy_thread+0x30>
 *================================*/

void acoral_unrdy_thread(acoral_thread_t *thread){
	acoral_8 cpu;
	if(!(ACORAL_THREAD_STATE_READY&thread->state))
		return;
30002bf0:	e1a00000 	nop			; (mov r0, r0)
		return;
	}
#endif
	/**/
	acoral_rdyqueue_del(thread);
}
30002bf4:	e28dd014 	add	sp, sp, #20
30002bf8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002bfc:	e12fff1e 	bx	lr

30002c00 <acoral_thread_move2_tail>:

void acoral_thread_move2_tail(acoral_thread_t *thread){
30002c00:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002c04:	e24dd014 	sub	sp, sp, #20
30002c08:	e58d0004 	str	r0, [sp, #4]
	if(cpu!=acoral_current_cpu){
	  	acoral_ipi_cmd_send(cpu,ACORAL_IPI_THREAD_MOVE2_TAIL,thread->res.id,NULL);
		return;
	}
#endif
	HAL_ENTER_CRITICAL();
30002c0c:	ebfffab8 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30002c10:	e1a03000 	mov	r3, r0
30002c14:	e58d300c 	str	r3, [sp, #12]
	acoral_unrdy_thread(thread);
30002c18:	e59d0004 	ldr	r0, [sp, #4]
30002c1c:	ebffffe8 	bl	30002bc4 <acoral_unrdy_thread>
	acoral_rdy_thread(thread);
30002c20:	e59d0004 	ldr	r0, [sp, #4]
30002c24:	ebffffd7 	bl	30002b88 <acoral_rdy_thread>
	HAL_EXIT_CRITICAL();
30002c28:	e59d000c 	ldr	r0, [sp, #12]
30002c2c:	ebfffaae 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sched();
30002c30:	ebfffdfa 	bl	30002420 <acoral_sched>
}
30002c34:	e28dd014 	add	sp, sp, #20
30002c38:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002c3c:	e12fff1e 	bx	lr

30002c40 <acoral_thread_move2_tail_by_id>:

void acoral_thread_move2_tail_by_id(acoral_id thread_id){
30002c40:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002c44:	e24dd014 	sub	sp, sp, #20
30002c48:	e58d0004 	str	r0, [sp, #4]
	acoral_thread_t *thread=(acoral_thread_t *)acoral_get_res_by_id(thread_id);
30002c4c:	e59d0004 	ldr	r0, [sp, #4]
30002c50:	eb00030c 	bl	30003888 <acoral_get_res_by_id>
30002c54:	e1a03000 	mov	r3, r0
30002c58:	e58d300c 	str	r3, [sp, #12]
	acoral_thread_move2_tail(thread);
30002c5c:	e59d000c 	ldr	r0, [sp, #12]
30002c60:	ebffffe6 	bl	30002c00 <acoral_thread_move2_tail>
}
30002c64:	e28dd014 	add	sp, sp, #20
30002c68:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002c6c:	e12fff1e 	bx	lr

30002c70 <acoral_alloc_thread>:

/*================================
 * func: alloc thread struct data in acoral
 *     TCB
 *================================*/
acoral_thread_t *acoral_alloc_thread(){
30002c70:	e92d4008 	push	{r3, lr}
  	return (acoral_thread_t *)acoral_get_res(&acoral_thread_pool_ctrl);
30002c74:	e59f0010 	ldr	r0, [pc, #16]	; 30002c8c <acoral_alloc_thread+0x1c>
30002c78:	eb000223 	bl	3000350c <acoral_get_res>
30002c7c:	e1a03000 	mov	r3, r0
}
30002c80:	e1a00003 	mov	r0, r3
30002c84:	e8bd4008 	pop	{r3, lr}
30002c88:	e12fff1e 	bx	lr
30002c8c:	300eaab4 	.word	0x300eaab4

30002c90 <acoral_thread_init>:
 * in:   (*exit)   (acoral_thread_exit)
 *       stack_size 
 *       args       
 *       name       
 *================================*/
acoral_err acoral_thread_init(acoral_thread_t *thread,void (*route)(void *args),void (*exit)(void),void *args){
30002c90:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002c94:	e24dd01c 	sub	sp, sp, #28
30002c98:	e58d000c 	str	r0, [sp, #12]
30002c9c:	e58d1008 	str	r1, [sp, #8]
30002ca0:	e58d2004 	str	r2, [sp, #4]
30002ca4:	e58d3000 	str	r3, [sp]
	acoral_sr cpu_sr;
	acoral_u32 stack_size=thread->stack_size;
30002ca8:	e59d300c 	ldr	r3, [sp, #12]
30002cac:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
30002cb0:	e58d3014 	str	r3, [sp, #20]
	if(thread->stack_buttom==NULL){
30002cb4:	e59d300c 	ldr	r3, [sp, #12]
30002cb8:	e5933038 	ldr	r3, [r3, #56]	; 0x38
30002cbc:	e3530000 	cmp	r3, #0
30002cc0:	1a000015 	bne	30002d1c <acoral_thread_init+0x8c>
		if(stack_size<ACORAL_MIN_STACK_SIZE)
30002cc4:	e59d2014 	ldr	r2, [sp, #20]
30002cc8:	e3a03eff 	mov	r3, #4080	; 0xff0
30002ccc:	e283300f 	add	r3, r3, #15
30002cd0:	e1520003 	cmp	r2, r3
30002cd4:	8a000001 	bhi	30002ce0 <acoral_thread_init+0x50>
			stack_size=ACORAL_MIN_STACK_SIZE;
30002cd8:	e3a03a01 	mov	r3, #4096	; 0x1000
30002cdc:	e58d3014 	str	r3, [sp, #20]
		thread->stack_buttom=(acoral_u32 *)acoral_malloc(stack_size);
30002ce0:	e59d0014 	ldr	r0, [sp, #20]
30002ce4:	eb000db7 	bl	300063c8 <buddy_malloc>
30002ce8:	e1a03000 	mov	r3, r0
30002cec:	e1a02003 	mov	r2, r3
30002cf0:	e59d300c 	ldr	r3, [sp, #12]
30002cf4:	e5832038 	str	r2, [r3, #56]	; 0x38
		if(thread->stack_buttom==NULL)
30002cf8:	e59d300c 	ldr	r3, [sp, #12]
30002cfc:	e5933038 	ldr	r3, [r3, #56]	; 0x38
30002d00:	e3530000 	cmp	r3, #0
30002d04:	1a000001 	bne	30002d10 <acoral_thread_init+0x80>
			return ACORAL_ERR_THREAD_NO_STACK;
30002d08:	e3a03016 	mov	r3, #22
30002d0c:	ea000064 	b	30002ea4 <acoral_thread_init+0x214>
		thread->stack_size=stack_size;
30002d10:	e59d300c 	ldr	r3, [sp, #12]
30002d14:	e59d2014 	ldr	r2, [sp, #20]
30002d18:	e583203c 	str	r2, [r3, #60]	; 0x3c
	}
	thread->stack=(acoral_u32 *)((acoral_8 *)thread->stack_buttom+stack_size-4);
30002d1c:	e59d300c 	ldr	r3, [sp, #12]
30002d20:	e5932038 	ldr	r2, [r3, #56]	; 0x38
30002d24:	e59d3014 	ldr	r3, [sp, #20]
30002d28:	e2433004 	sub	r3, r3, #4
30002d2c:	e0822003 	add	r2, r2, r3
30002d30:	e59d300c 	ldr	r3, [sp, #12]
30002d34:	e5832034 	str	r2, [r3, #52]	; 0x34
	HAL_STACK_INIT(&thread->stack,route,exit,args);
30002d38:	e59d300c 	ldr	r3, [sp, #12]
30002d3c:	e2833034 	add	r3, r3, #52	; 0x34
30002d40:	e1a00003 	mov	r0, r3
30002d44:	e59d1008 	ldr	r1, [sp, #8]
30002d48:	e59d2004 	ldr	r2, [sp, #4]
30002d4c:	e59d3000 	ldr	r3, [sp]
30002d50:	ebfff55a 	bl	300002c0 <hal_stack_init>
	/*cpu_mask*/
	if(thread->cpu_mask==-1)
30002d54:	e59d300c 	ldr	r3, [sp, #12]
30002d58:	e5933008 	ldr	r3, [r3, #8]
30002d5c:	e3730001 	cmn	r3, #1
30002d60:	1a000002 	bne	30002d70 <acoral_thread_init+0xe0>
		thread->cpu_mask=0xefffffff;
30002d64:	e59d300c 	ldr	r3, [sp, #12]
30002d68:	e3e02201 	mvn	r2, #268435456	; 0x10000000
30002d6c:	e5832008 	str	r2, [r3, #8]
	if(thread->cpu<0)
30002d70:	e59d300c 	ldr	r3, [sp, #12]
30002d74:	e5d33006 	ldrb	r3, [r3, #6]
30002d78:	e1a03c03 	lsl	r3, r3, #24
30002d7c:	e1a03c43 	asr	r3, r3, #24
30002d80:	e3530000 	cmp	r3, #0
30002d84:	aa000007 	bge	30002da8 <acoral_thread_init+0x118>
	      thread->cpu=acoral_get_idle_maskcpu(thread->cpu_mask);
30002d88:	e59d300c 	ldr	r3, [sp, #12]
30002d8c:	e5933008 	ldr	r3, [r3, #8]
30002d90:	e1a00003 	mov	r0, r3
30002d94:	ebfffd02 	bl	300021a4 <acoral_get_idle_maskcpu>
30002d98:	e1a03000 	mov	r3, r0
30002d9c:	e20320ff 	and	r2, r3, #255	; 0xff
30002da0:	e59d300c 	ldr	r3, [sp, #12]
30002da4:	e5c32006 	strb	r2, [r3, #6]
	if(thread->cpu>=HAL_MAX_CPU)
30002da8:	e59d300c 	ldr	r3, [sp, #12]
30002dac:	e5d33006 	ldrb	r3, [r3, #6]
30002db0:	e1a03c03 	lsl	r3, r3, #24
30002db4:	e1a03c43 	asr	r3, r3, #24
30002db8:	e3530000 	cmp	r3, #0
30002dbc:	da000002 	ble	30002dcc <acoral_thread_init+0x13c>
		thread->cpu=HAL_MAX_CPU-1;
30002dc0:	e59d300c 	ldr	r3, [sp, #12]
30002dc4:	e3a02000 	mov	r2, #0
30002dc8:	e5c32006 	strb	r2, [r3, #6]
	thread->data=NULL;
30002dcc:	e59d300c 	ldr	r3, [sp, #12]
30002dd0:	e3a02000 	mov	r2, #0
30002dd4:	e5832054 	str	r2, [r3, #84]	; 0x54
	thread->state=ACORAL_THREAD_STATE_SUSPEND;
30002dd8:	e59d300c 	ldr	r3, [sp, #12]
30002ddc:	e3a02002 	mov	r2, #2
30002de0:	e5c32004 	strb	r2, [r3, #4]
	/*继承父线程的console_id*/
	thread->console_id=acoral_cur_thread->console_id;
30002de4:	e59f30c8 	ldr	r3, [pc, #200]	; 30002eb4 <acoral_thread_init+0x224>
30002de8:	e5933000 	ldr	r3, [r3]
30002dec:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
30002df0:	e59d300c 	ldr	r3, [sp, #12]
30002df4:	e583204c 	str	r2, [r3, #76]	; 0x4c
	acoral_init_list(&thread->waiting);
30002df8:	e59d300c 	ldr	r3, [sp, #12]
30002dfc:	e2832020 	add	r2, r3, #32
30002e00:	e59d300c 	ldr	r3, [sp, #12]
30002e04:	e5832020 	str	r2, [r3, #32]
30002e08:	e59d300c 	ldr	r3, [sp, #12]
30002e0c:	e2832020 	add	r2, r3, #32
30002e10:	e59d300c 	ldr	r3, [sp, #12]
30002e14:	e5832024 	str	r2, [r3, #36]	; 0x24
	acoral_init_list(&thread->ready);
30002e18:	e59d300c 	ldr	r3, [sp, #12]
30002e1c:	e2832010 	add	r2, r3, #16
30002e20:	e59d300c 	ldr	r3, [sp, #12]
30002e24:	e5832010 	str	r2, [r3, #16]
30002e28:	e59d300c 	ldr	r3, [sp, #12]
30002e2c:	e2832010 	add	r2, r3, #16
30002e30:	e59d300c 	ldr	r3, [sp, #12]
30002e34:	e5832014 	str	r2, [r3, #20]
	acoral_init_list(&thread->timeout);
30002e38:	e59d300c 	ldr	r3, [sp, #12]
30002e3c:	e2832018 	add	r2, r3, #24
30002e40:	e59d300c 	ldr	r3, [sp, #12]
30002e44:	e5832018 	str	r2, [r3, #24]
30002e48:	e59d300c 	ldr	r3, [sp, #12]
30002e4c:	e2832018 	add	r2, r3, #24
30002e50:	e59d300c 	ldr	r3, [sp, #12]
30002e54:	e583201c 	str	r2, [r3, #28]
	acoral_init_list(&thread->global_list);
30002e58:	e59d300c 	ldr	r3, [sp, #12]
30002e5c:	e2832028 	add	r2, r3, #40	; 0x28
30002e60:	e59d300c 	ldr	r3, [sp, #12]
30002e64:	e5832028 	str	r2, [r3, #40]	; 0x28
30002e68:	e59d300c 	ldr	r3, [sp, #12]
30002e6c:	e2832028 	add	r2, r3, #40	; 0x28
30002e70:	e59d300c 	ldr	r3, [sp, #12]
30002e74:	e583202c 	str	r2, [r3, #44]	; 0x2c
	acoral_spin_init(&thread->timeout.lock);
	acoral_spin_init(&thread->waiting.lock);
	acoral_spin_init(&thread->ready.lock);
	acoral_spin_init(&thread->move_lock);
	HAL_ENTER_CRITICAL();
30002e78:	ebfffa1d 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30002e7c:	e1a03000 	mov	r3, r0
30002e80:	e58d3010 	str	r3, [sp, #16]
	acoral_spin_lock(&acoral_threads_queue.head.lock);
	acoral_list_add2_tail(&thread->global_list,&acoral_threads_queue.head);
30002e84:	e59d300c 	ldr	r3, [sp, #12]
30002e88:	e2833028 	add	r3, r3, #40	; 0x28
30002e8c:	e1a00003 	mov	r0, r3
30002e90:	e59f1020 	ldr	r1, [pc, #32]	; 30002eb8 <acoral_thread_init+0x228>
30002e94:	eb001c57 	bl	30009ff8 <acoral_list_add2_tail>
	acoral_spin_unlock(&acoral_threads_queue.head.lock);
	HAL_EXIT_CRITICAL();
30002e98:	e59d0010 	ldr	r0, [sp, #16]
30002e9c:	ebfffa12 	bl	300016ec <HAL_INTR_RESTORE>
#ifdef CFG_TEST
	acoral_print("%s thread initial well\n",thread->name);
#endif
	return 0;
30002ea0:	e3a03000 	mov	r3, #0
}
30002ea4:	e1a00003 	mov	r0, r3
30002ea8:	e28dd01c 	add	sp, sp, #28
30002eac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30002eb0:	e12fff1e 	bx	lr
30002eb4:	302be818 	.word	0x302be818
30002eb8:	300eab34 	.word	0x300eab34

30002ebc <acoral_thread_pool_init>:

/*================================
 *      init tcb pool
 *      
 *================================*/
void acoral_thread_pool_init(){
30002ebc:	e92d4008 	push	{r3, lr}
	thread_api.release_res=acoral_release_thread;
30002ec0:	e59f3068 	ldr	r3, [pc, #104]	; 30002f30 <acoral_thread_pool_init+0x74>
30002ec4:	e59f2068 	ldr	r2, [pc, #104]	; 30002f34 <acoral_thread_pool_init+0x78>
30002ec8:	e5832000 	str	r2, [r3]
	acoral_thread_pool_ctrl.type=ACORAL_RES_THREAD;
30002ecc:	e59f3064 	ldr	r3, [pc, #100]	; 30002f38 <acoral_thread_pool_init+0x7c>
30002ed0:	e3a02001 	mov	r2, #1
30002ed4:	e5832000 	str	r2, [r3]
	acoral_thread_pool_ctrl.size=sizeof(acoral_thread_t);
30002ed8:	e59f3058 	ldr	r3, [pc, #88]	; 30002f38 <acoral_thread_pool_init+0x7c>
30002edc:	e3a02058 	mov	r2, #88	; 0x58
30002ee0:	e5832004 	str	r2, [r3, #4]
	if(CFG_MAX_THREAD>20)
		acoral_thread_pool_ctrl.num_per_pool=20;
30002ee4:	e59f304c 	ldr	r3, [pc, #76]	; 30002f38 <acoral_thread_pool_init+0x7c>
30002ee8:	e3a02014 	mov	r2, #20
30002eec:	e5832008 	str	r2, [r3, #8]
	else
		acoral_thread_pool_ctrl.num_per_pool=CFG_MAX_THREAD;
	acoral_thread_pool_ctrl.max_pools=ACORAL_MAX_THREAD/acoral_thread_pool_ctrl.num_per_pool;
30002ef0:	e59f3040 	ldr	r3, [pc, #64]	; 30002f38 <acoral_thread_pool_init+0x7c>
30002ef4:	e5933008 	ldr	r3, [r3, #8]
30002ef8:	e3a00064 	mov	r0, #100	; 0x64
30002efc:	e1a01003 	mov	r1, r3
30002f00:	eb010366 	bl	30043ca0 <__aeabi_uidiv>
30002f04:	e1a03000 	mov	r3, r0
30002f08:	e1a02003 	mov	r2, r3
30002f0c:	e59f3024 	ldr	r3, [pc, #36]	; 30002f38 <acoral_thread_pool_init+0x7c>
30002f10:	e5832010 	str	r2, [r3, #16]
	acoral_thread_pool_ctrl.api=&thread_api;
30002f14:	e59f301c 	ldr	r3, [pc, #28]	; 30002f38 <acoral_thread_pool_init+0x7c>
30002f18:	e59f2010 	ldr	r2, [pc, #16]	; 30002f30 <acoral_thread_pool_init+0x74>
30002f1c:	e583202c 	str	r2, [r3, #44]	; 0x2c
	acoral_pool_ctrl_init(&acoral_thread_pool_ctrl);
30002f20:	e59f0010 	ldr	r0, [pc, #16]	; 30002f38 <acoral_thread_pool_init+0x7c>
30002f24:	eb0002d7 	bl	30003a88 <acoral_pool_ctrl_init>
}
30002f28:	e8bd4008 	pop	{r3, lr}
30002f2c:	e12fff1e 	bx	lr
30002f30:	300eaa20 	.word	0x300eaa20
30002f34:	3000273c 	.word	0x3000273c
30002f38:	300eaab4 	.word	0x300eaab4

30002f3c <acoral_set_thread_console>:

void acoral_set_thread_console(acoral_id id){
30002f3c:	e24dd008 	sub	sp, sp, #8
30002f40:	e58d0004 	str	r0, [sp, #4]
	acoral_cur_thread->console_id=id;	
30002f44:	e59f3010 	ldr	r3, [pc, #16]	; 30002f5c <acoral_set_thread_console+0x20>
30002f48:	e5933000 	ldr	r3, [r3]
30002f4c:	e59d2004 	ldr	r2, [sp, #4]
30002f50:	e583204c 	str	r2, [r3, #76]	; 0x4c
}
30002f54:	e28dd008 	add	sp, sp, #8
30002f58:	e12fff1e 	bx	lr
30002f5c:	302be818 	.word	0x302be818

30002f60 <acoral_sched_mechanism_init>:

void acoral_sched_mechanism_init(){
30002f60:	e92d4008 	push	{r3, lr}
	acoral_thread_pool_init();
30002f64:	ebffffd4 	bl	30002ebc <acoral_thread_pool_init>
	acoral_thread_runqueue_init();
30002f68:	ebfffc45 	bl	30002084 <acoral_thread_runqueue_init>
	acoral_init_list(&acoral_threads_queue.head);
30002f6c:	e59f3018 	ldr	r3, [pc, #24]	; 30002f8c <acoral_sched_mechanism_init+0x2c>
30002f70:	e59f2014 	ldr	r2, [pc, #20]	; 30002f8c <acoral_sched_mechanism_init+0x2c>
30002f74:	e5832000 	str	r2, [r3]
30002f78:	e59f300c 	ldr	r3, [pc, #12]	; 30002f8c <acoral_sched_mechanism_init+0x2c>
30002f7c:	e59f2008 	ldr	r2, [pc, #8]	; 30002f8c <acoral_sched_mechanism_init+0x2c>
30002f80:	e5832004 	str	r2, [r3, #4]
	acoral_spin_init(&acoral_threads_queue.head.lock);
}
30002f84:	e8bd4008 	pop	{r3, lr}
30002f88:	e12fff1e 	bx	lr
30002f8c:	300eab34 	.word	0x300eab34

30002f90 <acoral_thread_sys_init>:

/*================================
 *      init thread system 
 *       
 *================================*/
void acoral_thread_sys_init(){
30002f90:	e92d4008 	push	{r3, lr}
	acoral_sched_mechanism_init();
30002f94:	ebfffff1 	bl	30002f60 <acoral_sched_mechanism_init>
	acoral_sched_policy_init();
30002f98:	ebfffbe9 	bl	30001f44 <acoral_sched_policy_init>
}
30002f9c:	e8bd4008 	pop	{r3, lr}
30002fa0:	e12fff1e 	bx	lr

30002fa4 <create_comm_thread>:
 *       args       传进线程的参数
 *       name       创建线程的名字
 *       prio       创建线程的优先级
 *       cpu        绑定进程到指定cpu运行,-1为由系统指定
 *================================*/
acoral_id create_comm_thread(void (*route)(void *args),acoral_u32 stack_size,void *args,acoral_char *name,acoral_u8 prio,acoral_8 cpu){
30002fa4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30002fa8:	e24dd01c 	sub	sp, sp, #28
30002fac:	e58d000c 	str	r0, [sp, #12]
30002fb0:	e58d1008 	str	r1, [sp, #8]
30002fb4:	e58d2004 	str	r2, [sp, #4]
30002fb8:	e58d3000 	str	r3, [sp]
	acoral_comm_policy_data_t policy_ctrl;
	acoral_thread_t *thread;
        /*分配tcb数据块*/
	thread=acoral_alloc_thread();
30002fbc:	ebffff2b 	bl	30002c70 <acoral_alloc_thread>
30002fc0:	e1a03000 	mov	r3, r0
30002fc4:	e58d3014 	str	r3, [sp, #20]
	if(NULL==thread){
30002fc8:	e59d3014 	ldr	r3, [sp, #20]
30002fcc:	e3530000 	cmp	r3, #0
30002fd0:	1a000004 	bne	30002fe8 <create_comm_thread+0x44>
		acoral_printerr("Alloc thread:%s fail\n",name);
30002fd4:	e59f0094 	ldr	r0, [pc, #148]	; 30003070 <create_comm_thread+0xcc>
30002fd8:	e59d1000 	ldr	r1, [sp]
30002fdc:	eb002097 	bl	3000b240 <acoral_print>
		acoral_printk("No Mem Space or Beyond the max thread\n");
		return -1;
30002fe0:	e3e03000 	mvn	r3, #0
30002fe4:	ea00001d 	b	30003060 <create_comm_thread+0xbc>
	}
	thread->name=name;
30002fe8:	e59d3014 	ldr	r3, [sp, #20]
30002fec:	e59d2000 	ldr	r2, [sp]
30002ff0:	e5832048 	str	r2, [r3, #72]	; 0x48
	stack_size=stack_size&(~3);
30002ff4:	e59d3008 	ldr	r3, [sp, #8]
30002ff8:	e3c33003 	bic	r3, r3, #3
30002ffc:	e58d3008 	str	r3, [sp, #8]
	thread->stack_size=stack_size;
30003000:	e59d3014 	ldr	r3, [sp, #20]
30003004:	e59d2008 	ldr	r2, [sp, #8]
30003008:	e583203c 	str	r2, [r3, #60]	; 0x3c
	thread->stack_buttom=NULL;
3000300c:	e59d3014 	ldr	r3, [sp, #20]
30003010:	e3a02000 	mov	r2, #0
30003014:	e5832038 	str	r2, [r3, #56]	; 0x38
        /*设置线程要运行的cpu核心*/
	policy_ctrl.cpu=cpu;
30003018:	e5dd3024 	ldrb	r3, [sp, #36]	; 0x24
3000301c:	e5cd3010 	strb	r3, [sp, #16]
        /*设置线程的优先级*/
	policy_ctrl.prio=prio;
30003020:	e5dd3020 	ldrb	r3, [sp, #32]
30003024:	e5cd3011 	strb	r3, [sp, #17]
	policy_ctrl.prio_type=ACORAL_BASE_PRIO;
30003028:	e3a03002 	mov	r3, #2
3000302c:	e5cd3012 	strb	r3, [sp, #18]
	thread->policy=ACORAL_SCHED_POLICY_COMM;
30003030:	e59d3014 	ldr	r3, [sp, #20]
30003034:	e3a02015 	mov	r2, #21
30003038:	e5c3200c 	strb	r2, [r3, #12]
	thread->cpu_mask=-1;
3000303c:	e59d3014 	ldr	r3, [sp, #20]
30003040:	e3e02000 	mvn	r2, #0
30003044:	e5832008 	str	r2, [r3, #8]
	return comm_policy_thread_init(thread,route,args,&policy_ctrl);
30003048:	e28d3010 	add	r3, sp, #16
3000304c:	e59d0014 	ldr	r0, [sp, #20]
30003050:	e59d100c 	ldr	r1, [sp, #12]
30003054:	e59d2004 	ldr	r2, [sp, #4]
30003058:	eb000005 	bl	30003074 <comm_policy_thread_init>
3000305c:	e1a03000 	mov	r3, r0
}
30003060:	e1a00003 	mov	r0, r3
30003064:	e28dd01c 	add	sp, sp, #28
30003068:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000306c:	e12fff1e 	bx	lr
30003070:	300450e4 	.word	0x300450e4

30003074 <comm_policy_thread_init>:

acoral_id comm_policy_thread_init(acoral_thread_t *thread,void (*route)(void *args),void *args,void *data){
30003074:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003078:	e24dd024 	sub	sp, sp, #36	; 0x24
3000307c:	e58d000c 	str	r0, [sp, #12]
30003080:	e58d1008 	str	r1, [sp, #8]
30003084:	e58d2004 	str	r2, [sp, #4]
30003088:	e58d3000 	str	r3, [sp]
	acoral_sr cpu_sr;
	acoral_u32 prio;
	acoral_comm_policy_data_t *policy_data;
	policy_data=(acoral_comm_policy_data_t *)data;
3000308c:	e59d3000 	ldr	r3, [sp]
30003090:	e58d301c 	str	r3, [sp, #28]
	thread->cpu=policy_data->cpu;
30003094:	e59d301c 	ldr	r3, [sp, #28]
30003098:	e5d32000 	ldrb	r2, [r3]
3000309c:	e59d300c 	ldr	r3, [sp, #12]
300030a0:	e5c32006 	strb	r2, [r3, #6]
	prio=policy_data->prio;
300030a4:	e59d301c 	ldr	r3, [sp, #28]
300030a8:	e5d33001 	ldrb	r3, [r3, #1]
300030ac:	e58d3018 	str	r3, [sp, #24]
	if(policy_data->prio_type==ACORAL_BASE_PRIO){
300030b0:	e59d301c 	ldr	r3, [sp, #28]
300030b4:	e5d33002 	ldrb	r3, [r3, #2]
300030b8:	e3530002 	cmp	r3, #2
300030bc:	1a000007 	bne	300030e0 <comm_policy_thread_init+0x6c>
		prio+=ACORAL_BASE_PRIO_MIN;
300030c0:	e59d3018 	ldr	r3, [sp, #24]
300030c4:	e2833016 	add	r3, r3, #22
300030c8:	e58d3018 	str	r3, [sp, #24]
		if(prio>=ACORAL_BASE_PRIO_MAX)
300030cc:	e59d3018 	ldr	r3, [sp, #24]
300030d0:	e3530062 	cmp	r3, #98	; 0x62
300030d4:	9a000001 	bls	300030e0 <comm_policy_thread_init+0x6c>
			prio=ACORAL_BASE_PRIO_MAX-1;
300030d8:	e3a03062 	mov	r3, #98	; 0x62
300030dc:	e58d3018 	str	r3, [sp, #24]
	}
	thread->prio=prio;
300030e0:	e59d3018 	ldr	r3, [sp, #24]
300030e4:	e20320ff 	and	r2, r3, #255	; 0xff
300030e8:	e59d300c 	ldr	r3, [sp, #12]
300030ec:	e5c32005 	strb	r2, [r3, #5]
	if(acoral_thread_init(thread,route,acoral_thread_exit,args)!=0){
300030f0:	e59d000c 	ldr	r0, [sp, #12]
300030f4:	e59d1008 	ldr	r1, [sp, #8]
300030f8:	e59f206c 	ldr	r2, [pc, #108]	; 3000316c <comm_policy_thread_init+0xf8>
300030fc:	e59d3004 	ldr	r3, [sp, #4]
30003100:	ebfffee2 	bl	30002c90 <acoral_thread_init>
30003104:	e1a03000 	mov	r3, r0
30003108:	e3530000 	cmp	r3, #0
3000310c:	0a00000e 	beq	3000314c <comm_policy_thread_init+0xd8>
		acoral_printerr("No thread stack:%s\n",thread->name);
30003110:	e59d300c 	ldr	r3, [sp, #12]
30003114:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30003118:	e59f0050 	ldr	r0, [pc, #80]	; 30003170 <comm_policy_thread_init+0xfc>
3000311c:	e1a01003 	mov	r1, r3
30003120:	eb002046 	bl	3000b240 <acoral_print>
		HAL_ENTER_CRITICAL();
30003124:	ebfff972 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30003128:	e1a03000 	mov	r3, r0
3000312c:	e58d3014 	str	r3, [sp, #20]
		acoral_release_res((acoral_res_t *)thread);
30003130:	e59d300c 	ldr	r3, [sp, #12]
30003134:	e1a00003 	mov	r0, r3
30003138:	eb00013e 	bl	30003638 <acoral_release_res>
		HAL_EXIT_CRITICAL();
3000313c:	e59d0014 	ldr	r0, [sp, #20]
30003140:	ebfff969 	bl	300016ec <HAL_INTR_RESTORE>
		return -1;
30003144:	e3e03000 	mvn	r3, #0
30003148:	ea000003 	b	3000315c <comm_policy_thread_init+0xe8>
	}
        /*将线程就绪，并重新调度*/
	acoral_resume_thread(thread);
3000314c:	e59d000c 	ldr	r0, [sp, #12]
30003150:	ebfffdc5 	bl	3000286c <acoral_resume_thread>
	return thread->res.id;
30003154:	e59d300c 	ldr	r3, [sp, #12]
30003158:	e5933000 	ldr	r3, [r3]
}
3000315c:	e1a00003 	mov	r0, r3
30003160:	e28dd024 	add	sp, sp, #36	; 0x24
30003164:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003168:	e12fff1e 	bx	lr
3000316c:	30002a80 	.word	0x30002a80
30003170:	300450fc 	.word	0x300450fc

30003174 <comm_policy_init>:

void comm_policy_init(){
30003174:	e92d4008 	push	{r3, lr}
	comm_policy.type=ACORAL_SCHED_POLICY_COMM;	
30003178:	e59f3044 	ldr	r3, [pc, #68]	; 300031c4 <comm_policy_init+0x50>
3000317c:	e3a02015 	mov	r2, #21
30003180:	e5c32008 	strb	r2, [r3, #8]
	comm_policy.policy_thread_init=comm_policy_thread_init;	
30003184:	e59f3038 	ldr	r3, [pc, #56]	; 300031c4 <comm_policy_init+0x50>
30003188:	e59f2038 	ldr	r2, [pc, #56]	; 300031c8 <comm_policy_init+0x54>
3000318c:	e583200c 	str	r2, [r3, #12]
	comm_policy.policy_thread_release=NULL;	
30003190:	e59f302c 	ldr	r3, [pc, #44]	; 300031c4 <comm_policy_init+0x50>
30003194:	e3a02000 	mov	r2, #0
30003198:	e5832010 	str	r2, [r3, #16]
	comm_policy.delay_deal=NULL;	
3000319c:	e59f3020 	ldr	r3, [pc, #32]	; 300031c4 <comm_policy_init+0x50>
300031a0:	e3a02000 	mov	r2, #0
300031a4:	e5832014 	str	r2, [r3, #20]
	comm_policy.name="comm";	
300031a8:	e59f3014 	ldr	r3, [pc, #20]	; 300031c4 <comm_policy_init+0x50>
300031ac:	e59f2018 	ldr	r2, [pc, #24]	; 300031cc <comm_policy_init+0x58>
300031b0:	e5832018 	str	r2, [r3, #24]
	acoral_register_sched_policy(&comm_policy);
300031b4:	e59f0008 	ldr	r0, [pc, #8]	; 300031c4 <comm_policy_init+0x50>
300031b8:	ebfffb22 	bl	30001e48 <acoral_register_sched_policy>
}
300031bc:	e8bd4008 	pop	{r3, lr}
300031c0:	e12fff1e 	bx	lr
300031c4:	300ea39c 	.word	0x300ea39c
300031c8:	30003074 	.word	0x30003074
300031cc:	30045110 	.word	0x30045110

300031d0 <acoral_create_pool>:
/*================================
 *    create a kind of resource pool
 *       创建某一资源内存池
 *       pool_ctrl---资源内存池管理块
 *================================*/
acoral_err acoral_create_pool(acoral_pool_ctrl_t *pool_ctrl){
300031d0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300031d4:	e24dd014 	sub	sp, sp, #20
300031d8:	e58d0004 	str	r0, [sp, #4]
  	acoral_pool_t *pool;
	if(pool_ctrl->num>=pool_ctrl->max_pools)
300031dc:	e59d3004 	ldr	r3, [sp, #4]
300031e0:	e593200c 	ldr	r2, [r3, #12]
300031e4:	e59d3004 	ldr	r3, [sp, #4]
300031e8:	e5933010 	ldr	r3, [r3, #16]
300031ec:	e1520003 	cmp	r2, r3
300031f0:	3a000001 	bcc	300031fc <acoral_create_pool+0x2c>
	    return ACORAL_RES_MAX_POOL;
300031f4:	e3a030f3 	mov	r3, #243	; 0xf3
300031f8:	ea000049 	b	30003324 <acoral_create_pool+0x154>
  	pool=acoral_get_free_pool();
300031fc:	eb000188 	bl	30003824 <acoral_get_free_pool>
30003200:	e1a03000 	mov	r3, r0
30003204:	e58d300c 	str	r3, [sp, #12]
	if(pool==NULL)
30003208:	e59d300c 	ldr	r3, [sp, #12]
3000320c:	e3530000 	cmp	r3, #0
30003210:	1a000001 	bne	3000321c <acoral_create_pool+0x4c>
		return ACORAL_RES_NO_POOL;
30003214:	e3a030f1 	mov	r3, #241	; 0xf1
30003218:	ea000041 	b	30003324 <acoral_create_pool+0x154>
	pool->id=pool_ctrl->type<<ACORAL_RES_TYPE_BIT|pool->id;
3000321c:	e59d3004 	ldr	r3, [sp, #4]
30003220:	e5933000 	ldr	r3, [r3]
30003224:	e1a02503 	lsl	r2, r3, #10
30003228:	e59d300c 	ldr	r3, [sp, #12]
3000322c:	e5933008 	ldr	r3, [r3, #8]
30003230:	e1823003 	orr	r3, r2, r3
30003234:	e1a02003 	mov	r2, r3
30003238:	e59d300c 	ldr	r3, [sp, #12]
3000323c:	e5832008 	str	r2, [r3, #8]
	pool->size=pool_ctrl->size;
30003240:	e59d3004 	ldr	r3, [sp, #4]
30003244:	e5932004 	ldr	r2, [r3, #4]
30003248:	e59d300c 	ldr	r3, [sp, #12]
3000324c:	e583200c 	str	r2, [r3, #12]
	pool->num=pool_ctrl->num_per_pool;
30003250:	e59d3004 	ldr	r3, [sp, #4]
30003254:	e5932008 	ldr	r2, [r3, #8]
30003258:	e59d300c 	ldr	r3, [sp, #12]
3000325c:	e5832010 	str	r2, [r3, #16]
	pool->base_adr=(void *)acoral_malloc(pool->size*pool->num);
30003260:	e59d300c 	ldr	r3, [sp, #12]
30003264:	e593300c 	ldr	r3, [r3, #12]
30003268:	e59d200c 	ldr	r2, [sp, #12]
3000326c:	e5922010 	ldr	r2, [r2, #16]
30003270:	e0030392 	mul	r3, r2, r3
30003274:	e1a00003 	mov	r0, r3
30003278:	eb000c52 	bl	300063c8 <buddy_malloc>
3000327c:	e1a02000 	mov	r2, r0
30003280:	e59d300c 	ldr	r3, [sp, #12]
30003284:	e5832000 	str	r2, [r3]
	if(pool->base_adr==NULL)
30003288:	e59d300c 	ldr	r3, [sp, #12]
3000328c:	e5933000 	ldr	r3, [r3]
30003290:	e3530000 	cmp	r3, #0
30003294:	1a000001 	bne	300032a0 <acoral_create_pool+0xd0>
		return ACORAL_RES_NO_MEM;
30003298:	e3a030f2 	mov	r3, #242	; 0xf2
3000329c:	ea000020 	b	30003324 <acoral_create_pool+0x154>
	pool->res_free=pool->base_adr;
300032a0:	e59d300c 	ldr	r3, [sp, #12]
300032a4:	e5932000 	ldr	r2, [r3]
300032a8:	e59d300c 	ldr	r3, [sp, #12]
300032ac:	e5832004 	str	r2, [r3, #4]
	pool->free_num=pool->num;
300032b0:	e59d300c 	ldr	r3, [sp, #12]
300032b4:	e5932010 	ldr	r2, [r3, #16]
300032b8:	e59d300c 	ldr	r3, [sp, #12]
300032bc:	e5832018 	str	r2, [r3, #24]
	pool->ctrl=pool_ctrl;
300032c0:	e59d300c 	ldr	r3, [sp, #12]
300032c4:	e59d2004 	ldr	r2, [sp, #4]
300032c8:	e583201c 	str	r2, [r3, #28]
	acoral_pool_res_init(pool);
300032cc:	e59d000c 	ldr	r0, [sp, #12]
300032d0:	eb00018a 	bl	30003900 <acoral_pool_res_init>
        acoral_list_add2_tail(&pool->ctrl_list,pool_ctrl->pools);
300032d4:	e59d300c 	ldr	r3, [sp, #12]
300032d8:	e2832020 	add	r2, r3, #32
300032dc:	e59d3004 	ldr	r3, [sp, #4]
300032e0:	e5933018 	ldr	r3, [r3, #24]
300032e4:	e1a00002 	mov	r0, r2
300032e8:	e1a01003 	mov	r1, r3
300032ec:	eb001b41 	bl	30009ff8 <acoral_list_add2_tail>
	acoral_list_add2_tail(&pool->free_list,pool_ctrl->free_pools);
300032f0:	e59d300c 	ldr	r3, [sp, #12]
300032f4:	e2832028 	add	r2, r3, #40	; 0x28
300032f8:	e59d3004 	ldr	r3, [sp, #4]
300032fc:	e5933014 	ldr	r3, [r3, #20]
30003300:	e1a00002 	mov	r0, r2
30003304:	e1a01003 	mov	r1, r3
30003308:	eb001b3a 	bl	30009ff8 <acoral_list_add2_tail>
	pool_ctrl->num++;
3000330c:	e59d3004 	ldr	r3, [sp, #4]
30003310:	e593300c 	ldr	r3, [r3, #12]
30003314:	e2832001 	add	r2, r3, #1
30003318:	e59d3004 	ldr	r3, [sp, #4]
3000331c:	e583200c 	str	r2, [r3, #12]
	return 0;
30003320:	e3a03000 	mov	r3, #0
}
30003324:	e1a00003 	mov	r0, r3
30003328:	e28dd014 	add	sp, sp, #20
3000332c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003330:	e12fff1e 	bx	lr

30003334 <acoral_release_pool>:
/*================================
 *      release a kind of resource pool
 *       释放某一资源内存池所有资源
 *       pool_ctrl--资源内存池管理块
 *================================*/
void acoral_release_pool(acoral_pool_ctrl_t *pool_ctrl){
30003334:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003338:	e24dd01c 	sub	sp, sp, #28
3000333c:	e58d0004 	str	r0, [sp, #4]
	acoral_pool_t *pool;
	acoral_list_t *list,*head;
	head=pool_ctrl->pools;
30003340:	e59d3004 	ldr	r3, [sp, #4]
30003344:	e5933018 	ldr	r3, [r3, #24]
30003348:	e58d3014 	str	r3, [sp, #20]
	if(acoral_list_empty(head))
3000334c:	e59d3014 	ldr	r3, [sp, #20]
30003350:	e5932000 	ldr	r2, [r3]
30003354:	e59d3014 	ldr	r3, [sp, #20]
30003358:	e1520003 	cmp	r2, r3
3000335c:	0a000027 	beq	30003400 <acoral_release_pool+0xcc>
	  	return;
   for(list=head->next;list!=head;list=list->next){
30003360:	e59d3014 	ldr	r3, [sp, #20]
30003364:	e5933000 	ldr	r3, [r3]
30003368:	e58d3010 	str	r3, [sp, #16]
3000336c:	ea00001e 	b	300033ec <acoral_release_pool+0xb8>
			pool=list_entry(list,acoral_pool_t,free_list);
30003370:	e59d3010 	ldr	r3, [sp, #16]
30003374:	e2433028 	sub	r3, r3, #40	; 0x28
30003378:	e58d300c 	str	r3, [sp, #12]
		    acoral_list_del(&pool->ctrl_list);
3000337c:	e59d300c 	ldr	r3, [sp, #12]
30003380:	e2833020 	add	r3, r3, #32
30003384:	e1a00003 	mov	r0, r3
30003388:	eb001b2d 	bl	3000a044 <acoral_list_del>
			acoral_list_del(&pool->free_list);
3000338c:	e59d300c 	ldr	r3, [sp, #12]
30003390:	e2833028 	add	r3, r3, #40	; 0x28
30003394:	e1a00003 	mov	r0, r3
30003398:	eb001b29 	bl	3000a044 <acoral_list_del>
			acoral_free(pool->base_adr);
3000339c:	e59d300c 	ldr	r3, [sp, #12]
300033a0:	e5933000 	ldr	r3, [r3]
300033a4:	e1a00003 	mov	r0, r3
300033a8:	eb000c3e 	bl	300064a8 <buddy_free>
			pool->base_adr=(void *)acoral_free_res_pool;
300033ac:	e59f305c 	ldr	r3, [pc, #92]	; 30003410 <acoral_release_pool+0xdc>
300033b0:	e5932000 	ldr	r2, [r3]
300033b4:	e59d300c 	ldr	r3, [sp, #12]
300033b8:	e5832000 	str	r2, [r3]
			pool->id=pool->id&ACORAL_POOL_INDEX_MASK;
300033bc:	e59d300c 	ldr	r3, [sp, #12]
300033c0:	e5933008 	ldr	r3, [r3, #8]
300033c4:	e1a03b03 	lsl	r3, r3, #22
300033c8:	e1a03b23 	lsr	r3, r3, #22
300033cc:	e59d200c 	ldr	r2, [sp, #12]
300033d0:	e5823008 	str	r3, [r2, #8]
			acoral_free_res_pool=pool;
300033d4:	e59f3034 	ldr	r3, [pc, #52]	; 30003410 <acoral_release_pool+0xdc>
300033d8:	e59d200c 	ldr	r2, [sp, #12]
300033dc:	e5832000 	str	r2, [r3]
	acoral_pool_t *pool;
	acoral_list_t *list,*head;
	head=pool_ctrl->pools;
	if(acoral_list_empty(head))
	  	return;
   for(list=head->next;list!=head;list=list->next){
300033e0:	e59d3010 	ldr	r3, [sp, #16]
300033e4:	e5933000 	ldr	r3, [r3]
300033e8:	e58d3010 	str	r3, [sp, #16]
300033ec:	e59d2010 	ldr	r2, [sp, #16]
300033f0:	e59d3014 	ldr	r3, [sp, #20]
300033f4:	e1520003 	cmp	r2, r3
300033f8:	1affffdc 	bne	30003370 <acoral_release_pool+0x3c>
300033fc:	ea000000 	b	30003404 <acoral_release_pool+0xd0>
void acoral_release_pool(acoral_pool_ctrl_t *pool_ctrl){
	acoral_pool_t *pool;
	acoral_list_t *list,*head;
	head=pool_ctrl->pools;
	if(acoral_list_empty(head))
	  	return;
30003400:	e1a00000 	nop			; (mov r0, r0)
			acoral_free(pool->base_adr);
			pool->base_adr=(void *)acoral_free_res_pool;
			pool->id=pool->id&ACORAL_POOL_INDEX_MASK;
			acoral_free_res_pool=pool;
	}
}
30003404:	e28dd01c 	add	sp, sp, #28
30003408:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000340c:	e12fff1e 	bx	lr
30003410:	300ea3b8 	.word	0x300ea3b8

30003414 <acoral_collect_pool>:
/*================================
 *    collect a kind of resource pool
 *       回收某一资源内存池空闲的内存池
 *       pool_ctrl--资源内存池管理块
 *================================*/
void acoral_collect_pool(acoral_pool_ctrl_t *pool_ctrl){
30003414:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003418:	e24dd01c 	sub	sp, sp, #28
3000341c:	e58d0004 	str	r0, [sp, #4]
	acoral_pool_t *pool;
	acoral_list_t *list,*head;
	head=pool_ctrl->free_pools;
30003420:	e59d3004 	ldr	r3, [sp, #4]
30003424:	e5933014 	ldr	r3, [r3, #20]
30003428:	e58d3014 	str	r3, [sp, #20]
	if(acoral_list_empty(head))
3000342c:	e59d3014 	ldr	r3, [sp, #20]
30003430:	e5932000 	ldr	r2, [r3]
30003434:	e59d3014 	ldr	r3, [sp, #20]
30003438:	e1520003 	cmp	r2, r3
3000343c:	0a00002d 	beq	300034f8 <acoral_collect_pool+0xe4>
	  	return;
        for(list=head->next;list!=head;list=list->next){
30003440:	e59d3014 	ldr	r3, [sp, #20]
30003444:	e5933000 	ldr	r3, [r3]
30003448:	e58d3010 	str	r3, [sp, #16]
3000344c:	ea000024 	b	300034e4 <acoral_collect_pool+0xd0>
			pool=list_entry(list,acoral_pool_t,free_list);
30003450:	e59d3010 	ldr	r3, [sp, #16]
30003454:	e2433028 	sub	r3, r3, #40	; 0x28
30003458:	e58d300c 	str	r3, [sp, #12]
	       	if(pool->free_num==pool->num){
3000345c:	e59d300c 	ldr	r3, [sp, #12]
30003460:	e5932018 	ldr	r2, [r3, #24]
30003464:	e59d300c 	ldr	r3, [sp, #12]
30003468:	e5933010 	ldr	r3, [r3, #16]
3000346c:	e1520003 	cmp	r2, r3
30003470:	1a000018 	bne	300034d8 <acoral_collect_pool+0xc4>
		      	acoral_list_del(&pool->ctrl_list);
30003474:	e59d300c 	ldr	r3, [sp, #12]
30003478:	e2833020 	add	r3, r3, #32
3000347c:	e1a00003 	mov	r0, r3
30003480:	eb001aef 	bl	3000a044 <acoral_list_del>
				acoral_list_del(&pool->free_list);
30003484:	e59d300c 	ldr	r3, [sp, #12]
30003488:	e2833028 	add	r3, r3, #40	; 0x28
3000348c:	e1a00003 	mov	r0, r3
30003490:	eb001aeb 	bl	3000a044 <acoral_list_del>
				acoral_free(pool->base_adr);
30003494:	e59d300c 	ldr	r3, [sp, #12]
30003498:	e5933000 	ldr	r3, [r3]
3000349c:	e1a00003 	mov	r0, r3
300034a0:	eb000c00 	bl	300064a8 <buddy_free>
				pool->base_adr=(void *)acoral_free_res_pool;
300034a4:	e59f305c 	ldr	r3, [pc, #92]	; 30003508 <acoral_collect_pool+0xf4>
300034a8:	e5932000 	ldr	r2, [r3]
300034ac:	e59d300c 	ldr	r3, [sp, #12]
300034b0:	e5832000 	str	r2, [r3]
				pool->id=pool->id&ACORAL_POOL_INDEX_MASK;
300034b4:	e59d300c 	ldr	r3, [sp, #12]
300034b8:	e5933008 	ldr	r3, [r3, #8]
300034bc:	e1a03b03 	lsl	r3, r3, #22
300034c0:	e1a03b23 	lsr	r3, r3, #22
300034c4:	e59d200c 	ldr	r2, [sp, #12]
300034c8:	e5823008 	str	r3, [r2, #8]
				acoral_free_res_pool=pool;
300034cc:	e59f3034 	ldr	r3, [pc, #52]	; 30003508 <acoral_collect_pool+0xf4>
300034d0:	e59d200c 	ldr	r2, [sp, #12]
300034d4:	e5832000 	str	r2, [r3]
	acoral_pool_t *pool;
	acoral_list_t *list,*head;
	head=pool_ctrl->free_pools;
	if(acoral_list_empty(head))
	  	return;
        for(list=head->next;list!=head;list=list->next){
300034d8:	e59d3010 	ldr	r3, [sp, #16]
300034dc:	e5933000 	ldr	r3, [r3]
300034e0:	e58d3010 	str	r3, [sp, #16]
300034e4:	e59d2010 	ldr	r2, [sp, #16]
300034e8:	e59d3014 	ldr	r3, [sp, #20]
300034ec:	e1520003 	cmp	r2, r3
300034f0:	1affffd6 	bne	30003450 <acoral_collect_pool+0x3c>
300034f4:	ea000000 	b	300034fc <acoral_collect_pool+0xe8>
void acoral_collect_pool(acoral_pool_ctrl_t *pool_ctrl){
	acoral_pool_t *pool;
	acoral_list_t *list,*head;
	head=pool_ctrl->free_pools;
	if(acoral_list_empty(head))
	  	return;
300034f8:	e1a00000 	nop			; (mov r0, r0)
				pool->base_adr=(void *)acoral_free_res_pool;
				pool->id=pool->id&ACORAL_POOL_INDEX_MASK;
				acoral_free_res_pool=pool;
			}
	}
}
300034fc:	e28dd01c 	add	sp, sp, #28
30003500:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003504:	e12fff1e 	bx	lr
30003508:	300ea3b8 	.word	0x300ea3b8

3000350c <acoral_get_res>:
/*================================
 *    get a kind of resource 
 *       获取某一资源
 *       pool_ctrl--资源池管理块
 *================================*/
acoral_res_t *acoral_get_res(acoral_pool_ctrl_t *pool_ctrl){
3000350c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003510:	e24dd01c 	sub	sp, sp, #28
30003514:	e58d0004 	str	r0, [sp, #4]
	acoral_sr cpu_sr;
  	acoral_list_t *first;
	acoral_res_t *res;
	acoral_pool_t *pool;
	HAL_ENTER_CRITICAL();
30003518:	ebfff875 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000351c:	e1a03000 	mov	r3, r0
30003520:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&pool_ctrl->lock);
	first=pool_ctrl->free_pools->next;
30003524:	e59d3004 	ldr	r3, [sp, #4]
30003528:	e5933014 	ldr	r3, [r3, #20]
3000352c:	e5933000 	ldr	r3, [r3]
30003530:	e58d300c 	str	r3, [sp, #12]
	if(acoral_list_empty(first)){
30003534:	e59d300c 	ldr	r3, [sp, #12]
30003538:	e5932000 	ldr	r2, [r3]
3000353c:	e59d300c 	ldr	r3, [sp, #12]
30003540:	e1520003 	cmp	r2, r3
30003544:	1a00000c 	bne	3000357c <acoral_get_res+0x70>
	  	if(acoral_create_pool(pool_ctrl)){
30003548:	e59d0004 	ldr	r0, [sp, #4]
3000354c:	ebffff1f 	bl	300031d0 <acoral_create_pool>
30003550:	e1a03000 	mov	r3, r0
30003554:	e3530000 	cmp	r3, #0
30003558:	0a000003 	beq	3000356c <acoral_get_res+0x60>
			acoral_spin_unlock(&pool_ctrl->lock);
			HAL_EXIT_CRITICAL();
3000355c:	e59d0008 	ldr	r0, [sp, #8]
30003560:	ebfff861 	bl	300016ec <HAL_INTR_RESTORE>
			return NULL;
30003564:	e3a03000 	mov	r3, #0
30003568:	ea00002e 	b	30003628 <acoral_get_res+0x11c>
		}
		else{
			first=pool_ctrl->free_pools->next;
3000356c:	e59d3004 	ldr	r3, [sp, #4]
30003570:	e5933014 	ldr	r3, [r3, #20]
30003574:	e5933000 	ldr	r3, [r3]
30003578:	e58d300c 	str	r3, [sp, #12]
		}
	}
	pool=list_entry(first,acoral_pool_t,free_list);
3000357c:	e59d300c 	ldr	r3, [sp, #12]
30003580:	e2433028 	sub	r3, r3, #40	; 0x28
30003584:	e58d3014 	str	r3, [sp, #20]
	res=(acoral_res_t *)pool->res_free;
30003588:	e59d3014 	ldr	r3, [sp, #20]
3000358c:	e5933004 	ldr	r3, [r3, #4]
30003590:	e58d3010 	str	r3, [sp, #16]
	pool->res_free=(void *)((acoral_u8 *)pool->base_adr+res->next_id*pool->size);
30003594:	e59d3014 	ldr	r3, [sp, #20]
30003598:	e5932000 	ldr	r2, [r3]
3000359c:	e59d3010 	ldr	r3, [sp, #16]
300035a0:	e1d330b0 	ldrh	r3, [r3]
300035a4:	e59d1014 	ldr	r1, [sp, #20]
300035a8:	e591100c 	ldr	r1, [r1, #12]
300035ac:	e0030391 	mul	r3, r1, r3
300035b0:	e0822003 	add	r2, r2, r3
300035b4:	e59d3014 	ldr	r3, [sp, #20]
300035b8:	e5832004 	str	r2, [r3, #4]
	res->id=(res->id>>(ACORAL_RES_INDEX_INIT_BIT-ACORAL_RES_INDEX_BIT))&ACORAL_RES_INDEX_MASK|pool->id;
300035bc:	e59d3010 	ldr	r3, [sp, #16]
300035c0:	e5933000 	ldr	r3, [r3]
300035c4:	e1a03143 	asr	r3, r3, #2
300035c8:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
300035cc:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
300035d0:	e3c3303f 	bic	r3, r3, #63	; 0x3f
300035d4:	e59d2014 	ldr	r2, [sp, #20]
300035d8:	e5922008 	ldr	r2, [r2, #8]
300035dc:	e1832002 	orr	r2, r3, r2
300035e0:	e59d3010 	ldr	r3, [sp, #16]
300035e4:	e5832000 	str	r2, [r3]
        pool->free_num--;
300035e8:	e59d3014 	ldr	r3, [sp, #20]
300035ec:	e5933018 	ldr	r3, [r3, #24]
300035f0:	e2432001 	sub	r2, r3, #1
300035f4:	e59d3014 	ldr	r3, [sp, #20]
300035f8:	e5832018 	str	r2, [r3, #24]
#ifdef CFG_TEST
	acoral_print("Alloc res 0x%x\n",res);
#endif
	if(!pool->free_num){
300035fc:	e59d3014 	ldr	r3, [sp, #20]
30003600:	e5933018 	ldr	r3, [r3, #24]
30003604:	e3530000 	cmp	r3, #0
30003608:	1a000003 	bne	3000361c <acoral_get_res+0x110>
	  	acoral_list_del(&pool->free_list);
3000360c:	e59d3014 	ldr	r3, [sp, #20]
30003610:	e2833028 	add	r3, r3, #40	; 0x28
30003614:	e1a00003 	mov	r0, r3
30003618:	eb001a89 	bl	3000a044 <acoral_list_del>
	}
	acoral_spin_unlock(&pool_ctrl->lock);
	HAL_EXIT_CRITICAL();
3000361c:	e59d0008 	ldr	r0, [sp, #8]
30003620:	ebfff831 	bl	300016ec <HAL_INTR_RESTORE>
	return res;
30003624:	e59d3010 	ldr	r3, [sp, #16]
}
30003628:	e1a00003 	mov	r0, r3
3000362c:	e28dd01c 	add	sp, sp, #28
30003630:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003634:	e12fff1e 	bx	lr

30003638 <acoral_release_res>:
/*================================
 *    release a kind of resource 
 *       释放某一资源
 *      res--资源数据块
 *================================*/
void acoral_release_res(acoral_res_t *res){
30003638:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000363c:	e24dd01c 	sub	sp, sp, #28
30003640:	e58d0004 	str	r0, [sp, #4]
  	acoral_pool_t *pool;
	acoral_u32 index;
  	void *tmp;
       	acoral_pool_ctrl_t *pool_ctrl;
	if(!ACORAL_ASSERT(res,"Res Release\n"))
30003644:	e59f3168 	ldr	r3, [pc, #360]	; 300037b4 <acoral_release_res+0x17c>
30003648:	e59d0004 	ldr	r0, [sp, #4]
3000364c:	e1a01003 	mov	r1, r3
30003650:	eb00017f 	bl	30003c54 <acoral_assert_res>
30003654:	e1a03000 	mov	r3, r0
30003658:	e3530000 	cmp	r3, #0
3000365c:	0a00004e 	beq	3000379c <acoral_release_res+0x164>
		return;
	pool=acoral_get_pool_by_id(res->id);
30003660:	e59d3004 	ldr	r3, [sp, #4]
30003664:	e5933000 	ldr	r3, [r3]
30003668:	e1a00003 	mov	r0, r3
3000366c:	eb000053 	bl	300037c0 <acoral_get_pool_by_id>
30003670:	e1a03000 	mov	r3, r0
30003674:	e58d3008 	str	r3, [sp, #8]
	if(pool==NULL){
30003678:	e59d3008 	ldr	r3, [sp, #8]
3000367c:	e3530000 	cmp	r3, #0
30003680:	1a000002 	bne	30003690 <acoral_release_res+0x58>
		acoral_printerr("Res release Err\n");
30003684:	e59f012c 	ldr	r0, [pc, #300]	; 300037b8 <acoral_release_res+0x180>
30003688:	eb001eec 	bl	3000b240 <acoral_print>
		return;
3000368c:	ea000045 	b	300037a8 <acoral_release_res+0x170>
	}
 	pool_ctrl=pool->ctrl;
30003690:	e59d3008 	ldr	r3, [sp, #8]
30003694:	e593301c 	ldr	r3, [r3, #28]
30003698:	e58d3014 	str	r3, [sp, #20]
	acoral_spin_lock(&pool_ctrl->lock);
	if((void *)res<pool->base_adr){
3000369c:	e59d3008 	ldr	r3, [sp, #8]
300036a0:	e5932000 	ldr	r2, [r3]
300036a4:	e59d3004 	ldr	r3, [sp, #4]
300036a8:	e1520003 	cmp	r2, r3
300036ac:	9a000002 	bls	300036bc <acoral_release_res+0x84>
		acoral_printerr("Err Res\n");
300036b0:	e59f0104 	ldr	r0, [pc, #260]	; 300037bc <acoral_release_res+0x184>
300036b4:	eb001ee1 	bl	3000b240 <acoral_print>
		return;
300036b8:	ea00003a 	b	300037a8 <acoral_release_res+0x170>
	}
	index=(((acoral_u32)res-(acoral_u32)pool->base_adr)/pool->size);
300036bc:	e59d2004 	ldr	r2, [sp, #4]
300036c0:	e59d3008 	ldr	r3, [sp, #8]
300036c4:	e5933000 	ldr	r3, [r3]
300036c8:	e0632002 	rsb	r2, r3, r2
300036cc:	e59d3008 	ldr	r3, [sp, #8]
300036d0:	e593300c 	ldr	r3, [r3, #12]
300036d4:	e1a00002 	mov	r0, r2
300036d8:	e1a01003 	mov	r1, r3
300036dc:	eb01016f 	bl	30043ca0 <__aeabi_uidiv>
300036e0:	e1a03000 	mov	r3, r0
300036e4:	e58d300c 	str	r3, [sp, #12]
	if(index>=pool->num){
300036e8:	e59d3008 	ldr	r3, [sp, #8]
300036ec:	e5932010 	ldr	r2, [r3, #16]
300036f0:	e59d300c 	ldr	r3, [sp, #12]
300036f4:	e1520003 	cmp	r2, r3
300036f8:	8a000002 	bhi	30003708 <acoral_release_res+0xd0>
		acoral_printerr("Err Res\n");
300036fc:	e59f00b8 	ldr	r0, [pc, #184]	; 300037bc <acoral_release_res+0x184>
30003700:	eb001ece 	bl	3000b240 <acoral_print>
		return;
30003704:	ea000027 	b	300037a8 <acoral_release_res+0x170>
	}
#ifdef CFG_TEST
	acoral_print("Free res 0x%x\n",res);
#endif
	tmp=pool->res_free;
30003708:	e59d3008 	ldr	r3, [sp, #8]
3000370c:	e5933004 	ldr	r3, [r3, #4]
30003710:	e58d3010 	str	r3, [sp, #16]
	pool->res_free=(void *)res;
30003714:	e59d3008 	ldr	r3, [sp, #8]
30003718:	e59d2004 	ldr	r2, [sp, #4]
3000371c:	e5832004 	str	r2, [r3, #4]
	res->id=index<<ACORAL_RES_INDEX_INIT_BIT;
30003720:	e59d300c 	ldr	r3, [sp, #12]
30003724:	e1a03803 	lsl	r3, r3, #16
30003728:	e1a02003 	mov	r2, r3
3000372c:	e59d3004 	ldr	r3, [sp, #4]
30003730:	e5832000 	str	r2, [r3]
	res->next_id=((acoral_res_t *)tmp)->id>>ACORAL_RES_INDEX_INIT_BIT;
30003734:	e59d3010 	ldr	r3, [sp, #16]
30003738:	e5933000 	ldr	r3, [r3]
3000373c:	e1a03843 	asr	r3, r3, #16
30003740:	e1a03803 	lsl	r3, r3, #16
30003744:	e1a02823 	lsr	r2, r3, #16
30003748:	e59d3004 	ldr	r3, [sp, #4]
3000374c:	e1c320b0 	strh	r2, [r3]
	pool->free_num++;
30003750:	e59d3008 	ldr	r3, [sp, #8]
30003754:	e5933018 	ldr	r3, [r3, #24]
30003758:	e2832001 	add	r2, r3, #1
3000375c:	e59d3008 	ldr	r3, [sp, #8]
30003760:	e5832018 	str	r2, [r3, #24]
	if(acoral_list_empty(&pool->free_list))
30003764:	e59d3008 	ldr	r3, [sp, #8]
30003768:	e5932028 	ldr	r2, [r3, #40]	; 0x28
3000376c:	e59d3008 	ldr	r3, [sp, #8]
30003770:	e2833028 	add	r3, r3, #40	; 0x28
30003774:	e1520003 	cmp	r2, r3
30003778:	1a000009 	bne	300037a4 <acoral_release_res+0x16c>
	  	acoral_list_add(&pool->free_list,pool_ctrl->free_pools);
3000377c:	e59d3008 	ldr	r3, [sp, #8]
30003780:	e2832028 	add	r2, r3, #40	; 0x28
30003784:	e59d3014 	ldr	r3, [sp, #20]
30003788:	e5933014 	ldr	r3, [r3, #20]
3000378c:	e1a00002 	mov	r0, r2
30003790:	e1a01003 	mov	r1, r3
30003794:	eb001a04 	bl	30009fac <acoral_list_add>
	acoral_spin_unlock(&pool_ctrl->lock);
	return;
30003798:	ea000002 	b	300037a8 <acoral_release_res+0x170>
  	acoral_pool_t *pool;
	acoral_u32 index;
  	void *tmp;
       	acoral_pool_ctrl_t *pool_ctrl;
	if(!ACORAL_ASSERT(res,"Res Release\n"))
		return;
3000379c:	e1a00000 	nop			; (mov r0, r0)
300037a0:	ea000000 	b	300037a8 <acoral_release_res+0x170>
	res->next_id=((acoral_res_t *)tmp)->id>>ACORAL_RES_INDEX_INIT_BIT;
	pool->free_num++;
	if(acoral_list_empty(&pool->free_list))
	  	acoral_list_add(&pool->free_list,pool_ctrl->free_pools);
	acoral_spin_unlock(&pool_ctrl->lock);
	return;
300037a4:	e1a00000 	nop			; (mov r0, r0)
}
300037a8:	e28dd01c 	add	sp, sp, #28
300037ac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300037b0:	e12fff1e 	bx	lr
300037b4:	30045118 	.word	0x30045118
300037b8:	30045128 	.word	0x30045128
300037bc:	3004513c 	.word	0x3004513c

300037c0 <acoral_get_pool_by_id>:
/*================================
 *    get a kind of resource by res_id
 *  根据资源ID获取某一资源对应的资源池
 *      res_id--资源ID
 *================================*/
acoral_pool_t *acoral_get_pool_by_id(acoral_id res_id){
300037c0:	e24dd010 	sub	sp, sp, #16
300037c4:	e58d0004 	str	r0, [sp, #4]
  	acoral_u32 index;
	index=(res_id&ACORAL_POOL_INDEX_MASK)>>ACORAL_POOL_INDEX_BIT;
300037c8:	e59d3004 	ldr	r3, [sp, #4]
300037cc:	e1a03b03 	lsl	r3, r3, #22
300037d0:	e1a03b23 	lsr	r3, r3, #22
300037d4:	e58d300c 	str	r3, [sp, #12]
	if(index<ACORAL_MAX_POOLS)
300037d8:	e59d300c 	ldr	r3, [sp, #12]
300037dc:	e3530027 	cmp	r3, #39	; 0x27
300037e0:	8a00000a 	bhi	30003810 <acoral_get_pool_by_id+0x50>
	  	return acoral_pools+index;
300037e4:	e59d200c 	ldr	r2, [sp, #12]
300037e8:	e1a03002 	mov	r3, r2
300037ec:	e1a03083 	lsl	r3, r3, #1
300037f0:	e0833002 	add	r3, r3, r2
300037f4:	e1a03103 	lsl	r3, r3, #2
300037f8:	e0833002 	add	r3, r3, r2
300037fc:	e1a03103 	lsl	r3, r3, #2
30003800:	e1a02003 	mov	r2, r3
30003804:	e59f3014 	ldr	r3, [pc, #20]	; 30003820 <acoral_get_pool_by_id+0x60>
30003808:	e0823003 	add	r3, r2, r3
3000380c:	ea000000 	b	30003814 <acoral_get_pool_by_id+0x54>
	return NULL;
30003810:	e3a03000 	mov	r3, #0
}
30003814:	e1a00003 	mov	r0, r3
30003818:	e28dd010 	add	sp, sp, #16
3000381c:	e12fff1e 	bx	lr
30003820:	3012ae14 	.word	0x3012ae14

30003824 <acoral_get_free_pool>:

/*================================
 *    get a free pool
 *     获取空闲资源池
 *================================*/
acoral_pool_t *acoral_get_free_pool(){
30003824:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003828:	e24dd00c 	sub	sp, sp, #12
	acoral_sr cpu_sr;
  	acoral_pool_t *tmp;
	HAL_ENTER_CRITICAL();
3000382c:	ebfff7b0 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30003830:	e1a03000 	mov	r3, r0
30003834:	e58d3000 	str	r3, [sp]
	tmp=acoral_free_res_pool;
30003838:	e59f3044 	ldr	r3, [pc, #68]	; 30003884 <acoral_get_free_pool+0x60>
3000383c:	e5933000 	ldr	r3, [r3]
30003840:	e58d3004 	str	r3, [sp, #4]
	if(NULL!=tmp){
30003844:	e59d3004 	ldr	r3, [sp, #4]
30003848:	e3530000 	cmp	r3, #0
3000384c:	0a000005 	beq	30003868 <acoral_get_free_pool+0x44>
		acoral_spin_lock(&tmp->lock);
		acoral_free_res_pool=*(void **)tmp->base_adr;
30003850:	e59d3004 	ldr	r3, [sp, #4]
30003854:	e5933000 	ldr	r3, [r3]
30003858:	e5933000 	ldr	r3, [r3]
3000385c:	e1a02003 	mov	r2, r3
30003860:	e59f301c 	ldr	r3, [pc, #28]	; 30003884 <acoral_get_free_pool+0x60>
30003864:	e5832000 	str	r2, [r3]
		acoral_spin_unlock(&tmp->lock);
	}
	HAL_EXIT_CRITICAL();
30003868:	e59d0000 	ldr	r0, [sp]
3000386c:	ebfff79e 	bl	300016ec <HAL_INTR_RESTORE>
	return tmp;
30003870:	e59d3004 	ldr	r3, [sp, #4]
}
30003874:	e1a00003 	mov	r0, r3
30003878:	e28dd00c 	add	sp, sp, #12
3000387c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003880:	e12fff1e 	bx	lr
30003884:	300ea3b8 	.word	0x300ea3b8

30003888 <acoral_get_res_by_id>:

acoral_res_t * acoral_get_res_by_id(acoral_id id){
30003888:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000388c:	e24dd014 	sub	sp, sp, #20
30003890:	e58d0004 	str	r0, [sp, #4]
  	acoral_pool_t *pool;
	acoral_u32 index;
	pool=acoral_get_pool_by_id(id);
30003894:	e59d0004 	ldr	r0, [sp, #4]
30003898:	ebffffc8 	bl	300037c0 <acoral_get_pool_by_id>
3000389c:	e1a03000 	mov	r3, r0
300038a0:	e58d3008 	str	r3, [sp, #8]
	if(pool==NULL)
300038a4:	e59d3008 	ldr	r3, [sp, #8]
300038a8:	e3530000 	cmp	r3, #0
300038ac:	1a000001 	bne	300038b8 <acoral_get_res_by_id+0x30>
		return NULL;
300038b0:	e3a03000 	mov	r3, #0
300038b4:	ea00000d 	b	300038f0 <acoral_get_res_by_id+0x68>
	index=(id&ACORAL_RES_INDEX_MASK)>>ACORAL_RES_INDEX_BIT;
300038b8:	e59d3004 	ldr	r3, [sp, #4]
300038bc:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
300038c0:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
300038c4:	e3c3303f 	bic	r3, r3, #63	; 0x3f
300038c8:	e1a03743 	asr	r3, r3, #14
300038cc:	e58d300c 	str	r3, [sp, #12]
     	return (acoral_res_t *)((acoral_u8 *)pool->base_adr+index*pool->size);
300038d0:	e59d3008 	ldr	r3, [sp, #8]
300038d4:	e5933000 	ldr	r3, [r3]
300038d8:	e1a02003 	mov	r2, r3
300038dc:	e59d3008 	ldr	r3, [sp, #8]
300038e0:	e593300c 	ldr	r3, [r3, #12]
300038e4:	e59d100c 	ldr	r1, [sp, #12]
300038e8:	e0030391 	mul	r3, r1, r3
300038ec:	e0823003 	add	r3, r2, r3
}
300038f0:	e1a00003 	mov	r0, r3
300038f4:	e28dd014 	add	sp, sp, #20
300038f8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300038fc:	e12fff1e 	bx	lr

30003900 <acoral_pool_res_init>:

/*================================
 *       a kind of resource initial 
 *        资源初始化
 *================================*/
void acoral_pool_res_init(acoral_pool_t * pool){
30003900:	e24dd018 	sub	sp, sp, #24
30003904:	e58d0004 	str	r0, [sp, #4]
	acoral_res_t *res;
	acoral_u32 i;
	acoral_u8 *pblk;
	acoral_u32 blks;
	blks=pool->num;
30003908:	e59d3004 	ldr	r3, [sp, #4]
3000390c:	e5933010 	ldr	r3, [r3, #16]
30003910:	e58d3014 	str	r3, [sp, #20]
	res=(acoral_res_t *)pool->base_adr;
30003914:	e59d3004 	ldr	r3, [sp, #4]
30003918:	e5933000 	ldr	r3, [r3]
3000391c:	e58d3008 	str	r3, [sp, #8]
     	pblk=(acoral_u8 *)pool->base_adr + pool->size;
30003920:	e59d3004 	ldr	r3, [sp, #4]
30003924:	e5933000 	ldr	r3, [r3]
30003928:	e1a02003 	mov	r2, r3
3000392c:	e59d3004 	ldr	r3, [sp, #4]
30003930:	e593300c 	ldr	r3, [r3, #12]
30003934:	e0823003 	add	r3, r2, r3
30003938:	e58d3010 	str	r3, [sp, #16]
	for (i = 0; i < (blks - 1); i++) {
3000393c:	e3a03000 	mov	r3, #0
30003940:	e58d300c 	str	r3, [sp, #12]
30003944:	ea000016 	b	300039a4 <acoral_pool_res_init+0xa4>
	    res->id=i<<ACORAL_RES_INDEX_INIT_BIT;
30003948:	e59d300c 	ldr	r3, [sp, #12]
3000394c:	e1a03803 	lsl	r3, r3, #16
30003950:	e1a02003 	mov	r2, r3
30003954:	e59d3008 	ldr	r3, [sp, #8]
30003958:	e5832000 	str	r2, [r3]
	    res->next_id=i+1;
3000395c:	e59d300c 	ldr	r3, [sp, #12]
30003960:	e1a03803 	lsl	r3, r3, #16
30003964:	e1a03823 	lsr	r3, r3, #16
30003968:	e2833001 	add	r3, r3, #1
3000396c:	e1a03803 	lsl	r3, r3, #16
30003970:	e1a02823 	lsr	r2, r3, #16
30003974:	e59d3008 	ldr	r3, [sp, #8]
30003978:	e1c320b0 	strh	r2, [r3]
	    res=(acoral_res_t *)pblk;
3000397c:	e59d3010 	ldr	r3, [sp, #16]
30003980:	e58d3008 	str	r3, [sp, #8]
	    pblk+=pool->size;
30003984:	e59d3004 	ldr	r3, [sp, #4]
30003988:	e593300c 	ldr	r3, [r3, #12]
3000398c:	e59d2010 	ldr	r2, [sp, #16]
30003990:	e0823003 	add	r3, r2, r3
30003994:	e58d3010 	str	r3, [sp, #16]
	acoral_u8 *pblk;
	acoral_u32 blks;
	blks=pool->num;
	res=(acoral_res_t *)pool->base_adr;
     	pblk=(acoral_u8 *)pool->base_adr + pool->size;
	for (i = 0; i < (blks - 1); i++) {
30003998:	e59d300c 	ldr	r3, [sp, #12]
3000399c:	e2833001 	add	r3, r3, #1
300039a0:	e58d300c 	str	r3, [sp, #12]
300039a4:	e59d3014 	ldr	r3, [sp, #20]
300039a8:	e2432001 	sub	r2, r3, #1
300039ac:	e59d300c 	ldr	r3, [sp, #12]
300039b0:	e1520003 	cmp	r2, r3
300039b4:	8affffe3 	bhi	30003948 <acoral_pool_res_init+0x48>
	    res->id=i<<ACORAL_RES_INDEX_INIT_BIT;
	    res->next_id=i+1;
	    res=(acoral_res_t *)pblk;
	    pblk+=pool->size;
	}
	res->id=blks-1<<ACORAL_RES_INDEX_INIT_BIT;
300039b8:	e59d3014 	ldr	r3, [sp, #20]
300039bc:	e2433001 	sub	r3, r3, #1
300039c0:	e1a03803 	lsl	r3, r3, #16
300039c4:	e1a02003 	mov	r2, r3
300039c8:	e59d3008 	ldr	r3, [sp, #8]
300039cc:	e5832000 	str	r2, [r3]
	res->next_id=0;
300039d0:	e59d3008 	ldr	r3, [sp, #8]
300039d4:	e3a02000 	mov	r2, #0
300039d8:	e1c320b0 	strh	r2, [r3]
}
300039dc:	e28dd018 	add	sp, sp, #24
300039e0:	e12fff1e 	bx	lr

300039e4 <acoral_pools_init>:
/*================================
 *        resource pool initial 
 *              资源池初始化
 *================================*/
void  acoral_pools_init(void)
{
300039e4:	e24dd008 	sub	sp, sp, #8
    acoral_pool_t  *pool;
    acoral_u32 i;
    pool = &acoral_pools[0];
300039e8:	e59f3090 	ldr	r3, [pc, #144]	; 30003a80 <acoral_pools_init+0x9c>
300039ec:	e58d3000 	str	r3, [sp]
    for (i = 0; i < (ACORAL_MAX_POOLS - 1); i++) {
300039f0:	e3a03000 	mov	r3, #0
300039f4:	e58d3004 	str	r3, [sp, #4]
300039f8:	ea000015 	b	30003a54 <acoral_pools_init+0x70>
        pool->base_adr= (void *)&acoral_pools[i+1];
300039fc:	e59d3004 	ldr	r3, [sp, #4]
30003a00:	e2832001 	add	r2, r3, #1
30003a04:	e1a03002 	mov	r3, r2
30003a08:	e1a03083 	lsl	r3, r3, #1
30003a0c:	e0833002 	add	r3, r3, r2
30003a10:	e1a03103 	lsl	r3, r3, #2
30003a14:	e0833002 	add	r3, r3, r2
30003a18:	e1a03103 	lsl	r3, r3, #2
30003a1c:	e1a02003 	mov	r2, r3
30003a20:	e59f3058 	ldr	r3, [pc, #88]	; 30003a80 <acoral_pools_init+0x9c>
30003a24:	e0822003 	add	r2, r2, r3
30003a28:	e59d3000 	ldr	r3, [sp]
30003a2c:	e5832000 	str	r2, [r3]
		pool->id=i;
30003a30:	e59d2004 	ldr	r2, [sp, #4]
30003a34:	e59d3000 	ldr	r3, [sp]
30003a38:	e5832008 	str	r2, [r3, #8]
        pool++;
30003a3c:	e59d3000 	ldr	r3, [sp]
30003a40:	e2833034 	add	r3, r3, #52	; 0x34
30003a44:	e58d3000 	str	r3, [sp]
void  acoral_pools_init(void)
{
    acoral_pool_t  *pool;
    acoral_u32 i;
    pool = &acoral_pools[0];
    for (i = 0; i < (ACORAL_MAX_POOLS - 1); i++) {
30003a48:	e59d3004 	ldr	r3, [sp, #4]
30003a4c:	e2833001 	add	r3, r3, #1
30003a50:	e58d3004 	str	r3, [sp, #4]
30003a54:	e59d3004 	ldr	r3, [sp, #4]
30003a58:	e3530026 	cmp	r3, #38	; 0x26
30003a5c:	9affffe6 	bls	300039fc <acoral_pools_init+0x18>
        pool->base_adr= (void *)&acoral_pools[i+1];
		pool->id=i;
        pool++;
		acoral_spin_init(&pool->lock);
    }
    pool->base_adr= (void *)0;
30003a60:	e59d3000 	ldr	r3, [sp]
30003a64:	e3a02000 	mov	r2, #0
30003a68:	e5832000 	str	r2, [r3]
    acoral_free_res_pool = &acoral_pools[0];
30003a6c:	e59f3010 	ldr	r3, [pc, #16]	; 30003a84 <acoral_pools_init+0xa0>
30003a70:	e59f2008 	ldr	r2, [pc, #8]	; 30003a80 <acoral_pools_init+0x9c>
30003a74:	e5832000 	str	r2, [r3]
	acoral_spin_init(&acoral_free_res_pool->lock);
}
30003a78:	e28dd008 	add	sp, sp, #8
30003a7c:	e12fff1e 	bx	lr
30003a80:	3012ae14 	.word	0x3012ae14
30003a84:	300ea3b8 	.word	0x300ea3b8

30003a88 <acoral_pool_ctrl_init>:
/*================================
 *        resource pool control initial 
 *              资源池控制块初始化
 *================================*/
void acoral_pool_ctrl_init(acoral_pool_ctrl_t *pool_ctrl)
{
30003a88:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003a8c:	e24dd014 	sub	sp, sp, #20
30003a90:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 size;
	pool_ctrl->free_pools=&pool_ctrl->list[0];
30003a94:	e59d3004 	ldr	r3, [sp, #4]
30003a98:	e283201c 	add	r2, r3, #28
30003a9c:	e59d3004 	ldr	r3, [sp, #4]
30003aa0:	e5832014 	str	r2, [r3, #20]
	pool_ctrl->pools=&pool_ctrl->list[1];
30003aa4:	e59d3004 	ldr	r3, [sp, #4]
30003aa8:	e2832024 	add	r2, r3, #36	; 0x24
30003aac:	e59d3004 	ldr	r3, [sp, #4]
30003ab0:	e5832018 	str	r2, [r3, #24]
	pool_ctrl->num=0;
30003ab4:	e59d3004 	ldr	r3, [sp, #4]
30003ab8:	e3a02000 	mov	r2, #0
30003abc:	e583200c 	str	r2, [r3, #12]
	acoral_init_list(pool_ctrl->pools);
30003ac0:	e59d3004 	ldr	r3, [sp, #4]
30003ac4:	e5933018 	ldr	r3, [r3, #24]
30003ac8:	e59d2004 	ldr	r2, [sp, #4]
30003acc:	e5922018 	ldr	r2, [r2, #24]
30003ad0:	e5832000 	str	r2, [r3]
30003ad4:	e59d3004 	ldr	r3, [sp, #4]
30003ad8:	e5933018 	ldr	r3, [r3, #24]
30003adc:	e59d2004 	ldr	r2, [sp, #4]
30003ae0:	e5922018 	ldr	r2, [r2, #24]
30003ae4:	e5832004 	str	r2, [r3, #4]
    acoral_init_list(pool_ctrl->free_pools);
30003ae8:	e59d3004 	ldr	r3, [sp, #4]
30003aec:	e5933014 	ldr	r3, [r3, #20]
30003af0:	e59d2004 	ldr	r2, [sp, #4]
30003af4:	e5922014 	ldr	r2, [r2, #20]
30003af8:	e5832000 	str	r2, [r3]
30003afc:	e59d3004 	ldr	r3, [sp, #4]
30003b00:	e5933014 	ldr	r3, [r3, #20]
30003b04:	e59d2004 	ldr	r2, [sp, #4]
30003b08:	e5922014 	ldr	r2, [r2, #20]
30003b0c:	e5832004 	str	r2, [r3, #4]
    acoral_spin_init(&pool_ctrl->lock);
	/*调整pool的对象个数以最大化利用分配了的内存*/
	size=acoral_malloc_size(pool_ctrl->size*pool_ctrl->num_per_pool);
30003b10:	e59d3004 	ldr	r3, [sp, #4]
30003b14:	e5933004 	ldr	r3, [r3, #4]
30003b18:	e59d2004 	ldr	r2, [sp, #4]
30003b1c:	e5922008 	ldr	r2, [r2, #8]
30003b20:	e0030392 	mul	r3, r2, r3
30003b24:	e1a00003 	mov	r0, r3
30003b28:	eb0009fd 	bl	30006324 <buddy_malloc_size>
30003b2c:	e1a03000 	mov	r3, r0
30003b30:	e58d300c 	str	r3, [sp, #12]
	if(size<pool_ctrl->size){
30003b34:	e59d3004 	ldr	r3, [sp, #4]
30003b38:	e5932004 	ldr	r2, [r3, #4]
30003b3c:	e59d300c 	ldr	r3, [sp, #12]
30003b40:	e1520003 	cmp	r2, r3
30003b44:	9a000003 	bls	30003b58 <acoral_pool_ctrl_init+0xd0>
		pool_ctrl->num_per_pool=0;
30003b48:	e59d3004 	ldr	r3, [sp, #4]
30003b4c:	e3a02000 	mov	r2, #0
30003b50:	e5832008 	str	r2, [r3, #8]
30003b54:	ea00000a 	b	30003b84 <acoral_pool_ctrl_init+0xfc>
	}
	else{
		pool_ctrl->num_per_pool=size/pool_ctrl->size;
30003b58:	e59d3004 	ldr	r3, [sp, #4]
30003b5c:	e5933004 	ldr	r3, [r3, #4]
30003b60:	e59d000c 	ldr	r0, [sp, #12]
30003b64:	e1a01003 	mov	r1, r3
30003b68:	eb01004c 	bl	30043ca0 <__aeabi_uidiv>
30003b6c:	e1a03000 	mov	r3, r0
30003b70:	e1a02003 	mov	r2, r3
30003b74:	e59d3004 	ldr	r3, [sp, #4]
30003b78:	e5832008 	str	r2, [r3, #8]
		acoral_create_pool(pool_ctrl);
30003b7c:	e59d0004 	ldr	r0, [sp, #4]
30003b80:	ebfffd92 	bl	300031d0 <acoral_create_pool>
	}
}
30003b84:	e28dd014 	add	sp, sp, #20
30003b88:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003b8c:	e12fff1e 	bx	lr

30003b90 <acoral_obj_pool_init>:
 *        user resource api
 *         用户资源相关接口
 *================================*/

void acoral_obj_pool_init(acoral_pool_ctrl_t *pool_ctrl)
{
30003b90:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003b94:	e24dd00c 	sub	sp, sp, #12
30003b98:	e58d0004 	str	r0, [sp, #4]
	pool_ctrl->type=ACORAL_RES_USER;
30003b9c:	e59d3004 	ldr	r3, [sp, #4]
30003ba0:	e3a02006 	mov	r2, #6
30003ba4:	e5832000 	str	r2, [r3]
	pool_ctrl->size+=sizeof(acoral_res_t);
30003ba8:	e59d3004 	ldr	r3, [sp, #4]
30003bac:	e5933004 	ldr	r3, [r3, #4]
30003bb0:	e2832004 	add	r2, r3, #4
30003bb4:	e59d3004 	ldr	r3, [sp, #4]
30003bb8:	e5832004 	str	r2, [r3, #4]
	acoral_pool_ctrl_init(pool_ctrl);
30003bbc:	e59d0004 	ldr	r0, [sp, #4]
30003bc0:	ebffffb0 	bl	30003a88 <acoral_pool_ctrl_init>
}
30003bc4:	e28dd00c 	add	sp, sp, #12
30003bc8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003bcc:	e12fff1e 	bx	lr

30003bd0 <acoral_obj_pool_release>:

void acoral_obj_pool_release(acoral_pool_ctrl_t *pool_ctrl){
30003bd0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003bd4:	e24dd00c 	sub	sp, sp, #12
30003bd8:	e58d0004 	str	r0, [sp, #4]
	 acoral_release_pool(pool_ctrl);
30003bdc:	e59d0004 	ldr	r0, [sp, #4]
30003be0:	ebfffdd3 	bl	30003334 <acoral_release_pool>
}
30003be4:	e28dd00c 	add	sp, sp, #12
30003be8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003bec:	e12fff1e 	bx	lr

30003bf0 <acoral_get_obj>:

void *acoral_get_obj(acoral_pool_ctrl_t *pool_ctrl){
30003bf0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003bf4:	e24dd00c 	sub	sp, sp, #12
30003bf8:	e58d0004 	str	r0, [sp, #4]
	return (void *)((acoral_char *)acoral_get_res(pool_ctrl)+sizeof(acoral_res_t));
30003bfc:	e59d0004 	ldr	r0, [sp, #4]
30003c00:	ebfffe41 	bl	3000350c <acoral_get_res>
30003c04:	e1a03000 	mov	r3, r0
30003c08:	e2833004 	add	r3, r3, #4
}
30003c0c:	e1a00003 	mov	r0, r3
30003c10:	e28dd00c 	add	sp, sp, #12
30003c14:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003c18:	e12fff1e 	bx	lr

30003c1c <acoral_free_obj>:

void acoral_free_obj(void *obj){
30003c1c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003c20:	e24dd00c 	sub	sp, sp, #12
30003c24:	e58d0004 	str	r0, [sp, #4]
	acoral_release_res((acoral_char *)obj-sizeof(acoral_res_t));
30003c28:	e59d3004 	ldr	r3, [sp, #4]
30003c2c:	e2433004 	sub	r3, r3, #4
30003c30:	e1a00003 	mov	r0, r3
30003c34:	ebfffe7f 	bl	30003638 <acoral_release_res>
}
30003c38:	e28dd00c 	add	sp, sp, #12
30003c3c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003c40:	e12fff1e 	bx	lr

30003c44 <acoral_res_sys_init>:

/*================================
 *        resource  system initial 
 *          资源系统初始化
 *================================*/
void acoral_res_sys_init(){
30003c44:	e92d4008 	push	{r3, lr}
	acoral_pools_init();
30003c48:	ebffff65 	bl	300039e4 <acoral_pools_init>
}
30003c4c:	e8bd4008 	pop	{r3, lr}
30003c50:	e12fff1e 	bx	lr

30003c54 <acoral_assert_res>:

acoral_char acoral_assert_res(acoral_res_t *res,acoral_8 *assert){
30003c54:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003c58:	e24dd00c 	sub	sp, sp, #12
30003c5c:	e58d0004 	str	r0, [sp, #4]
30003c60:	e58d1000 	str	r1, [sp]
	if(res==NULL||acoral_get_res_by_id(res->id)!=res){
30003c64:	e59d3004 	ldr	r3, [sp, #4]
30003c68:	e3530000 	cmp	r3, #0
30003c6c:	0a000007 	beq	30003c90 <acoral_assert_res+0x3c>
30003c70:	e59d3004 	ldr	r3, [sp, #4]
30003c74:	e5933000 	ldr	r3, [r3]
30003c78:	e1a00003 	mov	r0, r3
30003c7c:	ebffff01 	bl	30003888 <acoral_get_res_by_id>
30003c80:	e1a02000 	mov	r2, r0
30003c84:	e59d3004 	ldr	r3, [sp, #4]
30003c88:	e1520003 	cmp	r2, r3
30003c8c:	0a000009 	beq	30003cb8 <acoral_assert_res+0x64>
		acoral_printerr("%s\n",assert);
30003c90:	e59f0034 	ldr	r0, [pc, #52]	; 30003ccc <acoral_assert_res+0x78>
30003c94:	e59d1000 	ldr	r1, [sp]
30003c98:	eb001d68 	bl	3000b240 <acoral_print>
		acoral_printerr("Err res's id:%x\n",res->id);
30003c9c:	e59d3004 	ldr	r3, [sp, #4]
30003ca0:	e5933000 	ldr	r3, [r3]
30003ca4:	e59f0024 	ldr	r0, [pc, #36]	; 30003cd0 <acoral_assert_res+0x7c>
30003ca8:	e1a01003 	mov	r1, r3
30003cac:	eb001d63 	bl	3000b240 <acoral_print>
		return false;
30003cb0:	e3a03000 	mov	r3, #0
30003cb4:	ea000000 	b	30003cbc <acoral_assert_res+0x68>
	}
	return true;
30003cb8:	e3a03001 	mov	r3, #1
}
30003cbc:	e1a00003 	mov	r0, r3
30003cc0:	e28dd00c 	add	sp, sp, #12
30003cc4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003cc8:	e12fff1e 	bx	lr
30003ccc:	30045148 	.word	0x30045148
30003cd0:	3004514c 	.word	0x3004514c

30003cd4 <acoral_intr_sys_init>:

/*===========================                                                                                                                 
*Initialize the interrupt      
*中断初始化函数
*===========================*/
void acoral_intr_sys_init(){
30003cd4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003cd8:	e24dd00c 	sub	sp, sp, #12
	acoral_u32 i;
	acoral_vector index;
      
    /*关中断*/
	acoral_intr_disable();
30003cdc:	ebfff67d 	bl	300016d8 <HAL_INTR_DISABLE>

    /*中断嵌套标志初始化*/
    HAL_INTR_NESTING_INIT();
30003ce0:	ebfff68d 	bl	3000171c <hal_intr_nesting_init_comm>

    /*中断底层初始化函数*/
	HAL_INTR_INIT();
30003ce4:	ebfff29f 	bl	30000768 <hal_intr_init>


    /*对于每个中断，设置默认的服务处理程序，然后屏蔽该中断*/
	for(i=HAL_INTR_MIN;i<=HAL_INTR_MAX;i++){
30003ce8:	e3a03000 	mov	r3, #0
30003cec:	e58d3000 	str	r3, [sp]
30003cf0:	ea00001b 	b	30003d64 <acoral_intr_sys_init+0x90>
		HAL_TRANSLATE_VECTOR(i,index);
30003cf4:	e59d3000 	ldr	r3, [sp]
30003cf8:	e58d3004 	str	r3, [sp, #4]
		intr_table[index].isr=acoral_default_isr;
30003cfc:	e59d2004 	ldr	r2, [sp, #4]
30003d00:	e59f0074 	ldr	r0, [pc, #116]	; 30003d7c <acoral_intr_sys_init+0xa8>
30003d04:	e3a01008 	mov	r1, #8
30003d08:	e1a03002 	mov	r3, r2
30003d0c:	e1a03183 	lsl	r3, r3, #3
30003d10:	e0623003 	rsb	r3, r2, r3
30003d14:	e1a03103 	lsl	r3, r3, #2
30003d18:	e0833000 	add	r3, r3, r0
30003d1c:	e0833001 	add	r3, r3, r1
30003d20:	e59f2058 	ldr	r2, [pc, #88]	; 30003d80 <acoral_intr_sys_init+0xac>
30003d24:	e5832000 	str	r2, [r3]
		intr_table[index].type=ACORAL_COMM_INTR;
30003d28:	e59d2004 	ldr	r2, [sp, #4]
30003d2c:	e59f1048 	ldr	r1, [pc, #72]	; 30003d7c <acoral_intr_sys_init+0xa8>
30003d30:	e1a03002 	mov	r3, r2
30003d34:	e1a03183 	lsl	r3, r3, #3
30003d38:	e0623003 	rsb	r3, r2, r3
30003d3c:	e1a03103 	lsl	r3, r3, #2
30003d40:	e0833001 	add	r3, r3, r1
30003d44:	e3a02001 	mov	r2, #1
30003d48:	e5c32005 	strb	r2, [r3, #5]
		acoral_intr_mask(i);
30003d4c:	e59d3000 	ldr	r3, [sp]
30003d50:	e1a00003 	mov	r0, r3
30003d54:	eb000078 	bl	30003f3c <acoral_intr_mask>
    /*中断底层初始化函数*/
	HAL_INTR_INIT();


    /*对于每个中断，设置默认的服务处理程序，然后屏蔽该中断*/
	for(i=HAL_INTR_MIN;i<=HAL_INTR_MAX;i++){
30003d58:	e59d3000 	ldr	r3, [sp]
30003d5c:	e2833001 	add	r3, r3, #1
30003d60:	e58d3000 	str	r3, [sp]
30003d64:	e59d3000 	ldr	r3, [sp]
30003d68:	e3530031 	cmp	r3, #49	; 0x31
30003d6c:	9affffe0 	bls	30003cf4 <acoral_intr_sys_init+0x20>
		HAL_TRANSLATE_VECTOR(i,index);
		intr_table[index].isr=acoral_default_isr;
		intr_table[index].type=ACORAL_COMM_INTR;
		acoral_intr_mask(i);
	}
}
30003d70:	e28dd00c 	add	sp, sp, #12
30003d74:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003d78:	e12fff1e 	bx	lr
30003d7c:	300ea48c 	.word	0x300ea48c
30003d80:	300041cc 	.word	0x300041cc

30003d84 <acoral_intr_attach>:

/*===========================                                                                                                                 
*Binding the isr t0 the Vector      
*将服务函数isr绑定到中断向量Vector
*===========================*/
acoral_32 acoral_intr_attach(acoral_vector vector,void (*isr)(acoral_vector)){
30003d84:	e24dd010 	sub	sp, sp, #16
30003d88:	e58d0004 	str	r0, [sp, #4]
30003d8c:	e58d1000 	str	r1, [sp]
  	acoral_vector index;
   	HAL_TRANSLATE_VECTOR(vector,index);
30003d90:	e59d3004 	ldr	r3, [sp, #4]
30003d94:	e58d300c 	str	r3, [sp, #12]
	if(intr_table[index].type!=ACORAL_RT_INTR)
30003d98:	e59d200c 	ldr	r2, [sp, #12]
30003d9c:	e59f1058 	ldr	r1, [pc, #88]	; 30003dfc <acoral_intr_attach+0x78>
30003da0:	e1a03002 	mov	r3, r2
30003da4:	e1a03183 	lsl	r3, r3, #3
30003da8:	e0623003 	rsb	r3, r2, r3
30003dac:	e1a03103 	lsl	r3, r3, #2
30003db0:	e0833001 	add	r3, r3, r1
30003db4:	e5d33005 	ldrb	r3, [r3, #5]
30003db8:	e3530003 	cmp	r3, #3
30003dbc:	0a00000a 	beq	30003dec <acoral_intr_attach+0x68>
		intr_table[index].isr =isr;
30003dc0:	e59d200c 	ldr	r2, [sp, #12]
30003dc4:	e59f0030 	ldr	r0, [pc, #48]	; 30003dfc <acoral_intr_attach+0x78>
30003dc8:	e3a01008 	mov	r1, #8
30003dcc:	e1a03002 	mov	r3, r2
30003dd0:	e1a03183 	lsl	r3, r3, #3
30003dd4:	e0623003 	rsb	r3, r2, r3
30003dd8:	e1a03103 	lsl	r3, r3, #2
30003ddc:	e0833000 	add	r3, r3, r0
30003de0:	e0833001 	add	r3, r3, r1
30003de4:	e59d2000 	ldr	r2, [sp]
30003de8:	e5832000 	str	r2, [r3]
	else
		HAL_INTR_ATTACH(vector,isr);
	return 0;
30003dec:	e3a03000 	mov	r3, #0
}
30003df0:	e1a00003 	mov	r0, r3
30003df4:	e28dd010 	add	sp, sp, #16
30003df8:	e12fff1e 	bx	lr
30003dfc:	300ea48c 	.word	0x300ea48c

30003e00 <acoral_intr_detach>:

/*===========================                                                                                                                 
*Detach the  isr from the Vector      
*将中断的服务函数设为默认的
*===========================*/
acoral_32 acoral_intr_detach(acoral_vector vector){
30003e00:	e24dd010 	sub	sp, sp, #16
30003e04:	e58d0004 	str	r0, [sp, #4]
  	acoral_vector index;
   	HAL_TRANSLATE_VECTOR(vector,index);
30003e08:	e59d3004 	ldr	r3, [sp, #4]
30003e0c:	e58d300c 	str	r3, [sp, #12]
	intr_table[index].isr =acoral_default_isr;
30003e10:	e59d200c 	ldr	r2, [sp, #12]
30003e14:	e59f0030 	ldr	r0, [pc, #48]	; 30003e4c <acoral_intr_detach+0x4c>
30003e18:	e3a01008 	mov	r1, #8
30003e1c:	e1a03002 	mov	r3, r2
30003e20:	e1a03183 	lsl	r3, r3, #3
30003e24:	e0623003 	rsb	r3, r2, r3
30003e28:	e1a03103 	lsl	r3, r3, #2
30003e2c:	e0833000 	add	r3, r3, r0
30003e30:	e0833001 	add	r3, r3, r1
30003e34:	e59f2014 	ldr	r2, [pc, #20]	; 30003e50 <acoral_intr_detach+0x50>
30003e38:	e5832000 	str	r2, [r3]
	return 0;
30003e3c:	e3a03000 	mov	r3, #0
}
30003e40:	e1a00003 	mov	r0, r3
30003e44:	e28dd010 	add	sp, sp, #16
30003e48:	e12fff1e 	bx	lr
30003e4c:	300ea48c 	.word	0x300ea48c
30003e50:	300041cc 	.word	0x300041cc

30003e54 <acoral_intr_unmask>:

/*===========================                                                                                                                 
*Enable the interrupt      
*使能中断
*===========================*/
void acoral_intr_unmask(acoral_vector vector){
30003e54:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003e58:	e24dd014 	sub	sp, sp, #20
30003e5c:	e58d0004 	str	r0, [sp, #4]
  	acoral_vector index;
	if(vector>HAL_INTR_MAX)
30003e60:	e59d3004 	ldr	r3, [sp, #4]
30003e64:	e3530031 	cmp	r3, #49	; 0x31
30003e68:	ca00002e 	bgt	30003f28 <acoral_intr_unmask+0xd4>
		return;
   	HAL_TRANSLATE_VECTOR(vector,index);
30003e6c:	e59d3004 	ldr	r3, [sp, #4]
30003e70:	e58d300c 	str	r3, [sp, #12]

        /*如果中断的使能函数不为空，就调用该使能函数*/
	if(intr_table[index].unmask!=NULL&&intr_table[index].type==ACORAL_COMM_INTR){
30003e74:	e59d200c 	ldr	r2, [sp, #12]
30003e78:	e59f00b8 	ldr	r0, [pc, #184]	; 30003f38 <acoral_intr_unmask+0xe4>
30003e7c:	e3a01018 	mov	r1, #24
30003e80:	e1a03002 	mov	r3, r2
30003e84:	e1a03183 	lsl	r3, r3, #3
30003e88:	e0623003 	rsb	r3, r2, r3
30003e8c:	e1a03103 	lsl	r3, r3, #2
30003e90:	e0833000 	add	r3, r3, r0
30003e94:	e0833001 	add	r3, r3, r1
30003e98:	e5933000 	ldr	r3, [r3]
30003e9c:	e3530000 	cmp	r3, #0
30003ea0:	0a000021 	beq	30003f2c <acoral_intr_unmask+0xd8>
30003ea4:	e59d200c 	ldr	r2, [sp, #12]
30003ea8:	e59f1088 	ldr	r1, [pc, #136]	; 30003f38 <acoral_intr_unmask+0xe4>
30003eac:	e1a03002 	mov	r3, r2
30003eb0:	e1a03183 	lsl	r3, r3, #3
30003eb4:	e0623003 	rsb	r3, r2, r3
30003eb8:	e1a03103 	lsl	r3, r3, #2
30003ebc:	e0833001 	add	r3, r3, r1
30003ec0:	e5d33005 	ldrb	r3, [r3, #5]
30003ec4:	e3530001 	cmp	r3, #1
30003ec8:	1a000017 	bne	30003f2c <acoral_intr_unmask+0xd8>
		intr_table[index].unmask(vector);
30003ecc:	e59d200c 	ldr	r2, [sp, #12]
30003ed0:	e59f0060 	ldr	r0, [pc, #96]	; 30003f38 <acoral_intr_unmask+0xe4>
30003ed4:	e3a01018 	mov	r1, #24
30003ed8:	e1a03002 	mov	r3, r2
30003edc:	e1a03183 	lsl	r3, r3, #3
30003ee0:	e0623003 	rsb	r3, r2, r3
30003ee4:	e1a03103 	lsl	r3, r3, #2
30003ee8:	e0833000 	add	r3, r3, r0
30003eec:	e0833001 	add	r3, r3, r1
30003ef0:	e5933000 	ldr	r3, [r3]
30003ef4:	e59d0004 	ldr	r0, [sp, #4]
30003ef8:	e1a0e00f 	mov	lr, pc
30003efc:	e12fff13 	bx	r3
		/*将中断状态设为真*/
		intr_table[index].state=true;
30003f00:	e59d200c 	ldr	r2, [sp, #12]
30003f04:	e59f102c 	ldr	r1, [pc, #44]	; 30003f38 <acoral_intr_unmask+0xe4>
30003f08:	e1a03002 	mov	r3, r2
30003f0c:	e1a03183 	lsl	r3, r3, #3
30003f10:	e0623003 	rsb	r3, r2, r3
30003f14:	e1a03103 	lsl	r3, r3, #2
30003f18:	e0833001 	add	r3, r3, r1
30003f1c:	e3a02001 	mov	r2, #1
30003f20:	e5c32004 	strb	r2, [r3, #4]
30003f24:	ea000000 	b	30003f2c <acoral_intr_unmask+0xd8>
*使能中断
*===========================*/
void acoral_intr_unmask(acoral_vector vector){
  	acoral_vector index;
	if(vector>HAL_INTR_MAX)
		return;
30003f28:	e1a00000 	nop			; (mov r0, r0)
	if(intr_table[index].unmask!=NULL&&intr_table[index].type==ACORAL_COMM_INTR){
		intr_table[index].unmask(vector);
		/*将中断状态设为真*/
		intr_table[index].state=true;
	}
}
30003f2c:	e28dd014 	add	sp, sp, #20
30003f30:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30003f34:	e12fff1e 	bx	lr
30003f38:	300ea48c 	.word	0x300ea48c

30003f3c <acoral_intr_mask>:

/*===========================                                                                                                                 
*Disable the interrupt       
*除能中断
*===========================*/
void acoral_intr_mask(acoral_vector vector){
30003f3c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30003f40:	e24dd014 	sub	sp, sp, #20
30003f44:	e58d0004 	str	r0, [sp, #4]
  	acoral_vector index;
	if(vector>HAL_INTR_MAX)
30003f48:	e59d3004 	ldr	r3, [sp, #4]
30003f4c:	e3530031 	cmp	r3, #49	; 0x31
30003f50:	ca00002e 	bgt	30004010 <acoral_intr_mask+0xd4>
		return;
   	HAL_TRANSLATE_VECTOR(vector,index);
30003f54:	e59d3004 	ldr	r3, [sp, #4]
30003f58:	e58d300c 	str	r3, [sp, #12]

        /*如果中断的除能函数不为空，就调用该除能函数 */
	if(intr_table[index].mask!=NULL&&intr_table[index].type==ACORAL_COMM_INTR){
30003f5c:	e59d200c 	ldr	r2, [sp, #12]
30003f60:	e59f00b8 	ldr	r0, [pc, #184]	; 30004020 <acoral_intr_mask+0xe4>
30003f64:	e3a01014 	mov	r1, #20
30003f68:	e1a03002 	mov	r3, r2
30003f6c:	e1a03183 	lsl	r3, r3, #3
30003f70:	e0623003 	rsb	r3, r2, r3
30003f74:	e1a03103 	lsl	r3, r3, #2
30003f78:	e0833000 	add	r3, r3, r0
30003f7c:	e0833001 	add	r3, r3, r1
30003f80:	e5933000 	ldr	r3, [r3]
30003f84:	e3530000 	cmp	r3, #0
30003f88:	0a000021 	beq	30004014 <acoral_intr_mask+0xd8>
30003f8c:	e59d200c 	ldr	r2, [sp, #12]
30003f90:	e59f1088 	ldr	r1, [pc, #136]	; 30004020 <acoral_intr_mask+0xe4>
30003f94:	e1a03002 	mov	r3, r2
30003f98:	e1a03183 	lsl	r3, r3, #3
30003f9c:	e0623003 	rsb	r3, r2, r3
30003fa0:	e1a03103 	lsl	r3, r3, #2
30003fa4:	e0833001 	add	r3, r3, r1
30003fa8:	e5d33005 	ldrb	r3, [r3, #5]
30003fac:	e3530001 	cmp	r3, #1
30003fb0:	1a000017 	bne	30004014 <acoral_intr_mask+0xd8>
		intr_table[index].mask(vector);
30003fb4:	e59d200c 	ldr	r2, [sp, #12]
30003fb8:	e59f0060 	ldr	r0, [pc, #96]	; 30004020 <acoral_intr_mask+0xe4>
30003fbc:	e3a01014 	mov	r1, #20
30003fc0:	e1a03002 	mov	r3, r2
30003fc4:	e1a03183 	lsl	r3, r3, #3
30003fc8:	e0623003 	rsb	r3, r2, r3
30003fcc:	e1a03103 	lsl	r3, r3, #2
30003fd0:	e0833000 	add	r3, r3, r0
30003fd4:	e0833001 	add	r3, r3, r1
30003fd8:	e5933000 	ldr	r3, [r3]
30003fdc:	e59d0004 	ldr	r0, [sp, #4]
30003fe0:	e1a0e00f 	mov	lr, pc
30003fe4:	e12fff13 	bx	r3
		/*将中断状态设为假    */
		intr_table[index].state=false;
30003fe8:	e59d200c 	ldr	r2, [sp, #12]
30003fec:	e59f102c 	ldr	r1, [pc, #44]	; 30004020 <acoral_intr_mask+0xe4>
30003ff0:	e1a03002 	mov	r3, r2
30003ff4:	e1a03183 	lsl	r3, r3, #3
30003ff8:	e0623003 	rsb	r3, r2, r3
30003ffc:	e1a03103 	lsl	r3, r3, #2
30004000:	e0833001 	add	r3, r3, r1
30004004:	e3a02000 	mov	r2, #0
30004008:	e5c32004 	strb	r2, [r3, #4]
3000400c:	ea000000 	b	30004014 <acoral_intr_mask+0xd8>
*除能中断
*===========================*/
void acoral_intr_mask(acoral_vector vector){
  	acoral_vector index;
	if(vector>HAL_INTR_MAX)
		return;
30004010:	e1a00000 	nop			; (mov r0, r0)
	if(intr_table[index].mask!=NULL&&intr_table[index].type==ACORAL_COMM_INTR){
		intr_table[index].mask(vector);
		/*将中断状态设为假    */
		intr_table[index].state=false;
	}
}
30004014:	e28dd014 	add	sp, sp, #20
30004018:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000401c:	e12fff1e 	bx	lr
30004020:	300ea48c 	.word	0x300ea48c

30004024 <acoral_intr_entry>:

/*===========================                                                                                                                 
*the commen isr of vector      
*中断公共服务入口函数
*===========================*/
void acoral_intr_entry(acoral_vector vector){
30004024:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004028:	e24dd014 	sub	sp, sp, #20
3000402c:	e58d0004 	str	r0, [sp, #4]
	acoral_vector index;
#ifdef CFG_DEBUG
  	acoral_print("isr in cpu:%d\n",acoral_current_cpu);
#endif
   	HAL_TRANSLATE_VECTOR(vector,index);
30004030:	e59d3004 	ldr	r3, [sp, #4]
30004034:	e58d300c 	str	r3, [sp, #12]
	acoral_intr_nesting_inc();
30004038:	ebfff5de 	bl	300017b8 <hal_intr_nesting_inc_comm>
	if(intr_table[index].type==ACORAL_EXPERT_INTR){
3000403c:	e59d200c 	ldr	r2, [sp, #12]
30004040:	e59f1180 	ldr	r1, [pc, #384]	; 300041c8 <acoral_intr_entry+0x1a4>
30004044:	e1a03002 	mov	r3, r2
30004048:	e1a03183 	lsl	r3, r3, #3
3000404c:	e0623003 	rsb	r3, r2, r3
30004050:	e1a03103 	lsl	r3, r3, #2
30004054:	e0833001 	add	r3, r3, r1
30004058:	e5d33005 	ldrb	r3, [r3, #5]
3000405c:	e3530002 	cmp	r3, #2
30004060:	1a00000e 	bne	300040a0 <acoral_intr_entry+0x7c>
		intr_table[index].isr(vector);
30004064:	e59d200c 	ldr	r2, [sp, #12]
30004068:	e59f0158 	ldr	r0, [pc, #344]	; 300041c8 <acoral_intr_entry+0x1a4>
3000406c:	e3a01008 	mov	r1, #8
30004070:	e1a03002 	mov	r3, r2
30004074:	e1a03183 	lsl	r3, r3, #3
30004078:	e0623003 	rsb	r3, r2, r3
3000407c:	e1a03103 	lsl	r3, r3, #2
30004080:	e0833000 	add	r3, r3, r0
30004084:	e0833001 	add	r3, r3, r1
30004088:	e5933000 	ldr	r3, [r3]
3000408c:	e59d0004 	ldr	r0, [sp, #4]
30004090:	e1a0e00f 	mov	lr, pc
30004094:	e12fff13 	bx	r3
		acoral_intr_disable();
30004098:	ebfff58e 	bl	300016d8 <HAL_INTR_DISABLE>
3000409c:	ea000044 	b	300041b4 <acoral_intr_entry+0x190>
	}else{
		/*这个之前都要是关中断的，调用中断进入函数*/
		if(intr_table[index].enter!=NULL)
300040a0:	e59d200c 	ldr	r2, [sp, #12]
300040a4:	e59f011c 	ldr	r0, [pc, #284]	; 300041c8 <acoral_intr_entry+0x1a4>
300040a8:	e3a0100c 	mov	r1, #12
300040ac:	e1a03002 	mov	r3, r2
300040b0:	e1a03183 	lsl	r3, r3, #3
300040b4:	e0623003 	rsb	r3, r2, r3
300040b8:	e1a03103 	lsl	r3, r3, #2
300040bc:	e0833000 	add	r3, r3, r0
300040c0:	e0833001 	add	r3, r3, r1
300040c4:	e5933000 	ldr	r3, [r3]
300040c8:	e3530000 	cmp	r3, #0
300040cc:	0a00000c 	beq	30004104 <acoral_intr_entry+0xe0>
			intr_table[index].enter(vector);
300040d0:	e59d200c 	ldr	r2, [sp, #12]
300040d4:	e59f00ec 	ldr	r0, [pc, #236]	; 300041c8 <acoral_intr_entry+0x1a4>
300040d8:	e3a0100c 	mov	r1, #12
300040dc:	e1a03002 	mov	r3, r2
300040e0:	e1a03183 	lsl	r3, r3, #3
300040e4:	e0623003 	rsb	r3, r2, r3
300040e8:	e1a03103 	lsl	r3, r3, #2
300040ec:	e0833000 	add	r3, r3, r0
300040f0:	e0833001 	add	r3, r3, r1
300040f4:	e5933000 	ldr	r3, [r3]
300040f8:	e59d0004 	ldr	r0, [sp, #4]
300040fc:	e1a0e00f 	mov	lr, pc
30004100:	e12fff13 	bx	r3
	
		acoral_intr_mask(vector);	
30004104:	e59d0004 	ldr	r0, [sp, #4]
30004108:	ebffff8b 	bl	30003f3c <acoral_intr_mask>
		/*开中断*/
		acoral_intr_enable();
3000410c:	ebfff56d 	bl	300016c8 <HAL_INTR_ENABLE>

		/*调用该中断的服务处理函数*/
		intr_table[index].isr(vector);
30004110:	e59d200c 	ldr	r2, [sp, #12]
30004114:	e59f00ac 	ldr	r0, [pc, #172]	; 300041c8 <acoral_intr_entry+0x1a4>
30004118:	e3a01008 	mov	r1, #8
3000411c:	e1a03002 	mov	r3, r2
30004120:	e1a03183 	lsl	r3, r3, #3
30004124:	e0623003 	rsb	r3, r2, r3
30004128:	e1a03103 	lsl	r3, r3, #2
3000412c:	e0833000 	add	r3, r3, r0
30004130:	e0833001 	add	r3, r3, r1
30004134:	e5933000 	ldr	r3, [r3]
30004138:	e59d0004 	ldr	r0, [sp, #4]
3000413c:	e1a0e00f 	mov	lr, pc
30004140:	e12fff13 	bx	r3
	
		/*关中断*/
		acoral_intr_disable();
30004144:	ebfff563 	bl	300016d8 <HAL_INTR_DISABLE>
	
		acoral_intr_unmask(vector);	
30004148:	e59d0004 	ldr	r0, [sp, #4]
3000414c:	ebffff40 	bl	30003e54 <acoral_intr_unmask>
		/*调用中断退出函数*/
		if(intr_table[index].exit!=NULL)
30004150:	e59d200c 	ldr	r2, [sp, #12]
30004154:	e59f006c 	ldr	r0, [pc, #108]	; 300041c8 <acoral_intr_entry+0x1a4>
30004158:	e3a01010 	mov	r1, #16
3000415c:	e1a03002 	mov	r3, r2
30004160:	e1a03183 	lsl	r3, r3, #3
30004164:	e0623003 	rsb	r3, r2, r3
30004168:	e1a03103 	lsl	r3, r3, #2
3000416c:	e0833000 	add	r3, r3, r0
30004170:	e0833001 	add	r3, r3, r1
30004174:	e5933000 	ldr	r3, [r3]
30004178:	e3530000 	cmp	r3, #0
3000417c:	0a00000c 	beq	300041b4 <acoral_intr_entry+0x190>
			intr_table[index].exit(vector);
30004180:	e59d200c 	ldr	r2, [sp, #12]
30004184:	e59f003c 	ldr	r0, [pc, #60]	; 300041c8 <acoral_intr_entry+0x1a4>
30004188:	e3a01010 	mov	r1, #16
3000418c:	e1a03002 	mov	r3, r2
30004190:	e1a03183 	lsl	r3, r3, #3
30004194:	e0623003 	rsb	r3, r2, r3
30004198:	e1a03103 	lsl	r3, r3, #2
3000419c:	e0833000 	add	r3, r3, r0
300041a0:	e0833001 	add	r3, r3, r1
300041a4:	e5933000 	ldr	r3, [r3]
300041a8:	e59d0004 	ldr	r0, [sp, #4]
300041ac:	e1a0e00f 	mov	lr, pc
300041b0:	e12fff13 	bx	r3
	}
	acoral_intr_nesting_dec();
300041b4:	ebfff56e 	bl	30001774 <hal_intr_nesting_dec_comm>
	acoral_intr_exit();
300041b8:	eb000007 	bl	300041dc <acoral_intr_exit>
}
300041bc:	e28dd014 	add	sp, sp, #20
300041c0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300041c4:	e12fff1e 	bx	lr
300041c8:	300ea48c 	.word	0x300ea48c

300041cc <acoral_default_isr>:

/*===========================                                                                                                                 
*The default isr      
*默认中断处理程序
*===========================*/
void acoral_default_isr(acoral_vector vector){
300041cc:	e24dd008 	sub	sp, sp, #8
300041d0:	e58d0004 	str	r0, [sp, #4]
  	acoral_printdbg("in Default interrupt route\n");
}
300041d4:	e28dd008 	add	sp, sp, #8
300041d8:	e12fff1e 	bx	lr

300041dc <acoral_intr_exit>:

/*===========================                                                                                                                 
*The exit function of the vector      
*中断退出函数
*===========================*/
void acoral_intr_exit(){
300041dc:	e92d4008 	push	{r3, lr}
      	if(!acoral_need_sched)
300041e0:	e59f3064 	ldr	r3, [pc, #100]	; 3000424c <acoral_intr_exit+0x70>
300041e4:	e5d33000 	ldrb	r3, [r3]
300041e8:	e3530000 	cmp	r3, #0
300041ec:	0a00000d 	beq	30004228 <acoral_intr_exit+0x4c>
	    return;

	if(acoral_intr_nesting)
300041f0:	ebfff55a 	bl	30001760 <hal_get_intr_nesting_comm>
300041f4:	e1a03000 	mov	r3, r0
300041f8:	e3530000 	cmp	r3, #0
300041fc:	1a00000b 	bne	30004230 <acoral_intr_exit+0x54>
	    return;

	if(acoral_sched_is_lock)
30004200:	e59f3048 	ldr	r3, [pc, #72]	; 30004250 <acoral_intr_exit+0x74>
30004204:	e5d33000 	ldrb	r3, [r3]
30004208:	e3530000 	cmp	r3, #0
3000420c:	1a000009 	bne	30004238 <acoral_intr_exit+0x5c>
	    return;

	if (!acoral_start_sched)
30004210:	e59f303c 	ldr	r3, [pc, #60]	; 30004254 <acoral_intr_exit+0x78>
30004214:	e5933000 	ldr	r3, [r3]
30004218:	e3530000 	cmp	r3, #0
3000421c:	0a000007 	beq	30004240 <acoral_intr_exit+0x64>
	    return;
      
      /*如果需要调度，则调用此函数*/
	HAL_INTR_EXIT_BRIDGE();
30004220:	ebfff576 	bl	30001800 <hal_intr_exit_bridge_comm>
30004224:	ea000006 	b	30004244 <acoral_intr_exit+0x68>
*The exit function of the vector      
*中断退出函数
*===========================*/
void acoral_intr_exit(){
      	if(!acoral_need_sched)
	    return;
30004228:	e1a00000 	nop			; (mov r0, r0)
3000422c:	ea000004 	b	30004244 <acoral_intr_exit+0x68>

	if(acoral_intr_nesting)
	    return;
30004230:	e1a00000 	nop			; (mov r0, r0)
30004234:	ea000002 	b	30004244 <acoral_intr_exit+0x68>

	if(acoral_sched_is_lock)
	    return;
30004238:	e1a00000 	nop			; (mov r0, r0)
3000423c:	ea000000 	b	30004244 <acoral_intr_exit+0x68>

	if (!acoral_start_sched)
	    return;
30004240:	e1a00000 	nop			; (mov r0, r0)
      
      /*如果需要调度，则调用此函数*/
	HAL_INTR_EXIT_BRIDGE();
}
30004244:	e8bd4008 	pop	{r3, lr}
30004248:	e12fff1e 	bx	lr
3000424c:	302bf848 	.word	0x302bf848
30004250:	300ea488 	.word	0x300ea488
30004254:	300c9a98 	.word	0x300c9a98

30004258 <acoral_set_intr_enter>:

/*===========================                                                                                                                 
*Set the enter function of the vector      
*设置中断进入函数为isr
*===========================*/
void acoral_set_intr_enter(acoral_vector vector,void (*enter)(acoral_vector)){
30004258:	e24dd010 	sub	sp, sp, #16
3000425c:	e58d0004 	str	r0, [sp, #4]
30004260:	e58d1000 	str	r1, [sp]
	acoral_vector index;
	HAL_TRANSLATE_VECTOR(vector,index);
30004264:	e59d3004 	ldr	r3, [sp, #4]
30004268:	e58d300c 	str	r3, [sp, #12]
	intr_table[index].enter=enter;
3000426c:	e59d200c 	ldr	r2, [sp, #12]
30004270:	e59f0028 	ldr	r0, [pc, #40]	; 300042a0 <acoral_set_intr_enter+0x48>
30004274:	e3a0100c 	mov	r1, #12
30004278:	e1a03002 	mov	r3, r2
3000427c:	e1a03183 	lsl	r3, r3, #3
30004280:	e0623003 	rsb	r3, r2, r3
30004284:	e1a03103 	lsl	r3, r3, #2
30004288:	e0833000 	add	r3, r3, r0
3000428c:	e0833001 	add	r3, r3, r1
30004290:	e59d2000 	ldr	r2, [sp]
30004294:	e5832000 	str	r2, [r3]
}
30004298:	e28dd010 	add	sp, sp, #16
3000429c:	e12fff1e 	bx	lr
300042a0:	300ea48c 	.word	0x300ea48c

300042a4 <acoral_set_intr_exit>:

/*===========================                                                                                                                 
*Set the exit  function of the vector 
*设置中断退出函数为isr
*===========================*/
void acoral_set_intr_exit(acoral_vector vector,void (*exit)(acoral_vector)){
300042a4:	e24dd010 	sub	sp, sp, #16
300042a8:	e58d0004 	str	r0, [sp, #4]
300042ac:	e58d1000 	str	r1, [sp]
	acoral_vector index;
	HAL_TRANSLATE_VECTOR(vector,index);
300042b0:	e59d3004 	ldr	r3, [sp, #4]
300042b4:	e58d300c 	str	r3, [sp, #12]
	intr_table[index].exit=exit;
300042b8:	e59d200c 	ldr	r2, [sp, #12]
300042bc:	e59f0028 	ldr	r0, [pc, #40]	; 300042ec <acoral_set_intr_exit+0x48>
300042c0:	e3a01010 	mov	r1, #16
300042c4:	e1a03002 	mov	r3, r2
300042c8:	e1a03183 	lsl	r3, r3, #3
300042cc:	e0623003 	rsb	r3, r2, r3
300042d0:	e1a03103 	lsl	r3, r3, #2
300042d4:	e0833000 	add	r3, r3, r0
300042d8:	e0833001 	add	r3, r3, r1
300042dc:	e59d2000 	ldr	r2, [sp]
300042e0:	e5832000 	str	r2, [r3]
}
300042e4:	e28dd010 	add	sp, sp, #16
300042e8:	e12fff1e 	bx	lr
300042ec:	300ea48c 	.word	0x300ea48c

300042f0 <acoral_set_intr_mask>:

/*===========================                                                                                                                 
*Set the mask  function of the vector 
*设置中断屏蔽函数为isr
*===========================*/
void acoral_set_intr_mask(acoral_vector vector,void (*mask)(acoral_vector)){
300042f0:	e24dd010 	sub	sp, sp, #16
300042f4:	e58d0004 	str	r0, [sp, #4]
300042f8:	e58d1000 	str	r1, [sp]
	acoral_vector index;
	HAL_TRANSLATE_VECTOR(vector,index);
300042fc:	e59d3004 	ldr	r3, [sp, #4]
30004300:	e58d300c 	str	r3, [sp, #12]
	intr_table[index].mask=mask;
30004304:	e59d200c 	ldr	r2, [sp, #12]
30004308:	e59f0028 	ldr	r0, [pc, #40]	; 30004338 <acoral_set_intr_mask+0x48>
3000430c:	e3a01014 	mov	r1, #20
30004310:	e1a03002 	mov	r3, r2
30004314:	e1a03183 	lsl	r3, r3, #3
30004318:	e0623003 	rsb	r3, r2, r3
3000431c:	e1a03103 	lsl	r3, r3, #2
30004320:	e0833000 	add	r3, r3, r0
30004324:	e0833001 	add	r3, r3, r1
30004328:	e59d2000 	ldr	r2, [sp]
3000432c:	e5832000 	str	r2, [r3]
}
30004330:	e28dd010 	add	sp, sp, #16
30004334:	e12fff1e 	bx	lr
30004338:	300ea48c 	.word	0x300ea48c

3000433c <acoral_set_intr_unmask>:

/*===========================                                                                                                                 
*Set the unmask function of the vector 
*设置中断使能函数为isr
*===========================*/
void acoral_set_intr_unmask(acoral_vector vector,void (*unmask)(acoral_vector)){
3000433c:	e24dd010 	sub	sp, sp, #16
30004340:	e58d0004 	str	r0, [sp, #4]
30004344:	e58d1000 	str	r1, [sp]
	acoral_vector index;
	HAL_TRANSLATE_VECTOR(vector,index);
30004348:	e59d3004 	ldr	r3, [sp, #4]
3000434c:	e58d300c 	str	r3, [sp, #12]
	intr_table[index].unmask=unmask;
30004350:	e59d200c 	ldr	r2, [sp, #12]
30004354:	e59f0028 	ldr	r0, [pc, #40]	; 30004384 <acoral_set_intr_unmask+0x48>
30004358:	e3a01018 	mov	r1, #24
3000435c:	e1a03002 	mov	r3, r2
30004360:	e1a03183 	lsl	r3, r3, #3
30004364:	e0623003 	rsb	r3, r2, r3
30004368:	e1a03103 	lsl	r3, r3, #2
3000436c:	e0833000 	add	r3, r3, r0
30004370:	e0833001 	add	r3, r3, r1
30004374:	e59d2000 	ldr	r2, [sp]
30004378:	e5832000 	str	r2, [r3]
}
3000437c:	e28dd010 	add	sp, sp, #16
30004380:	e12fff1e 	bx	lr
30004384:	300ea48c 	.word	0x300ea48c

30004388 <acoral_intr_set_type>:

/*===========================                                                                                                                 
*Set interrupt type
*设置中断类型
*===========================*/
void acoral_intr_set_type(acoral_vector vector,acoral_u8 type){
30004388:	e24dd010 	sub	sp, sp, #16
3000438c:	e58d0004 	str	r0, [sp, #4]
30004390:	e1a03001 	mov	r3, r1
30004394:	e5cd3003 	strb	r3, [sp, #3]
  	acoral_vector index;
   	HAL_TRANSLATE_VECTOR(vector,index);
30004398:	e59d3004 	ldr	r3, [sp, #4]
3000439c:	e58d300c 	str	r3, [sp, #12]
	intr_table[index].type =type;
300043a0:	e59d200c 	ldr	r2, [sp, #12]
300043a4:	e59f1020 	ldr	r1, [pc, #32]	; 300043cc <acoral_intr_set_type+0x44>
300043a8:	e1a03002 	mov	r3, r2
300043ac:	e1a03183 	lsl	r3, r3, #3
300043b0:	e0623003 	rsb	r3, r2, r3
300043b4:	e1a03103 	lsl	r3, r3, #2
300043b8:	e0833001 	add	r3, r3, r1
300043bc:	e5dd2003 	ldrb	r2, [sp, #3]
300043c0:	e5c32005 	strb	r2, [r3, #5]
}
300043c4:	e28dd010 	add	sp, sp, #16
300043c8:	e12fff1e 	bx	lr
300043cc:	300ea48c 	.word	0x300ea48c

300043d0 <acoral_fault_entry>:
/*===========================                                                                                                                 
*     exception err output
*        异常错误输出
*===========================*/

void acoral_fault_entry(acoral_u32 lr,acoral_u32 *stack){
300043d0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300043d4:	e24dd00c 	sub	sp, sp, #12
300043d8:	e58d0004 	str	r0, [sp, #4]
300043dc:	e58d1000 	str	r1, [sp]
	acoral_intr_disable();
300043e0:	ebfff4bc 	bl	300016d8 <HAL_INTR_DISABLE>
	if(!acoral_start_sched)
300043e4:	e59f30c4 	ldr	r3, [pc, #196]	; 300044b0 <acoral_fault_entry+0xe0>
300043e8:	e5933000 	ldr	r3, [r3]
300043ec:	e3530000 	cmp	r3, #0
300043f0:	1a000000 	bne	300043f8 <acoral_fault_entry+0x28>
		while(1);	
300043f4:	eafffffe 	b	300043f4 <acoral_fault_entry+0x24>
	acoral_printerr("Exception occur\n");
300043f8:	e59f00b4 	ldr	r0, [pc, #180]	; 300044b4 <acoral_fault_entry+0xe4>
300043fc:	eb001b8f 	bl	3000b240 <acoral_print>
	acoral_printerr("******************\n");
30004400:	e59f00b0 	ldr	r0, [pc, #176]	; 300044b8 <acoral_fault_entry+0xe8>
30004404:	eb001b8d 	bl	3000b240 <acoral_print>
	acoral_printerr("CPU:%d\n",acoral_current_cpu);;
30004408:	e59f00ac 	ldr	r0, [pc, #172]	; 300044bc <acoral_fault_entry+0xec>
3000440c:	e3a01000 	mov	r1, #0
30004410:	eb001b8a 	bl	3000b240 <acoral_print>
	acoral_printerr("Thread name:%s\n",acoral_cur_thread->name);;
30004414:	e59f30a4 	ldr	r3, [pc, #164]	; 300044c0 <acoral_fault_entry+0xf0>
30004418:	e5933000 	ldr	r3, [r3]
3000441c:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30004420:	e59f009c 	ldr	r0, [pc, #156]	; 300044c4 <acoral_fault_entry+0xf4>
30004424:	e1a01003 	mov	r1, r3
30004428:	eb001b84 	bl	3000b240 <acoral_print>
	acoral_printerr("Thread prio:%d\n",acoral_cur_thread->prio);;
3000442c:	e59f308c 	ldr	r3, [pc, #140]	; 300044c0 <acoral_fault_entry+0xf0>
30004430:	e5933000 	ldr	r3, [r3]
30004434:	e5d33005 	ldrb	r3, [r3, #5]
30004438:	e59f0088 	ldr	r0, [pc, #136]	; 300044c8 <acoral_fault_entry+0xf8>
3000443c:	e1a01003 	mov	r1, r3
30004440:	eb001b7e 	bl	3000b240 <acoral_print>
	acoral_printerr("Thread stack_size:%d\n",acoral_cur_thread->stack_size);;
30004444:	e59f3074 	ldr	r3, [pc, #116]	; 300044c0 <acoral_fault_entry+0xf0>
30004448:	e5933000 	ldr	r3, [r3]
3000444c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
30004450:	e59f0074 	ldr	r0, [pc, #116]	; 300044cc <acoral_fault_entry+0xfc>
30004454:	e1a01003 	mov	r1, r3
30004458:	eb001b78 	bl	3000b240 <acoral_print>
	acoral_printerr("Thread stack_buttom:0x%x\n",acoral_cur_thread->stack_buttom);;
3000445c:	e59f305c 	ldr	r3, [pc, #92]	; 300044c0 <acoral_fault_entry+0xf0>
30004460:	e5933000 	ldr	r3, [r3]
30004464:	e5933038 	ldr	r3, [r3, #56]	; 0x38
30004468:	e59f0060 	ldr	r0, [pc, #96]	; 300044d0 <acoral_fault_entry+0x100>
3000446c:	e1a01003 	mov	r1, r3
30004470:	eb001b72 	bl	3000b240 <acoral_print>
	acoral_printerr("Thread stack:0x%x\n",acoral_cur_thread->stack);;
30004474:	e59f3044 	ldr	r3, [pc, #68]	; 300044c0 <acoral_fault_entry+0xf0>
30004478:	e5933000 	ldr	r3, [r3]
3000447c:	e5933034 	ldr	r3, [r3, #52]	; 0x34
30004480:	e59f004c 	ldr	r0, [pc, #76]	; 300044d4 <acoral_fault_entry+0x104>
30004484:	e1a01003 	mov	r1, r3
30004488:	eb001b6c 	bl	3000b240 <acoral_print>
	acoral_printerr("Pc:0x%x\n",lr);
3000448c:	e59f0044 	ldr	r0, [pc, #68]	; 300044d8 <acoral_fault_entry+0x108>
30004490:	e59d1004 	ldr	r1, [sp, #4]
30004494:	eb001b69 	bl	3000b240 <acoral_print>
	acoral_printerr("Stack:0x%x\n",stack);
30004498:	e59f003c 	ldr	r0, [pc, #60]	; 300044dc <acoral_fault_entry+0x10c>
3000449c:	e59d1000 	ldr	r1, [sp]
300044a0:	eb001b66 	bl	3000b240 <acoral_print>
	acoral_printerr("******************\n");
300044a4:	e59f000c 	ldr	r0, [pc, #12]	; 300044b8 <acoral_fault_entry+0xe8>
300044a8:	eb001b64 	bl	3000b240 <acoral_print>
	while(1);
300044ac:	eafffffe 	b	300044ac <acoral_fault_entry+0xdc>
300044b0:	300c9a98 	.word	0x300c9a98
300044b4:	30045160 	.word	0x30045160
300044b8:	30045174 	.word	0x30045174
300044bc:	30045188 	.word	0x30045188
300044c0:	302be818 	.word	0x302be818
300044c4:	30045190 	.word	0x30045190
300044c8:	300451a0 	.word	0x300451a0
300044cc:	300451b0 	.word	0x300451b0
300044d0:	300451c8 	.word	0x300451c8
300044d4:	300451e4 	.word	0x300451e4
300044d8:	300451f8 	.word	0x300451f8
300044dc:	30045204 	.word	0x30045204

300044e0 <acoral_time_sys_init>:
/*  pegasus   0719*/
/*----------------*/
acoral_queue_t timeout_queue;
static acoral_u32 ticks;
void acoral_time_sys_init(){
  	acoral_init_list(&time_delay_queue.head);
300044e0:	e59f302c 	ldr	r3, [pc, #44]	; 30004514 <acoral_time_sys_init+0x34>
300044e4:	e59f2028 	ldr	r2, [pc, #40]	; 30004514 <acoral_time_sys_init+0x34>
300044e8:	e5832000 	str	r2, [r3]
300044ec:	e59f3020 	ldr	r3, [pc, #32]	; 30004514 <acoral_time_sys_init+0x34>
300044f0:	e59f201c 	ldr	r2, [pc, #28]	; 30004514 <acoral_time_sys_init+0x34>
300044f4:	e5832004 	str	r2, [r3, #4]

	/*---------------*/
	/*  新增延时初始化 timeout_queue*/
	/*  pegasus   0719*/
	/*---------------*/
	acoral_init_list(&timeout_queue.head);
300044f8:	e59f3018 	ldr	r3, [pc, #24]	; 30004518 <acoral_time_sys_init+0x38>
300044fc:	e59f2014 	ldr	r2, [pc, #20]	; 30004518 <acoral_time_sys_init+0x38>
30004500:	e5832000 	str	r2, [r3]
30004504:	e59f300c 	ldr	r3, [pc, #12]	; 30004518 <acoral_time_sys_init+0x38>
30004508:	e59f2008 	ldr	r2, [pc, #8]	; 30004518 <acoral_time_sys_init+0x38>
3000450c:	e5832004 	str	r2, [r3, #4]
	acoral_spin_init(&timeout_queue.head.lock);
}
30004510:	e12fff1e 	bx	lr
30004514:	3012d720 	.word	0x3012d720
30004518:	301f593c 	.word	0x301f593c

3000451c <acoral_get_ticks>:


acoral_time acoral_get_ticks(){
	return ticks;
3000451c:	e59f3008 	ldr	r3, [pc, #8]	; 3000452c <acoral_get_ticks+0x10>
30004520:	e5933000 	ldr	r3, [r3]
}
30004524:	e1a00003 	mov	r0, r3
30004528:	e12fff1e 	bx	lr
3000452c:	300ca0d8 	.word	0x300ca0d8

30004530 <acoral_set_ticks>:

void acoral_set_ticks(acoral_time time){
30004530:	e24dd008 	sub	sp, sp, #8
30004534:	e58d0004 	str	r0, [sp, #4]
  	ticks=time;
30004538:	e59f300c 	ldr	r3, [pc, #12]	; 3000454c <acoral_set_ticks+0x1c>
3000453c:	e59d2004 	ldr	r2, [sp, #4]
30004540:	e5832000 	str	r2, [r3]
}
30004544:	e28dd008 	add	sp, sp, #8
30004548:	e12fff1e 	bx	lr
3000454c:	300ca0d8 	.word	0x300ca0d8

30004550 <acoral_ticks_init>:

void acoral_ticks_init(){
30004550:	e92d4008 	push	{r3, lr}
  	ticks=0;                                      /*初始化滴答时钟计数器*/
30004554:	e59f3024 	ldr	r3, [pc, #36]	; 30004580 <acoral_ticks_init+0x30>
30004558:	e3a02000 	mov	r2, #0
3000455c:	e5832000 	str	r2, [r3]
	acoral_intr_attach(HAL_TICKS_INTR,acoral_ticks_entry);/*这个用于注册ticks的处理函数*/
30004560:	e3a0001c 	mov	r0, #28
30004564:	e59f1018 	ldr	r1, [pc, #24]	; 30004584 <acoral_ticks_init+0x34>
30004568:	ebfffe05 	bl	30003d84 <acoral_intr_attach>
	HAL_TICKS_INIT();                            /*这个主要用于将用于ticks的时钟初始化*/
3000456c:	ebfff0bc 	bl	30000864 <hal_ticks_init>
	acoral_intr_unmask(HAL_TICKS_INTR);
30004570:	e3a0001c 	mov	r0, #28
30004574:	ebfffe36 	bl	30003e54 <acoral_intr_unmask>
	return;
}
30004578:	e8bd4008 	pop	{r3, lr}
3000457c:	e12fff1e 	bx	lr
30004580:	300ca0d8 	.word	0x300ca0d8
30004584:	30004588 	.word	0x30004588

30004588 <acoral_ticks_entry>:

void acoral_ticks_entry(acoral_vector vector){
30004588:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000458c:	e24dd00c 	sub	sp, sp, #12
30004590:	e58d0004 	str	r0, [sp, #4]
#ifdef CFG_HOOK_TICKS
	acoral_ticks_hook();
#endif
        ticks++;
30004594:	e59f3034 	ldr	r3, [pc, #52]	; 300045d0 <acoral_ticks_entry+0x48>
30004598:	e5933000 	ldr	r3, [r3]
3000459c:	e2832001 	add	r2, r3, #1
300045a0:	e59f3028 	ldr	r3, [pc, #40]	; 300045d0 <acoral_ticks_entry+0x48>
300045a4:	e5832000 	str	r2, [r3]
	acoral_printdbg("In ticks isr\n");
	if(acoral_start_sched==true){
300045a8:	e59f3024 	ldr	r3, [pc, #36]	; 300045d4 <acoral_ticks_entry+0x4c>
300045ac:	e5933000 	ldr	r3, [r3]
300045b0:	e3530001 	cmp	r3, #1
300045b4:	1a000002 	bne	300045c4 <acoral_ticks_entry+0x3c>
		time_delay_deal();
300045b8:	eb000051 	bl	30004704 <time_delay_deal>
		acoral_policy_delay_deal();
300045bc:	ebfff62c 	bl	30001e74 <acoral_policy_delay_deal>
		/*--------------------*/
		/* 超时链表处理函数*/
		/* pegasus  0719*/
		/*--------------------*/
		timeout_delay_deal();
300045c0:	eb0000ef 	bl	30004984 <timeout_delay_deal>
	}
}
300045c4:	e28dd00c 	add	sp, sp, #12
300045c8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300045cc:	e12fff1e 	bx	lr
300045d0:	300ca0d8 	.word	0x300ca0d8
300045d4:	300c9a98 	.word	0x300c9a98

300045d8 <acoral_delayqueue_add>:

/*================================
 * func: add thread to  time_delay_queue 
 *    将线程挂到延时队列上
 *================================*/
void acoral_delayqueue_add(acoral_queue_t *queue, acoral_thread_t *new){
300045d8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300045dc:	e24dd02c 	sub	sp, sp, #44	; 0x2c
300045e0:	e58d0004 	str	r0, [sp, #4]
300045e4:	e58d1000 	str	r1, [sp]
	acoral_sr cpu_sr;
	acoral_list_t   *tmp, *tmp1,*head;
	acoral_thread_t *thread;
	acoral_32  delay2;
	acoral_32  delay= new->delay;
300045e8:	e59d3000 	ldr	r3, [sp]
300045ec:	e5933040 	ldr	r3, [r3, #64]	; 0x40
300045f0:	e58d3024 	str	r3, [sp, #36]	; 0x24
	if(new->state&ACORAL_THREAD_STATE_DELAY){
		acoral_printerr("Still in delay but be waked,why?\n");
		return;
	}
#endif
	head=&queue->head;
300045f4:	e59d3004 	ldr	r3, [sp, #4]
300045f8:	e58d3018 	str	r3, [sp, #24]
	HAL_ENTER_CRITICAL();
300045fc:	ebfff43c 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30004600:	e1a03000 	mov	r3, r0
30004604:	e58d300c 	str	r3, [sp, #12]
		/*获取下一个成员锁*/
		acoral_spin_lock(&tmp1->lock);
		acoral_spin_unlock(&tmp->lock);
	}
#else
	new->state|=ACORAL_THREAD_STATE_DELAY;
30004608:	e59d3000 	ldr	r3, [sp]
3000460c:	e5d33004 	ldrb	r3, [r3, #4]
30004610:	e3833020 	orr	r3, r3, #32
30004614:	e20320ff 	and	r2, r3, #255	; 0xff
30004618:	e59d3000 	ldr	r3, [sp]
3000461c:	e5c32004 	strb	r2, [r3, #4]
	for (tmp=head->next;delay2=delay,tmp!=head; tmp=tmp->next){
30004620:	e59d3018 	ldr	r3, [sp, #24]
30004624:	e5933000 	ldr	r3, [r3]
30004628:	e58d3010 	str	r3, [sp, #16]
3000462c:	ea00000d 	b	30004668 <acoral_delayqueue_add+0x90>
		thread = list_entry (tmp, acoral_thread_t, waiting);
30004630:	e59d3010 	ldr	r3, [sp, #16]
30004634:	e2433020 	sub	r3, r3, #32
30004638:	e58d301c 	str	r3, [sp, #28]
		delay  = delay-thread->delay;
3000463c:	e59d301c 	ldr	r3, [sp, #28]
30004640:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30004644:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30004648:	e0633002 	rsb	r3, r3, r2
3000464c:	e58d3024 	str	r3, [sp, #36]	; 0x24
		if (delay < 0)
30004650:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30004654:	e3530000 	cmp	r3, #0
30004658:	ba000009 	blt	30004684 <acoral_delayqueue_add+0xac>
		acoral_spin_lock(&tmp1->lock);
		acoral_spin_unlock(&tmp->lock);
	}
#else
	new->state|=ACORAL_THREAD_STATE_DELAY;
	for (tmp=head->next;delay2=delay,tmp!=head; tmp=tmp->next){
3000465c:	e59d3010 	ldr	r3, [sp, #16]
30004660:	e5933000 	ldr	r3, [r3]
30004664:	e58d3010 	str	r3, [sp, #16]
30004668:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3000466c:	e58d3020 	str	r3, [sp, #32]
30004670:	e59d2010 	ldr	r2, [sp, #16]
30004674:	e59d3018 	ldr	r3, [sp, #24]
30004678:	e1520003 	cmp	r2, r3
3000467c:	1affffeb 	bne	30004630 <acoral_delayqueue_add+0x58>
30004680:	ea000000 	b	30004688 <acoral_delayqueue_add+0xb0>
		thread = list_entry (tmp, acoral_thread_t, waiting);
		delay  = delay-thread->delay;
		if (delay < 0)
			break;
30004684:	e1a00000 	nop			; (mov r0, r0)
	}
	new->delay = delay2;
30004688:	e59d3000 	ldr	r3, [sp]
3000468c:	e59d2020 	ldr	r2, [sp, #32]
30004690:	e5832040 	str	r2, [r3, #64]	; 0x40
	acoral_list_add(&new->waiting,tmp->prev);
30004694:	e59d3000 	ldr	r3, [sp]
30004698:	e2832020 	add	r2, r3, #32
3000469c:	e59d3010 	ldr	r3, [sp, #16]
300046a0:	e5933004 	ldr	r3, [r3, #4]
300046a4:	e1a00002 	mov	r0, r2
300046a8:	e1a01003 	mov	r1, r3
300046ac:	eb00163e 	bl	30009fac <acoral_list_add>
	/* 插入等待任务后，后继等待任务时间处理*/
	if(tmp != head){
300046b0:	e59d2010 	ldr	r2, [sp, #16]
300046b4:	e59d3018 	ldr	r3, [sp, #24]
300046b8:	e1520003 	cmp	r2, r3
300046bc:	0a000008 	beq	300046e4 <acoral_delayqueue_add+0x10c>
		thread = list_entry(tmp, acoral_thread_t, waiting);
300046c0:	e59d3010 	ldr	r3, [sp, #16]
300046c4:	e2433020 	sub	r3, r3, #32
300046c8:	e58d301c 	str	r3, [sp, #28]
		thread->delay-=delay2;
300046cc:	e59d301c 	ldr	r3, [sp, #28]
300046d0:	e5932040 	ldr	r2, [r3, #64]	; 0x40
300046d4:	e59d3020 	ldr	r3, [sp, #32]
300046d8:	e0632002 	rsb	r2, r3, r2
300046dc:	e59d301c 	ldr	r3, [sp, #28]
300046e0:	e5832040 	str	r2, [r3, #64]	; 0x40
	}
	acoral_unrdy_thread(new);
300046e4:	e59d0000 	ldr	r0, [sp]
300046e8:	ebfff935 	bl	30002bc4 <acoral_unrdy_thread>
#endif
	HAL_EXIT_CRITICAL();
300046ec:	e59d000c 	ldr	r0, [sp, #12]
300046f0:	ebfff3fd 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sched();
300046f4:	ebfff749 	bl	30002420 <acoral_sched>
	return;
}
300046f8:	e28dd02c 	add	sp, sp, #44	; 0x2c
300046fc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004700:	e12fff1e 	bx	lr

30004704 <time_delay_deal>:

void time_delay_deal(){
30004704:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004708:	e24dd014 	sub	sp, sp, #20
	acoral_list_t   *tmp,*tmp1,*head;
	acoral_thread_t *thread;
	head = &time_delay_queue.head;
3000470c:	e59f30f8 	ldr	r3, [pc, #248]	; 3000480c <time_delay_deal+0x108>
30004710:	e58d3008 	str	r3, [sp, #8]
	if(acoral_list_empty(head))
30004714:	e59d3008 	ldr	r3, [sp, #8]
30004718:	e5932000 	ldr	r2, [r3]
3000471c:	e59d3008 	ldr	r3, [sp, #8]
30004720:	e1520003 	cmp	r2, r3
30004724:	0a000032 	beq	300047f4 <time_delay_deal+0xf0>
	  	return;
	thread=list_entry(head->next,acoral_thread_t,waiting);
30004728:	e59d3008 	ldr	r3, [sp, #8]
3000472c:	e5933000 	ldr	r3, [r3]
30004730:	e2433020 	sub	r3, r3, #32
30004734:	e58d300c 	str	r3, [sp, #12]
	ACORAL_ASSERT(thread,"in time deal");
30004738:	e59d200c 	ldr	r2, [sp, #12]
3000473c:	e59f30cc 	ldr	r3, [pc, #204]	; 30004810 <time_delay_deal+0x10c>
30004740:	e1a00002 	mov	r0, r2
30004744:	e1a01003 	mov	r1, r3
30004748:	ebfffd41 	bl	30003c54 <acoral_assert_res>
	thread->delay--;
3000474c:	e59d300c 	ldr	r3, [sp, #12]
30004750:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30004754:	e2432001 	sub	r2, r3, #1
30004758:	e59d300c 	ldr	r3, [sp, #12]
3000475c:	e5832040 	str	r2, [r3, #64]	; 0x40
	for(tmp=head->next;tmp!=head;){
30004760:	e59d3008 	ldr	r3, [sp, #8]
30004764:	e5933000 	ldr	r3, [r3]
30004768:	e58d3000 	str	r3, [sp]
3000476c:	ea00001b 	b	300047e0 <time_delay_deal+0xdc>
		thread=list_entry(tmp,acoral_thread_t,waiting);
30004770:	e59d3000 	ldr	r3, [sp]
30004774:	e2433020 	sub	r3, r3, #32
30004778:	e58d300c 	str	r3, [sp, #12]
		ACORAL_ASSERT(thread,"in time deal for");
3000477c:	e59d200c 	ldr	r2, [sp, #12]
30004780:	e59f308c 	ldr	r3, [pc, #140]	; 30004814 <time_delay_deal+0x110>
30004784:	e1a00002 	mov	r0, r2
30004788:	e1a01003 	mov	r1, r3
3000478c:	ebfffd30 	bl	30003c54 <acoral_assert_res>
		if(thread->delay>0)
30004790:	e59d300c 	ldr	r3, [sp, #12]
30004794:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30004798:	e3530000 	cmp	r3, #0
3000479c:	ca000016 	bgt	300047fc <time_delay_deal+0xf8>
		/*防止add判断delay时取下thread*/
#ifndef CFG_TICKS_PRIVATE
		acoral_spin_lock(&head->lock);
		acoral_spin_lock(&tmp->lock);
#endif
		tmp1=tmp->next;
300047a0:	e59d3000 	ldr	r3, [sp]
300047a4:	e5933000 	ldr	r3, [r3]
300047a8:	e58d3004 	str	r3, [sp, #4]
		acoral_list_del(&thread->waiting);
300047ac:	e59d300c 	ldr	r3, [sp, #12]
300047b0:	e2833020 	add	r3, r3, #32
300047b4:	e1a00003 	mov	r0, r3
300047b8:	eb001621 	bl	3000a044 <acoral_list_del>
#ifndef CFG_TICKS_PRIVATE
		acoral_spin_unlock(&tmp->lock);
		acoral_spin_unlock(&head->lock);
#endif
		tmp=tmp1;
300047bc:	e59d3004 	ldr	r3, [sp, #4]
300047c0:	e58d3000 	str	r3, [sp]
		thread->state&=~ACORAL_THREAD_STATE_DELAY;
300047c4:	e59d300c 	ldr	r3, [sp, #12]
300047c8:	e5d33004 	ldrb	r3, [r3, #4]
300047cc:	e20330df 	and	r3, r3, #223	; 0xdf
300047d0:	e59d200c 	ldr	r2, [sp, #12]
300047d4:	e5c23004 	strb	r3, [r2, #4]
		acoral_rdy_thread(thread);
300047d8:	e59d000c 	ldr	r0, [sp, #12]
300047dc:	ebfff8e9 	bl	30002b88 <acoral_rdy_thread>
	if(acoral_list_empty(head))
	  	return;
	thread=list_entry(head->next,acoral_thread_t,waiting);
	ACORAL_ASSERT(thread,"in time deal");
	thread->delay--;
	for(tmp=head->next;tmp!=head;){
300047e0:	e59d2000 	ldr	r2, [sp]
300047e4:	e59d3008 	ldr	r3, [sp, #8]
300047e8:	e1520003 	cmp	r2, r3
300047ec:	1affffdf 	bne	30004770 <time_delay_deal+0x6c>
300047f0:	ea000002 	b	30004800 <time_delay_deal+0xfc>
void time_delay_deal(){
	acoral_list_t   *tmp,*tmp1,*head;
	acoral_thread_t *thread;
	head = &time_delay_queue.head;
	if(acoral_list_empty(head))
	  	return;
300047f4:	e1a00000 	nop			; (mov r0, r0)
300047f8:	ea000000 	b	30004800 <time_delay_deal+0xfc>
	thread->delay--;
	for(tmp=head->next;tmp!=head;){
		thread=list_entry(tmp,acoral_thread_t,waiting);
		ACORAL_ASSERT(thread,"in time deal for");
		if(thread->delay>0)
		    break;
300047fc:	e1a00000 	nop			; (mov r0, r0)
#endif
		tmp=tmp1;
		thread->state&=~ACORAL_THREAD_STATE_DELAY;
		acoral_rdy_thread(thread);
	}
}
30004800:	e28dd014 	add	sp, sp, #20
30004804:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004808:	e12fff1e 	bx	lr
3000480c:	3012d720 	.word	0x3012d720
30004810:	30045210 	.word	0x30045210
30004814:	30045220 	.word	0x30045220

30004818 <timeout_queue_add>:
/*================================
 *  
 *    将线程挂到超时队列上
 *================================*/
void timeout_queue_add(acoral_thread_t *new)
{
30004818:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000481c:	e24dd02c 	sub	sp, sp, #44	; 0x2c
30004820:	e58d0004 	str	r0, [sp, #4]
	acoral_sr cpu_sr;
	acoral_list_t   *tmp, *tmp1,*head;
	acoral_thread_t *thread;
	acoral_32  delay2;
	acoral_32  delay= new->delay;
30004824:	e59d3004 	ldr	r3, [sp, #4]
30004828:	e5933040 	ldr	r3, [r3, #64]	; 0x40
3000482c:	e58d3024 	str	r3, [sp, #36]	; 0x24
	head=&timeout_queue.head;
30004830:	e59f30e4 	ldr	r3, [pc, #228]	; 3000491c <timeout_queue_add+0x104>
30004834:	e58d3018 	str	r3, [sp, #24]
	HAL_ENTER_CRITICAL();
30004838:	ebfff3ad 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000483c:	e1a03000 	mov	r3, r0
30004840:	e58d300c 	str	r3, [sp, #12]
		/*获取下一个成员锁*/
		acoral_spin_lock(&tmp1->lock);
		acoral_spin_unlock(&tmp->lock);
	}
#else
	for (tmp=head->next;delay2=delay,tmp!=head; tmp=tmp->next){
30004844:	e59d3018 	ldr	r3, [sp, #24]
30004848:	e5933000 	ldr	r3, [r3]
3000484c:	e58d3010 	str	r3, [sp, #16]
30004850:	ea00000d 	b	3000488c <timeout_queue_add+0x74>
		thread = list_entry (tmp, acoral_thread_t, timeout);
30004854:	e59d3010 	ldr	r3, [sp, #16]
30004858:	e2433018 	sub	r3, r3, #24
3000485c:	e58d301c 	str	r3, [sp, #28]
		delay  = delay-thread->delay;
30004860:	e59d301c 	ldr	r3, [sp, #28]
30004864:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30004868:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
3000486c:	e0633002 	rsb	r3, r3, r2
30004870:	e58d3024 	str	r3, [sp, #36]	; 0x24
		if (delay < 0)
30004874:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30004878:	e3530000 	cmp	r3, #0
3000487c:	ba000009 	blt	300048a8 <timeout_queue_add+0x90>
		/*获取下一个成员锁*/
		acoral_spin_lock(&tmp1->lock);
		acoral_spin_unlock(&tmp->lock);
	}
#else
	for (tmp=head->next;delay2=delay,tmp!=head; tmp=tmp->next){
30004880:	e59d3010 	ldr	r3, [sp, #16]
30004884:	e5933000 	ldr	r3, [r3]
30004888:	e58d3010 	str	r3, [sp, #16]
3000488c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30004890:	e58d3020 	str	r3, [sp, #32]
30004894:	e59d2010 	ldr	r2, [sp, #16]
30004898:	e59d3018 	ldr	r3, [sp, #24]
3000489c:	e1520003 	cmp	r2, r3
300048a0:	1affffeb 	bne	30004854 <timeout_queue_add+0x3c>
300048a4:	ea000000 	b	300048ac <timeout_queue_add+0x94>
		thread = list_entry (tmp, acoral_thread_t, timeout);
		delay  = delay-thread->delay;
		if (delay < 0)
			break;
300048a8:	e1a00000 	nop			; (mov r0, r0)
	}
	new->delay = delay2;
300048ac:	e59d3004 	ldr	r3, [sp, #4]
300048b0:	e59d2020 	ldr	r2, [sp, #32]
300048b4:	e5832040 	str	r2, [r3, #64]	; 0x40
	acoral_list_add(&new->timeout,tmp->prev);
300048b8:	e59d3004 	ldr	r3, [sp, #4]
300048bc:	e2832018 	add	r2, r3, #24
300048c0:	e59d3010 	ldr	r3, [sp, #16]
300048c4:	e5933004 	ldr	r3, [r3, #4]
300048c8:	e1a00002 	mov	r0, r2
300048cc:	e1a01003 	mov	r1, r3
300048d0:	eb0015b5 	bl	30009fac <acoral_list_add>
	/* 插入等待任务后，后继等待任务时间处理*/
	if(tmp != head){
300048d4:	e59d2010 	ldr	r2, [sp, #16]
300048d8:	e59d3018 	ldr	r3, [sp, #24]
300048dc:	e1520003 	cmp	r2, r3
300048e0:	0a000008 	beq	30004908 <timeout_queue_add+0xf0>
		thread = list_entry(tmp, acoral_thread_t, timeout);
300048e4:	e59d3010 	ldr	r3, [sp, #16]
300048e8:	e2433018 	sub	r3, r3, #24
300048ec:	e58d301c 	str	r3, [sp, #28]
		thread->delay-=delay2;
300048f0:	e59d301c 	ldr	r3, [sp, #28]
300048f4:	e5932040 	ldr	r2, [r3, #64]	; 0x40
300048f8:	e59d3020 	ldr	r3, [sp, #32]
300048fc:	e0632002 	rsb	r2, r3, r2
30004900:	e59d301c 	ldr	r3, [sp, #28]
30004904:	e5832040 	str	r2, [r3, #64]	; 0x40
	}
#endif

	HAL_EXIT_CRITICAL();
30004908:	e59d000c 	ldr	r0, [sp, #12]
3000490c:	ebfff376 	bl	300016ec <HAL_INTR_RESTORE>
	return;
}
30004910:	e28dd02c 	add	sp, sp, #44	; 0x2c
30004914:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004918:	e12fff1e 	bx	lr
3000491c:	301f593c 	.word	0x301f593c

30004920 <timeout_queue_del>:
/*================================
 *  
 *    将线程超时队列删除
 *================================*/
void timeout_queue_del(acoral_thread_t *new)
{
30004920:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004924:	e24dd014 	sub	sp, sp, #20
30004928:	e58d0004 	str	r0, [sp, #4]
	acoral_list_t  *p, *q;
	
	if (acoral_list_empty(&new->timeout))
3000492c:	e59d3004 	ldr	r3, [sp, #4]
30004930:	e5932018 	ldr	r2, [r3, #24]
30004934:	e59d3004 	ldr	r3, [sp, #4]
30004938:	e2833018 	add	r3, r3, #24
3000493c:	e1520003 	cmp	r2, r3
30004940:	0a00000b 	beq	30004974 <timeout_queue_del+0x54>
		return;

	p = new->timeout.prev;
30004944:	e59d3004 	ldr	r3, [sp, #4]
30004948:	e593301c 	ldr	r3, [r3, #28]
3000494c:	e58d3008 	str	r3, [sp, #8]
	q = &new->timeout;
30004950:	e59d3004 	ldr	r3, [sp, #4]
30004954:	e2833018 	add	r3, r3, #24
30004958:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&p->lock);
	acoral_spin_lock(&q->lock);
	acoral_list_del(&new->timeout);
3000495c:	e59d3004 	ldr	r3, [sp, #4]
30004960:	e2833018 	add	r3, r3, #24
30004964:	e1a00003 	mov	r0, r3
30004968:	eb0015b5 	bl	3000a044 <acoral_list_del>
	acoral_spin_unlock(&q->lock);
	acoral_spin_unlock(&p->lock);
	return;
3000496c:	e1a00000 	nop			; (mov r0, r0)
30004970:	ea000000 	b	30004978 <timeout_queue_del+0x58>
void timeout_queue_del(acoral_thread_t *new)
{
	acoral_list_t  *p, *q;
	
	if (acoral_list_empty(&new->timeout))
		return;
30004974:	e1a00000 	nop			; (mov r0, r0)
	acoral_spin_lock(&q->lock);
	acoral_list_del(&new->timeout);
	acoral_spin_unlock(&q->lock);
	acoral_spin_unlock(&p->lock);
	return;
}
30004978:	e28dd014 	add	sp, sp, #20
3000497c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004980:	e12fff1e 	bx	lr

30004984 <timeout_delay_deal>:
/*---------------------*/
/*  超时链表处理函数*/
/*   pegasus  0719*/
/*---------------------*/
void timeout_delay_deal()
{
30004984:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004988:	e24dd014 	sub	sp, sp, #20
	acoral_list_t *tmp, *tmp1, *head;
	acoral_thread_t  *thread;

	head = &timeout_queue.head;
3000498c:	e59f30f4 	ldr	r3, [pc, #244]	; 30004a88 <timeout_delay_deal+0x104>
30004990:	e58d3008 	str	r3, [sp, #8]
	if(acoral_list_empty(head))
30004994:	e59d3008 	ldr	r3, [sp, #8]
30004998:	e5932000 	ldr	r2, [r3]
3000499c:	e59d3008 	ldr	r3, [sp, #8]
300049a0:	e1520003 	cmp	r2, r3
300049a4:	0a000031 	beq	30004a70 <timeout_delay_deal+0xec>
	{
	  	return;
	}

	thread=list_entry(head->next,acoral_thread_t,timeout);
300049a8:	e59d3008 	ldr	r3, [sp, #8]
300049ac:	e5933000 	ldr	r3, [r3]
300049b0:	e2433018 	sub	r3, r3, #24
300049b4:	e58d300c 	str	r3, [sp, #12]
	ACORAL_ASSERT(thread,"in timeout deal");
300049b8:	e59d200c 	ldr	r2, [sp, #12]
300049bc:	e59f30c8 	ldr	r3, [pc, #200]	; 30004a8c <timeout_delay_deal+0x108>
300049c0:	e1a00002 	mov	r0, r2
300049c4:	e1a01003 	mov	r1, r3
300049c8:	ebfffca1 	bl	30003c54 <acoral_assert_res>
	if (thread->delay>0)
300049cc:	e59d300c 	ldr	r3, [sp, #12]
300049d0:	e5933040 	ldr	r3, [r3, #64]	; 0x40
300049d4:	e3530000 	cmp	r3, #0
300049d8:	da000004 	ble	300049f0 <timeout_delay_deal+0x6c>
		thread->delay--;
300049dc:	e59d300c 	ldr	r3, [sp, #12]
300049e0:	e5933040 	ldr	r3, [r3, #64]	; 0x40
300049e4:	e2432001 	sub	r2, r3, #1
300049e8:	e59d300c 	ldr	r3, [sp, #12]
300049ec:	e5832040 	str	r2, [r3, #64]	; 0x40
	for(tmp=head->next;tmp!=head;)
300049f0:	e59d3008 	ldr	r3, [sp, #8]
300049f4:	e5933000 	ldr	r3, [r3]
300049f8:	e58d3000 	str	r3, [sp]
300049fc:	ea000016 	b	30004a5c <timeout_delay_deal+0xd8>
	{
		thread=list_entry(tmp,acoral_thread_t,timeout);
30004a00:	e59d3000 	ldr	r3, [sp]
30004a04:	e2433018 	sub	r3, r3, #24
30004a08:	e58d300c 	str	r3, [sp, #12]
		ACORAL_ASSERT(thread,"in timeout deal");
30004a0c:	e59d200c 	ldr	r2, [sp, #12]
30004a10:	e59f3074 	ldr	r3, [pc, #116]	; 30004a8c <timeout_delay_deal+0x108>
30004a14:	e1a00002 	mov	r0, r2
30004a18:	e1a01003 	mov	r1, r3
30004a1c:	ebfffc8c 	bl	30003c54 <acoral_assert_res>
		if(thread->delay>0)
30004a20:	e59d300c 	ldr	r3, [sp, #12]
30004a24:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30004a28:	e3530000 	cmp	r3, #0
30004a2c:	ca000011 	bgt	30004a78 <timeout_delay_deal+0xf4>
		    break;
#ifndef CFG_TICKS_PRIVATE
		acoral_spin_lock(&head->lock);
		acoral_spin_lock(&tmp->lock);
#endif
		tmp1=tmp->next;
30004a30:	e59d3000 	ldr	r3, [sp]
30004a34:	e5933000 	ldr	r3, [r3]
30004a38:	e58d3004 	str	r3, [sp, #4]
		acoral_list_del(&thread->timeout);
30004a3c:	e59d300c 	ldr	r3, [sp, #12]
30004a40:	e2833018 	add	r3, r3, #24
30004a44:	e1a00003 	mov	r0, r3
30004a48:	eb00157d 	bl	3000a044 <acoral_list_del>
#ifndef CFG_TICKS_PRIVATE
		acoral_spin_unlock(&tmp->lock);
		acoral_spin_unlock(&head->lock);
#endif
		tmp=tmp1;
30004a4c:	e59d3004 	ldr	r3, [sp, #4]
30004a50:	e58d3000 	str	r3, [sp]
		/*thread->state*/
		acoral_rdy_thread(thread);
30004a54:	e59d000c 	ldr	r0, [sp, #12]
30004a58:	ebfff84a 	bl	30002b88 <acoral_rdy_thread>

	thread=list_entry(head->next,acoral_thread_t,timeout);
	ACORAL_ASSERT(thread,"in timeout deal");
	if (thread->delay>0)
		thread->delay--;
	for(tmp=head->next;tmp!=head;)
30004a5c:	e59d2000 	ldr	r2, [sp]
30004a60:	e59d3008 	ldr	r3, [sp, #8]
30004a64:	e1520003 	cmp	r2, r3
30004a68:	1affffe4 	bne	30004a00 <timeout_delay_deal+0x7c>
30004a6c:	ea000002 	b	30004a7c <timeout_delay_deal+0xf8>
	acoral_thread_t  *thread;

	head = &timeout_queue.head;
	if(acoral_list_empty(head))
	{
	  	return;
30004a70:	e1a00000 	nop			; (mov r0, r0)
30004a74:	ea000000 	b	30004a7c <timeout_delay_deal+0xf8>
	for(tmp=head->next;tmp!=head;)
	{
		thread=list_entry(tmp,acoral_thread_t,timeout);
		ACORAL_ASSERT(thread,"in timeout deal");
		if(thread->delay>0)
		    break;
30004a78:	e1a00000 	nop			; (mov r0, r0)
#endif
		tmp=tmp1;
		/*thread->state*/
		acoral_rdy_thread(thread);
	}
}
30004a7c:	e28dd014 	add	sp, sp, #20
30004a80:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004a84:	e12fff1e 	bx	lr
30004a88:	301f593c 	.word	0x301f593c
30004a8c:	30045234 	.word	0x30045234

30004a90 <acoral_mem_sys_init>:
#include<mem.h>
/*================================
 *   memory system initialize
 *	内存管理系统初始化
 *================================*/
void acoral_mem_sys_init(){
30004a90:	e92d4008 	push	{r3, lr}
	/*硬件相关的内存初始化，比如内存控制器等*/
  	HAL_MEM_INIT();
30004a94:	ebffefb6 	bl	30000974 <hal_mem_init>
	/*堆初始化,这个可以选择不同管理系统，比如buddy内存管理等*/
  	acoral_mem_init((acoral_u32)HAL_HEAP_START,(acoral_u32)HAL_HEAP_END);
30004a98:	e59f2018 	ldr	r2, [pc, #24]	; 30004ab8 <acoral_mem_sys_init+0x28>
30004a9c:	e59f3018 	ldr	r3, [pc, #24]	; 30004abc <acoral_mem_sys_init+0x2c>
30004aa0:	e1a00002 	mov	r0, r2
30004aa4:	e1a01003 	mov	r1, r3
30004aa8:	eb0002b3 	bl	3000557c <buddy_init>
#ifdef CFG_MEM2
  	acoral_mem_init2();
30004aac:	eb000916 	bl	30006f0c <v_mem_init>
#endif
}
30004ab0:	e8bd4008 	pop	{r3, lr}
30004ab4:	e12fff1e 	bx	lr
30004ab8:	302f7e6c 	.word	0x302f7e6c
30004abc:	33eff000 	.word	0x33eff000

30004ac0 <spin_lock_intr_save>:
#include <hal.h>
#include <spinlock.h>
#include <lsched.h>
acoral_sr spin_lock_intr_save(acoral_spinlock_t *v){
30004ac0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004ac4:	e24dd014 	sub	sp, sp, #20
30004ac8:	e58d0004 	str	r0, [sp, #4]
	acoral_sr sr;
	sr=HAL_INTR_DISABLE_SAVE();
30004acc:	ebfff308 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30004ad0:	e1a03000 	mov	r3, r0
30004ad4:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(v);
	return sr;
30004ad8:	e59d300c 	ldr	r3, [sp, #12]
}
30004adc:	e1a00003 	mov	r0, r3
30004ae0:	e28dd014 	add	sp, sp, #20
30004ae4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004ae8:	e12fff1e 	bx	lr

30004aec <spin_unlock_intr_restore>:

void spin_unlock_intr_restore(acoral_sr sr,acoral_spinlock_t *v){
30004aec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004af0:	e24dd00c 	sub	sp, sp, #12
30004af4:	e58d0004 	str	r0, [sp, #4]
30004af8:	e58d1000 	str	r1, [sp]
	acoral_spin_unlock(v);
	HAL_INTR_RESTORE(sr);
30004afc:	e59d0004 	ldr	r0, [sp, #4]
30004b00:	ebfff2f9 	bl	300016ec <HAL_INTR_RESTORE>
}
30004b04:	e28dd00c 	add	sp, sp, #12
30004b08:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004b0c:	e12fff1e 	bx	lr

30004b10 <spin_lock_intr>:

void spin_lock_intr(acoral_spinlock_t *v){
30004b10:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004b14:	e24dd00c 	sub	sp, sp, #12
30004b18:	e58d0004 	str	r0, [sp, #4]
	HAL_INTR_DISABLE();
30004b1c:	ebfff2ed 	bl	300016d8 <HAL_INTR_DISABLE>
	acoral_spin_lock(v);
}
30004b20:	e28dd00c 	add	sp, sp, #12
30004b24:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004b28:	e12fff1e 	bx	lr

30004b2c <spin_unlock_intr>:

void spin_unlock_intr(acoral_spinlock_t *v){
30004b2c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004b30:	e24dd00c 	sub	sp, sp, #12
30004b34:	e58d0004 	str	r0, [sp, #4]
	acoral_spin_unlock(v);
	HAL_INTR_ENABLE();
30004b38:	ebfff2e2 	bl	300016c8 <HAL_INTR_ENABLE>
}
30004b3c:	e28dd00c 	add	sp, sp, #12
30004b40:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004b44:	e12fff1e 	bx	lr

30004b48 <spin_lock_stamp>:

void spin_lock_stamp(acoral_spinlock_t *v){
30004b48:	e24dd008 	sub	sp, sp, #8
30004b4c:	e58d0004 	str	r0, [sp, #4]
	acoral_sched_lock();
30004b50:	e59f300c 	ldr	r3, [pc, #12]	; 30004b64 <spin_lock_stamp+0x1c>
30004b54:	e3a02001 	mov	r2, #1
30004b58:	e5c32000 	strb	r2, [r3]
	acoral_spin_lock(v);
}
30004b5c:	e28dd008 	add	sp, sp, #8
30004b60:	e12fff1e 	bx	lr
30004b64:	300ea488 	.word	0x300ea488

30004b68 <spin_unlock_stamp>:

void spin_unlock_stamp(acoral_spinlock_t *v){
30004b68:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004b6c:	e24dd00c 	sub	sp, sp, #12
30004b70:	e58d0004 	str	r0, [sp, #4]
	acoral_spin_unlock(v);
	acoral_sched_unlock();
30004b74:	ebfff51d 	bl	30001ff0 <acoral_sched_unlock>
}
30004b78:	e28dd00c 	add	sp, sp, #12
30004b7c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004b80:	e12fff1e 	bx	lr

30004b84 <acoral_evt_sys_init>:
#include "acoral.h"
#include "event.h"
acoral_pool_ctrl_t acoral_evt_pool_ctrl;
void acoral_evt_sys_init(){
30004b84:	e92d4008 	push	{r3, lr}
	acoral_evt_pool_init();
30004b88:	eb000001 	bl	30004b94 <acoral_evt_pool_init>
}
30004b8c:	e8bd4008 	pop	{r3, lr}
30004b90:	e12fff1e 	bx	lr

30004b94 <acoral_evt_pool_init>:

void acoral_evt_pool_init(){
30004b94:	e92d4008 	push	{r3, lr}
	acoral_evt_pool_ctrl.type=ACORAL_RES_EVENT;
30004b98:	e59f3048 	ldr	r3, [pc, #72]	; 30004be8 <acoral_evt_pool_init+0x54>
30004b9c:	e3a02002 	mov	r2, #2
30004ba0:	e5832000 	str	r2, [r3]
	acoral_evt_pool_ctrl.size=sizeof(acoral_evt_t);
30004ba4:	e59f303c 	ldr	r3, [pc, #60]	; 30004be8 <acoral_evt_pool_init+0x54>
30004ba8:	e3a02024 	mov	r2, #36	; 0x24
30004bac:	e5832004 	str	r2, [r3, #4]
	acoral_evt_pool_ctrl.num_per_pool=8;
30004bb0:	e59f3030 	ldr	r3, [pc, #48]	; 30004be8 <acoral_evt_pool_init+0x54>
30004bb4:	e3a02008 	mov	r2, #8
30004bb8:	e5832008 	str	r2, [r3, #8]
	acoral_evt_pool_ctrl.num=0;
30004bbc:	e59f3024 	ldr	r3, [pc, #36]	; 30004be8 <acoral_evt_pool_init+0x54>
30004bc0:	e3a02000 	mov	r2, #0
30004bc4:	e583200c 	str	r2, [r3, #12]
	acoral_evt_pool_ctrl.max_pools=4;
30004bc8:	e59f3018 	ldr	r3, [pc, #24]	; 30004be8 <acoral_evt_pool_init+0x54>
30004bcc:	e3a02004 	mov	r2, #4
30004bd0:	e5832010 	str	r2, [r3, #16]
	acoral_pool_ctrl_init(&acoral_evt_pool_ctrl);
30004bd4:	e59f000c 	ldr	r0, [pc, #12]	; 30004be8 <acoral_evt_pool_init+0x54>
30004bd8:	ebfffbaa 	bl	30003a88 <acoral_pool_ctrl_init>
#ifdef CFG_MSG
	acoral_msg_sys_init();
30004bdc:	eb000b7a 	bl	300079cc <acoral_msg_sys_init>
#endif
}
30004be0:	e8bd4008 	pop	{r3, lr}
30004be4:	e12fff1e 	bx	lr
30004be8:	301f5730 	.word	0x301f5730

30004bec <acoral_alloc_evt>:

acoral_evt_t *acoral_alloc_evt(){
30004bec:	e92d4008 	push	{r3, lr}
  	return (acoral_evt_t *)acoral_get_res(&acoral_evt_pool_ctrl);
30004bf0:	e59f0010 	ldr	r0, [pc, #16]	; 30004c08 <acoral_alloc_evt+0x1c>
30004bf4:	ebfffa44 	bl	3000350c <acoral_get_res>
30004bf8:	e1a03000 	mov	r3, r0
}
30004bfc:	e1a00003 	mov	r0, r3
30004c00:	e8bd4008 	pop	{r3, lr}
30004c04:	e12fff1e 	bx	lr
30004c08:	301f5730 	.word	0x301f5730

30004c0c <acoral_evt_init>:

void acoral_evt_init(acoral_evt_t *evt){
30004c0c:	e24dd008 	sub	sp, sp, #8
30004c10:	e58d0004 	str	r0, [sp, #4]
	acoral_spin_init(&evt->spin_lock);
	acoral_list_init(&evt->wait_queue.head);
30004c14:	e59d3004 	ldr	r3, [sp, #4]
30004c18:	e2832010 	add	r2, r3, #16
30004c1c:	e59d3004 	ldr	r3, [sp, #4]
30004c20:	e5832010 	str	r2, [r3, #16]
30004c24:	e59d3004 	ldr	r3, [sp, #4]
30004c28:	e2832010 	add	r2, r3, #16
30004c2c:	e59d3004 	ldr	r3, [sp, #4]
30004c30:	e5832014 	str	r2, [r3, #20]
}
30004c34:	e28dd008 	add	sp, sp, #8
30004c38:	e12fff1e 	bx	lr

30004c3c <acoral_evt_queue_empty>:

bool acoral_evt_queue_empty(acoral_evt_t *evt){
30004c3c:	e24dd008 	sub	sp, sp, #8
30004c40:	e58d0004 	str	r0, [sp, #4]
	return acoral_list_empty(&evt->wait_queue.head);
30004c44:	e59d3004 	ldr	r3, [sp, #4]
30004c48:	e5932010 	ldr	r2, [r3, #16]
30004c4c:	e59d3004 	ldr	r3, [sp, #4]
30004c50:	e2833010 	add	r3, r3, #16
30004c54:	e1520003 	cmp	r2, r3
30004c58:	13a03000 	movne	r3, #0
30004c5c:	03a03001 	moveq	r3, #1
30004c60:	e1a03c03 	lsl	r3, r3, #24
30004c64:	e1a03c43 	asr	r3, r3, #24
}
30004c68:	e1a00003 	mov	r0, r3
30004c6c:	e28dd008 	add	sp, sp, #8
30004c70:	e12fff1e 	bx	lr

30004c74 <acoral_evt_high_thread>:

acoral_thread_t *acoral_evt_high_thread(acoral_evt_t *evt){
30004c74:	e24dd010 	sub	sp, sp, #16
30004c78:	e58d0004 	str	r0, [sp, #4]
	acoral_list_t *head;
	acoral_thread_t *thread;
	head=&evt->wait_queue.head;
30004c7c:	e59d3004 	ldr	r3, [sp, #4]
30004c80:	e2833010 	add	r3, r3, #16
30004c84:	e58d3008 	str	r3, [sp, #8]
	if(acoral_list_empty(head))
30004c88:	e59d3008 	ldr	r3, [sp, #8]
30004c8c:	e5932000 	ldr	r2, [r3]
30004c90:	e59d3008 	ldr	r3, [sp, #8]
30004c94:	e1520003 	cmp	r2, r3
30004c98:	1a000001 	bne	30004ca4 <acoral_evt_high_thread+0x30>
		return NULL;
30004c9c:	e3a03000 	mov	r3, #0
30004ca0:	ea000004 	b	30004cb8 <acoral_evt_high_thread+0x44>
	thread=list_entry(head->next,acoral_thread_t,waiting);
30004ca4:	e59d3008 	ldr	r3, [sp, #8]
30004ca8:	e5933000 	ldr	r3, [r3]
30004cac:	e2433020 	sub	r3, r3, #32
30004cb0:	e58d300c 	str	r3, [sp, #12]
	return thread;	
30004cb4:	e59d300c 	ldr	r3, [sp, #12]
}
30004cb8:	e1a00003 	mov	r0, r3
30004cbc:	e28dd010 	add	sp, sp, #16
30004cc0:	e12fff1e 	bx	lr

30004cc4 <acoral_evt_queue_add>:

void acoral_evt_queue_add(acoral_evt_t *evt,acoral_thread_t *new){
30004cc4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004cc8:	e24dd01c 	sub	sp, sp, #28
30004ccc:	e58d0004 	str	r0, [sp, #4]
30004cd0:	e58d1000 	str	r1, [sp]
	acoral_list_t *head,*tmp;
	acoral_thread_t *thread;
  	new->evt=evt;
30004cd4:	e59d3000 	ldr	r3, [sp]
30004cd8:	e59d2004 	ldr	r2, [sp, #4]
30004cdc:	e5832030 	str	r2, [r3, #48]	; 0x30
	head=&evt->wait_queue.head;
30004ce0:	e59d3004 	ldr	r3, [sp, #4]
30004ce4:	e2833010 	add	r3, r3, #16
30004ce8:	e58d300c 	str	r3, [sp, #12]
	for(tmp=head->next;tmp!=head;tmp=tmp->next){
30004cec:	e59d300c 	ldr	r3, [sp, #12]
30004cf0:	e5933000 	ldr	r3, [r3]
30004cf4:	e58d3010 	str	r3, [sp, #16]
30004cf8:	ea000010 	b	30004d40 <acoral_evt_queue_add+0x7c>
		thread=list_entry(tmp,acoral_thread_t,waiting);
30004cfc:	e59d3010 	ldr	r3, [sp, #16]
30004d00:	e2433020 	sub	r3, r3, #32
30004d04:	e58d3014 	str	r3, [sp, #20]
		/*如果线程资源已经不在使用，即release状态则释放*/
		if(thread->prio>new->prio)
30004d08:	e59d3014 	ldr	r3, [sp, #20]
30004d0c:	e5d32005 	ldrb	r2, [r3, #5]
30004d10:	e59d3000 	ldr	r3, [sp]
30004d14:	e5d33005 	ldrb	r3, [r3, #5]
30004d18:	e1520003 	cmp	r2, r3
30004d1c:	8a00000c 	bhi	30004d54 <acoral_evt_queue_add+0x90>
			break;


		if(tmp == tmp->next)
30004d20:	e59d3010 	ldr	r3, [sp, #16]
30004d24:	e5932000 	ldr	r2, [r3]
30004d28:	e59d3010 	ldr	r3, [sp, #16]
30004d2c:	e1520003 	cmp	r2, r3
30004d30:	0a000009 	beq	30004d5c <acoral_evt_queue_add+0x98>
void acoral_evt_queue_add(acoral_evt_t *evt,acoral_thread_t *new){
	acoral_list_t *head,*tmp;
	acoral_thread_t *thread;
  	new->evt=evt;
	head=&evt->wait_queue.head;
	for(tmp=head->next;tmp!=head;tmp=tmp->next){
30004d34:	e59d3010 	ldr	r3, [sp, #16]
30004d38:	e5933000 	ldr	r3, [r3]
30004d3c:	e58d3010 	str	r3, [sp, #16]
30004d40:	e59d2010 	ldr	r2, [sp, #16]
30004d44:	e59d300c 	ldr	r3, [sp, #12]
30004d48:	e1520003 	cmp	r2, r3
30004d4c:	1affffea 	bne	30004cfc <acoral_evt_queue_add+0x38>
30004d50:	ea000002 	b	30004d60 <acoral_evt_queue_add+0x9c>
		thread=list_entry(tmp,acoral_thread_t,waiting);
		/*如果线程资源已经不在使用，即release状态则释放*/
		if(thread->prio>new->prio)
			break;
30004d54:	e1a00000 	nop			; (mov r0, r0)
30004d58:	ea000000 	b	30004d60 <acoral_evt_queue_add+0x9c>


		if(tmp == tmp->next)
			break;
30004d5c:	e1a00000 	nop			; (mov r0, r0)

	}
	acoral_list_add(&new->waiting,tmp->prev);
30004d60:	e59d3000 	ldr	r3, [sp]
30004d64:	e2832020 	add	r2, r3, #32
30004d68:	e59d3010 	ldr	r3, [sp, #16]
30004d6c:	e5933004 	ldr	r3, [r3, #4]
30004d70:	e1a00002 	mov	r0, r2
30004d74:	e1a01003 	mov	r1, r3
30004d78:	eb00148b 	bl	30009fac <acoral_list_add>
}
30004d7c:	e28dd01c 	add	sp, sp, #28
30004d80:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004d84:	e12fff1e 	bx	lr

30004d88 <acoral_evt_queue_del>:

void acoral_evt_queue_del(acoral_thread_t *thread){
30004d88:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004d8c:	e24dd00c 	sub	sp, sp, #12
30004d90:	e58d0004 	str	r0, [sp, #4]
	acoral_list_del(&thread->waiting);
30004d94:	e59d3004 	ldr	r3, [sp, #4]
30004d98:	e2833020 	add	r3, r3, #32
30004d9c:	e1a00003 	mov	r0, r3
30004da0:	eb0014a7 	bl	3000a044 <acoral_list_del>
	thread->evt=NULL;
30004da4:	e59d3004 	ldr	r3, [sp, #4]
30004da8:	e3a02000 	mov	r2, #0
30004dac:	e5832030 	str	r2, [r3, #48]	; 0x30
}
30004db0:	e28dd00c 	add	sp, sp, #12
30004db4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004db8:	e12fff1e 	bx	lr

30004dbc <acoral_mutex_init>:
/*==============================
 *  The initialize of the mutex
 *       信号量初始化函数
 *==============================*/
acoral_u32 acoral_mutex_init(acoral_evt_t *evt, acoral_u8 prio)
{
30004dbc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004dc0:	e24dd00c 	sub	sp, sp, #12
30004dc4:	e58d0004 	str	r0, [sp, #4]
30004dc8:	e1a03001 	mov	r3, r1
30004dcc:	e5cd3003 	strb	r3, [sp, #3]
	if ((acoral_evt_t*)0 == evt)
30004dd0:	e59d3004 	ldr	r3, [sp, #4]
30004dd4:	e3530000 	cmp	r3, #0
30004dd8:	1a000001 	bne	30004de4 <acoral_mutex_init+0x28>
	{
		return MUTEX_ERR_NULL;
30004ddc:	e3a03002 	mov	r3, #2
30004de0:	ea00000d 	b	30004e1c <acoral_mutex_init+0x60>
	}
	evt->count  = (prio << 8) | MUTEX_AVAI;
30004de4:	e5dd3003 	ldrb	r3, [sp, #3]
30004de8:	e1a03403 	lsl	r3, r3, #8
30004dec:	e38320ff 	orr	r2, r3, #255	; 0xff
30004df0:	e59d3004 	ldr	r3, [sp, #4]
30004df4:	e583200c 	str	r2, [r3, #12]
	evt->type = ACORAL_EVENT_MUTEX;
30004df8:	e59d3004 	ldr	r3, [sp, #4]
30004dfc:	e3a02001 	mov	r2, #1
30004e00:	e5c32004 	strb	r2, [r3, #4]
	evt->data = NULL;
30004e04:	e59d3004 	ldr	r3, [sp, #4]
30004e08:	e3a02000 	mov	r2, #0
30004e0c:	e5832020 	str	r2, [r3, #32]
	acoral_evt_init(evt);
30004e10:	e59d0004 	ldr	r0, [sp, #4]
30004e14:	ebffff7c 	bl	30004c0c <acoral_evt_init>
	return MUTEX_SUCCED;
30004e18:	e3a03000 	mov	r3, #0
}
30004e1c:	e1a00003 	mov	r0, r3
30004e20:	e28dd00c 	add	sp, sp, #12
30004e24:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004e28:	e12fff1e 	bx	lr

30004e2c <acoral_mutex_create>:
/*==============================
 *  The creation of the mutex
 *       信号量创建函数
 *==============================*/
acoral_evt_t *acoral_mutex_create(acoral_u8 prio, acoral_u32 *err)
{
30004e2c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004e30:	e24dd014 	sub	sp, sp, #20
30004e34:	e1a03000 	mov	r3, r0
30004e38:	e58d1000 	str	r1, [sp]
30004e3c:	e5cd3007 	strb	r3, [sp, #7]
	acoral_evt_t *evt;

	/* 是否大于最小优先线，和是否该优先级已占用*/
	evt = acoral_alloc_evt();      /* alloc a RAM for the event*/
30004e40:	ebffff69 	bl	30004bec <acoral_alloc_evt>
30004e44:	e1a03000 	mov	r3, r0
30004e48:	e58d300c 	str	r3, [sp, #12]
	if (NULL == evt)
30004e4c:	e59d300c 	ldr	r3, [sp, #12]
30004e50:	e3530000 	cmp	r3, #0
30004e54:	1a000004 	bne	30004e6c <acoral_mutex_create+0x40>
	{
		*err = MUTEX_ERR_NULL;
30004e58:	e59d3000 	ldr	r3, [sp]
30004e5c:	e3a02002 	mov	r2, #2
30004e60:	e5832000 	str	r2, [r3]
		return NULL;
30004e64:	e3a03000 	mov	r3, #0
30004e68:	ea00000d 	b	30004ea4 <acoral_mutex_create+0x78>
	}
	evt->count  = (prio << 8) | MUTEX_AVAI;
30004e6c:	e5dd3007 	ldrb	r3, [sp, #7]
30004e70:	e1a03403 	lsl	r3, r3, #8
30004e74:	e38320ff 	orr	r2, r3, #255	; 0xff
30004e78:	e59d300c 	ldr	r3, [sp, #12]
30004e7c:	e583200c 	str	r2, [r3, #12]
	evt->type = ACORAL_EVENT_MUTEX;
30004e80:	e59d300c 	ldr	r3, [sp, #12]
30004e84:	e3a02001 	mov	r2, #1
30004e88:	e5c32004 	strb	r2, [r3, #4]
	evt->data = NULL;
30004e8c:	e59d300c 	ldr	r3, [sp, #12]
30004e90:	e3a02000 	mov	r2, #0
30004e94:	e5832020 	str	r2, [r3, #32]
	acoral_evt_init(evt);
30004e98:	e59d000c 	ldr	r0, [sp, #12]
30004e9c:	ebffff5a 	bl	30004c0c <acoral_evt_init>
	return evt;
30004ea0:	e59d300c 	ldr	r3, [sp, #12]
}
30004ea4:	e1a00003 	mov	r0, r3
30004ea8:	e28dd014 	add	sp, sp, #20
30004eac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004eb0:	e12fff1e 	bx	lr

30004eb4 <acoral_mutex_del>:
/*=============================
 *  The deletion of the mutex
 *      信号号删除函数
 *============================= */
acoral_u32 acoral_mutex_del(acoral_evt_t *evt, acoral_u32 opt)
{
30004eb4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004eb8:	e24dd014 	sub	sp, sp, #20
30004ebc:	e58d0004 	str	r0, [sp, #4]
30004ec0:	e58d1000 	str	r1, [sp]
	acoral_sr            cpu_sr;

	/* 参数检测 */
	if (NULL == evt)
30004ec4:	e59d3004 	ldr	r3, [sp, #4]
30004ec8:	e3530000 	cmp	r3, #0
30004ecc:	1a000001 	bne	30004ed8 <acoral_mutex_del+0x24>
	{
		return MUTEX_ERR_NULL; /*error*/
30004ed0:	e3a03002 	mov	r3, #2
30004ed4:	ea000015 	b	30004f30 <acoral_mutex_del+0x7c>
	}

	if ( ACORAL_EVENT_MUTEX != evt->type )
30004ed8:	e59d3004 	ldr	r3, [sp, #4]
30004edc:	e5d33004 	ldrb	r3, [r3, #4]
30004ee0:	e3530001 	cmp	r3, #1
30004ee4:	0a000001 	beq	30004ef0 <acoral_mutex_del+0x3c>
	{
		return MUTEX_ERR_TYPE; /*error*/
30004ee8:	e3a03003 	mov	r3, #3
30004eec:	ea00000f 	b	30004f30 <acoral_mutex_del+0x7c>
	}

	/* 是否有任务等待*/
	HAL_ENTER_CRITICAL();
30004ef0:	ebfff1ff 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30004ef4:	e1a03000 	mov	r3, r0
30004ef8:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&evt->spin_lock);
	if (acoral_evt_queue_empty(evt))
30004efc:	e59d0004 	ldr	r0, [sp, #4]
30004f00:	ebffff4d 	bl	30004c3c <acoral_evt_queue_empty>
30004f04:	e1a03000 	mov	r3, r0
30004f08:	e20330ff 	and	r3, r3, #255	; 0xff
30004f0c:	e3530000 	cmp	r3, #0
30004f10:	0a000003 	beq	30004f24 <acoral_mutex_del+0x70>
	{
		/*无等待任务删除*/
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30004f14:	e59d000c 	ldr	r0, [sp, #12]
30004f18:	ebfff1f3 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_SUCCED;
30004f1c:	e3a03000 	mov	r3, #0
30004f20:	ea000002 	b	30004f30 <acoral_mutex_del+0x7c>
	}
	else
	{
		/*有等待任务*/
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30004f24:	e59d000c 	ldr	r0, [sp, #12]
30004f28:	ebfff1ef 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_TASK_EXIST;
30004f2c:	e3a03004 	mov	r3, #4
	}
}
30004f30:	e1a00003 	mov	r0, r3
30004f34:	e28dd014 	add	sp, sp, #20
30004f38:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30004f3c:	e12fff1e 	bx	lr

30004f40 <acoral_mutex_trypend>:
 *  the appliation for mutex
 *      信号号申请操作
 *  优先级继承的优先级反转解决
 *=============================*/
acoral_u32 acoral_mutex_trypend(acoral_evt_t *evt)
{
30004f40:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30004f44:	e24dd014 	sub	sp, sp, #20
30004f48:	e58d0004 	str	r0, [sp, #4]
	acoral_sr        cpu_sr;
	acoral_thread_t *cur;

	if(acoral_intr_nesting>0)
30004f4c:	ebfff203 	bl	30001760 <hal_get_intr_nesting_comm>
30004f50:	e1a03000 	mov	r3, r0
30004f54:	e3530000 	cmp	r3, #0
30004f58:	da000001 	ble	30004f64 <acoral_mutex_trypend+0x24>
		return MUTEX_ERR_INTR;
30004f5c:	e3a03005 	mov	r3, #5
30004f60:	ea000027 	b	30005004 <acoral_mutex_trypend+0xc4>
	
	cur=acoral_cur_thread;
30004f64:	e59f30a8 	ldr	r3, [pc, #168]	; 30005014 <acoral_mutex_trypend+0xd4>
30004f68:	e5933000 	ldr	r3, [r3]
30004f6c:	e58d300c 	str	r3, [sp, #12]
	
	HAL_ENTER_CRITICAL();
30004f70:	ebfff1df 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30004f74:	e1a03000 	mov	r3, r0
30004f78:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&evt->spin_lock);
	if (NULL== evt)
30004f7c:	e59d3004 	ldr	r3, [sp, #4]
30004f80:	e3530000 	cmp	r3, #0
30004f84:	1a000003 	bne	30004f98 <acoral_mutex_trypend+0x58>
	{
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30004f88:	e59d0008 	ldr	r0, [sp, #8]
30004f8c:	ebfff1d6 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_NULL;
30004f90:	e3a03002 	mov	r3, #2
30004f94:	ea00001a 	b	30005004 <acoral_mutex_trypend+0xc4>
	}
	
	if ((acoral_u8)(evt->count & MUTEX_L_MASK) == MUTEX_AVAI)
30004f98:	e59d3004 	ldr	r3, [sp, #4]
30004f9c:	e593300c 	ldr	r3, [r3, #12]
30004fa0:	e20330ff 	and	r3, r3, #255	; 0xff
30004fa4:	e35300ff 	cmp	r3, #255	; 0xff
30004fa8:	1a000012 	bne	30004ff8 <acoral_mutex_trypend+0xb8>
	{
		/* 申请成功*/
		evt->count &= MUTEX_U_MASK;
30004fac:	e59d3004 	ldr	r3, [sp, #4]
30004fb0:	e593300c 	ldr	r3, [r3, #12]
30004fb4:	e2032cff 	and	r2, r3, #65280	; 0xff00
30004fb8:	e59d3004 	ldr	r3, [sp, #4]
30004fbc:	e583200c 	str	r2, [r3, #12]
		evt->count |= cur->prio;
30004fc0:	e59d3004 	ldr	r3, [sp, #4]
30004fc4:	e593200c 	ldr	r2, [r3, #12]
30004fc8:	e59d300c 	ldr	r3, [sp, #12]
30004fcc:	e5d33005 	ldrb	r3, [r3, #5]
30004fd0:	e1822003 	orr	r2, r2, r3
30004fd4:	e59d3004 	ldr	r3, [sp, #4]
30004fd8:	e583200c 	str	r2, [r3, #12]
		evt->data = (void*)cur;
30004fdc:	e59d3004 	ldr	r3, [sp, #4]
30004fe0:	e59d200c 	ldr	r2, [sp, #12]
30004fe4:	e5832020 	str	r2, [r3, #32]
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30004fe8:	e59d0008 	ldr	r0, [sp, #8]
30004fec:	ebfff1be 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_SUCCED;
30004ff0:	e3a03000 	mov	r3, #0
30004ff4:	ea000002 	b	30005004 <acoral_mutex_trypend+0xc4>
	}

	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
30004ff8:	e59d0008 	ldr	r0, [sp, #8]
30004ffc:	ebfff1ba 	bl	300016ec <HAL_INTR_RESTORE>
	return MUTEX_ERR_TIMEOUT;
30005000:	e3a03007 	mov	r3, #7
}
30005004:	e1a00003 	mov	r0, r3
30005008:	e28dd014 	add	sp, sp, #20
3000500c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30005010:	e12fff1e 	bx	lr
30005014:	302be818 	.word	0x302be818

30005018 <acoral_mutex_pend>:
 *  the appliation for mutex
 *      信号号申请操作
 *  优先级继承的优先级反转解决
 *=============================*/
acoral_u32 acoral_mutex_pend(acoral_evt_t *evt, acoral_time timeout)
{
30005018:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000501c:	e24dd01c 	sub	sp, sp, #28
30005020:	e58d0004 	str	r0, [sp, #4]
30005024:	e58d1000 	str	r1, [sp]
	acoral_u8        highPrio;
	acoral_u8        ownerPrio;
	acoral_thread_t *thread;
	acoral_thread_t *cur;

	if(acoral_intr_nesting>0)
30005028:	ebfff1cc 	bl	30001760 <hal_get_intr_nesting_comm>
3000502c:	e1a03000 	mov	r3, r0
30005030:	e3530000 	cmp	r3, #0
30005034:	da000001 	ble	30005040 <acoral_mutex_pend+0x28>
		return MUTEX_ERR_INTR;
30005038:	e3a03005 	mov	r3, #5
3000503c:	ea000080 	b	30005244 <acoral_mutex_pend+0x22c>
	
	cur=acoral_cur_thread;
30005040:	e59f320c 	ldr	r3, [pc, #524]	; 30005254 <acoral_mutex_pend+0x23c>
30005044:	e5933000 	ldr	r3, [r3]
30005048:	e58d3014 	str	r3, [sp, #20]
	
	HAL_ENTER_CRITICAL();
3000504c:	ebfff1a8 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30005050:	e1a03000 	mov	r3, r0
30005054:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&evt->spin_lock);
	if (NULL== evt)
30005058:	e59d3004 	ldr	r3, [sp, #4]
3000505c:	e3530000 	cmp	r3, #0
30005060:	1a000003 	bne	30005074 <acoral_mutex_pend+0x5c>
	{
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30005064:	e59d0008 	ldr	r0, [sp, #8]
30005068:	ebfff19f 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_NULL;
3000506c:	e3a03002 	mov	r3, #2
30005070:	ea000073 	b	30005244 <acoral_mutex_pend+0x22c>
	}
	
	if ((acoral_u8)(evt->count & MUTEX_L_MASK) == MUTEX_AVAI)
30005074:	e59d3004 	ldr	r3, [sp, #4]
30005078:	e593300c 	ldr	r3, [r3, #12]
3000507c:	e20330ff 	and	r3, r3, #255	; 0xff
30005080:	e35300ff 	cmp	r3, #255	; 0xff
30005084:	1a000012 	bne	300050d4 <acoral_mutex_pend+0xbc>
	{
		/* 申请成功*/
		evt->count &= MUTEX_U_MASK;
30005088:	e59d3004 	ldr	r3, [sp, #4]
3000508c:	e593300c 	ldr	r3, [r3, #12]
30005090:	e2032cff 	and	r2, r3, #65280	; 0xff00
30005094:	e59d3004 	ldr	r3, [sp, #4]
30005098:	e583200c 	str	r2, [r3, #12]
		evt->count |= cur->prio;
3000509c:	e59d3004 	ldr	r3, [sp, #4]
300050a0:	e593200c 	ldr	r2, [r3, #12]
300050a4:	e59d3014 	ldr	r3, [sp, #20]
300050a8:	e5d33005 	ldrb	r3, [r3, #5]
300050ac:	e1822003 	orr	r2, r2, r3
300050b0:	e59d3004 	ldr	r3, [sp, #4]
300050b4:	e583200c 	str	r2, [r3, #12]
		evt->data = (void*)cur;
300050b8:	e59d3004 	ldr	r3, [sp, #4]
300050bc:	e59d2014 	ldr	r2, [sp, #20]
300050c0:	e5832020 	str	r2, [r3, #32]
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
300050c4:	e59d0008 	ldr	r0, [sp, #8]
300050c8:	ebfff187 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_SUCCED;
300050cc:	e3a03000 	mov	r3, #0
300050d0:	ea00005b 	b	30005244 <acoral_mutex_pend+0x22c>
	}
	
	/* 互斥量已被占有*/
	/* 这里要看进程是否一个核上的*/
	/* 是一个核上的任务才有可能发生优先级反转*/
	highPrio = (acoral_u8)(evt->count >> 8);
300050d4:	e59d3004 	ldr	r3, [sp, #4]
300050d8:	e593300c 	ldr	r3, [r3, #12]
300050dc:	e1a03443 	asr	r3, r3, #8
300050e0:	e5cd300e 	strb	r3, [sp, #14]
	ownerPrio = (acoral_u8)(evt->count & MUTEX_L_MASK);
300050e4:	e59d3004 	ldr	r3, [sp, #4]
300050e8:	e593300c 	ldr	r3, [r3, #12]
300050ec:	e5cd300f 	strb	r3, [sp, #15]
	thread = (acoral_thread_t*)evt->data;
300050f0:	e59d3004 	ldr	r3, [sp, #4]
300050f4:	e5933020 	ldr	r3, [r3, #32]
300050f8:	e58d3010 	str	r3, [sp, #16]

	if (thread->prio != highPrio&&ownerPrio>cur->prio)
300050fc:	e59d3010 	ldr	r3, [sp, #16]
30005100:	e5d33005 	ldrb	r3, [r3, #5]
30005104:	e5dd200e 	ldrb	r2, [sp, #14]
30005108:	e1520003 	cmp	r2, r3
3000510c:	0a00000e 	beq	3000514c <acoral_mutex_pend+0x134>
30005110:	e59d3014 	ldr	r3, [sp, #20]
30005114:	e5d33005 	ldrb	r3, [r3, #5]
30005118:	e5dd200f 	ldrb	r2, [sp, #15]
3000511c:	e1520003 	cmp	r2, r3
30005120:	9a000009 	bls	3000514c <acoral_mutex_pend+0x134>
	{
		/*有可能优先级反转，提升拥有者优先级*/
		if(highPrio==0)
30005124:	e5dd300e 	ldrb	r3, [sp, #14]
30005128:	e3530000 	cmp	r3, #0
3000512c:	1a000002 	bne	3000513c <acoral_mutex_pend+0x124>
			highPrio=cur->prio;
30005130:	e59d3014 	ldr	r3, [sp, #20]
30005134:	e5d33005 	ldrb	r3, [r3, #5]
30005138:	e5cd300e 	strb	r3, [sp, #14]
		acoral_thread_change_prio(thread,highPrio);
3000513c:	e5dd300e 	ldrb	r3, [sp, #14]
30005140:	e59d0010 	ldr	r0, [sp, #16]
30005144:	e1a01003 	mov	r1, r3
30005148:	ebfff654 	bl	30002aa0 <acoral_thread_change_prio>
	}
	/*不需要或不能提高优先级*/
	acoral_unrdy_thread(cur);
3000514c:	e59d0014 	ldr	r0, [sp, #20]
30005150:	ebfff69b 	bl	30002bc4 <acoral_unrdy_thread>
	acoral_evt_queue_add(evt,cur);
30005154:	e59d0004 	ldr	r0, [sp, #4]
30005158:	e59d1014 	ldr	r1, [sp, #20]
3000515c:	ebfffed8 	bl	30004cc4 <acoral_evt_queue_add>
	if (timeout > 0)
30005160:	e59d3000 	ldr	r3, [sp]
30005164:	e3530000 	cmp	r3, #0
30005168:	0a00000f 	beq	300051ac <acoral_mutex_pend+0x194>
	{
		/*加载到超时队列*/
		cur->delay = TIME_TO_TICKS(timeout);
3000516c:	e59d2000 	ldr	r2, [sp]
30005170:	e1a03002 	mov	r3, r2
30005174:	e1a03103 	lsl	r3, r3, #2
30005178:	e0833002 	add	r3, r3, r2
3000517c:	e1a02103 	lsl	r2, r3, #2
30005180:	e0833002 	add	r3, r3, r2
30005184:	e1a03103 	lsl	r3, r3, #2
30005188:	e1a02003 	mov	r2, r3
3000518c:	e59f30c4 	ldr	r3, [pc, #196]	; 30005258 <acoral_mutex_pend+0x240>
30005190:	e0831392 	umull	r1, r3, r2, r3
30005194:	e1a03323 	lsr	r3, r3, #6
30005198:	e1a02003 	mov	r2, r3
3000519c:	e59d3014 	ldr	r3, [sp, #20]
300051a0:	e5832040 	str	r2, [r3, #64]	; 0x40
		timeout_queue_add(cur);
300051a4:	e59d0014 	ldr	r0, [sp, #20]
300051a8:	ebfffd9a 	bl	30004818 <timeout_queue_add>
	}
	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
300051ac:	e59d0008 	ldr	r0, [sp, #8]
300051b0:	ebfff14d 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sched();
300051b4:	ebfff499 	bl	30002420 <acoral_sched>
	HAL_ENTER_CRITICAL();
300051b8:	ebfff14d 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300051bc:	e1a03000 	mov	r3, r0
300051c0:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&evt->spin_lock);
	if(evt->data!=cur&&timeout>0&&cur->delay<=0){
300051c4:	e59d3004 	ldr	r3, [sp, #4]
300051c8:	e5932020 	ldr	r2, [r3, #32]
300051cc:	e59d3014 	ldr	r3, [sp, #20]
300051d0:	e1520003 	cmp	r2, r3
300051d4:	0a00000c 	beq	3000520c <acoral_mutex_pend+0x1f4>
300051d8:	e59d3000 	ldr	r3, [sp]
300051dc:	e3530000 	cmp	r3, #0
300051e0:	0a000009 	beq	3000520c <acoral_mutex_pend+0x1f4>
300051e4:	e59d3014 	ldr	r3, [sp, #20]
300051e8:	e5933040 	ldr	r3, [r3, #64]	; 0x40
300051ec:	e3530000 	cmp	r3, #0
300051f0:	ca000005 	bgt	3000520c <acoral_mutex_pend+0x1f4>
		acoral_printk("Time Out Return\n");
		acoral_evt_queue_del(cur);
300051f4:	e59d0014 	ldr	r0, [sp, #20]
300051f8:	ebfffee2 	bl	30004d88 <acoral_evt_queue_del>
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
300051fc:	e59d0008 	ldr	r0, [sp, #8]
30005200:	ebfff139 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_TIMEOUT;
30005204:	e3a03007 	mov	r3, #7
30005208:	ea00000d 	b	30005244 <acoral_mutex_pend+0x22c>
	}

	//---------------
	// modify by pegasus 0804: timeout_queue_del [+]
	timeout_queue_del(cur);
3000520c:	e59d0014 	ldr	r0, [sp, #20]
30005210:	ebfffdc2 	bl	30004920 <timeout_queue_del>

	if(evt->data!=cur){
30005214:	e59d3004 	ldr	r3, [sp, #4]
30005218:	e5932020 	ldr	r2, [r3, #32]
3000521c:	e59d3014 	ldr	r3, [sp, #20]
30005220:	e1520003 	cmp	r2, r3
30005224:	0a000005 	beq	30005240 <acoral_mutex_pend+0x228>
		acoral_printk("Err Ready Return\n");
		acoral_evt_queue_del(cur);
30005228:	e59d0014 	ldr	r0, [sp, #20]
3000522c:	ebfffed5 	bl	30004d88 <acoral_evt_queue_del>
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30005230:	e59d0008 	ldr	r0, [sp, #8]
30005234:	ebfff12c 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_RDY;
30005238:	e3a03008 	mov	r3, #8
3000523c:	ea000000 	b	30005244 <acoral_mutex_pend+0x22c>
	}
	
	return MUTEX_SUCCED;
30005240:	e3a03000 	mov	r3, #0
}
30005244:	e1a00003 	mov	r0, r3
30005248:	e28dd01c 	add	sp, sp, #28
3000524c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30005250:	e12fff1e 	bx	lr
30005254:	302be818 	.word	0x302be818
30005258:	10624dd3 	.word	0x10624dd3

3000525c <acoral_mutex_post>:
/*============================
 *  post a mutex to thread
 *     信号量的释放
 *===========================*/
acoral_u32 acoral_mutex_post(acoral_evt_t *evt)
{
3000525c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30005260:	e24dd01c 	sub	sp, sp, #28
30005264:	e58d0004 	str	r0, [sp, #4]
	acoral_u8             ownerPrio;
	acoral_u8             highPrio;
	acoral_thread_t      *thread;
	acoral_thread_t      *cur;

	HAL_ENTER_CRITICAL();
30005268:	ebfff121 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000526c:	e1a03000 	mov	r3, r0
30005270:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&evt->spin_lock);

	if ( NULL == evt )
30005274:	e59d3004 	ldr	r3, [sp, #4]
30005278:	e3530000 	cmp	r3, #0
3000527c:	1a000005 	bne	30005298 <acoral_mutex_post+0x3c>
	{
		acoral_printerr("mutex NULL\n");
30005280:	e59f0170 	ldr	r0, [pc, #368]	; 300053f8 <acoral_mutex_post+0x19c>
30005284:	eb0017ed 	bl	3000b240 <acoral_print>
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30005288:	e59d0008 	ldr	r0, [sp, #8]
3000528c:	ebfff116 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_NULL;   /*error*/
30005290:	e3a03002 	mov	r3, #2
30005294:	ea000053 	b	300053e8 <acoral_mutex_post+0x18c>
	}
	
	highPrio  = (acoral_u8)(evt->count >> 8);
30005298:	e59d3004 	ldr	r3, [sp, #4]
3000529c:	e593300c 	ldr	r3, [r3, #12]
300052a0:	e1a03443 	asr	r3, r3, #8
300052a4:	e5cd300f 	strb	r3, [sp, #15]
	ownerPrio = (acoral_u8)(evt->count & MUTEX_L_MASK);
300052a8:	e59d3004 	ldr	r3, [sp, #4]
300052ac:	e593300c 	ldr	r3, [r3, #12]
300052b0:	e5cd300e 	strb	r3, [sp, #14]
	cur=acoral_cur_thread;
300052b4:	e59f3140 	ldr	r3, [pc, #320]	; 300053fc <acoral_mutex_post+0x1a0>
300052b8:	e5933000 	ldr	r3, [r3]
300052bc:	e58d3014 	str	r3, [sp, #20]
	if (highPrio!=0&&cur->prio != highPrio && cur->prio != ownerPrio )
300052c0:	e5dd300f 	ldrb	r3, [sp, #15]
300052c4:	e3530000 	cmp	r3, #0
300052c8:	0a00000f 	beq	3000530c <acoral_mutex_post+0xb0>
300052cc:	e59d3014 	ldr	r3, [sp, #20]
300052d0:	e5d33005 	ldrb	r3, [r3, #5]
300052d4:	e5dd200f 	ldrb	r2, [sp, #15]
300052d8:	e1520003 	cmp	r2, r3
300052dc:	0a00000a 	beq	3000530c <acoral_mutex_post+0xb0>
300052e0:	e59d3014 	ldr	r3, [sp, #20]
300052e4:	e5d33005 	ldrb	r3, [r3, #5]
300052e8:	e5dd200e 	ldrb	r2, [sp, #14]
300052ec:	e1520003 	cmp	r2, r3
300052f0:	0a000005 	beq	3000530c <acoral_mutex_post+0xb0>
	{
		acoral_printerr("mutex prio err\n");
300052f4:	e59f0104 	ldr	r0, [pc, #260]	; 30005400 <acoral_mutex_post+0x1a4>
300052f8:	eb0017d0 	bl	3000b240 <acoral_print>
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
300052fc:	e59d0008 	ldr	r0, [sp, #8]
30005300:	ebfff0f9 	bl	300016ec <HAL_INTR_RESTORE>
		return MUTEX_ERR_UNDEF;
30005304:	e3a03006 	mov	r3, #6
30005308:	ea000036 	b	300053e8 <acoral_mutex_post+0x18c>
	}
	cur->evt=NULL;	
3000530c:	e59d3014 	ldr	r3, [sp, #20]
30005310:	e3a02000 	mov	r2, #0
30005314:	e5832030 	str	r2, [r3, #48]	; 0x30
	if (cur->prio != ownerPrio)
30005318:	e59d3014 	ldr	r3, [sp, #20]
3000531c:	e5d33005 	ldrb	r3, [r3, #5]
30005320:	e5dd200e 	ldrb	r2, [sp, #14]
30005324:	e1520003 	cmp	r2, r3
30005328:	0a000002 	beq	30005338 <acoral_mutex_post+0xdc>
	{
		/* 提升过优先级，进行优先级复原*/
		acoral_change_prio_self(ownerPrio);
3000532c:	e5dd300e 	ldrb	r3, [sp, #14]
30005330:	e1a00003 	mov	r0, r3
30005334:	ebfff5f8 	bl	30002b1c <acoral_change_prio_self>
	}
    
	thread =acoral_evt_high_thread(evt);
30005338:	e59d0004 	ldr	r0, [sp, #4]
3000533c:	ebfffe4c 	bl	30004c74 <acoral_evt_high_thread>
30005340:	e1a03000 	mov	r3, r0
30005344:	e58d3010 	str	r3, [sp, #16]
	if (thread==NULL){
30005348:	e59d3010 	ldr	r3, [sp, #16]
3000534c:	e3530000 	cmp	r3, #0
30005350:	1a00000b 	bne	30005384 <acoral_mutex_post+0x128>
			evt->count |= MUTEX_AVAI;
30005354:	e59d3004 	ldr	r3, [sp, #4]
30005358:	e593300c 	ldr	r3, [r3, #12]
3000535c:	e38320ff 	orr	r2, r3, #255	; 0xff
30005360:	e59d3004 	ldr	r3, [sp, #4]
30005364:	e583200c 	str	r2, [r3, #12]
			evt->data = NULL;
30005368:	e59d3004 	ldr	r3, [sp, #4]
3000536c:	e3a02000 	mov	r2, #0
30005370:	e5832020 	str	r2, [r3, #32]
			acoral_spin_unlock(&evt->spin_lock);
			HAL_EXIT_CRITICAL();
30005374:	e59d0008 	ldr	r0, [sp, #8]
30005378:	ebfff0db 	bl	300016ec <HAL_INTR_RESTORE>
			return MUTEX_SUCCED;
3000537c:	e3a03000 	mov	r3, #0
30005380:	ea000018 	b	300053e8 <acoral_mutex_post+0x18c>
	}
	timeout_queue_del(thread);
30005384:	e59d0010 	ldr	r0, [sp, #16]
30005388:	ebfffd64 	bl	30004920 <timeout_queue_del>
	acoral_evt_queue_del(thread);
3000538c:	e59d0010 	ldr	r0, [sp, #16]
30005390:	ebfffe7c 	bl	30004d88 <acoral_evt_queue_del>
#ifdef CFG_TEST
	acoral_print("%d post %d\n",cur->prio,thread->prio);
#endif
	evt->count &= MUTEX_U_MASK;
30005394:	e59d3004 	ldr	r3, [sp, #4]
30005398:	e593300c 	ldr	r3, [r3, #12]
3000539c:	e2032cff 	and	r2, r3, #65280	; 0xff00
300053a0:	e59d3004 	ldr	r3, [sp, #4]
300053a4:	e583200c 	str	r2, [r3, #12]
	evt->count |= thread->prio;
300053a8:	e59d3004 	ldr	r3, [sp, #4]
300053ac:	e593200c 	ldr	r2, [r3, #12]
300053b0:	e59d3010 	ldr	r3, [sp, #16]
300053b4:	e5d33005 	ldrb	r3, [r3, #5]
300053b8:	e1822003 	orr	r2, r2, r3
300053bc:	e59d3004 	ldr	r3, [sp, #4]
300053c0:	e583200c 	str	r2, [r3, #12]
	evt->data = thread;
300053c4:	e59d3004 	ldr	r3, [sp, #4]
300053c8:	e59d2010 	ldr	r2, [sp, #16]
300053cc:	e5832020 	str	r2, [r3, #32]
	acoral_rdy_thread(thread);
300053d0:	e59d0010 	ldr	r0, [sp, #16]
300053d4:	ebfff5eb 	bl	30002b88 <acoral_rdy_thread>
	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
300053d8:	e59d0008 	ldr	r0, [sp, #8]
300053dc:	ebfff0c2 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sched();
300053e0:	ebfff40e 	bl	30002420 <acoral_sched>
	return MUTEX_SUCCED;
300053e4:	e3a03000 	mov	r3, #0
}
300053e8:	e1a00003 	mov	r0, r3
300053ec:	e28dd01c 	add	sp, sp, #28
300053f0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300053f4:	e12fff1e 	bx	lr
300053f8:	30045244 	.word	0x30045244
300053fc:	302be818 	.word	0x302be818
30005400:	30045250 	.word	0x30045250

30005404 <buddy_scan>:
}acoral_block_ctr_t;

acoral_block_ctr_t *acoral_mem_ctrl;
acoral_block_t *acoral_mem_blocks;

void buddy_scan(){
30005404:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30005408:	e24dd01c 	sub	sp, sp, #28
	acoral_u32 i,k,num,n;	
	acoral_u32 max_level=acoral_mem_ctrl->level;
3000540c:	e59f314c 	ldr	r3, [pc, #332]	; 30005560 <buddy_scan+0x15c>
30005410:	e5933000 	ldr	r3, [r3]
30005414:	e5d330e0 	ldrb	r3, [r3, #224]	; 0xe0
30005418:	e1a03c03 	lsl	r3, r3, #24
3000541c:	e1a03c43 	asr	r3, r3, #24
30005420:	e58d3014 	str	r3, [sp, #20]
	for(i=0;i<max_level;i++){
30005424:	e3a03000 	mov	r3, #0
30005428:	e58d3004 	str	r3, [sp, #4]
3000542c:	ea00003c 	b	30005524 <buddy_scan+0x120>
		acoral_print("Level%d\r\n",i); 	
30005430:	e59f012c 	ldr	r0, [pc, #300]	; 30005564 <buddy_scan+0x160>
30005434:	e59d1004 	ldr	r1, [sp, #4]
30005438:	eb001780 	bl	3000b240 <acoral_print>
		acoral_prints("bitmap:"); 	
3000543c:	e59f0124 	ldr	r0, [pc, #292]	; 30005568 <buddy_scan+0x164>
30005440:	eb0017a1 	bl	3000b2cc <acoral_prints>
		num=acoral_mem_ctrl->num[i];
30005444:	e59f3114 	ldr	r3, [pc, #276]	; 30005560 <buddy_scan+0x15c>
30005448:	e5933000 	ldr	r3, [r3]
3000544c:	e59d2004 	ldr	r2, [sp, #4]
30005450:	e282202a 	add	r2, r2, #42	; 0x2a
30005454:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30005458:	e58d300c 	str	r3, [sp, #12]
		for(k=0;k<num;){
3000545c:	e3a03000 	mov	r3, #0
30005460:	e58d3008 	str	r3, [sp, #8]
30005464:	ea00001d 	b	300054e0 <buddy_scan+0xdc>
			for(n=0;n<8&&k<num;n++,k++){
30005468:	e3a03000 	mov	r3, #0
3000546c:	e58d3010 	str	r3, [sp, #16]
30005470:	ea000011 	b	300054bc <buddy_scan+0xb8>
				acoral_print("%x ",acoral_mem_ctrl->bitmap[i][k]); 
30005474:	e59f30e4 	ldr	r3, [pc, #228]	; 30005560 <buddy_scan+0x15c>
30005478:	e5933000 	ldr	r3, [r3]
3000547c:	e59d2004 	ldr	r2, [sp, #4]
30005480:	e282200e 	add	r2, r2, #14
30005484:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005488:	e59d3008 	ldr	r3, [sp, #8]
3000548c:	e1a03103 	lsl	r3, r3, #2
30005490:	e0823003 	add	r3, r2, r3
30005494:	e5933000 	ldr	r3, [r3]
30005498:	e59f00cc 	ldr	r0, [pc, #204]	; 3000556c <buddy_scan+0x168>
3000549c:	e1a01003 	mov	r1, r3
300054a0:	eb001766 	bl	3000b240 <acoral_print>
	for(i=0;i<max_level;i++){
		acoral_print("Level%d\r\n",i); 	
		acoral_prints("bitmap:"); 	
		num=acoral_mem_ctrl->num[i];
		for(k=0;k<num;){
			for(n=0;n<8&&k<num;n++,k++){
300054a4:	e59d3010 	ldr	r3, [sp, #16]
300054a8:	e2833001 	add	r3, r3, #1
300054ac:	e58d3010 	str	r3, [sp, #16]
300054b0:	e59d3008 	ldr	r3, [sp, #8]
300054b4:	e2833001 	add	r3, r3, #1
300054b8:	e58d3008 	str	r3, [sp, #8]
300054bc:	e59d3010 	ldr	r3, [sp, #16]
300054c0:	e3530007 	cmp	r3, #7
300054c4:	8a000003 	bhi	300054d8 <buddy_scan+0xd4>
300054c8:	e59d2008 	ldr	r2, [sp, #8]
300054cc:	e59d300c 	ldr	r3, [sp, #12]
300054d0:	e1520003 	cmp	r2, r3
300054d4:	3affffe6 	bcc	30005474 <buddy_scan+0x70>
				acoral_print("%x ",acoral_mem_ctrl->bitmap[i][k]); 
			}	
			acoral_prints("\r\n"); 	
300054d8:	e59f0090 	ldr	r0, [pc, #144]	; 30005570 <buddy_scan+0x16c>
300054dc:	eb00177a 	bl	3000b2cc <acoral_prints>
	acoral_u32 max_level=acoral_mem_ctrl->level;
	for(i=0;i<max_level;i++){
		acoral_print("Level%d\r\n",i); 	
		acoral_prints("bitmap:"); 	
		num=acoral_mem_ctrl->num[i];
		for(k=0;k<num;){
300054e0:	e59d2008 	ldr	r2, [sp, #8]
300054e4:	e59d300c 	ldr	r3, [sp, #12]
300054e8:	e1520003 	cmp	r2, r3
300054ec:	3affffdd 	bcc	30005468 <buddy_scan+0x64>
			for(n=0;n<8&&k<num;n++,k++){
				acoral_print("%x ",acoral_mem_ctrl->bitmap[i][k]); 
			}	
			acoral_prints("\r\n"); 	
		}
		acoral_print("Free Block head:%d\r\n",acoral_mem_ctrl->free_cur[i]); 	
300054f0:	e59f3068 	ldr	r3, [pc, #104]	; 30005560 <buddy_scan+0x15c>
300054f4:	e5933000 	ldr	r3, [r3]
300054f8:	e59d2004 	ldr	r2, [sp, #4]
300054fc:	e282201c 	add	r2, r2, #28
30005500:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30005504:	e59f0068 	ldr	r0, [pc, #104]	; 30005574 <buddy_scan+0x170>
30005508:	e1a01003 	mov	r1, r3
3000550c:	eb00174b 	bl	3000b240 <acoral_print>
		acoral_prints("\r\n"); 	
30005510:	e59f0058 	ldr	r0, [pc, #88]	; 30005570 <buddy_scan+0x16c>
30005514:	eb00176c 	bl	3000b2cc <acoral_prints>
acoral_block_t *acoral_mem_blocks;

void buddy_scan(){
	acoral_u32 i,k,num,n;	
	acoral_u32 max_level=acoral_mem_ctrl->level;
	for(i=0;i<max_level;i++){
30005518:	e59d3004 	ldr	r3, [sp, #4]
3000551c:	e2833001 	add	r3, r3, #1
30005520:	e58d3004 	str	r3, [sp, #4]
30005524:	e59d2004 	ldr	r2, [sp, #4]
30005528:	e59d3014 	ldr	r3, [sp, #20]
3000552c:	e1520003 	cmp	r2, r3
30005530:	3affffbe 	bcc	30005430 <buddy_scan+0x2c>
			acoral_prints("\r\n"); 	
		}
		acoral_print("Free Block head:%d\r\n",acoral_mem_ctrl->free_cur[i]); 	
		acoral_prints("\r\n"); 	
	}
	acoral_print("Free Mem Block Number:%d\r\n",acoral_mem_ctrl->free_num); 	
30005534:	e59f3024 	ldr	r3, [pc, #36]	; 30005560 <buddy_scan+0x15c>
30005538:	e5933000 	ldr	r3, [r3]
3000553c:	e59330f0 	ldr	r3, [r3, #240]	; 0xf0
30005540:	e59f0030 	ldr	r0, [pc, #48]	; 30005578 <buddy_scan+0x174>
30005544:	e1a01003 	mov	r1, r3
30005548:	eb00173c 	bl	3000b240 <acoral_print>
	acoral_print("\r\n"); 	
3000554c:	e59f001c 	ldr	r0, [pc, #28]	; 30005570 <buddy_scan+0x16c>
30005550:	eb00173a 	bl	3000b240 <acoral_print>
}
30005554:	e28dd01c 	add	sp, sp, #28
30005558:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000555c:	e12fff1e 	bx	lr
30005560:	3012d6b8 	.word	0x3012d6b8
30005564:	30045260 	.word	0x30045260
30005568:	3004526c 	.word	0x3004526c
3000556c:	30045274 	.word	0x30045274
30005570:	30045278 	.word	0x30045278
30005574:	3004527c 	.word	0x3004527c
30005578:	30045294 	.word	0x30045294

3000557c <buddy_init>:

acoral_err buddy_init(acoral_u32 start_adr,acoral_u32 end_adr){
3000557c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30005580:	e24dd03c 	sub	sp, sp, #60	; 0x3c
30005584:	e58d0004 	str	r0, [sp, #4]
30005588:	e58d1000 	str	r1, [sp]
	acoral_32 i,k;
	acoral_u32 resize_size;
	acoral_u32 save_adr;
	acoral_u32 index;
	acoral_u32 num=1;
3000558c:	e3a03001 	mov	r3, #1
30005590:	e58d3020 	str	r3, [sp, #32]
	acoral_u32 adjust_level=1;
30005594:	e3a03001 	mov	r3, #1
30005598:	e58d3024 	str	r3, [sp, #36]	; 0x24
	acoral_32 level=0;
3000559c:	e3a03000 	mov	r3, #0
300055a0:	e58d3028 	str	r3, [sp, #40]	; 0x28
	acoral_u32 max_num,o_num;
	acoral_u32 cur;
	start_adr+=3;
300055a4:	e59d3004 	ldr	r3, [sp, #4]
300055a8:	e2833003 	add	r3, r3, #3
300055ac:	e58d3004 	str	r3, [sp, #4]
	start_adr&=~(4-1);		
300055b0:	e59d3004 	ldr	r3, [sp, #4]
300055b4:	e3c33003 	bic	r3, r3, #3
300055b8:	e58d3004 	str	r3, [sp, #4]
	end_adr&=~(4-1);		
300055bc:	e59d3000 	ldr	r3, [sp]
300055c0:	e3c33003 	bic	r3, r3, #3
300055c4:	e58d3000 	str	r3, [sp]
	resize_size=BLOCK_SIZE;
300055c8:	e3a03080 	mov	r3, #128	; 0x80
300055cc:	e58d3014 	str	r3, [sp, #20]
	end_adr=end_adr - sizeof(acoral_block_ctr_t);
300055d0:	e59d3000 	ldr	r3, [sp]
300055d4:	e24330fc 	sub	r3, r3, #252	; 0xfc
300055d8:	e58d3000 	str	r3, [sp]
	end_adr&=~(4-1);
300055dc:	e59d3000 	ldr	r3, [sp]
300055e0:	e3c33003 	bic	r3, r3, #3
300055e4:	e58d3000 	str	r3, [sp]
	acoral_mem_ctrl=(acoral_block_ctr_t *)end_adr;
300055e8:	e59d2000 	ldr	r2, [sp]
300055ec:	e59f3720 	ldr	r3, [pc, #1824]	; 30005d14 <buddy_init+0x798>
300055f0:	e5832000 	str	r2, [r3]
	/*如果内存这么少，不适合分配*/
	if(start_adr>end_adr||end_adr-start_adr<BLOCK_SIZE){
300055f4:	e59d2004 	ldr	r2, [sp, #4]
300055f8:	e59d3000 	ldr	r3, [sp]
300055fc:	e1520003 	cmp	r2, r3
30005600:	8a000004 	bhi	30005618 <buddy_init+0x9c>
30005604:	e59d2000 	ldr	r2, [sp]
30005608:	e59d3004 	ldr	r3, [sp, #4]
3000560c:	e0633002 	rsb	r3, r3, r2
30005610:	e353007f 	cmp	r3, #127	; 0x7f
30005614:	8a000005 	bhi	30005630 <buddy_init+0xb4>
		acoral_mem_ctrl->state=MEM_NO_ALLOC;
30005618:	e59f36f4 	ldr	r3, [pc, #1780]	; 30005d14 <buddy_init+0x798>
3000561c:	e5933000 	ldr	r3, [r3]
30005620:	e3a02000 	mov	r2, #0
30005624:	e5c320e1 	strb	r2, [r3, #225]	; 0xe1
		return -1;
30005628:	e3e03000 	mvn	r3, #0
3000562c:	ea0001b4 	b	30005d04 <buddy_init+0x788>
	}
	acoral_mem_ctrl->state=MEM_OK;
30005630:	e59f36dc 	ldr	r3, [pc, #1756]	; 30005d14 <buddy_init+0x798>
30005634:	e5933000 	ldr	r3, [r3]
30005638:	e3a02001 	mov	r2, #1
3000563c:	e5c320e1 	strb	r2, [r3, #225]	; 0xe1
	while(1){
		if(end_adr<=start_adr+resize_size)
30005640:	e59d2004 	ldr	r2, [sp, #4]
30005644:	e59d3014 	ldr	r3, [sp, #20]
30005648:	e0822003 	add	r2, r2, r3
3000564c:	e59d3000 	ldr	r3, [sp]
30005650:	e1520003 	cmp	r2, r3
30005654:	3a00000e 	bcc	30005694 <buddy_init+0x118>
			break;
		resize_size=resize_size<<1;
		num=num<<1;
		adjust_level++;
	}
	acoral_mem_blocks=(acoral_block_t *)end_adr-num;
30005658:	e59d2000 	ldr	r2, [sp]
3000565c:	e59d3020 	ldr	r3, [sp, #32]
30005660:	e0633002 	rsb	r3, r3, r2
30005664:	e1a02003 	mov	r2, r3
30005668:	e59f36a8 	ldr	r3, [pc, #1704]	; 30005d18 <buddy_init+0x79c>
3000566c:	e5832000 	str	r2, [r3]
	save_adr=(acoral_u32)acoral_mem_blocks;
30005670:	e59f36a0 	ldr	r3, [pc, #1696]	; 30005d18 <buddy_init+0x79c>
30005674:	e5933000 	ldr	r3, [r3]
30005678:	e58d3018 	str	r3, [sp, #24]
	level=adjust_level;
3000567c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30005680:	e58d3028 	str	r3, [sp, #40]	; 0x28
	if(adjust_level>LEVEL)
30005684:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30005688:	e353000e 	cmp	r3, #14
3000568c:	8a00000a 	bhi	300056bc <buddy_init+0x140>
30005690:	ea00000b 	b	300056c4 <buddy_init+0x148>
	}
	acoral_mem_ctrl->state=MEM_OK;
	while(1){
		if(end_adr<=start_adr+resize_size)
			break;
		resize_size=resize_size<<1;
30005694:	e59d3014 	ldr	r3, [sp, #20]
30005698:	e1a03083 	lsl	r3, r3, #1
3000569c:	e58d3014 	str	r3, [sp, #20]
		num=num<<1;
300056a0:	e59d3020 	ldr	r3, [sp, #32]
300056a4:	e1a03083 	lsl	r3, r3, #1
300056a8:	e58d3020 	str	r3, [sp, #32]
		adjust_level++;
300056ac:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300056b0:	e2833001 	add	r3, r3, #1
300056b4:	e58d3024 	str	r3, [sp, #36]	; 0x24
	}
300056b8:	eaffffe0 	b	30005640 <buddy_init+0xc4>
	acoral_mem_blocks=(acoral_block_t *)end_adr-num;
	save_adr=(acoral_u32)acoral_mem_blocks;
	level=adjust_level;
	if(adjust_level>LEVEL)
		level=LEVEL;
300056bc:	e3a0300e 	mov	r3, #14
300056c0:	e58d3028 	str	r3, [sp, #40]	; 0x28
	num=num/32; 
300056c4:	e59d3020 	ldr	r3, [sp, #32]
300056c8:	e1a032a3 	lsr	r3, r3, #5
300056cc:	e58d3020 	str	r3, [sp, #32]
	for(i=0;i<level-1;i++){
300056d0:	e3a03000 	mov	r3, #0
300056d4:	e58d300c 	str	r3, [sp, #12]
300056d8:	ea00004e 	b	30005818 <buddy_init+0x29c>
		num=num>>1;
300056dc:	e59d3020 	ldr	r3, [sp, #32]
300056e0:	e1a030a3 	lsr	r3, r3, #1
300056e4:	e58d3020 	str	r3, [sp, #32]
		if(num==0)
300056e8:	e59d3020 	ldr	r3, [sp, #32]
300056ec:	e3530000 	cmp	r3, #0
300056f0:	1a000001 	bne	300056fc <buddy_init+0x180>
			num=1;
300056f4:	e3a03001 	mov	r3, #1
300056f8:	e58d3020 	str	r3, [sp, #32]
		save_adr-=num*4;
300056fc:	e59d3020 	ldr	r3, [sp, #32]
30005700:	e1a03103 	lsl	r3, r3, #2
30005704:	e59d2018 	ldr	r2, [sp, #24]
30005708:	e0633002 	rsb	r3, r3, r2
3000570c:	e58d3018 	str	r3, [sp, #24]
		save_adr&=~(4-1);
30005710:	e59d3018 	ldr	r3, [sp, #24]
30005714:	e3c33003 	bic	r3, r3, #3
30005718:	e58d3018 	str	r3, [sp, #24]
		acoral_mem_ctrl->bitmap[i]=(acoral_u32 *)save_adr;
3000571c:	e59f35f0 	ldr	r3, [pc, #1520]	; 30005d14 <buddy_init+0x798>
30005720:	e5933000 	ldr	r3, [r3]
30005724:	e59d200c 	ldr	r2, [sp, #12]
30005728:	e59d1018 	ldr	r1, [sp, #24]
3000572c:	e282200e 	add	r2, r2, #14
30005730:	e7831102 	str	r1, [r3, r2, lsl #2]
		acoral_mem_ctrl->num[i]=num;
30005734:	e59f35d8 	ldr	r3, [pc, #1496]	; 30005d14 <buddy_init+0x798>
30005738:	e5933000 	ldr	r3, [r3]
3000573c:	e59d200c 	ldr	r2, [sp, #12]
30005740:	e282202a 	add	r2, r2, #42	; 0x2a
30005744:	e59d1020 	ldr	r1, [sp, #32]
30005748:	e7831102 	str	r1, [r3, r2, lsl #2]
		save_adr-=num*4;
3000574c:	e59d3020 	ldr	r3, [sp, #32]
30005750:	e1a03103 	lsl	r3, r3, #2
30005754:	e59d2018 	ldr	r2, [sp, #24]
30005758:	e0633002 	rsb	r3, r3, r2
3000575c:	e58d3018 	str	r3, [sp, #24]
		save_adr&=~(4-1);
30005760:	e59d3018 	ldr	r3, [sp, #24]
30005764:	e3c33003 	bic	r3, r3, #3
30005768:	e58d3018 	str	r3, [sp, #24]
		acoral_mem_ctrl->free_list[i]=(acoral_32 *)save_adr;
3000576c:	e59f35a0 	ldr	r3, [pc, #1440]	; 30005d14 <buddy_init+0x798>
30005770:	e5933000 	ldr	r3, [r3]
30005774:	e59d200c 	ldr	r2, [sp, #12]
30005778:	e59d1018 	ldr	r1, [sp, #24]
3000577c:	e7831102 	str	r1, [r3, r2, lsl #2]
		for(k=0;k<num;k++){
30005780:	e3a03000 	mov	r3, #0
30005784:	e58d3010 	str	r3, [sp, #16]
30005788:	ea000015 	b	300057e4 <buddy_init+0x268>
			acoral_mem_ctrl->bitmap[i][k]=0;;
3000578c:	e59f3580 	ldr	r3, [pc, #1408]	; 30005d14 <buddy_init+0x798>
30005790:	e5933000 	ldr	r3, [r3]
30005794:	e59d200c 	ldr	r2, [sp, #12]
30005798:	e282200e 	add	r2, r2, #14
3000579c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
300057a0:	e59d3010 	ldr	r3, [sp, #16]
300057a4:	e1a03103 	lsl	r3, r3, #2
300057a8:	e0823003 	add	r3, r2, r3
300057ac:	e3a02000 	mov	r2, #0
300057b0:	e5832000 	str	r2, [r3]
			acoral_mem_ctrl->free_list[i][k]=-1;
300057b4:	e59f3558 	ldr	r3, [pc, #1368]	; 30005d14 <buddy_init+0x798>
300057b8:	e5933000 	ldr	r3, [r3]
300057bc:	e59d200c 	ldr	r2, [sp, #12]
300057c0:	e7932102 	ldr	r2, [r3, r2, lsl #2]
300057c4:	e59d3010 	ldr	r3, [sp, #16]
300057c8:	e1a03103 	lsl	r3, r3, #2
300057cc:	e0823003 	add	r3, r2, r3
300057d0:	e3e02000 	mvn	r2, #0
300057d4:	e5832000 	str	r2, [r3]
		acoral_mem_ctrl->bitmap[i]=(acoral_u32 *)save_adr;
		acoral_mem_ctrl->num[i]=num;
		save_adr-=num*4;
		save_adr&=~(4-1);
		acoral_mem_ctrl->free_list[i]=(acoral_32 *)save_adr;
		for(k=0;k<num;k++){
300057d8:	e59d3010 	ldr	r3, [sp, #16]
300057dc:	e2833001 	add	r3, r3, #1
300057e0:	e58d3010 	str	r3, [sp, #16]
300057e4:	e59d2010 	ldr	r2, [sp, #16]
300057e8:	e59d3020 	ldr	r3, [sp, #32]
300057ec:	e1520003 	cmp	r2, r3
300057f0:	3affffe5 	bcc	3000578c <buddy_init+0x210>
			acoral_mem_ctrl->bitmap[i][k]=0;;
			acoral_mem_ctrl->free_list[i][k]=-1;
		}
		acoral_mem_ctrl->free_cur[i]=-1;
300057f4:	e59f3518 	ldr	r3, [pc, #1304]	; 30005d14 <buddy_init+0x798>
300057f8:	e5933000 	ldr	r3, [r3]
300057fc:	e59d200c 	ldr	r2, [sp, #12]
30005800:	e282201c 	add	r2, r2, #28
30005804:	e3e01000 	mvn	r1, #0
30005808:	e7831102 	str	r1, [r3, r2, lsl #2]
	save_adr=(acoral_u32)acoral_mem_blocks;
	level=adjust_level;
	if(adjust_level>LEVEL)
		level=LEVEL;
	num=num/32; 
	for(i=0;i<level-1;i++){
3000580c:	e59d300c 	ldr	r3, [sp, #12]
30005810:	e2833001 	add	r3, r3, #1
30005814:	e58d300c 	str	r3, [sp, #12]
30005818:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000581c:	e2432001 	sub	r2, r3, #1
30005820:	e59d300c 	ldr	r3, [sp, #12]
30005824:	e1520003 	cmp	r2, r3
30005828:	caffffab 	bgt	300056dc <buddy_init+0x160>
			acoral_mem_ctrl->bitmap[i][k]=0;;
			acoral_mem_ctrl->free_list[i][k]=-1;
		}
		acoral_mem_ctrl->free_cur[i]=-1;
	}
	if(num==0)
3000582c:	e59d3020 	ldr	r3, [sp, #32]
30005830:	e3530000 	cmp	r3, #0
30005834:	1a000001 	bne	30005840 <buddy_init+0x2c4>
		num=1;
30005838:	e3a03001 	mov	r3, #1
3000583c:	e58d3020 	str	r3, [sp, #32]
	save_adr-=num*4;
30005840:	e59d3020 	ldr	r3, [sp, #32]
30005844:	e1a03103 	lsl	r3, r3, #2
30005848:	e59d2018 	ldr	r2, [sp, #24]
3000584c:	e0633002 	rsb	r3, r3, r2
30005850:	e58d3018 	str	r3, [sp, #24]
	save_adr&=~(4-1);
30005854:	e59d3018 	ldr	r3, [sp, #24]
30005858:	e3c33003 	bic	r3, r3, #3
3000585c:	e58d3018 	str	r3, [sp, #24]
	acoral_mem_ctrl->bitmap[i]=(acoral_u32 *)save_adr;
30005860:	e59f34ac 	ldr	r3, [pc, #1196]	; 30005d14 <buddy_init+0x798>
30005864:	e5933000 	ldr	r3, [r3]
30005868:	e59d200c 	ldr	r2, [sp, #12]
3000586c:	e59d1018 	ldr	r1, [sp, #24]
30005870:	e282200e 	add	r2, r2, #14
30005874:	e7831102 	str	r1, [r3, r2, lsl #2]
	acoral_mem_ctrl->num[i]=num;
30005878:	e59f3494 	ldr	r3, [pc, #1172]	; 30005d14 <buddy_init+0x798>
3000587c:	e5933000 	ldr	r3, [r3]
30005880:	e59d200c 	ldr	r2, [sp, #12]
30005884:	e282202a 	add	r2, r2, #42	; 0x2a
30005888:	e59d1020 	ldr	r1, [sp, #32]
3000588c:	e7831102 	str	r1, [r3, r2, lsl #2]
	save_adr-=num*4;
30005890:	e59d3020 	ldr	r3, [sp, #32]
30005894:	e1a03103 	lsl	r3, r3, #2
30005898:	e59d2018 	ldr	r2, [sp, #24]
3000589c:	e0633002 	rsb	r3, r3, r2
300058a0:	e58d3018 	str	r3, [sp, #24]
	save_adr&=~(4-1);
300058a4:	e59d3018 	ldr	r3, [sp, #24]
300058a8:	e3c33003 	bic	r3, r3, #3
300058ac:	e58d3018 	str	r3, [sp, #24]
	acoral_mem_ctrl->free_list[i]=(acoral_32 *)save_adr;
300058b0:	e59f345c 	ldr	r3, [pc, #1116]	; 30005d14 <buddy_init+0x798>
300058b4:	e5933000 	ldr	r3, [r3]
300058b8:	e59d200c 	ldr	r2, [sp, #12]
300058bc:	e59d1018 	ldr	r1, [sp, #24]
300058c0:	e7831102 	str	r1, [r3, r2, lsl #2]
	for(k=0;k<num;k++){
300058c4:	e3a03000 	mov	r3, #0
300058c8:	e58d3010 	str	r3, [sp, #16]
300058cc:	ea000015 	b	30005928 <buddy_init+0x3ac>
		acoral_mem_ctrl->bitmap[i][k]=0;;
300058d0:	e59f343c 	ldr	r3, [pc, #1084]	; 30005d14 <buddy_init+0x798>
300058d4:	e5933000 	ldr	r3, [r3]
300058d8:	e59d200c 	ldr	r2, [sp, #12]
300058dc:	e282200e 	add	r2, r2, #14
300058e0:	e7932102 	ldr	r2, [r3, r2, lsl #2]
300058e4:	e59d3010 	ldr	r3, [sp, #16]
300058e8:	e1a03103 	lsl	r3, r3, #2
300058ec:	e0823003 	add	r3, r2, r3
300058f0:	e3a02000 	mov	r2, #0
300058f4:	e5832000 	str	r2, [r3]
		acoral_mem_ctrl->free_list[i][k]=-1;
300058f8:	e59f3414 	ldr	r3, [pc, #1044]	; 30005d14 <buddy_init+0x798>
300058fc:	e5933000 	ldr	r3, [r3]
30005900:	e59d200c 	ldr	r2, [sp, #12]
30005904:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005908:	e59d3010 	ldr	r3, [sp, #16]
3000590c:	e1a03103 	lsl	r3, r3, #2
30005910:	e0823003 	add	r3, r2, r3
30005914:	e3e02000 	mvn	r2, #0
30005918:	e5832000 	str	r2, [r3]
	acoral_mem_ctrl->bitmap[i]=(acoral_u32 *)save_adr;
	acoral_mem_ctrl->num[i]=num;
	save_adr-=num*4;
	save_adr&=~(4-1);
	acoral_mem_ctrl->free_list[i]=(acoral_32 *)save_adr;
	for(k=0;k<num;k++){
3000591c:	e59d3010 	ldr	r3, [sp, #16]
30005920:	e2833001 	add	r3, r3, #1
30005924:	e58d3010 	str	r3, [sp, #16]
30005928:	e59d2010 	ldr	r2, [sp, #16]
3000592c:	e59d3020 	ldr	r3, [sp, #32]
30005930:	e1520003 	cmp	r2, r3
30005934:	3affffe5 	bcc	300058d0 <buddy_init+0x354>
		acoral_mem_ctrl->bitmap[i][k]=0;;
		acoral_mem_ctrl->free_list[i][k]=-1;
	}
	acoral_mem_ctrl->free_cur[i]=-1;
30005938:	e59f33d4 	ldr	r3, [pc, #980]	; 30005d14 <buddy_init+0x798>
3000593c:	e5933000 	ldr	r3, [r3]
30005940:	e59d200c 	ldr	r2, [sp, #12]
30005944:	e282201c 	add	r2, r2, #28
30005948:	e3e01000 	mvn	r1, #0
3000594c:	e7831102 	str	r1, [r3, r2, lsl #2]

	/*如果减去刚才bitmap用的内存刚好是下一level*/
	if(save_adr<=(start_adr+(resize_size>>1)))
30005950:	e59d3014 	ldr	r3, [sp, #20]
30005954:	e1a020a3 	lsr	r2, r3, #1
30005958:	e59d3004 	ldr	r3, [sp, #4]
3000595c:	e0822003 	add	r2, r2, r3
30005960:	e59d3018 	ldr	r3, [sp, #24]
30005964:	e1520003 	cmp	r2, r3
30005968:	3a000002 	bcc	30005978 <buddy_init+0x3fc>
		adjust_level--;
3000596c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30005970:	e2433001 	sub	r3, r3, #1
30005974:	e58d3024 	str	r3, [sp, #36]	; 0x24
	if(adjust_level>LEVEL)
30005978:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3000597c:	e353000e 	cmp	r3, #14
30005980:	9a000001 	bls	3000598c <buddy_init+0x410>
		level=LEVEL;
30005984:	e3a0300e 	mov	r3, #14
30005988:	e58d3028 	str	r3, [sp, #40]	; 0x28
	acoral_mem_ctrl->level=level;
3000598c:	e59f3380 	ldr	r3, [pc, #896]	; 30005d14 <buddy_init+0x798>
30005990:	e5933000 	ldr	r3, [r3]
30005994:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005998:	e20220ff 	and	r2, r2, #255	; 0xff
3000599c:	e5c320e0 	strb	r2, [r3, #224]	; 0xe0
	acoral_mem_ctrl->start_adr=start_adr;
300059a0:	e59f336c 	ldr	r3, [pc, #876]	; 30005d14 <buddy_init+0x798>
300059a4:	e5933000 	ldr	r3, [r3]
300059a8:	e59d2004 	ldr	r2, [sp, #4]
300059ac:	e58320e4 	str	r2, [r3, #228]	; 0xe4
	num=(save_adr-start_adr)>>BLOCK_SHIFT;
300059b0:	e59d2018 	ldr	r2, [sp, #24]
300059b4:	e59d3004 	ldr	r3, [sp, #4]
300059b8:	e0633002 	rsb	r3, r3, r2
300059bc:	e1a033a3 	lsr	r3, r3, #7
300059c0:	e58d3020 	str	r3, [sp, #32]
	acoral_mem_ctrl->end_adr=start_adr+(num<<BLOCK_SHIFT);
300059c4:	e59f3348 	ldr	r3, [pc, #840]	; 30005d14 <buddy_init+0x798>
300059c8:	e5933000 	ldr	r3, [r3]
300059cc:	e59d2020 	ldr	r2, [sp, #32]
300059d0:	e1a01382 	lsl	r1, r2, #7
300059d4:	e59d2004 	ldr	r2, [sp, #4]
300059d8:	e0812002 	add	r2, r1, r2
300059dc:	e58320e8 	str	r2, [r3, #232]	; 0xe8
	acoral_mem_ctrl->block_num=num;
300059e0:	e59f332c 	ldr	r3, [pc, #812]	; 30005d14 <buddy_init+0x798>
300059e4:	e5933000 	ldr	r3, [r3]
300059e8:	e59d2020 	ldr	r2, [sp, #32]
300059ec:	e58320ec 	str	r2, [r3, #236]	; 0xec
	acoral_mem_ctrl->free_num=num;
300059f0:	e59f331c 	ldr	r3, [pc, #796]	; 30005d14 <buddy_init+0x798>
300059f4:	e5933000 	ldr	r3, [r3]
300059f8:	e59d2020 	ldr	r2, [sp, #32]
300059fc:	e58320f0 	str	r2, [r3, #240]	; 0xf0
	acoral_mem_ctrl->block_size=BLOCK_SIZE;
30005a00:	e59f330c 	ldr	r3, [pc, #780]	; 30005d14 <buddy_init+0x798>
30005a04:	e5933000 	ldr	r3, [r3]
30005a08:	e3a02080 	mov	r2, #128	; 0x80
30005a0c:	e58320f4 	str	r2, [r3, #244]	; 0xf4

	i=0;
30005a10:	e3a03000 	mov	r3, #0
30005a14:	e58d300c 	str	r3, [sp, #12]
	max_num=1<<level-1;
30005a18:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30005a1c:	e2433001 	sub	r3, r3, #1
30005a20:	e3a02001 	mov	r2, #1
30005a24:	e1a03312 	lsl	r3, r2, r3
30005a28:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	o_num=0;
30005a2c:	e3a03000 	mov	r3, #0
30005a30:	e58d3030 	str	r3, [sp, #48]	; 0x30
	if(num>0)
30005a34:	e59d3020 	ldr	r3, [sp, #32]
30005a38:	e3530000 	cmp	r3, #0
30005a3c:	0a000007 	beq	30005a60 <buddy_init+0x4e4>
		acoral_mem_ctrl->free_cur[level-1]=0;
30005a40:	e59f32cc 	ldr	r3, [pc, #716]	; 30005d14 <buddy_init+0x798>
30005a44:	e5933000 	ldr	r3, [r3]
30005a48:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005a4c:	e2422001 	sub	r2, r2, #1
30005a50:	e282201c 	add	r2, r2, #28
30005a54:	e3a01000 	mov	r1, #0
30005a58:	e7831102 	str	r1, [r3, r2, lsl #2]
	else
		acoral_mem_ctrl->free_cur[level-1]=-1;

	while(num>=max_num*32){
30005a5c:	ea00002a 	b	30005b0c <buddy_init+0x590>
	max_num=1<<level-1;
	o_num=0;
	if(num>0)
		acoral_mem_ctrl->free_cur[level-1]=0;
	else
		acoral_mem_ctrl->free_cur[level-1]=-1;
30005a60:	e59f32ac 	ldr	r3, [pc, #684]	; 30005d14 <buddy_init+0x798>
30005a64:	e5933000 	ldr	r3, [r3]
30005a68:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005a6c:	e2422001 	sub	r2, r2, #1
30005a70:	e282201c 	add	r2, r2, #28
30005a74:	e3e01000 	mvn	r1, #0
30005a78:	e7831102 	str	r1, [r3, r2, lsl #2]

	while(num>=max_num*32){
30005a7c:	ea000022 	b	30005b0c <buddy_init+0x590>
		acoral_mem_ctrl->bitmap[level-1][i]=-1;;
30005a80:	e59f328c 	ldr	r3, [pc, #652]	; 30005d14 <buddy_init+0x798>
30005a84:	e5933000 	ldr	r3, [r3]
30005a88:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005a8c:	e2422001 	sub	r2, r2, #1
30005a90:	e282200e 	add	r2, r2, #14
30005a94:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005a98:	e59d300c 	ldr	r3, [sp, #12]
30005a9c:	e1a03103 	lsl	r3, r3, #2
30005aa0:	e0823003 	add	r3, r2, r3
30005aa4:	e3e02000 	mvn	r2, #0
30005aa8:	e5832000 	str	r2, [r3]
		acoral_mem_ctrl->free_list[level-1][i]=i+1;
30005aac:	e59f3260 	ldr	r3, [pc, #608]	; 30005d14 <buddy_init+0x798>
30005ab0:	e5933000 	ldr	r3, [r3]
30005ab4:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005ab8:	e2422001 	sub	r2, r2, #1
30005abc:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005ac0:	e59d300c 	ldr	r3, [sp, #12]
30005ac4:	e1a03103 	lsl	r3, r3, #2
30005ac8:	e0823003 	add	r3, r2, r3
30005acc:	e59d200c 	ldr	r2, [sp, #12]
30005ad0:	e2822001 	add	r2, r2, #1
30005ad4:	e5832000 	str	r2, [r3]
		num-=max_num*32;
30005ad8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005adc:	e1a03283 	lsl	r3, r3, #5
30005ae0:	e59d2020 	ldr	r2, [sp, #32]
30005ae4:	e0633002 	rsb	r3, r3, r2
30005ae8:	e58d3020 	str	r3, [sp, #32]
		o_num+=max_num*32;
30005aec:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005af0:	e1a03283 	lsl	r3, r3, #5
30005af4:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
30005af8:	e0823003 	add	r3, r2, r3
30005afc:	e58d3030 	str	r3, [sp, #48]	; 0x30
		i++;
30005b00:	e59d300c 	ldr	r3, [sp, #12]
30005b04:	e2833001 	add	r3, r3, #1
30005b08:	e58d300c 	str	r3, [sp, #12]
	if(num>0)
		acoral_mem_ctrl->free_cur[level-1]=0;
	else
		acoral_mem_ctrl->free_cur[level-1]=-1;

	while(num>=max_num*32){
30005b0c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005b10:	e1a02283 	lsl	r2, r3, #5
30005b14:	e59d3020 	ldr	r3, [sp, #32]
30005b18:	e1520003 	cmp	r2, r3
30005b1c:	9affffd7 	bls	30005a80 <buddy_init+0x504>
		acoral_mem_ctrl->free_list[level-1][i]=i+1;
		num-=max_num*32;
		o_num+=max_num*32;
		i++;
	}
	if(num==0)
30005b20:	e59d3020 	ldr	r3, [sp, #32]
30005b24:	e3530000 	cmp	r3, #0
30005b28:	1a000021 	bne	30005bb4 <buddy_init+0x638>
		acoral_mem_ctrl->free_list[level-1][i-1]=-1;
30005b2c:	e59f31e0 	ldr	r3, [pc, #480]	; 30005d14 <buddy_init+0x798>
30005b30:	e5933000 	ldr	r3, [r3]
30005b34:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005b38:	e2422001 	sub	r2, r2, #1
30005b3c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005b40:	e59d300c 	ldr	r3, [sp, #12]
30005b44:	e2433001 	sub	r3, r3, #1
30005b48:	e1a03103 	lsl	r3, r3, #2
30005b4c:	e0823003 	add	r3, r2, r3
30005b50:	e3e02000 	mvn	r2, #0
30005b54:	e5832000 	str	r2, [r3]
	while(num>=max_num){
30005b58:	ea000015 	b	30005bb4 <buddy_init+0x638>
		index=o_num>>level-1;
30005b5c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30005b60:	e2433001 	sub	r3, r3, #1
30005b64:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
30005b68:	e1a03332 	lsr	r3, r2, r3
30005b6c:	e58d301c 	str	r3, [sp, #28]
		acoral_set_bit(index,acoral_mem_ctrl->bitmap[level-1]);
30005b70:	e59f319c 	ldr	r3, [pc, #412]	; 30005d14 <buddy_init+0x798>
30005b74:	e5933000 	ldr	r3, [r3]
30005b78:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005b7c:	e2422001 	sub	r2, r2, #1
30005b80:	e282200e 	add	r2, r2, #14
30005b84:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30005b88:	e59d001c 	ldr	r0, [sp, #28]
30005b8c:	e1a01003 	mov	r1, r3
30005b90:	eb001036 	bl	30009c70 <acoral_set_bit>
		num-=max_num;
30005b94:	e59d2020 	ldr	r2, [sp, #32]
30005b98:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005b9c:	e0633002 	rsb	r3, r3, r2
30005ba0:	e58d3020 	str	r3, [sp, #32]
		o_num+=max_num;
30005ba4:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
30005ba8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005bac:	e0823003 	add	r3, r2, r3
30005bb0:	e58d3030 	str	r3, [sp, #48]	; 0x30
		o_num+=max_num*32;
		i++;
	}
	if(num==0)
		acoral_mem_ctrl->free_list[level-1][i-1]=-1;
	while(num>=max_num){
30005bb4:	e59d2020 	ldr	r2, [sp, #32]
30005bb8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005bbc:	e1520003 	cmp	r2, r3
30005bc0:	2affffe5 	bcs	30005b5c <buddy_init+0x5e0>
		index=o_num>>level-1;
		acoral_set_bit(index,acoral_mem_ctrl->bitmap[level-1]);
		num-=max_num;
		o_num+=max_num;
	}
	acoral_mem_ctrl->free_list[level-1][i]=-1;
30005bc4:	e59f3148 	ldr	r3, [pc, #328]	; 30005d14 <buddy_init+0x798>
30005bc8:	e5933000 	ldr	r3, [r3]
30005bcc:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005bd0:	e2422001 	sub	r2, r2, #1
30005bd4:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005bd8:	e59d300c 	ldr	r3, [sp, #12]
30005bdc:	e1a03103 	lsl	r3, r3, #2
30005be0:	e0823003 	add	r3, r2, r3
30005be4:	e3e02000 	mvn	r2, #0
30005be8:	e5832000 	str	r2, [r3]

	
	while(--level>0){
30005bec:	ea00003b 	b	30005ce0 <buddy_init+0x764>
		index=o_num>>level;
30005bf0:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
30005bf4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30005bf8:	e1a03332 	lsr	r3, r2, r3
30005bfc:	e58d301c 	str	r3, [sp, #28]
		if(num==0)
30005c00:	e59d3020 	ldr	r3, [sp, #32]
30005c04:	e3530000 	cmp	r3, #0
30005c08:	0a00003b 	beq	30005cfc <buddy_init+0x780>
			break;
		cur=index/32;
30005c0c:	e59d301c 	ldr	r3, [sp, #28]
30005c10:	e1a032a3 	lsr	r3, r3, #5
30005c14:	e58d3034 	str	r3, [sp, #52]	; 0x34
		max_num=1<<level-1;
30005c18:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30005c1c:	e2433001 	sub	r3, r3, #1
30005c20:	e3a02001 	mov	r2, #1
30005c24:	e1a03312 	lsl	r3, r2, r3
30005c28:	e58d302c 	str	r3, [sp, #44]	; 0x2c
		if(num>=max_num){
30005c2c:	e59d2020 	ldr	r2, [sp, #32]
30005c30:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005c34:	e1520003 	cmp	r2, r3
30005c38:	3a000028 	bcc	30005ce0 <buddy_init+0x764>
			acoral_mem_blocks[BLOCK_INDEX(o_num)].level=-1;	
30005c3c:	e59f30d4 	ldr	r3, [pc, #212]	; 30005d18 <buddy_init+0x79c>
30005c40:	e5932000 	ldr	r2, [r3]
30005c44:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30005c48:	e1a030a3 	lsr	r3, r3, #1
30005c4c:	e0823003 	add	r3, r2, r3
30005c50:	e3e02000 	mvn	r2, #0
30005c54:	e5c32000 	strb	r2, [r3]
			acoral_set_bit(index,acoral_mem_ctrl->bitmap[level-1]);
30005c58:	e59f30b4 	ldr	r3, [pc, #180]	; 30005d14 <buddy_init+0x798>
30005c5c:	e5933000 	ldr	r3, [r3]
30005c60:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005c64:	e2422001 	sub	r2, r2, #1
30005c68:	e282200e 	add	r2, r2, #14
30005c6c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30005c70:	e59d001c 	ldr	r0, [sp, #28]
30005c74:	e1a01003 	mov	r1, r3
30005c78:	eb000ffc 	bl	30009c70 <acoral_set_bit>
			acoral_mem_ctrl->free_list[level-1][cur]=-1;	
30005c7c:	e59f3090 	ldr	r3, [pc, #144]	; 30005d14 <buddy_init+0x798>
30005c80:	e5933000 	ldr	r3, [r3]
30005c84:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005c88:	e2422001 	sub	r2, r2, #1
30005c8c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005c90:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30005c94:	e1a03103 	lsl	r3, r3, #2
30005c98:	e0823003 	add	r3, r2, r3
30005c9c:	e3e02000 	mvn	r2, #0
30005ca0:	e5832000 	str	r2, [r3]
			acoral_mem_ctrl->free_cur[level-1]=cur;	
30005ca4:	e59f3068 	ldr	r3, [pc, #104]	; 30005d14 <buddy_init+0x798>
30005ca8:	e5933000 	ldr	r3, [r3]
30005cac:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30005cb0:	e2422001 	sub	r2, r2, #1
30005cb4:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
30005cb8:	e282201c 	add	r2, r2, #28
30005cbc:	e7831102 	str	r1, [r3, r2, lsl #2]
			o_num+=max_num;
30005cc0:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
30005cc4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005cc8:	e0823003 	add	r3, r2, r3
30005ccc:	e58d3030 	str	r3, [sp, #48]	; 0x30
			num-=max_num;
30005cd0:	e59d2020 	ldr	r2, [sp, #32]
30005cd4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30005cd8:	e0633002 	rsb	r3, r3, r2
30005cdc:	e58d3020 	str	r3, [sp, #32]
		o_num+=max_num;
	}
	acoral_mem_ctrl->free_list[level-1][i]=-1;

	
	while(--level>0){
30005ce0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30005ce4:	e2433001 	sub	r3, r3, #1
30005ce8:	e58d3028 	str	r3, [sp, #40]	; 0x28
30005cec:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30005cf0:	e3530000 	cmp	r3, #0
30005cf4:	caffffbd 	bgt	30005bf0 <buddy_init+0x674>
30005cf8:	ea000000 	b	30005d00 <buddy_init+0x784>
		index=o_num>>level;
		if(num==0)
			break;
30005cfc:	e1a00000 	nop			; (mov r0, r0)
			o_num+=max_num;
			num-=max_num;
		}
	}
	acoral_spin_init(&acoral_mem_ctrl->lock);
	return 0;
30005d00:	e3a03000 	mov	r3, #0
}
30005d04:	e1a00003 	mov	r0, r3
30005d08:	e28dd03c 	add	sp, sp, #60	; 0x3c
30005d0c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30005d10:	e12fff1e 	bx	lr
30005d14:	3012d6b8 	.word	0x3012d6b8
30005d18:	300eabe0 	.word	0x300eabe0

30005d1c <recus_malloc>:

static acoral_32 recus_malloc(level){
30005d1c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30005d20:	e24dd01c 	sub	sp, sp, #28
30005d24:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 index;
	acoral_32 cur;
	acoral_32 num;
	if(level>=acoral_mem_ctrl->level)
30005d28:	e59f328c 	ldr	r3, [pc, #652]	; 30005fbc <recus_malloc+0x2a0>
30005d2c:	e5933000 	ldr	r3, [r3]
30005d30:	e5d330e0 	ldrb	r3, [r3, #224]	; 0xe0
30005d34:	e1a03c03 	lsl	r3, r3, #24
30005d38:	e1a02c43 	asr	r2, r3, #24
30005d3c:	e59d3004 	ldr	r3, [sp, #4]
30005d40:	e1520003 	cmp	r2, r3
30005d44:	ca000001 	bgt	30005d50 <recus_malloc+0x34>
		return -1;
30005d48:	e3e03000 	mvn	r3, #0
30005d4c:	ea000096 	b	30005fac <recus_malloc+0x290>
	cur=acoral_mem_ctrl->free_cur[level];
30005d50:	e59f3264 	ldr	r3, [pc, #612]	; 30005fbc <recus_malloc+0x2a0>
30005d54:	e5933000 	ldr	r3, [r3]
30005d58:	e59d2004 	ldr	r2, [sp, #4]
30005d5c:	e282201c 	add	r2, r2, #28
30005d60:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30005d64:	e58d3010 	str	r3, [sp, #16]
	if(cur<0){
30005d68:	e59d3010 	ldr	r3, [sp, #16]
30005d6c:	e3530000 	cmp	r3, #0
30005d70:	aa00002b 	bge	30005e24 <recus_malloc+0x108>
		num=recus_malloc(level+1);
30005d74:	e59d3004 	ldr	r3, [sp, #4]
30005d78:	e2833001 	add	r3, r3, #1
30005d7c:	e1a00003 	mov	r0, r3
30005d80:	ebffffe5 	bl	30005d1c <recus_malloc>
30005d84:	e1a03000 	mov	r3, r0
30005d88:	e58d3014 	str	r3, [sp, #20]
		if(num<0)
30005d8c:	e59d3014 	ldr	r3, [sp, #20]
30005d90:	e3530000 	cmp	r3, #0
30005d94:	aa000001 	bge	30005da0 <recus_malloc+0x84>
			return -1;
30005d98:	e3e03000 	mvn	r3, #0
30005d9c:	ea000082 	b	30005fac <recus_malloc+0x290>
		index=num>>level+1;
30005da0:	e59d3004 	ldr	r3, [sp, #4]
30005da4:	e2833001 	add	r3, r3, #1
30005da8:	e59d2014 	ldr	r2, [sp, #20]
30005dac:	e1a03352 	asr	r3, r2, r3
30005db0:	e58d300c 	str	r3, [sp, #12]
		cur=index/32;
30005db4:	e59d300c 	ldr	r3, [sp, #12]
30005db8:	e1a032a3 	lsr	r3, r3, #5
30005dbc:	e58d3010 	str	r3, [sp, #16]
		acoral_set_bit(index,acoral_mem_ctrl->bitmap[level]);
30005dc0:	e59f31f4 	ldr	r3, [pc, #500]	; 30005fbc <recus_malloc+0x2a0>
30005dc4:	e5933000 	ldr	r3, [r3]
30005dc8:	e59d2004 	ldr	r2, [sp, #4]
30005dcc:	e282200e 	add	r2, r2, #14
30005dd0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30005dd4:	e59d000c 	ldr	r0, [sp, #12]
30005dd8:	e1a01003 	mov	r1, r3
30005ddc:	eb000fa3 	bl	30009c70 <acoral_set_bit>
		acoral_mem_ctrl->free_list[level][cur]=-1;
30005de0:	e59f31d4 	ldr	r3, [pc, #468]	; 30005fbc <recus_malloc+0x2a0>
30005de4:	e5933000 	ldr	r3, [r3]
30005de8:	e59d2004 	ldr	r2, [sp, #4]
30005dec:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005df0:	e59d3010 	ldr	r3, [sp, #16]
30005df4:	e1a03103 	lsl	r3, r3, #2
30005df8:	e0823003 	add	r3, r2, r3
30005dfc:	e3e02000 	mvn	r2, #0
30005e00:	e5832000 	str	r2, [r3]
		acoral_mem_ctrl->free_cur[level]=cur;
30005e04:	e59f31b0 	ldr	r3, [pc, #432]	; 30005fbc <recus_malloc+0x2a0>
30005e08:	e5933000 	ldr	r3, [r3]
30005e0c:	e59d2004 	ldr	r2, [sp, #4]
30005e10:	e282201c 	add	r2, r2, #28
30005e14:	e59d1010 	ldr	r1, [sp, #16]
30005e18:	e7831102 	str	r1, [r3, r2, lsl #2]
		return num;
30005e1c:	e59d3014 	ldr	r3, [sp, #20]
30005e20:	ea000061 	b	30005fac <recus_malloc+0x290>
	}
	index=acoral_ffs(acoral_mem_ctrl->bitmap[level][cur]);
30005e24:	e59f3190 	ldr	r3, [pc, #400]	; 30005fbc <recus_malloc+0x2a0>
30005e28:	e5933000 	ldr	r3, [r3]
30005e2c:	e59d2004 	ldr	r2, [sp, #4]
30005e30:	e282200e 	add	r2, r2, #14
30005e34:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005e38:	e59d3010 	ldr	r3, [sp, #16]
30005e3c:	e1a03103 	lsl	r3, r3, #2
30005e40:	e0823003 	add	r3, r2, r3
30005e44:	e5933000 	ldr	r3, [r3]
30005e48:	e1a00003 	mov	r0, r3
30005e4c:	eb000f2c 	bl	30009b04 <acoral_ffs>
30005e50:	e1a03000 	mov	r3, r0
30005e54:	e58d300c 	str	r3, [sp, #12]
	index=cur*32+index;
30005e58:	e59d3010 	ldr	r3, [sp, #16]
30005e5c:	e1a03283 	lsl	r3, r3, #5
30005e60:	e59d200c 	ldr	r2, [sp, #12]
30005e64:	e0823003 	add	r3, r2, r3
30005e68:	e58d300c 	str	r3, [sp, #12]
	acoral_clear_bit(index,acoral_mem_ctrl->bitmap[level]);
30005e6c:	e59f3148 	ldr	r3, [pc, #328]	; 30005fbc <recus_malloc+0x2a0>
30005e70:	e5933000 	ldr	r3, [r3]
30005e74:	e59d2004 	ldr	r2, [sp, #4]
30005e78:	e282200e 	add	r2, r2, #14
30005e7c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30005e80:	e59d000c 	ldr	r0, [sp, #12]
30005e84:	e1a01003 	mov	r1, r3
30005e88:	eb000f90 	bl	30009cd0 <acoral_clear_bit>
	if(acoral_mem_ctrl->bitmap[level][cur]==0)
30005e8c:	e59f3128 	ldr	r3, [pc, #296]	; 30005fbc <recus_malloc+0x2a0>
30005e90:	e5933000 	ldr	r3, [r3]
30005e94:	e59d2004 	ldr	r2, [sp, #4]
30005e98:	e282200e 	add	r2, r2, #14
30005e9c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30005ea0:	e59d3010 	ldr	r3, [sp, #16]
30005ea4:	e1a03103 	lsl	r3, r3, #2
30005ea8:	e0823003 	add	r3, r2, r3
30005eac:	e5933000 	ldr	r3, [r3]
30005eb0:	e3530000 	cmp	r3, #0
30005eb4:	1a00000c 	bne	30005eec <recus_malloc+0x1d0>
		acoral_mem_ctrl->free_cur[level]=acoral_mem_ctrl->free_list[level][cur];
30005eb8:	e59f30fc 	ldr	r3, [pc, #252]	; 30005fbc <recus_malloc+0x2a0>
30005ebc:	e5933000 	ldr	r3, [r3]
30005ec0:	e59d2004 	ldr	r2, [sp, #4]
30005ec4:	e59f10f0 	ldr	r1, [pc, #240]	; 30005fbc <recus_malloc+0x2a0>
30005ec8:	e5911000 	ldr	r1, [r1]
30005ecc:	e59d0004 	ldr	r0, [sp, #4]
30005ed0:	e7910100 	ldr	r0, [r1, r0, lsl #2]
30005ed4:	e59d1010 	ldr	r1, [sp, #16]
30005ed8:	e1a01101 	lsl	r1, r1, #2
30005edc:	e0801001 	add	r1, r0, r1
30005ee0:	e5911000 	ldr	r1, [r1]
30005ee4:	e282201c 	add	r2, r2, #28
30005ee8:	e7831102 	str	r1, [r3, r2, lsl #2]
	num=index<<level+1;
30005eec:	e59d3004 	ldr	r3, [sp, #4]
30005ef0:	e2833001 	add	r3, r3, #1
30005ef4:	e59d200c 	ldr	r2, [sp, #12]
30005ef8:	e1a03312 	lsl	r3, r2, r3
30005efc:	e58d3014 	str	r3, [sp, #20]
	/*最高level情况*/
	if(level==acoral_mem_ctrl->level-1){
30005f00:	e59f30b4 	ldr	r3, [pc, #180]	; 30005fbc <recus_malloc+0x2a0>
30005f04:	e5933000 	ldr	r3, [r3]
30005f08:	e5d330e0 	ldrb	r3, [r3, #224]	; 0xe0
30005f0c:	e1a03c03 	lsl	r3, r3, #24
30005f10:	e1a03c43 	asr	r3, r3, #24
30005f14:	e2432001 	sub	r2, r3, #1
30005f18:	e59d3004 	ldr	r3, [sp, #4]
30005f1c:	e1520003 	cmp	r2, r3
30005f20:	1a000010 	bne	30005f68 <recus_malloc+0x24c>
		if((num>>1)+(1<<level)>acoral_mem_ctrl->block_num)
30005f24:	e59d3014 	ldr	r3, [sp, #20]
30005f28:	e1a020c3 	asr	r2, r3, #1
30005f2c:	e3a01001 	mov	r1, #1
30005f30:	e59d3004 	ldr	r3, [sp, #4]
30005f34:	e1a03311 	lsl	r3, r1, r3
30005f38:	e0823003 	add	r3, r2, r3
30005f3c:	e1a02003 	mov	r2, r3
30005f40:	e59f3074 	ldr	r3, [pc, #116]	; 30005fbc <recus_malloc+0x2a0>
30005f44:	e5933000 	ldr	r3, [r3]
30005f48:	e59330ec 	ldr	r3, [r3, #236]	; 0xec
30005f4c:	e1520003 	cmp	r2, r3
30005f50:	9a000001 	bls	30005f5c <recus_malloc+0x240>
			return -1;
30005f54:	e3e03000 	mvn	r3, #0
30005f58:	ea000013 	b	30005fac <recus_malloc+0x290>
		return num>>1;
30005f5c:	e59d3014 	ldr	r3, [sp, #20]
30005f60:	e1a030c3 	asr	r3, r3, #1
30005f64:	ea000010 	b	30005fac <recus_malloc+0x290>
	}
	if(acoral_mem_blocks[BLOCK_INDEX(num)].level>=0)
30005f68:	e59f3050 	ldr	r3, [pc, #80]	; 30005fc0 <recus_malloc+0x2a4>
30005f6c:	e5932000 	ldr	r2, [r3]
30005f70:	e59d3014 	ldr	r3, [sp, #20]
30005f74:	e1a030c3 	asr	r3, r3, #1
30005f78:	e0823003 	add	r3, r2, r3
30005f7c:	e5d33000 	ldrb	r3, [r3]
30005f80:	e1a03c03 	lsl	r3, r3, #24
30005f84:	e1a03c43 	asr	r3, r3, #24
30005f88:	e3530000 	cmp	r3, #0
30005f8c:	ba000005 	blt	30005fa8 <recus_malloc+0x28c>
		return num+(1<<level);
30005f90:	e3a02001 	mov	r2, #1
30005f94:	e59d3004 	ldr	r3, [sp, #4]
30005f98:	e1a02312 	lsl	r2, r2, r3
30005f9c:	e59d3014 	ldr	r3, [sp, #20]
30005fa0:	e0823003 	add	r3, r2, r3
30005fa4:	ea000000 	b	30005fac <recus_malloc+0x290>
	else
		return num;
30005fa8:	e59d3014 	ldr	r3, [sp, #20]
}
30005fac:	e1a00003 	mov	r0, r3
30005fb0:	e28dd01c 	add	sp, sp, #28
30005fb4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30005fb8:	e12fff1e 	bx	lr
30005fbc:	3012d6b8 	.word	0x3012d6b8
30005fc0:	300eabe0 	.word	0x300eabe0

30005fc4 <r_malloc>:

static void *r_malloc(acoral_u8 level){
30005fc4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30005fc8:	e24dd01c 	sub	sp, sp, #28
30005fcc:	e1a03000 	mov	r3, r0
30005fd0:	e5cd3007 	strb	r3, [sp, #7]
	acoral_sr cpu_sr;
	acoral_u32 index;
	acoral_32 num,cur;
	HAL_ENTER_CRITICAL();
30005fd4:	ebffedc6 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30005fd8:	e1a03000 	mov	r3, r0
30005fdc:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&acoral_mem_ctrl->lock);
	acoral_mem_ctrl->free_num-=1<<level;
30005fe0:	e59f3334 	ldr	r3, [pc, #820]	; 3000631c <r_malloc+0x358>
30005fe4:	e5933000 	ldr	r3, [r3]
30005fe8:	e59f232c 	ldr	r2, [pc, #812]	; 3000631c <r_malloc+0x358>
30005fec:	e5922000 	ldr	r2, [r2]
30005ff0:	e59210f0 	ldr	r1, [r2, #240]	; 0xf0
30005ff4:	e5dd2007 	ldrb	r2, [sp, #7]
30005ff8:	e3a00001 	mov	r0, #1
30005ffc:	e1a02210 	lsl	r2, r0, r2
30006000:	e0622001 	rsb	r2, r2, r1
30006004:	e58320f0 	str	r2, [r3, #240]	; 0xf0
	cur=acoral_mem_ctrl->free_cur[level];
30006008:	e59f330c 	ldr	r3, [pc, #780]	; 3000631c <r_malloc+0x358>
3000600c:	e5933000 	ldr	r3, [r3]
30006010:	e5dd2007 	ldrb	r2, [sp, #7]
30006014:	e282201c 	add	r2, r2, #28
30006018:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3000601c:	e58d3014 	str	r3, [sp, #20]
	if(cur<0){
30006020:	e59d3014 	ldr	r3, [sp, #20]
30006024:	e3530000 	cmp	r3, #0
30006028:	aa00003f 	bge	3000612c <r_malloc+0x168>
		num=recus_malloc(level+1);
3000602c:	e5dd3007 	ldrb	r3, [sp, #7]
30006030:	e2833001 	add	r3, r3, #1
30006034:	e1a00003 	mov	r0, r3
30006038:	ebffff37 	bl	30005d1c <recus_malloc>
3000603c:	e1a03000 	mov	r3, r0
30006040:	e58d3010 	str	r3, [sp, #16]
		if(num<0){
30006044:	e59d3010 	ldr	r3, [sp, #16]
30006048:	e3530000 	cmp	r3, #0
3000604c:	aa000003 	bge	30006060 <r_malloc+0x9c>
			acoral_spin_unlock(&acoral_mem_ctrl->lock);
			HAL_EXIT_CRITICAL();
30006050:	e59d0008 	ldr	r0, [sp, #8]
30006054:	ebffeda4 	bl	300016ec <HAL_INTR_RESTORE>
			return NULL;
30006058:	e3a03000 	mov	r3, #0
3000605c:	ea0000aa 	b	3000630c <r_malloc+0x348>
		}
		index=num>>level+1;
30006060:	e5dd3007 	ldrb	r3, [sp, #7]
30006064:	e2833001 	add	r3, r3, #1
30006068:	e59d2010 	ldr	r2, [sp, #16]
3000606c:	e1a03352 	asr	r3, r2, r3
30006070:	e58d300c 	str	r3, [sp, #12]
		cur=index/32;
30006074:	e59d300c 	ldr	r3, [sp, #12]
30006078:	e1a032a3 	lsr	r3, r3, #5
3000607c:	e58d3014 	str	r3, [sp, #20]
		acoral_set_bit(index,acoral_mem_ctrl->bitmap[level]);
30006080:	e59f3294 	ldr	r3, [pc, #660]	; 3000631c <r_malloc+0x358>
30006084:	e5933000 	ldr	r3, [r3]
30006088:	e5dd2007 	ldrb	r2, [sp, #7]
3000608c:	e282200e 	add	r2, r2, #14
30006090:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30006094:	e59d000c 	ldr	r0, [sp, #12]
30006098:	e1a01003 	mov	r1, r3
3000609c:	eb000ef3 	bl	30009c70 <acoral_set_bit>
		acoral_mem_ctrl->free_list[level][cur]=-1;
300060a0:	e59f3274 	ldr	r3, [pc, #628]	; 3000631c <r_malloc+0x358>
300060a4:	e5933000 	ldr	r3, [r3]
300060a8:	e5dd2007 	ldrb	r2, [sp, #7]
300060ac:	e7932102 	ldr	r2, [r3, r2, lsl #2]
300060b0:	e59d3014 	ldr	r3, [sp, #20]
300060b4:	e1a03103 	lsl	r3, r3, #2
300060b8:	e0823003 	add	r3, r2, r3
300060bc:	e3e02000 	mvn	r2, #0
300060c0:	e5832000 	str	r2, [r3]
		acoral_mem_ctrl->free_cur[level]=cur;
300060c4:	e59f3250 	ldr	r3, [pc, #592]	; 3000631c <r_malloc+0x358>
300060c8:	e5933000 	ldr	r3, [r3]
300060cc:	e5dd2007 	ldrb	r2, [sp, #7]
300060d0:	e282201c 	add	r2, r2, #28
300060d4:	e59d1014 	ldr	r1, [sp, #20]
300060d8:	e7831102 	str	r1, [r3, r2, lsl #2]
		if((num&0x1)==0)
300060dc:	e59d3010 	ldr	r3, [sp, #16]
300060e0:	e2033001 	and	r3, r3, #1
300060e4:	e3530000 	cmp	r3, #0
300060e8:	1a000006 	bne	30006108 <r_malloc+0x144>
			acoral_mem_blocks[BLOCK_INDEX(num)].level=level;
300060ec:	e59f322c 	ldr	r3, [pc, #556]	; 30006320 <r_malloc+0x35c>
300060f0:	e5932000 	ldr	r2, [r3]
300060f4:	e59d3010 	ldr	r3, [sp, #16]
300060f8:	e1a030c3 	asr	r3, r3, #1
300060fc:	e0823003 	add	r3, r2, r3
30006100:	e5dd2007 	ldrb	r2, [sp, #7]
30006104:	e5c32000 	strb	r2, [r3]
#endif
#ifdef CFG_TEST_MEM
		buddy_scan();
#endif
		acoral_spin_unlock(&acoral_mem_ctrl->lock);
		HAL_EXIT_CRITICAL();
30006108:	e59d0008 	ldr	r0, [sp, #8]
3000610c:	ebffed76 	bl	300016ec <HAL_INTR_RESTORE>
		return (void *)(acoral_mem_ctrl->start_adr+(num<<BLOCK_SHIFT));
30006110:	e59f3204 	ldr	r3, [pc, #516]	; 3000631c <r_malloc+0x358>
30006114:	e5933000 	ldr	r3, [r3]
30006118:	e59320e4 	ldr	r2, [r3, #228]	; 0xe4
3000611c:	e59d3010 	ldr	r3, [sp, #16]
30006120:	e1a03383 	lsl	r3, r3, #7
30006124:	e0823003 	add	r3, r2, r3
30006128:	ea000077 	b	3000630c <r_malloc+0x348>
	}
	index=acoral_ffs(acoral_mem_ctrl->bitmap[level][cur]);
3000612c:	e59f31e8 	ldr	r3, [pc, #488]	; 3000631c <r_malloc+0x358>
30006130:	e5933000 	ldr	r3, [r3]
30006134:	e5dd2007 	ldrb	r2, [sp, #7]
30006138:	e282200e 	add	r2, r2, #14
3000613c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30006140:	e59d3014 	ldr	r3, [sp, #20]
30006144:	e1a03103 	lsl	r3, r3, #2
30006148:	e0823003 	add	r3, r2, r3
3000614c:	e5933000 	ldr	r3, [r3]
30006150:	e1a00003 	mov	r0, r3
30006154:	eb000e6a 	bl	30009b04 <acoral_ffs>
30006158:	e1a03000 	mov	r3, r0
3000615c:	e58d300c 	str	r3, [sp, #12]
	index=index+cur*32;
30006160:	e59d3014 	ldr	r3, [sp, #20]
30006164:	e1a03283 	lsl	r3, r3, #5
30006168:	e59d200c 	ldr	r2, [sp, #12]
3000616c:	e0823003 	add	r3, r2, r3
30006170:	e58d300c 	str	r3, [sp, #12]
	acoral_clear_bit(index,acoral_mem_ctrl->bitmap[level]);
30006174:	e59f31a0 	ldr	r3, [pc, #416]	; 3000631c <r_malloc+0x358>
30006178:	e5933000 	ldr	r3, [r3]
3000617c:	e5dd2007 	ldrb	r2, [sp, #7]
30006180:	e282200e 	add	r2, r2, #14
30006184:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30006188:	e59d000c 	ldr	r0, [sp, #12]
3000618c:	e1a01003 	mov	r1, r3
30006190:	eb000ece 	bl	30009cd0 <acoral_clear_bit>
	if(acoral_mem_ctrl->bitmap[level][cur]==0){
30006194:	e59f3180 	ldr	r3, [pc, #384]	; 3000631c <r_malloc+0x358>
30006198:	e5933000 	ldr	r3, [r3]
3000619c:	e5dd2007 	ldrb	r2, [sp, #7]
300061a0:	e282200e 	add	r2, r2, #14
300061a4:	e7932102 	ldr	r2, [r3, r2, lsl #2]
300061a8:	e59d3014 	ldr	r3, [sp, #20]
300061ac:	e1a03103 	lsl	r3, r3, #2
300061b0:	e0823003 	add	r3, r2, r3
300061b4:	e5933000 	ldr	r3, [r3]
300061b8:	e3530000 	cmp	r3, #0
300061bc:	1a00000c 	bne	300061f4 <r_malloc+0x230>
		acoral_mem_ctrl->free_cur[level]=acoral_mem_ctrl->free_list[level][cur];
300061c0:	e59f3154 	ldr	r3, [pc, #340]	; 3000631c <r_malloc+0x358>
300061c4:	e5933000 	ldr	r3, [r3]
300061c8:	e5dd2007 	ldrb	r2, [sp, #7]
300061cc:	e59f1148 	ldr	r1, [pc, #328]	; 3000631c <r_malloc+0x358>
300061d0:	e5911000 	ldr	r1, [r1]
300061d4:	e5dd0007 	ldrb	r0, [sp, #7]
300061d8:	e7910100 	ldr	r0, [r1, r0, lsl #2]
300061dc:	e59d1014 	ldr	r1, [sp, #20]
300061e0:	e1a01101 	lsl	r1, r1, #2
300061e4:	e0801001 	add	r1, r0, r1
300061e8:	e5911000 	ldr	r1, [r1]
300061ec:	e282201c 	add	r2, r2, #28
300061f0:	e7831102 	str	r1, [r3, r2, lsl #2]
	}
	if(level==acoral_mem_ctrl->level-1){
300061f4:	e5dd2007 	ldrb	r2, [sp, #7]
300061f8:	e59f311c 	ldr	r3, [pc, #284]	; 3000631c <r_malloc+0x358>
300061fc:	e5933000 	ldr	r3, [r3]
30006200:	e5d330e0 	ldrb	r3, [r3, #224]	; 0xe0
30006204:	e1a03c03 	lsl	r3, r3, #24
30006208:	e1a03c43 	asr	r3, r3, #24
3000620c:	e2433001 	sub	r3, r3, #1
30006210:	e1520003 	cmp	r2, r3
30006214:	1a000012 	bne	30006264 <r_malloc+0x2a0>
		num=index<<level;
30006218:	e5dd3007 	ldrb	r3, [sp, #7]
3000621c:	e59d200c 	ldr	r2, [sp, #12]
30006220:	e1a03312 	lsl	r3, r2, r3
30006224:	e58d3010 	str	r3, [sp, #16]
		if(num+(1<<level)>acoral_mem_ctrl->block_num){
30006228:	e5dd3007 	ldrb	r3, [sp, #7]
3000622c:	e3a02001 	mov	r2, #1
30006230:	e1a02312 	lsl	r2, r2, r3
30006234:	e59d3010 	ldr	r3, [sp, #16]
30006238:	e0823003 	add	r3, r2, r3
3000623c:	e1a02003 	mov	r2, r3
30006240:	e59f30d4 	ldr	r3, [pc, #212]	; 3000631c <r_malloc+0x358>
30006244:	e5933000 	ldr	r3, [r3]
30006248:	e59330ec 	ldr	r3, [r3, #236]	; 0xec
3000624c:	e1520003 	cmp	r2, r3
30006250:	9a000019 	bls	300062bc <r_malloc+0x2f8>
			acoral_spin_unlock(&acoral_mem_ctrl->lock);
			HAL_EXIT_CRITICAL();
30006254:	e59d0008 	ldr	r0, [sp, #8]
30006258:	ebffed23 	bl	300016ec <HAL_INTR_RESTORE>
			return NULL; 
3000625c:	e3a03000 	mov	r3, #0
30006260:	ea000029 	b	3000630c <r_malloc+0x348>
		}
	}
	else{
		num=index<<level+1;
30006264:	e5dd3007 	ldrb	r3, [sp, #7]
30006268:	e2833001 	add	r3, r3, #1
3000626c:	e59d200c 	ldr	r2, [sp, #12]
30006270:	e1a03312 	lsl	r3, r2, r3
30006274:	e58d3010 	str	r3, [sp, #16]
		if(acoral_mem_blocks[BLOCK_INDEX(num)].level>=0)
30006278:	e59f30a0 	ldr	r3, [pc, #160]	; 30006320 <r_malloc+0x35c>
3000627c:	e5932000 	ldr	r2, [r3]
30006280:	e59d3010 	ldr	r3, [sp, #16]
30006284:	e1a030c3 	asr	r3, r3, #1
30006288:	e0823003 	add	r3, r2, r3
3000628c:	e5d33000 	ldrb	r3, [r3]
30006290:	e1a03c03 	lsl	r3, r3, #24
30006294:	e1a03c43 	asr	r3, r3, #24
30006298:	e3530000 	cmp	r3, #0
3000629c:	ba000007 	blt	300062c0 <r_malloc+0x2fc>
			num+=(1<<level);
300062a0:	e5dd3007 	ldrb	r3, [sp, #7]
300062a4:	e3a02001 	mov	r2, #1
300062a8:	e1a03312 	lsl	r3, r2, r3
300062ac:	e59d2010 	ldr	r2, [sp, #16]
300062b0:	e0823003 	add	r3, r2, r3
300062b4:	e58d3010 	str	r3, [sp, #16]
300062b8:	ea000000 	b	300062c0 <r_malloc+0x2fc>
	if(level==acoral_mem_ctrl->level-1){
		num=index<<level;
		if(num+(1<<level)>acoral_mem_ctrl->block_num){
			acoral_spin_unlock(&acoral_mem_ctrl->lock);
			HAL_EXIT_CRITICAL();
			return NULL; 
300062bc:	e1a00000 	nop			; (mov r0, r0)
	else{
		num=index<<level+1;
		if(acoral_mem_blocks[BLOCK_INDEX(num)].level>=0)
			num+=(1<<level);
	}
	if((num&0x1)==0)
300062c0:	e59d3010 	ldr	r3, [sp, #16]
300062c4:	e2033001 	and	r3, r3, #1
300062c8:	e3530000 	cmp	r3, #0
300062cc:	1a000006 	bne	300062ec <r_malloc+0x328>
		acoral_mem_blocks[BLOCK_INDEX(num)].level=level;
300062d0:	e59f3048 	ldr	r3, [pc, #72]	; 30006320 <r_malloc+0x35c>
300062d4:	e5932000 	ldr	r2, [r3]
300062d8:	e59d3010 	ldr	r3, [sp, #16]
300062dc:	e1a030c3 	asr	r3, r3, #1
300062e0:	e0823003 	add	r3, r2, r3
300062e4:	e5dd2007 	ldrb	r2, [sp, #7]
300062e8:	e5c32000 	strb	r2, [r3]
#endif
#ifdef CFG_TEST_MEM
	buddy_scan();
#endif
	acoral_spin_unlock(&acoral_mem_ctrl->lock);
	HAL_EXIT_CRITICAL();
300062ec:	e59d0008 	ldr	r0, [sp, #8]
300062f0:	ebffecfd 	bl	300016ec <HAL_INTR_RESTORE>
	return (void *)(acoral_mem_ctrl->start_adr+(num<<BLOCK_SHIFT));
300062f4:	e59f3020 	ldr	r3, [pc, #32]	; 3000631c <r_malloc+0x358>
300062f8:	e5933000 	ldr	r3, [r3]
300062fc:	e59320e4 	ldr	r2, [r3, #228]	; 0xe4
30006300:	e59d3010 	ldr	r3, [sp, #16]
30006304:	e1a03383 	lsl	r3, r3, #7
30006308:	e0823003 	add	r3, r2, r3
}
3000630c:	e1a00003 	mov	r0, r3
30006310:	e28dd01c 	add	sp, sp, #28
30006314:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30006318:	e12fff1e 	bx	lr
3000631c:	3012d6b8 	.word	0x3012d6b8
30006320:	300eabe0 	.word	0x300eabe0

30006324 <buddy_malloc_size>:

acoral_u32 buddy_malloc_size(acoral_u32 size){
30006324:	e24dd018 	sub	sp, sp, #24
30006328:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 resize_size;	
	acoral_u8 level=0;	
3000632c:	e3a03000 	mov	r3, #0
30006330:	e5cd3013 	strb	r3, [sp, #19]
	acoral_u32 num=1;	
30006334:	e3a03001 	mov	r3, #1
30006338:	e58d3014 	str	r3, [sp, #20]
	resize_size=BLOCK_SIZE;
3000633c:	e3a03080 	mov	r3, #128	; 0x80
30006340:	e58d300c 	str	r3, [sp, #12]
	if(acoral_mem_ctrl->state==MEM_NO_ALLOC)
30006344:	e59f3078 	ldr	r3, [pc, #120]	; 300063c4 <buddy_malloc_size+0xa0>
30006348:	e5933000 	ldr	r3, [r3]
3000634c:	e5d330e1 	ldrb	r3, [r3, #225]	; 0xe1
30006350:	e3530000 	cmp	r3, #0
30006354:	1a00000a 	bne	30006384 <buddy_malloc_size+0x60>
		return 0;
30006358:	e3a03000 	mov	r3, #0
3000635c:	ea000015 	b	300063b8 <buddy_malloc_size+0x94>
	while(resize_size<size&&level<acoral_mem_ctrl->level){
		num=num<<1;
30006360:	e59d3014 	ldr	r3, [sp, #20]
30006364:	e1a03083 	lsl	r3, r3, #1
30006368:	e58d3014 	str	r3, [sp, #20]
		level++;
3000636c:	e5dd3013 	ldrb	r3, [sp, #19]
30006370:	e2833001 	add	r3, r3, #1
30006374:	e5cd3013 	strb	r3, [sp, #19]
		resize_size=resize_size<<1;
30006378:	e59d300c 	ldr	r3, [sp, #12]
3000637c:	e1a03083 	lsl	r3, r3, #1
30006380:	e58d300c 	str	r3, [sp, #12]
	acoral_u8 level=0;	
	acoral_u32 num=1;	
	resize_size=BLOCK_SIZE;
	if(acoral_mem_ctrl->state==MEM_NO_ALLOC)
		return 0;
	while(resize_size<size&&level<acoral_mem_ctrl->level){
30006384:	e59d200c 	ldr	r2, [sp, #12]
30006388:	e59d3004 	ldr	r3, [sp, #4]
3000638c:	e1520003 	cmp	r2, r3
30006390:	2a000007 	bcs	300063b4 <buddy_malloc_size+0x90>
30006394:	e5dd2013 	ldrb	r2, [sp, #19]
30006398:	e59f3024 	ldr	r3, [pc, #36]	; 300063c4 <buddy_malloc_size+0xa0>
3000639c:	e5933000 	ldr	r3, [r3]
300063a0:	e5d330e0 	ldrb	r3, [r3, #224]	; 0xe0
300063a4:	e1a03c03 	lsl	r3, r3, #24
300063a8:	e1a03c43 	asr	r3, r3, #24
300063ac:	e1520003 	cmp	r2, r3
300063b0:	baffffea 	blt	30006360 <buddy_malloc_size+0x3c>
		num=num<<1;
		level++;
		resize_size=resize_size<<1;
	}
	return resize_size;
300063b4:	e59d300c 	ldr	r3, [sp, #12]
}
300063b8:	e1a00003 	mov	r0, r3
300063bc:	e28dd018 	add	sp, sp, #24
300063c0:	e12fff1e 	bx	lr
300063c4:	3012d6b8 	.word	0x3012d6b8

300063c8 <buddy_malloc>:

void *buddy_malloc(acoral_u32 size){
300063c8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300063cc:	e24dd01c 	sub	sp, sp, #28
300063d0:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 resize_size;	
	acoral_u8 level=0;	
300063d4:	e3a03000 	mov	r3, #0
300063d8:	e5cd3013 	strb	r3, [sp, #19]
	acoral_u32 num=1;	
300063dc:	e3a03001 	mov	r3, #1
300063e0:	e58d3014 	str	r3, [sp, #20]
	resize_size=BLOCK_SIZE;
300063e4:	e3a03080 	mov	r3, #128	; 0x80
300063e8:	e58d300c 	str	r3, [sp, #12]
	if(acoral_mem_ctrl->state==MEM_NO_ALLOC)
300063ec:	e59f30b0 	ldr	r3, [pc, #176]	; 300064a4 <buddy_malloc+0xdc>
300063f0:	e5933000 	ldr	r3, [r3]
300063f4:	e5d330e1 	ldrb	r3, [r3, #225]	; 0xe1
300063f8:	e3530000 	cmp	r3, #0
300063fc:	1a00000a 	bne	3000642c <buddy_malloc+0x64>
		return NULL;
30006400:	e3a03000 	mov	r3, #0
30006404:	ea000022 	b	30006494 <buddy_malloc+0xcc>
	while(resize_size<size){
		num=num<<1;
30006408:	e59d3014 	ldr	r3, [sp, #20]
3000640c:	e1a03083 	lsl	r3, r3, #1
30006410:	e58d3014 	str	r3, [sp, #20]
		level++;
30006414:	e5dd3013 	ldrb	r3, [sp, #19]
30006418:	e2833001 	add	r3, r3, #1
3000641c:	e5cd3013 	strb	r3, [sp, #19]
		resize_size=resize_size<<1;
30006420:	e59d300c 	ldr	r3, [sp, #12]
30006424:	e1a03083 	lsl	r3, r3, #1
30006428:	e58d300c 	str	r3, [sp, #12]
	acoral_u8 level=0;	
	acoral_u32 num=1;	
	resize_size=BLOCK_SIZE;
	if(acoral_mem_ctrl->state==MEM_NO_ALLOC)
		return NULL;
	while(resize_size<size){
3000642c:	e59d200c 	ldr	r2, [sp, #12]
30006430:	e59d3004 	ldr	r3, [sp, #4]
30006434:	e1520003 	cmp	r2, r3
30006438:	3afffff2 	bcc	30006408 <buddy_malloc+0x40>
		num=num<<1;
		level++;
		resize_size=resize_size<<1;
	}
	if(num>acoral_mem_ctrl->free_num)
3000643c:	e59f3060 	ldr	r3, [pc, #96]	; 300064a4 <buddy_malloc+0xdc>
30006440:	e5933000 	ldr	r3, [r3]
30006444:	e59320f0 	ldr	r2, [r3, #240]	; 0xf0
30006448:	e59d3014 	ldr	r3, [sp, #20]
3000644c:	e1520003 	cmp	r2, r3
30006450:	2a000001 	bcs	3000645c <buddy_malloc+0x94>
		return NULL;
30006454:	e3a03000 	mov	r3, #0
30006458:	ea00000d 	b	30006494 <buddy_malloc+0xcc>
	if(level>=acoral_mem_ctrl->level)
3000645c:	e5dd2013 	ldrb	r2, [sp, #19]
30006460:	e59f303c 	ldr	r3, [pc, #60]	; 300064a4 <buddy_malloc+0xdc>
30006464:	e5933000 	ldr	r3, [r3]
30006468:	e5d330e0 	ldrb	r3, [r3, #224]	; 0xe0
3000646c:	e1a03c03 	lsl	r3, r3, #24
30006470:	e1a03c43 	asr	r3, r3, #24
30006474:	e1520003 	cmp	r2, r3
30006478:	ba000001 	blt	30006484 <buddy_malloc+0xbc>
		return NULL;	
3000647c:	e3a03000 	mov	r3, #0
30006480:	ea000003 	b	30006494 <buddy_malloc+0xcc>
	return r_malloc(level);
30006484:	e5dd3013 	ldrb	r3, [sp, #19]
30006488:	e1a00003 	mov	r0, r3
3000648c:	ebfffecc 	bl	30005fc4 <r_malloc>
30006490:	e1a03000 	mov	r3, r0
}
30006494:	e1a00003 	mov	r0, r3
30006498:	e28dd01c 	add	sp, sp, #28
3000649c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300064a0:	e12fff1e 	bx	lr
300064a4:	3012d6b8 	.word	0x3012d6b8

300064a8 <buddy_free>:

void buddy_free(void *ptr){
300064a8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300064ac:	e24dd02c 	sub	sp, sp, #44	; 0x2c
300064b0:	e58d0004 	str	r0, [sp, #4]
	acoral_32 cur;
	acoral_u32 index;
	acoral_u32 num;
	acoral_u32 max_level;
	acoral_u32 adr;
	adr=(acoral_u32)ptr;
300064b4:	e59d3004 	ldr	r3, [sp, #4]
300064b8:	e58d3024 	str	r3, [sp, #36]	; 0x24
	if(acoral_mem_ctrl->state==MEM_NO_ALLOC)
300064bc:	e59f348c 	ldr	r3, [pc, #1164]	; 30006950 <buddy_free+0x4a8>
300064c0:	e5933000 	ldr	r3, [r3]
300064c4:	e5d330e1 	ldrb	r3, [r3, #225]	; 0xe1
300064c8:	e3530000 	cmp	r3, #0
300064cc:	0a00011b 	beq	30006940 <buddy_free+0x498>
		return;
	if(ptr==NULL||adr<acoral_mem_ctrl->start_adr||adr+BLOCK_SIZE>acoral_mem_ctrl->end_adr){
300064d0:	e59d3004 	ldr	r3, [sp, #4]
300064d4:	e3530000 	cmp	r3, #0
300064d8:	0a00000c 	beq	30006510 <buddy_free+0x68>
300064dc:	e59f346c 	ldr	r3, [pc, #1132]	; 30006950 <buddy_free+0x4a8>
300064e0:	e5933000 	ldr	r3, [r3]
300064e4:	e59320e4 	ldr	r2, [r3, #228]	; 0xe4
300064e8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300064ec:	e1520003 	cmp	r2, r3
300064f0:	8a000006 	bhi	30006510 <buddy_free+0x68>
300064f4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300064f8:	e2832080 	add	r2, r3, #128	; 0x80
300064fc:	e59f344c 	ldr	r3, [pc, #1100]	; 30006950 <buddy_free+0x4a8>
30006500:	e5933000 	ldr	r3, [r3]
30006504:	e59330e8 	ldr	r3, [r3, #232]	; 0xe8
30006508:	e1520003 	cmp	r2, r3
3000650c:	9a000003 	bls	30006520 <buddy_free+0x78>
		acoral_printerr("Invalid Free Address:0x%x\n",ptr);
30006510:	e59f043c 	ldr	r0, [pc, #1084]	; 30006954 <buddy_free+0x4ac>
30006514:	e59d1004 	ldr	r1, [sp, #4]
30006518:	eb001348 	bl	3000b240 <acoral_print>
		return;
3000651c:	ea000108 	b	30006944 <buddy_free+0x49c>
	}
	max_level=acoral_mem_ctrl->level;
30006520:	e59f3428 	ldr	r3, [pc, #1064]	; 30006950 <buddy_free+0x4a8>
30006524:	e5933000 	ldr	r3, [r3]
30006528:	e5d330e0 	ldrb	r3, [r3, #224]	; 0xe0
3000652c:	e1a03c03 	lsl	r3, r3, #24
30006530:	e1a03c43 	asr	r3, r3, #24
30006534:	e58d3020 	str	r3, [sp, #32]
	num=(adr-acoral_mem_ctrl->start_adr)>>BLOCK_SHIFT;
30006538:	e59f3410 	ldr	r3, [pc, #1040]	; 30006950 <buddy_free+0x4a8>
3000653c:	e5933000 	ldr	r3, [r3]
30006540:	e59330e4 	ldr	r3, [r3, #228]	; 0xe4
30006544:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30006548:	e0633002 	rsb	r3, r3, r2
3000654c:	e1a033a3 	lsr	r3, r3, #7
30006550:	e58d301c 	str	r3, [sp, #28]
	/*如果不是block整数倍，肯定是非法地址*/
	if(adr!=acoral_mem_ctrl->start_adr+(num<<BLOCK_SHIFT)){
30006554:	e59f33f4 	ldr	r3, [pc, #1012]	; 30006950 <buddy_free+0x4a8>
30006558:	e5933000 	ldr	r3, [r3]
3000655c:	e59320e4 	ldr	r2, [r3, #228]	; 0xe4
30006560:	e59d301c 	ldr	r3, [sp, #28]
30006564:	e1a03383 	lsl	r3, r3, #7
30006568:	e0822003 	add	r2, r2, r3
3000656c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30006570:	e1520003 	cmp	r2, r3
30006574:	0a000003 	beq	30006588 <buddy_free+0xe0>
		acoral_printerr("Invalid Free Address:0x%x\n",ptr);
30006578:	e59f03d4 	ldr	r0, [pc, #980]	; 30006954 <buddy_free+0x4ac>
3000657c:	e59d1004 	ldr	r1, [sp, #4]
30006580:	eb00132e 	bl	3000b240 <acoral_print>
		return;
30006584:	ea0000ee 	b	30006944 <buddy_free+0x49c>
	}
	HAL_ENTER_CRITICAL();
30006588:	ebffec59 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000658c:	e1a03000 	mov	r3, r0
30006590:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&acoral_mem_ctrl->lock);
	if(num&0x1){
30006594:	e59d301c 	ldr	r3, [sp, #28]
30006598:	e2033001 	and	r3, r3, #1
3000659c:	e20330ff 	and	r3, r3, #255	; 0xff
300065a0:	e3530000 	cmp	r3, #0
300065a4:	0a00003c 	beq	3000669c <buddy_free+0x1f4>
		level=0;
300065a8:	e3a03000 	mov	r3, #0
300065ac:	e5cd3012 	strb	r3, [sp, #18]
		/*下面是地址检查*/
		index=num>>1;
300065b0:	e59d301c 	ldr	r3, [sp, #28]
300065b4:	e1a030a3 	lsr	r3, r3, #1
300065b8:	e58d3018 	str	r3, [sp, #24]
		buddy_level=acoral_mem_blocks[BLOCK_INDEX(num)].level;
300065bc:	e59f3394 	ldr	r3, [pc, #916]	; 30006958 <buddy_free+0x4b0>
300065c0:	e5932000 	ldr	r2, [r3]
300065c4:	e59d301c 	ldr	r3, [sp, #28]
300065c8:	e1a030a3 	lsr	r3, r3, #1
300065cc:	e0823003 	add	r3, r2, r3
300065d0:	e5d33000 	ldrb	r3, [r3]
300065d4:	e5cd3013 	strb	r3, [sp, #19]
		if(buddy_level>0){
300065d8:	e1dd31d3 	ldrsb	r3, [sp, #19]
300065dc:	e3530000 	cmp	r3, #0
300065e0:	da000005 	ble	300065fc <buddy_free+0x154>
			acoral_printerr("Invalid Free Address:0x%x\n",ptr);
300065e4:	e59f0368 	ldr	r0, [pc, #872]	; 30006954 <buddy_free+0x4ac>
300065e8:	e59d1004 	ldr	r1, [sp, #4]
300065ec:	eb001313 	bl	3000b240 <acoral_print>
			acoral_spin_unlock(&acoral_mem_ctrl->lock);
			HAL_EXIT_CRITICAL();
300065f0:	e59d000c 	ldr	r0, [sp, #12]
300065f4:	ebffec3c 	bl	300016ec <HAL_INTR_RESTORE>
			return;
300065f8:	ea0000d1 	b	30006944 <buddy_free+0x49c>
		}
		/*伙伴分配出去，如果对应的位为1,肯定是回收过一次了*/
		if(buddy_level==0&&acoral_get_bit(index,acoral_mem_ctrl->bitmap[level])){
300065fc:	e1dd31d3 	ldrsb	r3, [sp, #19]
30006600:	e3530000 	cmp	r3, #0
30006604:	1a000010 	bne	3000664c <buddy_free+0x1a4>
30006608:	e59f3340 	ldr	r3, [pc, #832]	; 30006950 <buddy_free+0x4a8>
3000660c:	e5933000 	ldr	r3, [r3]
30006610:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006614:	e282200e 	add	r2, r2, #14
30006618:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3000661c:	e59d0018 	ldr	r0, [sp, #24]
30006620:	e1a01003 	mov	r1, r3
30006624:	eb000dc2 	bl	30009d34 <acoral_get_bit>
30006628:	e1a03000 	mov	r3, r0
3000662c:	e3530000 	cmp	r3, #0
30006630:	0a000005 	beq	3000664c <buddy_free+0x1a4>
			acoral_printerr("Address:0x%x have been freed\n",ptr);
30006634:	e59f0320 	ldr	r0, [pc, #800]	; 3000695c <buddy_free+0x4b4>
30006638:	e59d1004 	ldr	r1, [sp, #4]
3000663c:	eb0012ff 	bl	3000b240 <acoral_print>
			acoral_spin_unlock(&acoral_mem_ctrl->lock);
			HAL_EXIT_CRITICAL();
30006640:	e59d000c 	ldr	r0, [sp, #12]
30006644:	ebffec28 	bl	300016ec <HAL_INTR_RESTORE>
			return;
30006648:	ea0000bd 	b	30006944 <buddy_free+0x49c>
		}
		/*伙伴没有分配出去了，如果对应的位为0,肯定是回收过一次了*/
		if(buddy_level<0&&!acoral_get_bit(index,acoral_mem_ctrl->bitmap[level])){
3000664c:	e1dd31d3 	ldrsb	r3, [sp, #19]
30006650:	e3530000 	cmp	r3, #0
30006654:	aa000032 	bge	30006724 <buddy_free+0x27c>
30006658:	e59f32f0 	ldr	r3, [pc, #752]	; 30006950 <buddy_free+0x4a8>
3000665c:	e5933000 	ldr	r3, [r3]
30006660:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006664:	e282200e 	add	r2, r2, #14
30006668:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3000666c:	e59d0018 	ldr	r0, [sp, #24]
30006670:	e1a01003 	mov	r1, r3
30006674:	eb000dae 	bl	30009d34 <acoral_get_bit>
30006678:	e1a03000 	mov	r3, r0
3000667c:	e3530000 	cmp	r3, #0
30006680:	1a000029 	bne	3000672c <buddy_free+0x284>
			acoral_printerr("Address:0x%x have been freed\n",ptr);
30006684:	e59f02d0 	ldr	r0, [pc, #720]	; 3000695c <buddy_free+0x4b4>
30006688:	e59d1004 	ldr	r1, [sp, #4]
3000668c:	eb0012eb 	bl	3000b240 <acoral_print>
			acoral_spin_unlock(&acoral_mem_ctrl->lock);
			HAL_EXIT_CRITICAL();
30006690:	e59d000c 	ldr	r0, [sp, #12]
30006694:	ebffec14 	bl	300016ec <HAL_INTR_RESTORE>
			return;
30006698:	ea0000a9 	b	30006944 <buddy_free+0x49c>
		}
	}else{
		level=acoral_mem_blocks[BLOCK_INDEX(num)].level;
3000669c:	e59f32b4 	ldr	r3, [pc, #692]	; 30006958 <buddy_free+0x4b0>
300066a0:	e5932000 	ldr	r2, [r3]
300066a4:	e59d301c 	ldr	r3, [sp, #28]
300066a8:	e1a030a3 	lsr	r3, r3, #1
300066ac:	e0823003 	add	r3, r2, r3
300066b0:	e5d33000 	ldrb	r3, [r3]
300066b4:	e5cd3012 	strb	r3, [sp, #18]
		/*已经释放*/
		if(level<0){
300066b8:	e1dd31d2 	ldrsb	r3, [sp, #18]
300066bc:	e3530000 	cmp	r3, #0
300066c0:	aa000005 	bge	300066dc <buddy_free+0x234>
			acoral_printerr("Address:0x%x have been freed\n",ptr);
300066c4:	e59f0290 	ldr	r0, [pc, #656]	; 3000695c <buddy_free+0x4b4>
300066c8:	e59d1004 	ldr	r1, [sp, #4]
300066cc:	eb0012db 	bl	3000b240 <acoral_print>
			acoral_spin_unlock(&acoral_mem_ctrl->lock);
			HAL_EXIT_CRITICAL();
300066d0:	e59d000c 	ldr	r0, [sp, #12]
300066d4:	ebffec04 	bl	300016ec <HAL_INTR_RESTORE>
			return;
300066d8:	ea000099 	b	30006944 <buddy_free+0x49c>
		}	
		acoral_mem_ctrl->free_num+=1<<level;
300066dc:	e59f326c 	ldr	r3, [pc, #620]	; 30006950 <buddy_free+0x4a8>
300066e0:	e5933000 	ldr	r3, [r3]
300066e4:	e59f2264 	ldr	r2, [pc, #612]	; 30006950 <buddy_free+0x4a8>
300066e8:	e5922000 	ldr	r2, [r2]
300066ec:	e59210f0 	ldr	r1, [r2, #240]	; 0xf0
300066f0:	e1dd21d2 	ldrsb	r2, [sp, #18]
300066f4:	e3a00001 	mov	r0, #1
300066f8:	e1a02210 	lsl	r2, r0, r2
300066fc:	e0812002 	add	r2, r1, r2
30006700:	e58320f0 	str	r2, [r3, #240]	; 0xf0
		acoral_mem_blocks[BLOCK_INDEX(num)].level=-1;
30006704:	e59f324c 	ldr	r3, [pc, #588]	; 30006958 <buddy_free+0x4b0>
30006708:	e5932000 	ldr	r2, [r3]
3000670c:	e59d301c 	ldr	r3, [sp, #28]
30006710:	e1a030a3 	lsr	r3, r3, #1
30006714:	e0823003 	add	r3, r2, r3
30006718:	e3e02000 	mvn	r2, #0
3000671c:	e5c32000 	strb	r2, [r3]
30006720:	ea000002 	b	30006730 <buddy_free+0x288>
		/*伙伴没有分配出去了，如果对应的位为0,肯定是回收过一次了*/
		if(buddy_level<0&&!acoral_get_bit(index,acoral_mem_ctrl->bitmap[level])){
			acoral_printerr("Address:0x%x have been freed\n",ptr);
			acoral_spin_unlock(&acoral_mem_ctrl->lock);
			HAL_EXIT_CRITICAL();
			return;
30006724:	e1a00000 	nop			; (mov r0, r0)
30006728:	ea000000 	b	30006730 <buddy_free+0x288>
3000672c:	e1a00000 	nop			; (mov r0, r0)
		acoral_mem_blocks[BLOCK_INDEX(num)].level=-1;
	}
#ifdef CFG_TEST
	acoral_print("Free-level:%d,num:%d\n",level,num);
#endif
	if(level==max_level-1){
30006730:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006734:	e59d3020 	ldr	r3, [sp, #32]
30006738:	e2433001 	sub	r3, r3, #1
3000673c:	e1520003 	cmp	r2, r3
30006740:	1a00000e 	bne	30006780 <buddy_free+0x2d8>
		index=num>>level;
30006744:	e1dd31d2 	ldrsb	r3, [sp, #18]
30006748:	e59d201c 	ldr	r2, [sp, #28]
3000674c:	e1a03332 	lsr	r3, r2, r3
30006750:	e58d3018 	str	r3, [sp, #24]
		acoral_set_bit(index,acoral_mem_ctrl->bitmap[level]);
30006754:	e59f31f4 	ldr	r3, [pc, #500]	; 30006950 <buddy_free+0x4a8>
30006758:	e5933000 	ldr	r3, [r3]
3000675c:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006760:	e282200e 	add	r2, r2, #14
30006764:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30006768:	e59d0018 	ldr	r0, [sp, #24]
3000676c:	e1a01003 	mov	r1, r3
30006770:	eb000d3e 	bl	30009c70 <acoral_set_bit>
		HAL_EXIT_CRITICAL();
30006774:	e59d000c 	ldr	r0, [sp, #12]
30006778:	ebffebdb 	bl	300016ec <HAL_INTR_RESTORE>
		acoral_spin_unlock(&acoral_mem_ctrl->lock);
		return;
3000677c:	ea000070 	b	30006944 <buddy_free+0x49c>
	}
	index=num>>1+level;
30006780:	e1dd31d2 	ldrsb	r3, [sp, #18]
30006784:	e2833001 	add	r3, r3, #1
30006788:	e59d201c 	ldr	r2, [sp, #28]
3000678c:	e1a03332 	lsr	r3, r2, r3
30006790:	e58d3018 	str	r3, [sp, #24]
	while(level<max_level){
30006794:	ea000060 	b	3000691c <buddy_free+0x474>
		cur=index/32;
30006798:	e59d3018 	ldr	r3, [sp, #24]
3000679c:	e1a032a3 	lsr	r3, r3, #5
300067a0:	e58d3014 	str	r3, [sp, #20]
		if(!acoral_get_bit(index,acoral_mem_ctrl->bitmap[level])){
300067a4:	e59f31a4 	ldr	r3, [pc, #420]	; 30006950 <buddy_free+0x4a8>
300067a8:	e5933000 	ldr	r3, [r3]
300067ac:	e1dd21d2 	ldrsb	r2, [sp, #18]
300067b0:	e282200e 	add	r2, r2, #14
300067b4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300067b8:	e59d0018 	ldr	r0, [sp, #24]
300067bc:	e1a01003 	mov	r1, r3
300067c0:	eb000d5b 	bl	30009d34 <acoral_get_bit>
300067c4:	e1a03000 	mov	r3, r0
300067c8:	e3530000 	cmp	r3, #0
300067cc:	1a00002a 	bne	3000687c <buddy_free+0x3d4>
			acoral_set_bit(index,acoral_mem_ctrl->bitmap[level]);
300067d0:	e59f3178 	ldr	r3, [pc, #376]	; 30006950 <buddy_free+0x4a8>
300067d4:	e5933000 	ldr	r3, [r3]
300067d8:	e1dd21d2 	ldrsb	r2, [sp, #18]
300067dc:	e282200e 	add	r2, r2, #14
300067e0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300067e4:	e59d0018 	ldr	r0, [sp, #24]
300067e8:	e1a01003 	mov	r1, r3
300067ec:	eb000d1f 	bl	30009c70 <acoral_set_bit>
			if(acoral_mem_ctrl->free_cur[level]<0||cur<acoral_mem_ctrl->free_cur[level]){
300067f0:	e59f3158 	ldr	r3, [pc, #344]	; 30006950 <buddy_free+0x4a8>
300067f4:	e5933000 	ldr	r3, [r3]
300067f8:	e1dd21d2 	ldrsb	r2, [sp, #18]
300067fc:	e282201c 	add	r2, r2, #28
30006800:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30006804:	e3530000 	cmp	r3, #0
30006808:	ba000007 	blt	3000682c <buddy_free+0x384>
3000680c:	e59f313c 	ldr	r3, [pc, #316]	; 30006950 <buddy_free+0x4a8>
30006810:	e5933000 	ldr	r3, [r3]
30006814:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006818:	e282201c 	add	r2, r2, #28
3000681c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30006820:	e59d3014 	ldr	r3, [sp, #20]
30006824:	e1520003 	cmp	r2, r3
30006828:	da000040 	ble	30006930 <buddy_free+0x488>
				acoral_mem_ctrl->free_list[level][cur]=acoral_mem_ctrl->free_cur[level];	
3000682c:	e59f311c 	ldr	r3, [pc, #284]	; 30006950 <buddy_free+0x4a8>
30006830:	e5933000 	ldr	r3, [r3]
30006834:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006838:	e7932102 	ldr	r2, [r3, r2, lsl #2]
3000683c:	e59d3014 	ldr	r3, [sp, #20]
30006840:	e1a03103 	lsl	r3, r3, #2
30006844:	e0823003 	add	r3, r2, r3
30006848:	e59f2100 	ldr	r2, [pc, #256]	; 30006950 <buddy_free+0x4a8>
3000684c:	e5922000 	ldr	r2, [r2]
30006850:	e1dd11d2 	ldrsb	r1, [sp, #18]
30006854:	e281101c 	add	r1, r1, #28
30006858:	e7922101 	ldr	r2, [r2, r1, lsl #2]
3000685c:	e5832000 	str	r2, [r3]
				acoral_mem_ctrl->free_cur[level]=cur;	
30006860:	e59f30e8 	ldr	r3, [pc, #232]	; 30006950 <buddy_free+0x4a8>
30006864:	e5933000 	ldr	r3, [r3]
30006868:	e1dd21d2 	ldrsb	r2, [sp, #18]
3000686c:	e282201c 	add	r2, r2, #28
30006870:	e59d1014 	ldr	r1, [sp, #20]
30006874:	e7831102 	str	r1, [r3, r2, lsl #2]
			}
			break;
30006878:	ea00002d 	b	30006934 <buddy_free+0x48c>
		}
		/*有个伙伴是空闲的，向上级回收*/
		acoral_clear_bit(index,acoral_mem_ctrl->bitmap[level]);
3000687c:	e59f30cc 	ldr	r3, [pc, #204]	; 30006950 <buddy_free+0x4a8>
30006880:	e5933000 	ldr	r3, [r3]
30006884:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006888:	e282200e 	add	r2, r2, #14
3000688c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30006890:	e59d0018 	ldr	r0, [sp, #24]
30006894:	e1a01003 	mov	r1, r3
30006898:	eb000d0c 	bl	30009cd0 <acoral_clear_bit>
		if(cur==acoral_mem_ctrl->free_cur[level])
3000689c:	e59f30ac 	ldr	r3, [pc, #172]	; 30006950 <buddy_free+0x4a8>
300068a0:	e5933000 	ldr	r3, [r3]
300068a4:	e1dd21d2 	ldrsb	r2, [sp, #18]
300068a8:	e282201c 	add	r2, r2, #28
300068ac:	e7932102 	ldr	r2, [r3, r2, lsl #2]
300068b0:	e59d3014 	ldr	r3, [sp, #20]
300068b4:	e1520003 	cmp	r2, r3
300068b8:	1a00000c 	bne	300068f0 <buddy_free+0x448>
			acoral_mem_ctrl->free_cur[level]=acoral_mem_ctrl->free_list[level][cur];	
300068bc:	e59f308c 	ldr	r3, [pc, #140]	; 30006950 <buddy_free+0x4a8>
300068c0:	e5933000 	ldr	r3, [r3]
300068c4:	e1dd21d2 	ldrsb	r2, [sp, #18]
300068c8:	e59f1080 	ldr	r1, [pc, #128]	; 30006950 <buddy_free+0x4a8>
300068cc:	e5911000 	ldr	r1, [r1]
300068d0:	e1dd01d2 	ldrsb	r0, [sp, #18]
300068d4:	e7910100 	ldr	r0, [r1, r0, lsl #2]
300068d8:	e59d1014 	ldr	r1, [sp, #20]
300068dc:	e1a01101 	lsl	r1, r1, #2
300068e0:	e0801001 	add	r1, r0, r1
300068e4:	e5911000 	ldr	r1, [r1]
300068e8:	e282201c 	add	r2, r2, #28
300068ec:	e7831102 	str	r1, [r3, r2, lsl #2]
		level++;
300068f0:	e5dd3012 	ldrb	r3, [sp, #18]
300068f4:	e2833001 	add	r3, r3, #1
300068f8:	e5cd3012 	strb	r3, [sp, #18]
		if(level<max_level-1)
300068fc:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006900:	e59d3020 	ldr	r3, [sp, #32]
30006904:	e2433001 	sub	r3, r3, #1
30006908:	e1520003 	cmp	r2, r3
3000690c:	2a000002 	bcs	3000691c <buddy_free+0x474>
			index=index>>1;
30006910:	e59d3018 	ldr	r3, [sp, #24]
30006914:	e1a030a3 	lsr	r3, r3, #1
30006918:	e58d3018 	str	r3, [sp, #24]
		HAL_EXIT_CRITICAL();
		acoral_spin_unlock(&acoral_mem_ctrl->lock);
		return;
	}
	index=num>>1+level;
	while(level<max_level){
3000691c:	e1dd21d2 	ldrsb	r2, [sp, #18]
30006920:	e59d3020 	ldr	r3, [sp, #32]
30006924:	e1520003 	cmp	r2, r3
30006928:	3affff9a 	bcc	30006798 <buddy_free+0x2f0>
3000692c:	ea000000 	b	30006934 <buddy_free+0x48c>
			acoral_set_bit(index,acoral_mem_ctrl->bitmap[level]);
			if(acoral_mem_ctrl->free_cur[level]<0||cur<acoral_mem_ctrl->free_cur[level]){
				acoral_mem_ctrl->free_list[level][cur]=acoral_mem_ctrl->free_cur[level];	
				acoral_mem_ctrl->free_cur[level]=cur;	
			}
			break;
30006930:	e1a00000 	nop			; (mov r0, r0)
			acoral_mem_ctrl->free_cur[level]=acoral_mem_ctrl->free_list[level][cur];	
		level++;
		if(level<max_level-1)
			index=index>>1;
	}
	HAL_EXIT_CRITICAL();
30006934:	e59d000c 	ldr	r0, [sp, #12]
30006938:	ebffeb6b 	bl	300016ec <HAL_INTR_RESTORE>
3000693c:	ea000000 	b	30006944 <buddy_free+0x49c>
	acoral_u32 num;
	acoral_u32 max_level;
	acoral_u32 adr;
	adr=(acoral_u32)ptr;
	if(acoral_mem_ctrl->state==MEM_NO_ALLOC)
		return;
30006940:	e1a00000 	nop			; (mov r0, r0)
	HAL_EXIT_CRITICAL();
	acoral_spin_unlock(&acoral_mem_ctrl->lock);
#ifdef CFG_TEST_MEM
	buddy_scan();
#endif
}
30006944:	e28dd02c 	add	sp, sp, #44	; 0x2c
30006948:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000694c:	e12fff1e 	bx	lr
30006950:	3012d6b8 	.word	0x3012d6b8
30006954:	300452b0 	.word	0x300452b0
30006958:	300eabe0 	.word	0x300eabe0
3000695c:	300452cc 	.word	0x300452cc

30006960 <r_malloc>:
	acoral_u32 alloc_size;
#endif
	acoral_u8 mem_state;
}mem_ctrl;

static void *r_malloc(acoral_32 size){
30006960:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30006964:	e24dd01c 	sub	sp, sp, #28
30006968:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 * tp;
	acoral_8 * ctp;
	acoral_u32 b_size;
	size=size+4;
3000696c:	e59d3004 	ldr	r3, [sp, #4]
30006970:	e2833004 	add	r3, r3, #4
30006974:	e58d3004 	str	r3, [sp, #4]
	while(acoral_mutex_pend(&mem_ctrl.mutex, 0)!=MUTEX_SUCCED)
30006978:	ea000000 	b	30006980 <r_malloc+0x20>
		acoral_suspend_self();
3000697c:	ebffef98 	bl	300027e4 <acoral_suspend_self>
static void *r_malloc(acoral_32 size){
	acoral_u32 * tp;
	acoral_8 * ctp;
	acoral_u32 b_size;
	size=size+4;
	while(acoral_mutex_pend(&mem_ctrl.mutex, 0)!=MUTEX_SUCCED)
30006980:	e59f0284 	ldr	r0, [pc, #644]	; 30006c0c <r_malloc+0x2ac>
30006984:	e3a01000 	mov	r1, #0
30006988:	ebfff9a2 	bl	30005018 <acoral_mutex_pend>
3000698c:	e1a03000 	mov	r3, r0
30006990:	e3530000 	cmp	r3, #0
30006994:	1afffff8 	bne	3000697c <r_malloc+0x1c>
#ifdef CFG_TEST
	mem_ctrl.alloc_size+=size;
	mem_ctrl.alloc_num++;
	acoral_print("In malloc:%d\n",size);
#endif
	tp=mem_ctrl.freep_p;
30006998:	e59f326c 	ldr	r3, [pc, #620]	; 30006c0c <r_malloc+0x2ac>
3000699c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
300069a0:	e58d300c 	str	r3, [sp, #12]
	ctp=(acoral_8 *)tp;
300069a4:	e59d300c 	ldr	r3, [sp, #12]
300069a8:	e58d3010 	str	r3, [sp, #16]
	while(ctp<mem_ctrl.top_p){
300069ac:	ea00003f 	b	30006ab0 <r_malloc+0x150>
             b_size=BLOCK_SIZE(*tp);
300069b0:	e59d300c 	ldr	r3, [sp, #12]
300069b4:	e5933000 	ldr	r3, [r3]
300069b8:	e1a03423 	lsr	r3, r3, #8
300069bc:	e58d3014 	str	r3, [sp, #20]
	     if(b_size==0){
300069c0:	e59d3014 	ldr	r3, [sp, #20]
300069c4:	e3530000 	cmp	r3, #0
300069c8:	1a000006 	bne	300069e8 <r_malloc+0x88>
			acoral_printerr("Err address is 0x%x,size should not be 0",tp);
300069cc:	e59f023c 	ldr	r0, [pc, #572]	; 30006c10 <r_malloc+0x2b0>
300069d0:	e59d100c 	ldr	r1, [sp, #12]
300069d4:	eb001219 	bl	3000b240 <acoral_print>
			acoral_mutex_post(&mem_ctrl.mutex);
300069d8:	e59f022c 	ldr	r0, [pc, #556]	; 30006c0c <r_malloc+0x2ac>
300069dc:	ebfffa1e 	bl	3000525c <acoral_mutex_post>
			return NULL;
300069e0:	e3a03000 	mov	r3, #0
300069e4:	ea000084 	b	30006bfc <r_malloc+0x29c>
	     }
	     if(BLOCK_USED(*tp)||b_size<size){
300069e8:	e59d300c 	ldr	r3, [sp, #12]
300069ec:	e5933000 	ldr	r3, [r3]
300069f0:	e2033001 	and	r3, r3, #1
300069f4:	e20330ff 	and	r3, r3, #255	; 0xff
300069f8:	e3530000 	cmp	r3, #0
300069fc:	1a000003 	bne	30006a10 <r_malloc+0xb0>
30006a00:	e59d2004 	ldr	r2, [sp, #4]
30006a04:	e59d3014 	ldr	r3, [sp, #20]
30006a08:	e1520003 	cmp	r2, r3
30006a0c:	9a000006 	bls	30006a2c <r_malloc+0xcc>
        	ctp=ctp+b_size;
30006a10:	e59d2010 	ldr	r2, [sp, #16]
30006a14:	e59d3014 	ldr	r3, [sp, #20]
30006a18:	e0823003 	add	r3, r2, r3
30006a1c:	e58d3010 	str	r3, [sp, #16]
		tp=(acoral_u32 *)ctp;
30006a20:	e59d3010 	ldr	r3, [sp, #16]
30006a24:	e58d300c 	str	r3, [sp, #12]
	     if(b_size==0){
			acoral_printerr("Err address is 0x%x,size should not be 0",tp);
			acoral_mutex_post(&mem_ctrl.mutex);
			return NULL;
	     }
	     if(BLOCK_USED(*tp)||b_size<size){
30006a28:	ea000020 	b	30006ab0 <r_malloc+0x150>
        	ctp=ctp+b_size;
		tp=(acoral_u32 *)ctp;
	     }
	     else
	     {
		BLOCK_SET_USED(tp,size);
30006a2c:	e59d3004 	ldr	r3, [sp, #4]
30006a30:	e1a03403 	lsl	r3, r3, #8
30006a34:	e38330cd 	orr	r3, r3, #205	; 0xcd
30006a38:	e1a02003 	mov	r2, r3
30006a3c:	e59d300c 	ldr	r3, [sp, #12]
30006a40:	e5832000 	str	r2, [r3]
		ctp=ctp+size;
30006a44:	e59d3004 	ldr	r3, [sp, #4]
30006a48:	e59d2010 	ldr	r2, [sp, #16]
30006a4c:	e0823003 	add	r3, r2, r3
30006a50:	e58d3010 	str	r3, [sp, #16]
		tp=(acoral_u32 *)ctp;
30006a54:	e59d3010 	ldr	r3, [sp, #16]
30006a58:	e58d300c 	str	r3, [sp, #12]
		if(b_size-size>0)
30006a5c:	e59d2004 	ldr	r2, [sp, #4]
30006a60:	e59d3014 	ldr	r3, [sp, #20]
30006a64:	e1520003 	cmp	r2, r3
30006a68:	0a000006 	beq	30006a88 <r_malloc+0x128>
			BLOCK_SET_FREE(tp,b_size-size);
30006a6c:	e59d3004 	ldr	r3, [sp, #4]
30006a70:	e59d2014 	ldr	r2, [sp, #20]
30006a74:	e0633002 	rsb	r3, r3, r2
30006a78:	e1a03403 	lsl	r3, r3, #8
30006a7c:	e38320cc 	orr	r2, r3, #204	; 0xcc
30006a80:	e59d300c 	ldr	r3, [sp, #12]
30006a84:	e5832000 	str	r2, [r3]
		mem_ctrl.freep_p=tp;
30006a88:	e59f317c 	ldr	r3, [pc, #380]	; 30006c0c <r_malloc+0x2ac>
30006a8c:	e59d200c 	ldr	r2, [sp, #12]
30006a90:	e583202c 	str	r2, [r3, #44]	; 0x2c
#ifdef CFG_TEST_MEM2
		acoral_print("After malloc\n");
		v_mem_scan();
		acoral_print("...................\n");
#endif
		acoral_mutex_post(&mem_ctrl.mutex);
30006a94:	e59f0170 	ldr	r0, [pc, #368]	; 30006c0c <r_malloc+0x2ac>
30006a98:	ebfff9ef 	bl	3000525c <acoral_mutex_post>
	        return (void *)(ctp-size+4);	
30006a9c:	e59d3004 	ldr	r3, [sp, #4]
30006aa0:	e2632004 	rsb	r2, r3, #4
30006aa4:	e59d3010 	ldr	r3, [sp, #16]
30006aa8:	e0823003 	add	r3, r2, r3
30006aac:	ea000052 	b	30006bfc <r_malloc+0x29c>
	mem_ctrl.alloc_num++;
	acoral_print("In malloc:%d\n",size);
#endif
	tp=mem_ctrl.freep_p;
	ctp=(acoral_8 *)tp;
	while(ctp<mem_ctrl.top_p){
30006ab0:	e59f3154 	ldr	r3, [pc, #340]	; 30006c0c <r_malloc+0x2ac>
30006ab4:	e5932024 	ldr	r2, [r3, #36]	; 0x24
30006ab8:	e59d3010 	ldr	r3, [sp, #16]
30006abc:	e1520003 	cmp	r2, r3
30006ac0:	8affffba 	bhi	300069b0 <r_malloc+0x50>
#endif
		acoral_mutex_post(&mem_ctrl.mutex);
	        return (void *)(ctp-size+4);	
	     }
	}
    	ctp=mem_ctrl.down_p;
30006ac4:	e59f3140 	ldr	r3, [pc, #320]	; 30006c0c <r_malloc+0x2ac>
30006ac8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30006acc:	e58d3010 	str	r3, [sp, #16]
	tp=(acoral_u32 *)ctp;
30006ad0:	e59d3010 	ldr	r3, [sp, #16]
30006ad4:	e58d300c 	str	r3, [sp, #12]
	while(tp<mem_ctrl.freep_p){
30006ad8:	ea00003f 	b	30006bdc <r_malloc+0x27c>
	     b_size=BLOCK_SIZE(*tp);
30006adc:	e59d300c 	ldr	r3, [sp, #12]
30006ae0:	e5933000 	ldr	r3, [r3]
30006ae4:	e1a03423 	lsr	r3, r3, #8
30006ae8:	e58d3014 	str	r3, [sp, #20]
	     if(b_size==0){
30006aec:	e59d3014 	ldr	r3, [sp, #20]
30006af0:	e3530000 	cmp	r3, #0
30006af4:	1a000006 	bne	30006b14 <r_malloc+0x1b4>
			acoral_printerr("Err address is 0x%x,size should not be 0",tp);
30006af8:	e59f0110 	ldr	r0, [pc, #272]	; 30006c10 <r_malloc+0x2b0>
30006afc:	e59d100c 	ldr	r1, [sp, #12]
30006b00:	eb0011ce 	bl	3000b240 <acoral_print>
			acoral_mutex_post(&mem_ctrl.mutex);
30006b04:	e59f0100 	ldr	r0, [pc, #256]	; 30006c0c <r_malloc+0x2ac>
30006b08:	ebfff9d3 	bl	3000525c <acoral_mutex_post>
			return NULL;
30006b0c:	e3a03000 	mov	r3, #0
30006b10:	ea000039 	b	30006bfc <r_malloc+0x29c>
	     }
	     if(BLOCK_USED(*tp)||b_size<size){
30006b14:	e59d300c 	ldr	r3, [sp, #12]
30006b18:	e5933000 	ldr	r3, [r3]
30006b1c:	e2033001 	and	r3, r3, #1
30006b20:	e20330ff 	and	r3, r3, #255	; 0xff
30006b24:	e3530000 	cmp	r3, #0
30006b28:	1a000003 	bne	30006b3c <r_malloc+0x1dc>
30006b2c:	e59d2004 	ldr	r2, [sp, #4]
30006b30:	e59d3014 	ldr	r3, [sp, #20]
30006b34:	e1520003 	cmp	r2, r3
30006b38:	9a000006 	bls	30006b58 <r_malloc+0x1f8>
        	ctp=ctp+b_size;
30006b3c:	e59d2010 	ldr	r2, [sp, #16]
30006b40:	e59d3014 	ldr	r3, [sp, #20]
30006b44:	e0823003 	add	r3, r2, r3
30006b48:	e58d3010 	str	r3, [sp, #16]
		tp=(acoral_u32 *)ctp;
30006b4c:	e59d3010 	ldr	r3, [sp, #16]
30006b50:	e58d300c 	str	r3, [sp, #12]
	     if(b_size==0){
			acoral_printerr("Err address is 0x%x,size should not be 0",tp);
			acoral_mutex_post(&mem_ctrl.mutex);
			return NULL;
	     }
	     if(BLOCK_USED(*tp)||b_size<size){
30006b54:	ea000020 	b	30006bdc <r_malloc+0x27c>
        	ctp=ctp+b_size;
		tp=(acoral_u32 *)ctp;
	     }
	     else
	     {
		BLOCK_SET_USED(tp,size);
30006b58:	e59d3004 	ldr	r3, [sp, #4]
30006b5c:	e1a03403 	lsl	r3, r3, #8
30006b60:	e38330cd 	orr	r3, r3, #205	; 0xcd
30006b64:	e1a02003 	mov	r2, r3
30006b68:	e59d300c 	ldr	r3, [sp, #12]
30006b6c:	e5832000 	str	r2, [r3]
		ctp=ctp+size;
30006b70:	e59d3004 	ldr	r3, [sp, #4]
30006b74:	e59d2010 	ldr	r2, [sp, #16]
30006b78:	e0823003 	add	r3, r2, r3
30006b7c:	e58d3010 	str	r3, [sp, #16]
		tp=(acoral_u32 *)ctp;
30006b80:	e59d3010 	ldr	r3, [sp, #16]
30006b84:	e58d300c 	str	r3, [sp, #12]
		if(b_size-size>0)
30006b88:	e59d2004 	ldr	r2, [sp, #4]
30006b8c:	e59d3014 	ldr	r3, [sp, #20]
30006b90:	e1520003 	cmp	r2, r3
30006b94:	0a000006 	beq	30006bb4 <r_malloc+0x254>
			BLOCK_SET_FREE(tp,b_size-size);
30006b98:	e59d3004 	ldr	r3, [sp, #4]
30006b9c:	e59d2014 	ldr	r2, [sp, #20]
30006ba0:	e0633002 	rsb	r3, r3, r2
30006ba4:	e1a03403 	lsl	r3, r3, #8
30006ba8:	e38320cc 	orr	r2, r3, #204	; 0xcc
30006bac:	e59d300c 	ldr	r3, [sp, #12]
30006bb0:	e5832000 	str	r2, [r3]
		mem_ctrl.freep_p=tp;
30006bb4:	e59f3050 	ldr	r3, [pc, #80]	; 30006c0c <r_malloc+0x2ac>
30006bb8:	e59d200c 	ldr	r2, [sp, #12]
30006bbc:	e583202c 	str	r2, [r3, #44]	; 0x2c
#ifdef CFG_TEST_MEM2
		acoral_print("After malloc\n");
		v_mem_scan();
		acoral_print("...................\n");
#endif
		acoral_mutex_post(&mem_ctrl.mutex);
30006bc0:	e59f0044 	ldr	r0, [pc, #68]	; 30006c0c <r_malloc+0x2ac>
30006bc4:	ebfff9a4 	bl	3000525c <acoral_mutex_post>
	        return (void *)(ctp-size+4);	
30006bc8:	e59d3004 	ldr	r3, [sp, #4]
30006bcc:	e2632004 	rsb	r2, r3, #4
30006bd0:	e59d3010 	ldr	r3, [sp, #16]
30006bd4:	e0823003 	add	r3, r2, r3
30006bd8:	ea000007 	b	30006bfc <r_malloc+0x29c>
	        return (void *)(ctp-size+4);	
	     }
	}
    	ctp=mem_ctrl.down_p;
	tp=(acoral_u32 *)ctp;
	while(tp<mem_ctrl.freep_p){
30006bdc:	e59f3028 	ldr	r3, [pc, #40]	; 30006c0c <r_malloc+0x2ac>
30006be0:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
30006be4:	e59d300c 	ldr	r3, [sp, #12]
30006be8:	e1520003 	cmp	r2, r3
30006bec:	8affffba 	bhi	30006adc <r_malloc+0x17c>
	acoral_print("...................\n");
#endif
#ifdef CFG_TEST
	mem_ctrl.alloc_size-=size;
#endif
	acoral_mutex_post(&mem_ctrl.mutex);
30006bf0:	e59f0014 	ldr	r0, [pc, #20]	; 30006c0c <r_malloc+0x2ac>
30006bf4:	ebfff998 	bl	3000525c <acoral_mutex_post>
	return NULL;
30006bf8:	e3a03000 	mov	r3, #0
}
30006bfc:	e1a00003 	mov	r0, r3
30006c00:	e28dd01c 	add	sp, sp, #28
30006c04:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30006c08:	e12fff1e 	bx	lr
30006c0c:	300eaa40 	.word	0x300eaa40
30006c10:	300452ec 	.word	0x300452ec

30006c14 <v_malloc>:

void * v_malloc(acoral_32 size){
30006c14:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30006c18:	e24dd00c 	sub	sp, sp, #12
30006c1c:	e58d0004 	str	r0, [sp, #4]
	if(mem_ctrl.mem_state==0)
30006c20:	e59f303c 	ldr	r3, [pc, #60]	; 30006c64 <v_malloc+0x50>
30006c24:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
30006c28:	e3530000 	cmp	r3, #0
30006c2c:	1a000001 	bne	30006c38 <v_malloc+0x24>
		return NULL;
30006c30:	e3a03000 	mov	r3, #0
30006c34:	ea000006 	b	30006c54 <v_malloc+0x40>
	size=(size+3)&~3;
30006c38:	e59d3004 	ldr	r3, [sp, #4]
30006c3c:	e2833003 	add	r3, r3, #3
30006c40:	e3c33003 	bic	r3, r3, #3
30006c44:	e58d3004 	str	r3, [sp, #4]
    return r_malloc(size);
30006c48:	e59d0004 	ldr	r0, [sp, #4]
30006c4c:	ebffff43 	bl	30006960 <r_malloc>
30006c50:	e1a03000 	mov	r3, r0
}
30006c54:	e1a00003 	mov	r0, r3
30006c58:	e28dd00c 	add	sp, sp, #12
30006c5c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30006c60:	e12fff1e 	bx	lr
30006c64:	300eaa40 	.word	0x300eaa40

30006c68 <v_free>:

void v_free(void * p){
30006c68:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30006c6c:	e24dd024 	sub	sp, sp, #36	; 0x24
30006c70:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 * tp,*prev_tp;
	acoral_8 * ctp;
	acoral_u32 b_size,size;
	if(mem_ctrl.mem_state==0)
30006c74:	e59f327c 	ldr	r3, [pc, #636]	; 30006ef8 <v_free+0x290>
30006c78:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
30006c7c:	e3530000 	cmp	r3, #0
30006c80:	0a000098 	beq	30006ee8 <v_free+0x280>
		return;
	p=(acoral_8 *)p-4;
30006c84:	e59d3004 	ldr	r3, [sp, #4]
30006c88:	e2433004 	sub	r3, r3, #4
30006c8c:	e58d3004 	str	r3, [sp, #4]
	tp=(acoral_u32 *)p;
30006c90:	e59d3004 	ldr	r3, [sp, #4]
30006c94:	e58d300c 	str	r3, [sp, #12]
	while(acoral_mutex_pend(&mem_ctrl.mutex, 0)!=0) //周期性任务
30006c98:	ea000000 	b	30006ca0 <v_free+0x38>
		acoral_suspend_self();
30006c9c:	ebffeed0 	bl	300027e4 <acoral_suspend_self>
	acoral_u32 b_size,size;
	if(mem_ctrl.mem_state==0)
		return;
	p=(acoral_8 *)p-4;
	tp=(acoral_u32 *)p;
	while(acoral_mutex_pend(&mem_ctrl.mutex, 0)!=0) //周期性任务
30006ca0:	e59f0250 	ldr	r0, [pc, #592]	; 30006ef8 <v_free+0x290>
30006ca4:	e3a01000 	mov	r1, #0
30006ca8:	ebfff8da 	bl	30005018 <acoral_mutex_pend>
30006cac:	e1a03000 	mov	r3, r0
30006cb0:	e3530000 	cmp	r3, #0
30006cb4:	1afffff8 	bne	30006c9c <v_free+0x34>
		acoral_suspend_self();
	if(p==NULL||(acoral_8 *)p<mem_ctrl.down_p||(acoral_8 *)p>=mem_ctrl.top_p||!BLOCK_CHECK(*tp)){
30006cb8:	e59d3004 	ldr	r3, [sp, #4]
30006cbc:	e3530000 	cmp	r3, #0
30006cc0:	0a00000e 	beq	30006d00 <v_free+0x98>
30006cc4:	e59f322c 	ldr	r3, [pc, #556]	; 30006ef8 <v_free+0x290>
30006cc8:	e5932028 	ldr	r2, [r3, #40]	; 0x28
30006ccc:	e59d3004 	ldr	r3, [sp, #4]
30006cd0:	e1520003 	cmp	r2, r3
30006cd4:	8a000009 	bhi	30006d00 <v_free+0x98>
30006cd8:	e59f3218 	ldr	r3, [pc, #536]	; 30006ef8 <v_free+0x290>
30006cdc:	e5932024 	ldr	r2, [r3, #36]	; 0x24
30006ce0:	e59d3004 	ldr	r3, [sp, #4]
30006ce4:	e1520003 	cmp	r2, r3
30006ce8:	9a000004 	bls	30006d00 <v_free+0x98>
30006cec:	e59d300c 	ldr	r3, [sp, #12]
30006cf0:	e5933000 	ldr	r3, [r3]
30006cf4:	e20330fe 	and	r3, r3, #254	; 0xfe
30006cf8:	e35300cc 	cmp	r3, #204	; 0xcc
30006cfc:	0a000003 	beq	30006d10 <v_free+0xa8>
		acoral_printerr("Invalide Free address:0x%x\n",tp);
30006d00:	e59f01f4 	ldr	r0, [pc, #500]	; 30006efc <v_free+0x294>
30006d04:	e59d100c 	ldr	r1, [sp, #12]
30006d08:	eb00114c 	bl	3000b240 <acoral_print>
		return;
30006d0c:	ea000076 	b	30006eec <v_free+0x284>
	}
	if(BLOCK_FREE(*tp)){
30006d10:	e59d300c 	ldr	r3, [sp, #12]
30006d14:	e5933000 	ldr	r3, [r3]
30006d18:	e2033001 	and	r3, r3, #1
30006d1c:	e3530000 	cmp	r3, #0
30006d20:	1a000003 	bne	30006d34 <v_free+0xcc>
		acoral_printerr("Address:0x%x have been freed\n",tp);
30006d24:	e59f01d4 	ldr	r0, [pc, #468]	; 30006f00 <v_free+0x298>
30006d28:	e59d100c 	ldr	r1, [sp, #12]
30006d2c:	eb001143 	bl	3000b240 <acoral_print>
		return;
30006d30:	ea00006d 	b	30006eec <v_free+0x284>
	}
	prev_tp=tp;
30006d34:	e59d300c 	ldr	r3, [sp, #12]
30006d38:	e58d3010 	str	r3, [sp, #16]
	ctp=(acoral_8 *)tp;
30006d3c:	e59d300c 	ldr	r3, [sp, #12]
30006d40:	e58d3014 	str	r3, [sp, #20]
    b_size=BLOCK_SIZE(*tp);
30006d44:	e59d300c 	ldr	r3, [sp, #12]
30006d48:	e5933000 	ldr	r3, [r3]
30006d4c:	e1a03423 	lsr	r3, r3, #8
30006d50:	e58d3018 	str	r3, [sp, #24]
#ifdef CFG_TEST_MEM2
	acoral_print("...................\n");
	acoral_print("Before free\n");
	v_mem_scan();
#endif
   	ctp=ctp+b_size;
30006d54:	e59d2014 	ldr	r2, [sp, #20]
30006d58:	e59d3018 	ldr	r3, [sp, #24]
30006d5c:	e0823003 	add	r3, r2, r3
30006d60:	e58d3014 	str	r3, [sp, #20]
	tp=(acoral_u32 *)ctp;
30006d64:	e59d3014 	ldr	r3, [sp, #20]
30006d68:	e58d300c 	str	r3, [sp, #12]
	if(BLOCK_FREE(*tp)){
30006d6c:	e59d300c 	ldr	r3, [sp, #12]
30006d70:	e5933000 	ldr	r3, [r3]
30006d74:	e2033001 	and	r3, r3, #1
30006d78:	e3530000 	cmp	r3, #0
30006d7c:	1a000013 	bne	30006dd0 <v_free+0x168>
		size=BLOCK_SIZE(*tp);
30006d80:	e59d300c 	ldr	r3, [sp, #12]
30006d84:	e5933000 	ldr	r3, [r3]
30006d88:	e1a03423 	lsr	r3, r3, #8
30006d8c:	e58d301c 	str	r3, [sp, #28]
		if(size==0){
30006d90:	e59d301c 	ldr	r3, [sp, #28]
30006d94:	e3530000 	cmp	r3, #0
30006d98:	1a000005 	bne	30006db4 <v_free+0x14c>
			acoral_printerr("Err address is 0x%x,size should not be 0",tp);
30006d9c:	e59f0160 	ldr	r0, [pc, #352]	; 30006f04 <v_free+0x29c>
30006da0:	e59d100c 	ldr	r1, [sp, #12]
30006da4:	eb001125 	bl	3000b240 <acoral_print>
			acoral_mutex_post(&mem_ctrl.mutex);
30006da8:	e59f0148 	ldr	r0, [pc, #328]	; 30006ef8 <v_free+0x290>
30006dac:	ebfff92a 	bl	3000525c <acoral_mutex_post>
			return;
30006db0:	ea00004d 	b	30006eec <v_free+0x284>
		}
		b_size+=size;
30006db4:	e59d2018 	ldr	r2, [sp, #24]
30006db8:	e59d301c 	ldr	r3, [sp, #28]
30006dbc:	e0823003 	add	r3, r2, r3
30006dc0:	e58d3018 	str	r3, [sp, #24]
		BLOCK_CLEAR(tp);
30006dc4:	e59d300c 	ldr	r3, [sp, #12]
30006dc8:	e3a02000 	mov	r2, #0
30006dcc:	e5832000 	str	r2, [r3]
	}
	BLOCK_SET_FREE(prev_tp,b_size);
30006dd0:	e59d3018 	ldr	r3, [sp, #24]
30006dd4:	e1a03403 	lsl	r3, r3, #8
30006dd8:	e38320cc 	orr	r2, r3, #204	; 0xcc
30006ddc:	e59d3010 	ldr	r3, [sp, #16]
30006de0:	e5832000 	str	r2, [r3]
	mem_ctrl.freep_p=prev_tp;
30006de4:	e59f310c 	ldr	r3, [pc, #268]	; 30006ef8 <v_free+0x290>
30006de8:	e59d2010 	ldr	r2, [sp, #16]
30006dec:	e583202c 	str	r2, [r3, #44]	; 0x2c
	if(p==mem_ctrl.down_p){
30006df0:	e59f3100 	ldr	r3, [pc, #256]	; 30006ef8 <v_free+0x290>
30006df4:	e5932028 	ldr	r2, [r3, #40]	; 0x28
30006df8:	e59d3004 	ldr	r3, [sp, #4]
30006dfc:	e1520003 	cmp	r2, r3
30006e00:	1a000002 	bne	30006e10 <v_free+0x1a8>
#ifdef CFG_TEST_MEM2
		acoral_print("After free\n");
		v_mem_scan();
		acoral_print("...................\n");
#endif
		acoral_mutex_post(&mem_ctrl.mutex);
30006e04:	e59f00ec 	ldr	r0, [pc, #236]	; 30006ef8 <v_free+0x290>
30006e08:	ebfff913 	bl	3000525c <acoral_mutex_post>
		return;
30006e0c:	ea000036 	b	30006eec <v_free+0x284>
	}
	ctp=mem_ctrl.down_p;
30006e10:	e59f30e0 	ldr	r3, [pc, #224]	; 30006ef8 <v_free+0x290>
30006e14:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30006e18:	e58d3014 	str	r3, [sp, #20]
	tp=(acoral_u32 *)ctp;
30006e1c:	e59d3014 	ldr	r3, [sp, #20]
30006e20:	e58d300c 	str	r3, [sp, #12]
	while(ctp<(acoral_8 *)p){
30006e24:	ea000014 	b	30006e7c <v_free+0x214>
	     size=BLOCK_SIZE(*tp);
30006e28:	e59d300c 	ldr	r3, [sp, #12]
30006e2c:	e5933000 	ldr	r3, [r3]
30006e30:	e1a03423 	lsr	r3, r3, #8
30006e34:	e58d301c 	str	r3, [sp, #28]
	     if(size==0){
30006e38:	e59d301c 	ldr	r3, [sp, #28]
30006e3c:	e3530000 	cmp	r3, #0
30006e40:	1a000005 	bne	30006e5c <v_free+0x1f4>
			acoral_printerr("err address is 0x%x,size should not be 0",tp);
30006e44:	e59f00bc 	ldr	r0, [pc, #188]	; 30006f08 <v_free+0x2a0>
30006e48:	e59d100c 	ldr	r1, [sp, #12]
30006e4c:	eb0010fb 	bl	3000b240 <acoral_print>
			acoral_mutex_post(&mem_ctrl.mutex);
30006e50:	e59f00a0 	ldr	r0, [pc, #160]	; 30006ef8 <v_free+0x290>
30006e54:	ebfff900 	bl	3000525c <acoral_mutex_post>
			return;
30006e58:	ea000023 	b	30006eec <v_free+0x284>
             }
	     ctp=ctp+size;
30006e5c:	e59d2014 	ldr	r2, [sp, #20]
30006e60:	e59d301c 	ldr	r3, [sp, #28]
30006e64:	e0823003 	add	r3, r2, r3
30006e68:	e58d3014 	str	r3, [sp, #20]
	     prev_tp=tp;
30006e6c:	e59d300c 	ldr	r3, [sp, #12]
30006e70:	e58d3010 	str	r3, [sp, #16]
	     tp=(acoral_u32 *)ctp;
30006e74:	e59d3014 	ldr	r3, [sp, #20]
30006e78:	e58d300c 	str	r3, [sp, #12]
		acoral_mutex_post(&mem_ctrl.mutex);
		return;
	}
	ctp=mem_ctrl.down_p;
	tp=(acoral_u32 *)ctp;
	while(ctp<(acoral_8 *)p){
30006e7c:	e59d3004 	ldr	r3, [sp, #4]
30006e80:	e59d2014 	ldr	r2, [sp, #20]
30006e84:	e1520003 	cmp	r2, r3
30006e88:	3affffe6 	bcc	30006e28 <v_free+0x1c0>
             }
	     ctp=ctp+size;
	     prev_tp=tp;
	     tp=(acoral_u32 *)ctp;
	}
	if(BLOCK_FREE(*prev_tp)){
30006e8c:	e59d3010 	ldr	r3, [sp, #16]
30006e90:	e5933000 	ldr	r3, [r3]
30006e94:	e2033001 	and	r3, r3, #1
30006e98:	e3530000 	cmp	r3, #0
30006e9c:	1a00000e 	bne	30006edc <v_free+0x274>
		tp=(acoral_u32*)p;
30006ea0:	e59d3004 	ldr	r3, [sp, #4]
30006ea4:	e58d300c 	str	r3, [sp, #12]
		BLOCK_CLEAR(tp);
30006ea8:	e59d300c 	ldr	r3, [sp, #12]
30006eac:	e3a02000 	mov	r2, #0
30006eb0:	e5832000 	str	r2, [r3]
		BLOCK_SET_FREE(prev_tp,b_size+size);
30006eb4:	e59d2018 	ldr	r2, [sp, #24]
30006eb8:	e59d301c 	ldr	r3, [sp, #28]
30006ebc:	e0823003 	add	r3, r2, r3
30006ec0:	e1a03403 	lsl	r3, r3, #8
30006ec4:	e38320cc 	orr	r2, r3, #204	; 0xcc
30006ec8:	e59d3010 	ldr	r3, [sp, #16]
30006ecc:	e5832000 	str	r2, [r3]
		mem_ctrl.freep_p=prev_tp;
30006ed0:	e59f3020 	ldr	r3, [pc, #32]	; 30006ef8 <v_free+0x290>
30006ed4:	e59d2010 	ldr	r2, [sp, #16]
30006ed8:	e583202c 	str	r2, [r3, #44]	; 0x2c
#ifdef CFG_TEST_MEM2
	acoral_print("After free\n");
	v_mem_scan();
	acoral_print("...................\n");
#endif
	acoral_mutex_post(&mem_ctrl.mutex);
30006edc:	e59f0014 	ldr	r0, [pc, #20]	; 30006ef8 <v_free+0x290>
30006ee0:	ebfff8dd 	bl	3000525c <acoral_mutex_post>
30006ee4:	ea000000 	b	30006eec <v_free+0x284>
void v_free(void * p){
	acoral_u32 * tp,*prev_tp;
	acoral_8 * ctp;
	acoral_u32 b_size,size;
	if(mem_ctrl.mem_state==0)
		return;
30006ee8:	e1a00000 	nop			; (mov r0, r0)
	acoral_print("After free\n");
	v_mem_scan();
	acoral_print("...................\n");
#endif
	acoral_mutex_post(&mem_ctrl.mutex);
}
30006eec:	e28dd024 	add	sp, sp, #36	; 0x24
30006ef0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30006ef4:	e12fff1e 	bx	lr
30006ef8:	300eaa40 	.word	0x300eaa40
30006efc:	30045318 	.word	0x30045318
30006f00:	30045334 	.word	0x30045334
30006f04:	300452ec 	.word	0x300452ec
30006f08:	30045354 	.word	0x30045354

30006f0c <v_mem_init>:

void v_mem_init(){
30006f0c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30006f10:	e24dd00c 	sub	sp, sp, #12
	acoral_size size;
	size=acoral_malloc_size(MEM_SIZE);
30006f14:	e3a00afa 	mov	r0, #1024000	; 0xfa000
30006f18:	ebfffd01 	bl	30006324 <buddy_malloc_size>
30006f1c:	e1a03000 	mov	r3, r0
30006f20:	e58d3004 	str	r3, [sp, #4]
	mem_ctrl.down_p=(acoral_8 *)acoral_malloc(size);
30006f24:	e59d0004 	ldr	r0, [sp, #4]
30006f28:	ebfffd26 	bl	300063c8 <buddy_malloc>
30006f2c:	e1a03000 	mov	r3, r0
30006f30:	e1a02003 	mov	r2, r3
30006f34:	e59f3088 	ldr	r3, [pc, #136]	; 30006fc4 <v_mem_init+0xb8>
30006f38:	e5832028 	str	r2, [r3, #40]	; 0x28
	if(mem_ctrl.down_p==NULL){
30006f3c:	e59f3080 	ldr	r3, [pc, #128]	; 30006fc4 <v_mem_init+0xb8>
30006f40:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30006f44:	e3530000 	cmp	r3, #0
30006f48:	1a000003 	bne	30006f5c <v_mem_init+0x50>
		mem_ctrl.mem_state=0;
30006f4c:	e59f3070 	ldr	r3, [pc, #112]	; 30006fc4 <v_mem_init+0xb8>
30006f50:	e3a02000 	mov	r2, #0
30006f54:	e5c32030 	strb	r2, [r3, #48]	; 0x30
		return;
30006f58:	ea000016 	b	30006fb8 <v_mem_init+0xac>
	}
	else{
		mem_ctrl.mem_state=1;
30006f5c:	e59f3060 	ldr	r3, [pc, #96]	; 30006fc4 <v_mem_init+0xb8>
30006f60:	e3a02001 	mov	r2, #1
30006f64:	e5c32030 	strb	r2, [r3, #48]	; 0x30
	}
	acoral_mutex_init(&mem_ctrl.mutex,0);
30006f68:	e59f0054 	ldr	r0, [pc, #84]	; 30006fc4 <v_mem_init+0xb8>
30006f6c:	e3a01000 	mov	r1, #0
30006f70:	ebfff791 	bl	30004dbc <acoral_mutex_init>
	mem_ctrl.top_p=mem_ctrl.down_p+size;
30006f74:	e59f3048 	ldr	r3, [pc, #72]	; 30006fc4 <v_mem_init+0xb8>
30006f78:	e5932028 	ldr	r2, [r3, #40]	; 0x28
30006f7c:	e59d3004 	ldr	r3, [sp, #4]
30006f80:	e0822003 	add	r2, r2, r3
30006f84:	e59f3038 	ldr	r3, [pc, #56]	; 30006fc4 <v_mem_init+0xb8>
30006f88:	e5832024 	str	r2, [r3, #36]	; 0x24
	mem_ctrl.freep_p=(acoral_u32 *)mem_ctrl.down_p;
30006f8c:	e59f3030 	ldr	r3, [pc, #48]	; 30006fc4 <v_mem_init+0xb8>
30006f90:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30006f94:	e1a02003 	mov	r2, r3
30006f98:	e59f3024 	ldr	r3, [pc, #36]	; 30006fc4 <v_mem_init+0xb8>
30006f9c:	e583202c 	str	r2, [r3, #44]	; 0x2c
	BLOCK_SET_FREE(mem_ctrl.freep_p,size);
30006fa0:	e59f301c 	ldr	r3, [pc, #28]	; 30006fc4 <v_mem_init+0xb8>
30006fa4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
30006fa8:	e59d2004 	ldr	r2, [sp, #4]
30006fac:	e1a02402 	lsl	r2, r2, #8
30006fb0:	e38220cc 	orr	r2, r2, #204	; 0xcc
30006fb4:	e5832000 	str	r2, [r3]
#ifdef CFG_TEST
	mem_ctrl.alloc_size=0;
	mem_ctrl.alloc_num=0;
	mem_ctrl.free_num=0;
#endif
}
30006fb8:	e28dd00c 	add	sp, sp, #12
30006fbc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30006fc0:	e12fff1e 	bx	lr
30006fc4:	300eaa40 	.word	0x300eaa40

30006fc8 <v_mem_scan>:

void v_mem_scan(void){
30006fc8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30006fcc:	e24dd014 	sub	sp, sp, #20
        acoral_8 * ctp;
	acoral_u32 * tp;
	acoral_u32 size;
	if(mem_ctrl.mem_state==0){
30006fd0:	e59f30c0 	ldr	r3, [pc, #192]	; 30007098 <v_mem_scan+0xd0>
30006fd4:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
30006fd8:	e3530000 	cmp	r3, #0
30006fdc:	1a000002 	bne	30006fec <v_mem_scan+0x24>
		acoral_print("Mem Init Err ,so no mem space to malloc\r\n");
30006fe0:	e59f00b4 	ldr	r0, [pc, #180]	; 3000709c <v_mem_scan+0xd4>
30006fe4:	eb001095 	bl	3000b240 <acoral_print>
		return;
30006fe8:	ea000027 	b	3000708c <v_mem_scan+0xc4>
	}
	ctp=mem_ctrl.down_p;
30006fec:	e59f30a4 	ldr	r3, [pc, #164]	; 30007098 <v_mem_scan+0xd0>
30006ff0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30006ff4:	e58d3004 	str	r3, [sp, #4]
	do{
		tp=(acoral_u32 *)ctp;
30006ff8:	e59d3004 	ldr	r3, [sp, #4]
30006ffc:	e58d3008 	str	r3, [sp, #8]
		size=BLOCK_SIZE(*tp);
30007000:	e59d3008 	ldr	r3, [sp, #8]
30007004:	e5933000 	ldr	r3, [r3]
30007008:	e1a03423 	lsr	r3, r3, #8
3000700c:	e58d300c 	str	r3, [sp, #12]
		if(size==0){
30007010:	e59d300c 	ldr	r3, [sp, #12]
30007014:	e3530000 	cmp	r3, #0
30007018:	1a000003 	bne	3000702c <v_mem_scan+0x64>
			acoral_print("Err address is 0x%x,size should not be 0\r\n",tp);
3000701c:	e59f007c 	ldr	r0, [pc, #124]	; 300070a0 <v_mem_scan+0xd8>
30007020:	e59d1008 	ldr	r1, [sp, #8]
30007024:	eb001085 	bl	3000b240 <acoral_print>
			break;
30007028:	ea000017 	b	3000708c <v_mem_scan+0xc4>
		}
		if(BLOCK_USED(*tp)){
3000702c:	e59d3008 	ldr	r3, [sp, #8]
30007030:	e5933000 	ldr	r3, [r3]
30007034:	e2033001 	and	r3, r3, #1
30007038:	e20330ff 	and	r3, r3, #255	; 0xff
3000703c:	e3530000 	cmp	r3, #0
30007040:	0a000004 	beq	30007058 <v_mem_scan+0x90>
			acoral_print("The address is 0x%x,the block is used and it's size is %d\r\n",tp,size);
30007044:	e59f0058 	ldr	r0, [pc, #88]	; 300070a4 <v_mem_scan+0xdc>
30007048:	e59d1008 	ldr	r1, [sp, #8]
3000704c:	e59d200c 	ldr	r2, [sp, #12]
30007050:	eb00107a 	bl	3000b240 <acoral_print>
30007054:	ea000003 	b	30007068 <v_mem_scan+0xa0>
		}
		else{
			
			acoral_print("The address is 0x%x,the block is unused and it's size is %d\r\n",tp,size);
30007058:	e59f0048 	ldr	r0, [pc, #72]	; 300070a8 <v_mem_scan+0xe0>
3000705c:	e59d1008 	ldr	r1, [sp, #8]
30007060:	e59d200c 	ldr	r2, [sp, #12]
30007064:	eb001075 	bl	3000b240 <acoral_print>
		}
		ctp=ctp+size;
30007068:	e59d2004 	ldr	r2, [sp, #4]
3000706c:	e59d300c 	ldr	r3, [sp, #12]
30007070:	e0823003 	add	r3, r2, r3
30007074:	e58d3004 	str	r3, [sp, #4]
	}while(ctp<mem_ctrl.top_p);
30007078:	e59f3018 	ldr	r3, [pc, #24]	; 30007098 <v_mem_scan+0xd0>
3000707c:	e5932024 	ldr	r2, [r3, #36]	; 0x24
30007080:	e59d3004 	ldr	r3, [sp, #4]
30007084:	e1520003 	cmp	r2, r3
30007088:	8affffda 	bhi	30006ff8 <v_mem_scan+0x30>
#ifdef CFG_TEST
	acoral_print("Alloc Size:%d  Free_num:%d  alloc_num:%d\r\n",mem_ctrl.alloc_size,mem_ctrl.free_num,mem_ctrl.alloc_num);
#endif
}
3000708c:	e28dd014 	add	sp, sp, #20
30007090:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007094:	e12fff1e 	bx	lr
30007098:	300eaa40 	.word	0x300eaa40
3000709c:	30045380 	.word	0x30045380
300070a0:	300453ac 	.word	0x300453ac
300070a4:	300453d8 	.word	0x300453d8
300070a8:	30045414 	.word	0x30045414

300070ac <acoral_mbox_create>:
/*====================================
 *     create a mailbox
 *       创建一个邮箱
 *====================================*/
acoral_evt_t *acoral_mbox_create()
{
300070ac:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300070b0:	e24dd00c 	sub	sp, sp, #12
  	acoral_evt_t * event;
	
	event=acoral_alloc_evt();
300070b4:	ebfff6cc 	bl	30004bec <acoral_alloc_evt>
300070b8:	e1a03000 	mov	r3, r0
300070bc:	e58d3004 	str	r3, [sp, #4]
	if (NULL == event)
300070c0:	e59d3004 	ldr	r3, [sp, #4]
300070c4:	e3530000 	cmp	r3, #0
300070c8:	1a000001 	bne	300070d4 <acoral_mbox_create+0x28>
		return NULL;
300070cc:	e3a03000 	mov	r3, #0
300070d0:	ea00000b 	b	30007104 <acoral_mbox_create+0x58>

	event->type  = ACORAL_EVENT_MBOX;
300070d4:	e59d3004 	ldr	r3, [sp, #4]
300070d8:	e3a02003 	mov	r2, #3
300070dc:	e5c32004 	strb	r2, [r3, #4]
	event->count = 0x00000000;
300070e0:	e59d3004 	ldr	r3, [sp, #4]
300070e4:	e3a02000 	mov	r2, #0
300070e8:	e583200c 	str	r2, [r3, #12]
	event->data  = NULL;
300070ec:	e59d3004 	ldr	r3, [sp, #4]
300070f0:	e3a02000 	mov	r2, #0
300070f4:	e5832020 	str	r2, [r3, #32]
	acoral_evt_init(event);
300070f8:	e59d0004 	ldr	r0, [sp, #4]
300070fc:	ebfff6c2 	bl	30004c0c <acoral_evt_init>
	return event;
30007100:	e59d3004 	ldr	r3, [sp, #4]
}
30007104:	e1a00003 	mov	r0, r3
30007108:	e28dd00c 	add	sp, sp, #12
3000710c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007110:	e12fff1e 	bx	lr

30007114 <acoral_mbox_del>:
/*=====================================
 *   delete a mailbox
 *     删除一个邮箱
 *=====================================*/
acoral_u32 acoral_mbox_del(acoral_evt_t* event)
{
30007114:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007118:	e24dd00c 	sub	sp, sp, #12
3000711c:	e58d0004 	str	r0, [sp, #4]
	if (acoral_intr_nesting > 0)
30007120:	ebffe98e 	bl	30001760 <hal_get_intr_nesting_comm>
30007124:	e1a03000 	mov	r3, r0
30007128:	e3530000 	cmp	r3, #0
3000712c:	da000001 	ble	30007138 <acoral_mbox_del+0x24>
		return MBOX_ERR_INTR;
30007130:	e3a03006 	mov	r3, #6
30007134:	ea00000e 	b	30007174 <acoral_mbox_del+0x60>
	
	if (NULL == event)
30007138:	e59d3004 	ldr	r3, [sp, #4]
3000713c:	e3530000 	cmp	r3, #0
30007140:	1a000001 	bne	3000714c <acoral_mbox_del+0x38>
		return MBOX_ERR_NULL;
30007144:	e3a03002 	mov	r3, #2
30007148:	ea000009 	b	30007174 <acoral_mbox_del+0x60>

	if(event->type != ACORAL_EVENT_MBOX)
3000714c:	e59d3004 	ldr	r3, [sp, #4]
30007150:	e5d33004 	ldrb	r3, [r3, #4]
30007154:	e3530003 	cmp	r3, #3
30007158:	0a000001 	beq	30007164 <acoral_mbox_del+0x50>
		return MBOX_ERR_TYPE;
3000715c:	e3a03004 	mov	r3, #4
30007160:	ea000003 	b	30007174 <acoral_mbox_del+0x60>

	acoral_release_thread((acoral_res_t *)event); 
30007164:	e59d3004 	ldr	r3, [sp, #4]
30007168:	e1a00003 	mov	r0, r3
3000716c:	ebffed72 	bl	3000273c <acoral_release_thread>
	return MBOX_SUCCED;
30007170:	e3a03000 	mov	r3, #0
}
30007174:	e1a00003 	mov	r0, r3
30007178:	e28dd00c 	add	sp, sp, #12
3000717c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007180:	e12fff1e 	bx	lr

30007184 <acoral_mbox_send>:
/*======================================
 *     send a mail to mailbox
 *       发送邮件至邮箱
 *======================================*/
acoral_u32 acoral_mbox_send(acoral_evt_t * event, void *msg)
{
30007184:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007188:	e24dd014 	sub	sp, sp, #20
3000718c:	e58d0004 	str	r0, [sp, #4]
30007190:	e58d1000 	str	r1, [sp]
	acoral_thread_t     *thread;

	/*if (acoral_intr_nesting > 0)
		return MBOX_ERR_INTR;
	*/
	if (NULL == event)
30007194:	e59d3004 	ldr	r3, [sp, #4]
30007198:	e3530000 	cmp	r3, #0
3000719c:	1a000001 	bne	300071a8 <acoral_mbox_send+0x24>
		return MBOX_ERR_NULL;
300071a0:	e3a03002 	mov	r3, #2
300071a4:	ea000028 	b	3000724c <acoral_mbox_send+0xc8>

	if(event->type != ACORAL_EVENT_MBOX)
300071a8:	e59d3004 	ldr	r3, [sp, #4]
300071ac:	e5d33004 	ldrb	r3, [r3, #4]
300071b0:	e3530003 	cmp	r3, #3
300071b4:	0a000001 	beq	300071c0 <acoral_mbox_send+0x3c>
		return MBOX_ERR_TYPE;
300071b8:	e3a03004 	mov	r3, #4
300071bc:	ea000022 	b	3000724c <acoral_mbox_send+0xc8>

	HAL_ENTER_CRITICAL();
300071c0:	ebffe94b 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300071c4:	e1a03000 	mov	r3, r0
300071c8:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&event->spin_lock);
	if(event->data != NULL)
300071cc:	e59d3004 	ldr	r3, [sp, #4]
300071d0:	e5933020 	ldr	r3, [r3, #32]
300071d4:	e3530000 	cmp	r3, #0
300071d8:	0a000003 	beq	300071ec <acoral_mbox_send+0x68>
	{
		acoral_spin_unlock(&event->spin_lock);
		HAL_EXIT_CRITICAL();
300071dc:	e59d0008 	ldr	r0, [sp, #8]
300071e0:	ebffe941 	bl	300016ec <HAL_INTR_RESTORE>
		return MBOX_ERR_MES_EXIST;
300071e4:	e3a03005 	mov	r3, #5
300071e8:	ea000017 	b	3000724c <acoral_mbox_send+0xc8>
	}
	event->data = msg;
300071ec:	e59d3004 	ldr	r3, [sp, #4]
300071f0:	e59d2000 	ldr	r2, [sp]
300071f4:	e5832020 	str	r2, [r3, #32]
	thread =acoral_evt_high_thread(event);
300071f8:	e59d0004 	ldr	r0, [sp, #4]
300071fc:	ebfff69c 	bl	30004c74 <acoral_evt_high_thread>
30007200:	e1a03000 	mov	r3, r0
30007204:	e58d300c 	str	r3, [sp, #12]
	/* 释放等待进程*/
	if (thread==NULL)
30007208:	e59d300c 	ldr	r3, [sp, #12]
3000720c:	e3530000 	cmp	r3, #0
30007210:	1a000003 	bne	30007224 <acoral_mbox_send+0xa0>
	{
		/* 没有等待队列*/
		acoral_spin_unlock(&event->spin_lock);
		HAL_EXIT_CRITICAL();
30007214:	e59d0008 	ldr	r0, [sp, #8]
30007218:	ebffe933 	bl	300016ec <HAL_INTR_RESTORE>
		return  MBOX_SUCCED;
3000721c:	e3a03000 	mov	r3, #0
30007220:	ea000009 	b	3000724c <acoral_mbox_send+0xc8>
	}
	/*释放等待任务*/
	timeout_queue_del(thread);
30007224:	e59d000c 	ldr	r0, [sp, #12]
30007228:	ebfff5bc 	bl	30004920 <timeout_queue_del>
	acoral_evt_queue_del(thread);
3000722c:	e59d000c 	ldr	r0, [sp, #12]
30007230:	ebfff6d4 	bl	30004d88 <acoral_evt_queue_del>
	acoral_rdy_thread(thread);
30007234:	e59d000c 	ldr	r0, [sp, #12]
30007238:	ebffee52 	bl	30002b88 <acoral_rdy_thread>
	acoral_spin_unlock(&event->spin_lock);
	HAL_EXIT_CRITICAL();
3000723c:	e59d0008 	ldr	r0, [sp, #8]
30007240:	ebffe929 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sched();
30007244:	ebffec75 	bl	30002420 <acoral_sched>
	return MBOX_SUCCED;
30007248:	e3a03000 	mov	r3, #0
}
3000724c:	e1a00003 	mov	r0, r3
30007250:	e28dd014 	add	sp, sp, #20
30007254:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007258:	e12fff1e 	bx	lr

3000725c <acoral_mbox_recv>:
/*======================================
 *    receive  a mail to mailbox
 *       接收邮件从邮箱
 *======================================*/
void* acoral_mbox_recv(acoral_evt_t * event, acoral_time timeout)
{
3000725c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007260:	e24dd01c 	sub	sp, sp, #28
30007264:	e58d0004 	str	r0, [sp, #4]
30007268:	e58d1000 	str	r1, [sp]
	void            *msg;
	acoral_sr         cpu_sr;
	acoral_thread_t  *cur;
	
	if (acoral_intr_nesting > 0)
3000726c:	ebffe93b 	bl	30001760 <hal_get_intr_nesting_comm>
30007270:	e1a03000 	mov	r3, r0
30007274:	e3530000 	cmp	r3, #0
30007278:	da000001 	ble	30007284 <acoral_mbox_recv+0x28>
		return NULL;
3000727c:	e3a03000 	mov	r3, #0
30007280:	ea00004d 	b	300073bc <acoral_mbox_recv+0x160>

	if(event->type!=ACORAL_EVENT_MBOX)
30007284:	e59d3004 	ldr	r3, [sp, #4]
30007288:	e5d33004 	ldrb	r3, [r3, #4]
3000728c:	e3530003 	cmp	r3, #3
30007290:	0a000001 	beq	3000729c <acoral_mbox_recv+0x40>
		return NULL;
30007294:	e3a03000 	mov	r3, #0
30007298:	ea000047 	b	300073bc <acoral_mbox_recv+0x160>
	
	HAL_ENTER_CRITICAL();
3000729c:	ebffe914 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300072a0:	e1a03000 	mov	r3, r0
300072a4:	e58d3010 	str	r3, [sp, #16]
	acoral_spin_lock(&event->spin_lock);
	if( event->data == NULL)
300072a8:	e59d3004 	ldr	r3, [sp, #4]
300072ac:	e5933020 	ldr	r3, [r3, #32]
300072b0:	e3530000 	cmp	r3, #0
300072b4:	1a000037 	bne	30007398 <acoral_mbox_recv+0x13c>
	{
		cur = acoral_cur_thread;
300072b8:	e59f310c 	ldr	r3, [pc, #268]	; 300073cc <acoral_mbox_recv+0x170>
300072bc:	e5933000 	ldr	r3, [r3]
300072c0:	e58d3014 	str	r3, [sp, #20]
		if (timeout > 0)
300072c4:	e59d3000 	ldr	r3, [sp]
300072c8:	e3530000 	cmp	r3, #0
300072cc:	0a00000f 	beq	30007310 <acoral_mbox_recv+0xb4>
		{
			cur->delay = TIME_TO_TICKS(timeout);
300072d0:	e59d2000 	ldr	r2, [sp]
300072d4:	e1a03002 	mov	r3, r2
300072d8:	e1a03103 	lsl	r3, r3, #2
300072dc:	e0833002 	add	r3, r3, r2
300072e0:	e1a02103 	lsl	r2, r3, #2
300072e4:	e0833002 	add	r3, r3, r2
300072e8:	e1a03103 	lsl	r3, r3, #2
300072ec:	e1a02003 	mov	r2, r3
300072f0:	e59f30d8 	ldr	r3, [pc, #216]	; 300073d0 <acoral_mbox_recv+0x174>
300072f4:	e0831392 	umull	r1, r3, r2, r3
300072f8:	e1a03323 	lsr	r3, r3, #6
300072fc:	e1a02003 	mov	r2, r3
30007300:	e59d3014 	ldr	r3, [sp, #20]
30007304:	e5832040 	str	r2, [r3, #64]	; 0x40
			timeout_queue_add(cur);
30007308:	e59d0014 	ldr	r0, [sp, #20]
3000730c:	ebfff541 	bl	30004818 <timeout_queue_add>
		}
		acoral_unrdy_thread(cur);
30007310:	e59d0014 	ldr	r0, [sp, #20]
30007314:	ebffee2a 	bl	30002bc4 <acoral_unrdy_thread>
		acoral_evt_queue_add(event, cur);
30007318:	e59d0004 	ldr	r0, [sp, #4]
3000731c:	e59d1014 	ldr	r1, [sp, #20]
30007320:	ebfff667 	bl	30004cc4 <acoral_evt_queue_add>
		acoral_spin_unlock(&event->spin_lock);
		HAL_EXIT_CRITICAL();
30007324:	e59d0010 	ldr	r0, [sp, #16]
30007328:	ebffe8ef 	bl	300016ec <HAL_INTR_RESTORE>
		acoral_sched();
3000732c:	ebffec3b 	bl	30002420 <acoral_sched>
		HAL_ENTER_CRITICAL();
30007330:	ebffe8ef 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30007334:	e1a03000 	mov	r3, r0
30007338:	e58d3010 	str	r3, [sp, #16]
		acoral_spin_lock(&event->spin_lock);

		if (timeout > 0 && cur->delay <= 0)
3000733c:	e59d3000 	ldr	r3, [sp]
30007340:	e3530000 	cmp	r3, #0
30007344:	0a000009 	beq	30007370 <acoral_mbox_recv+0x114>
30007348:	e59d3014 	ldr	r3, [sp, #20]
3000734c:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30007350:	e3530000 	cmp	r3, #0
30007354:	ca000005 	bgt	30007370 <acoral_mbox_recv+0x114>
		{
			acoral_evt_queue_del(cur);
30007358:	e59d0014 	ldr	r0, [sp, #20]
3000735c:	ebfff689 	bl	30004d88 <acoral_evt_queue_del>
			acoral_spin_unlock(&event->spin_lock);
			HAL_EXIT_CRITICAL();
30007360:	e59d0010 	ldr	r0, [sp, #16]
30007364:	ebffe8e0 	bl	300016ec <HAL_INTR_RESTORE>
			return NULL;
30007368:	e3a03000 	mov	r3, #0
3000736c:	ea000012 	b	300073bc <acoral_mbox_recv+0x160>
		}

		msg        = event->data;
30007370:	e59d3004 	ldr	r3, [sp, #4]
30007374:	e5933020 	ldr	r3, [r3, #32]
30007378:	e58d300c 	str	r3, [sp, #12]
		event->data = NULL;
3000737c:	e59d3004 	ldr	r3, [sp, #4]
30007380:	e3a02000 	mov	r2, #0
30007384:	e5832020 	str	r2, [r3, #32]
		acoral_spin_unlock(&event->spin_lock);
		HAL_EXIT_CRITICAL();
30007388:	e59d0010 	ldr	r0, [sp, #16]
3000738c:	ebffe8d6 	bl	300016ec <HAL_INTR_RESTORE>
		return msg;
30007390:	e59d300c 	ldr	r3, [sp, #12]
30007394:	ea000008 	b	300073bc <acoral_mbox_recv+0x160>
	}
	
	msg         = event->data;
30007398:	e59d3004 	ldr	r3, [sp, #4]
3000739c:	e5933020 	ldr	r3, [r3, #32]
300073a0:	e58d300c 	str	r3, [sp, #12]
	event->data = NULL;
300073a4:	e59d3004 	ldr	r3, [sp, #4]
300073a8:	e3a02000 	mov	r2, #0
300073ac:	e5832020 	str	r2, [r3, #32]
	acoral_spin_unlock(&event->spin_lock);
	HAL_EXIT_CRITICAL();
300073b0:	e59d0010 	ldr	r0, [sp, #16]
300073b4:	ebffe8cc 	bl	300016ec <HAL_INTR_RESTORE>

	return msg;
300073b8:	e59d300c 	ldr	r3, [sp, #12]
}
300073bc:	e1a00003 	mov	r0, r3
300073c0:	e28dd01c 	add	sp, sp, #28
300073c4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300073c8:	e12fff1e 	bx	lr
300073cc:	302be818 	.word	0x302be818
300073d0:	10624dd3 	.word	0x10624dd3

300073d4 <acoral_mbox_tryrecv>:
/*======================================
 *   try receive  a mail to mailbox
 *       接收邮件从邮箱
 *======================================*/
void* acoral_mbox_tryrecv(acoral_evt_t * event)
{
300073d4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300073d8:	e24dd014 	sub	sp, sp, #20
300073dc:	e58d0004 	str	r0, [sp, #4]
	void            *msg;
	acoral_sr         cpu_sr;
	
	if (acoral_intr_nesting > 0)
300073e0:	ebffe8de 	bl	30001760 <hal_get_intr_nesting_comm>
300073e4:	e1a03000 	mov	r3, r0
300073e8:	e3530000 	cmp	r3, #0
300073ec:	da000001 	ble	300073f8 <acoral_mbox_tryrecv+0x24>
		return NULL;
300073f0:	e3a03000 	mov	r3, #0
300073f4:	ea000019 	b	30007460 <acoral_mbox_tryrecv+0x8c>

	if(event->type!=ACORAL_EVENT_MBOX)
300073f8:	e59d3004 	ldr	r3, [sp, #4]
300073fc:	e5d33004 	ldrb	r3, [r3, #4]
30007400:	e3530003 	cmp	r3, #3
30007404:	0a000001 	beq	30007410 <acoral_mbox_tryrecv+0x3c>
		return NULL;
30007408:	e3a03000 	mov	r3, #0
3000740c:	ea000013 	b	30007460 <acoral_mbox_tryrecv+0x8c>
	
	HAL_ENTER_CRITICAL();
30007410:	ebffe8b7 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30007414:	e1a03000 	mov	r3, r0
30007418:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&event->spin_lock);
	if( event->data == NULL)
3000741c:	e59d3004 	ldr	r3, [sp, #4]
30007420:	e5933020 	ldr	r3, [r3, #32]
30007424:	e3530000 	cmp	r3, #0
30007428:	1a000003 	bne	3000743c <acoral_mbox_tryrecv+0x68>
	{
		acoral_spin_unlock(&event->spin_lock);
		HAL_EXIT_CRITICAL();
3000742c:	e59d000c 	ldr	r0, [sp, #12]
30007430:	ebffe8ad 	bl	300016ec <HAL_INTR_RESTORE>
		return NULL;
30007434:	e3a03000 	mov	r3, #0
30007438:	ea000008 	b	30007460 <acoral_mbox_tryrecv+0x8c>
	}
	
	msg         = event->data;
3000743c:	e59d3004 	ldr	r3, [sp, #4]
30007440:	e5933020 	ldr	r3, [r3, #32]
30007444:	e58d3008 	str	r3, [sp, #8]
	event->data = NULL;
30007448:	e59d3004 	ldr	r3, [sp, #4]
3000744c:	e3a02000 	mov	r2, #0
30007450:	e5832020 	str	r2, [r3, #32]
	acoral_spin_unlock(&event->spin_lock);
	HAL_EXIT_CRITICAL();
30007454:	e59d000c 	ldr	r0, [sp, #12]
30007458:	ebffe8a3 	bl	300016ec <HAL_INTR_RESTORE>

	return msg;
3000745c:	e59d3008 	ldr	r3, [sp, #8]
}
30007460:	e1a00003 	mov	r0, r3
30007464:	e28dd014 	add	sp, sp, #20
30007468:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000746c:	e12fff1e 	bx	lr

30007470 <acoral_sem_init>:
#include <timer.h>
#include <print.h>
#include <sem.h>
acoral_thread_t *acoral_evt_high_thread(acoral_evt_t *evt);
acoral_u32 *acoral_sem_init(acoral_evt_t *evt,acoral_u32 semNum)
{
30007470:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007474:	e24dd00c 	sub	sp, sp, #12
30007478:	e58d0004 	str	r0, [sp, #4]
3000747c:	e58d1000 	str	r1, [sp]
	if (NULL == evt)
30007480:	e59d3004 	ldr	r3, [sp, #4]
30007484:	e3530000 	cmp	r3, #0
30007488:	1a000001 	bne	30007494 <acoral_sem_init+0x24>
	{
		return NULL;
3000748c:	e3a03000 	mov	r3, #0
30007490:	ea00000e 	b	300074d0 <acoral_sem_init+0x60>
	}
	semNum = 1 - semNum;  /* 拥有多个资源，0,一个  -1 两个， -2 三个 ....*/
30007494:	e59d3000 	ldr	r3, [sp]
30007498:	e2633001 	rsb	r3, r3, #1
3000749c:	e58d3000 	str	r3, [sp]
	evt->count = semNum;
300074a0:	e59d2000 	ldr	r2, [sp]
300074a4:	e59d3004 	ldr	r3, [sp, #4]
300074a8:	e583200c 	str	r2, [r3, #12]
	evt->type  = ACORAL_EVENT_SEM;
300074ac:	e59d3004 	ldr	r3, [sp, #4]
300074b0:	e3a02000 	mov	r2, #0
300074b4:	e5c32004 	strb	r2, [r3, #4]
	evt->data  = NULL;
300074b8:	e59d3004 	ldr	r3, [sp, #4]
300074bc:	e3a02000 	mov	r2, #0
300074c0:	e5832020 	str	r2, [r3, #32]
	acoral_evt_init(evt);
300074c4:	e59d0004 	ldr	r0, [sp, #4]
300074c8:	ebfff5cf 	bl	30004c0c <acoral_evt_init>
	return SEM_SUCCED;
300074cc:	e3a03000 	mov	r3, #0
}
300074d0:	e1a00003 	mov	r0, r3
300074d4:	e28dd00c 	add	sp, sp, #12
300074d8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300074dc:	e12fff1e 	bx	lr

300074e0 <acoral_sem_create>:
/*============================
 *   the creation of signal
 *   计算信号量的创建
 *============================*/
acoral_evt_t *acoral_sem_create(acoral_u32 semNum)
{
300074e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300074e4:	e24dd014 	sub	sp, sp, #20
300074e8:	e58d0004 	str	r0, [sp, #4]
	acoral_evt_t *evt;
	evt = acoral_alloc_evt();
300074ec:	ebfff5be 	bl	30004bec <acoral_alloc_evt>
300074f0:	e1a03000 	mov	r3, r0
300074f4:	e58d300c 	str	r3, [sp, #12]
	if (NULL == evt)
300074f8:	e59d300c 	ldr	r3, [sp, #12]
300074fc:	e3530000 	cmp	r3, #0
30007500:	1a000001 	bne	3000750c <acoral_sem_create+0x2c>
	{
		return NULL;
30007504:	e3a03000 	mov	r3, #0
30007508:	ea00000e 	b	30007548 <acoral_sem_create+0x68>
	}
	semNum = 1 - semNum;  /* 拥有多个资源，0,一个  -1 两个， -2 三个 ....*/
3000750c:	e59d3004 	ldr	r3, [sp, #4]
30007510:	e2633001 	rsb	r3, r3, #1
30007514:	e58d3004 	str	r3, [sp, #4]
	evt->count = semNum;
30007518:	e59d2004 	ldr	r2, [sp, #4]
3000751c:	e59d300c 	ldr	r3, [sp, #12]
30007520:	e583200c 	str	r2, [r3, #12]
	evt->type  = ACORAL_EVENT_SEM;
30007524:	e59d300c 	ldr	r3, [sp, #12]
30007528:	e3a02000 	mov	r2, #0
3000752c:	e5c32004 	strb	r2, [r3, #4]
	evt->data  = NULL;
30007530:	e59d300c 	ldr	r3, [sp, #12]
30007534:	e3a02000 	mov	r2, #0
30007538:	e5832020 	str	r2, [r3, #32]
	acoral_evt_init(evt);
3000753c:	e59d000c 	ldr	r0, [sp, #12]
30007540:	ebfff5b1 	bl	30004c0c <acoral_evt_init>
	return evt;
30007544:	e59d300c 	ldr	r3, [sp, #12]
}
30007548:	e1a00003 	mov	r0, r3
3000754c:	e28dd014 	add	sp, sp, #20
30007550:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007554:	e12fff1e 	bx	lr

30007558 <acoral_sem_del>:
/*============================
 *  the deletion of singal 
 *   计算信号量的删除
 *============================*/
acoral_u32 acoral_sem_del(acoral_evt_t *evt, acoral_u32 opt)
{
30007558:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000755c:	e24dd014 	sub	sp, sp, #20
30007560:	e58d0004 	str	r0, [sp, #4]
30007564:	e58d1000 	str	r1, [sp]
	acoral_sr            cpu_sr;
	acoral_thread_t     *thread;
	if (acoral_intr_nesting)
30007568:	ebffe87c 	bl	30001760 <hal_get_intr_nesting_comm>
3000756c:	e1a03000 	mov	r3, r0
30007570:	e3530000 	cmp	r3, #0
30007574:	0a000001 	beq	30007580 <acoral_sem_del+0x28>
	{
		return SEM_ERR_INTR;
30007578:	e3a03006 	mov	r3, #6
3000757c:	ea00001d 	b	300075f8 <acoral_sem_del+0xa0>
	}
	/* 参数检测*/
	if (NULL == evt)
30007580:	e59d3004 	ldr	r3, [sp, #4]
30007584:	e3530000 	cmp	r3, #0
30007588:	1a000001 	bne	30007594 <acoral_sem_del+0x3c>
		return SEM_ERR_NULL; /* error*/
3000758c:	e3a03002 	mov	r3, #2
30007590:	ea000018 	b	300075f8 <acoral_sem_del+0xa0>
	if ( evt->type != ACORAL_EVENT_SEM )
30007594:	e59d3004 	ldr	r3, [sp, #4]
30007598:	e5d33004 	ldrb	r3, [r3, #4]
3000759c:	e3530000 	cmp	r3, #0
300075a0:	0a000001 	beq	300075ac <acoral_sem_del+0x54>
		return SEM_ERR_TYPE; /* error*/
300075a4:	e3a03004 	mov	r3, #4
300075a8:	ea000012 	b	300075f8 <acoral_sem_del+0xa0>

	HAL_ENTER_CRITICAL();
300075ac:	ebffe850 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300075b0:	e1a03000 	mov	r3, r0
300075b4:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&evt->spin_lock);
	thread =acoral_evt_high_thread(evt);
300075b8:	e59d0004 	ldr	r0, [sp, #4]
300075bc:	ebfff5ac 	bl	30004c74 <acoral_evt_high_thread>
300075c0:	e1a03000 	mov	r3, r0
300075c4:	e58d300c 	str	r3, [sp, #12]
	if (thread==NULL)
300075c8:	e59d300c 	ldr	r3, [sp, #12]
300075cc:	e3530000 	cmp	r3, #0
300075d0:	1a000005 	bne	300075ec <acoral_sem_del+0x94>
	{
		/*队列上无等待任务*/
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
300075d4:	e59d0008 	ldr	r0, [sp, #8]
300075d8:	ebffe843 	bl	300016ec <HAL_INTR_RESTORE>
		evt = NULL;
300075dc:	e3a03000 	mov	r3, #0
300075e0:	e58d3004 	str	r3, [sp, #4]
		return SEM_ERR_UNDEF;
300075e4:	e3a03007 	mov	r3, #7
300075e8:	ea000002 	b	300075f8 <acoral_sem_del+0xa0>
	}
	else
	{
		/*有等待任务*/
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
300075ec:	e59d0008 	ldr	r0, [sp, #8]
300075f0:	ebffe83d 	bl	300016ec <HAL_INTR_RESTORE>
		return SEM_ERR_TASK_EXIST; /*error*/
300075f4:	e3a03005 	mov	r3, #5
	}
}
300075f8:	e1a00003 	mov	r0, r3
300075fc:	e28dd014 	add	sp, sp, #20
30007600:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007604:	e12fff1e 	bx	lr

30007608 <acoral_sem_trypend>:
 *  计算信号量的申请
 *  desp: count <= SEM_RES_AVAI  信号量有效 a++
 *        count >  SEM_RES_AVAI  信号量无效 a++ && thread suspend
 *============================*/
acoral_u32 acoral_sem_trypend(acoral_evt_t *evt)
{
30007608:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000760c:	e24dd014 	sub	sp, sp, #20
30007610:	e58d0004 	str	r0, [sp, #4]
	acoral_sr cpu_sr;

	if (acoral_intr_nesting)
30007614:	ebffe851 	bl	30001760 <hal_get_intr_nesting_comm>
30007618:	e1a03000 	mov	r3, r0
3000761c:	e3530000 	cmp	r3, #0
30007620:	0a000001 	beq	3000762c <acoral_sem_trypend+0x24>
	{
		return SEM_ERR_INTR;
30007624:	e3a03006 	mov	r3, #6
30007628:	ea000020 	b	300076b0 <acoral_sem_trypend+0xa8>
	}

	/* 参数检测 */
	if (NULL == evt)
3000762c:	e59d3004 	ldr	r3, [sp, #4]
30007630:	e3530000 	cmp	r3, #0
30007634:	1a000001 	bne	30007640 <acoral_sem_trypend+0x38>
	{
		return SEM_ERR_NULL; /*error*/
30007638:	e3a03002 	mov	r3, #2
3000763c:	ea00001b 	b	300076b0 <acoral_sem_trypend+0xa8>
	}
	if (ACORAL_EVENT_SEM != evt->type)
30007640:	e59d3004 	ldr	r3, [sp, #4]
30007644:	e5d33004 	ldrb	r3, [r3, #4]
30007648:	e3530000 	cmp	r3, #0
3000764c:	0a000001 	beq	30007658 <acoral_sem_trypend+0x50>
	{
		return SEM_ERR_TYPE; /*error*/
30007650:	e3a03004 	mov	r3, #4
30007654:	ea000015 	b	300076b0 <acoral_sem_trypend+0xa8>
	}

	/* 计算信号量处理*/
	HAL_ENTER_CRITICAL();
30007658:	ebffe825 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000765c:	e1a03000 	mov	r3, r0
30007660:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&evt->spin_lock);
	if ((acoral_8)evt->count <= SEM_RES_AVAI)
30007664:	e59d3004 	ldr	r3, [sp, #4]
30007668:	e593300c 	ldr	r3, [r3, #12]
3000766c:	e20330ff 	and	r3, r3, #255	; 0xff
30007670:	e1a03c03 	lsl	r3, r3, #24
30007674:	e1a03c43 	asr	r3, r3, #24
30007678:	e3530000 	cmp	r3, #0
3000767c:	ca000008 	bgt	300076a4 <acoral_sem_trypend+0x9c>
	{   /* available*/
		evt->count++;
30007680:	e59d3004 	ldr	r3, [sp, #4]
30007684:	e593300c 	ldr	r3, [r3, #12]
30007688:	e2832001 	add	r2, r3, #1
3000768c:	e59d3004 	ldr	r3, [sp, #4]
30007690:	e583200c 	str	r2, [r3, #12]
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30007694:	e59d000c 	ldr	r0, [sp, #12]
30007698:	ebffe813 	bl	300016ec <HAL_INTR_RESTORE>
		return SEM_SUCCED;
3000769c:	e3a03000 	mov	r3, #0
300076a0:	ea000002 	b	300076b0 <acoral_sem_trypend+0xa8>
	}

	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
300076a4:	e59d000c 	ldr	r0, [sp, #12]
300076a8:	ebffe80f 	bl	300016ec <HAL_INTR_RESTORE>
	return SEM_ERR_TIMEOUT;
300076ac:	e3a03008 	mov	r3, #8
}
300076b0:	e1a00003 	mov	r0, r3
300076b4:	e28dd014 	add	sp, sp, #20
300076b8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300076bc:	e12fff1e 	bx	lr

300076c0 <acoral_sem_pend>:
 *  计算信号量的申请
 *  desp: count <= SEM_RES_AVAI  信号量有效 a++
 *        count >  SEM_RES_AVAI  信号量无效 a++ && thread suspend
 *============================*/
acoral_u32 acoral_sem_pend(acoral_evt_t *evt, acoral_time timeout)
{
300076c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300076c4:	e24dd014 	sub	sp, sp, #20
300076c8:	e58d0004 	str	r0, [sp, #4]
300076cc:	e58d1000 	str	r1, [sp]
	acoral_thread_t *cur = acoral_cur_thread;
300076d0:	e59f318c 	ldr	r3, [pc, #396]	; 30007864 <acoral_sem_pend+0x1a4>
300076d4:	e5933000 	ldr	r3, [r3]
300076d8:	e58d3008 	str	r3, [sp, #8]
	acoral_sr cpu_sr;

	if (acoral_intr_nesting)
300076dc:	ebffe81f 	bl	30001760 <hal_get_intr_nesting_comm>
300076e0:	e1a03000 	mov	r3, r0
300076e4:	e3530000 	cmp	r3, #0
300076e8:	0a000001 	beq	300076f4 <acoral_sem_pend+0x34>
	{
		return SEM_ERR_INTR;
300076ec:	e3a03006 	mov	r3, #6
300076f0:	ea000057 	b	30007854 <acoral_sem_pend+0x194>
	}

	/* 参数检测 */
	if (NULL == evt)
300076f4:	e59d3004 	ldr	r3, [sp, #4]
300076f8:	e3530000 	cmp	r3, #0
300076fc:	1a000001 	bne	30007708 <acoral_sem_pend+0x48>
	{
		return SEM_ERR_NULL; /*error*/
30007700:	e3a03002 	mov	r3, #2
30007704:	ea000052 	b	30007854 <acoral_sem_pend+0x194>
	}
	if (ACORAL_EVENT_SEM != evt->type)
30007708:	e59d3004 	ldr	r3, [sp, #4]
3000770c:	e5d33004 	ldrb	r3, [r3, #4]
30007710:	e3530000 	cmp	r3, #0
30007714:	0a000001 	beq	30007720 <acoral_sem_pend+0x60>
	{
		return SEM_ERR_TYPE; /*error*/
30007718:	e3a03004 	mov	r3, #4
3000771c:	ea00004c 	b	30007854 <acoral_sem_pend+0x194>
	}

	/* 计算信号量处理*/
	HAL_ENTER_CRITICAL();
30007720:	ebffe7f3 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30007724:	e1a03000 	mov	r3, r0
30007728:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&evt->spin_lock);
	if ((acoral_8)evt->count <= SEM_RES_AVAI)
3000772c:	e59d3004 	ldr	r3, [sp, #4]
30007730:	e593300c 	ldr	r3, [r3, #12]
30007734:	e20330ff 	and	r3, r3, #255	; 0xff
30007738:	e1a03c03 	lsl	r3, r3, #24
3000773c:	e1a03c43 	asr	r3, r3, #24
30007740:	e3530000 	cmp	r3, #0
30007744:	ca000008 	bgt	3000776c <acoral_sem_pend+0xac>
	{   /* available*/
		evt->count++;
30007748:	e59d3004 	ldr	r3, [sp, #4]
3000774c:	e593300c 	ldr	r3, [r3, #12]
30007750:	e2832001 	add	r2, r3, #1
30007754:	e59d3004 	ldr	r3, [sp, #4]
30007758:	e583200c 	str	r2, [r3, #12]
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
3000775c:	e59d000c 	ldr	r0, [sp, #12]
30007760:	ebffe7e1 	bl	300016ec <HAL_INTR_RESTORE>
		return SEM_SUCCED;
30007764:	e3a03000 	mov	r3, #0
30007768:	ea000039 	b	30007854 <acoral_sem_pend+0x194>
	}

	evt->count++;
3000776c:	e59d3004 	ldr	r3, [sp, #4]
30007770:	e593300c 	ldr	r3, [r3, #12]
30007774:	e2832001 	add	r2, r3, #1
30007778:	e59d3004 	ldr	r3, [sp, #4]
3000777c:	e583200c 	str	r2, [r3, #12]
	acoral_unrdy_thread(cur);
30007780:	e59d0008 	ldr	r0, [sp, #8]
30007784:	ebffed0e 	bl	30002bc4 <acoral_unrdy_thread>
	if (timeout > 0)
30007788:	e59d3000 	ldr	r3, [sp]
3000778c:	e3530000 	cmp	r3, #0
30007790:	0a00000f 	beq	300077d4 <acoral_sem_pend+0x114>
	{
		cur->delay = TIME_TO_TICKS(timeout);
30007794:	e59d2000 	ldr	r2, [sp]
30007798:	e1a03002 	mov	r3, r2
3000779c:	e1a03103 	lsl	r3, r3, #2
300077a0:	e0833002 	add	r3, r3, r2
300077a4:	e1a02103 	lsl	r2, r3, #2
300077a8:	e0833002 	add	r3, r3, r2
300077ac:	e1a03103 	lsl	r3, r3, #2
300077b0:	e1a02003 	mov	r2, r3
300077b4:	e59f30ac 	ldr	r3, [pc, #172]	; 30007868 <acoral_sem_pend+0x1a8>
300077b8:	e0831392 	umull	r1, r3, r2, r3
300077bc:	e1a03323 	lsr	r3, r3, #6
300077c0:	e1a02003 	mov	r2, r3
300077c4:	e59d3008 	ldr	r3, [sp, #8]
300077c8:	e5832040 	str	r2, [r3, #64]	; 0x40
		timeout_queue_add(cur);
300077cc:	e59d0008 	ldr	r0, [sp, #8]
300077d0:	ebfff410 	bl	30004818 <timeout_queue_add>
	}
	acoral_evt_queue_add(evt,cur);
300077d4:	e59d0004 	ldr	r0, [sp, #4]
300077d8:	e59d1008 	ldr	r1, [sp, #8]
300077dc:	ebfff538 	bl	30004cc4 <acoral_evt_queue_add>
	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
300077e0:	e59d000c 	ldr	r0, [sp, #12]
300077e4:	ebffe7c0 	bl	300016ec <HAL_INTR_RESTORE>
	
	acoral_sched();
300077e8:	ebffeb0c 	bl	30002420 <acoral_sched>

	HAL_ENTER_CRITICAL();
300077ec:	ebffe7c0 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300077f0:	e1a03000 	mov	r3, r0
300077f4:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&evt->spin_lock);
	if(timeout>0 && cur->delay<=0)
300077f8:	e59d3000 	ldr	r3, [sp]
300077fc:	e3530000 	cmp	r3, #0
30007800:	0a00000e 	beq	30007840 <acoral_sem_pend+0x180>
30007804:	e59d3008 	ldr	r3, [sp, #8]
30007808:	e5933040 	ldr	r3, [r3, #64]	; 0x40
3000780c:	e3530000 	cmp	r3, #0
30007810:	ca00000a 	bgt	30007840 <acoral_sem_pend+0x180>
	{
		//--------------
		// modify by pegasus 0804: count-- [+]
		evt->count--;
30007814:	e59d3004 	ldr	r3, [sp, #4]
30007818:	e593300c 	ldr	r3, [r3, #12]
3000781c:	e2432001 	sub	r2, r3, #1
30007820:	e59d3004 	ldr	r3, [sp, #4]
30007824:	e583200c 	str	r2, [r3, #12]
		acoral_evt_queue_del(cur);
30007828:	e59d0008 	ldr	r0, [sp, #8]
3000782c:	ebfff555 	bl	30004d88 <acoral_evt_queue_del>
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30007830:	e59d000c 	ldr	r0, [sp, #12]
30007834:	ebffe7ac 	bl	300016ec <HAL_INTR_RESTORE>
		return SEM_ERR_TIMEOUT;
30007838:	e3a03008 	mov	r3, #8
3000783c:	ea000004 	b	30007854 <acoral_sem_pend+0x194>
	}

	//-------------------
	// modify by pegasus 0804: timeout_queue_del [+]
	timeout_queue_del(cur);
30007840:	e59d0008 	ldr	r0, [sp, #8]
30007844:	ebfff435 	bl	30004920 <timeout_queue_del>
	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
30007848:	e59d000c 	ldr	r0, [sp, #12]
3000784c:	ebffe7a6 	bl	300016ec <HAL_INTR_RESTORE>
	return SEM_SUCCED;
30007850:	e3a03000 	mov	r3, #0
}
30007854:	e1a00003 	mov	r0, r3
30007858:	e28dd014 	add	sp, sp, #20
3000785c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007860:	e12fff1e 	bx	lr
30007864:	302be818 	.word	0x302be818
30007868:	10624dd3 	.word	0x10624dd3

3000786c <acoral_sem_post>:
 *  计算信号量的释放
 *  desp: count > SEM_RES_NOAVAI 有等待线程 a-- && resume waiting thread.
 *        count <= SEM_RES_NOAVAI 无等待线程 a--
 *===========================*/
acoral_u32 acoral_sem_post(acoral_evt_t *evt)
{
3000786c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007870:	e24dd014 	sub	sp, sp, #20
30007874:	e58d0004 	str	r0, [sp, #4]
	acoral_thread_t     *thread;
	acoral_sr            cpu_sr;

	/* 参数检测*/
	if ( NULL == evt)
30007878:	e59d3004 	ldr	r3, [sp, #4]
3000787c:	e3530000 	cmp	r3, #0
30007880:	1a000001 	bne	3000788c <acoral_sem_post+0x20>
	{
		return SEM_ERR_NULL; /* error*/
30007884:	e3a03002 	mov	r3, #2
30007888:	ea000034 	b	30007960 <acoral_sem_post+0xf4>
	}
	if (ACORAL_EVENT_SEM != evt->type)
3000788c:	e59d3004 	ldr	r3, [sp, #4]
30007890:	e5d33004 	ldrb	r3, [r3, #4]
30007894:	e3530000 	cmp	r3, #0
30007898:	0a000001 	beq	300078a4 <acoral_sem_post+0x38>
	{
		return SEM_ERR_TYPE;
3000789c:	e3a03004 	mov	r3, #4
300078a0:	ea00002e 	b	30007960 <acoral_sem_post+0xf4>
	}

	HAL_ENTER_CRITICAL();
300078a4:	ebffe792 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300078a8:	e1a03000 	mov	r3, r0
300078ac:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&evt->spin_lock);

	/* 计算信号量的释放*/
	if ((acoral_8)evt->count <= SEM_RES_NOAVAI)
300078b0:	e59d3004 	ldr	r3, [sp, #4]
300078b4:	e593300c 	ldr	r3, [r3, #12]
300078b8:	e20330ff 	and	r3, r3, #255	; 0xff
300078bc:	e1a03c03 	lsl	r3, r3, #24
300078c0:	e1a03c43 	asr	r3, r3, #24
300078c4:	e3530001 	cmp	r3, #1
300078c8:	ca000008 	bgt	300078f0 <acoral_sem_post+0x84>
	{ /* no waiting thread*/
		evt->count--;
300078cc:	e59d3004 	ldr	r3, [sp, #4]
300078d0:	e593300c 	ldr	r3, [r3, #12]
300078d4:	e2432001 	sub	r2, r3, #1
300078d8:	e59d3004 	ldr	r3, [sp, #4]
300078dc:	e583200c 	str	r2, [r3, #12]
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
300078e0:	e59d000c 	ldr	r0, [sp, #12]
300078e4:	ebffe780 	bl	300016ec <HAL_INTR_RESTORE>
		return SEM_SUCCED;
300078e8:	e3a03000 	mov	r3, #0
300078ec:	ea00001b 	b	30007960 <acoral_sem_post+0xf4>
	}
	/* 有等待线程*/
	evt->count--;
300078f0:	e59d3004 	ldr	r3, [sp, #4]
300078f4:	e593300c 	ldr	r3, [r3, #12]
300078f8:	e2432001 	sub	r2, r3, #1
300078fc:	e59d3004 	ldr	r3, [sp, #4]
30007900:	e583200c 	str	r2, [r3, #12]
	thread =acoral_evt_high_thread(evt);
30007904:	e59d0004 	ldr	r0, [sp, #4]
30007908:	ebfff4d9 	bl	30004c74 <acoral_evt_high_thread>
3000790c:	e1a03000 	mov	r3, r0
30007910:	e58d3008 	str	r3, [sp, #8]
	if (thread==NULL)
30007914:	e59d3008 	ldr	r3, [sp, #8]
30007918:	e3530000 	cmp	r3, #0
3000791c:	1a000005 	bne	30007938 <acoral_sem_post+0xcc>
	{
		/*应该有等待线程却没有找到*/
		acoral_printerr("Err Sem post\n");
30007920:	e59f0048 	ldr	r0, [pc, #72]	; 30007970 <acoral_sem_post+0x104>
30007924:	eb000e45 	bl	3000b240 <acoral_print>
		acoral_spin_unlock(&evt->spin_lock);
		HAL_EXIT_CRITICAL();
30007928:	e59d000c 	ldr	r0, [sp, #12]
3000792c:	ebffe76e 	bl	300016ec <HAL_INTR_RESTORE>
		return SEM_ERR_UNDEF;
30007930:	e3a03007 	mov	r3, #7
30007934:	ea000009 	b	30007960 <acoral_sem_post+0xf4>
	}
	timeout_queue_del(thread);
30007938:	e59d0008 	ldr	r0, [sp, #8]
3000793c:	ebfff3f7 	bl	30004920 <timeout_queue_del>
	/*释放等待任务*/
	acoral_evt_queue_del(thread);
30007940:	e59d0008 	ldr	r0, [sp, #8]
30007944:	ebfff50f 	bl	30004d88 <acoral_evt_queue_del>
	acoral_rdy_thread(thread);
30007948:	e59d0008 	ldr	r0, [sp, #8]
3000794c:	ebffec8d 	bl	30002b88 <acoral_rdy_thread>
	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
30007950:	e59d000c 	ldr	r0, [sp, #12]
30007954:	ebffe764 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sched();
30007958:	ebffeab0 	bl	30002420 <acoral_sched>
	return SEM_SUCCED;
3000795c:	e3a03000 	mov	r3, #0
}
30007960:	e1a00003 	mov	r0, r3
30007964:	e28dd014 	add	sp, sp, #20
30007968:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000796c:	e12fff1e 	bx	lr
30007970:	30045454 	.word	0x30045454

30007974 <acoral_sem_getnum>:
/*===================================
 *   get singal's number now
 *     得到当前信号量数目
 *===================================*/
acoral_32 acoral_sem_getnum(acoral_evt_t* evt)
{
30007974:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007978:	e24dd014 	sub	sp, sp, #20
3000797c:	e58d0004 	str	r0, [sp, #4]
	acoral_32 t;
	acoral_sr cpu_sr;

	if (NULL == evt)
30007980:	e59d3004 	ldr	r3, [sp, #4]
30007984:	e3530000 	cmp	r3, #0
30007988:	1a000001 	bne	30007994 <acoral_sem_getnum+0x20>
		return SEM_ERR_NULL;
3000798c:	e3a03002 	mov	r3, #2
30007990:	ea000009 	b	300079bc <acoral_sem_getnum+0x48>

	HAL_ENTER_CRITICAL();
30007994:	ebffe756 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30007998:	e1a03000 	mov	r3, r0
3000799c:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&evt->spin_lock);
	t = 1 - (acoral_32)evt->count;
300079a0:	e59d3004 	ldr	r3, [sp, #4]
300079a4:	e593300c 	ldr	r3, [r3, #12]
300079a8:	e2633001 	rsb	r3, r3, #1
300079ac:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_unlock(&evt->spin_lock);
	HAL_EXIT_CRITICAL();
300079b0:	e59d000c 	ldr	r0, [sp, #12]
300079b4:	ebffe74c 	bl	300016ec <HAL_INTR_RESTORE>
	return t;
300079b8:	e59d3008 	ldr	r3, [sp, #8]
}
300079bc:	e1a00003 	mov	r0, r3
300079c0:	e28dd014 	add	sp, sp, #20
300079c4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300079c8:	e12fff1e 	bx	lr

300079cc <acoral_msg_sys_init>:
/*=============================
 *
 *  mssage 机制缓冲池初始化
 *=============================*/
void acoral_msg_sys_init()
{
300079cc:	e92d4008 	push	{r3, lr}
	/*初始化全局事件列表头*/
	acoral_init_list (&(g_msgctr_header.head));
300079d0:	e59f3094 	ldr	r3, [pc, #148]	; 30007a6c <acoral_msg_sys_init+0xa0>
300079d4:	e59f2090 	ldr	r2, [pc, #144]	; 30007a6c <acoral_msg_sys_init+0xa0>
300079d8:	e5832000 	str	r2, [r3]
300079dc:	e59f3088 	ldr	r3, [pc, #136]	; 30007a6c <acoral_msg_sys_init+0xa0>
300079e0:	e59f2084 	ldr	r2, [pc, #132]	; 30007a6c <acoral_msg_sys_init+0xa0>
300079e4:	e5832004 	str	r2, [r3, #4]
	g_msgctr_header.data = NULL;
300079e8:	e59f307c 	ldr	r3, [pc, #124]	; 30007a6c <acoral_msg_sys_init+0xa0>
300079ec:	e3a02000 	mov	r2, #0
300079f0:	e5832008 	str	r2, [r3, #8]
	acoral_msgctr_pool_ctrl.type=ACORAL_RES_MST;
300079f4:	e59f3074 	ldr	r3, [pc, #116]	; 30007a70 <acoral_msg_sys_init+0xa4>
300079f8:	e3a02006 	mov	r2, #6
300079fc:	e5832000 	str	r2, [r3]
	acoral_msgctr_pool_ctrl.size=sizeof(acoral_msgctr_t);
30007a00:	e59f3068 	ldr	r3, [pc, #104]	; 30007a70 <acoral_msg_sys_init+0xa4>
30007a04:	e3a02030 	mov	r2, #48	; 0x30
30007a08:	e5832004 	str	r2, [r3, #4]
	acoral_msgctr_pool_ctrl.num_per_pool=10;
30007a0c:	e59f305c 	ldr	r3, [pc, #92]	; 30007a70 <acoral_msg_sys_init+0xa4>
30007a10:	e3a0200a 	mov	r2, #10
30007a14:	e5832008 	str	r2, [r3, #8]
	acoral_msgctr_pool_ctrl.max_pools=4;
30007a18:	e59f3050 	ldr	r3, [pc, #80]	; 30007a70 <acoral_msg_sys_init+0xa4>
30007a1c:	e3a02004 	mov	r2, #4
30007a20:	e5832010 	str	r2, [r3, #16]

	acoral_msg_pool_ctrl.type=ACORAL_RES_MSG;
30007a24:	e59f3048 	ldr	r3, [pc, #72]	; 30007a74 <acoral_msg_sys_init+0xa8>
30007a28:	e3a02005 	mov	r2, #5
30007a2c:	e5832000 	str	r2, [r3]
	acoral_msg_pool_ctrl.size=sizeof(acoral_msg_t);
30007a30:	e59f303c 	ldr	r3, [pc, #60]	; 30007a74 <acoral_msg_sys_init+0xa8>
30007a34:	e3a0201c 	mov	r2, #28
30007a38:	e5832004 	str	r2, [r3, #4]
	acoral_msg_pool_ctrl.num_per_pool=10;
30007a3c:	e59f3030 	ldr	r3, [pc, #48]	; 30007a74 <acoral_msg_sys_init+0xa8>
30007a40:	e3a0200a 	mov	r2, #10
30007a44:	e5832008 	str	r2, [r3, #8]
	acoral_msg_pool_ctrl.max_pools=4;
30007a48:	e59f3024 	ldr	r3, [pc, #36]	; 30007a74 <acoral_msg_sys_init+0xa8>
30007a4c:	e3a02004 	mov	r2, #4
30007a50:	e5832010 	str	r2, [r3, #16]

	acoral_pool_ctrl_init(&acoral_msgctr_pool_ctrl);
30007a54:	e59f0014 	ldr	r0, [pc, #20]	; 30007a70 <acoral_msg_sys_init+0xa4>
30007a58:	ebfff00a 	bl	30003a88 <acoral_pool_ctrl_init>
	acoral_pool_ctrl_init(&acoral_msg_pool_ctrl);
30007a5c:	e59f0010 	ldr	r0, [pc, #16]	; 30007a74 <acoral_msg_sys_init+0xa8>
30007a60:	ebfff008 	bl	30003a88 <acoral_pool_ctrl_init>
}
30007a64:	e8bd4008 	pop	{r3, lr}
30007a68:	e12fff1e 	bx	lr
30007a6c:	300ea328 	.word	0x300ea328
30007a70:	301f5768 	.word	0x301f5768
30007a74:	3012b648 	.word	0x3012b648

30007a78 <acoral_msgctr_list_queueadd>:
 *  静态创建的acoral_msgctr_t调用
 *  message container 挂全局队列
 *  在中断中处理 ttl 时使用
 *==============================*/
void acoral_msgctr_list_queueadd(acoral_msgctr_t* msgctr)
{
30007a78:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007a7c:	e24dd00c 	sub	sp, sp, #12
30007a80:	e58d0004 	str	r0, [sp, #4]
  	acoral_list_add2_tail (&msgctr->msgctr_list, &(g_msgctr_header.head));
30007a84:	e59d3004 	ldr	r3, [sp, #4]
30007a88:	e283300c 	add	r3, r3, #12
30007a8c:	e1a00003 	mov	r0, r3
30007a90:	e59f100c 	ldr	r1, [pc, #12]	; 30007aa4 <acoral_msgctr_list_queueadd+0x2c>
30007a94:	eb000957 	bl	30009ff8 <acoral_list_add2_tail>
}
30007a98:	e28dd00c 	add	sp, sp, #12
30007a9c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007aa0:	e12fff1e 	bx	lr
30007aa4:	300ea328 	.word	0x300ea328

30007aa8 <acoral_alloc_msgctr>:
/*==============================
 *
 *  message 分配
 *==============================*/
acoral_msgctr_t* acoral_alloc_msgctr()
{
30007aa8:	e92d4008 	push	{r3, lr}
	return (acoral_msgctr_t*)acoral_get_res (&acoral_msgctr_pool_ctrl);
30007aac:	e59f0010 	ldr	r0, [pc, #16]	; 30007ac4 <acoral_alloc_msgctr+0x1c>
30007ab0:	ebffee95 	bl	3000350c <acoral_get_res>
30007ab4:	e1a03000 	mov	r3, r0
}
30007ab8:	e1a00003 	mov	r0, r3
30007abc:	e8bd4008 	pop	{r3, lr}
30007ac0:	e12fff1e 	bx	lr
30007ac4:	301f5768 	.word	0x301f5768

30007ac8 <acoral_alloc_msg>:

acoral_msg_t* acoral_alloc_msg()
{
30007ac8:	e92d4008 	push	{r3, lr}
	return (acoral_msg_t*)acoral_get_res (&acoral_msg_pool_ctrl);
30007acc:	e59f0010 	ldr	r0, [pc, #16]	; 30007ae4 <acoral_alloc_msg+0x1c>
30007ad0:	ebffee8d 	bl	3000350c <acoral_get_res>
30007ad4:	e1a03000 	mov	r3, r0
}
30007ad8:	e1a00003 	mov	r0, r3
30007adc:	e8bd4008 	pop	{r3, lr}
30007ae0:	e12fff1e 	bx	lr
30007ae4:	3012b648 	.word	0x3012b648

30007ae8 <acoral_msgctr_queue_add>:
 *
 *  message 等待队列增加
 *==============================*/
void acoral_msgctr_queue_add (acoral_msgctr_t* msgctr, 
		                            acoral_thread_t* thread)
{   /*需按优先级排序*/
30007ae8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007aec:	e24dd01c 	sub	sp, sp, #28
30007af0:	e58d0004 	str	r0, [sp, #4]
30007af4:	e58d1000 	str	r1, [sp]
	/*acoral_list_add2_tail (&thread->waiting, &msgctr->waiting);*/
	acoral_list_t *p, *q;
	acoral_thread_t*  ptd;
	
	p = &msgctr->waiting;
30007af8:	e59d3004 	ldr	r3, [sp, #4]
30007afc:	e2833020 	add	r3, r3, #32
30007b00:	e58d300c 	str	r3, [sp, #12]
	q = p->next;
30007b04:	e59d300c 	ldr	r3, [sp, #12]
30007b08:	e5933000 	ldr	r3, [r3]
30007b0c:	e58d3010 	str	r3, [sp, #16]
	for( ; p != q; q=q->next)
30007b10:	ea00000b 	b	30007b44 <acoral_msgctr_queue_add+0x5c>
	{
		ptd = list_entry( q, acoral_thread_t, waiting);
30007b14:	e59d3010 	ldr	r3, [sp, #16]
30007b18:	e2433020 	sub	r3, r3, #32
30007b1c:	e58d3014 	str	r3, [sp, #20]
		if (ptd->prio > thread->prio)
30007b20:	e59d3014 	ldr	r3, [sp, #20]
30007b24:	e5d32005 	ldrb	r2, [r3, #5]
30007b28:	e59d3000 	ldr	r3, [sp]
30007b2c:	e5d33005 	ldrb	r3, [r3, #5]
30007b30:	e1520003 	cmp	r2, r3
30007b34:	8a000007 	bhi	30007b58 <acoral_msgctr_queue_add+0x70>
	acoral_list_t *p, *q;
	acoral_thread_t*  ptd;
	
	p = &msgctr->waiting;
	q = p->next;
	for( ; p != q; q=q->next)
30007b38:	e59d3010 	ldr	r3, [sp, #16]
30007b3c:	e5933000 	ldr	r3, [r3]
30007b40:	e58d3010 	str	r3, [sp, #16]
30007b44:	e59d200c 	ldr	r2, [sp, #12]
30007b48:	e59d3010 	ldr	r3, [sp, #16]
30007b4c:	e1520003 	cmp	r2, r3
30007b50:	1affffef 	bne	30007b14 <acoral_msgctr_queue_add+0x2c>
30007b54:	ea000000 	b	30007b5c <acoral_msgctr_queue_add+0x74>
	{
		ptd = list_entry( q, acoral_thread_t, waiting);
		if (ptd->prio > thread->prio)
			break;
30007b58:	e1a00000 	nop			; (mov r0, r0)
	}
	acoral_list_add( &thread->waiting, q->prev);
30007b5c:	e59d3000 	ldr	r3, [sp]
30007b60:	e2832020 	add	r2, r3, #32
30007b64:	e59d3010 	ldr	r3, [sp, #16]
30007b68:	e5933004 	ldr	r3, [r3, #4]
30007b6c:	e1a00002 	mov	r0, r2
30007b70:	e1a01003 	mov	r1, r3
30007b74:	eb00090c 	bl	30009fac <acoral_list_add>
}
30007b78:	e28dd01c 	add	sp, sp, #28
30007b7c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007b80:	e12fff1e 	bx	lr

30007b84 <acoral_msg_queue_add>:

void acoral_msg_queue_add (acoral_msgctr_t* msgctr, 
		                          acoral_msg_t* msg)
{
30007b84:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007b88:	e24dd00c 	sub	sp, sp, #12
30007b8c:	e58d0004 	str	r0, [sp, #4]
30007b90:	e58d1000 	str	r1, [sp]
	acoral_list_add2_tail (&msg->msglist, &msgctr->msglist);
30007b94:	e59d3000 	ldr	r3, [sp]
30007b98:	e2832004 	add	r2, r3, #4
30007b9c:	e59d3004 	ldr	r3, [sp, #4]
30007ba0:	e2833028 	add	r3, r3, #40	; 0x28
30007ba4:	e1a00002 	mov	r0, r2
30007ba8:	e1a01003 	mov	r1, r3
30007bac:	eb000911 	bl	30009ff8 <acoral_list_add2_tail>
}
30007bb0:	e28dd00c 	add	sp, sp, #12
30007bb4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007bb8:	e12fff1e 	bx	lr

30007bbc <acoral_msgctr_init>:
/*==============================
 * The initialize of the message
 *       消息容器初始化
 *==============================*/
acoral_u32  acoral_msgctr_init(acoral_msgctr_t *msgctr)
{
30007bbc:	e24dd008 	sub	sp, sp, #8
30007bc0:	e58d0004 	str	r0, [sp, #4]
	if (msgctr == NULL)
30007bc4:	e59d3004 	ldr	r3, [sp, #4]
30007bc8:	e3530000 	cmp	r3, #0
30007bcc:	1a000001 	bne	30007bd8 <acoral_msgctr_init+0x1c>
		return MST_ERR_NULL;
30007bd0:	e3a03000 	mov	r3, #0
30007bd4:	ea000024 	b	30007c6c <acoral_msgctr_init+0xb0>

	msgctr->name  = NULL;
30007bd8:	e59d3004 	ldr	r3, [sp, #4]
30007bdc:	e3a02000 	mov	r2, #0
30007be0:	e5832004 	str	r2, [r3, #4]
	msgctr->type  = ACORAL_MSGCTR;
30007be4:	e59d3004 	ldr	r3, [sp, #4]
30007be8:	e3a02001 	mov	r2, #1
30007bec:	e5c32008 	strb	r2, [r3, #8]
	msgctr->count = 0;
30007bf0:	e59d3004 	ldr	r3, [sp, #4]
30007bf4:	e3a02000 	mov	r2, #0
30007bf8:	e5832018 	str	r2, [r3, #24]
	msgctr->wait_thread_num = 0;
30007bfc:	e59d3004 	ldr	r3, [sp, #4]
30007c00:	e3a02000 	mov	r2, #0
30007c04:	e583201c 	str	r2, [r3, #28]

	acoral_init_list(&msgctr->msglist);
30007c08:	e59d3004 	ldr	r3, [sp, #4]
30007c0c:	e2832028 	add	r2, r3, #40	; 0x28
30007c10:	e59d3004 	ldr	r3, [sp, #4]
30007c14:	e5832028 	str	r2, [r3, #40]	; 0x28
30007c18:	e59d3004 	ldr	r3, [sp, #4]
30007c1c:	e2832028 	add	r2, r3, #40	; 0x28
30007c20:	e59d3004 	ldr	r3, [sp, #4]
30007c24:	e583202c 	str	r2, [r3, #44]	; 0x2c
	acoral_init_list(&msgctr->waiting);
30007c28:	e59d3004 	ldr	r3, [sp, #4]
30007c2c:	e2832020 	add	r2, r3, #32
30007c30:	e59d3004 	ldr	r3, [sp, #4]
30007c34:	e5832020 	str	r2, [r3, #32]
30007c38:	e59d3004 	ldr	r3, [sp, #4]
30007c3c:	e2832020 	add	r2, r3, #32
30007c40:	e59d3004 	ldr	r3, [sp, #4]
30007c44:	e5832024 	str	r2, [r3, #36]	; 0x24
	acoral_init_list(&msgctr->msgctr_list);
30007c48:	e59d3004 	ldr	r3, [sp, #4]
30007c4c:	e283200c 	add	r2, r3, #12
30007c50:	e59d3004 	ldr	r3, [sp, #4]
30007c54:	e583200c 	str	r2, [r3, #12]
30007c58:	e59d3004 	ldr	r3, [sp, #4]
30007c5c:	e283200c 	add	r2, r3, #12
30007c60:	e59d3004 	ldr	r3, [sp, #4]
30007c64:	e5832010 	str	r2, [r3, #16]
	acoral_spin_init(&msgctr->spin_lock);
	return MSGCTR_SUCCED;
30007c68:	e3a03004 	mov	r3, #4
}
30007c6c:	e1a00003 	mov	r0, r3
30007c70:	e28dd008 	add	sp, sp, #8
30007c74:	e12fff1e 	bx	lr

30007c78 <acoral_msg_init>:

acoral_u32 acoral_msg_init(
		acoral_msg_t *msg, acoral_u32 id /*= 0*/, acoral_u32 n /*= 0*/, 
		acoral_u32  nTtl /*= 0*/, void* dat /*= NULL*/)
{
30007c78:	e24dd010 	sub	sp, sp, #16
30007c7c:	e58d000c 	str	r0, [sp, #12]
30007c80:	e58d1008 	str	r1, [sp, #8]
30007c84:	e58d2004 	str	r2, [sp, #4]
30007c88:	e58d3000 	str	r3, [sp]
	if (msg == NULL)
30007c8c:	e59d300c 	ldr	r3, [sp, #12]
30007c90:	e3530000 	cmp	r3, #0
30007c94:	1a000001 	bne	30007ca0 <acoral_msg_init+0x28>
		return MSG_ERR_NULL;
30007c98:	e3a03007 	mov	r3, #7
30007c9c:	ea000014 	b	30007cf4 <acoral_msg_init+0x7c>

	msg->id   =  id;                /*消息标识*/
30007ca0:	e59d300c 	ldr	r3, [sp, #12]
30007ca4:	e59d2008 	ldr	r2, [sp, #8]
30007ca8:	e583200c 	str	r2, [r3, #12]
	msg->n    =  n;                 /*消息被接收次数*/
30007cac:	e59d300c 	ldr	r3, [sp, #12]
30007cb0:	e59d2004 	ldr	r2, [sp, #4]
30007cb4:	e5832010 	str	r2, [r3, #16]
	msg->ttl  =  nTtl;              /*消息生存周期*/
30007cb8:	e59d300c 	ldr	r3, [sp, #12]
30007cbc:	e59d2000 	ldr	r2, [sp]
30007cc0:	e5832014 	str	r2, [r3, #20]
	msg->data =  dat;               /*消息指针*/
30007cc4:	e59d300c 	ldr	r3, [sp, #12]
30007cc8:	e59d2010 	ldr	r2, [sp, #16]
30007ccc:	e5832018 	str	r2, [r3, #24]
	acoral_init_list(&msg->msglist);
30007cd0:	e59d300c 	ldr	r3, [sp, #12]
30007cd4:	e2832004 	add	r2, r3, #4
30007cd8:	e59d300c 	ldr	r3, [sp, #12]
30007cdc:	e5832004 	str	r2, [r3, #4]
30007ce0:	e59d300c 	ldr	r3, [sp, #12]
30007ce4:	e2832004 	add	r2, r3, #4
30007ce8:	e59d300c 	ldr	r3, [sp, #12]
30007cec:	e5832008 	str	r2, [r3, #8]
	acoral_spin_init(&(msg->msglist.lock));
	return 0;
30007cf0:	e3a03000 	mov	r3, #0
}
30007cf4:	e1a00003 	mov	r0, r3
30007cf8:	e28dd010 	add	sp, sp, #16
30007cfc:	e12fff1e 	bx	lr

30007d00 <acoral_msg_assign>:

acoral_32 acoral_msg_assign(
		acoral_msg_t* msg, void* dat, acoral_u32 id,
		acoral_u32 nTtl, acoral_u32 n)
{
30007d00:	e24dd010 	sub	sp, sp, #16
30007d04:	e58d000c 	str	r0, [sp, #12]
30007d08:	e58d1008 	str	r1, [sp, #8]
30007d0c:	e58d2004 	str	r2, [sp, #4]
30007d10:	e58d3000 	str	r3, [sp]
	if (msg == NULL)
30007d14:	e59d300c 	ldr	r3, [sp, #12]
30007d18:	e3530000 	cmp	r3, #0
30007d1c:	1a000001 	bne	30007d28 <acoral_msg_assign+0x28>
		return MSG_ERR_NULL;
30007d20:	e3a03007 	mov	r3, #7
30007d24:	ea00000c 	b	30007d5c <acoral_msg_assign+0x5c>

	msg->id   =  id;                /*消息标识*/
30007d28:	e59d300c 	ldr	r3, [sp, #12]
30007d2c:	e59d2004 	ldr	r2, [sp, #4]
30007d30:	e583200c 	str	r2, [r3, #12]
	msg->n    =  n;                 /*消息被接收次数*/
30007d34:	e59d300c 	ldr	r3, [sp, #12]
30007d38:	e59d2010 	ldr	r2, [sp, #16]
30007d3c:	e5832010 	str	r2, [r3, #16]
	msg->ttl  =  nTtl;              /*消息生存周期*/
30007d40:	e59d300c 	ldr	r3, [sp, #12]
30007d44:	e59d2000 	ldr	r2, [sp]
30007d48:	e5832014 	str	r2, [r3, #20]
	msg->data =  dat;               /*消息指针*/
30007d4c:	e59d300c 	ldr	r3, [sp, #12]
30007d50:	e59d2008 	ldr	r2, [sp, #8]
30007d54:	e5832018 	str	r2, [r3, #24]
	return 0;
30007d58:	e3a03000 	mov	r3, #0
}
30007d5c:	e1a00003 	mov	r0, r3
30007d60:	e28dd010 	add	sp, sp, #16
30007d64:	e12fff1e 	bx	lr

30007d68 <acoral_msgctr_create>:
/*==================================
 *
 *   消息创建
 *==================================*/
acoral_msgctr_t*  acoral_msgctr_create (acoral_u32 *err)
{
30007d68:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007d6c:	e24dd014 	sub	sp, sp, #20
30007d70:	e58d0004 	str	r0, [sp, #4]
	acoral_msgctr_t *msgctr;

	msgctr = acoral_alloc_msgctr();
30007d74:	ebffff4b 	bl	30007aa8 <acoral_alloc_msgctr>
30007d78:	e1a03000 	mov	r3, r0
30007d7c:	e58d300c 	str	r3, [sp, #12]

	if (msgctr == NULL)
30007d80:	e59d300c 	ldr	r3, [sp, #12]
30007d84:	e3530000 	cmp	r3, #0
30007d88:	1a000001 	bne	30007d94 <acoral_msgctr_create+0x2c>
		return NULL;
30007d8c:	e3a03000 	mov	r3, #0
30007d90:	ea000029 	b	30007e3c <acoral_msgctr_create+0xd4>

	msgctr->name  = NULL;
30007d94:	e59d300c 	ldr	r3, [sp, #12]
30007d98:	e3a02000 	mov	r2, #0
30007d9c:	e5832004 	str	r2, [r3, #4]
	msgctr->type  = ACORAL_MSGCTR;
30007da0:	e59d300c 	ldr	r3, [sp, #12]
30007da4:	e3a02001 	mov	r2, #1
30007da8:	e5c32008 	strb	r2, [r3, #8]
	msgctr->count = 0;
30007dac:	e59d300c 	ldr	r3, [sp, #12]
30007db0:	e3a02000 	mov	r2, #0
30007db4:	e5832018 	str	r2, [r3, #24]
	msgctr->wait_thread_num = 0;
30007db8:	e59d300c 	ldr	r3, [sp, #12]
30007dbc:	e3a02000 	mov	r2, #0
30007dc0:	e583201c 	str	r2, [r3, #28]

	acoral_init_list(&msgctr->msgctr_list);
30007dc4:	e59d300c 	ldr	r3, [sp, #12]
30007dc8:	e283200c 	add	r2, r3, #12
30007dcc:	e59d300c 	ldr	r3, [sp, #12]
30007dd0:	e583200c 	str	r2, [r3, #12]
30007dd4:	e59d300c 	ldr	r3, [sp, #12]
30007dd8:	e283200c 	add	r2, r3, #12
30007ddc:	e59d300c 	ldr	r3, [sp, #12]
30007de0:	e5832010 	str	r2, [r3, #16]
	acoral_init_list(&msgctr->msglist);
30007de4:	e59d300c 	ldr	r3, [sp, #12]
30007de8:	e2832028 	add	r2, r3, #40	; 0x28
30007dec:	e59d300c 	ldr	r3, [sp, #12]
30007df0:	e5832028 	str	r2, [r3, #40]	; 0x28
30007df4:	e59d300c 	ldr	r3, [sp, #12]
30007df8:	e2832028 	add	r2, r3, #40	; 0x28
30007dfc:	e59d300c 	ldr	r3, [sp, #12]
30007e00:	e583202c 	str	r2, [r3, #44]	; 0x2c
	acoral_init_list(&msgctr->waiting);
30007e04:	e59d300c 	ldr	r3, [sp, #12]
30007e08:	e2832020 	add	r2, r3, #32
30007e0c:	e59d300c 	ldr	r3, [sp, #12]
30007e10:	e5832020 	str	r2, [r3, #32]
30007e14:	e59d300c 	ldr	r3, [sp, #12]
30007e18:	e2832020 	add	r2, r3, #32
30007e1c:	e59d300c 	ldr	r3, [sp, #12]
30007e20:	e5832024 	str	r2, [r3, #36]	; 0x24
	acoral_spin_init(&(msgctr->msgctr_list.lock));
	acoral_spin_init(&(msgctr->msglist.lock));
	acoral_spin_init(&(msgctr->waiting.lock));

	acoral_spin_init(&msgctr->spin_lock);
	acoral_list_add2_tail (&msgctr->msgctr_list, &(g_msgctr_header.head));
30007e24:	e59d300c 	ldr	r3, [sp, #12]
30007e28:	e283300c 	add	r3, r3, #12
30007e2c:	e1a00003 	mov	r0, r3
30007e30:	e59f1014 	ldr	r1, [pc, #20]	; 30007e4c <acoral_msgctr_create+0xe4>
30007e34:	eb00086f 	bl	30009ff8 <acoral_list_add2_tail>
	return msgctr;
30007e38:	e59d300c 	ldr	r3, [sp, #12]
}
30007e3c:	e1a00003 	mov	r0, r3
30007e40:	e28dd014 	add	sp, sp, #20
30007e44:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007e48:	e12fff1e 	bx	lr
30007e4c:	300ea328 	.word	0x300ea328

30007e50 <acoral_msg_create>:

acoral_msg_t* acoral_msg_create (
		acoral_u32 n, acoral_u32 *err, acoral_u32 id, 
		acoral_u32 nTtl/* = 0*/, void* dat /*= NULL*/)
{
30007e50:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30007e54:	e24dd01c 	sub	sp, sp, #28
30007e58:	e58d000c 	str	r0, [sp, #12]
30007e5c:	e58d1008 	str	r1, [sp, #8]
30007e60:	e58d2004 	str	r2, [sp, #4]
30007e64:	e58d3000 	str	r3, [sp]
	acoral_msg_t *msg;

	msg = acoral_alloc_msg();
30007e68:	ebffff16 	bl	30007ac8 <acoral_alloc_msg>
30007e6c:	e1a03000 	mov	r3, r0
30007e70:	e58d3014 	str	r3, [sp, #20]

	if (msg == NULL)
30007e74:	e59d3014 	ldr	r3, [sp, #20]
30007e78:	e3530000 	cmp	r3, #0
30007e7c:	1a000001 	bne	30007e88 <acoral_msg_create+0x38>
		return NULL;
30007e80:	e3a03000 	mov	r3, #0
30007e84:	ea000014 	b	30007edc <acoral_msg_create+0x8c>

	msg->id   =  id;                 /*消息标识*/
30007e88:	e59d3014 	ldr	r3, [sp, #20]
30007e8c:	e59d2004 	ldr	r2, [sp, #4]
30007e90:	e583200c 	str	r2, [r3, #12]
	msg->n    =  n;                  /*消息被接收次数*/
30007e94:	e59d3014 	ldr	r3, [sp, #20]
30007e98:	e59d200c 	ldr	r2, [sp, #12]
30007e9c:	e5832010 	str	r2, [r3, #16]
	msg->ttl  =  nTtl;               /*消息生存周期*/
30007ea0:	e59d3014 	ldr	r3, [sp, #20]
30007ea4:	e59d2000 	ldr	r2, [sp]
30007ea8:	e5832014 	str	r2, [r3, #20]
	msg->data =  dat;                /*消息指针*/
30007eac:	e59d3014 	ldr	r3, [sp, #20]
30007eb0:	e59d2020 	ldr	r2, [sp, #32]
30007eb4:	e5832018 	str	r2, [r3, #24]
	acoral_init_list(&msg->msglist);
30007eb8:	e59d3014 	ldr	r3, [sp, #20]
30007ebc:	e2832004 	add	r2, r3, #4
30007ec0:	e59d3014 	ldr	r3, [sp, #20]
30007ec4:	e5832004 	str	r2, [r3, #4]
30007ec8:	e59d3014 	ldr	r3, [sp, #20]
30007ecc:	e2832004 	add	r2, r3, #4
30007ed0:	e59d3014 	ldr	r3, [sp, #20]
30007ed4:	e5832008 	str	r2, [r3, #8]
	return msg;
30007ed8:	e59d3014 	ldr	r3, [sp, #20]
}
30007edc:	e1a00003 	mov	r0, r3
30007ee0:	e28dd01c 	add	sp, sp, #28
30007ee4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30007ee8:	e12fff1e 	bx	lr

30007eec <acoral_msg_send>:
/*===================================
 * 
 *   消息发送
 *===================================*/
acoral_u32 acoral_msg_send(acoral_msgctr_t* msgctr, acoral_msg_t* msg)
{
30007eec:	e92d4010 	push	{r4, lr}
30007ef0:	e24dd010 	sub	sp, sp, #16
30007ef4:	e58d0004 	str	r0, [sp, #4]
30007ef8:	e58d1000 	str	r1, [sp]
	acoral_sr     cpu_sr;
	
/*	if (acoral_intr_nesting > 0)
		return MST_ERR_INTR;
*/
	HAL_ENTER_CRITICAL();
30007efc:	ebffe5fc 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30007f00:	e1a03000 	mov	r3, r0
30007f04:	e58d300c 	str	r3, [sp, #12]
	acoral_spin_lock(&msgctr->spin_lock);

	if (NULL == msgctr)
30007f08:	e59d3004 	ldr	r3, [sp, #4]
30007f0c:	e3530000 	cmp	r3, #0
30007f10:	1a000003 	bne	30007f24 <acoral_msg_send+0x38>
	{
		acoral_spin_unlock(&msgctr->spin_lock);
		HAL_EXIT_CRITICAL();
30007f14:	e59d000c 	ldr	r0, [sp, #12]
30007f18:	ebffe5f3 	bl	300016ec <HAL_INTR_RESTORE>
		return MST_ERR_NULL;
30007f1c:	e3a03000 	mov	r3, #0
30007f20:	ea000032 	b	30007ff0 <acoral_msg_send+0x104>
	}

	if (NULL == msg)
30007f24:	e59d3000 	ldr	r3, [sp]
30007f28:	e3530000 	cmp	r3, #0
30007f2c:	1a000003 	bne	30007f40 <acoral_msg_send+0x54>
	{
		acoral_spin_unlock(&msgctr->spin_lock);
		HAL_EXIT_CRITICAL();
30007f30:	e59d000c 	ldr	r0, [sp, #12]
30007f34:	ebffe5ec 	bl	300016ec <HAL_INTR_RESTORE>
		return MSG_ERR_NULL;
30007f38:	e3a03007 	mov	r3, #7
30007f3c:	ea00002b 	b	30007ff0 <acoral_msg_send+0x104>
	}

	/*----------------*/
	/*   消息数限制*/
	/*----------------*/
	if (ACORAL_MESSAGE_MAX_COUNT <= msgctr->count)
30007f40:	e59d3004 	ldr	r3, [sp, #4]
30007f44:	e5933018 	ldr	r3, [r3, #24]
30007f48:	e3530009 	cmp	r3, #9
30007f4c:	9a000003 	bls	30007f60 <acoral_msg_send+0x74>
	{
		acoral_spin_unlock(&msgctr->spin_lock);
		HAL_EXIT_CRITICAL();
30007f50:	e59d000c 	ldr	r0, [sp, #12]
30007f54:	ebffe5e4 	bl	300016ec <HAL_INTR_RESTORE>
		return MSG_ERR_COUNT;
30007f58:	e3a03003 	mov	r3, #3
30007f5c:	ea000023 	b	30007ff0 <acoral_msg_send+0x104>
	}

	/*----------------*/
	/*   增加消息*/
	/*----------------*/
	msgctr->count++;
30007f60:	e59d3004 	ldr	r3, [sp, #4]
30007f64:	e5933018 	ldr	r3, [r3, #24]
30007f68:	e2832001 	add	r2, r3, #1
30007f6c:	e59d3004 	ldr	r3, [sp, #4]
30007f70:	e5832018 	str	r2, [r3, #24]
	msg->ttl += acoral_get_ticks();
30007f74:	e59d3000 	ldr	r3, [sp]
30007f78:	e5934014 	ldr	r4, [r3, #20]
30007f7c:	ebfff166 	bl	3000451c <acoral_get_ticks>
30007f80:	e1a03000 	mov	r3, r0
30007f84:	e0842003 	add	r2, r4, r3
30007f88:	e59d3000 	ldr	r3, [sp]
30007f8c:	e5832014 	str	r2, [r3, #20]
	acoral_list_add2_tail(&msg->msglist, &msgctr->msglist);
30007f90:	e59d3000 	ldr	r3, [sp]
30007f94:	e2832004 	add	r2, r3, #4
30007f98:	e59d3004 	ldr	r3, [sp, #4]
30007f9c:	e2833028 	add	r3, r3, #40	; 0x28
30007fa0:	e1a00002 	mov	r0, r2
30007fa4:	e1a01003 	mov	r1, r3
30007fa8:	eb000812 	bl	30009ff8 <acoral_list_add2_tail>

	/*----------------*/
	/*   唤醒等待*/
	/*----------------*/
	if (msgctr->wait_thread_num > 0)
30007fac:	e59d3004 	ldr	r3, [sp, #4]
30007fb0:	e593301c 	ldr	r3, [r3, #28]
30007fb4:	e3530000 	cmp	r3, #0
30007fb8:	0a000008 	beq	30007fe0 <acoral_msg_send+0xf4>
	{
		/* 此处将最高优先级唤醒*/
		wake_up_thread(&msgctr->waiting);
30007fbc:	e59d3004 	ldr	r3, [sp, #4]
30007fc0:	e2833020 	add	r3, r3, #32
30007fc4:	e1a00003 	mov	r0, r3
30007fc8:	eb000103 	bl	300083dc <wake_up_thread>
		msgctr->wait_thread_num--;
30007fcc:	e59d3004 	ldr	r3, [sp, #4]
30007fd0:	e593301c 	ldr	r3, [r3, #28]
30007fd4:	e2432001 	sub	r2, r3, #1
30007fd8:	e59d3004 	ldr	r3, [sp, #4]
30007fdc:	e583201c 	str	r2, [r3, #28]
	}
	acoral_spin_unlock(&msgctr->spin_lock);
	HAL_EXIT_CRITICAL();
30007fe0:	e59d000c 	ldr	r0, [sp, #12]
30007fe4:	ebffe5c0 	bl	300016ec <HAL_INTR_RESTORE>
	acoral_sched();
30007fe8:	ebffe90c 	bl	30002420 <acoral_sched>
	return MSGCTR_SUCCED;
30007fec:	e3a03004 	mov	r3, #4
}
30007ff0:	e1a00003 	mov	r0, r3
30007ff4:	e28dd010 	add	sp, sp, #16
30007ff8:	e8bd4010 	pop	{r4, lr}
30007ffc:	e12fff1e 	bx	lr

30008000 <acoral_msg_recv>:
 *===================================*/
void* acoral_msg_recv (acoral_msgctr_t* msgctr,
						acoral_u32  id,
						acoral_time  timeout,
						acoral_u32  *err)
{
30008000:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008004:	e24dd02c 	sub	sp, sp, #44	; 0x2c
30008008:	e58d000c 	str	r0, [sp, #12]
3000800c:	e58d1008 	str	r1, [sp, #8]
30008010:	e58d2004 	str	r2, [sp, #4]
30008014:	e58d3000 	str	r3, [sp]
	acoral_sr        cpu_sr;
	acoral_list_t    *p, *q;
	acoral_msg_t     *pmsg;
	acoral_thread_t  *cur;

	if (acoral_intr_nesting > 0)
30008018:	ebffe5d0 	bl	30001760 <hal_get_intr_nesting_comm>
3000801c:	e1a03000 	mov	r3, r0
30008020:	e3530000 	cmp	r3, #0
30008024:	da000004 	ble	3000803c <acoral_msg_recv+0x3c>
	{
		*err = MST_ERR_INTR;
30008028:	e59d3000 	ldr	r3, [sp]
3000802c:	e3a02001 	mov	r2, #1
30008030:	e5832000 	str	r2, [r3]
		return NULL;
30008034:	e3a03000 	mov	r3, #0
30008038:	ea000080 	b	30008240 <acoral_msg_recv+0x240>
	}
	if (NULL == msgctr)
3000803c:	e59d300c 	ldr	r3, [sp, #12]
30008040:	e3530000 	cmp	r3, #0
30008044:	1a000004 	bne	3000805c <acoral_msg_recv+0x5c>
	{
		*err = MST_ERR_NULL;
30008048:	e59d3000 	ldr	r3, [sp]
3000804c:	e3a02000 	mov	r2, #0
30008050:	e5832000 	str	r2, [r3]
		return NULL;
30008054:	e3a03000 	mov	r3, #0
30008058:	ea000078 	b	30008240 <acoral_msg_recv+0x240>
	}

	cur = acoral_cur_thread;
3000805c:	e59f31ec 	ldr	r3, [pc, #492]	; 30008250 <acoral_msg_recv+0x250>
30008060:	e5933000 	ldr	r3, [r3]
30008064:	e58d3024 	str	r3, [sp, #36]	; 0x24

	HAL_ENTER_CRITICAL();
30008068:	ebffe5a1 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000806c:	e1a03000 	mov	r3, r0
30008070:	e58d3014 	str	r3, [sp, #20]
	acoral_spin_lock(&msgctr->spin_lock);
	if(timeout>0){
30008074:	e59d3004 	ldr	r3, [sp, #4]
30008078:	e3530000 	cmp	r3, #0
3000807c:	0a000013 	beq	300080d0 <acoral_msg_recv+0xd0>
		cur->delay = TIME_TO_TICKS(timeout);
30008080:	e59d2004 	ldr	r2, [sp, #4]
30008084:	e1a03002 	mov	r3, r2
30008088:	e1a03103 	lsl	r3, r3, #2
3000808c:	e0833002 	add	r3, r3, r2
30008090:	e1a02103 	lsl	r2, r3, #2
30008094:	e0833002 	add	r3, r3, r2
30008098:	e1a03103 	lsl	r3, r3, #2
3000809c:	e1a02003 	mov	r2, r3
300080a0:	e59f31ac 	ldr	r3, [pc, #428]	; 30008254 <acoral_msg_recv+0x254>
300080a4:	e0831392 	umull	r1, r3, r2, r3
300080a8:	e1a03323 	lsr	r3, r3, #6
300080ac:	e1a02003 	mov	r2, r3
300080b0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300080b4:	e5832040 	str	r2, [r3, #64]	; 0x40
		timeout_queue_add( cur);
300080b8:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
300080bc:	ebfff1d5 	bl	30004818 <timeout_queue_add>
300080c0:	ea000002 	b	300080d0 <acoral_msg_recv+0xd0>
		acoral_spin_lock(&msgctr->spin_lock);
	
		if (timeout>0&&(acoral_32)cur->delay <=0 )
			break;

	}
300080c4:	e1a00000 	nop			; (mov r0, r0)
300080c8:	ea000000 	b	300080d0 <acoral_msg_recv+0xd0>
300080cc:	e1a00000 	nop			; (mov r0, r0)
		cur->delay = TIME_TO_TICKS(timeout);
		timeout_queue_add( cur);
	}
	while(1)
	{
		p = &msgctr->msglist;
300080d0:	e59d300c 	ldr	r3, [sp, #12]
300080d4:	e2833028 	add	r3, r3, #40	; 0x28
300080d8:	e58d3018 	str	r3, [sp, #24]
		q = p->next;
300080dc:	e59d3018 	ldr	r3, [sp, #24]
300080e0:	e5933000 	ldr	r3, [r3]
300080e4:	e58d301c 	str	r3, [sp, #28]
		for( ;p != q; q = q->next)
300080e8:	ea000026 	b	30008188 <acoral_msg_recv+0x188>
		{
			pmsg = list_entry( q, acoral_msg_t, msglist);
300080ec:	e59d301c 	ldr	r3, [sp, #28]
300080f0:	e2433004 	sub	r3, r3, #4
300080f4:	e58d3020 	str	r3, [sp, #32]
			if ( (pmsg->id == id) && (pmsg->n > 0))
300080f8:	e59d3020 	ldr	r3, [sp, #32]
300080fc:	e593200c 	ldr	r2, [r3, #12]
30008100:	e59d3008 	ldr	r3, [sp, #8]
30008104:	e1520003 	cmp	r2, r3
30008108:	1a00001b 	bne	3000817c <acoral_msg_recv+0x17c>
3000810c:	e59d3020 	ldr	r3, [sp, #32]
30008110:	e5933010 	ldr	r3, [r3, #16]
30008114:	e3530000 	cmp	r3, #0
30008118:	0a000017 	beq	3000817c <acoral_msg_recv+0x17c>
			{
				/*-----------------*/
				/* 有接收消息*/
				/*-----------------*/
				pmsg->n--;
3000811c:	e59d3020 	ldr	r3, [sp, #32]
30008120:	e5933010 	ldr	r3, [r3, #16]
30008124:	e2432001 	sub	r2, r3, #1
30008128:	e59d3020 	ldr	r3, [sp, #32]
3000812c:	e5832010 	str	r2, [r3, #16]
				/*-----------------*/
				/* 延时列表删除*/
				/*-----------------*/
				timeout_queue_del(cur);
30008130:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
30008134:	ebfff1f9 	bl	30004920 <timeout_queue_del>
				dat = pmsg->data;
30008138:	e59d3020 	ldr	r3, [sp, #32]
3000813c:	e5933018 	ldr	r3, [r3, #24]
30008140:	e58d3010 	str	r3, [sp, #16]
				acoral_list_del (q);
30008144:	e59d001c 	ldr	r0, [sp, #28]
30008148:	eb0007bd 	bl	3000a044 <acoral_list_del>
				acoral_release_res ((acoral_res_t *)pmsg);		
3000814c:	e59d3020 	ldr	r3, [sp, #32]
30008150:	e1a00003 	mov	r0, r3
30008154:	ebffed37 	bl	30003638 <acoral_release_res>
				msgctr->count--;
30008158:	e59d300c 	ldr	r3, [sp, #12]
3000815c:	e5933018 	ldr	r3, [r3, #24]
30008160:	e2432001 	sub	r2, r3, #1
30008164:	e59d300c 	ldr	r3, [sp, #12]
30008168:	e5832018 	str	r2, [r3, #24]
				acoral_spin_unlock(&msgctr->spin_lock);
				HAL_EXIT_CRITICAL();
3000816c:	e59d0014 	ldr	r0, [sp, #20]
30008170:	ebffe55d 	bl	300016ec <HAL_INTR_RESTORE>
				return dat;
30008174:	e59d3010 	ldr	r3, [sp, #16]
30008178:	ea000030 	b	30008240 <acoral_msg_recv+0x240>
	}
	while(1)
	{
		p = &msgctr->msglist;
		q = p->next;
		for( ;p != q; q = q->next)
3000817c:	e59d301c 	ldr	r3, [sp, #28]
30008180:	e5933000 	ldr	r3, [r3]
30008184:	e58d301c 	str	r3, [sp, #28]
30008188:	e59d2018 	ldr	r2, [sp, #24]
3000818c:	e59d301c 	ldr	r3, [sp, #28]
30008190:	e1520003 	cmp	r2, r3
30008194:	1affffd4 	bne	300080ec <acoral_msg_recv+0xec>
		}
	
		/*-----------------*/
		/*  没有接收消息*/
		/*-----------------*/
		msgctr->wait_thread_num++;
30008198:	e59d300c 	ldr	r3, [sp, #12]
3000819c:	e593301c 	ldr	r3, [r3, #28]
300081a0:	e2832001 	add	r2, r3, #1
300081a4:	e59d300c 	ldr	r3, [sp, #12]
300081a8:	e583201c 	str	r2, [r3, #28]
		acoral_msgctr_queue_add(msgctr, cur);
300081ac:	e59d000c 	ldr	r0, [sp, #12]
300081b0:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
300081b4:	ebfffe4b 	bl	30007ae8 <acoral_msgctr_queue_add>
		acoral_unrdy_thread(cur);
300081b8:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
300081bc:	ebffea80 	bl	30002bc4 <acoral_unrdy_thread>
		acoral_spin_unlock(&msgctr->spin_lock);
		HAL_EXIT_CRITICAL();
300081c0:	e59d0014 	ldr	r0, [sp, #20]
300081c4:	ebffe548 	bl	300016ec <HAL_INTR_RESTORE>
		acoral_sched();
300081c8:	ebffe894 	bl	30002420 <acoral_sched>
		/*-----------------*/
		/*  看有没有超时*/
		/*-----------------*/
		HAL_ENTER_CRITICAL();
300081cc:	ebffe548 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300081d0:	e1a03000 	mov	r3, r0
300081d4:	e58d3014 	str	r3, [sp, #20]
		acoral_spin_lock(&msgctr->spin_lock);
	
		if (timeout>0&&(acoral_32)cur->delay <=0 )
300081d8:	e59d3004 	ldr	r3, [sp, #4]
300081dc:	e3530000 	cmp	r3, #0
300081e0:	0affffb7 	beq	300080c4 <acoral_msg_recv+0xc4>
300081e4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300081e8:	e5933040 	ldr	r3, [r3, #64]	; 0x40
300081ec:	e3530000 	cmp	r3, #0
300081f0:	caffffb5 	bgt	300080cc <acoral_msg_recv+0xcc>

	/*---------------*/
	/*  超时退出*/
	/*---------------*/
//	timeout_queue_del(cur);
	if(msgctr->wait_thread_num>0)
300081f4:	e59d300c 	ldr	r3, [sp, #12]
300081f8:	e593301c 	ldr	r3, [r3, #28]
300081fc:	e3530000 	cmp	r3, #0
30008200:	0a000004 	beq	30008218 <acoral_msg_recv+0x218>
		msgctr->wait_thread_num--;
30008204:	e59d300c 	ldr	r3, [sp, #12]
30008208:	e593301c 	ldr	r3, [r3, #28]
3000820c:	e2432001 	sub	r2, r3, #1
30008210:	e59d300c 	ldr	r3, [sp, #12]
30008214:	e583201c 	str	r2, [r3, #28]
	acoral_list_del(&cur->waiting);
30008218:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3000821c:	e2833020 	add	r3, r3, #32
30008220:	e1a00003 	mov	r0, r3
30008224:	eb000786 	bl	3000a044 <acoral_list_del>
	acoral_spin_unlock(&msgctr->spin_lock);
	HAL_EXIT_CRITICAL();
30008228:	e59d0014 	ldr	r0, [sp, #20]
3000822c:	ebffe52e 	bl	300016ec <HAL_INTR_RESTORE>
	*err = MST_ERR_TIMEOUT;
30008230:	e59d3000 	ldr	r3, [sp]
30008234:	e3a02002 	mov	r2, #2
30008238:	e5832000 	str	r2, [r3]
	return NULL;
3000823c:	e3a03000 	mov	r3, #0

}
30008240:	e1a00003 	mov	r0, r3
30008244:	e28dd02c 	add	sp, sp, #44	; 0x2c
30008248:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000824c:	e12fff1e 	bx	lr
30008250:	302be818 	.word	0x302be818
30008254:	10624dd3 	.word	0x10624dd3

30008258 <acoral_msgctr_del>:
/*===================================
 *
 *  消息删除
 *===================================*/
acoral_u32 acoral_msgctr_del(acoral_msgctr_t* pmsgctr, acoral_u32 flag)
{
30008258:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000825c:	e24dd01c 	sub	sp, sp, #28
30008260:	e58d0004 	str	r0, [sp, #4]
30008264:	e58d1000 	str	r1, [sp]
	acoral_list_t    *p, *q;
	acoral_thread_t  *thread;
	acoral_msg_t     *pmsg;
	
	if(NULL == pmsgctr)
30008268:	e59d3004 	ldr	r3, [sp, #4]
3000826c:	e3530000 	cmp	r3, #0
30008270:	1a000001 	bne	3000827c <acoral_msgctr_del+0x24>
		return MST_ERR_NULL;
30008274:	e3a03000 	mov	r3, #0
30008278:	ea000045 	b	30008394 <acoral_msgctr_del+0x13c>
	if (flag == MST_DEL_UNFORCE)
3000827c:	e59d3000 	ldr	r3, [sp]
30008280:	e3530000 	cmp	r3, #0
30008284:	1a00000d 	bne	300082c0 <acoral_msgctr_del+0x68>
	{
		if ((pmsgctr->count > 0) || (pmsgctr->wait_thread_num > 0))
30008288:	e59d3004 	ldr	r3, [sp, #4]
3000828c:	e5933018 	ldr	r3, [r3, #24]
30008290:	e3530000 	cmp	r3, #0
30008294:	1a000003 	bne	300082a8 <acoral_msgctr_del+0x50>
30008298:	e59d3004 	ldr	r3, [sp, #4]
3000829c:	e593301c 	ldr	r3, [r3, #28]
300082a0:	e3530000 	cmp	r3, #0
300082a4:	0a000001 	beq	300082b0 <acoral_msgctr_del+0x58>
			return MST_ERR_UNDEF;
300082a8:	e3a03003 	mov	r3, #3
300082ac:	ea000038 	b	30008394 <acoral_msgctr_del+0x13c>
		else
			acoral_release_res((acoral_res_t *)pmsgctr);
300082b0:	e59d3004 	ldr	r3, [sp, #4]
300082b4:	e1a00003 	mov	r0, r3
300082b8:	ebffecde 	bl	30003638 <acoral_release_res>
300082bc:	ea000033 	b	30008390 <acoral_msgctr_del+0x138>
	}
	else
	{
		// 释放等待进程
		if (pmsgctr->wait_thread_num > 0)
300082c0:	e59d3004 	ldr	r3, [sp, #4]
300082c4:	e593301c 	ldr	r3, [r3, #28]
300082c8:	e3530000 	cmp	r3, #0
300082cc:	0a000012 	beq	3000831c <acoral_msgctr_del+0xc4>
		{
			p = &pmsgctr->waiting;
300082d0:	e59d3004 	ldr	r3, [sp, #4]
300082d4:	e2833020 	add	r3, r3, #32
300082d8:	e58d3008 	str	r3, [sp, #8]
			q = p->next;
300082dc:	e59d3008 	ldr	r3, [sp, #8]
300082e0:	e5933000 	ldr	r3, [r3]
300082e4:	e58d300c 	str	r3, [sp, #12]
			for(; q != p; q = q->next)
300082e8:	ea000007 	b	3000830c <acoral_msgctr_del+0xb4>
			{
				thread=list_entry( q, acoral_thread_t, waiting);
300082ec:	e59d300c 	ldr	r3, [sp, #12]
300082f0:	e2433020 	sub	r3, r3, #32
300082f4:	e58d3010 	str	r3, [sp, #16]
				//acoral_list_del  (&thread->waiting);
				acoral_rdy_thread(thread);
300082f8:	e59d0010 	ldr	r0, [sp, #16]
300082fc:	ebffea21 	bl	30002b88 <acoral_rdy_thread>
		// 释放等待进程
		if (pmsgctr->wait_thread_num > 0)
		{
			p = &pmsgctr->waiting;
			q = p->next;
			for(; q != p; q = q->next)
30008300:	e59d300c 	ldr	r3, [sp, #12]
30008304:	e5933000 	ldr	r3, [r3]
30008308:	e58d300c 	str	r3, [sp, #12]
3000830c:	e59d200c 	ldr	r2, [sp, #12]
30008310:	e59d3008 	ldr	r3, [sp, #8]
30008314:	e1520003 	cmp	r2, r3
30008318:	1afffff3 	bne	300082ec <acoral_msgctr_del+0x94>
				acoral_rdy_thread(thread);
			}
		}
		
		// 释放消息结构
		if (pmsgctr->count > 0)
3000831c:	e59d3004 	ldr	r3, [sp, #4]
30008320:	e5933018 	ldr	r3, [r3, #24]
30008324:	e3530000 	cmp	r3, #0
30008328:	0a000015 	beq	30008384 <acoral_msgctr_del+0x12c>
		{
			p = &pmsgctr->msglist;
3000832c:	e59d3004 	ldr	r3, [sp, #4]
30008330:	e2833028 	add	r3, r3, #40	; 0x28
30008334:	e58d3008 	str	r3, [sp, #8]
			q = p->next;
30008338:	e59d3008 	ldr	r3, [sp, #8]
3000833c:	e5933000 	ldr	r3, [r3]
30008340:	e58d300c 	str	r3, [sp, #12]
			for( ;p != q; q = p->next)
30008344:	ea00000a 	b	30008374 <acoral_msgctr_del+0x11c>
			{
				pmsg = list_entry( q, acoral_msg_t, msglist);
30008348:	e59d300c 	ldr	r3, [sp, #12]
3000834c:	e2433004 	sub	r3, r3, #4
30008350:	e58d3014 	str	r3, [sp, #20]
				acoral_list_del (q);
30008354:	e59d000c 	ldr	r0, [sp, #12]
30008358:	eb000739 	bl	3000a044 <acoral_list_del>
				acoral_release_res ((acoral_res_t *)pmsg);		
3000835c:	e59d3014 	ldr	r3, [sp, #20]
30008360:	e1a00003 	mov	r0, r3
30008364:	ebffecb3 	bl	30003638 <acoral_release_res>
		// 释放消息结构
		if (pmsgctr->count > 0)
		{
			p = &pmsgctr->msglist;
			q = p->next;
			for( ;p != q; q = p->next)
30008368:	e59d3008 	ldr	r3, [sp, #8]
3000836c:	e5933000 	ldr	r3, [r3]
30008370:	e58d300c 	str	r3, [sp, #12]
30008374:	e59d2008 	ldr	r2, [sp, #8]
30008378:	e59d300c 	ldr	r3, [sp, #12]
3000837c:	e1520003 	cmp	r2, r3
30008380:	1afffff0 	bne	30008348 <acoral_msgctr_del+0xf0>
				acoral_release_res ((acoral_res_t *)pmsg);		
			}		
		}
		
		// 释放资源
		acoral_release_res((acoral_res_t *)pmsgctr);
30008384:	e59d3004 	ldr	r3, [sp, #4]
30008388:	e1a00003 	mov	r0, r3
3000838c:	ebffeca9 	bl	30003638 <acoral_release_res>
30008390:	eaffffff 	b	30008394 <acoral_msgctr_del+0x13c>
	}
}
30008394:	e1a00003 	mov	r0, r3
30008398:	e28dd01c 	add	sp, sp, #28
3000839c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300083a0:	e12fff1e 	bx	lr

300083a4 <acoral_msg_del>:

acoral_u32 acoral_msg_del(acoral_msg_t* pmsg)
{
300083a4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300083a8:	e24dd00c 	sub	sp, sp, #12
300083ac:	e58d0004 	str	r0, [sp, #4]
	if (NULL != pmsg)
300083b0:	e59d3004 	ldr	r3, [sp, #4]
300083b4:	e3530000 	cmp	r3, #0
300083b8:	0a000002 	beq	300083c8 <acoral_msg_del+0x24>
		acoral_release_res ((acoral_res_t *)pmsg);
300083bc:	e59d3004 	ldr	r3, [sp, #4]
300083c0:	e1a00003 	mov	r0, r3
300083c4:	ebffec9b 	bl	30003638 <acoral_release_res>
	return 0;
300083c8:	e3a03000 	mov	r3, #0
}
300083cc:	e1a00003 	mov	r0, r3
300083d0:	e28dd00c 	add	sp, sp, #12
300083d4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300083d8:	e12fff1e 	bx	lr

300083dc <wake_up_thread>:
/*==========================
 *
 *  唤醒最高优先等待线程
 *==========================*/
void wake_up_thread(acoral_list_t  *head)
{
300083dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300083e0:	e24dd01c 	sub	sp, sp, #28
300083e4:	e58d0004 	str	r0, [sp, #4]
	acoral_list_t    *p, *q;
	acoral_thread_t  *thread;

	p = head;
300083e8:	e59d3004 	ldr	r3, [sp, #4]
300083ec:	e58d300c 	str	r3, [sp, #12]
	q = p->next;
300083f0:	e59d300c 	ldr	r3, [sp, #12]
300083f4:	e5933000 	ldr	r3, [r3]
300083f8:	e58d3010 	str	r3, [sp, #16]
	thread=list_entry( q, acoral_thread_t, waiting);
300083fc:	e59d3010 	ldr	r3, [sp, #16]
30008400:	e2433020 	sub	r3, r3, #32
30008404:	e58d3014 	str	r3, [sp, #20]
	acoral_list_del  (&thread->waiting);
30008408:	e59d3014 	ldr	r3, [sp, #20]
3000840c:	e2833020 	add	r3, r3, #32
30008410:	e1a00003 	mov	r0, r3
30008414:	eb00070a 	bl	3000a044 <acoral_list_del>
	acoral_rdy_thread(thread);
30008418:	e59d0014 	ldr	r0, [sp, #20]
3000841c:	ebffe9d9 	bl	30002b88 <acoral_rdy_thread>
}
30008420:	e28dd01c 	add	sp, sp, #28
30008424:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30008428:	e12fff1e 	bx	lr

3000842c <acoral_print_all_msg>:
/*======================*/
/**/
/*  输出事件容器上全部消息*/
/*======================*/
void acoral_print_all_msg(acoral_msgctr_t* msgctr)
{
3000842c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008430:	e24dd01c 	sub	sp, sp, #28
30008434:	e58d0004 	str	r0, [sp, #4]
	acoral_list_t *p, *q;
	acoral_msg_t  *pmsg;

	acoral_doMsgTtl_checked = DO_CHECKED_TRUE;
30008438:	e59f3074 	ldr	r3, [pc, #116]	; 300084b4 <acoral_print_all_msg+0x88>
3000843c:	e3a02000 	mov	r2, #0
30008440:	e5832000 	str	r2, [r3]

	p = &msgctr->msglist;
30008444:	e59d3004 	ldr	r3, [sp, #4]
30008448:	e2833028 	add	r3, r3, #40	; 0x28
3000844c:	e58d300c 	str	r3, [sp, #12]
	q = p->next;
30008450:	e59d300c 	ldr	r3, [sp, #12]
30008454:	e5933000 	ldr	r3, [r3]
30008458:	e58d3010 	str	r3, [sp, #16]
	for( ;p != q; q = q->next)
3000845c:	ea00000a 	b	3000848c <acoral_print_all_msg+0x60>
	{
		pmsg = list_entry( q, acoral_msg_t, msglist);
30008460:	e59d3010 	ldr	r3, [sp, #16]
30008464:	e2433004 	sub	r3, r3, #4
30008468:	e58d3014 	str	r3, [sp, #20]
		acoral_print ("\nid = %d", pmsg->id);
3000846c:	e59d3014 	ldr	r3, [sp, #20]
30008470:	e593300c 	ldr	r3, [r3, #12]
30008474:	e59f003c 	ldr	r0, [pc, #60]	; 300084b8 <acoral_print_all_msg+0x8c>
30008478:	e1a01003 	mov	r1, r3
3000847c:	eb000b6f 	bl	3000b240 <acoral_print>

	acoral_doMsgTtl_checked = DO_CHECKED_TRUE;

	p = &msgctr->msglist;
	q = p->next;
	for( ;p != q; q = q->next)
30008480:	e59d3010 	ldr	r3, [sp, #16]
30008484:	e5933000 	ldr	r3, [r3]
30008488:	e58d3010 	str	r3, [sp, #16]
3000848c:	e59d200c 	ldr	r2, [sp, #12]
30008490:	e59d3010 	ldr	r3, [sp, #16]
30008494:	e1520003 	cmp	r2, r3
30008498:	1afffff0 	bne	30008460 <acoral_print_all_msg+0x34>
	{
		pmsg = list_entry( q, acoral_msg_t, msglist);
		acoral_print ("\nid = %d", pmsg->id);
	}

	acoral_doMsgTtl_checked = DO_CHECKED_FALSE;
3000849c:	e59f3010 	ldr	r3, [pc, #16]	; 300084b4 <acoral_print_all_msg+0x88>
300084a0:	e3a02001 	mov	r2, #1
300084a4:	e5832000 	str	r2, [r3]

}
300084a8:	e28dd01c 	add	sp, sp, #28
300084ac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300084b0:	e12fff1e 	bx	lr
300084b4:	30046688 	.word	0x30046688
300084b8:	30045464 	.word	0x30045464

300084bc <acoral_print_waitThreadsNum>:
/*======================*/
/**/
/*  输出等待任务数目*/
/*======================*/
void acoral_print_waitThreadsNum(acoral_msgctr_t* msgctr)
{
300084bc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300084c0:	e24dd00c 	sub	sp, sp, #12
300084c4:	e58d0004 	str	r0, [sp, #4]
	acoral_print("\n wait threads mum = %d", msgctr->wait_thread_num);
300084c8:	e59d3004 	ldr	r3, [sp, #4]
300084cc:	e593301c 	ldr	r3, [r3, #28]
300084d0:	e59f0010 	ldr	r0, [pc, #16]	; 300084e8 <acoral_print_waitThreadsNum+0x2c>
300084d4:	e1a01003 	mov	r1, r3
300084d8:	eb000b58 	bl	3000b240 <acoral_print>
}
300084dc:	e28dd00c 	add	sp, sp, #12
300084e0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300084e4:	e12fff1e 	bx	lr
300084e8:	30045470 	.word	0x30045470

300084ec <rm_policy_thread_init>:
struct{
	acoral_u32 num;
	acoral_fl sum;
}left[HAL_MAX_CPU];

acoral_id rm_policy_thread_init(acoral_thread_t *thread,void (*route)(void *args),void *args,void *data){
300084ec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300084f0:	e24dd024 	sub	sp, sp, #36	; 0x24
300084f4:	e58d000c 	str	r0, [sp, #12]
300084f8:	e58d1008 	str	r1, [sp, #8]
300084fc:	e58d2004 	str	r2, [sp, #4]
30008500:	e58d3000 	str	r3, [sp]
	acoral_sr cpu_sr;
	acoral_rm_policy_data_t *policy_data;
	rm_policy_data_t *private_data;
	policy_data=(acoral_rm_policy_data_t *)data;
30008504:	e59d3000 	ldr	r3, [sp]
30008508:	e58d3018 	str	r3, [sp, #24]
	private_data=(rm_policy_data_t *)acoral_malloc2(sizeof(rm_policy_data_t));
3000850c:	e3a0001c 	mov	r0, #28
30008510:	ebfff9bf 	bl	30006c14 <v_malloc>
30008514:	e1a03000 	mov	r3, r0
30008518:	e58d301c 	str	r3, [sp, #28]
	if(private_data==NULL){
3000851c:	e59d301c 	ldr	r3, [sp, #28]
30008520:	e3530000 	cmp	r3, #0
30008524:	1a00000e 	bne	30008564 <rm_policy_thread_init+0x78>
		acoral_printerr("No level2 mem space for private_data:%s\n",thread->name);
30008528:	e59d300c 	ldr	r3, [sp, #12]
3000852c:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30008530:	e59f00f8 	ldr	r0, [pc, #248]	; 30008630 <rm_policy_thread_init+0x144>
30008534:	e1a01003 	mov	r1, r3
30008538:	eb000b40 	bl	3000b240 <acoral_print>
		HAL_ENTER_CRITICAL();
3000853c:	ebffe46c 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30008540:	e1a03000 	mov	r3, r0
30008544:	e58d3014 	str	r3, [sp, #20]
		acoral_release_res((acoral_res_t *)thread);
30008548:	e59d300c 	ldr	r3, [sp, #12]
3000854c:	e1a00003 	mov	r0, r3
30008550:	ebffec38 	bl	30003638 <acoral_release_res>
		HAL_EXIT_CRITICAL();
30008554:	e59d0014 	ldr	r0, [sp, #20]
30008558:	ebffe463 	bl	300016ec <HAL_INTR_RESTORE>
		return -1;
3000855c:	e3e03000 	mvn	r3, #0
30008560:	ea00002e 	b	30008620 <rm_policy_thread_init+0x134>
	}
	private_data->t=100*policy_data->t;
30008564:	e59d3018 	ldr	r3, [sp, #24]
30008568:	e5932000 	ldr	r2, [r3]
3000856c:	e1a03002 	mov	r3, r2
30008570:	e1a03103 	lsl	r3, r3, #2
30008574:	e0833002 	add	r3, r3, r2
30008578:	e1a02103 	lsl	r2, r3, #2
3000857c:	e0833002 	add	r3, r3, r2
30008580:	e1a03103 	lsl	r3, r3, #2
30008584:	e1a02003 	mov	r2, r3
30008588:	e59d301c 	ldr	r3, [sp, #28]
3000858c:	e583200c 	str	r2, [r3, #12]
	private_data->lt=private_data->t;
30008590:	e59d301c 	ldr	r3, [sp, #28]
30008594:	e593200c 	ldr	r2, [r3, #12]
30008598:	e59d301c 	ldr	r3, [sp, #28]
3000859c:	e5832010 	str	r2, [r3, #16]
	private_data->e=100*policy_data->e;
300085a0:	e59d3018 	ldr	r3, [sp, #24]
300085a4:	e5932004 	ldr	r2, [r3, #4]
300085a8:	e1a03002 	mov	r3, r2
300085ac:	e1a03103 	lsl	r3, r3, #2
300085b0:	e0833002 	add	r3, r3, r2
300085b4:	e1a02103 	lsl	r2, r3, #2
300085b8:	e0833002 	add	r3, r3, r2
300085bc:	e1a03103 	lsl	r3, r3, #2
300085c0:	e1a02003 	mov	r2, r3
300085c4:	e59d301c 	ldr	r3, [sp, #28]
300085c8:	e5832014 	str	r2, [r3, #20]
	private_data->le=private_data->e;
300085cc:	e59d301c 	ldr	r3, [sp, #28]
300085d0:	e5932014 	ldr	r2, [r3, #20]
300085d4:	e59d301c 	ldr	r3, [sp, #28]
300085d8:	e5832018 	str	r2, [r3, #24]
	private_data->period_data.args=args;
300085dc:	e59d301c 	ldr	r3, [sp, #28]
300085e0:	e59d2004 	ldr	r2, [sp, #4]
300085e4:	e5832008 	str	r2, [r3, #8]
	private_data->period_data.route=route;
300085e8:	e59d301c 	ldr	r3, [sp, #28]
300085ec:	e59d2008 	ldr	r2, [sp, #8]
300085f0:	e5832004 	str	r2, [r3, #4]
	private_data->period_data.time=private_data->t;
300085f4:	e59d301c 	ldr	r3, [sp, #28]
300085f8:	e593200c 	ldr	r2, [r3, #12]
300085fc:	e59d301c 	ldr	r3, [sp, #28]
30008600:	e5832000 	str	r2, [r3]
	thread->private_data=private_data;
30008604:	e59d300c 	ldr	r3, [sp, #12]
30008608:	e59d201c 	ldr	r2, [sp, #28]
3000860c:	e5832050 	str	r2, [r3, #80]	; 0x50
	rm_queue_ascend_add(thread);
30008610:	e59d000c 	ldr	r0, [sp, #12]
30008614:	eb000021 	bl	300086a0 <rm_queue_ascend_add>
	return thread->res.id;
30008618:	e59d300c 	ldr	r3, [sp, #12]
3000861c:	e5933000 	ldr	r3, [r3]
}
30008620:	e1a00003 	mov	r0, r3
30008624:	e28dd024 	add	sp, sp, #36	; 0x24
30008628:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000862c:	e12fff1e 	bx	lr
30008630:	30045488 	.word	0x30045488

30008634 <rm_policy_thread_release>:

void rm_policy_thread_release(acoral_thread_t *thread){
30008634:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008638:	e24dd00c 	sub	sp, sp, #12
3000863c:	e58d0004 	str	r0, [sp, #4]
	acoral_printk("Release Rm thread\n");
	acoral_free2(thread->private_data);	
30008640:	e59d3004 	ldr	r3, [sp, #4]
30008644:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30008648:	e1a00003 	mov	r0, r3
3000864c:	ebfff985 	bl	30006c68 <v_free>
}
30008650:	e28dd00c 	add	sp, sp, #12
30008654:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30008658:	e12fff1e 	bx	lr

3000865c <rm_discard_thread>:

void rm_discard_thread(acoral_thread_t *thread){
3000865c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008660:	e24dd00c 	sub	sp, sp, #12
30008664:	e58d0004 	str	r0, [sp, #4]
	acoral_list_del(&thread->ready);
30008668:	e59d3004 	ldr	r3, [sp, #4]
3000866c:	e2833010 	add	r3, r3, #16
30008670:	e1a00003 	mov	r0, r3
30008674:	eb000672 	bl	3000a044 <acoral_list_del>
	acoral_free2(thread->private_data);	
30008678:	e59d3004 	ldr	r3, [sp, #4]
3000867c:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30008680:	e1a00003 	mov	r0, r3
30008684:	ebfff977 	bl	30006c68 <v_free>
	acoral_release_res((acoral_res_t *)thread);
30008688:	e59d3004 	ldr	r3, [sp, #4]
3000868c:	e1a00003 	mov	r0, r3
30008690:	ebffebe8 	bl	30003638 <acoral_release_res>
}
30008694:	e28dd00c 	add	sp, sp, #12
30008698:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000869c:	e12fff1e 	bx	lr

300086a0 <rm_queue_ascend_add>:

void rm_queue_ascend_add(acoral_thread_t *new){
300086a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300086a4:	e24dd024 	sub	sp, sp, #36	; 0x24
300086a8:	e58d0004 	str	r0, [sp, #4]
      rm_policy_data_t *new_data;
      rm_policy_data_t *old_data;
      acoral_thread_t * thread;
      acoral_list_t *tmp,*head;
      head=&rm_queue->head;
300086ac:	e59f309c 	ldr	r3, [pc, #156]	; 30008750 <rm_queue_ascend_add+0xb0>
300086b0:	e5933000 	ldr	r3, [r3]
300086b4:	e58d301c 	str	r3, [sp, #28]
      new_data=new->private_data; 
300086b8:	e59d3004 	ldr	r3, [sp, #4]
300086bc:	e5933050 	ldr	r3, [r3, #80]	; 0x50
300086c0:	e58d300c 	str	r3, [sp, #12]
      for (tmp=head->next;tmp!=head; tmp=tmp->next){
300086c4:	e59d301c 	ldr	r3, [sp, #28]
300086c8:	e5933000 	ldr	r3, [r3]
300086cc:	e58d3018 	str	r3, [sp, #24]
300086d0:	ea00000e 	b	30008710 <rm_queue_ascend_add+0x70>
		thread =list_entry(tmp, acoral_thread_t,ready);
300086d4:	e59d3018 	ldr	r3, [sp, #24]
300086d8:	e2433010 	sub	r3, r3, #16
300086dc:	e58d3014 	str	r3, [sp, #20]
		old_data=thread->private_data;
300086e0:	e59d3014 	ldr	r3, [sp, #20]
300086e4:	e5933050 	ldr	r3, [r3, #80]	; 0x50
300086e8:	e58d3010 	str	r3, [sp, #16]
      	        if(old_data->lt>new_data->lt)
300086ec:	e59d3010 	ldr	r3, [sp, #16]
300086f0:	e5932010 	ldr	r2, [r3, #16]
300086f4:	e59d300c 	ldr	r3, [sp, #12]
300086f8:	e5933010 	ldr	r3, [r3, #16]
300086fc:	e1520003 	cmp	r2, r3
30008700:	8a000007 	bhi	30008724 <rm_queue_ascend_add+0x84>
      rm_policy_data_t *old_data;
      acoral_thread_t * thread;
      acoral_list_t *tmp,*head;
      head=&rm_queue->head;
      new_data=new->private_data; 
      for (tmp=head->next;tmp!=head; tmp=tmp->next){
30008704:	e59d3018 	ldr	r3, [sp, #24]
30008708:	e5933000 	ldr	r3, [r3]
3000870c:	e58d3018 	str	r3, [sp, #24]
30008710:	e59d2018 	ldr	r2, [sp, #24]
30008714:	e59d301c 	ldr	r3, [sp, #28]
30008718:	e1520003 	cmp	r2, r3
3000871c:	1affffec 	bne	300086d4 <rm_queue_ascend_add+0x34>
30008720:	ea000000 	b	30008728 <rm_queue_ascend_add+0x88>
		thread =list_entry(tmp, acoral_thread_t,ready);
		old_data=thread->private_data;
      	        if(old_data->lt>new_data->lt)
			break;		  
30008724:	e1a00000 	nop			; (mov r0, r0)
     }
     acoral_list_add(&new->ready,tmp->prev);
30008728:	e59d3004 	ldr	r3, [sp, #4]
3000872c:	e2832010 	add	r2, r3, #16
30008730:	e59d3018 	ldr	r3, [sp, #24]
30008734:	e5933004 	ldr	r3, [r3, #4]
30008738:	e1a00002 	mov	r0, r2
3000873c:	e1a01003 	mov	r1, r3
30008740:	eb000619 	bl	30009fac <acoral_list_add>
}
30008744:	e28dd024 	add	sp, sp, #36	; 0x24
30008748:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000874c:	e12fff1e 	bx	lr
30008750:	30046690 	.word	0x30046690

30008754 <rm_check>:

acoral_u8 rm_check(acoral_thread_t *thread,acoral_u32 cpu){
30008754:	e92d4010 	push	{r4, lr}
30008758:	e24dd010 	sub	sp, sp, #16
3000875c:	e58d0004 	str	r0, [sp, #4]
30008760:	e58d1000 	str	r1, [sp]
	rm_policy_data_t *data;
	acoral_fl tmp;
	data=thread->private_data;
30008764:	e59d3004 	ldr	r3, [sp, #4]
30008768:	e5933050 	ldr	r3, [r3, #80]	; 0x50
3000876c:	e58d3008 	str	r3, [sp, #8]
	tmp=(acoral_fl)data->e/(acoral_fl)data->t;		
30008770:	e59d3008 	ldr	r3, [sp, #8]
30008774:	e5933014 	ldr	r3, [r3, #20]
30008778:	e1a00003 	mov	r0, r3
3000877c:	eb00f0fc 	bl	30044b74 <__aeabi_ui2f>
30008780:	e1a04000 	mov	r4, r0
30008784:	e59d3008 	ldr	r3, [sp, #8]
30008788:	e593300c 	ldr	r3, [r3, #12]
3000878c:	e1a00003 	mov	r0, r3
30008790:	eb00f0f7 	bl	30044b74 <__aeabi_ui2f>
30008794:	e1a03000 	mov	r3, r0
30008798:	e1a00004 	mov	r0, r4
3000879c:	e1a01003 	mov	r1, r3
300087a0:	eb00f192 	bl	30044df0 <__aeabi_fdiv>
300087a4:	e1a03000 	mov	r3, r0
300087a8:	e58d300c 	str	r3, [sp, #12]
	if(left[cpu].sum+tmp<right[left[cpu].num]){
300087ac:	e59d1000 	ldr	r1, [sp]
300087b0:	e59f20ec 	ldr	r2, [pc, #236]	; 300088a4 <rm_check+0x150>
300087b4:	e3a03004 	mov	r3, #4
300087b8:	e1a01181 	lsl	r1, r1, #3
300087bc:	e0812002 	add	r2, r1, r2
300087c0:	e0823003 	add	r3, r2, r3
300087c4:	e5933000 	ldr	r3, [r3]
300087c8:	e1a00003 	mov	r0, r3
300087cc:	e59d100c 	ldr	r1, [sp, #12]
300087d0:	eb00f078 	bl	300449b8 <__addsf3>
300087d4:	e1a03000 	mov	r3, r0
300087d8:	e1a02003 	mov	r2, r3
300087dc:	e59d1000 	ldr	r1, [sp]
300087e0:	e59f30bc 	ldr	r3, [pc, #188]	; 300088a4 <rm_check+0x150>
300087e4:	e7931181 	ldr	r1, [r3, r1, lsl #3]
300087e8:	e59f30b8 	ldr	r3, [pc, #184]	; 300088a8 <rm_check+0x154>
300087ec:	e7933101 	ldr	r3, [r3, r1, lsl #2]
300087f0:	e3a01000 	mov	r1, #0
300087f4:	e1a04001 	mov	r4, r1
300087f8:	e1a00002 	mov	r0, r2
300087fc:	e1a01003 	mov	r1, r3
30008800:	eb00f1ff 	bl	30045004 <__aeabi_fcmplt>
30008804:	e1a03000 	mov	r3, r0
30008808:	e3530000 	cmp	r3, #0
3000880c:	0a000001 	beq	30008818 <rm_check+0xc4>
30008810:	e3a03001 	mov	r3, #1
30008814:	e1a04003 	mov	r4, r3
30008818:	e20430ff 	and	r3, r4, #255	; 0xff
3000881c:	e3530000 	cmp	r3, #0
30008820:	0a00001a 	beq	30008890 <rm_check+0x13c>
		left[cpu].sum+=tmp;
30008824:	e59d4000 	ldr	r4, [sp]
30008828:	e59d1000 	ldr	r1, [sp]
3000882c:	e59f2070 	ldr	r2, [pc, #112]	; 300088a4 <rm_check+0x150>
30008830:	e3a03004 	mov	r3, #4
30008834:	e1a01181 	lsl	r1, r1, #3
30008838:	e0812002 	add	r2, r1, r2
3000883c:	e0823003 	add	r3, r2, r3
30008840:	e5933000 	ldr	r3, [r3]
30008844:	e1a00003 	mov	r0, r3
30008848:	e59d100c 	ldr	r1, [sp, #12]
3000884c:	eb00f059 	bl	300449b8 <__addsf3>
30008850:	e1a03000 	mov	r3, r0
30008854:	e1a02003 	mov	r2, r3
30008858:	e59f1044 	ldr	r1, [pc, #68]	; 300088a4 <rm_check+0x150>
3000885c:	e3a03004 	mov	r3, #4
30008860:	e1a00184 	lsl	r0, r4, #3
30008864:	e0801001 	add	r1, r0, r1
30008868:	e0813003 	add	r3, r1, r3
3000886c:	e5832000 	str	r2, [r3]
		left[cpu].num++;
30008870:	e59d3000 	ldr	r3, [sp]
30008874:	e59f2028 	ldr	r2, [pc, #40]	; 300088a4 <rm_check+0x150>
30008878:	e7922183 	ldr	r2, [r2, r3, lsl #3]
3000887c:	e2821001 	add	r1, r2, #1
30008880:	e59f201c 	ldr	r2, [pc, #28]	; 300088a4 <rm_check+0x150>
30008884:	e7821183 	str	r1, [r2, r3, lsl #3]
		return 1;
30008888:	e3a03001 	mov	r3, #1
3000888c:	ea000000 	b	30008894 <rm_check+0x140>
	}
	return 0;
30008890:	e3a03000 	mov	r3, #0
}
30008894:	e1a00003 	mov	r0, r3
30008898:	e28dd010 	add	sp, sp, #16
3000889c:	e8bd4010 	pop	{r4, lr}
300088a0:	e12fff1e 	bx	lr
300088a4:	3012a810 	.word	0x3012a810
300088a8:	30046694 	.word	0x30046694

300088ac <rm_thread_dispatch>:

void rm_thread_dispatch(){
300088ac:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300088b0:	e24dd01c 	sub	sp, sp, #28
	acoral_sr cpu_sr;
	acoral_u32 i;
	acoral_thread_t * thread;
	acoral_list_t *tmp,*head;
	HAL_ENTER_CRITICAL();
300088b4:	ebffe38e 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300088b8:	e1a03000 	mov	r3, r0
300088bc:	e58d3004 	str	r3, [sp, #4]
	head=&rm_queue->head;
300088c0:	e59f3120 	ldr	r3, [pc, #288]	; 300089e8 <rm_thread_dispatch+0x13c>
300088c4:	e5933000 	ldr	r3, [r3]
300088c8:	e58d3014 	str	r3, [sp, #20]
	for (tmp=head->next;tmp!=head;){
300088cc:	e59d3014 	ldr	r3, [sp, #20]
300088d0:	e5933000 	ldr	r3, [r3]
300088d4:	e58d3010 	str	r3, [sp, #16]
300088d8:	ea000039 	b	300089c4 <rm_thread_dispatch+0x118>
		thread =list_entry(tmp, acoral_thread_t,ready);
300088dc:	e59d3010 	ldr	r3, [sp, #16]
300088e0:	e2433010 	sub	r3, r3, #16
300088e4:	e58d300c 	str	r3, [sp, #12]
		tmp=tmp->next;
300088e8:	e59d3010 	ldr	r3, [sp, #16]
300088ec:	e5933000 	ldr	r3, [r3]
300088f0:	e58d3010 	str	r3, [sp, #16]
		if(prio>=ACORAL_HARD_RT_PRIO_MAX){
300088f4:	e59f30f0 	ldr	r3, [pc, #240]	; 300089ec <rm_thread_dispatch+0x140>
300088f8:	e5933000 	ldr	r3, [r3]
300088fc:	e3530015 	cmp	r3, #21
30008900:	9a000007 	bls	30008924 <rm_thread_dispatch+0x78>
				acoral_printerr("RM thread %s Err,Prio is not enough\n",thread->name);
30008904:	e59d300c 	ldr	r3, [sp, #12]
30008908:	e5933048 	ldr	r3, [r3, #72]	; 0x48
3000890c:	e59f00dc 	ldr	r0, [pc, #220]	; 300089f0 <rm_thread_dispatch+0x144>
30008910:	e1a01003 	mov	r1, r3
30008914:	eb000a49 	bl	3000b240 <acoral_print>
				/*这个线程还没初始化，包括它的stack,lock等,原来是用acoral_release_thread导致很多错误*/
				rm_discard_thread(thread);
30008918:	e59d000c 	ldr	r0, [sp, #12]
3000891c:	ebffff4e 	bl	3000865c <rm_discard_thread>
30008920:	ea000027 	b	300089c4 <rm_thread_dispatch+0x118>
		}else{
			thread->prio=prio;
30008924:	e59f30c0 	ldr	r3, [pc, #192]	; 300089ec <rm_thread_dispatch+0x140>
30008928:	e5933000 	ldr	r3, [r3]
3000892c:	e20320ff 	and	r2, r3, #255	; 0xff
30008930:	e59d300c 	ldr	r3, [sp, #12]
30008934:	e5c32005 	strb	r2, [r3, #5]
			prio++;
30008938:	e59f30ac 	ldr	r3, [pc, #172]	; 300089ec <rm_thread_dispatch+0x140>
3000893c:	e5933000 	ldr	r3, [r3]
30008940:	e2832001 	add	r2, r3, #1
30008944:	e59f30a0 	ldr	r3, [pc, #160]	; 300089ec <rm_thread_dispatch+0x140>
30008948:	e5832000 	str	r2, [r3]
			for(i=0;i<HAL_MAX_CPU;i++){
3000894c:	e3a03000 	mov	r3, #0
30008950:	e58d3008 	str	r3, [sp, #8]
30008954:	ea00000d 	b	30008990 <rm_thread_dispatch+0xe4>
				if(rm_check(thread,i)){
30008958:	e59d000c 	ldr	r0, [sp, #12]
3000895c:	e59d1008 	ldr	r1, [sp, #8]
30008960:	ebffff7b 	bl	30008754 <rm_check>
30008964:	e1a03000 	mov	r3, r0
30008968:	e3530000 	cmp	r3, #0
3000896c:	0a000004 	beq	30008984 <rm_thread_dispatch+0xd8>
					thread->cpu=i;
30008970:	e59d3008 	ldr	r3, [sp, #8]
30008974:	e20320ff 	and	r2, r3, #255	; 0xff
30008978:	e59d300c 	ldr	r3, [sp, #12]
3000897c:	e5c32006 	strb	r2, [r3, #6]
					break;
30008980:	ea000005 	b	3000899c <rm_thread_dispatch+0xf0>
				/*这个线程还没初始化，包括它的stack,lock等,原来是用acoral_release_thread导致很多错误*/
				rm_discard_thread(thread);
		}else{
			thread->prio=prio;
			prio++;
			for(i=0;i<HAL_MAX_CPU;i++){
30008984:	e59d3008 	ldr	r3, [sp, #8]
30008988:	e2833001 	add	r3, r3, #1
3000898c:	e58d3008 	str	r3, [sp, #8]
30008990:	e59d3008 	ldr	r3, [sp, #8]
30008994:	e3530000 	cmp	r3, #0
30008998:	0affffee 	beq	30008958 <rm_thread_dispatch+0xac>
				if(rm_check(thread,i)){
					thread->cpu=i;
					break;
				}
			}
			if(i==HAL_MAX_CPU){
3000899c:	e59d3008 	ldr	r3, [sp, #8]
300089a0:	e3530001 	cmp	r3, #1
300089a4:	1a000006 	bne	300089c4 <rm_thread_dispatch+0x118>
				acoral_printerr("Discard thread %s\n",thread->name);
300089a8:	e59d300c 	ldr	r3, [sp, #12]
300089ac:	e5933048 	ldr	r3, [r3, #72]	; 0x48
300089b0:	e59f003c 	ldr	r0, [pc, #60]	; 300089f4 <rm_thread_dispatch+0x148>
300089b4:	e1a01003 	mov	r1, r3
300089b8:	eb000a20 	bl	3000b240 <acoral_print>
				/*这个线程还没初始化，包括它的stack,lock等*/
				rm_discard_thread(thread);
300089bc:	e59d000c 	ldr	r0, [sp, #12]
300089c0:	ebffff25 	bl	3000865c <rm_discard_thread>
	acoral_u32 i;
	acoral_thread_t * thread;
	acoral_list_t *tmp,*head;
	HAL_ENTER_CRITICAL();
	head=&rm_queue->head;
	for (tmp=head->next;tmp!=head;){
300089c4:	e59d2010 	ldr	r2, [sp, #16]
300089c8:	e59d3014 	ldr	r3, [sp, #20]
300089cc:	e1520003 	cmp	r2, r3
300089d0:	1affffc1 	bne	300088dc <rm_thread_dispatch+0x30>
				/*这个线程还没初始化，包括它的stack,lock等*/
				rm_discard_thread(thread);
			}
		} 
	}
	HAL_EXIT_CRITICAL();
300089d4:	e59d0004 	ldr	r0, [sp, #4]
300089d8:	ebffe343 	bl	300016ec <HAL_INTR_RESTORE>
	return;
}
300089dc:	e28dd01c 	add	sp, sp, #28
300089e0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300089e4:	e12fff1e 	bx	lr
300089e8:	30046690 	.word	0x30046690
300089ec:	3004668c 	.word	0x3004668c
300089f0:	300454b4 	.word	0x300454b4
300089f4:	300454dc 	.word	0x300454dc

300089f8 <rm_init>:

void rm_init(){
300089f8:	e24dd008 	sub	sp, sp, #8
      acoral_u32 i;
      acoral_init_list(&rm_queue->head);
300089fc:	e59f307c 	ldr	r3, [pc, #124]	; 30008a80 <rm_init+0x88>
30008a00:	e5933000 	ldr	r3, [r3]
30008a04:	e59f2074 	ldr	r2, [pc, #116]	; 30008a80 <rm_init+0x88>
30008a08:	e5922000 	ldr	r2, [r2]
30008a0c:	e5832000 	str	r2, [r3]
30008a10:	e59f3068 	ldr	r3, [pc, #104]	; 30008a80 <rm_init+0x88>
30008a14:	e5933000 	ldr	r3, [r3]
30008a18:	e59f2060 	ldr	r2, [pc, #96]	; 30008a80 <rm_init+0x88>
30008a1c:	e5922000 	ldr	r2, [r2]
30008a20:	e5832004 	str	r2, [r3, #4]
      for(i=0;i<HAL_MAX_CPU;i++){
30008a24:	e3a03000 	mov	r3, #0
30008a28:	e58d3004 	str	r3, [sp, #4]
30008a2c:	ea00000e 	b	30008a6c <rm_init+0x74>
		left[i].sum=0;
30008a30:	e59d1004 	ldr	r1, [sp, #4]
30008a34:	e59f2048 	ldr	r2, [pc, #72]	; 30008a84 <rm_init+0x8c>
30008a38:	e3a03004 	mov	r3, #4
30008a3c:	e1a01181 	lsl	r1, r1, #3
30008a40:	e0812002 	add	r2, r1, r2
30008a44:	e0823003 	add	r3, r2, r3
30008a48:	e59f2038 	ldr	r2, [pc, #56]	; 30008a88 <rm_init+0x90>
30008a4c:	e5832000 	str	r2, [r3]
		left[i].num=0;
30008a50:	e59d2004 	ldr	r2, [sp, #4]
30008a54:	e59f3028 	ldr	r3, [pc, #40]	; 30008a84 <rm_init+0x8c>
30008a58:	e3a01000 	mov	r1, #0
30008a5c:	e7831182 	str	r1, [r3, r2, lsl #3]
}

void rm_init(){
      acoral_u32 i;
      acoral_init_list(&rm_queue->head);
      for(i=0;i<HAL_MAX_CPU;i++){
30008a60:	e59d3004 	ldr	r3, [sp, #4]
30008a64:	e2833001 	add	r3, r3, #1
30008a68:	e58d3004 	str	r3, [sp, #4]
30008a6c:	e59d3004 	ldr	r3, [sp, #4]
30008a70:	e3530000 	cmp	r3, #0
30008a74:	0affffed 	beq	30008a30 <rm_init+0x38>
		left[i].sum=0;
		left[i].num=0;
      }
}
30008a78:	e28dd008 	add	sp, sp, #8
30008a7c:	e12fff1e 	bx	lr
30008a80:	30046690 	.word	0x30046690
30008a84:	3012a810 	.word	0x3012a810
30008a88:	00000000 	.word	0x00000000

30008a8c <rm_policy_init>:

acoral_sched_policy_t rm_policy;
void rm_policy_init(){
30008a8c:	e92d4008 	push	{r3, lr}
	rm_init();
30008a90:	ebffffd8 	bl	300089f8 <rm_init>
	rm_policy.type=ACORAL_SCHED_POLICY_RM;
30008a94:	e59f3044 	ldr	r3, [pc, #68]	; 30008ae0 <rm_policy_init+0x54>
30008a98:	e3a02017 	mov	r2, #23
30008a9c:	e5c32008 	strb	r2, [r3, #8]
	rm_policy.policy_thread_init=rm_policy_thread_init;
30008aa0:	e59f3038 	ldr	r3, [pc, #56]	; 30008ae0 <rm_policy_init+0x54>
30008aa4:	e59f2038 	ldr	r2, [pc, #56]	; 30008ae4 <rm_policy_init+0x58>
30008aa8:	e583200c 	str	r2, [r3, #12]
	rm_policy.policy_thread_release=rm_policy_thread_release;
30008aac:	e59f302c 	ldr	r3, [pc, #44]	; 30008ae0 <rm_policy_init+0x54>
30008ab0:	e59f2030 	ldr	r2, [pc, #48]	; 30008ae8 <rm_policy_init+0x5c>
30008ab4:	e5832010 	str	r2, [r3, #16]
	rm_policy.delay_deal=NULL;
30008ab8:	e59f3020 	ldr	r3, [pc, #32]	; 30008ae0 <rm_policy_init+0x54>
30008abc:	e3a02000 	mov	r2, #0
30008ac0:	e5832014 	str	r2, [r3, #20]
	rm_policy.name="rm";
30008ac4:	e59f3014 	ldr	r3, [pc, #20]	; 30008ae0 <rm_policy_init+0x54>
30008ac8:	e59f201c 	ldr	r2, [pc, #28]	; 30008aec <rm_policy_init+0x60>
30008acc:	e5832018 	str	r2, [r3, #24]
	acoral_register_sched_policy(&rm_policy);
30008ad0:	e59f0008 	ldr	r0, [pc, #8]	; 30008ae0 <rm_policy_init+0x54>
30008ad4:	ebffe4db 	bl	30001e48 <acoral_register_sched_policy>
}
30008ad8:	e8bd4008 	pop	{r3, lr}
30008adc:	e12fff1e 	bx	lr
30008ae0:	3012d6bc 	.word	0x3012d6bc
30008ae4:	300084ec 	.word	0x300084ec
30008ae8:	30008634 	.word	0x30008634
30008aec:	300454f0 	.word	0x300454f0

30008af0 <rm_end>:

void rm_end(){
30008af0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008af4:	e24dd024 	sub	sp, sp, #36	; 0x24
      acoral_sr cpu_sr;
      acoral_thread_t * thread;
      rm_policy_data_t *private_data;
      acoral_list_t *tmp,*head;
      rm_thread_dispatch();
30008af8:	ebffff6b 	bl	300088ac <rm_thread_dispatch>
      HAL_ENTER_CRITICAL();
30008afc:	ebffe2fc 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30008b00:	e1a03000 	mov	r3, r0
30008b04:	e58d300c 	str	r3, [sp, #12]
      head=&rm_queue->head;
30008b08:	e59f3090 	ldr	r3, [pc, #144]	; 30008ba0 <rm_end+0xb0>
30008b0c:	e5933000 	ldr	r3, [r3]
30008b10:	e58d301c 	str	r3, [sp, #28]
      for (tmp=head->next;tmp!=head;){
30008b14:	e59d301c 	ldr	r3, [sp, #28]
30008b18:	e5933000 	ldr	r3, [r3]
30008b1c:	e58d3018 	str	r3, [sp, #24]
30008b20:	ea000015 	b	30008b7c <rm_end+0x8c>
	  thread =list_entry(tmp, acoral_thread_t,ready);
30008b24:	e59d3018 	ldr	r3, [sp, #24]
30008b28:	e2433010 	sub	r3, r3, #16
30008b2c:	e58d3010 	str	r3, [sp, #16]
	  tmp=tmp->next;
30008b30:	e59d3018 	ldr	r3, [sp, #24]
30008b34:	e5933000 	ldr	r3, [r3]
30008b38:	e58d3018 	str	r3, [sp, #24]
	  acoral_list_del(&thread->ready); /*从队列上取下线程*/
30008b3c:	e59d3010 	ldr	r3, [sp, #16]
30008b40:	e2833010 	add	r3, r3, #16
30008b44:	e1a00003 	mov	r0, r3
30008b48:	eb00053d 	bl	3000a044 <acoral_list_del>
	  private_data=thread->private_data;
30008b4c:	e59d3010 	ldr	r3, [sp, #16]
30008b50:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30008b54:	e58d3014 	str	r3, [sp, #20]
	  acoral_policy_thread_init(ACORAL_SCHED_POLICY_PERIOD,thread,private_data->period_data.route,private_data->period_data.args,NULL);
30008b58:	e59d3014 	ldr	r3, [sp, #20]
30008b5c:	e5932004 	ldr	r2, [r3, #4]
30008b60:	e59d3014 	ldr	r3, [sp, #20]
30008b64:	e5933008 	ldr	r3, [r3, #8]
30008b68:	e3a01000 	mov	r1, #0
30008b6c:	e58d1000 	str	r1, [sp]
30008b70:	e3a00016 	mov	r0, #22
30008b74:	e59d1010 	ldr	r1, [sp, #16]
30008b78:	ebffe482 	bl	30001d88 <acoral_policy_thread_init>
      rm_policy_data_t *private_data;
      acoral_list_t *tmp,*head;
      rm_thread_dispatch();
      HAL_ENTER_CRITICAL();
      head=&rm_queue->head;
      for (tmp=head->next;tmp!=head;){
30008b7c:	e59d2018 	ldr	r2, [sp, #24]
30008b80:	e59d301c 	ldr	r3, [sp, #28]
30008b84:	e1520003 	cmp	r2, r3
30008b88:	1affffe5 	bne	30008b24 <rm_end+0x34>
	  tmp=tmp->next;
	  acoral_list_del(&thread->ready); /*从队列上取下线程*/
	  private_data=thread->private_data;
	  acoral_policy_thread_init(ACORAL_SCHED_POLICY_PERIOD,thread,private_data->period_data.route,private_data->period_data.args,NULL);
     }
     HAL_EXIT_CRITICAL();
30008b8c:	e59d000c 	ldr	r0, [sp, #12]
30008b90:	ebffe2d5 	bl	300016ec <HAL_INTR_RESTORE>
}
30008b94:	e28dd024 	add	sp, sp, #36	; 0x24
30008b98:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30008b9c:	e12fff1e 	bx	lr
30008ba0:	30046690 	.word	0x30046690

30008ba4 <period_policy_thread_init>:
#include<policy.h>
#include<mem.h>
#include<timer.h>
#include<period_thrd.h>
acoral_queue_t period_delay_queue;
acoral_id period_policy_thread_init(acoral_thread_t *thread,void (*route)(void *args),void *args,void *data){
30008ba4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008ba8:	e24dd024 	sub	sp, sp, #36	; 0x24
30008bac:	e58d000c 	str	r0, [sp, #12]
30008bb0:	e58d1008 	str	r1, [sp, #8]
30008bb4:	e58d2004 	str	r2, [sp, #4]
30008bb8:	e58d3000 	str	r3, [sp]
	acoral_sr cpu_sr;
	acoral_u32 prio;
	acoral_period_policy_data_t *policy_data;
	period_policy_data_t *private_data;
	if(thread->policy==ACORAL_SCHED_POLICY_PERIOD){
30008bbc:	e59d300c 	ldr	r3, [sp, #12]
30008bc0:	e5d3300c 	ldrb	r3, [r3, #12]
30008bc4:	e3530016 	cmp	r3, #22
30008bc8:	1a000040 	bne	30008cd0 <period_policy_thread_init+0x12c>
		policy_data=(acoral_period_policy_data_t *)data;
30008bcc:	e59d3000 	ldr	r3, [sp]
30008bd0:	e58d3018 	str	r3, [sp, #24]
		thread->cpu=policy_data->cpu;
30008bd4:	e59d3018 	ldr	r3, [sp, #24]
30008bd8:	e5d32000 	ldrb	r2, [r3]
30008bdc:	e59d300c 	ldr	r3, [sp, #12]
30008be0:	e5c32006 	strb	r2, [r3, #6]
		prio=policy_data->prio;
30008be4:	e59d3018 	ldr	r3, [sp, #24]
30008be8:	e5d33001 	ldrb	r3, [r3, #1]
30008bec:	e58d3014 	str	r3, [sp, #20]
		if(policy_data->prio_type==ACORAL_BASE_PRIO){
30008bf0:	e59d3018 	ldr	r3, [sp, #24]
30008bf4:	e5d33002 	ldrb	r3, [r3, #2]
30008bf8:	e1a03c03 	lsl	r3, r3, #24
30008bfc:	e1a03c43 	asr	r3, r3, #24
30008c00:	e3530002 	cmp	r3, #2
30008c04:	1a000007 	bne	30008c28 <period_policy_thread_init+0x84>
			prio+=ACORAL_BASE_PRIO_MIN;
30008c08:	e59d3014 	ldr	r3, [sp, #20]
30008c0c:	e2833016 	add	r3, r3, #22
30008c10:	e58d3014 	str	r3, [sp, #20]
			if(prio>=ACORAL_BASE_PRIO_MAX)
30008c14:	e59d3014 	ldr	r3, [sp, #20]
30008c18:	e3530062 	cmp	r3, #98	; 0x62
30008c1c:	9a000001 	bls	30008c28 <period_policy_thread_init+0x84>
				prio=ACORAL_BASE_PRIO_MAX-1;
30008c20:	e3a03062 	mov	r3, #98	; 0x62
30008c24:	e58d3014 	str	r3, [sp, #20]
		}
		thread->prio=prio;
30008c28:	e59d3014 	ldr	r3, [sp, #20]
30008c2c:	e20320ff 	and	r2, r3, #255	; 0xff
30008c30:	e59d300c 	ldr	r3, [sp, #12]
30008c34:	e5c32005 	strb	r2, [r3, #5]
		private_data=(period_policy_data_t *)acoral_malloc2(sizeof(period_policy_data_t));
30008c38:	e3a0000c 	mov	r0, #12
30008c3c:	ebfff7f4 	bl	30006c14 <v_malloc>
30008c40:	e1a03000 	mov	r3, r0
30008c44:	e58d301c 	str	r3, [sp, #28]
		if(private_data==NULL){
30008c48:	e59d301c 	ldr	r3, [sp, #28]
30008c4c:	e3530000 	cmp	r3, #0
30008c50:	1a00000e 	bne	30008c90 <period_policy_thread_init+0xec>
			acoral_printerr("No level2 mem space for private_data:%s\n",thread->name);
30008c54:	e59d300c 	ldr	r3, [sp, #12]
30008c58:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30008c5c:	e59f0118 	ldr	r0, [pc, #280]	; 30008d7c <period_policy_thread_init+0x1d8>
30008c60:	e1a01003 	mov	r1, r3
30008c64:	eb000975 	bl	3000b240 <acoral_print>
			HAL_ENTER_CRITICAL();
30008c68:	ebffe2a1 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30008c6c:	e1a03000 	mov	r3, r0
30008c70:	e58d3010 	str	r3, [sp, #16]
			acoral_release_res((acoral_res_t *)thread);
30008c74:	e59d300c 	ldr	r3, [sp, #12]
30008c78:	e1a00003 	mov	r0, r3
30008c7c:	ebffea6d 	bl	30003638 <acoral_release_res>
			HAL_EXIT_CRITICAL();
30008c80:	e59d0010 	ldr	r0, [sp, #16]
30008c84:	ebffe298 	bl	300016ec <HAL_INTR_RESTORE>
			return -1;
30008c88:	e3e03000 	mvn	r3, #0
30008c8c:	ea000036 	b	30008d6c <period_policy_thread_init+0x1c8>
		}
		private_data->time=policy_data->time;
30008c90:	e59d3018 	ldr	r3, [sp, #24]
30008c94:	e5932004 	ldr	r2, [r3, #4]
30008c98:	e59d301c 	ldr	r3, [sp, #28]
30008c9c:	e5832000 	str	r2, [r3]
		private_data->route=route;
30008ca0:	e59d301c 	ldr	r3, [sp, #28]
30008ca4:	e59d2008 	ldr	r2, [sp, #8]
30008ca8:	e5832004 	str	r2, [r3, #4]
		private_data->args=args;
30008cac:	e59d301c 	ldr	r3, [sp, #28]
30008cb0:	e59d2004 	ldr	r2, [sp, #4]
30008cb4:	e5832008 	str	r2, [r3, #8]
		thread->private_data=private_data;
30008cb8:	e59d300c 	ldr	r3, [sp, #12]
30008cbc:	e59d201c 	ldr	r2, [sp, #28]
30008cc0:	e5832050 	str	r2, [r3, #80]	; 0x50
		thread->cpu_mask=-1;
30008cc4:	e59d300c 	ldr	r3, [sp, #12]
30008cc8:	e3e02000 	mvn	r2, #0
30008ccc:	e5832008 	str	r2, [r3, #8]
	}
	if(acoral_thread_init(thread,route,period_thread_exit,args)!=0){
30008cd0:	e59f30a8 	ldr	r3, [pc, #168]	; 30008d80 <period_policy_thread_init+0x1dc>
30008cd4:	e59d000c 	ldr	r0, [sp, #12]
30008cd8:	e59d1008 	ldr	r1, [sp, #8]
30008cdc:	e1a02003 	mov	r2, r3
30008ce0:	e59d3004 	ldr	r3, [sp, #4]
30008ce4:	ebffe7e9 	bl	30002c90 <acoral_thread_init>
30008ce8:	e1a03000 	mov	r3, r0
30008cec:	e3530000 	cmp	r3, #0
30008cf0:	0a00000e 	beq	30008d30 <period_policy_thread_init+0x18c>
		acoral_printerr("No thread stack:%s\n",thread->name);
30008cf4:	e59d300c 	ldr	r3, [sp, #12]
30008cf8:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30008cfc:	e59f0080 	ldr	r0, [pc, #128]	; 30008d84 <period_policy_thread_init+0x1e0>
30008d00:	e1a01003 	mov	r1, r3
30008d04:	eb00094d 	bl	3000b240 <acoral_print>
		HAL_ENTER_CRITICAL();
30008d08:	ebffe279 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30008d0c:	e1a03000 	mov	r3, r0
30008d10:	e58d3010 	str	r3, [sp, #16]
		acoral_release_res((acoral_res_t *)thread);
30008d14:	e59d300c 	ldr	r3, [sp, #12]
30008d18:	e1a00003 	mov	r0, r3
30008d1c:	ebffea45 	bl	30003638 <acoral_release_res>
		HAL_EXIT_CRITICAL();
30008d20:	e59d0010 	ldr	r0, [sp, #16]
30008d24:	ebffe270 	bl	300016ec <HAL_INTR_RESTORE>
		return -1;
30008d28:	e3e03000 	mvn	r3, #0
30008d2c:	ea00000e 	b	30008d6c <period_policy_thread_init+0x1c8>
	}
        /*将线程就绪，并重新调度*/
	acoral_resume_thread(thread);
30008d30:	e59d000c 	ldr	r0, [sp, #12]
30008d34:	ebffe6cc 	bl	3000286c <acoral_resume_thread>
	HAL_ENTER_CRITICAL();
30008d38:	ebffe26d 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30008d3c:	e1a03000 	mov	r3, r0
30008d40:	e58d3010 	str	r3, [sp, #16]
	period_thread_delay(thread,((period_policy_data_t *)thread->private_data)->time);
30008d44:	e59d300c 	ldr	r3, [sp, #12]
30008d48:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30008d4c:	e5933000 	ldr	r3, [r3]
30008d50:	e59d000c 	ldr	r0, [sp, #12]
30008d54:	e1a01003 	mov	r1, r3
30008d58:	eb000057 	bl	30008ebc <period_thread_delay>
	HAL_EXIT_CRITICAL();
30008d5c:	e59d0010 	ldr	r0, [sp, #16]
30008d60:	ebffe261 	bl	300016ec <HAL_INTR_RESTORE>
	return thread->res.id;
30008d64:	e59d300c 	ldr	r3, [sp, #12]
30008d68:	e5933000 	ldr	r3, [r3]
}
30008d6c:	e1a00003 	mov	r0, r3
30008d70:	e28dd024 	add	sp, sp, #36	; 0x24
30008d74:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30008d78:	e12fff1e 	bx	lr
30008d7c:	300454f4 	.word	0x300454f4
30008d80:	3000909c 	.word	0x3000909c
30008d84:	30045520 	.word	0x30045520

30008d88 <period_policy_thread_release>:

void period_policy_thread_release(acoral_thread_t *thread){
30008d88:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008d8c:	e24dd00c 	sub	sp, sp, #12
30008d90:	e58d0004 	str	r0, [sp, #4]
	acoral_free2(thread->private_data);	
30008d94:	e59d3004 	ldr	r3, [sp, #4]
30008d98:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30008d9c:	e1a00003 	mov	r0, r3
30008da0:	ebfff7b0 	bl	30006c68 <v_free>
}
30008da4:	e28dd00c 	add	sp, sp, #12
30008da8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30008dac:	e12fff1e 	bx	lr

30008db0 <acoral_periodqueue_add>:

void acoral_periodqueue_add(acoral_thread_t *new){
30008db0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008db4:	e24dd024 	sub	sp, sp, #36	; 0x24
30008db8:	e58d0004 	str	r0, [sp, #4]
	acoral_list_t   *tmp,*head;
	acoral_thread_t *thread;
	acoral_32  delay2;
	acoral_32  delay= new->delay;
30008dbc:	e59d3004 	ldr	r3, [sp, #4]
30008dc0:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30008dc4:	e58d301c 	str	r3, [sp, #28]
	head=&period_delay_queue.head;
30008dc8:	e59f30e8 	ldr	r3, [pc, #232]	; 30008eb8 <acoral_periodqueue_add+0x108>
30008dcc:	e58d3010 	str	r3, [sp, #16]
	acoral_spin_lock(&head->lock);
	new->state|=ACORAL_THREAD_STATE_DELAY;
30008dd0:	e59d3004 	ldr	r3, [sp, #4]
30008dd4:	e5d33004 	ldrb	r3, [r3, #4]
30008dd8:	e3833020 	orr	r3, r3, #32
30008ddc:	e20320ff 	and	r2, r3, #255	; 0xff
30008de0:	e59d3004 	ldr	r3, [sp, #4]
30008de4:	e5c32004 	strb	r2, [r3, #4]
	for (tmp=head->next;delay2=delay,tmp!=head; tmp=tmp->next){
30008de8:	e59d3010 	ldr	r3, [sp, #16]
30008dec:	e5933000 	ldr	r3, [r3]
30008df0:	e58d300c 	str	r3, [sp, #12]
30008df4:	ea00000d 	b	30008e30 <acoral_periodqueue_add+0x80>
		thread = list_entry (tmp, acoral_thread_t, waiting);
30008df8:	e59d300c 	ldr	r3, [sp, #12]
30008dfc:	e2433020 	sub	r3, r3, #32
30008e00:	e58d3014 	str	r3, [sp, #20]
		delay  = delay-thread->delay;
30008e04:	e59d3014 	ldr	r3, [sp, #20]
30008e08:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30008e0c:	e59d201c 	ldr	r2, [sp, #28]
30008e10:	e0633002 	rsb	r3, r3, r2
30008e14:	e58d301c 	str	r3, [sp, #28]
		if (delay < 0)
30008e18:	e59d301c 	ldr	r3, [sp, #28]
30008e1c:	e3530000 	cmp	r3, #0
30008e20:	ba000009 	blt	30008e4c <acoral_periodqueue_add+0x9c>
	acoral_32  delay2;
	acoral_32  delay= new->delay;
	head=&period_delay_queue.head;
	acoral_spin_lock(&head->lock);
	new->state|=ACORAL_THREAD_STATE_DELAY;
	for (tmp=head->next;delay2=delay,tmp!=head; tmp=tmp->next){
30008e24:	e59d300c 	ldr	r3, [sp, #12]
30008e28:	e5933000 	ldr	r3, [r3]
30008e2c:	e58d300c 	str	r3, [sp, #12]
30008e30:	e59d301c 	ldr	r3, [sp, #28]
30008e34:	e58d3018 	str	r3, [sp, #24]
30008e38:	e59d200c 	ldr	r2, [sp, #12]
30008e3c:	e59d3010 	ldr	r3, [sp, #16]
30008e40:	e1520003 	cmp	r2, r3
30008e44:	1affffeb 	bne	30008df8 <acoral_periodqueue_add+0x48>
30008e48:	ea000000 	b	30008e50 <acoral_periodqueue_add+0xa0>
		thread = list_entry (tmp, acoral_thread_t, waiting);
		delay  = delay-thread->delay;
		if (delay < 0)
			break;
30008e4c:	e1a00000 	nop			; (mov r0, r0)
	}
	new->delay = delay2;
30008e50:	e59d3004 	ldr	r3, [sp, #4]
30008e54:	e59d2018 	ldr	r2, [sp, #24]
30008e58:	e5832040 	str	r2, [r3, #64]	; 0x40
	acoral_list_add(&new->waiting,tmp->prev);
30008e5c:	e59d3004 	ldr	r3, [sp, #4]
30008e60:	e2832020 	add	r2, r3, #32
30008e64:	e59d300c 	ldr	r3, [sp, #12]
30008e68:	e5933004 	ldr	r3, [r3, #4]
30008e6c:	e1a00002 	mov	r0, r2
30008e70:	e1a01003 	mov	r1, r3
30008e74:	eb00044c 	bl	30009fac <acoral_list_add>
	/* 插入等待任务后，后继等待任务时间处理*/
	if(tmp != head){
30008e78:	e59d200c 	ldr	r2, [sp, #12]
30008e7c:	e59d3010 	ldr	r3, [sp, #16]
30008e80:	e1520003 	cmp	r2, r3
30008e84:	0a000008 	beq	30008eac <acoral_periodqueue_add+0xfc>
		thread = list_entry(tmp, acoral_thread_t, waiting);
30008e88:	e59d300c 	ldr	r3, [sp, #12]
30008e8c:	e2433020 	sub	r3, r3, #32
30008e90:	e58d3014 	str	r3, [sp, #20]
		thread->delay-=delay2;
30008e94:	e59d3014 	ldr	r3, [sp, #20]
30008e98:	e5932040 	ldr	r2, [r3, #64]	; 0x40
30008e9c:	e59d3018 	ldr	r3, [sp, #24]
30008ea0:	e0632002 	rsb	r2, r3, r2
30008ea4:	e59d3014 	ldr	r3, [sp, #20]
30008ea8:	e5832040 	str	r2, [r3, #64]	; 0x40
	}
	acoral_spin_unlock(&head->lock);
}
30008eac:	e28dd024 	add	sp, sp, #36	; 0x24
30008eb0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30008eb4:	e12fff1e 	bx	lr
30008eb8:	3012ac8c 	.word	0x3012ac8c

30008ebc <period_thread_delay>:

void period_thread_delay(acoral_thread_t* thread,acoral_time time){
30008ebc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008ec0:	e24dd00c 	sub	sp, sp, #12
30008ec4:	e58d0004 	str	r0, [sp, #4]
30008ec8:	e58d1000 	str	r1, [sp]
	thread->delay=TIME_TO_TICKS(time);
30008ecc:	e59d2000 	ldr	r2, [sp]
30008ed0:	e1a03002 	mov	r3, r2
30008ed4:	e1a03103 	lsl	r3, r3, #2
30008ed8:	e0833002 	add	r3, r3, r2
30008edc:	e1a02103 	lsl	r2, r3, #2
30008ee0:	e0833002 	add	r3, r3, r2
30008ee4:	e1a03103 	lsl	r3, r3, #2
30008ee8:	e1a02003 	mov	r2, r3
30008eec:	e59f3024 	ldr	r3, [pc, #36]	; 30008f18 <period_thread_delay+0x5c>
30008ef0:	e0831392 	umull	r1, r3, r2, r3
30008ef4:	e1a03323 	lsr	r3, r3, #6
30008ef8:	e1a02003 	mov	r2, r3
30008efc:	e59d3004 	ldr	r3, [sp, #4]
30008f00:	e5832040 	str	r2, [r3, #64]	; 0x40
	acoral_periodqueue_add(thread);
30008f04:	e59d0004 	ldr	r0, [sp, #4]
30008f08:	ebffffa8 	bl	30008db0 <acoral_periodqueue_add>
}
30008f0c:	e28dd00c 	add	sp, sp, #12
30008f10:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30008f14:	e12fff1e 	bx	lr
30008f18:	10624dd3 	.word	0x10624dd3

30008f1c <period_delay_deal>:

void period_delay_deal(){
30008f1c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30008f20:	e24dd01c 	sub	sp, sp, #28
	acoral_list_t *tmp,*tmp1,*head;
	acoral_thread_t * thread;
	period_policy_data_t * private_data;
	head=&period_delay_queue.head;
30008f24:	e59f3160 	ldr	r3, [pc, #352]	; 3000908c <period_delay_deal+0x170>
30008f28:	e58d300c 	str	r3, [sp, #12]
	if(acoral_list_empty(head))
30008f2c:	e59d300c 	ldr	r3, [sp, #12]
30008f30:	e5932000 	ldr	r2, [r3]
30008f34:	e59d300c 	ldr	r3, [sp, #12]
30008f38:	e1520003 	cmp	r2, r3
30008f3c:	0a00004c 	beq	30009074 <period_delay_deal+0x158>
	    	return;
	thread=list_entry(head->next,acoral_thread_t,waiting);
30008f40:	e59d300c 	ldr	r3, [sp, #12]
30008f44:	e5933000 	ldr	r3, [r3]
30008f48:	e2433020 	sub	r3, r3, #32
30008f4c:	e58d3010 	str	r3, [sp, #16]
	ACORAL_ASSERT(thread,"in period thread deal");
30008f50:	e59d2010 	ldr	r2, [sp, #16]
30008f54:	e59f3134 	ldr	r3, [pc, #308]	; 30009090 <period_delay_deal+0x174>
30008f58:	e1a00002 	mov	r0, r2
30008f5c:	e1a01003 	mov	r1, r3
30008f60:	ebffeb3b 	bl	30003c54 <acoral_assert_res>
	thread->delay--;
30008f64:	e59d3010 	ldr	r3, [sp, #16]
30008f68:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30008f6c:	e2432001 	sub	r2, r3, #1
30008f70:	e59d3010 	ldr	r3, [sp, #16]
30008f74:	e5832040 	str	r2, [r3, #64]	; 0x40
	for(tmp=head->next;tmp!=head;){
30008f78:	e59d300c 	ldr	r3, [sp, #12]
30008f7c:	e5933000 	ldr	r3, [r3]
30008f80:	e58d3004 	str	r3, [sp, #4]
30008f84:	ea000035 	b	30009060 <period_delay_deal+0x144>
		thread=list_entry(tmp,acoral_thread_t,waiting);
30008f88:	e59d3004 	ldr	r3, [sp, #4]
30008f8c:	e2433020 	sub	r3, r3, #32
30008f90:	e58d3010 	str	r3, [sp, #16]
		ACORAL_ASSERT(thread,"in period thread deal ");
30008f94:	e59d2010 	ldr	r2, [sp, #16]
30008f98:	e59f30f4 	ldr	r3, [pc, #244]	; 30009094 <period_delay_deal+0x178>
30008f9c:	e1a00002 	mov	r0, r2
30008fa0:	e1a01003 	mov	r1, r3
30008fa4:	ebffeb2a 	bl	30003c54 <acoral_assert_res>
		if(thread->delay>0)
30008fa8:	e59d3010 	ldr	r3, [sp, #16]
30008fac:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30008fb0:	e3530000 	cmp	r3, #0
30008fb4:	ca000030 	bgt	3000907c <period_delay_deal+0x160>
		    break;
		private_data=thread->private_data;
30008fb8:	e59d3010 	ldr	r3, [sp, #16]
30008fbc:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30008fc0:	e58d3014 	str	r3, [sp, #20]
		/*防止add判断delay时取下thread*/
		acoral_spin_lock(&head->lock);
		tmp1=tmp->next;
30008fc4:	e59d3004 	ldr	r3, [sp, #4]
30008fc8:	e5933000 	ldr	r3, [r3]
30008fcc:	e58d3008 	str	r3, [sp, #8]
		acoral_list_del(&thread->waiting);
30008fd0:	e59d3010 	ldr	r3, [sp, #16]
30008fd4:	e2833020 	add	r3, r3, #32
30008fd8:	e1a00003 	mov	r0, r3
30008fdc:	eb000418 	bl	3000a044 <acoral_list_del>
		tmp=tmp1;
30008fe0:	e59d3008 	ldr	r3, [sp, #8]
30008fe4:	e58d3004 	str	r3, [sp, #4]
		acoral_spin_unlock(&head->lock);
		if(thread->state&ACORAL_THREAD_STATE_SUSPEND){
30008fe8:	e59d3010 	ldr	r3, [sp, #16]
30008fec:	e5d33004 	ldrb	r3, [r3, #4]
30008ff0:	e2033002 	and	r3, r3, #2
30008ff4:	e3530000 	cmp	r3, #0
30008ff8:	0a000013 	beq	3000904c <period_delay_deal+0x130>
			thread->stack=(acoral_u32 *)((acoral_8 *)thread->stack_buttom+thread->stack_size-4);
30008ffc:	e59d3010 	ldr	r3, [sp, #16]
30009000:	e5932038 	ldr	r2, [r3, #56]	; 0x38
30009004:	e59d3010 	ldr	r3, [sp, #16]
30009008:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
3000900c:	e2433004 	sub	r3, r3, #4
30009010:	e0822003 	add	r2, r2, r3
30009014:	e59d3010 	ldr	r3, [sp, #16]
30009018:	e5832034 	str	r2, [r3, #52]	; 0x34
			HAL_STACK_INIT(&thread->stack,private_data->route,period_thread_exit,private_data->args);
3000901c:	e59d3010 	ldr	r3, [sp, #16]
30009020:	e2831034 	add	r1, r3, #52	; 0x34
30009024:	e59d3014 	ldr	r3, [sp, #20]
30009028:	e5932004 	ldr	r2, [r3, #4]
3000902c:	e59d3014 	ldr	r3, [sp, #20]
30009030:	e5933008 	ldr	r3, [r3, #8]
30009034:	e1a00001 	mov	r0, r1
30009038:	e1a01002 	mov	r1, r2
3000903c:	e59f2054 	ldr	r2, [pc, #84]	; 30009098 <period_delay_deal+0x17c>
30009040:	ebffdc9e 	bl	300002c0 <hal_stack_init>
			acoral_rdy_thread(thread);
30009044:	e59d0010 	ldr	r0, [sp, #16]
30009048:	ebffe6ce 	bl	30002b88 <acoral_rdy_thread>
		}
		period_thread_delay(thread,private_data->time);
3000904c:	e59d3014 	ldr	r3, [sp, #20]
30009050:	e5933000 	ldr	r3, [r3]
30009054:	e59d0010 	ldr	r0, [sp, #16]
30009058:	e1a01003 	mov	r1, r3
3000905c:	ebffff96 	bl	30008ebc <period_thread_delay>
	if(acoral_list_empty(head))
	    	return;
	thread=list_entry(head->next,acoral_thread_t,waiting);
	ACORAL_ASSERT(thread,"in period thread deal");
	thread->delay--;
	for(tmp=head->next;tmp!=head;){
30009060:	e59d2004 	ldr	r2, [sp, #4]
30009064:	e59d300c 	ldr	r3, [sp, #12]
30009068:	e1520003 	cmp	r2, r3
3000906c:	1affffc5 	bne	30008f88 <period_delay_deal+0x6c>
30009070:	ea000002 	b	30009080 <period_delay_deal+0x164>
	acoral_list_t *tmp,*tmp1,*head;
	acoral_thread_t * thread;
	period_policy_data_t * private_data;
	head=&period_delay_queue.head;
	if(acoral_list_empty(head))
	    	return;
30009074:	e1a00000 	nop			; (mov r0, r0)
30009078:	ea000000 	b	30009080 <period_delay_deal+0x164>
	thread->delay--;
	for(tmp=head->next;tmp!=head;){
		thread=list_entry(tmp,acoral_thread_t,waiting);
		ACORAL_ASSERT(thread,"in period thread deal ");
		if(thread->delay>0)
		    break;
3000907c:	e1a00000 	nop			; (mov r0, r0)
			HAL_STACK_INIT(&thread->stack,private_data->route,period_thread_exit,private_data->args);
			acoral_rdy_thread(thread);
		}
		period_thread_delay(thread,private_data->time);
	}
}
30009080:	e28dd01c 	add	sp, sp, #28
30009084:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009088:	e12fff1e 	bx	lr
3000908c:	3012ac8c 	.word	0x3012ac8c
30009090:	30045534 	.word	0x30045534
30009094:	3004554c 	.word	0x3004554c
30009098:	3000909c 	.word	0x3000909c

3000909c <period_thread_exit>:

void period_thread_exit(){
3000909c:	e92d4008 	push	{r3, lr}
	acoral_suspend_self();
300090a0:	ebffe5cf 	bl	300027e4 <acoral_suspend_self>
}
300090a4:	e8bd4008 	pop	{r3, lr}
300090a8:	e12fff1e 	bx	lr

300090ac <period_policy_init>:

acoral_sched_policy_t period_policy;
void period_policy_init(){
300090ac:	e92d4008 	push	{r3, lr}
	acoral_list_init(&period_delay_queue.head);
300090b0:	e59f305c 	ldr	r3, [pc, #92]	; 30009114 <period_policy_init+0x68>
300090b4:	e59f2058 	ldr	r2, [pc, #88]	; 30009114 <period_policy_init+0x68>
300090b8:	e5832000 	str	r2, [r3]
300090bc:	e59f3050 	ldr	r3, [pc, #80]	; 30009114 <period_policy_init+0x68>
300090c0:	e59f204c 	ldr	r2, [pc, #76]	; 30009114 <period_policy_init+0x68>
300090c4:	e5832004 	str	r2, [r3, #4]
	acoral_spin_init(&period_delay_queue.head.lock);
	period_policy.type=ACORAL_SCHED_POLICY_PERIOD;
300090c8:	e59f3048 	ldr	r3, [pc, #72]	; 30009118 <period_policy_init+0x6c>
300090cc:	e3a02016 	mov	r2, #22
300090d0:	e5c32008 	strb	r2, [r3, #8]
	period_policy.policy_thread_init=period_policy_thread_init;
300090d4:	e59f303c 	ldr	r3, [pc, #60]	; 30009118 <period_policy_init+0x6c>
300090d8:	e59f203c 	ldr	r2, [pc, #60]	; 3000911c <period_policy_init+0x70>
300090dc:	e583200c 	str	r2, [r3, #12]
	period_policy.policy_thread_release=period_policy_thread_release;
300090e0:	e59f3030 	ldr	r3, [pc, #48]	; 30009118 <period_policy_init+0x6c>
300090e4:	e59f2034 	ldr	r2, [pc, #52]	; 30009120 <period_policy_init+0x74>
300090e8:	e5832010 	str	r2, [r3, #16]
	period_policy.delay_deal=period_delay_deal;
300090ec:	e59f3024 	ldr	r3, [pc, #36]	; 30009118 <period_policy_init+0x6c>
300090f0:	e59f202c 	ldr	r2, [pc, #44]	; 30009124 <period_policy_init+0x78>
300090f4:	e5832014 	str	r2, [r3, #20]
	period_policy.name="period";
300090f8:	e59f3018 	ldr	r3, [pc, #24]	; 30009118 <period_policy_init+0x6c>
300090fc:	e59f2024 	ldr	r2, [pc, #36]	; 30009128 <period_policy_init+0x7c>
30009100:	e5832018 	str	r2, [r3, #24]
	acoral_register_sched_policy(&period_policy);
30009104:	e59f000c 	ldr	r0, [pc, #12]	; 30009118 <period_policy_init+0x6c>
30009108:	ebffe34e 	bl	30001e48 <acoral_register_sched_policy>
}
3000910c:	e8bd4008 	pop	{r3, lr}
30009110:	e12fff1e 	bx	lr
30009114:	3012ac8c 	.word	0x3012ac8c
30009118:	302f7e04 	.word	0x302f7e04
3000911c:	30008ba4 	.word	0x30008ba4
30009120:	30008d88 	.word	0x30008d88
30009124:	30008f1c 	.word	0x30008f1c
30009128:	30045564 	.word	0x30045564

3000912c <slice_policy_thread_init>:
#include<policy.h>
#include<timer.h>
#include<mem.h>
#include<slice_thrd.h>
acoral_sched_policy_t slice_policy;
acoral_id slice_policy_thread_init(acoral_thread_t *thread,void (*route)(void *args),void *args,void *data){
3000912c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009130:	e24dd024 	sub	sp, sp, #36	; 0x24
30009134:	e58d000c 	str	r0, [sp, #12]
30009138:	e58d1008 	str	r1, [sp, #8]
3000913c:	e58d2004 	str	r2, [sp, #4]
30009140:	e58d3000 	str	r3, [sp]
	acoral_sr cpu_sr;
	acoral_u32 prio;
	acoral_slice_policy_data_t *policy_data;
	slice_policy_data_t *private_data;
	if(thread->policy==ACORAL_SCHED_POLICY_SLICE){
30009144:	e59d300c 	ldr	r3, [sp, #12]
30009148:	e5d3300c 	ldrb	r3, [r3, #12]
3000914c:	e3530018 	cmp	r3, #24
30009150:	1a000046 	bne	30009270 <slice_policy_thread_init+0x144>
		policy_data=(acoral_slice_policy_data_t *)data;
30009154:	e59d3000 	ldr	r3, [sp]
30009158:	e58d3018 	str	r3, [sp, #24]
		thread->cpu=policy_data->cpu;
3000915c:	e59d3018 	ldr	r3, [sp, #24]
30009160:	e5d32000 	ldrb	r2, [r3]
30009164:	e59d300c 	ldr	r3, [sp, #12]
30009168:	e5c32006 	strb	r2, [r3, #6]
		prio=policy_data->prio;
3000916c:	e59d3018 	ldr	r3, [sp, #24]
30009170:	e5d33001 	ldrb	r3, [r3, #1]
30009174:	e58d3014 	str	r3, [sp, #20]
		if(policy_data->prio_type==ACORAL_BASE_PRIO){
30009178:	e59d3018 	ldr	r3, [sp, #24]
3000917c:	e5d33002 	ldrb	r3, [r3, #2]
30009180:	e3530002 	cmp	r3, #2
30009184:	1a000007 	bne	300091a8 <slice_policy_thread_init+0x7c>
			prio+=ACORAL_BASE_PRIO_MIN;
30009188:	e59d3014 	ldr	r3, [sp, #20]
3000918c:	e2833016 	add	r3, r3, #22
30009190:	e58d3014 	str	r3, [sp, #20]
			if(prio>=ACORAL_BASE_PRIO_MAX)
30009194:	e59d3014 	ldr	r3, [sp, #20]
30009198:	e3530062 	cmp	r3, #98	; 0x62
3000919c:	9a000001 	bls	300091a8 <slice_policy_thread_init+0x7c>
				prio=ACORAL_BASE_PRIO_MAX-1;
300091a0:	e3a03062 	mov	r3, #98	; 0x62
300091a4:	e58d3014 	str	r3, [sp, #20]
		}
		thread->prio=prio;
300091a8:	e59d3014 	ldr	r3, [sp, #20]
300091ac:	e20320ff 	and	r2, r3, #255	; 0xff
300091b0:	e59d300c 	ldr	r3, [sp, #12]
300091b4:	e5c32005 	strb	r2, [r3, #5]
		private_data=(slice_policy_data_t *)acoral_malloc2(sizeof(slice_policy_data_t));
300091b8:	e3a00004 	mov	r0, #4
300091bc:	ebfff694 	bl	30006c14 <v_malloc>
300091c0:	e1a03000 	mov	r3, r0
300091c4:	e58d301c 	str	r3, [sp, #28]
		if(private_data==NULL){
300091c8:	e59d301c 	ldr	r3, [sp, #28]
300091cc:	e3530000 	cmp	r3, #0
300091d0:	1a00000e 	bne	30009210 <slice_policy_thread_init+0xe4>
			acoral_printerr("No level2 mem space for private_data:%s\n",thread->name);
300091d4:	e59d300c 	ldr	r3, [sp, #12]
300091d8:	e5933048 	ldr	r3, [r3, #72]	; 0x48
300091dc:	e59f0108 	ldr	r0, [pc, #264]	; 300092ec <slice_policy_thread_init+0x1c0>
300091e0:	e1a01003 	mov	r1, r3
300091e4:	eb000815 	bl	3000b240 <acoral_print>
			HAL_ENTER_CRITICAL();
300091e8:	ebffe141 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300091ec:	e1a03000 	mov	r3, r0
300091f0:	e58d3010 	str	r3, [sp, #16]
			acoral_release_res((acoral_res_t *)thread);
300091f4:	e59d300c 	ldr	r3, [sp, #12]
300091f8:	e1a00003 	mov	r0, r3
300091fc:	ebffe90d 	bl	30003638 <acoral_release_res>
			HAL_EXIT_CRITICAL();
30009200:	e59d0010 	ldr	r0, [sp, #16]
30009204:	ebffe138 	bl	300016ec <HAL_INTR_RESTORE>
			return -1;
30009208:	e3e03000 	mvn	r3, #0
3000920c:	ea000032 	b	300092dc <slice_policy_thread_init+0x1b0>
		}
		private_data->slice_ld=TIME_TO_TICKS(policy_data->slice);
30009210:	e59d3018 	ldr	r3, [sp, #24]
30009214:	e5932004 	ldr	r2, [r3, #4]
30009218:	e1a03002 	mov	r3, r2
3000921c:	e1a03103 	lsl	r3, r3, #2
30009220:	e0833002 	add	r3, r3, r2
30009224:	e1a02103 	lsl	r2, r3, #2
30009228:	e0833002 	add	r3, r3, r2
3000922c:	e1a03103 	lsl	r3, r3, #2
30009230:	e1a02003 	mov	r2, r3
30009234:	e59f30b4 	ldr	r3, [pc, #180]	; 300092f0 <slice_policy_thread_init+0x1c4>
30009238:	e0831392 	umull	r1, r3, r2, r3
3000923c:	e1a02323 	lsr	r2, r3, #6
30009240:	e59d301c 	ldr	r3, [sp, #28]
30009244:	e5832000 	str	r2, [r3]
		thread->slice=private_data->slice_ld;
30009248:	e59d301c 	ldr	r3, [sp, #28]
3000924c:	e5932000 	ldr	r2, [r3]
30009250:	e59d300c 	ldr	r3, [sp, #12]
30009254:	e5832044 	str	r2, [r3, #68]	; 0x44
		thread->private_data=private_data;
30009258:	e59d300c 	ldr	r3, [sp, #12]
3000925c:	e59d201c 	ldr	r2, [sp, #28]
30009260:	e5832050 	str	r2, [r3, #80]	; 0x50
		thread->cpu_mask=-1;
30009264:	e59d300c 	ldr	r3, [sp, #12]
30009268:	e3e02000 	mvn	r2, #0
3000926c:	e5832008 	str	r2, [r3, #8]
	}
	if(acoral_thread_init(thread,route,acoral_thread_exit,args)!=0){
30009270:	e59d000c 	ldr	r0, [sp, #12]
30009274:	e59d1008 	ldr	r1, [sp, #8]
30009278:	e59f2074 	ldr	r2, [pc, #116]	; 300092f4 <slice_policy_thread_init+0x1c8>
3000927c:	e59d3004 	ldr	r3, [sp, #4]
30009280:	ebffe682 	bl	30002c90 <acoral_thread_init>
30009284:	e1a03000 	mov	r3, r0
30009288:	e3530000 	cmp	r3, #0
3000928c:	0a00000e 	beq	300092cc <slice_policy_thread_init+0x1a0>
		acoral_printerr("No thread stack:%s\n",thread->name);
30009290:	e59d300c 	ldr	r3, [sp, #12]
30009294:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30009298:	e59f0058 	ldr	r0, [pc, #88]	; 300092f8 <slice_policy_thread_init+0x1cc>
3000929c:	e1a01003 	mov	r1, r3
300092a0:	eb0007e6 	bl	3000b240 <acoral_print>
		HAL_ENTER_CRITICAL();
300092a4:	ebffe112 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300092a8:	e1a03000 	mov	r3, r0
300092ac:	e58d3010 	str	r3, [sp, #16]
		acoral_release_res((acoral_res_t *)thread);
300092b0:	e59d300c 	ldr	r3, [sp, #12]
300092b4:	e1a00003 	mov	r0, r3
300092b8:	ebffe8de 	bl	30003638 <acoral_release_res>
		HAL_EXIT_CRITICAL();
300092bc:	e59d0010 	ldr	r0, [sp, #16]
300092c0:	ebffe109 	bl	300016ec <HAL_INTR_RESTORE>
		return -1;
300092c4:	e3e03000 	mvn	r3, #0
300092c8:	ea000003 	b	300092dc <slice_policy_thread_init+0x1b0>
	}
        /*将线程就绪，并重新调度*/
	acoral_resume_thread(thread);
300092cc:	e59d000c 	ldr	r0, [sp, #12]
300092d0:	ebffe565 	bl	3000286c <acoral_resume_thread>
	return thread->res.id;
300092d4:	e59d300c 	ldr	r3, [sp, #12]
300092d8:	e5933000 	ldr	r3, [r3]
}
300092dc:	e1a00003 	mov	r0, r3
300092e0:	e28dd024 	add	sp, sp, #36	; 0x24
300092e4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300092e8:	e12fff1e 	bx	lr
300092ec:	3004556c 	.word	0x3004556c
300092f0:	10624dd3 	.word	0x10624dd3
300092f4:	30002a80 	.word	0x30002a80
300092f8:	30045598 	.word	0x30045598

300092fc <slice_policy_thread_release>:

void slice_policy_thread_release(acoral_thread_t *thread){
300092fc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009300:	e24dd00c 	sub	sp, sp, #12
30009304:	e58d0004 	str	r0, [sp, #4]
	acoral_free2(thread->private_data);	
30009308:	e59d3004 	ldr	r3, [sp, #4]
3000930c:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30009310:	e1a00003 	mov	r0, r3
30009314:	ebfff653 	bl	30006c68 <v_free>
}
30009318:	e28dd00c 	add	sp, sp, #12
3000931c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009320:	e12fff1e 	bx	lr

30009324 <slice_delay_deal>:

void slice_delay_deal(){
30009324:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009328:	e24dd00c 	sub	sp, sp, #12
#ifndef CFG_TICKS_PRIVATE
	acoral_u32 i;
	for(i=0;i<HAL_MAX_CPU;i++){
		cur=acoral_get_running_thread(i);
#else
		cur=acoral_cur_thread;
3000932c:	e59f3068 	ldr	r3, [pc, #104]	; 3000939c <slice_delay_deal+0x78>
30009330:	e5933000 	ldr	r3, [r3]
30009334:	e58d3000 	str	r3, [sp]
#endif
		if(cur->policy==ACORAL_SCHED_POLICY_SLICE){
30009338:	e59d3000 	ldr	r3, [sp]
3000933c:	e5d3300c 	ldrb	r3, [r3, #12]
30009340:	e3530018 	cmp	r3, #24
30009344:	1a000011 	bne	30009390 <slice_delay_deal+0x6c>
			cur->slice--;
30009348:	e59d3000 	ldr	r3, [sp]
3000934c:	e5933044 	ldr	r3, [r3, #68]	; 0x44
30009350:	e2432001 	sub	r2, r3, #1
30009354:	e59d3000 	ldr	r3, [sp]
30009358:	e5832044 	str	r2, [r3, #68]	; 0x44
			if(cur->slice<=0){
3000935c:	e59d3000 	ldr	r3, [sp]
30009360:	e5933044 	ldr	r3, [r3, #68]	; 0x44
30009364:	e3530000 	cmp	r3, #0
30009368:	1a000008 	bne	30009390 <slice_delay_deal+0x6c>
				data=(slice_policy_data_t *)cur->private_data;
3000936c:	e59d3000 	ldr	r3, [sp]
30009370:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30009374:	e58d3004 	str	r3, [sp, #4]
				cur->slice=data->slice_ld;
30009378:	e59d3004 	ldr	r3, [sp, #4]
3000937c:	e5932000 	ldr	r2, [r3]
30009380:	e59d3000 	ldr	r3, [sp]
30009384:	e5832044 	str	r2, [r3, #68]	; 0x44
				acoral_thread_move2_tail(cur);
30009388:	e59d0000 	ldr	r0, [sp]
3000938c:	ebffe61b 	bl	30002c00 <acoral_thread_move2_tail>
			}
		}
#ifndef CFG_TICKS_PRIVATE
	}
#endif
}
30009390:	e28dd00c 	add	sp, sp, #12
30009394:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009398:	e12fff1e 	bx	lr
3000939c:	302be818 	.word	0x302be818

300093a0 <slice_policy_init>:

void slice_policy_init(){
300093a0:	e92d4008 	push	{r3, lr}
	slice_policy.type=ACORAL_SCHED_POLICY_SLICE;
300093a4:	e59f3044 	ldr	r3, [pc, #68]	; 300093f0 <slice_policy_init+0x50>
300093a8:	e3a02018 	mov	r2, #24
300093ac:	e5c32008 	strb	r2, [r3, #8]
	slice_policy.policy_thread_release=slice_policy_thread_release;
300093b0:	e59f3038 	ldr	r3, [pc, #56]	; 300093f0 <slice_policy_init+0x50>
300093b4:	e59f2038 	ldr	r2, [pc, #56]	; 300093f4 <slice_policy_init+0x54>
300093b8:	e5832010 	str	r2, [r3, #16]
	slice_policy.policy_thread_init=slice_policy_thread_init;
300093bc:	e59f302c 	ldr	r3, [pc, #44]	; 300093f0 <slice_policy_init+0x50>
300093c0:	e59f2030 	ldr	r2, [pc, #48]	; 300093f8 <slice_policy_init+0x58>
300093c4:	e583200c 	str	r2, [r3, #12]
	slice_policy.delay_deal=slice_delay_deal;
300093c8:	e59f3020 	ldr	r3, [pc, #32]	; 300093f0 <slice_policy_init+0x50>
300093cc:	e59f2028 	ldr	r2, [pc, #40]	; 300093fc <slice_policy_init+0x5c>
300093d0:	e5832014 	str	r2, [r3, #20]
	slice_policy.name="slice";
300093d4:	e59f3014 	ldr	r3, [pc, #20]	; 300093f0 <slice_policy_init+0x50>
300093d8:	e59f2020 	ldr	r2, [pc, #32]	; 30009400 <slice_policy_init+0x60>
300093dc:	e5832018 	str	r2, [r3, #24]
	acoral_register_sched_policy(&slice_policy);
300093e0:	e59f0008 	ldr	r0, [pc, #8]	; 300093f0 <slice_policy_init+0x50>
300093e4:	ebffe297 	bl	30001e48 <acoral_register_sched_policy>
}
300093e8:	e8bd4008 	pop	{r3, lr}
300093ec:	e12fff1e 	bx	lr
300093f0:	300eaa04 	.word	0x300eaa04
300093f4:	300092fc 	.word	0x300092fc
300093f8:	3000912c 	.word	0x3000912c
300093fc:	30009324 	.word	0x30009324
30009400:	300455ac 	.word	0x300455ac

30009404 <posix_delay_deal>:
#include<policy.h>
#include<mem.h>
#include<timer.h>
#include<posix_thrd.h>
#define POSIX_SLICE_RATE 5
void posix_delay_deal(){
30009404:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009408:	e24dd00c 	sub	sp, sp, #12
#ifndef CFG_TICKS_PRIVATE
	acoral_u32 i;
	for(i=0;i<HAL_MAX_CPU;i++){
		cur=acoral_get_running_thread(i);
#else
		cur=acoral_cur_thread;
3000940c:	e59f3178 	ldr	r3, [pc, #376]	; 3000958c <posix_delay_deal+0x188>
30009410:	e5933000 	ldr	r3, [r3]
30009414:	e58d3000 	str	r3, [sp]
#endif
		if(cur->policy==ACORAL_SCHED_POLICY_POSIX){
30009418:	e59d3000 	ldr	r3, [sp]
3000941c:	e5d3300c 	ldrb	r3, [r3, #12]
30009420:	e3530019 	cmp	r3, #25
30009424:	1a000055 	bne	30009580 <posix_delay_deal+0x17c>
			cur->slice--;
30009428:	e59d3000 	ldr	r3, [sp]
3000942c:	e5933044 	ldr	r3, [r3, #68]	; 0x44
30009430:	e2432001 	sub	r2, r3, #1
30009434:	e59d3000 	ldr	r3, [sp]
30009438:	e5832044 	str	r2, [r3, #68]	; 0x44
			if(cur->slice==0){
3000943c:	e59d3000 	ldr	r3, [sp]
30009440:	e5933044 	ldr	r3, [r3, #68]	; 0x44
30009444:	e3530000 	cmp	r3, #0
30009448:	1a00004c 	bne	30009580 <posix_delay_deal+0x17c>
				data=(posix_policy_data_t *)cur->private_data;
3000944c:	e59d3000 	ldr	r3, [sp]
30009450:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30009454:	e58d3004 	str	r3, [sp, #4]
				data->stair++;
30009458:	e59d3004 	ldr	r3, [sp, #4]
3000945c:	e5d33008 	ldrb	r3, [r3, #8]
30009460:	e2833001 	add	r3, r3, #1
30009464:	e20320ff 	and	r2, r3, #255	; 0xff
30009468:	e59d3004 	ldr	r3, [sp, #4]
3000946c:	e5c32008 	strb	r2, [r3, #8]
				if(data->stair>=ACORAL_POSIX_PRIO_MAX){
30009470:	e59d3004 	ldr	r3, [sp, #4]
30009474:	e5d33008 	ldrb	r3, [r3, #8]
30009478:	e3530080 	cmp	r3, #128	; 0x80
3000947c:	9a000029 	bls	30009528 <posix_delay_deal+0x124>
					if(data->time<ACORAL_POSIX_STAIR_NUM){
30009480:	e59d3004 	ldr	r3, [sp, #4]
30009484:	e5d33009 	ldrb	r3, [r3, #9]
30009488:	e353001d 	cmp	r3, #29
3000948c:	8a00000c 	bhi	300094c4 <posix_delay_deal+0xc0>
						data->stair=ACORAL_POSIX_PRIO_MIN+data->time;
30009490:	e59d3004 	ldr	r3, [sp, #4]
30009494:	e5d33009 	ldrb	r3, [r3, #9]
30009498:	e2833063 	add	r3, r3, #99	; 0x63
3000949c:	e20320ff 	and	r2, r3, #255	; 0xff
300094a0:	e59d3004 	ldr	r3, [sp, #4]
300094a4:	e5c32008 	strb	r2, [r3, #8]
						data->time++;
300094a8:	e59d3004 	ldr	r3, [sp, #4]
300094ac:	e5d33009 	ldrb	r3, [r3, #9]
300094b0:	e2833001 	add	r3, r3, #1
300094b4:	e20320ff 	and	r2, r3, #255	; 0xff
300094b8:	e59d3004 	ldr	r3, [sp, #4]
300094bc:	e5c32009 	strb	r2, [r3, #9]
300094c0:	ea000018 	b	30009528 <posix_delay_deal+0x124>
					}
					else{
						cur->policy=ACORAL_SCHED_POLICY_SLICE;
300094c4:	e59d3000 	ldr	r3, [sp]
300094c8:	e3a02018 	mov	r2, #24
300094cc:	e5c3200c 	strb	r2, [r3, #12]
						((slice_policy_data_t *)data)->slice_ld=TIME_TO_TICKS(data->time<<POSIX_SLICE_RATE);
300094d0:	e59d1004 	ldr	r1, [sp, #4]
300094d4:	e59d3004 	ldr	r3, [sp, #4]
300094d8:	e5d33009 	ldrb	r3, [r3, #9]
300094dc:	e1a02283 	lsl	r2, r3, #5
300094e0:	e1a03002 	mov	r3, r2
300094e4:	e1a03103 	lsl	r3, r3, #2
300094e8:	e0833002 	add	r3, r3, r2
300094ec:	e1a02103 	lsl	r2, r3, #2
300094f0:	e0833002 	add	r3, r3, r2
300094f4:	e1a03103 	lsl	r3, r3, #2
300094f8:	e59f2090 	ldr	r2, [pc, #144]	; 30009590 <posix_delay_deal+0x18c>
300094fc:	e0c20293 	smull	r0, r2, r3, r2
30009500:	e1a02342 	asr	r2, r2, #6
30009504:	e1a03fc3 	asr	r3, r3, #31
30009508:	e0633002 	rsb	r3, r3, r2
3000950c:	e5813000 	str	r3, [r1]
						data->stair--;
30009510:	e59d3004 	ldr	r3, [sp, #4]
30009514:	e5d33008 	ldrb	r3, [r3, #8]
30009518:	e2433001 	sub	r3, r3, #1
3000951c:	e20320ff 	and	r2, r3, #255	; 0xff
30009520:	e59d3004 	ldr	r3, [sp, #4]
30009524:	e5c32008 	strb	r2, [r3, #8]
					}
				}
				cur->slice=TIME_TO_TICKS(data->time<<POSIX_SLICE_RATE);
30009528:	e59d3004 	ldr	r3, [sp, #4]
3000952c:	e5d33009 	ldrb	r3, [r3, #9]
30009530:	e1a02283 	lsl	r2, r3, #5
30009534:	e1a03002 	mov	r3, r2
30009538:	e1a03103 	lsl	r3, r3, #2
3000953c:	e0833002 	add	r3, r3, r2
30009540:	e1a02103 	lsl	r2, r3, #2
30009544:	e0833002 	add	r3, r3, r2
30009548:	e1a03103 	lsl	r3, r3, #2
3000954c:	e59f203c 	ldr	r2, [pc, #60]	; 30009590 <posix_delay_deal+0x18c>
30009550:	e0c21293 	smull	r1, r2, r3, r2
30009554:	e1a02342 	asr	r2, r2, #6
30009558:	e1a03fc3 	asr	r3, r3, #31
3000955c:	e0633002 	rsb	r3, r3, r2
30009560:	e1a02003 	mov	r2, r3
30009564:	e59d3000 	ldr	r3, [sp]
30009568:	e5832044 	str	r2, [r3, #68]	; 0x44
				acoral_thread_change_prio(cur,data->stair);
3000956c:	e59d3004 	ldr	r3, [sp, #4]
30009570:	e5d33008 	ldrb	r3, [r3, #8]
30009574:	e59d0000 	ldr	r0, [sp]
30009578:	e1a01003 	mov	r1, r3
3000957c:	ebffe547 	bl	30002aa0 <acoral_thread_change_prio>
			}
		}
#ifndef CFG_TICKS_PRIVATE
	}
#endif
}
30009580:	e28dd00c 	add	sp, sp, #12
30009584:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009588:	e12fff1e 	bx	lr
3000958c:	302be818 	.word	0x302be818
30009590:	10624dd3 	.word	0x10624dd3

30009594 <acoral_posix_create>:

void acoral_posix_create(acoral_id* id,acoral_posix_policy_data_t *data,void (*route)(void *args),void *args){
30009594:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009598:	e24dd01c 	sub	sp, sp, #28
3000959c:	e58d000c 	str	r0, [sp, #12]
300095a0:	e58d1008 	str	r1, [sp, #8]
300095a4:	e58d2004 	str	r2, [sp, #4]
300095a8:	e58d3000 	str	r3, [sp]
	acoral_thread_t *thread;
	thread=acoral_alloc_thread();
300095ac:	ebffe5af 	bl	30002c70 <acoral_alloc_thread>
300095b0:	e1a03000 	mov	r3, r0
300095b4:	e58d3014 	str	r3, [sp, #20]
	if(NULL==thread){
300095b8:	e59d3014 	ldr	r3, [sp, #20]
300095bc:	e3530000 	cmp	r3, #0
300095c0:	1a000002 	bne	300095d0 <acoral_posix_create+0x3c>
		acoral_printerr("Alloc Posix thread fail\n");
300095c4:	e59f0084 	ldr	r0, [pc, #132]	; 30009650 <acoral_posix_create+0xbc>
300095c8:	eb00071c 	bl	3000b240 <acoral_print>
		acoral_printk("No Mem Space or Beyond the max thread\n");
		return ;
300095cc:	ea00001c 	b	30009644 <acoral_posix_create+0xb0>
	}
	thread->stack_size=0;
300095d0:	e59d3014 	ldr	r3, [sp, #20]
300095d4:	e3a02000 	mov	r2, #0
300095d8:	e583203c 	str	r2, [r3, #60]	; 0x3c
	thread->stack_buttom=NULL;
300095dc:	e59d3014 	ldr	r3, [sp, #20]
300095e0:	e3a02000 	mov	r2, #0
300095e4:	e5832038 	str	r2, [r3, #56]	; 0x38
	thread->name=NULL;
300095e8:	e59d3014 	ldr	r3, [sp, #20]
300095ec:	e3a02000 	mov	r2, #0
300095f0:	e5832048 	str	r2, [r3, #72]	; 0x48
	thread->policy=ACORAL_SCHED_POLICY_POSIX;
300095f4:	e59d3014 	ldr	r3, [sp, #20]
300095f8:	e3a02019 	mov	r2, #25
300095fc:	e5c3200c 	strb	r2, [r3, #12]
	if(id!=NULL)
30009600:	e59d300c 	ldr	r3, [sp, #12]
30009604:	e3530000 	cmp	r3, #0
30009608:	0a000008 	beq	30009630 <acoral_posix_create+0x9c>
		*id=posix_policy_thread_init(thread,route,args,data);
3000960c:	e59d0014 	ldr	r0, [sp, #20]
30009610:	e59d1004 	ldr	r1, [sp, #4]
30009614:	e59d2000 	ldr	r2, [sp]
30009618:	e59d3008 	ldr	r3, [sp, #8]
3000961c:	eb00000c 	bl	30009654 <posix_policy_thread_init>
30009620:	e1a02000 	mov	r2, r0
30009624:	e59d300c 	ldr	r3, [sp, #12]
30009628:	e5832000 	str	r2, [r3]
3000962c:	ea000004 	b	30009644 <acoral_posix_create+0xb0>
	else
		posix_policy_thread_init(thread,route,args,data);
30009630:	e59d0014 	ldr	r0, [sp, #20]
30009634:	e59d1004 	ldr	r1, [sp, #4]
30009638:	e59d2000 	ldr	r2, [sp]
3000963c:	e59d3008 	ldr	r3, [sp, #8]
30009640:	eb000003 	bl	30009654 <posix_policy_thread_init>
}
30009644:	e28dd01c 	add	sp, sp, #28
30009648:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000964c:	e12fff1e 	bx	lr
30009650:	300455b4 	.word	0x300455b4

30009654 <posix_policy_thread_init>:

acoral_id posix_policy_thread_init(acoral_thread_t *thread,void (*route)(void *args),void *args,void *data){
30009654:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009658:	e24dd024 	sub	sp, sp, #36	; 0x24
3000965c:	e58d000c 	str	r0, [sp, #12]
30009660:	e58d1008 	str	r1, [sp, #8]
30009664:	e58d2004 	str	r2, [sp, #4]
30009668:	e58d3000 	str	r3, [sp]
	acoral_sr cpu_sr;
	acoral_posix_policy_data_t *policy_data;
	posix_policy_data_t *private_data;
	policy_data=(acoral_posix_policy_data_t *)data;
3000966c:	e59d3000 	ldr	r3, [sp]
30009670:	e58d3018 	str	r3, [sp, #24]
	private_data=(posix_policy_data_t *)posix_malloc(sizeof(posix_policy_data_t));
30009674:	e3a0000c 	mov	r0, #12
30009678:	ebfff565 	bl	30006c14 <v_malloc>
3000967c:	e1a03000 	mov	r3, r0
30009680:	e58d301c 	str	r3, [sp, #28]
	if(private_data==NULL){
30009684:	e59d301c 	ldr	r3, [sp, #28]
30009688:	e3530000 	cmp	r3, #0
3000968c:	1a00000e 	bne	300096cc <posix_policy_thread_init+0x78>
		acoral_printerr("No mem space for posix private_data:%s\n",thread->name);
30009690:	e59d300c 	ldr	r3, [sp, #12]
30009694:	e5933048 	ldr	r3, [r3, #72]	; 0x48
30009698:	e59f01a4 	ldr	r0, [pc, #420]	; 30009844 <posix_policy_thread_init+0x1f0>
3000969c:	e1a01003 	mov	r1, r3
300096a0:	eb0006e6 	bl	3000b240 <acoral_print>
		HAL_ENTER_CRITICAL();
300096a4:	ebffe012 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300096a8:	e1a03000 	mov	r3, r0
300096ac:	e58d3014 	str	r3, [sp, #20]
		acoral_release_res((acoral_res_t *)thread);
300096b0:	e59d300c 	ldr	r3, [sp, #12]
300096b4:	e1a00003 	mov	r0, r3
300096b8:	ebffe7de 	bl	30003638 <acoral_release_res>
		HAL_EXIT_CRITICAL();
300096bc:	e59d0014 	ldr	r0, [sp, #20]
300096c0:	ebffe009 	bl	300016ec <HAL_INTR_RESTORE>
		return -1;
300096c4:	e3e03000 	mvn	r3, #0
300096c8:	ea000059 	b	30009834 <posix_policy_thread_init+0x1e0>
	}
	posix_policy_data_init(private_data);
300096cc:	e59d001c 	ldr	r0, [sp, #28]
300096d0:	eb000069 	bl	3000987c <posix_policy_data_init>
	if(policy_data!=NULL){
300096d4:	e59d3018 	ldr	r3, [sp, #24]
300096d8:	e3530000 	cmp	r3, #0
300096dc:	0a000014 	beq	30009734 <posix_policy_thread_init+0xe0>
		private_data->attach_state=policy_data->attach_state;
300096e0:	e59d3018 	ldr	r3, [sp, #24]
300096e4:	e5d32004 	ldrb	r2, [r3, #4]
300096e8:	e59d301c 	ldr	r3, [sp, #28]
300096ec:	e5c32004 	strb	r2, [r3, #4]
		private_data->cpu_mask=policy_data->cpu_mask;
300096f0:	e59d3018 	ldr	r3, [sp, #24]
300096f4:	e5933008 	ldr	r3, [r3, #8]
300096f8:	e20320ff 	and	r2, r3, #255	; 0xff
300096fc:	e59d301c 	ldr	r3, [sp, #28]
30009700:	e5c32007 	strb	r2, [r3, #7]
		private_data->cancel_type=policy_data->cancel_type;
30009704:	e59d3018 	ldr	r3, [sp, #24]
30009708:	e5d32005 	ldrb	r2, [r3, #5]
3000970c:	e59d301c 	ldr	r3, [sp, #28]
30009710:	e5c32005 	strb	r2, [r3, #5]
		private_data->cancel_enable=policy_data->cancel_enable;
30009714:	e59d3018 	ldr	r3, [sp, #24]
30009718:	e5d32006 	ldrb	r2, [r3, #6]
3000971c:	e59d301c 	ldr	r3, [sp, #28]
30009720:	e5c32006 	strb	r2, [r3, #6]
		thread->stack_size=policy_data->stack_size;
30009724:	e59d3018 	ldr	r3, [sp, #24]
30009728:	e593200c 	ldr	r2, [r3, #12]
3000972c:	e59d300c 	ldr	r3, [sp, #12]
30009730:	e583203c 	str	r2, [r3, #60]	; 0x3c
	}
	thread->private_data=private_data;
30009734:	e59d300c 	ldr	r3, [sp, #12]
30009738:	e59d201c 	ldr	r2, [sp, #28]
3000973c:	e5832050 	str	r2, [r3, #80]	; 0x50
	if(thread->stack_size==0)
30009740:	e59d300c 	ldr	r3, [sp, #12]
30009744:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
30009748:	e3530000 	cmp	r3, #0
3000974c:	1a000002 	bne	3000975c <posix_policy_thread_init+0x108>
		thread->stack_size=POSIX_DEFAULT_STACK_SIZE;
30009750:	e59d300c 	ldr	r3, [sp, #12]
30009754:	e3a02b05 	mov	r2, #5120	; 0x1400
30009758:	e583203c 	str	r2, [r3, #60]	; 0x3c
	thread->cpu=-1;
3000975c:	e59d300c 	ldr	r3, [sp, #12]
30009760:	e3e02000 	mvn	r2, #0
30009764:	e5c32006 	strb	r2, [r3, #6]
	thread->cpu_mask=-1;
30009768:	e59d300c 	ldr	r3, [sp, #12]
3000976c:	e3e02000 	mvn	r2, #0
30009770:	e5832008 	str	r2, [r3, #8]
	thread->prio=private_data->stair;
30009774:	e59d301c 	ldr	r3, [sp, #28]
30009778:	e5d32008 	ldrb	r2, [r3, #8]
3000977c:	e59d300c 	ldr	r3, [sp, #12]
30009780:	e5c32005 	strb	r2, [r3, #5]
	thread->slice=TIME_TO_TICKS(private_data->time<<POSIX_SLICE_RATE);
30009784:	e59d301c 	ldr	r3, [sp, #28]
30009788:	e5d33009 	ldrb	r3, [r3, #9]
3000978c:	e1a02283 	lsl	r2, r3, #5
30009790:	e1a03002 	mov	r3, r2
30009794:	e1a03103 	lsl	r3, r3, #2
30009798:	e0833002 	add	r3, r3, r2
3000979c:	e1a02103 	lsl	r2, r3, #2
300097a0:	e0833002 	add	r3, r3, r2
300097a4:	e1a03103 	lsl	r3, r3, #2
300097a8:	e59f2098 	ldr	r2, [pc, #152]	; 30009848 <posix_policy_thread_init+0x1f4>
300097ac:	e0c21293 	smull	r1, r2, r3, r2
300097b0:	e1a02342 	asr	r2, r2, #6
300097b4:	e1a03fc3 	asr	r3, r3, #31
300097b8:	e0633002 	rsb	r3, r3, r2
300097bc:	e1a02003 	mov	r2, r3
300097c0:	e59d300c 	ldr	r3, [sp, #12]
300097c4:	e5832044 	str	r2, [r3, #68]	; 0x44
	if(acoral_thread_init(thread,route,acoral_thread_exit,args)!=0){
300097c8:	e59d000c 	ldr	r0, [sp, #12]
300097cc:	e59d1008 	ldr	r1, [sp, #8]
300097d0:	e59f2074 	ldr	r2, [pc, #116]	; 3000984c <posix_policy_thread_init+0x1f8>
300097d4:	e59d3004 	ldr	r3, [sp, #4]
300097d8:	ebffe52c 	bl	30002c90 <acoral_thread_init>
300097dc:	e1a03000 	mov	r3, r0
300097e0:	e3530000 	cmp	r3, #0
300097e4:	0a00000e 	beq	30009824 <posix_policy_thread_init+0x1d0>
		acoral_printerr("No thread stack:%s\n",thread->name);
300097e8:	e59d300c 	ldr	r3, [sp, #12]
300097ec:	e5933048 	ldr	r3, [r3, #72]	; 0x48
300097f0:	e59f0058 	ldr	r0, [pc, #88]	; 30009850 <posix_policy_thread_init+0x1fc>
300097f4:	e1a01003 	mov	r1, r3
300097f8:	eb000690 	bl	3000b240 <acoral_print>
		HAL_ENTER_CRITICAL();
300097fc:	ebffdfbc 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30009800:	e1a03000 	mov	r3, r0
30009804:	e58d3014 	str	r3, [sp, #20]
		acoral_release_res((acoral_res_t *)thread);
30009808:	e59d300c 	ldr	r3, [sp, #12]
3000980c:	e1a00003 	mov	r0, r3
30009810:	ebffe788 	bl	30003638 <acoral_release_res>
		HAL_EXIT_CRITICAL();
30009814:	e59d0014 	ldr	r0, [sp, #20]
30009818:	ebffdfb3 	bl	300016ec <HAL_INTR_RESTORE>
		return -1;
3000981c:	e3e03000 	mvn	r3, #0
30009820:	ea000003 	b	30009834 <posix_policy_thread_init+0x1e0>
	}
	acoral_resume_thread(thread);
30009824:	e59d000c 	ldr	r0, [sp, #12]
30009828:	ebffe40f 	bl	3000286c <acoral_resume_thread>
	return thread->res.id;
3000982c:	e59d300c 	ldr	r3, [sp, #12]
30009830:	e5933000 	ldr	r3, [r3]
}
30009834:	e1a00003 	mov	r0, r3
30009838:	e28dd024 	add	sp, sp, #36	; 0x24
3000983c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009840:	e12fff1e 	bx	lr
30009844:	300455d0 	.word	0x300455d0
30009848:	10624dd3 	.word	0x10624dd3
3000984c:	30002a80 	.word	0x30002a80
30009850:	300455f8 	.word	0x300455f8

30009854 <posix_policy_thread_release>:

void posix_policy_thread_release(acoral_thread_t *thread){
30009854:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009858:	e24dd00c 	sub	sp, sp, #12
3000985c:	e58d0004 	str	r0, [sp, #4]
	posix_free(thread->private_data);
30009860:	e59d3004 	ldr	r3, [sp, #4]
30009864:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30009868:	e1a00003 	mov	r0, r3
3000986c:	ebfff4fd 	bl	30006c68 <v_free>
}
30009870:	e28dd00c 	add	sp, sp, #12
30009874:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009878:	e12fff1e 	bx	lr

3000987c <posix_policy_data_init>:

void posix_policy_data_init(posix_policy_data_t *private_data){
3000987c:	e24dd008 	sub	sp, sp, #8
30009880:	e58d0004 	str	r0, [sp, #4]
	private_data->attach_state=POSIX_JOINABLE;
30009884:	e59d3004 	ldr	r3, [sp, #4]
30009888:	e3a02001 	mov	r2, #1
3000988c:	e5c32004 	strb	r2, [r3, #4]
	private_data->cancel_type=POSIX_CANCEL_DEFER;
30009890:	e59d3004 	ldr	r3, [sp, #4]
30009894:	e3a02000 	mov	r2, #0
30009898:	e5c32005 	strb	r2, [r3, #5]
	private_data->cancel_enable=true;
3000989c:	e59d3004 	ldr	r3, [sp, #4]
300098a0:	e3a02001 	mov	r2, #1
300098a4:	e5c32006 	strb	r2, [r3, #6]
	private_data->cpu_mask=0xff;
300098a8:	e59d3004 	ldr	r3, [sp, #4]
300098ac:	e3e02000 	mvn	r2, #0
300098b0:	e5c32007 	strb	r2, [r3, #7]
	private_data->stair=ACORAL_POSIX_PRIO_MIN;
300098b4:	e59d3004 	ldr	r3, [sp, #4]
300098b8:	e3a02063 	mov	r2, #99	; 0x63
300098bc:	e5c32008 	strb	r2, [r3, #8]
	private_data->time=1;
300098c0:	e59d3004 	ldr	r3, [sp, #4]
300098c4:	e3a02001 	mov	r2, #1
300098c8:	e5c32009 	strb	r2, [r3, #9]
}
300098cc:	e28dd008 	add	sp, sp, #8
300098d0:	e12fff1e 	bx	lr

300098d4 <posix_policy_init>:

acoral_sched_policy_t posix_policy;
void posix_policy_init(){
300098d4:	e92d4008 	push	{r3, lr}
	posix_policy.type=ACORAL_SCHED_POLICY_POSIX;
300098d8:	e59f3044 	ldr	r3, [pc, #68]	; 30009924 <posix_policy_init+0x50>
300098dc:	e3a02019 	mov	r2, #25
300098e0:	e5c32008 	strb	r2, [r3, #8]
	posix_policy.policy_thread_init=posix_policy_thread_init;
300098e4:	e59f3038 	ldr	r3, [pc, #56]	; 30009924 <posix_policy_init+0x50>
300098e8:	e59f2038 	ldr	r2, [pc, #56]	; 30009928 <posix_policy_init+0x54>
300098ec:	e583200c 	str	r2, [r3, #12]
	posix_policy.policy_thread_release=posix_policy_thread_release;
300098f0:	e59f302c 	ldr	r3, [pc, #44]	; 30009924 <posix_policy_init+0x50>
300098f4:	e59f2030 	ldr	r2, [pc, #48]	; 3000992c <posix_policy_init+0x58>
300098f8:	e5832010 	str	r2, [r3, #16]
	posix_policy.delay_deal=posix_delay_deal;
300098fc:	e59f3020 	ldr	r3, [pc, #32]	; 30009924 <posix_policy_init+0x50>
30009900:	e59f2028 	ldr	r2, [pc, #40]	; 30009930 <posix_policy_init+0x5c>
30009904:	e5832014 	str	r2, [r3, #20]
	posix_policy.name="posix";
30009908:	e59f3014 	ldr	r3, [pc, #20]	; 30009924 <posix_policy_init+0x50>
3000990c:	e59f2020 	ldr	r2, [pc, #32]	; 30009934 <posix_policy_init+0x60>
30009910:	e5832018 	str	r2, [r3, #24]
	acoral_register_sched_policy(&posix_policy);
30009914:	e59f0008 	ldr	r0, [pc, #8]	; 30009924 <posix_policy_init+0x50>
30009918:	ebffe14a 	bl	30001e48 <acoral_register_sched_policy>
}
3000991c:	e8bd4008 	pop	{r3, lr}
30009920:	e12fff1e 	bx	lr
30009924:	300ea45c 	.word	0x300ea45c
30009928:	30009654 	.word	0x30009654
3000992c:	30009854 	.word	0x30009854
30009930:	30009404 	.word	0x30009404
30009934:	3004560c 	.word	0x3004560c

30009938 <delay>:
#include<hal.h>
#include<cpu.h>
#include<policy.h>
acoral_u32 sample_100ms;
volatile acoral_u32 sample;
void delay(){
30009938:	e24dd008 	sub	sp, sp, #8
	volatile acoral_32 tmp=0xfff;
3000993c:	e3a03eff 	mov	r3, #4080	; 0xff0
30009940:	e283300f 	add	r3, r3, #15
30009944:	e58d3004 	str	r3, [sp, #4]
	while(tmp-->0);
30009948:	e59d3004 	ldr	r3, [sp, #4]
3000994c:	e3530000 	cmp	r3, #0
30009950:	d3a02000 	movle	r2, #0
30009954:	c3a02001 	movgt	r2, #1
30009958:	e20220ff 	and	r2, r2, #255	; 0xff
3000995c:	e2433001 	sub	r3, r3, #1
30009960:	e58d3004 	str	r3, [sp, #4]
30009964:	e3520000 	cmp	r2, #0
30009968:	1afffff6 	bne	30009948 <delay+0x10>
	sample++;
3000996c:	e59f3014 	ldr	r3, [pc, #20]	; 30009988 <delay+0x50>
30009970:	e5933000 	ldr	r3, [r3]
30009974:	e2832001 	add	r2, r3, #1
30009978:	e59f3008 	ldr	r3, [pc, #8]	; 30009988 <delay+0x50>
3000997c:	e5832000 	str	r2, [r3]
}
30009980:	e28dd008 	add	sp, sp, #8
30009984:	e12fff1e 	bx	lr
30009988:	302f7e24 	.word	0x302f7e24

3000998c <delay_task>:

void delay_task(void *args){
3000998c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009990:	e24dd00c 	sub	sp, sp, #12
30009994:	e58d0004 	str	r0, [sp, #4]
	sample=0;
30009998:	e59f300c 	ldr	r3, [pc, #12]	; 300099ac <delay_task+0x20>
3000999c:	e3a02000 	mov	r2, #0
300099a0:	e5832000 	str	r2, [r3]
	for(;;){
		delay();
300099a4:	ebffffe3 	bl	30009938 <delay>
	}
300099a8:	eafffffd 	b	300099a4 <delay_task+0x18>
300099ac:	302f7e24 	.word	0x302f7e24

300099b0 <acoral_soft_delay>:
}

void acoral_soft_delay(acoral_u32 n100ms){
300099b0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300099b4:	e24dd014 	sub	sp, sp, #20
300099b8:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 i;
	acoral_u32 tmp=n100ms*sample_100ms;	
300099bc:	e59f3044 	ldr	r3, [pc, #68]	; 30009a08 <acoral_soft_delay+0x58>
300099c0:	e5932000 	ldr	r2, [r3]
300099c4:	e59d3004 	ldr	r3, [sp, #4]
300099c8:	e0030392 	mul	r3, r2, r3
300099cc:	e58d300c 	str	r3, [sp, #12]
	for(i=0;i<tmp;i++)
300099d0:	e3a03000 	mov	r3, #0
300099d4:	e58d3008 	str	r3, [sp, #8]
300099d8:	ea000003 	b	300099ec <acoral_soft_delay+0x3c>
		delay();
300099dc:	ebffffd5 	bl	30009938 <delay>
}

void acoral_soft_delay(acoral_u32 n100ms){
	acoral_u32 i;
	acoral_u32 tmp=n100ms*sample_100ms;	
	for(i=0;i<tmp;i++)
300099e0:	e59d3008 	ldr	r3, [sp, #8]
300099e4:	e2833001 	add	r3, r3, #1
300099e8:	e58d3008 	str	r3, [sp, #8]
300099ec:	e59d2008 	ldr	r2, [sp, #8]
300099f0:	e59d300c 	ldr	r3, [sp, #12]
300099f4:	e1520003 	cmp	r2, r3
300099f8:	3afffff7 	bcc	300099dc <acoral_soft_delay+0x2c>
		delay();
}
300099fc:	e28dd014 	add	sp, sp, #20
30009a00:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009a04:	e12fff1e 	bx	lr
30009a08:	3012a7f0 	.word	0x3012a7f0

30009a0c <soft_delay_init>:

void soft_delay_init(){
30009a0c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009a10:	e24dd024 	sub	sp, sp, #36	; 0x24
	acoral_sr cpu_sr;
	acoral_comm_policy_data_t data;
	acoral_thread_t *thread;
	acoral_id tmp_id;
	data.cpu=acoral_current_cpu;
30009a14:	e3a03000 	mov	r3, #0
30009a18:	e5cd3010 	strb	r3, [sp, #16]
	data.prio=ACORAL_TMP_PRIO;
30009a1c:	e3e0307e 	mvn	r3, #126	; 0x7e
30009a20:	e5cd3011 	strb	r3, [sp, #17]
	data.prio_type=ACORAL_ABSOLUTE_PRIO;
30009a24:	e3a03004 	mov	r3, #4
30009a28:	e5cd3012 	strb	r3, [sp, #18]
	tmp_id=acoral_create_thread_ext(delay_task,256,NULL,"softdelay",NULL,ACORAL_SCHED_POLICY_COMM,&data);
30009a2c:	e3a03000 	mov	r3, #0
30009a30:	e58d3000 	str	r3, [sp]
30009a34:	e3a03015 	mov	r3, #21
30009a38:	e58d3004 	str	r3, [sp, #4]
30009a3c:	e28d3010 	add	r3, sp, #16
30009a40:	e58d3008 	str	r3, [sp, #8]
30009a44:	e59f0090 	ldr	r0, [pc, #144]	; 30009adc <soft_delay_init+0xd0>
30009a48:	e3a01c01 	mov	r1, #256	; 0x100
30009a4c:	e3a02000 	mov	r2, #0
30009a50:	e59f3088 	ldr	r3, [pc, #136]	; 30009ae0 <soft_delay_init+0xd4>
30009a54:	ebffe076 	bl	30001c34 <create_thread_ext>
30009a58:	e1a03000 	mov	r3, r0
30009a5c:	e58d301c 	str	r3, [sp, #28]
	if(tmp_id==-1)
30009a60:	e59d301c 	ldr	r3, [sp, #28]
30009a64:	e3730001 	cmn	r3, #1
30009a68:	0a000017 	beq	30009acc <soft_delay_init+0xc0>
		return;
	acoral_delay_self(1000);
30009a6c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
30009a70:	ebffe3c3 	bl	30002984 <acoral_delay_self>
	sample_100ms=sample/10;
30009a74:	e59f3068 	ldr	r3, [pc, #104]	; 30009ae4 <soft_delay_init+0xd8>
30009a78:	e5932000 	ldr	r2, [r3]
30009a7c:	e59f3064 	ldr	r3, [pc, #100]	; 30009ae8 <soft_delay_init+0xdc>
30009a80:	e0831392 	umull	r1, r3, r2, r3
30009a84:	e1a021a3 	lsr	r2, r3, #3
30009a88:	e59f305c 	ldr	r3, [pc, #92]	; 30009aec <soft_delay_init+0xe0>
30009a8c:	e5832000 	str	r2, [r3]
	/*这里daemo回收进程还没启动，不能使用acoral_kill_thread*/
	thread=(acoral_thread_t *)acoral_get_res_by_id(tmp_id);
30009a90:	e59d001c 	ldr	r0, [sp, #28]
30009a94:	ebffe77b 	bl	30003888 <acoral_get_res_by_id>
30009a98:	e1a03000 	mov	r3, r0
30009a9c:	e58d3018 	str	r3, [sp, #24]
	HAL_ENTER_CRITICAL();
30009aa0:	ebffdf13 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30009aa4:	e1a03000 	mov	r3, r0
30009aa8:	e58d3014 	str	r3, [sp, #20]
	acoral_unrdy_thread(thread);
30009aac:	e59d0018 	ldr	r0, [sp, #24]
30009ab0:	ebffe443 	bl	30002bc4 <acoral_unrdy_thread>
	acoral_release_thread((acoral_res_t *)thread);
30009ab4:	e59d3018 	ldr	r3, [sp, #24]
30009ab8:	e1a00003 	mov	r0, r3
30009abc:	ebffe31e 	bl	3000273c <acoral_release_thread>
	HAL_EXIT_CRITICAL();
30009ac0:	e59d0014 	ldr	r0, [sp, #20]
30009ac4:	ebffdf08 	bl	300016ec <HAL_INTR_RESTORE>
30009ac8:	ea000000 	b	30009ad0 <soft_delay_init+0xc4>
	data.cpu=acoral_current_cpu;
	data.prio=ACORAL_TMP_PRIO;
	data.prio_type=ACORAL_ABSOLUTE_PRIO;
	tmp_id=acoral_create_thread_ext(delay_task,256,NULL,"softdelay",NULL,ACORAL_SCHED_POLICY_COMM,&data);
	if(tmp_id==-1)
		return;
30009acc:	e1a00000 	nop			; (mov r0, r0)
	thread=(acoral_thread_t *)acoral_get_res_by_id(tmp_id);
	HAL_ENTER_CRITICAL();
	acoral_unrdy_thread(thread);
	acoral_release_thread((acoral_res_t *)thread);
	HAL_EXIT_CRITICAL();
}
30009ad0:	e28dd024 	add	sp, sp, #36	; 0x24
30009ad4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009ad8:	e12fff1e 	bx	lr
30009adc:	3000998c 	.word	0x3000998c
30009ae0:	30045614 	.word	0x30045614
30009ae4:	302f7e24 	.word	0x302f7e24
30009ae8:	cccccccd 	.word	0xcccccccd
30009aec:	3012a7f0 	.word	0x3012a7f0

30009af0 <dummy_print>:
#include<type.h>
acoral_32 dummy_print(const acoral_char *fmt, ...){
30009af0:	e92d000f 	push	{r0, r1, r2, r3}
	return 0;
30009af4:	e3a03000 	mov	r3, #0
}
30009af8:	e1a00003 	mov	r0, r3
30009afc:	e28dd010 	add	sp, sp, #16
30009b00:	e12fff1e 	bx	lr

30009b04 <acoral_ffs>:
#include<type.h>
#include<bitops.h>
acoral_u32 acoral_ffs(acoral_u32 word)
{
30009b04:	e24dd010 	sub	sp, sp, #16
30009b08:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 k;
	k = 31;
30009b0c:	e3a0301f 	mov	r3, #31
30009b10:	e58d300c 	str	r3, [sp, #12]
	if (word & 0x0000ffff) { k -= 16; word <<= 16; }
30009b14:	e59d3004 	ldr	r3, [sp, #4]
30009b18:	e1a03803 	lsl	r3, r3, #16
30009b1c:	e1a03823 	lsr	r3, r3, #16
30009b20:	e3530000 	cmp	r3, #0
30009b24:	0a000005 	beq	30009b40 <acoral_ffs+0x3c>
30009b28:	e59d300c 	ldr	r3, [sp, #12]
30009b2c:	e2433010 	sub	r3, r3, #16
30009b30:	e58d300c 	str	r3, [sp, #12]
30009b34:	e59d3004 	ldr	r3, [sp, #4]
30009b38:	e1a03803 	lsl	r3, r3, #16
30009b3c:	e58d3004 	str	r3, [sp, #4]
	if (word & 0x00ff0000) { k -= 8;  word <<= 8;  }
30009b40:	e59d3004 	ldr	r3, [sp, #4]
30009b44:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
30009b48:	e3530000 	cmp	r3, #0
30009b4c:	0a000005 	beq	30009b68 <acoral_ffs+0x64>
30009b50:	e59d300c 	ldr	r3, [sp, #12]
30009b54:	e2433008 	sub	r3, r3, #8
30009b58:	e58d300c 	str	r3, [sp, #12]
30009b5c:	e59d3004 	ldr	r3, [sp, #4]
30009b60:	e1a03403 	lsl	r3, r3, #8
30009b64:	e58d3004 	str	r3, [sp, #4]
	if (word & 0x0f000000) { k -= 4;  word <<= 4;  }
30009b68:	e59d3004 	ldr	r3, [sp, #4]
30009b6c:	e203340f 	and	r3, r3, #251658240	; 0xf000000
30009b70:	e3530000 	cmp	r3, #0
30009b74:	0a000005 	beq	30009b90 <acoral_ffs+0x8c>
30009b78:	e59d300c 	ldr	r3, [sp, #12]
30009b7c:	e2433004 	sub	r3, r3, #4
30009b80:	e58d300c 	str	r3, [sp, #12]
30009b84:	e59d3004 	ldr	r3, [sp, #4]
30009b88:	e1a03203 	lsl	r3, r3, #4
30009b8c:	e58d3004 	str	r3, [sp, #4]
	if (word & 0x30000000) { k -= 2;  word <<= 2;  }
30009b90:	e59d3004 	ldr	r3, [sp, #4]
30009b94:	e2033203 	and	r3, r3, #805306368	; 0x30000000
30009b98:	e3530000 	cmp	r3, #0
30009b9c:	0a000005 	beq	30009bb8 <acoral_ffs+0xb4>
30009ba0:	e59d300c 	ldr	r3, [sp, #12]
30009ba4:	e2433002 	sub	r3, r3, #2
30009ba8:	e58d300c 	str	r3, [sp, #12]
30009bac:	e59d3004 	ldr	r3, [sp, #4]
30009bb0:	e1a03103 	lsl	r3, r3, #2
30009bb4:	e58d3004 	str	r3, [sp, #4]
	if (word & 0x40000000) { k -= 1; }
30009bb8:	e59d3004 	ldr	r3, [sp, #4]
30009bbc:	e2033101 	and	r3, r3, #1073741824	; 0x40000000
30009bc0:	e3530000 	cmp	r3, #0
30009bc4:	0a000002 	beq	30009bd4 <acoral_ffs+0xd0>
30009bc8:	e59d300c 	ldr	r3, [sp, #12]
30009bcc:	e2433001 	sub	r3, r3, #1
30009bd0:	e58d300c 	str	r3, [sp, #12]
        return k;
30009bd4:	e59d300c 	ldr	r3, [sp, #12]
}
30009bd8:	e1a00003 	mov	r0, r3
30009bdc:	e28dd010 	add	sp, sp, #16
30009be0:	e12fff1e 	bx	lr

30009be4 <acoral_find_first_bit>:

acoral_u32 acoral_find_first_bit(const acoral_u32 *b,acoral_u32 length)
{
30009be4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009be8:	e24dd014 	sub	sp, sp, #20
30009bec:	e58d0004 	str	r0, [sp, #4]
30009bf0:	e58d1000 	str	r1, [sp]
	acoral_u32 v;
	acoral_u32 off;

	for (off = 0; v = b[off], off < length; off++) {
30009bf4:	e3a03000 	mov	r3, #0
30009bf8:	e58d300c 	str	r3, [sp, #12]
30009bfc:	ea000005 	b	30009c18 <acoral_find_first_bit+0x34>
		if (v)
30009c00:	e59d3008 	ldr	r3, [sp, #8]
30009c04:	e3530000 	cmp	r3, #0
30009c08:	1a00000d 	bne	30009c44 <acoral_find_first_bit+0x60>
acoral_u32 acoral_find_first_bit(const acoral_u32 *b,acoral_u32 length)
{
	acoral_u32 v;
	acoral_u32 off;

	for (off = 0; v = b[off], off < length; off++) {
30009c0c:	e59d300c 	ldr	r3, [sp, #12]
30009c10:	e2833001 	add	r3, r3, #1
30009c14:	e58d300c 	str	r3, [sp, #12]
30009c18:	e59d300c 	ldr	r3, [sp, #12]
30009c1c:	e1a02103 	lsl	r2, r3, #2
30009c20:	e59d3004 	ldr	r3, [sp, #4]
30009c24:	e0823003 	add	r3, r2, r3
30009c28:	e5933000 	ldr	r3, [r3]
30009c2c:	e58d3008 	str	r3, [sp, #8]
30009c30:	e59d200c 	ldr	r2, [sp, #12]
30009c34:	e59d3000 	ldr	r3, [sp]
30009c38:	e1520003 	cmp	r2, r3
30009c3c:	3affffef 	bcc	30009c00 <acoral_find_first_bit+0x1c>
30009c40:	ea000000 	b	30009c48 <acoral_find_first_bit+0x64>
		if (v)
			break;
30009c44:	e1a00000 	nop			; (mov r0, r0)
	}
	return acoral_ffs(v) + off * 32;
30009c48:	e59d0008 	ldr	r0, [sp, #8]
30009c4c:	ebffffac 	bl	30009b04 <acoral_ffs>
30009c50:	e1a02000 	mov	r2, r0
30009c54:	e59d300c 	ldr	r3, [sp, #12]
30009c58:	e1a03283 	lsl	r3, r3, #5
30009c5c:	e0823003 	add	r3, r2, r3
}
30009c60:	e1a00003 	mov	r0, r3
30009c64:	e28dd014 	add	sp, sp, #20
30009c68:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009c6c:	e12fff1e 	bx	lr

30009c70 <acoral_set_bit>:

void acoral_set_bit(acoral_32 nr,acoral_u32 *bitmap)
{
30009c70:	e24dd018 	sub	sp, sp, #24
30009c74:	e58d0004 	str	r0, [sp, #4]
30009c78:	e58d1000 	str	r1, [sp]
	acoral_u32 oldval, mask = 1UL << (nr & 31);
30009c7c:	e59d3004 	ldr	r3, [sp, #4]
30009c80:	e203301f 	and	r3, r3, #31
30009c84:	e3a02001 	mov	r2, #1
30009c88:	e1a03312 	lsl	r3, r2, r3
30009c8c:	e58d3010 	str	r3, [sp, #16]
	acoral_u32 *p;
	p =bitmap+(nr>>5);
30009c90:	e59d3004 	ldr	r3, [sp, #4]
30009c94:	e1a032c3 	asr	r3, r3, #5
30009c98:	e1a03103 	lsl	r3, r3, #2
30009c9c:	e59d2000 	ldr	r2, [sp]
30009ca0:	e0823003 	add	r3, r2, r3
30009ca4:	e58d3014 	str	r3, [sp, #20]
	oldval = *p;
30009ca8:	e59d3014 	ldr	r3, [sp, #20]
30009cac:	e5933000 	ldr	r3, [r3]
30009cb0:	e58d300c 	str	r3, [sp, #12]
	*p = oldval | mask;
30009cb4:	e59d200c 	ldr	r2, [sp, #12]
30009cb8:	e59d3010 	ldr	r3, [sp, #16]
30009cbc:	e1822003 	orr	r2, r2, r3
30009cc0:	e59d3014 	ldr	r3, [sp, #20]
30009cc4:	e5832000 	str	r2, [r3]
}
30009cc8:	e28dd018 	add	sp, sp, #24
30009ccc:	e12fff1e 	bx	lr

30009cd0 <acoral_clear_bit>:

void acoral_clear_bit(acoral_32 nr,acoral_u32 *bitmap)
{
30009cd0:	e24dd018 	sub	sp, sp, #24
30009cd4:	e58d0004 	str	r0, [sp, #4]
30009cd8:	e58d1000 	str	r1, [sp]
	acoral_u32 oldval, mask = 1UL << (nr & 31);
30009cdc:	e59d3004 	ldr	r3, [sp, #4]
30009ce0:	e203301f 	and	r3, r3, #31
30009ce4:	e3a02001 	mov	r2, #1
30009ce8:	e1a03312 	lsl	r3, r2, r3
30009cec:	e58d3010 	str	r3, [sp, #16]
	acoral_u32 *p;
	p =bitmap+(nr >> 5);
30009cf0:	e59d3004 	ldr	r3, [sp, #4]
30009cf4:	e1a032c3 	asr	r3, r3, #5
30009cf8:	e1a03103 	lsl	r3, r3, #2
30009cfc:	e59d2000 	ldr	r2, [sp]
30009d00:	e0823003 	add	r3, r2, r3
30009d04:	e58d3014 	str	r3, [sp, #20]
	oldval = *p;
30009d08:	e59d3014 	ldr	r3, [sp, #20]
30009d0c:	e5933000 	ldr	r3, [r3]
30009d10:	e58d300c 	str	r3, [sp, #12]
	*p = oldval &(~mask);
30009d14:	e59d3010 	ldr	r3, [sp, #16]
30009d18:	e1e02003 	mvn	r2, r3
30009d1c:	e59d300c 	ldr	r3, [sp, #12]
30009d20:	e0022003 	and	r2, r2, r3
30009d24:	e59d3014 	ldr	r3, [sp, #20]
30009d28:	e5832000 	str	r2, [r3]
}
30009d2c:	e28dd018 	add	sp, sp, #24
30009d30:	e12fff1e 	bx	lr

30009d34 <acoral_get_bit>:

acoral_u32 acoral_get_bit(acoral_32 nr,acoral_u32 *bitmap)
{
30009d34:	e24dd018 	sub	sp, sp, #24
30009d38:	e58d0004 	str	r0, [sp, #4]
30009d3c:	e58d1000 	str	r1, [sp]
	acoral_u32 oldval, mask = 1UL << (nr & 31);
30009d40:	e59d3004 	ldr	r3, [sp, #4]
30009d44:	e203301f 	and	r3, r3, #31
30009d48:	e3a02001 	mov	r2, #1
30009d4c:	e1a03312 	lsl	r3, r2, r3
30009d50:	e58d3010 	str	r3, [sp, #16]
	acoral_u32 *p;
	p =bitmap+(nr>>5);
30009d54:	e59d3004 	ldr	r3, [sp, #4]
30009d58:	e1a032c3 	asr	r3, r3, #5
30009d5c:	e1a03103 	lsl	r3, r3, #2
30009d60:	e59d2000 	ldr	r2, [sp]
30009d64:	e0823003 	add	r3, r2, r3
30009d68:	e58d3014 	str	r3, [sp, #20]
	oldval = *p;
30009d6c:	e59d3014 	ldr	r3, [sp, #20]
30009d70:	e5933000 	ldr	r3, [r3]
30009d74:	e58d300c 	str	r3, [sp, #12]
	return oldval & mask;
30009d78:	e59d200c 	ldr	r2, [sp, #12]
30009d7c:	e59d3010 	ldr	r3, [sp, #16]
30009d80:	e0023003 	and	r3, r2, r3
}
30009d84:	e1a00003 	mov	r0, r3
30009d88:	e28dd018 	add	sp, sp, #24
30009d8c:	e12fff1e 	bx	lr

30009d90 <acoral_prio_queue_add>:
#include<queue.h>
#include<list.h>
#include<bitops.h>
void acoral_prio_queue_add(acoral_prio_array_t *array,acoral_u8 prio,acoral_list_t *list){
30009d90:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009d94:	e24dd01c 	sub	sp, sp, #28
30009d98:	e58d000c 	str	r0, [sp, #12]
30009d9c:	e1a03001 	mov	r3, r1
30009da0:	e58d2004 	str	r2, [sp, #4]
30009da4:	e5cd300b 	strb	r3, [sp, #11]
	acoral_queue_t *queue;
	acoral_list_t *head;
	array->num++;
30009da8:	e59d300c 	ldr	r3, [sp, #12]
30009dac:	e5933000 	ldr	r3, [r3]
30009db0:	e2832001 	add	r2, r3, #1
30009db4:	e59d300c 	ldr	r3, [sp, #12]
30009db8:	e5832000 	str	r2, [r3]
        queue=array->queue + prio;
30009dbc:	e59d300c 	ldr	r3, [sp, #12]
30009dc0:	e2831018 	add	r1, r3, #24
30009dc4:	e5dd200b 	ldrb	r2, [sp, #11]
30009dc8:	e1a03002 	mov	r3, r2
30009dcc:	e1a03083 	lsl	r3, r3, #1
30009dd0:	e0833002 	add	r3, r3, r2
30009dd4:	e1a03103 	lsl	r3, r3, #2
30009dd8:	e0813003 	add	r3, r1, r3
30009ddc:	e58d3010 	str	r3, [sp, #16]
	head=&queue->head;
30009de0:	e59d3010 	ldr	r3, [sp, #16]
30009de4:	e58d3014 	str	r3, [sp, #20]
	acoral_list_add2_tail(list,head);
30009de8:	e59d0004 	ldr	r0, [sp, #4]
30009dec:	e59d1014 	ldr	r1, [sp, #20]
30009df0:	eb000080 	bl	30009ff8 <acoral_list_add2_tail>
	acoral_set_bit(prio,array->bitmap);
30009df4:	e5dd200b 	ldrb	r2, [sp, #11]
30009df8:	e59d300c 	ldr	r3, [sp, #12]
30009dfc:	e2833004 	add	r3, r3, #4
30009e00:	e1a00002 	mov	r0, r2
30009e04:	e1a01003 	mov	r1, r3
30009e08:	ebffff98 	bl	30009c70 <acoral_set_bit>
}
30009e0c:	e28dd01c 	add	sp, sp, #28
30009e10:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009e14:	e12fff1e 	bx	lr

30009e18 <acoral_prio_queue_del>:

void acoral_prio_queue_del(acoral_prio_array_t *array,acoral_u8 prio,acoral_list_t *list){
30009e18:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009e1c:	e24dd01c 	sub	sp, sp, #28
30009e20:	e58d000c 	str	r0, [sp, #12]
30009e24:	e1a03001 	mov	r3, r1
30009e28:	e58d2004 	str	r2, [sp, #4]
30009e2c:	e5cd300b 	strb	r3, [sp, #11]
	acoral_queue_t *queue;
	acoral_list_t *head;
        queue= array->queue + prio;
30009e30:	e59d300c 	ldr	r3, [sp, #12]
30009e34:	e2831018 	add	r1, r3, #24
30009e38:	e5dd200b 	ldrb	r2, [sp, #11]
30009e3c:	e1a03002 	mov	r3, r2
30009e40:	e1a03083 	lsl	r3, r3, #1
30009e44:	e0833002 	add	r3, r3, r2
30009e48:	e1a03103 	lsl	r3, r3, #2
30009e4c:	e0813003 	add	r3, r1, r3
30009e50:	e58d3010 	str	r3, [sp, #16]
	head=&queue->head;
30009e54:	e59d3010 	ldr	r3, [sp, #16]
30009e58:	e58d3014 	str	r3, [sp, #20]
	array->num--;
30009e5c:	e59d300c 	ldr	r3, [sp, #12]
30009e60:	e5933000 	ldr	r3, [r3]
30009e64:	e2432001 	sub	r2, r3, #1
30009e68:	e59d300c 	ldr	r3, [sp, #12]
30009e6c:	e5832000 	str	r2, [r3]
	acoral_list_del(list);
30009e70:	e59d0004 	ldr	r0, [sp, #4]
30009e74:	eb000072 	bl	3000a044 <acoral_list_del>
	if(acoral_list_empty(head))
30009e78:	e59d3014 	ldr	r3, [sp, #20]
30009e7c:	e5932000 	ldr	r2, [r3]
30009e80:	e59d3014 	ldr	r3, [sp, #20]
30009e84:	e1520003 	cmp	r2, r3
30009e88:	1a000005 	bne	30009ea4 <acoral_prio_queue_del+0x8c>
		acoral_clear_bit(prio,array->bitmap);
30009e8c:	e5dd200b 	ldrb	r2, [sp, #11]
30009e90:	e59d300c 	ldr	r3, [sp, #12]
30009e94:	e2833004 	add	r3, r3, #4
30009e98:	e1a00002 	mov	r0, r2
30009e9c:	e1a01003 	mov	r1, r3
30009ea0:	ebffff8a 	bl	30009cd0 <acoral_clear_bit>
}
30009ea4:	e28dd01c 	add	sp, sp, #28
30009ea8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009eac:	e12fff1e 	bx	lr

30009eb0 <acoral_get_highprio>:

acoral_u32 acoral_get_highprio(acoral_prio_array_t *array){
30009eb0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30009eb4:	e24dd00c 	sub	sp, sp, #12
30009eb8:	e58d0004 	str	r0, [sp, #4]
	return acoral_find_first_bit(array->bitmap,PRIO_BITMAP_SIZE);
30009ebc:	e59d3004 	ldr	r3, [sp, #4]
30009ec0:	e2833004 	add	r3, r3, #4
30009ec4:	e1a00003 	mov	r0, r3
30009ec8:	e3a01005 	mov	r1, #5
30009ecc:	ebffff44 	bl	30009be4 <acoral_find_first_bit>
30009ed0:	e1a03000 	mov	r3, r0
}
30009ed4:	e1a00003 	mov	r0, r3
30009ed8:	e28dd00c 	add	sp, sp, #12
30009edc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30009ee0:	e12fff1e 	bx	lr

30009ee4 <acoral_prio_queue_init>:

void acoral_prio_queue_init(acoral_prio_array_t *array){
30009ee4:	e24dd018 	sub	sp, sp, #24
30009ee8:	e58d0004 	str	r0, [sp, #4]
  	acoral_u8 i;
	acoral_queue_t *queue;
	acoral_list_t *head;
	array->num=0;
30009eec:	e59d3004 	ldr	r3, [sp, #4]
30009ef0:	e3a02000 	mov	r2, #0
30009ef4:	e5832000 	str	r2, [r3]
	for(i=0;i<PRIO_BITMAP_SIZE;i++)
30009ef8:	e3a03000 	mov	r3, #0
30009efc:	e5cd300f 	strb	r3, [sp, #15]
30009f00:	ea00000a 	b	30009f30 <acoral_prio_queue_init+0x4c>
	    array->bitmap[i]=0;
30009f04:	e5dd100f 	ldrb	r1, [sp, #15]
30009f08:	e59d2004 	ldr	r2, [sp, #4]
30009f0c:	e3a03004 	mov	r3, #4
30009f10:	e1a01101 	lsl	r1, r1, #2
30009f14:	e0812002 	add	r2, r1, r2
30009f18:	e0823003 	add	r3, r2, r3
30009f1c:	e3a02000 	mov	r2, #0
30009f20:	e5832000 	str	r2, [r3]
void acoral_prio_queue_init(acoral_prio_array_t *array){
  	acoral_u8 i;
	acoral_queue_t *queue;
	acoral_list_t *head;
	array->num=0;
	for(i=0;i<PRIO_BITMAP_SIZE;i++)
30009f24:	e5dd300f 	ldrb	r3, [sp, #15]
30009f28:	e2833001 	add	r3, r3, #1
30009f2c:	e5cd300f 	strb	r3, [sp, #15]
30009f30:	e5dd300f 	ldrb	r3, [sp, #15]
30009f34:	e3530004 	cmp	r3, #4
30009f38:	9afffff1 	bls	30009f04 <acoral_prio_queue_init+0x20>
	    array->bitmap[i]=0;
  	for(i=0;i<ACORAL_MAX_PRIO_NUM;i++){
30009f3c:	e3a03000 	mov	r3, #0
30009f40:	e5cd300f 	strb	r3, [sp, #15]
30009f44:	ea000013 	b	30009f98 <acoral_prio_queue_init+0xb4>
	    queue= array->queue + i;
30009f48:	e59d3004 	ldr	r3, [sp, #4]
30009f4c:	e2831018 	add	r1, r3, #24
30009f50:	e5dd200f 	ldrb	r2, [sp, #15]
30009f54:	e1a03002 	mov	r3, r2
30009f58:	e1a03083 	lsl	r3, r3, #1
30009f5c:	e0833002 	add	r3, r3, r2
30009f60:	e1a03103 	lsl	r3, r3, #2
30009f64:	e0813003 	add	r3, r1, r3
30009f68:	e58d3010 	str	r3, [sp, #16]
	    head=&queue->head;
30009f6c:	e59d3010 	ldr	r3, [sp, #16]
30009f70:	e58d3014 	str	r3, [sp, #20]
	    acoral_init_list(head);
30009f74:	e59d3014 	ldr	r3, [sp, #20]
30009f78:	e59d2014 	ldr	r2, [sp, #20]
30009f7c:	e5832000 	str	r2, [r3]
30009f80:	e59d3014 	ldr	r3, [sp, #20]
30009f84:	e59d2014 	ldr	r2, [sp, #20]
30009f88:	e5832004 	str	r2, [r3, #4]
	acoral_queue_t *queue;
	acoral_list_t *head;
	array->num=0;
	for(i=0;i<PRIO_BITMAP_SIZE;i++)
	    array->bitmap[i]=0;
  	for(i=0;i<ACORAL_MAX_PRIO_NUM;i++){
30009f8c:	e5dd300f 	ldrb	r3, [sp, #15]
30009f90:	e2833001 	add	r3, r3, #1
30009f94:	e5cd300f 	strb	r3, [sp, #15]
30009f98:	e5dd300f 	ldrb	r3, [sp, #15]
30009f9c:	e3530082 	cmp	r3, #130	; 0x82
30009fa0:	9affffe8 	bls	30009f48 <acoral_prio_queue_init+0x64>
	    queue= array->queue + i;
	    head=&queue->head;
	    acoral_init_list(head);
	} 	
}
30009fa4:	e28dd018 	add	sp, sp, #24
30009fa8:	e12fff1e 	bx	lr

30009fac <acoral_list_add>:
#include<list.h>
void acoral_list_add(acoral_list_t *new, acoral_list_t *head)
{
30009fac:	e24dd008 	sub	sp, sp, #8
30009fb0:	e58d0004 	str	r0, [sp, #4]
30009fb4:	e58d1000 	str	r1, [sp]
	new->prev=head;	
30009fb8:	e59d3004 	ldr	r3, [sp, #4]
30009fbc:	e59d2000 	ldr	r2, [sp]
30009fc0:	e5832004 	str	r2, [r3, #4]
	new->next=head->next;	
30009fc4:	e59d3000 	ldr	r3, [sp]
30009fc8:	e5932000 	ldr	r2, [r3]
30009fcc:	e59d3004 	ldr	r3, [sp, #4]
30009fd0:	e5832000 	str	r2, [r3]
	head->next->prev=new;	
30009fd4:	e59d3000 	ldr	r3, [sp]
30009fd8:	e5933000 	ldr	r3, [r3]
30009fdc:	e59d2004 	ldr	r2, [sp, #4]
30009fe0:	e5832004 	str	r2, [r3, #4]
	head->next=new;	
30009fe4:	e59d3000 	ldr	r3, [sp]
30009fe8:	e59d2004 	ldr	r2, [sp, #4]
30009fec:	e5832000 	str	r2, [r3]
}
30009ff0:	e28dd008 	add	sp, sp, #8
30009ff4:	e12fff1e 	bx	lr

30009ff8 <acoral_list_add2_tail>:

void acoral_list_add2_tail(acoral_list_t *new, acoral_list_t *head)
{
30009ff8:	e24dd008 	sub	sp, sp, #8
30009ffc:	e58d0004 	str	r0, [sp, #4]
3000a000:	e58d1000 	str	r1, [sp]
	new->prev=head->prev;
3000a004:	e59d3000 	ldr	r3, [sp]
3000a008:	e5932004 	ldr	r2, [r3, #4]
3000a00c:	e59d3004 	ldr	r3, [sp, #4]
3000a010:	e5832004 	str	r2, [r3, #4]
	new->next=head;
3000a014:	e59d3004 	ldr	r3, [sp, #4]
3000a018:	e59d2000 	ldr	r2, [sp]
3000a01c:	e5832000 	str	r2, [r3]
	head->prev->next=new;
3000a020:	e59d3000 	ldr	r3, [sp]
3000a024:	e5933004 	ldr	r3, [r3, #4]
3000a028:	e59d2004 	ldr	r2, [sp, #4]
3000a02c:	e5832000 	str	r2, [r3]
	head->prev=new;
3000a030:	e59d3000 	ldr	r3, [sp]
3000a034:	e59d2004 	ldr	r2, [sp, #4]
3000a038:	e5832004 	str	r2, [r3, #4]
}
3000a03c:	e28dd008 	add	sp, sp, #8
3000a040:	e12fff1e 	bx	lr

3000a044 <acoral_list_del>:

void acoral_list_del(acoral_list_t *entry)
{
3000a044:	e24dd008 	sub	sp, sp, #8
3000a048:	e58d0004 	str	r0, [sp, #4]
	entry->prev->next= entry->next;
3000a04c:	e59d3004 	ldr	r3, [sp, #4]
3000a050:	e5933004 	ldr	r3, [r3, #4]
3000a054:	e59d2004 	ldr	r2, [sp, #4]
3000a058:	e5922000 	ldr	r2, [r2]
3000a05c:	e5832000 	str	r2, [r3]
	entry->next->prev=entry->prev;
3000a060:	e59d3004 	ldr	r3, [sp, #4]
3000a064:	e5933000 	ldr	r3, [r3]
3000a068:	e59d2004 	ldr	r2, [sp, #4]
3000a06c:	e5922004 	ldr	r2, [r2, #4]
3000a070:	e5832004 	str	r2, [r3, #4]
	entry->next = entry;
3000a074:	e59d3004 	ldr	r3, [sp, #4]
3000a078:	e59d2004 	ldr	r2, [sp, #4]
3000a07c:	e5832000 	str	r2, [r3]
	entry->prev = entry;
3000a080:	e59d3004 	ldr	r3, [sp, #4]
3000a084:	e59d2004 	ldr	r2, [sp, #4]
3000a088:	e5832004 	str	r2, [r3, #4]
}
3000a08c:	e28dd008 	add	sp, sp, #8
3000a090:	e12fff1e 	bx	lr

3000a094 <do_div>:
#define SPACE	8		/* space if plus */
#define LEFT	16		/* left justified */
#define SPECIAL	32		/* 0x */
#define LARGE	64		/* use 'ABCDEF' instead of 'abcdef' */
static acoral_32 do_div(acoral_64 *n,acoral_32 base)		
{								
3000a094:	e92d4010 	push	{r4, lr}
3000a098:	e24dd010 	sub	sp, sp, #16
3000a09c:	e58d0004 	str	r0, [sp, #4]
3000a0a0:	e58d1000 	str	r1, [sp]
	acoral_32 __res;				
	__res = ((acoral_u32)*n) % (acoral_u32)base;
3000a0a4:	e59d3004 	ldr	r3, [sp, #4]
3000a0a8:	e8930018 	ldm	r3, {r3, r4}
3000a0ac:	e1a02003 	mov	r2, r3
3000a0b0:	e59d3000 	ldr	r3, [sp]
3000a0b4:	e1a00002 	mov	r0, r2
3000a0b8:	e1a01003 	mov	r1, r3
3000a0bc:	eb00e734 	bl	30043d94 <__aeabi_uidivmod>
3000a0c0:	e1a03001 	mov	r3, r1
3000a0c4:	e58d300c 	str	r3, [sp, #12]
	*n = ((acoral_u32)*n) / (acoral_u32)base;	
3000a0c8:	e59d3004 	ldr	r3, [sp, #4]
3000a0cc:	e8930018 	ldm	r3, {r3, r4}
3000a0d0:	e1a02003 	mov	r2, r3
3000a0d4:	e59d3000 	ldr	r3, [sp]
3000a0d8:	e1a00002 	mov	r0, r2
3000a0dc:	e1a01003 	mov	r1, r3
3000a0e0:	eb00e6ee 	bl	30043ca0 <__aeabi_uidiv>
3000a0e4:	e1a03000 	mov	r3, r0
3000a0e8:	e3a04000 	mov	r4, #0
3000a0ec:	e59d2004 	ldr	r2, [sp, #4]
3000a0f0:	e8820018 	stm	r2, {r3, r4}
	return __res;					
3000a0f4:	e59d300c 	ldr	r3, [sp, #12]
}
3000a0f8:	e1a00003 	mov	r0, r3
3000a0fc:	e28dd010 	add	sp, sp, #16
3000a100:	e8bd4010 	pop	{r4, lr}
3000a104:	e12fff1e 	bx	lr

3000a108 <skip_atoi>:


acoral_32 skip_atoi(const acoral_char **s)
    {/*change the string "s" to digit*/
3000a108:	e24dd010 	sub	sp, sp, #16
3000a10c:	e58d0004 	str	r0, [sp, #4]
            acoral_32 i=0;
3000a110:	e3a03000 	mov	r3, #0
3000a114:	e58d300c 	str	r3, [sp, #12]
 
            while (IS_DIGIT(**s))
3000a118:	ea00000e 	b	3000a158 <skip_atoi+0x50>
                    i = i*10 + *((*s)++) - '0';
3000a11c:	e59d200c 	ldr	r2, [sp, #12]
3000a120:	e1a03002 	mov	r3, r2
3000a124:	e1a03103 	lsl	r3, r3, #2
3000a128:	e0833002 	add	r3, r3, r2
3000a12c:	e1a03083 	lsl	r3, r3, #1
3000a130:	e1a01003 	mov	r1, r3
3000a134:	e59d3004 	ldr	r3, [sp, #4]
3000a138:	e5933000 	ldr	r3, [r3]
3000a13c:	e5d32000 	ldrb	r2, [r3]
3000a140:	e0812002 	add	r2, r1, r2
3000a144:	e2422030 	sub	r2, r2, #48	; 0x30
3000a148:	e58d200c 	str	r2, [sp, #12]
3000a14c:	e2832001 	add	r2, r3, #1
3000a150:	e59d3004 	ldr	r3, [sp, #4]
3000a154:	e5832000 	str	r2, [r3]

acoral_32 skip_atoi(const acoral_char **s)
    {/*change the string "s" to digit*/
            acoral_32 i=0;
 
            while (IS_DIGIT(**s))
3000a158:	e59d3004 	ldr	r3, [sp, #4]
3000a15c:	e5933000 	ldr	r3, [r3]
3000a160:	e5d33000 	ldrb	r3, [r3]
3000a164:	e353002f 	cmp	r3, #47	; 0x2f
3000a168:	9a000004 	bls	3000a180 <skip_atoi+0x78>
3000a16c:	e59d3004 	ldr	r3, [sp, #4]
3000a170:	e5933000 	ldr	r3, [r3]
3000a174:	e5d33000 	ldrb	r3, [r3]
3000a178:	e3530038 	cmp	r3, #56	; 0x38
3000a17c:	9affffe6 	bls	3000a11c <skip_atoi+0x14>
                    i = i*10 + *((*s)++) - '0';
            return i;
3000a180:	e59d300c 	ldr	r3, [sp, #12]
} 
3000a184:	e1a00003 	mov	r0, r3
3000a188:	e28dd010 	add	sp, sp, #16
3000a18c:	e12fff1e 	bx	lr

3000a190 <number>:

const acoral_char small_digits[] = "0123456789abcdefghijklmnopqrstuvwxyz";
const acoral_char large_digits[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
acoral_char * number(acoral_char * buf, acoral_char * end, acoral_64 num, acoral_32 base, acoral_32 size, acoral_32 precision, acoral_32 type)
{
3000a190:	e92d4010 	push	{r4, lr}
3000a194:	e24dd060 	sub	sp, sp, #96	; 0x60
3000a198:	e58d000c 	str	r0, [sp, #12]
3000a19c:	e58d1008 	str	r1, [sp, #8]
3000a1a0:	e88d000c 	stm	sp, {r2, r3}
	acoral_char c,sign,tmp[66];
	const acoral_char *digits;
	acoral_32 i;

	digits = (type & LARGE) ? large_digits : small_digits;
3000a1a4:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a1a8:	e2033040 	and	r3, r3, #64	; 0x40
3000a1ac:	e3530000 	cmp	r3, #0
3000a1b0:	0a000001 	beq	3000a1bc <number+0x2c>
3000a1b4:	e59f34e4 	ldr	r3, [pc, #1252]	; 3000a6a0 <number+0x510>
3000a1b8:	ea000000 	b	3000a1c0 <number+0x30>
3000a1bc:	e59f34e0 	ldr	r3, [pc, #1248]	; 3000a6a4 <number+0x514>
3000a1c0:	e58d3058 	str	r3, [sp, #88]	; 0x58
	if (type & LEFT)
3000a1c4:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a1c8:	e2033010 	and	r3, r3, #16
3000a1cc:	e3530000 	cmp	r3, #0
3000a1d0:	0a000002 	beq	3000a1e0 <number+0x50>
		type &= ~ZEROPAD;
3000a1d4:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a1d8:	e3c33001 	bic	r3, r3, #1
3000a1dc:	e58d3074 	str	r3, [sp, #116]	; 0x74
	if (base < 2 || base > 36)
3000a1e0:	e59d3068 	ldr	r3, [sp, #104]	; 0x68
3000a1e4:	e3530001 	cmp	r3, #1
3000a1e8:	da000002 	ble	3000a1f8 <number+0x68>
3000a1ec:	e59d3068 	ldr	r3, [sp, #104]	; 0x68
3000a1f0:	e3530024 	cmp	r3, #36	; 0x24
3000a1f4:	da000001 	ble	3000a200 <number+0x70>
		return 0;
3000a1f8:	e3a03000 	mov	r3, #0
3000a1fc:	ea000123 	b	3000a690 <number+0x500>
	c = (type & ZEROPAD) ? '0' : ' ';
3000a200:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a204:	e2033001 	and	r3, r3, #1
3000a208:	e20330ff 	and	r3, r3, #255	; 0xff
3000a20c:	e3530000 	cmp	r3, #0
3000a210:	0a000001 	beq	3000a21c <number+0x8c>
3000a214:	e3a03030 	mov	r3, #48	; 0x30
3000a218:	ea000000 	b	3000a220 <number+0x90>
3000a21c:	e3a03020 	mov	r3, #32
3000a220:	e5cd3056 	strb	r3, [sp, #86]	; 0x56
	sign = 0;
3000a224:	e3a03000 	mov	r3, #0
3000a228:	e5cd3057 	strb	r3, [sp, #87]	; 0x57
	if (type & SIGN) {
3000a22c:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a230:	e2033002 	and	r3, r3, #2
3000a234:	e3530000 	cmp	r3, #0
3000a238:	0a000020 	beq	3000a2c0 <number+0x130>
		if (num < 0) {
3000a23c:	e89d0018 	ldm	sp, {r3, r4}
3000a240:	e3530000 	cmp	r3, #0
3000a244:	e2d40000 	sbcs	r0, r4, #0
3000a248:	aa000009 	bge	3000a274 <number+0xe4>
			sign = '-';
3000a24c:	e3a0302d 	mov	r3, #45	; 0x2d
3000a250:	e5cd3057 	strb	r3, [sp, #87]	; 0x57
			num = -num;
3000a254:	e89d0018 	ldm	sp, {r3, r4}
3000a258:	e2733000 	rsbs	r3, r3, #0
3000a25c:	e2e44000 	rsc	r4, r4, #0
3000a260:	e88d0018 	stm	sp, {r3, r4}
			size--;
3000a264:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
3000a268:	e2433001 	sub	r3, r3, #1
3000a26c:	e58d306c 	str	r3, [sp, #108]	; 0x6c
3000a270:	ea000012 	b	3000a2c0 <number+0x130>
		} else if (type & PLUS) {
3000a274:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a278:	e2033004 	and	r3, r3, #4
3000a27c:	e3530000 	cmp	r3, #0
3000a280:	0a000005 	beq	3000a29c <number+0x10c>
			sign = '+';
3000a284:	e3a0302b 	mov	r3, #43	; 0x2b
3000a288:	e5cd3057 	strb	r3, [sp, #87]	; 0x57
			size--;
3000a28c:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
3000a290:	e2433001 	sub	r3, r3, #1
3000a294:	e58d306c 	str	r3, [sp, #108]	; 0x6c
3000a298:	ea000008 	b	3000a2c0 <number+0x130>
		} else if (type & SPACE) {
3000a29c:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a2a0:	e2033008 	and	r3, r3, #8
3000a2a4:	e3530000 	cmp	r3, #0
3000a2a8:	0a000004 	beq	3000a2c0 <number+0x130>
			sign = ' ';
3000a2ac:	e3a03020 	mov	r3, #32
3000a2b0:	e5cd3057 	strb	r3, [sp, #87]	; 0x57
			size--;
3000a2b4:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
3000a2b8:	e2433001 	sub	r3, r3, #1
3000a2bc:	e58d306c 	str	r3, [sp, #108]	; 0x6c
		}
	}
	if (type & SPECIAL) {
3000a2c0:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a2c4:	e2033020 	and	r3, r3, #32
3000a2c8:	e3530000 	cmp	r3, #0
3000a2cc:	0a00000c 	beq	3000a304 <number+0x174>
		if (base == 16)
3000a2d0:	e59d3068 	ldr	r3, [sp, #104]	; 0x68
3000a2d4:	e3530010 	cmp	r3, #16
3000a2d8:	1a000003 	bne	3000a2ec <number+0x15c>
			size -= 2;
3000a2dc:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
3000a2e0:	e2433002 	sub	r3, r3, #2
3000a2e4:	e58d306c 	str	r3, [sp, #108]	; 0x6c
3000a2e8:	ea000005 	b	3000a304 <number+0x174>
		else if (base == 8)
3000a2ec:	e59d3068 	ldr	r3, [sp, #104]	; 0x68
3000a2f0:	e3530008 	cmp	r3, #8
3000a2f4:	1a000002 	bne	3000a304 <number+0x174>
			size--;
3000a2f8:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
3000a2fc:	e2433001 	sub	r3, r3, #1
3000a300:	e58d306c 	str	r3, [sp, #108]	; 0x6c
	}
	i = 0;
3000a304:	e3a03000 	mov	r3, #0
3000a308:	e58d305c 	str	r3, [sp, #92]	; 0x5c
	if (num == 0)
3000a30c:	e89d0018 	ldm	sp, {r3, r4}
3000a310:	e1931004 	orrs	r1, r3, r4
3000a314:	1a00001d 	bne	3000a390 <number+0x200>
		tmp[i++]='0';
3000a318:	e59d205c 	ldr	r2, [sp, #92]	; 0x5c
3000a31c:	e3e0304b 	mvn	r3, #75	; 0x4b
3000a320:	e28d0060 	add	r0, sp, #96	; 0x60
3000a324:	e0802002 	add	r2, r0, r2
3000a328:	e0823003 	add	r3, r2, r3
3000a32c:	e3a02030 	mov	r2, #48	; 0x30
3000a330:	e5c32000 	strb	r2, [r3]
3000a334:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
3000a338:	e2833001 	add	r3, r3, #1
3000a33c:	e58d305c 	str	r3, [sp, #92]	; 0x5c
3000a340:	ea000016 	b	3000a3a0 <number+0x210>
	else while (num != 0)
		tmp[i++] = digits[do_div(&num,base)];
3000a344:	e59d405c 	ldr	r4, [sp, #92]	; 0x5c
3000a348:	e1a0300d 	mov	r3, sp
3000a34c:	e1a00003 	mov	r0, r3
3000a350:	e59d1068 	ldr	r1, [sp, #104]	; 0x68
3000a354:	ebffff4e 	bl	3000a094 <do_div>
3000a358:	e1a03000 	mov	r3, r0
3000a35c:	e1a02003 	mov	r2, r3
3000a360:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000a364:	e0823003 	add	r3, r2, r3
3000a368:	e5d32000 	ldrb	r2, [r3]
3000a36c:	e3e0304b 	mvn	r3, #75	; 0x4b
3000a370:	e28d0060 	add	r0, sp, #96	; 0x60
3000a374:	e0801004 	add	r1, r0, r4
3000a378:	e0813003 	add	r3, r1, r3
3000a37c:	e5c32000 	strb	r2, [r3]
3000a380:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
3000a384:	e2833001 	add	r3, r3, #1
3000a388:	e58d305c 	str	r3, [sp, #92]	; 0x5c
3000a38c:	ea000000 	b	3000a394 <number+0x204>
			size--;
	}
	i = 0;
	if (num == 0)
		tmp[i++]='0';
	else while (num != 0)
3000a390:	e1a00000 	nop			; (mov r0, r0)
3000a394:	e89d0018 	ldm	sp, {r3, r4}
3000a398:	e1931004 	orrs	r1, r3, r4
3000a39c:	1affffe8 	bne	3000a344 <number+0x1b4>
		tmp[i++] = digits[do_div(&num,base)];
	if (i > precision)
3000a3a0:	e59d205c 	ldr	r2, [sp, #92]	; 0x5c
3000a3a4:	e59d3070 	ldr	r3, [sp, #112]	; 0x70
3000a3a8:	e1520003 	cmp	r2, r3
3000a3ac:	da000001 	ble	3000a3b8 <number+0x228>
		precision = i;
3000a3b0:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
3000a3b4:	e58d3070 	str	r3, [sp, #112]	; 0x70
	size -= precision;
3000a3b8:	e59d206c 	ldr	r2, [sp, #108]	; 0x6c
3000a3bc:	e59d3070 	ldr	r3, [sp, #112]	; 0x70
3000a3c0:	e0633002 	rsb	r3, r3, r2
3000a3c4:	e58d306c 	str	r3, [sp, #108]	; 0x6c
	if (!(type&(ZEROPAD+LEFT))) {
3000a3c8:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a3cc:	e2033011 	and	r3, r3, #17
3000a3d0:	e3530000 	cmp	r3, #0
3000a3d4:	1a000014 	bne	3000a42c <number+0x29c>
		while(size-->0) {
3000a3d8:	ea000009 	b	3000a404 <number+0x274>
			if (buf <= end)
3000a3dc:	e59d200c 	ldr	r2, [sp, #12]
3000a3e0:	e59d3008 	ldr	r3, [sp, #8]
3000a3e4:	e1520003 	cmp	r2, r3
3000a3e8:	8a000002 	bhi	3000a3f8 <number+0x268>
				*buf = ' ';
3000a3ec:	e59d300c 	ldr	r3, [sp, #12]
3000a3f0:	e3a02020 	mov	r2, #32
3000a3f4:	e5c32000 	strb	r2, [r3]
			++buf;
3000a3f8:	e59d300c 	ldr	r3, [sp, #12]
3000a3fc:	e2833001 	add	r3, r3, #1
3000a400:	e58d300c 	str	r3, [sp, #12]
		tmp[i++] = digits[do_div(&num,base)];
	if (i > precision)
		precision = i;
	size -= precision;
	if (!(type&(ZEROPAD+LEFT))) {
		while(size-->0) {
3000a404:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
3000a408:	e3530000 	cmp	r3, #0
3000a40c:	d3a03000 	movle	r3, #0
3000a410:	c3a03001 	movgt	r3, #1
3000a414:	e20330ff 	and	r3, r3, #255	; 0xff
3000a418:	e59d206c 	ldr	r2, [sp, #108]	; 0x6c
3000a41c:	e2422001 	sub	r2, r2, #1
3000a420:	e58d206c 	str	r2, [sp, #108]	; 0x6c
3000a424:	e3530000 	cmp	r3, #0
3000a428:	1affffeb 	bne	3000a3dc <number+0x24c>
			if (buf <= end)
				*buf = ' ';
			++buf;
		}
	}
	if (sign) {
3000a42c:	e5dd3057 	ldrb	r3, [sp, #87]	; 0x57
3000a430:	e3530000 	cmp	r3, #0
3000a434:	0a000009 	beq	3000a460 <number+0x2d0>
		if (buf <= end)
3000a438:	e59d200c 	ldr	r2, [sp, #12]
3000a43c:	e59d3008 	ldr	r3, [sp, #8]
3000a440:	e1520003 	cmp	r2, r3
3000a444:	8a000002 	bhi	3000a454 <number+0x2c4>
			*buf = sign;
3000a448:	e59d300c 	ldr	r3, [sp, #12]
3000a44c:	e5dd2057 	ldrb	r2, [sp, #87]	; 0x57
3000a450:	e5c32000 	strb	r2, [r3]
		++buf;
3000a454:	e59d300c 	ldr	r3, [sp, #12]
3000a458:	e2833001 	add	r3, r3, #1
3000a45c:	e58d300c 	str	r3, [sp, #12]
	}
	if (type & SPECIAL) {
3000a460:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a464:	e2033020 	and	r3, r3, #32
3000a468:	e3530000 	cmp	r3, #0
3000a46c:	0a000026 	beq	3000a50c <number+0x37c>
		if (base==8) {
3000a470:	e59d3068 	ldr	r3, [sp, #104]	; 0x68
3000a474:	e3530008 	cmp	r3, #8
3000a478:	1a00000a 	bne	3000a4a8 <number+0x318>
			if (buf <= end)
3000a47c:	e59d200c 	ldr	r2, [sp, #12]
3000a480:	e59d3008 	ldr	r3, [sp, #8]
3000a484:	e1520003 	cmp	r2, r3
3000a488:	8a000002 	bhi	3000a498 <number+0x308>
				*buf = '0';
3000a48c:	e59d300c 	ldr	r3, [sp, #12]
3000a490:	e3a02030 	mov	r2, #48	; 0x30
3000a494:	e5c32000 	strb	r2, [r3]
			++buf;
3000a498:	e59d300c 	ldr	r3, [sp, #12]
3000a49c:	e2833001 	add	r3, r3, #1
3000a4a0:	e58d300c 	str	r3, [sp, #12]
3000a4a4:	ea000018 	b	3000a50c <number+0x37c>
		} else if (base==16) {
3000a4a8:	e59d3068 	ldr	r3, [sp, #104]	; 0x68
3000a4ac:	e3530010 	cmp	r3, #16
3000a4b0:	1a000015 	bne	3000a50c <number+0x37c>
			if (buf <= end)
3000a4b4:	e59d200c 	ldr	r2, [sp, #12]
3000a4b8:	e59d3008 	ldr	r3, [sp, #8]
3000a4bc:	e1520003 	cmp	r2, r3
3000a4c0:	8a000002 	bhi	3000a4d0 <number+0x340>
				*buf = '0';
3000a4c4:	e59d300c 	ldr	r3, [sp, #12]
3000a4c8:	e3a02030 	mov	r2, #48	; 0x30
3000a4cc:	e5c32000 	strb	r2, [r3]
			++buf;
3000a4d0:	e59d300c 	ldr	r3, [sp, #12]
3000a4d4:	e2833001 	add	r3, r3, #1
3000a4d8:	e58d300c 	str	r3, [sp, #12]
			if (buf <= end)
3000a4dc:	e59d200c 	ldr	r2, [sp, #12]
3000a4e0:	e59d3008 	ldr	r3, [sp, #8]
3000a4e4:	e1520003 	cmp	r2, r3
3000a4e8:	8a000004 	bhi	3000a500 <number+0x370>
				*buf = digits[33];
3000a4ec:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000a4f0:	e2833021 	add	r3, r3, #33	; 0x21
3000a4f4:	e5d32000 	ldrb	r2, [r3]
3000a4f8:	e59d300c 	ldr	r3, [sp, #12]
3000a4fc:	e5c32000 	strb	r2, [r3]
			++buf;
3000a500:	e59d300c 	ldr	r3, [sp, #12]
3000a504:	e2833001 	add	r3, r3, #1
3000a508:	e58d300c 	str	r3, [sp, #12]
		}
	}
	if (!(type & LEFT)) {
3000a50c:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
3000a510:	e2033010 	and	r3, r3, #16
3000a514:	e3530000 	cmp	r3, #0
3000a518:	1a000020 	bne	3000a5a0 <number+0x410>
		while (size-- > 0) {
3000a51c:	ea000009 	b	3000a548 <number+0x3b8>
			if (buf <= end)
3000a520:	e59d200c 	ldr	r2, [sp, #12]
3000a524:	e59d3008 	ldr	r3, [sp, #8]
3000a528:	e1520003 	cmp	r2, r3
3000a52c:	8a000002 	bhi	3000a53c <number+0x3ac>
				*buf = c;
3000a530:	e59d300c 	ldr	r3, [sp, #12]
3000a534:	e5dd2056 	ldrb	r2, [sp, #86]	; 0x56
3000a538:	e5c32000 	strb	r2, [r3]
			++buf;
3000a53c:	e59d300c 	ldr	r3, [sp, #12]
3000a540:	e2833001 	add	r3, r3, #1
3000a544:	e58d300c 	str	r3, [sp, #12]
				*buf = digits[33];
			++buf;
		}
	}
	if (!(type & LEFT)) {
		while (size-- > 0) {
3000a548:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
3000a54c:	e3530000 	cmp	r3, #0
3000a550:	d3a03000 	movle	r3, #0
3000a554:	c3a03001 	movgt	r3, #1
3000a558:	e20330ff 	and	r3, r3, #255	; 0xff
3000a55c:	e59d206c 	ldr	r2, [sp, #108]	; 0x6c
3000a560:	e2422001 	sub	r2, r2, #1
3000a564:	e58d206c 	str	r2, [sp, #108]	; 0x6c
3000a568:	e3530000 	cmp	r3, #0
3000a56c:	1affffeb 	bne	3000a520 <number+0x390>
			if (buf <= end)
				*buf = c;
			++buf;
		}
	}
	while (i < precision--) {
3000a570:	ea00000b 	b	3000a5a4 <number+0x414>
		if (buf <= end)
3000a574:	e59d200c 	ldr	r2, [sp, #12]
3000a578:	e59d3008 	ldr	r3, [sp, #8]
3000a57c:	e1520003 	cmp	r2, r3
3000a580:	8a000002 	bhi	3000a590 <number+0x400>
			*buf = '0';
3000a584:	e59d300c 	ldr	r3, [sp, #12]
3000a588:	e3a02030 	mov	r2, #48	; 0x30
3000a58c:	e5c32000 	strb	r2, [r3]
		++buf;
3000a590:	e59d300c 	ldr	r3, [sp, #12]
3000a594:	e2833001 	add	r3, r3, #1
3000a598:	e58d300c 	str	r3, [sp, #12]
3000a59c:	ea000000 	b	3000a5a4 <number+0x414>
			if (buf <= end)
				*buf = c;
			++buf;
		}
	}
	while (i < precision--) {
3000a5a0:	e1a00000 	nop			; (mov r0, r0)
3000a5a4:	e59d2070 	ldr	r2, [sp, #112]	; 0x70
3000a5a8:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
3000a5ac:	e1520003 	cmp	r2, r3
3000a5b0:	d3a03000 	movle	r3, #0
3000a5b4:	c3a03001 	movgt	r3, #1
3000a5b8:	e20330ff 	and	r3, r3, #255	; 0xff
3000a5bc:	e59d2070 	ldr	r2, [sp, #112]	; 0x70
3000a5c0:	e2422001 	sub	r2, r2, #1
3000a5c4:	e58d2070 	str	r2, [sp, #112]	; 0x70
3000a5c8:	e3530000 	cmp	r3, #0
3000a5cc:	1affffe8 	bne	3000a574 <number+0x3e4>
		if (buf <= end)
			*buf = '0';
		++buf;
	}
	while (i-- > 0) {
3000a5d0:	ea00000e 	b	3000a610 <number+0x480>
		if (buf <= end)
3000a5d4:	e59d200c 	ldr	r2, [sp, #12]
3000a5d8:	e59d3008 	ldr	r3, [sp, #8]
3000a5dc:	e1520003 	cmp	r2, r3
3000a5e0:	8a000007 	bhi	3000a604 <number+0x474>
			*buf = tmp[i];
3000a5e4:	e59d205c 	ldr	r2, [sp, #92]	; 0x5c
3000a5e8:	e3e0304b 	mvn	r3, #75	; 0x4b
3000a5ec:	e28d0060 	add	r0, sp, #96	; 0x60
3000a5f0:	e0802002 	add	r2, r0, r2
3000a5f4:	e0823003 	add	r3, r2, r3
3000a5f8:	e5d32000 	ldrb	r2, [r3]
3000a5fc:	e59d300c 	ldr	r3, [sp, #12]
3000a600:	e5c32000 	strb	r2, [r3]
		++buf;
3000a604:	e59d300c 	ldr	r3, [sp, #12]
3000a608:	e2833001 	add	r3, r3, #1
3000a60c:	e58d300c 	str	r3, [sp, #12]
	while (i < precision--) {
		if (buf <= end)
			*buf = '0';
		++buf;
	}
	while (i-- > 0) {
3000a610:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
3000a614:	e3530000 	cmp	r3, #0
3000a618:	d3a03000 	movle	r3, #0
3000a61c:	c3a03001 	movgt	r3, #1
3000a620:	e20330ff 	and	r3, r3, #255	; 0xff
3000a624:	e59d205c 	ldr	r2, [sp, #92]	; 0x5c
3000a628:	e2422001 	sub	r2, r2, #1
3000a62c:	e58d205c 	str	r2, [sp, #92]	; 0x5c
3000a630:	e3530000 	cmp	r3, #0
3000a634:	1affffe6 	bne	3000a5d4 <number+0x444>
		if (buf <= end)
			*buf = tmp[i];
		++buf;
	}
	while (size-- > 0) {
3000a638:	ea000009 	b	3000a664 <number+0x4d4>
		if (buf <= end)
3000a63c:	e59d200c 	ldr	r2, [sp, #12]
3000a640:	e59d3008 	ldr	r3, [sp, #8]
3000a644:	e1520003 	cmp	r2, r3
3000a648:	8a000002 	bhi	3000a658 <number+0x4c8>
			*buf = ' ';
3000a64c:	e59d300c 	ldr	r3, [sp, #12]
3000a650:	e3a02020 	mov	r2, #32
3000a654:	e5c32000 	strb	r2, [r3]
		++buf;
3000a658:	e59d300c 	ldr	r3, [sp, #12]
3000a65c:	e2833001 	add	r3, r3, #1
3000a660:	e58d300c 	str	r3, [sp, #12]
	while (i-- > 0) {
		if (buf <= end)
			*buf = tmp[i];
		++buf;
	}
	while (size-- > 0) {
3000a664:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
3000a668:	e3530000 	cmp	r3, #0
3000a66c:	d3a03000 	movle	r3, #0
3000a670:	c3a03001 	movgt	r3, #1
3000a674:	e20330ff 	and	r3, r3, #255	; 0xff
3000a678:	e59d206c 	ldr	r2, [sp, #108]	; 0x6c
3000a67c:	e2422001 	sub	r2, r2, #1
3000a680:	e58d206c 	str	r2, [sp, #108]	; 0x6c
3000a684:	e3530000 	cmp	r3, #0
3000a688:	1affffeb 	bne	3000a63c <number+0x4ac>
		if (buf <= end)
			*buf = ' ';
		++buf;
	}
	return buf;
3000a68c:	e59d300c 	ldr	r3, [sp, #12]
}
3000a690:	e1a00003 	mov	r0, r3
3000a694:	e28dd060 	add	sp, sp, #96	; 0x60
3000a698:	e8bd4010 	pop	{r4, lr}
3000a69c:	e12fff1e 	bx	lr
3000a6a0:	30045648 	.word	0x30045648
3000a6a4:	30045620 	.word	0x30045620

3000a6a8 <vsnprintf>:
				   number of acoral_chars for from string */
	acoral_32 qualifier;		/* 'h', 'l', or 'L' for acoral_32eger fields */
				/* 'z' support added 23/7/1999 S.H.    */
				/* 'z' changed to 'Z' --davidm 1/25/99 */

	str = buf;
3000a6a8:	e92d4010 	push	{r4, lr}
3000a6ac:	e24dd068 	sub	sp, sp, #104	; 0x68
3000a6b0:	e58d001c 	str	r0, [sp, #28]
3000a6b4:	e58d1018 	str	r1, [sp, #24]
3000a6b8:	e58d2014 	str	r2, [sp, #20]
3000a6bc:	e58d3010 	str	r3, [sp, #16]
3000a6c0:	e59d301c 	ldr	r3, [sp, #28]
3000a6c4:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	end = buf + size - 1;
3000a6c8:	e59d3018 	ldr	r3, [sp, #24]
3000a6cc:	e2433001 	sub	r3, r3, #1
3000a6d0:	e59d201c 	ldr	r2, [sp, #28]
3000a6d4:	e0823003 	add	r3, r2, r3
3000a6d8:	e58d3040 	str	r3, [sp, #64]	; 0x40

	if (end < buf - 1) {
3000a6dc:	e59d301c 	ldr	r3, [sp, #28]
3000a6e0:	e2432001 	sub	r2, r3, #1
3000a6e4:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000a6e8:	e1520003 	cmp	r2, r3
3000a6ec:	9a0002a0 	bls	3000b174 <vsnprintf+0xacc>
		end = ((void *) -1);
3000a6f0:	e3e03000 	mvn	r3, #0
3000a6f4:	e58d3040 	str	r3, [sp, #64]	; 0x40
		size = end - buf + 1;
3000a6f8:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
3000a6fc:	e59d301c 	ldr	r3, [sp, #28]
3000a700:	e0633002 	rsb	r3, r3, r2
3000a704:	e2833001 	add	r3, r3, #1
3000a708:	e58d3018 	str	r3, [sp, #24]
	}

	for (; *fmt ; ++fmt) {
3000a70c:	ea000299 	b	3000b178 <vsnprintf+0xad0>
		if (*fmt != '%') {
3000a710:	e59d3014 	ldr	r3, [sp, #20]
3000a714:	e5d33000 	ldrb	r3, [r3]
3000a718:	e3530025 	cmp	r3, #37	; 0x25
3000a71c:	0a00000b 	beq	3000a750 <vsnprintf+0xa8>
			if (str <= end)
3000a720:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000a724:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000a728:	e1520003 	cmp	r2, r3
3000a72c:	8a000003 	bhi	3000a740 <vsnprintf+0x98>
				*str = *fmt;
3000a730:	e59d3014 	ldr	r3, [sp, #20]
3000a734:	e5d32000 	ldrb	r2, [r3]
3000a738:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000a73c:	e5c32000 	strb	r2, [r3]
			++str;
3000a740:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000a744:	e2833001 	add	r3, r3, #1
3000a748:	e58d303c 	str	r3, [sp, #60]	; 0x3c
			continue;
3000a74c:	ea000284 	b	3000b164 <vsnprintf+0xabc>
		}

		/* process flags */
		flags = 0;
3000a750:	e3a03000 	mov	r3, #0
3000a754:	e58d304c 	str	r3, [sp, #76]	; 0x4c
		repeat:
			++fmt;		/* this also skips first '%' */
3000a758:	e59d3014 	ldr	r3, [sp, #20]
3000a75c:	e2833001 	add	r3, r3, #1
3000a760:	e58d3014 	str	r3, [sp, #20]
			switch (*fmt) {
3000a764:	e59d3014 	ldr	r3, [sp, #20]
3000a768:	e5d33000 	ldrb	r3, [r3]
3000a76c:	e2433020 	sub	r3, r3, #32
3000a770:	e3530010 	cmp	r3, #16
3000a774:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3000a778:	ea000024 	b	3000a810 <vsnprintf+0x168>
3000a77c:	3000a7e0 	.word	0x3000a7e0
3000a780:	3000a810 	.word	0x3000a810
3000a784:	3000a810 	.word	0x3000a810
3000a788:	3000a7f0 	.word	0x3000a7f0
3000a78c:	3000a810 	.word	0x3000a810
3000a790:	3000a810 	.word	0x3000a810
3000a794:	3000a810 	.word	0x3000a810
3000a798:	3000a810 	.word	0x3000a810
3000a79c:	3000a810 	.word	0x3000a810
3000a7a0:	3000a810 	.word	0x3000a810
3000a7a4:	3000a810 	.word	0x3000a810
3000a7a8:	3000a7d0 	.word	0x3000a7d0
3000a7ac:	3000a810 	.word	0x3000a810
3000a7b0:	3000a7c0 	.word	0x3000a7c0
3000a7b4:	3000a810 	.word	0x3000a810
3000a7b8:	3000a810 	.word	0x3000a810
3000a7bc:	3000a800 	.word	0x3000a800
				case '-': flags |= LEFT; goto repeat;
3000a7c0:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000a7c4:	e3833010 	orr	r3, r3, #16
3000a7c8:	e58d304c 	str	r3, [sp, #76]	; 0x4c
3000a7cc:	eaffffe1 	b	3000a758 <vsnprintf+0xb0>
				case '+': flags |= PLUS; goto repeat;
3000a7d0:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000a7d4:	e3833004 	orr	r3, r3, #4
3000a7d8:	e58d304c 	str	r3, [sp, #76]	; 0x4c
3000a7dc:	eaffffdd 	b	3000a758 <vsnprintf+0xb0>
				case ' ': flags |= SPACE; goto repeat;
3000a7e0:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000a7e4:	e3833008 	orr	r3, r3, #8
3000a7e8:	e58d304c 	str	r3, [sp, #76]	; 0x4c
3000a7ec:	eaffffd9 	b	3000a758 <vsnprintf+0xb0>
				case '#': flags |= SPECIAL; goto repeat;
3000a7f0:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000a7f4:	e3833020 	orr	r3, r3, #32
3000a7f8:	e58d304c 	str	r3, [sp, #76]	; 0x4c
3000a7fc:	eaffffd5 	b	3000a758 <vsnprintf+0xb0>
				case '0': flags |= ZEROPAD; goto repeat;
3000a800:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000a804:	e3833001 	orr	r3, r3, #1
3000a808:	e58d304c 	str	r3, [sp, #76]	; 0x4c
3000a80c:	eaffffd1 	b	3000a758 <vsnprintf+0xb0>
			}

		/* get field width */
		field_width = -1;
3000a810:	e3e03000 	mvn	r3, #0
3000a814:	e58d3050 	str	r3, [sp, #80]	; 0x50
		if (IS_DIGIT(*fmt))
3000a818:	e59d3014 	ldr	r3, [sp, #20]
3000a81c:	e5d33000 	ldrb	r3, [r3]
3000a820:	e353002f 	cmp	r3, #47	; 0x2f
3000a824:	9a000009 	bls	3000a850 <vsnprintf+0x1a8>
3000a828:	e59d3014 	ldr	r3, [sp, #20]
3000a82c:	e5d33000 	ldrb	r3, [r3]
3000a830:	e3530038 	cmp	r3, #56	; 0x38
3000a834:	8a000005 	bhi	3000a850 <vsnprintf+0x1a8>
			field_width = skip_atoi(&fmt);
3000a838:	e28d3014 	add	r3, sp, #20
3000a83c:	e1a00003 	mov	r0, r3
3000a840:	ebfffe30 	bl	3000a108 <skip_atoi>
3000a844:	e1a03000 	mov	r3, r0
3000a848:	e58d3050 	str	r3, [sp, #80]	; 0x50
				case '0': flags |= ZEROPAD; goto repeat;
			}

		/* get field width */
		field_width = -1;
		if (IS_DIGIT(*fmt))
3000a84c:	ea000016 	b	3000a8ac <vsnprintf+0x204>
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
3000a850:	e59d3014 	ldr	r3, [sp, #20]
3000a854:	e5d33000 	ldrb	r3, [r3]
3000a858:	e353002a 	cmp	r3, #42	; 0x2a
3000a85c:	1a000012 	bne	3000a8ac <vsnprintf+0x204>
			++fmt;
3000a860:	e59d3014 	ldr	r3, [sp, #20]
3000a864:	e2833001 	add	r3, r3, #1
3000a868:	e58d3014 	str	r3, [sp, #20]
			/* it's the next argument */
			field_width = va_arg(args, acoral_32);
3000a86c:	e59d3010 	ldr	r3, [sp, #16]
3000a870:	e2833004 	add	r3, r3, #4
3000a874:	e58d3010 	str	r3, [sp, #16]
3000a878:	e59d3010 	ldr	r3, [sp, #16]
3000a87c:	e2433004 	sub	r3, r3, #4
3000a880:	e5933000 	ldr	r3, [r3]
3000a884:	e58d3050 	str	r3, [sp, #80]	; 0x50
			if (field_width < 0) {
3000a888:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
3000a88c:	e3530000 	cmp	r3, #0
3000a890:	aa000005 	bge	3000a8ac <vsnprintf+0x204>
				field_width = -field_width;
3000a894:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
3000a898:	e2633000 	rsb	r3, r3, #0
3000a89c:	e58d3050 	str	r3, [sp, #80]	; 0x50
				flags |= LEFT;
3000a8a0:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000a8a4:	e3833010 	orr	r3, r3, #16
3000a8a8:	e58d304c 	str	r3, [sp, #76]	; 0x4c
			}
		}

		/* get the precision */
		precision = -1;
3000a8ac:	e3e03000 	mvn	r3, #0
3000a8b0:	e58d3054 	str	r3, [sp, #84]	; 0x54
		if (*fmt == '.') {
3000a8b4:	e59d3014 	ldr	r3, [sp, #20]
3000a8b8:	e5d33000 	ldrb	r3, [r3]
3000a8bc:	e353002e 	cmp	r3, #46	; 0x2e
3000a8c0:	1a000023 	bne	3000a954 <vsnprintf+0x2ac>
			++fmt;	
3000a8c4:	e59d3014 	ldr	r3, [sp, #20]
3000a8c8:	e2833001 	add	r3, r3, #1
3000a8cc:	e58d3014 	str	r3, [sp, #20]
			if (IS_DIGIT(*fmt))
3000a8d0:	e59d3014 	ldr	r3, [sp, #20]
3000a8d4:	e5d33000 	ldrb	r3, [r3]
3000a8d8:	e353002f 	cmp	r3, #47	; 0x2f
3000a8dc:	9a000009 	bls	3000a908 <vsnprintf+0x260>
3000a8e0:	e59d3014 	ldr	r3, [sp, #20]
3000a8e4:	e5d33000 	ldrb	r3, [r3]
3000a8e8:	e3530038 	cmp	r3, #56	; 0x38
3000a8ec:	8a000005 	bhi	3000a908 <vsnprintf+0x260>
				precision = skip_atoi(&fmt);
3000a8f0:	e28d3014 	add	r3, sp, #20
3000a8f4:	e1a00003 	mov	r0, r3
3000a8f8:	ebfffe02 	bl	3000a108 <skip_atoi>
3000a8fc:	e1a03000 	mov	r3, r0
3000a900:	e58d3054 	str	r3, [sp, #84]	; 0x54

		/* get the precision */
		precision = -1;
		if (*fmt == '.') {
			++fmt;	
			if (IS_DIGIT(*fmt))
3000a904:	ea00000d 	b	3000a940 <vsnprintf+0x298>
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
3000a908:	e59d3014 	ldr	r3, [sp, #20]
3000a90c:	e5d33000 	ldrb	r3, [r3]
3000a910:	e353002a 	cmp	r3, #42	; 0x2a
3000a914:	1a000009 	bne	3000a940 <vsnprintf+0x298>
				++fmt;
3000a918:	e59d3014 	ldr	r3, [sp, #20]
3000a91c:	e2833001 	add	r3, r3, #1
3000a920:	e58d3014 	str	r3, [sp, #20]
				/* it's the next argument */
				precision = va_arg(args, acoral_32);
3000a924:	e59d3010 	ldr	r3, [sp, #16]
3000a928:	e2833004 	add	r3, r3, #4
3000a92c:	e58d3010 	str	r3, [sp, #16]
3000a930:	e59d3010 	ldr	r3, [sp, #16]
3000a934:	e2433004 	sub	r3, r3, #4
3000a938:	e5933000 	ldr	r3, [r3]
3000a93c:	e58d3054 	str	r3, [sp, #84]	; 0x54
			}
			if (precision < 0)
3000a940:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
3000a944:	e3530000 	cmp	r3, #0
3000a948:	aa000001 	bge	3000a954 <vsnprintf+0x2ac>
				precision = 0;
3000a94c:	e3a03000 	mov	r3, #0
3000a950:	e58d3054 	str	r3, [sp, #84]	; 0x54
		}

		/* get the conversion qualifier */
		qualifier = -1;
3000a954:	e3e03000 	mvn	r3, #0
3000a958:	e58d3058 	str	r3, [sp, #88]	; 0x58
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt =='Z') {
3000a95c:	e59d3014 	ldr	r3, [sp, #20]
3000a960:	e5d33000 	ldrb	r3, [r3]
3000a964:	e3530068 	cmp	r3, #104	; 0x68
3000a968:	0a00000b 	beq	3000a99c <vsnprintf+0x2f4>
3000a96c:	e59d3014 	ldr	r3, [sp, #20]
3000a970:	e5d33000 	ldrb	r3, [r3]
3000a974:	e353006c 	cmp	r3, #108	; 0x6c
3000a978:	0a000007 	beq	3000a99c <vsnprintf+0x2f4>
3000a97c:	e59d3014 	ldr	r3, [sp, #20]
3000a980:	e5d33000 	ldrb	r3, [r3]
3000a984:	e353004c 	cmp	r3, #76	; 0x4c
3000a988:	0a000003 	beq	3000a99c <vsnprintf+0x2f4>
3000a98c:	e59d3014 	ldr	r3, [sp, #20]
3000a990:	e5d33000 	ldrb	r3, [r3]
3000a994:	e353005a 	cmp	r3, #90	; 0x5a
3000a998:	1a000011 	bne	3000a9e4 <vsnprintf+0x33c>
			qualifier = *fmt;
3000a99c:	e59d3014 	ldr	r3, [sp, #20]
3000a9a0:	e5d33000 	ldrb	r3, [r3]
3000a9a4:	e58d3058 	str	r3, [sp, #88]	; 0x58
			++fmt;
3000a9a8:	e59d3014 	ldr	r3, [sp, #20]
3000a9ac:	e2833001 	add	r3, r3, #1
3000a9b0:	e58d3014 	str	r3, [sp, #20]
			if (qualifier == 'l' && *fmt == 'l') {
3000a9b4:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000a9b8:	e353006c 	cmp	r3, #108	; 0x6c
3000a9bc:	1a000008 	bne	3000a9e4 <vsnprintf+0x33c>
3000a9c0:	e59d3014 	ldr	r3, [sp, #20]
3000a9c4:	e5d33000 	ldrb	r3, [r3]
3000a9c8:	e353006c 	cmp	r3, #108	; 0x6c
3000a9cc:	1a000004 	bne	3000a9e4 <vsnprintf+0x33c>
				qualifier = 'L';
3000a9d0:	e3a0304c 	mov	r3, #76	; 0x4c
3000a9d4:	e58d3058 	str	r3, [sp, #88]	; 0x58
				++fmt;
3000a9d8:	e59d3014 	ldr	r3, [sp, #20]
3000a9dc:	e2833001 	add	r3, r3, #1
3000a9e0:	e58d3014 	str	r3, [sp, #20]
			}
		}

		/* default base */
		base = 10;
3000a9e4:	e3a0300a 	mov	r3, #10
3000a9e8:	e58d3038 	str	r3, [sp, #56]	; 0x38

		switch (*fmt) {
3000a9ec:	e59d3014 	ldr	r3, [sp, #20]
3000a9f0:	e5d33000 	ldrb	r3, [r3]
3000a9f4:	e2433025 	sub	r3, r3, #37	; 0x25
3000a9f8:	e3530053 	cmp	r3, #83	; 0x53
3000a9fc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3000aa00:	ea00014b 	b	3000af34 <vsnprintf+0x88c>
3000aa04:	3000aed4 	.word	0x3000aed4
3000aa08:	3000af34 	.word	0x3000af34
3000aa0c:	3000af34 	.word	0x3000af34
3000aa10:	3000af34 	.word	0x3000af34
3000aa14:	3000af34 	.word	0x3000af34
3000aa18:	3000af34 	.word	0x3000af34
3000aa1c:	3000af34 	.word	0x3000af34
3000aa20:	3000af34 	.word	0x3000af34
3000aa24:	3000af34 	.word	0x3000af34
3000aa28:	3000af34 	.word	0x3000af34
3000aa2c:	3000af34 	.word	0x3000af34
3000aa30:	3000af34 	.word	0x3000af34
3000aa34:	3000af34 	.word	0x3000af34
3000aa38:	3000af34 	.word	0x3000af34
3000aa3c:	3000af34 	.word	0x3000af34
3000aa40:	3000af34 	.word	0x3000af34
3000aa44:	3000af34 	.word	0x3000af34
3000aa48:	3000af34 	.word	0x3000af34
3000aa4c:	3000af34 	.word	0x3000af34
3000aa50:	3000af34 	.word	0x3000af34
3000aa54:	3000af34 	.word	0x3000af34
3000aa58:	3000af34 	.word	0x3000af34
3000aa5c:	3000af34 	.word	0x3000af34
3000aa60:	3000af34 	.word	0x3000af34
3000aa64:	3000af34 	.word	0x3000af34
3000aa68:	3000af34 	.word	0x3000af34
3000aa6c:	3000af34 	.word	0x3000af34
3000aa70:	3000af34 	.word	0x3000af34
3000aa74:	3000af34 	.word	0x3000af34
3000aa78:	3000af34 	.word	0x3000af34
3000aa7c:	3000af34 	.word	0x3000af34
3000aa80:	3000af34 	.word	0x3000af34
3000aa84:	3000af34 	.word	0x3000af34
3000aa88:	3000af34 	.word	0x3000af34
3000aa8c:	3000af34 	.word	0x3000af34
3000aa90:	3000af34 	.word	0x3000af34
3000aa94:	3000af34 	.word	0x3000af34
3000aa98:	3000af34 	.word	0x3000af34
3000aa9c:	3000af34 	.word	0x3000af34
3000aaa0:	3000af34 	.word	0x3000af34
3000aaa4:	3000af34 	.word	0x3000af34
3000aaa8:	3000af34 	.word	0x3000af34
3000aaac:	3000af34 	.word	0x3000af34
3000aab0:	3000af34 	.word	0x3000af34
3000aab4:	3000af34 	.word	0x3000af34
3000aab8:	3000af34 	.word	0x3000af34
3000aabc:	3000af34 	.word	0x3000af34
3000aac0:	3000af34 	.word	0x3000af34
3000aac4:	3000af34 	.word	0x3000af34
3000aac8:	3000af34 	.word	0x3000af34
3000aacc:	3000af34 	.word	0x3000af34
3000aad0:	3000af0c 	.word	0x3000af0c
3000aad4:	3000af34 	.word	0x3000af34
3000aad8:	3000af34 	.word	0x3000af34
3000aadc:	3000af34 	.word	0x3000af34
3000aae0:	3000af34 	.word	0x3000af34
3000aae4:	3000af34 	.word	0x3000af34
3000aae8:	3000af34 	.word	0x3000af34
3000aaec:	3000af34 	.word	0x3000af34
3000aaf0:	3000af34 	.word	0x3000af34
3000aaf4:	3000af34 	.word	0x3000af34
3000aaf8:	3000af34 	.word	0x3000af34
3000aafc:	3000ab54 	.word	0x3000ab54
3000ab00:	3000af24 	.word	0x3000af24
3000ab04:	3000af34 	.word	0x3000af34
3000ab08:	3000af34 	.word	0x3000af34
3000ab0c:	3000af34 	.word	0x3000af34
3000ab10:	3000af34 	.word	0x3000af34
3000ab14:	3000af24 	.word	0x3000af24
3000ab18:	3000af34 	.word	0x3000af34
3000ab1c:	3000af34 	.word	0x3000af34
3000ab20:	3000af34 	.word	0x3000af34
3000ab24:	3000af34 	.word	0x3000af34
3000ab28:	3000ae1c 	.word	0x3000ae1c
3000ab2c:	3000af00 	.word	0x3000af00
3000ab30:	3000ada0 	.word	0x3000ada0
3000ab34:	3000af34 	.word	0x3000af34
3000ab38:	3000af34 	.word	0x3000af34
3000ab3c:	3000ac34 	.word	0x3000ac34
3000ab40:	3000af34 	.word	0x3000af34
3000ab44:	3000afac 	.word	0x3000afac
3000ab48:	3000af34 	.word	0x3000af34
3000ab4c:	3000af34 	.word	0x3000af34
3000ab50:	3000af18 	.word	0x3000af18
			case 'c':
				if (!(flags & LEFT)) {
3000ab54:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000ab58:	e2033010 	and	r3, r3, #16
3000ab5c:	e3530000 	cmp	r3, #0
3000ab60:	1a000010 	bne	3000aba8 <vsnprintf+0x500>
					while (--field_width > 0) {
3000ab64:	ea000009 	b	3000ab90 <vsnprintf+0x4e8>
						if (str <= end)
3000ab68:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000ab6c:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000ab70:	e1520003 	cmp	r2, r3
3000ab74:	8a000002 	bhi	3000ab84 <vsnprintf+0x4dc>
							*str = ' ';
3000ab78:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000ab7c:	e3a02020 	mov	r2, #32
3000ab80:	e5c32000 	strb	r2, [r3]
						++str;
3000ab84:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000ab88:	e2833001 	add	r3, r3, #1
3000ab8c:	e58d303c 	str	r3, [sp, #60]	; 0x3c
		base = 10;

		switch (*fmt) {
			case 'c':
				if (!(flags & LEFT)) {
					while (--field_width > 0) {
3000ab90:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
3000ab94:	e2433001 	sub	r3, r3, #1
3000ab98:	e58d3050 	str	r3, [sp, #80]	; 0x50
3000ab9c:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
3000aba0:	e3530000 	cmp	r3, #0
3000aba4:	caffffef 	bgt	3000ab68 <vsnprintf+0x4c0>
						if (str <= end)
							*str = ' ';
						++str;
					}
				}
				c = (acoral_u8) va_arg(args, acoral_32);
3000aba8:	e59d3010 	ldr	r3, [sp, #16]
3000abac:	e2833004 	add	r3, r3, #4
3000abb0:	e58d3010 	str	r3, [sp, #16]
3000abb4:	e59d3010 	ldr	r3, [sp, #16]
3000abb8:	e2433004 	sub	r3, r3, #4
3000abbc:	e5933000 	ldr	r3, [r3]
3000abc0:	e5cd3047 	strb	r3, [sp, #71]	; 0x47
				if (str <= end)
3000abc4:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000abc8:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000abcc:	e1520003 	cmp	r2, r3
3000abd0:	8a000002 	bhi	3000abe0 <vsnprintf+0x538>
					*str = c;
3000abd4:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000abd8:	e5dd2047 	ldrb	r2, [sp, #71]	; 0x47
3000abdc:	e5c32000 	strb	r2, [r3]
				++str;
3000abe0:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000abe4:	e2833001 	add	r3, r3, #1
3000abe8:	e58d303c 	str	r3, [sp, #60]	; 0x3c
				while (--field_width > 0) {
3000abec:	ea000009 	b	3000ac18 <vsnprintf+0x570>
					if (str <= end)
3000abf0:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000abf4:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000abf8:	e1520003 	cmp	r2, r3
3000abfc:	8a000002 	bhi	3000ac0c <vsnprintf+0x564>
						*str = ' ';
3000ac00:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000ac04:	e3a02020 	mov	r2, #32
3000ac08:	e5c32000 	strb	r2, [r3]
					++str;
3000ac0c:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000ac10:	e2833001 	add	r3, r3, #1
3000ac14:	e58d303c 	str	r3, [sp, #60]	; 0x3c
				}
				c = (acoral_u8) va_arg(args, acoral_32);
				if (str <= end)
					*str = c;
				++str;
				while (--field_width > 0) {
3000ac18:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
3000ac1c:	e2433001 	sub	r3, r3, #1
3000ac20:	e58d3050 	str	r3, [sp, #80]	; 0x50
3000ac24:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
3000ac28:	e3530000 	cmp	r3, #0
3000ac2c:	caffffef 	bgt	3000abf0 <vsnprintf+0x548>
					if (str <= end)
						*str = ' ';
					++str;
				}
				continue;
3000ac30:	ea00014b 	b	3000b164 <vsnprintf+0xabc>

			case 's':
				s = va_arg(args, acoral_char *);
3000ac34:	e59d3010 	ldr	r3, [sp, #16]
3000ac38:	e2833004 	add	r3, r3, #4
3000ac3c:	e58d3010 	str	r3, [sp, #16]
3000ac40:	e59d3010 	ldr	r3, [sp, #16]
3000ac44:	e2433004 	sub	r3, r3, #4
3000ac48:	e5933000 	ldr	r3, [r3]
3000ac4c:	e58d3048 	str	r3, [sp, #72]	; 0x48
				if (!s)
3000ac50:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
3000ac54:	e3530000 	cmp	r3, #0
3000ac58:	1a000001 	bne	3000ac64 <vsnprintf+0x5bc>
					s = "<NULL>";
3000ac5c:	e59f3578 	ldr	r3, [pc, #1400]	; 3000b1dc <vsnprintf+0xb34>
3000ac60:	e58d3048 	str	r3, [sp, #72]	; 0x48

				len = acoral_str_nlen(s, precision);
3000ac64:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
3000ac68:	e59d0048 	ldr	r0, [sp, #72]	; 0x48
3000ac6c:	e1a01003 	mov	r1, r3
3000ac70:	eb0004c5 	bl	3000bf8c <acoral_str_nlen>
3000ac74:	e1a03000 	mov	r3, r0
3000ac78:	e58d3024 	str	r3, [sp, #36]	; 0x24

				if (!(flags & LEFT)) {
3000ac7c:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000ac80:	e2033010 	and	r3, r3, #16
3000ac84:	e3530000 	cmp	r3, #0
3000ac88:	1a000015 	bne	3000ace4 <vsnprintf+0x63c>
					while (len < field_width--) {
3000ac8c:	ea000009 	b	3000acb8 <vsnprintf+0x610>
						if (str <= end)
3000ac90:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000ac94:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000ac98:	e1520003 	cmp	r2, r3
3000ac9c:	8a000002 	bhi	3000acac <vsnprintf+0x604>
							*str = ' ';
3000aca0:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000aca4:	e3a02020 	mov	r2, #32
3000aca8:	e5c32000 	strb	r2, [r3]
						++str;
3000acac:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000acb0:	e2833001 	add	r3, r3, #1
3000acb4:	e58d303c 	str	r3, [sp, #60]	; 0x3c
					s = "<NULL>";

				len = acoral_str_nlen(s, precision);

				if (!(flags & LEFT)) {
					while (len < field_width--) {
3000acb8:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
3000acbc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3000acc0:	e1520003 	cmp	r2, r3
3000acc4:	d3a03000 	movle	r3, #0
3000acc8:	c3a03001 	movgt	r3, #1
3000accc:	e20330ff 	and	r3, r3, #255	; 0xff
3000acd0:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
3000acd4:	e2422001 	sub	r2, r2, #1
3000acd8:	e58d2050 	str	r2, [sp, #80]	; 0x50
3000acdc:	e3530000 	cmp	r3, #0
3000ace0:	1affffea 	bne	3000ac90 <vsnprintf+0x5e8>
						if (str <= end)
							*str = ' ';
						++str;
					}
				}
				for (i = 0; i < len; ++i) {
3000ace4:	e3a03000 	mov	r3, #0
3000ace8:	e58d3034 	str	r3, [sp, #52]	; 0x34
3000acec:	ea000010 	b	3000ad34 <vsnprintf+0x68c>
					if (str <= end)
3000acf0:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000acf4:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000acf8:	e1520003 	cmp	r2, r3
3000acfc:	8a000003 	bhi	3000ad10 <vsnprintf+0x668>
						*str = *s;
3000ad00:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
3000ad04:	e5d32000 	ldrb	r2, [r3]
3000ad08:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000ad0c:	e5c32000 	strb	r2, [r3]
					++str; ++s;
3000ad10:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000ad14:	e2833001 	add	r3, r3, #1
3000ad18:	e58d303c 	str	r3, [sp, #60]	; 0x3c
3000ad1c:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
3000ad20:	e2833001 	add	r3, r3, #1
3000ad24:	e58d3048 	str	r3, [sp, #72]	; 0x48
						if (str <= end)
							*str = ' ';
						++str;
					}
				}
				for (i = 0; i < len; ++i) {
3000ad28:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3000ad2c:	e2833001 	add	r3, r3, #1
3000ad30:	e58d3034 	str	r3, [sp, #52]	; 0x34
3000ad34:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3000ad38:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3000ad3c:	e1520003 	cmp	r2, r3
3000ad40:	baffffea 	blt	3000acf0 <vsnprintf+0x648>
					if (str <= end)
						*str = *s;
					++str; ++s;
				}
				while (len < field_width--) {
3000ad44:	ea000009 	b	3000ad70 <vsnprintf+0x6c8>
					if (str <= end)
3000ad48:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000ad4c:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000ad50:	e1520003 	cmp	r2, r3
3000ad54:	8a000002 	bhi	3000ad64 <vsnprintf+0x6bc>
						*str = ' ';
3000ad58:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000ad5c:	e3a02020 	mov	r2, #32
3000ad60:	e5c32000 	strb	r2, [r3]
					++str;
3000ad64:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000ad68:	e2833001 	add	r3, r3, #1
3000ad6c:	e58d303c 	str	r3, [sp, #60]	; 0x3c
				for (i = 0; i < len; ++i) {
					if (str <= end)
						*str = *s;
					++str; ++s;
				}
				while (len < field_width--) {
3000ad70:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
3000ad74:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3000ad78:	e1520003 	cmp	r2, r3
3000ad7c:	d3a03000 	movle	r3, #0
3000ad80:	c3a03001 	movgt	r3, #1
3000ad84:	e20330ff 	and	r3, r3, #255	; 0xff
3000ad88:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
3000ad8c:	e2422001 	sub	r2, r2, #1
3000ad90:	e58d2050 	str	r2, [sp, #80]	; 0x50
3000ad94:	e3530000 	cmp	r3, #0
3000ad98:	1affffea 	bne	3000ad48 <vsnprintf+0x6a0>
					if (str <= end)
						*str = ' ';
					++str;
				}
				continue;
3000ad9c:	ea0000f0 	b	3000b164 <vsnprintf+0xabc>

			case 'p':
				if (field_width == -1) {
3000ada0:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
3000ada4:	e3730001 	cmn	r3, #1
3000ada8:	1a000004 	bne	3000adc0 <vsnprintf+0x718>
					field_width = 2*sizeof(void *);
3000adac:	e3a03008 	mov	r3, #8
3000adb0:	e58d3050 	str	r3, [sp, #80]	; 0x50
					flags |= ZEROPAD;
3000adb4:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000adb8:	e3833001 	orr	r3, r3, #1
3000adbc:	e58d304c 	str	r3, [sp, #76]	; 0x4c
				}
				str = number(str, end,
3000adc0:	e59d3010 	ldr	r3, [sp, #16]
3000adc4:	e2833004 	add	r3, r3, #4
3000adc8:	e58d3010 	str	r3, [sp, #16]
						(acoral_u32) va_arg(args, void *),
3000adcc:	e59d3010 	ldr	r3, [sp, #16]
3000add0:	e2433004 	sub	r3, r3, #4
3000add4:	e5933000 	ldr	r3, [r3]
			case 'p':
				if (field_width == -1) {
					field_width = 2*sizeof(void *);
					flags |= ZEROPAD;
				}
				str = number(str, end,
3000add8:	e3a04000 	mov	r4, #0
3000addc:	e3a02010 	mov	r2, #16
3000ade0:	e58d2000 	str	r2, [sp]
3000ade4:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
3000ade8:	e58d2004 	str	r2, [sp, #4]
3000adec:	e59d2054 	ldr	r2, [sp, #84]	; 0x54
3000adf0:	e58d2008 	str	r2, [sp, #8]
3000adf4:	e59d204c 	ldr	r2, [sp, #76]	; 0x4c
3000adf8:	e58d200c 	str	r2, [sp, #12]
3000adfc:	e59d003c 	ldr	r0, [sp, #60]	; 0x3c
3000ae00:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
3000ae04:	e1a02003 	mov	r2, r3
3000ae08:	e1a03004 	mov	r3, r4
3000ae0c:	ebfffcdf 	bl	3000a190 <number>
3000ae10:	e1a03000 	mov	r3, r0
3000ae14:	e58d303c 	str	r3, [sp, #60]	; 0x3c
						(acoral_u32) va_arg(args, void *),
						16, field_width, precision, flags);
				continue;
3000ae18:	ea0000d1 	b	3000b164 <vsnprintf+0xabc>


			case 'n':
				/* FIXME:
				* What does C99 say about the overflow case here? */
				if (qualifier == 'l') {
3000ae1c:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000ae20:	e353006c 	cmp	r3, #108	; 0x6c
3000ae24:	1a00000c 	bne	3000ae5c <vsnprintf+0x7b4>
					acoral_32 * ip = va_arg(args, acoral_32 *);
3000ae28:	e59d3010 	ldr	r3, [sp, #16]
3000ae2c:	e2833004 	add	r3, r3, #4
3000ae30:	e58d3010 	str	r3, [sp, #16]
3000ae34:	e59d3010 	ldr	r3, [sp, #16]
3000ae38:	e2433004 	sub	r3, r3, #4
3000ae3c:	e5933000 	ldr	r3, [r3]
3000ae40:	e58d305c 	str	r3, [sp, #92]	; 0x5c
					*ip = (str - buf);
3000ae44:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000ae48:	e59d301c 	ldr	r3, [sp, #28]
3000ae4c:	e0632002 	rsb	r2, r3, r2
3000ae50:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
3000ae54:	e5832000 	str	r2, [r3]
					*ip = (str - buf);
				} else {
					acoral_32 * ip = va_arg(args, acoral_32 *);
					*ip = (str - buf);
				}
				continue;
3000ae58:	ea0000c1 	b	3000b164 <vsnprintf+0xabc>
				/* FIXME:
				* What does C99 say about the overflow case here? */
				if (qualifier == 'l') {
					acoral_32 * ip = va_arg(args, acoral_32 *);
					*ip = (str - buf);
				} else if (qualifier == 'Z') {
3000ae5c:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000ae60:	e353005a 	cmp	r3, #90	; 0x5a
3000ae64:	1a00000d 	bne	3000aea0 <vsnprintf+0x7f8>
					acoral_u32 * ip = va_arg(args, acoral_u32 *);
3000ae68:	e59d3010 	ldr	r3, [sp, #16]
3000ae6c:	e2833004 	add	r3, r3, #4
3000ae70:	e58d3010 	str	r3, [sp, #16]
3000ae74:	e59d3010 	ldr	r3, [sp, #16]
3000ae78:	e2433004 	sub	r3, r3, #4
3000ae7c:	e5933000 	ldr	r3, [r3]
3000ae80:	e58d3060 	str	r3, [sp, #96]	; 0x60
					*ip = (str - buf);
3000ae84:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000ae88:	e59d301c 	ldr	r3, [sp, #28]
3000ae8c:	e0633002 	rsb	r3, r3, r2
3000ae90:	e1a02003 	mov	r2, r3
3000ae94:	e59d3060 	ldr	r3, [sp, #96]	; 0x60
3000ae98:	e5832000 	str	r2, [r3]
				} else {
					acoral_32 * ip = va_arg(args, acoral_32 *);
					*ip = (str - buf);
				}
				continue;
3000ae9c:	ea0000b0 	b	3000b164 <vsnprintf+0xabc>
					*ip = (str - buf);
				} else if (qualifier == 'Z') {
					acoral_u32 * ip = va_arg(args, acoral_u32 *);
					*ip = (str - buf);
				} else {
					acoral_32 * ip = va_arg(args, acoral_32 *);
3000aea0:	e59d3010 	ldr	r3, [sp, #16]
3000aea4:	e2833004 	add	r3, r3, #4
3000aea8:	e58d3010 	str	r3, [sp, #16]
3000aeac:	e59d3010 	ldr	r3, [sp, #16]
3000aeb0:	e2433004 	sub	r3, r3, #4
3000aeb4:	e5933000 	ldr	r3, [r3]
3000aeb8:	e58d3064 	str	r3, [sp, #100]	; 0x64
					*ip = (str - buf);
3000aebc:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000aec0:	e59d301c 	ldr	r3, [sp, #28]
3000aec4:	e0632002 	rsb	r2, r3, r2
3000aec8:	e59d3064 	ldr	r3, [sp, #100]	; 0x64
3000aecc:	e5832000 	str	r2, [r3]
				}
				continue;
3000aed0:	ea0000a3 	b	3000b164 <vsnprintf+0xabc>

			case '%':
				if (str <= end)
3000aed4:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000aed8:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000aedc:	e1520003 	cmp	r2, r3
3000aee0:	8a000002 	bhi	3000aef0 <vsnprintf+0x848>
					*str = '%';
3000aee4:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000aee8:	e3a02025 	mov	r2, #37	; 0x25
3000aeec:	e5c32000 	strb	r2, [r3]
				++str;
3000aef0:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000aef4:	e2833001 	add	r3, r3, #1
3000aef8:	e58d303c 	str	r3, [sp, #60]	; 0x3c
				continue;
3000aefc:	ea000098 	b	3000b164 <vsnprintf+0xabc>

				/* acoral_32eger number formats - set up the flags and "break" */
			case 'o':
				base = 8;
3000af00:	e3a03008 	mov	r3, #8
3000af04:	e58d3038 	str	r3, [sp, #56]	; 0x38
				break;
3000af08:	ea000028 	b	3000afb0 <vsnprintf+0x908>

			case 'X':
				flags |= LARGE;
3000af0c:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000af10:	e3833040 	orr	r3, r3, #64	; 0x40
3000af14:	e58d304c 	str	r3, [sp, #76]	; 0x4c
			case 'x':
				base = 16;
3000af18:	e3a03010 	mov	r3, #16
3000af1c:	e58d3038 	str	r3, [sp, #56]	; 0x38
				break;
3000af20:	ea000022 	b	3000afb0 <vsnprintf+0x908>

			case 'd':
			case 'i':
				flags |= SIGN;
3000af24:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000af28:	e3833002 	orr	r3, r3, #2
3000af2c:	e58d304c 	str	r3, [sp, #76]	; 0x4c
			case 'u':
				break;
3000af30:	ea00001e 	b	3000afb0 <vsnprintf+0x908>

			default:
				if (str <= end)
3000af34:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000af38:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000af3c:	e1520003 	cmp	r2, r3
3000af40:	8a000002 	bhi	3000af50 <vsnprintf+0x8a8>
					*str = '%';
3000af44:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000af48:	e3a02025 	mov	r2, #37	; 0x25
3000af4c:	e5c32000 	strb	r2, [r3]
				++str;
3000af50:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000af54:	e2833001 	add	r3, r3, #1
3000af58:	e58d303c 	str	r3, [sp, #60]	; 0x3c
				if (*fmt) {
3000af5c:	e59d3014 	ldr	r3, [sp, #20]
3000af60:	e5d33000 	ldrb	r3, [r3]
3000af64:	e3530000 	cmp	r3, #0
3000af68:	0a00000b 	beq	3000af9c <vsnprintf+0x8f4>
					if (str <= end)
3000af6c:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000af70:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000af74:	e1520003 	cmp	r2, r3
3000af78:	8a000003 	bhi	3000af8c <vsnprintf+0x8e4>
						*str = *fmt;
3000af7c:	e59d3014 	ldr	r3, [sp, #20]
3000af80:	e5d32000 	ldrb	r2, [r3]
3000af84:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000af88:	e5c32000 	strb	r2, [r3]
					++str;
3000af8c:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000af90:	e2833001 	add	r3, r3, #1
3000af94:	e58d303c 	str	r3, [sp, #60]	; 0x3c
				} else {
					--fmt;
				}
				continue;
3000af98:	ea000071 	b	3000b164 <vsnprintf+0xabc>
				if (*fmt) {
					if (str <= end)
						*str = *fmt;
					++str;
				} else {
					--fmt;
3000af9c:	e59d3014 	ldr	r3, [sp, #20]
3000afa0:	e2433001 	sub	r3, r3, #1
3000afa4:	e58d3014 	str	r3, [sp, #20]
				}
				continue;
3000afa8:	ea00006d 	b	3000b164 <vsnprintf+0xabc>

			case 'd':
			case 'i':
				flags |= SIGN;
			case 'u':
				break;
3000afac:	e1a00000 	nop			; (mov r0, r0)
				} else {
					--fmt;
				}
				continue;
		}
		if (qualifier == 'L')
3000afb0:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000afb4:	e353004c 	cmp	r3, #76	; 0x4c
3000afb8:	1a000008 	bne	3000afe0 <vsnprintf+0x938>
			num = va_arg(args, acoral_64);
3000afbc:	e59d3010 	ldr	r3, [sp, #16]
3000afc0:	e2833008 	add	r3, r3, #8
3000afc4:	e58d3010 	str	r3, [sp, #16]
3000afc8:	e59d3010 	ldr	r3, [sp, #16]
3000afcc:	e2433008 	sub	r3, r3, #8
3000afd0:	e8930018 	ldm	r3, {r3, r4}
3000afd4:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000afd8:	e58d402c 	str	r4, [sp, #44]	; 0x2c
3000afdc:	ea00004f 	b	3000b120 <vsnprintf+0xa78>
		else if (qualifier == 'l') {
3000afe0:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000afe4:	e353006c 	cmp	r3, #108	; 0x6c
3000afe8:	1a000011 	bne	3000b034 <vsnprintf+0x98c>
			num = va_arg(args, acoral_u32);
3000afec:	e59d3010 	ldr	r3, [sp, #16]
3000aff0:	e2833004 	add	r3, r3, #4
3000aff4:	e58d3010 	str	r3, [sp, #16]
3000aff8:	e59d3010 	ldr	r3, [sp, #16]
3000affc:	e2433004 	sub	r3, r3, #4
3000b000:	e5933000 	ldr	r3, [r3]
3000b004:	e3a04000 	mov	r4, #0
3000b008:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000b00c:	e58d402c 	str	r4, [sp, #44]	; 0x2c
			if (flags & SIGN)
3000b010:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000b014:	e2033002 	and	r3, r3, #2
3000b018:	e3530000 	cmp	r3, #0
3000b01c:	0a00003c 	beq	3000b114 <vsnprintf+0xa6c>
				num = (acoral_32) num;
3000b020:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000b024:	e1a04fc3 	asr	r4, r3, #31
3000b028:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000b02c:	e58d402c 	str	r4, [sp, #44]	; 0x2c
3000b030:	ea00003a 	b	3000b120 <vsnprintf+0xa78>
		} else if (qualifier == 'Z') {
3000b034:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000b038:	e353005a 	cmp	r3, #90	; 0x5a
3000b03c:	1a000009 	bne	3000b068 <vsnprintf+0x9c0>
			num = va_arg(args, acoral_u32);
3000b040:	e59d3010 	ldr	r3, [sp, #16]
3000b044:	e2833004 	add	r3, r3, #4
3000b048:	e58d3010 	str	r3, [sp, #16]
3000b04c:	e59d3010 	ldr	r3, [sp, #16]
3000b050:	e2433004 	sub	r3, r3, #4
3000b054:	e5933000 	ldr	r3, [r3]
3000b058:	e3a04000 	mov	r4, #0
3000b05c:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000b060:	e58d402c 	str	r4, [sp, #44]	; 0x2c
3000b064:	ea00002d 	b	3000b120 <vsnprintf+0xa78>
		} else if (qualifier == 'h') {
3000b068:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3000b06c:	e3530068 	cmp	r3, #104	; 0x68
3000b070:	1a000015 	bne	3000b0cc <vsnprintf+0xa24>
			num = (acoral_u16) va_arg(args, acoral_32);
3000b074:	e59d3010 	ldr	r3, [sp, #16]
3000b078:	e2833004 	add	r3, r3, #4
3000b07c:	e58d3010 	str	r3, [sp, #16]
3000b080:	e59d3010 	ldr	r3, [sp, #16]
3000b084:	e2433004 	sub	r3, r3, #4
3000b088:	e5933000 	ldr	r3, [r3]
3000b08c:	e1a03803 	lsl	r3, r3, #16
3000b090:	e1a03823 	lsr	r3, r3, #16
3000b094:	e3a04000 	mov	r4, #0
3000b098:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000b09c:	e58d402c 	str	r4, [sp, #44]	; 0x2c
			if (flags & SIGN)
3000b0a0:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000b0a4:	e2033002 	and	r3, r3, #2
3000b0a8:	e3530000 	cmp	r3, #0
3000b0ac:	0a00001a 	beq	3000b11c <vsnprintf+0xa74>
				num = (acoral_16) num;
3000b0b0:	e1dd32b8 	ldrh	r3, [sp, #40]	; 0x28
3000b0b4:	e1a03803 	lsl	r3, r3, #16
3000b0b8:	e1a03843 	asr	r3, r3, #16
3000b0bc:	e1a04fc3 	asr	r4, r3, #31
3000b0c0:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000b0c4:	e58d402c 	str	r4, [sp, #44]	; 0x2c
3000b0c8:	ea000014 	b	3000b120 <vsnprintf+0xa78>
		} else {
			num = va_arg(args, acoral_u32);
3000b0cc:	e59d3010 	ldr	r3, [sp, #16]
3000b0d0:	e2833004 	add	r3, r3, #4
3000b0d4:	e58d3010 	str	r3, [sp, #16]
3000b0d8:	e59d3010 	ldr	r3, [sp, #16]
3000b0dc:	e2433004 	sub	r3, r3, #4
3000b0e0:	e5933000 	ldr	r3, [r3]
3000b0e4:	e3a04000 	mov	r4, #0
3000b0e8:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000b0ec:	e58d402c 	str	r4, [sp, #44]	; 0x2c
			if (flags & SIGN)
3000b0f0:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3000b0f4:	e2033002 	and	r3, r3, #2
3000b0f8:	e3530000 	cmp	r3, #0
3000b0fc:	0a000007 	beq	3000b120 <vsnprintf+0xa78>
				num = (acoral_32) num;
3000b100:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000b104:	e1a04fc3 	asr	r4, r3, #31
3000b108:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000b10c:	e58d402c 	str	r4, [sp, #44]	; 0x2c
3000b110:	ea000002 	b	3000b120 <vsnprintf+0xa78>
		if (qualifier == 'L')
			num = va_arg(args, acoral_64);
		else if (qualifier == 'l') {
			num = va_arg(args, acoral_u32);
			if (flags & SIGN)
				num = (acoral_32) num;
3000b114:	e1a00000 	nop			; (mov r0, r0)
3000b118:	ea000000 	b	3000b120 <vsnprintf+0xa78>
		} else if (qualifier == 'Z') {
			num = va_arg(args, acoral_u32);
		} else if (qualifier == 'h') {
			num = (acoral_u16) va_arg(args, acoral_32);
			if (flags & SIGN)
				num = (acoral_16) num;
3000b11c:	e1a00000 	nop			; (mov r0, r0)
		} else {
			num = va_arg(args, acoral_u32);
			if (flags & SIGN)
				num = (acoral_32) num;
		}
		str = number(str, end, num, base,
3000b120:	e28d4028 	add	r4, sp, #40	; 0x28
3000b124:	e8940018 	ldm	r4, {r3, r4}
3000b128:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
3000b12c:	e58d2000 	str	r2, [sp]
3000b130:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
3000b134:	e58d2004 	str	r2, [sp, #4]
3000b138:	e59d2054 	ldr	r2, [sp, #84]	; 0x54
3000b13c:	e58d2008 	str	r2, [sp, #8]
3000b140:	e59d204c 	ldr	r2, [sp, #76]	; 0x4c
3000b144:	e58d200c 	str	r2, [sp, #12]
3000b148:	e59d003c 	ldr	r0, [sp, #60]	; 0x3c
3000b14c:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
3000b150:	e1a02003 	mov	r2, r3
3000b154:	e1a03004 	mov	r3, r4
3000b158:	ebfffc0c 	bl	3000a190 <number>
3000b15c:	e1a03000 	mov	r3, r0
3000b160:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	if (end < buf - 1) {
		end = ((void *) -1);
		size = end - buf + 1;
	}

	for (; *fmt ; ++fmt) {
3000b164:	e59d3014 	ldr	r3, [sp, #20]
3000b168:	e2833001 	add	r3, r3, #1
3000b16c:	e58d3014 	str	r3, [sp, #20]
3000b170:	ea000000 	b	3000b178 <vsnprintf+0xad0>
3000b174:	e1a00000 	nop			; (mov r0, r0)
3000b178:	e59d3014 	ldr	r3, [sp, #20]
3000b17c:	e5d33000 	ldrb	r3, [r3]
3000b180:	e3530000 	cmp	r3, #0
3000b184:	1afffd61 	bne	3000a710 <vsnprintf+0x68>
				num = (acoral_32) num;
		}
		str = number(str, end, num, base,
				field_width, precision, flags);
	}
	if (str <= end)
3000b188:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000b18c:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000b190:	e1520003 	cmp	r2, r3
3000b194:	8a000003 	bhi	3000b1a8 <vsnprintf+0xb00>
		*str = '\0';
3000b198:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3000b19c:	e3a02000 	mov	r2, #0
3000b1a0:	e5c32000 	strb	r2, [r3]
3000b1a4:	ea000005 	b	3000b1c0 <vsnprintf+0xb18>
	else if (size > 0)
3000b1a8:	e59d3018 	ldr	r3, [sp, #24]
3000b1ac:	e3530000 	cmp	r3, #0
3000b1b0:	0a000002 	beq	3000b1c0 <vsnprintf+0xb18>
		/* don't write out a null byte if the buf size is zero */
		*end = '\0';
3000b1b4:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3000b1b8:	e3a02000 	mov	r2, #0
3000b1bc:	e5c32000 	strb	r2, [r3]
	/* the trailing null byte doesn't count towards the total
	* ++str;
	*/
	return str-buf;
3000b1c0:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3000b1c4:	e59d301c 	ldr	r3, [sp, #28]
3000b1c8:	e0633002 	rsb	r3, r3, r2
}
3000b1cc:	e1a00003 	mov	r0, r3
3000b1d0:	e28dd068 	add	sp, sp, #104	; 0x68
3000b1d4:	e8bd4010 	pop	{r4, lr}
3000b1d8:	e12fff1e 	bx	lr
3000b1dc:	30045670 	.word	0x30045670

3000b1e0 <acoral_sprint>:

acoral_32 acoral_sprint(acoral_char * buf, acoral_u32 size, const acoral_char *fmt, ...)
{
3000b1e0:	e92d000c 	push	{r2, r3}
3000b1e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b1e8:	e24dd014 	sub	sp, sp, #20
3000b1ec:	e58d0004 	str	r0, [sp, #4]
3000b1f0:	e58d1000 	str	r1, [sp]
	acoral_32 i;
	va_list args;
	va_start(args, fmt);
3000b1f4:	e28d3018 	add	r3, sp, #24
3000b1f8:	e2833004 	add	r3, r3, #4
3000b1fc:	e58d300c 	str	r3, [sp, #12]
	i=vsnprintf(buf,size,fmt,args);
3000b200:	e59d3018 	ldr	r3, [sp, #24]
3000b204:	e59d0004 	ldr	r0, [sp, #4]
3000b208:	e59d1000 	ldr	r1, [sp]
3000b20c:	e1a02003 	mov	r2, r3
3000b210:	e59d300c 	ldr	r3, [sp, #12]
3000b214:	ebfffd23 	bl	3000a6a8 <vsnprintf>
3000b218:	e1a03000 	mov	r3, r0
3000b21c:	e58d3008 	str	r3, [sp, #8]
	va_end(args);
3000b220:	e3a03000 	mov	r3, #0
3000b224:	e58d300c 	str	r3, [sp, #12]
	return i;
3000b228:	e59d3008 	ldr	r3, [sp, #8]
}
3000b22c:	e1a00003 	mov	r0, r3
3000b230:	e28dd014 	add	sp, sp, #20
3000b234:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000b238:	e28dd008 	add	sp, sp, #8
3000b23c:	e12fff1e 	bx	lr

3000b240 <acoral_print>:

acoral_32 acoral_print(const acoral_char *fmt, ...)
{
3000b240:	e92d000f 	push	{r0, r1, r2, r3}
3000b244:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b248:	e24dd014 	sub	sp, sp, #20
	va_list args;
	acoral_32 printed_len;
	static acoral_char print_buf[256];
	va_start(args, fmt);
3000b24c:	e28d3018 	add	r3, sp, #24
3000b250:	e2833004 	add	r3, r3, #4
3000b254:	e58d3008 	str	r3, [sp, #8]
	printed_len =vsnprintf(print_buf, sizeof(print_buf), fmt, args);
3000b258:	e59d3018 	ldr	r3, [sp, #24]
3000b25c:	e59f0060 	ldr	r0, [pc, #96]	; 3000b2c4 <acoral_print+0x84>
3000b260:	e3a01c01 	mov	r1, #256	; 0x100
3000b264:	e1a02003 	mov	r2, r3
3000b268:	e59d3008 	ldr	r3, [sp, #8]
3000b26c:	ebfffd0d 	bl	3000a6a8 <vsnprintf>
3000b270:	e1a03000 	mov	r3, r0
3000b274:	e58d300c 	str	r3, [sp, #12]
	va_end(args);
3000b278:	e3a03000 	mov	r3, #0
3000b27c:	e58d3008 	str	r3, [sp, #8]
	return acoral_dev_write(acoral_cur_thread->console_id,(void *)print_buf,printed_len,0,0);
3000b280:	e59f3040 	ldr	r3, [pc, #64]	; 3000b2c8 <acoral_print+0x88>
3000b284:	e5933000 	ldr	r3, [r3]
3000b288:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
3000b28c:	e59d300c 	ldr	r3, [sp, #12]
3000b290:	e3a01000 	mov	r1, #0
3000b294:	e58d1000 	str	r1, [sp]
3000b298:	e1a00002 	mov	r0, r2
3000b29c:	e59f1020 	ldr	r1, [pc, #32]	; 3000b2c4 <acoral_print+0x84>
3000b2a0:	e1a02003 	mov	r2, r3
3000b2a4:	e3a03000 	mov	r3, #0
3000b2a8:	eb00d4f2 	bl	30040678 <acoral_dev_write>
3000b2ac:	e1a03000 	mov	r3, r0
}
3000b2b0:	e1a00003 	mov	r0, r3
3000b2b4:	e28dd014 	add	sp, sp, #20
3000b2b8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000b2bc:	e28dd010 	add	sp, sp, #16
3000b2c0:	e12fff1e 	bx	lr
3000b2c4:	300ca4dc 	.word	0x300ca4dc
3000b2c8:	302be818 	.word	0x302be818

3000b2cc <acoral_prints>:

acoral_32 acoral_prints(const acoral_char *str)
{
3000b2cc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b2d0:	e24dd01c 	sub	sp, sp, #28
3000b2d4:	e58d000c 	str	r0, [sp, #12]
	acoral_32 printed_len;
	printed_len=acoral_str_len(str);  
3000b2d8:	e59d000c 	ldr	r0, [sp, #12]
3000b2dc:	eb000115 	bl	3000b738 <acoral_str_len>
3000b2e0:	e1a03000 	mov	r3, r0
3000b2e4:	e58d3014 	str	r3, [sp, #20]
	return acoral_dev_write(acoral_cur_thread->console_id,(void *)str,printed_len,0,0);
3000b2e8:	e59f3038 	ldr	r3, [pc, #56]	; 3000b328 <acoral_prints+0x5c>
3000b2ec:	e5933000 	ldr	r3, [r3]
3000b2f0:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
3000b2f4:	e59d3014 	ldr	r3, [sp, #20]
3000b2f8:	e3a01000 	mov	r1, #0
3000b2fc:	e58d1000 	str	r1, [sp]
3000b300:	e1a00002 	mov	r0, r2
3000b304:	e59d100c 	ldr	r1, [sp, #12]
3000b308:	e1a02003 	mov	r2, r3
3000b30c:	e3a03000 	mov	r3, #0
3000b310:	eb00d4d8 	bl	30040678 <acoral_dev_write>
3000b314:	e1a03000 	mov	r3, r0
}
3000b318:	e1a00003 	mov	r0, r3
3000b31c:	e28dd01c 	add	sp, sp, #28
3000b320:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000b324:	e12fff1e 	bx	lr
3000b328:	302be818 	.word	0x302be818

3000b32c <acoral_getchar>:

acoral_char acoral_getchar(){
3000b32c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b330:	e24dd014 	sub	sp, sp, #20
	acoral_char c;
	acoral_dev_read(acoral_cur_thread->console_id,&c,1,0,0);
3000b334:	e59f3038 	ldr	r3, [pc, #56]	; 3000b374 <acoral_getchar+0x48>
3000b338:	e5933000 	ldr	r3, [r3]
3000b33c:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
3000b340:	e28d300f 	add	r3, sp, #15
3000b344:	e3a01000 	mov	r1, #0
3000b348:	e58d1000 	str	r1, [sp]
3000b34c:	e1a00002 	mov	r0, r2
3000b350:	e1a01003 	mov	r1, r3
3000b354:	e3a02001 	mov	r2, #1
3000b358:	e3a03000 	mov	r3, #0
3000b35c:	eb00d4eb 	bl	30040710 <acoral_dev_read>
	return c;
3000b360:	e5dd300f 	ldrb	r3, [sp, #15]
}
3000b364:	e1a00003 	mov	r0, r3
3000b368:	e28dd014 	add	sp, sp, #20
3000b36c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000b370:	e12fff1e 	bx	lr
3000b374:	302be818 	.word	0x302be818

3000b378 <acoral_putchar>:

acoral_char acoral_putchar(acoral_char c){
3000b378:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b37c:	e24dd014 	sub	sp, sp, #20
3000b380:	e1a03000 	mov	r3, r0
3000b384:	e5cd300f 	strb	r3, [sp, #15]
	acoral_dev_write(acoral_cur_thread->console_id,&c,1,0,0);
3000b388:	e59f3038 	ldr	r3, [pc, #56]	; 3000b3c8 <acoral_putchar+0x50>
3000b38c:	e5933000 	ldr	r3, [r3]
3000b390:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
3000b394:	e28d300f 	add	r3, sp, #15
3000b398:	e3a01000 	mov	r1, #0
3000b39c:	e58d1000 	str	r1, [sp]
3000b3a0:	e1a00002 	mov	r0, r2
3000b3a4:	e1a01003 	mov	r1, r3
3000b3a8:	e3a02001 	mov	r2, #1
3000b3ac:	e3a03000 	mov	r3, #0
3000b3b0:	eb00d4b0 	bl	30040678 <acoral_dev_write>
	return c;
3000b3b4:	e5dd300f 	ldrb	r3, [sp, #15]
}
3000b3b8:	e1a00003 	mov	r0, r3
3000b3bc:	e28dd014 	add	sp, sp, #20
3000b3c0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000b3c4:	e12fff1e 	bx	lr
3000b3c8:	302be818 	.word	0x302be818

3000b3cc <acoral_debug>:

static acoral_id console_id=ACORAL_DEV_ERR_ID;
//======================
acoral_32 acoral_debug(const acoral_char *fmt, ...)
{
3000b3cc:	e92d000f 	push	{r0, r1, r2, r3}
3000b3d0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b3d4:	e24dd014 	sub	sp, sp, #20
	va_list args;
	acoral_32 printed_len;
	static acoral_char print_buf[1024];
	va_start(args, fmt);
3000b3d8:	e28d3018 	add	r3, sp, #24
3000b3dc:	e2833004 	add	r3, r3, #4
3000b3e0:	e58d3008 	str	r3, [sp, #8]
	printed_len =vsnprintf(print_buf, sizeof(print_buf), fmt, args);
3000b3e4:	e59d3018 	ldr	r3, [sp, #24]
3000b3e8:	e59f0094 	ldr	r0, [pc, #148]	; 3000b484 <acoral_debug+0xb8>
3000b3ec:	e3a01b01 	mov	r1, #1024	; 0x400
3000b3f0:	e1a02003 	mov	r2, r3
3000b3f4:	e59d3008 	ldr	r3, [sp, #8]
3000b3f8:	ebfffcaa 	bl	3000a6a8 <vsnprintf>
3000b3fc:	e1a03000 	mov	r3, r0
3000b400:	e58d300c 	str	r3, [sp, #12]
	va_end(args);
3000b404:	e3a03000 	mov	r3, #0
3000b408:	e58d3008 	str	r3, [sp, #8]
	if(console_id==ACORAL_DEV_ERR_ID){
3000b40c:	e59f3074 	ldr	r3, [pc, #116]	; 3000b488 <acoral_debug+0xbc>
3000b410:	e5933000 	ldr	r3, [r3]
3000b414:	e3730001 	cmn	r3, #1
3000b418:	1a000009 	bne	3000b444 <acoral_debug+0x78>
		console_id=acoral_dev_open("console");
3000b41c:	e59f0068 	ldr	r0, [pc, #104]	; 3000b48c <acoral_debug+0xc0>
3000b420:	eb00d46f 	bl	300405e4 <acoral_dev_open>
3000b424:	e1a02000 	mov	r2, r0
3000b428:	e59f3058 	ldr	r3, [pc, #88]	; 3000b488 <acoral_debug+0xbc>
3000b42c:	e5832000 	str	r2, [r3]
		if(console_id==ACORAL_DEV_ERR_ID)
3000b430:	e59f3050 	ldr	r3, [pc, #80]	; 3000b488 <acoral_debug+0xbc>
3000b434:	e5933000 	ldr	r3, [r3]
3000b438:	e3730001 	cmn	r3, #1
3000b43c:	1a000000 	bne	3000b444 <acoral_debug+0x78>
3000b440:	ea00000a 	b	3000b470 <acoral_debug+0xa4>
			return;
	}
	return acoral_dev_write(console_id,(void *)print_buf,printed_len,0,0);
3000b444:	e59f303c 	ldr	r3, [pc, #60]	; 3000b488 <acoral_debug+0xbc>
3000b448:	e5932000 	ldr	r2, [r3]
3000b44c:	e59d300c 	ldr	r3, [sp, #12]
3000b450:	e3a01000 	mov	r1, #0
3000b454:	e58d1000 	str	r1, [sp]
3000b458:	e1a00002 	mov	r0, r2
3000b45c:	e59f1020 	ldr	r1, [pc, #32]	; 3000b484 <acoral_debug+0xb8>
3000b460:	e1a02003 	mov	r2, r3
3000b464:	e3a03000 	mov	r3, #0
3000b468:	eb00d482 	bl	30040678 <acoral_dev_write>
3000b46c:	e1a03000 	mov	r3, r0
}
3000b470:	e1a00003 	mov	r0, r3
3000b474:	e28dd014 	add	sp, sp, #20
3000b478:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000b47c:	e28dd010 	add	sp, sp, #16
3000b480:	e12fff1e 	bx	lr
3000b484:	300ca0dc 	.word	0x300ca0dc
3000b488:	300466bc 	.word	0x300466bc
3000b48c:	30045678 	.word	0x30045678

3000b490 <acoral_debugs>:

acoral_32 acoral_debugs(const acoral_char *str)
{
3000b490:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b494:	e24dd01c 	sub	sp, sp, #28
3000b498:	e58d000c 	str	r0, [sp, #12]
	acoral_32 printed_len;
	printed_len=acoral_str_len(str);  
3000b49c:	e59d000c 	ldr	r0, [sp, #12]
3000b4a0:	eb0000a4 	bl	3000b738 <acoral_str_len>
3000b4a4:	e1a03000 	mov	r3, r0
3000b4a8:	e58d3014 	str	r3, [sp, #20]
	if(console_id==ACORAL_DEV_ERR_ID){
3000b4ac:	e59f306c 	ldr	r3, [pc, #108]	; 3000b520 <acoral_debugs+0x90>
3000b4b0:	e5933000 	ldr	r3, [r3]
3000b4b4:	e3730001 	cmn	r3, #1
3000b4b8:	1a000009 	bne	3000b4e4 <acoral_debugs+0x54>
		console_id=acoral_dev_open("console");
3000b4bc:	e59f0060 	ldr	r0, [pc, #96]	; 3000b524 <acoral_debugs+0x94>
3000b4c0:	eb00d447 	bl	300405e4 <acoral_dev_open>
3000b4c4:	e1a02000 	mov	r2, r0
3000b4c8:	e59f3050 	ldr	r3, [pc, #80]	; 3000b520 <acoral_debugs+0x90>
3000b4cc:	e5832000 	str	r2, [r3]
		if(console_id==ACORAL_DEV_ERR_ID)
3000b4d0:	e59f3048 	ldr	r3, [pc, #72]	; 3000b520 <acoral_debugs+0x90>
3000b4d4:	e5933000 	ldr	r3, [r3]
3000b4d8:	e3730001 	cmn	r3, #1
3000b4dc:	1a000000 	bne	3000b4e4 <acoral_debugs+0x54>
3000b4e0:	ea00000a 	b	3000b510 <acoral_debugs+0x80>
			return;
	}
	return acoral_dev_write(console_id,(void *)str,printed_len,0,0);
3000b4e4:	e59f3034 	ldr	r3, [pc, #52]	; 3000b520 <acoral_debugs+0x90>
3000b4e8:	e5932000 	ldr	r2, [r3]
3000b4ec:	e59d3014 	ldr	r3, [sp, #20]
3000b4f0:	e3a01000 	mov	r1, #0
3000b4f4:	e58d1000 	str	r1, [sp]
3000b4f8:	e1a00002 	mov	r0, r2
3000b4fc:	e59d100c 	ldr	r1, [sp, #12]
3000b500:	e1a02003 	mov	r2, r3
3000b504:	e3a03000 	mov	r3, #0
3000b508:	eb00d45a 	bl	30040678 <acoral_dev_write>
3000b50c:	e1a03000 	mov	r3, r0
}
3000b510:	e1a00003 	mov	r0, r3
3000b514:	e28dd01c 	add	sp, sp, #28
3000b518:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000b51c:	e12fff1e 	bx	lr
3000b520:	300466bc 	.word	0x300466bc
3000b524:	30045678 	.word	0x30045678

3000b528 <acoral_tolower>:
#include<string.h>

acoral_u8  acoral_tolower(acoral_u8 c){
3000b528:	e24dd008 	sub	sp, sp, #8
3000b52c:	e1a03000 	mov	r3, r0
3000b530:	e5cd3007 	strb	r3, [sp, #7]
      if(IS_LOWER(c))
3000b534:	e5dd3007 	ldrb	r3, [sp, #7]
3000b538:	e3530060 	cmp	r3, #96	; 0x60
3000b53c:	9a000004 	bls	3000b554 <acoral_tolower+0x2c>
3000b540:	e5dd3007 	ldrb	r3, [sp, #7]
3000b544:	e353007a 	cmp	r3, #122	; 0x7a
3000b548:	8a000001 	bhi	3000b554 <acoral_tolower+0x2c>
        return c;
3000b54c:	e5dd3007 	ldrb	r3, [sp, #7]
3000b550:	ea00000a 	b	3000b580 <acoral_tolower+0x58>
      else if(IS_UPPER(c))
3000b554:	e5dd3007 	ldrb	r3, [sp, #7]
3000b558:	e3530040 	cmp	r3, #64	; 0x40
3000b55c:	9a000006 	bls	3000b57c <acoral_tolower+0x54>
3000b560:	e5dd3007 	ldrb	r3, [sp, #7]
3000b564:	e353005a 	cmp	r3, #90	; 0x5a
3000b568:	8a000003 	bhi	3000b57c <acoral_tolower+0x54>
        return (acoral_u8)(c+32);
3000b56c:	e5dd3007 	ldrb	r3, [sp, #7]
3000b570:	e2833020 	add	r3, r3, #32
3000b574:	e20330ff 	and	r3, r3, #255	; 0xff
3000b578:	ea000000 	b	3000b580 <acoral_tolower+0x58>
      else
        return FALSE; 
3000b57c:	e3a03000 	mov	r3, #0
            
}
3000b580:	e1a00003 	mov	r0, r3
3000b584:	e28dd008 	add	sp, sp, #8
3000b588:	e12fff1e 	bx	lr

3000b58c <acoral_toupper>:
acoral_u8  acoral_toupper(acoral_u8 c){
3000b58c:	e24dd008 	sub	sp, sp, #8
3000b590:	e1a03000 	mov	r3, r0
3000b594:	e5cd3007 	strb	r3, [sp, #7]
     if(IS_LOWER(c))
3000b598:	e5dd3007 	ldrb	r3, [sp, #7]
3000b59c:	e3530060 	cmp	r3, #96	; 0x60
3000b5a0:	9a000006 	bls	3000b5c0 <acoral_toupper+0x34>
3000b5a4:	e5dd3007 	ldrb	r3, [sp, #7]
3000b5a8:	e353007a 	cmp	r3, #122	; 0x7a
3000b5ac:	8a000003 	bhi	3000b5c0 <acoral_toupper+0x34>
        return (acoral_u8)(c-32);
3000b5b0:	e5dd3007 	ldrb	r3, [sp, #7]
3000b5b4:	e2433020 	sub	r3, r3, #32
3000b5b8:	e20330ff 	and	r3, r3, #255	; 0xff
3000b5bc:	ea000008 	b	3000b5e4 <acoral_toupper+0x58>
     else if(IS_UPPER(c))
3000b5c0:	e5dd3007 	ldrb	r3, [sp, #7]
3000b5c4:	e3530040 	cmp	r3, #64	; 0x40
3000b5c8:	9a000004 	bls	3000b5e0 <acoral_toupper+0x54>
3000b5cc:	e5dd3007 	ldrb	r3, [sp, #7]
3000b5d0:	e353005a 	cmp	r3, #90	; 0x5a
3000b5d4:	8a000001 	bhi	3000b5e0 <acoral_toupper+0x54>
        return c;
3000b5d8:	e5dd3007 	ldrb	r3, [sp, #7]
3000b5dc:	ea000000 	b	3000b5e4 <acoral_toupper+0x58>
     else
        return FALSE; 
3000b5e0:	e3a03000 	mov	r3, #0
}
3000b5e4:	e1a00003 	mov	r0, r3
3000b5e8:	e28dd008 	add	sp, sp, #8
3000b5ec:	e12fff1e 	bx	lr

3000b5f0 <acoral_str_upr>:

acoral_char *acoral_str_upr(acoral_char *str){
3000b5f0:	e24dd010 	sub	sp, sp, #16
3000b5f4:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 i=0;
3000b5f8:	e3a03000 	mov	r3, #0
3000b5fc:	e58d3008 	str	r3, [sp, #8]
	acoral_char *s=str;
3000b600:	e59d3004 	ldr	r3, [sp, #4]
3000b604:	e58d300c 	str	r3, [sp, #12]
	while(s[i]!='\0'){
3000b608:	ea000018 	b	3000b670 <acoral_str_upr+0x80>
		if(s[i]>='a'&&s[i]<='z')
3000b60c:	e59d200c 	ldr	r2, [sp, #12]
3000b610:	e59d3008 	ldr	r3, [sp, #8]
3000b614:	e0823003 	add	r3, r2, r3
3000b618:	e5d33000 	ldrb	r3, [r3]
3000b61c:	e3530060 	cmp	r3, #96	; 0x60
3000b620:	9a00000f 	bls	3000b664 <acoral_str_upr+0x74>
3000b624:	e59d200c 	ldr	r2, [sp, #12]
3000b628:	e59d3008 	ldr	r3, [sp, #8]
3000b62c:	e0823003 	add	r3, r2, r3
3000b630:	e5d33000 	ldrb	r3, [r3]
3000b634:	e353007a 	cmp	r3, #122	; 0x7a
3000b638:	8a000009 	bhi	3000b664 <acoral_str_upr+0x74>
			s[i]-=32;
3000b63c:	e59d200c 	ldr	r2, [sp, #12]
3000b640:	e59d3008 	ldr	r3, [sp, #8]
3000b644:	e0823003 	add	r3, r2, r3
3000b648:	e59d100c 	ldr	r1, [sp, #12]
3000b64c:	e59d2008 	ldr	r2, [sp, #8]
3000b650:	e0812002 	add	r2, r1, r2
3000b654:	e5d22000 	ldrb	r2, [r2]
3000b658:	e2422020 	sub	r2, r2, #32
3000b65c:	e20220ff 	and	r2, r2, #255	; 0xff
3000b660:	e5c32000 	strb	r2, [r3]
		i++;
3000b664:	e59d3008 	ldr	r3, [sp, #8]
3000b668:	e2833001 	add	r3, r3, #1
3000b66c:	e58d3008 	str	r3, [sp, #8]
}

acoral_char *acoral_str_upr(acoral_char *str){
	acoral_u32 i=0;
	acoral_char *s=str;
	while(s[i]!='\0'){
3000b670:	e59d200c 	ldr	r2, [sp, #12]
3000b674:	e59d3008 	ldr	r3, [sp, #8]
3000b678:	e0823003 	add	r3, r2, r3
3000b67c:	e5d33000 	ldrb	r3, [r3]
3000b680:	e3530000 	cmp	r3, #0
3000b684:	1affffe0 	bne	3000b60c <acoral_str_upr+0x1c>
		if(s[i]>='a'&&s[i]<='z')
			s[i]-=32;
		i++;
	} 
	return str;
3000b688:	e59d3004 	ldr	r3, [sp, #4]
}
3000b68c:	e1a00003 	mov	r0, r3
3000b690:	e28dd010 	add	sp, sp, #16
3000b694:	e12fff1e 	bx	lr

3000b698 <acoral_str_lwr>:

acoral_char *acoral_str_lwr(acoral_char *s){
3000b698:	e24dd010 	sub	sp, sp, #16
3000b69c:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 i=0;
3000b6a0:	e3a03000 	mov	r3, #0
3000b6a4:	e58d300c 	str	r3, [sp, #12]
	while(s[i]!='\0'){
3000b6a8:	ea000018 	b	3000b710 <acoral_str_lwr+0x78>
		if(s[i]>='A'&&s[i]<='Z')
3000b6ac:	e59d2004 	ldr	r2, [sp, #4]
3000b6b0:	e59d300c 	ldr	r3, [sp, #12]
3000b6b4:	e0823003 	add	r3, r2, r3
3000b6b8:	e5d33000 	ldrb	r3, [r3]
3000b6bc:	e3530040 	cmp	r3, #64	; 0x40
3000b6c0:	9a00000f 	bls	3000b704 <acoral_str_lwr+0x6c>
3000b6c4:	e59d2004 	ldr	r2, [sp, #4]
3000b6c8:	e59d300c 	ldr	r3, [sp, #12]
3000b6cc:	e0823003 	add	r3, r2, r3
3000b6d0:	e5d33000 	ldrb	r3, [r3]
3000b6d4:	e353005a 	cmp	r3, #90	; 0x5a
3000b6d8:	8a000009 	bhi	3000b704 <acoral_str_lwr+0x6c>
			s[i]+=32;
3000b6dc:	e59d2004 	ldr	r2, [sp, #4]
3000b6e0:	e59d300c 	ldr	r3, [sp, #12]
3000b6e4:	e0823003 	add	r3, r2, r3
3000b6e8:	e59d1004 	ldr	r1, [sp, #4]
3000b6ec:	e59d200c 	ldr	r2, [sp, #12]
3000b6f0:	e0812002 	add	r2, r1, r2
3000b6f4:	e5d22000 	ldrb	r2, [r2]
3000b6f8:	e2822020 	add	r2, r2, #32
3000b6fc:	e20220ff 	and	r2, r2, #255	; 0xff
3000b700:	e5c32000 	strb	r2, [r3]
		i++;
3000b704:	e59d300c 	ldr	r3, [sp, #12]
3000b708:	e2833001 	add	r3, r3, #1
3000b70c:	e58d300c 	str	r3, [sp, #12]
	return str;
}

acoral_char *acoral_str_lwr(acoral_char *s){
	acoral_u32 i=0;
	while(s[i]!='\0'){
3000b710:	e59d2004 	ldr	r2, [sp, #4]
3000b714:	e59d300c 	ldr	r3, [sp, #12]
3000b718:	e0823003 	add	r3, r2, r3
3000b71c:	e5d33000 	ldrb	r3, [r3]
3000b720:	e3530000 	cmp	r3, #0
3000b724:	1affffe0 	bne	3000b6ac <acoral_str_lwr+0x14>
		if(s[i]>='A'&&s[i]<='Z')
			s[i]+=32;
		i++;
	} 
	return s;
3000b728:	e59d3004 	ldr	r3, [sp, #4]
}
3000b72c:	e1a00003 	mov	r0, r3
3000b730:	e28dd010 	add	sp, sp, #16
3000b734:	e12fff1e 	bx	lr

3000b738 <acoral_str_len>:

acoral_u32 acoral_str_len(const acoral_char *str)  
{  
3000b738:	e24dd010 	sub	sp, sp, #16
3000b73c:	e58d0004 	str	r0, [sp, #4]
  acoral_u32  i=0;  
3000b740:	e3a03000 	mov	r3, #0
3000b744:	e58d3008 	str	r3, [sp, #8]
  const acoral_char *p=str;
3000b748:	e59d3004 	ldr	r3, [sp, #4]
3000b74c:	e58d300c 	str	r3, [sp, #12]
  while(*p++)  
3000b750:	ea000002 	b	3000b760 <acoral_str_len+0x28>
      i++;  
3000b754:	e59d3008 	ldr	r3, [sp, #8]
3000b758:	e2833001 	add	r3, r3, #1
3000b75c:	e58d3008 	str	r3, [sp, #8]

acoral_u32 acoral_str_len(const acoral_char *str)  
{  
  acoral_u32  i=0;  
  const acoral_char *p=str;
  while(*p++)  
3000b760:	e59d300c 	ldr	r3, [sp, #12]
3000b764:	e5d33000 	ldrb	r3, [r3]
3000b768:	e3530000 	cmp	r3, #0
3000b76c:	03a03000 	moveq	r3, #0
3000b770:	13a03001 	movne	r3, #1
3000b774:	e20330ff 	and	r3, r3, #255	; 0xff
3000b778:	e59d200c 	ldr	r2, [sp, #12]
3000b77c:	e2822001 	add	r2, r2, #1
3000b780:	e58d200c 	str	r2, [sp, #12]
3000b784:	e3530000 	cmp	r3, #0
3000b788:	1afffff1 	bne	3000b754 <acoral_str_len+0x1c>
      i++;  
  return  i;  
3000b78c:	e59d3008 	ldr	r3, [sp, #8]
}
3000b790:	e1a00003 	mov	r0, r3
3000b794:	e28dd010 	add	sp, sp, #16
3000b798:	e12fff1e 	bx	lr

3000b79c <acoral_str_cpy>:

acoral_char *acoral_str_cpy(acoral_char *to, const acoral_char *from)
{
3000b79c:	e24dd010 	sub	sp, sp, #16
3000b7a0:	e58d0004 	str	r0, [sp, #4]
3000b7a4:	e58d1000 	str	r1, [sp]
    acoral_char *rev = to;
3000b7a8:	e59d3004 	ldr	r3, [sp, #4]
3000b7ac:	e58d300c 	str	r3, [sp, #12]
    while(*to++ = *from++);
3000b7b0:	e59d3000 	ldr	r3, [sp]
3000b7b4:	e5d32000 	ldrb	r2, [r3]
3000b7b8:	e59d3004 	ldr	r3, [sp, #4]
3000b7bc:	e5c32000 	strb	r2, [r3]
3000b7c0:	e59d3004 	ldr	r3, [sp, #4]
3000b7c4:	e5d33000 	ldrb	r3, [r3]
3000b7c8:	e3530000 	cmp	r3, #0
3000b7cc:	03a03000 	moveq	r3, #0
3000b7d0:	13a03001 	movne	r3, #1
3000b7d4:	e20330ff 	and	r3, r3, #255	; 0xff
3000b7d8:	e59d2004 	ldr	r2, [sp, #4]
3000b7dc:	e2822001 	add	r2, r2, #1
3000b7e0:	e58d2004 	str	r2, [sp, #4]
3000b7e4:	e59d2000 	ldr	r2, [sp]
3000b7e8:	e2822001 	add	r2, r2, #1
3000b7ec:	e58d2000 	str	r2, [sp]
3000b7f0:	e3530000 	cmp	r3, #0
3000b7f4:	1affffed 	bne	3000b7b0 <acoral_str_cpy+0x14>
    return rev;
3000b7f8:	e59d300c 	ldr	r3, [sp, #12]
}
3000b7fc:	e1a00003 	mov	r0, r3
3000b800:	e28dd010 	add	sp, sp, #16
3000b804:	e12fff1e 	bx	lr

3000b808 <acoral_str_cmp>:

acoral_u32 acoral_str_cmp(const acoral_char * des,const  acoral_char * src)
{
3000b808:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b80c:	e24dd01c 	sub	sp, sp, #28
3000b810:	e58d0004 	str	r0, [sp, #4]
3000b814:	e58d1000 	str	r1, [sp]
    acoral_u32 c;
    acoral_u32 len1;
    acoral_u32 len2;
    if(des == NULL || src == NULL)
3000b818:	e59d3004 	ldr	r3, [sp, #4]
3000b81c:	e3530000 	cmp	r3, #0
3000b820:	0a000002 	beq	3000b830 <acoral_str_cmp+0x28>
3000b824:	e59d3000 	ldr	r3, [sp]
3000b828:	e3530000 	cmp	r3, #0
3000b82c:	1a000001 	bne	3000b838 <acoral_str_cmp+0x30>
      	return -1;	
3000b830:	e3e03000 	mvn	r3, #0
3000b834:	ea00002b 	b	3000b8e8 <acoral_str_cmp+0xe0>
    len1 = acoral_str_len(des);
3000b838:	e59d0004 	ldr	r0, [sp, #4]
3000b83c:	ebffffbd 	bl	3000b738 <acoral_str_len>
3000b840:	e1a03000 	mov	r3, r0
3000b844:	e58d3010 	str	r3, [sp, #16]
    len2 = acoral_str_len(src);
3000b848:	e59d0000 	ldr	r0, [sp]
3000b84c:	ebffffb9 	bl	3000b738 <acoral_str_len>
3000b850:	e1a03000 	mov	r3, r0
3000b854:	e58d3014 	str	r3, [sp, #20]
    if(len1 != len2)
3000b858:	e59d2010 	ldr	r2, [sp, #16]
3000b85c:	e59d3014 	ldr	r3, [sp, #20]
3000b860:	e1520003 	cmp	r2, r3
3000b864:	0a000019 	beq	3000b8d0 <acoral_str_cmp+0xc8>
    {
        return len1-len2;
3000b868:	e59d2010 	ldr	r2, [sp, #16]
3000b86c:	e59d3014 	ldr	r3, [sp, #20]
3000b870:	e0633002 	rsb	r3, r3, r2
3000b874:	ea00001b 	b	3000b8e8 <acoral_str_cmp+0xe0>
    }
    while(*des != '\0')
    {
        if((c=(*des++ - * src++)) != 0)
3000b878:	e59d3004 	ldr	r3, [sp, #4]
3000b87c:	e5d33000 	ldrb	r3, [r3]
3000b880:	e1a02003 	mov	r2, r3
3000b884:	e59d3000 	ldr	r3, [sp]
3000b888:	e5d33000 	ldrb	r3, [r3]
3000b88c:	e0633002 	rsb	r3, r3, r2
3000b890:	e58d300c 	str	r3, [sp, #12]
3000b894:	e59d300c 	ldr	r3, [sp, #12]
3000b898:	e3530000 	cmp	r3, #0
3000b89c:	03a03000 	moveq	r3, #0
3000b8a0:	13a03001 	movne	r3, #1
3000b8a4:	e20330ff 	and	r3, r3, #255	; 0xff
3000b8a8:	e59d2004 	ldr	r2, [sp, #4]
3000b8ac:	e2822001 	add	r2, r2, #1
3000b8b0:	e58d2004 	str	r2, [sp, #4]
3000b8b4:	e59d2000 	ldr	r2, [sp]
3000b8b8:	e2822001 	add	r2, r2, #1
3000b8bc:	e58d2000 	str	r2, [sp]
3000b8c0:	e3530000 	cmp	r3, #0
3000b8c4:	0a000002 	beq	3000b8d4 <acoral_str_cmp+0xcc>
        {
            return c;
3000b8c8:	e59d300c 	ldr	r3, [sp, #12]
3000b8cc:	ea000005 	b	3000b8e8 <acoral_str_cmp+0xe0>
    len2 = acoral_str_len(src);
    if(len1 != len2)
    {
        return len1-len2;
    }
    while(*des != '\0')
3000b8d0:	e1a00000 	nop			; (mov r0, r0)
3000b8d4:	e59d3004 	ldr	r3, [sp, #4]
3000b8d8:	e5d33000 	ldrb	r3, [r3]
3000b8dc:	e3530000 	cmp	r3, #0
3000b8e0:	1affffe4 	bne	3000b878 <acoral_str_cmp+0x70>
        if((c=(*des++ - * src++)) != 0)
        {
            return c;
        }
    }
    return c;
3000b8e4:	e59d300c 	ldr	r3, [sp, #12]
}
3000b8e8:	e1a00003 	mov	r0, r3
3000b8ec:	e28dd01c 	add	sp, sp, #28
3000b8f0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000b8f4:	e12fff1e 	bx	lr

3000b8f8 <acoral_str_nicmp>:
 * @s1: One string
 * @s2: The other string
 * @len: the maximum number of characters to compare
 */
acoral_32 acoral_str_nicmp(const acoral_char *s1, const acoral_char *s2, acoral_u32 len)
{
3000b8f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000b8fc:	e24dd01c 	sub	sp, sp, #28
3000b900:	e58d000c 	str	r0, [sp, #12]
3000b904:	e58d1008 	str	r1, [sp, #8]
3000b908:	e58d2004 	str	r2, [sp, #4]
	/* Yes, Virginia, it had better be unsigned */
	acoral_u8 c1, c2;

	c1 = 0;	c2 = 0;
3000b90c:	e3a03000 	mov	r3, #0
3000b910:	e5cd3016 	strb	r3, [sp, #22]
3000b914:	e3a03000 	mov	r3, #0
3000b918:	e5cd3017 	strb	r3, [sp, #23]
	if (len) {
3000b91c:	e59d3004 	ldr	r3, [sp, #4]
3000b920:	e3530000 	cmp	r3, #0
3000b924:	0a000031 	beq	3000b9f0 <acoral_str_nicmp+0xf8>
		do {
			c1 = *s1; c2 = *s2;
3000b928:	e59d300c 	ldr	r3, [sp, #12]
3000b92c:	e5d33000 	ldrb	r3, [r3]
3000b930:	e5cd3016 	strb	r3, [sp, #22]
3000b934:	e59d3008 	ldr	r3, [sp, #8]
3000b938:	e5d33000 	ldrb	r3, [r3]
3000b93c:	e5cd3017 	strb	r3, [sp, #23]
			s1++; s2++;
3000b940:	e59d300c 	ldr	r3, [sp, #12]
3000b944:	e2833001 	add	r3, r3, #1
3000b948:	e58d300c 	str	r3, [sp, #12]
3000b94c:	e59d3008 	ldr	r3, [sp, #8]
3000b950:	e2833001 	add	r3, r3, #1
3000b954:	e58d3008 	str	r3, [sp, #8]
			if (!c1)
3000b958:	e5dd3016 	ldrb	r3, [sp, #22]
3000b95c:	e3530000 	cmp	r3, #0
3000b960:	0a00001d 	beq	3000b9dc <acoral_str_nicmp+0xe4>
				break;
			if (!c2)
3000b964:	e5dd3017 	ldrb	r3, [sp, #23]
3000b968:	e3530000 	cmp	r3, #0
3000b96c:	0a00001c 	beq	3000b9e4 <acoral_str_nicmp+0xec>
				break;
			if (c1 == c2)
3000b970:	e5dd2016 	ldrb	r2, [sp, #22]
3000b974:	e5dd3017 	ldrb	r3, [sp, #23]
3000b978:	e1520003 	cmp	r2, r3
3000b97c:	0a00000e 	beq	3000b9bc <acoral_str_nicmp+0xc4>
				continue;
			c1 = acoral_tolower(c1);
3000b980:	e5dd3016 	ldrb	r3, [sp, #22]
3000b984:	e1a00003 	mov	r0, r3
3000b988:	ebfffee6 	bl	3000b528 <acoral_tolower>
3000b98c:	e1a03000 	mov	r3, r0
3000b990:	e5cd3016 	strb	r3, [sp, #22]
			c2 = acoral_tolower(c2);
3000b994:	e5dd3017 	ldrb	r3, [sp, #23]
3000b998:	e1a00003 	mov	r0, r3
3000b99c:	ebfffee1 	bl	3000b528 <acoral_tolower>
3000b9a0:	e1a03000 	mov	r3, r0
3000b9a4:	e5cd3017 	strb	r3, [sp, #23]
			if (c1 != c2)
3000b9a8:	e5dd2016 	ldrb	r2, [sp, #22]
3000b9ac:	e5dd3017 	ldrb	r3, [sp, #23]
3000b9b0:	e1520003 	cmp	r2, r3
3000b9b4:	1a00000c 	bne	3000b9ec <acoral_str_nicmp+0xf4>
3000b9b8:	ea000000 	b	3000b9c0 <acoral_str_nicmp+0xc8>
			if (!c1)
				break;
			if (!c2)
				break;
			if (c1 == c2)
				continue;
3000b9bc:	e1a00000 	nop			; (mov r0, r0)
			c1 = acoral_tolower(c1);
			c2 = acoral_tolower(c2);
			if (c1 != c2)
				break;
		} while (--len);
3000b9c0:	e59d3004 	ldr	r3, [sp, #4]
3000b9c4:	e2433001 	sub	r3, r3, #1
3000b9c8:	e58d3004 	str	r3, [sp, #4]
3000b9cc:	e59d3004 	ldr	r3, [sp, #4]
3000b9d0:	e3530000 	cmp	r3, #0
3000b9d4:	1affffd3 	bne	3000b928 <acoral_str_nicmp+0x30>
3000b9d8:	ea000004 	b	3000b9f0 <acoral_str_nicmp+0xf8>
	if (len) {
		do {
			c1 = *s1; c2 = *s2;
			s1++; s2++;
			if (!c1)
				break;
3000b9dc:	e1a00000 	nop			; (mov r0, r0)
3000b9e0:	ea000002 	b	3000b9f0 <acoral_str_nicmp+0xf8>
			if (!c2)
				break;
3000b9e4:	e1a00000 	nop			; (mov r0, r0)
3000b9e8:	ea000000 	b	3000b9f0 <acoral_str_nicmp+0xf8>
			if (c1 == c2)
				continue;
			c1 = acoral_tolower(c1);
			c2 = acoral_tolower(c2);
			if (c1 != c2)
				break;
3000b9ec:	e1a00000 	nop			; (mov r0, r0)
		} while (--len);
	}
	return (acoral_32)c1 - (acoral_32)c2;
3000b9f0:	e5dd2016 	ldrb	r2, [sp, #22]
3000b9f4:	e5dd3017 	ldrb	r3, [sp, #23]
3000b9f8:	e0633002 	rsb	r3, r3, r2
}
3000b9fc:	e1a00003 	mov	r0, r3
3000ba00:	e28dd01c 	add	sp, sp, #28
3000ba04:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000ba08:	e12fff1e 	bx	lr

3000ba0c <acoral_str_ncpy>:
 *
 * The result is not %NUL-terminated if the source exceeds
 * @count bytes.
 */
acoral_char * acoral_str_ncpy(acoral_char * dest,const acoral_char *src,acoral_u32 count)
{
3000ba0c:	e24dd018 	sub	sp, sp, #24
3000ba10:	e58d000c 	str	r0, [sp, #12]
3000ba14:	e58d1008 	str	r1, [sp, #8]
3000ba18:	e58d2004 	str	r2, [sp, #4]
	acoral_char *tmp = dest;
3000ba1c:	e59d300c 	ldr	r3, [sp, #12]
3000ba20:	e58d3014 	str	r3, [sp, #20]

	while (count) {
3000ba24:	ea000012 	b	3000ba74 <acoral_str_ncpy+0x68>
		if ((*tmp = *src) == '\0')
3000ba28:	e59d3008 	ldr	r3, [sp, #8]
3000ba2c:	e5d32000 	ldrb	r2, [r3]
3000ba30:	e59d3014 	ldr	r3, [sp, #20]
3000ba34:	e5c32000 	strb	r2, [r3]
3000ba38:	e59d3014 	ldr	r3, [sp, #20]
3000ba3c:	e5d33000 	ldrb	r3, [r3]
3000ba40:	e3530000 	cmp	r3, #0
3000ba44:	1a000001 	bne	3000ba50 <acoral_str_ncpy+0x44>
			return dest;
3000ba48:	e59d300c 	ldr	r3, [sp, #12]
3000ba4c:	ea00000f 	b	3000ba90 <acoral_str_ncpy+0x84>
		src++;
3000ba50:	e59d3008 	ldr	r3, [sp, #8]
3000ba54:	e2833001 	add	r3, r3, #1
3000ba58:	e58d3008 	str	r3, [sp, #8]
		tmp++;
3000ba5c:	e59d3014 	ldr	r3, [sp, #20]
3000ba60:	e2833001 	add	r3, r3, #1
3000ba64:	e58d3014 	str	r3, [sp, #20]
		count--;
3000ba68:	e59d3004 	ldr	r3, [sp, #4]
3000ba6c:	e2433001 	sub	r3, r3, #1
3000ba70:	e58d3004 	str	r3, [sp, #4]
 */
acoral_char * acoral_str_ncpy(acoral_char * dest,const acoral_char *src,acoral_u32 count)
{
	acoral_char *tmp = dest;

	while (count) {
3000ba74:	e59d3004 	ldr	r3, [sp, #4]
3000ba78:	e3530000 	cmp	r3, #0
3000ba7c:	1affffe9 	bne	3000ba28 <acoral_str_ncpy+0x1c>
			return dest;
		src++;
		tmp++;
		count--;
	}
	*tmp = '\0';
3000ba80:	e59d3014 	ldr	r3, [sp, #20]
3000ba84:	e3a02000 	mov	r2, #0
3000ba88:	e5c32000 	strb	r2, [r3]
	return dest;
3000ba8c:	e59d300c 	ldr	r3, [sp, #12]
}
3000ba90:	e1a00003 	mov	r0, r3
3000ba94:	e28dd018 	add	sp, sp, #24
3000ba98:	e12fff1e 	bx	lr

3000ba9c <acoral_str_lcpy>:
 * NUL-terminated string that fits in the buffer (unless,
 * of course, the buffer size is zero). It does not pad
 * out the result like acoral_str_ncpy() does.
 */
acoral_u32 acoral_str_lcpy(acoral_char *dest, const acoral_char *src, acoral_u32 size)
{
3000ba9c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000baa0:	e24dd01c 	sub	sp, sp, #28
3000baa4:	e58d000c 	str	r0, [sp, #12]
3000baa8:	e58d1008 	str	r1, [sp, #8]
3000baac:	e58d2004 	str	r2, [sp, #4]
	acoral_u32 ret = acoral_str_len(src);
3000bab0:	e59d0008 	ldr	r0, [sp, #8]
3000bab4:	ebffff1f 	bl	3000b738 <acoral_str_len>
3000bab8:	e1a03000 	mov	r3, r0
3000babc:	e58d3010 	str	r3, [sp, #16]

	if (size) {
3000bac0:	e59d3004 	ldr	r3, [sp, #4]
3000bac4:	e3530000 	cmp	r3, #0
3000bac8:	0a000011 	beq	3000bb14 <acoral_str_lcpy+0x78>
		acoral_u32 len = (ret >= size) ? size-1 : ret;
3000bacc:	e59d2010 	ldr	r2, [sp, #16]
3000bad0:	e59d3004 	ldr	r3, [sp, #4]
3000bad4:	e1520003 	cmp	r2, r3
3000bad8:	3a000002 	bcc	3000bae8 <acoral_str_lcpy+0x4c>
3000badc:	e59d3004 	ldr	r3, [sp, #4]
3000bae0:	e2433001 	sub	r3, r3, #1
3000bae4:	ea000000 	b	3000baec <acoral_str_lcpy+0x50>
3000bae8:	e59d3010 	ldr	r3, [sp, #16]
3000baec:	e58d3014 	str	r3, [sp, #20]
		acoral_memcpy(dest, src, len);
3000baf0:	e59d000c 	ldr	r0, [sp, #12]
3000baf4:	e59d1008 	ldr	r1, [sp, #8]
3000baf8:	e59d2014 	ldr	r2, [sp, #20]
3000bafc:	eb0001f6 	bl	3000c2dc <acoral_memcpy>
		dest[len] = '\0';
3000bb00:	e59d200c 	ldr	r2, [sp, #12]
3000bb04:	e59d3014 	ldr	r3, [sp, #20]
3000bb08:	e0823003 	add	r3, r2, r3
3000bb0c:	e3a02000 	mov	r2, #0
3000bb10:	e5c32000 	strb	r2, [r3]
	}
	return ret;
3000bb14:	e59d3010 	ldr	r3, [sp, #16]
}
3000bb18:	e1a00003 	mov	r0, r3
3000bb1c:	e28dd01c 	add	sp, sp, #28
3000bb20:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000bb24:	e12fff1e 	bx	lr

3000bb28 <acoral_str_cat>:
 * acoral_str_cat - Append one %NUL-terminated string to another
 * @dest: The string to be appended to
 * @src: The string to append to it
 */
acoral_char * acoral_str_cat(acoral_char * dest, const acoral_char * src)
{
3000bb28:	e24dd010 	sub	sp, sp, #16
3000bb2c:	e58d0004 	str	r0, [sp, #4]
3000bb30:	e58d1000 	str	r1, [sp]
	acoral_char *tmp = dest;
3000bb34:	e59d3004 	ldr	r3, [sp, #4]
3000bb38:	e58d300c 	str	r3, [sp, #12]

	while (*dest)
3000bb3c:	ea000002 	b	3000bb4c <acoral_str_cat+0x24>
		dest++;
3000bb40:	e59d3004 	ldr	r3, [sp, #4]
3000bb44:	e2833001 	add	r3, r3, #1
3000bb48:	e58d3004 	str	r3, [sp, #4]
 */
acoral_char * acoral_str_cat(acoral_char * dest, const acoral_char * src)
{
	acoral_char *tmp = dest;

	while (*dest)
3000bb4c:	e59d3004 	ldr	r3, [sp, #4]
3000bb50:	e5d33000 	ldrb	r3, [r3]
3000bb54:	e3530000 	cmp	r3, #0
3000bb58:	1afffff8 	bne	3000bb40 <acoral_str_cat+0x18>
		dest++;
	while ((*dest++ = *src++) != '\0')
3000bb5c:	e59d3000 	ldr	r3, [sp]
3000bb60:	e5d32000 	ldrb	r2, [r3]
3000bb64:	e59d3004 	ldr	r3, [sp, #4]
3000bb68:	e5c32000 	strb	r2, [r3]
3000bb6c:	e59d3004 	ldr	r3, [sp, #4]
3000bb70:	e5d33000 	ldrb	r3, [r3]
3000bb74:	e3530000 	cmp	r3, #0
3000bb78:	03a03000 	moveq	r3, #0
3000bb7c:	13a03001 	movne	r3, #1
3000bb80:	e20330ff 	and	r3, r3, #255	; 0xff
3000bb84:	e59d2004 	ldr	r2, [sp, #4]
3000bb88:	e2822001 	add	r2, r2, #1
3000bb8c:	e58d2004 	str	r2, [sp, #4]
3000bb90:	e59d2000 	ldr	r2, [sp]
3000bb94:	e2822001 	add	r2, r2, #1
3000bb98:	e58d2000 	str	r2, [sp]
3000bb9c:	e3530000 	cmp	r3, #0
3000bba0:	1affffed 	bne	3000bb5c <acoral_str_cat+0x34>
		;

	return tmp;
3000bba4:	e59d300c 	ldr	r3, [sp, #12]
}
3000bba8:	e1a00003 	mov	r0, r3
3000bbac:	e28dd010 	add	sp, sp, #16
3000bbb0:	e12fff1e 	bx	lr

3000bbb4 <acoral_str_ncat>:
 *
 * Note that in contrast to acoral_str_ncpy, acoral_str_ncat ensures the result is
 * terminated.
 */
acoral_char * acoral_str_ncat(acoral_char *dest, const acoral_char *src, acoral_u32 count)
{
3000bbb4:	e24dd018 	sub	sp, sp, #24
3000bbb8:	e58d000c 	str	r0, [sp, #12]
3000bbbc:	e58d1008 	str	r1, [sp, #8]
3000bbc0:	e58d2004 	str	r2, [sp, #4]
	acoral_char *tmp = dest;
3000bbc4:	e59d300c 	ldr	r3, [sp, #12]
3000bbc8:	e58d3014 	str	r3, [sp, #20]

	if (count) {
3000bbcc:	e59d3004 	ldr	r3, [sp, #4]
3000bbd0:	e3530000 	cmp	r3, #0
3000bbd4:	0a000024 	beq	3000bc6c <acoral_str_ncat+0xb8>
		while (*dest)
3000bbd8:	ea000002 	b	3000bbe8 <acoral_str_ncat+0x34>
			dest++;
3000bbdc:	e59d300c 	ldr	r3, [sp, #12]
3000bbe0:	e2833001 	add	r3, r3, #1
3000bbe4:	e58d300c 	str	r3, [sp, #12]
acoral_char * acoral_str_ncat(acoral_char *dest, const acoral_char *src, acoral_u32 count)
{
	acoral_char *tmp = dest;

	if (count) {
		while (*dest)
3000bbe8:	e59d300c 	ldr	r3, [sp, #12]
3000bbec:	e5d33000 	ldrb	r3, [r3]
3000bbf0:	e3530000 	cmp	r3, #0
3000bbf4:	1afffff8 	bne	3000bbdc <acoral_str_ncat+0x28>
			dest++;
		while ((*dest++ = *src++) != 0) {
3000bbf8:	ea000009 	b	3000bc24 <acoral_str_ncat+0x70>
			if (--count == 0) {
3000bbfc:	e59d3004 	ldr	r3, [sp, #4]
3000bc00:	e2433001 	sub	r3, r3, #1
3000bc04:	e58d3004 	str	r3, [sp, #4]
3000bc08:	e59d3004 	ldr	r3, [sp, #4]
3000bc0c:	e3530000 	cmp	r3, #0
3000bc10:	1a000003 	bne	3000bc24 <acoral_str_ncat+0x70>
				*dest = '\0';
3000bc14:	e59d300c 	ldr	r3, [sp, #12]
3000bc18:	e3a02000 	mov	r2, #0
3000bc1c:	e5c32000 	strb	r2, [r3]
				break;
3000bc20:	ea000011 	b	3000bc6c <acoral_str_ncat+0xb8>
	acoral_char *tmp = dest;

	if (count) {
		while (*dest)
			dest++;
		while ((*dest++ = *src++) != 0) {
3000bc24:	e59d3008 	ldr	r3, [sp, #8]
3000bc28:	e5d32000 	ldrb	r2, [r3]
3000bc2c:	e59d300c 	ldr	r3, [sp, #12]
3000bc30:	e5c32000 	strb	r2, [r3]
3000bc34:	e59d300c 	ldr	r3, [sp, #12]
3000bc38:	e5d33000 	ldrb	r3, [r3]
3000bc3c:	e3530000 	cmp	r3, #0
3000bc40:	03a03000 	moveq	r3, #0
3000bc44:	13a03001 	movne	r3, #1
3000bc48:	e20330ff 	and	r3, r3, #255	; 0xff
3000bc4c:	e59d200c 	ldr	r2, [sp, #12]
3000bc50:	e2822001 	add	r2, r2, #1
3000bc54:	e58d200c 	str	r2, [sp, #12]
3000bc58:	e59d2008 	ldr	r2, [sp, #8]
3000bc5c:	e2822001 	add	r2, r2, #1
3000bc60:	e58d2008 	str	r2, [sp, #8]
3000bc64:	e3530000 	cmp	r3, #0
3000bc68:	1affffe3 	bne	3000bbfc <acoral_str_ncat+0x48>
				break;
			}
		}
	}

	return tmp;
3000bc6c:	e59d3014 	ldr	r3, [sp, #20]
}
3000bc70:	e1a00003 	mov	r0, r3
3000bc74:	e28dd018 	add	sp, sp, #24
3000bc78:	e12fff1e 	bx	lr

3000bc7c <acoral_str_lcat>:
 * @dest: The string to be appended to
 * @src: The string to append to it
 * @count: The size of the destination buffer.
 */
acoral_u32 acoral_str_lcat(acoral_char *dest, const acoral_char *src, acoral_u32 count)
{
3000bc7c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000bc80:	e24dd024 	sub	sp, sp, #36	; 0x24
3000bc84:	e58d000c 	str	r0, [sp, #12]
3000bc88:	e58d1008 	str	r1, [sp, #8]
3000bc8c:	e58d2004 	str	r2, [sp, #4]
	acoral_u32 dsize = acoral_str_len(dest);
3000bc90:	e59d000c 	ldr	r0, [sp, #12]
3000bc94:	ebfffea7 	bl	3000b738 <acoral_str_len>
3000bc98:	e1a03000 	mov	r3, r0
3000bc9c:	e58d3014 	str	r3, [sp, #20]
	acoral_u32 len = acoral_str_len(src);
3000bca0:	e59d0008 	ldr	r0, [sp, #8]
3000bca4:	ebfffea3 	bl	3000b738 <acoral_str_len>
3000bca8:	e1a03000 	mov	r3, r0
3000bcac:	e58d3018 	str	r3, [sp, #24]
	acoral_u32 res = dsize + len;
3000bcb0:	e59d2014 	ldr	r2, [sp, #20]
3000bcb4:	e59d3018 	ldr	r3, [sp, #24]
3000bcb8:	e0823003 	add	r3, r2, r3
3000bcbc:	e58d301c 	str	r3, [sp, #28]

	/* This would be a bug */
//	BUG_ON(dsize >= count);

	dest += dsize;
3000bcc0:	e59d200c 	ldr	r2, [sp, #12]
3000bcc4:	e59d3014 	ldr	r3, [sp, #20]
3000bcc8:	e0823003 	add	r3, r2, r3
3000bccc:	e58d300c 	str	r3, [sp, #12]
	count -= dsize;
3000bcd0:	e59d2004 	ldr	r2, [sp, #4]
3000bcd4:	e59d3014 	ldr	r3, [sp, #20]
3000bcd8:	e0633002 	rsb	r3, r3, r2
3000bcdc:	e58d3004 	str	r3, [sp, #4]
	if (len >= count)
3000bce0:	e59d2018 	ldr	r2, [sp, #24]
3000bce4:	e59d3004 	ldr	r3, [sp, #4]
3000bce8:	e1520003 	cmp	r2, r3
3000bcec:	3a000002 	bcc	3000bcfc <acoral_str_lcat+0x80>
		len = count-1;
3000bcf0:	e59d3004 	ldr	r3, [sp, #4]
3000bcf4:	e2433001 	sub	r3, r3, #1
3000bcf8:	e58d3018 	str	r3, [sp, #24]
	acoral_memcpy(dest, src, len);
3000bcfc:	e59d000c 	ldr	r0, [sp, #12]
3000bd00:	e59d1008 	ldr	r1, [sp, #8]
3000bd04:	e59d2018 	ldr	r2, [sp, #24]
3000bd08:	eb000173 	bl	3000c2dc <acoral_memcpy>
	dest[len] = 0;
3000bd0c:	e59d200c 	ldr	r2, [sp, #12]
3000bd10:	e59d3018 	ldr	r3, [sp, #24]
3000bd14:	e0823003 	add	r3, r2, r3
3000bd18:	e3a02000 	mov	r2, #0
3000bd1c:	e5c32000 	strb	r2, [r3]
	return res;
3000bd20:	e59d301c 	ldr	r3, [sp, #28]
}
3000bd24:	e1a00003 	mov	r0, r3
3000bd28:	e28dd024 	add	sp, sp, #36	; 0x24
3000bd2c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000bd30:	e12fff1e 	bx	lr

3000bd34 <acoral_str_ncmp>:
 * @cs: One string
 * @ct: Another string
 * @count: The maximum number of bytes to compare
 */
acoral_32 acoral_str_ncmp(const acoral_char * cs,const acoral_char * ct,acoral_u32 count)
{
3000bd34:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
3000bd38:	e24dd014 	sub	sp, sp, #20
3000bd3c:	e58d000c 	str	r0, [sp, #12]
3000bd40:	e58d1008 	str	r1, [sp, #8]
3000bd44:	e58d2004 	str	r2, [sp, #4]
	register acoral_8 __res = 0;
3000bd48:	e3a04000 	mov	r4, #0

	while (count) {
3000bd4c:	ea00001f 	b	3000bdd0 <acoral_str_ncmp+0x9c>
		if ((__res = *cs - *ct++) != 0 || !*cs++)
3000bd50:	e59d300c 	ldr	r3, [sp, #12]
3000bd54:	e5d32000 	ldrb	r2, [r3]
3000bd58:	e59d3008 	ldr	r3, [sp, #8]
3000bd5c:	e5d33000 	ldrb	r3, [r3]
3000bd60:	e0633002 	rsb	r3, r3, r2
3000bd64:	e20330ff 	and	r3, r3, #255	; 0xff
3000bd68:	e1a04003 	mov	r4, r3
3000bd6c:	e1a03c04 	lsl	r3, r4, #24
3000bd70:	e1a03c43 	asr	r3, r3, #24
3000bd74:	e3530000 	cmp	r3, #0
3000bd78:	03a03000 	moveq	r3, #0
3000bd7c:	13a03001 	movne	r3, #1
3000bd80:	e20330ff 	and	r3, r3, #255	; 0xff
3000bd84:	e59d2008 	ldr	r2, [sp, #8]
3000bd88:	e2822001 	add	r2, r2, #1
3000bd8c:	e58d2008 	str	r2, [sp, #8]
3000bd90:	e3530000 	cmp	r3, #0
3000bd94:	1a000010 	bne	3000bddc <acoral_str_ncmp+0xa8>
3000bd98:	e59d300c 	ldr	r3, [sp, #12]
3000bd9c:	e5d33000 	ldrb	r3, [r3]
3000bda0:	e3530000 	cmp	r3, #0
3000bda4:	13a03000 	movne	r3, #0
3000bda8:	03a03001 	moveq	r3, #1
3000bdac:	e20330ff 	and	r3, r3, #255	; 0xff
3000bdb0:	e59d200c 	ldr	r2, [sp, #12]
3000bdb4:	e2822001 	add	r2, r2, #1
3000bdb8:	e58d200c 	str	r2, [sp, #12]
3000bdbc:	e3530000 	cmp	r3, #0
3000bdc0:	1a000005 	bne	3000bddc <acoral_str_ncmp+0xa8>
			break;
		count--;
3000bdc4:	e59d3004 	ldr	r3, [sp, #4]
3000bdc8:	e2433001 	sub	r3, r3, #1
3000bdcc:	e58d3004 	str	r3, [sp, #4]
 */
acoral_32 acoral_str_ncmp(const acoral_char * cs,const acoral_char * ct,acoral_u32 count)
{
	register acoral_8 __res = 0;

	while (count) {
3000bdd0:	e59d3004 	ldr	r3, [sp, #4]
3000bdd4:	e3530000 	cmp	r3, #0
3000bdd8:	1affffdc 	bne	3000bd50 <acoral_str_ncmp+0x1c>
		if ((__res = *cs - *ct++) != 0 || !*cs++)
			break;
		count--;
	}

	return __res;
3000bddc:	e1a03c04 	lsl	r3, r4, #24
3000bde0:	e1a03c43 	asr	r3, r3, #24
}
3000bde4:	e1a00003 	mov	r0, r3
3000bde8:	e28dd014 	add	sp, sp, #20
3000bdec:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
3000bdf0:	e12fff1e 	bx	lr

3000bdf4 <acoral_str_chr>:
 * acoral_str_chr - Find the first occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
acoral_32  acoral_str_chr(const acoral_char * s, acoral_32 c)
{
3000bdf4:	e24dd010 	sub	sp, sp, #16
3000bdf8:	e58d0004 	str	r0, [sp, #4]
3000bdfc:	e58d1000 	str	r1, [sp]
	acoral_u32 pos = 1;
3000be00:	e3a03001 	mov	r3, #1
3000be04:	e58d300c 	str	r3, [sp, #12]
	for(; *s != (acoral_char) c; ++s,++pos)
3000be08:	ea00000b 	b	3000be3c <acoral_str_chr+0x48>
		if (*s == '\0')
3000be0c:	e59d3004 	ldr	r3, [sp, #4]
3000be10:	e5d33000 	ldrb	r3, [r3]
3000be14:	e3530000 	cmp	r3, #0
3000be18:	1a000001 	bne	3000be24 <acoral_str_chr+0x30>
			return 0;
3000be1c:	e3a03000 	mov	r3, #0
3000be20:	ea00000c 	b	3000be58 <acoral_str_chr+0x64>
 * @c: The character to search for
 */
acoral_32  acoral_str_chr(const acoral_char * s, acoral_32 c)
{
	acoral_u32 pos = 1;
	for(; *s != (acoral_char) c; ++s,++pos)
3000be24:	e59d3004 	ldr	r3, [sp, #4]
3000be28:	e2833001 	add	r3, r3, #1
3000be2c:	e58d3004 	str	r3, [sp, #4]
3000be30:	e59d300c 	ldr	r3, [sp, #12]
3000be34:	e2833001 	add	r3, r3, #1
3000be38:	e58d300c 	str	r3, [sp, #12]
3000be3c:	e59d3004 	ldr	r3, [sp, #4]
3000be40:	e5d32000 	ldrb	r2, [r3]
3000be44:	e59d3000 	ldr	r3, [sp]
3000be48:	e20330ff 	and	r3, r3, #255	; 0xff
3000be4c:	e1520003 	cmp	r2, r3
3000be50:	1affffed 	bne	3000be0c <acoral_str_chr+0x18>
		if (*s == '\0')
			return 0;
	return pos;
3000be54:	e59d300c 	ldr	r3, [sp, #12]
}
3000be58:	e1a00003 	mov	r0, r3
3000be5c:	e28dd010 	add	sp, sp, #16
3000be60:	e12fff1e 	bx	lr

3000be64 <acoral_str_rchr>:
 * acoral_str_rchr - Find the last occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
acoral_32  acoral_str_rchr(const acoral_char * s, acoral_32 c)
{
3000be64:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000be68:	e24dd014 	sub	sp, sp, #20
3000be6c:	e58d0004 	str	r0, [sp, #4]
3000be70:	e58d1000 	str	r1, [sp]
	   acoral_u32 pos = acoral_str_len(s);
3000be74:	e59d0004 	ldr	r0, [sp, #4]
3000be78:	ebfffe2e 	bl	3000b738 <acoral_str_len>
3000be7c:	e1a03000 	mov	r3, r0
3000be80:	e58d3008 	str	r3, [sp, #8]
       const acoral_char *p = s + pos;
3000be84:	e59d2004 	ldr	r2, [sp, #4]
3000be88:	e59d3008 	ldr	r3, [sp, #8]
3000be8c:	e0823003 	add	r3, r2, r3
3000be90:	e58d300c 	str	r3, [sp, #12]
       do {
           if (*p == (acoral_char)c)
3000be94:	e59d300c 	ldr	r3, [sp, #12]
3000be98:	e5d32000 	ldrb	r2, [r3]
3000be9c:	e59d3000 	ldr	r3, [sp]
3000bea0:	e20330ff 	and	r3, r3, #255	; 0xff
3000bea4:	e1520003 	cmp	r2, r3
3000bea8:	1a000001 	bne	3000beb4 <acoral_str_rchr+0x50>
               return pos;
3000beac:	e59d3008 	ldr	r3, [sp, #8]
3000beb0:	ea00000a 	b	3000bee0 <acoral_str_rchr+0x7c>
           --pos;
3000beb4:	e59d3008 	ldr	r3, [sp, #8]
3000beb8:	e2433001 	sub	r3, r3, #1
3000bebc:	e58d3008 	str	r3, [sp, #8]
       } while (--p >= s);
3000bec0:	e59d300c 	ldr	r3, [sp, #12]
3000bec4:	e2433001 	sub	r3, r3, #1
3000bec8:	e58d300c 	str	r3, [sp, #12]
3000becc:	e59d200c 	ldr	r2, [sp, #12]
3000bed0:	e59d3004 	ldr	r3, [sp, #4]
3000bed4:	e1520003 	cmp	r2, r3
3000bed8:	2affffed 	bcs	3000be94 <acoral_str_rchr+0x30>
       return 0;
3000bedc:	e3a03000 	mov	r3, #0
}
3000bee0:	e1a00003 	mov	r0, r3
3000bee4:	e28dd014 	add	sp, sp, #20
3000bee8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000beec:	e12fff1e 	bx	lr

3000bef0 <acoral_str_nchr>:
 * @s: The string to be searched
 * @count: The number of characters to be searched
 * @c: The character to search for
 */
acoral_32 acoral_str_nchr(const acoral_char *s, acoral_u32 count, acoral_32 c)
{
3000bef0:	e24dd018 	sub	sp, sp, #24
3000bef4:	e58d000c 	str	r0, [sp, #12]
3000bef8:	e58d1008 	str	r1, [sp, #8]
3000befc:	e58d2004 	str	r2, [sp, #4]
	acoral_u32 pos = 1;
3000bf00:	e3a03001 	mov	r3, #1
3000bf04:	e58d3014 	str	r3, [sp, #20]
	for (; count-- && *s != '\0'; ++s,++pos)
3000bf08:	ea00000d 	b	3000bf44 <acoral_str_nchr+0x54>
		if (*s == (acoral_char) c)
3000bf0c:	e59d300c 	ldr	r3, [sp, #12]
3000bf10:	e5d32000 	ldrb	r2, [r3]
3000bf14:	e59d3004 	ldr	r3, [sp, #4]
3000bf18:	e20330ff 	and	r3, r3, #255	; 0xff
3000bf1c:	e1520003 	cmp	r2, r3
3000bf20:	1a000001 	bne	3000bf2c <acoral_str_nchr+0x3c>
			return pos;
3000bf24:	e59d3014 	ldr	r3, [sp, #20]
3000bf28:	ea000014 	b	3000bf80 <acoral_str_nchr+0x90>
 * @c: The character to search for
 */
acoral_32 acoral_str_nchr(const acoral_char *s, acoral_u32 count, acoral_32 c)
{
	acoral_u32 pos = 1;
	for (; count-- && *s != '\0'; ++s,++pos)
3000bf2c:	e59d300c 	ldr	r3, [sp, #12]
3000bf30:	e2833001 	add	r3, r3, #1
3000bf34:	e58d300c 	str	r3, [sp, #12]
3000bf38:	e59d3014 	ldr	r3, [sp, #20]
3000bf3c:	e2833001 	add	r3, r3, #1
3000bf40:	e58d3014 	str	r3, [sp, #20]
3000bf44:	e59d3008 	ldr	r3, [sp, #8]
3000bf48:	e3530000 	cmp	r3, #0
3000bf4c:	03a03000 	moveq	r3, #0
3000bf50:	13a03001 	movne	r3, #1
3000bf54:	e20330ff 	and	r3, r3, #255	; 0xff
3000bf58:	e59d2008 	ldr	r2, [sp, #8]
3000bf5c:	e2422001 	sub	r2, r2, #1
3000bf60:	e58d2008 	str	r2, [sp, #8]
3000bf64:	e3530000 	cmp	r3, #0
3000bf68:	0a000003 	beq	3000bf7c <acoral_str_nchr+0x8c>
3000bf6c:	e59d300c 	ldr	r3, [sp, #12]
3000bf70:	e5d33000 	ldrb	r3, [r3]
3000bf74:	e3530000 	cmp	r3, #0
3000bf78:	1affffe3 	bne	3000bf0c <acoral_str_nchr+0x1c>
		if (*s == (acoral_char) c)
			return pos;
	return 0;
3000bf7c:	e3a03000 	mov	r3, #0
}
3000bf80:	e1a00003 	mov	r0, r3
3000bf84:	e28dd018 	add	sp, sp, #24
3000bf88:	e12fff1e 	bx	lr

3000bf8c <acoral_str_nlen>:
 * acoral_str_nlen - Find the length of a length-limited string
 * @s: The string to be sized
 * @count: The maximum number of bytes to search
 */
acoral_u32 acoral_str_nlen(const acoral_char * s, acoral_u32 count)
{
3000bf8c:	e24dd010 	sub	sp, sp, #16
3000bf90:	e58d0004 	str	r0, [sp, #4]
3000bf94:	e58d1000 	str	r1, [sp]
	const acoral_char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
3000bf98:	e59d3004 	ldr	r3, [sp, #4]
3000bf9c:	e58d300c 	str	r3, [sp, #12]
3000bfa0:	ea000002 	b	3000bfb0 <acoral_str_nlen+0x24>
3000bfa4:	e59d300c 	ldr	r3, [sp, #12]
3000bfa8:	e2833001 	add	r3, r3, #1
3000bfac:	e58d300c 	str	r3, [sp, #12]
3000bfb0:	e59d3000 	ldr	r3, [sp]
3000bfb4:	e3530000 	cmp	r3, #0
3000bfb8:	03a03000 	moveq	r3, #0
3000bfbc:	13a03001 	movne	r3, #1
3000bfc0:	e20330ff 	and	r3, r3, #255	; 0xff
3000bfc4:	e59d2000 	ldr	r2, [sp]
3000bfc8:	e2422001 	sub	r2, r2, #1
3000bfcc:	e58d2000 	str	r2, [sp]
3000bfd0:	e3530000 	cmp	r3, #0
3000bfd4:	0a000003 	beq	3000bfe8 <acoral_str_nlen+0x5c>
3000bfd8:	e59d300c 	ldr	r3, [sp, #12]
3000bfdc:	e5d33000 	ldrb	r3, [r3]
3000bfe0:	e3530000 	cmp	r3, #0
3000bfe4:	1affffee 	bne	3000bfa4 <acoral_str_nlen+0x18>
		/* nothing */;
	return sc - s;
3000bfe8:	e59d200c 	ldr	r2, [sp, #12]
3000bfec:	e59d3004 	ldr	r3, [sp, #4]
3000bff0:	e0633002 	rsb	r3, r3, r2
}
3000bff4:	e1a00003 	mov	r0, r3
3000bff8:	e28dd010 	add	sp, sp, #16
3000bffc:	e12fff1e 	bx	lr

3000c000 <acoral_str_spn>:
 * 	contain letters in @accept
 * @s: The string to be searched
 * @accept: The string to search for
 */
acoral_u32 acoral_str_spn(const acoral_char *s, const acoral_char *accept)
{
3000c000:	e24dd018 	sub	sp, sp, #24
3000c004:	e58d0004 	str	r0, [sp, #4]
3000c008:	e58d1000 	str	r1, [sp]
	const acoral_char *p;
	const acoral_char *a;
	acoral_u32 count = 0;
3000c00c:	e3a03000 	mov	r3, #0
3000c010:	e58d3014 	str	r3, [sp, #20]

	for (p = s; *p != '\0'; ++p) {
3000c014:	e59d3004 	ldr	r3, [sp, #4]
3000c018:	e58d300c 	str	r3, [sp, #12]
3000c01c:	ea00001d 	b	3000c098 <acoral_str_spn+0x98>
		for (a = accept; *a != '\0'; ++a) {
3000c020:	e59d3000 	ldr	r3, [sp]
3000c024:	e58d3010 	str	r3, [sp, #16]
3000c028:	ea000008 	b	3000c050 <acoral_str_spn+0x50>
			if (*p == *a)
3000c02c:	e59d300c 	ldr	r3, [sp, #12]
3000c030:	e5d32000 	ldrb	r2, [r3]
3000c034:	e59d3010 	ldr	r3, [sp, #16]
3000c038:	e5d33000 	ldrb	r3, [r3]
3000c03c:	e1520003 	cmp	r2, r3
3000c040:	0a000007 	beq	3000c064 <acoral_str_spn+0x64>
	const acoral_char *p;
	const acoral_char *a;
	acoral_u32 count = 0;

	for (p = s; *p != '\0'; ++p) {
		for (a = accept; *a != '\0'; ++a) {
3000c044:	e59d3010 	ldr	r3, [sp, #16]
3000c048:	e2833001 	add	r3, r3, #1
3000c04c:	e58d3010 	str	r3, [sp, #16]
3000c050:	e59d3010 	ldr	r3, [sp, #16]
3000c054:	e5d33000 	ldrb	r3, [r3]
3000c058:	e3530000 	cmp	r3, #0
3000c05c:	1afffff2 	bne	3000c02c <acoral_str_spn+0x2c>
3000c060:	ea000000 	b	3000c068 <acoral_str_spn+0x68>
			if (*p == *a)
				break;
3000c064:	e1a00000 	nop			; (mov r0, r0)
		}
		if (*a == '\0')
3000c068:	e59d3010 	ldr	r3, [sp, #16]
3000c06c:	e5d33000 	ldrb	r3, [r3]
3000c070:	e3530000 	cmp	r3, #0
3000c074:	1a000001 	bne	3000c080 <acoral_str_spn+0x80>
			return count;
3000c078:	e59d3014 	ldr	r3, [sp, #20]
3000c07c:	ea00000a 	b	3000c0ac <acoral_str_spn+0xac>
		++count;
3000c080:	e59d3014 	ldr	r3, [sp, #20]
3000c084:	e2833001 	add	r3, r3, #1
3000c088:	e58d3014 	str	r3, [sp, #20]
{
	const acoral_char *p;
	const acoral_char *a;
	acoral_u32 count = 0;

	for (p = s; *p != '\0'; ++p) {
3000c08c:	e59d300c 	ldr	r3, [sp, #12]
3000c090:	e2833001 	add	r3, r3, #1
3000c094:	e58d300c 	str	r3, [sp, #12]
3000c098:	e59d300c 	ldr	r3, [sp, #12]
3000c09c:	e5d33000 	ldrb	r3, [r3]
3000c0a0:	e3530000 	cmp	r3, #0
3000c0a4:	1affffdd 	bne	3000c020 <acoral_str_spn+0x20>
		if (*a == '\0')
			return count;
		++count;
	}

	return count;
3000c0a8:	e59d3014 	ldr	r3, [sp, #20]
}
3000c0ac:	e1a00003 	mov	r0, r3
3000c0b0:	e28dd018 	add	sp, sp, #24
3000c0b4:	e12fff1e 	bx	lr

3000c0b8 <acoral_str_cspn>:
 * 	not contain letters in @reject
 * @s: The string to be searched
 * @reject: The string to avoid
 */
acoral_u32 acoral_str_cspn(const acoral_char *s, const acoral_char *reject)
{
3000c0b8:	e24dd018 	sub	sp, sp, #24
3000c0bc:	e58d0004 	str	r0, [sp, #4]
3000c0c0:	e58d1000 	str	r1, [sp]
	const acoral_char *p;
	const acoral_char *r;
	acoral_u32 count = 0;
3000c0c4:	e3a03000 	mov	r3, #0
3000c0c8:	e58d3014 	str	r3, [sp, #20]

	for (p = s; *p != '\0'; ++p) {
3000c0cc:	e59d3004 	ldr	r3, [sp, #4]
3000c0d0:	e58d300c 	str	r3, [sp, #12]
3000c0d4:	ea000017 	b	3000c138 <acoral_str_cspn+0x80>
		for (r = reject; *r != '\0'; ++r) {
3000c0d8:	e59d3000 	ldr	r3, [sp]
3000c0dc:	e58d3010 	str	r3, [sp, #16]
3000c0e0:	ea00000a 	b	3000c110 <acoral_str_cspn+0x58>
			if (*p == *r)
3000c0e4:	e59d300c 	ldr	r3, [sp, #12]
3000c0e8:	e5d32000 	ldrb	r2, [r3]
3000c0ec:	e59d3010 	ldr	r3, [sp, #16]
3000c0f0:	e5d33000 	ldrb	r3, [r3]
3000c0f4:	e1520003 	cmp	r2, r3
3000c0f8:	1a000001 	bne	3000c104 <acoral_str_cspn+0x4c>
				return count;
3000c0fc:	e59d3014 	ldr	r3, [sp, #20]
3000c100:	ea000011 	b	3000c14c <acoral_str_cspn+0x94>
	const acoral_char *p;
	const acoral_char *r;
	acoral_u32 count = 0;

	for (p = s; *p != '\0'; ++p) {
		for (r = reject; *r != '\0'; ++r) {
3000c104:	e59d3010 	ldr	r3, [sp, #16]
3000c108:	e2833001 	add	r3, r3, #1
3000c10c:	e58d3010 	str	r3, [sp, #16]
3000c110:	e59d3010 	ldr	r3, [sp, #16]
3000c114:	e5d33000 	ldrb	r3, [r3]
3000c118:	e3530000 	cmp	r3, #0
3000c11c:	1afffff0 	bne	3000c0e4 <acoral_str_cspn+0x2c>
			if (*p == *r)
				return count;
		}
		++count;
3000c120:	e59d3014 	ldr	r3, [sp, #20]
3000c124:	e2833001 	add	r3, r3, #1
3000c128:	e58d3014 	str	r3, [sp, #20]
{
	const acoral_char *p;
	const acoral_char *r;
	acoral_u32 count = 0;

	for (p = s; *p != '\0'; ++p) {
3000c12c:	e59d300c 	ldr	r3, [sp, #12]
3000c130:	e2833001 	add	r3, r3, #1
3000c134:	e58d300c 	str	r3, [sp, #12]
3000c138:	e59d300c 	ldr	r3, [sp, #12]
3000c13c:	e5d33000 	ldrb	r3, [r3]
3000c140:	e3530000 	cmp	r3, #0
3000c144:	1affffe3 	bne	3000c0d8 <acoral_str_cspn+0x20>
				return count;
		}
		++count;
	}

	return count;
3000c148:	e59d3014 	ldr	r3, [sp, #20]
}	
3000c14c:	e1a00003 	mov	r0, r3
3000c150:	e28dd018 	add	sp, sp, #24
3000c154:	e12fff1e 	bx	lr

3000c158 <acoral_str_pbrk>:
 * acoral_str_pbrk - Find the first occurrence of a set of characters
 * @cs: The string to be searched
 * @ct: The characters to search for
 */
acoral_char * acoral_str_pbrk(const acoral_char * cs,const acoral_char * ct)
{
3000c158:	e24dd010 	sub	sp, sp, #16
3000c15c:	e58d0004 	str	r0, [sp, #4]
3000c160:	e58d1000 	str	r1, [sp]
	const acoral_char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
3000c164:	e59d3004 	ldr	r3, [sp, #4]
3000c168:	e58d3008 	str	r3, [sp, #8]
3000c16c:	ea000014 	b	3000c1c4 <acoral_str_pbrk+0x6c>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
3000c170:	e59d3000 	ldr	r3, [sp]
3000c174:	e58d300c 	str	r3, [sp, #12]
3000c178:	ea00000a 	b	3000c1a8 <acoral_str_pbrk+0x50>
			if (*sc1 == *sc2)
3000c17c:	e59d3008 	ldr	r3, [sp, #8]
3000c180:	e5d32000 	ldrb	r2, [r3]
3000c184:	e59d300c 	ldr	r3, [sp, #12]
3000c188:	e5d33000 	ldrb	r3, [r3]
3000c18c:	e1520003 	cmp	r2, r3
3000c190:	1a000001 	bne	3000c19c <acoral_str_pbrk+0x44>
				return (acoral_char *) sc1;
3000c194:	e59d3008 	ldr	r3, [sp, #8]
3000c198:	ea00000e 	b	3000c1d8 <acoral_str_pbrk+0x80>
acoral_char * acoral_str_pbrk(const acoral_char * cs,const acoral_char * ct)
{
	const acoral_char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
3000c19c:	e59d300c 	ldr	r3, [sp, #12]
3000c1a0:	e2833001 	add	r3, r3, #1
3000c1a4:	e58d300c 	str	r3, [sp, #12]
3000c1a8:	e59d300c 	ldr	r3, [sp, #12]
3000c1ac:	e5d33000 	ldrb	r3, [r3]
3000c1b0:	e3530000 	cmp	r3, #0
3000c1b4:	1afffff0 	bne	3000c17c <acoral_str_pbrk+0x24>
 */
acoral_char * acoral_str_pbrk(const acoral_char * cs,const acoral_char * ct)
{
	const acoral_char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
3000c1b8:	e59d3008 	ldr	r3, [sp, #8]
3000c1bc:	e2833001 	add	r3, r3, #1
3000c1c0:	e58d3008 	str	r3, [sp, #8]
3000c1c4:	e59d3008 	ldr	r3, [sp, #8]
3000c1c8:	e5d33000 	ldrb	r3, [r3]
3000c1cc:	e3530000 	cmp	r3, #0
3000c1d0:	1affffe6 	bne	3000c170 <acoral_str_pbrk+0x18>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
				return (acoral_char *) sc1;
		}
	}
	return NULL;
3000c1d4:	e3a03000 	mov	r3, #0
}
3000c1d8:	e1a00003 	mov	r0, r3
3000c1dc:	e28dd010 	add	sp, sp, #16
3000c1e0:	e12fff1e 	bx	lr

3000c1e4 <acoral_str_sep>:
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
acoral_char * acoral_str_sep(acoral_char **s, const acoral_char *ct)
{
3000c1e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000c1e8:	e24dd014 	sub	sp, sp, #20
3000c1ec:	e58d0004 	str	r0, [sp, #4]
3000c1f0:	e58d1000 	str	r1, [sp]
	acoral_char *sbegin = *s, *end;
3000c1f4:	e59d3004 	ldr	r3, [sp, #4]
3000c1f8:	e5933000 	ldr	r3, [r3]
3000c1fc:	e58d3008 	str	r3, [sp, #8]

	if (sbegin == NULL)
3000c200:	e59d3008 	ldr	r3, [sp, #8]
3000c204:	e3530000 	cmp	r3, #0
3000c208:	1a000001 	bne	3000c214 <acoral_str_sep+0x30>
		return NULL;
3000c20c:	e3a03000 	mov	r3, #0
3000c210:	ea000011 	b	3000c25c <acoral_str_sep+0x78>

	end = acoral_str_pbrk(sbegin, ct);
3000c214:	e59d0008 	ldr	r0, [sp, #8]
3000c218:	e59d1000 	ldr	r1, [sp]
3000c21c:	ebffffcd 	bl	3000c158 <acoral_str_pbrk>
3000c220:	e1a03000 	mov	r3, r0
3000c224:	e58d300c 	str	r3, [sp, #12]
	if (end)
3000c228:	e59d300c 	ldr	r3, [sp, #12]
3000c22c:	e3530000 	cmp	r3, #0
3000c230:	0a000005 	beq	3000c24c <acoral_str_sep+0x68>
		*end++ = '\0';
3000c234:	e59d300c 	ldr	r3, [sp, #12]
3000c238:	e3a02000 	mov	r2, #0
3000c23c:	e5c32000 	strb	r2, [r3]
3000c240:	e59d300c 	ldr	r3, [sp, #12]
3000c244:	e2833001 	add	r3, r3, #1
3000c248:	e58d300c 	str	r3, [sp, #12]
	*s = end;
3000c24c:	e59d3004 	ldr	r3, [sp, #4]
3000c250:	e59d200c 	ldr	r2, [sp, #12]
3000c254:	e5832000 	str	r2, [r3]

	return sbegin;
3000c258:	e59d3008 	ldr	r3, [sp, #8]
}
3000c25c:	e1a00003 	mov	r0, r3
3000c260:	e28dd014 	add	sp, sp, #20
3000c264:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000c268:	e12fff1e 	bx	lr

3000c26c <acoral_memset>:
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * acoral_memset(void * s,acoral_char c,acoral_u32 count)
{
3000c26c:	e24dd018 	sub	sp, sp, #24
3000c270:	e58d000c 	str	r0, [sp, #12]
3000c274:	e1a03001 	mov	r3, r1
3000c278:	e58d2004 	str	r2, [sp, #4]
3000c27c:	e5cd300b 	strb	r3, [sp, #11]
	acoral_char *xs = (acoral_char *) s;
3000c280:	e59d300c 	ldr	r3, [sp, #12]
3000c284:	e58d3014 	str	r3, [sp, #20]

	while (count--)
3000c288:	ea000005 	b	3000c2a4 <acoral_memset+0x38>
		*xs++ = c;
3000c28c:	e59d3014 	ldr	r3, [sp, #20]
3000c290:	e5dd200b 	ldrb	r2, [sp, #11]
3000c294:	e5c32000 	strb	r2, [r3]
3000c298:	e59d3014 	ldr	r3, [sp, #20]
3000c29c:	e2833001 	add	r3, r3, #1
3000c2a0:	e58d3014 	str	r3, [sp, #20]
 */
void * acoral_memset(void * s,acoral_char c,acoral_u32 count)
{
	acoral_char *xs = (acoral_char *) s;

	while (count--)
3000c2a4:	e59d3004 	ldr	r3, [sp, #4]
3000c2a8:	e3530000 	cmp	r3, #0
3000c2ac:	03a03000 	moveq	r3, #0
3000c2b0:	13a03001 	movne	r3, #1
3000c2b4:	e20330ff 	and	r3, r3, #255	; 0xff
3000c2b8:	e59d2004 	ldr	r2, [sp, #4]
3000c2bc:	e2422001 	sub	r2, r2, #1
3000c2c0:	e58d2004 	str	r2, [sp, #4]
3000c2c4:	e3530000 	cmp	r3, #0
3000c2c8:	1affffef 	bne	3000c28c <acoral_memset+0x20>
		*xs++ = c;

	return s;
3000c2cc:	e59d300c 	ldr	r3, [sp, #12]
}
3000c2d0:	e1a00003 	mov	r0, r3
3000c2d4:	e28dd018 	add	sp, sp, #24
3000c2d8:	e12fff1e 	bx	lr

3000c2dc <acoral_memcpy>:
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * acoral_memcpy(void * dest,const void *src,acoral_u32 count)
{
3000c2dc:	e24dd018 	sub	sp, sp, #24
3000c2e0:	e58d000c 	str	r0, [sp, #12]
3000c2e4:	e58d1008 	str	r1, [sp, #8]
3000c2e8:	e58d2004 	str	r2, [sp, #4]
	acoral_char *tmp = (acoral_char *) dest, *s = (acoral_char *) src;
3000c2ec:	e59d300c 	ldr	r3, [sp, #12]
3000c2f0:	e58d3010 	str	r3, [sp, #16]
3000c2f4:	e59d3008 	ldr	r3, [sp, #8]
3000c2f8:	e58d3014 	str	r3, [sp, #20]

	while (count--)
3000c2fc:	ea000009 	b	3000c328 <acoral_memcpy+0x4c>
		*tmp++ = *s++;
3000c300:	e59d3014 	ldr	r3, [sp, #20]
3000c304:	e5d32000 	ldrb	r2, [r3]
3000c308:	e59d3010 	ldr	r3, [sp, #16]
3000c30c:	e5c32000 	strb	r2, [r3]
3000c310:	e59d3010 	ldr	r3, [sp, #16]
3000c314:	e2833001 	add	r3, r3, #1
3000c318:	e58d3010 	str	r3, [sp, #16]
3000c31c:	e59d3014 	ldr	r3, [sp, #20]
3000c320:	e2833001 	add	r3, r3, #1
3000c324:	e58d3014 	str	r3, [sp, #20]
 */
void * acoral_memcpy(void * dest,const void *src,acoral_u32 count)
{
	acoral_char *tmp = (acoral_char *) dest, *s = (acoral_char *) src;

	while (count--)
3000c328:	e59d3004 	ldr	r3, [sp, #4]
3000c32c:	e3530000 	cmp	r3, #0
3000c330:	03a03000 	moveq	r3, #0
3000c334:	13a03001 	movne	r3, #1
3000c338:	e20330ff 	and	r3, r3, #255	; 0xff
3000c33c:	e59d2004 	ldr	r2, [sp, #4]
3000c340:	e2422001 	sub	r2, r2, #1
3000c344:	e58d2004 	str	r2, [sp, #4]
3000c348:	e3530000 	cmp	r3, #0
3000c34c:	1affffeb 	bne	3000c300 <acoral_memcpy+0x24>
		*tmp++ = *s++;

	return dest;
3000c350:	e59d300c 	ldr	r3, [sp, #12]
}
3000c354:	e1a00003 	mov	r0, r3
3000c358:	e28dd018 	add	sp, sp, #24
3000c35c:	e12fff1e 	bx	lr

3000c360 <acoral_memmove>:
 * @count: The size of the area.
 *
 * Unlike memcpy(), memmove() copes with overlapping areas.
 */
void * acoral_memmove(void * dest,const void *src,acoral_u32 count)
{
3000c360:	e24dd018 	sub	sp, sp, #24
3000c364:	e58d000c 	str	r0, [sp, #12]
3000c368:	e58d1008 	str	r1, [sp, #8]
3000c36c:	e58d2004 	str	r2, [sp, #4]
	acoral_char *tmp, *s;

	if (dest <= src) {
3000c370:	e59d200c 	ldr	r2, [sp, #12]
3000c374:	e59d3008 	ldr	r3, [sp, #8]
3000c378:	e1520003 	cmp	r2, r3
3000c37c:	8a000019 	bhi	3000c3e8 <acoral_memmove+0x88>
		tmp = (acoral_char *) dest;
3000c380:	e59d300c 	ldr	r3, [sp, #12]
3000c384:	e58d3010 	str	r3, [sp, #16]
		s = (acoral_char *) src;
3000c388:	e59d3008 	ldr	r3, [sp, #8]
3000c38c:	e58d3014 	str	r3, [sp, #20]
		while (count--)
3000c390:	ea000009 	b	3000c3bc <acoral_memmove+0x5c>
			*tmp++ = *s++;
3000c394:	e59d3014 	ldr	r3, [sp, #20]
3000c398:	e5d32000 	ldrb	r2, [r3]
3000c39c:	e59d3010 	ldr	r3, [sp, #16]
3000c3a0:	e5c32000 	strb	r2, [r3]
3000c3a4:	e59d3010 	ldr	r3, [sp, #16]
3000c3a8:	e2833001 	add	r3, r3, #1
3000c3ac:	e58d3010 	str	r3, [sp, #16]
3000c3b0:	e59d3014 	ldr	r3, [sp, #20]
3000c3b4:	e2833001 	add	r3, r3, #1
3000c3b8:	e58d3014 	str	r3, [sp, #20]
	acoral_char *tmp, *s;

	if (dest <= src) {
		tmp = (acoral_char *) dest;
		s = (acoral_char *) src;
		while (count--)
3000c3bc:	e59d3004 	ldr	r3, [sp, #4]
3000c3c0:	e3530000 	cmp	r3, #0
3000c3c4:	03a03000 	moveq	r3, #0
3000c3c8:	13a03001 	movne	r3, #1
3000c3cc:	e20330ff 	and	r3, r3, #255	; 0xff
3000c3d0:	e59d2004 	ldr	r2, [sp, #4]
3000c3d4:	e2422001 	sub	r2, r2, #1
3000c3d8:	e58d2004 	str	r2, [sp, #4]
3000c3dc:	e3530000 	cmp	r3, #0
3000c3e0:	1affffeb 	bne	3000c394 <acoral_memmove+0x34>
3000c3e4:	ea00001c 	b	3000c45c <acoral_memmove+0xfc>
			*tmp++ = *s++;
		}
	else {
		tmp = (acoral_char *) dest + count;
3000c3e8:	e59d200c 	ldr	r2, [sp, #12]
3000c3ec:	e59d3004 	ldr	r3, [sp, #4]
3000c3f0:	e0823003 	add	r3, r2, r3
3000c3f4:	e58d3010 	str	r3, [sp, #16]
		s = (acoral_char *) src + count;
3000c3f8:	e59d2008 	ldr	r2, [sp, #8]
3000c3fc:	e59d3004 	ldr	r3, [sp, #4]
3000c400:	e0823003 	add	r3, r2, r3
3000c404:	e58d3014 	str	r3, [sp, #20]
		while (count--)
3000c408:	ea000009 	b	3000c434 <acoral_memmove+0xd4>
			*--tmp = *--s;
3000c40c:	e59d3010 	ldr	r3, [sp, #16]
3000c410:	e2433001 	sub	r3, r3, #1
3000c414:	e58d3010 	str	r3, [sp, #16]
3000c418:	e59d3014 	ldr	r3, [sp, #20]
3000c41c:	e2433001 	sub	r3, r3, #1
3000c420:	e58d3014 	str	r3, [sp, #20]
3000c424:	e59d3014 	ldr	r3, [sp, #20]
3000c428:	e5d32000 	ldrb	r2, [r3]
3000c42c:	e59d3010 	ldr	r3, [sp, #16]
3000c430:	e5c32000 	strb	r2, [r3]
			*tmp++ = *s++;
		}
	else {
		tmp = (acoral_char *) dest + count;
		s = (acoral_char *) src + count;
		while (count--)
3000c434:	e59d3004 	ldr	r3, [sp, #4]
3000c438:	e3530000 	cmp	r3, #0
3000c43c:	03a03000 	moveq	r3, #0
3000c440:	13a03001 	movne	r3, #1
3000c444:	e20330ff 	and	r3, r3, #255	; 0xff
3000c448:	e59d2004 	ldr	r2, [sp, #4]
3000c44c:	e2422001 	sub	r2, r2, #1
3000c450:	e58d2004 	str	r2, [sp, #4]
3000c454:	e3530000 	cmp	r3, #0
3000c458:	1affffeb 	bne	3000c40c <acoral_memmove+0xac>
			*--tmp = *--s;
		}

	return dest;
3000c45c:	e59d300c 	ldr	r3, [sp, #12]
}
3000c460:	e1a00003 	mov	r0, r3
3000c464:	e28dd018 	add	sp, sp, #24
3000c468:	e12fff1e 	bx	lr

3000c46c <acoral_memcmp>:
 * @cs: One area of memory
 * @ct: Another area of memory
 * @count: The size of the area.
 */
acoral_32 acoral_memcmp(const void * cs,const void * ct,acoral_u32 count)
{
3000c46c:	e24dd020 	sub	sp, sp, #32
3000c470:	e58d000c 	str	r0, [sp, #12]
3000c474:	e58d1008 	str	r1, [sp, #8]
3000c478:	e58d2004 	str	r2, [sp, #4]
	const acoral_u8 *su1, *su2;
	acoral_32 res = 0;
3000c47c:	e3a03000 	mov	r3, #0
3000c480:	e58d301c 	str	r3, [sp, #28]

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
3000c484:	e59d300c 	ldr	r3, [sp, #12]
3000c488:	e58d3014 	str	r3, [sp, #20]
3000c48c:	e59d3008 	ldr	r3, [sp, #8]
3000c490:	e58d3018 	str	r3, [sp, #24]
3000c494:	ea000012 	b	3000c4e4 <acoral_memcmp+0x78>
		if ((res = *su1 - *su2) != 0)
3000c498:	e59d3014 	ldr	r3, [sp, #20]
3000c49c:	e5d33000 	ldrb	r3, [r3]
3000c4a0:	e1a02003 	mov	r2, r3
3000c4a4:	e59d3018 	ldr	r3, [sp, #24]
3000c4a8:	e5d33000 	ldrb	r3, [r3]
3000c4ac:	e0633002 	rsb	r3, r3, r2
3000c4b0:	e58d301c 	str	r3, [sp, #28]
3000c4b4:	e59d301c 	ldr	r3, [sp, #28]
3000c4b8:	e3530000 	cmp	r3, #0
3000c4bc:	1a00000c 	bne	3000c4f4 <acoral_memcmp+0x88>
acoral_32 acoral_memcmp(const void * cs,const void * ct,acoral_u32 count)
{
	const acoral_u8 *su1, *su2;
	acoral_32 res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
3000c4c0:	e59d3014 	ldr	r3, [sp, #20]
3000c4c4:	e2833001 	add	r3, r3, #1
3000c4c8:	e58d3014 	str	r3, [sp, #20]
3000c4cc:	e59d3018 	ldr	r3, [sp, #24]
3000c4d0:	e2833001 	add	r3, r3, #1
3000c4d4:	e58d3018 	str	r3, [sp, #24]
3000c4d8:	e59d3004 	ldr	r3, [sp, #4]
3000c4dc:	e2433001 	sub	r3, r3, #1
3000c4e0:	e58d3004 	str	r3, [sp, #4]
3000c4e4:	e59d3004 	ldr	r3, [sp, #4]
3000c4e8:	e3530000 	cmp	r3, #0
3000c4ec:	1affffe9 	bne	3000c498 <acoral_memcmp+0x2c>
3000c4f0:	ea000000 	b	3000c4f8 <acoral_memcmp+0x8c>
		if ((res = *su1 - *su2) != 0)
			break;
3000c4f4:	e1a00000 	nop			; (mov r0, r0)
	return res;
3000c4f8:	e59d301c 	ldr	r3, [sp, #28]
}
3000c4fc:	e1a00003 	mov	r0, r3
3000c500:	e28dd020 	add	sp, sp, #32
3000c504:	e12fff1e 	bx	lr

3000c508 <acoral_memscan>:
 *
 * returns the address of the first occurrence of @c, or 1 byte past
 * the area if @c is not found
 */
void * acoral_memscan(void * addr, acoral_32 c, acoral_u32 size)
{
3000c508:	e24dd018 	sub	sp, sp, #24
3000c50c:	e58d000c 	str	r0, [sp, #12]
3000c510:	e58d1008 	str	r1, [sp, #8]
3000c514:	e58d2004 	str	r2, [sp, #4]
	acoral_u8 * p = (acoral_u8 *) addr;
3000c518:	e59d300c 	ldr	r3, [sp, #12]
3000c51c:	e58d3014 	str	r3, [sp, #20]

	while (size) {
3000c520:	ea00000d 	b	3000c55c <acoral_memscan+0x54>
		if (*p == c)
3000c524:	e59d3014 	ldr	r3, [sp, #20]
3000c528:	e5d33000 	ldrb	r3, [r3]
3000c52c:	e1a02003 	mov	r2, r3
3000c530:	e59d3008 	ldr	r3, [sp, #8]
3000c534:	e1520003 	cmp	r2, r3
3000c538:	1a000001 	bne	3000c544 <acoral_memscan+0x3c>
			return (void *) p;
3000c53c:	e59d3014 	ldr	r3, [sp, #20]
3000c540:	ea000009 	b	3000c56c <acoral_memscan+0x64>
		p++;
3000c544:	e59d3014 	ldr	r3, [sp, #20]
3000c548:	e2833001 	add	r3, r3, #1
3000c54c:	e58d3014 	str	r3, [sp, #20]
		size--;
3000c550:	e59d3004 	ldr	r3, [sp, #4]
3000c554:	e2433001 	sub	r3, r3, #1
3000c558:	e58d3004 	str	r3, [sp, #4]
 */
void * acoral_memscan(void * addr, acoral_32 c, acoral_u32 size)
{
	acoral_u8 * p = (acoral_u8 *) addr;

	while (size) {
3000c55c:	e59d3004 	ldr	r3, [sp, #4]
3000c560:	e3530000 	cmp	r3, #0
3000c564:	1affffee 	bne	3000c524 <acoral_memscan+0x1c>
		if (*p == c)
			return (void *) p;
		p++;
		size--;
	}
  	return (void *) p;
3000c568:	e59d3014 	ldr	r3, [sp, #20]
}
3000c56c:	e1a00003 	mov	r0, r3
3000c570:	e28dd018 	add	sp, sp, #24
3000c574:	e12fff1e 	bx	lr

3000c578 <acoral_strstr>:
 * acoral_strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
acoral_char * acoral_strstr(const acoral_char * s1,const acoral_char * s2)
{
3000c578:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000c57c:	e24dd014 	sub	sp, sp, #20
3000c580:	e58d0004 	str	r0, [sp, #4]
3000c584:	e58d1000 	str	r1, [sp]
	acoral_32 l1, l2;

	l2 = acoral_str_len(s2);
3000c588:	e59d0000 	ldr	r0, [sp]
3000c58c:	ebfffc69 	bl	3000b738 <acoral_str_len>
3000c590:	e1a03000 	mov	r3, r0
3000c594:	e58d300c 	str	r3, [sp, #12]
	if (!l2)
3000c598:	e59d300c 	ldr	r3, [sp, #12]
3000c59c:	e3530000 	cmp	r3, #0
3000c5a0:	1a000001 	bne	3000c5ac <acoral_strstr+0x34>
		return (acoral_char *) s1;
3000c5a4:	e59d3004 	ldr	r3, [sp, #4]
3000c5a8:	ea000019 	b	3000c614 <acoral_strstr+0x9c>
	l1 = acoral_str_len(s1);
3000c5ac:	e59d0004 	ldr	r0, [sp, #4]
3000c5b0:	ebfffc60 	bl	3000b738 <acoral_str_len>
3000c5b4:	e1a03000 	mov	r3, r0
3000c5b8:	e58d3008 	str	r3, [sp, #8]
	while (l1 >= l2) {
3000c5bc:	ea00000f 	b	3000c600 <acoral_strstr+0x88>
		l1--;
3000c5c0:	e59d3008 	ldr	r3, [sp, #8]
3000c5c4:	e2433001 	sub	r3, r3, #1
3000c5c8:	e58d3008 	str	r3, [sp, #8]
		if (!acoral_memcmp(s1,s2,l2))
3000c5cc:	e59d300c 	ldr	r3, [sp, #12]
3000c5d0:	e59d0004 	ldr	r0, [sp, #4]
3000c5d4:	e59d1000 	ldr	r1, [sp]
3000c5d8:	e1a02003 	mov	r2, r3
3000c5dc:	ebffffa2 	bl	3000c46c <acoral_memcmp>
3000c5e0:	e1a03000 	mov	r3, r0
3000c5e4:	e3530000 	cmp	r3, #0
3000c5e8:	1a000001 	bne	3000c5f4 <acoral_strstr+0x7c>
			return (acoral_char *) s1;
3000c5ec:	e59d3004 	ldr	r3, [sp, #4]
3000c5f0:	ea000007 	b	3000c614 <acoral_strstr+0x9c>
		s1++;
3000c5f4:	e59d3004 	ldr	r3, [sp, #4]
3000c5f8:	e2833001 	add	r3, r3, #1
3000c5fc:	e58d3004 	str	r3, [sp, #4]

	l2 = acoral_str_len(s2);
	if (!l2)
		return (acoral_char *) s1;
	l1 = acoral_str_len(s1);
	while (l1 >= l2) {
3000c600:	e59d2008 	ldr	r2, [sp, #8]
3000c604:	e59d300c 	ldr	r3, [sp, #12]
3000c608:	e1520003 	cmp	r2, r3
3000c60c:	aaffffeb 	bge	3000c5c0 <acoral_strstr+0x48>
		l1--;
		if (!acoral_memcmp(s1,s2,l2))
			return (acoral_char *) s1;
		s1++;
	}
	return NULL;
3000c610:	e3a03000 	mov	r3, #0
}
3000c614:	e1a00003 	mov	r0, r3
3000c618:	e28dd014 	add	sp, sp, #20
3000c61c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000c620:	e12fff1e 	bx	lr

3000c624 <acoral_memchr>:
 *
 * returns the address of the first occurrence of @c, or %NULL
 * if @c is not found
 */
void *acoral_memchr(const void *s, acoral_32 c, acoral_u32 n)
{
3000c624:	e24dd018 	sub	sp, sp, #24
3000c628:	e58d000c 	str	r0, [sp, #12]
3000c62c:	e58d1008 	str	r1, [sp, #8]
3000c630:	e58d2004 	str	r2, [sp, #4]
	const acoral_u8 *p = s;
3000c634:	e59d300c 	ldr	r3, [sp, #12]
3000c638:	e58d3014 	str	r3, [sp, #20]
	while (n-- != 0) {
3000c63c:	ea00000f 	b	3000c680 <acoral_memchr+0x5c>
        	if ((acoral_u8)c == *p++) {
3000c640:	e59d3008 	ldr	r3, [sp, #8]
3000c644:	e20320ff 	and	r2, r3, #255	; 0xff
3000c648:	e59d3014 	ldr	r3, [sp, #20]
3000c64c:	e5d33000 	ldrb	r3, [r3]
3000c650:	e1520003 	cmp	r2, r3
3000c654:	13a03000 	movne	r3, #0
3000c658:	03a03001 	moveq	r3, #1
3000c65c:	e20330ff 	and	r3, r3, #255	; 0xff
3000c660:	e59d2014 	ldr	r2, [sp, #20]
3000c664:	e2822001 	add	r2, r2, #1
3000c668:	e58d2014 	str	r2, [sp, #20]
3000c66c:	e3530000 	cmp	r3, #0
3000c670:	0a000002 	beq	3000c680 <acoral_memchr+0x5c>
			return (void *)(p-1);
3000c674:	e59d3014 	ldr	r3, [sp, #20]
3000c678:	e2433001 	sub	r3, r3, #1
3000c67c:	ea00000a 	b	3000c6ac <acoral_memchr+0x88>
 * if @c is not found
 */
void *acoral_memchr(const void *s, acoral_32 c, acoral_u32 n)
{
	const acoral_u8 *p = s;
	while (n-- != 0) {
3000c680:	e59d3004 	ldr	r3, [sp, #4]
3000c684:	e3530000 	cmp	r3, #0
3000c688:	03a03000 	moveq	r3, #0
3000c68c:	13a03001 	movne	r3, #1
3000c690:	e20330ff 	and	r3, r3, #255	; 0xff
3000c694:	e59d2004 	ldr	r2, [sp, #4]
3000c698:	e2422001 	sub	r2, r2, #1
3000c69c:	e58d2004 	str	r2, [sp, #4]
3000c6a0:	e3530000 	cmp	r3, #0
3000c6a4:	1affffe5 	bne	3000c640 <acoral_memchr+0x1c>
        	if ((acoral_u8)c == *p++) {
			return (void *)(p-1);
		}
	}
	return NULL;
3000c6a8:	e3a03000 	mov	r3, #0
}
3000c6ac:	e1a00003 	mov	r0, r3
3000c6b0:	e28dd018 	add	sp, sp, #24
3000c6b4:	e12fff1e 	bx	lr

3000c6b8 <acoral_rand>:
#include<acoral.h>
static acoral_u32 rand_seed;
acoral_u32 acoral_rand(void)
{
	rand_seed=(rand_seed*123+59)%65536;
3000c6b8:	e59f3038 	ldr	r3, [pc, #56]	; 3000c6f8 <acoral_rand+0x40>
3000c6bc:	e5932000 	ldr	r2, [r3]
3000c6c0:	e1a03002 	mov	r3, r2
3000c6c4:	e1a03283 	lsl	r3, r3, #5
3000c6c8:	e0623003 	rsb	r3, r2, r3
3000c6cc:	e1a03103 	lsl	r3, r3, #2
3000c6d0:	e0623003 	rsb	r3, r2, r3
3000c6d4:	e283303b 	add	r3, r3, #59	; 0x3b
3000c6d8:	e1a03803 	lsl	r3, r3, #16
3000c6dc:	e1a03823 	lsr	r3, r3, #16
3000c6e0:	e59f2010 	ldr	r2, [pc, #16]	; 3000c6f8 <acoral_rand+0x40>
3000c6e4:	e5823000 	str	r3, [r2]
	return rand_seed;
3000c6e8:	e59f3008 	ldr	r3, [pc, #8]	; 3000c6f8 <acoral_rand+0x40>
3000c6ec:	e5933000 	ldr	r3, [r3]
}
3000c6f0:	e1a00003 	mov	r0, r3
3000c6f4:	e12fff1e 	bx	lr
3000c6f8:	300ca5dc 	.word	0x300ca5dc

3000c6fc <acoral_rand_start>:

void acoral_rand_start(void)
{
3000c6fc:	e92d4008 	push	{r3, lr}
	rand_seed=acoral_ticks;
3000c700:	ebffdf85 	bl	3000451c <acoral_get_ticks>
3000c704:	e1a02000 	mov	r2, r0
3000c708:	e59f3008 	ldr	r3, [pc, #8]	; 3000c718 <acoral_rand_start+0x1c>
3000c70c:	e5832000 	str	r2, [r3]
}
3000c710:	e8bd4008 	pop	{r3, lr}
3000c714:	e12fff1e 	bx	lr
3000c718:	300ca5dc 	.word	0x300ca5dc

3000c71c <plugin_init>:
#include<acoral.h>
#include<plugin.h>
void plugin_init(){
3000c71c:	e92d4008 	push	{r3, lr}
#ifdef CFG_PLUGIN_NET
	acoral_net_lwip_init();
3000c720:	eb00002c 	bl	3000c7d8 <acoral_net_lwip_init>
#endif
#ifdef CFG_PLUGIN_FS
	acoral_fs_init();
3000c724:	eb007c83 	bl	3002b938 <acoral_fs_init>
#endif

#ifdef CFG_PLUGIN_GUI
	acoral_gui_init();
#endif
}
3000c728:	e8bd4008 	pop	{r3, lr}
3000c72c:	e12fff1e 	bx	lr

3000c730 <my_lwip_init>:
err_t ethernetif_init(struct netif *netif);
void  tcpip_init(void (* initfunc)(void *), void *arg);
void  ethernetif_input(void *arg);

void  my_lwip_init(void)
{  	
3000c730:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000c734:	e24dd024 	sub	sp, sp, #36	; 0x24
	struct ip_addr ipaddr, netmask, gw;
	u8_t bTemp;

	tcpip_init(NULL, NULL);
3000c738:	e3a00000 	mov	r0, #0
3000c73c:	e3a01000 	mov	r1, #0
3000c740:	eb0017a8 	bl	300125e8 <tcpip_init>
	IP4_ADDR(&gw, 192,168,1,1);
3000c744:	e3a00c01 	mov	r0, #256	; 0x100
3000c748:	e2800107 	add	r0, r0, #-1073741823	; 0xc0000001
3000c74c:	e280072a 	add	r0, r0, #11010048	; 0xa80000
3000c750:	eb001bc9 	bl	3001367c <htonl>
3000c754:	e1a03000 	mov	r3, r0
3000c758:	e58d3010 	str	r3, [sp, #16]
	IP4_ADDR(&ipaddr, 192,168,1,2);
3000c75c:	e3a00c01 	mov	r0, #256	; 0x100
3000c760:	e280010b 	add	r0, r0, #-1073741822	; 0xc0000002
3000c764:	e280072a 	add	r0, r0, #11010048	; 0xa80000
3000c768:	eb001bc3 	bl	3001367c <htonl>
3000c76c:	e1a03000 	mov	r3, r0
3000c770:	e58d3018 	str	r3, [sp, #24]
	IP4_ADDR(&netmask, 255,255,255,0);
3000c774:	e3e000ff 	mvn	r0, #255	; 0xff
3000c778:	eb001bbf 	bl	3001367c <htonl>
3000c77c:	e1a03000 	mov	r3, r0
3000c780:	e58d3014 	str	r3, [sp, #20]
	netif_add(&net_if, &ipaddr, &netmask, &gw, NULL, ethernetif_init, tcpip_input);  
3000c784:	e28d1018 	add	r1, sp, #24
3000c788:	e28d2014 	add	r2, sp, #20
3000c78c:	e28d3010 	add	r3, sp, #16
3000c790:	e3a00000 	mov	r0, #0
3000c794:	e58d0000 	str	r0, [sp]
3000c798:	e59f002c 	ldr	r0, [pc, #44]	; 3000c7cc <my_lwip_init+0x9c>
3000c79c:	e58d0004 	str	r0, [sp, #4]
3000c7a0:	e59f0028 	ldr	r0, [pc, #40]	; 3000c7d0 <my_lwip_init+0xa0>
3000c7a4:	e58d0008 	str	r0, [sp, #8]
3000c7a8:	e59f0024 	ldr	r0, [pc, #36]	; 3000c7d4 <my_lwip_init+0xa4>
3000c7ac:	eb002376 	bl	3001558c <netif_add>
	netif_set_default(&net_if);
3000c7b0:	e59f001c 	ldr	r0, [pc, #28]	; 3000c7d4 <my_lwip_init+0xa4>
3000c7b4:	eb0024c4 	bl	30015acc <netif_set_default>
	netif_set_up(&net_if);	 
3000c7b8:	e59f0014 	ldr	r0, [pc, #20]	; 3000c7d4 <my_lwip_init+0xa4>
3000c7bc:	eb0024ca 	bl	30015aec <netif_set_up>
}
3000c7c0:	e28dd024 	add	sp, sp, #36	; 0x24
3000c7c4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000c7c8:	e12fff1e 	bx	lr
3000c7cc:	300234d0 	.word	0x300234d0
3000c7d0:	300122f4 	.word	0x300122f4
3000c7d4:	3012ac58 	.word	0x3012ac58

3000c7d8 <acoral_net_lwip_init>:


void acoral_net_lwip_init()
{
3000c7d8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000c7dc:	e24dd00c 	sub	sp, sp, #12
	//acoral_prints("\r\nacoral_net_lwip_init\r\n");
	my_lwip_init();
3000c7e0:	ebffffd2 	bl	3000c730 <my_lwip_init>
	//sys_thread_new("RecvData", ethernetif_input, &net_if, 8192+1024, ETH_RECV_TASK_PPIO);
	sys_thread_new("RecvData", ethernetif_input, &net_if, 81920*2, ETH_RECV_TASK_PPIO);
3000c7e4:	e3a03014 	mov	r3, #20
3000c7e8:	e58d3000 	str	r3, [sp]
3000c7ec:	e59f0018 	ldr	r0, [pc, #24]	; 3000c80c <acoral_net_lwip_init+0x34>
3000c7f0:	e59f1018 	ldr	r1, [pc, #24]	; 3000c810 <acoral_net_lwip_init+0x38>
3000c7f4:	e59f2018 	ldr	r2, [pc, #24]	; 3000c814 <acoral_net_lwip_init+0x3c>
3000c7f8:	e3a0390a 	mov	r3, #163840	; 0x28000
3000c7fc:	eb0000da 	bl	3000cb6c <sys_thread_new>
}
3000c800:	e28dd00c 	add	sp, sp, #12
3000c804:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000c808:	e12fff1e 	bx	lr
3000c80c:	30045680 	.word	0x30045680
3000c810:	300233b4 	.word	0x300233b4
3000c814:	3012ac58 	.word	0x3012ac58

3000c818 <sys_init>:

/*-----------------------------
   void sys_init()
 */
void sys_init(void)
{
3000c818:	e24dd008 	sub	sp, sp, #8
	int i;
	
    timeoutslist = &nulltimeouts;
3000c81c:	e59f30a4 	ldr	r3, [pc, #164]	; 3000c8c8 <sys_init+0xb0>
3000c820:	e59f20a4 	ldr	r2, [pc, #164]	; 3000c8cc <sys_init+0xb4>
3000c824:	e5832000 	str	r2, [r3]
    
    nulltimeouts.timeouts.next = NULL; 
3000c828:	e59f309c 	ldr	r3, [pc, #156]	; 3000c8cc <sys_init+0xb4>
3000c82c:	e3a02000 	mov	r2, #0
3000c830:	e5832000 	str	r2, [r3]
    
    nulltimeouts.next = NULL;
3000c834:	e59f3090 	ldr	r3, [pc, #144]	; 3000c8cc <sys_init+0xb4>
3000c838:	e3a02000 	mov	r2, #0
3000c83c:	e5832008 	str	r2, [r3, #8]
    
    /* timeoutnodes init */
    timeoutnodes.flag = 0;
3000c840:	e59f3088 	ldr	r3, [pc, #136]	; 3000c8d0 <sys_init+0xb8>
3000c844:	e3a02000 	mov	r2, #0
3000c848:	e5832048 	str	r2, [r3, #72]	; 0x48
    for(i=0; i<TCPIP_THREAD_MAXNUM; i++)
3000c84c:	e3a03000 	mov	r3, #0
3000c850:	e58d3004 	str	r3, [sp, #4]
3000c854:	ea000016 	b	3000c8b4 <sys_init+0x9c>
    {
    	timeoutnodes.p[i].next = NULL;  /*��ʼ��Ϊδʹ��*/
3000c858:	e59d2004 	ldr	r2, [sp, #4]
3000c85c:	e59f006c 	ldr	r0, [pc, #108]	; 3000c8d0 <sys_init+0xb8>
3000c860:	e3a01008 	mov	r1, #8
3000c864:	e1a03002 	mov	r3, r2
3000c868:	e1a03083 	lsl	r3, r3, #1
3000c86c:	e0833002 	add	r3, r3, r2
3000c870:	e1a03103 	lsl	r3, r3, #2
3000c874:	e0833000 	add	r3, r3, r0
3000c878:	e0833001 	add	r3, r3, r1
3000c87c:	e3a02000 	mov	r2, #0
3000c880:	e5832000 	str	r2, [r3]
    	timeoutnodes.p[i].timeouts.next = NULL;
3000c884:	e59d2004 	ldr	r2, [sp, #4]
3000c888:	e59f1040 	ldr	r1, [pc, #64]	; 3000c8d0 <sys_init+0xb8>
3000c88c:	e1a03002 	mov	r3, r2
3000c890:	e1a03083 	lsl	r3, r3, #1
3000c894:	e0833002 	add	r3, r3, r2
3000c898:	e1a03103 	lsl	r3, r3, #2
3000c89c:	e0833001 	add	r3, r3, r1
3000c8a0:	e3a02000 	mov	r2, #0
3000c8a4:	e5832000 	str	r2, [r3]
    
    nulltimeouts.next = NULL;
    
    /* timeoutnodes init */
    timeoutnodes.flag = 0;
    for(i=0; i<TCPIP_THREAD_MAXNUM; i++)
3000c8a8:	e59d3004 	ldr	r3, [sp, #4]
3000c8ac:	e2833001 	add	r3, r3, #1
3000c8b0:	e58d3004 	str	r3, [sp, #4]
3000c8b4:	e59d3004 	ldr	r3, [sp, #4]
3000c8b8:	e3530004 	cmp	r3, #4
3000c8bc:	daffffe5 	ble	3000c858 <sys_init+0x40>
    {
    	timeoutnodes.p[i].next = NULL;  /*��ʼ��Ϊδʹ��*/
    	timeoutnodes.p[i].timeouts.next = NULL;
    }
    
}
3000c8c0:	e28dd008 	add	sp, sp, #8
3000c8c4:	e12fff1e 	bx	lr
3000c8c8:	301f57a0 	.word	0x301f57a0
3000c8cc:	300ea31c 	.word	0x300ea31c
3000c8d0:	302be520 	.word	0x302be520

3000c8d4 <sys_sem_new>:

/*----------------------------
	sys_sem_t sys_sem_new(u8_t count)
 */
sys_sem_t sys_sem_new(u8_t count)
{
3000c8d4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000c8d8:	e24dd00c 	sub	sp, sp, #12
3000c8dc:	e1a03000 	mov	r3, r0
3000c8e0:	e5cd3007 	strb	r3, [sp, #7]
	return acoral_sem_create(count);
3000c8e4:	e5dd3007 	ldrb	r3, [sp, #7]
3000c8e8:	e1a00003 	mov	r0, r3
3000c8ec:	ebffeafb 	bl	300074e0 <acoral_sem_create>
3000c8f0:	e1a03000 	mov	r3, r0
}
3000c8f4:	e1a00003 	mov	r0, r3
3000c8f8:	e28dd00c 	add	sp, sp, #12
3000c8fc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000c900:	e12fff1e 	bx	lr

3000c904 <sys_sem_free>:

/*------------------------------
   void sys_sem_free(sys_sem_t sem)
 */
void sys_sem_free(sys_sem_t sem)
{
3000c904:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000c908:	e24dd00c 	sub	sp, sp, #12
3000c90c:	e58d0004 	str	r0, [sp, #4]
	acoral_sem_del(sem, 0);
3000c910:	e59d0004 	ldr	r0, [sp, #4]
3000c914:	e3a01000 	mov	r1, #0
3000c918:	ebffeb0e 	bl	30007558 <acoral_sem_del>
}
3000c91c:	e28dd00c 	add	sp, sp, #12
3000c920:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000c924:	e12fff1e 	bx	lr

3000c928 <sys_sem_signal>:

/*--------------------------------
   void sys_sem_signal(sys_sem_t sem)
 */
void sys_sem_signal(sys_sem_t sem)
{
3000c928:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000c92c:	e24dd00c 	sub	sp, sp, #12
3000c930:	e58d0004 	str	r0, [sp, #4]
	acoral_sem_post(sem);
3000c934:	e59d0004 	ldr	r0, [sp, #4]
3000c938:	ebffebcb 	bl	3000786c <acoral_sem_post>
}
3000c93c:	e28dd00c 	add	sp, sp, #12
3000c940:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000c944:	e12fff1e 	bx	lr

3000c948 <sys_arch_sem_wait>:

/*----------------------------------
   u32_t sys_arch_sem_wait(sys_sem_t sem, u32_t timeout)
 */
u32_t sys_arch_sem_wait(sys_sem_t sem, u32_t timeout)
{
3000c948:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000c94c:	e24dd00c 	sub	sp, sp, #12
3000c950:	e58d0004 	str	r0, [sp, #4]
3000c954:	e58d1000 	str	r1, [sp]
	if(SEM_SUCCED == acoral_sem_pend(sem, timeout))
3000c958:	e59d0004 	ldr	r0, [sp, #4]
3000c95c:	e59d1000 	ldr	r1, [sp]
3000c960:	ebffeb56 	bl	300076c0 <acoral_sem_pend>
3000c964:	e1a03000 	mov	r3, r0
3000c968:	e3530000 	cmp	r3, #0
3000c96c:	1a000001 	bne	3000c978 <sys_arch_sem_wait+0x30>
		return 0;
3000c970:	e3a03000 	mov	r3, #0
3000c974:	ea000000 	b	3000c97c <sys_arch_sem_wait+0x34>
	else
		return SYS_ARCH_TIMEOUT;
3000c978:	e3e03000 	mvn	r3, #0
}
3000c97c:	e1a00003 	mov	r0, r3
3000c980:	e28dd00c 	add	sp, sp, #12
3000c984:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000c988:	e12fff1e 	bx	lr

3000c98c <sys_mbox_new>:

/*---------------------------------
   sys_mbox_t sys_mbox_new()
 */
sys_mbox_t sys_mbox_new(int size)
{
3000c98c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000c990:	e24dd014 	sub	sp, sp, #20
3000c994:	e58d0004 	str	r0, [sp, #4]
	u32_t  err;
	return acoral_msgctr_create(&err);
3000c998:	e28d300c 	add	r3, sp, #12
3000c99c:	e1a00003 	mov	r0, r3
3000c9a0:	ebffecf0 	bl	30007d68 <acoral_msgctr_create>
3000c9a4:	e1a03000 	mov	r3, r0
	//return acoral_mbox_create();
}
3000c9a8:	e1a00003 	mov	r0, r3
3000c9ac:	e28dd014 	add	sp, sp, #20
3000c9b0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000c9b4:	e12fff1e 	bx	lr

3000c9b8 <sys_mbox_free>:

/*--------------------------------
   void sys_mbox_free(sys_mbox_t mbox)
 */
void sys_mbox_free(sys_mbox_t mbox)
{
3000c9b8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000c9bc:	e24dd00c 	sub	sp, sp, #12
3000c9c0:	e58d0004 	str	r0, [sp, #4]
	acoral_msgctr_del(mbox, 1);
3000c9c4:	e59d0004 	ldr	r0, [sp, #4]
3000c9c8:	e3a01001 	mov	r1, #1
3000c9cc:	ebffee21 	bl	30008258 <acoral_msgctr_del>
	//acoral_mbox_del(mbox);
}
3000c9d0:	e28dd00c 	add	sp, sp, #12
3000c9d4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000c9d8:	e12fff1e 	bx	lr

3000c9dc <sys_mbox_post>:

/*--------------------------------
   void sys_mbox_post(sys_mbox_t  mbox, void *msg)
 */
void sys_mbox_post(sys_mbox_t mbox, void* msg)
{
3000c9dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000c9e0:	e24dd024 	sub	sp, sp, #36	; 0x24
3000c9e4:	e58d000c 	str	r0, [sp, #12]
3000c9e8:	e58d1008 	str	r1, [sp, #8]
	u32_t err;
	u32_t id = 1;
3000c9ec:	e3a03001 	mov	r3, #1
3000c9f0:	e58d3018 	str	r3, [sp, #24]
	sys_msg_t pmsg = acoral_msg_create(1, &err, id, 0, msg);
3000c9f4:	e28d3014 	add	r3, sp, #20
3000c9f8:	e59d2008 	ldr	r2, [sp, #8]
3000c9fc:	e58d2000 	str	r2, [sp]
3000ca00:	e3a00001 	mov	r0, #1
3000ca04:	e1a01003 	mov	r1, r3
3000ca08:	e59d2018 	ldr	r2, [sp, #24]
3000ca0c:	e3a03000 	mov	r3, #0
3000ca10:	ebffed0e 	bl	30007e50 <acoral_msg_create>
3000ca14:	e1a03000 	mov	r3, r0
3000ca18:	e58d301c 	str	r3, [sp, #28]
	if (NULL != pmsg)
3000ca1c:	e59d301c 	ldr	r3, [sp, #28]
3000ca20:	e3530000 	cmp	r3, #0
3000ca24:	0a000002 	beq	3000ca34 <sys_mbox_post+0x58>
		acoral_msg_send(mbox, pmsg);
3000ca28:	e59d000c 	ldr	r0, [sp, #12]
3000ca2c:	e59d101c 	ldr	r1, [sp, #28]
3000ca30:	ebffed2d 	bl	30007eec <acoral_msg_send>
	//acoral_mbox_send(mbox,msg);
}
3000ca34:	e28dd024 	add	sp, sp, #36	; 0x24
3000ca38:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000ca3c:	e12fff1e 	bx	lr

3000ca40 <sys_mbox_trypost>:

/*--------------------------------
   err_t sys_mbox_trypost(sys_mbox_t  mbox, void *msg)
 */
err_t sys_mbox_trypost(sys_mbox_t mbox, void* msg)
{
3000ca40:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000ca44:	e24dd024 	sub	sp, sp, #36	; 0x24
3000ca48:	e58d000c 	str	r0, [sp, #12]
3000ca4c:	e58d1008 	str	r1, [sp, #8]
	u32_t err;
	u32_t id = 1;
3000ca50:	e3a03001 	mov	r3, #1
3000ca54:	e58d3018 	str	r3, [sp, #24]
	sys_msg_t pmsg = acoral_msg_create(1, &err, id, 0, msg);
3000ca58:	e28d3014 	add	r3, sp, #20
3000ca5c:	e59d2008 	ldr	r2, [sp, #8]
3000ca60:	e58d2000 	str	r2, [sp]
3000ca64:	e3a00001 	mov	r0, #1
3000ca68:	e1a01003 	mov	r1, r3
3000ca6c:	e59d2018 	ldr	r2, [sp, #24]
3000ca70:	e3a03000 	mov	r3, #0
3000ca74:	ebffecf5 	bl	30007e50 <acoral_msg_create>
3000ca78:	e1a03000 	mov	r3, r0
3000ca7c:	e58d301c 	str	r3, [sp, #28]
	if (NULL != pmsg)
3000ca80:	e59d301c 	ldr	r3, [sp, #28]
3000ca84:	e3530000 	cmp	r3, #0
3000ca88:	0a000002 	beq	3000ca98 <sys_mbox_trypost+0x58>
		acoral_msg_send(mbox, pmsg);
3000ca8c:	e59d000c 	ldr	r0, [sp, #12]
3000ca90:	e59d101c 	ldr	r1, [sp, #28]
3000ca94:	ebffed14 	bl	30007eec <acoral_msg_send>
	//acoral_mbox_send(mbox,msg);
	return ERR_OK;
3000ca98:	e3a03000 	mov	r3, #0
3000ca9c:	e1a03c03 	lsl	r3, r3, #24
3000caa0:	e1a03c43 	asr	r3, r3, #24
}
3000caa4:	e1a00003 	mov	r0, r3
3000caa8:	e28dd024 	add	sp, sp, #36	; 0x24
3000caac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000cab0:	e12fff1e 	bx	lr

3000cab4 <sys_arch_mbox_fetch>:

/*---------------------------------
   u32_t sys_arch_mbox_fetch(sys_mbox_t mbox, void** msg, u32_t timeout)
 */
u32_t sys_arch_mbox_fetch(sys_mbox_t mbox, void** msg, u32_t timeout)
{
3000cab4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cab8:	e24dd01c 	sub	sp, sp, #28
3000cabc:	e58d000c 	str	r0, [sp, #12]
3000cac0:	e58d1008 	str	r1, [sp, #8]
3000cac4:	e58d2004 	str	r2, [sp, #4]

	u32_t err;
	u32_t id = 1;
3000cac8:	e3a03001 	mov	r3, #1
3000cacc:	e58d3014 	str	r3, [sp, #20]
	*msg = acoral_msg_recv(mbox, id, timeout, &err);
3000cad0:	e28d3010 	add	r3, sp, #16
3000cad4:	e59d000c 	ldr	r0, [sp, #12]
3000cad8:	e59d1014 	ldr	r1, [sp, #20]
3000cadc:	e59d2004 	ldr	r2, [sp, #4]
3000cae0:	ebffed46 	bl	30008000 <acoral_msg_recv>
3000cae4:	e1a02000 	mov	r2, r0
3000cae8:	e59d3008 	ldr	r3, [sp, #8]
3000caec:	e5832000 	str	r2, [r3]
	//*msg = acoral_mbox_recv(mbox, timeout);
	if (*msg == NULL)
3000caf0:	e59d3008 	ldr	r3, [sp, #8]
3000caf4:	e5933000 	ldr	r3, [r3]
3000caf8:	e3530000 	cmp	r3, #0
3000cafc:	1a000001 	bne	3000cb08 <sys_arch_mbox_fetch+0x54>
		return SYS_ARCH_TIMEOUT;
3000cb00:	e3e03000 	mvn	r3, #0
3000cb04:	ea000000 	b	3000cb0c <sys_arch_mbox_fetch+0x58>
	else
		return 0;
3000cb08:	e3a03000 	mov	r3, #0
}
3000cb0c:	e1a00003 	mov	r0, r3
3000cb10:	e28dd01c 	add	sp, sp, #28
3000cb14:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000cb18:	e12fff1e 	bx	lr

3000cb1c <getTONAvai>:


int getTONAvai()
{
3000cb1c:	e24dd008 	sub	sp, sp, #8
	int ret;
    
    if(timeoutnodes.flag < TCPIP_THREAD_MAXNUM)
3000cb20:	e59f3040 	ldr	r3, [pc, #64]	; 3000cb68 <getTONAvai+0x4c>
3000cb24:	e5933048 	ldr	r3, [r3, #72]	; 0x48
3000cb28:	e3530004 	cmp	r3, #4
3000cb2c:	ca000009 	bgt	3000cb58 <getTONAvai+0x3c>
    {
	    ret =timeoutnodes.flag;
3000cb30:	e59f3030 	ldr	r3, [pc, #48]	; 3000cb68 <getTONAvai+0x4c>
3000cb34:	e5933048 	ldr	r3, [r3, #72]	; 0x48
3000cb38:	e58d3004 	str	r3, [sp, #4]
    
    	timeoutnodes.flag += 1;
3000cb3c:	e59f3024 	ldr	r3, [pc, #36]	; 3000cb68 <getTONAvai+0x4c>
3000cb40:	e5933048 	ldr	r3, [r3, #72]	; 0x48
3000cb44:	e2832001 	add	r2, r3, #1
3000cb48:	e59f3018 	ldr	r3, [pc, #24]	; 3000cb68 <getTONAvai+0x4c>
3000cb4c:	e5832048 	str	r2, [r3, #72]	; 0x48
    	return ret;
3000cb50:	e59d3004 	ldr	r3, [sp, #4]
3000cb54:	ea000000 	b	3000cb5c <getTONAvai+0x40>
    }
   	return TCPIP_THREAD_MAXNUM;
3000cb58:	e3a03005 	mov	r3, #5
}
3000cb5c:	e1a00003 	mov	r0, r3
3000cb60:	e28dd008 	add	sp, sp, #8
3000cb64:	e12fff1e 	bx	lr
3000cb68:	302be520 	.word	0x302be520

3000cb6c <sys_thread_new>:
/*----------------------------------
   sys_thread_t sys_thread_new(void(*thread)(void* arg), void *arg, int prio)
 */
acoral_id tcp_id;
sys_thread_t sys_thread_new(char *name, void (* thread)(void *arg), void *arg, int stacksize, int prio)
{
3000cb6c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cb70:	e24dd02c 	sub	sp, sp, #44	; 0x2c
3000cb74:	e58d0014 	str	r0, [sp, #20]
3000cb78:	e58d1010 	str	r1, [sp, #16]
3000cb7c:	e58d200c 	str	r2, [sp, #12]
3000cb80:	e58d3008 	str	r3, [sp, #8]
		int          i;
		struct timeoutnode * pto;
		SYS_ARCH_DECL_PROTECT(x);
		
		//tmp =  acoral_create_thread(thread, TCPIP_THREAD_STACKSIZE, arg, name, prio, 0 );
		tmp =  acoral_create_thread(thread, 81920, arg, name, prio, 0 );
3000cb84:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3000cb88:	e20330ff 	and	r3, r3, #255	; 0xff
3000cb8c:	e58d3000 	str	r3, [sp]
3000cb90:	e3a03000 	mov	r3, #0
3000cb94:	e58d3004 	str	r3, [sp, #4]
3000cb98:	e59d0010 	ldr	r0, [sp, #16]
3000cb9c:	e3a01905 	mov	r1, #81920	; 0x14000
3000cba0:	e59d200c 	ldr	r2, [sp, #12]
3000cba4:	e59d3014 	ldr	r3, [sp, #20]
3000cba8:	ebffd8fd 	bl	30002fa4 <create_comm_thread>
3000cbac:	e1a03000 	mov	r3, r0
3000cbb0:	e58d3018 	str	r3, [sp, #24]
		tcp_id = tmp;
3000cbb4:	e59f30a8 	ldr	r3, [pc, #168]	; 3000cc64 <sys_thread_new+0xf8>
3000cbb8:	e59d2018 	ldr	r2, [sp, #24]
3000cbbc:	e5832000 	str	r2, [r3]
		i   = getTONAvai();
3000cbc0:	ebffffd5 	bl	3000cb1c <getTONAvai>
3000cbc4:	e1a03000 	mov	r3, r0
3000cbc8:	e58d301c 	str	r3, [sp, #28]
		if (i >= TCPIP_THREAD_MAXNUM)
3000cbcc:	e59d301c 	ldr	r3, [sp, #28]
3000cbd0:	e3530004 	cmp	r3, #4
3000cbd4:	da000001 	ble	3000cbe0 <sys_thread_new+0x74>
			return 0;
3000cbd8:	e3a03000 	mov	r3, #0
3000cbdc:	ea00001c 	b	3000cc54 <sys_thread_new+0xe8>
			
		pto = &timeoutnodes.p[i];
3000cbe0:	e59d201c 	ldr	r2, [sp, #28]
3000cbe4:	e1a03002 	mov	r3, r2
3000cbe8:	e1a03083 	lsl	r3, r3, #1
3000cbec:	e0833002 	add	r3, r3, r2
3000cbf0:	e1a03103 	lsl	r3, r3, #2
3000cbf4:	e1a02003 	mov	r2, r3
3000cbf8:	e59f3068 	ldr	r3, [pc, #104]	; 3000cc68 <sys_thread_new+0xfc>
3000cbfc:	e0823003 	add	r3, r2, r3
3000cc00:	e58d3020 	str	r3, [sp, #32]
		
		pto->prio = prio;
3000cc04:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3000cc08:	e20320ff 	and	r2, r3, #255	; 0xff
3000cc0c:	e59d3020 	ldr	r3, [sp, #32]
3000cc10:	e5c32004 	strb	r2, [r3, #4]
		    
		pto->timeouts.next = NULL;
3000cc14:	e59d3020 	ldr	r3, [sp, #32]
3000cc18:	e3a02000 	mov	r2, #0
3000cc1c:	e5832000 	str	r2, [r3]
       	SYS_ARCH_PROTECT(x)
3000cc20:	ebffd2b3 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000cc24:	e1a03000 	mov	r3, r0
3000cc28:	e58d3024 	str	r3, [sp, #36]	; 0x24
	    pto->next = timeoutslist;
3000cc2c:	e59f3038 	ldr	r3, [pc, #56]	; 3000cc6c <sys_thread_new+0x100>
3000cc30:	e5932000 	ldr	r2, [r3]
3000cc34:	e59d3020 	ldr	r3, [sp, #32]
3000cc38:	e5832008 	str	r2, [r3, #8]
		timeoutslist = pto;
3000cc3c:	e59f3028 	ldr	r3, [pc, #40]	; 3000cc6c <sys_thread_new+0x100>
3000cc40:	e59d2020 	ldr	r2, [sp, #32]
3000cc44:	e5832000 	str	r2, [r3]
      	SYS_ARCH_UNPROTECT(x)
3000cc48:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3000cc4c:	ebffd2a6 	bl	300016ec <HAL_INTR_RESTORE>
		
		return tmp;	
3000cc50:	e59d3018 	ldr	r3, [sp, #24]

}
3000cc54:	e1a00003 	mov	r0, r3
3000cc58:	e28dd02c 	add	sp, sp, #44	; 0x2c
3000cc5c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000cc60:	e12fff1e 	bx	lr
3000cc64:	3012d6a0 	.word	0x3012d6a0
3000cc68:	302be520 	.word	0x302be520
3000cc6c:	301f57a0 	.word	0x301f57a0

3000cc70 <sys_arch_timeouts>:
* �䡡	 �� : ��
*        
* �䡡	 �� : struct sys_timeouts *: �̵߳ĳ�ʱ�ṹ
********************************************/
struct sys_timeouts * sys_arch_timeouts(void)
{
3000cc70:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cc74:	e24dd014 	sub	sp, sp, #20
    struct timeoutnode * pto = timeoutslist;
3000cc78:	e59f3078 	ldr	r3, [pc, #120]	; 3000ccf8 <sys_arch_timeouts+0x88>
3000cc7c:	e5933000 	ldr	r3, [r3]
3000cc80:	e58d3004 	str	r3, [sp, #4]
   	u8_t curprio;	    
	SYS_ARCH_DECL_PROTECT(cpusr);

	SYS_ARCH_PROTECT(cpusr);
3000cc84:	ebffd29a 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000cc88:	e1a03000 	mov	r3, r0
3000cc8c:	e58d300c 	str	r3, [sp, #12]
	curprio = acoral_cur_thread->prio;
3000cc90:	e59f3064 	ldr	r3, [pc, #100]	; 3000ccfc <sys_arch_timeouts+0x8c>
3000cc94:	e5933000 	ldr	r3, [r3]
3000cc98:	e5d33005 	ldrb	r3, [r3, #5]
3000cc9c:	e5cd300b 	strb	r3, [sp, #11]
    SYS_ARCH_UNPROTECT(cpusr);
3000cca0:	e59d000c 	ldr	r0, [sp, #12]
3000cca4:	ebffd290 	bl	300016ec <HAL_INTR_RESTORE>
           	    
    while (pto != &nulltimeouts)
3000cca8:	ea000009 	b	3000ccd4 <sys_arch_timeouts+0x64>
    {
    	if (pto->prio == curprio)
3000ccac:	e59d3004 	ldr	r3, [sp, #4]
3000ccb0:	e5d33004 	ldrb	r3, [r3, #4]
3000ccb4:	e5dd200b 	ldrb	r2, [sp, #11]
3000ccb8:	e1520003 	cmp	r2, r3
3000ccbc:	1a000001 	bne	3000ccc8 <sys_arch_timeouts+0x58>
    	{
    		return &(pto->timeouts);
3000ccc0:	e59d3004 	ldr	r3, [sp, #4]
3000ccc4:	ea000007 	b	3000cce8 <sys_arch_timeouts+0x78>
    	}
    	else
    	{
    		pto = pto->next;
3000ccc8:	e59d3004 	ldr	r3, [sp, #4]
3000cccc:	e5933008 	ldr	r3, [r3, #8]
3000ccd0:	e58d3004 	str	r3, [sp, #4]

	SYS_ARCH_PROTECT(cpusr);
	curprio = acoral_cur_thread->prio;
    SYS_ARCH_UNPROTECT(cpusr);
           	    
    while (pto != &nulltimeouts)
3000ccd4:	e59d2004 	ldr	r2, [sp, #4]
3000ccd8:	e59f3020 	ldr	r3, [pc, #32]	; 3000cd00 <sys_arch_timeouts+0x90>
3000ccdc:	e1520003 	cmp	r2, r3
3000cce0:	1afffff1 	bne	3000ccac <sys_arch_timeouts+0x3c>
    	{
    		pto = pto->next;
    	}
    }

    return &(pto->timeouts);
3000cce4:	e59d3004 	ldr	r3, [sp, #4]
}
3000cce8:	e1a00003 	mov	r0, r3
3000ccec:	e28dd014 	add	sp, sp, #20
3000ccf0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000ccf4:	e12fff1e 	bx	lr
3000ccf8:	301f57a0 	.word	0x301f57a0
3000ccfc:	302be818 	.word	0x302be818
3000cd00:	300ea31c 	.word	0x300ea31c

3000cd04 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto,
		netconn_callback callback) {
3000cd04:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cd08:	e24dd024 	sub	sp, sp, #36	; 0x24
3000cd0c:	e1a03001 	mov	r3, r1
3000cd10:	e58d2000 	str	r2, [sp]
3000cd14:	e1a02000 	mov	r2, r0
3000cd18:	e5cd2007 	strb	r2, [sp, #7]
3000cd1c:	e5cd3006 	strb	r3, [sp, #6]
	struct netconn *conn;
	struct api_msg msg;

	conn = netconn_alloc(t, callback);
3000cd20:	e5dd3007 	ldrb	r3, [sp, #7]
3000cd24:	e1a00003 	mov	r0, r3
3000cd28:	e59d1000 	ldr	r1, [sp]
3000cd2c:	eb000477 	bl	3000df10 <netconn_alloc>
3000cd30:	e1a03000 	mov	r3, r0
3000cd34:	e58d301c 	str	r3, [sp, #28]
	if (conn != NULL) {
3000cd38:	e59d301c 	ldr	r3, [sp, #28]
3000cd3c:	e3530000 	cmp	r3, #0
3000cd40:	0a000019 	beq	3000cdac <netconn_new_with_proto_and_callback+0xa8>
		msg.function = do_newconn;
3000cd44:	e59f3074 	ldr	r3, [pc, #116]	; 3000cdc0 <netconn_new_with_proto_and_callback+0xbc>
3000cd48:	e58d3008 	str	r3, [sp, #8]
		msg.msg.msg.n.proto = proto;
3000cd4c:	e5dd3006 	ldrb	r3, [sp, #6]
3000cd50:	e5cd3010 	strb	r3, [sp, #16]
		msg.msg.conn = conn;
3000cd54:	e59d301c 	ldr	r3, [sp, #28]
3000cd58:	e58d300c 	str	r3, [sp, #12]
		TCPIP_APIMSG(&msg);
3000cd5c:	e28d3008 	add	r3, sp, #8
3000cd60:	e1a00003 	mov	r0, r3
3000cd64:	eb0015fe 	bl	30012564 <tcpip_apimsg>

		if (conn->err != ERR_OK) {
3000cd68:	e59d301c 	ldr	r3, [sp, #28]
3000cd6c:	e5d33008 	ldrb	r3, [r3, #8]
3000cd70:	e3530000 	cmp	r3, #0
3000cd74:	0a00000c 	beq	3000cdac <netconn_new_with_proto_and_callback+0xa8>
			LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
			sys_sem_free(conn->op_completed);
3000cd78:	e59d301c 	ldr	r3, [sp, #28]
3000cd7c:	e593300c 	ldr	r3, [r3, #12]
3000cd80:	e1a00003 	mov	r0, r3
3000cd84:	ebfffede 	bl	3000c904 <sys_sem_free>
			sys_mbox_free(conn->recvmbox);
3000cd88:	e59d301c 	ldr	r3, [sp, #28]
3000cd8c:	e5933010 	ldr	r3, [r3, #16]
3000cd90:	e1a00003 	mov	r0, r3
3000cd94:	ebffff07 	bl	3000c9b8 <sys_mbox_free>
			memp_free(MEMP_NETCONN, conn);
3000cd98:	e3a00006 	mov	r0, #6
3000cd9c:	e59d101c 	ldr	r1, [sp, #28]
3000cda0:	eb0021c8 	bl	300154c8 <memp_free>
			return NULL;
3000cda4:	e3a03000 	mov	r3, #0
3000cda8:	ea000000 	b	3000cdb0 <netconn_new_with_proto_and_callback+0xac>
		}
	}
	return conn;
3000cdac:	e59d301c 	ldr	r3, [sp, #28]
}
3000cdb0:	e1a00003 	mov	r0, r3
3000cdb4:	e28dd024 	add	sp, sp, #36	; 0x24
3000cdb8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000cdbc:	e12fff1e 	bx	lr
3000cdc0:	3000dec8 	.word	0x3000dec8

3000cdc4 <netconn_delete>:
 * after this returns.
 *
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t netconn_delete(struct netconn *conn) {
3000cdc4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cdc8:	e24dd024 	sub	sp, sp, #36	; 0x24
3000cdcc:	e58d0004 	str	r0, [sp, #4]
	struct api_msg msg;

	/* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
	if (conn == NULL) {
3000cdd0:	e59d3004 	ldr	r3, [sp, #4]
3000cdd4:	e3530000 	cmp	r3, #0
3000cdd8:	1a000001 	bne	3000cde4 <netconn_delete+0x20>
		return ERR_OK;
3000cddc:	e3a03000 	mov	r3, #0
3000cde0:	ea00000c 	b	3000ce18 <netconn_delete+0x54>
	}

	msg.function = do_delconn;
3000cde4:	e59f3044 	ldr	r3, [pc, #68]	; 3000ce30 <netconn_delete+0x6c>
3000cde8:	e58d300c 	str	r3, [sp, #12]
	msg.msg.conn = conn;
3000cdec:	e59d3004 	ldr	r3, [sp, #4]
3000cdf0:	e58d3010 	str	r3, [sp, #16]
	tcpip_apimsg(&msg);
3000cdf4:	e28d300c 	add	r3, sp, #12
3000cdf8:	e1a00003 	mov	r0, r3
3000cdfc:	eb0015d8 	bl	30012564 <tcpip_apimsg>

	conn->pcb.tcp = NULL;
3000ce00:	e59d3004 	ldr	r3, [sp, #4]
3000ce04:	e3a02000 	mov	r2, #0
3000ce08:	e5832004 	str	r2, [r3, #4]
	netconn_free(conn);
3000ce0c:	e59d0004 	ldr	r0, [sp, #4]
3000ce10:	eb00048b 	bl	3000e044 <netconn_free>

	return ERR_OK;
3000ce14:	e3a03000 	mov	r3, #0
3000ce18:	e1a03c03 	lsl	r3, r3, #24
3000ce1c:	e1a03c43 	asr	r3, r3, #24
}
3000ce20:	e1a00003 	mov	r0, r3
3000ce24:	e28dd024 	add	sp, sp, #36	; 0x24
3000ce28:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000ce2c:	e12fff1e 	bx	lr
3000ce30:	3000e308 	.word	0x3000e308

3000ce34 <netconn_type>:
 * Get the type of a netconn (as enum netconn_type).
 *
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type netconn_type(struct netconn *conn) {
3000ce34:	e24dd008 	sub	sp, sp, #8
3000ce38:	e58d0004 	str	r0, [sp, #4]
	LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
	return conn->type;
3000ce3c:	e59d3004 	ldr	r3, [sp, #4]
3000ce40:	e5d33000 	ldrb	r3, [r3]
}
3000ce44:	e1a00003 	mov	r0, r3
3000ce48:	e28dd008 	add	sp, sp, #8
3000ce4c:	e12fff1e 	bx	lr

3000ce50 <netconn_getaddr>:
 * @param local 1 to get the local IP address, 0 to get the remote one
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port,
		u8_t local) {
3000ce50:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000ce54:	e24dd02c 	sub	sp, sp, #44	; 0x2c
3000ce58:	e58d000c 	str	r0, [sp, #12]
3000ce5c:	e58d1008 	str	r1, [sp, #8]
3000ce60:	e58d2004 	str	r2, [sp, #4]
3000ce64:	e5cd3003 	strb	r3, [sp, #3]
	struct api_msg msg;

	LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);

	msg.function = do_getaddr;
3000ce68:	e59f304c 	ldr	r3, [pc, #76]	; 3000cebc <netconn_getaddr+0x6c>
3000ce6c:	e58d3014 	str	r3, [sp, #20]
	msg.msg.conn = conn;
3000ce70:	e59d300c 	ldr	r3, [sp, #12]
3000ce74:	e58d3018 	str	r3, [sp, #24]
	msg.msg.msg.ad.ipaddr = addr;
3000ce78:	e59d3008 	ldr	r3, [sp, #8]
3000ce7c:	e58d301c 	str	r3, [sp, #28]
	msg.msg.msg.ad.port = port;
3000ce80:	e59d3004 	ldr	r3, [sp, #4]
3000ce84:	e58d3020 	str	r3, [sp, #32]
	msg.msg.msg.ad.local = local;
3000ce88:	e5dd3003 	ldrb	r3, [sp, #3]
3000ce8c:	e5cd3024 	strb	r3, [sp, #36]	; 0x24
	TCPIP_APIMSG(&msg);
3000ce90:	e28d3014 	add	r3, sp, #20
3000ce94:	e1a00003 	mov	r0, r3
3000ce98:	eb0015b1 	bl	30012564 <tcpip_apimsg>

	return conn->err;
3000ce9c:	e59d300c 	ldr	r3, [sp, #12]
3000cea0:	e5d33008 	ldrb	r3, [r3, #8]
3000cea4:	e1a03c03 	lsl	r3, r3, #24
3000cea8:	e1a03c43 	asr	r3, r3, #24
}
3000ceac:	e1a00003 	mov	r0, r3
3000ceb0:	e28dd02c 	add	sp, sp, #44	; 0x2c
3000ceb4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000ceb8:	e12fff1e 	bx	lr
3000cebc:	3000efc4 	.word	0x3000efc4

3000cec0 <netconn_bind>:
 * @param addr the local IP address to bind the netconn to (use IP_ADDR_ANY
 *             to bind to all addresses)
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port) {
3000cec0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cec4:	e24dd02c 	sub	sp, sp, #44	; 0x2c
3000cec8:	e58d000c 	str	r0, [sp, #12]
3000cecc:	e58d1008 	str	r1, [sp, #8]
3000ced0:	e1a03002 	mov	r3, r2
3000ced4:	e1cd30b6 	strh	r3, [sp, #6]
	struct api_msg msg;

	LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);

	msg.function = do_bind;
3000ced8:	e59f3044 	ldr	r3, [pc, #68]	; 3000cf24 <netconn_bind+0x64>
3000cedc:	e58d3014 	str	r3, [sp, #20]
	msg.msg.conn = conn;
3000cee0:	e59d300c 	ldr	r3, [sp, #12]
3000cee4:	e58d3018 	str	r3, [sp, #24]
	msg.msg.msg.bc.ipaddr = addr;
3000cee8:	e59d3008 	ldr	r3, [sp, #8]
3000ceec:	e58d301c 	str	r3, [sp, #28]
	msg.msg.msg.bc.port = port;
3000cef0:	e1dd30b6 	ldrh	r3, [sp, #6]
3000cef4:	e1cd32b0 	strh	r3, [sp, #32]
	TCPIP_APIMSG(&msg);
3000cef8:	e28d3014 	add	r3, sp, #20
3000cefc:	e1a00003 	mov	r0, r3
3000cf00:	eb001597 	bl	30012564 <tcpip_apimsg>
	return conn->err;
3000cf04:	e59d300c 	ldr	r3, [sp, #12]
3000cf08:	e5d33008 	ldrb	r3, [r3, #8]
3000cf0c:	e1a03c03 	lsl	r3, r3, #24
3000cf10:	e1a03c43 	asr	r3, r3, #24
}
3000cf14:	e1a00003 	mov	r0, r3
3000cf18:	e28dd02c 	add	sp, sp, #44	; 0x2c
3000cf1c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000cf20:	e12fff1e 	bx	lr
3000cf24:	3000e468 	.word	0x3000e468

3000cf28 <netconn_connect>:
 * @param conn the netconn to connect
 * @param addr the remote IP address to connect to
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port) {
3000cf28:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cf2c:	e24dd02c 	sub	sp, sp, #44	; 0x2c
3000cf30:	e58d000c 	str	r0, [sp, #12]
3000cf34:	e58d1008 	str	r1, [sp, #8]
3000cf38:	e1a03002 	mov	r3, r2
3000cf3c:	e1cd30b6 	strh	r3, [sp, #6]
	struct api_msg msg;

	LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);

	msg.function = do_connect;
3000cf40:	e59f3044 	ldr	r3, [pc, #68]	; 3000cf8c <netconn_connect+0x64>
3000cf44:	e58d3014 	str	r3, [sp, #20]
	msg.msg.conn = conn;
3000cf48:	e59d300c 	ldr	r3, [sp, #12]
3000cf4c:	e58d3018 	str	r3, [sp, #24]
	msg.msg.msg.bc.ipaddr = addr;
3000cf50:	e59d3008 	ldr	r3, [sp, #8]
3000cf54:	e58d301c 	str	r3, [sp, #28]
	msg.msg.msg.bc.port = port;
3000cf58:	e1dd30b6 	ldrh	r3, [sp, #6]
3000cf5c:	e1cd32b0 	strh	r3, [sp, #32]
	/* This is the only function which need to not block tcpip_thread */
	tcpip_apimsg(&msg);
3000cf60:	e28d3014 	add	r3, sp, #20
3000cf64:	e1a00003 	mov	r0, r3
3000cf68:	eb00157d 	bl	30012564 <tcpip_apimsg>
	return conn->err;
3000cf6c:	e59d300c 	ldr	r3, [sp, #12]
3000cf70:	e5d33008 	ldrb	r3, [r3, #8]
3000cf74:	e1a03c03 	lsl	r3, r3, #24
3000cf78:	e1a03c43 	asr	r3, r3, #24
}
3000cf7c:	e1a00003 	mov	r0, r3
3000cf80:	e28dd02c 	add	sp, sp, #44	; 0x2c
3000cf84:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000cf88:	e12fff1e 	bx	lr
3000cf8c:	3000e660 	.word	0x3000e660

3000cf90 <netconn_disconnect>:
 * Disconnect a netconn from its current peer (only valid for UDP netconns).
 *
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t netconn_disconnect(struct netconn *conn) {
3000cf90:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cf94:	e24dd024 	sub	sp, sp, #36	; 0x24
3000cf98:	e58d0004 	str	r0, [sp, #4]
	struct api_msg msg;

	LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);

	msg.function = do_disconnect;
3000cf9c:	e59f3034 	ldr	r3, [pc, #52]	; 3000cfd8 <netconn_disconnect+0x48>
3000cfa0:	e58d300c 	str	r3, [sp, #12]
	msg.msg.conn = conn;
3000cfa4:	e59d3004 	ldr	r3, [sp, #4]
3000cfa8:	e58d3010 	str	r3, [sp, #16]
	TCPIP_APIMSG(&msg);
3000cfac:	e28d300c 	add	r3, sp, #12
3000cfb0:	e1a00003 	mov	r0, r3
3000cfb4:	eb00156a 	bl	30012564 <tcpip_apimsg>
	return conn->err;
3000cfb8:	e59d3004 	ldr	r3, [sp, #4]
3000cfbc:	e5d33008 	ldrb	r3, [r3, #8]
3000cfc0:	e1a03c03 	lsl	r3, r3, #24
3000cfc4:	e1a03c43 	asr	r3, r3, #24
}
3000cfc8:	e1a00003 	mov	r0, r3
3000cfcc:	e28dd024 	add	sp, sp, #36	; 0x24
3000cfd0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000cfd4:	e12fff1e 	bx	lr
3000cfd8:	3000e7dc 	.word	0x3000e7dc

3000cfdc <netconn_listen_with_backlog>:
 * @param conn the tcp netconn to set to listen mode
 * @param backlog the listen backlog, only used if TCP_LISTEN_BACKLOG==1
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t netconn_listen_with_backlog(struct netconn *conn, u8_t backlog) {
3000cfdc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000cfe0:	e24dd024 	sub	sp, sp, #36	; 0x24
3000cfe4:	e58d0004 	str	r0, [sp, #4]
3000cfe8:	e1a03001 	mov	r3, r1
3000cfec:	e5cd3003 	strb	r3, [sp, #3]
	/* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
	LWIP_UNUSED_ARG(backlog);

	LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);

	msg.function = do_listen;
3000cff0:	e59f3034 	ldr	r3, [pc, #52]	; 3000d02c <netconn_listen_with_backlog+0x50>
3000cff4:	e58d300c 	str	r3, [sp, #12]
	msg.msg.conn = conn;
3000cff8:	e59d3004 	ldr	r3, [sp, #4]
3000cffc:	e58d3010 	str	r3, [sp, #16]
#if TCP_LISTEN_BACKLOG
	msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
	TCPIP_APIMSG(&msg);
3000d000:	e28d300c 	add	r3, sp, #12
3000d004:	e1a00003 	mov	r0, r3
3000d008:	eb001555 	bl	30012564 <tcpip_apimsg>
	return conn->err;
3000d00c:	e59d3004 	ldr	r3, [sp, #4]
3000d010:	e5d33008 	ldrb	r3, [r3, #8]
3000d014:	e1a03c03 	lsl	r3, r3, #24
3000d018:	e1a03c43 	asr	r3, r3, #24
}
3000d01c:	e1a00003 	mov	r0, r3
3000d020:	e28dd024 	add	sp, sp, #36	; 0x24
3000d024:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d028:	e12fff1e 	bx	lr
3000d02c:	3000e834 	.word	0x3000e834

3000d030 <netconn_accept>:
 *
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn) {
3000d030:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d034:	e24dd014 	sub	sp, sp, #20
3000d038:	e58d0004 	str	r0, [sp, #4]
#if LWIP_SO_RCVTIMEO
	if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
		newconn = NULL;
	} else
#else
	sys_arch_mbox_fetch(conn->acceptmbox, (void *) &newconn, 0);
3000d03c:	e59d3004 	ldr	r3, [sp, #4]
3000d040:	e5932014 	ldr	r2, [r3, #20]
3000d044:	e28d300c 	add	r3, sp, #12
3000d048:	e1a00002 	mov	r0, r2
3000d04c:	e1a01003 	mov	r1, r3
3000d050:	e3a02000 	mov	r2, #0
3000d054:	ebfffe96 	bl	3000cab4 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
	{
		/* Register event with callback */
		API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
3000d058:	e59d3004 	ldr	r3, [sp, #4]
3000d05c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d060:	e3530000 	cmp	r3, #0
3000d064:	0a000006 	beq	3000d084 <netconn_accept+0x54>
3000d068:	e59d3004 	ldr	r3, [sp, #4]
3000d06c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d070:	e59d0004 	ldr	r0, [sp, #4]
3000d074:	e3a01001 	mov	r1, #1
3000d078:	e3a02000 	mov	r2, #0
3000d07c:	e1a0e00f 	mov	lr, pc
3000d080:	e12fff13 	bx	r3
			TCPIP_APIMSG(&msg);
		}
#endif /* TCP_LISTEN_BACKLOG */
	}

	return newconn;
3000d084:	e59d300c 	ldr	r3, [sp, #12]
}
3000d088:	e1a00003 	mov	r0, r3
3000d08c:	e28dd014 	add	sp, sp, #20
3000d090:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d094:	e12fff1e 	bx	lr

3000d098 <netconn_recv>:
 *
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn) {
3000d098:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d09c:	e24dd034 	sub	sp, sp, #52	; 0x34
3000d0a0:	e58d0004 	str	r0, [sp, #4]
	struct api_msg msg;
	struct netbuf *buf = NULL;
3000d0a4:	e3a03000 	mov	r3, #0
3000d0a8:	e58d300c 	str	r3, [sp, #12]
	struct pbuf *p;
	u16_t len;

	LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL), return NULL;);

	if (conn->recvmbox == SYS_MBOX_NULL) {
3000d0ac:	e59d3004 	ldr	r3, [sp, #4]
3000d0b0:	e5933010 	ldr	r3, [r3, #16]
3000d0b4:	e3530000 	cmp	r3, #0
3000d0b8:	1a000004 	bne	3000d0d0 <netconn_recv+0x38>
		/* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
		/* TCP listen conns don't have a recvmbox! */
		conn->err = ERR_CONN;
3000d0bc:	e59d3004 	ldr	r3, [sp, #4]
3000d0c0:	e3e02006 	mvn	r2, #6
3000d0c4:	e5c32008 	strb	r2, [r3, #8]
		return NULL;
3000d0c8:	e3a03000 	mov	r3, #0
3000d0cc:	ea00009d 	b	3000d348 <netconn_recv+0x2b0>
	}

	if (ERR_IS_FATAL(conn->err)) {
3000d0d0:	e59d3004 	ldr	r3, [sp, #4]
3000d0d4:	e5d33008 	ldrb	r3, [r3, #8]
3000d0d8:	e1a03c03 	lsl	r3, r3, #24
3000d0dc:	e1a03c43 	asr	r3, r3, #24
3000d0e0:	e3730003 	cmn	r3, #3
3000d0e4:	aa000001 	bge	3000d0f0 <netconn_recv+0x58>
		return NULL;
3000d0e8:	e3a03000 	mov	r3, #0
3000d0ec:	ea000095 	b	3000d348 <netconn_recv+0x2b0>
	}

	if (conn->type == NETCONN_TCP) {
3000d0f0:	e59d3004 	ldr	r3, [sp, #4]
3000d0f4:	e5d33000 	ldrb	r3, [r3]
3000d0f8:	e3530010 	cmp	r3, #16
3000d0fc:	1a00006a 	bne	3000d2ac <netconn_recv+0x214>
#if LWIP_TCP
		if (conn->state == NETCONN_LISTEN) {
3000d100:	e59d3004 	ldr	r3, [sp, #4]
3000d104:	e5d33001 	ldrb	r3, [r3, #1]
3000d108:	e3530002 	cmp	r3, #2
3000d10c:	1a000004 	bne	3000d124 <netconn_recv+0x8c>
			/* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
			conn->err = ERR_CONN;
3000d110:	e59d3004 	ldr	r3, [sp, #4]
3000d114:	e3e02006 	mvn	r2, #6
3000d118:	e5c32008 	strb	r2, [r3, #8]
			return NULL;
3000d11c:	e3a03000 	mov	r3, #0
3000d120:	ea000088 	b	3000d348 <netconn_recv+0x2b0>
		}

		buf = memp_malloc(MEMP_NETBUF);
3000d124:	e3a00005 	mov	r0, #5
3000d128:	eb002081 	bl	30015334 <memp_malloc>
3000d12c:	e1a03000 	mov	r3, r0
3000d130:	e58d300c 	str	r3, [sp, #12]

		if (buf == NULL) {
3000d134:	e59d300c 	ldr	r3, [sp, #12]
3000d138:	e3530000 	cmp	r3, #0
3000d13c:	1a000004 	bne	3000d154 <netconn_recv+0xbc>
			conn->err = ERR_MEM;
3000d140:	e59d3004 	ldr	r3, [sp, #4]
3000d144:	e3e02000 	mvn	r2, #0
3000d148:	e5c32008 	strb	r2, [r3, #8]
			return NULL;
3000d14c:	e3a03000 	mov	r3, #0
3000d150:	ea00007c 	b	3000d348 <netconn_recv+0x2b0>
		if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
			conn->err = ERR_TIMEOUT;
			p = NULL;
		}
#else
		sys_arch_mbox_fetch(conn->recvmbox, (void *) &p, 0);
3000d154:	e59d3004 	ldr	r3, [sp, #4]
3000d158:	e5932010 	ldr	r2, [r3, #16]
3000d15c:	e28d3008 	add	r3, sp, #8
3000d160:	e1a00002 	mov	r0, r2
3000d164:	e1a01003 	mov	r1, r3
3000d168:	e3a02000 	mov	r2, #0
3000d16c:	ebfffe50 	bl	3000cab4 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

		if (p != NULL) {
3000d170:	e59d3008 	ldr	r3, [sp, #8]
3000d174:	e3530000 	cmp	r3, #0
3000d178:	0a000010 	beq	3000d1c0 <netconn_recv+0x128>
			len = p->tot_len;
3000d17c:	e59d3008 	ldr	r3, [sp, #8]
3000d180:	e1d330b8 	ldrh	r3, [r3, #8]
3000d184:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
			SYS_ARCH_DEC(conn->recv_avail, len);
3000d188:	ebffd159 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000d18c:	e1a03000 	mov	r3, r0
3000d190:	e58d3028 	str	r3, [sp, #40]	; 0x28
3000d194:	e59d3004 	ldr	r3, [sp, #4]
3000d198:	e1d321bc 	ldrh	r2, [r3, #28]
3000d19c:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3000d1a0:	e0633002 	rsb	r3, r3, r2
3000d1a4:	e1a03803 	lsl	r3, r3, #16
3000d1a8:	e1a02823 	lsr	r2, r3, #16
3000d1ac:	e59d3004 	ldr	r3, [sp, #4]
3000d1b0:	e1c321bc 	strh	r2, [r3, #28]
3000d1b4:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
3000d1b8:	ebffd14b 	bl	300016ec <HAL_INTR_RESTORE>
3000d1bc:	ea000001 	b	3000d1c8 <netconn_recv+0x130>
		} else {
			len = 0;
3000d1c0:	e3a03000 	mov	r3, #0
3000d1c4:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
		}

		/* Register event with callback */
		API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
3000d1c8:	e59d3004 	ldr	r3, [sp, #4]
3000d1cc:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d1d0:	e3530000 	cmp	r3, #0
3000d1d4:	0a000006 	beq	3000d1f4 <netconn_recv+0x15c>
3000d1d8:	e59d3004 	ldr	r3, [sp, #4]
3000d1dc:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d1e0:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
3000d1e4:	e59d0004 	ldr	r0, [sp, #4]
3000d1e8:	e3a01001 	mov	r1, #1
3000d1ec:	e1a0e00f 	mov	lr, pc
3000d1f0:	e12fff13 	bx	r3

		/* If we are closed, we indicate that we no longer wish to use the socket */
		if (p == NULL) {
3000d1f4:	e59d3008 	ldr	r3, [sp, #8]
3000d1f8:	e3530000 	cmp	r3, #0
3000d1fc:	1a00000c 	bne	3000d234 <netconn_recv+0x19c>
			memp_free(MEMP_NETBUF, buf);
3000d200:	e59d300c 	ldr	r3, [sp, #12]
3000d204:	e3a00005 	mov	r0, #5
3000d208:	e1a01003 	mov	r1, r3
3000d20c:	eb0020ad 	bl	300154c8 <memp_free>
			/* Avoid to lose any previous error code */
			if (conn->err == ERR_OK) {
3000d210:	e59d3004 	ldr	r3, [sp, #4]
3000d214:	e5d33008 	ldrb	r3, [r3, #8]
3000d218:	e3530000 	cmp	r3, #0
3000d21c:	1a000002 	bne	3000d22c <netconn_recv+0x194>
				conn->err = ERR_CLSD;
3000d220:	e59d3004 	ldr	r3, [sp, #4]
3000d224:	e3e02005 	mvn	r2, #5
3000d228:	e5c32008 	strb	r2, [r3, #8]
			}
			return NULL;
3000d22c:	e3a03000 	mov	r3, #0
3000d230:	ea000044 	b	3000d348 <netconn_recv+0x2b0>
		}

		buf->p = p;
3000d234:	e59d300c 	ldr	r3, [sp, #12]
3000d238:	e59d2008 	ldr	r2, [sp, #8]
3000d23c:	e5832000 	str	r2, [r3]
		buf->ptr = p;
3000d240:	e59d300c 	ldr	r3, [sp, #12]
3000d244:	e59d2008 	ldr	r2, [sp, #8]
3000d248:	e5832004 	str	r2, [r3, #4]
		buf->port = 0;
3000d24c:	e59d300c 	ldr	r3, [sp, #12]
3000d250:	e3a02000 	mov	r2, #0
3000d254:	e1c320bc 	strh	r2, [r3, #12]
		buf->addr = NULL;
3000d258:	e59d300c 	ldr	r3, [sp, #12]
3000d25c:	e3a02000 	mov	r2, #0
3000d260:	e5832008 	str	r2, [r3, #8]

		/* Let the stack know that we have taken the data. */
		msg.function = do_recv;
3000d264:	e59f30ec 	ldr	r3, [pc, #236]	; 3000d358 <netconn_recv+0x2c0>
3000d268:	e58d3010 	str	r3, [sp, #16]
		msg.msg.conn = conn;
3000d26c:	e59d3004 	ldr	r3, [sp, #4]
3000d270:	e58d3014 	str	r3, [sp, #20]
		if (buf != NULL) {
3000d274:	e59d300c 	ldr	r3, [sp, #12]
3000d278:	e3530000 	cmp	r3, #0
3000d27c:	0a000004 	beq	3000d294 <netconn_recv+0x1fc>
			msg.msg.msg.r.len = buf->p->tot_len;
3000d280:	e59d300c 	ldr	r3, [sp, #12]
3000d284:	e5933000 	ldr	r3, [r3]
3000d288:	e1d330b8 	ldrh	r3, [r3, #8]
3000d28c:	e1cd31b8 	strh	r3, [sp, #24]
3000d290:	ea000001 	b	3000d29c <netconn_recv+0x204>
		} else {
			msg.msg.msg.r.len = 1;
3000d294:	e3a03001 	mov	r3, #1
3000d298:	e1cd31b8 	strh	r3, [sp, #24]
		}
		TCPIP_APIMSG(&msg);
3000d29c:	e28d3010 	add	r3, sp, #16
3000d2a0:	e1a00003 	mov	r0, r3
3000d2a4:	eb0014ae 	bl	30012564 <tcpip_apimsg>
3000d2a8:	ea000025 	b	3000d344 <netconn_recv+0x2ac>
#if LWIP_SO_RCVTIMEO
		if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
			buf = NULL;
		}
#else
		sys_arch_mbox_fetch(conn->recvmbox, (void *) &buf, 0);
3000d2ac:	e59d3004 	ldr	r3, [sp, #4]
3000d2b0:	e5932010 	ldr	r2, [r3, #16]
3000d2b4:	e28d300c 	add	r3, sp, #12
3000d2b8:	e1a00002 	mov	r0, r2
3000d2bc:	e1a01003 	mov	r1, r3
3000d2c0:	e3a02000 	mov	r2, #0
3000d2c4:	ebfffdfa 	bl	3000cab4 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
		if (buf != NULL) {
3000d2c8:	e59d300c 	ldr	r3, [sp, #12]
3000d2cc:	e3530000 	cmp	r3, #0
3000d2d0:	0a00001b 	beq	3000d344 <netconn_recv+0x2ac>
			SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
3000d2d4:	ebffd106 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000d2d8:	e1a03000 	mov	r3, r0
3000d2dc:	e58d302c 	str	r3, [sp, #44]	; 0x2c
3000d2e0:	e59d3004 	ldr	r3, [sp, #4]
3000d2e4:	e1d321bc 	ldrh	r2, [r3, #28]
3000d2e8:	e59d300c 	ldr	r3, [sp, #12]
3000d2ec:	e5933000 	ldr	r3, [r3]
3000d2f0:	e1d330b8 	ldrh	r3, [r3, #8]
3000d2f4:	e0633002 	rsb	r3, r3, r2
3000d2f8:	e1a03803 	lsl	r3, r3, #16
3000d2fc:	e1a02823 	lsr	r2, r3, #16
3000d300:	e59d3004 	ldr	r3, [sp, #4]
3000d304:	e1c321bc 	strh	r2, [r3, #28]
3000d308:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
3000d30c:	ebffd0f6 	bl	300016ec <HAL_INTR_RESTORE>
			/* Register event with callback */
			API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
3000d310:	e59d3004 	ldr	r3, [sp, #4]
3000d314:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d318:	e3530000 	cmp	r3, #0
3000d31c:	0a000008 	beq	3000d344 <netconn_recv+0x2ac>
3000d320:	e59d3004 	ldr	r3, [sp, #4]
3000d324:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d328:	e59d200c 	ldr	r2, [sp, #12]
3000d32c:	e5922000 	ldr	r2, [r2]
3000d330:	e1d220b8 	ldrh	r2, [r2, #8]
3000d334:	e59d0004 	ldr	r0, [sp, #4]
3000d338:	e3a01001 	mov	r1, #1
3000d33c:	e1a0e00f 	mov	lr, pc
3000d340:	e12fff13 	bx	r3
#endif /* (LWIP_UDP || LWIP_RAW) */
	}

	LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

	return buf;
3000d344:	e59d300c 	ldr	r3, [sp, #12]
}
3000d348:	e1a00003 	mov	r0, r3
3000d34c:	e28dd034 	add	sp, sp, #52	; 0x34
3000d350:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d354:	e12fff1e 	bx	lr
3000d358:	3000ebb8 	.word	0x3000ebb8

3000d35c <netconn_sendto>:
 * @param addr the remote IP address to which to send the data
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t netconn_sendto(struct netconn *conn, struct netbuf *buf,
		struct ip_addr *addr, u16_t port) {
3000d35c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d360:	e24dd014 	sub	sp, sp, #20
3000d364:	e58d000c 	str	r0, [sp, #12]
3000d368:	e58d1008 	str	r1, [sp, #8]
3000d36c:	e58d2004 	str	r2, [sp, #4]
3000d370:	e1cd30b2 	strh	r3, [sp, #2]
	if (buf != NULL) {
3000d374:	e59d3008 	ldr	r3, [sp, #8]
3000d378:	e3530000 	cmp	r3, #0
3000d37c:	0a00000c 	beq	3000d3b4 <netconn_sendto+0x58>
		buf->addr = addr;
3000d380:	e59d3008 	ldr	r3, [sp, #8]
3000d384:	e59d2004 	ldr	r2, [sp, #4]
3000d388:	e5832008 	str	r2, [r3, #8]
		buf->port = port;
3000d38c:	e59d3008 	ldr	r3, [sp, #8]
3000d390:	e1dd20b2 	ldrh	r2, [sp, #2]
3000d394:	e1c320bc 	strh	r2, [r3, #12]
		return netconn_send(conn, buf);
3000d398:	e59d000c 	ldr	r0, [sp, #12]
3000d39c:	e59d1008 	ldr	r1, [sp, #8]
3000d3a0:	eb00000a 	bl	3000d3d0 <netconn_send>
3000d3a4:	e1a03000 	mov	r3, r0
3000d3a8:	e20330ff 	and	r3, r3, #255	; 0xff
3000d3ac:	e20330ff 	and	r3, r3, #255	; 0xff
3000d3b0:	ea000000 	b	3000d3b8 <netconn_sendto+0x5c>
	}
	return ERR_VAL;
3000d3b4:	e3a030f8 	mov	r3, #248	; 0xf8
3000d3b8:	e1a03c03 	lsl	r3, r3, #24
3000d3bc:	e1a03c43 	asr	r3, r3, #24
}
3000d3c0:	e1a00003 	mov	r0, r3
3000d3c4:	e28dd014 	add	sp, sp, #20
3000d3c8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d3cc:	e12fff1e 	bx	lr

3000d3d0 <netconn_send>:
 *
 * @param conn the UDP or RAW netconn over which to send data
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t netconn_send(struct netconn *conn, struct netbuf *buf) {
3000d3d0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d3d4:	e24dd024 	sub	sp, sp, #36	; 0x24
3000d3d8:	e58d0004 	str	r0, [sp, #4]
3000d3dc:	e58d1000 	str	r1, [sp]
	struct api_msg msg;

	LWIP_ERROR("netconn_send: invalid conn", (conn != NULL), return ERR_ARG;);

	LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
	msg.function = do_send;
3000d3e0:	e59f303c 	ldr	r3, [pc, #60]	; 3000d424 <netconn_send+0x54>
3000d3e4:	e58d300c 	str	r3, [sp, #12]
	msg.msg.conn = conn;
3000d3e8:	e59d3004 	ldr	r3, [sp, #4]
3000d3ec:	e58d3010 	str	r3, [sp, #16]
	msg.msg.msg.b = buf;
3000d3f0:	e59d3000 	ldr	r3, [sp]
3000d3f4:	e58d3014 	str	r3, [sp, #20]
	TCPIP_APIMSG(&msg);
3000d3f8:	e28d300c 	add	r3, sp, #12
3000d3fc:	e1a00003 	mov	r0, r3
3000d400:	eb001457 	bl	30012564 <tcpip_apimsg>
	return conn->err;
3000d404:	e59d3004 	ldr	r3, [sp, #4]
3000d408:	e5d33008 	ldrb	r3, [r3, #8]
3000d40c:	e1a03c03 	lsl	r3, r3, #24
3000d410:	e1a03c43 	asr	r3, r3, #24
}
3000d414:	e1a00003 	mov	r0, r3
3000d418:	e28dd024 	add	sp, sp, #36	; 0x24
3000d41c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d420:	e12fff1e 	bx	lr
3000d424:	3000ea08 	.word	0x3000ea08

3000d428 <netconn_write>:
 * - NETCONN_COPY (0x01) data will be copied into memory belonging to the stack
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t netconn_write(struct netconn *conn, const void *dataptr, int size,
		u8_t apiflags) {
3000d428:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d42c:	e24dd02c 	sub	sp, sp, #44	; 0x2c
3000d430:	e58d000c 	str	r0, [sp, #12]
3000d434:	e58d1008 	str	r1, [sp, #8]
3000d438:	e58d2004 	str	r2, [sp, #4]
3000d43c:	e5cd3003 	strb	r3, [sp, #3]
	struct api_msg msg;

	LWIP_ERROR("netconn_write: invalid conn", (conn != NULL), return ERR_ARG;);LWIP_ERROR("netconn_write: invalid conn->type", (conn->type == NETCONN_TCP), return ERR_VAL;);

	msg.function = do_write;
3000d440:	e59f304c 	ldr	r3, [pc, #76]	; 3000d494 <netconn_write+0x6c>
3000d444:	e58d3014 	str	r3, [sp, #20]
	msg.msg.conn = conn;
3000d448:	e59d300c 	ldr	r3, [sp, #12]
3000d44c:	e58d3018 	str	r3, [sp, #24]
	msg.msg.msg.w.dataptr = dataptr;
3000d450:	e59d3008 	ldr	r3, [sp, #8]
3000d454:	e58d301c 	str	r3, [sp, #28]
	msg.msg.msg.w.apiflags = apiflags;
3000d458:	e5dd3003 	ldrb	r3, [sp, #3]
3000d45c:	e5cd3024 	strb	r3, [sp, #36]	; 0x24
	msg.msg.msg.w.len = size;
3000d460:	e59d3004 	ldr	r3, [sp, #4]
3000d464:	e58d3020 	str	r3, [sp, #32]
	/* For locking the core: this _can_ be delayed on low memory/low send buffer,
	 but if it is, this is done inside api_msg.c:do_write(), so we can use the
	 non-blocking version here. */
	//acoral_prints("\r\nnetconnWrite\r\n");
	TCPIP_APIMSG(&msg);
3000d468:	e28d3014 	add	r3, sp, #20
3000d46c:	e1a00003 	mov	r0, r3
3000d470:	eb00143b 	bl	30012564 <tcpip_apimsg>
	return conn->err;
3000d474:	e59d300c 	ldr	r3, [sp, #12]
3000d478:	e5d33008 	ldrb	r3, [r3, #8]
3000d47c:	e1a03c03 	lsl	r3, r3, #24
3000d480:	e1a03c43 	asr	r3, r3, #24
}
3000d484:	e1a00003 	mov	r0, r3
3000d488:	e28dd02c 	add	sp, sp, #44	; 0x2c
3000d48c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d490:	e12fff1e 	bx	lr
3000d494:	3000ef00 	.word	0x3000ef00

3000d498 <netconn_close>:
 * Close a TCP netconn (doesn't delete it).
 *
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t netconn_close(struct netconn *conn) {
3000d498:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d49c:	e24dd024 	sub	sp, sp, #36	; 0x24
3000d4a0:	e58d0004 	str	r0, [sp, #4]
	struct api_msg msg;

	LWIP_ERROR("netconn_close: invalid conn", (conn != NULL), return ERR_ARG;);

	msg.function = do_close;
3000d4a4:	e59f3034 	ldr	r3, [pc, #52]	; 3000d4e0 <netconn_close+0x48>
3000d4a8:	e58d300c 	str	r3, [sp, #12]
	msg.msg.conn = conn;
3000d4ac:	e59d3004 	ldr	r3, [sp, #4]
3000d4b0:	e58d3010 	str	r3, [sp, #16]
	tcpip_apimsg(&msg);
3000d4b4:	e28d300c 	add	r3, sp, #12
3000d4b8:	e1a00003 	mov	r0, r3
3000d4bc:	eb001428 	bl	30012564 <tcpip_apimsg>
	return conn->err;
3000d4c0:	e59d3004 	ldr	r3, [sp, #4]
3000d4c4:	e5d33008 	ldrb	r3, [r3, #8]
3000d4c8:	e1a03c03 	lsl	r3, r3, #24
3000d4cc:	e1a03c43 	asr	r3, r3, #24
}
3000d4d0:	e1a00003 	mov	r0, r3
3000d4d4:	e28dd024 	add	sp, sp, #36	; 0x24
3000d4d8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d4dc:	e12fff1e 	bx	lr
3000d4e0:	3000f180 	.word	0x3000f180

3000d4e4 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
3000d4e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d4e8:	e24dd024 	sub	sp, sp, #36	; 0x24
3000d4ec:	e58d000c 	str	r0, [sp, #12]
3000d4f0:	e58d1008 	str	r1, [sp, #8]
3000d4f4:	e58d2004 	str	r2, [sp, #4]
3000d4f8:	e58d3000 	str	r3, [sp]
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
3000d4fc:	e59d300c 	ldr	r3, [sp, #12]
3000d500:	e58d3018 	str	r3, [sp, #24]
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
3000d504:	e59d3018 	ldr	r3, [sp, #24]
3000d508:	e3530000 	cmp	r3, #0
3000d50c:	0a00005c 	beq	3000d684 <recv_raw+0x1a0>
3000d510:	e59d3018 	ldr	r3, [sp, #24]
3000d514:	e5933010 	ldr	r3, [r3, #16]
3000d518:	e3530000 	cmp	r3, #0
3000d51c:	0a000058 	beq	3000d684 <recv_raw+0x1a0>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
3000d520:	e59d3004 	ldr	r3, [sp, #4]
3000d524:	e1d330b8 	ldrh	r3, [r3, #8]
3000d528:	e3a00003 	mov	r0, #3
3000d52c:	e1a01003 	mov	r1, r3
3000d530:	e3a02000 	mov	r2, #0
3000d534:	eb00219f 	bl	30015bb8 <pbuf_alloc>
3000d538:	e1a03000 	mov	r3, r0
3000d53c:	e58d3010 	str	r3, [sp, #16]
    if(q != NULL) {
3000d540:	e59d3010 	ldr	r3, [sp, #16]
3000d544:	e3530000 	cmp	r3, #0
3000d548:	0a00000a 	beq	3000d578 <recv_raw+0x94>
      if (pbuf_copy(q, p) != ERR_OK) {
3000d54c:	e59d0010 	ldr	r0, [sp, #16]
3000d550:	e59d1004 	ldr	r1, [sp, #4]
3000d554:	eb00240f 	bl	30016598 <pbuf_copy>
3000d558:	e1a03000 	mov	r3, r0
3000d55c:	e20330ff 	and	r3, r3, #255	; 0xff
3000d560:	e3530000 	cmp	r3, #0
3000d564:	0a000003 	beq	3000d578 <recv_raw+0x94>
        pbuf_free(q);
3000d568:	e59d0010 	ldr	r0, [sp, #16]
3000d56c:	eb002343 	bl	30016280 <pbuf_free>
        q = NULL;
3000d570:	e3a03000 	mov	r3, #0
3000d574:	e58d3010 	str	r3, [sp, #16]
      }
    }

    if(q != NULL) {
3000d578:	e59d3010 	ldr	r3, [sp, #16]
3000d57c:	e3530000 	cmp	r3, #0
3000d580:	0a00003f 	beq	3000d684 <recv_raw+0x1a0>
      buf = memp_malloc(MEMP_NETBUF);
3000d584:	e3a00005 	mov	r0, #5
3000d588:	eb001f69 	bl	30015334 <memp_malloc>
3000d58c:	e1a03000 	mov	r3, r0
3000d590:	e58d3014 	str	r3, [sp, #20]
      if (buf == NULL) {
3000d594:	e59d3014 	ldr	r3, [sp, #20]
3000d598:	e3530000 	cmp	r3, #0
3000d59c:	1a000003 	bne	3000d5b0 <recv_raw+0xcc>
        pbuf_free(q);
3000d5a0:	e59d0010 	ldr	r0, [sp, #16]
3000d5a4:	eb002335 	bl	30016280 <pbuf_free>
        return 0;
3000d5a8:	e3a03000 	mov	r3, #0
3000d5ac:	ea000035 	b	3000d688 <recv_raw+0x1a4>
      }

      buf->p = q;
3000d5b0:	e59d3014 	ldr	r3, [sp, #20]
3000d5b4:	e59d2010 	ldr	r2, [sp, #16]
3000d5b8:	e5832000 	str	r2, [r3]
      buf->ptr = q;
3000d5bc:	e59d3014 	ldr	r3, [sp, #20]
3000d5c0:	e59d2010 	ldr	r2, [sp, #16]
3000d5c4:	e5832004 	str	r2, [r3, #4]
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
3000d5c8:	e59d3010 	ldr	r3, [sp, #16]
3000d5cc:	e5933004 	ldr	r3, [r3, #4]
3000d5d0:	e283200c 	add	r2, r3, #12
3000d5d4:	e59d3014 	ldr	r3, [sp, #20]
3000d5d8:	e5832008 	str	r2, [r3, #8]
      buf->port = pcb->protocol;
3000d5dc:	e59d3008 	ldr	r3, [sp, #8]
3000d5e0:	e5d33010 	ldrb	r3, [r3, #16]
3000d5e4:	e1a02003 	mov	r2, r3
3000d5e8:	e59d3014 	ldr	r3, [sp, #20]
3000d5ec:	e1c320bc 	strh	r2, [r3, #12]

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
3000d5f0:	ebffd03f 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000d5f4:	e1a03000 	mov	r3, r0
3000d5f8:	e58d301c 	str	r3, [sp, #28]
3000d5fc:	e59d3018 	ldr	r3, [sp, #24]
3000d600:	e1d321bc 	ldrh	r2, [r3, #28]
3000d604:	e59d3010 	ldr	r3, [sp, #16]
3000d608:	e1d330b8 	ldrh	r3, [r3, #8]
3000d60c:	e0823003 	add	r3, r2, r3
3000d610:	e1a03803 	lsl	r3, r3, #16
3000d614:	e1a02823 	lsr	r2, r3, #16
3000d618:	e59d3018 	ldr	r3, [sp, #24]
3000d61c:	e1c321bc 	strh	r2, [r3, #28]
3000d620:	e59d001c 	ldr	r0, [sp, #28]
3000d624:	ebffd030 	bl	300016ec <HAL_INTR_RESTORE>
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
3000d628:	e59d3018 	ldr	r3, [sp, #24]
3000d62c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d630:	e3530000 	cmp	r3, #0
3000d634:	0a000007 	beq	3000d658 <recv_raw+0x174>
3000d638:	e59d3018 	ldr	r3, [sp, #24]
3000d63c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d640:	e59d2010 	ldr	r2, [sp, #16]
3000d644:	e1d220b8 	ldrh	r2, [r2, #8]
3000d648:	e59d0018 	ldr	r0, [sp, #24]
3000d64c:	e3a01000 	mov	r1, #0
3000d650:	e1a0e00f 	mov	lr, pc
3000d654:	e12fff13 	bx	r3
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
3000d658:	e59d3018 	ldr	r3, [sp, #24]
3000d65c:	e5933010 	ldr	r3, [r3, #16]
3000d660:	e1a00003 	mov	r0, r3
3000d664:	e59d1014 	ldr	r1, [sp, #20]
3000d668:	ebfffcf4 	bl	3000ca40 <sys_mbox_trypost>
3000d66c:	e1a03000 	mov	r3, r0
3000d670:	e20330ff 	and	r3, r3, #255	; 0xff
3000d674:	e3530000 	cmp	r3, #0
3000d678:	0a000001 	beq	3000d684 <recv_raw+0x1a0>
        netbuf_delete(buf);
3000d67c:	e59d0014 	ldr	r0, [sp, #20]
3000d680:	eb0006f9 	bl	3000f26c <netbuf_delete>
      }
    }
  }

  return 0; /* do not eat the packet */
3000d684:	e3a03000 	mov	r3, #0
}
3000d688:	e1a00003 	mov	r0, r3
3000d68c:	e28dd024 	add	sp, sp, #36	; 0x24
3000d690:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d694:	e12fff1e 	bx	lr

3000d698 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
3000d698:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d69c:	e24dd024 	sub	sp, sp, #36	; 0x24
3000d6a0:	e58d000c 	str	r0, [sp, #12]
3000d6a4:	e58d1008 	str	r1, [sp, #8]
3000d6a8:	e58d2004 	str	r2, [sp, #4]
3000d6ac:	e58d3000 	str	r3, [sp]
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  conn = arg;
3000d6b0:	e59d300c 	ldr	r3, [sp, #12]
3000d6b4:	e58d3018 	str	r3, [sp, #24]
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
3000d6b8:	e59d3018 	ldr	r3, [sp, #24]
3000d6bc:	e3530000 	cmp	r3, #0
3000d6c0:	0a000003 	beq	3000d6d4 <recv_udp+0x3c>
3000d6c4:	e59d3018 	ldr	r3, [sp, #24]
3000d6c8:	e5933010 	ldr	r3, [r3, #16]
3000d6cc:	e3530000 	cmp	r3, #0
3000d6d0:	1a000002 	bne	3000d6e0 <recv_udp+0x48>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
3000d6d4:	e59d0004 	ldr	r0, [sp, #4]
3000d6d8:	eb0022e8 	bl	30016280 <pbuf_free>
    return;
3000d6dc:	ea00003b 	b	3000d7d0 <recv_udp+0x138>
  }

  buf = memp_malloc(MEMP_NETBUF);
3000d6e0:	e3a00005 	mov	r0, #5
3000d6e4:	eb001f12 	bl	30015334 <memp_malloc>
3000d6e8:	e1a03000 	mov	r3, r0
3000d6ec:	e58d3014 	str	r3, [sp, #20]
  if (buf == NULL) {
3000d6f0:	e59d3014 	ldr	r3, [sp, #20]
3000d6f4:	e3530000 	cmp	r3, #0
3000d6f8:	1a000002 	bne	3000d708 <recv_udp+0x70>
    pbuf_free(p);
3000d6fc:	e59d0004 	ldr	r0, [sp, #4]
3000d700:	eb0022de 	bl	30016280 <pbuf_free>
    return;
3000d704:	ea000031 	b	3000d7d0 <recv_udp+0x138>
  } else {
    buf->p = p;
3000d708:	e59d3014 	ldr	r3, [sp, #20]
3000d70c:	e59d2004 	ldr	r2, [sp, #4]
3000d710:	e5832000 	str	r2, [r3]
    buf->ptr = p;
3000d714:	e59d3014 	ldr	r3, [sp, #20]
3000d718:	e59d2004 	ldr	r2, [sp, #4]
3000d71c:	e5832004 	str	r2, [r3, #4]
    buf->addr = addr;
3000d720:	e59d3014 	ldr	r3, [sp, #20]
3000d724:	e59d2000 	ldr	r2, [sp]
3000d728:	e5832008 	str	r2, [r3, #8]
    buf->port = port;
3000d72c:	e59d3014 	ldr	r3, [sp, #20]
3000d730:	e1dd22b8 	ldrh	r2, [sp, #40]	; 0x28
3000d734:	e1c320bc 	strh	r2, [r3, #12]
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
3000d738:	ebffcfed 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000d73c:	e1a03000 	mov	r3, r0
3000d740:	e58d301c 	str	r3, [sp, #28]
3000d744:	e59d3018 	ldr	r3, [sp, #24]
3000d748:	e1d321bc 	ldrh	r2, [r3, #28]
3000d74c:	e59d3004 	ldr	r3, [sp, #4]
3000d750:	e1d330b8 	ldrh	r3, [r3, #8]
3000d754:	e0823003 	add	r3, r2, r3
3000d758:	e1a03803 	lsl	r3, r3, #16
3000d75c:	e1a02823 	lsr	r2, r3, #16
3000d760:	e59d3018 	ldr	r3, [sp, #24]
3000d764:	e1c321bc 	strh	r2, [r3, #28]
3000d768:	e59d001c 	ldr	r0, [sp, #28]
3000d76c:	ebffcfde 	bl	300016ec <HAL_INTR_RESTORE>
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
3000d770:	e59d3018 	ldr	r3, [sp, #24]
3000d774:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d778:	e3530000 	cmp	r3, #0
3000d77c:	0a000007 	beq	3000d7a0 <recv_udp+0x108>
3000d780:	e59d3018 	ldr	r3, [sp, #24]
3000d784:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d788:	e59d2004 	ldr	r2, [sp, #4]
3000d78c:	e1d220b8 	ldrh	r2, [r2, #8]
3000d790:	e59d0018 	ldr	r0, [sp, #24]
3000d794:	e3a01000 	mov	r1, #0
3000d798:	e1a0e00f 	mov	lr, pc
3000d79c:	e12fff13 	bx	r3
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
3000d7a0:	e59d3018 	ldr	r3, [sp, #24]
3000d7a4:	e5933010 	ldr	r3, [r3, #16]
3000d7a8:	e1a00003 	mov	r0, r3
3000d7ac:	e59d1014 	ldr	r1, [sp, #20]
3000d7b0:	ebfffca2 	bl	3000ca40 <sys_mbox_trypost>
3000d7b4:	e1a03000 	mov	r3, r0
3000d7b8:	e20330ff 	and	r3, r3, #255	; 0xff
3000d7bc:	e3530000 	cmp	r3, #0
3000d7c0:	0a000002 	beq	3000d7d0 <recv_udp+0x138>
    netbuf_delete(buf);
3000d7c4:	e59d0014 	ldr	r0, [sp, #20]
3000d7c8:	eb0006a7 	bl	3000f26c <netbuf_delete>
    return;
3000d7cc:	e1a00000 	nop			; (mov r0, r0)
  }
}
3000d7d0:	e28dd024 	add	sp, sp, #36	; 0x24
3000d7d4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d7d8:	e12fff1e 	bx	lr

3000d7dc <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
3000d7dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d7e0:	e24dd024 	sub	sp, sp, #36	; 0x24
3000d7e4:	e58d000c 	str	r0, [sp, #12]
3000d7e8:	e58d1008 	str	r1, [sp, #8]
3000d7ec:	e58d2004 	str	r2, [sp, #4]
3000d7f0:	e5cd3003 	strb	r3, [sp, #3]
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = arg;
3000d7f4:	e59d300c 	ldr	r3, [sp, #12]
3000d7f8:	e58d3014 	str	r3, [sp, #20]
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
3000d7fc:	e59d3014 	ldr	r3, [sp, #20]
3000d800:	e3530000 	cmp	r3, #0
3000d804:	0a000003 	beq	3000d818 <recv_tcp+0x3c>
3000d808:	e59d3014 	ldr	r3, [sp, #20]
3000d80c:	e5933010 	ldr	r3, [r3, #16]
3000d810:	e3530000 	cmp	r3, #0
3000d814:	1a000001 	bne	3000d820 <recv_tcp+0x44>
    return ERR_VAL;
3000d818:	e3a030f8 	mov	r3, #248	; 0xf8
3000d81c:	ea00002f 	b	3000d8e0 <recv_tcp+0x104>
  }

  conn->err = err;
3000d820:	e59d3014 	ldr	r3, [sp, #20]
3000d824:	e5dd2003 	ldrb	r2, [sp, #3]
3000d828:	e5c32008 	strb	r2, [r3, #8]
  if (p != NULL) {
3000d82c:	e59d3004 	ldr	r3, [sp, #4]
3000d830:	e3530000 	cmp	r3, #0
3000d834:	0a000010 	beq	3000d87c <recv_tcp+0xa0>
    len = p->tot_len;
3000d838:	e59d3004 	ldr	r3, [sp, #4]
3000d83c:	e1d330b8 	ldrh	r3, [r3, #8]
3000d840:	e1cd31ba 	strh	r3, [sp, #26]
    SYS_ARCH_INC(conn->recv_avail, len);
3000d844:	ebffcfaa 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3000d848:	e1a03000 	mov	r3, r0
3000d84c:	e58d301c 	str	r3, [sp, #28]
3000d850:	e59d3014 	ldr	r3, [sp, #20]
3000d854:	e1d321bc 	ldrh	r2, [r3, #28]
3000d858:	e1dd31ba 	ldrh	r3, [sp, #26]
3000d85c:	e0823003 	add	r3, r2, r3
3000d860:	e1a03803 	lsl	r3, r3, #16
3000d864:	e1a02823 	lsr	r2, r3, #16
3000d868:	e59d3014 	ldr	r3, [sp, #20]
3000d86c:	e1c321bc 	strh	r2, [r3, #28]
3000d870:	e59d001c 	ldr	r0, [sp, #28]
3000d874:	ebffcf9c 	bl	300016ec <HAL_INTR_RESTORE>
3000d878:	ea000001 	b	3000d884 <recv_tcp+0xa8>
  } else {
    len = 0;
3000d87c:	e3a03000 	mov	r3, #0
3000d880:	e1cd31ba 	strh	r3, [sp, #26]
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
3000d884:	e59d3014 	ldr	r3, [sp, #20]
3000d888:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d88c:	e3530000 	cmp	r3, #0
3000d890:	0a000006 	beq	3000d8b0 <recv_tcp+0xd4>
3000d894:	e59d3014 	ldr	r3, [sp, #20]
3000d898:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d89c:	e1dd21ba 	ldrh	r2, [sp, #26]
3000d8a0:	e59d0014 	ldr	r0, [sp, #20]
3000d8a4:	e3a01000 	mov	r1, #0
3000d8a8:	e1a0e00f 	mov	lr, pc
3000d8ac:	e12fff13 	bx	r3
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
3000d8b0:	e59d3014 	ldr	r3, [sp, #20]
3000d8b4:	e5933010 	ldr	r3, [r3, #16]
3000d8b8:	e1a00003 	mov	r0, r3
3000d8bc:	e59d1004 	ldr	r1, [sp, #4]
3000d8c0:	ebfffc5e 	bl	3000ca40 <sys_mbox_trypost>
3000d8c4:	e1a03000 	mov	r3, r0
3000d8c8:	e20330ff 	and	r3, r3, #255	; 0xff
3000d8cc:	e3530000 	cmp	r3, #0
3000d8d0:	0a000001 	beq	3000d8dc <recv_tcp+0x100>
    return ERR_MEM;
3000d8d4:	e3a030ff 	mov	r3, #255	; 0xff
3000d8d8:	ea000000 	b	3000d8e0 <recv_tcp+0x104>
  }

  return ERR_OK;
3000d8dc:	e3a03000 	mov	r3, #0
3000d8e0:	e1a03c03 	lsl	r3, r3, #24
3000d8e4:	e1a03c43 	asr	r3, r3, #24
}
3000d8e8:	e1a00003 	mov	r0, r3
3000d8ec:	e28dd024 	add	sp, sp, #36	; 0x24
3000d8f0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d8f4:	e12fff1e 	bx	lr

3000d8f8 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
3000d8f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d8fc:	e24dd014 	sub	sp, sp, #20
3000d900:	e58d0004 	str	r0, [sp, #4]
3000d904:	e58d1000 	str	r1, [sp]
  struct netconn *conn = arg;
3000d908:	e59d3004 	ldr	r3, [sp, #4]
3000d90c:	e58d300c 	str	r3, [sp, #12]

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn->state == NETCONN_WRITE) {
3000d910:	e59d300c 	ldr	r3, [sp, #12]
3000d914:	e5d33001 	ldrb	r3, [r3, #1]
3000d918:	e3530001 	cmp	r3, #1
3000d91c:	1a000002 	bne	3000d92c <poll_tcp+0x34>
    do_writemore(conn);
3000d920:	e59d000c 	ldr	r0, [sp, #12]
3000d924:	eb0004c7 	bl	3000ec48 <do_writemore>
3000d928:	ea000005 	b	3000d944 <poll_tcp+0x4c>
  } else if (conn->state == NETCONN_CLOSE) {
3000d92c:	e59d300c 	ldr	r3, [sp, #12]
3000d930:	e5d33001 	ldrb	r3, [r3, #1]
3000d934:	e3530004 	cmp	r3, #4
3000d938:	1a000001 	bne	3000d944 <poll_tcp+0x4c>
    do_close_internal(conn);
3000d93c:	e59d000c 	ldr	r0, [sp, #12]
3000d940:	eb00020e 	bl	3000e180 <do_close_internal>
  }

  return ERR_OK;
3000d944:	e3a03000 	mov	r3, #0
3000d948:	e1a03c03 	lsl	r3, r3, #24
3000d94c:	e1a03c43 	asr	r3, r3, #24
}
3000d950:	e1a00003 	mov	r0, r3
3000d954:	e28dd014 	add	sp, sp, #20
3000d958:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000d95c:	e12fff1e 	bx	lr

3000d960 <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
3000d960:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000d964:	e24dd01c 	sub	sp, sp, #28
3000d968:	e58d000c 	str	r0, [sp, #12]
3000d96c:	e58d1008 	str	r1, [sp, #8]
3000d970:	e1a03002 	mov	r3, r2
3000d974:	e1cd30b6 	strh	r3, [sp, #6]
  struct netconn *conn = arg;
3000d978:	e59d300c 	ldr	r3, [sp, #12]
3000d97c:	e58d3014 	str	r3, [sp, #20]

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn->state == NETCONN_WRITE) {
3000d980:	e59d3014 	ldr	r3, [sp, #20]
3000d984:	e5d33001 	ldrb	r3, [r3, #1]
3000d988:	e3530001 	cmp	r3, #1
3000d98c:	1a000002 	bne	3000d99c <sent_tcp+0x3c>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
    do_writemore(conn);
3000d990:	e59d0014 	ldr	r0, [sp, #20]
3000d994:	eb0004ab 	bl	3000ec48 <do_writemore>
3000d998:	ea000005 	b	3000d9b4 <sent_tcp+0x54>
  } else if (conn->state == NETCONN_CLOSE) {
3000d99c:	e59d3014 	ldr	r3, [sp, #20]
3000d9a0:	e5d33001 	ldrb	r3, [r3, #1]
3000d9a4:	e3530004 	cmp	r3, #4
3000d9a8:	1a000001 	bne	3000d9b4 <sent_tcp+0x54>
    do_close_internal(conn);
3000d9ac:	e59d0014 	ldr	r0, [sp, #20]
3000d9b0:	eb0001f2 	bl	3000e180 <do_close_internal>
  }

  if (conn) {
3000d9b4:	e59d3014 	ldr	r3, [sp, #20]
3000d9b8:	e3530000 	cmp	r3, #0
3000d9bc:	0a000013 	beq	3000da10 <sent_tcp+0xb0>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
3000d9c0:	e59d3014 	ldr	r3, [sp, #20]
3000d9c4:	e5933004 	ldr	r3, [r3, #4]
3000d9c8:	e3530000 	cmp	r3, #0
3000d9cc:	0a00000f 	beq	3000da10 <sent_tcp+0xb0>
3000d9d0:	e59d3014 	ldr	r3, [sp, #20]
3000d9d4:	e5933004 	ldr	r3, [r3, #4]
3000d9d8:	e1d336ba 	ldrh	r3, [r3, #106]	; 0x6a
3000d9dc:	e3530a01 	cmp	r3, #4096	; 0x1000
3000d9e0:	9a00000a 	bls	3000da10 <sent_tcp+0xb0>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
3000d9e4:	e59d3014 	ldr	r3, [sp, #20]
3000d9e8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d9ec:	e3530000 	cmp	r3, #0
3000d9f0:	0a000006 	beq	3000da10 <sent_tcp+0xb0>
3000d9f4:	e59d3014 	ldr	r3, [sp, #20]
3000d9f8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000d9fc:	e1dd20b6 	ldrh	r2, [sp, #6]
3000da00:	e59d0014 	ldr	r0, [sp, #20]
3000da04:	e3a01002 	mov	r1, #2
3000da08:	e1a0e00f 	mov	lr, pc
3000da0c:	e12fff13 	bx	r3
    }
  }
  
  return ERR_OK;
3000da10:	e3a03000 	mov	r3, #0
3000da14:	e1a03c03 	lsl	r3, r3, #24
3000da18:	e1a03c43 	asr	r3, r3, #24
}
3000da1c:	e1a00003 	mov	r0, r3
3000da20:	e28dd01c 	add	sp, sp, #28
3000da24:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000da28:	e12fff1e 	bx	lr

3000da2c <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
3000da2c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000da30:	e24dd014 	sub	sp, sp, #20
3000da34:	e58d0004 	str	r0, [sp, #4]
3000da38:	e1a03001 	mov	r3, r1
3000da3c:	e5cd3003 	strb	r3, [sp, #3]
  struct netconn *conn;

  conn = arg;
3000da40:	e59d3004 	ldr	r3, [sp, #4]
3000da44:	e58d300c 	str	r3, [sp, #12]
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  conn->pcb.tcp = NULL;
3000da48:	e59d300c 	ldr	r3, [sp, #12]
3000da4c:	e3a02000 	mov	r2, #0
3000da50:	e5832004 	str	r2, [r3, #4]

  conn->err = err;
3000da54:	e59d300c 	ldr	r3, [sp, #12]
3000da58:	e5dd2003 	ldrb	r2, [sp, #3]
3000da5c:	e5c32008 	strb	r2, [r3, #8]
  if (conn->recvmbox != SYS_MBOX_NULL) {
3000da60:	e59d300c 	ldr	r3, [sp, #12]
3000da64:	e5933010 	ldr	r3, [r3, #16]
3000da68:	e3530000 	cmp	r3, #0
3000da6c:	0a00000f 	beq	3000dab0 <err_tcp+0x84>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
3000da70:	e59d300c 	ldr	r3, [sp, #12]
3000da74:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000da78:	e3530000 	cmp	r3, #0
3000da7c:	0a000006 	beq	3000da9c <err_tcp+0x70>
3000da80:	e59d300c 	ldr	r3, [sp, #12]
3000da84:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000da88:	e59d000c 	ldr	r0, [sp, #12]
3000da8c:	e3a01000 	mov	r1, #0
3000da90:	e3a02000 	mov	r2, #0
3000da94:	e1a0e00f 	mov	lr, pc
3000da98:	e12fff13 	bx	r3
    sys_mbox_post(conn->recvmbox, NULL);
3000da9c:	e59d300c 	ldr	r3, [sp, #12]
3000daa0:	e5933010 	ldr	r3, [r3, #16]
3000daa4:	e1a00003 	mov	r0, r3
3000daa8:	e3a01000 	mov	r1, #0
3000daac:	ebfffbca 	bl	3000c9dc <sys_mbox_post>
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
3000dab0:	e59d300c 	ldr	r3, [sp, #12]
3000dab4:	e593300c 	ldr	r3, [r3, #12]
3000dab8:	e3530000 	cmp	r3, #0
3000dabc:	0a00000a 	beq	3000daec <err_tcp+0xc0>
3000dac0:	e59d300c 	ldr	r3, [sp, #12]
3000dac4:	e5d33001 	ldrb	r3, [r3, #1]
3000dac8:	e3530003 	cmp	r3, #3
3000dacc:	1a000006 	bne	3000daec <err_tcp+0xc0>
    conn->state = NETCONN_NONE;
3000dad0:	e59d300c 	ldr	r3, [sp, #12]
3000dad4:	e3a02000 	mov	r2, #0
3000dad8:	e5c32001 	strb	r2, [r3, #1]
    sys_sem_signal(conn->op_completed);
3000dadc:	e59d300c 	ldr	r3, [sp, #12]
3000dae0:	e593300c 	ldr	r3, [r3, #12]
3000dae4:	e1a00003 	mov	r0, r3
3000dae8:	ebfffb8e 	bl	3000c928 <sys_sem_signal>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
3000daec:	e59d300c 	ldr	r3, [sp, #12]
3000daf0:	e5933014 	ldr	r3, [r3, #20]
3000daf4:	e3530000 	cmp	r3, #0
3000daf8:	0a00000f 	beq	3000db3c <err_tcp+0x110>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
3000dafc:	e59d300c 	ldr	r3, [sp, #12]
3000db00:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000db04:	e3530000 	cmp	r3, #0
3000db08:	0a000006 	beq	3000db28 <err_tcp+0xfc>
3000db0c:	e59d300c 	ldr	r3, [sp, #12]
3000db10:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000db14:	e59d000c 	ldr	r0, [sp, #12]
3000db18:	e3a01000 	mov	r1, #0
3000db1c:	e3a02000 	mov	r2, #0
3000db20:	e1a0e00f 	mov	lr, pc
3000db24:	e12fff13 	bx	r3
    sys_mbox_post(conn->acceptmbox, NULL);
3000db28:	e59d300c 	ldr	r3, [sp, #12]
3000db2c:	e5933014 	ldr	r3, [r3, #20]
3000db30:	e1a00003 	mov	r0, r3
3000db34:	e3a01000 	mov	r1, #0
3000db38:	ebfffba7 	bl	3000c9dc <sys_mbox_post>
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
3000db3c:	e59d300c 	ldr	r3, [sp, #12]
3000db40:	e5d33001 	ldrb	r3, [r3, #1]
3000db44:	e3530001 	cmp	r3, #1
3000db48:	0a000003 	beq	3000db5c <err_tcp+0x130>
3000db4c:	e59d300c 	ldr	r3, [sp, #12]
3000db50:	e5d33001 	ldrb	r3, [r3, #1]
3000db54:	e3530004 	cmp	r3, #4
3000db58:	1a000006 	bne	3000db78 <err_tcp+0x14c>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
3000db5c:	e59d300c 	ldr	r3, [sp, #12]
3000db60:	e3a02000 	mov	r2, #0
3000db64:	e5c32001 	strb	r2, [r3, #1]
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
3000db68:	e59d300c 	ldr	r3, [sp, #12]
3000db6c:	e593300c 	ldr	r3, [r3, #12]
3000db70:	e1a00003 	mov	r0, r3
3000db74:	ebfffb6b 	bl	3000c928 <sys_sem_signal>
  }
}
3000db78:	e28dd014 	add	sp, sp, #20
3000db7c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000db80:	e12fff1e 	bx	lr

3000db84 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
3000db84:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000db88:	e24dd014 	sub	sp, sp, #20
3000db8c:	e58d0004 	str	r0, [sp, #4]
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
3000db90:	e59d3004 	ldr	r3, [sp, #4]
3000db94:	e5933004 	ldr	r3, [r3, #4]
3000db98:	e58d300c 	str	r3, [sp, #12]
  tcp_arg(pcb, conn);
3000db9c:	e59d000c 	ldr	r0, [sp, #12]
3000dba0:	e59d1004 	ldr	r1, [sp, #4]
3000dba4:	eb002d86 	bl	300191c4 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
3000dba8:	e59d000c 	ldr	r0, [sp, #12]
3000dbac:	e59f1034 	ldr	r1, [pc, #52]	; 3000dbe8 <setup_tcp+0x64>
3000dbb0:	eb002d8b 	bl	300191e4 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
3000dbb4:	e59d000c 	ldr	r0, [sp, #12]
3000dbb8:	e59f102c 	ldr	r1, [pc, #44]	; 3000dbec <setup_tcp+0x68>
3000dbbc:	eb002d90 	bl	30019204 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
3000dbc0:	e59d000c 	ldr	r0, [sp, #12]
3000dbc4:	e59f1024 	ldr	r1, [pc, #36]	; 3000dbf0 <setup_tcp+0x6c>
3000dbc8:	e3a02004 	mov	r2, #4
3000dbcc:	eb002da4 	bl	30019264 <tcp_poll>
  tcp_err(pcb, err_tcp);
3000dbd0:	e59d000c 	ldr	r0, [sp, #12]
3000dbd4:	e59f1018 	ldr	r1, [pc, #24]	; 3000dbf4 <setup_tcp+0x70>
3000dbd8:	eb002d91 	bl	30019224 <tcp_err>
}
3000dbdc:	e28dd014 	add	sp, sp, #20
3000dbe0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000dbe4:	e12fff1e 	bx	lr
3000dbe8:	3000d7dc 	.word	0x3000d7dc
3000dbec:	3000d960 	.word	0x3000d960
3000dbf0:	3000d8f8 	.word	0x3000d8f8
3000dbf4:	3000da2c 	.word	0x3000da2c

3000dbf8 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
3000dbf8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000dbfc:	e24dd01c 	sub	sp, sp, #28
3000dc00:	e58d000c 	str	r0, [sp, #12]
3000dc04:	e58d1008 	str	r1, [sp, #8]
3000dc08:	e1a03002 	mov	r3, r2
3000dc0c:	e5cd3007 	strb	r3, [sp, #7]
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
3000dc10:	e59d300c 	ldr	r3, [sp, #12]
3000dc14:	e58d3014 	str	r3, [sp, #20]
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
3000dc18:	e59d3014 	ldr	r3, [sp, #20]
3000dc1c:	e5d32000 	ldrb	r2, [r3]
3000dc20:	e59d3014 	ldr	r3, [sp, #20]
3000dc24:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000dc28:	e1a00002 	mov	r0, r2
3000dc2c:	e1a01003 	mov	r1, r3
3000dc30:	eb0000b6 	bl	3000df10 <netconn_alloc>
3000dc34:	e1a03000 	mov	r3, r0
3000dc38:	e58d3010 	str	r3, [sp, #16]
  if (newconn == NULL) {
3000dc3c:	e59d3010 	ldr	r3, [sp, #16]
3000dc40:	e3530000 	cmp	r3, #0
3000dc44:	1a000001 	bne	3000dc50 <accept_function+0x58>
    return ERR_MEM;
3000dc48:	e3a030ff 	mov	r3, #255	; 0xff
3000dc4c:	ea000023 	b	3000dce0 <accept_function+0xe8>
  }
  newconn->pcb.tcp = newpcb;
3000dc50:	e59d3010 	ldr	r3, [sp, #16]
3000dc54:	e59d2008 	ldr	r2, [sp, #8]
3000dc58:	e5832004 	str	r2, [r3, #4]
  setup_tcp(newconn);
3000dc5c:	e59d0010 	ldr	r0, [sp, #16]
3000dc60:	ebffffc7 	bl	3000db84 <setup_tcp>
  newconn->err = err;
3000dc64:	e59d3010 	ldr	r3, [sp, #16]
3000dc68:	e5dd2007 	ldrb	r2, [sp, #7]
3000dc6c:	e5c32008 	strb	r2, [r3, #8]
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
3000dc70:	e59d3014 	ldr	r3, [sp, #20]
3000dc74:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000dc78:	e3530000 	cmp	r3, #0
3000dc7c:	0a000006 	beq	3000dc9c <accept_function+0xa4>
3000dc80:	e59d3014 	ldr	r3, [sp, #20]
3000dc84:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000dc88:	e59d0014 	ldr	r0, [sp, #20]
3000dc8c:	e3a01000 	mov	r1, #0
3000dc90:	e3a02000 	mov	r2, #0
3000dc94:	e1a0e00f 	mov	lr, pc
3000dc98:	e12fff13 	bx	r3

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
3000dc9c:	e59d3014 	ldr	r3, [sp, #20]
3000dca0:	e5933014 	ldr	r3, [r3, #20]
3000dca4:	e1a00003 	mov	r0, r3
3000dca8:	e59d1010 	ldr	r1, [sp, #16]
3000dcac:	ebfffb63 	bl	3000ca40 <sys_mbox_trypost>
3000dcb0:	e1a03000 	mov	r3, r0
3000dcb4:	e20330ff 	and	r3, r3, #255	; 0xff
3000dcb8:	e3530000 	cmp	r3, #0
3000dcbc:	0a000006 	beq	3000dcdc <accept_function+0xe4>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
3000dcc0:	e59d3010 	ldr	r3, [sp, #16]
3000dcc4:	e3a02000 	mov	r2, #0
3000dcc8:	e5832004 	str	r2, [r3, #4]
    netconn_free(newconn);
3000dccc:	e59d0010 	ldr	r0, [sp, #16]
3000dcd0:	eb0000db 	bl	3000e044 <netconn_free>
    return ERR_MEM;
3000dcd4:	e3a030ff 	mov	r3, #255	; 0xff
3000dcd8:	ea000000 	b	3000dce0 <accept_function+0xe8>
  }
  return ERR_OK;
3000dcdc:	e3a03000 	mov	r3, #0
3000dce0:	e1a03c03 	lsl	r3, r3, #24
3000dce4:	e1a03c43 	asr	r3, r3, #24
}
3000dce8:	e1a00003 	mov	r0, r3
3000dcec:	e28dd01c 	add	sp, sp, #28
3000dcf0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000dcf4:	e12fff1e 	bx	lr

3000dcf8 <pcb_new>:
 * @param msg the api_msg_msg describing the connection type
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
3000dcf8:	e92d4010 	push	{r4, lr}
3000dcfc:	e24dd008 	sub	sp, sp, #8
3000dd00:	e58d0004 	str	r0, [sp, #4]
   msg->conn->err = ERR_OK;
3000dd04:	e59d3004 	ldr	r3, [sp, #4]
3000dd08:	e5933000 	ldr	r3, [r3]
3000dd0c:	e3a02000 	mov	r2, #0
3000dd10:	e5c32008 	strb	r2, [r3, #8]

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
3000dd14:	e59d3004 	ldr	r3, [sp, #4]
3000dd18:	e5933000 	ldr	r3, [r3]
3000dd1c:	e5d33000 	ldrb	r3, [r3]
3000dd20:	e20330f0 	and	r3, r3, #240	; 0xf0
3000dd24:	e3530020 	cmp	r3, #32
3000dd28:	0a000020 	beq	3000ddb0 <pcb_new+0xb8>
3000dd2c:	e3530040 	cmp	r3, #64	; 0x40
3000dd30:	0a000002 	beq	3000dd40 <pcb_new+0x48>
3000dd34:	e3530010 	cmp	r3, #16
3000dd38:	0a00003f 	beq	3000de3c <pcb_new+0x144>
3000dd3c:	ea000052 	b	3000de8c <pcb_new+0x194>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
3000dd40:	e59d3004 	ldr	r3, [sp, #4]
3000dd44:	e5934000 	ldr	r4, [r3]
3000dd48:	e59d3004 	ldr	r3, [sp, #4]
3000dd4c:	e5d33004 	ldrb	r3, [r3, #4]
3000dd50:	e1a00003 	mov	r0, r3
3000dd54:	eb0023f0 	bl	30016d1c <raw_new>
3000dd58:	e1a03000 	mov	r3, r0
3000dd5c:	e5843004 	str	r3, [r4, #4]
     if(msg->conn->pcb.raw == NULL) {
3000dd60:	e59d3004 	ldr	r3, [sp, #4]
3000dd64:	e5933000 	ldr	r3, [r3]
3000dd68:	e5933004 	ldr	r3, [r3, #4]
3000dd6c:	e3530000 	cmp	r3, #0
3000dd70:	1a000004 	bne	3000dd88 <pcb_new+0x90>
       msg->conn->err = ERR_MEM;
3000dd74:	e59d3004 	ldr	r3, [sp, #4]
3000dd78:	e5933000 	ldr	r3, [r3]
3000dd7c:	e3e02000 	mvn	r2, #0
3000dd80:	e5c32008 	strb	r2, [r3, #8]
       break;
3000dd84:	ea000044 	b	3000de9c <pcb_new+0x1a4>
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
3000dd88:	e59d3004 	ldr	r3, [sp, #4]
3000dd8c:	e5933000 	ldr	r3, [r3]
3000dd90:	e5932004 	ldr	r2, [r3, #4]
3000dd94:	e59d3004 	ldr	r3, [sp, #4]
3000dd98:	e5933000 	ldr	r3, [r3]
3000dd9c:	e1a00002 	mov	r0, r2
3000dda0:	e59f1118 	ldr	r1, [pc, #280]	; 3000dec0 <pcb_new+0x1c8>
3000dda4:	e1a02003 	mov	r2, r3
3000dda8:	eb002332 	bl	30016a78 <raw_recv>
     break;
3000ddac:	ea00003a 	b	3000de9c <pcb_new+0x1a4>
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
3000ddb0:	e59d3004 	ldr	r3, [sp, #4]
3000ddb4:	e5934000 	ldr	r4, [r3]
3000ddb8:	eb004ab7 	bl	3002089c <udp_new>
3000ddbc:	e1a03000 	mov	r3, r0
3000ddc0:	e5843004 	str	r3, [r4, #4]
     if(msg->conn->pcb.udp == NULL) {
3000ddc4:	e59d3004 	ldr	r3, [sp, #4]
3000ddc8:	e5933000 	ldr	r3, [r3]
3000ddcc:	e5933004 	ldr	r3, [r3, #4]
3000ddd0:	e3530000 	cmp	r3, #0
3000ddd4:	1a000004 	bne	3000ddec <pcb_new+0xf4>
       msg->conn->err = ERR_MEM;
3000ddd8:	e59d3004 	ldr	r3, [sp, #4]
3000dddc:	e5933000 	ldr	r3, [r3]
3000dde0:	e3e02000 	mvn	r2, #0
3000dde4:	e5c32008 	strb	r2, [r3, #8]
       break;
3000dde8:	ea00002b 	b	3000de9c <pcb_new+0x1a4>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
3000ddec:	e59d3004 	ldr	r3, [sp, #4]
3000ddf0:	e5933000 	ldr	r3, [r3]
3000ddf4:	e5d33000 	ldrb	r3, [r3]
3000ddf8:	e3530022 	cmp	r3, #34	; 0x22
3000ddfc:	1a000004 	bne	3000de14 <pcb_new+0x11c>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
3000de00:	e59d3004 	ldr	r3, [sp, #4]
3000de04:	e5933000 	ldr	r3, [r3]
3000de08:	e5933004 	ldr	r3, [r3, #4]
3000de0c:	e3a02001 	mov	r2, #1
3000de10:	e5c32010 	strb	r2, [r3, #16]
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
3000de14:	e59d3004 	ldr	r3, [sp, #4]
3000de18:	e5933000 	ldr	r3, [r3]
3000de1c:	e5932004 	ldr	r2, [r3, #4]
3000de20:	e59d3004 	ldr	r3, [sp, #4]
3000de24:	e5933000 	ldr	r3, [r3]
3000de28:	e1a00002 	mov	r0, r2
3000de2c:	e59f1090 	ldr	r1, [pc, #144]	; 3000dec4 <pcb_new+0x1cc>
3000de30:	e1a02003 	mov	r2, r3
3000de34:	eb004a60 	bl	300207bc <udp_recv>
     break;
3000de38:	ea000017 	b	3000de9c <pcb_new+0x1a4>
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
3000de3c:	e59d3004 	ldr	r3, [sp, #4]
3000de40:	e5934000 	ldr	r4, [r3]
3000de44:	eb002cd7 	bl	300191a8 <tcp_new>
3000de48:	e1a03000 	mov	r3, r0
3000de4c:	e5843004 	str	r3, [r4, #4]
     if(msg->conn->pcb.tcp == NULL) {
3000de50:	e59d3004 	ldr	r3, [sp, #4]
3000de54:	e5933000 	ldr	r3, [r3]
3000de58:	e5933004 	ldr	r3, [r3, #4]
3000de5c:	e3530000 	cmp	r3, #0
3000de60:	1a000004 	bne	3000de78 <pcb_new+0x180>
       msg->conn->err = ERR_MEM;
3000de64:	e59d3004 	ldr	r3, [sp, #4]
3000de68:	e5933000 	ldr	r3, [r3]
3000de6c:	e3e02000 	mvn	r2, #0
3000de70:	e5c32008 	strb	r2, [r3, #8]
       break;
3000de74:	ea000008 	b	3000de9c <pcb_new+0x1a4>
     }
     setup_tcp(msg->conn);
3000de78:	e59d3004 	ldr	r3, [sp, #4]
3000de7c:	e5933000 	ldr	r3, [r3]
3000de80:	e1a00003 	mov	r0, r3
3000de84:	ebffff3e 	bl	3000db84 <setup_tcp>
     break;
3000de88:	ea000003 	b	3000de9c <pcb_new+0x1a4>
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
3000de8c:	e59d3004 	ldr	r3, [sp, #4]
3000de90:	e5933000 	ldr	r3, [r3]
3000de94:	e3e02007 	mvn	r2, #7
3000de98:	e5c32008 	strb	r2, [r3, #8]
     break;
   }

  return msg->conn->err;
3000de9c:	e59d3004 	ldr	r3, [sp, #4]
3000dea0:	e5933000 	ldr	r3, [r3]
3000dea4:	e5d33008 	ldrb	r3, [r3, #8]
3000dea8:	e1a03c03 	lsl	r3, r3, #24
3000deac:	e1a03c43 	asr	r3, r3, #24
}
3000deb0:	e1a00003 	mov	r0, r3
3000deb4:	e28dd008 	add	sp, sp, #8
3000deb8:	e8bd4010 	pop	{r4, lr}
3000debc:	e12fff1e 	bx	lr
3000dec0:	3000d4e4 	.word	0x3000d4e4
3000dec4:	3000d698 	.word	0x3000d698

3000dec8 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
3000dec8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000decc:	e24dd00c 	sub	sp, sp, #12
3000ded0:	e58d0004 	str	r0, [sp, #4]
   if(msg->conn->pcb.tcp == NULL) {
3000ded4:	e59d3004 	ldr	r3, [sp, #4]
3000ded8:	e5933000 	ldr	r3, [r3]
3000dedc:	e5933004 	ldr	r3, [r3, #4]
3000dee0:	e3530000 	cmp	r3, #0
3000dee4:	1a000001 	bne	3000def0 <do_newconn+0x28>
     pcb_new(msg);
3000dee8:	e59d0004 	ldr	r0, [sp, #4]
3000deec:	ebffff81 	bl	3000dcf8 <pcb_new>
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
3000def0:	e59d3004 	ldr	r3, [sp, #4]
3000def4:	e5933000 	ldr	r3, [r3]
3000def8:	e593300c 	ldr	r3, [r3, #12]
3000defc:	e1a00003 	mov	r0, r3
3000df00:	ebfffa88 	bl	3000c928 <sys_sem_signal>
}
3000df04:	e28dd00c 	add	sp, sp, #12
3000df08:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000df0c:	e12fff1e 	bx	lr

3000df10 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
3000df10:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000df14:	e24dd014 	sub	sp, sp, #20
3000df18:	e1a03000 	mov	r3, r0
3000df1c:	e58d1000 	str	r1, [sp]
3000df20:	e5cd3007 	strb	r3, [sp, #7]
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
3000df24:	e3a00006 	mov	r0, #6
3000df28:	eb001d01 	bl	30015334 <memp_malloc>
3000df2c:	e1a03000 	mov	r3, r0
3000df30:	e58d3008 	str	r3, [sp, #8]
  if (conn == NULL) {
3000df34:	e59d3008 	ldr	r3, [sp, #8]
3000df38:	e3530000 	cmp	r3, #0
3000df3c:	1a000001 	bne	3000df48 <netconn_alloc+0x38>
    return NULL;
3000df40:	e3a03000 	mov	r3, #0
3000df44:	ea00003a 	b	3000e034 <netconn_alloc+0x124>
  }

  conn->err = ERR_OK;
3000df48:	e59d3008 	ldr	r3, [sp, #8]
3000df4c:	e3a02000 	mov	r2, #0
3000df50:	e5c32008 	strb	r2, [r3, #8]
  conn->type = t;
3000df54:	e59d3008 	ldr	r3, [sp, #8]
3000df58:	e5dd2007 	ldrb	r2, [sp, #7]
3000df5c:	e5c32000 	strb	r2, [r3]
  conn->pcb.tcp = NULL;
3000df60:	e59d3008 	ldr	r3, [sp, #8]
3000df64:	e3a02000 	mov	r2, #0
3000df68:	e5832004 	str	r2, [r3, #4]

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
3000df6c:	e3a0300a 	mov	r3, #10
3000df70:	e58d300c 	str	r3, [sp, #12]
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
3000df74:	e3a00000 	mov	r0, #0
3000df78:	ebfffa55 	bl	3000c8d4 <sys_sem_new>
3000df7c:	e1a02000 	mov	r2, r0
3000df80:	e59d3008 	ldr	r3, [sp, #8]
3000df84:	e583200c 	str	r2, [r3, #12]
3000df88:	e59d3008 	ldr	r3, [sp, #8]
3000df8c:	e593300c 	ldr	r3, [r3, #12]
3000df90:	e3530000 	cmp	r3, #0
3000df94:	1a000004 	bne	3000dfac <netconn_alloc+0x9c>
    memp_free(MEMP_NETCONN, conn);
3000df98:	e3a00006 	mov	r0, #6
3000df9c:	e59d1008 	ldr	r1, [sp, #8]
3000dfa0:	eb001d48 	bl	300154c8 <memp_free>
    return NULL;
3000dfa4:	e3a03000 	mov	r3, #0
3000dfa8:	ea000021 	b	3000e034 <netconn_alloc+0x124>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
3000dfac:	e59d000c 	ldr	r0, [sp, #12]
3000dfb0:	ebfffa75 	bl	3000c98c <sys_mbox_new>
3000dfb4:	e1a02000 	mov	r2, r0
3000dfb8:	e59d3008 	ldr	r3, [sp, #8]
3000dfbc:	e5832010 	str	r2, [r3, #16]
3000dfc0:	e59d3008 	ldr	r3, [sp, #8]
3000dfc4:	e5933010 	ldr	r3, [r3, #16]
3000dfc8:	e3530000 	cmp	r3, #0
3000dfcc:	1a000008 	bne	3000dff4 <netconn_alloc+0xe4>
    sys_sem_free(conn->op_completed);
3000dfd0:	e59d3008 	ldr	r3, [sp, #8]
3000dfd4:	e593300c 	ldr	r3, [r3, #12]
3000dfd8:	e1a00003 	mov	r0, r3
3000dfdc:	ebfffa48 	bl	3000c904 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
3000dfe0:	e3a00006 	mov	r0, #6
3000dfe4:	e59d1008 	ldr	r1, [sp, #8]
3000dfe8:	eb001d36 	bl	300154c8 <memp_free>
    return NULL;
3000dfec:	e3a03000 	mov	r3, #0
3000dff0:	ea00000f 	b	3000e034 <netconn_alloc+0x124>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
3000dff4:	e59d3008 	ldr	r3, [sp, #8]
3000dff8:	e3a02000 	mov	r2, #0
3000dffc:	e5832014 	str	r2, [r3, #20]
  conn->state        = NETCONN_NONE;
3000e000:	e59d3008 	ldr	r3, [sp, #8]
3000e004:	e3a02000 	mov	r2, #0
3000e008:	e5c32001 	strb	r2, [r3, #1]
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
3000e00c:	e59d3008 	ldr	r3, [sp, #8]
3000e010:	e3e02000 	mvn	r2, #0
3000e014:	e5832018 	str	r2, [r3, #24]
  conn->callback     = callback;
3000e018:	e59d3008 	ldr	r3, [sp, #8]
3000e01c:	e59d2000 	ldr	r2, [sp]
3000e020:	e5832028 	str	r2, [r3, #40]	; 0x28
  conn->recv_avail   = 0;
3000e024:	e59d3008 	ldr	r3, [sp, #8]
3000e028:	e3a02000 	mov	r2, #0
3000e02c:	e1c321bc 	strh	r2, [r3, #28]
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
3000e030:	e59d3008 	ldr	r3, [sp, #8]
}
3000e034:	e1a00003 	mov	r0, r3
3000e038:	e28dd014 	add	sp, sp, #20
3000e03c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000e040:	e12fff1e 	bx	lr

3000e044 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
3000e044:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000e048:	e24dd014 	sub	sp, sp, #20
3000e04c:	e58d0004 	str	r0, [sp, #4]
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
3000e050:	e59d3004 	ldr	r3, [sp, #4]
3000e054:	e5933010 	ldr	r3, [r3, #16]
3000e058:	e3530000 	cmp	r3, #0
3000e05c:	0a000021 	beq	3000e0e8 <netconn_free+0xa4>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
3000e060:	ea00000f 	b	3000e0a4 <netconn_free+0x60>
      if (conn->type == NETCONN_TCP) {
3000e064:	e59d3004 	ldr	r3, [sp, #4]
3000e068:	e5d33000 	ldrb	r3, [r3]
3000e06c:	e3530010 	cmp	r3, #16
3000e070:	1a000006 	bne	3000e090 <netconn_free+0x4c>
        if(mem != NULL) {
3000e074:	e59d300c 	ldr	r3, [sp, #12]
3000e078:	e3530000 	cmp	r3, #0
3000e07c:	0a000007 	beq	3000e0a0 <netconn_free+0x5c>
          pbuf_free((struct pbuf *)mem);
3000e080:	e59d300c 	ldr	r3, [sp, #12]
3000e084:	e1a00003 	mov	r0, r3
3000e088:	eb00207c 	bl	30016280 <pbuf_free>
3000e08c:	ea000004 	b	3000e0a4 <netconn_free+0x60>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
3000e090:	e59d300c 	ldr	r3, [sp, #12]
3000e094:	e1a00003 	mov	r0, r3
3000e098:	eb000473 	bl	3000f26c <netbuf_delete>
3000e09c:	ea000000 	b	3000e0a4 <netconn_free+0x60>
  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
        if(mem != NULL) {
          pbuf_free((struct pbuf *)mem);
3000e0a0:	e1a00000 	nop			; (mov r0, r0)
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
3000e0a4:	e59d3004 	ldr	r3, [sp, #4]
3000e0a8:	e5932010 	ldr	r2, [r3, #16]
3000e0ac:	e28d300c 	add	r3, sp, #12
3000e0b0:	e1a00002 	mov	r0, r2
3000e0b4:	e1a01003 	mov	r1, r3
3000e0b8:	e3a02001 	mov	r2, #1
3000e0bc:	ebfffa7c 	bl	3000cab4 <sys_arch_mbox_fetch>
3000e0c0:	e1a03000 	mov	r3, r0
3000e0c4:	e3730001 	cmn	r3, #1
3000e0c8:	1affffe5 	bne	3000e064 <netconn_free+0x20>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
3000e0cc:	e59d3004 	ldr	r3, [sp, #4]
3000e0d0:	e5933010 	ldr	r3, [r3, #16]
3000e0d4:	e1a00003 	mov	r0, r3
3000e0d8:	ebfffa36 	bl	3000c9b8 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
3000e0dc:	e59d3004 	ldr	r3, [sp, #4]
3000e0e0:	e3a02000 	mov	r2, #0
3000e0e4:	e5832010 	str	r2, [r3, #16]
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
3000e0e8:	e59d3004 	ldr	r3, [sp, #4]
3000e0ec:	e5933014 	ldr	r3, [r3, #20]
3000e0f0:	e3530000 	cmp	r3, #0
3000e0f4:	0a000014 	beq	3000e14c <netconn_free+0x108>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
3000e0f8:	ea000002 	b	3000e108 <netconn_free+0xc4>
      netconn_delete((struct netconn *)mem);
3000e0fc:	e59d300c 	ldr	r3, [sp, #12]
3000e100:	e1a00003 	mov	r0, r3
3000e104:	ebfffb2e 	bl	3000cdc4 <netconn_delete>
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
3000e108:	e59d3004 	ldr	r3, [sp, #4]
3000e10c:	e5932014 	ldr	r2, [r3, #20]
3000e110:	e28d300c 	add	r3, sp, #12
3000e114:	e1a00002 	mov	r0, r2
3000e118:	e1a01003 	mov	r1, r3
3000e11c:	e3a02001 	mov	r2, #1
3000e120:	ebfffa63 	bl	3000cab4 <sys_arch_mbox_fetch>
3000e124:	e1a03000 	mov	r3, r0
3000e128:	e3730001 	cmn	r3, #1
3000e12c:	1afffff2 	bne	3000e0fc <netconn_free+0xb8>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
3000e130:	e59d3004 	ldr	r3, [sp, #4]
3000e134:	e5933014 	ldr	r3, [r3, #20]
3000e138:	e1a00003 	mov	r0, r3
3000e13c:	ebfffa1d 	bl	3000c9b8 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
3000e140:	e59d3004 	ldr	r3, [sp, #4]
3000e144:	e3a02000 	mov	r2, #0
3000e148:	e5832014 	str	r2, [r3, #20]
  }

  sys_sem_free(conn->op_completed);
3000e14c:	e59d3004 	ldr	r3, [sp, #4]
3000e150:	e593300c 	ldr	r3, [r3, #12]
3000e154:	e1a00003 	mov	r0, r3
3000e158:	ebfff9e9 	bl	3000c904 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
3000e15c:	e59d3004 	ldr	r3, [sp, #4]
3000e160:	e3a02000 	mov	r2, #0
3000e164:	e583200c 	str	r2, [r3, #12]

  memp_free(MEMP_NETCONN, conn);
3000e168:	e3a00006 	mov	r0, #6
3000e16c:	e59d1004 	ldr	r1, [sp, #4]
3000e170:	eb001cd4 	bl	300154c8 <memp_free>
}
3000e174:	e28dd014 	add	sp, sp, #20
3000e178:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000e17c:	e12fff1e 	bx	lr

3000e180 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
3000e180:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000e184:	e24dd014 	sub	sp, sp, #20
3000e188:	e58d0004 	str	r0, [sp, #4]
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));

  /* Set back some callback pointers */
  if (conn->pcb.tcp->state == LISTEN) {
3000e18c:	e59d3004 	ldr	r3, [sp, #4]
3000e190:	e5933004 	ldr	r3, [r3, #4]
3000e194:	e5d33010 	ldrb	r3, [r3, #16]
3000e198:	e3530001 	cmp	r3, #1
3000e19c:	1a00000a 	bne	3000e1cc <do_close_internal+0x4c>
    tcp_arg(conn->pcb.tcp, NULL);
3000e1a0:	e59d3004 	ldr	r3, [sp, #4]
3000e1a4:	e5933004 	ldr	r3, [r3, #4]
3000e1a8:	e1a00003 	mov	r0, r3
3000e1ac:	e3a01000 	mov	r1, #0
3000e1b0:	eb002c03 	bl	300191c4 <tcp_arg>
    tcp_accept(conn->pcb.tcp, NULL);
3000e1b4:	e59d3004 	ldr	r3, [sp, #4]
3000e1b8:	e5933004 	ldr	r3, [r3, #4]
3000e1bc:	e1a00003 	mov	r0, r3
3000e1c0:	e3a01000 	mov	r1, #0
3000e1c4:	eb002c1e 	bl	30019244 <tcp_accept>
3000e1c8:	ea000004 	b	3000e1e0 <do_close_internal+0x60>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
3000e1cc:	e59d3004 	ldr	r3, [sp, #4]
3000e1d0:	e5933004 	ldr	r3, [r3, #4]
3000e1d4:	e1a00003 	mov	r0, r3
3000e1d8:	e3a01000 	mov	r1, #0
3000e1dc:	eb002c00 	bl	300191e4 <tcp_recv>
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
3000e1e0:	e59d3004 	ldr	r3, [sp, #4]
3000e1e4:	e5933004 	ldr	r3, [r3, #4]
3000e1e8:	e1a00003 	mov	r0, r3
3000e1ec:	eb0024aa 	bl	3001749c <tcp_close>
3000e1f0:	e1a03000 	mov	r3, r0
3000e1f4:	e20330ff 	and	r3, r3, #255	; 0xff
3000e1f8:	e5cd300f 	strb	r3, [sp, #15]
  if (err == ERR_OK) {
3000e1fc:	e1dd30df 	ldrsb	r3, [sp, #15]
3000e200:	e3530000 	cmp	r3, #0
3000e204:	1a00003c 	bne	3000e2fc <do_close_internal+0x17c>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
3000e208:	e59d3004 	ldr	r3, [sp, #4]
3000e20c:	e3a02000 	mov	r2, #0
3000e210:	e5c32001 	strb	r2, [r3, #1]
    /* Set back some callback pointers as conn is going away */
    tcp_err(conn->pcb.tcp, NULL);
3000e214:	e59d3004 	ldr	r3, [sp, #4]
3000e218:	e5933004 	ldr	r3, [r3, #4]
3000e21c:	e1a00003 	mov	r0, r3
3000e220:	e3a01000 	mov	r1, #0
3000e224:	eb002bfe 	bl	30019224 <tcp_err>
    tcp_poll(conn->pcb.tcp, NULL, 4);
3000e228:	e59d3004 	ldr	r3, [sp, #4]
3000e22c:	e5933004 	ldr	r3, [r3, #4]
3000e230:	e1a00003 	mov	r0, r3
3000e234:	e3a01000 	mov	r1, #0
3000e238:	e3a02004 	mov	r2, #4
3000e23c:	eb002c08 	bl	30019264 <tcp_poll>
    tcp_sent(conn->pcb.tcp, NULL);
3000e240:	e59d3004 	ldr	r3, [sp, #4]
3000e244:	e5933004 	ldr	r3, [r3, #4]
3000e248:	e1a00003 	mov	r0, r3
3000e24c:	e3a01000 	mov	r1, #0
3000e250:	eb002beb 	bl	30019204 <tcp_sent>
    tcp_recv(conn->pcb.tcp, NULL);
3000e254:	e59d3004 	ldr	r3, [sp, #4]
3000e258:	e5933004 	ldr	r3, [r3, #4]
3000e25c:	e1a00003 	mov	r0, r3
3000e260:	e3a01000 	mov	r1, #0
3000e264:	eb002bde 	bl	300191e4 <tcp_recv>
    tcp_arg(conn->pcb.tcp, NULL);
3000e268:	e59d3004 	ldr	r3, [sp, #4]
3000e26c:	e5933004 	ldr	r3, [r3, #4]
3000e270:	e1a00003 	mov	r0, r3
3000e274:	e3a01000 	mov	r1, #0
3000e278:	eb002bd1 	bl	300191c4 <tcp_arg>
    conn->pcb.tcp = NULL;
3000e27c:	e59d3004 	ldr	r3, [sp, #4]
3000e280:	e3a02000 	mov	r2, #0
3000e284:	e5832004 	str	r2, [r3, #4]
    conn->err = ERR_OK;
3000e288:	e59d3004 	ldr	r3, [sp, #4]
3000e28c:	e3a02000 	mov	r2, #0
3000e290:	e5c32008 	strb	r2, [r3, #8]
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
3000e294:	e59d3004 	ldr	r3, [sp, #4]
3000e298:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000e29c:	e3530000 	cmp	r3, #0
3000e2a0:	0a000006 	beq	3000e2c0 <do_close_internal+0x140>
3000e2a4:	e59d3004 	ldr	r3, [sp, #4]
3000e2a8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000e2ac:	e59d0004 	ldr	r0, [sp, #4]
3000e2b0:	e3a01000 	mov	r1, #0
3000e2b4:	e3a02000 	mov	r2, #0
3000e2b8:	e1a0e00f 	mov	lr, pc
3000e2bc:	e12fff13 	bx	r3
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
3000e2c0:	e59d3004 	ldr	r3, [sp, #4]
3000e2c4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000e2c8:	e3530000 	cmp	r3, #0
3000e2cc:	0a000006 	beq	3000e2ec <do_close_internal+0x16c>
3000e2d0:	e59d3004 	ldr	r3, [sp, #4]
3000e2d4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000e2d8:	e59d0004 	ldr	r0, [sp, #4]
3000e2dc:	e3a01002 	mov	r1, #2
3000e2e0:	e3a02000 	mov	r2, #0
3000e2e4:	e1a0e00f 	mov	lr, pc
3000e2e8:	e12fff13 	bx	r3
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
3000e2ec:	e59d3004 	ldr	r3, [sp, #4]
3000e2f0:	e593300c 	ldr	r3, [r3, #12]
3000e2f4:	e1a00003 	mov	r0, r3
3000e2f8:	ebfff98a 	bl	3000c928 <sys_sem_signal>
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
3000e2fc:	e28dd014 	add	sp, sp, #20
3000e300:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000e304:	e12fff1e 	bx	lr

3000e308 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
3000e308:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000e30c:	e24dd00c 	sub	sp, sp, #12
3000e310:	e58d0004 	str	r0, [sp, #4]
  if (msg->conn->pcb.tcp != NULL) {
3000e314:	e59d3004 	ldr	r3, [sp, #4]
3000e318:	e5933000 	ldr	r3, [r3]
3000e31c:	e5933004 	ldr	r3, [r3, #4]
3000e320:	e3530000 	cmp	r3, #0
3000e324:	0a000024 	beq	3000e3bc <do_delconn+0xb4>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
3000e328:	e59d3004 	ldr	r3, [sp, #4]
3000e32c:	e5933000 	ldr	r3, [r3]
3000e330:	e5d33000 	ldrb	r3, [r3]
3000e334:	e20330f0 	and	r3, r3, #240	; 0xf0
3000e338:	e3530020 	cmp	r3, #32
3000e33c:	0a00000a 	beq	3000e36c <do_delconn+0x64>
3000e340:	e3530040 	cmp	r3, #64	; 0x40
3000e344:	0a000002 	beq	3000e354 <do_delconn+0x4c>
3000e348:	e3530010 	cmp	r3, #16
3000e34c:	0a000011 	beq	3000e398 <do_delconn+0x90>
3000e350:	ea000019 	b	3000e3bc <do_delconn+0xb4>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
3000e354:	e59d3004 	ldr	r3, [sp, #4]
3000e358:	e5933000 	ldr	r3, [r3]
3000e35c:	e5933004 	ldr	r3, [r3, #4]
3000e360:	e1a00003 	mov	r0, r3
3000e364:	eb002240 	bl	30016c6c <raw_remove>
      break;
3000e368:	ea000013 	b	3000e3bc <do_delconn+0xb4>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
3000e36c:	e59d3004 	ldr	r3, [sp, #4]
3000e370:	e5933000 	ldr	r3, [r3]
3000e374:	e5933004 	ldr	r3, [r3, #4]
3000e378:	e3a02000 	mov	r2, #0
3000e37c:	e583201c 	str	r2, [r3, #28]
      udp_remove(msg->conn->pcb.udp);
3000e380:	e59d3004 	ldr	r3, [sp, #4]
3000e384:	e5933000 	ldr	r3, [r3]
3000e388:	e5933004 	ldr	r3, [r3, #4]
3000e38c:	e1a00003 	mov	r0, r3
3000e390:	eb004915 	bl	300207ec <udp_remove>
      break;
3000e394:	ea000008 	b	3000e3bc <do_delconn+0xb4>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
3000e398:	e59d3004 	ldr	r3, [sp, #4]
3000e39c:	e5933000 	ldr	r3, [r3]
3000e3a0:	e3a02004 	mov	r2, #4
3000e3a4:	e5c32001 	strb	r2, [r3, #1]
      do_close_internal(msg->conn);
3000e3a8:	e59d3004 	ldr	r3, [sp, #4]
3000e3ac:	e5933000 	ldr	r3, [r3]
3000e3b0:	e1a00003 	mov	r0, r3
3000e3b4:	ebffff71 	bl	3000e180 <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
3000e3b8:	ea000027 	b	3000e45c <do_delconn+0x154>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
3000e3bc:	e59d3004 	ldr	r3, [sp, #4]
3000e3c0:	e5933000 	ldr	r3, [r3]
3000e3c4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000e3c8:	e3530000 	cmp	r3, #0
3000e3cc:	0a000009 	beq	3000e3f8 <do_delconn+0xf0>
3000e3d0:	e59d3004 	ldr	r3, [sp, #4]
3000e3d4:	e5933000 	ldr	r3, [r3]
3000e3d8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000e3dc:	e59d2004 	ldr	r2, [sp, #4]
3000e3e0:	e5922000 	ldr	r2, [r2]
3000e3e4:	e1a00002 	mov	r0, r2
3000e3e8:	e3a01000 	mov	r1, #0
3000e3ec:	e3a02000 	mov	r2, #0
3000e3f0:	e1a0e00f 	mov	lr, pc
3000e3f4:	e12fff13 	bx	r3
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
3000e3f8:	e59d3004 	ldr	r3, [sp, #4]
3000e3fc:	e5933000 	ldr	r3, [r3]
3000e400:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000e404:	e3530000 	cmp	r3, #0
3000e408:	0a000009 	beq	3000e434 <do_delconn+0x12c>
3000e40c:	e59d3004 	ldr	r3, [sp, #4]
3000e410:	e5933000 	ldr	r3, [r3]
3000e414:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000e418:	e59d2004 	ldr	r2, [sp, #4]
3000e41c:	e5922000 	ldr	r2, [r2]
3000e420:	e1a00002 	mov	r0, r2
3000e424:	e3a01002 	mov	r1, #2
3000e428:	e3a02000 	mov	r2, #0
3000e42c:	e1a0e00f 	mov	lr, pc
3000e430:	e12fff13 	bx	r3

  if (msg->conn->op_completed != SYS_SEM_NULL) {
3000e434:	e59d3004 	ldr	r3, [sp, #4]
3000e438:	e5933000 	ldr	r3, [r3]
3000e43c:	e593300c 	ldr	r3, [r3, #12]
3000e440:	e3530000 	cmp	r3, #0
3000e444:	0a000004 	beq	3000e45c <do_delconn+0x154>
    sys_sem_signal(msg->conn->op_completed);
3000e448:	e59d3004 	ldr	r3, [sp, #4]
3000e44c:	e5933000 	ldr	r3, [r3]
3000e450:	e593300c 	ldr	r3, [r3, #12]
3000e454:	e1a00003 	mov	r0, r3
3000e458:	ebfff932 	bl	3000c928 <sys_sem_signal>
  }
}
3000e45c:	e28dd00c 	add	sp, sp, #12
3000e460:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000e464:	e12fff1e 	bx	lr

3000e468 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
3000e468:	e92d4010 	push	{r4, lr}
3000e46c:	e24dd008 	sub	sp, sp, #8
3000e470:	e58d0004 	str	r0, [sp, #4]
  if (!ERR_IS_FATAL(msg->conn->err)) {
3000e474:	e59d3004 	ldr	r3, [sp, #4]
3000e478:	e5933000 	ldr	r3, [r3]
3000e47c:	e5d33008 	ldrb	r3, [r3, #8]
3000e480:	e1a03c03 	lsl	r3, r3, #24
3000e484:	e1a03c43 	asr	r3, r3, #24
3000e488:	e3730003 	cmn	r3, #3
3000e48c:	ba000044 	blt	3000e5a4 <do_bind+0x13c>
    if (msg->conn->pcb.tcp != NULL) {
3000e490:	e59d3004 	ldr	r3, [sp, #4]
3000e494:	e5933000 	ldr	r3, [r3]
3000e498:	e5933004 	ldr	r3, [r3, #4]
3000e49c:	e3530000 	cmp	r3, #0
3000e4a0:	0a00003b 	beq	3000e594 <do_bind+0x12c>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
3000e4a4:	e59d3004 	ldr	r3, [sp, #4]
3000e4a8:	e5933000 	ldr	r3, [r3]
3000e4ac:	e5d33000 	ldrb	r3, [r3]
3000e4b0:	e20330f0 	and	r3, r3, #240	; 0xf0
3000e4b4:	e3530020 	cmp	r3, #32
3000e4b8:	0a000012 	beq	3000e508 <do_bind+0xa0>
3000e4bc:	e3530040 	cmp	r3, #64	; 0x40
3000e4c0:	0a000002 	beq	3000e4d0 <do_bind+0x68>
3000e4c4:	e3530010 	cmp	r3, #16
3000e4c8:	0a000020 	beq	3000e550 <do_bind+0xe8>
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
        break;
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
3000e4cc:	ea000034 	b	3000e5a4 <do_bind+0x13c>
  if (!ERR_IS_FATAL(msg->conn->err)) {
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
3000e4d0:	e59d3004 	ldr	r3, [sp, #4]
3000e4d4:	e5934000 	ldr	r4, [r3]
3000e4d8:	e59d3004 	ldr	r3, [sp, #4]
3000e4dc:	e5933000 	ldr	r3, [r3]
3000e4e0:	e5932004 	ldr	r2, [r3, #4]
3000e4e4:	e59d3004 	ldr	r3, [sp, #4]
3000e4e8:	e5933004 	ldr	r3, [r3, #4]
3000e4ec:	e1a00002 	mov	r0, r2
3000e4f0:	e1a01003 	mov	r1, r3
3000e4f4:	eb002129 	bl	300169a0 <raw_bind>
3000e4f8:	e1a03000 	mov	r3, r0
3000e4fc:	e20330ff 	and	r3, r3, #255	; 0xff
3000e500:	e5c43008 	strb	r3, [r4, #8]
        break;
3000e504:	ea000026 	b	3000e5a4 <do_bind+0x13c>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
3000e508:	e59d3004 	ldr	r3, [sp, #4]
3000e50c:	e5934000 	ldr	r4, [r3]
3000e510:	e59d3004 	ldr	r3, [sp, #4]
3000e514:	e5933000 	ldr	r3, [r3]
3000e518:	e5931004 	ldr	r1, [r3, #4]
3000e51c:	e59d3004 	ldr	r3, [sp, #4]
3000e520:	e5932004 	ldr	r2, [r3, #4]
3000e524:	e59d3004 	ldr	r3, [sp, #4]
3000e528:	e1d330b8 	ldrh	r3, [r3, #8]
3000e52c:	e1a00001 	mov	r0, r1
3000e530:	e1a01002 	mov	r1, r2
3000e534:	e1a02003 	mov	r2, r3
3000e538:	eb0047cf 	bl	3002047c <udp_bind>
3000e53c:	e1a03000 	mov	r3, r0
3000e540:	e20330ff 	and	r3, r3, #255	; 0xff
3000e544:	e5c43008 	strb	r3, [r4, #8]
        break;
3000e548:	e1a00000 	nop			; (mov r0, r0)
3000e54c:	ea000014 	b	3000e5a4 <do_bind+0x13c>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
3000e550:	e59d3004 	ldr	r3, [sp, #4]
3000e554:	e5934000 	ldr	r4, [r3]
3000e558:	e59d3004 	ldr	r3, [sp, #4]
3000e55c:	e5933000 	ldr	r3, [r3]
3000e560:	e5931004 	ldr	r1, [r3, #4]
3000e564:	e59d3004 	ldr	r3, [sp, #4]
3000e568:	e5932004 	ldr	r2, [r3, #4]
3000e56c:	e59d3004 	ldr	r3, [sp, #4]
3000e570:	e1d330b8 	ldrh	r3, [r3, #8]
3000e574:	e1a00001 	mov	r0, r1
3000e578:	e1a01002 	mov	r1, r2
3000e57c:	e1a02003 	mov	r2, r3
3000e580:	eb0024c9 	bl	300178ac <tcp_bind>
3000e584:	e1a03000 	mov	r3, r0
3000e588:	e20330ff 	and	r3, r3, #255	; 0xff
3000e58c:	e5c43008 	strb	r3, [r4, #8]
3000e590:	ea000003 	b	3000e5a4 <do_bind+0x13c>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
3000e594:	e59d3004 	ldr	r3, [sp, #4]
3000e598:	e5933000 	ldr	r3, [r3]
3000e59c:	e3e02007 	mvn	r2, #7
3000e5a0:	e5c32008 	strb	r2, [r3, #8]
    }
  }
  TCPIP_APIMSG_ACK(msg);
3000e5a4:	e59d3004 	ldr	r3, [sp, #4]
3000e5a8:	e5933000 	ldr	r3, [r3]
3000e5ac:	e593300c 	ldr	r3, [r3, #12]
3000e5b0:	e1a00003 	mov	r0, r3
3000e5b4:	ebfff8db 	bl	3000c928 <sys_sem_signal>
}
3000e5b8:	e28dd008 	add	sp, sp, #8
3000e5bc:	e8bd4010 	pop	{r4, lr}
3000e5c0:	e12fff1e 	bx	lr

3000e5c4 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
3000e5c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000e5c8:	e24dd01c 	sub	sp, sp, #28
3000e5cc:	e58d000c 	str	r0, [sp, #12]
3000e5d0:	e58d1008 	str	r1, [sp, #8]
3000e5d4:	e1a03002 	mov	r3, r2
3000e5d8:	e5cd3007 	strb	r3, [sp, #7]
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
3000e5dc:	e59d300c 	ldr	r3, [sp, #12]
3000e5e0:	e58d3014 	str	r3, [sp, #20]

  if (conn == NULL) {
3000e5e4:	e59d3014 	ldr	r3, [sp, #20]
3000e5e8:	e3530000 	cmp	r3, #0
3000e5ec:	1a000001 	bne	3000e5f8 <do_connected+0x34>
    return ERR_VAL;
3000e5f0:	e3a030f8 	mov	r3, #248	; 0xf8
3000e5f4:	ea000013 	b	3000e648 <do_connected+0x84>
  }

  conn->err = err;
3000e5f8:	e59d3014 	ldr	r3, [sp, #20]
3000e5fc:	e5dd2007 	ldrb	r2, [sp, #7]
3000e600:	e5c32008 	strb	r2, [r3, #8]
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
3000e604:	e59d3014 	ldr	r3, [sp, #20]
3000e608:	e5d33000 	ldrb	r3, [r3]
3000e60c:	e3530010 	cmp	r3, #16
3000e610:	1a000004 	bne	3000e628 <do_connected+0x64>
3000e614:	e1dd30d7 	ldrsb	r3, [sp, #7]
3000e618:	e3530000 	cmp	r3, #0
3000e61c:	1a000001 	bne	3000e628 <do_connected+0x64>
    setup_tcp(conn);
3000e620:	e59d0014 	ldr	r0, [sp, #20]
3000e624:	ebfffd56 	bl	3000db84 <setup_tcp>
  }
  conn->state = NETCONN_NONE;
3000e628:	e59d3014 	ldr	r3, [sp, #20]
3000e62c:	e3a02000 	mov	r2, #0
3000e630:	e5c32001 	strb	r2, [r3, #1]
  sys_sem_signal(conn->op_completed);
3000e634:	e59d3014 	ldr	r3, [sp, #20]
3000e638:	e593300c 	ldr	r3, [r3, #12]
3000e63c:	e1a00003 	mov	r0, r3
3000e640:	ebfff8b8 	bl	3000c928 <sys_sem_signal>
  return ERR_OK;
3000e644:	e3a03000 	mov	r3, #0
3000e648:	e1a03c03 	lsl	r3, r3, #24
3000e64c:	e1a03c43 	asr	r3, r3, #24
}
3000e650:	e1a00003 	mov	r0, r3
3000e654:	e28dd01c 	add	sp, sp, #28
3000e658:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000e65c:	e12fff1e 	bx	lr

3000e660 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
3000e660:	e92d4010 	push	{r4, lr}
3000e664:	e24dd008 	sub	sp, sp, #8
3000e668:	e58d0004 	str	r0, [sp, #4]
  if (msg->conn->pcb.tcp == NULL) {
3000e66c:	e59d3004 	ldr	r3, [sp, #4]
3000e670:	e5933000 	ldr	r3, [r3]
3000e674:	e5933004 	ldr	r3, [r3, #4]
3000e678:	e3530000 	cmp	r3, #0
3000e67c:	1a000005 	bne	3000e698 <do_connect+0x38>
    sys_sem_signal(msg->conn->op_completed);
3000e680:	e59d3004 	ldr	r3, [sp, #4]
3000e684:	e5933000 	ldr	r3, [r3]
3000e688:	e593300c 	ldr	r3, [r3, #12]
3000e68c:	e1a00003 	mov	r0, r3
3000e690:	ebfff8a4 	bl	3000c928 <sys_sem_signal>
    return;
3000e694:	ea00004c 	b	3000e7cc <do_connect+0x16c>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
3000e698:	e59d3004 	ldr	r3, [sp, #4]
3000e69c:	e5933000 	ldr	r3, [r3]
3000e6a0:	e5d33000 	ldrb	r3, [r3]
3000e6a4:	e20330f0 	and	r3, r3, #240	; 0xf0
3000e6a8:	e3530020 	cmp	r3, #32
3000e6ac:	0a000017 	beq	3000e710 <do_connect+0xb0>
3000e6b0:	e3530040 	cmp	r3, #64	; 0x40
3000e6b4:	0a000002 	beq	3000e6c4 <do_connect+0x64>
3000e6b8:	e3530010 	cmp	r3, #16
3000e6bc:	0a000029 	beq	3000e768 <do_connect+0x108>
3000e6c0:	ea000041 	b	3000e7cc <do_connect+0x16c>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
3000e6c4:	e59d3004 	ldr	r3, [sp, #4]
3000e6c8:	e5934000 	ldr	r4, [r3]
3000e6cc:	e59d3004 	ldr	r3, [sp, #4]
3000e6d0:	e5933000 	ldr	r3, [r3]
3000e6d4:	e5932004 	ldr	r2, [r3, #4]
3000e6d8:	e59d3004 	ldr	r3, [sp, #4]
3000e6dc:	e5933004 	ldr	r3, [r3, #4]
3000e6e0:	e1a00002 	mov	r0, r2
3000e6e4:	e1a01003 	mov	r1, r3
3000e6e8:	eb0020c7 	bl	30016a0c <raw_connect>
3000e6ec:	e1a03000 	mov	r3, r0
3000e6f0:	e20330ff 	and	r3, r3, #255	; 0xff
3000e6f4:	e5c43008 	strb	r3, [r4, #8]
    sys_sem_signal(msg->conn->op_completed);
3000e6f8:	e59d3004 	ldr	r3, [sp, #4]
3000e6fc:	e5933000 	ldr	r3, [r3]
3000e700:	e593300c 	ldr	r3, [r3, #12]
3000e704:	e1a00003 	mov	r0, r3
3000e708:	ebfff886 	bl	3000c928 <sys_sem_signal>
    break;
3000e70c:	ea00002e 	b	3000e7cc <do_connect+0x16c>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
3000e710:	e59d3004 	ldr	r3, [sp, #4]
3000e714:	e5934000 	ldr	r4, [r3]
3000e718:	e59d3004 	ldr	r3, [sp, #4]
3000e71c:	e5933000 	ldr	r3, [r3]
3000e720:	e5931004 	ldr	r1, [r3, #4]
3000e724:	e59d3004 	ldr	r3, [sp, #4]
3000e728:	e5932004 	ldr	r2, [r3, #4]
3000e72c:	e59d3004 	ldr	r3, [sp, #4]
3000e730:	e1d330b8 	ldrh	r3, [r3, #8]
3000e734:	e1a00001 	mov	r0, r1
3000e738:	e1a01002 	mov	r1, r2
3000e73c:	e1a02003 	mov	r2, r3
3000e740:	eb0047af 	bl	30020604 <udp_connect>
3000e744:	e1a03000 	mov	r3, r0
3000e748:	e20330ff 	and	r3, r3, #255	; 0xff
3000e74c:	e5c43008 	strb	r3, [r4, #8]
    sys_sem_signal(msg->conn->op_completed);
3000e750:	e59d3004 	ldr	r3, [sp, #4]
3000e754:	e5933000 	ldr	r3, [r3]
3000e758:	e593300c 	ldr	r3, [r3, #12]
3000e75c:	e1a00003 	mov	r0, r3
3000e760:	ebfff870 	bl	3000c928 <sys_sem_signal>
    break;
3000e764:	ea000018 	b	3000e7cc <do_connect+0x16c>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
3000e768:	e59d3004 	ldr	r3, [sp, #4]
3000e76c:	e5933000 	ldr	r3, [r3]
3000e770:	e3a02003 	mov	r2, #3
3000e774:	e5c32001 	strb	r2, [r3, #1]
    setup_tcp(msg->conn);
3000e778:	e59d3004 	ldr	r3, [sp, #4]
3000e77c:	e5933000 	ldr	r3, [r3]
3000e780:	e1a00003 	mov	r0, r3
3000e784:	ebfffcfe 	bl	3000db84 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
3000e788:	e59d3004 	ldr	r3, [sp, #4]
3000e78c:	e5934000 	ldr	r4, [r3]
3000e790:	e59d3004 	ldr	r3, [sp, #4]
3000e794:	e5933000 	ldr	r3, [r3]
3000e798:	e5931004 	ldr	r1, [r3, #4]
3000e79c:	e59d3004 	ldr	r3, [sp, #4]
3000e7a0:	e5932004 	ldr	r2, [r3, #4]
3000e7a4:	e59d3004 	ldr	r3, [sp, #4]
3000e7a8:	e1d330b8 	ldrh	r3, [r3, #8]
3000e7ac:	e1a00001 	mov	r0, r1
3000e7b0:	e1a01002 	mov	r1, r2
3000e7b4:	e1a02003 	mov	r2, r3
3000e7b8:	e59f3018 	ldr	r3, [pc, #24]	; 3000e7d8 <do_connect+0x178>
3000e7bc:	eb00267a 	bl	300181ac <tcp_connect>
3000e7c0:	e1a03000 	mov	r3, r0
3000e7c4:	e20330ff 	and	r3, r3, #255	; 0xff
3000e7c8:	e5c43008 	strb	r3, [r4, #8]
    break;
#endif /* LWIP_TCP */
  default:
    break;
  }
}
3000e7cc:	e28dd008 	add	sp, sp, #8
3000e7d0:	e8bd4010 	pop	{r4, lr}
3000e7d4:	e12fff1e 	bx	lr
3000e7d8:	3000e5c4 	.word	0x3000e5c4

3000e7dc <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
3000e7dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000e7e0:	e24dd00c 	sub	sp, sp, #12
3000e7e4:	e58d0004 	str	r0, [sp, #4]
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
3000e7e8:	e59d3004 	ldr	r3, [sp, #4]
3000e7ec:	e5933000 	ldr	r3, [r3]
3000e7f0:	e5d33000 	ldrb	r3, [r3]
3000e7f4:	e20330f0 	and	r3, r3, #240	; 0xf0
3000e7f8:	e3530020 	cmp	r3, #32
3000e7fc:	1a000004 	bne	3000e814 <do_disconnect+0x38>
    udp_disconnect(msg->conn->pcb.udp);
3000e800:	e59d3004 	ldr	r3, [sp, #4]
3000e804:	e5933000 	ldr	r3, [r3]
3000e808:	e5933004 	ldr	r3, [r3, #4]
3000e80c:	e1a00003 	mov	r0, r3
3000e810:	eb0047ce 	bl	30020750 <udp_disconnect>
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
3000e814:	e59d3004 	ldr	r3, [sp, #4]
3000e818:	e5933000 	ldr	r3, [r3]
3000e81c:	e593300c 	ldr	r3, [r3, #12]
3000e820:	e1a00003 	mov	r0, r3
3000e824:	ebfff83f 	bl	3000c928 <sys_sem_signal>
}
3000e828:	e28dd00c 	add	sp, sp, #12
3000e82c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000e830:	e12fff1e 	bx	lr

3000e834 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
3000e834:	e92d4010 	push	{r4, lr}
3000e838:	e24dd010 	sub	sp, sp, #16
3000e83c:	e58d0004 	str	r0, [sp, #4]
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
3000e840:	e59d3004 	ldr	r3, [sp, #4]
3000e844:	e5933000 	ldr	r3, [r3]
3000e848:	e5d33008 	ldrb	r3, [r3, #8]
3000e84c:	e1a03c03 	lsl	r3, r3, #24
3000e850:	e1a03c43 	asr	r3, r3, #24
3000e854:	e3730003 	cmn	r3, #3
3000e858:	ba000061 	blt	3000e9e4 <do_listen+0x1b0>
    if (msg->conn->pcb.tcp != NULL) {
3000e85c:	e59d3004 	ldr	r3, [sp, #4]
3000e860:	e5933000 	ldr	r3, [r3]
3000e864:	e5933004 	ldr	r3, [r3, #4]
3000e868:	e3530000 	cmp	r3, #0
3000e86c:	0a00005c 	beq	3000e9e4 <do_listen+0x1b0>
      if (msg->conn->type == NETCONN_TCP) {
3000e870:	e59d3004 	ldr	r3, [sp, #4]
3000e874:	e5933000 	ldr	r3, [r3]
3000e878:	e5d33000 	ldrb	r3, [r3]
3000e87c:	e3530010 	cmp	r3, #16
3000e880:	1a000057 	bne	3000e9e4 <do_listen+0x1b0>
        if (msg->conn->pcb.tcp->state == CLOSED) {
3000e884:	e59d3004 	ldr	r3, [sp, #4]
3000e888:	e5933000 	ldr	r3, [r3]
3000e88c:	e5933004 	ldr	r3, [r3, #4]
3000e890:	e5d33010 	ldrb	r3, [r3, #16]
3000e894:	e3530000 	cmp	r3, #0
3000e898:	1a00004b 	bne	3000e9cc <do_listen+0x198>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
3000e89c:	e59d3004 	ldr	r3, [sp, #4]
3000e8a0:	e5933000 	ldr	r3, [r3]
3000e8a4:	e5933004 	ldr	r3, [r3, #4]
3000e8a8:	e1a00003 	mov	r0, r3
3000e8ac:	e3a010ff 	mov	r1, #255	; 0xff
3000e8b0:	eb00250d 	bl	30017cec <tcp_listen_with_backlog>
3000e8b4:	e1a03000 	mov	r3, r0
3000e8b8:	e58d300c 	str	r3, [sp, #12]
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
3000e8bc:	e59d300c 	ldr	r3, [sp, #12]
3000e8c0:	e3530000 	cmp	r3, #0
3000e8c4:	1a000004 	bne	3000e8dc <do_listen+0xa8>
            msg->conn->err = ERR_MEM;
3000e8c8:	e59d3004 	ldr	r3, [sp, #4]
3000e8cc:	e5933000 	ldr	r3, [r3]
3000e8d0:	e3e02000 	mvn	r2, #0
3000e8d4:	e5c32008 	strb	r2, [r3, #8]
            }
            if (msg->conn->err == ERR_OK) {
              msg->conn->state = NETCONN_LISTEN;
              msg->conn->pcb.tcp = lpcb;
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
              tcp_accept(msg->conn->pcb.tcp, accept_function);
3000e8d8:	ea000041 	b	3000e9e4 <do_listen+0x1b0>
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
            msg->conn->err = ERR_MEM;
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
3000e8dc:	e59d3004 	ldr	r3, [sp, #4]
3000e8e0:	e5933000 	ldr	r3, [r3]
3000e8e4:	e5933010 	ldr	r3, [r3, #16]
3000e8e8:	e3530000 	cmp	r3, #0
3000e8ec:	0a000008 	beq	3000e914 <do_listen+0xe0>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
3000e8f0:	e59d3004 	ldr	r3, [sp, #4]
3000e8f4:	e5933000 	ldr	r3, [r3]
3000e8f8:	e5933010 	ldr	r3, [r3, #16]
3000e8fc:	e1a00003 	mov	r0, r3
3000e900:	ebfff82c 	bl	3000c9b8 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
3000e904:	e59d3004 	ldr	r3, [sp, #4]
3000e908:	e5933000 	ldr	r3, [r3]
3000e90c:	e3a02000 	mov	r2, #0
3000e910:	e5832010 	str	r2, [r3, #16]
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
3000e914:	e59d3004 	ldr	r3, [sp, #4]
3000e918:	e5933000 	ldr	r3, [r3]
3000e91c:	e5933014 	ldr	r3, [r3, #20]
3000e920:	e3530000 	cmp	r3, #0
3000e924:	1a00000c 	bne	3000e95c <do_listen+0x128>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
3000e928:	e59d3004 	ldr	r3, [sp, #4]
3000e92c:	e5934000 	ldr	r4, [r3]
3000e930:	e3a0000a 	mov	r0, #10
3000e934:	ebfff814 	bl	3000c98c <sys_mbox_new>
3000e938:	e1a03000 	mov	r3, r0
3000e93c:	e5843014 	str	r3, [r4, #20]
3000e940:	e5943014 	ldr	r3, [r4, #20]
3000e944:	e3530000 	cmp	r3, #0
3000e948:	1a000003 	bne	3000e95c <do_listen+0x128>
                msg->conn->err = ERR_MEM;
3000e94c:	e59d3004 	ldr	r3, [sp, #4]
3000e950:	e5933000 	ldr	r3, [r3]
3000e954:	e3e02000 	mvn	r2, #0
3000e958:	e5c32008 	strb	r2, [r3, #8]
              }
            }
            if (msg->conn->err == ERR_OK) {
3000e95c:	e59d3004 	ldr	r3, [sp, #4]
3000e960:	e5933000 	ldr	r3, [r3]
3000e964:	e5d33008 	ldrb	r3, [r3, #8]
3000e968:	e3530000 	cmp	r3, #0
3000e96c:	1a00001b 	bne	3000e9e0 <do_listen+0x1ac>
              msg->conn->state = NETCONN_LISTEN;
3000e970:	e59d3004 	ldr	r3, [sp, #4]
3000e974:	e5933000 	ldr	r3, [r3]
3000e978:	e3a02002 	mov	r2, #2
3000e97c:	e5c32001 	strb	r2, [r3, #1]
              msg->conn->pcb.tcp = lpcb;
3000e980:	e59d3004 	ldr	r3, [sp, #4]
3000e984:	e5933000 	ldr	r3, [r3]
3000e988:	e59d200c 	ldr	r2, [sp, #12]
3000e98c:	e5832004 	str	r2, [r3, #4]
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
3000e990:	e59d3004 	ldr	r3, [sp, #4]
3000e994:	e5933000 	ldr	r3, [r3]
3000e998:	e5932004 	ldr	r2, [r3, #4]
3000e99c:	e59d3004 	ldr	r3, [sp, #4]
3000e9a0:	e5933000 	ldr	r3, [r3]
3000e9a4:	e1a00002 	mov	r0, r2
3000e9a8:	e1a01003 	mov	r1, r3
3000e9ac:	eb002a04 	bl	300191c4 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
3000e9b0:	e59d3004 	ldr	r3, [sp, #4]
3000e9b4:	e5933000 	ldr	r3, [r3]
3000e9b8:	e5933004 	ldr	r3, [r3, #4]
3000e9bc:	e1a00003 	mov	r0, r3
3000e9c0:	e59f103c 	ldr	r1, [pc, #60]	; 3000ea04 <do_listen+0x1d0>
3000e9c4:	eb002a1e 	bl	30019244 <tcp_accept>
3000e9c8:	ea000005 	b	3000e9e4 <do_listen+0x1b0>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
3000e9cc:	e59d3004 	ldr	r3, [sp, #4]
3000e9d0:	e5933000 	ldr	r3, [r3]
3000e9d4:	e3e02006 	mvn	r2, #6
3000e9d8:	e5c32008 	strb	r2, [r3, #8]
3000e9dc:	ea000000 	b	3000e9e4 <do_listen+0x1b0>
            }
            if (msg->conn->err == ERR_OK) {
              msg->conn->state = NETCONN_LISTEN;
              msg->conn->pcb.tcp = lpcb;
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
              tcp_accept(msg->conn->pcb.tcp, accept_function);
3000e9e0:	e1a00000 	nop			; (mov r0, r0)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
3000e9e4:	e59d3004 	ldr	r3, [sp, #4]
3000e9e8:	e5933000 	ldr	r3, [r3]
3000e9ec:	e593300c 	ldr	r3, [r3, #12]
3000e9f0:	e1a00003 	mov	r0, r3
3000e9f4:	ebfff7cb 	bl	3000c928 <sys_sem_signal>
}
3000e9f8:	e28dd010 	add	sp, sp, #16
3000e9fc:	e8bd4010 	pop	{r4, lr}
3000ea00:	e12fff1e 	bx	lr
3000ea04:	3000dbf8 	.word	0x3000dbf8

3000ea08 <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
3000ea08:	e92d4010 	push	{r4, lr}
3000ea0c:	e24dd008 	sub	sp, sp, #8
3000ea10:	e58d0004 	str	r0, [sp, #4]
  if (!ERR_IS_FATAL(msg->conn->err)) {
3000ea14:	e59d3004 	ldr	r3, [sp, #4]
3000ea18:	e5933000 	ldr	r3, [r3]
3000ea1c:	e5d33008 	ldrb	r3, [r3, #8]
3000ea20:	e1a03c03 	lsl	r3, r3, #24
3000ea24:	e1a03c43 	asr	r3, r3, #24
3000ea28:	e3730003 	cmn	r3, #3
3000ea2c:	ba000059 	blt	3000eb98 <do_send+0x190>
    if (msg->conn->pcb.tcp != NULL) {
3000ea30:	e59d3004 	ldr	r3, [sp, #4]
3000ea34:	e5933000 	ldr	r3, [r3]
3000ea38:	e5933004 	ldr	r3, [r3, #4]
3000ea3c:	e3530000 	cmp	r3, #0
3000ea40:	0a000054 	beq	3000eb98 <do_send+0x190>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
3000ea44:	e59d3004 	ldr	r3, [sp, #4]
3000ea48:	e5933000 	ldr	r3, [r3]
3000ea4c:	e5d33000 	ldrb	r3, [r3]
3000ea50:	e20330f0 	and	r3, r3, #240	; 0xf0
3000ea54:	e3530020 	cmp	r3, #32
3000ea58:	0a000028 	beq	3000eb00 <do_send+0xf8>
3000ea5c:	e3530040 	cmp	r3, #64	; 0x40
3000ea60:	1a00004c 	bne	3000eb98 <do_send+0x190>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
3000ea64:	e59d3004 	ldr	r3, [sp, #4]
3000ea68:	e5933004 	ldr	r3, [r3, #4]
3000ea6c:	e5933008 	ldr	r3, [r3, #8]
3000ea70:	e3530000 	cmp	r3, #0
3000ea74:	1a00000e 	bne	3000eab4 <do_send+0xac>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
3000ea78:	e59d3004 	ldr	r3, [sp, #4]
3000ea7c:	e5934000 	ldr	r4, [r3]
3000ea80:	e59d3004 	ldr	r3, [sp, #4]
3000ea84:	e5933000 	ldr	r3, [r3]
3000ea88:	e5932004 	ldr	r2, [r3, #4]
3000ea8c:	e59d3004 	ldr	r3, [sp, #4]
3000ea90:	e5933004 	ldr	r3, [r3, #4]
3000ea94:	e5933000 	ldr	r3, [r3]
3000ea98:	e1a00002 	mov	r0, r2
3000ea9c:	e1a01003 	mov	r1, r3
3000eaa0:	eb00205e 	bl	30016c20 <raw_send>
3000eaa4:	e1a03000 	mov	r3, r0
3000eaa8:	e20330ff 	and	r3, r3, #255	; 0xff
3000eaac:	e5c43008 	strb	r3, [r4, #8]
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
        }
        break;
3000eab0:	ea000038 	b	3000eb98 <do_send+0x190>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
3000eab4:	e59d3004 	ldr	r3, [sp, #4]
3000eab8:	e5934000 	ldr	r4, [r3]
3000eabc:	e59d3004 	ldr	r3, [sp, #4]
3000eac0:	e5933000 	ldr	r3, [r3]
3000eac4:	e5931004 	ldr	r1, [r3, #4]
3000eac8:	e59d3004 	ldr	r3, [sp, #4]
3000eacc:	e5933004 	ldr	r3, [r3, #4]
3000ead0:	e5932000 	ldr	r2, [r3]
3000ead4:	e59d3004 	ldr	r3, [sp, #4]
3000ead8:	e5933004 	ldr	r3, [r3, #4]
3000eadc:	e5933008 	ldr	r3, [r3, #8]
3000eae0:	e1a00001 	mov	r0, r1
3000eae4:	e1a01002 	mov	r1, r2
3000eae8:	e1a02003 	mov	r2, r3
3000eaec:	eb001fed 	bl	30016aa8 <raw_sendto>
3000eaf0:	e1a03000 	mov	r3, r0
3000eaf4:	e20330ff 	and	r3, r3, #255	; 0xff
3000eaf8:	e5c43008 	strb	r3, [r4, #8]
        }
        break;
3000eafc:	ea000025 	b	3000eb98 <do_send+0x190>
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
3000eb00:	e59d3004 	ldr	r3, [sp, #4]
3000eb04:	e5933004 	ldr	r3, [r3, #4]
3000eb08:	e5933008 	ldr	r3, [r3, #8]
3000eb0c:	e3530000 	cmp	r3, #0
3000eb10:	1a00000e 	bne	3000eb50 <do_send+0x148>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
3000eb14:	e59d3004 	ldr	r3, [sp, #4]
3000eb18:	e5934000 	ldr	r4, [r3]
3000eb1c:	e59d3004 	ldr	r3, [sp, #4]
3000eb20:	e5933000 	ldr	r3, [r3]
3000eb24:	e5932004 	ldr	r2, [r3, #4]
3000eb28:	e59d3004 	ldr	r3, [sp, #4]
3000eb2c:	e5933004 	ldr	r3, [r3, #4]
3000eb30:	e5933000 	ldr	r3, [r3]
3000eb34:	e1a00002 	mov	r0, r2
3000eb38:	e1a01003 	mov	r1, r3
3000eb3c:	eb00453d 	bl	30020038 <udp_send>
3000eb40:	e1a03000 	mov	r3, r0
3000eb44:	e20330ff 	and	r3, r3, #255	; 0xff
3000eb48:	e5c43008 	strb	r3, [r4, #8]
3000eb4c:	ea000011 	b	3000eb98 <do_send+0x190>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
3000eb50:	e59d3004 	ldr	r3, [sp, #4]
3000eb54:	e5934000 	ldr	r4, [r3]
3000eb58:	e59d3004 	ldr	r3, [sp, #4]
3000eb5c:	e5933000 	ldr	r3, [r3]
3000eb60:	e5930004 	ldr	r0, [r3, #4]
3000eb64:	e59d3004 	ldr	r3, [sp, #4]
3000eb68:	e5933004 	ldr	r3, [r3, #4]
3000eb6c:	e5931000 	ldr	r1, [r3]
3000eb70:	e59d3004 	ldr	r3, [sp, #4]
3000eb74:	e5933004 	ldr	r3, [r3, #4]
3000eb78:	e5932008 	ldr	r2, [r3, #8]
3000eb7c:	e59d3004 	ldr	r3, [sp, #4]
3000eb80:	e5933004 	ldr	r3, [r3, #4]
3000eb84:	e1d330bc 	ldrh	r3, [r3, #12]
3000eb88:	eb00453e 	bl	30020088 <udp_sendto>
3000eb8c:	e1a03000 	mov	r3, r0
3000eb90:	e20330ff 	and	r3, r3, #255	; 0xff
3000eb94:	e5c43008 	strb	r3, [r4, #8]
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
3000eb98:	e59d3004 	ldr	r3, [sp, #4]
3000eb9c:	e5933000 	ldr	r3, [r3]
3000eba0:	e593300c 	ldr	r3, [r3, #12]
3000eba4:	e1a00003 	mov	r0, r3
3000eba8:	ebfff75e 	bl	3000c928 <sys_sem_signal>
}
3000ebac:	e28dd008 	add	sp, sp, #8
3000ebb0:	e8bd4010 	pop	{r4, lr}
3000ebb4:	e12fff1e 	bx	lr

3000ebb8 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
3000ebb8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000ebbc:	e24dd00c 	sub	sp, sp, #12
3000ebc0:	e58d0004 	str	r0, [sp, #4]
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
3000ebc4:	e59d3004 	ldr	r3, [sp, #4]
3000ebc8:	e5933000 	ldr	r3, [r3]
3000ebcc:	e5d33008 	ldrb	r3, [r3, #8]
3000ebd0:	e1a03c03 	lsl	r3, r3, #24
3000ebd4:	e1a03c43 	asr	r3, r3, #24
3000ebd8:	e3730003 	cmn	r3, #3
3000ebdc:	ba000011 	blt	3000ec28 <do_recv+0x70>
    if (msg->conn->pcb.tcp != NULL) {
3000ebe0:	e59d3004 	ldr	r3, [sp, #4]
3000ebe4:	e5933000 	ldr	r3, [r3]
3000ebe8:	e5933004 	ldr	r3, [r3, #4]
3000ebec:	e3530000 	cmp	r3, #0
3000ebf0:	0a00000c 	beq	3000ec28 <do_recv+0x70>
      if (msg->conn->type == NETCONN_TCP) {
3000ebf4:	e59d3004 	ldr	r3, [sp, #4]
3000ebf8:	e5933000 	ldr	r3, [r3]
3000ebfc:	e5d33000 	ldrb	r3, [r3]
3000ec00:	e3530010 	cmp	r3, #16
3000ec04:	1a000007 	bne	3000ec28 <do_recv+0x70>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
3000ec08:	e59d3004 	ldr	r3, [sp, #4]
3000ec0c:	e5933000 	ldr	r3, [r3]
3000ec10:	e5932004 	ldr	r2, [r3, #4]
3000ec14:	e59d3004 	ldr	r3, [sp, #4]
3000ec18:	e1d330b4 	ldrh	r3, [r3, #4]
3000ec1c:	e1a00002 	mov	r0, r2
3000ec20:	e1a01003 	mov	r1, r3
3000ec24:	eb0024af 	bl	30017ee8 <tcp_recved>
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
3000ec28:	e59d3004 	ldr	r3, [sp, #4]
3000ec2c:	e5933000 	ldr	r3, [r3]
3000ec30:	e593300c 	ldr	r3, [r3, #12]
3000ec34:	e1a00003 	mov	r0, r3
3000ec38:	ebfff73a 	bl	3000c928 <sys_sem_signal>
}
3000ec3c:	e28dd00c 	add	sp, sp, #12
3000ec40:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000ec44:	e12fff1e 	bx	lr

3000ec48 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
3000ec48:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000ec4c:	e24dd01c 	sub	sp, sp, #28
3000ec50:	e58d0004 	str	r0, [sp, #4]
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
3000ec54:	e3a03000 	mov	r3, #0
3000ec58:	e5cd3017 	strb	r3, [sp, #23]

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
3000ec5c:	e59d3004 	ldr	r3, [sp, #4]
3000ec60:	e5933020 	ldr	r3, [r3, #32]
3000ec64:	e5932004 	ldr	r2, [r3, #4]
3000ec68:	e59d3004 	ldr	r3, [sp, #4]
3000ec6c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
3000ec70:	e0823003 	add	r3, r2, r3
3000ec74:	e58d300c 	str	r3, [sp, #12]
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
3000ec78:	e59d3004 	ldr	r3, [sp, #4]
3000ec7c:	e5933020 	ldr	r3, [r3, #32]
3000ec80:	e5932008 	ldr	r2, [r3, #8]
3000ec84:	e59d3004 	ldr	r3, [sp, #4]
3000ec88:	e5933024 	ldr	r3, [r3, #36]	; 0x24
3000ec8c:	e0632002 	rsb	r2, r3, r2
3000ec90:	e3a03801 	mov	r3, #65536	; 0x10000
3000ec94:	e2433001 	sub	r3, r3, #1
3000ec98:	e1520003 	cmp	r2, r3
3000ec9c:	da000002 	ble	3000ecac <do_writemore+0x64>
    len = 0xffff;
3000eca0:	e3e03000 	mvn	r3, #0
3000eca4:	e1cd31b2 	strh	r3, [sp, #18]
3000eca8:	ea00000a 	b	3000ecd8 <do_writemore+0x90>
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
3000ecac:	e59d3004 	ldr	r3, [sp, #4]
3000ecb0:	e5933020 	ldr	r3, [r3, #32]
3000ecb4:	e5933008 	ldr	r3, [r3, #8]
3000ecb8:	e1a03803 	lsl	r3, r3, #16
3000ecbc:	e1a02823 	lsr	r2, r3, #16
3000ecc0:	e59d3004 	ldr	r3, [sp, #4]
3000ecc4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
3000ecc8:	e1a03803 	lsl	r3, r3, #16
3000eccc:	e1a03823 	lsr	r3, r3, #16
3000ecd0:	e0633002 	rsb	r3, r3, r2
3000ecd4:	e1cd31b2 	strh	r3, [sp, #18]
  }
  available = tcp_sndbuf(conn->pcb.tcp);
3000ecd8:	e59d3004 	ldr	r3, [sp, #4]
3000ecdc:	e5933004 	ldr	r3, [r3, #4]
3000ece0:	e1d336ba 	ldrh	r3, [r3, #106]	; 0x6a
3000ece4:	e1cd31b4 	strh	r3, [sp, #20]
  if (available < len) {
3000ece8:	e1dd21b4 	ldrh	r2, [sp, #20]
3000ecec:	e1dd31b2 	ldrh	r3, [sp, #18]
3000ecf0:	e1520003 	cmp	r2, r3
3000ecf4:	2a000001 	bcs	3000ed00 <do_writemore+0xb8>
    /* don't try to write more than sendbuf */
    len = available;
3000ecf8:	e1dd31b4 	ldrh	r3, [sp, #20]
3000ecfc:	e1cd31b2 	strh	r3, [sp, #18]
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
3000ed00:	e59d3004 	ldr	r3, [sp, #4]
3000ed04:	e5931004 	ldr	r1, [r3, #4]
3000ed08:	e59d3004 	ldr	r3, [sp, #4]
3000ed0c:	e5933020 	ldr	r3, [r3, #32]
3000ed10:	e5d3300c 	ldrb	r3, [r3, #12]
3000ed14:	e1dd21b2 	ldrh	r2, [sp, #18]
3000ed18:	e1a00001 	mov	r0, r1
3000ed1c:	e59d100c 	ldr	r1, [sp, #12]
3000ed20:	eb003a2c 	bl	3001d5d8 <tcp_write>
3000ed24:	e1a03000 	mov	r3, r0
3000ed28:	e20330ff 	and	r3, r3, #255	; 0xff
3000ed2c:	e5cd300b 	strb	r3, [sp, #11]
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
3000ed30:	e1dd30db 	ldrsb	r3, [sp, #11]
3000ed34:	e3530000 	cmp	r3, #0
3000ed38:	1a00004b 	bne	3000ee6c <do_writemore+0x224>
    conn->write_offset += len;
3000ed3c:	e59d3004 	ldr	r3, [sp, #4]
3000ed40:	e5932024 	ldr	r2, [r3, #36]	; 0x24
3000ed44:	e1dd31b2 	ldrh	r3, [sp, #18]
3000ed48:	e0822003 	add	r2, r2, r3
3000ed4c:	e59d3004 	ldr	r3, [sp, #4]
3000ed50:	e5832024 	str	r2, [r3, #36]	; 0x24
    if (conn->write_offset == conn->write_msg->msg.w.len) {
3000ed54:	e59d3004 	ldr	r3, [sp, #4]
3000ed58:	e5932024 	ldr	r2, [r3, #36]	; 0x24
3000ed5c:	e59d3004 	ldr	r3, [sp, #4]
3000ed60:	e5933020 	ldr	r3, [r3, #32]
3000ed64:	e5933008 	ldr	r3, [r3, #8]
3000ed68:	e1520003 	cmp	r2, r3
3000ed6c:	1a000007 	bne	3000ed90 <do_writemore+0x148>
      /* everything was written */
      write_finished = 1;
3000ed70:	e3a03001 	mov	r3, #1
3000ed74:	e5cd3017 	strb	r3, [sp, #23]
      conn->write_msg = NULL;
3000ed78:	e59d3004 	ldr	r3, [sp, #4]
3000ed7c:	e3a02000 	mov	r2, #0
3000ed80:	e5832020 	str	r2, [r3, #32]
      conn->write_offset = 0;
3000ed84:	e59d3004 	ldr	r3, [sp, #4]
3000ed88:	e3a02000 	mov	r2, #0
3000ed8c:	e5832024 	str	r2, [r3, #36]	; 0x24
	//acoral_print("\r\ndWMS\r\n");   
    //acoral_print("\r\n=%d\r\n",((conn->pcb.tcp)->unacked == NULL)?1:0);
    //acoral_print("\r\n=%d\r\n",((conn->pcb.tcp)->flags & TF_NODELAY)?1:0);
    //acoral_print("\r\n=%d\r\n",((conn->pcb.tcp)->unsent != NULL)?1:0);
    //acoral_print("\r\n=%d\r\n",((conn->pcb.tcp)->unsent->next != NULL)?1:0);
    err = tcp_output_nagle(conn->pcb.tcp);
3000ed90:	e59d3004 	ldr	r3, [sp, #4]
3000ed94:	e5933004 	ldr	r3, [r3, #4]
3000ed98:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3000ed9c:	e3530000 	cmp	r3, #0
3000eda0:	0a000010 	beq	3000ede8 <do_writemore+0x1a0>
3000eda4:	e59d3004 	ldr	r3, [sp, #4]
3000eda8:	e5933004 	ldr	r3, [r3, #4]
3000edac:	e5d3301c 	ldrb	r3, [r3, #28]
3000edb0:	e2033040 	and	r3, r3, #64	; 0x40
3000edb4:	e3530000 	cmp	r3, #0
3000edb8:	1a00000a 	bne	3000ede8 <do_writemore+0x1a0>
3000edbc:	e59d3004 	ldr	r3, [sp, #4]
3000edc0:	e5933004 	ldr	r3, [r3, #4]
3000edc4:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3000edc8:	e3530000 	cmp	r3, #0
3000edcc:	0a00000d 	beq	3000ee08 <do_writemore+0x1c0>
3000edd0:	e59d3004 	ldr	r3, [sp, #4]
3000edd4:	e5933004 	ldr	r3, [r3, #4]
3000edd8:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3000eddc:	e5933000 	ldr	r3, [r3]
3000ede0:	e3530000 	cmp	r3, #0
3000ede4:	0a000007 	beq	3000ee08 <do_writemore+0x1c0>
3000ede8:	e59d3004 	ldr	r3, [sp, #4]
3000edec:	e5933004 	ldr	r3, [r3, #4]
3000edf0:	e1a00003 	mov	r0, r3
3000edf4:	eb003c76 	bl	3001dfd4 <tcp_output>
3000edf8:	e1a03000 	mov	r3, r0
3000edfc:	e20330ff 	and	r3, r3, #255	; 0xff
3000ee00:	e20330ff 	and	r3, r3, #255	; 0xff
3000ee04:	ea000000 	b	3000ee0c <do_writemore+0x1c4>
3000ee08:	e3a03000 	mov	r3, #0
3000ee0c:	e5cd300b 	strb	r3, [sp, #11]
    //acoral_print("\r\ndWME########%d\r\n",err);
    conn->err = err;
3000ee10:	e59d3004 	ldr	r3, [sp, #4]
3000ee14:	e5dd200b 	ldrb	r2, [sp, #11]
3000ee18:	e5c32008 	strb	r2, [r3, #8]
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
3000ee1c:	e1dd30db 	ldrsb	r3, [sp, #11]
3000ee20:	e3530000 	cmp	r3, #0
3000ee24:	1a000021 	bne	3000eeb0 <do_writemore+0x268>
3000ee28:	e59d3004 	ldr	r3, [sp, #4]
3000ee2c:	e5933004 	ldr	r3, [r3, #4]
3000ee30:	e1d336ba 	ldrh	r3, [r3, #106]	; 0x6a
3000ee34:	e3530a01 	cmp	r3, #4096	; 0x1000
3000ee38:	8a00001e 	bhi	3000eeb8 <do_writemore+0x270>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
3000ee3c:	e59d3004 	ldr	r3, [sp, #4]
3000ee40:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000ee44:	e3530000 	cmp	r3, #0
3000ee48:	0a00001b 	beq	3000eebc <do_writemore+0x274>
3000ee4c:	e59d3004 	ldr	r3, [sp, #4]
3000ee50:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3000ee54:	e1dd21b2 	ldrh	r2, [sp, #18]
3000ee58:	e59d0004 	ldr	r0, [sp, #4]
3000ee5c:	e3a01003 	mov	r1, #3
3000ee60:	e1a0e00f 	mov	lr, pc
3000ee64:	e12fff13 	bx	r3
3000ee68:	ea000013 	b	3000eebc <do_writemore+0x274>
    }
  } else if (err == ERR_MEM) {
3000ee6c:	e1dd30db 	ldrsb	r3, [sp, #11]
3000ee70:	e3730001 	cmn	r3, #1
3000ee74:	1a000007 	bne	3000ee98 <do_writemore+0x250>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
3000ee78:	e59d3004 	ldr	r3, [sp, #4]
3000ee7c:	e5933004 	ldr	r3, [r3, #4]
3000ee80:	e1a00003 	mov	r0, r3
3000ee84:	eb003c52 	bl	3001dfd4 <tcp_output>
3000ee88:	e1a03000 	mov	r3, r0
3000ee8c:	e20330ff 	and	r3, r3, #255	; 0xff
3000ee90:	e5cd300b 	strb	r3, [sp, #11]
3000ee94:	ea000008 	b	3000eebc <do_writemore+0x274>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
3000ee98:	e59d3004 	ldr	r3, [sp, #4]
3000ee9c:	e5dd200b 	ldrb	r2, [sp, #11]
3000eea0:	e5c32008 	strb	r2, [r3, #8]
    write_finished = 1;
3000eea4:	e3a03001 	mov	r3, #1
3000eea8:	e5cd3017 	strb	r3, [sp, #23]
3000eeac:	ea000002 	b	3000eebc <do_writemore+0x274>
    //acoral_print("\r\n=%d\r\n",((conn->pcb.tcp)->unsent->next != NULL)?1:0);
    err = tcp_output_nagle(conn->pcb.tcp);
    //acoral_print("\r\ndWME########%d\r\n",err);
    conn->err = err;
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
3000eeb0:	e1a00000 	nop			; (mov r0, r0)
3000eeb4:	ea000000 	b	3000eebc <do_writemore+0x274>
3000eeb8:	e1a00000 	nop			; (mov r0, r0)
       the error to the application thread. */
    conn->err = err;
    write_finished = 1;
  }

  if (write_finished) {
3000eebc:	e5dd3017 	ldrb	r3, [sp, #23]
3000eec0:	e3530000 	cmp	r3, #0
3000eec4:	0a000006 	beq	3000eee4 <do_writemore+0x29c>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
3000eec8:	e59d3004 	ldr	r3, [sp, #4]
3000eecc:	e3a02000 	mov	r2, #0
3000eed0:	e5c32001 	strb	r2, [r3, #1]
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
3000eed4:	e59d3004 	ldr	r3, [sp, #4]
3000eed8:	e593300c 	ldr	r3, [r3, #12]
3000eedc:	e1a00003 	mov	r0, r3
3000eee0:	ebfff690 	bl	3000c928 <sys_sem_signal>
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
3000eee4:	e3a03000 	mov	r3, #0
3000eee8:	e1a03c03 	lsl	r3, r3, #24
3000eeec:	e1a03c43 	asr	r3, r3, #24
}
3000eef0:	e1a00003 	mov	r0, r3
3000eef4:	e28dd01c 	add	sp, sp, #28
3000eef8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000eefc:	e12fff1e 	bx	lr

3000ef00 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
3000ef00:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000ef04:	e24dd00c 	sub	sp, sp, #12
3000ef08:	e58d0004 	str	r0, [sp, #4]
  if (!ERR_IS_FATAL(msg->conn->err)) {
3000ef0c:	e59d3004 	ldr	r3, [sp, #4]
3000ef10:	e5933000 	ldr	r3, [r3]
3000ef14:	e5d33008 	ldrb	r3, [r3, #8]
3000ef18:	e1a03c03 	lsl	r3, r3, #24
3000ef1c:	e1a03c43 	asr	r3, r3, #24
3000ef20:	e3730003 	cmn	r3, #3
3000ef24:	ba00001e 	blt	3000efa4 <do_write+0xa4>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
3000ef28:	e59d3004 	ldr	r3, [sp, #4]
3000ef2c:	e5933000 	ldr	r3, [r3]
3000ef30:	e5933004 	ldr	r3, [r3, #4]
3000ef34:	e3530000 	cmp	r3, #0
3000ef38:	0a000015 	beq	3000ef94 <do_write+0x94>
3000ef3c:	e59d3004 	ldr	r3, [sp, #4]
3000ef40:	e5933000 	ldr	r3, [r3]
3000ef44:	e5d33000 	ldrb	r3, [r3]
3000ef48:	e3530010 	cmp	r3, #16
3000ef4c:	1a000010 	bne	3000ef94 <do_write+0x94>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
3000ef50:	e59d3004 	ldr	r3, [sp, #4]
3000ef54:	e5933000 	ldr	r3, [r3]
3000ef58:	e3a02001 	mov	r2, #1
3000ef5c:	e5c32001 	strb	r2, [r3, #1]
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
3000ef60:	e59d3004 	ldr	r3, [sp, #4]
3000ef64:	e5933000 	ldr	r3, [r3]
3000ef68:	e59d2004 	ldr	r2, [sp, #4]
3000ef6c:	e5832020 	str	r2, [r3, #32]
      msg->conn->write_offset = 0;
3000ef70:	e59d3004 	ldr	r3, [sp, #4]
3000ef74:	e5933000 	ldr	r3, [r3]
3000ef78:	e3a02000 	mov	r2, #0
3000ef7c:	e5832024 	str	r2, [r3, #36]	; 0x24
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
	 // acoral_prints("\r\ndWSta\r\n");
      do_writemore(msg->conn);
3000ef80:	e59d3004 	ldr	r3, [sp, #4]
3000ef84:	e5933000 	ldr	r3, [r3]
3000ef88:	e1a00003 	mov	r0, r3
3000ef8c:	ebffff2d 	bl	3000ec48 <do_writemore>
     // acoral_prints("\r\ndWEnd\r\n");
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
3000ef90:	ea000008 	b	3000efb8 <do_write+0xb8>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
3000ef94:	e59d3004 	ldr	r3, [sp, #4]
3000ef98:	e5933000 	ldr	r3, [r3]
3000ef9c:	e3e02007 	mvn	r2, #7
3000efa0:	e5c32008 	strb	r2, [r3, #8]
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
3000efa4:	e59d3004 	ldr	r3, [sp, #4]
3000efa8:	e5933000 	ldr	r3, [r3]
3000efac:	e593300c 	ldr	r3, [r3, #12]
3000efb0:	e1a00003 	mov	r0, r3
3000efb4:	ebfff65b 	bl	3000c928 <sys_sem_signal>
}
3000efb8:	e28dd00c 	add	sp, sp, #12
3000efbc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000efc0:	e12fff1e 	bx	lr

3000efc4 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
3000efc4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000efc8:	e24dd00c 	sub	sp, sp, #12
3000efcc:	e58d0004 	str	r0, [sp, #4]
  if (msg->conn->pcb.ip != NULL) {
3000efd0:	e59d3004 	ldr	r3, [sp, #4]
3000efd4:	e5933000 	ldr	r3, [r3]
3000efd8:	e5933004 	ldr	r3, [r3, #4]
3000efdc:	e3530000 	cmp	r3, #0
3000efe0:	0a00005a 	beq	3000f150 <do_getaddr+0x18c>
    (msg->msg.ad.ipaddr) = (msg->msg.ad.local?&(msg->conn->pcb.ip->local_ip):&(msg->conn->pcb.ip->remote_ip));
3000efe4:	e59d3004 	ldr	r3, [sp, #4]
3000efe8:	e5d3300c 	ldrb	r3, [r3, #12]
3000efec:	e3530000 	cmp	r3, #0
3000eff0:	0a000003 	beq	3000f004 <do_getaddr+0x40>
3000eff4:	e59d3004 	ldr	r3, [sp, #4]
3000eff8:	e5933000 	ldr	r3, [r3]
3000effc:	e5933004 	ldr	r3, [r3, #4]
3000f000:	ea000003 	b	3000f014 <do_getaddr+0x50>
3000f004:	e59d3004 	ldr	r3, [sp, #4]
3000f008:	e5933000 	ldr	r3, [r3]
3000f00c:	e5933004 	ldr	r3, [r3, #4]
3000f010:	e2833004 	add	r3, r3, #4
3000f014:	e59d2004 	ldr	r2, [sp, #4]
3000f018:	e5823004 	str	r3, [r2, #4]
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
3000f01c:	e59d3004 	ldr	r3, [sp, #4]
3000f020:	e5933000 	ldr	r3, [r3]
3000f024:	e5d33000 	ldrb	r3, [r3]
3000f028:	e20330f0 	and	r3, r3, #240	; 0xf0
3000f02c:	e3530020 	cmp	r3, #32
3000f030:	0a000015 	beq	3000f08c <do_getaddr+0xc8>
3000f034:	e3530040 	cmp	r3, #64	; 0x40
3000f038:	0a000002 	beq	3000f048 <do_getaddr+0x84>
3000f03c:	e3530010 	cmp	r3, #16
3000f040:	0a000031 	beq	3000f10c <do_getaddr+0x148>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
3000f044:	ea000045 	b	3000f160 <do_getaddr+0x19c>
    (msg->msg.ad.ipaddr) = (msg->msg.ad.local?&(msg->conn->pcb.ip->local_ip):&(msg->conn->pcb.ip->remote_ip));
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
3000f048:	e59d3004 	ldr	r3, [sp, #4]
3000f04c:	e5d3300c 	ldrb	r3, [r3, #12]
3000f050:	e3530000 	cmp	r3, #0
3000f054:	0a000007 	beq	3000f078 <do_getaddr+0xb4>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
3000f058:	e59d3004 	ldr	r3, [sp, #4]
3000f05c:	e5933008 	ldr	r3, [r3, #8]
3000f060:	e59d2004 	ldr	r2, [sp, #4]
3000f064:	e5922000 	ldr	r2, [r2]
3000f068:	e5922004 	ldr	r2, [r2, #4]
3000f06c:	e5d22010 	ldrb	r2, [r2, #16]
3000f070:	e1c320b0 	strh	r2, [r3]
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
      }
      break;
3000f074:	ea000039 	b	3000f160 <do_getaddr+0x19c>
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
3000f078:	e59d3004 	ldr	r3, [sp, #4]
3000f07c:	e5933000 	ldr	r3, [r3]
3000f080:	e3e02006 	mvn	r2, #6
3000f084:	e5c32008 	strb	r2, [r3, #8]
      }
      break;
3000f088:	ea000034 	b	3000f160 <do_getaddr+0x19c>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
3000f08c:	e59d3004 	ldr	r3, [sp, #4]
3000f090:	e5d3300c 	ldrb	r3, [r3, #12]
3000f094:	e3530000 	cmp	r3, #0
3000f098:	0a000007 	beq	3000f0bc <do_getaddr+0xf8>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
3000f09c:	e59d3004 	ldr	r3, [sp, #4]
3000f0a0:	e5933008 	ldr	r3, [r3, #8]
3000f0a4:	e59d2004 	ldr	r2, [sp, #4]
3000f0a8:	e5922000 	ldr	r2, [r2]
3000f0ac:	e5922004 	ldr	r2, [r2, #4]
3000f0b0:	e1d221b2 	ldrh	r2, [r2, #18]
3000f0b4:	e1c320b0 	strh	r2, [r3]
          msg->conn->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
3000f0b8:	ea000028 	b	3000f160 <do_getaddr+0x19c>
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
3000f0bc:	e59d3004 	ldr	r3, [sp, #4]
3000f0c0:	e5933000 	ldr	r3, [r3]
3000f0c4:	e5933004 	ldr	r3, [r3, #4]
3000f0c8:	e5d33010 	ldrb	r3, [r3, #16]
3000f0cc:	e2033004 	and	r3, r3, #4
3000f0d0:	e3530000 	cmp	r3, #0
3000f0d4:	1a000004 	bne	3000f0ec <do_getaddr+0x128>
          msg->conn->err = ERR_CONN;
3000f0d8:	e59d3004 	ldr	r3, [sp, #4]
3000f0dc:	e5933000 	ldr	r3, [r3]
3000f0e0:	e3e02006 	mvn	r2, #6
3000f0e4:	e5c32008 	strb	r2, [r3, #8]
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
3000f0e8:	ea00001c 	b	3000f160 <do_getaddr+0x19c>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
          msg->conn->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
3000f0ec:	e59d3004 	ldr	r3, [sp, #4]
3000f0f0:	e5933008 	ldr	r3, [r3, #8]
3000f0f4:	e59d2004 	ldr	r2, [sp, #4]
3000f0f8:	e5922000 	ldr	r2, [r2]
3000f0fc:	e5922004 	ldr	r2, [r2, #4]
3000f100:	e1d221b4 	ldrh	r2, [r2, #20]
3000f104:	e1c320b0 	strh	r2, [r3]
        }
      }
      break;
3000f108:	ea000014 	b	3000f160 <do_getaddr+0x19c>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
3000f10c:	e59d3004 	ldr	r3, [sp, #4]
3000f110:	e5932008 	ldr	r2, [r3, #8]
3000f114:	e59d3004 	ldr	r3, [sp, #4]
3000f118:	e5d3300c 	ldrb	r3, [r3, #12]
3000f11c:	e3530000 	cmp	r3, #0
3000f120:	0a000004 	beq	3000f138 <do_getaddr+0x174>
3000f124:	e59d3004 	ldr	r3, [sp, #4]
3000f128:	e5933000 	ldr	r3, [r3]
3000f12c:	e5933004 	ldr	r3, [r3, #4]
3000f130:	e1d331b8 	ldrh	r3, [r3, #24]
3000f134:	ea000003 	b	3000f148 <do_getaddr+0x184>
3000f138:	e59d3004 	ldr	r3, [sp, #4]
3000f13c:	e5933000 	ldr	r3, [r3]
3000f140:	e5933004 	ldr	r3, [r3, #4]
3000f144:	e1d331ba 	ldrh	r3, [r3, #26]
3000f148:	e1c230b0 	strh	r3, [r2]
3000f14c:	ea000003 	b	3000f160 <do_getaddr+0x19c>
      break;
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
3000f150:	e59d3004 	ldr	r3, [sp, #4]
3000f154:	e5933000 	ldr	r3, [r3]
3000f158:	e3e02006 	mvn	r2, #6
3000f15c:	e5c32008 	strb	r2, [r3, #8]
  }
  TCPIP_APIMSG_ACK(msg);
3000f160:	e59d3004 	ldr	r3, [sp, #4]
3000f164:	e5933000 	ldr	r3, [r3]
3000f168:	e593300c 	ldr	r3, [r3, #12]
3000f16c:	e1a00003 	mov	r0, r3
3000f170:	ebfff5ec 	bl	3000c928 <sys_sem_signal>
}
3000f174:	e28dd00c 	add	sp, sp, #12
3000f178:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f17c:	e12fff1e 	bx	lr

3000f180 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
3000f180:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f184:	e24dd00c 	sub	sp, sp, #12
3000f188:	e58d0004 	str	r0, [sp, #4]
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
3000f18c:	e59d3004 	ldr	r3, [sp, #4]
3000f190:	e5933000 	ldr	r3, [r3]
3000f194:	e5933004 	ldr	r3, [r3, #4]
3000f198:	e3530000 	cmp	r3, #0
3000f19c:	0a00000d 	beq	3000f1d8 <do_close+0x58>
3000f1a0:	e59d3004 	ldr	r3, [sp, #4]
3000f1a4:	e5933000 	ldr	r3, [r3]
3000f1a8:	e5d33000 	ldrb	r3, [r3]
3000f1ac:	e3530010 	cmp	r3, #16
3000f1b0:	1a000008 	bne	3000f1d8 <do_close+0x58>
      msg->conn->state = NETCONN_CLOSE;
3000f1b4:	e59d3004 	ldr	r3, [sp, #4]
3000f1b8:	e5933000 	ldr	r3, [r3]
3000f1bc:	e3a02004 	mov	r2, #4
3000f1c0:	e5c32001 	strb	r2, [r3, #1]
      do_close_internal(msg->conn);
3000f1c4:	e59d3004 	ldr	r3, [sp, #4]
3000f1c8:	e5933000 	ldr	r3, [r3]
3000f1cc:	e1a00003 	mov	r0, r3
3000f1d0:	ebfffbea 	bl	3000e180 <do_close_internal>
 */
void
do_close(struct api_msg_msg *msg)
{
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
3000f1d4:	ea000008 	b	3000f1fc <do_close+0x7c>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
3000f1d8:	e59d3004 	ldr	r3, [sp, #4]
3000f1dc:	e5933000 	ldr	r3, [r3]
3000f1e0:	e3e02007 	mvn	r2, #7
3000f1e4:	e5c32008 	strb	r2, [r3, #8]
    TCPIP_APIMSG_ACK(msg);
3000f1e8:	e59d3004 	ldr	r3, [sp, #4]
3000f1ec:	e5933000 	ldr	r3, [r3]
3000f1f0:	e593300c 	ldr	r3, [r3, #12]
3000f1f4:	e1a00003 	mov	r0, r3
3000f1f8:	ebfff5ca 	bl	3000c928 <sys_sem_signal>
  }
}
3000f1fc:	e28dd00c 	add	sp, sp, #12
3000f200:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f204:	e12fff1e 	bx	lr

3000f208 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
3000f208:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f20c:	e24dd00c 	sub	sp, sp, #12
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
3000f210:	e3a00005 	mov	r0, #5
3000f214:	eb001846 	bl	30015334 <memp_malloc>
3000f218:	e1a03000 	mov	r3, r0
3000f21c:	e58d3004 	str	r3, [sp, #4]
  if (buf != NULL) {
3000f220:	e59d3004 	ldr	r3, [sp, #4]
3000f224:	e3530000 	cmp	r3, #0
3000f228:	0a00000a 	beq	3000f258 <netbuf_new+0x50>
    buf->p = NULL;
3000f22c:	e59d3004 	ldr	r3, [sp, #4]
3000f230:	e3a02000 	mov	r2, #0
3000f234:	e5832000 	str	r2, [r3]
    buf->ptr = NULL;
3000f238:	e59d3004 	ldr	r3, [sp, #4]
3000f23c:	e3a02000 	mov	r2, #0
3000f240:	e5832004 	str	r2, [r3, #4]
    buf->addr = NULL;
3000f244:	e59d3004 	ldr	r3, [sp, #4]
3000f248:	e3a02000 	mov	r2, #0
3000f24c:	e5832008 	str	r2, [r3, #8]
    return buf;
3000f250:	e59d3004 	ldr	r3, [sp, #4]
3000f254:	ea000000 	b	3000f25c <netbuf_new+0x54>
  } else {
    return NULL;
3000f258:	e3a03000 	mov	r3, #0
  }
}
3000f25c:	e1a00003 	mov	r0, r3
3000f260:	e28dd00c 	add	sp, sp, #12
3000f264:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f268:	e12fff1e 	bx	lr

3000f26c <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
3000f26c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f270:	e24dd00c 	sub	sp, sp, #12
3000f274:	e58d0004 	str	r0, [sp, #4]
  if (buf != NULL) {
3000f278:	e59d3004 	ldr	r3, [sp, #4]
3000f27c:	e3530000 	cmp	r3, #0
3000f280:	0a000011 	beq	3000f2cc <netbuf_delete+0x60>
    if (buf->p != NULL) {
3000f284:	e59d3004 	ldr	r3, [sp, #4]
3000f288:	e5933000 	ldr	r3, [r3]
3000f28c:	e3530000 	cmp	r3, #0
3000f290:	0a00000a 	beq	3000f2c0 <netbuf_delete+0x54>
      pbuf_free(buf->p);
3000f294:	e59d3004 	ldr	r3, [sp, #4]
3000f298:	e5933000 	ldr	r3, [r3]
3000f29c:	e1a00003 	mov	r0, r3
3000f2a0:	eb001bf6 	bl	30016280 <pbuf_free>
      buf->p = buf->ptr = NULL;
3000f2a4:	e59d3004 	ldr	r3, [sp, #4]
3000f2a8:	e3a02000 	mov	r2, #0
3000f2ac:	e5832004 	str	r2, [r3, #4]
3000f2b0:	e59d3004 	ldr	r3, [sp, #4]
3000f2b4:	e5932004 	ldr	r2, [r3, #4]
3000f2b8:	e59d3004 	ldr	r3, [sp, #4]
3000f2bc:	e5832000 	str	r2, [r3]
    }
    memp_free(MEMP_NETBUF, buf);
3000f2c0:	e3a00005 	mov	r0, #5
3000f2c4:	e59d1004 	ldr	r1, [sp, #4]
3000f2c8:	eb00187e 	bl	300154c8 <memp_free>
  }
}
3000f2cc:	e28dd00c 	add	sp, sp, #12
3000f2d0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f2d4:	e12fff1e 	bx	lr

3000f2d8 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
3000f2d8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f2dc:	e24dd00c 	sub	sp, sp, #12
3000f2e0:	e58d0004 	str	r0, [sp, #4]
3000f2e4:	e1a03001 	mov	r3, r1
3000f2e8:	e1cd30b2 	strh	r3, [sp, #2]
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
3000f2ec:	e59d3004 	ldr	r3, [sp, #4]
3000f2f0:	e5933000 	ldr	r3, [r3]
3000f2f4:	e3530000 	cmp	r3, #0
3000f2f8:	0a000003 	beq	3000f30c <netbuf_alloc+0x34>
    pbuf_free(buf->p);
3000f2fc:	e59d3004 	ldr	r3, [sp, #4]
3000f300:	e5933000 	ldr	r3, [r3]
3000f304:	e1a00003 	mov	r0, r3
3000f308:	eb001bdc 	bl	30016280 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
3000f30c:	e1dd30b2 	ldrh	r3, [sp, #2]
3000f310:	e3a00000 	mov	r0, #0
3000f314:	e1a01003 	mov	r1, r3
3000f318:	e3a02000 	mov	r2, #0
3000f31c:	eb001a25 	bl	30015bb8 <pbuf_alloc>
3000f320:	e1a02000 	mov	r2, r0
3000f324:	e59d3004 	ldr	r3, [sp, #4]
3000f328:	e5832000 	str	r2, [r3]
  if (buf->p == NULL) {
3000f32c:	e59d3004 	ldr	r3, [sp, #4]
3000f330:	e5933000 	ldr	r3, [r3]
3000f334:	e3530000 	cmp	r3, #0
3000f338:	1a000001 	bne	3000f344 <netbuf_alloc+0x6c>
     return NULL;
3000f33c:	e3a03000 	mov	r3, #0
3000f340:	ea000006 	b	3000f360 <netbuf_alloc+0x88>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
3000f344:	e59d3004 	ldr	r3, [sp, #4]
3000f348:	e5932000 	ldr	r2, [r3]
3000f34c:	e59d3004 	ldr	r3, [sp, #4]
3000f350:	e5832004 	str	r2, [r3, #4]
  return buf->p->payload;
3000f354:	e59d3004 	ldr	r3, [sp, #4]
3000f358:	e5933000 	ldr	r3, [r3]
3000f35c:	e5933004 	ldr	r3, [r3, #4]
}
3000f360:	e1a00003 	mov	r0, r3
3000f364:	e28dd00c 	add	sp, sp, #12
3000f368:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f36c:	e12fff1e 	bx	lr

3000f370 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
3000f370:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f374:	e24dd00c 	sub	sp, sp, #12
3000f378:	e58d0004 	str	r0, [sp, #4]
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  if (buf->p != NULL) {
3000f37c:	e59d3004 	ldr	r3, [sp, #4]
3000f380:	e5933000 	ldr	r3, [r3]
3000f384:	e3530000 	cmp	r3, #0
3000f388:	0a000003 	beq	3000f39c <netbuf_free+0x2c>
    pbuf_free(buf->p);
3000f38c:	e59d3004 	ldr	r3, [sp, #4]
3000f390:	e5933000 	ldr	r3, [r3]
3000f394:	e1a00003 	mov	r0, r3
3000f398:	eb001bb8 	bl	30016280 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
3000f39c:	e59d3004 	ldr	r3, [sp, #4]
3000f3a0:	e3a02000 	mov	r2, #0
3000f3a4:	e5832004 	str	r2, [r3, #4]
3000f3a8:	e59d3004 	ldr	r3, [sp, #4]
3000f3ac:	e5932004 	ldr	r2, [r3, #4]
3000f3b0:	e59d3004 	ldr	r3, [sp, #4]
3000f3b4:	e5832000 	str	r2, [r3]
}
3000f3b8:	e28dd00c 	add	sp, sp, #12
3000f3bc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f3c0:	e12fff1e 	bx	lr

3000f3c4 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
3000f3c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f3c8:	e24dd014 	sub	sp, sp, #20
3000f3cc:	e58d000c 	str	r0, [sp, #12]
3000f3d0:	e58d1008 	str	r1, [sp, #8]
3000f3d4:	e1a03002 	mov	r3, r2
3000f3d8:	e1cd30b6 	strh	r3, [sp, #6]
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  if (buf->p != NULL) {
3000f3dc:	e59d300c 	ldr	r3, [sp, #12]
3000f3e0:	e5933000 	ldr	r3, [r3]
3000f3e4:	e3530000 	cmp	r3, #0
3000f3e8:	0a000003 	beq	3000f3fc <netbuf_ref+0x38>
    pbuf_free(buf->p);
3000f3ec:	e59d300c 	ldr	r3, [sp, #12]
3000f3f0:	e5933000 	ldr	r3, [r3]
3000f3f4:	e1a00003 	mov	r0, r3
3000f3f8:	eb001ba0 	bl	30016280 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
3000f3fc:	e3a00000 	mov	r0, #0
3000f400:	e3a01000 	mov	r1, #0
3000f404:	e3a02002 	mov	r2, #2
3000f408:	eb0019ea 	bl	30015bb8 <pbuf_alloc>
3000f40c:	e1a02000 	mov	r2, r0
3000f410:	e59d300c 	ldr	r3, [sp, #12]
3000f414:	e5832000 	str	r2, [r3]
  if (buf->p == NULL) {
3000f418:	e59d300c 	ldr	r3, [sp, #12]
3000f41c:	e5933000 	ldr	r3, [r3]
3000f420:	e3530000 	cmp	r3, #0
3000f424:	1a000004 	bne	3000f43c <netbuf_ref+0x78>
    buf->ptr = NULL;
3000f428:	e59d300c 	ldr	r3, [sp, #12]
3000f42c:	e3a02000 	mov	r2, #0
3000f430:	e5832004 	str	r2, [r3, #4]
    return ERR_MEM;
3000f434:	e3a030ff 	mov	r3, #255	; 0xff
3000f438:	ea000010 	b	3000f480 <netbuf_ref+0xbc>
  }
  buf->p->payload = (void*)dataptr;
3000f43c:	e59d300c 	ldr	r3, [sp, #12]
3000f440:	e5933000 	ldr	r3, [r3]
3000f444:	e59d2008 	ldr	r2, [sp, #8]
3000f448:	e5832004 	str	r2, [r3, #4]
  buf->p->len = buf->p->tot_len = size;
3000f44c:	e59d300c 	ldr	r3, [sp, #12]
3000f450:	e5932000 	ldr	r2, [r3]
3000f454:	e59d300c 	ldr	r3, [sp, #12]
3000f458:	e5933000 	ldr	r3, [r3]
3000f45c:	e1dd10b6 	ldrh	r1, [sp, #6]
3000f460:	e1c310b8 	strh	r1, [r3, #8]
3000f464:	e1d330b8 	ldrh	r3, [r3, #8]
3000f468:	e1c230ba 	strh	r3, [r2, #10]
  buf->ptr = buf->p;
3000f46c:	e59d300c 	ldr	r3, [sp, #12]
3000f470:	e5932000 	ldr	r2, [r3]
3000f474:	e59d300c 	ldr	r3, [sp, #12]
3000f478:	e5832004 	str	r2, [r3, #4]
  return ERR_OK;
3000f47c:	e3a03000 	mov	r3, #0
3000f480:	e1a03c03 	lsl	r3, r3, #24
3000f484:	e1a03c43 	asr	r3, r3, #24
}
3000f488:	e1a00003 	mov	r0, r3
3000f48c:	e28dd014 	add	sp, sp, #20
3000f490:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f494:	e12fff1e 	bx	lr

3000f498 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
3000f498:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f49c:	e24dd00c 	sub	sp, sp, #12
3000f4a0:	e58d0004 	str	r0, [sp, #4]
3000f4a4:	e58d1000 	str	r1, [sp]
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  pbuf_chain(head->p, tail->p);
3000f4a8:	e59d3004 	ldr	r3, [sp, #4]
3000f4ac:	e5932000 	ldr	r2, [r3]
3000f4b0:	e59d3000 	ldr	r3, [sp]
3000f4b4:	e5933000 	ldr	r3, [r3]
3000f4b8:	e1a00002 	mov	r0, r2
3000f4bc:	e1a01003 	mov	r1, r3
3000f4c0:	eb001bff 	bl	300164c4 <pbuf_chain>
  head->ptr = head->p;
3000f4c4:	e59d3004 	ldr	r3, [sp, #4]
3000f4c8:	e5932000 	ldr	r2, [r3]
3000f4cc:	e59d3004 	ldr	r3, [sp, #4]
3000f4d0:	e5832004 	str	r2, [r3, #4]
  memp_free(MEMP_NETBUF, tail);
3000f4d4:	e3a00005 	mov	r0, #5
3000f4d8:	e59d1000 	ldr	r1, [sp]
3000f4dc:	eb0017f9 	bl	300154c8 <memp_free>
}
3000f4e0:	e28dd00c 	add	sp, sp, #12
3000f4e4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f4e8:	e12fff1e 	bx	lr

3000f4ec <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
3000f4ec:	e24dd010 	sub	sp, sp, #16
3000f4f0:	e58d000c 	str	r0, [sp, #12]
3000f4f4:	e58d1008 	str	r1, [sp, #8]
3000f4f8:	e58d2004 	str	r2, [sp, #4]
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);

  if (buf->ptr == NULL) {
3000f4fc:	e59d300c 	ldr	r3, [sp, #12]
3000f500:	e5933004 	ldr	r3, [r3, #4]
3000f504:	e3530000 	cmp	r3, #0
3000f508:	1a000001 	bne	3000f514 <netbuf_data+0x28>
    return ERR_BUF;
3000f50c:	e3a030fe 	mov	r3, #254	; 0xfe
3000f510:	ea00000a 	b	3000f540 <netbuf_data+0x54>
  }
  *dataptr = buf->ptr->payload;
3000f514:	e59d300c 	ldr	r3, [sp, #12]
3000f518:	e5933004 	ldr	r3, [r3, #4]
3000f51c:	e5932004 	ldr	r2, [r3, #4]
3000f520:	e59d3008 	ldr	r3, [sp, #8]
3000f524:	e5832000 	str	r2, [r3]
  *len = buf->ptr->len;
3000f528:	e59d300c 	ldr	r3, [sp, #12]
3000f52c:	e5933004 	ldr	r3, [r3, #4]
3000f530:	e1d320ba 	ldrh	r2, [r3, #10]
3000f534:	e59d3004 	ldr	r3, [sp, #4]
3000f538:	e1c320b0 	strh	r2, [r3]
  return ERR_OK;
3000f53c:	e3a03000 	mov	r3, #0
3000f540:	e1a03c03 	lsl	r3, r3, #24
3000f544:	e1a03c43 	asr	r3, r3, #24
}
3000f548:	e1a00003 	mov	r0, r3
3000f54c:	e28dd010 	add	sp, sp, #16
3000f550:	e12fff1e 	bx	lr

3000f554 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
3000f554:	e24dd008 	sub	sp, sp, #8
3000f558:	e58d0004 	str	r0, [sp, #4]
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  if (buf->ptr->next == NULL) {
3000f55c:	e59d3004 	ldr	r3, [sp, #4]
3000f560:	e5933004 	ldr	r3, [r3, #4]
3000f564:	e5933000 	ldr	r3, [r3]
3000f568:	e3530000 	cmp	r3, #0
3000f56c:	1a000001 	bne	3000f578 <netbuf_next+0x24>
    return -1;
3000f570:	e3a030ff 	mov	r3, #255	; 0xff
3000f574:	ea00000c 	b	3000f5ac <netbuf_next+0x58>
  }
  buf->ptr = buf->ptr->next;
3000f578:	e59d3004 	ldr	r3, [sp, #4]
3000f57c:	e5933004 	ldr	r3, [r3, #4]
3000f580:	e5932000 	ldr	r2, [r3]
3000f584:	e59d3004 	ldr	r3, [sp, #4]
3000f588:	e5832004 	str	r2, [r3, #4]
  if (buf->ptr->next == NULL) {
3000f58c:	e59d3004 	ldr	r3, [sp, #4]
3000f590:	e5933004 	ldr	r3, [r3, #4]
3000f594:	e5933000 	ldr	r3, [r3]
3000f598:	e3530000 	cmp	r3, #0
3000f59c:	1a000001 	bne	3000f5a8 <netbuf_next+0x54>
    return 1;
3000f5a0:	e3a03001 	mov	r3, #1
3000f5a4:	ea000000 	b	3000f5ac <netbuf_next+0x58>
  }
  return 0;
3000f5a8:	e3a03000 	mov	r3, #0
3000f5ac:	e1a03c03 	lsl	r3, r3, #24
3000f5b0:	e1a03c43 	asr	r3, r3, #24
}
3000f5b4:	e1a00003 	mov	r0, r3
3000f5b8:	e28dd008 	add	sp, sp, #8
3000f5bc:	e12fff1e 	bx	lr

3000f5c0 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
3000f5c0:	e24dd008 	sub	sp, sp, #8
3000f5c4:	e58d0004 	str	r0, [sp, #4]
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  buf->ptr = buf->p;
3000f5c8:	e59d3004 	ldr	r3, [sp, #4]
3000f5cc:	e5932000 	ldr	r2, [r3]
3000f5d0:	e59d3004 	ldr	r3, [sp, #4]
3000f5d4:	e5832004 	str	r2, [r3, #4]
}
3000f5d8:	e28dd008 	add	sp, sp, #8
3000f5dc:	e12fff1e 	bx	lr

3000f5e0 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
3000f5e0:	e92d4008 	push	{r3, lr}
  socksem   = sys_sem_new(1);
3000f5e4:	e3a00001 	mov	r0, #1
3000f5e8:	ebfff4b9 	bl	3000c8d4 <sys_sem_new>
3000f5ec:	e1a02000 	mov	r2, r0
3000f5f0:	e59f301c 	ldr	r3, [pc, #28]	; 3000f614 <lwip_socket_init+0x34>
3000f5f4:	e5832000 	str	r2, [r3]
  selectsem = sys_sem_new(1);
3000f5f8:	e3a00001 	mov	r0, #1
3000f5fc:	ebfff4b4 	bl	3000c8d4 <sys_sem_new>
3000f600:	e1a02000 	mov	r2, r0
3000f604:	e59f300c 	ldr	r3, [pc, #12]	; 3000f618 <lwip_socket_init+0x38>
3000f608:	e5832000 	str	r2, [r3]
}
3000f60c:	e8bd4008 	pop	{r3, lr}
3000f610:	e12fff1e 	bx	lr
3000f614:	300ca638 	.word	0x300ca638
3000f618:	300ca63c 	.word	0x300ca63c

3000f61c <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
3000f61c:	e24dd010 	sub	sp, sp, #16
3000f620:	e58d0004 	str	r0, [sp, #4]
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
3000f624:	e59d3004 	ldr	r3, [sp, #4]
3000f628:	e3530000 	cmp	r3, #0
3000f62c:	ba000002 	blt	3000f63c <get_socket+0x20>
3000f630:	e59d3004 	ldr	r3, [sp, #4]
3000f634:	e3530003 	cmp	r3, #3
3000f638:	da000001 	ble	3000f644 <get_socket+0x28>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
3000f63c:	e3a03000 	mov	r3, #0
3000f640:	ea00000f 	b	3000f684 <get_socket+0x68>
  }

  sock = &sockets[s];
3000f644:	e59d2004 	ldr	r2, [sp, #4]
3000f648:	e1a03002 	mov	r3, r2
3000f64c:	e1a03103 	lsl	r3, r3, #2
3000f650:	e0833002 	add	r3, r3, r2
3000f654:	e1a03103 	lsl	r3, r3, #2
3000f658:	e1a02003 	mov	r2, r3
3000f65c:	e59f302c 	ldr	r3, [pc, #44]	; 3000f690 <get_socket+0x74>
3000f660:	e0823003 	add	r3, r2, r3
3000f664:	e58d300c 	str	r3, [sp, #12]

  if (!sock->conn) {
3000f668:	e59d300c 	ldr	r3, [sp, #12]
3000f66c:	e5933000 	ldr	r3, [r3]
3000f670:	e3530000 	cmp	r3, #0
3000f674:	1a000001 	bne	3000f680 <get_socket+0x64>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
    return NULL;
3000f678:	e3a03000 	mov	r3, #0
3000f67c:	ea000000 	b	3000f684 <get_socket+0x68>
  }

  return sock;
3000f680:	e59d300c 	ldr	r3, [sp, #12]
}
3000f684:	e1a00003 	mov	r0, r3
3000f688:	e28dd010 	add	sp, sp, #16
3000f68c:	e12fff1e 	bx	lr
3000f690:	300ca5e4 	.word	0x300ca5e4

3000f694 <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
3000f694:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f698:	e24dd014 	sub	sp, sp, #20
3000f69c:	e58d0004 	str	r0, [sp, #4]
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
3000f6a0:	e59f31bc 	ldr	r3, [pc, #444]	; 3000f864 <alloc_socket+0x1d0>
3000f6a4:	e5933000 	ldr	r3, [r3]
3000f6a8:	e1a00003 	mov	r0, r3
3000f6ac:	eb001e15 	bl	30016f08 <sys_sem_wait>

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
3000f6b0:	e3a03000 	mov	r3, #0
3000f6b4:	e58d300c 	str	r3, [sp, #12]
3000f6b8:	ea00005d 	b	3000f834 <alloc_socket+0x1a0>
    if (!sockets[i].conn) {
3000f6bc:	e59d200c 	ldr	r2, [sp, #12]
3000f6c0:	e59f11a0 	ldr	r1, [pc, #416]	; 3000f868 <alloc_socket+0x1d4>
3000f6c4:	e1a03002 	mov	r3, r2
3000f6c8:	e1a03103 	lsl	r3, r3, #2
3000f6cc:	e0833002 	add	r3, r3, r2
3000f6d0:	e1a03103 	lsl	r3, r3, #2
3000f6d4:	e0833001 	add	r3, r3, r1
3000f6d8:	e5933000 	ldr	r3, [r3]
3000f6dc:	e3530000 	cmp	r3, #0
3000f6e0:	1a000050 	bne	3000f828 <alloc_socket+0x194>
      sockets[i].conn       = newconn;
3000f6e4:	e59d200c 	ldr	r2, [sp, #12]
3000f6e8:	e59f1178 	ldr	r1, [pc, #376]	; 3000f868 <alloc_socket+0x1d4>
3000f6ec:	e1a03002 	mov	r3, r2
3000f6f0:	e1a03103 	lsl	r3, r3, #2
3000f6f4:	e0833002 	add	r3, r3, r2
3000f6f8:	e1a03103 	lsl	r3, r3, #2
3000f6fc:	e0833001 	add	r3, r3, r1
3000f700:	e59d2004 	ldr	r2, [sp, #4]
3000f704:	e5832000 	str	r2, [r3]
      sockets[i].lastdata   = NULL;
3000f708:	e59d200c 	ldr	r2, [sp, #12]
3000f70c:	e59f0154 	ldr	r0, [pc, #340]	; 3000f868 <alloc_socket+0x1d4>
3000f710:	e3a01004 	mov	r1, #4
3000f714:	e1a03002 	mov	r3, r2
3000f718:	e1a03103 	lsl	r3, r3, #2
3000f71c:	e0833002 	add	r3, r3, r2
3000f720:	e1a03103 	lsl	r3, r3, #2
3000f724:	e0833000 	add	r3, r3, r0
3000f728:	e0833001 	add	r3, r3, r1
3000f72c:	e3a02000 	mov	r2, #0
3000f730:	e5832000 	str	r2, [r3]
      sockets[i].lastoffset = 0;
3000f734:	e59d200c 	ldr	r2, [sp, #12]
3000f738:	e59f0128 	ldr	r0, [pc, #296]	; 3000f868 <alloc_socket+0x1d4>
3000f73c:	e3a01008 	mov	r1, #8
3000f740:	e1a03002 	mov	r3, r2
3000f744:	e1a03103 	lsl	r3, r3, #2
3000f748:	e0833002 	add	r3, r3, r2
3000f74c:	e1a03103 	lsl	r3, r3, #2
3000f750:	e0833000 	add	r3, r3, r0
3000f754:	e0833001 	add	r3, r3, r1
3000f758:	e3a02000 	mov	r2, #0
3000f75c:	e1c320b0 	strh	r2, [r3]
      sockets[i].rcvevent   = 0;
3000f760:	e59d200c 	ldr	r2, [sp, #12]
3000f764:	e59f00fc 	ldr	r0, [pc, #252]	; 3000f868 <alloc_socket+0x1d4>
3000f768:	e3a01008 	mov	r1, #8
3000f76c:	e1a03002 	mov	r3, r2
3000f770:	e1a03103 	lsl	r3, r3, #2
3000f774:	e0833002 	add	r3, r3, r2
3000f778:	e1a03103 	lsl	r3, r3, #2
3000f77c:	e0833000 	add	r3, r3, r0
3000f780:	e0833001 	add	r3, r3, r1
3000f784:	e3a02000 	mov	r2, #0
3000f788:	e1c320b2 	strh	r2, [r3, #2]
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
3000f78c:	e59d200c 	ldr	r2, [sp, #12]
3000f790:	e59f00d0 	ldr	r0, [pc, #208]	; 3000f868 <alloc_socket+0x1d4>
3000f794:	e3a01008 	mov	r1, #8
3000f798:	e1a03002 	mov	r3, r2
3000f79c:	e1a03103 	lsl	r3, r3, #2
3000f7a0:	e0833002 	add	r3, r3, r2
3000f7a4:	e1a03103 	lsl	r3, r3, #2
3000f7a8:	e0833000 	add	r3, r3, r0
3000f7ac:	e0833001 	add	r3, r3, r1
3000f7b0:	e3a02001 	mov	r2, #1
3000f7b4:	e1c320b4 	strh	r2, [r3, #4]
      sockets[i].flags      = 0;
3000f7b8:	e59d200c 	ldr	r2, [sp, #12]
3000f7bc:	e59f00a4 	ldr	r0, [pc, #164]	; 3000f868 <alloc_socket+0x1d4>
3000f7c0:	e3a01008 	mov	r1, #8
3000f7c4:	e1a03002 	mov	r3, r2
3000f7c8:	e1a03103 	lsl	r3, r3, #2
3000f7cc:	e0833002 	add	r3, r3, r2
3000f7d0:	e1a03103 	lsl	r3, r3, #2
3000f7d4:	e0833000 	add	r3, r3, r0
3000f7d8:	e0833001 	add	r3, r3, r1
3000f7dc:	e3a02000 	mov	r2, #0
3000f7e0:	e1c320b6 	strh	r2, [r3, #6]
      sockets[i].err        = 0;
3000f7e4:	e59d200c 	ldr	r2, [sp, #12]
3000f7e8:	e59f0078 	ldr	r0, [pc, #120]	; 3000f868 <alloc_socket+0x1d4>
3000f7ec:	e3a01010 	mov	r1, #16
3000f7f0:	e1a03002 	mov	r3, r2
3000f7f4:	e1a03103 	lsl	r3, r3, #2
3000f7f8:	e0833002 	add	r3, r3, r2
3000f7fc:	e1a03103 	lsl	r3, r3, #2
3000f800:	e0833000 	add	r3, r3, r0
3000f804:	e0833001 	add	r3, r3, r1
3000f808:	e3a02000 	mov	r2, #0
3000f80c:	e5832000 	str	r2, [r3]
      sys_sem_signal(socksem);
3000f810:	e59f304c 	ldr	r3, [pc, #76]	; 3000f864 <alloc_socket+0x1d0>
3000f814:	e5933000 	ldr	r3, [r3]
3000f818:	e1a00003 	mov	r0, r3
3000f81c:	ebfff441 	bl	3000c928 <sys_sem_signal>
      return i;
3000f820:	e59d300c 	ldr	r3, [sp, #12]
3000f824:	ea00000a 	b	3000f854 <alloc_socket+0x1c0>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
3000f828:	e59d300c 	ldr	r3, [sp, #12]
3000f82c:	e2833001 	add	r3, r3, #1
3000f830:	e58d300c 	str	r3, [sp, #12]
3000f834:	e59d300c 	ldr	r3, [sp, #12]
3000f838:	e3530003 	cmp	r3, #3
3000f83c:	daffff9e 	ble	3000f6bc <alloc_socket+0x28>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
3000f840:	e59f301c 	ldr	r3, [pc, #28]	; 3000f864 <alloc_socket+0x1d0>
3000f844:	e5933000 	ldr	r3, [r3]
3000f848:	e1a00003 	mov	r0, r3
3000f84c:	ebfff435 	bl	3000c928 <sys_sem_signal>
  return -1;
3000f850:	e3e03000 	mvn	r3, #0
}
3000f854:	e1a00003 	mov	r0, r3
3000f858:	e28dd014 	add	sp, sp, #20
3000f85c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000f860:	e12fff1e 	bx	lr
3000f864:	300ca638 	.word	0x300ca638
3000f868:	300ca5e4 	.word	0x300ca5e4

3000f86c <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
3000f86c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000f870:	e24dd044 	sub	sp, sp, #68	; 0x44
3000f874:	e58d000c 	str	r0, [sp, #12]
3000f878:	e58d1008 	str	r1, [sp, #8]
3000f87c:	e58d2004 	str	r2, [sp, #4]
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
3000f880:	e59d000c 	ldr	r0, [sp, #12]
3000f884:	ebffff64 	bl	3000f61c <get_socket>
3000f888:	e1a03000 	mov	r3, r0
3000f88c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  if (!sock)
3000f890:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3000f894:	e3530000 	cmp	r3, #0
3000f898:	1a000001 	bne	3000f8a4 <lwip_accept+0x38>
    return -1;
3000f89c:	e3e03000 	mvn	r3, #0
3000f8a0:	ea000090 	b	3000fae8 <lwip_accept+0x27c>

  newconn = netconn_accept(sock->conn);
3000f8a4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3000f8a8:	e5933000 	ldr	r3, [r3]
3000f8ac:	e1a00003 	mov	r0, r3
3000f8b0:	ebfff5de 	bl	3000d030 <netconn_accept>
3000f8b4:	e1a03000 	mov	r3, r0
3000f8b8:	e58d3034 	str	r3, [sp, #52]	; 0x34
  if (!newconn) {
3000f8bc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3000f8c0:	e3530000 	cmp	r3, #0
3000f8c4:	1a000015 	bne	3000f920 <lwip_accept+0xb4>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
3000f8c8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3000f8cc:	e5933000 	ldr	r3, [r3]
3000f8d0:	e5d33008 	ldrb	r3, [r3, #8]
3000f8d4:	e1a03c03 	lsl	r3, r3, #24
3000f8d8:	e1a03c43 	asr	r3, r3, #24
3000f8dc:	e2633000 	rsb	r3, r3, #0
3000f8e0:	e353000e 	cmp	r3, #14
3000f8e4:	8a000008 	bhi	3000f90c <lwip_accept+0xa0>
3000f8e8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3000f8ec:	e5933000 	ldr	r3, [r3]
3000f8f0:	e5d33008 	ldrb	r3, [r3, #8]
3000f8f4:	e1a03c03 	lsl	r3, r3, #24
3000f8f8:	e1a03c43 	asr	r3, r3, #24
3000f8fc:	e2632000 	rsb	r2, r3, #0
3000f900:	e59f31f0 	ldr	r3, [pc, #496]	; 3000faf8 <lwip_accept+0x28c>
3000f904:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3000f908:	ea000000 	b	3000f910 <lwip_accept+0xa4>
3000f90c:	e3a03005 	mov	r3, #5
3000f910:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
3000f914:	e5823010 	str	r3, [r2, #16]
    return -1;
3000f918:	e3e03000 	mvn	r3, #0
3000f91c:	ea000071 	b	3000fae8 <lwip_accept+0x27c>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
3000f920:	e28d2028 	add	r2, sp, #40	; 0x28
3000f924:	e28d3026 	add	r3, sp, #38	; 0x26
3000f928:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
3000f92c:	e1a01002 	mov	r1, r2
3000f930:	e1a02003 	mov	r2, r3
3000f934:	e3a03000 	mov	r3, #0
3000f938:	ebfff544 	bl	3000ce50 <netconn_getaddr>
3000f93c:	e1a03000 	mov	r3, r0
3000f940:	e20330ff 	and	r3, r3, #255	; 0xff
3000f944:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
  if (err != ERR_OK) {
3000f948:	e1dd33df 	ldrsb	r3, [sp, #63]	; 0x3f
3000f94c:	e3530000 	cmp	r3, #0
3000f950:	0a00000f 	beq	3000f994 <lwip_accept+0x128>
    netconn_delete(newconn);
3000f954:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
3000f958:	ebfff519 	bl	3000cdc4 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
3000f95c:	e1dd33df 	ldrsb	r3, [sp, #63]	; 0x3f
3000f960:	e2633000 	rsb	r3, r3, #0
3000f964:	e353000e 	cmp	r3, #14
3000f968:	8a000004 	bhi	3000f980 <lwip_accept+0x114>
3000f96c:	e1dd33df 	ldrsb	r3, [sp, #63]	; 0x3f
3000f970:	e2632000 	rsb	r2, r3, #0
3000f974:	e59f317c 	ldr	r3, [pc, #380]	; 3000faf8 <lwip_accept+0x28c>
3000f978:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3000f97c:	ea000000 	b	3000f984 <lwip_accept+0x118>
3000f980:	e3a03005 	mov	r3, #5
3000f984:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
3000f988:	e5823010 	str	r3, [r2, #16]
    return -1;
3000f98c:	e3e03000 	mvn	r3, #0
3000f990:	ea000054 	b	3000fae8 <lwip_accept+0x27c>
  }

  memset(&sin, 0, sizeof(sin));
3000f994:	e28d3014 	add	r3, sp, #20
3000f998:	e1a00003 	mov	r0, r3
3000f99c:	e3a01000 	mov	r1, #0
3000f9a0:	e3a02010 	mov	r2, #16
3000f9a4:	ebfff230 	bl	3000c26c <acoral_memset>
  sin.sin_len = sizeof(sin);
3000f9a8:	e3a03010 	mov	r3, #16
3000f9ac:	e5cd3014 	strb	r3, [sp, #20]
  sin.sin_family = AF_INET;
3000f9b0:	e3a03002 	mov	r3, #2
3000f9b4:	e5cd3015 	strb	r3, [sp, #21]
  sin.sin_port = htons(port);
3000f9b8:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3000f9bc:	e1a00003 	mov	r0, r3
3000f9c0:	eb000f0e 	bl	30013600 <htons>
3000f9c4:	e1a03000 	mov	r3, r0
3000f9c8:	e1cd31b6 	strh	r3, [sp, #22]
  sin.sin_addr.s_addr = naddr.addr;
3000f9cc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000f9d0:	e58d3018 	str	r3, [sp, #24]

  if (*addrlen > sizeof(sin))
3000f9d4:	e59d3004 	ldr	r3, [sp, #4]
3000f9d8:	e5933000 	ldr	r3, [r3]
3000f9dc:	e3530010 	cmp	r3, #16
3000f9e0:	9a000002 	bls	3000f9f0 <lwip_accept+0x184>
    *addrlen = sizeof(sin);
3000f9e4:	e59d3004 	ldr	r3, [sp, #4]
3000f9e8:	e3a02010 	mov	r2, #16
3000f9ec:	e5832000 	str	r2, [r3]

  SMEMCPY(addr, &sin, *addrlen);
3000f9f0:	e59d3004 	ldr	r3, [sp, #4]
3000f9f4:	e5933000 	ldr	r3, [r3]
3000f9f8:	e28d2014 	add	r2, sp, #20
3000f9fc:	e59d0008 	ldr	r0, [sp, #8]
3000fa00:	e1a01002 	mov	r1, r2
3000fa04:	e1a02003 	mov	r2, r3
3000fa08:	ebfff233 	bl	3000c2dc <acoral_memcpy>

  newsock = alloc_socket(newconn);
3000fa0c:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
3000fa10:	ebffff1f 	bl	3000f694 <alloc_socket>
3000fa14:	e1a03000 	mov	r3, r0
3000fa18:	e58d3038 	str	r3, [sp, #56]	; 0x38
  if (newsock == -1) {
3000fa1c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3000fa20:	e3730001 	cmn	r3, #1
3000fa24:	1a000006 	bne	3000fa44 <lwip_accept+0x1d8>
    netconn_delete(newconn);
3000fa28:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
3000fa2c:	ebfff4e4 	bl	3000cdc4 <netconn_delete>
    sock_set_errno(sock, ENFILE);
3000fa30:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3000fa34:	e3a02017 	mov	r2, #23
3000fa38:	e5832010 	str	r2, [r3, #16]
    return -1;
3000fa3c:	e3e03000 	mvn	r3, #0
3000fa40:	ea000028 	b	3000fae8 <lwip_accept+0x27c>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  newconn->callback = event_callback;
3000fa44:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3000fa48:	e59f20ac 	ldr	r2, [pc, #172]	; 3000fafc <lwip_accept+0x290>
3000fa4c:	e5832028 	str	r2, [r3, #40]	; 0x28
  nsock = &sockets[newsock];
3000fa50:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
3000fa54:	e1a03002 	mov	r3, r2
3000fa58:	e1a03103 	lsl	r3, r3, #2
3000fa5c:	e0833002 	add	r3, r3, r2
3000fa60:	e1a03103 	lsl	r3, r3, #2
3000fa64:	e1a02003 	mov	r2, r3
3000fa68:	e59f3090 	ldr	r3, [pc, #144]	; 3000fb00 <lwip_accept+0x294>
3000fa6c:	e0823003 	add	r3, r2, r3
3000fa70:	e58d3030 	str	r3, [sp, #48]	; 0x30
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);

  sys_sem_wait(socksem);
3000fa74:	e59f3088 	ldr	r3, [pc, #136]	; 3000fb04 <lwip_accept+0x298>
3000fa78:	e5933000 	ldr	r3, [r3]
3000fa7c:	e1a00003 	mov	r0, r3
3000fa80:	eb001d20 	bl	30016f08 <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
3000fa84:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3000fa88:	e1d320ba 	ldrh	r2, [r3, #10]
3000fa8c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3000fa90:	e5933018 	ldr	r3, [r3, #24]
3000fa94:	e1a03803 	lsl	r3, r3, #16
3000fa98:	e1a03823 	lsr	r3, r3, #16
3000fa9c:	e1e03003 	mvn	r3, r3
3000faa0:	e1a03803 	lsl	r3, r3, #16
3000faa4:	e1a03823 	lsr	r3, r3, #16
3000faa8:	e0823003 	add	r3, r2, r3
3000faac:	e1a03803 	lsl	r3, r3, #16
3000fab0:	e1a02823 	lsr	r2, r3, #16
3000fab4:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3000fab8:	e1c320ba 	strh	r2, [r3, #10]
  newconn->socket = newsock;
3000fabc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3000fac0:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
3000fac4:	e5832018 	str	r2, [r3, #24]
  sys_sem_signal(socksem);
3000fac8:	e59f3034 	ldr	r3, [pc, #52]	; 3000fb04 <lwip_accept+0x298>
3000facc:	e5933000 	ldr	r3, [r3]
3000fad0:	e1a00003 	mov	r0, r3
3000fad4:	ebfff393 	bl	3000c928 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
3000fad8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3000fadc:	e3a02000 	mov	r2, #0
3000fae0:	e5832010 	str	r2, [r3, #16]
  return newsock;
3000fae4:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
}
3000fae8:	e1a00003 	mov	r0, r3
3000faec:	e28dd044 	add	sp, sp, #68	; 0x44
3000faf0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000faf4:	e12fff1e 	bx	lr
3000faf8:	3004568c 	.word	0x3004568c
3000fafc:	30010ef8 	.word	0x30010ef8
3000fb00:	300ca5e4 	.word	0x300ca5e4
3000fb04:	300ca638 	.word	0x300ca638

3000fb08 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
3000fb08:	e92d4010 	push	{r4, lr}
3000fb0c:	e24dd020 	sub	sp, sp, #32
3000fb10:	e58d000c 	str	r0, [sp, #12]
3000fb14:	e58d1008 	str	r1, [sp, #8]
3000fb18:	e58d2004 	str	r2, [sp, #4]
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
3000fb1c:	e59d000c 	ldr	r0, [sp, #12]
3000fb20:	ebfffebd 	bl	3000f61c <get_socket>
3000fb24:	e1a03000 	mov	r3, r0
3000fb28:	e58d3018 	str	r3, [sp, #24]
  if (!sock)
3000fb2c:	e59d3018 	ldr	r3, [sp, #24]
3000fb30:	e3530000 	cmp	r3, #0
3000fb34:	1a000001 	bne	3000fb40 <lwip_bind+0x38>
    return -1;
3000fb38:	e3e03000 	mvn	r3, #0
3000fb3c:	ea000028 	b	3000fbe4 <lwip_bind+0xdc>

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
3000fb40:	e59d3008 	ldr	r3, [sp, #8]
3000fb44:	e5933004 	ldr	r3, [r3, #4]
3000fb48:	e58d3014 	str	r3, [sp, #20]
  local_port = ((struct sockaddr_in *)name)->sin_port;
3000fb4c:	e59d3008 	ldr	r3, [sp, #8]
3000fb50:	e1d330b2 	ldrh	r3, [r3, #2]
3000fb54:	e1cd31bc 	strh	r3, [sp, #28]

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
3000fb58:	e59d3018 	ldr	r3, [sp, #24]
3000fb5c:	e5934000 	ldr	r4, [r3]
3000fb60:	e1dd31bc 	ldrh	r3, [sp, #28]
3000fb64:	e1a00003 	mov	r0, r3
3000fb68:	eb000eb7 	bl	3001364c <ntohs>
3000fb6c:	e1a03000 	mov	r3, r0
3000fb70:	e28d2014 	add	r2, sp, #20
3000fb74:	e1a00004 	mov	r0, r4
3000fb78:	e1a01002 	mov	r1, r2
3000fb7c:	e1a02003 	mov	r2, r3
3000fb80:	ebfff4ce 	bl	3000cec0 <netconn_bind>
3000fb84:	e1a03000 	mov	r3, r0
3000fb88:	e20330ff 	and	r3, r3, #255	; 0xff
3000fb8c:	e5cd301f 	strb	r3, [sp, #31]

  if (err != ERR_OK) {
3000fb90:	e1dd31df 	ldrsb	r3, [sp, #31]
3000fb94:	e3530000 	cmp	r3, #0
3000fb98:	0a00000d 	beq	3000fbd4 <lwip_bind+0xcc>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
3000fb9c:	e1dd31df 	ldrsb	r3, [sp, #31]
3000fba0:	e2633000 	rsb	r3, r3, #0
3000fba4:	e353000e 	cmp	r3, #14
3000fba8:	8a000004 	bhi	3000fbc0 <lwip_bind+0xb8>
3000fbac:	e1dd31df 	ldrsb	r3, [sp, #31]
3000fbb0:	e2632000 	rsb	r2, r3, #0
3000fbb4:	e59f3038 	ldr	r3, [pc, #56]	; 3000fbf4 <lwip_bind+0xec>
3000fbb8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3000fbbc:	ea000000 	b	3000fbc4 <lwip_bind+0xbc>
3000fbc0:	e3a03005 	mov	r3, #5
3000fbc4:	e59d2018 	ldr	r2, [sp, #24]
3000fbc8:	e5823010 	str	r3, [r2, #16]
    return -1;
3000fbcc:	e3e03000 	mvn	r3, #0
3000fbd0:	ea000003 	b	3000fbe4 <lwip_bind+0xdc>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
3000fbd4:	e59d3018 	ldr	r3, [sp, #24]
3000fbd8:	e3a02000 	mov	r2, #0
3000fbdc:	e5832010 	str	r2, [r3, #16]
  return 0;
3000fbe0:	e3a03000 	mov	r3, #0
}
3000fbe4:	e1a00003 	mov	r0, r3
3000fbe8:	e28dd020 	add	sp, sp, #32
3000fbec:	e8bd4010 	pop	{r4, lr}
3000fbf0:	e12fff1e 	bx	lr
3000fbf4:	3004568c 	.word	0x3004568c

3000fbf8 <lwip_close>:

int
lwip_close(int s)
{
3000fbf8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000fbfc:	e24dd014 	sub	sp, sp, #20
3000fc00:	e58d0004 	str	r0, [sp, #4]
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
3000fc04:	e59d0004 	ldr	r0, [sp, #4]
3000fc08:	ebfffe83 	bl	3000f61c <get_socket>
3000fc0c:	e1a03000 	mov	r3, r0
3000fc10:	e58d300c 	str	r3, [sp, #12]
  if (!sock) {
3000fc14:	e59d300c 	ldr	r3, [sp, #12]
3000fc18:	e3530000 	cmp	r3, #0
3000fc1c:	1a000001 	bne	3000fc28 <lwip_close+0x30>
    return -1;
3000fc20:	e3e03000 	mvn	r3, #0
3000fc24:	ea000020 	b	3000fcac <lwip_close+0xb4>
  }

  netconn_delete(sock->conn);
3000fc28:	e59d300c 	ldr	r3, [sp, #12]
3000fc2c:	e5933000 	ldr	r3, [r3]
3000fc30:	e1a00003 	mov	r0, r3
3000fc34:	ebfff462 	bl	3000cdc4 <netconn_delete>

  sys_sem_wait(socksem);
3000fc38:	e59f307c 	ldr	r3, [pc, #124]	; 3000fcbc <lwip_close+0xc4>
3000fc3c:	e5933000 	ldr	r3, [r3]
3000fc40:	e1a00003 	mov	r0, r3
3000fc44:	eb001caf 	bl	30016f08 <sys_sem_wait>
  if (sock->lastdata) {
3000fc48:	e59d300c 	ldr	r3, [sp, #12]
3000fc4c:	e5933004 	ldr	r3, [r3, #4]
3000fc50:	e3530000 	cmp	r3, #0
3000fc54:	0a000003 	beq	3000fc68 <lwip_close+0x70>
    netbuf_delete(sock->lastdata);
3000fc58:	e59d300c 	ldr	r3, [sp, #12]
3000fc5c:	e5933004 	ldr	r3, [r3, #4]
3000fc60:	e1a00003 	mov	r0, r3
3000fc64:	ebfffd80 	bl	3000f26c <netbuf_delete>
  }
  sock->lastdata   = NULL;
3000fc68:	e59d300c 	ldr	r3, [sp, #12]
3000fc6c:	e3a02000 	mov	r2, #0
3000fc70:	e5832004 	str	r2, [r3, #4]
  sock->lastoffset = 0;
3000fc74:	e59d300c 	ldr	r3, [sp, #12]
3000fc78:	e3a02000 	mov	r2, #0
3000fc7c:	e1c320b8 	strh	r2, [r3, #8]
  sock->conn       = NULL;
3000fc80:	e59d300c 	ldr	r3, [sp, #12]
3000fc84:	e3a02000 	mov	r2, #0
3000fc88:	e5832000 	str	r2, [r3]
  sock_set_errno(sock, 0);
3000fc8c:	e59d300c 	ldr	r3, [sp, #12]
3000fc90:	e3a02000 	mov	r2, #0
3000fc94:	e5832010 	str	r2, [r3, #16]
  sys_sem_signal(socksem);
3000fc98:	e59f301c 	ldr	r3, [pc, #28]	; 3000fcbc <lwip_close+0xc4>
3000fc9c:	e5933000 	ldr	r3, [r3]
3000fca0:	e1a00003 	mov	r0, r3
3000fca4:	ebfff31f 	bl	3000c928 <sys_sem_signal>
  return 0;
3000fca8:	e3a03000 	mov	r3, #0
}
3000fcac:	e1a00003 	mov	r0, r3
3000fcb0:	e28dd014 	add	sp, sp, #20
3000fcb4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000fcb8:	e12fff1e 	bx	lr
3000fcbc:	300ca638 	.word	0x300ca638

3000fcc0 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
3000fcc0:	e92d4010 	push	{r4, lr}
3000fcc4:	e24dd020 	sub	sp, sp, #32
3000fcc8:	e58d000c 	str	r0, [sp, #12]
3000fccc:	e58d1008 	str	r1, [sp, #8]
3000fcd0:	e58d2004 	str	r2, [sp, #4]
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
3000fcd4:	e59d000c 	ldr	r0, [sp, #12]
3000fcd8:	ebfffe4f 	bl	3000f61c <get_socket>
3000fcdc:	e1a03000 	mov	r3, r0
3000fce0:	e58d3018 	str	r3, [sp, #24]
  if (!sock)
3000fce4:	e59d3018 	ldr	r3, [sp, #24]
3000fce8:	e3530000 	cmp	r3, #0
3000fcec:	1a000001 	bne	3000fcf8 <lwip_connect+0x38>
    return -1;
3000fcf0:	e3e03000 	mvn	r3, #0
3000fcf4:	ea000034 	b	3000fdcc <lwip_connect+0x10c>

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  if (((struct sockaddr_in *)name)->sin_family == AF_UNSPEC) {
3000fcf8:	e59d3008 	ldr	r3, [sp, #8]
3000fcfc:	e5d33001 	ldrb	r3, [r3, #1]
3000fd00:	e3530000 	cmp	r3, #0
3000fd04:	1a000007 	bne	3000fd28 <lwip_connect+0x68>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
3000fd08:	e59d3018 	ldr	r3, [sp, #24]
3000fd0c:	e5933000 	ldr	r3, [r3]
3000fd10:	e1a00003 	mov	r0, r3
3000fd14:	ebfff49d 	bl	3000cf90 <netconn_disconnect>
3000fd18:	e1a03000 	mov	r3, r0
3000fd1c:	e20330ff 	and	r3, r3, #255	; 0xff
3000fd20:	e5cd301d 	strb	r3, [sp, #29]
3000fd24:	ea000013 	b	3000fd78 <lwip_connect+0xb8>
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
3000fd28:	e59d3008 	ldr	r3, [sp, #8]
3000fd2c:	e5933004 	ldr	r3, [r3, #4]
3000fd30:	e58d3014 	str	r3, [sp, #20]
    remote_port = ((struct sockaddr_in *)name)->sin_port;
3000fd34:	e59d3008 	ldr	r3, [sp, #8]
3000fd38:	e1d330b2 	ldrh	r3, [r3, #2]
3000fd3c:	e1cd31be 	strh	r3, [sp, #30]

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
3000fd40:	e59d3018 	ldr	r3, [sp, #24]
3000fd44:	e5934000 	ldr	r4, [r3]
3000fd48:	e1dd31be 	ldrh	r3, [sp, #30]
3000fd4c:	e1a00003 	mov	r0, r3
3000fd50:	eb000e3d 	bl	3001364c <ntohs>
3000fd54:	e1a03000 	mov	r3, r0
3000fd58:	e28d2014 	add	r2, sp, #20
3000fd5c:	e1a00004 	mov	r0, r4
3000fd60:	e1a01002 	mov	r1, r2
3000fd64:	e1a02003 	mov	r2, r3
3000fd68:	ebfff46e 	bl	3000cf28 <netconn_connect>
3000fd6c:	e1a03000 	mov	r3, r0
3000fd70:	e20330ff 	and	r3, r3, #255	; 0xff
3000fd74:	e5cd301d 	strb	r3, [sp, #29]
  }

  if (err != ERR_OK) {
3000fd78:	e1dd31dd 	ldrsb	r3, [sp, #29]
3000fd7c:	e3530000 	cmp	r3, #0
3000fd80:	0a00000d 	beq	3000fdbc <lwip_connect+0xfc>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
3000fd84:	e1dd31dd 	ldrsb	r3, [sp, #29]
3000fd88:	e2633000 	rsb	r3, r3, #0
3000fd8c:	e353000e 	cmp	r3, #14
3000fd90:	8a000004 	bhi	3000fda8 <lwip_connect+0xe8>
3000fd94:	e1dd31dd 	ldrsb	r3, [sp, #29]
3000fd98:	e2632000 	rsb	r2, r3, #0
3000fd9c:	e59f3038 	ldr	r3, [pc, #56]	; 3000fddc <lwip_connect+0x11c>
3000fda0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3000fda4:	ea000000 	b	3000fdac <lwip_connect+0xec>
3000fda8:	e3a03005 	mov	r3, #5
3000fdac:	e59d2018 	ldr	r2, [sp, #24]
3000fdb0:	e5823010 	str	r3, [r2, #16]
    return -1;
3000fdb4:	e3e03000 	mvn	r3, #0
3000fdb8:	ea000003 	b	3000fdcc <lwip_connect+0x10c>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
3000fdbc:	e59d3018 	ldr	r3, [sp, #24]
3000fdc0:	e3a02000 	mov	r2, #0
3000fdc4:	e5832010 	str	r2, [r3, #16]
  return 0;
3000fdc8:	e3a03000 	mov	r3, #0
}
3000fdcc:	e1a00003 	mov	r0, r3
3000fdd0:	e28dd020 	add	sp, sp, #32
3000fdd4:	e8bd4010 	pop	{r4, lr}
3000fdd8:	e12fff1e 	bx	lr
3000fddc:	3004568c 	.word	0x3004568c

3000fde0 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
3000fde0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000fde4:	e24dd014 	sub	sp, sp, #20
3000fde8:	e58d0004 	str	r0, [sp, #4]
3000fdec:	e58d1000 	str	r1, [sp]
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
3000fdf0:	e59d0004 	ldr	r0, [sp, #4]
3000fdf4:	ebfffe08 	bl	3000f61c <get_socket>
3000fdf8:	e1a03000 	mov	r3, r0
3000fdfc:	e58d3008 	str	r3, [sp, #8]
  if (!sock)
3000fe00:	e59d3008 	ldr	r3, [sp, #8]
3000fe04:	e3530000 	cmp	r3, #0
3000fe08:	1a000001 	bne	3000fe14 <lwip_listen+0x34>
    return -1;
3000fe0c:	e3e03000 	mvn	r3, #0
3000fe10:	ea000028 	b	3000feb8 <lwip_listen+0xd8>

  /* limit the "backlog" parameter to fit in an u8_t */
  if (backlog < 0) {
3000fe14:	e59d3000 	ldr	r3, [sp]
3000fe18:	e3530000 	cmp	r3, #0
3000fe1c:	aa000001 	bge	3000fe28 <lwip_listen+0x48>
    backlog = 0;
3000fe20:	e3a03000 	mov	r3, #0
3000fe24:	e58d3000 	str	r3, [sp]
  }
  if (backlog > 0xff) {
3000fe28:	e59d3000 	ldr	r3, [sp]
3000fe2c:	e35300ff 	cmp	r3, #255	; 0xff
3000fe30:	da000001 	ble	3000fe3c <lwip_listen+0x5c>
    backlog = 0xff;
3000fe34:	e3a030ff 	mov	r3, #255	; 0xff
3000fe38:	e58d3000 	str	r3, [sp]
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
3000fe3c:	e59d3008 	ldr	r3, [sp, #8]
3000fe40:	e5932000 	ldr	r2, [r3]
3000fe44:	e59d3000 	ldr	r3, [sp]
3000fe48:	e20330ff 	and	r3, r3, #255	; 0xff
3000fe4c:	e1a00002 	mov	r0, r2
3000fe50:	e1a01003 	mov	r1, r3
3000fe54:	ebfff460 	bl	3000cfdc <netconn_listen_with_backlog>
3000fe58:	e1a03000 	mov	r3, r0
3000fe5c:	e20330ff 	and	r3, r3, #255	; 0xff
3000fe60:	e5cd300f 	strb	r3, [sp, #15]

  if (err != ERR_OK) {
3000fe64:	e1dd30df 	ldrsb	r3, [sp, #15]
3000fe68:	e3530000 	cmp	r3, #0
3000fe6c:	0a00000d 	beq	3000fea8 <lwip_listen+0xc8>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
3000fe70:	e1dd30df 	ldrsb	r3, [sp, #15]
3000fe74:	e2633000 	rsb	r3, r3, #0
3000fe78:	e353000e 	cmp	r3, #14
3000fe7c:	8a000004 	bhi	3000fe94 <lwip_listen+0xb4>
3000fe80:	e1dd30df 	ldrsb	r3, [sp, #15]
3000fe84:	e2632000 	rsb	r2, r3, #0
3000fe88:	e59f3038 	ldr	r3, [pc, #56]	; 3000fec8 <lwip_listen+0xe8>
3000fe8c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3000fe90:	ea000000 	b	3000fe98 <lwip_listen+0xb8>
3000fe94:	e3a03005 	mov	r3, #5
3000fe98:	e59d2008 	ldr	r2, [sp, #8]
3000fe9c:	e5823010 	str	r3, [r2, #16]
    return -1;
3000fea0:	e3e03000 	mvn	r3, #0
3000fea4:	ea000003 	b	3000feb8 <lwip_listen+0xd8>
  }

  sock_set_errno(sock, 0);
3000fea8:	e59d3008 	ldr	r3, [sp, #8]
3000feac:	e3a02000 	mov	r2, #0
3000feb0:	e5832010 	str	r2, [r3, #16]
  return 0;
3000feb4:	e3a03000 	mov	r3, #0
}
3000feb8:	e1a00003 	mov	r0, r3
3000febc:	e28dd014 	add	sp, sp, #20
3000fec0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3000fec4:	e12fff1e 	bx	lr
3000fec8:	3004568c 	.word	0x3004568c

3000fecc <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
3000fecc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3000fed0:	e24dd044 	sub	sp, sp, #68	; 0x44
3000fed4:	e58d000c 	str	r0, [sp, #12]
3000fed8:	e58d1008 	str	r1, [sp, #8]
3000fedc:	e58d2004 	str	r2, [sp, #4]
3000fee0:	e58d3000 	str	r3, [sp]
  struct lwip_socket *sock;
  struct netbuf      *buf;
  u16_t               buflen, copylen, off = 0;
3000fee4:	e3a03000 	mov	r3, #0
3000fee8:	e1cd33b6 	strh	r3, [sp, #54]	; 0x36
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;
3000feec:	e3a03000 	mov	r3, #0
3000fef0:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
3000fef4:	e59d000c 	ldr	r0, [sp, #12]
3000fef8:	ebfffdc7 	bl	3000f61c <get_socket>
3000fefc:	e1a03000 	mov	r3, r0
3000ff00:	e58d3028 	str	r3, [sp, #40]	; 0x28
  if (!sock)
3000ff04:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000ff08:	e3530000 	cmp	r3, #0
3000ff0c:	1a000001 	bne	3000ff18 <lwip_recvfrom+0x4c>
    return -1;
3000ff10:	e3e03000 	mvn	r3, #0
3000ff14:	ea0000fa 	b	30010304 <lwip_recvfrom+0x438>

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
3000ff18:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000ff1c:	e5933004 	ldr	r3, [r3, #4]
3000ff20:	e3530000 	cmp	r3, #0
3000ff24:	0a000003 	beq	3000ff38 <lwip_recvfrom+0x6c>
      buf = sock->lastdata;
3000ff28:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000ff2c:	e5933004 	ldr	r3, [r3, #4]
3000ff30:	e58d302c 	str	r3, [sp, #44]	; 0x2c
3000ff34:	ea00003f 	b	30010038 <lwip_recvfrom+0x16c>
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
3000ff38:	e59d3000 	ldr	r3, [sp]
3000ff3c:	e2033008 	and	r3, r3, #8
3000ff40:	e3530000 	cmp	r3, #0
3000ff44:	1a000004 	bne	3000ff5c <lwip_recvfrom+0x90>
3000ff48:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000ff4c:	e1d330be 	ldrh	r3, [r3, #14]
3000ff50:	e2033b02 	and	r3, r3, #2048	; 0x800
3000ff54:	e3530000 	cmp	r3, #0
3000ff58:	0a000008 	beq	3000ff80 <lwip_recvfrom+0xb4>
3000ff5c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000ff60:	e1d330ba 	ldrh	r3, [r3, #10]
3000ff64:	e3530000 	cmp	r3, #0
3000ff68:	1a000004 	bne	3000ff80 <lwip_recvfrom+0xb4>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
3000ff6c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000ff70:	e3a0200b 	mov	r2, #11
3000ff74:	e5832010 	str	r2, [r3, #16]
        return -1;
3000ff78:	e3e03000 	mvn	r3, #0
3000ff7c:	ea0000e0 	b	30010304 <lwip_recvfrom+0x438>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
3000ff80:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000ff84:	e5933000 	ldr	r3, [r3]
3000ff88:	e1a00003 	mov	r0, r3
3000ff8c:	ebfff441 	bl	3000d098 <netconn_recv>
3000ff90:	e1a03000 	mov	r3, r0
3000ff94:	e58d302c 	str	r3, [sp, #44]	; 0x2c
3000ff98:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000ff9c:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
3000ffa0:	e5832004 	str	r2, [r3, #4]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
3000ffa4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3000ffa8:	e3530000 	cmp	r3, #0
3000ffac:	1a000021 	bne	30010038 <lwip_recvfrom+0x16c>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
3000ffb0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000ffb4:	e5933000 	ldr	r3, [r3]
3000ffb8:	e5933004 	ldr	r3, [r3, #4]
3000ffbc:	e3530000 	cmp	r3, #0
3000ffc0:	0a000004 	beq	3000ffd8 <lwip_recvfrom+0x10c>
3000ffc4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000ffc8:	e5933000 	ldr	r3, [r3]
3000ffcc:	e5d33008 	ldrb	r3, [r3, #8]
3000ffd0:	e3530000 	cmp	r3, #0
3000ffd4:	0a000012 	beq	30010024 <lwip_recvfrom+0x158>
3000ffd8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000ffdc:	e5933000 	ldr	r3, [r3]
3000ffe0:	e5d33008 	ldrb	r3, [r3, #8]
3000ffe4:	e1a03c03 	lsl	r3, r3, #24
3000ffe8:	e1a03c43 	asr	r3, r3, #24
3000ffec:	e2633000 	rsb	r3, r3, #0
3000fff0:	e353000e 	cmp	r3, #14
3000fff4:	8a000008 	bhi	3001001c <lwip_recvfrom+0x150>
3000fff8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3000fffc:	e5933000 	ldr	r3, [r3]
30010000:	e5d33008 	ldrb	r3, [r3, #8]
30010004:	e1a03c03 	lsl	r3, r3, #24
30010008:	e1a03c43 	asr	r3, r3, #24
3001000c:	e2632000 	rsb	r2, r3, #0
30010010:	e59f32fc 	ldr	r3, [pc, #764]	; 30010314 <lwip_recvfrom+0x448>
30010014:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30010018:	ea000000 	b	30010020 <lwip_recvfrom+0x154>
3001001c:	e3a03005 	mov	r3, #5
30010020:	ea000000 	b	30010028 <lwip_recvfrom+0x15c>
30010024:	e3a0306e 	mov	r3, #110	; 0x6e
30010028:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
3001002c:	e5823010 	str	r3, [r2, #16]
        return 0;
30010030:	e3a03000 	mov	r3, #0
30010034:	ea0000b2 	b	30010304 <lwip_recvfrom+0x438>
      }
    }

    buflen = netbuf_len(buf);
30010038:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3001003c:	e5933000 	ldr	r3, [r3]
30010040:	e1d330b8 	ldrh	r3, [r3, #8]
30010044:	e1cd33b2 	strh	r3, [sp, #50]	; 0x32
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
30010048:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001004c:	e1d330b8 	ldrh	r3, [r3, #8]
30010050:	e1dd23b2 	ldrh	r2, [sp, #50]	; 0x32
30010054:	e0633002 	rsb	r3, r3, r2
30010058:	e1cd33b2 	strh	r3, [sp, #50]	; 0x32

    if (len > buflen) {
3001005c:	e1dd23b2 	ldrh	r2, [sp, #50]	; 0x32
30010060:	e59d3004 	ldr	r3, [sp, #4]
30010064:	e1520003 	cmp	r2, r3
30010068:	aa000002 	bge	30010078 <lwip_recvfrom+0x1ac>
      copylen = buflen;
3001006c:	e1dd33b2 	ldrh	r3, [sp, #50]	; 0x32
30010070:	e1cd33b4 	strh	r3, [sp, #52]	; 0x34
30010074:	ea000001 	b	30010080 <lwip_recvfrom+0x1b4>
    } else {
      copylen = len;
30010078:	e59d3004 	ldr	r3, [sp, #4]
3001007c:	e1cd33b4 	strh	r3, [sp, #52]	; 0x34
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
30010080:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30010084:	e5930000 	ldr	r0, [r3]
30010088:	e1dd23b6 	ldrh	r2, [sp, #54]	; 0x36
3001008c:	e59d3008 	ldr	r3, [sp, #8]
30010090:	e0821003 	add	r1, r2, r3
30010094:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010098:	e1d330b8 	ldrh	r3, [r3, #8]
3001009c:	e1dd23b4 	ldrh	r2, [sp, #52]	; 0x34
300100a0:	eb001992 	bl	300166f0 <pbuf_copy_partial>

    off += copylen;
300100a4:	e1dd23b6 	ldrh	r2, [sp, #54]	; 0x36
300100a8:	e1dd33b4 	ldrh	r3, [sp, #52]	; 0x34
300100ac:	e0823003 	add	r3, r2, r3
300100b0:	e1cd33b6 	strh	r3, [sp, #54]	; 0x36

    if (netconn_type(sock->conn) == NETCONN_TCP) {
300100b4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300100b8:	e5933000 	ldr	r3, [r3]
300100bc:	e1a00003 	mov	r0, r3
300100c0:	ebfff35b 	bl	3000ce34 <netconn_type>
300100c4:	e1a03000 	mov	r3, r0
300100c8:	e3530010 	cmp	r3, #16
300100cc:	1a000014 	bne	30010124 <lwip_recvfrom+0x258>
      len -= copylen;
300100d0:	e1dd33b4 	ldrh	r3, [sp, #52]	; 0x34
300100d4:	e59d2004 	ldr	r2, [sp, #4]
300100d8:	e0633002 	rsb	r3, r3, r2
300100dc:	e58d3004 	str	r3, [sp, #4]
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
300100e0:	e59d3004 	ldr	r3, [sp, #4]
300100e4:	e3530000 	cmp	r3, #0
300100e8:	da00000a 	ble	30010118 <lwip_recvfrom+0x24c>
300100ec:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300100f0:	e5933000 	ldr	r3, [r3]
300100f4:	e5d3300d 	ldrb	r3, [r3, #13]
300100f8:	e2033001 	and	r3, r3, #1
300100fc:	e20330ff 	and	r3, r3, #255	; 0xff
30010100:	e3530000 	cmp	r3, #0
30010104:	1a000003 	bne	30010118 <lwip_recvfrom+0x24c>
30010108:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001010c:	e1d330ba 	ldrh	r3, [r3, #10]
30010110:	e3530000 	cmp	r3, #0
30010114:	1a000005 	bne	30010130 <lwip_recvfrom+0x264>
        done = 1;
30010118:	e3a03001 	mov	r3, #1
3001011c:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
30010120:	ea000003 	b	30010134 <lwip_recvfrom+0x268>
      }
    } else {
      done = 1;
30010124:	e3a03001 	mov	r3, #1
30010128:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
3001012c:	ea000000 	b	30010134 <lwip_recvfrom+0x268>
    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      len -= copylen;
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
        done = 1;
30010130:	e1a00000 	nop			; (mov r0, r0)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
30010134:	e59d3000 	ldr	r3, [sp]
30010138:	e2033001 	and	r3, r3, #1
3001013c:	e3530000 	cmp	r3, #0
30010140:	1a00001f 	bne	300101c4 <lwip_recvfrom+0x2f8>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
30010144:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010148:	e5933000 	ldr	r3, [r3]
3001014c:	e5d33000 	ldrb	r3, [r3]
30010150:	e3530010 	cmp	r3, #16
30010154:	1a000011 	bne	300101a0 <lwip_recvfrom+0x2d4>
30010158:	e1dd23b2 	ldrh	r2, [sp, #50]	; 0x32
3001015c:	e1dd33b4 	ldrh	r3, [sp, #52]	; 0x34
30010160:	e0633002 	rsb	r3, r3, r2
30010164:	e3530000 	cmp	r3, #0
30010168:	da00000c 	ble	300101a0 <lwip_recvfrom+0x2d4>
        sock->lastdata = buf;
3001016c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010170:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30010174:	e5832004 	str	r2, [r3, #4]
        sock->lastoffset += copylen;
30010178:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001017c:	e1d320b8 	ldrh	r2, [r3, #8]
30010180:	e1dd33b4 	ldrh	r3, [sp, #52]	; 0x34
30010184:	e0823003 	add	r3, r2, r3
30010188:	e1a03803 	lsl	r3, r3, #16
3001018c:	e1a02823 	lsr	r2, r3, #16
30010190:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010194:	e1c320b8 	strh	r2, [r3, #8]
    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
30010198:	e1a00000 	nop			; (mov r0, r0)
3001019c:	ea00000a 	b	300101cc <lwip_recvfrom+0x300>
        sock->lastdata = buf;
        sock->lastoffset += copylen;
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
      } else {
        sock->lastdata = NULL;
300101a0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300101a4:	e3a02000 	mov	r2, #0
300101a8:	e5832004 	str	r2, [r3, #4]
        sock->lastoffset = 0;
300101ac:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300101b0:	e3a02000 	mov	r2, #0
300101b4:	e1c320b8 	strh	r2, [r3, #8]
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
300101b8:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
300101bc:	ebfffc2a 	bl	3000f26c <netbuf_delete>
300101c0:	ea000001 	b	300101cc <lwip_recvfrom+0x300>
      }
    } else {
      done = 1;
300101c4:	e3a03001 	mov	r3, #1
300101c8:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
    }
  } while (!done);
300101cc:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
300101d0:	e3530000 	cmp	r3, #0
300101d4:	0affff4f 	beq	3000ff18 <lwip_recvfrom+0x4c>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
300101d8:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
300101dc:	e3530000 	cmp	r3, #0
300101e0:	0a000043 	beq	300102f4 <lwip_recvfrom+0x428>
300101e4:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
300101e8:	e3530000 	cmp	r3, #0
300101ec:	0a000040 	beq	300102f4 <lwip_recvfrom+0x428>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
300101f0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300101f4:	e5933000 	ldr	r3, [r3]
300101f8:	e1a00003 	mov	r0, r3
300101fc:	ebfff30c 	bl	3000ce34 <netconn_type>
30010200:	e1a03000 	mov	r3, r0
30010204:	e3530010 	cmp	r3, #16
30010208:	1a00000b 	bne	3001023c <lwip_recvfrom+0x370>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
3001020c:	e28d3014 	add	r3, sp, #20
30010210:	e2833004 	add	r3, r3, #4
30010214:	e58d3038 	str	r3, [sp, #56]	; 0x38
      netconn_getaddr(sock->conn, addr, &port, 0);
30010218:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001021c:	e5932000 	ldr	r2, [r3]
30010220:	e28d3026 	add	r3, sp, #38	; 0x26
30010224:	e1a00002 	mov	r0, r2
30010228:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
3001022c:	e1a02003 	mov	r2, r3
30010230:	e3a03000 	mov	r3, #0
30010234:	ebfff305 	bl	3000ce50 <netconn_getaddr>
30010238:	ea000005 	b	30010254 <lwip_recvfrom+0x388>
    } else {
      addr = netbuf_fromaddr(buf);
3001023c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30010240:	e5933008 	ldr	r3, [r3, #8]
30010244:	e58d3038 	str	r3, [sp, #56]	; 0x38
      port = netbuf_fromport(buf);
30010248:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3001024c:	e1d330bc 	ldrh	r3, [r3, #12]
30010250:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
    }

    memset(&sin, 0, sizeof(sin));
30010254:	e28d3014 	add	r3, sp, #20
30010258:	e1a00003 	mov	r0, r3
3001025c:	e3a01000 	mov	r1, #0
30010260:	e3a02010 	mov	r2, #16
30010264:	ebfff000 	bl	3000c26c <acoral_memset>
    sin.sin_len = sizeof(sin);
30010268:	e3a03010 	mov	r3, #16
3001026c:	e5cd3014 	strb	r3, [sp, #20]
    sin.sin_family = AF_INET;
30010270:	e3a03002 	mov	r3, #2
30010274:	e5cd3015 	strb	r3, [sp, #21]
    sin.sin_port = htons(port);
30010278:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3001027c:	e1a00003 	mov	r0, r3
30010280:	eb000cde 	bl	30013600 <htons>
30010284:	e1a03000 	mov	r3, r0
30010288:	e1cd31b6 	strh	r3, [sp, #22]
    sin.sin_addr.s_addr = addr->addr;
3001028c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30010290:	e5d32000 	ldrb	r2, [r3]
30010294:	e5d31001 	ldrb	r1, [r3, #1]
30010298:	e1a01401 	lsl	r1, r1, #8
3001029c:	e1812002 	orr	r2, r1, r2
300102a0:	e5d31002 	ldrb	r1, [r3, #2]
300102a4:	e1a01801 	lsl	r1, r1, #16
300102a8:	e1812002 	orr	r2, r1, r2
300102ac:	e5d33003 	ldrb	r3, [r3, #3]
300102b0:	e1a03c03 	lsl	r3, r3, #24
300102b4:	e1833002 	orr	r3, r3, r2
300102b8:	e58d3018 	str	r3, [sp, #24]

    if (*fromlen > sizeof(sin))
300102bc:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
300102c0:	e5933000 	ldr	r3, [r3]
300102c4:	e3530010 	cmp	r3, #16
300102c8:	9a000002 	bls	300102d8 <lwip_recvfrom+0x40c>
      *fromlen = sizeof(sin);
300102cc:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
300102d0:	e3a02010 	mov	r2, #16
300102d4:	e5832000 	str	r2, [r3]

    SMEMCPY(from, &sin, *fromlen);
300102d8:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
300102dc:	e5933000 	ldr	r3, [r3]
300102e0:	e28d2014 	add	r2, sp, #20
300102e4:	e59d0048 	ldr	r0, [sp, #72]	; 0x48
300102e8:	e1a01002 	mov	r1, r2
300102ec:	e1a02003 	mov	r2, r3
300102f0:	ebffeff9 	bl	3000c2dc <acoral_memcpy>
    ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
300102f4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300102f8:	e3a02000 	mov	r2, #0
300102fc:	e5832010 	str	r2, [r3, #16]
  return off;
30010300:	e1dd33b6 	ldrh	r3, [sp, #54]	; 0x36
}
30010304:	e1a00003 	mov	r0, r3
30010308:	e28dd044 	add	sp, sp, #68	; 0x44
3001030c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30010310:	e12fff1e 	bx	lr
30010314:	3004568c 	.word	0x3004568c

30010318 <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
30010318:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001031c:	e24dd01c 	sub	sp, sp, #28
30010320:	e58d0014 	str	r0, [sp, #20]
30010324:	e58d1010 	str	r1, [sp, #16]
30010328:	e58d200c 	str	r2, [sp, #12]
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
3001032c:	e3a03000 	mov	r3, #0
30010330:	e58d3000 	str	r3, [sp]
30010334:	e3a03000 	mov	r3, #0
30010338:	e58d3004 	str	r3, [sp, #4]
3001033c:	e59d0014 	ldr	r0, [sp, #20]
30010340:	e59d1010 	ldr	r1, [sp, #16]
30010344:	e59d200c 	ldr	r2, [sp, #12]
30010348:	e3a03000 	mov	r3, #0
3001034c:	ebfffede 	bl	3000fecc <lwip_recvfrom>
30010350:	e1a03000 	mov	r3, r0
}
30010354:	e1a00003 	mov	r0, r3
30010358:	e28dd01c 	add	sp, sp, #28
3001035c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30010360:	e12fff1e 	bx	lr

30010364 <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
30010364:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30010368:	e24dd01c 	sub	sp, sp, #28
3001036c:	e58d0014 	str	r0, [sp, #20]
30010370:	e58d1010 	str	r1, [sp, #16]
30010374:	e58d200c 	str	r2, [sp, #12]
30010378:	e58d3008 	str	r3, [sp, #8]
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
3001037c:	e3a03000 	mov	r3, #0
30010380:	e58d3000 	str	r3, [sp]
30010384:	e3a03000 	mov	r3, #0
30010388:	e58d3004 	str	r3, [sp, #4]
3001038c:	e59d0014 	ldr	r0, [sp, #20]
30010390:	e59d1010 	ldr	r1, [sp, #16]
30010394:	e59d200c 	ldr	r2, [sp, #12]
30010398:	e59d3008 	ldr	r3, [sp, #8]
3001039c:	ebfffeca 	bl	3000fecc <lwip_recvfrom>
300103a0:	e1a03000 	mov	r3, r0
}
300103a4:	e1a00003 	mov	r0, r3
300103a8:	e28dd01c 	add	sp, sp, #28
300103ac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300103b0:	e12fff1e 	bx	lr

300103b4 <lwip_send>:

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
300103b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300103b8:	e24dd024 	sub	sp, sp, #36	; 0x24
300103bc:	e58d0014 	str	r0, [sp, #20]
300103c0:	e58d1010 	str	r1, [sp, #16]
300103c4:	e58d200c 	str	r2, [sp, #12]
300103c8:	e58d3008 	str	r3, [sp, #8]
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
300103cc:	e59d0014 	ldr	r0, [sp, #20]
300103d0:	ebfffc91 	bl	3000f61c <get_socket>
300103d4:	e1a03000 	mov	r3, r0
300103d8:	e58d3018 	str	r3, [sp, #24]
  if (!sock)
300103dc:	e59d3018 	ldr	r3, [sp, #24]
300103e0:	e3530000 	cmp	r3, #0
300103e4:	1a000001 	bne	300103f0 <lwip_send+0x3c>
    return -1;
300103e8:	e3e03000 	mvn	r3, #0
300103ec:	ea000031 	b	300104b8 <lwip_send+0x104>

  if (sock->conn->type!=NETCONN_TCP) {
300103f0:	e59d3018 	ldr	r3, [sp, #24]
300103f4:	e5933000 	ldr	r3, [r3]
300103f8:	e5d33000 	ldrb	r3, [r3]
300103fc:	e3530010 	cmp	r3, #16
30010400:	0a00000a 	beq	30010430 <lwip_send+0x7c>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
30010404:	e3a03000 	mov	r3, #0
30010408:	e58d3000 	str	r3, [sp]
3001040c:	e3a03000 	mov	r3, #0
30010410:	e58d3004 	str	r3, [sp, #4]
30010414:	e59d0014 	ldr	r0, [sp, #20]
30010418:	e59d1010 	ldr	r1, [sp, #16]
3001041c:	e59d200c 	ldr	r2, [sp, #12]
30010420:	e59d3008 	ldr	r3, [sp, #8]
30010424:	eb000028 	bl	300104cc <lwip_sendto>
30010428:	e1a03000 	mov	r3, r0
3001042c:	ea000021 	b	300104b8 <lwip_send+0x104>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
30010430:	e59d3018 	ldr	r3, [sp, #24]
30010434:	e5932000 	ldr	r2, [r3]
30010438:	e59d3008 	ldr	r3, [sp, #8]
3001043c:	e2033010 	and	r3, r3, #16
30010440:	e3530000 	cmp	r3, #0
30010444:	0a000001 	beq	30010450 <lwip_send+0x9c>
30010448:	e3a03003 	mov	r3, #3
3001044c:	ea000000 	b	30010454 <lwip_send+0xa0>
30010450:	e3a03001 	mov	r3, #1
30010454:	e1a00002 	mov	r0, r2
30010458:	e59d1010 	ldr	r1, [sp, #16]
3001045c:	e59d200c 	ldr	r2, [sp, #12]
30010460:	ebfff3f0 	bl	3000d428 <netconn_write>
30010464:	e1a03000 	mov	r3, r0
30010468:	e20330ff 	and	r3, r3, #255	; 0xff
3001046c:	e5cd301f 	strb	r3, [sp, #31]

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
30010470:	e1dd31df 	ldrsb	r3, [sp, #31]
30010474:	e2633000 	rsb	r3, r3, #0
30010478:	e353000e 	cmp	r3, #14
3001047c:	8a000004 	bhi	30010494 <lwip_send+0xe0>
30010480:	e1dd31df 	ldrsb	r3, [sp, #31]
30010484:	e2632000 	rsb	r2, r3, #0
30010488:	e59f3038 	ldr	r3, [pc, #56]	; 300104c8 <lwip_send+0x114>
3001048c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30010490:	ea000000 	b	30010498 <lwip_send+0xe4>
30010494:	e3a03005 	mov	r3, #5
30010498:	e59d2018 	ldr	r2, [sp, #24]
3001049c:	e5823010 	str	r3, [r2, #16]
  return (err==ERR_OK?size:-1);
300104a0:	e1dd31df 	ldrsb	r3, [sp, #31]
300104a4:	e3530000 	cmp	r3, #0
300104a8:	1a000001 	bne	300104b4 <lwip_send+0x100>
300104ac:	e59d300c 	ldr	r3, [sp, #12]
300104b0:	ea000000 	b	300104b8 <lwip_send+0x104>
300104b4:	e3e03000 	mvn	r3, #0
}
300104b8:	e1a00003 	mov	r0, r3
300104bc:	e28dd024 	add	sp, sp, #36	; 0x24
300104c0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300104c4:	e12fff1e 	bx	lr
300104c8:	3004568c 	.word	0x3004568c

300104cc <lwip_sendto>:

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
300104cc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300104d0:	e24dd034 	sub	sp, sp, #52	; 0x34
300104d4:	e58d000c 	str	r0, [sp, #12]
300104d8:	e58d1008 	str	r1, [sp, #8]
300104dc:	e58d2004 	str	r2, [sp, #4]
300104e0:	e58d3000 	str	r3, [sp]
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
300104e4:	e59d000c 	ldr	r0, [sp, #12]
300104e8:	ebfffc4b 	bl	3000f61c <get_socket>
300104ec:	e1a03000 	mov	r3, r0
300104f0:	e58d3024 	str	r3, [sp, #36]	; 0x24
  if (!sock)
300104f4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300104f8:	e3530000 	cmp	r3, #0
300104fc:	1a000001 	bne	30010508 <lwip_sendto+0x3c>
    return -1;
30010500:	e3e03000 	mvn	r3, #0
30010504:	ea00005b 	b	30010678 <lwip_sendto+0x1ac>

  if (sock->conn->type==NETCONN_TCP) {
30010508:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001050c:	e5933000 	ldr	r3, [r3]
30010510:	e5d33000 	ldrb	r3, [r3]
30010514:	e3530010 	cmp	r3, #16
30010518:	1a000006 	bne	30010538 <lwip_sendto+0x6c>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
3001051c:	e59d000c 	ldr	r0, [sp, #12]
30010520:	e59d1008 	ldr	r1, [sp, #8]
30010524:	e59d2004 	ldr	r2, [sp, #4]
30010528:	e59d3000 	ldr	r3, [sp]
3001052c:	ebffffa0 	bl	300103b4 <lwip_send>
30010530:	e1a03000 	mov	r3, r0
30010534:	ea00004f 	b	30010678 <lwip_sendto+0x1ac>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
30010538:	e3a03000 	mov	r3, #0
3001053c:	e58d3014 	str	r3, [sp, #20]
30010540:	e59d3014 	ldr	r3, [sp, #20]
30010544:	e58d3010 	str	r3, [sp, #16]
  if (to) {
30010548:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3001054c:	e3530000 	cmp	r3, #0
30010550:	0a00000d 	beq	3001058c <lwip_sendto+0xc0>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
30010554:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30010558:	e5933004 	ldr	r3, [r3, #4]
3001055c:	e58d3020 	str	r3, [sp, #32]
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
30010560:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30010564:	e1d330b2 	ldrh	r3, [r3, #2]
30010568:	e1a00003 	mov	r0, r3
3001056c:	eb000c36 	bl	3001364c <ntohs>
30010570:	e1a03000 	mov	r3, r0
30010574:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
    buf.addr         = &remote_addr;
30010578:	e28d3020 	add	r3, sp, #32
3001057c:	e58d3018 	str	r3, [sp, #24]
    buf.port         = remote_port;
30010580:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
30010584:	e1cd31bc 	strh	r3, [sp, #28]
30010588:	ea000007 	b	300105ac <lwip_sendto+0xe0>
  } else {
    remote_addr.addr = 0;
3001058c:	e3a03000 	mov	r3, #0
30010590:	e58d3020 	str	r3, [sp, #32]
    remote_port      = 0;
30010594:	e3a03000 	mov	r3, #0
30010598:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
    buf.addr         = NULL;
3001059c:	e3a03000 	mov	r3, #0
300105a0:	e58d3018 	str	r3, [sp, #24]
    buf.port         = 0;
300105a4:	e3a03000 	mov	r3, #0
300105a8:	e1cd31bc 	strh	r3, [sp, #28]
              s, data, size, flags));
  ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
300105ac:	e59d3004 	ldr	r3, [sp, #4]
300105b0:	e1a03803 	lsl	r3, r3, #16
300105b4:	e1a03823 	lsr	r3, r3, #16
300105b8:	e28d2010 	add	r2, sp, #16
300105bc:	e1a00002 	mov	r0, r2
300105c0:	e59d1008 	ldr	r1, [sp, #8]
300105c4:	e1a02003 	mov	r2, r3
300105c8:	ebfffb7d 	bl	3000f3c4 <netbuf_ref>
300105cc:	e1a03000 	mov	r3, r0
300105d0:	e20330ff 	and	r3, r3, #255	; 0xff
300105d4:	e1a03c03 	lsl	r3, r3, #24
300105d8:	e1a03c43 	asr	r3, r3, #24
300105dc:	e58d3028 	str	r3, [sp, #40]	; 0x28
300105e0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300105e4:	e3530000 	cmp	r3, #0
300105e8:	1a00000a 	bne	30010618 <lwip_sendto+0x14c>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
300105ec:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300105f0:	e5932000 	ldr	r2, [r3]
300105f4:	e28d3010 	add	r3, sp, #16
300105f8:	e1a00002 	mov	r0, r2
300105fc:	e1a01003 	mov	r1, r3
30010600:	ebfff372 	bl	3000d3d0 <netconn_send>
30010604:	e1a03000 	mov	r3, r0
30010608:	e20330ff 	and	r3, r3, #255	; 0xff
3001060c:	e1a03c03 	lsl	r3, r3, #24
30010610:	e1a03c43 	asr	r3, r3, #24
30010614:	e58d3028 	str	r3, [sp, #40]	; 0x28
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
30010618:	e59d3010 	ldr	r3, [sp, #16]
3001061c:	e3530000 	cmp	r3, #0
30010620:	0a000002 	beq	30010630 <lwip_sendto+0x164>
    pbuf_free(buf.p);
30010624:	e59d3010 	ldr	r3, [sp, #16]
30010628:	e1a00003 	mov	r0, r3
3001062c:	eb001713 	bl	30016280 <pbuf_free>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
30010630:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010634:	e2633000 	rsb	r3, r3, #0
30010638:	e353000e 	cmp	r3, #14
3001063c:	8a000004 	bhi	30010654 <lwip_sendto+0x188>
30010640:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010644:	e2632000 	rsb	r2, r3, #0
30010648:	e59f3038 	ldr	r3, [pc, #56]	; 30010688 <lwip_sendto+0x1bc>
3001064c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30010650:	ea000000 	b	30010658 <lwip_sendto+0x18c>
30010654:	e3a03005 	mov	r3, #5
30010658:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
3001065c:	e5823010 	str	r3, [r2, #16]
  return (err==ERR_OK?size:-1);
30010660:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010664:	e3530000 	cmp	r3, #0
30010668:	1a000001 	bne	30010674 <lwip_sendto+0x1a8>
3001066c:	e59d3004 	ldr	r3, [sp, #4]
30010670:	ea000000 	b	30010678 <lwip_sendto+0x1ac>
30010674:	e3e03000 	mvn	r3, #0
}
30010678:	e1a00003 	mov	r0, r3
3001067c:	e28dd034 	add	sp, sp, #52	; 0x34
30010680:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30010684:	e12fff1e 	bx	lr
30010688:	3004568c 	.word	0x3004568c

3001068c <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
3001068c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30010690:	e24dd01c 	sub	sp, sp, #28
30010694:	e58d000c 	str	r0, [sp, #12]
30010698:	e58d1008 	str	r1, [sp, #8]
3001069c:	e58d2004 	str	r2, [sp, #4]
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
300106a0:	e59d3008 	ldr	r3, [sp, #8]
300106a4:	e3530002 	cmp	r3, #2
300106a8:	0a00000d 	beq	300106e4 <lwip_socket+0x58>
300106ac:	e3530003 	cmp	r3, #3
300106b0:	0a000002 	beq	300106c0 <lwip_socket+0x34>
300106b4:	e3530001 	cmp	r3, #1
300106b8:	0a000016 	beq	30010718 <lwip_socket+0x8c>
300106bc:	ea00001c 	b	30010734 <lwip_socket+0xa8>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
300106c0:	e59d3004 	ldr	r3, [sp, #4]
300106c4:	e20330ff 	and	r3, r3, #255	; 0xff
300106c8:	e3a00040 	mov	r0, #64	; 0x40
300106cc:	e1a01003 	mov	r1, r3
300106d0:	e59f20c4 	ldr	r2, [pc, #196]	; 3001079c <lwip_socket+0x110>
300106d4:	ebfff18a 	bl	3000cd04 <netconn_new_with_proto_and_callback>
300106d8:	e1a03000 	mov	r3, r0
300106dc:	e58d3010 	str	r3, [sp, #16]
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
300106e0:	ea000015 	b	3001073c <lwip_socket+0xb0>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
300106e4:	e59d3004 	ldr	r3, [sp, #4]
300106e8:	e3530088 	cmp	r3, #136	; 0x88
300106ec:	1a000001 	bne	300106f8 <lwip_socket+0x6c>
300106f0:	e3a03021 	mov	r3, #33	; 0x21
300106f4:	ea000000 	b	300106fc <lwip_socket+0x70>
300106f8:	e3a03020 	mov	r3, #32
300106fc:	e1a00003 	mov	r0, r3
30010700:	e3a01000 	mov	r1, #0
30010704:	e59f2090 	ldr	r2, [pc, #144]	; 3001079c <lwip_socket+0x110>
30010708:	ebfff17d 	bl	3000cd04 <netconn_new_with_proto_and_callback>
3001070c:	e1a03000 	mov	r3, r0
30010710:	e58d3010 	str	r3, [sp, #16]
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
30010714:	ea000008 	b	3001073c <lwip_socket+0xb0>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
30010718:	e3a00010 	mov	r0, #16
3001071c:	e3a01000 	mov	r1, #0
30010720:	e59f2074 	ldr	r2, [pc, #116]	; 3001079c <lwip_socket+0x110>
30010724:	ebfff176 	bl	3000cd04 <netconn_new_with_proto_and_callback>
30010728:	e1a03000 	mov	r3, r0
3001072c:	e58d3010 	str	r3, [sp, #16]
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
30010730:	ea000001 	b	3001073c <lwip_socket+0xb0>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
    return -1;
30010734:	e3e03000 	mvn	r3, #0
30010738:	ea000013 	b	3001078c <lwip_socket+0x100>
  }

  if (!conn) {
3001073c:	e59d3010 	ldr	r3, [sp, #16]
30010740:	e3530000 	cmp	r3, #0
30010744:	1a000001 	bne	30010750 <lwip_socket+0xc4>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
    return -1;
30010748:	e3e03000 	mvn	r3, #0
3001074c:	ea00000e 	b	3001078c <lwip_socket+0x100>
  }

  i = alloc_socket(conn);
30010750:	e59d0010 	ldr	r0, [sp, #16]
30010754:	ebfffbce 	bl	3000f694 <alloc_socket>
30010758:	e1a03000 	mov	r3, r0
3001075c:	e58d3014 	str	r3, [sp, #20]

  if (i == -1) {
30010760:	e59d3014 	ldr	r3, [sp, #20]
30010764:	e3730001 	cmn	r3, #1
30010768:	1a000003 	bne	3001077c <lwip_socket+0xf0>
    netconn_delete(conn);
3001076c:	e59d0010 	ldr	r0, [sp, #16]
30010770:	ebfff193 	bl	3000cdc4 <netconn_delete>
    set_errno(ENFILE);
    return -1;
30010774:	e3e03000 	mvn	r3, #0
30010778:	ea000003 	b	3001078c <lwip_socket+0x100>
  }
  conn->socket = i;
3001077c:	e59d3010 	ldr	r3, [sp, #16]
30010780:	e59d2014 	ldr	r2, [sp, #20]
30010784:	e5832018 	str	r2, [r3, #24]
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  return i;
30010788:	e59d3014 	ldr	r3, [sp, #20]
}
3001078c:	e1a00003 	mov	r0, r3
30010790:	e28dd01c 	add	sp, sp, #28
30010794:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30010798:	e12fff1e 	bx	lr
3001079c:	30010ef8 	.word	0x30010ef8

300107a0 <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
300107a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300107a4:	e24dd014 	sub	sp, sp, #20
300107a8:	e58d000c 	str	r0, [sp, #12]
300107ac:	e58d1008 	str	r1, [sp, #8]
300107b0:	e58d2004 	str	r2, [sp, #4]
  return lwip_send(s, data, size, 0);
300107b4:	e59d000c 	ldr	r0, [sp, #12]
300107b8:	e59d1008 	ldr	r1, [sp, #8]
300107bc:	e59d2004 	ldr	r2, [sp, #4]
300107c0:	e3a03000 	mov	r3, #0
300107c4:	ebfffefa 	bl	300103b4 <lwip_send>
300107c8:	e1a03000 	mov	r3, r0
}
300107cc:	e1a00003 	mov	r0, r3
300107d0:	e28dd014 	add	sp, sp, #20
300107d4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300107d8:	e12fff1e 	bx	lr

300107dc <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
300107dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300107e0:	e24dd02c 	sub	sp, sp, #44	; 0x2c
300107e4:	e58d000c 	str	r0, [sp, #12]
300107e8:	e58d1008 	str	r1, [sp, #8]
300107ec:	e58d2004 	str	r2, [sp, #4]
300107f0:	e58d3000 	str	r3, [sp]
  int i, nready = 0;
300107f4:	e3a03000 	mov	r3, #0
300107f8:	e58d3020 	str	r3, [sp, #32]
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
300107fc:	e28d3018 	add	r3, sp, #24
30010800:	e1a00003 	mov	r0, r3
30010804:	e3a01000 	mov	r1, #0
30010808:	e3a02001 	mov	r2, #1
3001080c:	ebffee96 	bl	3000c26c <acoral_memset>
  FD_ZERO(&lwriteset);
30010810:	e28d3014 	add	r3, sp, #20
30010814:	e1a00003 	mov	r0, r3
30010818:	e3a01000 	mov	r1, #0
3001081c:	e3a02001 	mov	r2, #1
30010820:	ebffee91 	bl	3000c26c <acoral_memset>
  FD_ZERO(&lexceptset);
30010824:	e28d3010 	add	r3, sp, #16
30010828:	e1a00003 	mov	r0, r3
3001082c:	e3a01000 	mov	r1, #0
30010830:	e3a02001 	mov	r2, #1
30010834:	ebffee8c 	bl	3000c26c <acoral_memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
30010838:	e3a03000 	mov	r3, #0
3001083c:	e58d301c 	str	r3, [sp, #28]
30010840:	ea000074 	b	30010a18 <lwip_selscan+0x23c>
    if (FD_ISSET(i, readset)) {
30010844:	e59d301c 	ldr	r3, [sp, #28]
30010848:	e2832007 	add	r2, r3, #7
3001084c:	e3530000 	cmp	r3, #0
30010850:	b1a03002 	movlt	r3, r2
30010854:	e1a031c3 	asr	r3, r3, #3
30010858:	e59d2008 	ldr	r2, [sp, #8]
3001085c:	e7d23003 	ldrb	r3, [r2, r3]
30010860:	e1a02003 	mov	r2, r3
30010864:	e59d301c 	ldr	r3, [sp, #28]
30010868:	e2033007 	and	r3, r3, #7
3001086c:	e1a03352 	asr	r3, r2, r3
30010870:	e2033001 	and	r3, r3, #1
30010874:	e20330ff 	and	r3, r3, #255	; 0xff
30010878:	e3530000 	cmp	r3, #0
3001087c:	0a00002b 	beq	30010930 <lwip_selscan+0x154>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
30010880:	e59d001c 	ldr	r0, [sp, #28]
30010884:	ebfffb64 	bl	3000f61c <get_socket>
30010888:	e1a03000 	mov	r3, r0
3001088c:	e58d3024 	str	r3, [sp, #36]	; 0x24
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
30010890:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30010894:	e3530000 	cmp	r3, #0
30010898:	0a000024 	beq	30010930 <lwip_selscan+0x154>
3001089c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300108a0:	e5933004 	ldr	r3, [r3, #4]
300108a4:	e3530000 	cmp	r3, #0
300108a8:	1a000003 	bne	300108bc <lwip_selscan+0xe0>
300108ac:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300108b0:	e1d330ba 	ldrh	r3, [r3, #10]
300108b4:	e3530000 	cmp	r3, #0
300108b8:	0a00001c 	beq	30010930 <lwip_selscan+0x154>
        FD_SET(i, &lreadset);
300108bc:	e59d301c 	ldr	r3, [sp, #28]
300108c0:	e2832007 	add	r2, r3, #7
300108c4:	e3530000 	cmp	r3, #0
300108c8:	b1a03002 	movlt	r3, r2
300108cc:	e1a031c3 	asr	r3, r3, #3
300108d0:	e1a01003 	mov	r1, r3
300108d4:	e1a02003 	mov	r2, r3
300108d8:	e3e0300f 	mvn	r3, #15
300108dc:	e28d0028 	add	r0, sp, #40	; 0x28
300108e0:	e0802002 	add	r2, r0, r2
300108e4:	e0823003 	add	r3, r2, r3
300108e8:	e5d33000 	ldrb	r3, [r3]
300108ec:	e1a02003 	mov	r2, r3
300108f0:	e59d301c 	ldr	r3, [sp, #28]
300108f4:	e2033007 	and	r3, r3, #7
300108f8:	e3a00001 	mov	r0, #1
300108fc:	e1a03310 	lsl	r3, r0, r3
30010900:	e20330ff 	and	r3, r3, #255	; 0xff
30010904:	e1823003 	orr	r3, r2, r3
30010908:	e20330ff 	and	r3, r3, #255	; 0xff
3001090c:	e20320ff 	and	r2, r3, #255	; 0xff
30010910:	e3e0300f 	mvn	r3, #15
30010914:	e28d0028 	add	r0, sp, #40	; 0x28
30010918:	e0801001 	add	r1, r0, r1
3001091c:	e0813003 	add	r3, r1, r3
30010920:	e5c32000 	strb	r2, [r3]
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
30010924:	e59d3020 	ldr	r3, [sp, #32]
30010928:	e2833001 	add	r3, r3, #1
3001092c:	e58d3020 	str	r3, [sp, #32]
      }
    }
    if (FD_ISSET(i, writeset)) {
30010930:	e59d301c 	ldr	r3, [sp, #28]
30010934:	e2832007 	add	r2, r3, #7
30010938:	e3530000 	cmp	r3, #0
3001093c:	b1a03002 	movlt	r3, r2
30010940:	e1a031c3 	asr	r3, r3, #3
30010944:	e59d2004 	ldr	r2, [sp, #4]
30010948:	e7d23003 	ldrb	r3, [r2, r3]
3001094c:	e1a02003 	mov	r2, r3
30010950:	e59d301c 	ldr	r3, [sp, #28]
30010954:	e2033007 	and	r3, r3, #7
30010958:	e1a03352 	asr	r3, r2, r3
3001095c:	e2033001 	and	r3, r3, #1
30010960:	e20330ff 	and	r3, r3, #255	; 0xff
30010964:	e3530000 	cmp	r3, #0
30010968:	0a000027 	beq	30010a0c <lwip_selscan+0x230>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
3001096c:	e59d001c 	ldr	r0, [sp, #28]
30010970:	ebfffb29 	bl	3000f61c <get_socket>
30010974:	e1a03000 	mov	r3, r0
30010978:	e58d3024 	str	r3, [sp, #36]	; 0x24
      if (p_sock && p_sock->sendevent) {
3001097c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30010980:	e3530000 	cmp	r3, #0
30010984:	0a000020 	beq	30010a0c <lwip_selscan+0x230>
30010988:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001098c:	e1d330bc 	ldrh	r3, [r3, #12]
30010990:	e3530000 	cmp	r3, #0
30010994:	0a00001c 	beq	30010a0c <lwip_selscan+0x230>
        FD_SET(i, &lwriteset);
30010998:	e59d301c 	ldr	r3, [sp, #28]
3001099c:	e2832007 	add	r2, r3, #7
300109a0:	e3530000 	cmp	r3, #0
300109a4:	b1a03002 	movlt	r3, r2
300109a8:	e1a031c3 	asr	r3, r3, #3
300109ac:	e1a01003 	mov	r1, r3
300109b0:	e1a02003 	mov	r2, r3
300109b4:	e3e03013 	mvn	r3, #19
300109b8:	e28d0028 	add	r0, sp, #40	; 0x28
300109bc:	e0802002 	add	r2, r0, r2
300109c0:	e0823003 	add	r3, r2, r3
300109c4:	e5d33000 	ldrb	r3, [r3]
300109c8:	e1a02003 	mov	r2, r3
300109cc:	e59d301c 	ldr	r3, [sp, #28]
300109d0:	e2033007 	and	r3, r3, #7
300109d4:	e3a00001 	mov	r0, #1
300109d8:	e1a03310 	lsl	r3, r0, r3
300109dc:	e20330ff 	and	r3, r3, #255	; 0xff
300109e0:	e1823003 	orr	r3, r2, r3
300109e4:	e20330ff 	and	r3, r3, #255	; 0xff
300109e8:	e20320ff 	and	r2, r3, #255	; 0xff
300109ec:	e3e03013 	mvn	r3, #19
300109f0:	e28d0028 	add	r0, sp, #40	; 0x28
300109f4:	e0801001 	add	r1, r0, r1
300109f8:	e0813003 	add	r3, r1, r3
300109fc:	e5c32000 	strb	r2, [r3]
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
30010a00:	e59d3020 	ldr	r3, [sp, #32]
30010a04:	e2833001 	add	r3, r3, #1
30010a08:	e58d3020 	str	r3, [sp, #32]
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
30010a0c:	e59d301c 	ldr	r3, [sp, #28]
30010a10:	e2833001 	add	r3, r3, #1
30010a14:	e58d301c 	str	r3, [sp, #28]
30010a18:	e59d201c 	ldr	r2, [sp, #28]
30010a1c:	e59d300c 	ldr	r3, [sp, #12]
30010a20:	e1520003 	cmp	r2, r3
30010a24:	baffff86 	blt	30010844 <lwip_selscan+0x68>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
30010a28:	e59d3008 	ldr	r3, [sp, #8]
30010a2c:	e5dd2018 	ldrb	r2, [sp, #24]
30010a30:	e5c32000 	strb	r2, [r3]
  *writeset = lwriteset;
30010a34:	e59d3004 	ldr	r3, [sp, #4]
30010a38:	e5dd2014 	ldrb	r2, [sp, #20]
30010a3c:	e5c32000 	strb	r2, [r3]
  FD_ZERO(exceptset);
30010a40:	e59d0000 	ldr	r0, [sp]
30010a44:	e3a01000 	mov	r1, #0
30010a48:	e3a02001 	mov	r2, #1
30010a4c:	ebffee06 	bl	3000c26c <acoral_memset>
  
  return nready;
30010a50:	e59d3020 	ldr	r3, [sp, #32]
}
30010a54:	e1a00003 	mov	r0, r3
30010a58:	e28dd02c 	add	sp, sp, #44	; 0x2c
30010a5c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30010a60:	e12fff1e 	bx	lr

30010a64 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
30010a64:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30010a68:	e24dd04c 	sub	sp, sp, #76	; 0x4c
30010a6c:	e58d000c 	str	r0, [sp, #12]
30010a70:	e58d1008 	str	r1, [sp, #8]
30010a74:	e58d2004 	str	r2, [sp, #4]
30010a78:	e58d3000 	str	r3, [sp]

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
30010a7c:	e3a03000 	mov	r3, #0
30010a80:	e58d3014 	str	r3, [sp, #20]
  select_cb.readset = readset;
30010a84:	e59d3008 	ldr	r3, [sp, #8]
30010a88:	e58d3018 	str	r3, [sp, #24]
  select_cb.writeset = writeset;
30010a8c:	e59d3004 	ldr	r3, [sp, #4]
30010a90:	e58d301c 	str	r3, [sp, #28]
  select_cb.exceptset = exceptset;
30010a94:	e59d3000 	ldr	r3, [sp]
30010a98:	e58d3020 	str	r3, [sp, #32]
  select_cb.sem_signalled = 0;
30010a9c:	e3a03000 	mov	r3, #0
30010aa0:	e58d3024 	str	r3, [sp, #36]	; 0x24

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
30010aa4:	e59f3440 	ldr	r3, [pc, #1088]	; 30010eec <lwip_select+0x488>
30010aa8:	e5933000 	ldr	r3, [r3]
30010aac:	e1a00003 	mov	r0, r3
30010ab0:	eb001914 	bl	30016f08 <sys_sem_wait>

  if (readset)
30010ab4:	e59d3008 	ldr	r3, [sp, #8]
30010ab8:	e3530000 	cmp	r3, #0
30010abc:	0a000003 	beq	30010ad0 <lwip_select+0x6c>
    lreadset = *readset;
30010ac0:	e59d3008 	ldr	r3, [sp, #8]
30010ac4:	e5d33000 	ldrb	r3, [r3]
30010ac8:	e5cd3034 	strb	r3, [sp, #52]	; 0x34
30010acc:	ea000004 	b	30010ae4 <lwip_select+0x80>
  else
    FD_ZERO(&lreadset);
30010ad0:	e28d3034 	add	r3, sp, #52	; 0x34
30010ad4:	e1a00003 	mov	r0, r3
30010ad8:	e3a01000 	mov	r1, #0
30010adc:	e3a02001 	mov	r2, #1
30010ae0:	ebffede1 	bl	3000c26c <acoral_memset>
  if (writeset)
30010ae4:	e59d3004 	ldr	r3, [sp, #4]
30010ae8:	e3530000 	cmp	r3, #0
30010aec:	0a000003 	beq	30010b00 <lwip_select+0x9c>
    lwriteset = *writeset;
30010af0:	e59d3004 	ldr	r3, [sp, #4]
30010af4:	e5d33000 	ldrb	r3, [r3]
30010af8:	e5cd3030 	strb	r3, [sp, #48]	; 0x30
30010afc:	ea000004 	b	30010b14 <lwip_select+0xb0>
  else
    FD_ZERO(&lwriteset);
30010b00:	e28d3030 	add	r3, sp, #48	; 0x30
30010b04:	e1a00003 	mov	r0, r3
30010b08:	e3a01000 	mov	r1, #0
30010b0c:	e3a02001 	mov	r2, #1
30010b10:	ebffedd5 	bl	3000c26c <acoral_memset>
  if (exceptset)
30010b14:	e59d3000 	ldr	r3, [sp]
30010b18:	e3530000 	cmp	r3, #0
30010b1c:	0a000003 	beq	30010b30 <lwip_select+0xcc>
    lexceptset = *exceptset;
30010b20:	e59d3000 	ldr	r3, [sp]
30010b24:	e5d33000 	ldrb	r3, [r3]
30010b28:	e5cd302c 	strb	r3, [sp, #44]	; 0x2c
30010b2c:	ea000004 	b	30010b44 <lwip_select+0xe0>
  else
    FD_ZERO(&lexceptset);
30010b30:	e28d302c 	add	r3, sp, #44	; 0x2c
30010b34:	e1a00003 	mov	r0, r3
30010b38:	e3a01000 	mov	r1, #0
30010b3c:	e3a02001 	mov	r2, #1
30010b40:	ebffedc9 	bl	3000c26c <acoral_memset>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
30010b44:	e28d1034 	add	r1, sp, #52	; 0x34
30010b48:	e28d2030 	add	r2, sp, #48	; 0x30
30010b4c:	e28d302c 	add	r3, sp, #44	; 0x2c
30010b50:	e59d000c 	ldr	r0, [sp, #12]
30010b54:	ebffff20 	bl	300107dc <lwip_selscan>
30010b58:	e1a03000 	mov	r3, r0
30010b5c:	e58d303c 	str	r3, [sp, #60]	; 0x3c

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
30010b60:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30010b64:	e3530000 	cmp	r3, #0
30010b68:	1a0000c4 	bne	30010e80 <lwip_select+0x41c>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
30010b6c:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
30010b70:	e3530000 	cmp	r3, #0
30010b74:	0a000022 	beq	30010c04 <lwip_select+0x1a0>
30010b78:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
30010b7c:	e5933000 	ldr	r3, [r3]
30010b80:	e3530000 	cmp	r3, #0
30010b84:	1a00001e 	bne	30010c04 <lwip_select+0x1a0>
30010b88:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
30010b8c:	e5933004 	ldr	r3, [r3, #4]
30010b90:	e3530000 	cmp	r3, #0
30010b94:	1a00001a 	bne	30010c04 <lwip_select+0x1a0>
      sys_sem_signal(selectsem);
30010b98:	e59f334c 	ldr	r3, [pc, #844]	; 30010eec <lwip_select+0x488>
30010b9c:	e5933000 	ldr	r3, [r3]
30010ba0:	e1a00003 	mov	r0, r3
30010ba4:	ebffef5f 	bl	3000c928 <sys_sem_signal>
      if (readset)
30010ba8:	e59d3008 	ldr	r3, [sp, #8]
30010bac:	e3530000 	cmp	r3, #0
30010bb0:	0a000003 	beq	30010bc4 <lwip_select+0x160>
        FD_ZERO(readset);
30010bb4:	e59d0008 	ldr	r0, [sp, #8]
30010bb8:	e3a01000 	mov	r1, #0
30010bbc:	e3a02001 	mov	r2, #1
30010bc0:	ebffeda9 	bl	3000c26c <acoral_memset>
      if (writeset)
30010bc4:	e59d3004 	ldr	r3, [sp, #4]
30010bc8:	e3530000 	cmp	r3, #0
30010bcc:	0a000003 	beq	30010be0 <lwip_select+0x17c>
        FD_ZERO(writeset);
30010bd0:	e59d0004 	ldr	r0, [sp, #4]
30010bd4:	e3a01000 	mov	r1, #0
30010bd8:	e3a02001 	mov	r2, #1
30010bdc:	ebffeda2 	bl	3000c26c <acoral_memset>
      if (exceptset)
30010be0:	e59d3000 	ldr	r3, [sp]
30010be4:	e3530000 	cmp	r3, #0
30010be8:	0a000003 	beq	30010bfc <lwip_select+0x198>
        FD_ZERO(exceptset);
30010bec:	e59d0000 	ldr	r0, [sp]
30010bf0:	e3a01000 	mov	r1, #0
30010bf4:	e3a02001 	mov	r2, #1
30010bf8:	ebffed9b 	bl	3000c26c <acoral_memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  
      return 0;
30010bfc:	e3a03000 	mov	r3, #0
30010c00:	ea0000b5 	b	30010edc <lwip_select+0x478>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
30010c04:	e3a00000 	mov	r0, #0
30010c08:	ebffef31 	bl	3000c8d4 <sys_sem_new>
30010c0c:	e1a03000 	mov	r3, r0
30010c10:	e58d3028 	str	r3, [sp, #40]	; 0x28
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
30010c14:	e59f32d4 	ldr	r3, [pc, #724]	; 30010ef0 <lwip_select+0x48c>
30010c18:	e5933000 	ldr	r3, [r3]
30010c1c:	e58d3014 	str	r3, [sp, #20]
    select_cb_list = &select_cb;
30010c20:	e59f32c8 	ldr	r3, [pc, #712]	; 30010ef0 <lwip_select+0x48c>
30010c24:	e28d2014 	add	r2, sp, #20
30010c28:	e5832000 	str	r2, [r3]
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
30010c2c:	e59f32b8 	ldr	r3, [pc, #696]	; 30010eec <lwip_select+0x488>
30010c30:	e5933000 	ldr	r3, [r3]
30010c34:	e1a00003 	mov	r0, r3
30010c38:	ebffef3a 	bl	3000c928 <sys_sem_signal>
    
    /* Now just wait to be woken */
    if (timeout == 0)
30010c3c:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
30010c40:	e3530000 	cmp	r3, #0
30010c44:	1a000002 	bne	30010c54 <lwip_select+0x1f0>
      /* Wait forever */
      msectimeout = 0;
30010c48:	e3a03000 	mov	r3, #0
30010c4c:	e58d3040 	str	r3, [sp, #64]	; 0x40
30010c50:	ea000017 	b	30010cb4 <lwip_select+0x250>
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
30010c54:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
30010c58:	e5932000 	ldr	r2, [r3]
30010c5c:	e1a03002 	mov	r3, r2
30010c60:	e1a03283 	lsl	r3, r3, #5
30010c64:	e0623003 	rsb	r3, r2, r3
30010c68:	e1a03103 	lsl	r3, r3, #2
30010c6c:	e0833002 	add	r3, r3, r2
30010c70:	e1a03183 	lsl	r3, r3, #3
30010c74:	e1a02003 	mov	r2, r3
30010c78:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
30010c7c:	e5933004 	ldr	r3, [r3, #4]
30010c80:	e2833f7d 	add	r3, r3, #500	; 0x1f4
30010c84:	e59f1268 	ldr	r1, [pc, #616]	; 30010ef4 <lwip_select+0x490>
30010c88:	e0c10193 	smull	r0, r1, r3, r1
30010c8c:	e1a01341 	asr	r1, r1, #6
30010c90:	e1a03fc3 	asr	r3, r3, #31
30010c94:	e0633001 	rsb	r3, r3, r1
30010c98:	e0823003 	add	r3, r2, r3
30010c9c:	e58d3040 	str	r3, [sp, #64]	; 0x40
      if(msectimeout == 0)
30010ca0:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
30010ca4:	e3530000 	cmp	r3, #0
30010ca8:	1a000001 	bne	30010cb4 <lwip_select+0x250>
        msectimeout = 1;
30010cac:	e3a03001 	mov	r3, #1
30010cb0:	e58d3040 	str	r3, [sp, #64]	; 0x40
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
30010cb4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010cb8:	e1a00003 	mov	r0, r3
30010cbc:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
30010cc0:	eb0019b2 	bl	30017390 <sys_sem_wait_timeout>
30010cc4:	e1a03000 	mov	r3, r0
30010cc8:	e58d3038 	str	r3, [sp, #56]	; 0x38
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
30010ccc:	e59f3218 	ldr	r3, [pc, #536]	; 30010eec <lwip_select+0x488>
30010cd0:	e5933000 	ldr	r3, [r3]
30010cd4:	e1a00003 	mov	r0, r3
30010cd8:	eb00188a 	bl	30016f08 <sys_sem_wait>
    if (select_cb_list == &select_cb)
30010cdc:	e59f320c 	ldr	r3, [pc, #524]	; 30010ef0 <lwip_select+0x48c>
30010ce0:	e5933000 	ldr	r3, [r3]
30010ce4:	e28d2014 	add	r2, sp, #20
30010ce8:	e1520003 	cmp	r2, r3
30010cec:	1a000003 	bne	30010d00 <lwip_select+0x29c>
      select_cb_list = select_cb.next;
30010cf0:	e59d2014 	ldr	r2, [sp, #20]
30010cf4:	e59f31f4 	ldr	r3, [pc, #500]	; 30010ef0 <lwip_select+0x48c>
30010cf8:	e5832000 	str	r2, [r3]
30010cfc:	ea000012 	b	30010d4c <lwip_select+0x2e8>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
30010d00:	e59f31e8 	ldr	r3, [pc, #488]	; 30010ef0 <lwip_select+0x48c>
30010d04:	e5933000 	ldr	r3, [r3]
30010d08:	e58d3044 	str	r3, [sp, #68]	; 0x44
30010d0c:	ea00000b 	b	30010d40 <lwip_select+0x2dc>
        if (p_selcb->next == &select_cb) {
30010d10:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30010d14:	e5933000 	ldr	r3, [r3]
30010d18:	e28d2014 	add	r2, sp, #20
30010d1c:	e1520003 	cmp	r2, r3
30010d20:	1a000003 	bne	30010d34 <lwip_select+0x2d0>
          p_selcb->next = select_cb.next;
30010d24:	e59d2014 	ldr	r2, [sp, #20]
30010d28:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30010d2c:	e5832000 	str	r2, [r3]
          break;
30010d30:	ea000005 	b	30010d4c <lwip_select+0x2e8>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
30010d34:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30010d38:	e5933000 	ldr	r3, [r3]
30010d3c:	e58d3044 	str	r3, [sp, #68]	; 0x44
30010d40:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30010d44:	e3530000 	cmp	r3, #0
30010d48:	1afffff0 	bne	30010d10 <lwip_select+0x2ac>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
30010d4c:	e59f3198 	ldr	r3, [pc, #408]	; 30010eec <lwip_select+0x488>
30010d50:	e5933000 	ldr	r3, [r3]
30010d54:	e1a00003 	mov	r0, r3
30010d58:	ebffeef2 	bl	3000c928 <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
30010d5c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30010d60:	e1a00003 	mov	r0, r3
30010d64:	ebffeee6 	bl	3000c904 <sys_sem_free>
    if (i == 0)  {
30010d68:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30010d6c:	e3530000 	cmp	r3, #0
30010d70:	1a000016 	bne	30010dd0 <lwip_select+0x36c>
      /* Timeout */
      if (readset)
30010d74:	e59d3008 	ldr	r3, [sp, #8]
30010d78:	e3530000 	cmp	r3, #0
30010d7c:	0a000003 	beq	30010d90 <lwip_select+0x32c>
        FD_ZERO(readset);
30010d80:	e59d0008 	ldr	r0, [sp, #8]
30010d84:	e3a01000 	mov	r1, #0
30010d88:	e3a02001 	mov	r2, #1
30010d8c:	ebffed36 	bl	3000c26c <acoral_memset>
      if (writeset)
30010d90:	e59d3004 	ldr	r3, [sp, #4]
30010d94:	e3530000 	cmp	r3, #0
30010d98:	0a000003 	beq	30010dac <lwip_select+0x348>
        FD_ZERO(writeset);
30010d9c:	e59d0004 	ldr	r0, [sp, #4]
30010da0:	e3a01000 	mov	r1, #0
30010da4:	e3a02001 	mov	r2, #1
30010da8:	ebffed2f 	bl	3000c26c <acoral_memset>
      if (exceptset)
30010dac:	e59d3000 	ldr	r3, [sp]
30010db0:	e3530000 	cmp	r3, #0
30010db4:	0a000003 	beq	30010dc8 <lwip_select+0x364>
        FD_ZERO(exceptset);
30010db8:	e59d0000 	ldr	r0, [sp]
30010dbc:	e3a01000 	mov	r1, #0
30010dc0:	e3a02001 	mov	r2, #1
30010dc4:	ebffed28 	bl	3000c26c <acoral_memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  
      return 0;
30010dc8:	e3a03000 	mov	r3, #0
30010dcc:	ea000042 	b	30010edc <lwip_select+0x478>
    }
    
    if (readset)
30010dd0:	e59d3008 	ldr	r3, [sp, #8]
30010dd4:	e3530000 	cmp	r3, #0
30010dd8:	0a000003 	beq	30010dec <lwip_select+0x388>
      lreadset = *readset;
30010ddc:	e59d3008 	ldr	r3, [sp, #8]
30010de0:	e5d33000 	ldrb	r3, [r3]
30010de4:	e5cd3034 	strb	r3, [sp, #52]	; 0x34
30010de8:	ea000004 	b	30010e00 <lwip_select+0x39c>
    else
      FD_ZERO(&lreadset);
30010dec:	e28d3034 	add	r3, sp, #52	; 0x34
30010df0:	e1a00003 	mov	r0, r3
30010df4:	e3a01000 	mov	r1, #0
30010df8:	e3a02001 	mov	r2, #1
30010dfc:	ebffed1a 	bl	3000c26c <acoral_memset>
    if (writeset)
30010e00:	e59d3004 	ldr	r3, [sp, #4]
30010e04:	e3530000 	cmp	r3, #0
30010e08:	0a000003 	beq	30010e1c <lwip_select+0x3b8>
      lwriteset = *writeset;
30010e0c:	e59d3004 	ldr	r3, [sp, #4]
30010e10:	e5d33000 	ldrb	r3, [r3]
30010e14:	e5cd3030 	strb	r3, [sp, #48]	; 0x30
30010e18:	ea000004 	b	30010e30 <lwip_select+0x3cc>
    else
      FD_ZERO(&lwriteset);
30010e1c:	e28d3030 	add	r3, sp, #48	; 0x30
30010e20:	e1a00003 	mov	r0, r3
30010e24:	e3a01000 	mov	r1, #0
30010e28:	e3a02001 	mov	r2, #1
30010e2c:	ebffed0e 	bl	3000c26c <acoral_memset>
    if (exceptset)
30010e30:	e59d3000 	ldr	r3, [sp]
30010e34:	e3530000 	cmp	r3, #0
30010e38:	0a000003 	beq	30010e4c <lwip_select+0x3e8>
      lexceptset = *exceptset;
30010e3c:	e59d3000 	ldr	r3, [sp]
30010e40:	e5d33000 	ldrb	r3, [r3]
30010e44:	e5cd302c 	strb	r3, [sp, #44]	; 0x2c
30010e48:	ea000004 	b	30010e60 <lwip_select+0x3fc>
    else
      FD_ZERO(&lexceptset);
30010e4c:	e28d302c 	add	r3, sp, #44	; 0x2c
30010e50:	e1a00003 	mov	r0, r3
30010e54:	e3a01000 	mov	r1, #0
30010e58:	e3a02001 	mov	r2, #1
30010e5c:	ebffed02 	bl	3000c26c <acoral_memset>
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
30010e60:	e28d1034 	add	r1, sp, #52	; 0x34
30010e64:	e28d2030 	add	r2, sp, #48	; 0x30
30010e68:	e28d302c 	add	r3, sp, #44	; 0x2c
30010e6c:	e59d000c 	ldr	r0, [sp, #12]
30010e70:	ebfffe59 	bl	300107dc <lwip_selscan>
30010e74:	e1a03000 	mov	r3, r0
30010e78:	e58d303c 	str	r3, [sp, #60]	; 0x3c
30010e7c:	ea000003 	b	30010e90 <lwip_select+0x42c>
  } else
    sys_sem_signal(selectsem);
30010e80:	e59f3064 	ldr	r3, [pc, #100]	; 30010eec <lwip_select+0x488>
30010e84:	e5933000 	ldr	r3, [r3]
30010e88:	e1a00003 	mov	r0, r3
30010e8c:	ebffeea5 	bl	3000c928 <sys_sem_signal>
  
  if (readset)
30010e90:	e59d3008 	ldr	r3, [sp, #8]
30010e94:	e3530000 	cmp	r3, #0
30010e98:	0a000002 	beq	30010ea8 <lwip_select+0x444>
    *readset = lreadset;
30010e9c:	e59d3008 	ldr	r3, [sp, #8]
30010ea0:	e5dd2034 	ldrb	r2, [sp, #52]	; 0x34
30010ea4:	e5c32000 	strb	r2, [r3]
  if (writeset)
30010ea8:	e59d3004 	ldr	r3, [sp, #4]
30010eac:	e3530000 	cmp	r3, #0
30010eb0:	0a000002 	beq	30010ec0 <lwip_select+0x45c>
    *writeset = lwriteset;
30010eb4:	e59d3004 	ldr	r3, [sp, #4]
30010eb8:	e5dd2030 	ldrb	r2, [sp, #48]	; 0x30
30010ebc:	e5c32000 	strb	r2, [r3]
  if (exceptset)
30010ec0:	e59d3000 	ldr	r3, [sp]
30010ec4:	e3530000 	cmp	r3, #0
30010ec8:	0a000002 	beq	30010ed8 <lwip_select+0x474>
    *exceptset = lexceptset;
30010ecc:	e59d3000 	ldr	r3, [sp]
30010ed0:	e5dd202c 	ldrb	r2, [sp, #44]	; 0x2c
30010ed4:	e5c32000 	strb	r2, [r3]
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  
  return nready;
30010ed8:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
}
30010edc:	e1a00003 	mov	r0, r3
30010ee0:	e28dd04c 	add	sp, sp, #76	; 0x4c
30010ee4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30010ee8:	e12fff1e 	bx	lr
30010eec:	300ca63c 	.word	0x300ca63c
30010ef0:	300ca634 	.word	0x300ca634
30010ef4:	10624dd3 	.word	0x10624dd3

30010ef8 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
30010ef8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30010efc:	e24dd01c 	sub	sp, sp, #28
30010f00:	e58d0004 	str	r0, [sp, #4]
30010f04:	e1a03002 	mov	r3, r2
30010f08:	e1a02001 	mov	r2, r1
30010f0c:	e5cd2003 	strb	r2, [sp, #3]
30010f10:	e1cd30b0 	strh	r3, [sp]
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
30010f14:	e59d3004 	ldr	r3, [sp, #4]
30010f18:	e3530000 	cmp	r3, #0
30010f1c:	0a0000a7 	beq	300111c0 <event_callback+0x2c8>
    s = conn->socket;
30010f20:	e59d3004 	ldr	r3, [sp, #4]
30010f24:	e5933018 	ldr	r3, [r3, #24]
30010f28:	e58d300c 	str	r3, [sp, #12]
    if (s < 0) {
30010f2c:	e59d300c 	ldr	r3, [sp, #12]
30010f30:	e3530000 	cmp	r3, #0
30010f34:	aa000018 	bge	30010f9c <event_callback+0xa4>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
30010f38:	e59f3298 	ldr	r3, [pc, #664]	; 300111d8 <event_callback+0x2e0>
30010f3c:	e5933000 	ldr	r3, [r3]
30010f40:	e1a00003 	mov	r0, r3
30010f44:	eb0017ef 	bl	30016f08 <sys_sem_wait>
      if (conn->socket < 0) {
30010f48:	e59d3004 	ldr	r3, [sp, #4]
30010f4c:	e5933018 	ldr	r3, [r3, #24]
30010f50:	e3530000 	cmp	r3, #0
30010f54:	aa00000c 	bge	30010f8c <event_callback+0x94>
        if (evt == NETCONN_EVT_RCVPLUS) {
30010f58:	e5dd3003 	ldrb	r3, [sp, #3]
30010f5c:	e3530000 	cmp	r3, #0
30010f60:	1a000004 	bne	30010f78 <event_callback+0x80>
          conn->socket--;
30010f64:	e59d3004 	ldr	r3, [sp, #4]
30010f68:	e5933018 	ldr	r3, [r3, #24]
30010f6c:	e2432001 	sub	r2, r3, #1
30010f70:	e59d3004 	ldr	r3, [sp, #4]
30010f74:	e5832018 	str	r2, [r3, #24]
        }
        sys_sem_signal(socksem);
30010f78:	e59f3258 	ldr	r3, [pc, #600]	; 300111d8 <event_callback+0x2e0>
30010f7c:	e5933000 	ldr	r3, [r3]
30010f80:	e1a00003 	mov	r0, r3
30010f84:	ebffee67 	bl	3000c928 <sys_sem_signal>
        return;
30010f88:	ea00008f 	b	300111cc <event_callback+0x2d4>
      }
      sys_sem_signal(socksem);
30010f8c:	e59f3244 	ldr	r3, [pc, #580]	; 300111d8 <event_callback+0x2e0>
30010f90:	e5933000 	ldr	r3, [r3]
30010f94:	e1a00003 	mov	r0, r3
30010f98:	ebffee62 	bl	3000c928 <sys_sem_signal>
    }

    sock = get_socket(s);
30010f9c:	e59d000c 	ldr	r0, [sp, #12]
30010fa0:	ebfff99d 	bl	3000f61c <get_socket>
30010fa4:	e1a03000 	mov	r3, r0
30010fa8:	e58d3010 	str	r3, [sp, #16]
    if (!sock) {
30010fac:	e59d3010 	ldr	r3, [sp, #16]
30010fb0:	e3530000 	cmp	r3, #0
30010fb4:	0a000083 	beq	300111c8 <event_callback+0x2d0>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
30010fb8:	e59f321c 	ldr	r3, [pc, #540]	; 300111dc <event_callback+0x2e4>
30010fbc:	e5933000 	ldr	r3, [r3]
30010fc0:	e1a00003 	mov	r0, r3
30010fc4:	eb0017cf 	bl	30016f08 <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
30010fc8:	e5dd3003 	ldrb	r3, [sp, #3]
30010fcc:	e3530003 	cmp	r3, #3
30010fd0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30010fd4:	ea00001a 	b	30011044 <event_callback+0x14c>
30010fd8:	30010fe8 	.word	0x30010fe8
30010fdc:	30011008 	.word	0x30011008
30010fe0:	30011028 	.word	0x30011028
30010fe4:	30011038 	.word	0x30011038
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
30010fe8:	e59d3010 	ldr	r3, [sp, #16]
30010fec:	e1d330ba 	ldrh	r3, [r3, #10]
30010ff0:	e2833001 	add	r3, r3, #1
30010ff4:	e1a03803 	lsl	r3, r3, #16
30010ff8:	e1a02823 	lsr	r2, r3, #16
30010ffc:	e59d3010 	ldr	r3, [sp, #16]
30011000:	e1c320ba 	strh	r2, [r3, #10]
      break;
30011004:	ea00000e 	b	30011044 <event_callback+0x14c>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
30011008:	e59d3010 	ldr	r3, [sp, #16]
3001100c:	e1d330ba 	ldrh	r3, [r3, #10]
30011010:	e2433001 	sub	r3, r3, #1
30011014:	e1a03803 	lsl	r3, r3, #16
30011018:	e1a02823 	lsr	r2, r3, #16
3001101c:	e59d3010 	ldr	r3, [sp, #16]
30011020:	e1c320ba 	strh	r2, [r3, #10]
      break;
30011024:	ea000006 	b	30011044 <event_callback+0x14c>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
30011028:	e59d3010 	ldr	r3, [sp, #16]
3001102c:	e3a02001 	mov	r2, #1
30011030:	e1c320bc 	strh	r2, [r3, #12]
      break;
30011034:	ea000002 	b	30011044 <event_callback+0x14c>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
30011038:	e59d3010 	ldr	r3, [sp, #16]
3001103c:	e3a02000 	mov	r2, #0
30011040:	e1c320bc 	strh	r2, [r3, #12]
      break;
    default:
      LWIP_ASSERT("unknown event", 0);
      break;
  }
  sys_sem_signal(selectsem);
30011044:	e59f3190 	ldr	r3, [pc, #400]	; 300111dc <event_callback+0x2e4>
30011048:	e5933000 	ldr	r3, [r3]
3001104c:	e1a00003 	mov	r0, r3
30011050:	ebffee34 	bl	3000c928 <sys_sem_signal>
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
30011054:	e59f3180 	ldr	r3, [pc, #384]	; 300111dc <event_callback+0x2e4>
30011058:	e5933000 	ldr	r3, [r3]
3001105c:	e1a00003 	mov	r0, r3
30011060:	eb0017a8 	bl	30016f08 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
30011064:	e59f3174 	ldr	r3, [pc, #372]	; 300111e0 <event_callback+0x2e8>
30011068:	e5933000 	ldr	r3, [r3]
3001106c:	e58d3014 	str	r3, [sp, #20]
30011070:	ea000036 	b	30011150 <event_callback+0x258>
      if (scb->sem_signalled == 0) {
30011074:	e59d3014 	ldr	r3, [sp, #20]
30011078:	e5933010 	ldr	r3, [r3, #16]
3001107c:	e3530000 	cmp	r3, #0
30011080:	1a00002f 	bne	30011144 <event_callback+0x24c>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
30011084:	e59d3014 	ldr	r3, [sp, #20]
30011088:	e5933004 	ldr	r3, [r3, #4]
3001108c:	e3530000 	cmp	r3, #0
30011090:	0a000013 	beq	300110e4 <event_callback+0x1ec>
30011094:	e59d3014 	ldr	r3, [sp, #20]
30011098:	e5932004 	ldr	r2, [r3, #4]
3001109c:	e59d300c 	ldr	r3, [sp, #12]
300110a0:	e2831007 	add	r1, r3, #7
300110a4:	e3530000 	cmp	r3, #0
300110a8:	b1a03001 	movlt	r3, r1
300110ac:	e1a031c3 	asr	r3, r3, #3
300110b0:	e7d23003 	ldrb	r3, [r2, r3]
300110b4:	e1a02003 	mov	r2, r3
300110b8:	e59d300c 	ldr	r3, [sp, #12]
300110bc:	e2033007 	and	r3, r3, #7
300110c0:	e1a03352 	asr	r3, r2, r3
300110c4:	e2033001 	and	r3, r3, #1
300110c8:	e20330ff 	and	r3, r3, #255	; 0xff
300110cc:	e3530000 	cmp	r3, #0
300110d0:	0a000003 	beq	300110e4 <event_callback+0x1ec>
          if (sock->rcvevent)
300110d4:	e59d3010 	ldr	r3, [sp, #16]
300110d8:	e1d330ba 	ldrh	r3, [r3, #10]
300110dc:	e3530000 	cmp	r3, #0
300110e0:	1a00001e 	bne	30011160 <event_callback+0x268>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
300110e4:	e59d3014 	ldr	r3, [sp, #20]
300110e8:	e5933008 	ldr	r3, [r3, #8]
300110ec:	e3530000 	cmp	r3, #0
300110f0:	0a000013 	beq	30011144 <event_callback+0x24c>
300110f4:	e59d3014 	ldr	r3, [sp, #20]
300110f8:	e5932008 	ldr	r2, [r3, #8]
300110fc:	e59d300c 	ldr	r3, [sp, #12]
30011100:	e2831007 	add	r1, r3, #7
30011104:	e3530000 	cmp	r3, #0
30011108:	b1a03001 	movlt	r3, r1
3001110c:	e1a031c3 	asr	r3, r3, #3
30011110:	e7d23003 	ldrb	r3, [r2, r3]
30011114:	e1a02003 	mov	r2, r3
30011118:	e59d300c 	ldr	r3, [sp, #12]
3001111c:	e2033007 	and	r3, r3, #7
30011120:	e1a03352 	asr	r3, r2, r3
30011124:	e2033001 	and	r3, r3, #1
30011128:	e20330ff 	and	r3, r3, #255	; 0xff
3001112c:	e3530000 	cmp	r3, #0
30011130:	0a000003 	beq	30011144 <event_callback+0x24c>
          if (sock->sendevent)
30011134:	e59d3010 	ldr	r3, [sp, #16]
30011138:	e1d330bc 	ldrh	r3, [r3, #12]
3001113c:	e3530000 	cmp	r3, #0
30011140:	1a000008 	bne	30011168 <event_callback+0x270>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
30011144:	e59d3014 	ldr	r3, [sp, #20]
30011148:	e5933000 	ldr	r3, [r3]
3001114c:	e58d3014 	str	r3, [sp, #20]
30011150:	e59d3014 	ldr	r3, [sp, #20]
30011154:	e3530000 	cmp	r3, #0
30011158:	1affffc5 	bne	30011074 <event_callback+0x17c>
3001115c:	ea000002 	b	3001116c <event_callback+0x274>
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
          if (sock->rcvevent)
            break;
30011160:	e1a00000 	nop			; (mov r0, r0)
30011164:	ea000000 	b	3001116c <event_callback+0x274>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
          if (sock->sendevent)
            break;
30011168:	e1a00000 	nop			; (mov r0, r0)
      }
    }
    if (scb) {
3001116c:	e59d3014 	ldr	r3, [sp, #20]
30011170:	e3530000 	cmp	r3, #0
30011174:	0a00000b 	beq	300111a8 <event_callback+0x2b0>
      scb->sem_signalled = 1;
30011178:	e59d3014 	ldr	r3, [sp, #20]
3001117c:	e3a02001 	mov	r2, #1
30011180:	e5832010 	str	r2, [r3, #16]
      sys_sem_signal(selectsem);
30011184:	e59f3050 	ldr	r3, [pc, #80]	; 300111dc <event_callback+0x2e4>
30011188:	e5933000 	ldr	r3, [r3]
3001118c:	e1a00003 	mov	r0, r3
30011190:	ebffede4 	bl	3000c928 <sys_sem_signal>
      sys_sem_signal(scb->sem);
30011194:	e59d3014 	ldr	r3, [sp, #20]
30011198:	e5933014 	ldr	r3, [r3, #20]
3001119c:	e1a00003 	mov	r0, r3
300111a0:	ebffede0 	bl	3000c928 <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
300111a4:	eaffffaa 	b	30011054 <event_callback+0x15c>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
300111a8:	e59f302c 	ldr	r3, [pc, #44]	; 300111dc <event_callback+0x2e4>
300111ac:	e5933000 	ldr	r3, [r3]
300111b0:	e1a00003 	mov	r0, r3
300111b4:	ebffeddb 	bl	3000c928 <sys_sem_signal>
      break;
300111b8:	e1a00000 	nop			; (mov r0, r0)
300111bc:	ea000002 	b	300111cc <event_callback+0x2d4>
    sock = get_socket(s);
    if (!sock) {
      return;
    }
  } else {
    return;
300111c0:	e1a00000 	nop			; (mov r0, r0)
300111c4:	ea000000 	b	300111cc <event_callback+0x2d4>
      sys_sem_signal(socksem);
    }

    sock = get_socket(s);
    if (!sock) {
      return;
300111c8:	e1a00000 	nop			; (mov r0, r0)
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
}
300111cc:	e28dd01c 	add	sp, sp, #28
300111d0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300111d4:	e12fff1e 	bx	lr
300111d8:	300ca638 	.word	0x300ca638
300111dc:	300ca63c 	.word	0x300ca63c
300111e0:	300ca634 	.word	0x300ca634

300111e4 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
300111e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300111e8:	e24dd00c 	sub	sp, sp, #12
300111ec:	e58d0004 	str	r0, [sp, #4]
300111f0:	e58d1000 	str	r1, [sp]
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
300111f4:	e59d0004 	ldr	r0, [sp, #4]
300111f8:	ebfffa7e 	bl	3000fbf8 <lwip_close>
300111fc:	e1a03000 	mov	r3, r0
}
30011200:	e1a00003 	mov	r0, r3
30011204:	e28dd00c 	add	sp, sp, #12
30011208:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001120c:	e12fff1e 	bx	lr

30011210 <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
30011210:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30011214:	e24dd02c 	sub	sp, sp, #44	; 0x2c
30011218:	e58d000c 	str	r0, [sp, #12]
3001121c:	e58d1008 	str	r1, [sp, #8]
30011220:	e58d2004 	str	r2, [sp, #4]
30011224:	e5cd3003 	strb	r3, [sp, #3]
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
30011228:	e59d000c 	ldr	r0, [sp, #12]
3001122c:	ebfff8fa 	bl	3000f61c <get_socket>
30011230:	e1a03000 	mov	r3, r0
30011234:	e58d3024 	str	r3, [sp, #36]	; 0x24
  if (!sock)
30011238:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001123c:	e3530000 	cmp	r3, #0
30011240:	1a000001 	bne	3001124c <lwip_getaddrname+0x3c>
    return -1;
30011244:	e3e03000 	mvn	r3, #0
30011248:	ea000028 	b	300112f0 <lwip_getaddrname+0xe0>

  memset(&sin, 0, sizeof(sin));
3001124c:	e28d3014 	add	r3, sp, #20
30011250:	e1a00003 	mov	r0, r3
30011254:	e3a01000 	mov	r1, #0
30011258:	e3a02010 	mov	r2, #16
3001125c:	ebffec02 	bl	3000c26c <acoral_memset>
  sin.sin_len = sizeof(sin);
30011260:	e3a03010 	mov	r3, #16
30011264:	e5cd3014 	strb	r3, [sp, #20]
  sin.sin_family = AF_INET;
30011268:	e3a03002 	mov	r3, #2
3001126c:	e5cd3015 	strb	r3, [sp, #21]

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
30011270:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30011274:	e5930000 	ldr	r0, [r3]
30011278:	e28d1010 	add	r1, sp, #16
3001127c:	e28d3014 	add	r3, sp, #20
30011280:	e2832002 	add	r2, r3, #2
30011284:	e5dd3003 	ldrb	r3, [sp, #3]
30011288:	ebffeef0 	bl	3000ce50 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
3001128c:	e1dd31b6 	ldrh	r3, [sp, #22]
30011290:	e1a00003 	mov	r0, r3
30011294:	eb0008d9 	bl	30013600 <htons>
30011298:	e1a03000 	mov	r3, r0
3001129c:	e1cd31b6 	strh	r3, [sp, #22]
  sin.sin_addr.s_addr = naddr.addr;
300112a0:	e59d3010 	ldr	r3, [sp, #16]
300112a4:	e58d3018 	str	r3, [sp, #24]

  if (*namelen > sizeof(sin))
300112a8:	e59d3004 	ldr	r3, [sp, #4]
300112ac:	e5933000 	ldr	r3, [r3]
300112b0:	e3530010 	cmp	r3, #16
300112b4:	9a000002 	bls	300112c4 <lwip_getaddrname+0xb4>
    *namelen = sizeof(sin);
300112b8:	e59d3004 	ldr	r3, [sp, #4]
300112bc:	e3a02010 	mov	r2, #16
300112c0:	e5832000 	str	r2, [r3]

  SMEMCPY(name, &sin, *namelen);
300112c4:	e59d3004 	ldr	r3, [sp, #4]
300112c8:	e5933000 	ldr	r3, [r3]
300112cc:	e28d2014 	add	r2, sp, #20
300112d0:	e59d0008 	ldr	r0, [sp, #8]
300112d4:	e1a01002 	mov	r1, r2
300112d8:	e1a02003 	mov	r2, r3
300112dc:	ebffebfe 	bl	3000c2dc <acoral_memcpy>
  sock_set_errno(sock, 0);
300112e0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300112e4:	e3a02000 	mov	r2, #0
300112e8:	e5832010 	str	r2, [r3, #16]
  return 0;
300112ec:	e3a03000 	mov	r3, #0
}
300112f0:	e1a00003 	mov	r0, r3
300112f4:	e28dd02c 	add	sp, sp, #44	; 0x2c
300112f8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300112fc:	e12fff1e 	bx	lr

30011300 <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
30011300:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30011304:	e24dd014 	sub	sp, sp, #20
30011308:	e58d000c 	str	r0, [sp, #12]
3001130c:	e58d1008 	str	r1, [sp, #8]
30011310:	e58d2004 	str	r2, [sp, #4]
  return lwip_getaddrname(s, name, namelen, 0);
30011314:	e59d000c 	ldr	r0, [sp, #12]
30011318:	e59d1008 	ldr	r1, [sp, #8]
3001131c:	e59d2004 	ldr	r2, [sp, #4]
30011320:	e3a03000 	mov	r3, #0
30011324:	ebffffb9 	bl	30011210 <lwip_getaddrname>
30011328:	e1a03000 	mov	r3, r0
}
3001132c:	e1a00003 	mov	r0, r3
30011330:	e28dd014 	add	sp, sp, #20
30011334:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30011338:	e12fff1e 	bx	lr

3001133c <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
3001133c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30011340:	e24dd014 	sub	sp, sp, #20
30011344:	e58d000c 	str	r0, [sp, #12]
30011348:	e58d1008 	str	r1, [sp, #8]
3001134c:	e58d2004 	str	r2, [sp, #4]
  return lwip_getaddrname(s, name, namelen, 1);
30011350:	e59d000c 	ldr	r0, [sp, #12]
30011354:	e59d1008 	ldr	r1, [sp, #8]
30011358:	e59d2004 	ldr	r2, [sp, #4]
3001135c:	e3a03001 	mov	r3, #1
30011360:	ebffffaa 	bl	30011210 <lwip_getaddrname>
30011364:	e1a03000 	mov	r3, r0
}
30011368:	e1a00003 	mov	r0, r3
3001136c:	e28dd014 	add	sp, sp, #20
30011370:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30011374:	e12fff1e 	bx	lr

30011378 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
30011378:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001137c:	e24dd03c 	sub	sp, sp, #60	; 0x3c
30011380:	e58d000c 	str	r0, [sp, #12]
30011384:	e58d1008 	str	r1, [sp, #8]
30011388:	e58d2004 	str	r2, [sp, #4]
3001138c:	e58d3000 	str	r3, [sp]
  err_t err = ERR_OK;
30011390:	e3a03000 	mov	r3, #0
30011394:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
  struct lwip_socket *sock = get_socket(s);
30011398:	e59d000c 	ldr	r0, [sp, #12]
3001139c:	ebfff89e 	bl	3000f61c <get_socket>
300113a0:	e1a03000 	mov	r3, r0
300113a4:	e58d3034 	str	r3, [sp, #52]	; 0x34
  struct lwip_setgetsockopt_data data;

  if (!sock)
300113a8:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
300113ac:	e3530000 	cmp	r3, #0
300113b0:	1a000001 	bne	300113bc <lwip_getsockopt+0x44>
    return -1;
300113b4:	e3e03000 	mvn	r3, #0
300113b8:	ea00009d 	b	30011634 <lwip_getsockopt+0x2bc>

  if ((NULL == optval) || (NULL == optlen)) {
300113bc:	e59d3000 	ldr	r3, [sp]
300113c0:	e3530000 	cmp	r3, #0
300113c4:	0a000002 	beq	300113d4 <lwip_getsockopt+0x5c>
300113c8:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
300113cc:	e3530000 	cmp	r3, #0
300113d0:	1a000004 	bne	300113e8 <lwip_getsockopt+0x70>
    sock_set_errno(sock, EFAULT);
300113d4:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
300113d8:	e3a0200e 	mov	r2, #14
300113dc:	e5832010 	str	r2, [r3, #16]
    return -1;
300113e0:	e3e03000 	mvn	r3, #0
300113e4:	ea000092 	b	30011634 <lwip_getsockopt+0x2bc>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
300113e8:	e59d3008 	ldr	r3, [sp, #8]
300113ec:	e3530006 	cmp	r3, #6
300113f0:	0a00004c 	beq	30011528 <lwip_getsockopt+0x1b0>
300113f4:	e3a02eff 	mov	r2, #4080	; 0xff0
300113f8:	e282200f 	add	r2, r2, #15
300113fc:	e1530002 	cmp	r3, r2
30011400:	0a000002 	beq	30011410 <lwip_getsockopt+0x98>
30011404:	e3530000 	cmp	r3, #0
30011408:	0a000037 	beq	300114ec <lwip_getsockopt+0x174>
3001140c:	ea00005c 	b	30011584 <lwip_getsockopt+0x20c>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
30011410:	e59d3004 	ldr	r3, [sp, #4]
30011414:	e3530020 	cmp	r3, #32
30011418:	0a000013 	beq	3001146c <lwip_getsockopt+0xf4>
3001141c:	e3530020 	cmp	r3, #32
30011420:	ca000004 	bgt	30011438 <lwip_getsockopt+0xc0>
30011424:	e3530002 	cmp	r3, #2
30011428:	0a00000f 	beq	3001146c <lwip_getsockopt+0xf4>
3001142c:	e3530008 	cmp	r3, #8
30011430:	0a00000d 	beq	3001146c <lwip_getsockopt+0xf4>
30011434:	ea000028 	b	300114dc <lwip_getsockopt+0x164>
30011438:	e3a02a01 	mov	r2, #4096	; 0x1000
3001143c:	e2822007 	add	r2, r2, #7
30011440:	e1530002 	cmp	r3, r2
30011444:	ba000024 	blt	300114dc <lwip_getsockopt+0x164>
30011448:	e3a02a01 	mov	r2, #4096	; 0x1000
3001144c:	e2822008 	add	r2, r2, #8
30011450:	e1530002 	cmp	r3, r2
30011454:	da000004 	ble	3001146c <lwip_getsockopt+0xf4>
30011458:	e3a02a01 	mov	r2, #4096	; 0x1000
3001145c:	e282200a 	add	r2, r2, #10
30011460:	e1530002 	cmp	r3, r2
30011464:	0a000007 	beq	30011488 <lwip_getsockopt+0x110>
30011468:	ea00001b 	b	300114dc <lwip_getsockopt+0x164>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
3001146c:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
30011470:	e5933000 	ldr	r3, [r3]
30011474:	e3530003 	cmp	r3, #3
30011478:	8a000001 	bhi	30011484 <lwip_getsockopt+0x10c>
        err = EINVAL;
3001147c:	e3a03016 	mov	r3, #22
30011480:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
      }
      break;
30011484:	ea000017 	b	300114e8 <lwip_getsockopt+0x170>

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
30011488:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3001148c:	e5933000 	ldr	r3, [r3]
30011490:	e3530003 	cmp	r3, #3
30011494:	8a000001 	bhi	300114a0 <lwip_getsockopt+0x128>
        err = EINVAL;
30011498:	e3a03016 	mov	r3, #22
3001149c:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
300114a0:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
300114a4:	e5933000 	ldr	r3, [r3]
300114a8:	e5d33000 	ldrb	r3, [r3]
300114ac:	e3530020 	cmp	r3, #32
300114b0:	1a000006 	bne	300114d0 <lwip_getsockopt+0x158>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
300114b4:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
300114b8:	e5933000 	ldr	r3, [r3]
300114bc:	e5933004 	ldr	r3, [r3, #4]
300114c0:	e5d33010 	ldrb	r3, [r3, #16]
300114c4:	e2033002 	and	r3, r3, #2
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
300114c8:	e3530000 	cmp	r3, #0
300114cc:	0a000001 	beq	300114d8 <lwip_getsockopt+0x160>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
300114d0:	e3a03061 	mov	r3, #97	; 0x61
300114d4:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
      }
#endif /* LWIP_UDP */
      break;
300114d8:	ea000002 	b	300114e8 <lwip_getsockopt+0x170>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
300114dc:	e3a0305c 	mov	r3, #92	; 0x5c
300114e0:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
    }  /* switch (optname) */
    break;
300114e4:	ea000028 	b	3001158c <lwip_getsockopt+0x214>
300114e8:	ea000027 	b	3001158c <lwip_getsockopt+0x214>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
300114ec:	e59d3004 	ldr	r3, [sp, #4]
300114f0:	e2433001 	sub	r3, r3, #1
300114f4:	e3530001 	cmp	r3, #1
300114f8:	8a000007 	bhi	3001151c <lwip_getsockopt+0x1a4>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
300114fc:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
30011500:	e5933000 	ldr	r3, [r3]
30011504:	e3530003 	cmp	r3, #3
30011508:	8a000001 	bhi	30011514 <lwip_getsockopt+0x19c>
        err = EINVAL;
3001150c:	e3a03016 	mov	r3, #22
30011510:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
      }
      break;
30011514:	e1a00000 	nop			; (mov r0, r0)
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
30011518:	ea00001b 	b	3001158c <lwip_getsockopt+0x214>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
3001151c:	e3a0305c 	mov	r3, #92	; 0x5c
30011520:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
    }  /* switch (optname) */
    break;
30011524:	ea000018 	b	3001158c <lwip_getsockopt+0x214>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
30011528:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3001152c:	e5933000 	ldr	r3, [r3]
30011530:	e3530003 	cmp	r3, #3
30011534:	8a000002 	bhi	30011544 <lwip_getsockopt+0x1cc>
      err = EINVAL;
30011538:	e3a03016 	mov	r3, #22
3001153c:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
      break;
30011540:	ea000011 	b	3001158c <lwip_getsockopt+0x214>
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
30011544:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30011548:	e5933000 	ldr	r3, [r3]
3001154c:	e5d33000 	ldrb	r3, [r3]
30011550:	e3530010 	cmp	r3, #16
30011554:	0a000001 	beq	30011560 <lwip_getsockopt+0x1e8>
      return 0;
30011558:	e3a03000 	mov	r3, #0
3001155c:	ea000034 	b	30011634 <lwip_getsockopt+0x2bc>

    switch (optname) {
30011560:	e59d3004 	ldr	r3, [sp, #4]
30011564:	e2433001 	sub	r3, r3, #1
30011568:	e3530001 	cmp	r3, #1
3001156c:	8a000001 	bhi	30011578 <lwip_getsockopt+0x200>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
30011570:	e1a00000 	nop			; (mov r0, r0)
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
30011574:	ea000004 	b	3001158c <lwip_getsockopt+0x214>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
30011578:	e3a0305c 	mov	r3, #92	; 0x5c
3001157c:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
    }  /* switch (optname) */
    break;
30011580:	ea000001 	b	3001158c <lwip_getsockopt+0x214>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
30011584:	e3a0305c 	mov	r3, #92	; 0x5c
30011588:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
  }  /* switch */

   
  if (err != ERR_OK) {
3001158c:	e1dd33d3 	ldrsb	r3, [sp, #51]	; 0x33
30011590:	e3530000 	cmp	r3, #0
30011594:	0a000004 	beq	300115ac <lwip_getsockopt+0x234>
    sock_set_errno(sock, err);
30011598:	e1dd23d3 	ldrsb	r2, [sp, #51]	; 0x33
3001159c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
300115a0:	e5832010 	str	r2, [r3, #16]
    return -1;
300115a4:	e3e03000 	mvn	r3, #0
300115a8:	ea000021 	b	30011634 <lwip_getsockopt+0x2bc>
  }

  /* Now do the actual option processing */
  data.sock = sock;
300115ac:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
300115b0:	e58d3014 	str	r3, [sp, #20]
  data.level = level;
300115b4:	e59d3008 	ldr	r3, [sp, #8]
300115b8:	e58d301c 	str	r3, [sp, #28]
  data.optname = optname;
300115bc:	e59d3004 	ldr	r3, [sp, #4]
300115c0:	e58d3020 	str	r3, [sp, #32]
  data.optval = optval;
300115c4:	e59d3000 	ldr	r3, [sp]
300115c8:	e58d3024 	str	r3, [sp, #36]	; 0x24
  data.optlen = optlen;
300115cc:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
300115d0:	e58d3028 	str	r3, [sp, #40]	; 0x28
  data.err = err;
300115d4:	e5dd3033 	ldrb	r3, [sp, #51]	; 0x33
300115d8:	e5cd302c 	strb	r3, [sp, #44]	; 0x2c
  tcpip_callback(lwip_getsockopt_internal, &data);
300115dc:	e28d3014 	add	r3, sp, #20
300115e0:	e59f005c 	ldr	r0, [pc, #92]	; 30011644 <lwip_getsockopt+0x2cc>
300115e4:	e1a01003 	mov	r1, r3
300115e8:	e3a02001 	mov	r2, #1
300115ec:	eb000372 	bl	300123bc <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
300115f0:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
300115f4:	e5933000 	ldr	r3, [r3]
300115f8:	e593300c 	ldr	r3, [r3, #12]
300115fc:	e1a00003 	mov	r0, r3
30011600:	e3a01000 	mov	r1, #0
30011604:	ebffeccf 	bl	3000c948 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
30011608:	e5dd302c 	ldrb	r3, [sp, #44]	; 0x2c
3001160c:	e5cd3033 	strb	r3, [sp, #51]	; 0x33

  sock_set_errno(sock, err);
30011610:	e1dd23d3 	ldrsb	r2, [sp, #51]	; 0x33
30011614:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30011618:	e5832010 	str	r2, [r3, #16]
  return err ? -1 : 0;
3001161c:	e1dd33d3 	ldrsb	r3, [sp, #51]	; 0x33
30011620:	e3530000 	cmp	r3, #0
30011624:	0a000001 	beq	30011630 <lwip_getsockopt+0x2b8>
30011628:	e3e03000 	mvn	r3, #0
3001162c:	ea000000 	b	30011634 <lwip_getsockopt+0x2bc>
30011630:	e3a03000 	mov	r3, #0
}
30011634:	e1a00003 	mov	r0, r3
30011638:	e28dd03c 	add	sp, sp, #60	; 0x3c
3001163c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30011640:	e12fff1e 	bx	lr
30011644:	30011648 	.word	0x30011648

30011648 <lwip_getsockopt_internal>:

static void
lwip_getsockopt_internal(void *arg)
{
30011648:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001164c:	e24dd024 	sub	sp, sp, #36	; 0x24
30011650:	e58d0004 	str	r0, [sp, #4]
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);

  data = (struct lwip_setgetsockopt_data*)arg;
30011654:	e59d3004 	ldr	r3, [sp, #4]
30011658:	e58d301c 	str	r3, [sp, #28]
  sock = data->sock;
3001165c:	e59d301c 	ldr	r3, [sp, #28]
30011660:	e5933000 	ldr	r3, [r3]
30011664:	e58d300c 	str	r3, [sp, #12]
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
30011668:	e59d301c 	ldr	r3, [sp, #28]
3001166c:	e5933008 	ldr	r3, [r3, #8]
30011670:	e58d3010 	str	r3, [sp, #16]
  optname = data->optname;
30011674:	e59d301c 	ldr	r3, [sp, #28]
30011678:	e593300c 	ldr	r3, [r3, #12]
3001167c:	e58d3014 	str	r3, [sp, #20]
  optval = data->optval;
30011680:	e59d301c 	ldr	r3, [sp, #28]
30011684:	e5933010 	ldr	r3, [r3, #16]
30011688:	e58d3018 	str	r3, [sp, #24]

  switch (level) {
3001168c:	e59d3010 	ldr	r3, [sp, #16]
30011690:	e3530006 	cmp	r3, #6
30011694:	0a000081 	beq	300118a0 <lwip_getsockopt_internal+0x258>
30011698:	e3a02eff 	mov	r2, #4080	; 0xff0
3001169c:	e282200f 	add	r2, r2, #15
300116a0:	e1530002 	cmp	r3, r2
300116a4:	0a000002 	beq	300116b4 <lwip_getsockopt_internal+0x6c>
300116a8:	e3530000 	cmp	r3, #0
300116ac:	0a000067 	beq	30011850 <lwip_getsockopt_internal+0x208>
300116b0:	ea000090 	b	300118f8 <lwip_getsockopt_internal+0x2b0>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
300116b4:	e59d3014 	ldr	r3, [sp, #20]
300116b8:	e3530020 	cmp	r3, #32
300116bc:	0a000013 	beq	30011710 <lwip_getsockopt_internal+0xc8>
300116c0:	e3530020 	cmp	r3, #32
300116c4:	ca000004 	bgt	300116dc <lwip_getsockopt_internal+0x94>
300116c8:	e3530002 	cmp	r3, #2
300116cc:	0a00000f 	beq	30011710 <lwip_getsockopt_internal+0xc8>
300116d0:	e3530008 	cmp	r3, #8
300116d4:	0a00000d 	beq	30011710 <lwip_getsockopt_internal+0xc8>
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
300116d8:	ea000086 	b	300118f8 <lwip_getsockopt_internal+0x2b0>

  switch (level) {
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
300116dc:	e3a02a01 	mov	r2, #4096	; 0x1000
300116e0:	e2822008 	add	r2, r2, #8
300116e4:	e1530002 	cmp	r3, r2
300116e8:	0a000012 	beq	30011738 <lwip_getsockopt_internal+0xf0>
300116ec:	e3a02a01 	mov	r2, #4096	; 0x1000
300116f0:	e282200a 	add	r2, r2, #10
300116f4:	e1530002 	cmp	r3, r2
300116f8:	0a00004b 	beq	3001182c <lwip_getsockopt_internal+0x1e4>
300116fc:	e3a02a01 	mov	r2, #4096	; 0x1000
30011700:	e2822007 	add	r2, r2, #7
30011704:	e1530002 	cmp	r3, r2
30011708:	0a000027 	beq	300117ac <lwip_getsockopt_internal+0x164>
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
3001170c:	ea000079 	b	300118f8 <lwip_getsockopt_internal+0x2b0>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
30011710:	e59d3018 	ldr	r3, [sp, #24]
30011714:	e59d200c 	ldr	r2, [sp, #12]
30011718:	e5922000 	ldr	r2, [r2]
3001171c:	e5922004 	ldr	r2, [r2, #4]
30011720:	e1d220b8 	ldrh	r2, [r2, #8]
30011724:	e1a01002 	mov	r1, r2
30011728:	e59d2014 	ldr	r2, [sp, #20]
3001172c:	e0012002 	and	r2, r1, r2
30011730:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
30011734:	ea000044 	b	3001184c <lwip_getsockopt_internal+0x204>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
30011738:	e59d300c 	ldr	r3, [sp, #12]
3001173c:	e5933000 	ldr	r3, [r3]
30011740:	e5d33000 	ldrb	r3, [r3]
30011744:	e20330f0 	and	r3, r3, #240	; 0xf0
30011748:	e3530020 	cmp	r3, #32
3001174c:	0a00000c 	beq	30011784 <lwip_getsockopt_internal+0x13c>
30011750:	e3530040 	cmp	r3, #64	; 0x40
30011754:	0a000002 	beq	30011764 <lwip_getsockopt_internal+0x11c>
30011758:	e3530010 	cmp	r3, #16
3001175c:	0a000004 	beq	30011774 <lwip_getsockopt_internal+0x12c>
30011760:	ea00000b 	b	30011794 <lwip_getsockopt_internal+0x14c>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
30011764:	e59d3018 	ldr	r3, [sp, #24]
30011768:	e3a02003 	mov	r2, #3
3001176c:	e5832000 	str	r2, [r3]
        break;
30011770:	ea00000c 	b	300117a8 <lwip_getsockopt_internal+0x160>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
30011774:	e59d3018 	ldr	r3, [sp, #24]
30011778:	e3a02001 	mov	r2, #1
3001177c:	e5832000 	str	r2, [r3]
        break;
30011780:	ea000008 	b	300117a8 <lwip_getsockopt_internal+0x160>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
30011784:	e59d3018 	ldr	r3, [sp, #24]
30011788:	e3a02002 	mov	r2, #2
3001178c:	e5832000 	str	r2, [r3]
        break;
30011790:	ea000004 	b	300117a8 <lwip_getsockopt_internal+0x160>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
30011794:	e59d3018 	ldr	r3, [sp, #24]
30011798:	e59d200c 	ldr	r2, [sp, #12]
3001179c:	e5922000 	ldr	r2, [r2]
300117a0:	e5d22000 	ldrb	r2, [r2]
300117a4:	e5832000 	str	r2, [r3]
                    ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
                    s, *(int *)optval));
      }  /* switch (sock->conn->type) */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;
300117a8:	ea000027 	b	3001184c <lwip_getsockopt_internal+0x204>

    case SO_ERROR:
      if (sock->err == 0) {
300117ac:	e59d300c 	ldr	r3, [sp, #12]
300117b0:	e5933010 	ldr	r3, [r3, #16]
300117b4:	e3530000 	cmp	r3, #0
300117b8:	1a000013 	bne	3001180c <lwip_getsockopt_internal+0x1c4>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
300117bc:	e59d300c 	ldr	r3, [sp, #12]
300117c0:	e5933000 	ldr	r3, [r3]
300117c4:	e5d33008 	ldrb	r3, [r3, #8]
300117c8:	e1a03c03 	lsl	r3, r3, #24
300117cc:	e1a03c43 	asr	r3, r3, #24
300117d0:	e2633000 	rsb	r3, r3, #0
300117d4:	e353000e 	cmp	r3, #14
300117d8:	8a000008 	bhi	30011800 <lwip_getsockopt_internal+0x1b8>
300117dc:	e59d300c 	ldr	r3, [sp, #12]
300117e0:	e5933000 	ldr	r3, [r3]
300117e4:	e5d33008 	ldrb	r3, [r3, #8]
300117e8:	e1a03c03 	lsl	r3, r3, #24
300117ec:	e1a03c43 	asr	r3, r3, #24
300117f0:	e2632000 	rsb	r2, r3, #0
300117f4:	e59f311c 	ldr	r3, [pc, #284]	; 30011918 <lwip_getsockopt_internal+0x2d0>
300117f8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300117fc:	ea000000 	b	30011804 <lwip_getsockopt_internal+0x1bc>
30011800:	e3a03005 	mov	r3, #5
30011804:	e59d200c 	ldr	r2, [sp, #12]
30011808:	e5823010 	str	r3, [r2, #16]
      } 
      *(int *)optval = sock->err;
3001180c:	e59d3018 	ldr	r3, [sp, #24]
30011810:	e59d200c 	ldr	r2, [sp, #12]
30011814:	e5922010 	ldr	r2, [r2, #16]
30011818:	e5832000 	str	r2, [r3]
      sock->err = 0;
3001181c:	e59d300c 	ldr	r3, [sp, #12]
30011820:	e3a02000 	mov	r2, #0
30011824:	e5832010 	str	r2, [r3, #16]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
30011828:	ea000007 	b	3001184c <lwip_getsockopt_internal+0x204>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
3001182c:	e59d3018 	ldr	r3, [sp, #24]
30011830:	e59d200c 	ldr	r2, [sp, #12]
30011834:	e5922000 	ldr	r2, [r2]
30011838:	e5922004 	ldr	r2, [r2, #4]
3001183c:	e5d22010 	ldrb	r2, [r2, #16]
30011840:	e2022001 	and	r2, r2, #1
30011844:	e5832000 	str	r2, [r3]
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
30011848:	ea00002a 	b	300118f8 <lwip_getsockopt_internal+0x2b0>
3001184c:	ea000029 	b	300118f8 <lwip_getsockopt_internal+0x2b0>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
30011850:	e59d3014 	ldr	r3, [sp, #20]
30011854:	e3530001 	cmp	r3, #1
30011858:	0a000009 	beq	30011884 <lwip_getsockopt_internal+0x23c>
3001185c:	e3530002 	cmp	r3, #2
30011860:	1a000023 	bne	300118f4 <lwip_getsockopt_internal+0x2ac>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
30011864:	e59d3018 	ldr	r3, [sp, #24]
30011868:	e59d200c 	ldr	r2, [sp, #12]
3001186c:	e5922000 	ldr	r2, [r2]
30011870:	e5922004 	ldr	r2, [r2, #4]
30011874:	e5d2200b 	ldrb	r2, [r2, #11]
30011878:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
3001187c:	e1a00000 	nop			; (mov r0, r0)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
30011880:	ea00001c 	b	300118f8 <lwip_getsockopt_internal+0x2b0>
      *(int*)optval = sock->conn->pcb.ip->ttl;
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
30011884:	e59d3018 	ldr	r3, [sp, #24]
30011888:	e59d200c 	ldr	r2, [sp, #12]
3001188c:	e5922000 	ldr	r2, [r2]
30011890:	e5922004 	ldr	r2, [r2, #4]
30011894:	e5d2200a 	ldrb	r2, [r2, #10]
30011898:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
3001189c:	ea000015 	b	300118f8 <lwip_getsockopt_internal+0x2b0>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
300118a0:	e59d3014 	ldr	r3, [sp, #20]
300118a4:	e3530001 	cmp	r3, #1
300118a8:	0a000002 	beq	300118b8 <lwip_getsockopt_internal+0x270>
300118ac:	e3530002 	cmp	r3, #2
300118b0:	0a000008 	beq	300118d8 <lwip_getsockopt_internal+0x290>
300118b4:	ea00000f 	b	300118f8 <lwip_getsockopt_internal+0x2b0>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
300118b8:	e59d3018 	ldr	r3, [sp, #24]
300118bc:	e59d200c 	ldr	r2, [sp, #12]
300118c0:	e5922000 	ldr	r2, [r2]
300118c4:	e5922004 	ldr	r2, [r2, #4]
300118c8:	e5d2201c 	ldrb	r2, [r2, #28]
300118cc:	e2022040 	and	r2, r2, #64	; 0x40
300118d0:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
300118d4:	ea000007 	b	300118f8 <lwip_getsockopt_internal+0x2b0>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
300118d8:	e59d3018 	ldr	r3, [sp, #24]
300118dc:	e59d200c 	ldr	r2, [sp, #12]
300118e0:	e5922000 	ldr	r2, [r2]
300118e4:	e5922004 	ldr	r2, [r2, #4]
300118e8:	e5922098 	ldr	r2, [r2, #152]	; 0x98
300118ec:	e5832000 	str	r2, [r3]
300118f0:	ea000000 	b	300118f8 <lwip_getsockopt_internal+0x2b0>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
300118f4:	e1a00000 	nop			; (mov r0, r0)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
300118f8:	e59d300c 	ldr	r3, [sp, #12]
300118fc:	e5933000 	ldr	r3, [r3]
30011900:	e593300c 	ldr	r3, [r3, #12]
30011904:	e1a00003 	mov	r0, r3
30011908:	ebffec06 	bl	3000c928 <sys_sem_signal>
}
3001190c:	e28dd024 	add	sp, sp, #36	; 0x24
30011910:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30011914:	e12fff1e 	bx	lr
30011918:	3004568c 	.word	0x3004568c

3001191c <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
3001191c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30011920:	e24dd03c 	sub	sp, sp, #60	; 0x3c
30011924:	e58d000c 	str	r0, [sp, #12]
30011928:	e58d1008 	str	r1, [sp, #8]
3001192c:	e58d2004 	str	r2, [sp, #4]
30011930:	e58d3000 	str	r3, [sp]
  struct lwip_socket *sock = get_socket(s);
30011934:	e59d000c 	ldr	r0, [sp, #12]
30011938:	ebfff737 	bl	3000f61c <get_socket>
3001193c:	e1a03000 	mov	r3, r0
30011940:	e58d3030 	str	r3, [sp, #48]	; 0x30
  int err = ERR_OK;
30011944:	e3a03000 	mov	r3, #0
30011948:	e58d3034 	str	r3, [sp, #52]	; 0x34
  struct lwip_setgetsockopt_data data;

  if (!sock)
3001194c:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011950:	e3530000 	cmp	r3, #0
30011954:	1a000001 	bne	30011960 <lwip_setsockopt+0x44>
    return -1;
30011958:	e3e03000 	mvn	r3, #0
3001195c:	ea00008b 	b	30011b90 <lwip_setsockopt+0x274>

  if (NULL == optval) {
30011960:	e59d3000 	ldr	r3, [sp]
30011964:	e3530000 	cmp	r3, #0
30011968:	1a000004 	bne	30011980 <lwip_setsockopt+0x64>
    sock_set_errno(sock, EFAULT);
3001196c:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011970:	e3a0200e 	mov	r2, #14
30011974:	e5832010 	str	r2, [r3, #16]
    return -1;
30011978:	e3e03000 	mvn	r3, #0
3001197c:	ea000083 	b	30011b90 <lwip_setsockopt+0x274>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
30011980:	e59d3008 	ldr	r3, [sp, #8]
30011984:	e3530006 	cmp	r3, #6
30011988:	0a00003b 	beq	30011a7c <lwip_setsockopt+0x160>
3001198c:	e3a02eff 	mov	r2, #4080	; 0xff0
30011990:	e282200f 	add	r2, r2, #15
30011994:	e1530002 	cmp	r3, r2
30011998:	0a000002 	beq	300119a8 <lwip_setsockopt+0x8c>
3001199c:	e3530000 	cmp	r3, #0
300119a0:	0a000027 	beq	30011a44 <lwip_setsockopt+0x128>
300119a4:	ea00004a 	b	30011ad4 <lwip_setsockopt+0x1b8>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
300119a8:	e59d3004 	ldr	r3, [sp, #4]
300119ac:	e3530020 	cmp	r3, #32
300119b0:	0a000005 	beq	300119cc <lwip_setsockopt+0xb0>
300119b4:	e3a02a01 	mov	r2, #4096	; 0x1000
300119b8:	e282200a 	add	r2, r2, #10
300119bc:	e1530002 	cmp	r3, r2
300119c0:	0a000007 	beq	300119e4 <lwip_setsockopt+0xc8>
300119c4:	e3530008 	cmp	r3, #8
300119c8:	1a000019 	bne	30011a34 <lwip_setsockopt+0x118>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
300119cc:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
300119d0:	e3530003 	cmp	r3, #3
300119d4:	8a000001 	bhi	300119e0 <lwip_setsockopt+0xc4>
        err = EINVAL;
300119d8:	e3a03016 	mov	r3, #22
300119dc:	e58d3034 	str	r3, [sp, #52]	; 0x34
      }
      break;
300119e0:	ea000016 	b	30011a40 <lwip_setsockopt+0x124>
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
300119e4:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
300119e8:	e3530003 	cmp	r3, #3
300119ec:	8a000001 	bhi	300119f8 <lwip_setsockopt+0xdc>
        err = EINVAL;
300119f0:	e3a03016 	mov	r3, #22
300119f4:	e58d3034 	str	r3, [sp, #52]	; 0x34
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
300119f8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
300119fc:	e5933000 	ldr	r3, [r3]
30011a00:	e5d33000 	ldrb	r3, [r3]
30011a04:	e3530020 	cmp	r3, #32
30011a08:	1a000006 	bne	30011a28 <lwip_setsockopt+0x10c>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
30011a0c:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011a10:	e5933000 	ldr	r3, [r3]
30011a14:	e5933004 	ldr	r3, [r3, #4]
30011a18:	e5d33010 	ldrb	r3, [r3, #16]
30011a1c:	e2033002 	and	r3, r3, #2
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
30011a20:	e3530000 	cmp	r3, #0
30011a24:	0a000001 	beq	30011a30 <lwip_setsockopt+0x114>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
30011a28:	e3a03061 	mov	r3, #97	; 0x61
30011a2c:	e58d3034 	str	r3, [sp, #52]	; 0x34
      }
#endif /* LWIP_UDP */
      break;
30011a30:	ea000002 	b	30011a40 <lwip_setsockopt+0x124>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
30011a34:	e3a0305c 	mov	r3, #92	; 0x5c
30011a38:	e58d3034 	str	r3, [sp, #52]	; 0x34
    }  /* switch (optname) */
    break;
30011a3c:	ea000026 	b	30011adc <lwip_setsockopt+0x1c0>
30011a40:	ea000025 	b	30011adc <lwip_setsockopt+0x1c0>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
30011a44:	e59d3004 	ldr	r3, [sp, #4]
30011a48:	e2433001 	sub	r3, r3, #1
30011a4c:	e3530001 	cmp	r3, #1
30011a50:	8a000006 	bhi	30011a70 <lwip_setsockopt+0x154>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
30011a54:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
30011a58:	e3530003 	cmp	r3, #3
30011a5c:	8a000001 	bhi	30011a68 <lwip_setsockopt+0x14c>
        err = EINVAL;
30011a60:	e3a03016 	mov	r3, #22
30011a64:	e58d3034 	str	r3, [sp, #52]	; 0x34
      }
      break;
30011a68:	e1a00000 	nop			; (mov r0, r0)
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
30011a6c:	ea00001a 	b	30011adc <lwip_setsockopt+0x1c0>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
30011a70:	e3a0305c 	mov	r3, #92	; 0x5c
30011a74:	e58d3034 	str	r3, [sp, #52]	; 0x34
    }  /* switch (optname) */
    break;
30011a78:	ea000017 	b	30011adc <lwip_setsockopt+0x1c0>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
30011a7c:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
30011a80:	e3530003 	cmp	r3, #3
30011a84:	8a000002 	bhi	30011a94 <lwip_setsockopt+0x178>
      err = EINVAL;
30011a88:	e3a03016 	mov	r3, #22
30011a8c:	e58d3034 	str	r3, [sp, #52]	; 0x34
      break;
30011a90:	ea000011 	b	30011adc <lwip_setsockopt+0x1c0>
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
30011a94:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011a98:	e5933000 	ldr	r3, [r3]
30011a9c:	e5d33000 	ldrb	r3, [r3]
30011aa0:	e3530010 	cmp	r3, #16
30011aa4:	0a000001 	beq	30011ab0 <lwip_setsockopt+0x194>
      return 0;
30011aa8:	e3a03000 	mov	r3, #0
30011aac:	ea000037 	b	30011b90 <lwip_setsockopt+0x274>

    switch (optname) {
30011ab0:	e59d3004 	ldr	r3, [sp, #4]
30011ab4:	e2433001 	sub	r3, r3, #1
30011ab8:	e3530001 	cmp	r3, #1
30011abc:	8a000001 	bhi	30011ac8 <lwip_setsockopt+0x1ac>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
30011ac0:	e1a00000 	nop			; (mov r0, r0)
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
30011ac4:	ea000004 	b	30011adc <lwip_setsockopt+0x1c0>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
30011ac8:	e3a0305c 	mov	r3, #92	; 0x5c
30011acc:	e58d3034 	str	r3, [sp, #52]	; 0x34
    }  /* switch (optname) */
    break;
30011ad0:	ea000001 	b	30011adc <lwip_setsockopt+0x1c0>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
30011ad4:	e3a0305c 	mov	r3, #92	; 0x5c
30011ad8:	e58d3034 	str	r3, [sp, #52]	; 0x34
  }  /* switch (level) */


  if (err != ERR_OK) {
30011adc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30011ae0:	e3530000 	cmp	r3, #0
30011ae4:	0a000004 	beq	30011afc <lwip_setsockopt+0x1e0>
    sock_set_errno(sock, err);
30011ae8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011aec:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
30011af0:	e5832010 	str	r2, [r3, #16]
    return -1;
30011af4:	e3e03000 	mvn	r3, #0
30011af8:	ea000024 	b	30011b90 <lwip_setsockopt+0x274>
  }


  /* Now do the actual option processing */
  data.sock = sock;
30011afc:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011b00:	e58d3014 	str	r3, [sp, #20]
  data.level = level;
30011b04:	e59d3008 	ldr	r3, [sp, #8]
30011b08:	e58d301c 	str	r3, [sp, #28]
  data.optname = optname;
30011b0c:	e59d3004 	ldr	r3, [sp, #4]
30011b10:	e58d3020 	str	r3, [sp, #32]
  data.optval = (void*)optval;
30011b14:	e59d3000 	ldr	r3, [sp]
30011b18:	e58d3024 	str	r3, [sp, #36]	; 0x24
  data.optlen = &optlen;
30011b1c:	e28d3040 	add	r3, sp, #64	; 0x40
30011b20:	e58d3028 	str	r3, [sp, #40]	; 0x28
  data.err = err;
30011b24:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30011b28:	e20330ff 	and	r3, r3, #255	; 0xff
30011b2c:	e5cd302c 	strb	r3, [sp, #44]	; 0x2c
  tcpip_callback(lwip_setsockopt_internal, &data);
30011b30:	e28d3014 	add	r3, sp, #20
30011b34:	e59f0064 	ldr	r0, [pc, #100]	; 30011ba0 <lwip_setsockopt+0x284>
30011b38:	e1a01003 	mov	r1, r3
30011b3c:	e3a02001 	mov	r2, #1
30011b40:	eb00021d 	bl	300123bc <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
30011b44:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011b48:	e5933000 	ldr	r3, [r3]
30011b4c:	e593300c 	ldr	r3, [r3, #12]
30011b50:	e1a00003 	mov	r0, r3
30011b54:	e3a01000 	mov	r1, #0
30011b58:	ebffeb7a 	bl	3000c948 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
30011b5c:	e5dd302c 	ldrb	r3, [sp, #44]	; 0x2c
30011b60:	e1a03c03 	lsl	r3, r3, #24
30011b64:	e1a03c43 	asr	r3, r3, #24
30011b68:	e58d3034 	str	r3, [sp, #52]	; 0x34

  sock_set_errno(sock, err);
30011b6c:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30011b70:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
30011b74:	e5832010 	str	r2, [r3, #16]
  return err ? -1 : 0;
30011b78:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30011b7c:	e3530000 	cmp	r3, #0
30011b80:	0a000001 	beq	30011b8c <lwip_setsockopt+0x270>
30011b84:	e3e03000 	mvn	r3, #0
30011b88:	ea000000 	b	30011b90 <lwip_setsockopt+0x274>
30011b8c:	e3a03000 	mov	r3, #0
}
30011b90:	e1a00003 	mov	r0, r3
30011b94:	e28dd03c 	add	sp, sp, #60	; 0x3c
30011b98:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30011b9c:	e12fff1e 	bx	lr
30011ba0:	30011ba4 	.word	0x30011ba4

30011ba4 <lwip_setsockopt_internal>:

static void
lwip_setsockopt_internal(void *arg)
{
30011ba4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30011ba8:	e24dd024 	sub	sp, sp, #36	; 0x24
30011bac:	e58d0004 	str	r0, [sp, #4]
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);

  data = (struct lwip_setgetsockopt_data*)arg;
30011bb0:	e59d3004 	ldr	r3, [sp, #4]
30011bb4:	e58d301c 	str	r3, [sp, #28]
  sock = data->sock;
30011bb8:	e59d301c 	ldr	r3, [sp, #28]
30011bbc:	e5933000 	ldr	r3, [r3]
30011bc0:	e58d300c 	str	r3, [sp, #12]
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
30011bc4:	e59d301c 	ldr	r3, [sp, #28]
30011bc8:	e5933008 	ldr	r3, [r3, #8]
30011bcc:	e58d3010 	str	r3, [sp, #16]
  optname = data->optname;
30011bd0:	e59d301c 	ldr	r3, [sp, #28]
30011bd4:	e593300c 	ldr	r3, [r3, #12]
30011bd8:	e58d3014 	str	r3, [sp, #20]
  optval = data->optval;
30011bdc:	e59d301c 	ldr	r3, [sp, #28]
30011be0:	e5933010 	ldr	r3, [r3, #16]
30011be4:	e58d3018 	str	r3, [sp, #24]

  switch (level) {
30011be8:	e59d3010 	ldr	r3, [sp, #16]
30011bec:	e3530006 	cmp	r3, #6
30011bf0:	0a00006a 	beq	30011da0 <lwip_setsockopt_internal+0x1fc>
30011bf4:	e3a02eff 	mov	r2, #4080	; 0xff0
30011bf8:	e282200f 	add	r2, r2, #15
30011bfc:	e1530002 	cmp	r3, r2
30011c00:	0a000002 	beq	30011c10 <lwip_setsockopt_internal+0x6c>
30011c04:	e3530000 	cmp	r3, #0
30011c08:	0a00004e 	beq	30011d48 <lwip_setsockopt_internal+0x1a4>
30011c0c:	ea00008c 	b	30011e44 <lwip_setsockopt_internal+0x2a0>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
30011c10:	e59d3014 	ldr	r3, [sp, #20]
30011c14:	e3530020 	cmp	r3, #32
30011c18:	0a000005 	beq	30011c34 <lwip_setsockopt_internal+0x90>
30011c1c:	e3a02a01 	mov	r2, #4096	; 0x1000
30011c20:	e282200a 	add	r2, r2, #10
30011c24:	e1530002 	cmp	r3, r2
30011c28:	0a00002d 	beq	30011ce4 <lwip_setsockopt_internal+0x140>
30011c2c:	e3530008 	cmp	r3, #8
30011c30:	1a000080 	bne	30011e38 <lwip_setsockopt_internal+0x294>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
30011c34:	e59d3018 	ldr	r3, [sp, #24]
30011c38:	e5933000 	ldr	r3, [r3]
30011c3c:	e3530000 	cmp	r3, #0
30011c40:	0a000011 	beq	30011c8c <lwip_setsockopt_internal+0xe8>
        sock->conn->pcb.ip->so_options |= optname;
30011c44:	e59d300c 	ldr	r3, [sp, #12]
30011c48:	e5933000 	ldr	r3, [r3]
30011c4c:	e5933004 	ldr	r3, [r3, #4]
30011c50:	e59d200c 	ldr	r2, [sp, #12]
30011c54:	e5922000 	ldr	r2, [r2]
30011c58:	e5922004 	ldr	r2, [r2, #4]
30011c5c:	e1d220b8 	ldrh	r2, [r2, #8]
30011c60:	e1a01002 	mov	r1, r2
30011c64:	e59d2014 	ldr	r2, [sp, #20]
30011c68:	e1a02802 	lsl	r2, r2, #16
30011c6c:	e1a02822 	lsr	r2, r2, #16
30011c70:	e1812002 	orr	r2, r1, r2
30011c74:	e1a02802 	lsl	r2, r2, #16
30011c78:	e1a02822 	lsr	r2, r2, #16
30011c7c:	e1a02802 	lsl	r2, r2, #16
30011c80:	e1a02822 	lsr	r2, r2, #16
30011c84:	e1c320b8 	strh	r2, [r3, #8]
30011c88:	ea000013 	b	30011cdc <lwip_setsockopt_internal+0x138>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
30011c8c:	e59d300c 	ldr	r3, [sp, #12]
30011c90:	e5933000 	ldr	r3, [r3]
30011c94:	e5933004 	ldr	r3, [r3, #4]
30011c98:	e59d200c 	ldr	r2, [sp, #12]
30011c9c:	e5922000 	ldr	r2, [r2]
30011ca0:	e5922004 	ldr	r2, [r2, #4]
30011ca4:	e1d220b8 	ldrh	r2, [r2, #8]
30011ca8:	e1a01002 	mov	r1, r2
30011cac:	e59d2014 	ldr	r2, [sp, #20]
30011cb0:	e1a02802 	lsl	r2, r2, #16
30011cb4:	e1a02822 	lsr	r2, r2, #16
30011cb8:	e1e02002 	mvn	r2, r2
30011cbc:	e1a02802 	lsl	r2, r2, #16
30011cc0:	e1a02822 	lsr	r2, r2, #16
30011cc4:	e0012002 	and	r2, r1, r2
30011cc8:	e1a02802 	lsl	r2, r2, #16
30011ccc:	e1a02822 	lsr	r2, r2, #16
30011cd0:	e1a02802 	lsl	r2, r2, #16
30011cd4:	e1a02822 	lsr	r2, r2, #16
30011cd8:	e1c320b8 	strh	r2, [r3, #8]
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
30011cdc:	e1a00000 	nop			; (mov r0, r0)
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
30011ce0:	ea000057 	b	30011e44 <lwip_setsockopt_internal+0x2a0>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
30011ce4:	e59d3018 	ldr	r3, [sp, #24]
30011ce8:	e5933000 	ldr	r3, [r3]
30011cec:	e3530000 	cmp	r3, #0
30011cf0:	0a00000a 	beq	30011d20 <lwip_setsockopt_internal+0x17c>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
30011cf4:	e59d300c 	ldr	r3, [sp, #12]
30011cf8:	e5933000 	ldr	r3, [r3]
30011cfc:	e5933004 	ldr	r3, [r3, #4]
30011d00:	e59d200c 	ldr	r2, [sp, #12]
30011d04:	e5922000 	ldr	r2, [r2]
30011d08:	e5922004 	ldr	r2, [r2, #4]
30011d0c:	e5d22010 	ldrb	r2, [r2, #16]
30011d10:	e3822001 	orr	r2, r2, #1
30011d14:	e20220ff 	and	r2, r2, #255	; 0xff
30011d18:	e5c32010 	strb	r2, [r3, #16]
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
30011d1c:	ea000048 	b	30011e44 <lwip_setsockopt_internal+0x2a0>
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
30011d20:	e59d300c 	ldr	r3, [sp, #12]
30011d24:	e5933000 	ldr	r3, [r3]
30011d28:	e5932004 	ldr	r2, [r3, #4]
30011d2c:	e59d300c 	ldr	r3, [sp, #12]
30011d30:	e5933000 	ldr	r3, [r3]
30011d34:	e5933004 	ldr	r3, [r3, #4]
30011d38:	e5d33010 	ldrb	r3, [r3, #16]
30011d3c:	e20330fe 	and	r3, r3, #254	; 0xfe
30011d40:	e5c23010 	strb	r3, [r2, #16]
      }
      break;
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
30011d44:	ea00003e 	b	30011e44 <lwip_setsockopt_internal+0x2a0>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
30011d48:	e59d3014 	ldr	r3, [sp, #20]
30011d4c:	e3530001 	cmp	r3, #1
30011d50:	0a00000a 	beq	30011d80 <lwip_setsockopt_internal+0x1dc>
30011d54:	e3530002 	cmp	r3, #2
30011d58:	1a000038 	bne	30011e40 <lwip_setsockopt_internal+0x29c>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
30011d5c:	e59d300c 	ldr	r3, [sp, #12]
30011d60:	e5933000 	ldr	r3, [r3]
30011d64:	e5933004 	ldr	r3, [r3, #4]
30011d68:	e59d2018 	ldr	r2, [sp, #24]
30011d6c:	e5922000 	ldr	r2, [r2]
30011d70:	e20220ff 	and	r2, r2, #255	; 0xff
30011d74:	e5c3200b 	strb	r2, [r3, #11]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
30011d78:	e1a00000 	nop			; (mov r0, r0)
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
30011d7c:	ea000030 	b	30011e44 <lwip_setsockopt_internal+0x2a0>
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
30011d80:	e59d300c 	ldr	r3, [sp, #12]
30011d84:	e5933000 	ldr	r3, [r3]
30011d88:	e5933004 	ldr	r3, [r3, #4]
30011d8c:	e59d2018 	ldr	r2, [sp, #24]
30011d90:	e5922000 	ldr	r2, [r2]
30011d94:	e20220ff 	and	r2, r2, #255	; 0xff
30011d98:	e5c3200a 	strb	r2, [r3, #10]
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
30011d9c:	ea000028 	b	30011e44 <lwip_setsockopt_internal+0x2a0>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
30011da0:	e59d3014 	ldr	r3, [sp, #20]
30011da4:	e3530001 	cmp	r3, #1
30011da8:	0a000002 	beq	30011db8 <lwip_setsockopt_internal+0x214>
30011dac:	e3530002 	cmp	r3, #2
30011db0:	0a000019 	beq	30011e1c <lwip_setsockopt_internal+0x278>
30011db4:	ea000022 	b	30011e44 <lwip_setsockopt_internal+0x2a0>
    case TCP_NODELAY:
      if (*(int*)optval) {
30011db8:	e59d3018 	ldr	r3, [sp, #24]
30011dbc:	e5933000 	ldr	r3, [r3]
30011dc0:	e3530000 	cmp	r3, #0
30011dc4:	0a00000a 	beq	30011df4 <lwip_setsockopt_internal+0x250>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
30011dc8:	e59d300c 	ldr	r3, [sp, #12]
30011dcc:	e5933000 	ldr	r3, [r3]
30011dd0:	e5933004 	ldr	r3, [r3, #4]
30011dd4:	e59d200c 	ldr	r2, [sp, #12]
30011dd8:	e5922000 	ldr	r2, [r2]
30011ddc:	e5922004 	ldr	r2, [r2, #4]
30011de0:	e5d2201c 	ldrb	r2, [r2, #28]
30011de4:	e3822040 	orr	r2, r2, #64	; 0x40
30011de8:	e20220ff 	and	r2, r2, #255	; 0xff
30011dec:	e5c3201c 	strb	r2, [r3, #28]
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
30011df0:	ea000013 	b	30011e44 <lwip_setsockopt_internal+0x2a0>
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
30011df4:	e59d300c 	ldr	r3, [sp, #12]
30011df8:	e5933000 	ldr	r3, [r3]
30011dfc:	e5932004 	ldr	r2, [r3, #4]
30011e00:	e59d300c 	ldr	r3, [sp, #12]
30011e04:	e5933000 	ldr	r3, [r3]
30011e08:	e5933004 	ldr	r3, [r3, #4]
30011e0c:	e5d3301c 	ldrb	r3, [r3, #28]
30011e10:	e20330bf 	and	r3, r3, #191	; 0xbf
30011e14:	e5c2301c 	strb	r3, [r2, #28]
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
30011e18:	ea000009 	b	30011e44 <lwip_setsockopt_internal+0x2a0>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
30011e1c:	e59d300c 	ldr	r3, [sp, #12]
30011e20:	e5933000 	ldr	r3, [r3]
30011e24:	e5933004 	ldr	r3, [r3, #4]
30011e28:	e59d2018 	ldr	r2, [sp, #24]
30011e2c:	e5922000 	ldr	r2, [r2]
30011e30:	e5832098 	str	r2, [r3, #152]	; 0x98
30011e34:	ea000002 	b	30011e44 <lwip_setsockopt_internal+0x2a0>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
30011e38:	e1a00000 	nop			; (mov r0, r0)
30011e3c:	ea000000 	b	30011e44 <lwip_setsockopt_internal+0x2a0>
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
30011e40:	e1a00000 	nop			; (mov r0, r0)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
30011e44:	e59d300c 	ldr	r3, [sp, #12]
30011e48:	e5933000 	ldr	r3, [r3]
30011e4c:	e593300c 	ldr	r3, [r3, #12]
30011e50:	e1a00003 	mov	r0, r3
30011e54:	ebffeab3 	bl	3000c928 <sys_sem_signal>
}
30011e58:	e28dd024 	add	sp, sp, #36	; 0x24
30011e5c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30011e60:	e12fff1e 	bx	lr

30011e64 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
30011e64:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30011e68:	e24dd024 	sub	sp, sp, #36	; 0x24
30011e6c:	e58d000c 	str	r0, [sp, #12]
30011e70:	e58d1008 	str	r1, [sp, #8]
30011e74:	e58d2004 	str	r2, [sp, #4]
  struct lwip_socket *sock = get_socket(s);
30011e78:	e59d000c 	ldr	r0, [sp, #12]
30011e7c:	ebfff5e6 	bl	3000f61c <get_socket>
30011e80:	e1a03000 	mov	r3, r0
30011e84:	e58d3014 	str	r3, [sp, #20]
  u16_t buflen = 0;
30011e88:	e3a03000 	mov	r3, #0
30011e8c:	e1cd31ba 	strh	r3, [sp, #26]

  if (!sock)
30011e90:	e59d3014 	ldr	r3, [sp, #20]
30011e94:	e3530000 	cmp	r3, #0
30011e98:	1a000001 	bne	30011ea4 <lwip_ioctl+0x40>
    return -1;
30011e9c:	e3e03000 	mvn	r3, #0
30011ea0:	ea000056 	b	30012000 <lwip_ioctl+0x19c>

  switch (cmd) {
30011ea4:	e59d2008 	ldr	r2, [sp, #8]
30011ea8:	e3a03a46 	mov	r3, #286720	; 0x46000
30011eac:	e2833e67 	add	r3, r3, #1648	; 0x670
30011eb0:	e283313a 	add	r3, r3, #-2147483634	; 0x8000000e
30011eb4:	e1520003 	cmp	r2, r3
30011eb8:	0a000031 	beq	30011f84 <lwip_ioctl+0x120>
30011ebc:	e3a03a46 	mov	r3, #286720	; 0x46000
30011ec0:	e2833e67 	add	r3, r3, #1648	; 0x670
30011ec4:	e283313d 	add	r3, r3, #1073741839	; 0x4000000f
30011ec8:	e1520003 	cmp	r2, r3
30011ecc:	1a000047 	bne	30011ff0 <lwip_ioctl+0x18c>
  case FIONREAD:
    if (!argp) {
30011ed0:	e59d3004 	ldr	r3, [sp, #4]
30011ed4:	e3530000 	cmp	r3, #0
30011ed8:	1a000004 	bne	30011ef0 <lwip_ioctl+0x8c>
      sock_set_errno(sock, EINVAL);
30011edc:	e59d3014 	ldr	r3, [sp, #20]
30011ee0:	e3a02016 	mov	r2, #22
30011ee4:	e5832010 	str	r2, [r3, #16]
      return -1;
30011ee8:	e3e03000 	mvn	r3, #0
30011eec:	ea000043 	b	30012000 <lwip_ioctl+0x19c>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
30011ef0:	ebffbdff 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30011ef4:	e1a03000 	mov	r3, r0
30011ef8:	e58d301c 	str	r3, [sp, #28]
30011efc:	e59d3004 	ldr	r3, [sp, #4]
30011f00:	e59d2014 	ldr	r2, [sp, #20]
30011f04:	e5922000 	ldr	r2, [r2]
30011f08:	e1d221bc 	ldrh	r2, [r2, #28]
30011f0c:	e1c320b0 	strh	r2, [r3]
30011f10:	e59d001c 	ldr	r0, [sp, #28]
30011f14:	ebffbdf4 	bl	300016ec <HAL_INTR_RESTORE>

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
30011f18:	e59d3014 	ldr	r3, [sp, #20]
30011f1c:	e5933004 	ldr	r3, [r3, #4]
30011f20:	e3530000 	cmp	r3, #0
30011f24:	0a000011 	beq	30011f70 <lwip_ioctl+0x10c>
      buflen = netbuf_len(sock->lastdata);
30011f28:	e59d3014 	ldr	r3, [sp, #20]
30011f2c:	e5933004 	ldr	r3, [r3, #4]
30011f30:	e5933000 	ldr	r3, [r3]
30011f34:	e1d330b8 	ldrh	r3, [r3, #8]
30011f38:	e1cd31ba 	strh	r3, [sp, #26]
      buflen -= sock->lastoffset;
30011f3c:	e59d3014 	ldr	r3, [sp, #20]
30011f40:	e1d330b8 	ldrh	r3, [r3, #8]
30011f44:	e1dd21ba 	ldrh	r2, [sp, #26]
30011f48:	e0633002 	rsb	r3, r3, r2
30011f4c:	e1cd31ba 	strh	r3, [sp, #26]

      *((u16_t*)argp) += buflen;
30011f50:	e59d3004 	ldr	r3, [sp, #4]
30011f54:	e59d2004 	ldr	r2, [sp, #4]
30011f58:	e1d210b0 	ldrh	r1, [r2]
30011f5c:	e1dd21ba 	ldrh	r2, [sp, #26]
30011f60:	e0812002 	add	r2, r1, r2
30011f64:	e1a02802 	lsl	r2, r2, #16
30011f68:	e1a02822 	lsr	r2, r2, #16
30011f6c:	e1c320b0 	strh	r2, [r3]
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
30011f70:	e59d3014 	ldr	r3, [sp, #20]
30011f74:	e3a02000 	mov	r2, #0
30011f78:	e5832010 	str	r2, [r3, #16]
    return 0;
30011f7c:	e3a03000 	mov	r3, #0
30011f80:	ea00001e 	b	30012000 <lwip_ioctl+0x19c>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
30011f84:	e59d3004 	ldr	r3, [sp, #4]
30011f88:	e3530000 	cmp	r3, #0
30011f8c:	0a00000b 	beq	30011fc0 <lwip_ioctl+0x15c>
30011f90:	e59d3004 	ldr	r3, [sp, #4]
30011f94:	e5933000 	ldr	r3, [r3]
30011f98:	e3530000 	cmp	r3, #0
30011f9c:	0a000007 	beq	30011fc0 <lwip_ioctl+0x15c>
      sock->flags |= O_NONBLOCK;
30011fa0:	e59d3014 	ldr	r3, [sp, #20]
30011fa4:	e1d330be 	ldrh	r3, [r3, #14]
30011fa8:	e3833b02 	orr	r3, r3, #2048	; 0x800
30011fac:	e1a03803 	lsl	r3, r3, #16
30011fb0:	e1a02823 	lsr	r2, r3, #16
30011fb4:	e59d3014 	ldr	r3, [sp, #20]
30011fb8:	e1c320be 	strh	r2, [r3, #14]
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
    return 0;

  case FIONBIO:
    if (argp && *(u32_t*)argp)
30011fbc:	ea000006 	b	30011fdc <lwip_ioctl+0x178>
      sock->flags |= O_NONBLOCK;
    else
      sock->flags &= ~O_NONBLOCK;
30011fc0:	e59d3014 	ldr	r3, [sp, #20]
30011fc4:	e1d330be 	ldrh	r3, [r3, #14]
30011fc8:	e3c33b02 	bic	r3, r3, #2048	; 0x800
30011fcc:	e1a03803 	lsl	r3, r3, #16
30011fd0:	e1a03823 	lsr	r3, r3, #16
30011fd4:	e59d2014 	ldr	r2, [sp, #20]
30011fd8:	e1c230be 	strh	r3, [r2, #14]
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
30011fdc:	e59d3014 	ldr	r3, [sp, #20]
30011fe0:	e3a02000 	mov	r2, #0
30011fe4:	e5832010 	str	r2, [r3, #16]
    return 0;
30011fe8:	e3a03000 	mov	r3, #0
30011fec:	ea000003 	b	30012000 <lwip_ioctl+0x19c>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
30011ff0:	e59d3014 	ldr	r3, [sp, #20]
30011ff4:	e3a02026 	mov	r2, #38	; 0x26
30011ff8:	e5832010 	str	r2, [r3, #16]
    return -1;
30011ffc:	e3e03000 	mvn	r3, #0
  } /* switch (cmd) */
}
30012000:	e1a00003 	mov	r0, r3
30012004:	e28dd024 	add	sp, sp, #36	; 0x24
30012008:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001200c:	e12fff1e 	bx	lr

30012010 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
30012010:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30012014:	e24dd00c 	sub	sp, sp, #12
30012018:	e58d0004 	str	r0, [sp, #4]
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
3001201c:	eb00150c 	bl	30017454 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
30012020:	e59f3044 	ldr	r3, [pc, #68]	; 3001206c <tcpip_tcp_timer+0x5c>
30012024:	e5933000 	ldr	r3, [r3]
30012028:	e3530000 	cmp	r3, #0
3001202c:	1a000003 	bne	30012040 <tcpip_tcp_timer+0x30>
30012030:	e59f3038 	ldr	r3, [pc, #56]	; 30012070 <tcpip_tcp_timer+0x60>
30012034:	e5933000 	ldr	r3, [r3]
30012038:	e3530000 	cmp	r3, #0
3001203c:	0a000004 	beq	30012054 <tcpip_tcp_timer+0x44>
    /* restart timer */
     sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
30012040:	e3a000fa 	mov	r0, #250	; 0xfa
30012044:	e59f1028 	ldr	r1, [pc, #40]	; 30012074 <tcpip_tcp_timer+0x64>
30012048:	e3a02000 	mov	r2, #0
3001204c:	eb001401 	bl	30017058 <sys_timeout>
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
30012050:	ea000002 	b	30012060 <tcpip_tcp_timer+0x50>
    /* restart timer */
     sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
30012054:	e59f301c 	ldr	r3, [pc, #28]	; 30012078 <tcpip_tcp_timer+0x68>
30012058:	e3a02000 	mov	r2, #0
3001205c:	e5832000 	str	r2, [r3]
  }
}
30012060:	e28dd00c 	add	sp, sp, #12
30012064:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30012068:	e12fff1e 	bx	lr
3001206c:	300eaa38 	.word	0x300eaa38
30012070:	302be508 	.word	0x302be508
30012074:	30012010 	.word	0x30012010
30012078:	300ca64c 	.word	0x300ca64c

3001207c <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
3001207c:	e92d4008 	push	{r3, lr}
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
30012080:	e59f304c 	ldr	r3, [pc, #76]	; 300120d4 <tcp_timer_needed+0x58>
30012084:	e5933000 	ldr	r3, [r3]
30012088:	e3530000 	cmp	r3, #0
3001208c:	1a00000e 	bne	300120cc <tcp_timer_needed+0x50>
30012090:	e59f3040 	ldr	r3, [pc, #64]	; 300120d8 <tcp_timer_needed+0x5c>
30012094:	e5933000 	ldr	r3, [r3]
30012098:	e3530000 	cmp	r3, #0
3001209c:	1a000003 	bne	300120b0 <tcp_timer_needed+0x34>
300120a0:	e59f3034 	ldr	r3, [pc, #52]	; 300120dc <tcp_timer_needed+0x60>
300120a4:	e5933000 	ldr	r3, [r3]
300120a8:	e3530000 	cmp	r3, #0
300120ac:	0a000006 	beq	300120cc <tcp_timer_needed+0x50>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
300120b0:	e59f301c 	ldr	r3, [pc, #28]	; 300120d4 <tcp_timer_needed+0x58>
300120b4:	e3a02001 	mov	r2, #1
300120b8:	e5832000 	str	r2, [r3]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
300120bc:	e3a000fa 	mov	r0, #250	; 0xfa
300120c0:	e59f1018 	ldr	r1, [pc, #24]	; 300120e0 <tcp_timer_needed+0x64>
300120c4:	e3a02000 	mov	r2, #0
300120c8:	eb0013e2 	bl	30017058 <sys_timeout>
  }
}
300120cc:	e8bd4008 	pop	{r3, lr}
300120d0:	e12fff1e 	bx	lr
300120d4:	300ca64c 	.word	0x300ca64c
300120d8:	300eaa38 	.word	0x300eaa38
300120dc:	302be508 	.word	0x302be508
300120e0:	30012010 	.word	0x30012010

300120e4 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
300120e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300120e8:	e24dd00c 	sub	sp, sp, #12
300120ec:	e58d0004 	str	r0, [sp, #4]
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
300120f0:	eb003ce7 	bl	30021494 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
300120f4:	e3a00d4e 	mov	r0, #4992	; 0x1380
300120f8:	e2800008 	add	r0, r0, #8
300120fc:	e59f1010 	ldr	r1, [pc, #16]	; 30012114 <arp_timer+0x30>
30012100:	e3a02000 	mov	r2, #0
30012104:	eb0013d3 	bl	30017058 <sys_timeout>
}
30012108:	e28dd00c 	add	sp, sp, #12
3001210c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30012110:	e12fff1e 	bx	lr
30012114:	300120e4 	.word	0x300120e4

30012118 <tcpip_thread>:
 *
 * @param arg unused argument
 */
void
tcpip_thread(void *arg)
{
30012118:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001211c:	e24dd014 	sub	sp, sp, #20
30012120:	e58d0004 	str	r0, [sp, #4]

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
30012124:	e3a00d4e 	mov	r0, #4992	; 0x1380
30012128:	e2800008 	add	r0, r0, #8
3001212c:	e59f11b0 	ldr	r1, [pc, #432]	; 300122e4 <tcpip_thread+0x1cc>
30012130:	e3a02000 	mov	r2, #0
30012134:	eb0013c7 	bl	30017058 <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
30012138:	e59f31a8 	ldr	r3, [pc, #424]	; 300122e8 <tcpip_thread+0x1d0>
3001213c:	e5933000 	ldr	r3, [r3]
30012140:	e3530000 	cmp	r3, #0
30012144:	0a000006 	beq	30012164 <tcpip_thread+0x4c>
    tcpip_init_done(tcpip_init_done_arg);
30012148:	e59f3198 	ldr	r3, [pc, #408]	; 300122e8 <tcpip_thread+0x1d0>
3001214c:	e5933000 	ldr	r3, [r3]
30012150:	e59f2194 	ldr	r2, [pc, #404]	; 300122ec <tcpip_thread+0x1d4>
30012154:	e5922000 	ldr	r2, [r2]
30012158:	e1a00002 	mov	r0, r2
3001215c:	e1a0e00f 	mov	lr, pc
30012160:	e12fff13 	bx	r3
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
30012164:	e59f3184 	ldr	r3, [pc, #388]	; 300122f0 <tcpip_thread+0x1d8>
30012168:	e5932000 	ldr	r2, [r3]
3001216c:	e28d300c 	add	r3, sp, #12
30012170:	e1a00002 	mov	r0, r2
30012174:	e1a01003 	mov	r1, r3
30012178:	eb001309 	bl	30016da4 <sys_mbox_fetch>
    // teset by pegasus
    //if (msg->msg.apimsg->msg.msg.w.dataptr == &htmldata)
    //  acoral_print("\nhtmldata:\n");//*,msg->msg.apimsg->msg.msg.w.dataptr);
    switch (msg->type) {
3001217c:	e59d300c 	ldr	r3, [sp, #12]
30012180:	e5d33000 	ldrb	r3, [r3]
30012184:	e3530003 	cmp	r3, #3
30012188:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3001218c:	ea00004e 	b	300122cc <tcpip_thread+0x1b4>
30012190:	300121a0 	.word	0x300121a0
30012194:	300121c8 	.word	0x300121c8
30012198:	30012230 	.word	0x30012230
3001219c:	30012260 	.word	0x30012260
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      //lwip_printf("\r\n1\r\n");
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
300121a0:	e59d300c 	ldr	r3, [sp, #12]
300121a4:	e5933008 	ldr	r3, [r3, #8]
300121a8:	e5933000 	ldr	r3, [r3]
300121ac:	e59d200c 	ldr	r2, [sp, #12]
300121b0:	e5922008 	ldr	r2, [r2, #8]
300121b4:	e2822004 	add	r2, r2, #4
300121b8:	e1a00002 	mov	r0, r2
300121bc:	e1a0e00f 	mov	lr, pc
300121c0:	e12fff13 	bx	r3
      //acoral_print("\r\n%x\r\n",msg->msg.apimsg->function);

      //acoral_print("MSG_API:%s",msg->msg.apimsg->msg.w.dataptr);
      
      break;
300121c4:	ea000045 	b	300122e0 <tcpip_thread+0x1c8>

    case TCPIP_MSG_INPKT:
      //lwip_printf("\r\n2\r\n");
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
300121c8:	e59d300c 	ldr	r3, [sp, #12]
300121cc:	e593300c 	ldr	r3, [r3, #12]
300121d0:	e5d3302a 	ldrb	r3, [r3, #42]	; 0x2a
300121d4:	e2033020 	and	r3, r3, #32
300121d8:	e3530000 	cmp	r3, #0
300121dc:	0a000007 	beq	30012200 <tcpip_thread+0xe8>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
300121e0:	e59d300c 	ldr	r3, [sp, #12]
300121e4:	e5932008 	ldr	r2, [r3, #8]
300121e8:	e59d300c 	ldr	r3, [sp, #12]
300121ec:	e593300c 	ldr	r3, [r3, #12]
300121f0:	e1a00002 	mov	r0, r2
300121f4:	e1a01003 	mov	r1, r3
300121f8:	eb0043c2 	bl	30023108 <ethernet_input>
300121fc:	ea000006 	b	3001221c <tcpip_thread+0x104>
      } else
#endif /* LWIP_ARP */
      {//acoral_print("\nip_input:2==2\n");
       ip_input(msg->msg.inp.p, msg->msg.inp.netif);
30012200:	e59d300c 	ldr	r3, [sp, #12]
30012204:	e5932008 	ldr	r2, [r3, #8]
30012208:	e59d300c 	ldr	r3, [sp, #12]
3001220c:	e593300c 	ldr	r3, [r3, #12]
30012210:	e1a00002 	mov	r0, r2
30012214:	e1a01003 	mov	r1, r3
30012218:	eb000792 	bl	30014068 <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
3001221c:	e59d300c 	ldr	r3, [sp, #12]
30012220:	e3a00008 	mov	r0, #8
30012224:	e1a01003 	mov	r1, r3
30012228:	eb000ca6 	bl	300154c8 <memp_free>
      break;
3001222c:	ea00002b 	b	300122e0 <tcpip_thread+0x1c8>
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      //lwip_printf("\r\n4\r\n");
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
30012230:	e59d300c 	ldr	r3, [sp, #12]
30012234:	e5933008 	ldr	r3, [r3, #8]
30012238:	e59d200c 	ldr	r2, [sp, #12]
3001223c:	e592200c 	ldr	r2, [r2, #12]
30012240:	e1a00002 	mov	r0, r2
30012244:	e1a0e00f 	mov	lr, pc
30012248:	e12fff13 	bx	r3
      memp_free(MEMP_TCPIP_MSG_API, msg);
3001224c:	e59d300c 	ldr	r3, [sp, #12]
30012250:	e3a00007 	mov	r0, #7
30012254:	e1a01003 	mov	r1, r3
30012258:	eb000c9a 	bl	300154c8 <memp_free>
      break;
3001225c:	ea00001f 	b	300122e0 <tcpip_thread+0x1c8>

    case TCPIP_MSG_TIMEOUT:
      //lwip_printf("\r\n5\r\n");
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
30012260:	e59d300c 	ldr	r3, [sp, #12]
30012264:	e5933008 	ldr	r3, [r3, #8]
30012268:	e3730001 	cmn	r3, #1
3001226c:	0a00000a 	beq	3001229c <tcpip_thread+0x184>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
30012270:	e59d300c 	ldr	r3, [sp, #12]
30012274:	e5931008 	ldr	r1, [r3, #8]
30012278:	e59d300c 	ldr	r3, [sp, #12]
3001227c:	e593200c 	ldr	r2, [r3, #12]
30012280:	e59d300c 	ldr	r3, [sp, #12]
30012284:	e5933010 	ldr	r3, [r3, #16]
30012288:	e1a00001 	mov	r0, r1
3001228c:	e1a01002 	mov	r1, r2
30012290:	e1a02003 	mov	r2, r3
30012294:	eb00136f 	bl	30017058 <sys_timeout>
30012298:	ea000006 	b	300122b8 <tcpip_thread+0x1a0>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
3001229c:	e59d300c 	ldr	r3, [sp, #12]
300122a0:	e593200c 	ldr	r2, [r3, #12]
300122a4:	e59d300c 	ldr	r3, [sp, #12]
300122a8:	e5933010 	ldr	r3, [r3, #16]
300122ac:	e1a00002 	mov	r0, r2
300122b0:	e1a01003 	mov	r1, r3
300122b4:	eb0013db 	bl	30017228 <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
300122b8:	e59d300c 	ldr	r3, [sp, #12]
300122bc:	e3a00007 	mov	r0, #7
300122c0:	e1a01003 	mov	r1, r3
300122c4:	eb000c7f 	bl	300154c8 <memp_free>
      break;
300122c8:	ea000004 	b	300122e0 <tcpip_thread+0x1c8>

    default:
      //lwip_printf("\r\n=======================\r\n");
      pbuf_free(msg->msg.inp.p);
300122cc:	e59d300c 	ldr	r3, [sp, #12]
300122d0:	e5933008 	ldr	r3, [r3, #8]
300122d4:	e1a00003 	mov	r0, r3
300122d8:	eb000fe8 	bl	30016280 <pbuf_free>
      break;
    }
  }
300122dc:	eaffffa0 	b	30012164 <tcpip_thread+0x4c>
300122e0:	eaffff9f 	b	30012164 <tcpip_thread+0x4c>
300122e4:	300120e4 	.word	0x300120e4
300122e8:	300ca640 	.word	0x300ca640
300122ec:	300ca644 	.word	0x300ca644
300122f0:	300ca648 	.word	0x300ca648

300122f4 <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
300122f4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300122f8:	e24dd014 	sub	sp, sp, #20
300122fc:	e58d0004 	str	r0, [sp, #4]
30012300:	e58d1000 	str	r1, [sp]

		}
		lwip_printf("\r\n+++++++++++++++++++++\r\n");
		/**/
	
  if (mbox != SYS_MBOX_NULL) {
30012304:	e59f30ac 	ldr	r3, [pc, #172]	; 300123b8 <tcpip_input+0xc4>
30012308:	e5933000 	ldr	r3, [r3]
3001230c:	e3530000 	cmp	r3, #0
30012310:	0a000021 	beq	3001239c <tcpip_input+0xa8>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
30012314:	e3a00008 	mov	r0, #8
30012318:	eb000c05 	bl	30015334 <memp_malloc>
3001231c:	e1a03000 	mov	r3, r0
30012320:	e58d300c 	str	r3, [sp, #12]
    if (msg == NULL) {
30012324:	e59d300c 	ldr	r3, [sp, #12]
30012328:	e3530000 	cmp	r3, #0
3001232c:	1a000001 	bne	30012338 <tcpip_input+0x44>
      return ERR_MEM;
30012330:	e3a030ff 	mov	r3, #255	; 0xff
30012334:	ea000019 	b	300123a0 <tcpip_input+0xac>
    }

    msg->type = TCPIP_MSG_INPKT;
30012338:	e59d300c 	ldr	r3, [sp, #12]
3001233c:	e3a02001 	mov	r2, #1
30012340:	e5c32000 	strb	r2, [r3]
    msg->msg.inp.p = p;
30012344:	e59d300c 	ldr	r3, [sp, #12]
30012348:	e59d2004 	ldr	r2, [sp, #4]
3001234c:	e5832008 	str	r2, [r3, #8]
    msg->msg.inp.netif = inp;
30012350:	e59d300c 	ldr	r3, [sp, #12]
30012354:	e59d2000 	ldr	r2, [sp]
30012358:	e583200c 	str	r2, [r3, #12]
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
3001235c:	e59f3054 	ldr	r3, [pc, #84]	; 300123b8 <tcpip_input+0xc4>
30012360:	e5933000 	ldr	r3, [r3]
30012364:	e1a00003 	mov	r0, r3
30012368:	e59d100c 	ldr	r1, [sp, #12]
3001236c:	ebffe9b3 	bl	3000ca40 <sys_mbox_trypost>
30012370:	e1a03000 	mov	r3, r0
30012374:	e20330ff 	and	r3, r3, #255	; 0xff
30012378:	e3530000 	cmp	r3, #0
3001237c:	0a000004 	beq	30012394 <tcpip_input+0xa0>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
30012380:	e3a00008 	mov	r0, #8
30012384:	e59d100c 	ldr	r1, [sp, #12]
30012388:	eb000c4e 	bl	300154c8 <memp_free>
      return ERR_MEM;
3001238c:	e3a030ff 	mov	r3, #255	; 0xff
30012390:	ea000002 	b	300123a0 <tcpip_input+0xac>
    }
    return ERR_OK;
30012394:	e3a03000 	mov	r3, #0
30012398:	ea000000 	b	300123a0 <tcpip_input+0xac>
  }
  return ERR_VAL;
3001239c:	e3a030f8 	mov	r3, #248	; 0xf8
300123a0:	e1a03c03 	lsl	r3, r3, #24
300123a4:	e1a03c43 	asr	r3, r3, #24
}
300123a8:	e1a00003 	mov	r0, r3
300123ac:	e28dd014 	add	sp, sp, #20
300123b0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300123b4:	e12fff1e 	bx	lr
300123b8:	300ca648 	.word	0x300ca648

300123bc <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
300123bc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300123c0:	e24dd01c 	sub	sp, sp, #28
300123c4:	e58d000c 	str	r0, [sp, #12]
300123c8:	e58d1008 	str	r1, [sp, #8]
300123cc:	e1a03002 	mov	r3, r2
300123d0:	e5cd3007 	strb	r3, [sp, #7]
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
300123d4:	e59f30d0 	ldr	r3, [pc, #208]	; 300124ac <tcpip_callback_with_block+0xf0>
300123d8:	e5933000 	ldr	r3, [r3]
300123dc:	e3530000 	cmp	r3, #0
300123e0:	0a00002a 	beq	30012490 <tcpip_callback_with_block+0xd4>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
300123e4:	e3a00007 	mov	r0, #7
300123e8:	eb000bd1 	bl	30015334 <memp_malloc>
300123ec:	e1a03000 	mov	r3, r0
300123f0:	e58d3014 	str	r3, [sp, #20]
    if (msg == NULL) {
300123f4:	e59d3014 	ldr	r3, [sp, #20]
300123f8:	e3530000 	cmp	r3, #0
300123fc:	1a000001 	bne	30012408 <tcpip_callback_with_block+0x4c>
      return ERR_MEM;
30012400:	e3a030ff 	mov	r3, #255	; 0xff
30012404:	ea000022 	b	30012494 <tcpip_callback_with_block+0xd8>
    }

    msg->type = TCPIP_MSG_CALLBACK;
30012408:	e59d3014 	ldr	r3, [sp, #20]
3001240c:	e3a02002 	mov	r2, #2
30012410:	e5c32000 	strb	r2, [r3]
    msg->msg.cb.f = f;
30012414:	e59d3014 	ldr	r3, [sp, #20]
30012418:	e59d200c 	ldr	r2, [sp, #12]
3001241c:	e5832008 	str	r2, [r3, #8]
    msg->msg.cb.ctx = ctx;
30012420:	e59d3014 	ldr	r3, [sp, #20]
30012424:	e59d2008 	ldr	r2, [sp, #8]
30012428:	e583200c 	str	r2, [r3, #12]
    if (block) {
3001242c:	e5dd3007 	ldrb	r3, [sp, #7]
30012430:	e3530000 	cmp	r3, #0
30012434:	0a000005 	beq	30012450 <tcpip_callback_with_block+0x94>
      sys_mbox_post(mbox, msg);
30012438:	e59f306c 	ldr	r3, [pc, #108]	; 300124ac <tcpip_callback_with_block+0xf0>
3001243c:	e5933000 	ldr	r3, [r3]
30012440:	e1a00003 	mov	r0, r3
30012444:	e59d1014 	ldr	r1, [sp, #20]
30012448:	ebffe963 	bl	3000c9dc <sys_mbox_post>
3001244c:	ea00000d 	b	30012488 <tcpip_callback_with_block+0xcc>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
30012450:	e59f3054 	ldr	r3, [pc, #84]	; 300124ac <tcpip_callback_with_block+0xf0>
30012454:	e5933000 	ldr	r3, [r3]
30012458:	e1a00003 	mov	r0, r3
3001245c:	e59d1014 	ldr	r1, [sp, #20]
30012460:	ebffe976 	bl	3000ca40 <sys_mbox_trypost>
30012464:	e1a03000 	mov	r3, r0
30012468:	e20330ff 	and	r3, r3, #255	; 0xff
3001246c:	e3530000 	cmp	r3, #0
30012470:	0a000004 	beq	30012488 <tcpip_callback_with_block+0xcc>
        memp_free(MEMP_TCPIP_MSG_API, msg);
30012474:	e3a00007 	mov	r0, #7
30012478:	e59d1014 	ldr	r1, [sp, #20]
3001247c:	eb000c11 	bl	300154c8 <memp_free>
        return ERR_MEM;
30012480:	e3a030ff 	mov	r3, #255	; 0xff
30012484:	ea000002 	b	30012494 <tcpip_callback_with_block+0xd8>
      }
    }
    return ERR_OK;
30012488:	e3a03000 	mov	r3, #0
3001248c:	ea000000 	b	30012494 <tcpip_callback_with_block+0xd8>
  }
  return ERR_VAL;
30012490:	e3a030f8 	mov	r3, #248	; 0xf8
30012494:	e1a03c03 	lsl	r3, r3, #24
30012498:	e1a03c43 	asr	r3, r3, #24
}
3001249c:	e1a00003 	mov	r0, r3
300124a0:	e28dd01c 	add	sp, sp, #28
300124a4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300124a8:	e12fff1e 	bx	lr
300124ac:	300ca648 	.word	0x300ca648

300124b0 <tcpip_timeout>:

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
300124b0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300124b4:	e24dd01c 	sub	sp, sp, #28
300124b8:	e58d000c 	str	r0, [sp, #12]
300124bc:	e58d1008 	str	r1, [sp, #8]
300124c0:	e58d2004 	str	r2, [sp, #4]
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
300124c4:	e59f3094 	ldr	r3, [pc, #148]	; 30012560 <tcpip_timeout+0xb0>
300124c8:	e5933000 	ldr	r3, [r3]
300124cc:	e3530000 	cmp	r3, #0
300124d0:	0a00001b 	beq	30012544 <tcpip_timeout+0x94>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
300124d4:	e3a00007 	mov	r0, #7
300124d8:	eb000b95 	bl	30015334 <memp_malloc>
300124dc:	e1a03000 	mov	r3, r0
300124e0:	e58d3014 	str	r3, [sp, #20]
    if (msg == NULL) {
300124e4:	e59d3014 	ldr	r3, [sp, #20]
300124e8:	e3530000 	cmp	r3, #0
300124ec:	1a000001 	bne	300124f8 <tcpip_timeout+0x48>
      return ERR_MEM;
300124f0:	e3a030ff 	mov	r3, #255	; 0xff
300124f4:	ea000013 	b	30012548 <tcpip_timeout+0x98>
    }

    msg->type = TCPIP_MSG_TIMEOUT;
300124f8:	e59d3014 	ldr	r3, [sp, #20]
300124fc:	e3a02003 	mov	r2, #3
30012500:	e5c32000 	strb	r2, [r3]
    msg->msg.tmo.msecs = msecs;
30012504:	e59d3014 	ldr	r3, [sp, #20]
30012508:	e59d200c 	ldr	r2, [sp, #12]
3001250c:	e5832008 	str	r2, [r3, #8]
    msg->msg.tmo.h = h;
30012510:	e59d3014 	ldr	r3, [sp, #20]
30012514:	e59d2008 	ldr	r2, [sp, #8]
30012518:	e583200c 	str	r2, [r3, #12]
    msg->msg.tmo.arg = arg;
3001251c:	e59d3014 	ldr	r3, [sp, #20]
30012520:	e59d2004 	ldr	r2, [sp, #4]
30012524:	e5832010 	str	r2, [r3, #16]
    sys_mbox_post(mbox, msg);
30012528:	e59f3030 	ldr	r3, [pc, #48]	; 30012560 <tcpip_timeout+0xb0>
3001252c:	e5933000 	ldr	r3, [r3]
30012530:	e1a00003 	mov	r0, r3
30012534:	e59d1014 	ldr	r1, [sp, #20]
30012538:	ebffe927 	bl	3000c9dc <sys_mbox_post>
    return ERR_OK;
3001253c:	e3a03000 	mov	r3, #0
30012540:	ea000000 	b	30012548 <tcpip_timeout+0x98>
  }
  return ERR_VAL;
30012544:	e3a030f8 	mov	r3, #248	; 0xf8
30012548:	e1a03c03 	lsl	r3, r3, #24
3001254c:	e1a03c43 	asr	r3, r3, #24
}
30012550:	e1a00003 	mov	r0, r3
30012554:	e28dd01c 	add	sp, sp, #28
30012558:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001255c:	e12fff1e 	bx	lr
30012560:	300ca648 	.word	0x300ca648

30012564 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
30012564:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30012568:	e24dd024 	sub	sp, sp, #36	; 0x24
3001256c:	e58d0004 	str	r0, [sp, #4]
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
30012570:	e59f306c 	ldr	r3, [pc, #108]	; 300125e4 <tcpip_apimsg+0x80>
30012574:	e5933000 	ldr	r3, [r3]
30012578:	e3530000 	cmp	r3, #0
3001257c:	0a000011 	beq	300125c8 <tcpip_apimsg+0x64>
    msg.type = TCPIP_MSG_API;
30012580:	e3a03000 	mov	r3, #0
30012584:	e5cd300c 	strb	r3, [sp, #12]
    msg.msg.apimsg = apimsg;
30012588:	e59d3004 	ldr	r3, [sp, #4]
3001258c:	e58d3014 	str	r3, [sp, #20]
    //acoral_prints("\r\ntcpip_apimsg_post\r\n");
    sys_mbox_post(mbox, &msg);
30012590:	e59f304c 	ldr	r3, [pc, #76]	; 300125e4 <tcpip_apimsg+0x80>
30012594:	e5932000 	ldr	r2, [r3]
30012598:	e28d300c 	add	r3, sp, #12
3001259c:	e1a00002 	mov	r0, r2
300125a0:	e1a01003 	mov	r1, r3
300125a4:	ebffe90c 	bl	3000c9dc <sys_mbox_post>
    //lwip_printf("\r\n %s \r\n====\r\n", apimsg->msg.msg.w.dataptr);
	//acoral_prints("\r\ntcpip_apimsg_op_completed\r\n");    
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
300125a8:	e59d3004 	ldr	r3, [sp, #4]
300125ac:	e5933004 	ldr	r3, [r3, #4]
300125b0:	e593300c 	ldr	r3, [r3, #12]
300125b4:	e1a00003 	mov	r0, r3
300125b8:	e3a01000 	mov	r1, #0
300125bc:	ebffe8e1 	bl	3000c948 <sys_arch_sem_wait>
    return ERR_OK;
300125c0:	e3a03000 	mov	r3, #0
300125c4:	ea000000 	b	300125cc <tcpip_apimsg+0x68>
  }
  return ERR_VAL;
300125c8:	e3a030f8 	mov	r3, #248	; 0xf8
300125cc:	e1a03c03 	lsl	r3, r3, #24
300125d0:	e1a03c43 	asr	r3, r3, #24
}
300125d4:	e1a00003 	mov	r0, r3
300125d8:	e28dd024 	add	sp, sp, #36	; 0x24
300125dc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300125e0:	e12fff1e 	bx	lr
300125e4:	300ca648 	.word	0x300ca648

300125e8 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
300125e8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300125ec:	e24dd014 	sub	sp, sp, #20
300125f0:	e58d000c 	str	r0, [sp, #12]
300125f4:	e58d1008 	str	r1, [sp, #8]
  lwip_init();
300125f8:	eb000acf 	bl	3001513c <lwip_init>
  tcp_active_pcbs=NULL;
300125fc:	e59f3088 	ldr	r3, [pc, #136]	; 3001268c <tcpip_init+0xa4>
30012600:	e3a02000 	mov	r2, #0
30012604:	e5832000 	str	r2, [r3]
  tcp_tw_pcbs=NULL;
30012608:	e59f3080 	ldr	r3, [pc, #128]	; 30012690 <tcpip_init+0xa8>
3001260c:	e3a02000 	mov	r2, #0
30012610:	e5832000 	str	r2, [r3]
  tcp_tmp_pcb=NULL;
30012614:	e59f3078 	ldr	r3, [pc, #120]	; 30012694 <tcpip_init+0xac>
30012618:	e3a02000 	mov	r2, #0
3001261c:	e5832000 	str	r2, [r3]
  tcp_listen_pcbs.listen_pcbs=NULL;
30012620:	e59f3070 	ldr	r3, [pc, #112]	; 30012698 <tcpip_init+0xb0>
30012624:	e3a02000 	mov	r2, #0
30012628:	e5832000 	str	r2, [r3]
  tcp_listen_pcbs.pcbs=NULL;
3001262c:	e59f3064 	ldr	r3, [pc, #100]	; 30012698 <tcpip_init+0xb0>
30012630:	e3a02000 	mov	r2, #0
30012634:	e5832000 	str	r2, [r3]
  tcpip_init_done = initfunc;
30012638:	e59f305c 	ldr	r3, [pc, #92]	; 3001269c <tcpip_init+0xb4>
3001263c:	e59d200c 	ldr	r2, [sp, #12]
30012640:	e5832000 	str	r2, [r3]
  tcpip_init_done_arg = arg;
30012644:	e59f3054 	ldr	r3, [pc, #84]	; 300126a0 <tcpip_init+0xb8>
30012648:	e59d2008 	ldr	r2, [sp, #8]
3001264c:	e5832000 	str	r2, [r3]
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
30012650:	e3a0000a 	mov	r0, #10
30012654:	ebffe8cc 	bl	3000c98c <sys_mbox_new>
30012658:	e1a02000 	mov	r2, r0
3001265c:	e59f3040 	ldr	r3, [pc, #64]	; 300126a4 <tcpip_init+0xbc>
30012660:	e5832000 	str	r2, [r3]
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  //sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, 81920, 24);
30012664:	e3a03018 	mov	r3, #24
30012668:	e58d3000 	str	r3, [sp]
3001266c:	e59f0034 	ldr	r0, [pc, #52]	; 300126a8 <tcpip_init+0xc0>
30012670:	e59f1034 	ldr	r1, [pc, #52]	; 300126ac <tcpip_init+0xc4>
30012674:	e3a02000 	mov	r2, #0
30012678:	e3a03905 	mov	r3, #81920	; 0x14000
3001267c:	ebffe93a 	bl	3000cb6c <sys_thread_new>
}
30012680:	e28dd014 	add	sp, sp, #20
30012684:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30012688:	e12fff1e 	bx	lr
3001268c:	300eaa38 	.word	0x300eaa38
30012690:	302be508 	.word	0x302be508
30012694:	3012a850 	.word	0x3012a850
30012698:	300eaa78 	.word	0x300eaa78
3001269c:	300ca640 	.word	0x300ca640
300126a0:	300ca644 	.word	0x300ca644
300126a4:	300ca648 	.word	0x300ca648
300126a8:	300456c8 	.word	0x300456c8
300126ac:	30012118 	.word	0x30012118

300126b0 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
300126b0:	e92d4010 	push	{r4, lr}
300126b4:	e24dd038 	sub	sp, sp, #56	; 0x38
300126b8:	e58d0014 	str	r0, [sp, #20]
300126bc:	e58d1010 	str	r1, [sp, #16]
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  struct ip_addr tmpaddr;
  s16_t hlen;

  ICMP_STATS_INC(icmp.recv);
300126c0:	e59f3720 	ldr	r3, [pc, #1824]	; 30012de8 <icmp_input+0x738>
300126c4:	e1d336bc 	ldrh	r3, [r3, #108]	; 0x6c
300126c8:	e2833001 	add	r3, r3, #1
300126cc:	e1a03803 	lsl	r3, r3, #16
300126d0:	e1a02823 	lsr	r2, r3, #16
300126d4:	e59f370c 	ldr	r3, [pc, #1804]	; 30012de8 <icmp_input+0x738>
300126d8:	e1c326bc 	strh	r2, [r3, #108]	; 0x6c
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
300126dc:	e59d3014 	ldr	r3, [sp, #20]
300126e0:	e5933004 	ldr	r3, [r3, #4]
300126e4:	e58d3028 	str	r3, [sp, #40]	; 0x28
  hlen = IPH_HL(iphdr) * 4;
300126e8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300126ec:	e5d32000 	ldrb	r2, [r3]
300126f0:	e5d33001 	ldrb	r3, [r3, #1]
300126f4:	e1a03403 	lsl	r3, r3, #8
300126f8:	e1833002 	orr	r3, r3, r2
300126fc:	e1a03803 	lsl	r3, r3, #16
30012700:	e1a03823 	lsr	r3, r3, #16
30012704:	e1a00003 	mov	r0, r3
30012708:	eb0003cf 	bl	3001364c <ntohs>
3001270c:	e1a03000 	mov	r3, r0
30012710:	e1a03423 	lsr	r3, r3, #8
30012714:	e1a03803 	lsl	r3, r3, #16
30012718:	e1a03823 	lsr	r3, r3, #16
3001271c:	e203300f 	and	r3, r3, #15
30012720:	e1a03103 	lsl	r3, r3, #2
30012724:	e1a03803 	lsl	r3, r3, #16
30012728:	e1a03823 	lsr	r3, r3, #16
3001272c:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
30012730:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
30012734:	e2633000 	rsb	r3, r3, #0
30012738:	e1a03803 	lsl	r3, r3, #16
3001273c:	e1a03823 	lsr	r3, r3, #16
30012740:	e1a03803 	lsl	r3, r3, #16
30012744:	e1a03843 	asr	r3, r3, #16
30012748:	e59d0014 	ldr	r0, [sp, #20]
3001274c:	e1a01003 	mov	r1, r3
30012750:	eb000e65 	bl	300160ec <pbuf_header>
30012754:	e1a03000 	mov	r3, r0
30012758:	e3530000 	cmp	r3, #0
3001275c:	1a000181 	bne	30012d68 <icmp_input+0x6b8>
30012760:	e59d3014 	ldr	r3, [sp, #20]
30012764:	e1d330b8 	ldrh	r3, [r3, #8]
30012768:	e3530003 	cmp	r3, #3
3001276c:	9a00017d 	bls	30012d68 <icmp_input+0x6b8>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
30012770:	e59d3014 	ldr	r3, [sp, #20]
30012774:	e5933004 	ldr	r3, [r3, #4]
30012778:	e5d33000 	ldrb	r3, [r3]
3001277c:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
30012780:	e5dd3023 	ldrb	r3, [sp, #35]	; 0x23
30012784:	e3530008 	cmp	r3, #8
30012788:	1a000162 	bne	30012d18 <icmp_input+0x668>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
3001278c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012790:	e2833010 	add	r3, r3, #16
30012794:	e1a00003 	mov	r0, r3
30012798:	e59d1010 	ldr	r1, [sp, #16]
3001279c:	eb00092d 	bl	30014c58 <ip_addr_isbroadcast>
300127a0:	e1a03000 	mov	r3, r0
300127a4:	e3530000 	cmp	r3, #0
300127a8:	1a000014 	bne	30012800 <icmp_input+0x150>
300127ac:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300127b0:	e5d32010 	ldrb	r2, [r3, #16]
300127b4:	e5d31011 	ldrb	r1, [r3, #17]
300127b8:	e1a01401 	lsl	r1, r1, #8
300127bc:	e1812002 	orr	r2, r1, r2
300127c0:	e5d31012 	ldrb	r1, [r3, #18]
300127c4:	e1a01801 	lsl	r1, r1, #16
300127c8:	e1812002 	orr	r2, r1, r2
300127cc:	e5d33013 	ldrb	r3, [r3, #19]
300127d0:	e1a03c03 	lsl	r3, r3, #24
300127d4:	e1833002 	orr	r3, r3, r2
300127d8:	e1a04003 	mov	r4, r3
300127dc:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
300127e0:	eb0003b7 	bl	300136c4 <ntohl>
300127e4:	e1a03000 	mov	r3, r0
300127e8:	e0044003 	and	r4, r4, r3
300127ec:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
300127f0:	eb0003b3 	bl	300136c4 <ntohl>
300127f4:	e1a03000 	mov	r3, r0
300127f8:	e1540003 	cmp	r4, r3
300127fc:	1a000009 	bne	30012828 <icmp_input+0x178>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
30012800:	e59f35e0 	ldr	r3, [pc, #1504]	; 30012de8 <icmp_input+0x738>
30012804:	e1d337be 	ldrh	r3, [r3, #126]	; 0x7e
30012808:	e2833001 	add	r3, r3, #1
3001280c:	e1a03803 	lsl	r3, r3, #16
30012810:	e1a02823 	lsr	r2, r3, #16
30012814:	e59f35cc 	ldr	r3, [pc, #1484]	; 30012de8 <icmp_input+0x738>
30012818:	e1c327be 	strh	r2, [r3, #126]	; 0x7e
      pbuf_free(p);
3001281c:	e59d0014 	ldr	r0, [sp, #20]
30012820:	eb000e96 	bl	30016280 <pbuf_free>
      return;
30012824:	ea00016c 	b	30012ddc <icmp_input+0x72c>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
30012828:	e59d3014 	ldr	r3, [sp, #20]
3001282c:	e1d330b8 	ldrh	r3, [r3, #8]
30012830:	e3530007 	cmp	r3, #7
30012834:	9a00014a 	bls	30012d64 <icmp_input+0x6b4>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
30012838:	e59d0014 	ldr	r0, [sp, #20]
3001283c:	eb00057a 	bl	30013e2c <inet_chksum_pbuf>
30012840:	e1a03000 	mov	r3, r0
30012844:	e3530000 	cmp	r3, #0
30012848:	0a000009 	beq	30012874 <icmp_input+0x1c4>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
3001284c:	e59d0014 	ldr	r0, [sp, #20]
30012850:	eb000e8a 	bl	30016280 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
30012854:	e59f358c 	ldr	r3, [pc, #1420]	; 30012de8 <icmp_input+0x738>
30012858:	e1d337b2 	ldrh	r3, [r3, #114]	; 0x72
3001285c:	e2833001 	add	r3, r3, #1
30012860:	e1a03803 	lsl	r3, r3, #16
30012864:	e1a02823 	lsr	r2, r3, #16
30012868:	e59f3578 	ldr	r3, [pc, #1400]	; 30012de8 <icmp_input+0x738>
3001286c:	e1c327b2 	strh	r2, [r3, #114]	; 0x72
      snmp_inc_icmpinerrors();
      return;
30012870:	ea000159 	b	30012ddc <icmp_input+0x72c>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
30012874:	e59d0014 	ldr	r0, [sp, #20]
30012878:	e3a01022 	mov	r1, #34	; 0x22
3001287c:	eb000e1a 	bl	300160ec <pbuf_header>
30012880:	e1a03000 	mov	r3, r0
30012884:	e3530000 	cmp	r3, #0
30012888:	0a00002c 	beq	30012940 <icmp_input+0x290>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
3001288c:	e1dd32fe 	ldrsh	r3, [sp, #46]	; 0x2e
30012890:	e59d0014 	ldr	r0, [sp, #20]
30012894:	e1a01003 	mov	r1, r3
30012898:	eb000e13 	bl	300160ec <pbuf_header>
3001289c:	e1a03000 	mov	r3, r0
300128a0:	e3530000 	cmp	r3, #0
300128a4:	1a000139 	bne	30012d90 <icmp_input+0x6e0>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
300128a8:	e59d3014 	ldr	r3, [sp, #20]
300128ac:	e1d330b8 	ldrh	r3, [r3, #8]
300128b0:	e3a00002 	mov	r0, #2
300128b4:	e1a01003 	mov	r1, r3
300128b8:	e3a02000 	mov	r2, #0
300128bc:	eb000cbd 	bl	30015bb8 <pbuf_alloc>
300128c0:	e1a03000 	mov	r3, r0
300128c4:	e58d3030 	str	r3, [sp, #48]	; 0x30
      if (r == NULL) {
300128c8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
300128cc:	e3530000 	cmp	r3, #0
300128d0:	0a000130 	beq	30012d98 <icmp_input+0x6e8>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
300128d4:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
300128d8:	e59d1014 	ldr	r1, [sp, #20]
300128dc:	eb000f2d 	bl	30016598 <pbuf_copy>
300128e0:	e1a03000 	mov	r3, r0
300128e4:	e20330ff 	and	r3, r3, #255	; 0xff
300128e8:	e3530000 	cmp	r3, #0
300128ec:	1a00012b 	bne	30012da0 <icmp_input+0x6f0>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = r->payload;
300128f0:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
300128f4:	e5933004 	ldr	r3, [r3, #4]
300128f8:	e58d3028 	str	r3, [sp, #40]	; 0x28
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
300128fc:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
30012900:	e2633000 	rsb	r3, r3, #0
30012904:	e1a03803 	lsl	r3, r3, #16
30012908:	e1a03823 	lsr	r3, r3, #16
3001290c:	e1a03803 	lsl	r3, r3, #16
30012910:	e1a03843 	asr	r3, r3, #16
30012914:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
30012918:	e1a01003 	mov	r1, r3
3001291c:	eb000df2 	bl	300160ec <pbuf_header>
30012920:	e1a03000 	mov	r3, r0
30012924:	e3530000 	cmp	r3, #0
30012928:	1a00011e 	bne	30012da8 <icmp_input+0x6f8>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
3001292c:	e59d0014 	ldr	r0, [sp, #20]
30012930:	eb000e52 	bl	30016280 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
30012934:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30012938:	e58d3014 	str	r3, [sp, #20]
3001293c:	ea000005 	b	30012958 <icmp_input+0x2a8>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
30012940:	e59d0014 	ldr	r0, [sp, #20]
30012944:	e3e01021 	mvn	r1, #33	; 0x21
30012948:	eb000de7 	bl	300160ec <pbuf_header>
3001294c:	e1a03000 	mov	r3, r0
30012950:	e3530000 	cmp	r3, #0
30012954:	1a000115 	bne	30012db0 <icmp_input+0x700>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
30012958:	e59d3014 	ldr	r3, [sp, #20]
3001295c:	e5933004 	ldr	r3, [r3, #4]
30012960:	e58d3024 	str	r3, [sp, #36]	; 0x24
    tmpaddr.addr = iphdr->src.addr;
30012964:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012968:	e5d3200c 	ldrb	r2, [r3, #12]
3001296c:	e5d3100d 	ldrb	r1, [r3, #13]
30012970:	e1a01401 	lsl	r1, r1, #8
30012974:	e1812002 	orr	r2, r1, r2
30012978:	e5d3100e 	ldrb	r1, [r3, #14]
3001297c:	e1a01801 	lsl	r1, r1, #16
30012980:	e1812002 	orr	r2, r1, r2
30012984:	e5d3300f 	ldrb	r3, [r3, #15]
30012988:	e1a03c03 	lsl	r3, r3, #24
3001298c:	e1833002 	orr	r3, r3, r2
30012990:	e58d301c 	str	r3, [sp, #28]
    iphdr->src.addr = iphdr->dest.addr;
30012994:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012998:	e5d32010 	ldrb	r2, [r3, #16]
3001299c:	e5d31011 	ldrb	r1, [r3, #17]
300129a0:	e1a01401 	lsl	r1, r1, #8
300129a4:	e1812002 	orr	r2, r1, r2
300129a8:	e5d31012 	ldrb	r1, [r3, #18]
300129ac:	e1a01801 	lsl	r1, r1, #16
300129b0:	e1812002 	orr	r2, r1, r2
300129b4:	e5d33013 	ldrb	r3, [r3, #19]
300129b8:	e1a03c03 	lsl	r3, r3, #24
300129bc:	e1833002 	orr	r3, r3, r2
300129c0:	e1a02003 	mov	r2, r3
300129c4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300129c8:	e20210ff 	and	r1, r2, #255	; 0xff
300129cc:	e3a00000 	mov	r0, #0
300129d0:	e1801001 	orr	r1, r0, r1
300129d4:	e5c3100c 	strb	r1, [r3, #12]
300129d8:	e1a01422 	lsr	r1, r2, #8
300129dc:	e20110ff 	and	r1, r1, #255	; 0xff
300129e0:	e3a00000 	mov	r0, #0
300129e4:	e1801001 	orr	r1, r0, r1
300129e8:	e5c3100d 	strb	r1, [r3, #13]
300129ec:	e1a01822 	lsr	r1, r2, #16
300129f0:	e20110ff 	and	r1, r1, #255	; 0xff
300129f4:	e3a00000 	mov	r0, #0
300129f8:	e1801001 	orr	r1, r0, r1
300129fc:	e5c3100e 	strb	r1, [r3, #14]
30012a00:	e1a02c22 	lsr	r2, r2, #24
30012a04:	e3a01000 	mov	r1, #0
30012a08:	e1812002 	orr	r2, r1, r2
30012a0c:	e5c3200f 	strb	r2, [r3, #15]
    iphdr->dest.addr = tmpaddr.addr;
30012a10:	e59d201c 	ldr	r2, [sp, #28]
30012a14:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012a18:	e20210ff 	and	r1, r2, #255	; 0xff
30012a1c:	e3a00000 	mov	r0, #0
30012a20:	e1801001 	orr	r1, r0, r1
30012a24:	e5c31010 	strb	r1, [r3, #16]
30012a28:	e1a01422 	lsr	r1, r2, #8
30012a2c:	e20110ff 	and	r1, r1, #255	; 0xff
30012a30:	e3a00000 	mov	r0, #0
30012a34:	e1801001 	orr	r1, r0, r1
30012a38:	e5c31011 	strb	r1, [r3, #17]
30012a3c:	e1a01822 	lsr	r1, r2, #16
30012a40:	e20110ff 	and	r1, r1, #255	; 0xff
30012a44:	e3a00000 	mov	r0, #0
30012a48:	e1801001 	orr	r1, r0, r1
30012a4c:	e5c31012 	strb	r1, [r3, #18]
30012a50:	e1a02c22 	lsr	r2, r2, #24
30012a54:	e3a01000 	mov	r1, #0
30012a58:	e1812002 	orr	r2, r1, r2
30012a5c:	e5c32013 	strb	r2, [r3, #19]
    ICMPH_TYPE_SET(iecho, ICMP_ER);
30012a60:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30012a64:	e5d32000 	ldrb	r2, [r3]
30012a68:	e5d33001 	ldrb	r3, [r3, #1]
30012a6c:	e1a03403 	lsl	r3, r3, #8
30012a70:	e1833002 	orr	r3, r3, r2
30012a74:	e1a03803 	lsl	r3, r3, #16
30012a78:	e1a03823 	lsr	r3, r3, #16
30012a7c:	e1a00003 	mov	r0, r3
30012a80:	eb0002f1 	bl	3001364c <ntohs>
30012a84:	e1a03000 	mov	r3, r0
30012a88:	e20330ff 	and	r3, r3, #255	; 0xff
30012a8c:	e1a00003 	mov	r0, r3
30012a90:	eb0002da 	bl	30013600 <htons>
30012a94:	e1a03000 	mov	r3, r0
30012a98:	e1a02003 	mov	r2, r3
30012a9c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30012aa0:	e20210ff 	and	r1, r2, #255	; 0xff
30012aa4:	e3a00000 	mov	r0, #0
30012aa8:	e1801001 	orr	r1, r0, r1
30012aac:	e5c31000 	strb	r1, [r3]
30012ab0:	e1a02422 	lsr	r2, r2, #8
30012ab4:	e1a02802 	lsl	r2, r2, #16
30012ab8:	e1a02822 	lsr	r2, r2, #16
30012abc:	e3a01000 	mov	r1, #0
30012ac0:	e1812002 	orr	r2, r1, r2
30012ac4:	e5c32001 	strb	r2, [r3, #1]
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
30012ac8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30012acc:	e5d32002 	ldrb	r2, [r3, #2]
30012ad0:	e5d33003 	ldrb	r3, [r3, #3]
30012ad4:	e1a03403 	lsl	r3, r3, #8
30012ad8:	e1833002 	orr	r3, r3, r2
30012adc:	e1a03803 	lsl	r3, r3, #16
30012ae0:	e1a04823 	lsr	r4, r3, #16
30012ae4:	e3a00b3e 	mov	r0, #63488	; 0xf800
30012ae8:	e2400001 	sub	r0, r0, #1
30012aec:	eb0002c3 	bl	30013600 <htons>
30012af0:	e1a03000 	mov	r3, r0
30012af4:	e1540003 	cmp	r4, r3
30012af8:	3a00001b 	bcc	30012b6c <icmp_input+0x4bc>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
30012afc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30012b00:	e5d32002 	ldrb	r2, [r3, #2]
30012b04:	e5d33003 	ldrb	r3, [r3, #3]
30012b08:	e1a03403 	lsl	r3, r3, #8
30012b0c:	e1833002 	orr	r3, r3, r2
30012b10:	e1a03803 	lsl	r3, r3, #16
30012b14:	e1a04823 	lsr	r4, r3, #16
30012b18:	e3a00b02 	mov	r0, #2048	; 0x800
30012b1c:	eb0002b7 	bl	30013600 <htons>
30012b20:	e1a03000 	mov	r3, r0
30012b24:	e0843003 	add	r3, r4, r3
30012b28:	e1a03803 	lsl	r3, r3, #16
30012b2c:	e1a03823 	lsr	r3, r3, #16
30012b30:	e2833001 	add	r3, r3, #1
30012b34:	e1a03803 	lsl	r3, r3, #16
30012b38:	e1a02823 	lsr	r2, r3, #16
30012b3c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30012b40:	e20210ff 	and	r1, r2, #255	; 0xff
30012b44:	e3a00000 	mov	r0, #0
30012b48:	e1801001 	orr	r1, r0, r1
30012b4c:	e5c31002 	strb	r1, [r3, #2]
30012b50:	e1a02422 	lsr	r2, r2, #8
30012b54:	e1a02802 	lsl	r2, r2, #16
30012b58:	e1a02822 	lsr	r2, r2, #16
30012b5c:	e3a01000 	mov	r1, #0
30012b60:	e1812002 	orr	r2, r1, r2
30012b64:	e5c32003 	strb	r2, [r3, #3]
30012b68:	ea000017 	b	30012bcc <icmp_input+0x51c>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
30012b6c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30012b70:	e5d32002 	ldrb	r2, [r3, #2]
30012b74:	e5d33003 	ldrb	r3, [r3, #3]
30012b78:	e1a03403 	lsl	r3, r3, #8
30012b7c:	e1833002 	orr	r3, r3, r2
30012b80:	e1a03803 	lsl	r3, r3, #16
30012b84:	e1a04823 	lsr	r4, r3, #16
30012b88:	e3a00b02 	mov	r0, #2048	; 0x800
30012b8c:	eb00029b 	bl	30013600 <htons>
30012b90:	e1a03000 	mov	r3, r0
30012b94:	e0843003 	add	r3, r4, r3
30012b98:	e1a03803 	lsl	r3, r3, #16
30012b9c:	e1a02823 	lsr	r2, r3, #16
30012ba0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30012ba4:	e20210ff 	and	r1, r2, #255	; 0xff
30012ba8:	e3a00000 	mov	r0, #0
30012bac:	e1801001 	orr	r1, r0, r1
30012bb0:	e5c31002 	strb	r1, [r3, #2]
30012bb4:	e1a02422 	lsr	r2, r2, #8
30012bb8:	e1a02802 	lsl	r2, r2, #16
30012bbc:	e1a02822 	lsr	r2, r2, #16
30012bc0:	e3a01000 	mov	r1, #0
30012bc4:	e1812002 	orr	r2, r1, r2
30012bc8:	e5c32003 	strb	r2, [r3, #3]
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
30012bcc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012bd0:	e5d32008 	ldrb	r2, [r3, #8]
30012bd4:	e5d33009 	ldrb	r3, [r3, #9]
30012bd8:	e1a03403 	lsl	r3, r3, #8
30012bdc:	e1833002 	orr	r3, r3, r2
30012be0:	e1a03803 	lsl	r3, r3, #16
30012be4:	e1a03823 	lsr	r3, r3, #16
30012be8:	e1a00003 	mov	r0, r3
30012bec:	eb000296 	bl	3001364c <ntohs>
30012bf0:	e1a03000 	mov	r3, r0
30012bf4:	e1e03c03 	mvn	r3, r3, lsl #24
30012bf8:	e1e03c23 	mvn	r3, r3, lsr #24
30012bfc:	e1a03803 	lsl	r3, r3, #16
30012c00:	e1a03823 	lsr	r3, r3, #16
30012c04:	e1a03803 	lsl	r3, r3, #16
30012c08:	e1a03823 	lsr	r3, r3, #16
30012c0c:	e1a00003 	mov	r0, r3
30012c10:	eb00027a 	bl	30013600 <htons>
30012c14:	e1a03000 	mov	r3, r0
30012c18:	e1a02003 	mov	r2, r3
30012c1c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012c20:	e20210ff 	and	r1, r2, #255	; 0xff
30012c24:	e3a00000 	mov	r0, #0
30012c28:	e1801001 	orr	r1, r0, r1
30012c2c:	e5c31008 	strb	r1, [r3, #8]
30012c30:	e1a02422 	lsr	r2, r2, #8
30012c34:	e1a02802 	lsl	r2, r2, #16
30012c38:	e1a02822 	lsr	r2, r2, #16
30012c3c:	e3a01000 	mov	r1, #0
30012c40:	e1812002 	orr	r2, r1, r2
30012c44:	e5c32009 	strb	r2, [r3, #9]
    IPH_CHKSUM_SET(iphdr, 0);
30012c48:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012c4c:	e3a02000 	mov	r2, #0
30012c50:	e5c3200a 	strb	r2, [r3, #10]
30012c54:	e3a02000 	mov	r2, #0
30012c58:	e5c3200b 	strb	r2, [r3, #11]
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
30012c5c:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
30012c60:	e3a01014 	mov	r1, #20
30012c64:	eb00044f 	bl	30013da8 <inet_chksum>
30012c68:	e1a03000 	mov	r3, r0
30012c6c:	e1a02003 	mov	r2, r3
30012c70:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012c74:	e20210ff 	and	r1, r2, #255	; 0xff
30012c78:	e3a00000 	mov	r0, #0
30012c7c:	e1801001 	orr	r1, r0, r1
30012c80:	e5c3100a 	strb	r1, [r3, #10]
30012c84:	e1a02422 	lsr	r2, r2, #8
30012c88:	e1a02802 	lsl	r2, r2, #16
30012c8c:	e1a02822 	lsr	r2, r2, #16
30012c90:	e3a01000 	mov	r1, #0
30012c94:	e1812002 	orr	r2, r1, r2
30012c98:	e5c3200b 	strb	r2, [r3, #11]
#endif /* CHECKSUM_GEN_IP */

    ICMP_STATS_INC(icmp.xmit);
30012c9c:	e59f3144 	ldr	r3, [pc, #324]	; 30012de8 <icmp_input+0x738>
30012ca0:	e1d336b8 	ldrh	r3, [r3, #104]	; 0x68
30012ca4:	e2833001 	add	r3, r3, #1
30012ca8:	e1a03803 	lsl	r3, r3, #16
30012cac:	e1a02823 	lsr	r2, r3, #16
30012cb0:	e59f3130 	ldr	r3, [pc, #304]	; 30012de8 <icmp_input+0x738>
30012cb4:	e1c326b8 	strh	r2, [r3, #104]	; 0x68
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
30012cb8:	e1dd32fe 	ldrsh	r3, [sp, #46]	; 0x2e
30012cbc:	e59d0014 	ldr	r0, [sp, #20]
30012cc0:	e1a01003 	mov	r1, r3
30012cc4:	eb000d08 	bl	300160ec <pbuf_header>
30012cc8:	e1a03000 	mov	r3, r0
30012ccc:	e3530000 	cmp	r3, #0
30012cd0:	1a00001f 	bne	30012d54 <icmp_input+0x6a4>
      LWIP_ASSERT("Can't move over header in packet", 0);
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
30012cd4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30012cd8:	e283300c 	add	r3, r3, #12
30012cdc:	e3a02000 	mov	r2, #0
30012ce0:	e58d2000 	str	r2, [sp]
30012ce4:	e3a02001 	mov	r2, #1
30012ce8:	e58d2004 	str	r2, [sp, #4]
30012cec:	e59d2010 	ldr	r2, [sp, #16]
30012cf0:	e58d2008 	str	r2, [sp, #8]
30012cf4:	e59d0014 	ldr	r0, [sp, #20]
30012cf8:	e1a01003 	mov	r1, r3
30012cfc:	e3a02000 	mov	r2, #0
30012d00:	e3a030ff 	mov	r3, #255	; 0xff
30012d04:	eb00064c 	bl	3001463c <ip_output_if>
30012d08:	e1a03000 	mov	r3, r0
30012d0c:	e20330ff 	and	r3, r3, #255	; 0xff
30012d10:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
30012d14:	ea00000f 	b	30012d58 <icmp_input+0x6a8>
  default:
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
30012d18:	e59f30c8 	ldr	r3, [pc, #200]	; 30012de8 <icmp_input+0x738>
30012d1c:	e1d337ba 	ldrh	r3, [r3, #122]	; 0x7a
30012d20:	e2833001 	add	r3, r3, #1
30012d24:	e1a03803 	lsl	r3, r3, #16
30012d28:	e1a02823 	lsr	r2, r3, #16
30012d2c:	e59f30b4 	ldr	r3, [pc, #180]	; 30012de8 <icmp_input+0x738>
30012d30:	e1c327ba 	strh	r2, [r3, #122]	; 0x7a
    ICMP_STATS_INC(icmp.drop);
30012d34:	e59f30ac 	ldr	r3, [pc, #172]	; 30012de8 <icmp_input+0x738>
30012d38:	e1d337b0 	ldrh	r3, [r3, #112]	; 0x70
30012d3c:	e2833001 	add	r3, r3, #1
30012d40:	e1a03803 	lsl	r3, r3, #16
30012d44:	e1a02823 	lsr	r2, r3, #16
30012d48:	e59f3098 	ldr	r3, [pc, #152]	; 30012de8 <icmp_input+0x738>
30012d4c:	e1c327b0 	strh	r2, [r3, #112]	; 0x70
30012d50:	ea000000 	b	30012d58 <icmp_input+0x6a8>
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
30012d54:	e1a00000 	nop			; (mov r0, r0)
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
30012d58:	e59d0014 	ldr	r0, [sp, #20]
30012d5c:	eb000d47 	bl	30016280 <pbuf_free>
  return;
30012d60:	ea00001d 	b	30012ddc <icmp_input+0x72c>
      return;
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
30012d64:	e1a00000 	nop			; (mov r0, r0)
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
30012d68:	e59d0014 	ldr	r0, [sp, #20]
30012d6c:	eb000d43 	bl	30016280 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
30012d70:	e59f3070 	ldr	r3, [pc, #112]	; 30012de8 <icmp_input+0x738>
30012d74:	e1d337b4 	ldrh	r3, [r3, #116]	; 0x74
30012d78:	e2833001 	add	r3, r3, #1
30012d7c:	e1a03803 	lsl	r3, r3, #16
30012d80:	e1a02823 	lsr	r2, r3, #16
30012d84:	e59f305c 	ldr	r3, [pc, #92]	; 30012de8 <icmp_input+0x738>
30012d88:	e1c327b4 	strh	r2, [r3, #116]	; 0x74
  snmp_inc_icmpinerrors();
  return;
30012d8c:	ea000012 	b	30012ddc <icmp_input+0x72c>
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
30012d90:	e1a00000 	nop			; (mov r0, r0)
30012d94:	ea000006 	b	30012db4 <icmp_input+0x704>
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
30012d98:	e1a00000 	nop			; (mov r0, r0)
30012d9c:	ea000004 	b	30012db4 <icmp_input+0x704>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
30012da0:	e1a00000 	nop			; (mov r0, r0)
30012da4:	ea000002 	b	30012db4 <icmp_input+0x704>
      }
      iphdr = r->payload;
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
30012da8:	e1a00000 	nop			; (mov r0, r0)
30012dac:	ea000000 	b	30012db4 <icmp_input+0x704>
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
30012db0:	e1a00000 	nop			; (mov r0, r0)
  pbuf_free(p);
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
memerr:
  pbuf_free(p);
30012db4:	e59d0014 	ldr	r0, [sp, #20]
30012db8:	eb000d30 	bl	30016280 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
30012dbc:	e59f3024 	ldr	r3, [pc, #36]	; 30012de8 <icmp_input+0x738>
30012dc0:	e1d337be 	ldrh	r3, [r3, #126]	; 0x7e
30012dc4:	e2833001 	add	r3, r3, #1
30012dc8:	e1a03803 	lsl	r3, r3, #16
30012dcc:	e1a02823 	lsr	r2, r3, #16
30012dd0:	e59f3010 	ldr	r3, [pc, #16]	; 30012de8 <icmp_input+0x738>
30012dd4:	e1c327be 	strh	r2, [r3, #126]	; 0x7e
  snmp_inc_icmpinerrors();
  return;
30012dd8:	e1a00000 	nop			; (mov r0, r0)
}
30012ddc:	e28dd038 	add	sp, sp, #56	; 0x38
30012de0:	e8bd4010 	pop	{r4, lr}
30012de4:	e12fff1e 	bx	lr
30012de8:	302be570 	.word	0x302be570

30012dec <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
30012dec:	e92d4010 	push	{r4, lr}
30012df0:	e24dd020 	sub	sp, sp, #32
30012df4:	e58d000c 	str	r0, [sp, #12]
30012df8:	e1a03001 	mov	r3, r1
30012dfc:	e5cd300b 	strb	r3, [sp, #11]
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
30012e00:	e3a00001 	mov	r0, #1
30012e04:	e3a01024 	mov	r1, #36	; 0x24
30012e08:	e3a02000 	mov	r2, #0
30012e0c:	eb000b69 	bl	30015bb8 <pbuf_alloc>
30012e10:	e1a03000 	mov	r3, r0
30012e14:	e58d3014 	str	r3, [sp, #20]
                 PBUF_RAM);
  if (q == NULL) {
30012e18:	e59d3014 	ldr	r3, [sp, #20]
30012e1c:	e3530000 	cmp	r3, #0
30012e20:	0a000081 	beq	3001302c <icmp_dest_unreach+0x240>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
30012e24:	e59d300c 	ldr	r3, [sp, #12]
30012e28:	e5933004 	ldr	r3, [r3, #4]
30012e2c:	e58d3018 	str	r3, [sp, #24]

  idur = q->payload;
30012e30:	e59d3014 	ldr	r3, [sp, #20]
30012e34:	e5933004 	ldr	r3, [r3, #4]
30012e38:	e58d301c 	str	r3, [sp, #28]
  ICMPH_TYPE_SET(idur, ICMP_DUR);
30012e3c:	e59d301c 	ldr	r3, [sp, #28]
30012e40:	e5d32000 	ldrb	r2, [r3]
30012e44:	e5d33001 	ldrb	r3, [r3, #1]
30012e48:	e1a03403 	lsl	r3, r3, #8
30012e4c:	e1833002 	orr	r3, r3, r2
30012e50:	e1a03803 	lsl	r3, r3, #16
30012e54:	e1a03823 	lsr	r3, r3, #16
30012e58:	e1a00003 	mov	r0, r3
30012e5c:	eb0001fa 	bl	3001364c <ntohs>
30012e60:	e1a03000 	mov	r3, r0
30012e64:	e1a03803 	lsl	r3, r3, #16
30012e68:	e1a03823 	lsr	r3, r3, #16
30012e6c:	e20330ff 	and	r3, r3, #255	; 0xff
30012e70:	e3833c03 	orr	r3, r3, #768	; 0x300
30012e74:	e1a03803 	lsl	r3, r3, #16
30012e78:	e1a03823 	lsr	r3, r3, #16
30012e7c:	e1a03803 	lsl	r3, r3, #16
30012e80:	e1a03823 	lsr	r3, r3, #16
30012e84:	e1a00003 	mov	r0, r3
30012e88:	eb0001dc 	bl	30013600 <htons>
30012e8c:	e1a03000 	mov	r3, r0
30012e90:	e1a02003 	mov	r2, r3
30012e94:	e59d301c 	ldr	r3, [sp, #28]
30012e98:	e20210ff 	and	r1, r2, #255	; 0xff
30012e9c:	e3a00000 	mov	r0, #0
30012ea0:	e1801001 	orr	r1, r0, r1
30012ea4:	e5c31000 	strb	r1, [r3]
30012ea8:	e1a02422 	lsr	r2, r2, #8
30012eac:	e1a02802 	lsl	r2, r2, #16
30012eb0:	e1a02822 	lsr	r2, r2, #16
30012eb4:	e3a01000 	mov	r1, #0
30012eb8:	e1812002 	orr	r2, r1, r2
30012ebc:	e5c32001 	strb	r2, [r3, #1]
  ICMPH_CODE_SET(idur, t);
30012ec0:	e5dd400b 	ldrb	r4, [sp, #11]
30012ec4:	e59d301c 	ldr	r3, [sp, #28]
30012ec8:	e5d32000 	ldrb	r2, [r3]
30012ecc:	e5d33001 	ldrb	r3, [r3, #1]
30012ed0:	e1a03403 	lsl	r3, r3, #8
30012ed4:	e1833002 	orr	r3, r3, r2
30012ed8:	e1a03803 	lsl	r3, r3, #16
30012edc:	e1a03823 	lsr	r3, r3, #16
30012ee0:	e1a00003 	mov	r0, r3
30012ee4:	eb0001d8 	bl	3001364c <ntohs>
30012ee8:	e1a03000 	mov	r3, r0
30012eec:	e1a03423 	lsr	r3, r3, #8
30012ef0:	e1a03803 	lsl	r3, r3, #16
30012ef4:	e1a03823 	lsr	r3, r3, #16
30012ef8:	e1a03403 	lsl	r3, r3, #8
30012efc:	e1a03803 	lsl	r3, r3, #16
30012f00:	e1a03823 	lsr	r3, r3, #16
30012f04:	e1a02004 	mov	r2, r4
30012f08:	e1823003 	orr	r3, r2, r3
30012f0c:	e1a03803 	lsl	r3, r3, #16
30012f10:	e1a03823 	lsr	r3, r3, #16
30012f14:	e1a03803 	lsl	r3, r3, #16
30012f18:	e1a03823 	lsr	r3, r3, #16
30012f1c:	e1a00003 	mov	r0, r3
30012f20:	eb0001b6 	bl	30013600 <htons>
30012f24:	e1a03000 	mov	r3, r0
30012f28:	e1a02003 	mov	r2, r3
30012f2c:	e59d301c 	ldr	r3, [sp, #28]
30012f30:	e20210ff 	and	r1, r2, #255	; 0xff
30012f34:	e3a00000 	mov	r0, #0
30012f38:	e1801001 	orr	r1, r0, r1
30012f3c:	e5c31000 	strb	r1, [r3]
30012f40:	e1a02422 	lsr	r2, r2, #8
30012f44:	e1a02802 	lsl	r2, r2, #16
30012f48:	e1a02822 	lsr	r2, r2, #16
30012f4c:	e3a01000 	mov	r1, #0
30012f50:	e1812002 	orr	r2, r1, r2
30012f54:	e5c32001 	strb	r2, [r3, #1]

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
30012f58:	e59d3014 	ldr	r3, [sp, #20]
30012f5c:	e5933004 	ldr	r3, [r3, #4]
30012f60:	e2832008 	add	r2, r3, #8
30012f64:	e59d300c 	ldr	r3, [sp, #12]
30012f68:	e5933004 	ldr	r3, [r3, #4]
30012f6c:	e1a00002 	mov	r0, r2
30012f70:	e1a01003 	mov	r1, r3
30012f74:	e3a0201c 	mov	r2, #28
30012f78:	ebffe4d7 	bl	3000c2dc <acoral_memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
30012f7c:	e59d301c 	ldr	r3, [sp, #28]
30012f80:	e3a02000 	mov	r2, #0
30012f84:	e5c32002 	strb	r2, [r3, #2]
30012f88:	e3a02000 	mov	r2, #0
30012f8c:	e5c32003 	strb	r2, [r3, #3]
  idur->chksum = inet_chksum(idur, q->len);
30012f90:	e59d3014 	ldr	r3, [sp, #20]
30012f94:	e1d330ba 	ldrh	r3, [r3, #10]
30012f98:	e59d001c 	ldr	r0, [sp, #28]
30012f9c:	e1a01003 	mov	r1, r3
30012fa0:	eb000380 	bl	30013da8 <inet_chksum>
30012fa4:	e1a03000 	mov	r3, r0
30012fa8:	e1a02003 	mov	r2, r3
30012fac:	e59d301c 	ldr	r3, [sp, #28]
30012fb0:	e20210ff 	and	r1, r2, #255	; 0xff
30012fb4:	e3a00000 	mov	r0, #0
30012fb8:	e1801001 	orr	r1, r0, r1
30012fbc:	e5c31002 	strb	r1, [r3, #2]
30012fc0:	e1a02422 	lsr	r2, r2, #8
30012fc4:	e1a02802 	lsl	r2, r2, #16
30012fc8:	e1a02822 	lsr	r2, r2, #16
30012fcc:	e3a01000 	mov	r1, #0
30012fd0:	e1812002 	orr	r2, r1, r2
30012fd4:	e5c32003 	strb	r2, [r3, #3]
  ICMP_STATS_INC(icmp.xmit);
30012fd8:	e59f305c 	ldr	r3, [pc, #92]	; 3001303c <icmp_dest_unreach+0x250>
30012fdc:	e1d336b8 	ldrh	r3, [r3, #104]	; 0x68
30012fe0:	e2833001 	add	r3, r3, #1
30012fe4:	e1a03803 	lsl	r3, r3, #16
30012fe8:	e1a02823 	lsr	r2, r3, #16
30012fec:	e59f3048 	ldr	r3, [pc, #72]	; 3001303c <icmp_dest_unreach+0x250>
30012ff0:	e1c326b8 	strh	r2, [r3, #104]	; 0x68
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
30012ff4:	e59d3018 	ldr	r3, [sp, #24]
30012ff8:	e283300c 	add	r3, r3, #12
30012ffc:	e3a02000 	mov	r2, #0
30013000:	e58d2000 	str	r2, [sp]
30013004:	e3a02001 	mov	r2, #1
30013008:	e58d2004 	str	r2, [sp, #4]
3001300c:	e59d0014 	ldr	r0, [sp, #20]
30013010:	e3a01000 	mov	r1, #0
30013014:	e1a02003 	mov	r2, r3
30013018:	e3a030ff 	mov	r3, #255	; 0xff
3001301c:	eb0006ea 	bl	30014bcc <ip_output>
  pbuf_free(q);
30013020:	e59d0014 	ldr	r0, [sp, #20]
30013024:	eb000c95 	bl	30016280 <pbuf_free>
30013028:	ea000000 	b	30013030 <icmp_dest_unreach+0x244>
  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
3001302c:	e1a00000 	nop			; (mov r0, r0)
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
30013030:	e28dd020 	add	sp, sp, #32
30013034:	e8bd4010 	pop	{r4, lr}
30013038:	e12fff1e 	bx	lr
3001303c:	302be570 	.word	0x302be570

30013040 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
30013040:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30013044:	e24dd014 	sub	sp, sp, #20
30013048:	e58d0004 	str	r0, [sp, #4]
  struct in_addr val;

  if (inet_aton(cp, &val)) {
3001304c:	e28d300c 	add	r3, sp, #12
30013050:	e59d0004 	ldr	r0, [sp, #4]
30013054:	e1a01003 	mov	r1, r3
30013058:	eb000009 	bl	30013084 <inet_aton>
3001305c:	e1a03000 	mov	r3, r0
30013060:	e3530000 	cmp	r3, #0
30013064:	0a000001 	beq	30013070 <inet_addr+0x30>
    return (val.s_addr);
30013068:	e59d300c 	ldr	r3, [sp, #12]
3001306c:	ea000000 	b	30013074 <inet_addr+0x34>
  }
  return (INADDR_NONE);
30013070:	e3e03000 	mvn	r3, #0
}
30013074:	e1a00003 	mov	r0, r3
30013078:	e28dd014 	add	sp, sp, #20
3001307c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30013080:	e12fff1e 	bx	lr

30013084 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
30013084:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30013088:	e24dd034 	sub	sp, sp, #52	; 0x34
3001308c:	e58d0004 	str	r0, [sp, #4]
30013090:	e58d1000 	str	r1, [sp]
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
30013094:	e28d300c 	add	r3, sp, #12
30013098:	e58d302c 	str	r3, [sp, #44]	; 0x2c

  c = *cp;
3001309c:	e59d3004 	ldr	r3, [sp, #4]
300130a0:	e5d33000 	ldrb	r3, [r3]
300130a4:	e58d3028 	str	r3, [sp, #40]	; 0x28
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
300130a8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300130ac:	e20330ff 	and	r3, r3, #255	; 0xff
300130b0:	e353002f 	cmp	r3, #47	; 0x2f
300130b4:	9a000003 	bls	300130c8 <inet_aton+0x44>
300130b8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300130bc:	e20330ff 	and	r3, r3, #255	; 0xff
300130c0:	e3530039 	cmp	r3, #57	; 0x39
300130c4:	9a000001 	bls	300130d0 <inet_aton+0x4c>
      return (0);
300130c8:	e3a03000 	mov	r3, #0
300130cc:	ea0000e6 	b	3001346c <inet_aton+0x3e8>
    val = 0;
300130d0:	e3a03000 	mov	r3, #0
300130d4:	e58d301c 	str	r3, [sp, #28]
    base = 10;
300130d8:	e3a0300a 	mov	r3, #10
300130dc:	e58d3020 	str	r3, [sp, #32]
    if (c == '0') {
300130e0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300130e4:	e3530030 	cmp	r3, #48	; 0x30
300130e8:	1a000016 	bne	30013148 <inet_aton+0xc4>
      c = *++cp;
300130ec:	e59d3004 	ldr	r3, [sp, #4]
300130f0:	e2833001 	add	r3, r3, #1
300130f4:	e58d3004 	str	r3, [sp, #4]
300130f8:	e59d3004 	ldr	r3, [sp, #4]
300130fc:	e5d33000 	ldrb	r3, [r3]
30013100:	e58d3028 	str	r3, [sp, #40]	; 0x28
      if (c == 'x' || c == 'X') {
30013104:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013108:	e3530078 	cmp	r3, #120	; 0x78
3001310c:	0a000002 	beq	3001311c <inet_aton+0x98>
30013110:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013114:	e3530058 	cmp	r3, #88	; 0x58
30013118:	1a000008 	bne	30013140 <inet_aton+0xbc>
        base = 16;
3001311c:	e3a03010 	mov	r3, #16
30013120:	e58d3020 	str	r3, [sp, #32]
        c = *++cp;
30013124:	e59d3004 	ldr	r3, [sp, #4]
30013128:	e2833001 	add	r3, r3, #1
3001312c:	e58d3004 	str	r3, [sp, #4]
30013130:	e59d3004 	ldr	r3, [sp, #4]
30013134:	e5d33000 	ldrb	r3, [r3]
30013138:	e58d3028 	str	r3, [sp, #40]	; 0x28
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
3001313c:	ea000001 	b	30013148 <inet_aton+0xc4>
        base = 16;
        c = *++cp;
      } else
        base = 8;
30013140:	e3a03008 	mov	r3, #8
30013144:	e58d3020 	str	r3, [sp, #32]
    }
    for (;;) {
      if (isdigit(c)) {
30013148:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001314c:	e20330ff 	and	r3, r3, #255	; 0xff
30013150:	e353002f 	cmp	r3, #47	; 0x2f
30013154:	9a000012 	bls	300131a4 <inet_aton+0x120>
30013158:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001315c:	e20330ff 	and	r3, r3, #255	; 0xff
30013160:	e3530039 	cmp	r3, #57	; 0x39
30013164:	8a00000e 	bhi	300131a4 <inet_aton+0x120>
        val = (val * base) + (int)(c - '0');
30013168:	e59d3020 	ldr	r3, [sp, #32]
3001316c:	e59d201c 	ldr	r2, [sp, #28]
30013170:	e0020293 	mul	r2, r3, r2
30013174:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013178:	e0823003 	add	r3, r2, r3
3001317c:	e2433030 	sub	r3, r3, #48	; 0x30
30013180:	e58d301c 	str	r3, [sp, #28]
        c = *++cp;
30013184:	e59d3004 	ldr	r3, [sp, #4]
30013188:	e2833001 	add	r3, r3, #1
3001318c:	e58d3004 	str	r3, [sp, #4]
30013190:	e59d3004 	ldr	r3, [sp, #4]
30013194:	e5d33000 	ldrb	r3, [r3]
30013198:	e58d3028 	str	r3, [sp, #40]	; 0x28
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
3001319c:	e1a00000 	nop			; (mov r0, r0)
      } else if (base == 16 && isxdigit(c)) {
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
300131a0:	eaffffe8 	b	30013148 <inet_aton+0xc4>
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
300131a4:	e59d3020 	ldr	r3, [sp, #32]
300131a8:	e3530010 	cmp	r3, #16
300131ac:	1a000030 	bne	30013274 <inet_aton+0x1f0>
300131b0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300131b4:	e20330ff 	and	r3, r3, #255	; 0xff
300131b8:	e353002f 	cmp	r3, #47	; 0x2f
300131bc:	9a000003 	bls	300131d0 <inet_aton+0x14c>
300131c0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300131c4:	e20330ff 	and	r3, r3, #255	; 0xff
300131c8:	e3530039 	cmp	r3, #57	; 0x39
300131cc:	9a00000f 	bls	30013210 <inet_aton+0x18c>
300131d0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300131d4:	e20330ff 	and	r3, r3, #255	; 0xff
300131d8:	e3530060 	cmp	r3, #96	; 0x60
300131dc:	9a000003 	bls	300131f0 <inet_aton+0x16c>
300131e0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300131e4:	e20330ff 	and	r3, r3, #255	; 0xff
300131e8:	e3530066 	cmp	r3, #102	; 0x66
300131ec:	9a000007 	bls	30013210 <inet_aton+0x18c>
300131f0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300131f4:	e20330ff 	and	r3, r3, #255	; 0xff
300131f8:	e3530040 	cmp	r3, #64	; 0x40
300131fc:	9a00001c 	bls	30013274 <inet_aton+0x1f0>
30013200:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013204:	e20330ff 	and	r3, r3, #255	; 0xff
30013208:	e3530046 	cmp	r3, #70	; 0x46
3001320c:	8a000018 	bhi	30013274 <inet_aton+0x1f0>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
30013210:	e59d301c 	ldr	r3, [sp, #28]
30013214:	e1a02203 	lsl	r2, r3, #4
30013218:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001321c:	e283100a 	add	r1, r3, #10
30013220:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013224:	e20330ff 	and	r3, r3, #255	; 0xff
30013228:	e3530060 	cmp	r3, #96	; 0x60
3001322c:	9a000005 	bls	30013248 <inet_aton+0x1c4>
30013230:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013234:	e20330ff 	and	r3, r3, #255	; 0xff
30013238:	e353007a 	cmp	r3, #122	; 0x7a
3001323c:	8a000001 	bhi	30013248 <inet_aton+0x1c4>
30013240:	e3a03061 	mov	r3, #97	; 0x61
30013244:	ea000000 	b	3001324c <inet_aton+0x1c8>
30013248:	e3a03041 	mov	r3, #65	; 0x41
3001324c:	e0633001 	rsb	r3, r3, r1
30013250:	e1823003 	orr	r3, r2, r3
30013254:	e58d301c 	str	r3, [sp, #28]
        c = *++cp;
30013258:	e59d3004 	ldr	r3, [sp, #4]
3001325c:	e2833001 	add	r3, r3, #1
30013260:	e58d3004 	str	r3, [sp, #4]
30013264:	e59d3004 	ldr	r3, [sp, #4]
30013268:	e5d33000 	ldrb	r3, [r3]
3001326c:	e58d3028 	str	r3, [sp, #40]	; 0x28
      } else
        break;
    }
30013270:	eaffffb4 	b	30013148 <inet_aton+0xc4>
    if (c == '.') {
30013274:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013278:	e353002e 	cmp	r3, #46	; 0x2e
3001327c:	1a000013 	bne	300132d0 <inet_aton+0x24c>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
30013280:	e28d300c 	add	r3, sp, #12
30013284:	e283200c 	add	r2, r3, #12
30013288:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3001328c:	e1520003 	cmp	r2, r3
30013290:	8a000001 	bhi	3001329c <inet_aton+0x218>
        return (0);
30013294:	e3a03000 	mov	r3, #0
30013298:	ea000073 	b	3001346c <inet_aton+0x3e8>
      *pp++ = val;
3001329c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300132a0:	e59d201c 	ldr	r2, [sp, #28]
300132a4:	e5832000 	str	r2, [r3]
300132a8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300132ac:	e2833004 	add	r3, r3, #4
300132b0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
      c = *++cp;
300132b4:	e59d3004 	ldr	r3, [sp, #4]
300132b8:	e2833001 	add	r3, r3, #1
300132bc:	e58d3004 	str	r3, [sp, #4]
300132c0:	e59d3004 	ldr	r3, [sp, #4]
300132c4:	e5d33000 	ldrb	r3, [r3]
300132c8:	e58d3028 	str	r3, [sp, #40]	; 0x28
    } else
      break;
  }
300132cc:	eaffff75 	b	300130a8 <inet_aton+0x24>
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
300132d0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300132d4:	e3530000 	cmp	r3, #0
300132d8:	0a00001d 	beq	30013354 <inet_aton+0x2d0>
300132dc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300132e0:	e20330ff 	and	r3, r3, #255	; 0xff
300132e4:	e353001f 	cmp	r3, #31
300132e8:	9a000017 	bls	3001334c <inet_aton+0x2c8>
300132ec:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300132f0:	e20330ff 	and	r3, r3, #255	; 0xff
300132f4:	e1a03c03 	lsl	r3, r3, #24
300132f8:	e1a03c43 	asr	r3, r3, #24
300132fc:	e3530000 	cmp	r3, #0
30013300:	ba000011 	blt	3001334c <inet_aton+0x2c8>
30013304:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013308:	e3530020 	cmp	r3, #32
3001330c:	0a000010 	beq	30013354 <inet_aton+0x2d0>
30013310:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013314:	e353000c 	cmp	r3, #12
30013318:	0a00000d 	beq	30013354 <inet_aton+0x2d0>
3001331c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013320:	e353000a 	cmp	r3, #10
30013324:	0a00000a 	beq	30013354 <inet_aton+0x2d0>
30013328:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3001332c:	e353000d 	cmp	r3, #13
30013330:	0a000007 	beq	30013354 <inet_aton+0x2d0>
30013334:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013338:	e3530009 	cmp	r3, #9
3001333c:	0a000004 	beq	30013354 <inet_aton+0x2d0>
30013340:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30013344:	e353000b 	cmp	r3, #11
30013348:	0a000001 	beq	30013354 <inet_aton+0x2d0>
    return (0);
3001334c:	e3a03000 	mov	r3, #0
30013350:	ea000045 	b	3001346c <inet_aton+0x3e8>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
30013354:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30013358:	e28d300c 	add	r3, sp, #12
3001335c:	e0633002 	rsb	r3, r3, r2
30013360:	e1a03143 	asr	r3, r3, #2
30013364:	e2833001 	add	r3, r3, #1
30013368:	e58d3024 	str	r3, [sp, #36]	; 0x24
  switch (n) {
3001336c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30013370:	e3530004 	cmp	r3, #4
30013374:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30013378:	ea000032 	b	30013448 <inet_aton+0x3c4>
3001337c:	30013390 	.word	0x30013390
30013380:	30013448 	.word	0x30013448
30013384:	30013398 	.word	0x30013398
30013388:	300133c8 	.word	0x300133c8
3001338c:	30013408 	.word	0x30013408

  case 0:
    return (0);       /* initial nondigit */
30013390:	e3a03000 	mov	r3, #0
30013394:	ea000034 	b	3001346c <inet_aton+0x3e8>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
30013398:	e59d201c 	ldr	r2, [sp, #28]
3001339c:	e3e034ff 	mvn	r3, #-16777216	; 0xff000000
300133a0:	e1520003 	cmp	r2, r3
300133a4:	9a000001 	bls	300133b0 <inet_aton+0x32c>
      return (0);
300133a8:	e3a03000 	mov	r3, #0
300133ac:	ea00002e 	b	3001346c <inet_aton+0x3e8>
    val |= parts[0] << 24;
300133b0:	e59d300c 	ldr	r3, [sp, #12]
300133b4:	e1a03c03 	lsl	r3, r3, #24
300133b8:	e59d201c 	ldr	r2, [sp, #28]
300133bc:	e1823003 	orr	r3, r2, r3
300133c0:	e58d301c 	str	r3, [sp, #28]
    break;
300133c4:	ea00001f 	b	30013448 <inet_aton+0x3c4>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
300133c8:	e59d201c 	ldr	r2, [sp, #28]
300133cc:	e3a03801 	mov	r3, #65536	; 0x10000
300133d0:	e2433001 	sub	r3, r3, #1
300133d4:	e1520003 	cmp	r2, r3
300133d8:	9a000001 	bls	300133e4 <inet_aton+0x360>
      return (0);
300133dc:	e3a03000 	mov	r3, #0
300133e0:	ea000021 	b	3001346c <inet_aton+0x3e8>
    val |= (parts[0] << 24) | (parts[1] << 16);
300133e4:	e59d300c 	ldr	r3, [sp, #12]
300133e8:	e1a02c03 	lsl	r2, r3, #24
300133ec:	e59d3010 	ldr	r3, [sp, #16]
300133f0:	e1a03803 	lsl	r3, r3, #16
300133f4:	e1823003 	orr	r3, r2, r3
300133f8:	e59d201c 	ldr	r2, [sp, #28]
300133fc:	e1823003 	orr	r3, r2, r3
30013400:	e58d301c 	str	r3, [sp, #28]
    break;
30013404:	ea00000f 	b	30013448 <inet_aton+0x3c4>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
30013408:	e59d301c 	ldr	r3, [sp, #28]
3001340c:	e35300ff 	cmp	r3, #255	; 0xff
30013410:	9a000001 	bls	3001341c <inet_aton+0x398>
      return (0);
30013414:	e3a03000 	mov	r3, #0
30013418:	ea000013 	b	3001346c <inet_aton+0x3e8>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
3001341c:	e59d300c 	ldr	r3, [sp, #12]
30013420:	e1a02c03 	lsl	r2, r3, #24
30013424:	e59d3010 	ldr	r3, [sp, #16]
30013428:	e1a03803 	lsl	r3, r3, #16
3001342c:	e1822003 	orr	r2, r2, r3
30013430:	e59d3014 	ldr	r3, [sp, #20]
30013434:	e1a03403 	lsl	r3, r3, #8
30013438:	e1823003 	orr	r3, r2, r3
3001343c:	e59d201c 	ldr	r2, [sp, #28]
30013440:	e1823003 	orr	r3, r2, r3
30013444:	e58d301c 	str	r3, [sp, #28]
    break;
  }
  if (addr)
30013448:	e59d3000 	ldr	r3, [sp]
3001344c:	e3530000 	cmp	r3, #0
30013450:	0a000004 	beq	30013468 <inet_aton+0x3e4>
    addr->s_addr = htonl(val);
30013454:	e59d001c 	ldr	r0, [sp, #28]
30013458:	eb000087 	bl	3001367c <htonl>
3001345c:	e1a02000 	mov	r2, r0
30013460:	e59d3000 	ldr	r3, [sp]
30013464:	e5832000 	str	r2, [r3]
  return (1);
30013468:	e3a03001 	mov	r3, #1
}
3001346c:	e1a00003 	mov	r0, r3
30013470:	e28dd034 	add	sp, sp, #52	; 0x34
30013474:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30013478:	e12fff1e 	bx	lr

3001347c <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
3001347c:	e24dd020 	sub	sp, sp, #32
30013480:	e58d0004 	str	r0, [sp, #4]
  static char str[16];
  u32_t s_addr = addr.s_addr;
30013484:	e59d3004 	ldr	r3, [sp, #4]
30013488:	e58d3010 	str	r3, [sp, #16]
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
3001348c:	e59f3164 	ldr	r3, [pc, #356]	; 300135f8 <inet_ntoa+0x17c>
30013490:	e58d3014 	str	r3, [sp, #20]
  ap = (u8_t *)&s_addr;
30013494:	e28d3010 	add	r3, sp, #16
30013498:	e58d3018 	str	r3, [sp, #24]
  for(n = 0; n < 4; n++) {
3001349c:	e3a03000 	mov	r3, #0
300134a0:	e5cd301e 	strb	r3, [sp, #30]
300134a4:	ea000046 	b	300135c4 <inet_ntoa+0x148>
    i = 0;
300134a8:	e3a03000 	mov	r3, #0
300134ac:	e5cd301f 	strb	r3, [sp, #31]
    do {
      rem = *ap % (u8_t)10;
300134b0:	e59d3018 	ldr	r3, [sp, #24]
300134b4:	e5d32000 	ldrb	r2, [r3]
300134b8:	e59f313c 	ldr	r3, [pc, #316]	; 300135fc <inet_ntoa+0x180>
300134bc:	e0830392 	umull	r0, r3, r2, r3
300134c0:	e1a011a3 	lsr	r1, r3, #3
300134c4:	e1a03001 	mov	r3, r1
300134c8:	e1a03103 	lsl	r3, r3, #2
300134cc:	e0833001 	add	r3, r3, r1
300134d0:	e1a03083 	lsl	r3, r3, #1
300134d4:	e0633002 	rsb	r3, r3, r2
300134d8:	e5cd301d 	strb	r3, [sp, #29]
      *ap /= (u8_t)10;
300134dc:	e59d3018 	ldr	r3, [sp, #24]
300134e0:	e5d32000 	ldrb	r2, [r3]
300134e4:	e59f3110 	ldr	r3, [pc, #272]	; 300135fc <inet_ntoa+0x180>
300134e8:	e0831392 	umull	r1, r3, r2, r3
300134ec:	e1a031a3 	lsr	r3, r3, #3
300134f0:	e20320ff 	and	r2, r3, #255	; 0xff
300134f4:	e59d3018 	ldr	r3, [sp, #24]
300134f8:	e5c32000 	strb	r2, [r3]
      inv[i++] = '0' + rem;
300134fc:	e5dd101f 	ldrb	r1, [sp, #31]
30013500:	e5dd301d 	ldrb	r3, [sp, #29]
30013504:	e2833030 	add	r3, r3, #48	; 0x30
30013508:	e20320ff 	and	r2, r3, #255	; 0xff
3001350c:	e3e03013 	mvn	r3, #19
30013510:	e28d0020 	add	r0, sp, #32
30013514:	e0801001 	add	r1, r0, r1
30013518:	e0813003 	add	r3, r1, r3
3001351c:	e5c32000 	strb	r2, [r3]
30013520:	e5dd301f 	ldrb	r3, [sp, #31]
30013524:	e2833001 	add	r3, r3, #1
30013528:	e5cd301f 	strb	r3, [sp, #31]
    } while(*ap);
3001352c:	e59d3018 	ldr	r3, [sp, #24]
30013530:	e5d33000 	ldrb	r3, [r3]
30013534:	e3530000 	cmp	r3, #0
30013538:	1affffdc 	bne	300134b0 <inet_ntoa+0x34>
    while(i--)
3001353c:	ea00000a 	b	3001356c <inet_ntoa+0xf0>
      *rp++ = inv[i];
30013540:	e5dd201f 	ldrb	r2, [sp, #31]
30013544:	e3e03013 	mvn	r3, #19
30013548:	e28d1020 	add	r1, sp, #32
3001354c:	e0812002 	add	r2, r1, r2
30013550:	e0823003 	add	r3, r2, r3
30013554:	e5d32000 	ldrb	r2, [r3]
30013558:	e59d3014 	ldr	r3, [sp, #20]
3001355c:	e5c32000 	strb	r2, [r3]
30013560:	e59d3014 	ldr	r3, [sp, #20]
30013564:	e2833001 	add	r3, r3, #1
30013568:	e58d3014 	str	r3, [sp, #20]
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
3001356c:	e5dd301f 	ldrb	r3, [sp, #31]
30013570:	e3530000 	cmp	r3, #0
30013574:	03a03000 	moveq	r3, #0
30013578:	13a03001 	movne	r3, #1
3001357c:	e20330ff 	and	r3, r3, #255	; 0xff
30013580:	e5dd201f 	ldrb	r2, [sp, #31]
30013584:	e2422001 	sub	r2, r2, #1
30013588:	e5cd201f 	strb	r2, [sp, #31]
3001358c:	e3530000 	cmp	r3, #0
30013590:	1affffea 	bne	30013540 <inet_ntoa+0xc4>
      *rp++ = inv[i];
    *rp++ = '.';
30013594:	e59d3014 	ldr	r3, [sp, #20]
30013598:	e3a0202e 	mov	r2, #46	; 0x2e
3001359c:	e5c32000 	strb	r2, [r3]
300135a0:	e59d3014 	ldr	r3, [sp, #20]
300135a4:	e2833001 	add	r3, r3, #1
300135a8:	e58d3014 	str	r3, [sp, #20]
    ap++;
300135ac:	e59d3018 	ldr	r3, [sp, #24]
300135b0:	e2833001 	add	r3, r3, #1
300135b4:	e58d3018 	str	r3, [sp, #24]
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
300135b8:	e5dd301e 	ldrb	r3, [sp, #30]
300135bc:	e2833001 	add	r3, r3, #1
300135c0:	e5cd301e 	strb	r3, [sp, #30]
300135c4:	e5dd301e 	ldrb	r3, [sp, #30]
300135c8:	e3530003 	cmp	r3, #3
300135cc:	9affffb5 	bls	300134a8 <inet_ntoa+0x2c>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
300135d0:	e59d3014 	ldr	r3, [sp, #20]
300135d4:	e2433001 	sub	r3, r3, #1
300135d8:	e58d3014 	str	r3, [sp, #20]
300135dc:	e59d3014 	ldr	r3, [sp, #20]
300135e0:	e3a02000 	mov	r2, #0
300135e4:	e5c32000 	strb	r2, [r3]
  return str;
300135e8:	e59f3008 	ldr	r3, [pc, #8]	; 300135f8 <inet_ntoa+0x17c>
}
300135ec:	e1a00003 	mov	r0, r3
300135f0:	e28dd020 	add	sp, sp, #32
300135f4:	e12fff1e 	bx	lr
300135f8:	300ca650 	.word	0x300ca650
300135fc:	cccccccd 	.word	0xcccccccd

30013600 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
30013600:	e24dd008 	sub	sp, sp, #8
30013604:	e1a03000 	mov	r3, r0
30013608:	e1cd30b6 	strh	r3, [sp, #6]
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
3001360c:	e1dd30b6 	ldrh	r3, [sp, #6]
30013610:	e1a03403 	lsl	r3, r3, #8
30013614:	e1a03803 	lsl	r3, r3, #16
30013618:	e1a02823 	lsr	r2, r3, #16
3001361c:	e1dd30b6 	ldrh	r3, [sp, #6]
30013620:	e1a03423 	lsr	r3, r3, #8
30013624:	e1a03803 	lsl	r3, r3, #16
30013628:	e1a03823 	lsr	r3, r3, #16
3001362c:	e1823003 	orr	r3, r2, r3
30013630:	e1a03803 	lsl	r3, r3, #16
30013634:	e1a03823 	lsr	r3, r3, #16
30013638:	e1a03803 	lsl	r3, r3, #16
3001363c:	e1a03823 	lsr	r3, r3, #16
}
30013640:	e1a00003 	mov	r0, r3
30013644:	e28dd008 	add	sp, sp, #8
30013648:	e12fff1e 	bx	lr

3001364c <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
3001364c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30013650:	e24dd00c 	sub	sp, sp, #12
30013654:	e1a03000 	mov	r3, r0
30013658:	e1cd30b6 	strh	r3, [sp, #6]
  return htons(n);
3001365c:	e1dd30b6 	ldrh	r3, [sp, #6]
30013660:	e1a00003 	mov	r0, r3
30013664:	ebffffe5 	bl	30013600 <htons>
30013668:	e1a03000 	mov	r3, r0
}
3001366c:	e1a00003 	mov	r0, r3
30013670:	e28dd00c 	add	sp, sp, #12
30013674:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30013678:	e12fff1e 	bx	lr

3001367c <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
3001367c:	e24dd008 	sub	sp, sp, #8
30013680:	e58d0004 	str	r0, [sp, #4]
  return ((n & 0xff) << 24) |
30013684:	e59d3004 	ldr	r3, [sp, #4]
30013688:	e1a02c03 	lsl	r2, r3, #24
    ((n & 0xff00) << 8) |
3001368c:	e59d3004 	ldr	r3, [sp, #4]
30013690:	e2033cff 	and	r3, r3, #65280	; 0xff00
30013694:	e1a03403 	lsl	r3, r3, #8
30013698:	e1822003 	orr	r2, r2, r3
    ((n & 0xff0000UL) >> 8) |
3001369c:	e59d3004 	ldr	r3, [sp, #4]
300136a0:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
300136a4:	e1a03423 	lsr	r3, r3, #8
300136a8:	e1822003 	orr	r2, r2, r3
    ((n & 0xff000000UL) >> 24);
300136ac:	e59d3004 	ldr	r3, [sp, #4]
300136b0:	e1a03c23 	lsr	r3, r3, #24
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
300136b4:	e1823003 	orr	r3, r2, r3
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
300136b8:	e1a00003 	mov	r0, r3
300136bc:	e28dd008 	add	sp, sp, #8
300136c0:	e12fff1e 	bx	lr

300136c4 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
300136c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300136c8:	e24dd00c 	sub	sp, sp, #12
300136cc:	e58d0004 	str	r0, [sp, #4]
  return htonl(n);
300136d0:	e59d0004 	ldr	r0, [sp, #4]
300136d4:	ebffffe8 	bl	3001367c <htonl>
300136d8:	e1a03000 	mov	r3, r0
}
300136dc:	e1a00003 	mov	r0, r3
300136e0:	e28dd00c 	add	sp, sp, #12
300136e4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300136e8:	e12fff1e 	bx	lr

300136ec <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
300136ec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300136f0:	e24dd01c 	sub	sp, sp, #28
300136f4:	e58d0004 	str	r0, [sp, #4]
300136f8:	e1a03001 	mov	r3, r1
300136fc:	e1cd30b2 	strh	r3, [sp, #2]
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
30013700:	e3a03000 	mov	r3, #0
30013704:	e58d300c 	str	r3, [sp, #12]
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
30013708:	e59d3004 	ldr	r3, [sp, #4]
3001370c:	e58d3014 	str	r3, [sp, #20]
  while (len > 1)
30013710:	ea000016 	b	30013770 <lwip_standard_chksum+0x84>
  {
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
30013714:	e59d3014 	ldr	r3, [sp, #20]
30013718:	e5d33000 	ldrb	r3, [r3]
3001371c:	e1a03403 	lsl	r3, r3, #8
30013720:	e1cd31b2 	strh	r3, [sp, #18]
    octetptr++;
30013724:	e59d3014 	ldr	r3, [sp, #20]
30013728:	e2833001 	add	r3, r3, #1
3001372c:	e58d3014 	str	r3, [sp, #20]
    /* declare second octet as least significant */
    src |= (*octetptr);
30013730:	e59d3014 	ldr	r3, [sp, #20]
30013734:	e5d33000 	ldrb	r3, [r3]
30013738:	e1a02003 	mov	r2, r3
3001373c:	e1dd31b2 	ldrh	r3, [sp, #18]
30013740:	e1823003 	orr	r3, r2, r3
30013744:	e1cd31b2 	strh	r3, [sp, #18]
    octetptr++;
30013748:	e59d3014 	ldr	r3, [sp, #20]
3001374c:	e2833001 	add	r3, r3, #1
30013750:	e58d3014 	str	r3, [sp, #20]
    acc += src;
30013754:	e1dd31b2 	ldrh	r3, [sp, #18]
30013758:	e59d200c 	ldr	r2, [sp, #12]
3001375c:	e0823003 	add	r3, r2, r3
30013760:	e58d300c 	str	r3, [sp, #12]
    len -= 2;
30013764:	e1dd30b2 	ldrh	r3, [sp, #2]
30013768:	e2433002 	sub	r3, r3, #2
3001376c:	e1cd30b2 	strh	r3, [sp, #2]
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1)
30013770:	e1dd30b2 	ldrh	r3, [sp, #2]
30013774:	e3530001 	cmp	r3, #1
30013778:	8affffe5 	bhi	30013714 <lwip_standard_chksum+0x28>
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0)
3001377c:	e1dd30b2 	ldrh	r3, [sp, #2]
30013780:	e3530000 	cmp	r3, #0
30013784:	0a000007 	beq	300137a8 <lwip_standard_chksum+0xbc>
  {
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
30013788:	e59d3014 	ldr	r3, [sp, #20]
3001378c:	e5d33000 	ldrb	r3, [r3]
30013790:	e1a03403 	lsl	r3, r3, #8
30013794:	e1cd31b2 	strh	r3, [sp, #18]
    acc += src;
30013798:	e1dd31b2 	ldrh	r3, [sp, #18]
3001379c:	e59d200c 	ldr	r2, [sp, #12]
300137a0:	e0823003 	add	r3, r2, r3
300137a4:	e58d300c 	str	r3, [sp, #12]
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
300137a8:	e59d300c 	ldr	r3, [sp, #12]
300137ac:	e1a02823 	lsr	r2, r3, #16
300137b0:	e59d300c 	ldr	r3, [sp, #12]
300137b4:	e1a03803 	lsl	r3, r3, #16
300137b8:	e1a03823 	lsr	r3, r3, #16
300137bc:	e0823003 	add	r3, r2, r3
300137c0:	e58d300c 	str	r3, [sp, #12]
  if ((acc & 0xffff0000) != 0) {
300137c4:	e59d300c 	ldr	r3, [sp, #12]
300137c8:	e1a03823 	lsr	r3, r3, #16
300137cc:	e1a03803 	lsl	r3, r3, #16
300137d0:	e3530000 	cmp	r3, #0
300137d4:	0a000006 	beq	300137f4 <lwip_standard_chksum+0x108>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
300137d8:	e59d300c 	ldr	r3, [sp, #12]
300137dc:	e1a02823 	lsr	r2, r3, #16
300137e0:	e59d300c 	ldr	r3, [sp, #12]
300137e4:	e1a03803 	lsl	r3, r3, #16
300137e8:	e1a03823 	lsr	r3, r3, #16
300137ec:	e0823003 	add	r3, r2, r3
300137f0:	e58d300c 	str	r3, [sp, #12]
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
300137f4:	e59d300c 	ldr	r3, [sp, #12]
300137f8:	e1a03803 	lsl	r3, r3, #16
300137fc:	e1a03823 	lsr	r3, r3, #16
30013800:	e1a00003 	mov	r0, r3
30013804:	ebffff7d 	bl	30013600 <htons>
30013808:	e1a03000 	mov	r3, r0
}
3001380c:	e1a00003 	mov	r0, r3
30013810:	e28dd01c 	add	sp, sp, #28
30013814:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30013818:	e12fff1e 	bx	lr

3001381c <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
3001381c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30013820:	e24dd024 	sub	sp, sp, #36	; 0x24
30013824:	e58d000c 	str	r0, [sp, #12]
30013828:	e58d1008 	str	r1, [sp, #8]
3001382c:	e58d2004 	str	r2, [sp, #4]
30013830:	e5cd3003 	strb	r3, [sp, #3]
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
30013834:	e3a03000 	mov	r3, #0
30013838:	e58d3014 	str	r3, [sp, #20]
  swapped = 0;
3001383c:	e3a03000 	mov	r3, #0
30013840:	e5cd301f 	strb	r3, [sp, #31]
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
30013844:	e59d300c 	ldr	r3, [sp, #12]
30013848:	e58d3018 	str	r3, [sp, #24]
3001384c:	ea00002b 	b	30013900 <inet_chksum_pseudo+0xe4>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
30013850:	e59d3018 	ldr	r3, [sp, #24]
30013854:	e5932004 	ldr	r2, [r3, #4]
30013858:	e59d3018 	ldr	r3, [sp, #24]
3001385c:	e1d330ba 	ldrh	r3, [r3, #10]
30013860:	e1a00002 	mov	r0, r2
30013864:	e1a01003 	mov	r1, r3
30013868:	ebffff9f 	bl	300136ec <lwip_standard_chksum>
3001386c:	e1a03000 	mov	r3, r0
30013870:	e59d2014 	ldr	r2, [sp, #20]
30013874:	e0823003 	add	r3, r2, r3
30013878:	e58d3014 	str	r3, [sp, #20]
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    while ((acc >> 16) != 0) {
3001387c:	ea000006 	b	3001389c <inet_chksum_pseudo+0x80>
      acc = (acc & 0xffffUL) + (acc >> 16);
30013880:	e59d3014 	ldr	r3, [sp, #20]
30013884:	e1a03803 	lsl	r3, r3, #16
30013888:	e1a03823 	lsr	r3, r3, #16
3001388c:	e59d2014 	ldr	r2, [sp, #20]
30013890:	e1a02822 	lsr	r2, r2, #16
30013894:	e0833002 	add	r3, r3, r2
30013898:	e58d3014 	str	r3, [sp, #20]
  for(q = p; q != NULL; q = q->next) {
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    while ((acc >> 16) != 0) {
3001389c:	e59d3014 	ldr	r3, [sp, #20]
300138a0:	e1a03823 	lsr	r3, r3, #16
300138a4:	e3530000 	cmp	r3, #0
300138a8:	1afffff4 	bne	30013880 <inet_chksum_pseudo+0x64>
      acc = (acc & 0xffffUL) + (acc >> 16);
    }
    if (q->len % 2 != 0) {
300138ac:	e59d3018 	ldr	r3, [sp, #24]
300138b0:	e1d330ba 	ldrh	r3, [r3, #10]
300138b4:	e2033001 	and	r3, r3, #1
300138b8:	e20330ff 	and	r3, r3, #255	; 0xff
300138bc:	e3530000 	cmp	r3, #0
300138c0:	0a00000b 	beq	300138f4 <inet_chksum_pseudo+0xd8>
      swapped = 1 - swapped;
300138c4:	e5dd301f 	ldrb	r3, [sp, #31]
300138c8:	e2633001 	rsb	r3, r3, #1
300138cc:	e5cd301f 	strb	r3, [sp, #31]
      acc = ((acc & 0xff) << 8) | ((acc & 0xff00UL) >> 8);
300138d0:	e59d3014 	ldr	r3, [sp, #20]
300138d4:	e1a03403 	lsl	r3, r3, #8
300138d8:	e1a03803 	lsl	r3, r3, #16
300138dc:	e1a03823 	lsr	r3, r3, #16
300138e0:	e59d2014 	ldr	r2, [sp, #20]
300138e4:	e2022cff 	and	r2, r2, #65280	; 0xff00
300138e8:	e1a02422 	lsr	r2, r2, #8
300138ec:	e1833002 	orr	r3, r3, r2
300138f0:	e58d3014 	str	r3, [sp, #20]
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
300138f4:	e59d3018 	ldr	r3, [sp, #24]
300138f8:	e5933000 	ldr	r3, [r3]
300138fc:	e58d3018 	str	r3, [sp, #24]
30013900:	e59d3018 	ldr	r3, [sp, #24]
30013904:	e3530000 	cmp	r3, #0
30013908:	1affffd0 	bne	30013850 <inet_chksum_pseudo+0x34>
      acc = ((acc & 0xff) << 8) | ((acc & 0xff00UL) >> 8);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
3001390c:	e5dd301f 	ldrb	r3, [sp, #31]
30013910:	e3530000 	cmp	r3, #0
30013914:	0a000008 	beq	3001393c <inet_chksum_pseudo+0x120>
    acc = ((acc & 0xff) << 8) | ((acc & 0xff00UL) >> 8);
30013918:	e59d3014 	ldr	r3, [sp, #20]
3001391c:	e1a03403 	lsl	r3, r3, #8
30013920:	e1a03803 	lsl	r3, r3, #16
30013924:	e1a03823 	lsr	r3, r3, #16
30013928:	e59d2014 	ldr	r2, [sp, #20]
3001392c:	e2022cff 	and	r2, r2, #65280	; 0xff00
30013930:	e1a02422 	lsr	r2, r2, #8
30013934:	e1833002 	orr	r3, r3, r2
30013938:	e58d3014 	str	r3, [sp, #20]
  }
  acc += (src->addr & 0xffffUL);
3001393c:	e59d3008 	ldr	r3, [sp, #8]
30013940:	e5d32000 	ldrb	r2, [r3]
30013944:	e5d31001 	ldrb	r1, [r3, #1]
30013948:	e1a01401 	lsl	r1, r1, #8
3001394c:	e1812002 	orr	r2, r1, r2
30013950:	e5d31002 	ldrb	r1, [r3, #2]
30013954:	e1a01801 	lsl	r1, r1, #16
30013958:	e1812002 	orr	r2, r1, r2
3001395c:	e5d33003 	ldrb	r3, [r3, #3]
30013960:	e1a03c03 	lsl	r3, r3, #24
30013964:	e1833002 	orr	r3, r3, r2
30013968:	e1a03803 	lsl	r3, r3, #16
3001396c:	e1a03823 	lsr	r3, r3, #16
30013970:	e59d2014 	ldr	r2, [sp, #20]
30013974:	e0823003 	add	r3, r2, r3
30013978:	e58d3014 	str	r3, [sp, #20]
  acc += ((src->addr >> 16) & 0xffffUL);
3001397c:	e59d3008 	ldr	r3, [sp, #8]
30013980:	e5d32000 	ldrb	r2, [r3]
30013984:	e5d31001 	ldrb	r1, [r3, #1]
30013988:	e1a01401 	lsl	r1, r1, #8
3001398c:	e1812002 	orr	r2, r1, r2
30013990:	e5d31002 	ldrb	r1, [r3, #2]
30013994:	e1a01801 	lsl	r1, r1, #16
30013998:	e1812002 	orr	r2, r1, r2
3001399c:	e5d33003 	ldrb	r3, [r3, #3]
300139a0:	e1a03c03 	lsl	r3, r3, #24
300139a4:	e1833002 	orr	r3, r3, r2
300139a8:	e1a03823 	lsr	r3, r3, #16
300139ac:	e59d2014 	ldr	r2, [sp, #20]
300139b0:	e0823003 	add	r3, r2, r3
300139b4:	e58d3014 	str	r3, [sp, #20]
  acc += (dest->addr & 0xffffUL);
300139b8:	e59d3004 	ldr	r3, [sp, #4]
300139bc:	e5d32000 	ldrb	r2, [r3]
300139c0:	e5d31001 	ldrb	r1, [r3, #1]
300139c4:	e1a01401 	lsl	r1, r1, #8
300139c8:	e1812002 	orr	r2, r1, r2
300139cc:	e5d31002 	ldrb	r1, [r3, #2]
300139d0:	e1a01801 	lsl	r1, r1, #16
300139d4:	e1812002 	orr	r2, r1, r2
300139d8:	e5d33003 	ldrb	r3, [r3, #3]
300139dc:	e1a03c03 	lsl	r3, r3, #24
300139e0:	e1833002 	orr	r3, r3, r2
300139e4:	e1a03803 	lsl	r3, r3, #16
300139e8:	e1a03823 	lsr	r3, r3, #16
300139ec:	e59d2014 	ldr	r2, [sp, #20]
300139f0:	e0823003 	add	r3, r2, r3
300139f4:	e58d3014 	str	r3, [sp, #20]
  acc += ((dest->addr >> 16) & 0xffffUL);
300139f8:	e59d3004 	ldr	r3, [sp, #4]
300139fc:	e5d32000 	ldrb	r2, [r3]
30013a00:	e5d31001 	ldrb	r1, [r3, #1]
30013a04:	e1a01401 	lsl	r1, r1, #8
30013a08:	e1812002 	orr	r2, r1, r2
30013a0c:	e5d31002 	ldrb	r1, [r3, #2]
30013a10:	e1a01801 	lsl	r1, r1, #16
30013a14:	e1812002 	orr	r2, r1, r2
30013a18:	e5d33003 	ldrb	r3, [r3, #3]
30013a1c:	e1a03c03 	lsl	r3, r3, #24
30013a20:	e1833002 	orr	r3, r3, r2
30013a24:	e1a03823 	lsr	r3, r3, #16
30013a28:	e59d2014 	ldr	r2, [sp, #20]
30013a2c:	e0823003 	add	r3, r2, r3
30013a30:	e58d3014 	str	r3, [sp, #20]
  acc += (u32_t)htons((u16_t)proto);
30013a34:	e5dd3003 	ldrb	r3, [sp, #3]
30013a38:	e1a00003 	mov	r0, r3
30013a3c:	ebfffeef 	bl	30013600 <htons>
30013a40:	e1a03000 	mov	r3, r0
30013a44:	e59d2014 	ldr	r2, [sp, #20]
30013a48:	e0823003 	add	r3, r2, r3
30013a4c:	e58d3014 	str	r3, [sp, #20]
  acc += (u32_t)htons(proto_len);
30013a50:	e1dd32b8 	ldrh	r3, [sp, #40]	; 0x28
30013a54:	e1a00003 	mov	r0, r3
30013a58:	ebfffee8 	bl	30013600 <htons>
30013a5c:	e1a03000 	mov	r3, r0
30013a60:	e59d2014 	ldr	r2, [sp, #20]
30013a64:	e0823003 	add	r3, r2, r3
30013a68:	e58d3014 	str	r3, [sp, #20]

  while ((acc >> 16) != 0) {
30013a6c:	ea000006 	b	30013a8c <inet_chksum_pseudo+0x270>
    acc = (acc & 0xffffUL) + (acc >> 16);
30013a70:	e59d3014 	ldr	r3, [sp, #20]
30013a74:	e1a03803 	lsl	r3, r3, #16
30013a78:	e1a03823 	lsr	r3, r3, #16
30013a7c:	e59d2014 	ldr	r2, [sp, #20]
30013a80:	e1a02822 	lsr	r2, r2, #16
30013a84:	e0833002 	add	r3, r3, r2
30013a88:	e58d3014 	str	r3, [sp, #20]
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
  acc += (u32_t)htons(proto_len);

  while ((acc >> 16) != 0) {
30013a8c:	e59d3014 	ldr	r3, [sp, #20]
30013a90:	e1a03823 	lsr	r3, r3, #16
30013a94:	e3530000 	cmp	r3, #0
30013a98:	1afffff4 	bne	30013a70 <inet_chksum_pseudo+0x254>
    acc = (acc & 0xffffUL) + (acc >> 16);
  }
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
30013a9c:	e59d3014 	ldr	r3, [sp, #20]
30013aa0:	e1a03803 	lsl	r3, r3, #16
30013aa4:	e1a03823 	lsr	r3, r3, #16
30013aa8:	e1e03003 	mvn	r3, r3
30013aac:	e1a03803 	lsl	r3, r3, #16
30013ab0:	e1a03823 	lsr	r3, r3, #16
}
30013ab4:	e1a00003 	mov	r0, r3
30013ab8:	e28dd024 	add	sp, sp, #36	; 0x24
30013abc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30013ac0:	e12fff1e 	bx	lr

30013ac4 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
30013ac4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30013ac8:	e24dd024 	sub	sp, sp, #36	; 0x24
30013acc:	e58d000c 	str	r0, [sp, #12]
30013ad0:	e58d1008 	str	r1, [sp, #8]
30013ad4:	e58d2004 	str	r2, [sp, #4]
30013ad8:	e5cd3003 	strb	r3, [sp, #3]
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
30013adc:	e3a03000 	mov	r3, #0
30013ae0:	e58d3014 	str	r3, [sp, #20]
  swapped = 0;
30013ae4:	e3a03000 	mov	r3, #0
30013ae8:	e5cd301d 	strb	r3, [sp, #29]
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
30013aec:	e59d300c 	ldr	r3, [sp, #12]
30013af0:	e58d3018 	str	r3, [sp, #24]
30013af4:	ea000037 	b	30013bd8 <inet_chksum_pseudo_partial+0x114>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
30013af8:	e59d3018 	ldr	r3, [sp, #24]
30013afc:	e1d330ba 	ldrh	r3, [r3, #10]
30013b00:	e1cd31be 	strh	r3, [sp, #30]
    if (chklen > chksum_len) {
30013b04:	e1dd21be 	ldrh	r2, [sp, #30]
30013b08:	e1dd32bc 	ldrh	r3, [sp, #44]	; 0x2c
30013b0c:	e1520003 	cmp	r2, r3
30013b10:	9a000001 	bls	30013b1c <inet_chksum_pseudo_partial+0x58>
      chklen = chksum_len;
30013b14:	e1dd32bc 	ldrh	r3, [sp, #44]	; 0x2c
30013b18:	e1cd31be 	strh	r3, [sp, #30]
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
30013b1c:	e59d3018 	ldr	r3, [sp, #24]
30013b20:	e5932004 	ldr	r2, [r3, #4]
30013b24:	e1dd31be 	ldrh	r3, [sp, #30]
30013b28:	e1a00002 	mov	r0, r2
30013b2c:	e1a01003 	mov	r1, r3
30013b30:	ebfffeed 	bl	300136ec <lwip_standard_chksum>
30013b34:	e1a03000 	mov	r3, r0
30013b38:	e59d2014 	ldr	r2, [sp, #20]
30013b3c:	e0823003 	add	r3, r2, r3
30013b40:	e58d3014 	str	r3, [sp, #20]
    chksum_len -= chklen;
30013b44:	e1dd22bc 	ldrh	r2, [sp, #44]	; 0x2c
30013b48:	e1dd31be 	ldrh	r3, [sp, #30]
30013b4c:	e0633002 	rsb	r3, r3, r2
30013b50:	e1cd32bc 	strh	r3, [sp, #44]	; 0x2c
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    while ((acc >> 16) != 0) {
30013b54:	ea000006 	b	30013b74 <inet_chksum_pseudo_partial+0xb0>
      acc = (acc & 0xffffUL) + (acc >> 16);
30013b58:	e59d3014 	ldr	r3, [sp, #20]
30013b5c:	e1a03803 	lsl	r3, r3, #16
30013b60:	e1a03823 	lsr	r3, r3, #16
30013b64:	e59d2014 	ldr	r2, [sp, #20]
30013b68:	e1a02822 	lsr	r2, r2, #16
30013b6c:	e0833002 	add	r3, r3, r2
30013b70:	e58d3014 	str	r3, [sp, #20]
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    while ((acc >> 16) != 0) {
30013b74:	e59d3014 	ldr	r3, [sp, #20]
30013b78:	e1a03823 	lsr	r3, r3, #16
30013b7c:	e3530000 	cmp	r3, #0
30013b80:	1afffff4 	bne	30013b58 <inet_chksum_pseudo_partial+0x94>
      acc = (acc & 0xffffUL) + (acc >> 16);
    }
    if (q->len % 2 != 0) {
30013b84:	e59d3018 	ldr	r3, [sp, #24]
30013b88:	e1d330ba 	ldrh	r3, [r3, #10]
30013b8c:	e2033001 	and	r3, r3, #1
30013b90:	e20330ff 	and	r3, r3, #255	; 0xff
30013b94:	e3530000 	cmp	r3, #0
30013b98:	0a00000b 	beq	30013bcc <inet_chksum_pseudo_partial+0x108>
      swapped = 1 - swapped;
30013b9c:	e5dd301d 	ldrb	r3, [sp, #29]
30013ba0:	e2633001 	rsb	r3, r3, #1
30013ba4:	e5cd301d 	strb	r3, [sp, #29]
      acc = ((acc & 0xff) << 8) | ((acc & 0xff00UL) >> 8);
30013ba8:	e59d3014 	ldr	r3, [sp, #20]
30013bac:	e1a03403 	lsl	r3, r3, #8
30013bb0:	e1a03803 	lsl	r3, r3, #16
30013bb4:	e1a03823 	lsr	r3, r3, #16
30013bb8:	e59d2014 	ldr	r2, [sp, #20]
30013bbc:	e2022cff 	and	r2, r2, #65280	; 0xff00
30013bc0:	e1a02422 	lsr	r2, r2, #8
30013bc4:	e1833002 	orr	r3, r3, r2
30013bc8:	e58d3014 	str	r3, [sp, #20]
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
30013bcc:	e59d3018 	ldr	r3, [sp, #24]
30013bd0:	e5933000 	ldr	r3, [r3]
30013bd4:	e58d3018 	str	r3, [sp, #24]
30013bd8:	e59d3018 	ldr	r3, [sp, #24]
30013bdc:	e3530000 	cmp	r3, #0
30013be0:	0a000002 	beq	30013bf0 <inet_chksum_pseudo_partial+0x12c>
30013be4:	e1dd32bc 	ldrh	r3, [sp, #44]	; 0x2c
30013be8:	e3530000 	cmp	r3, #0
30013bec:	1affffc1 	bne	30013af8 <inet_chksum_pseudo_partial+0x34>
      acc = ((acc & 0xff) << 8) | ((acc & 0xff00UL) >> 8);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
30013bf0:	e5dd301d 	ldrb	r3, [sp, #29]
30013bf4:	e3530000 	cmp	r3, #0
30013bf8:	0a000008 	beq	30013c20 <inet_chksum_pseudo_partial+0x15c>
    acc = ((acc & 0xff) << 8) | ((acc & 0xff00UL) >> 8);
30013bfc:	e59d3014 	ldr	r3, [sp, #20]
30013c00:	e1a03403 	lsl	r3, r3, #8
30013c04:	e1a03803 	lsl	r3, r3, #16
30013c08:	e1a03823 	lsr	r3, r3, #16
30013c0c:	e59d2014 	ldr	r2, [sp, #20]
30013c10:	e2022cff 	and	r2, r2, #65280	; 0xff00
30013c14:	e1a02422 	lsr	r2, r2, #8
30013c18:	e1833002 	orr	r3, r3, r2
30013c1c:	e58d3014 	str	r3, [sp, #20]
  }
  acc += (src->addr & 0xffffUL);
30013c20:	e59d3008 	ldr	r3, [sp, #8]
30013c24:	e5d32000 	ldrb	r2, [r3]
30013c28:	e5d31001 	ldrb	r1, [r3, #1]
30013c2c:	e1a01401 	lsl	r1, r1, #8
30013c30:	e1812002 	orr	r2, r1, r2
30013c34:	e5d31002 	ldrb	r1, [r3, #2]
30013c38:	e1a01801 	lsl	r1, r1, #16
30013c3c:	e1812002 	orr	r2, r1, r2
30013c40:	e5d33003 	ldrb	r3, [r3, #3]
30013c44:	e1a03c03 	lsl	r3, r3, #24
30013c48:	e1833002 	orr	r3, r3, r2
30013c4c:	e1a03803 	lsl	r3, r3, #16
30013c50:	e1a03823 	lsr	r3, r3, #16
30013c54:	e59d2014 	ldr	r2, [sp, #20]
30013c58:	e0823003 	add	r3, r2, r3
30013c5c:	e58d3014 	str	r3, [sp, #20]
  acc += ((src->addr >> 16) & 0xffffUL);
30013c60:	e59d3008 	ldr	r3, [sp, #8]
30013c64:	e5d32000 	ldrb	r2, [r3]
30013c68:	e5d31001 	ldrb	r1, [r3, #1]
30013c6c:	e1a01401 	lsl	r1, r1, #8
30013c70:	e1812002 	orr	r2, r1, r2
30013c74:	e5d31002 	ldrb	r1, [r3, #2]
30013c78:	e1a01801 	lsl	r1, r1, #16
30013c7c:	e1812002 	orr	r2, r1, r2
30013c80:	e5d33003 	ldrb	r3, [r3, #3]
30013c84:	e1a03c03 	lsl	r3, r3, #24
30013c88:	e1833002 	orr	r3, r3, r2
30013c8c:	e1a03823 	lsr	r3, r3, #16
30013c90:	e59d2014 	ldr	r2, [sp, #20]
30013c94:	e0823003 	add	r3, r2, r3
30013c98:	e58d3014 	str	r3, [sp, #20]
  acc += (dest->addr & 0xffffUL);
30013c9c:	e59d3004 	ldr	r3, [sp, #4]
30013ca0:	e5d32000 	ldrb	r2, [r3]
30013ca4:	e5d31001 	ldrb	r1, [r3, #1]
30013ca8:	e1a01401 	lsl	r1, r1, #8
30013cac:	e1812002 	orr	r2, r1, r2
30013cb0:	e5d31002 	ldrb	r1, [r3, #2]
30013cb4:	e1a01801 	lsl	r1, r1, #16
30013cb8:	e1812002 	orr	r2, r1, r2
30013cbc:	e5d33003 	ldrb	r3, [r3, #3]
30013cc0:	e1a03c03 	lsl	r3, r3, #24
30013cc4:	e1833002 	orr	r3, r3, r2
30013cc8:	e1a03803 	lsl	r3, r3, #16
30013ccc:	e1a03823 	lsr	r3, r3, #16
30013cd0:	e59d2014 	ldr	r2, [sp, #20]
30013cd4:	e0823003 	add	r3, r2, r3
30013cd8:	e58d3014 	str	r3, [sp, #20]
  acc += ((dest->addr >> 16) & 0xffffUL);
30013cdc:	e59d3004 	ldr	r3, [sp, #4]
30013ce0:	e5d32000 	ldrb	r2, [r3]
30013ce4:	e5d31001 	ldrb	r1, [r3, #1]
30013ce8:	e1a01401 	lsl	r1, r1, #8
30013cec:	e1812002 	orr	r2, r1, r2
30013cf0:	e5d31002 	ldrb	r1, [r3, #2]
30013cf4:	e1a01801 	lsl	r1, r1, #16
30013cf8:	e1812002 	orr	r2, r1, r2
30013cfc:	e5d33003 	ldrb	r3, [r3, #3]
30013d00:	e1a03c03 	lsl	r3, r3, #24
30013d04:	e1833002 	orr	r3, r3, r2
30013d08:	e1a03823 	lsr	r3, r3, #16
30013d0c:	e59d2014 	ldr	r2, [sp, #20]
30013d10:	e0823003 	add	r3, r2, r3
30013d14:	e58d3014 	str	r3, [sp, #20]
  acc += (u32_t)htons((u16_t)proto);
30013d18:	e5dd3003 	ldrb	r3, [sp, #3]
30013d1c:	e1a00003 	mov	r0, r3
30013d20:	ebfffe36 	bl	30013600 <htons>
30013d24:	e1a03000 	mov	r3, r0
30013d28:	e59d2014 	ldr	r2, [sp, #20]
30013d2c:	e0823003 	add	r3, r2, r3
30013d30:	e58d3014 	str	r3, [sp, #20]
  acc += (u32_t)htons(proto_len);
30013d34:	e1dd32b8 	ldrh	r3, [sp, #40]	; 0x28
30013d38:	e1a00003 	mov	r0, r3
30013d3c:	ebfffe2f 	bl	30013600 <htons>
30013d40:	e1a03000 	mov	r3, r0
30013d44:	e59d2014 	ldr	r2, [sp, #20]
30013d48:	e0823003 	add	r3, r2, r3
30013d4c:	e58d3014 	str	r3, [sp, #20]

  while ((acc >> 16) != 0) {
30013d50:	ea000006 	b	30013d70 <inet_chksum_pseudo_partial+0x2ac>
    acc = (acc & 0xffffUL) + (acc >> 16);
30013d54:	e59d3014 	ldr	r3, [sp, #20]
30013d58:	e1a03803 	lsl	r3, r3, #16
30013d5c:	e1a03823 	lsr	r3, r3, #16
30013d60:	e59d2014 	ldr	r2, [sp, #20]
30013d64:	e1a02822 	lsr	r2, r2, #16
30013d68:	e0833002 	add	r3, r3, r2
30013d6c:	e58d3014 	str	r3, [sp, #20]
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
  acc += (u32_t)htons(proto_len);

  while ((acc >> 16) != 0) {
30013d70:	e59d3014 	ldr	r3, [sp, #20]
30013d74:	e1a03823 	lsr	r3, r3, #16
30013d78:	e3530000 	cmp	r3, #0
30013d7c:	1afffff4 	bne	30013d54 <inet_chksum_pseudo_partial+0x290>
    acc = (acc & 0xffffUL) + (acc >> 16);
  }
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
30013d80:	e59d3014 	ldr	r3, [sp, #20]
30013d84:	e1a03803 	lsl	r3, r3, #16
30013d88:	e1a03823 	lsr	r3, r3, #16
30013d8c:	e1e03003 	mvn	r3, r3
30013d90:	e1a03803 	lsl	r3, r3, #16
30013d94:	e1a03823 	lsr	r3, r3, #16
}
30013d98:	e1a00003 	mov	r0, r3
30013d9c:	e28dd024 	add	sp, sp, #36	; 0x24
30013da0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30013da4:	e12fff1e 	bx	lr

30013da8 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
30013da8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30013dac:	e24dd014 	sub	sp, sp, #20
30013db0:	e58d0004 	str	r0, [sp, #4]
30013db4:	e1a03001 	mov	r3, r1
30013db8:	e1cd30b2 	strh	r3, [sp, #2]
  u32_t acc;

  acc = LWIP_CHKSUM(dataptr, len);
30013dbc:	e1dd30b2 	ldrh	r3, [sp, #2]
30013dc0:	e59d0004 	ldr	r0, [sp, #4]
30013dc4:	e1a01003 	mov	r1, r3
30013dc8:	ebfffe47 	bl	300136ec <lwip_standard_chksum>
30013dcc:	e1a03000 	mov	r3, r0
30013dd0:	e58d300c 	str	r3, [sp, #12]
  while ((acc >> 16) != 0) {
30013dd4:	ea000006 	b	30013df4 <inet_chksum+0x4c>
    acc = (acc & 0xffff) + (acc >> 16);
30013dd8:	e59d300c 	ldr	r3, [sp, #12]
30013ddc:	e1a03803 	lsl	r3, r3, #16
30013de0:	e1a03823 	lsr	r3, r3, #16
30013de4:	e59d200c 	ldr	r2, [sp, #12]
30013de8:	e1a02822 	lsr	r2, r2, #16
30013dec:	e0833002 	add	r3, r3, r2
30013df0:	e58d300c 	str	r3, [sp, #12]
inet_chksum(void *dataptr, u16_t len)
{
  u32_t acc;

  acc = LWIP_CHKSUM(dataptr, len);
  while ((acc >> 16) != 0) {
30013df4:	e59d300c 	ldr	r3, [sp, #12]
30013df8:	e1a03823 	lsr	r3, r3, #16
30013dfc:	e3530000 	cmp	r3, #0
30013e00:	1afffff4 	bne	30013dd8 <inet_chksum+0x30>
    acc = (acc & 0xffff) + (acc >> 16);
  }
  return (u16_t)~(acc & 0xffff);
30013e04:	e59d300c 	ldr	r3, [sp, #12]
30013e08:	e1a03803 	lsl	r3, r3, #16
30013e0c:	e1a03823 	lsr	r3, r3, #16
30013e10:	e1e03003 	mvn	r3, r3
30013e14:	e1a03803 	lsl	r3, r3, #16
30013e18:	e1a03823 	lsr	r3, r3, #16
}
30013e1c:	e1a00003 	mov	r0, r3
30013e20:	e28dd014 	add	sp, sp, #20
30013e24:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30013e28:	e12fff1e 	bx	lr

30013e2c <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
30013e2c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30013e30:	e24dd01c 	sub	sp, sp, #28
30013e34:	e58d0004 	str	r0, [sp, #4]
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
30013e38:	e3a03000 	mov	r3, #0
30013e3c:	e58d300c 	str	r3, [sp, #12]
  swapped = 0;
30013e40:	e3a03000 	mov	r3, #0
30013e44:	e5cd3017 	strb	r3, [sp, #23]
  for(q = p; q != NULL; q = q->next) {
30013e48:	e59d3004 	ldr	r3, [sp, #4]
30013e4c:	e58d3010 	str	r3, [sp, #16]
30013e50:	ea000026 	b	30013ef0 <inet_chksum_pbuf+0xc4>
    acc += LWIP_CHKSUM(q->payload, q->len);
30013e54:	e59d3010 	ldr	r3, [sp, #16]
30013e58:	e5932004 	ldr	r2, [r3, #4]
30013e5c:	e59d3010 	ldr	r3, [sp, #16]
30013e60:	e1d330ba 	ldrh	r3, [r3, #10]
30013e64:	e1a00002 	mov	r0, r2
30013e68:	e1a01003 	mov	r1, r3
30013e6c:	ebfffe1e 	bl	300136ec <lwip_standard_chksum>
30013e70:	e1a03000 	mov	r3, r0
30013e74:	e59d200c 	ldr	r2, [sp, #12]
30013e78:	e0823003 	add	r3, r2, r3
30013e7c:	e58d300c 	str	r3, [sp, #12]
    while ((acc >> 16) != 0) {
30013e80:	ea000006 	b	30013ea0 <inet_chksum_pbuf+0x74>
      acc = (acc & 0xffffUL) + (acc >> 16);
30013e84:	e59d300c 	ldr	r3, [sp, #12]
30013e88:	e1a03803 	lsl	r3, r3, #16
30013e8c:	e1a03823 	lsr	r3, r3, #16
30013e90:	e59d200c 	ldr	r2, [sp, #12]
30013e94:	e1a02822 	lsr	r2, r2, #16
30013e98:	e0833002 	add	r3, r3, r2
30013e9c:	e58d300c 	str	r3, [sp, #12]

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    while ((acc >> 16) != 0) {
30013ea0:	e59d300c 	ldr	r3, [sp, #12]
30013ea4:	e1a03823 	lsr	r3, r3, #16
30013ea8:	e3530000 	cmp	r3, #0
30013eac:	1afffff4 	bne	30013e84 <inet_chksum_pbuf+0x58>
      acc = (acc & 0xffffUL) + (acc >> 16);
    }
    if (q->len % 2 != 0) {
30013eb0:	e59d3010 	ldr	r3, [sp, #16]
30013eb4:	e1d330ba 	ldrh	r3, [r3, #10]
30013eb8:	e2033001 	and	r3, r3, #1
30013ebc:	e20330ff 	and	r3, r3, #255	; 0xff
30013ec0:	e3530000 	cmp	r3, #0
30013ec4:	0a000006 	beq	30013ee4 <inet_chksum_pbuf+0xb8>
      swapped = 1 - swapped;
30013ec8:	e5dd3017 	ldrb	r3, [sp, #23]
30013ecc:	e2633001 	rsb	r3, r3, #1
30013ed0:	e5cd3017 	strb	r3, [sp, #23]
      acc = (acc & 0x00ffUL << 8) | (acc & 0xff00UL >> 8);
30013ed4:	e59d300c 	ldr	r3, [sp, #12]
30013ed8:	e1a03803 	lsl	r3, r3, #16
30013edc:	e1a03823 	lsr	r3, r3, #16
30013ee0:	e58d300c 	str	r3, [sp, #12]
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
30013ee4:	e59d3010 	ldr	r3, [sp, #16]
30013ee8:	e5933000 	ldr	r3, [r3]
30013eec:	e58d3010 	str	r3, [sp, #16]
30013ef0:	e59d3010 	ldr	r3, [sp, #16]
30013ef4:	e3530000 	cmp	r3, #0
30013ef8:	1affffd5 	bne	30013e54 <inet_chksum_pbuf+0x28>
      swapped = 1 - swapped;
      acc = (acc & 0x00ffUL << 8) | (acc & 0xff00UL >> 8);
    }
  }

  if (swapped) {
30013efc:	e5dd3017 	ldrb	r3, [sp, #23]
30013f00:	e3530000 	cmp	r3, #0
30013f04:	0a000008 	beq	30013f2c <inet_chksum_pbuf+0x100>
    acc = ((acc & 0x00ffUL) << 8) | ((acc & 0xff00UL) >> 8);
30013f08:	e59d300c 	ldr	r3, [sp, #12]
30013f0c:	e1a03403 	lsl	r3, r3, #8
30013f10:	e1a03803 	lsl	r3, r3, #16
30013f14:	e1a03823 	lsr	r3, r3, #16
30013f18:	e59d200c 	ldr	r2, [sp, #12]
30013f1c:	e2022cff 	and	r2, r2, #65280	; 0xff00
30013f20:	e1a02422 	lsr	r2, r2, #8
30013f24:	e1833002 	orr	r3, r3, r2
30013f28:	e58d300c 	str	r3, [sp, #12]
  }
  return (u16_t)~(acc & 0xffffUL);
30013f2c:	e59d300c 	ldr	r3, [sp, #12]
30013f30:	e1a03803 	lsl	r3, r3, #16
30013f34:	e1a03823 	lsr	r3, r3, #16
30013f38:	e1e03003 	mvn	r3, r3
30013f3c:	e1a03803 	lsl	r3, r3, #16
30013f40:	e1a03823 	lsr	r3, r3, #16
}
30013f44:	e1a00003 	mov	r0, r3
30013f48:	e28dd01c 	add	sp, sp, #28
30013f4c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30013f50:	e12fff1e 	bx	lr

30013f54 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
30013f54:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30013f58:	e24dd014 	sub	sp, sp, #20
30013f5c:	e58d0004 	str	r0, [sp, #4]
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
30013f60:	e59f30f4 	ldr	r3, [pc, #244]	; 3001405c <ip_route+0x108>
30013f64:	e5933000 	ldr	r3, [r3]
30013f68:	e58d300c 	str	r3, [sp, #12]
30013f6c:	ea00001d 	b	30013fe8 <ip_route+0x94>
    /* network mask matches? */
    if (netif_is_up(netif)) {
30013f70:	e59d000c 	ldr	r0, [sp, #12]
30013f74:	eb000707 	bl	30015b98 <netif_is_up>
30013f78:	e1a03000 	mov	r3, r0
30013f7c:	e3530000 	cmp	r3, #0
30013f80:	0a000015 	beq	30013fdc <ip_route+0x88>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
30013f84:	e59d3004 	ldr	r3, [sp, #4]
30013f88:	e5d32000 	ldrb	r2, [r3]
30013f8c:	e5d31001 	ldrb	r1, [r3, #1]
30013f90:	e1a01401 	lsl	r1, r1, #8
30013f94:	e1812002 	orr	r2, r1, r2
30013f98:	e5d31002 	ldrb	r1, [r3, #2]
30013f9c:	e1a01801 	lsl	r1, r1, #16
30013fa0:	e1812002 	orr	r2, r1, r2
30013fa4:	e5d33003 	ldrb	r3, [r3, #3]
30013fa8:	e1a03c03 	lsl	r3, r3, #24
30013fac:	e1833002 	orr	r3, r3, r2
30013fb0:	e1a02003 	mov	r2, r3
30013fb4:	e59d300c 	ldr	r3, [sp, #12]
30013fb8:	e5933004 	ldr	r3, [r3, #4]
30013fbc:	e0222003 	eor	r2, r2, r3
30013fc0:	e59d300c 	ldr	r3, [sp, #12]
30013fc4:	e5933008 	ldr	r3, [r3, #8]
30013fc8:	e0023003 	and	r3, r2, r3
30013fcc:	e3530000 	cmp	r3, #0
30013fd0:	1a000001 	bne	30013fdc <ip_route+0x88>
        /* return netif on which to forward IP packet */
        return netif;
30013fd4:	e59d300c 	ldr	r3, [sp, #12]
30013fd8:	ea00001b 	b	3001404c <ip_route+0xf8>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
30013fdc:	e59d300c 	ldr	r3, [sp, #12]
30013fe0:	e5933000 	ldr	r3, [r3]
30013fe4:	e58d300c 	str	r3, [sp, #12]
30013fe8:	e59d300c 	ldr	r3, [sp, #12]
30013fec:	e3530000 	cmp	r3, #0
30013ff0:	1affffde 	bne	30013f70 <ip_route+0x1c>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
30013ff4:	e59f3064 	ldr	r3, [pc, #100]	; 30014060 <ip_route+0x10c>
30013ff8:	e5933000 	ldr	r3, [r3]
30013ffc:	e3530000 	cmp	r3, #0
30014000:	0a000006 	beq	30014020 <ip_route+0xcc>
30014004:	e59f3054 	ldr	r3, [pc, #84]	; 30014060 <ip_route+0x10c>
30014008:	e5933000 	ldr	r3, [r3]
3001400c:	e1a00003 	mov	r0, r3
30014010:	eb0006e0 	bl	30015b98 <netif_is_up>
30014014:	e1a03000 	mov	r3, r0
30014018:	e3530000 	cmp	r3, #0
3001401c:	1a000008 	bne	30014044 <ip_route+0xf0>
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
30014020:	e59f303c 	ldr	r3, [pc, #60]	; 30014064 <ip_route+0x110>
30014024:	e1d335be 	ldrh	r3, [r3, #94]	; 0x5e
30014028:	e2833001 	add	r3, r3, #1
3001402c:	e1a03803 	lsl	r3, r3, #16
30014030:	e1a02823 	lsr	r2, r3, #16
30014034:	e59f3028 	ldr	r3, [pc, #40]	; 30014064 <ip_route+0x110>
30014038:	e1c325be 	strh	r2, [r3, #94]	; 0x5e
    snmp_inc_ipoutnoroutes();
    return NULL;
3001403c:	e3a03000 	mov	r3, #0
30014040:	ea000001 	b	3001404c <ip_route+0xf8>
  }
  /* no matching netif found, use default netif */
  return netif_default;
30014044:	e59f3014 	ldr	r3, [pc, #20]	; 30014060 <ip_route+0x10c>
30014048:	e5933000 	ldr	r3, [r3]
}
3001404c:	e1a00003 	mov	r0, r3
30014050:	e28dd014 	add	sp, sp, #20
30014054:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30014058:	e12fff1e 	bx	lr
3001405c:	300ea398 	.word	0x300ea398
30014060:	302be6a8 	.word	0x302be6a8
30014064:	302be570 	.word	0x302be570

30014068 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
30014068:	e92d4010 	push	{r4, lr}
3001406c:	e24dd018 	sub	sp, sp, #24
30014070:	e58d0004 	str	r0, [sp, #4]
30014074:	e58d1000 	str	r1, [sp]
  u16_t iphdr_len;
#if LWIP_DHCP
  int check_ip_src=1;
#endif /* LWIP_DHCP */

  IP_STATS_INC(ip.recv);
30014078:	e59f35b4 	ldr	r3, [pc, #1460]	; 30014634 <ip_input+0x5cc>
3001407c:	e1d335b2 	ldrh	r3, [r3, #82]	; 0x52
30014080:	e2833001 	add	r3, r3, #1
30014084:	e1a03803 	lsl	r3, r3, #16
30014088:	e1a02823 	lsr	r2, r3, #16
3001408c:	e59f35a0 	ldr	r3, [pc, #1440]	; 30014634 <ip_input+0x5cc>
30014090:	e1c325b2 	strh	r2, [r3, #82]	; 0x52
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
30014094:	e59d3004 	ldr	r3, [sp, #4]
30014098:	e5933004 	ldr	r3, [r3, #4]
3001409c:	e58d3008 	str	r3, [sp, #8]
  if (IPH_V(iphdr) != 4) {
300140a0:	e59d3008 	ldr	r3, [sp, #8]
300140a4:	e5d32000 	ldrb	r2, [r3]
300140a8:	e5d33001 	ldrb	r3, [r3, #1]
300140ac:	e1a03403 	lsl	r3, r3, #8
300140b0:	e1833002 	orr	r3, r3, r2
300140b4:	e1a03803 	lsl	r3, r3, #16
300140b8:	e1a03823 	lsr	r3, r3, #16
300140bc:	e1a00003 	mov	r0, r3
300140c0:	ebfffd61 	bl	3001364c <ntohs>
300140c4:	e1a03000 	mov	r3, r0
300140c8:	e1a03623 	lsr	r3, r3, #12
300140cc:	e1a03803 	lsl	r3, r3, #16
300140d0:	e1a03823 	lsr	r3, r3, #16
300140d4:	e3530004 	cmp	r3, #4
300140d8:	0a000011 	beq	30014124 <ip_input+0xbc>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    //acoral_debug("\nip_input1 == %d\n", ++pbuf_release);
    pbuf_free(p);
300140dc:	e59d0004 	ldr	r0, [sp, #4]
300140e0:	eb000866 	bl	30016280 <pbuf_free>
    IP_STATS_INC(ip.err);
300140e4:	e59f3548 	ldr	r3, [pc, #1352]	; 30014634 <ip_input+0x5cc>
300140e8:	e1d336b4 	ldrh	r3, [r3, #100]	; 0x64
300140ec:	e2833001 	add	r3, r3, #1
300140f0:	e1a03803 	lsl	r3, r3, #16
300140f4:	e1a02823 	lsr	r2, r3, #16
300140f8:	e59f3534 	ldr	r3, [pc, #1332]	; 30014634 <ip_input+0x5cc>
300140fc:	e1c326b4 	strh	r2, [r3, #100]	; 0x64
    IP_STATS_INC(ip.drop);
30014100:	e59f352c 	ldr	r3, [pc, #1324]	; 30014634 <ip_input+0x5cc>
30014104:	e1d335b6 	ldrh	r3, [r3, #86]	; 0x56
30014108:	e2833001 	add	r3, r3, #1
3001410c:	e1a03803 	lsl	r3, r3, #16
30014110:	e1a02823 	lsr	r2, r3, #16
30014114:	e59f3518 	ldr	r3, [pc, #1304]	; 30014634 <ip_input+0x5cc>
30014118:	e1c325b6 	strh	r2, [r3, #86]	; 0x56
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
3001411c:	e3a03000 	mov	r3, #0
30014120:	ea00013d 	b	3001461c <ip_input+0x5b4>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
30014124:	e59d3008 	ldr	r3, [sp, #8]
30014128:	e5d32000 	ldrb	r2, [r3]
3001412c:	e5d33001 	ldrb	r3, [r3, #1]
30014130:	e1a03403 	lsl	r3, r3, #8
30014134:	e1833002 	orr	r3, r3, r2
30014138:	e1a03803 	lsl	r3, r3, #16
3001413c:	e1a03823 	lsr	r3, r3, #16
30014140:	e1a00003 	mov	r0, r3
30014144:	ebfffd40 	bl	3001364c <ntohs>
30014148:	e1a03000 	mov	r3, r0
3001414c:	e1a03423 	lsr	r3, r3, #8
30014150:	e1a03803 	lsl	r3, r3, #16
30014154:	e1a03823 	lsr	r3, r3, #16
30014158:	e203300f 	and	r3, r3, #15
3001415c:	e1cd31b0 	strh	r3, [sp, #16]
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
30014160:	e1dd31b0 	ldrh	r3, [sp, #16]
30014164:	e1a03103 	lsl	r3, r3, #2
30014168:	e1cd31b0 	strh	r3, [sp, #16]
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
3001416c:	e59d3008 	ldr	r3, [sp, #8]
30014170:	e5d32002 	ldrb	r2, [r3, #2]
30014174:	e5d33003 	ldrb	r3, [r3, #3]
30014178:	e1a03403 	lsl	r3, r3, #8
3001417c:	e1833002 	orr	r3, r3, r2
30014180:	e1a03803 	lsl	r3, r3, #16
30014184:	e1a03823 	lsr	r3, r3, #16
30014188:	e1a00003 	mov	r0, r3
3001418c:	ebfffd2e 	bl	3001364c <ntohs>
30014190:	e1a03000 	mov	r3, r0
30014194:	e1cd31b2 	strh	r3, [sp, #18]

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
30014198:	e59d3004 	ldr	r3, [sp, #4]
3001419c:	e1d330ba 	ldrh	r3, [r3, #10]
300141a0:	e1dd21b0 	ldrh	r2, [sp, #16]
300141a4:	e1520003 	cmp	r2, r3
300141a8:	8a000004 	bhi	300141c0 <ip_input+0x158>
300141ac:	e59d3004 	ldr	r3, [sp, #4]
300141b0:	e1d330b8 	ldrh	r3, [r3, #8]
300141b4:	e1dd21b2 	ldrh	r2, [sp, #18]
300141b8:	e1520003 	cmp	r2, r3
300141bc:	9a000011 	bls	30014208 <ip_input+0x1a0>
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    //acoral_debug("\nip_input2 == %d\n", ++pbuf_release);
    pbuf_free(p);
300141c0:	e59d0004 	ldr	r0, [sp, #4]
300141c4:	eb00082d 	bl	30016280 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
300141c8:	e59f3464 	ldr	r3, [pc, #1124]	; 30014634 <ip_input+0x5cc>
300141cc:	e1d335ba 	ldrh	r3, [r3, #90]	; 0x5a
300141d0:	e2833001 	add	r3, r3, #1
300141d4:	e1a03803 	lsl	r3, r3, #16
300141d8:	e1a02823 	lsr	r2, r3, #16
300141dc:	e59f3450 	ldr	r3, [pc, #1104]	; 30014634 <ip_input+0x5cc>
300141e0:	e1c325ba 	strh	r2, [r3, #90]	; 0x5a
    IP_STATS_INC(ip.drop);
300141e4:	e59f3448 	ldr	r3, [pc, #1096]	; 30014634 <ip_input+0x5cc>
300141e8:	e1d335b6 	ldrh	r3, [r3, #86]	; 0x56
300141ec:	e2833001 	add	r3, r3, #1
300141f0:	e1a03803 	lsl	r3, r3, #16
300141f4:	e1a02823 	lsr	r2, r3, #16
300141f8:	e59f3434 	ldr	r3, [pc, #1076]	; 30014634 <ip_input+0x5cc>
300141fc:	e1c325b6 	strh	r2, [r3, #86]	; 0x56
    snmp_inc_ipindiscards();
    return ERR_OK;
30014200:	e3a03000 	mov	r3, #0
30014204:	ea000104 	b	3001461c <ip_input+0x5b4>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
30014208:	e1dd31b0 	ldrh	r3, [sp, #16]
3001420c:	e59d0008 	ldr	r0, [sp, #8]
30014210:	e1a01003 	mov	r1, r3
30014214:	ebfffee3 	bl	30013da8 <inet_chksum>
30014218:	e1a03000 	mov	r3, r0
3001421c:	e3530000 	cmp	r3, #0
30014220:	0a000011 	beq	3001426c <ip_input+0x204>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    //acoral_debug("\nip_input3 == %d\n", ++pbuf_release);
    pbuf_free(p);
30014224:	e59d0004 	ldr	r0, [sp, #4]
30014228:	eb000814 	bl	30016280 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
3001422c:	e59f3400 	ldr	r3, [pc, #1024]	; 30014634 <ip_input+0x5cc>
30014230:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
30014234:	e2833001 	add	r3, r3, #1
30014238:	e1a03803 	lsl	r3, r3, #16
3001423c:	e1a02823 	lsr	r2, r3, #16
30014240:	e59f33ec 	ldr	r3, [pc, #1004]	; 30014634 <ip_input+0x5cc>
30014244:	e1c325b8 	strh	r2, [r3, #88]	; 0x58
    IP_STATS_INC(ip.drop);
30014248:	e59f33e4 	ldr	r3, [pc, #996]	; 30014634 <ip_input+0x5cc>
3001424c:	e1d335b6 	ldrh	r3, [r3, #86]	; 0x56
30014250:	e2833001 	add	r3, r3, #1
30014254:	e1a03803 	lsl	r3, r3, #16
30014258:	e1a02823 	lsr	r2, r3, #16
3001425c:	e59f33d0 	ldr	r3, [pc, #976]	; 30014634 <ip_input+0x5cc>
30014260:	e1c325b6 	strh	r2, [r3, #86]	; 0x56
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
30014264:	e3a03000 	mov	r3, #0
30014268:	ea0000eb 	b	3001461c <ip_input+0x5b4>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
3001426c:	e1dd31b2 	ldrh	r3, [sp, #18]
30014270:	e59d0004 	ldr	r0, [sp, #4]
30014274:	e1a01003 	mov	r1, r3
30014278:	eb00073d 	bl	30015f74 <pbuf_realloc>
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
3001427c:	e3a03001 	mov	r3, #1
30014280:	e58d3014 	str	r3, [sp, #20]
    netif = inp;
30014284:	e59d3000 	ldr	r3, [sp]
30014288:	e58d300c 	str	r3, [sp, #12]
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
3001428c:	e59d000c 	ldr	r0, [sp, #12]
30014290:	eb000640 	bl	30015b98 <netif_is_up>
30014294:	e1a03000 	mov	r3, r0
30014298:	e3530000 	cmp	r3, #0
3001429c:	0a00001f 	beq	30014320 <ip_input+0x2b8>
300142a0:	e59d300c 	ldr	r3, [sp, #12]
300142a4:	e2833004 	add	r3, r3, #4
300142a8:	e3530000 	cmp	r3, #0
300142ac:	0a00001b 	beq	30014320 <ip_input+0x2b8>
300142b0:	e59d300c 	ldr	r3, [sp, #12]
300142b4:	e5933004 	ldr	r3, [r3, #4]
300142b8:	e3530000 	cmp	r3, #0
300142bc:	0a000017 	beq	30014320 <ip_input+0x2b8>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
300142c0:	e59d3008 	ldr	r3, [sp, #8]
300142c4:	e5d32010 	ldrb	r2, [r3, #16]
300142c8:	e5d31011 	ldrb	r1, [r3, #17]
300142cc:	e1a01401 	lsl	r1, r1, #8
300142d0:	e1812002 	orr	r2, r1, r2
300142d4:	e5d31012 	ldrb	r1, [r3, #18]
300142d8:	e1a01801 	lsl	r1, r1, #16
300142dc:	e1812002 	orr	r2, r1, r2
300142e0:	e5d33013 	ldrb	r3, [r3, #19]
300142e4:	e1a03c03 	lsl	r3, r3, #24
300142e8:	e1833002 	orr	r3, r3, r2
300142ec:	e1a02003 	mov	r2, r3
300142f0:	e59d300c 	ldr	r3, [sp, #12]
300142f4:	e5933004 	ldr	r3, [r3, #4]
300142f8:	e1520003 	cmp	r2, r3
300142fc:	0a00001d 	beq	30014378 <ip_input+0x310>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
30014300:	e59d3008 	ldr	r3, [sp, #8]
30014304:	e2833010 	add	r3, r3, #16
30014308:	e1a00003 	mov	r0, r3
3001430c:	e59d100c 	ldr	r1, [sp, #12]
30014310:	eb000250 	bl	30014c58 <ip_addr_isbroadcast>
30014314:	e1a03000 	mov	r3, r0
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
30014318:	e3530000 	cmp	r3, #0
3001431c:	1a000015 	bne	30014378 <ip_input+0x310>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
30014320:	e59d3014 	ldr	r3, [sp, #20]
30014324:	e3530000 	cmp	r3, #0
30014328:	0a000005 	beq	30014344 <ip_input+0x2dc>
        first = 0;
3001432c:	e3a03000 	mov	r3, #0
30014330:	e58d3014 	str	r3, [sp, #20]
        netif = netif_list;
30014334:	e59f32fc 	ldr	r3, [pc, #764]	; 30014638 <ip_input+0x5d0>
30014338:	e5933000 	ldr	r3, [r3]
3001433c:	e58d300c 	str	r3, [sp, #12]
30014340:	ea000002 	b	30014350 <ip_input+0x2e8>
      } else {
        netif = netif->next;
30014344:	e59d300c 	ldr	r3, [sp, #12]
30014348:	e5933000 	ldr	r3, [r3]
3001434c:	e58d300c 	str	r3, [sp, #12]
      }
      if (netif == inp) {
30014350:	e59d200c 	ldr	r2, [sp, #12]
30014354:	e59d3000 	ldr	r3, [sp]
30014358:	e1520003 	cmp	r2, r3
3001435c:	1a000002 	bne	3001436c <ip_input+0x304>
        netif = netif->next;
30014360:	e59d300c 	ldr	r3, [sp, #12]
30014364:	e5933000 	ldr	r3, [r3]
30014368:	e58d300c 	str	r3, [sp, #12]
      }
    } while(netif != NULL);
3001436c:	e59d300c 	ldr	r3, [sp, #12]
30014370:	e3530000 	cmp	r3, #0
30014374:	1affffc4 	bne	3001428c <ip_input+0x224>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
30014378:	e59d3008 	ldr	r3, [sp, #8]
3001437c:	e283300c 	add	r3, r3, #12
30014380:	e1a00003 	mov	r0, r3
30014384:	e59d1000 	ldr	r1, [sp]
30014388:	eb000232 	bl	30014c58 <ip_addr_isbroadcast>
3001438c:	e1a03000 	mov	r3, r0
30014390:	e3530000 	cmp	r3, #0
30014394:	1a000014 	bne	300143ec <ip_input+0x384>
         (ip_addr_ismulticast(&(iphdr->src)))) {
30014398:	e59d3008 	ldr	r3, [sp, #8]
3001439c:	e5d3200c 	ldrb	r2, [r3, #12]
300143a0:	e5d3100d 	ldrb	r1, [r3, #13]
300143a4:	e1a01401 	lsl	r1, r1, #8
300143a8:	e1812002 	orr	r2, r1, r2
300143ac:	e5d3100e 	ldrb	r1, [r3, #14]
300143b0:	e1a01801 	lsl	r1, r1, #16
300143b4:	e1812002 	orr	r2, r1, r2
300143b8:	e5d3300f 	ldrb	r3, [r3, #15]
300143bc:	e1a03c03 	lsl	r3, r3, #24
300143c0:	e1833002 	orr	r3, r3, r2
300143c4:	e1a04003 	mov	r4, r3
300143c8:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
300143cc:	ebfffcbc 	bl	300136c4 <ntohl>
300143d0:	e1a03000 	mov	r3, r0
300143d4:	e0044003 	and	r4, r4, r3
300143d8:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
300143dc:	ebfffcb8 	bl	300136c4 <ntohl>
300143e0:	e1a03000 	mov	r3, r0

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
300143e4:	e1540003 	cmp	r4, r3
300143e8:	1a00000a 	bne	30014418 <ip_input+0x3b0>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      //acoral_debug("\nip_input4 == %d\n", ++pbuf_release);
      pbuf_free(p);
300143ec:	e59d0004 	ldr	r0, [sp, #4]
300143f0:	eb0007a2 	bl	30016280 <pbuf_free>
      IP_STATS_INC(ip.drop);
300143f4:	e59f3238 	ldr	r3, [pc, #568]	; 30014634 <ip_input+0x5cc>
300143f8:	e1d335b6 	ldrh	r3, [r3, #86]	; 0x56
300143fc:	e2833001 	add	r3, r3, #1
30014400:	e1a03803 	lsl	r3, r3, #16
30014404:	e1a02823 	lsr	r2, r3, #16
30014408:	e59f3224 	ldr	r3, [pc, #548]	; 30014634 <ip_input+0x5cc>
3001440c:	e1c325b6 	strh	r2, [r3, #86]	; 0x56
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
30014410:	e3a03000 	mov	r3, #0
30014414:	ea000080 	b	3001461c <ip_input+0x5b4>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
30014418:	e59d300c 	ldr	r3, [sp, #12]
3001441c:	e3530000 	cmp	r3, #0
30014420:	1a000003 	bne	30014434 <ip_input+0x3cc>
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    //acoral_debug("\nip_input5 == %d\n", ++pbuf_release);
    pbuf_free(p);
30014424:	e59d0004 	ldr	r0, [sp, #4]
30014428:	eb000794 	bl	30016280 <pbuf_free>
    return ERR_OK;
3001442c:	e3a03000 	mov	r3, #0
30014430:	ea000079 	b	3001461c <ip_input+0x5b4>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
30014434:	e59d3008 	ldr	r3, [sp, #8]
30014438:	e5d32006 	ldrb	r2, [r3, #6]
3001443c:	e5d33007 	ldrb	r3, [r3, #7]
30014440:	e1a03403 	lsl	r3, r3, #8
30014444:	e1833002 	orr	r3, r3, r2
30014448:	e1a03803 	lsl	r3, r3, #16
3001444c:	e1a04823 	lsr	r4, r3, #16
30014450:	e3a00dff 	mov	r0, #16320	; 0x3fc0
30014454:	e280003f 	add	r0, r0, #63	; 0x3f
30014458:	ebfffc68 	bl	30013600 <htons>
3001445c:	e1a03000 	mov	r3, r0
30014460:	e0043003 	and	r3, r4, r3
30014464:	e1a03803 	lsl	r3, r3, #16
30014468:	e1a03823 	lsr	r3, r3, #16
3001446c:	e3530000 	cmp	r3, #0
30014470:	0a000011 	beq	300144bc <ip_input+0x454>
      return ERR_OK;
    }
    iphdr = p->payload;
#else /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */
    //acoral_debug("\nip_input7 == %d\n", ++pbuf_release);
    pbuf_free(p);
30014474:	e59d0004 	ldr	r0, [sp, #4]
30014478:	eb000780 	bl	30016280 <pbuf_free>
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP packet dropped since it was fragmented (0x%"X16_F") (while IP_REASSEMBLY == 0).\n",
    ntohs(IPH_OFFSET(iphdr))));
    IP_STATS_INC(ip.opterr);
3001447c:	e59f31b0 	ldr	r3, [pc, #432]	; 30014634 <ip_input+0x5cc>
30014480:	e1d336b2 	ldrh	r3, [r3, #98]	; 0x62
30014484:	e2833001 	add	r3, r3, #1
30014488:	e1a03803 	lsl	r3, r3, #16
3001448c:	e1a02823 	lsr	r2, r3, #16
30014490:	e59f319c 	ldr	r3, [pc, #412]	; 30014634 <ip_input+0x5cc>
30014494:	e1c326b2 	strh	r2, [r3, #98]	; 0x62
    IP_STATS_INC(ip.drop);
30014498:	e59f3194 	ldr	r3, [pc, #404]	; 30014634 <ip_input+0x5cc>
3001449c:	e1d335b6 	ldrh	r3, [r3, #86]	; 0x56
300144a0:	e2833001 	add	r3, r3, #1
300144a4:	e1a03803 	lsl	r3, r3, #16
300144a8:	e1a02823 	lsr	r2, r3, #16
300144ac:	e59f3180 	ldr	r3, [pc, #384]	; 30014634 <ip_input+0x5cc>
300144b0:	e1c325b6 	strh	r2, [r3, #86]	; 0x56
    /* unsupported protocol feature */
    snmp_inc_ipinunknownprotos();
    return ERR_OK;
300144b4:	e3a03000 	mov	r3, #0
300144b8:	ea000057 	b	3001461c <ip_input+0x5b4>
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
300144bc:	e59d0004 	ldr	r0, [sp, #4]
300144c0:	e59d1000 	ldr	r1, [sp]
300144c4:	eb0008df 	bl	30016848 <raw_input>
300144c8:	e1a03000 	mov	r3, r0
300144cc:	e3530000 	cmp	r3, #0
300144d0:	1a000050 	bne	30014618 <ip_input+0x5b0>
#endif /* LWIP_RAW */
  {
    //acoral_print("\nip proto: %d\n",ntohs((iphdr)->_ttl_proto) & 0xff);
    switch (IPH_PROTO(iphdr)) {
300144d4:	e59d3008 	ldr	r3, [sp, #8]
300144d8:	e5d32008 	ldrb	r2, [r3, #8]
300144dc:	e5d33009 	ldrb	r3, [r3, #9]
300144e0:	e1a03403 	lsl	r3, r3, #8
300144e4:	e1833002 	orr	r3, r3, r2
300144e8:	e1a03803 	lsl	r3, r3, #16
300144ec:	e1a03823 	lsr	r3, r3, #16
300144f0:	e1a00003 	mov	r0, r3
300144f4:	ebfffc54 	bl	3001364c <ntohs>
300144f8:	e1a03000 	mov	r3, r0
300144fc:	e20330ff 	and	r3, r3, #255	; 0xff
30014500:	e3530006 	cmp	r3, #6
30014504:	0a000008 	beq	3001452c <ip_input+0x4c4>
30014508:	e3530011 	cmp	r3, #17
3001450c:	0a000002 	beq	3001451c <ip_input+0x4b4>
30014510:	e3530001 	cmp	r3, #1
30014514:	0a000008 	beq	3001453c <ip_input+0x4d4>
30014518:	ea00000b 	b	3001454c <ip_input+0x4e4>
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      //acoral_prints("\nUDP\n");
      udp_input(p, inp);
3001451c:	e59d0004 	ldr	r0, [sp, #4]
30014520:	e59d1000 	ldr	r1, [sp]
30014524:	eb002d25 	bl	3001f9c0 <udp_input>
      break;
30014528:	ea00003a 	b	30014618 <ip_input+0x5b0>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      //acoral_print("\nTCP: tot_len:%d, type:%d\n", p->tot_len, p->type);
      tcp_input(p, inp);
3001452c:	e59d0004 	ldr	r0, [sp, #4]
30014530:	e59d1000 	ldr	r1, [sp]
30014534:	eb001408 	bl	3001955c <tcp_input>
      //acoral_print("\ni am here.=== %d\n", mytmptest++);
      break;
30014538:	ea000036 	b	30014618 <ip_input+0x5b0>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      //acoral_prints("\nICMPS\n");
      icmp_input(p, inp);
3001453c:	e59d0004 	ldr	r0, [sp, #4]
30014540:	e59d1000 	ldr	r1, [sp]
30014544:	ebfff859 	bl	300126b0 <icmp_input>
      //acoral_prints("\nICMPE\n");
      break;
30014548:	ea000032 	b	30014618 <ip_input+0x5b0>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
3001454c:	e59d3008 	ldr	r3, [sp, #8]
30014550:	e2833010 	add	r3, r3, #16
30014554:	e1a00003 	mov	r0, r3
30014558:	e59d1000 	ldr	r1, [sp]
3001455c:	eb0001bd 	bl	30014c58 <ip_addr_isbroadcast>
30014560:	e1a03000 	mov	r3, r0
30014564:	e3530000 	cmp	r3, #0
30014568:	1a00001a 	bne	300145d8 <ip_input+0x570>
          !ip_addr_ismulticast(&(iphdr->dest))) {
3001456c:	e59d3008 	ldr	r3, [sp, #8]
30014570:	e5d32010 	ldrb	r2, [r3, #16]
30014574:	e5d31011 	ldrb	r1, [r3, #17]
30014578:	e1a01401 	lsl	r1, r1, #8
3001457c:	e1812002 	orr	r2, r1, r2
30014580:	e5d31012 	ldrb	r1, [r3, #18]
30014584:	e1a01801 	lsl	r1, r1, #16
30014588:	e1812002 	orr	r2, r1, r2
3001458c:	e5d33013 	ldrb	r3, [r3, #19]
30014590:	e1a03c03 	lsl	r3, r3, #24
30014594:	e1833002 	orr	r3, r3, r2
30014598:	e1a04003 	mov	r4, r3
3001459c:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
300145a0:	ebfffc47 	bl	300136c4 <ntohl>
300145a4:	e1a03000 	mov	r3, r0
300145a8:	e0044003 	and	r4, r4, r3
300145ac:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
300145b0:	ebfffc43 	bl	300136c4 <ntohl>
300145b4:	e1a03000 	mov	r3, r0
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
300145b8:	e1540003 	cmp	r4, r3
300145bc:	0a000005 	beq	300145d8 <ip_input+0x570>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
300145c0:	e59d3004 	ldr	r3, [sp, #4]
300145c4:	e59d2008 	ldr	r2, [sp, #8]
300145c8:	e5832004 	str	r2, [r3, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
300145cc:	e59d0004 	ldr	r0, [sp, #4]
300145d0:	e3a01002 	mov	r1, #2
300145d4:	ebfffa04 	bl	30012dec <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      //acoral_debug("\nip_input8 == %d\n", ++pbuf_release);
      pbuf_free(p);
300145d8:	e59d0004 	ldr	r0, [sp, #4]
300145dc:	eb000727 	bl	30016280 <pbuf_free>

      LWIP_DEBUGF(IP_DEBUG | 2, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));

      IP_STATS_INC(ip.proterr);
300145e0:	e59f304c 	ldr	r3, [pc, #76]	; 30014634 <ip_input+0x5cc>
300145e4:	e1d336b0 	ldrh	r3, [r3, #96]	; 0x60
300145e8:	e2833001 	add	r3, r3, #1
300145ec:	e1a03803 	lsl	r3, r3, #16
300145f0:	e1a02823 	lsr	r2, r3, #16
300145f4:	e59f3038 	ldr	r3, [pc, #56]	; 30014634 <ip_input+0x5cc>
300145f8:	e1c326b0 	strh	r2, [r3, #96]	; 0x60
      IP_STATS_INC(ip.drop);
300145fc:	e59f3030 	ldr	r3, [pc, #48]	; 30014634 <ip_input+0x5cc>
30014600:	e1d335b6 	ldrh	r3, [r3, #86]	; 0x56
30014604:	e2833001 	add	r3, r3, #1
30014608:	e1a03803 	lsl	r3, r3, #16
3001460c:	e1a02823 	lsr	r2, r3, #16
30014610:	e59f301c 	ldr	r3, [pc, #28]	; 30014634 <ip_input+0x5cc>
30014614:	e1c325b6 	strh	r2, [r3, #86]	; 0x56
      snmp_inc_ipinunknownprotos();
    }
    
  }
  //acoral_print("\n===  input ok  ===\n");
  return ERR_OK;
30014618:	e3a03000 	mov	r3, #0
3001461c:	e1a03c03 	lsl	r3, r3, #24
30014620:	e1a03c43 	asr	r3, r3, #24
}
30014624:	e1a00003 	mov	r0, r3
30014628:	e28dd018 	add	sp, sp, #24
3001462c:	e8bd4010 	pop	{r4, lr}
30014630:	e12fff1e 	bx	lr
30014634:	302be570 	.word	0x302be570
30014638:	300ea398 	.word	0x300ea398

3001463c <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
3001463c:	e92d4010 	push	{r4, lr}
30014640:	e24dd018 	sub	sp, sp, #24
30014644:	e58d000c 	str	r0, [sp, #12]
30014648:	e58d1008 	str	r1, [sp, #8]
3001464c:	e58d2004 	str	r2, [sp, #4]
30014650:	e5cd3003 	strb	r3, [sp, #3]
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
30014654:	e59d3004 	ldr	r3, [sp, #4]
30014658:	e3530000 	cmp	r3, #0
3001465c:	0a000129 	beq	30014b08 <ip_output_if+0x4cc>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
30014660:	e59d000c 	ldr	r0, [sp, #12]
30014664:	e3a01014 	mov	r1, #20
30014668:	eb00069f 	bl	300160ec <pbuf_header>
3001466c:	e1a03000 	mov	r3, r0
30014670:	e3530000 	cmp	r3, #0
30014674:	0a000008 	beq	3001469c <ip_output_if+0x60>
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
30014678:	e59f3544 	ldr	r3, [pc, #1348]	; 30014bc4 <ip_output_if+0x588>
3001467c:	e1d336b4 	ldrh	r3, [r3, #100]	; 0x64
30014680:	e2833001 	add	r3, r3, #1
30014684:	e1a03803 	lsl	r3, r3, #16
30014688:	e1a02823 	lsr	r2, r3, #16
3001468c:	e59f3530 	ldr	r3, [pc, #1328]	; 30014bc4 <ip_output_if+0x588>
30014690:	e1c326b4 	strh	r2, [r3, #100]	; 0x64
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
30014694:	e3a030fe 	mov	r3, #254	; 0xfe
30014698:	ea000143 	b	30014bac <ip_output_if+0x570>
    }

    iphdr = p->payload;
3001469c:	e59d300c 	ldr	r3, [sp, #12]
300146a0:	e5933004 	ldr	r3, [r3, #4]
300146a4:	e58d3014 	str	r3, [sp, #20]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
300146a8:	e59d3014 	ldr	r3, [sp, #20]
300146ac:	e5d32008 	ldrb	r2, [r3, #8]
300146b0:	e5d33009 	ldrb	r3, [r3, #9]
300146b4:	e1a03403 	lsl	r3, r3, #8
300146b8:	e1833002 	orr	r3, r3, r2
300146bc:	e1a03803 	lsl	r3, r3, #16
300146c0:	e1a03823 	lsr	r3, r3, #16
300146c4:	e1a00003 	mov	r0, r3
300146c8:	ebfffbdf 	bl	3001364c <ntohs>
300146cc:	e1a03000 	mov	r3, r0
300146d0:	e1a03803 	lsl	r3, r3, #16
300146d4:	e1a03823 	lsr	r3, r3, #16
300146d8:	e20330ff 	and	r3, r3, #255	; 0xff
300146dc:	e5dd2003 	ldrb	r2, [sp, #3]
300146e0:	e1a02402 	lsl	r2, r2, #8
300146e4:	e1a02802 	lsl	r2, r2, #16
300146e8:	e1a01822 	lsr	r1, r2, #16
300146ec:	e1a02003 	mov	r2, r3
300146f0:	e1a03001 	mov	r3, r1
300146f4:	e1823003 	orr	r3, r2, r3
300146f8:	e1a03803 	lsl	r3, r3, #16
300146fc:	e1a03823 	lsr	r3, r3, #16
30014700:	e1a03803 	lsl	r3, r3, #16
30014704:	e1a03823 	lsr	r3, r3, #16
30014708:	e1a00003 	mov	r0, r3
3001470c:	ebfffbbb 	bl	30013600 <htons>
30014710:	e1a03000 	mov	r3, r0
30014714:	e1a02003 	mov	r2, r3
30014718:	e59d3014 	ldr	r3, [sp, #20]
3001471c:	e20210ff 	and	r1, r2, #255	; 0xff
30014720:	e3a00000 	mov	r0, #0
30014724:	e1801001 	orr	r1, r0, r1
30014728:	e5c31008 	strb	r1, [r3, #8]
3001472c:	e1a02422 	lsr	r2, r2, #8
30014730:	e1a02802 	lsl	r2, r2, #16
30014734:	e1a02822 	lsr	r2, r2, #16
30014738:	e3a01000 	mov	r1, #0
3001473c:	e1812002 	orr	r2, r1, r2
30014740:	e5c32009 	strb	r2, [r3, #9]
    IPH_PROTO_SET(iphdr, proto);
30014744:	e5dd4024 	ldrb	r4, [sp, #36]	; 0x24
30014748:	e59d3014 	ldr	r3, [sp, #20]
3001474c:	e5d32008 	ldrb	r2, [r3, #8]
30014750:	e5d33009 	ldrb	r3, [r3, #9]
30014754:	e1a03403 	lsl	r3, r3, #8
30014758:	e1833002 	orr	r3, r3, r2
3001475c:	e1a03803 	lsl	r3, r3, #16
30014760:	e1a03823 	lsr	r3, r3, #16
30014764:	e1a00003 	mov	r0, r3
30014768:	ebfffbb7 	bl	3001364c <ntohs>
3001476c:	e1a03000 	mov	r3, r0
30014770:	e1a03423 	lsr	r3, r3, #8
30014774:	e1a03803 	lsl	r3, r3, #16
30014778:	e1a03823 	lsr	r3, r3, #16
3001477c:	e1a03403 	lsl	r3, r3, #8
30014780:	e1a03803 	lsl	r3, r3, #16
30014784:	e1a03823 	lsr	r3, r3, #16
30014788:	e1a02004 	mov	r2, r4
3001478c:	e1823003 	orr	r3, r2, r3
30014790:	e1a03803 	lsl	r3, r3, #16
30014794:	e1a03823 	lsr	r3, r3, #16
30014798:	e1a03803 	lsl	r3, r3, #16
3001479c:	e1a03823 	lsr	r3, r3, #16
300147a0:	e1a00003 	mov	r0, r3
300147a4:	ebfffb95 	bl	30013600 <htons>
300147a8:	e1a03000 	mov	r3, r0
300147ac:	e1a02003 	mov	r2, r3
300147b0:	e59d3014 	ldr	r3, [sp, #20]
300147b4:	e20210ff 	and	r1, r2, #255	; 0xff
300147b8:	e3a00000 	mov	r0, #0
300147bc:	e1801001 	orr	r1, r0, r1
300147c0:	e5c31008 	strb	r1, [r3, #8]
300147c4:	e1a02422 	lsr	r2, r2, #8
300147c8:	e1a02802 	lsl	r2, r2, #16
300147cc:	e1a02822 	lsr	r2, r2, #16
300147d0:	e3a01000 	mov	r1, #0
300147d4:	e1812002 	orr	r2, r1, r2
300147d8:	e5c32009 	strb	r2, [r3, #9]

    ip_addr_set(&(iphdr->dest), dest);
300147dc:	e59d3004 	ldr	r3, [sp, #4]
300147e0:	e3530000 	cmp	r3, #0
300147e4:	0a00000b 	beq	30014818 <ip_output_if+0x1dc>
300147e8:	e59d3004 	ldr	r3, [sp, #4]
300147ec:	e5d32000 	ldrb	r2, [r3]
300147f0:	e5d31001 	ldrb	r1, [r3, #1]
300147f4:	e1a01401 	lsl	r1, r1, #8
300147f8:	e1812002 	orr	r2, r1, r2
300147fc:	e5d31002 	ldrb	r1, [r3, #2]
30014800:	e1a01801 	lsl	r1, r1, #16
30014804:	e1812002 	orr	r2, r1, r2
30014808:	e5d33003 	ldrb	r3, [r3, #3]
3001480c:	e1a03c03 	lsl	r3, r3, #24
30014810:	e1833002 	orr	r3, r3, r2
30014814:	ea000000 	b	3001481c <ip_output_if+0x1e0>
30014818:	e3a03000 	mov	r3, #0
3001481c:	e59d2014 	ldr	r2, [sp, #20]
30014820:	e20310ff 	and	r1, r3, #255	; 0xff
30014824:	e3a00000 	mov	r0, #0
30014828:	e1801001 	orr	r1, r0, r1
3001482c:	e5c21010 	strb	r1, [r2, #16]
30014830:	e1a01423 	lsr	r1, r3, #8
30014834:	e20110ff 	and	r1, r1, #255	; 0xff
30014838:	e3a00000 	mov	r0, #0
3001483c:	e1801001 	orr	r1, r0, r1
30014840:	e5c21011 	strb	r1, [r2, #17]
30014844:	e1a01823 	lsr	r1, r3, #16
30014848:	e20110ff 	and	r1, r1, #255	; 0xff
3001484c:	e3a00000 	mov	r0, #0
30014850:	e1801001 	orr	r1, r0, r1
30014854:	e5c21012 	strb	r1, [r2, #18]
30014858:	e1a03c23 	lsr	r3, r3, #24
3001485c:	e3a01000 	mov	r1, #0
30014860:	e1813003 	orr	r3, r1, r3
30014864:	e5c23013 	strb	r3, [r2, #19]

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
30014868:	e5dd3020 	ldrb	r3, [sp, #32]
3001486c:	e3833c45 	orr	r3, r3, #17664	; 0x4500
30014870:	e1a03803 	lsl	r3, r3, #16
30014874:	e1a03823 	lsr	r3, r3, #16
30014878:	e1a03803 	lsl	r3, r3, #16
3001487c:	e1a03823 	lsr	r3, r3, #16
30014880:	e1a00003 	mov	r0, r3
30014884:	ebfffb5d 	bl	30013600 <htons>
30014888:	e1a03000 	mov	r3, r0
3001488c:	e1a02003 	mov	r2, r3
30014890:	e59d3014 	ldr	r3, [sp, #20]
30014894:	e20210ff 	and	r1, r2, #255	; 0xff
30014898:	e3a00000 	mov	r0, #0
3001489c:	e1801001 	orr	r1, r0, r1
300148a0:	e5c31000 	strb	r1, [r3]
300148a4:	e1a02422 	lsr	r2, r2, #8
300148a8:	e1a02802 	lsl	r2, r2, #16
300148ac:	e1a02822 	lsr	r2, r2, #16
300148b0:	e3a01000 	mov	r1, #0
300148b4:	e1812002 	orr	r2, r1, r2
300148b8:	e5c32001 	strb	r2, [r3, #1]
    IPH_LEN_SET(iphdr, htons(p->tot_len));
300148bc:	e59d300c 	ldr	r3, [sp, #12]
300148c0:	e1d330b8 	ldrh	r3, [r3, #8]
300148c4:	e1a00003 	mov	r0, r3
300148c8:	ebfffb4c 	bl	30013600 <htons>
300148cc:	e1a03000 	mov	r3, r0
300148d0:	e1a02003 	mov	r2, r3
300148d4:	e59d3014 	ldr	r3, [sp, #20]
300148d8:	e20210ff 	and	r1, r2, #255	; 0xff
300148dc:	e3a00000 	mov	r0, #0
300148e0:	e1801001 	orr	r1, r0, r1
300148e4:	e5c31002 	strb	r1, [r3, #2]
300148e8:	e1a02422 	lsr	r2, r2, #8
300148ec:	e1a02802 	lsl	r2, r2, #16
300148f0:	e1a02822 	lsr	r2, r2, #16
300148f4:	e3a01000 	mov	r1, #0
300148f8:	e1812002 	orr	r2, r1, r2
300148fc:	e5c32003 	strb	r2, [r3, #3]
    IPH_OFFSET_SET(iphdr, 0);
30014900:	e59d3014 	ldr	r3, [sp, #20]
30014904:	e3a02000 	mov	r2, #0
30014908:	e5c32006 	strb	r2, [r3, #6]
3001490c:	e3a02000 	mov	r2, #0
30014910:	e5c32007 	strb	r2, [r3, #7]
    IPH_ID_SET(iphdr, htons(ip_id));
30014914:	e59f32ac 	ldr	r3, [pc, #684]	; 30014bc8 <ip_output_if+0x58c>
30014918:	e1d330b0 	ldrh	r3, [r3]
3001491c:	e1a00003 	mov	r0, r3
30014920:	ebfffb36 	bl	30013600 <htons>
30014924:	e1a03000 	mov	r3, r0
30014928:	e1a02003 	mov	r2, r3
3001492c:	e59d3014 	ldr	r3, [sp, #20]
30014930:	e20210ff 	and	r1, r2, #255	; 0xff
30014934:	e3a00000 	mov	r0, #0
30014938:	e1801001 	orr	r1, r0, r1
3001493c:	e5c31004 	strb	r1, [r3, #4]
30014940:	e1a02422 	lsr	r2, r2, #8
30014944:	e1a02802 	lsl	r2, r2, #16
30014948:	e1a02822 	lsr	r2, r2, #16
3001494c:	e3a01000 	mov	r1, #0
30014950:	e1812002 	orr	r2, r1, r2
30014954:	e5c32005 	strb	r2, [r3, #5]
    ++ip_id;
30014958:	e59f3268 	ldr	r3, [pc, #616]	; 30014bc8 <ip_output_if+0x58c>
3001495c:	e1d330b0 	ldrh	r3, [r3]
30014960:	e2833001 	add	r3, r3, #1
30014964:	e1a03803 	lsl	r3, r3, #16
30014968:	e1a02823 	lsr	r2, r3, #16
3001496c:	e59f3254 	ldr	r3, [pc, #596]	; 30014bc8 <ip_output_if+0x58c>
30014970:	e1c320b0 	strh	r2, [r3]

    if (ip_addr_isany(src)) {
30014974:	e59d3008 	ldr	r3, [sp, #8]
30014978:	e3530000 	cmp	r3, #0
3001497c:	0a00000c 	beq	300149b4 <ip_output_if+0x378>
30014980:	e59d3008 	ldr	r3, [sp, #8]
30014984:	e5d32000 	ldrb	r2, [r3]
30014988:	e5d31001 	ldrb	r1, [r3, #1]
3001498c:	e1a01401 	lsl	r1, r1, #8
30014990:	e1812002 	orr	r2, r1, r2
30014994:	e5d31002 	ldrb	r1, [r3, #2]
30014998:	e1a01801 	lsl	r1, r1, #16
3001499c:	e1812002 	orr	r2, r1, r2
300149a0:	e5d33003 	ldrb	r3, [r3, #3]
300149a4:	e1a03c03 	lsl	r3, r3, #24
300149a8:	e1833002 	orr	r3, r3, r2
300149ac:	e3530000 	cmp	r3, #0
300149b0:	1a00001b 	bne	30014a24 <ip_output_if+0x3e8>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
300149b4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300149b8:	e2833004 	add	r3, r3, #4
300149bc:	e3530000 	cmp	r3, #0
300149c0:	0a000002 	beq	300149d0 <ip_output_if+0x394>
300149c4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300149c8:	e5933004 	ldr	r3, [r3, #4]
300149cc:	ea000000 	b	300149d4 <ip_output_if+0x398>
300149d0:	e3a03000 	mov	r3, #0
300149d4:	e59d2014 	ldr	r2, [sp, #20]
300149d8:	e20310ff 	and	r1, r3, #255	; 0xff
300149dc:	e3a00000 	mov	r0, #0
300149e0:	e1801001 	orr	r1, r0, r1
300149e4:	e5c2100c 	strb	r1, [r2, #12]
300149e8:	e1a01423 	lsr	r1, r3, #8
300149ec:	e20110ff 	and	r1, r1, #255	; 0xff
300149f0:	e3a00000 	mov	r0, #0
300149f4:	e1801001 	orr	r1, r0, r1
300149f8:	e5c2100d 	strb	r1, [r2, #13]
300149fc:	e1a01823 	lsr	r1, r3, #16
30014a00:	e20110ff 	and	r1, r1, #255	; 0xff
30014a04:	e3a00000 	mov	r0, #0
30014a08:	e1801001 	orr	r1, r0, r1
30014a0c:	e5c2100e 	strb	r1, [r2, #14]
30014a10:	e1a03c23 	lsr	r3, r3, #24
30014a14:	e3a01000 	mov	r1, #0
30014a18:	e1813003 	orr	r3, r1, r3
30014a1c:	e5c2300f 	strb	r3, [r2, #15]
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
    ++ip_id;

    if (ip_addr_isany(src)) {
30014a20:	ea000022 	b	30014ab0 <ip_output_if+0x474>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
    } else {
      ip_addr_set(&(iphdr->src), src);
30014a24:	e59d3008 	ldr	r3, [sp, #8]
30014a28:	e3530000 	cmp	r3, #0
30014a2c:	0a00000b 	beq	30014a60 <ip_output_if+0x424>
30014a30:	e59d3008 	ldr	r3, [sp, #8]
30014a34:	e5d32000 	ldrb	r2, [r3]
30014a38:	e5d31001 	ldrb	r1, [r3, #1]
30014a3c:	e1a01401 	lsl	r1, r1, #8
30014a40:	e1812002 	orr	r2, r1, r2
30014a44:	e5d31002 	ldrb	r1, [r3, #2]
30014a48:	e1a01801 	lsl	r1, r1, #16
30014a4c:	e1812002 	orr	r2, r1, r2
30014a50:	e5d33003 	ldrb	r3, [r3, #3]
30014a54:	e1a03c03 	lsl	r3, r3, #24
30014a58:	e1833002 	orr	r3, r3, r2
30014a5c:	ea000000 	b	30014a64 <ip_output_if+0x428>
30014a60:	e3a03000 	mov	r3, #0
30014a64:	e59d2014 	ldr	r2, [sp, #20]
30014a68:	e20310ff 	and	r1, r3, #255	; 0xff
30014a6c:	e3a00000 	mov	r0, #0
30014a70:	e1801001 	orr	r1, r0, r1
30014a74:	e5c2100c 	strb	r1, [r2, #12]
30014a78:	e1a01423 	lsr	r1, r3, #8
30014a7c:	e20110ff 	and	r1, r1, #255	; 0xff
30014a80:	e3a00000 	mov	r0, #0
30014a84:	e1801001 	orr	r1, r0, r1
30014a88:	e5c2100d 	strb	r1, [r2, #13]
30014a8c:	e1a01823 	lsr	r1, r3, #16
30014a90:	e20110ff 	and	r1, r1, #255	; 0xff
30014a94:	e3a00000 	mov	r0, #0
30014a98:	e1801001 	orr	r1, r0, r1
30014a9c:	e5c2100e 	strb	r1, [r2, #14]
30014aa0:	e1a03c23 	lsr	r3, r3, #24
30014aa4:	e3a01000 	mov	r1, #0
30014aa8:	e1813003 	orr	r3, r1, r3
30014aac:	e5c2300f 	strb	r3, [r2, #15]
    }

    IPH_CHKSUM_SET(iphdr, 0);
30014ab0:	e59d3014 	ldr	r3, [sp, #20]
30014ab4:	e3a02000 	mov	r2, #0
30014ab8:	e5c3200a 	strb	r2, [r3, #10]
30014abc:	e3a02000 	mov	r2, #0
30014ac0:	e5c3200b 	strb	r2, [r3, #11]
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
30014ac4:	e59d0014 	ldr	r0, [sp, #20]
30014ac8:	e3a01014 	mov	r1, #20
30014acc:	ebfffcb5 	bl	30013da8 <inet_chksum>
30014ad0:	e1a03000 	mov	r3, r0
30014ad4:	e1a02003 	mov	r2, r3
30014ad8:	e59d3014 	ldr	r3, [sp, #20]
30014adc:	e20210ff 	and	r1, r2, #255	; 0xff
30014ae0:	e3a00000 	mov	r0, #0
30014ae4:	e1801001 	orr	r1, r0, r1
30014ae8:	e5c3100a 	strb	r1, [r3, #10]
30014aec:	e1a02422 	lsr	r2, r2, #8
30014af0:	e1a02802 	lsl	r2, r2, #16
30014af4:	e1a02822 	lsr	r2, r2, #16
30014af8:	e3a01000 	mov	r1, #0
30014afc:	e1812002 	orr	r2, r1, r2
30014b00:	e5c3200b 	strb	r2, [r3, #11]
30014b04:	ea000005 	b	30014b20 <ip_output_if+0x4e4>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
30014b08:	e59d300c 	ldr	r3, [sp, #12]
30014b0c:	e5933004 	ldr	r3, [r3, #4]
30014b10:	e58d3014 	str	r3, [sp, #20]
    dest = &(iphdr->dest);
30014b14:	e59d3014 	ldr	r3, [sp, #20]
30014b18:	e2833010 	add	r3, r3, #16
30014b1c:	e58d3004 	str	r3, [sp, #4]
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
30014b20:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30014b24:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
30014b28:	e3530000 	cmp	r3, #0
30014b2c:	0a00000d 	beq	30014b68 <ip_output_if+0x52c>
30014b30:	e59d300c 	ldr	r3, [sp, #12]
30014b34:	e1d320b8 	ldrh	r2, [r3, #8]
30014b38:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30014b3c:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
30014b40:	e1520003 	cmp	r2, r3
30014b44:	9a000007 	bls	30014b68 <ip_output_if+0x52c>
    return ip_frag(p,netif,dest);
30014b48:	e59d000c 	ldr	r0, [sp, #12]
30014b4c:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
30014b50:	e59d2004 	ldr	r2, [sp, #4]
30014b54:	eb000088 	bl	30014d7c <ip_frag>
30014b58:	e1a03000 	mov	r3, r0
30014b5c:	e20330ff 	and	r3, r3, #255	; 0xff
30014b60:	e20330ff 	and	r3, r3, #255	; 0xff
30014b64:	ea000010 	b	30014bac <ip_output_if+0x570>
#endif

  IP_STATS_INC(ip.xmit);
30014b68:	e59f3054 	ldr	r3, [pc, #84]	; 30014bc4 <ip_output_if+0x588>
30014b6c:	e1d334be 	ldrh	r3, [r3, #78]	; 0x4e
30014b70:	e2833001 	add	r3, r3, #1
30014b74:	e1a03803 	lsl	r3, r3, #16
30014b78:	e1a02823 	lsr	r2, r3, #16
30014b7c:	e59f3040 	ldr	r3, [pc, #64]	; 30014bc4 <ip_output_if+0x588>
30014b80:	e1c324be 	strh	r2, [r3, #78]	; 0x4e
  LWIP_DEBUGF(IP_DEBUG, ("ip_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], netif->num));
  ip_debug_print(p);

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  //acoral_print("\r\nIpOutPutIf***netif\r\n");
  return netif->output(netif, p, dest);
30014b84:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30014b88:	e5933014 	ldr	r3, [r3, #20]
30014b8c:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
30014b90:	e59d100c 	ldr	r1, [sp, #12]
30014b94:	e59d2004 	ldr	r2, [sp, #4]
30014b98:	e1a0e00f 	mov	lr, pc
30014b9c:	e12fff13 	bx	r3
30014ba0:	e1a03000 	mov	r3, r0
30014ba4:	e20330ff 	and	r3, r3, #255	; 0xff
30014ba8:	e20330ff 	and	r3, r3, #255	; 0xff
30014bac:	e1a03c03 	lsl	r3, r3, #24
30014bb0:	e1a03c43 	asr	r3, r3, #24
}
30014bb4:	e1a00003 	mov	r0, r3
30014bb8:	e28dd018 	add	sp, sp, #24
30014bbc:	e8bd4010 	pop	{r4, lr}
30014bc0:	e12fff1e 	bx	lr
30014bc4:	302be570 	.word	0x302be570
30014bc8:	300ca660 	.word	0x300ca660

30014bcc <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
30014bcc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30014bd0:	e24dd02c 	sub	sp, sp, #44	; 0x2c
30014bd4:	e58d001c 	str	r0, [sp, #28]
30014bd8:	e58d1018 	str	r1, [sp, #24]
30014bdc:	e58d2014 	str	r2, [sp, #20]
30014be0:	e5cd3013 	strb	r3, [sp, #19]
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
30014be4:	e59d0014 	ldr	r0, [sp, #20]
30014be8:	ebfffcd9 	bl	30013f54 <ip_route>
30014bec:	e1a03000 	mov	r3, r0
30014bf0:	e58d3024 	str	r3, [sp, #36]	; 0x24
30014bf4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30014bf8:	e3530000 	cmp	r3, #0
30014bfc:	1a000001 	bne	30014c08 <ip_output+0x3c>
    return ERR_RTE;
30014c00:	e3a030fd 	mov	r3, #253	; 0xfd
30014c04:	ea00000d 	b	30014c40 <ip_output+0x74>
  }
  //acoral_print("\r\nIP_OUTPUT\r\n");
  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
30014c08:	e5dd3013 	ldrb	r3, [sp, #19]
30014c0c:	e5dd2030 	ldrb	r2, [sp, #48]	; 0x30
30014c10:	e58d2000 	str	r2, [sp]
30014c14:	e5dd2034 	ldrb	r2, [sp, #52]	; 0x34
30014c18:	e58d2004 	str	r2, [sp, #4]
30014c1c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30014c20:	e58d2008 	str	r2, [sp, #8]
30014c24:	e59d001c 	ldr	r0, [sp, #28]
30014c28:	e59d1018 	ldr	r1, [sp, #24]
30014c2c:	e59d2014 	ldr	r2, [sp, #20]
30014c30:	ebfffe81 	bl	3001463c <ip_output_if>
30014c34:	e1a03000 	mov	r3, r0
30014c38:	e20330ff 	and	r3, r3, #255	; 0xff
30014c3c:	e20330ff 	and	r3, r3, #255	; 0xff
30014c40:	e1a03c03 	lsl	r3, r3, #24
30014c44:	e1a03c43 	asr	r3, r3, #24
}
30014c48:	e1a00003 	mov	r0, r3
30014c4c:	e28dd02c 	add	sp, sp, #44	; 0x2c
30014c50:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30014c54:	e12fff1e 	bx	lr

30014c58 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
30014c58:	e24dd010 	sub	sp, sp, #16
30014c5c:	e58d0004 	str	r0, [sp, #4]
30014c60:	e58d1000 	str	r1, [sp]
  u32_t addr2test;

  addr2test = addr->addr;
30014c64:	e59d3004 	ldr	r3, [sp, #4]
30014c68:	e5d32000 	ldrb	r2, [r3]
30014c6c:	e5d31001 	ldrb	r1, [r3, #1]
30014c70:	e1a01401 	lsl	r1, r1, #8
30014c74:	e1812002 	orr	r2, r1, r2
30014c78:	e5d31002 	ldrb	r1, [r3, #2]
30014c7c:	e1a01801 	lsl	r1, r1, #16
30014c80:	e1812002 	orr	r2, r1, r2
30014c84:	e5d33003 	ldrb	r3, [r3, #3]
30014c88:	e1a03c03 	lsl	r3, r3, #24
30014c8c:	e1833002 	orr	r3, r3, r2
30014c90:	e58d300c 	str	r3, [sp, #12]
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
30014c94:	e59d300c 	ldr	r3, [sp, #12]
30014c98:	e3730001 	cmn	r3, #1
30014c9c:	0a000002 	beq	30014cac <ip_addr_isbroadcast+0x54>
30014ca0:	e59d300c 	ldr	r3, [sp, #12]
30014ca4:	e3530000 	cmp	r3, #0
30014ca8:	1a000001 	bne	30014cb4 <ip_addr_isbroadcast+0x5c>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
30014cac:	e3a03001 	mov	r3, #1
30014cb0:	ea00002e 	b	30014d70 <ip_addr_isbroadcast+0x118>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
30014cb4:	e59d3000 	ldr	r3, [sp]
30014cb8:	e5d3302a 	ldrb	r3, [r3, #42]	; 0x2a
30014cbc:	e2033002 	and	r3, r3, #2
30014cc0:	e3530000 	cmp	r3, #0
30014cc4:	1a000001 	bne	30014cd0 <ip_addr_isbroadcast+0x78>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
30014cc8:	e3a03000 	mov	r3, #0
30014ccc:	ea000027 	b	30014d70 <ip_addr_isbroadcast+0x118>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
30014cd0:	e59d3000 	ldr	r3, [sp]
30014cd4:	e5932004 	ldr	r2, [r3, #4]
30014cd8:	e59d300c 	ldr	r3, [sp, #12]
30014cdc:	e1520003 	cmp	r2, r3
30014ce0:	1a000001 	bne	30014cec <ip_addr_isbroadcast+0x94>
    return 0;
30014ce4:	e3a03000 	mov	r3, #0
30014ce8:	ea000020 	b	30014d70 <ip_addr_isbroadcast+0x118>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
30014cec:	e59d3004 	ldr	r3, [sp, #4]
30014cf0:	e5d32000 	ldrb	r2, [r3]
30014cf4:	e5d31001 	ldrb	r1, [r3, #1]
30014cf8:	e1a01401 	lsl	r1, r1, #8
30014cfc:	e1812002 	orr	r2, r1, r2
30014d00:	e5d31002 	ldrb	r1, [r3, #2]
30014d04:	e1a01801 	lsl	r1, r1, #16
30014d08:	e1812002 	orr	r2, r1, r2
30014d0c:	e5d33003 	ldrb	r3, [r3, #3]
30014d10:	e1a03c03 	lsl	r3, r3, #24
30014d14:	e1833002 	orr	r3, r3, r2
30014d18:	e1a02003 	mov	r2, r3
30014d1c:	e59d3000 	ldr	r3, [sp]
30014d20:	e5933004 	ldr	r3, [r3, #4]
30014d24:	e0222003 	eor	r2, r2, r3
30014d28:	e59d3000 	ldr	r3, [sp]
30014d2c:	e5933008 	ldr	r3, [r3, #8]
30014d30:	e0023003 	and	r3, r2, r3
30014d34:	e3530000 	cmp	r3, #0
30014d38:	1a00000b 	bne	30014d6c <ip_addr_isbroadcast+0x114>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
30014d3c:	e59d3000 	ldr	r3, [sp]
30014d40:	e5933008 	ldr	r3, [r3, #8]
30014d44:	e1e02003 	mvn	r2, r3
30014d48:	e59d300c 	ldr	r3, [sp, #12]
30014d4c:	e0022003 	and	r2, r2, r3
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
30014d50:	e59d3000 	ldr	r3, [sp]
30014d54:	e5933008 	ldr	r3, [r3, #8]
30014d58:	e1e03003 	mvn	r3, r3
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
30014d5c:	e1520003 	cmp	r2, r3
30014d60:	1a000001 	bne	30014d6c <ip_addr_isbroadcast+0x114>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
30014d64:	e3a03001 	mov	r3, #1
30014d68:	ea000000 	b	30014d70 <ip_addr_isbroadcast+0x118>
  else
    return 0;
30014d6c:	e3a03000 	mov	r3, #0
}
30014d70:	e1a00003 	mov	r0, r3
30014d74:	e28dd010 	add	sp, sp, #16
30014d78:	e12fff1e 	bx	lr

30014d7c <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
30014d7c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30014d80:	e24dd034 	sub	sp, sp, #52	; 0x34
30014d84:	e58d000c 	str	r0, [sp, #12]
30014d88:	e58d1008 	str	r1, [sp, #8]
30014d8c:	e58d2004 	str	r2, [sp, #4]
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
30014d90:	e59d3008 	ldr	r3, [sp, #8]
30014d94:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
30014d98:	e1cd32b4 	strh	r3, [sp, #36]	; 0x24
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
30014d9c:	e3a03014 	mov	r3, #20
30014da0:	e1cd32bc 	strh	r3, [sp, #44]	; 0x2c
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
30014da4:	e3a00002 	mov	r0, #2
30014da8:	e3a01000 	mov	r1, #0
30014dac:	e3a02002 	mov	r2, #2
30014db0:	eb000380 	bl	30015bb8 <pbuf_alloc>
30014db4:	e1a03000 	mov	r3, r0
30014db8:	e58d3010 	str	r3, [sp, #16]
  if (rambuf == NULL) {
30014dbc:	e59d3010 	ldr	r3, [sp, #16]
30014dc0:	e3530000 	cmp	r3, #0
30014dc4:	1a000001 	bne	30014dd0 <ip_frag+0x54>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
30014dc8:	e3a030ff 	mov	r3, #255	; 0xff
30014dcc:	ea0000d2 	b	3001511c <ip_frag+0x3a0>
  }
  rambuf->tot_len = rambuf->len = mtu;
30014dd0:	e59d3010 	ldr	r3, [sp, #16]
30014dd4:	e1dd22b4 	ldrh	r2, [sp, #36]	; 0x24
30014dd8:	e1c320ba 	strh	r2, [r3, #10]
30014ddc:	e59d3010 	ldr	r3, [sp, #16]
30014de0:	e1d320ba 	ldrh	r2, [r3, #10]
30014de4:	e59d3010 	ldr	r3, [sp, #16]
30014de8:	e1c320b8 	strh	r2, [r3, #8]
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
30014dec:	e59f3340 	ldr	r3, [pc, #832]	; 30015134 <ip_frag+0x3b8>
30014df0:	e2833003 	add	r3, r3, #3
30014df4:	e3c33003 	bic	r3, r3, #3
30014df8:	e1a02003 	mov	r2, r3
30014dfc:	e59d3010 	ldr	r3, [sp, #16]
30014e00:	e5832004 	str	r2, [r3, #4]

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
30014e04:	e59d3010 	ldr	r3, [sp, #16]
30014e08:	e5933004 	ldr	r3, [r3, #4]
30014e0c:	e58d3018 	str	r3, [sp, #24]
  SMEMCPY(iphdr, p->payload, IP_HLEN);
30014e10:	e59d300c 	ldr	r3, [sp, #12]
30014e14:	e5933004 	ldr	r3, [r3, #4]
30014e18:	e59d0018 	ldr	r0, [sp, #24]
30014e1c:	e1a01003 	mov	r1, r3
30014e20:	e3a02014 	mov	r2, #20
30014e24:	ebffdd2c 	bl	3000c2dc <acoral_memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
30014e28:	e59d3018 	ldr	r3, [sp, #24]
30014e2c:	e5d32006 	ldrb	r2, [r3, #6]
30014e30:	e5d33007 	ldrb	r3, [r3, #7]
30014e34:	e1a03403 	lsl	r3, r3, #8
30014e38:	e1833002 	orr	r3, r3, r2
30014e3c:	e1a03803 	lsl	r3, r3, #16
30014e40:	e1a03823 	lsr	r3, r3, #16
30014e44:	e1a00003 	mov	r0, r3
30014e48:	ebfff9ff 	bl	3001364c <ntohs>
30014e4c:	e1a03000 	mov	r3, r0
30014e50:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
  ofo = tmp & IP_OFFMASK;
30014e54:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
30014e58:	e1a03983 	lsl	r3, r3, #19
30014e5c:	e1a039a3 	lsr	r3, r3, #19
30014e60:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
  omf = tmp & IP_MF;
30014e64:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
30014e68:	e2033a02 	and	r3, r3, #8192	; 0x2000
30014e6c:	e1cd32b8 	strh	r3, [sp, #40]	; 0x28

  left = p->tot_len - IP_HLEN;
30014e70:	e59d300c 	ldr	r3, [sp, #12]
30014e74:	e1d330b8 	ldrh	r3, [r3, #8]
30014e78:	e2433014 	sub	r3, r3, #20
30014e7c:	e1cd32b0 	strh	r3, [sp, #32]

  nfb = (mtu - IP_HLEN) / 8;
30014e80:	e1dd32b4 	ldrh	r3, [sp, #36]	; 0x24
30014e84:	e2433014 	sub	r3, r3, #20
30014e88:	e2832007 	add	r2, r3, #7
30014e8c:	e3530000 	cmp	r3, #0
30014e90:	b1a03002 	movlt	r3, r2
30014e94:	e1a031c3 	asr	r3, r3, #3
30014e98:	e1cd31be 	strh	r3, [sp, #30]

  while (left) {
30014e9c:	ea000098 	b	30015104 <ip_frag+0x388>
    last = (left <= mtu - IP_HLEN);
30014ea0:	e1dd22b0 	ldrh	r2, [sp, #32]
30014ea4:	e1dd32b4 	ldrh	r3, [sp, #36]	; 0x24
30014ea8:	e2433014 	sub	r3, r3, #20
30014eac:	e1520003 	cmp	r2, r3
30014eb0:	c3a03000 	movgt	r3, #0
30014eb4:	d3a03001 	movle	r3, #1
30014eb8:	e1cd32ba 	strh	r3, [sp, #42]	; 0x2a

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
30014ebc:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
30014ec0:	e1a03803 	lsl	r3, r3, #16
30014ec4:	e1a03823 	lsr	r3, r3, #16
30014ec8:	e1a03983 	lsl	r3, r3, #19
30014ecc:	e1a039a3 	lsr	r3, r3, #19
30014ed0:	e1dd12b8 	ldrh	r1, [sp, #40]	; 0x28
30014ed4:	e1a02003 	mov	r2, r3
30014ed8:	e1a03001 	mov	r3, r1
30014edc:	e1823003 	orr	r3, r2, r3
30014ee0:	e1a03803 	lsl	r3, r3, #16
30014ee4:	e1a03823 	lsr	r3, r3, #16
30014ee8:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
    if (!last)
30014eec:	e1dd32ba 	ldrh	r3, [sp, #42]	; 0x2a
30014ef0:	e3530000 	cmp	r3, #0
30014ef4:	1a000002 	bne	30014f04 <ip_frag+0x188>
      tmp = tmp | IP_MF;
30014ef8:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
30014efc:	e3833a02 	orr	r3, r3, #8192	; 0x2000
30014f00:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
30014f04:	e1dd32ba 	ldrh	r3, [sp, #42]	; 0x2a
30014f08:	e3530000 	cmp	r3, #0
30014f0c:	1a000004 	bne	30014f24 <ip_frag+0x1a8>
30014f10:	e1dd31be 	ldrh	r3, [sp, #30]
30014f14:	e1a03183 	lsl	r3, r3, #3
30014f18:	e1a03803 	lsl	r3, r3, #16
30014f1c:	e1a03823 	lsr	r3, r3, #16
30014f20:	ea000000 	b	30014f28 <ip_frag+0x1ac>
30014f24:	e1dd32b0 	ldrh	r3, [sp, #32]
30014f28:	e1cd32b2 	strh	r3, [sp, #34]	; 0x22

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
30014f2c:	e59d3018 	ldr	r3, [sp, #24]
30014f30:	e2831014 	add	r1, r3, #20
30014f34:	e1dd22b2 	ldrh	r2, [sp, #34]	; 0x22
30014f38:	e1dd32bc 	ldrh	r3, [sp, #44]	; 0x2c
30014f3c:	e59d000c 	ldr	r0, [sp, #12]
30014f40:	eb0005ea 	bl	300166f0 <pbuf_copy_partial>
30014f44:	e1a03000 	mov	r3, r0
30014f48:	e1a02003 	mov	r2, r3
30014f4c:	e1dd32bc 	ldrh	r3, [sp, #44]	; 0x2c
30014f50:	e0823003 	add	r3, r2, r3
30014f54:	e1cd32bc 	strh	r3, [sp, #44]	; 0x2c
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
30014f58:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
30014f5c:	e1a00003 	mov	r0, r3
30014f60:	ebfff9a6 	bl	30013600 <htons>
30014f64:	e1a03000 	mov	r3, r0
30014f68:	e1a02003 	mov	r2, r3
30014f6c:	e59d3018 	ldr	r3, [sp, #24]
30014f70:	e20210ff 	and	r1, r2, #255	; 0xff
30014f74:	e3a00000 	mov	r0, #0
30014f78:	e1801001 	orr	r1, r0, r1
30014f7c:	e5c31006 	strb	r1, [r3, #6]
30014f80:	e1a02422 	lsr	r2, r2, #8
30014f84:	e1a02802 	lsl	r2, r2, #16
30014f88:	e1a02822 	lsr	r2, r2, #16
30014f8c:	e3a01000 	mov	r1, #0
30014f90:	e1812002 	orr	r2, r1, r2
30014f94:	e5c32007 	strb	r2, [r3, #7]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
30014f98:	e1dd32b2 	ldrh	r3, [sp, #34]	; 0x22
30014f9c:	e2833014 	add	r3, r3, #20
30014fa0:	e1a03803 	lsl	r3, r3, #16
30014fa4:	e1a03823 	lsr	r3, r3, #16
30014fa8:	e1a00003 	mov	r0, r3
30014fac:	ebfff993 	bl	30013600 <htons>
30014fb0:	e1a03000 	mov	r3, r0
30014fb4:	e1a02003 	mov	r2, r3
30014fb8:	e59d3018 	ldr	r3, [sp, #24]
30014fbc:	e20210ff 	and	r1, r2, #255	; 0xff
30014fc0:	e3a00000 	mov	r0, #0
30014fc4:	e1801001 	orr	r1, r0, r1
30014fc8:	e5c31002 	strb	r1, [r3, #2]
30014fcc:	e1a02422 	lsr	r2, r2, #8
30014fd0:	e1a02802 	lsl	r2, r2, #16
30014fd4:	e1a02822 	lsr	r2, r2, #16
30014fd8:	e3a01000 	mov	r1, #0
30014fdc:	e1812002 	orr	r2, r1, r2
30014fe0:	e5c32003 	strb	r2, [r3, #3]
    IPH_CHKSUM_SET(iphdr, 0);
30014fe4:	e59d3018 	ldr	r3, [sp, #24]
30014fe8:	e3a02000 	mov	r2, #0
30014fec:	e5c3200a 	strb	r2, [r3, #10]
30014ff0:	e3a02000 	mov	r2, #0
30014ff4:	e5c3200b 	strb	r2, [r3, #11]
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
30014ff8:	e59d0018 	ldr	r0, [sp, #24]
30014ffc:	e3a01014 	mov	r1, #20
30015000:	ebfffb68 	bl	30013da8 <inet_chksum>
30015004:	e1a03000 	mov	r3, r0
30015008:	e1a02003 	mov	r2, r3
3001500c:	e59d3018 	ldr	r3, [sp, #24]
30015010:	e20210ff 	and	r1, r2, #255	; 0xff
30015014:	e3a00000 	mov	r0, #0
30015018:	e1801001 	orr	r1, r0, r1
3001501c:	e5c3100a 	strb	r1, [r3, #10]
30015020:	e1a02422 	lsr	r2, r2, #8
30015024:	e1a02802 	lsl	r2, r2, #16
30015028:	e1a02822 	lsr	r2, r2, #16
3001502c:	e3a01000 	mov	r1, #0
30015030:	e1812002 	orr	r2, r1, r2
30015034:	e5c3200b 	strb	r2, [r3, #11]

#if IP_FRAG_USES_STATIC_BUF
    if (last)
30015038:	e1dd32ba 	ldrh	r3, [sp, #42]	; 0x2a
3001503c:	e3530000 	cmp	r3, #0
30015040:	0a000006 	beq	30015060 <ip_frag+0x2e4>
      pbuf_realloc(rambuf, left + IP_HLEN);
30015044:	e1dd32b0 	ldrh	r3, [sp, #32]
30015048:	e2833014 	add	r3, r3, #20
3001504c:	e1a03803 	lsl	r3, r3, #16
30015050:	e1a03823 	lsr	r3, r3, #16
30015054:	e59d0010 	ldr	r0, [sp, #16]
30015058:	e1a01003 	mov	r1, r3
3001505c:	eb0003c4 	bl	30015f74 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
30015060:	e3a00002 	mov	r0, #2
30015064:	e3a01000 	mov	r1, #0
30015068:	e3a02000 	mov	r2, #0
3001506c:	eb0002d1 	bl	30015bb8 <pbuf_alloc>
30015070:	e1a03000 	mov	r3, r0
30015074:	e58d3014 	str	r3, [sp, #20]
    if (header != NULL) {
30015078:	e59d3014 	ldr	r3, [sp, #20]
3001507c:	e3530000 	cmp	r3, #0
30015080:	0a00001b 	beq	300150f4 <ip_frag+0x378>
      pbuf_chain(header, rambuf);
30015084:	e59d0014 	ldr	r0, [sp, #20]
30015088:	e59d1010 	ldr	r1, [sp, #16]
3001508c:	eb00050c 	bl	300164c4 <pbuf_chain>
      netif->output(netif, header, dest);
30015090:	e59d3008 	ldr	r3, [sp, #8]
30015094:	e5933014 	ldr	r3, [r3, #20]
30015098:	e59d0008 	ldr	r0, [sp, #8]
3001509c:	e59d1014 	ldr	r1, [sp, #20]
300150a0:	e59d2004 	ldr	r2, [sp, #4]
300150a4:	e1a0e00f 	mov	lr, pc
300150a8:	e12fff13 	bx	r3
      IPFRAG_STATS_INC(ip_frag.xmit);
300150ac:	e59f3084 	ldr	r3, [pc, #132]	; 30015138 <ip_frag+0x3bc>
300150b0:	e1d333b4 	ldrh	r3, [r3, #52]	; 0x34
300150b4:	e2833001 	add	r3, r3, #1
300150b8:	e1a03803 	lsl	r3, r3, #16
300150bc:	e1a02823 	lsr	r2, r3, #16
300150c0:	e59f3070 	ldr	r3, [pc, #112]	; 30015138 <ip_frag+0x3bc>
300150c4:	e1c323b4 	strh	r2, [r3, #52]	; 0x34
      snmp_inc_ipfragcreates();
      pbuf_free(header);
300150c8:	e59d0014 	ldr	r0, [sp, #20]
300150cc:	eb00046b 	bl	30016280 <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
300150d0:	e1dd22b0 	ldrh	r2, [sp, #32]
300150d4:	e1dd32b2 	ldrh	r3, [sp, #34]	; 0x22
300150d8:	e0633002 	rsb	r3, r3, r2
300150dc:	e1cd32b0 	strh	r3, [sp, #32]
    ofo += nfb;
300150e0:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
300150e4:	e1dd31be 	ldrh	r3, [sp, #30]
300150e8:	e0823003 	add	r3, r2, r3
300150ec:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
300150f0:	ea000003 	b	30015104 <ip_frag+0x388>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
300150f4:	e59d0010 	ldr	r0, [sp, #16]
300150f8:	eb000460 	bl	30016280 <pbuf_free>
      return ERR_MEM;
300150fc:	e3a030ff 	mov	r3, #255	; 0xff
30015100:	ea000005 	b	3001511c <ip_frag+0x3a0>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
30015104:	e1dd32b0 	ldrh	r3, [sp, #32]
30015108:	e3530000 	cmp	r3, #0
3001510c:	1affff63 	bne	30014ea0 <ip_frag+0x124>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
30015110:	e59d0010 	ldr	r0, [sp, #16]
30015114:	eb000459 	bl	30016280 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
30015118:	e3a03000 	mov	r3, #0
3001511c:	e1a03c03 	lsl	r3, r3, #24
30015120:	e1a03c43 	asr	r3, r3, #24
}
30015124:	e1a00003 	mov	r0, r3
30015128:	e28dd034 	add	sp, sp, #52	; 0x34
3001512c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30015130:	e12fff1e 	bx	lr
30015134:	300ca664 	.word	0x300ca664
30015138:	302be570 	.word	0x302be570

3001513c <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
3001513c:	e92d4008 	push	{r3, lr}
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
30015140:	ebffddb4 	bl	3000c818 <sys_init>
  mem_init();
30015144:	eb002e4d 	bl	30020a80 <mem_init>
  memp_init();
30015148:	eb000002 	bl	30015158 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
3001514c:	ebffe923 	bl	3000f5e0 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
30015150:	e8bd4008 	pop	{r3, lr}
30015154:	e12fff1e 	bx	lr

30015158 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
30015158:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
3001515c:	e24dd00c 	sub	sp, sp, #12
  struct memp *memp;
  u16_t i, j;

#if MEMP_STATS
  for (i = 0; i < MEMP_MAX; ++i) {
30015160:	e3a03000 	mov	r3, #0
30015164:	e1cd30b4 	strh	r3, [sp, #4]
30015168:	ea000036 	b	30015248 <memp_init+0xf0>
    lwip_stats.memp[i].used = lwip_stats.memp[i].max =
3001516c:	e1dd00b4 	ldrh	r0, [sp, #4]
30015170:	e1dd30b4 	ldrh	r3, [sp, #4]
      lwip_stats.memp[i].err = 0;
30015174:	e1dd20b4 	ldrh	r2, [sp, #4]
  struct memp *memp;
  u16_t i, j;

#if MEMP_STATS
  for (i = 0; i < MEMP_MAX; ++i) {
    lwip_stats.memp[i].used = lwip_stats.memp[i].max =
30015178:	e59fc1a0 	ldr	ip, [pc, #416]	; 30015320 <memp_init+0x1c8>
3001517c:	e2824017 	add	r4, r2, #23
30015180:	e3a0100c 	mov	r1, #12
30015184:	e1a04184 	lsl	r4, r4, #3
30015188:	e084c00c 	add	ip, r4, ip
3001518c:	e08c1001 	add	r1, ip, r1
30015190:	e3a0c000 	mov	ip, #0
30015194:	e1c1c0b0 	strh	ip, [r1]
      lwip_stats.memp[i].err = 0;
30015198:	e59f1180 	ldr	r1, [pc, #384]	; 30015320 <memp_init+0x1c8>
3001519c:	e282c017 	add	ip, r2, #23
300151a0:	e3a0200c 	mov	r2, #12
300151a4:	e1a0c18c 	lsl	ip, ip, #3
300151a8:	e08c1001 	add	r1, ip, r1
300151ac:	e0812002 	add	r2, r1, r2
300151b0:	e1d210b0 	ldrh	r1, [r2]
  struct memp *memp;
  u16_t i, j;

#if MEMP_STATS
  for (i = 0; i < MEMP_MAX; ++i) {
    lwip_stats.memp[i].used = lwip_stats.memp[i].max =
300151b4:	e59fc164 	ldr	ip, [pc, #356]	; 30015320 <memp_init+0x1c8>
300151b8:	e2834017 	add	r4, r3, #23
300151bc:	e3a0200a 	mov	r2, #10
300151c0:	e1a04184 	lsl	r4, r4, #3
300151c4:	e084c00c 	add	ip, r4, ip
300151c8:	e08c2002 	add	r2, ip, r2
300151cc:	e1c210b0 	strh	r1, [r2]
300151d0:	e59f2148 	ldr	r2, [pc, #328]	; 30015320 <memp_init+0x1c8>
300151d4:	e2831017 	add	r1, r3, #23
300151d8:	e3a0300a 	mov	r3, #10
300151dc:	e1a01181 	lsl	r1, r1, #3
300151e0:	e0812002 	add	r2, r1, r2
300151e4:	e0823003 	add	r3, r2, r3
300151e8:	e1d320b0 	ldrh	r2, [r3]
300151ec:	e59f112c 	ldr	r1, [pc, #300]	; 30015320 <memp_init+0x1c8>
300151f0:	e2800017 	add	r0, r0, #23
300151f4:	e3a03008 	mov	r3, #8
300151f8:	e1a00180 	lsl	r0, r0, #3
300151fc:	e0801001 	add	r1, r0, r1
30015200:	e0813003 	add	r3, r1, r3
30015204:	e1c320b0 	strh	r2, [r3]
      lwip_stats.memp[i].err = 0;
    lwip_stats.memp[i].avail = memp_num[i];
30015208:	e1dd30b4 	ldrh	r3, [sp, #4]
3001520c:	e1dd10b4 	ldrh	r1, [sp, #4]
30015210:	e59f210c 	ldr	r2, [pc, #268]	; 30015324 <memp_init+0x1cc>
30015214:	e1a01081 	lsl	r1, r1, #1
30015218:	e0812002 	add	r2, r1, r2
3001521c:	e1d220b0 	ldrh	r2, [r2]
30015220:	e59f10f8 	ldr	r1, [pc, #248]	; 30015320 <memp_init+0x1c8>
30015224:	e2830017 	add	r0, r3, #23
30015228:	e3a03006 	mov	r3, #6
3001522c:	e1a00180 	lsl	r0, r0, #3
30015230:	e0801001 	add	r1, r0, r1
30015234:	e0813003 	add	r3, r1, r3
30015238:	e1c320b0 	strh	r2, [r3]
{
  struct memp *memp;
  u16_t i, j;

#if MEMP_STATS
  for (i = 0; i < MEMP_MAX; ++i) {
3001523c:	e1dd30b4 	ldrh	r3, [sp, #4]
30015240:	e2833001 	add	r3, r3, #1
30015244:	e1cd30b4 	strh	r3, [sp, #4]
30015248:	e1dd30b4 	ldrh	r3, [sp, #4]
3001524c:	e353000c 	cmp	r3, #12
30015250:	9affffc5 	bls	3001516c <memp_init+0x14>
      lwip_stats.memp[i].err = 0;
    lwip_stats.memp[i].avail = memp_num[i];
  }
#endif /* MEMP_STATS */

  memp = LWIP_MEM_ALIGN(memp_memory);
30015254:	e59f30cc 	ldr	r3, [pc, #204]	; 30015328 <memp_init+0x1d0>
30015258:	e2833003 	add	r3, r3, #3
3001525c:	e3c33003 	bic	r3, r3, #3
30015260:	e58d3000 	str	r3, [sp]
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
30015264:	e3a03000 	mov	r3, #0
30015268:	e1cd30b4 	strh	r3, [sp, #4]
3001526c:	ea000025 	b	30015308 <memp_init+0x1b0>
    memp_tab[i] = NULL;
30015270:	e1dd20b4 	ldrh	r2, [sp, #4]
30015274:	e59f30b0 	ldr	r3, [pc, #176]	; 3001532c <memp_init+0x1d4>
30015278:	e3a01000 	mov	r1, #0
3001527c:	e7831102 	str	r1, [r3, r2, lsl #2]
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
30015280:	e3a03000 	mov	r3, #0
30015284:	e1cd30b6 	strh	r3, [sp, #6]
30015288:	ea000013 	b	300152dc <memp_init+0x184>
      memp->next = memp_tab[i];
3001528c:	e1dd20b4 	ldrh	r2, [sp, #4]
30015290:	e59f3094 	ldr	r3, [pc, #148]	; 3001532c <memp_init+0x1d4>
30015294:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30015298:	e59d3000 	ldr	r3, [sp]
3001529c:	e5832000 	str	r2, [r3]
      memp_tab[i] = memp;
300152a0:	e1dd20b4 	ldrh	r2, [sp, #4]
300152a4:	e59f3080 	ldr	r3, [pc, #128]	; 3001532c <memp_init+0x1d4>
300152a8:	e59d1000 	ldr	r1, [sp]
300152ac:	e7831102 	str	r1, [r3, r2, lsl #2]
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
300152b0:	e1dd20b4 	ldrh	r2, [sp, #4]
300152b4:	e59f3074 	ldr	r3, [pc, #116]	; 30015330 <memp_init+0x1d8>
300152b8:	e1a02082 	lsl	r2, r2, #1
300152bc:	e0823003 	add	r3, r2, r3
300152c0:	e1d330b0 	ldrh	r3, [r3]
300152c4:	e59d2000 	ldr	r2, [sp]
300152c8:	e0823003 	add	r3, r2, r3
300152cc:	e58d3000 	str	r3, [sp]
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
300152d0:	e1dd30b6 	ldrh	r3, [sp, #6]
300152d4:	e2833001 	add	r3, r3, #1
300152d8:	e1cd30b6 	strh	r3, [sp, #6]
300152dc:	e1dd20b4 	ldrh	r2, [sp, #4]
300152e0:	e59f303c 	ldr	r3, [pc, #60]	; 30015324 <memp_init+0x1cc>
300152e4:	e1a02082 	lsl	r2, r2, #1
300152e8:	e0823003 	add	r3, r2, r3
300152ec:	e1d330b0 	ldrh	r3, [r3]
300152f0:	e1dd20b6 	ldrh	r2, [sp, #6]
300152f4:	e1520003 	cmp	r2, r3
300152f8:	3affffe3 	bcc	3001528c <memp_init+0x134>
  }
#endif /* MEMP_STATS */

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
300152fc:	e1dd30b4 	ldrh	r3, [sp, #4]
30015300:	e2833001 	add	r3, r3, #1
30015304:	e1cd30b4 	strh	r3, [sp, #4]
30015308:	e1dd30b4 	ldrh	r3, [sp, #4]
3001530c:	e353000c 	cmp	r3, #12
30015310:	9affffd6 	bls	30015270 <memp_init+0x118>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
30015314:	e28dd00c 	add	sp, sp, #12
30015318:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
3001531c:	e12fff1e 	bx	lr
30015320:	302be570 	.word	0x302be570
30015324:	300456f4 	.word	0x300456f4
30015328:	300cac74 	.word	0x300cac74
3001532c:	300cac40 	.word	0x300cac40
30015330:	300456d8 	.word	0x300456d8

30015334 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
30015334:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30015338:	e24dd014 	sub	sp, sp, #20
3001533c:	e1a03000 	mov	r3, r0
30015340:	e5cd3007 	strb	r3, [sp, #7]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);

  SYS_ARCH_PROTECT(old_level);
30015344:	ebffb0ea 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
30015348:	e1a03000 	mov	r3, r0
3001534c:	e58d300c 	str	r3, [sp, #12]
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
30015350:	e5dd2007 	ldrb	r2, [sp, #7]
30015354:	e59f3164 	ldr	r3, [pc, #356]	; 300154c0 <memp_malloc+0x18c>
30015358:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3001535c:	e58d3008 	str	r3, [sp, #8]
  
  if (memp != NULL) {    
30015360:	e59d3008 	ldr	r3, [sp, #8]
30015364:	e3530000 	cmp	r3, #0
30015368:	0a000039 	beq	30015454 <memp_malloc+0x120>
    memp_tab[type] = memp->next;    
3001536c:	e5dd2007 	ldrb	r2, [sp, #7]
30015370:	e59d3008 	ldr	r3, [sp, #8]
30015374:	e5931000 	ldr	r1, [r3]
30015378:	e59f3140 	ldr	r3, [pc, #320]	; 300154c0 <memp_malloc+0x18c>
3001537c:	e7831102 	str	r1, [r3, r2, lsl #2]
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
#if MEMP_STATS
    ++lwip_stats.memp[type].used;
30015380:	e5dd3007 	ldrb	r3, [sp, #7]
30015384:	e59f1138 	ldr	r1, [pc, #312]	; 300154c4 <memp_malloc+0x190>
30015388:	e2830017 	add	r0, r3, #23
3001538c:	e3a02008 	mov	r2, #8
30015390:	e1a00180 	lsl	r0, r0, #3
30015394:	e0801001 	add	r1, r0, r1
30015398:	e0812002 	add	r2, r1, r2
3001539c:	e1d220b0 	ldrh	r2, [r2]
300153a0:	e2822001 	add	r2, r2, #1
300153a4:	e1a02802 	lsl	r2, r2, #16
300153a8:	e1a02822 	lsr	r2, r2, #16
300153ac:	e59f1110 	ldr	r1, [pc, #272]	; 300154c4 <memp_malloc+0x190>
300153b0:	e2830017 	add	r0, r3, #23
300153b4:	e3a03008 	mov	r3, #8
300153b8:	e1a00180 	lsl	r0, r0, #3
300153bc:	e0801001 	add	r1, r0, r1
300153c0:	e0813003 	add	r3, r1, r3
300153c4:	e1c320b0 	strh	r2, [r3]
    if (lwip_stats.memp[type].used > lwip_stats.memp[type].max) {
300153c8:	e5dd3007 	ldrb	r3, [sp, #7]
300153cc:	e59f20f0 	ldr	r2, [pc, #240]	; 300154c4 <memp_malloc+0x190>
300153d0:	e2831017 	add	r1, r3, #23
300153d4:	e3a03008 	mov	r3, #8
300153d8:	e1a01181 	lsl	r1, r1, #3
300153dc:	e0812002 	add	r2, r1, r2
300153e0:	e0823003 	add	r3, r2, r3
300153e4:	e1d320b0 	ldrh	r2, [r3]
300153e8:	e5dd3007 	ldrb	r3, [sp, #7]
300153ec:	e59f10d0 	ldr	r1, [pc, #208]	; 300154c4 <memp_malloc+0x190>
300153f0:	e2830017 	add	r0, r3, #23
300153f4:	e3a0300a 	mov	r3, #10
300153f8:	e1a00180 	lsl	r0, r0, #3
300153fc:	e0801001 	add	r1, r0, r1
30015400:	e0813003 	add	r3, r1, r3
30015404:	e1d330b0 	ldrh	r3, [r3]
30015408:	e1520003 	cmp	r2, r3
3001540c:	9a000023 	bls	300154a0 <memp_malloc+0x16c>
      lwip_stats.memp[type].max = lwip_stats.memp[type].used;
30015410:	e5dd3007 	ldrb	r3, [sp, #7]
30015414:	e5dd2007 	ldrb	r2, [sp, #7]
30015418:	e59f10a4 	ldr	r1, [pc, #164]	; 300154c4 <memp_malloc+0x190>
3001541c:	e2820017 	add	r0, r2, #23
30015420:	e3a02008 	mov	r2, #8
30015424:	e1a00180 	lsl	r0, r0, #3
30015428:	e0801001 	add	r1, r0, r1
3001542c:	e0812002 	add	r2, r1, r2
30015430:	e1d220b0 	ldrh	r2, [r2]
30015434:	e59f1088 	ldr	r1, [pc, #136]	; 300154c4 <memp_malloc+0x190>
30015438:	e2830017 	add	r0, r3, #23
3001543c:	e3a0300a 	mov	r3, #10
30015440:	e1a00180 	lsl	r0, r0, #3
30015444:	e0801001 	add	r1, r0, r1
30015448:	e0813003 	add	r3, r1, r3
3001544c:	e1c320b0 	strh	r2, [r3]
30015450:	ea000013 	b	300154a4 <memp_malloc+0x170>
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
    memp = (struct memp*)((u8_t*)memp + MEMP_SIZE);
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | 2, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
#if MEMP_STATS
    ++lwip_stats.memp[type].err;
30015454:	e5dd3007 	ldrb	r3, [sp, #7]
30015458:	e59f1064 	ldr	r1, [pc, #100]	; 300154c4 <memp_malloc+0x190>
3001545c:	e2830017 	add	r0, r3, #23
30015460:	e3a0200c 	mov	r2, #12
30015464:	e1a00180 	lsl	r0, r0, #3
30015468:	e0801001 	add	r1, r0, r1
3001546c:	e0812002 	add	r2, r1, r2
30015470:	e1d220b0 	ldrh	r2, [r2]
30015474:	e2822001 	add	r2, r2, #1
30015478:	e1a02802 	lsl	r2, r2, #16
3001547c:	e1a02822 	lsr	r2, r2, #16
30015480:	e59f103c 	ldr	r1, [pc, #60]	; 300154c4 <memp_malloc+0x190>
30015484:	e2830017 	add	r0, r3, #23
30015488:	e3a0300c 	mov	r3, #12
3001548c:	e1a00180 	lsl	r0, r0, #3
30015490:	e0801001 	add	r1, r0, r1
30015494:	e0813003 	add	r3, r1, r3
30015498:	e1c320b0 	strh	r2, [r3]
3001549c:	ea000000 	b	300154a4 <memp_malloc+0x170>
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
#if MEMP_STATS
    ++lwip_stats.memp[type].used;
    if (lwip_stats.memp[type].used > lwip_stats.memp[type].max) {
      lwip_stats.memp[type].max = lwip_stats.memp[type].used;
300154a0:	e1a00000 	nop			; (mov r0, r0)
#if MEMP_STATS
    ++lwip_stats.memp[type].err;
#endif /* MEMP_STATS */
  }

  SYS_ARCH_UNPROTECT(old_level);
300154a4:	e59d000c 	ldr	r0, [sp, #12]
300154a8:	ebffb08f 	bl	300016ec <HAL_INTR_RESTORE>

  return memp;
300154ac:	e59d3008 	ldr	r3, [sp, #8]
}
300154b0:	e1a00003 	mov	r0, r3
300154b4:	e28dd014 	add	sp, sp, #20
300154b8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300154bc:	e12fff1e 	bx	lr
300154c0:	300cac40 	.word	0x300cac40
300154c4:	302be570 	.word	0x302be570

300154c8 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
300154c8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300154cc:	e24dd014 	sub	sp, sp, #20
300154d0:	e1a03000 	mov	r3, r0
300154d4:	e58d1000 	str	r1, [sp]
300154d8:	e5cd3007 	strb	r3, [sp, #7]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
300154dc:	e59d3000 	ldr	r3, [sp]
300154e0:	e3530000 	cmp	r3, #0
300154e4:	0a000022 	beq	30015574 <memp_free+0xac>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)((u8_t*)mem - MEMP_SIZE);
300154e8:	e59d3000 	ldr	r3, [sp]
300154ec:	e58d3008 	str	r3, [sp, #8]

  SYS_ARCH_PROTECT(old_level);
300154f0:	ebffb07f 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300154f4:	e1a03000 	mov	r3, r0
300154f8:	e58d300c 	str	r3, [sp, #12]
  memp_overflow_check_element(memp, memp_sizes[type]);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

#if MEMP_STATS
  lwip_stats.memp[type].used--; 
300154fc:	e5dd3007 	ldrb	r3, [sp, #7]
30015500:	e59f107c 	ldr	r1, [pc, #124]	; 30015584 <memp_free+0xbc>
30015504:	e2830017 	add	r0, r3, #23
30015508:	e3a02008 	mov	r2, #8
3001550c:	e1a00180 	lsl	r0, r0, #3
30015510:	e0801001 	add	r1, r0, r1
30015514:	e0812002 	add	r2, r1, r2
30015518:	e1d220b0 	ldrh	r2, [r2]
3001551c:	e2422001 	sub	r2, r2, #1
30015520:	e1a02802 	lsl	r2, r2, #16
30015524:	e1a02822 	lsr	r2, r2, #16
30015528:	e59f1054 	ldr	r1, [pc, #84]	; 30015584 <memp_free+0xbc>
3001552c:	e2830017 	add	r0, r3, #23
30015530:	e3a03008 	mov	r3, #8
30015534:	e1a00180 	lsl	r0, r0, #3
30015538:	e0801001 	add	r1, r0, r1
3001553c:	e0813003 	add	r3, r1, r3
30015540:	e1c320b0 	strh	r2, [r3]
#endif /* MEMP_STATS */
  
  memp->next = memp_tab[type]; 
30015544:	e5dd2007 	ldrb	r2, [sp, #7]
30015548:	e59f3038 	ldr	r3, [pc, #56]	; 30015588 <memp_free+0xc0>
3001554c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30015550:	e59d3008 	ldr	r3, [sp, #8]
30015554:	e5832000 	str	r2, [r3]
  memp_tab[type] = memp;
30015558:	e5dd2007 	ldrb	r2, [sp, #7]
3001555c:	e59f3024 	ldr	r3, [pc, #36]	; 30015588 <memp_free+0xc0>
30015560:	e59d1008 	ldr	r1, [sp, #8]
30015564:	e7831102 	str	r1, [r3, r2, lsl #2]

#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
30015568:	e59d000c 	ldr	r0, [sp, #12]
3001556c:	ebffb05e 	bl	300016ec <HAL_INTR_RESTORE>
30015570:	ea000000 	b	30015578 <memp_free+0xb0>
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
30015574:	e1a00000 	nop			; (mov r0, r0)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
30015578:	e28dd014 	add	sp, sp, #20
3001557c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30015580:	e12fff1e 	bx	lr
30015584:	302be570 	.word	0x302be570
30015588:	300cac40 	.word	0x300cac40

3001558c <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
3001558c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30015590:	e24dd014 	sub	sp, sp, #20
30015594:	e58d000c 	str	r0, [sp, #12]
30015598:	e58d1008 	str	r1, [sp, #8]
3001559c:	e58d2004 	str	r2, [sp, #4]
300155a0:	e58d3000 	str	r3, [sp]
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
300155a4:	e59d300c 	ldr	r3, [sp, #12]
300155a8:	e3a02000 	mov	r2, #0
300155ac:	e5832004 	str	r2, [r3, #4]
  netif->netmask.addr = 0;
300155b0:	e59d300c 	ldr	r3, [sp, #12]
300155b4:	e3a02000 	mov	r2, #0
300155b8:	e5832008 	str	r2, [r3, #8]
  netif->gw.addr = 0;
300155bc:	e59d300c 	ldr	r3, [sp, #12]
300155c0:	e3a02000 	mov	r2, #0
300155c4:	e583200c 	str	r2, [r3, #12]
  netif->flags = 0;
300155c8:	e59d300c 	ldr	r3, [sp, #12]
300155cc:	e3a02000 	mov	r2, #0
300155d0:	e5c3202a 	strb	r2, [r3, #42]	; 0x2a
#if LWIP_IGMP
  netif->igmp_mac_filter = NULL;
#endif /* LWIP_IGMP */

  /* remember netif specific state information data */
  netif->state = state;
300155d4:	e59d300c 	ldr	r3, [sp, #12]
300155d8:	e59d2018 	ldr	r2, [sp, #24]
300155dc:	e583201c 	str	r2, [r3, #28]
  netif->num = netifnum++;
300155e0:	e59f3094 	ldr	r3, [pc, #148]	; 3001567c <netif_add+0xf0>
300155e4:	e5d33000 	ldrb	r3, [r3]
300155e8:	e59d200c 	ldr	r2, [sp, #12]
300155ec:	e1a01003 	mov	r1, r3
300155f0:	e5c2102d 	strb	r1, [r2, #45]	; 0x2d
300155f4:	e2833001 	add	r3, r3, #1
300155f8:	e20320ff 	and	r2, r3, #255	; 0xff
300155fc:	e59f3078 	ldr	r3, [pc, #120]	; 3001567c <netif_add+0xf0>
30015600:	e5c32000 	strb	r2, [r3]
  netif->input = input;
30015604:	e59d300c 	ldr	r3, [sp, #12]
30015608:	e59d2020 	ldr	r2, [sp, #32]
3001560c:	e5832010 	str	r2, [r3, #16]
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  netif_set_addr(netif, ipaddr, netmask, gw);
30015610:	e59d000c 	ldr	r0, [sp, #12]
30015614:	e59d1008 	ldr	r1, [sp, #8]
30015618:	e59d2004 	ldr	r2, [sp, #4]
3001561c:	e59d3000 	ldr	r3, [sp]
30015620:	eb000017 	bl	30015684 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
30015624:	e59d301c 	ldr	r3, [sp, #28]
30015628:	e59d000c 	ldr	r0, [sp, #12]
3001562c:	e1a0e00f 	mov	lr, pc
30015630:	e12fff13 	bx	r3
30015634:	e1a03000 	mov	r3, r0
30015638:	e20330ff 	and	r3, r3, #255	; 0xff
3001563c:	e3530000 	cmp	r3, #0
30015640:	0a000001 	beq	3001564c <netif_add+0xc0>
    return NULL;
30015644:	e3a03000 	mov	r3, #0
30015648:	ea000007 	b	3001566c <netif_add+0xe0>
  }

  /* add this netif to the list */
  netif->next = netif_list;
3001564c:	e59f302c 	ldr	r3, [pc, #44]	; 30015680 <netif_add+0xf4>
30015650:	e5932000 	ldr	r2, [r3]
30015654:	e59d300c 	ldr	r3, [sp, #12]
30015658:	e5832000 	str	r2, [r3]
  netif_list = netif;
3001565c:	e59f301c 	ldr	r3, [pc, #28]	; 30015680 <netif_add+0xf4>
30015660:	e59d200c 	ldr	r2, [sp, #12]
30015664:	e5832000 	str	r2, [r3]
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
30015668:	e59d300c 	ldr	r3, [sp, #12]
}
3001566c:	e1a00003 	mov	r0, r3
30015670:	e28dd014 	add	sp, sp, #20
30015674:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30015678:	e12fff1e 	bx	lr
3001567c:	300dbb8c 	.word	0x300dbb8c
30015680:	300ea398 	.word	0x300ea398

30015684 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
30015684:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30015688:	e24dd014 	sub	sp, sp, #20
3001568c:	e58d000c 	str	r0, [sp, #12]
30015690:	e58d1008 	str	r1, [sp, #8]
30015694:	e58d2004 	str	r2, [sp, #4]
30015698:	e58d3000 	str	r3, [sp]
  netif_set_ipaddr(netif, ipaddr);
3001569c:	e59d000c 	ldr	r0, [sp, #12]
300156a0:	e59d1008 	ldr	r1, [sp, #8]
300156a4:	eb00006e 	bl	30015864 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
300156a8:	e59d000c 	ldr	r0, [sp, #12]
300156ac:	e59d1004 	ldr	r1, [sp, #4]
300156b0:	eb0000ee 	bl	30015a70 <netif_set_netmask>
  netif_set_gw(netif, gw);
300156b4:	e59d000c 	ldr	r0, [sp, #12]
300156b8:	e59d1000 	ldr	r1, [sp]
300156bc:	eb0000d4 	bl	30015a14 <netif_set_gw>
}
300156c0:	e28dd014 	add	sp, sp, #20
300156c4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300156c8:	e12fff1e 	bx	lr

300156cc <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
300156cc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300156d0:	e24dd014 	sub	sp, sp, #20
300156d4:	e58d0004 	str	r0, [sp, #4]
  if ( netif == NULL ) return;
300156d8:	e59d3004 	ldr	r3, [sp, #4]
300156dc:	e3530000 	cmp	r3, #0
300156e0:	0a000028 	beq	30015788 <netif_remove+0xbc>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
300156e4:	e59f30b4 	ldr	r3, [pc, #180]	; 300157a0 <netif_remove+0xd4>
300156e8:	e5932000 	ldr	r2, [r3]
300156ec:	e59d3004 	ldr	r3, [sp, #4]
300156f0:	e1520003 	cmp	r2, r3
300156f4:	1a000004 	bne	3001570c <netif_remove+0x40>
    netif_list = netif->next;
300156f8:	e59d3004 	ldr	r3, [sp, #4]
300156fc:	e5932000 	ldr	r2, [r3]
30015700:	e59f3098 	ldr	r3, [pc, #152]	; 300157a0 <netif_remove+0xd4>
30015704:	e5832000 	str	r2, [r3]
30015708:	ea000016 	b	30015768 <netif_remove+0x9c>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
3001570c:	e59f308c 	ldr	r3, [pc, #140]	; 300157a0 <netif_remove+0xd4>
30015710:	e5933000 	ldr	r3, [r3]
30015714:	e58d300c 	str	r3, [sp, #12]
30015718:	ea00000c 	b	30015750 <netif_remove+0x84>
      if (tmpNetif->next == netif) {
3001571c:	e59d300c 	ldr	r3, [sp, #12]
30015720:	e5932000 	ldr	r2, [r3]
30015724:	e59d3004 	ldr	r3, [sp, #4]
30015728:	e1520003 	cmp	r2, r3
3001572c:	1a000004 	bne	30015744 <netif_remove+0x78>
        tmpNetif->next = netif->next;
30015730:	e59d3004 	ldr	r3, [sp, #4]
30015734:	e5932000 	ldr	r2, [r3]
30015738:	e59d300c 	ldr	r3, [sp, #12]
3001573c:	e5832000 	str	r2, [r3]
        snmp_dec_iflist();
        break;
30015740:	ea000005 	b	3001575c <netif_remove+0x90>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
30015744:	e59d300c 	ldr	r3, [sp, #12]
30015748:	e5933000 	ldr	r3, [r3]
3001574c:	e58d300c 	str	r3, [sp, #12]
30015750:	e59d300c 	ldr	r3, [sp, #12]
30015754:	e3530000 	cmp	r3, #0
30015758:	1affffef 	bne	3001571c <netif_remove+0x50>
        tmpNetif->next = netif->next;
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
3001575c:	e59d300c 	ldr	r3, [sp, #12]
30015760:	e3530000 	cmp	r3, #0
30015764:	0a000009 	beq	30015790 <netif_remove+0xc4>
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
30015768:	e59f3034 	ldr	r3, [pc, #52]	; 300157a4 <netif_remove+0xd8>
3001576c:	e5932000 	ldr	r2, [r3]
30015770:	e59d3004 	ldr	r3, [sp, #4]
30015774:	e1520003 	cmp	r2, r3
30015778:	1a000005 	bne	30015794 <netif_remove+0xc8>
    /* reset default netif */
    netif_set_default(NULL);
3001577c:	e3a00000 	mov	r0, #0
30015780:	eb0000d1 	bl	30015acc <netif_set_default>
30015784:	ea000002 	b	30015794 <netif_remove+0xc8>
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  if ( netif == NULL ) return;
30015788:	e1a00000 	nop			; (mov r0, r0)
3001578c:	ea000000 	b	30015794 <netif_remove+0xc8>
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
30015790:	e1a00000 	nop			; (mov r0, r0)
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
30015794:	e28dd014 	add	sp, sp, #20
30015798:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001579c:	e12fff1e 	bx	lr
300157a0:	300ea398 	.word	0x300ea398
300157a4:	302be6a8 	.word	0x302be6a8

300157a8 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
300157a8:	e24dd010 	sub	sp, sp, #16
300157ac:	e58d0004 	str	r0, [sp, #4]
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
300157b0:	e59d3004 	ldr	r3, [sp, #4]
300157b4:	e3530000 	cmp	r3, #0
300157b8:	1a000001 	bne	300157c4 <netif_find+0x1c>
    return NULL;
300157bc:	e3a03000 	mov	r3, #0
300157c0:	ea000023 	b	30015854 <netif_find+0xac>
  }

  num = name[2] - '0';
300157c4:	e59d3004 	ldr	r3, [sp, #4]
300157c8:	e2833002 	add	r3, r3, #2
300157cc:	e5d33000 	ldrb	r3, [r3]
300157d0:	e2433030 	sub	r3, r3, #48	; 0x30
300157d4:	e5cd300f 	strb	r3, [sp, #15]

  for(netif = netif_list; netif != NULL; netif = netif->next) {
300157d8:	e59f3080 	ldr	r3, [pc, #128]	; 30015860 <netif_find+0xb8>
300157dc:	e5933000 	ldr	r3, [r3]
300157e0:	e58d3008 	str	r3, [sp, #8]
300157e4:	ea000016 	b	30015844 <netif_find+0x9c>
    if (num == netif->num &&
300157e8:	e59d3008 	ldr	r3, [sp, #8]
300157ec:	e5d3302d 	ldrb	r3, [r3, #45]	; 0x2d
300157f0:	e5dd200f 	ldrb	r2, [sp, #15]
300157f4:	e1520003 	cmp	r2, r3
300157f8:	1a00000e 	bne	30015838 <netif_find+0x90>
       name[0] == netif->name[0] &&
300157fc:	e59d3004 	ldr	r3, [sp, #4]
30015800:	e5d32000 	ldrb	r2, [r3]
30015804:	e59d3008 	ldr	r3, [sp, #8]
30015808:	e5d3302b 	ldrb	r3, [r3, #43]	; 0x2b
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
3001580c:	e1520003 	cmp	r2, r3
30015810:	1a000008 	bne	30015838 <netif_find+0x90>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
30015814:	e59d3004 	ldr	r3, [sp, #4]
30015818:	e2833001 	add	r3, r3, #1
3001581c:	e5d32000 	ldrb	r2, [r3]
30015820:	e59d3008 	ldr	r3, [sp, #8]
30015824:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
30015828:	e1520003 	cmp	r2, r3
3001582c:	1a000001 	bne	30015838 <netif_find+0x90>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
30015830:	e59d3008 	ldr	r3, [sp, #8]
30015834:	ea000006 	b	30015854 <netif_find+0xac>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
30015838:	e59d3008 	ldr	r3, [sp, #8]
3001583c:	e5933000 	ldr	r3, [r3]
30015840:	e58d3008 	str	r3, [sp, #8]
30015844:	e59d3008 	ldr	r3, [sp, #8]
30015848:	e3530000 	cmp	r3, #0
3001584c:	1affffe5 	bne	300157e8 <netif_find+0x40>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
30015850:	e3a03000 	mov	r3, #0
}
30015854:	e1a00003 	mov	r0, r3
30015858:	e28dd010 	add	sp, sp, #16
3001585c:	e12fff1e 	bx	lr
30015860:	300ea398 	.word	0x300ea398

30015864 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
30015864:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30015868:	e24dd01c 	sub	sp, sp, #28
3001586c:	e58d0004 	str	r0, [sp, #4]
30015870:	e58d1000 	str	r1, [sp]
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
30015874:	e59d3000 	ldr	r3, [sp]
30015878:	e5d32000 	ldrb	r2, [r3]
3001587c:	e5d31001 	ldrb	r1, [r3, #1]
30015880:	e1a01401 	lsl	r1, r1, #8
30015884:	e1812002 	orr	r2, r1, r2
30015888:	e5d31002 	ldrb	r1, [r3, #2]
3001588c:	e1a01801 	lsl	r1, r1, #16
30015890:	e1812002 	orr	r2, r1, r2
30015894:	e5d33003 	ldrb	r3, [r3, #3]
30015898:	e1a03c03 	lsl	r3, r3, #24
3001589c:	e1833002 	orr	r3, r3, r2
300158a0:	e1a02003 	mov	r2, r3
300158a4:	e59d3004 	ldr	r3, [sp, #4]
300158a8:	e5933004 	ldr	r3, [r3, #4]
300158ac:	e1520003 	cmp	r2, r3
300158b0:	0a000040 	beq	300159b8 <netif_set_ipaddr+0x154>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
300158b4:	e59f3150 	ldr	r3, [pc, #336]	; 30015a0c <netif_set_ipaddr+0x1a8>
300158b8:	e5933000 	ldr	r3, [r3]
300158bc:	e58d300c 	str	r3, [sp, #12]
    while (pcb != NULL) {
300158c0:	ea000010 	b	30015908 <netif_set_ipaddr+0xa4>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
300158c4:	e59d300c 	ldr	r3, [sp, #12]
300158c8:	e5932000 	ldr	r2, [r3]
300158cc:	e59d3004 	ldr	r3, [sp, #4]
300158d0:	e5933004 	ldr	r3, [r3, #4]
300158d4:	e1520003 	cmp	r2, r3
300158d8:	1a000007 	bne	300158fc <netif_set_ipaddr+0x98>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
300158dc:	e59d300c 	ldr	r3, [sp, #12]
300158e0:	e593300c 	ldr	r3, [r3, #12]
300158e4:	e58d3014 	str	r3, [sp, #20]
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
300158e8:	e59d000c 	ldr	r0, [sp, #12]
300158ec:	eb000789 	bl	30017718 <tcp_abort>
        pcb = next;
300158f0:	e59d3014 	ldr	r3, [sp, #20]
300158f4:	e58d300c 	str	r3, [sp, #12]
300158f8:	ea000002 	b	30015908 <netif_set_ipaddr+0xa4>
      } else {
        pcb = pcb->next;
300158fc:	e59d300c 	ldr	r3, [sp, #12]
30015900:	e593300c 	ldr	r3, [r3, #12]
30015904:	e58d300c 	str	r3, [sp, #12]
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
30015908:	e59d300c 	ldr	r3, [sp, #12]
3001590c:	e3530000 	cmp	r3, #0
30015910:	1affffeb 	bne	300158c4 <netif_set_ipaddr+0x60>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
30015914:	e59f30f4 	ldr	r3, [pc, #244]	; 30015a10 <netif_set_ipaddr+0x1ac>
30015918:	e5933000 	ldr	r3, [r3]
3001591c:	e58d3010 	str	r3, [sp, #16]
30015920:	ea000021 	b	300159ac <netif_set_ipaddr+0x148>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
30015924:	e59d3010 	ldr	r3, [sp, #16]
30015928:	e3530000 	cmp	r3, #0
3001592c:	0a00001b 	beq	300159a0 <netif_set_ipaddr+0x13c>
30015930:	e59d3010 	ldr	r3, [sp, #16]
30015934:	e5933000 	ldr	r3, [r3]
30015938:	e3530000 	cmp	r3, #0
3001593c:	0a000017 	beq	300159a0 <netif_set_ipaddr+0x13c>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
30015940:	e59d3010 	ldr	r3, [sp, #16]
30015944:	e5932000 	ldr	r2, [r3]
30015948:	e59d3004 	ldr	r3, [sp, #4]
3001594c:	e5933004 	ldr	r3, [r3, #4]
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
30015950:	e1520003 	cmp	r2, r3
30015954:	1a000011 	bne	300159a0 <netif_set_ipaddr+0x13c>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
30015958:	e59d3000 	ldr	r3, [sp]
3001595c:	e3530000 	cmp	r3, #0
30015960:	0a00000b 	beq	30015994 <netif_set_ipaddr+0x130>
30015964:	e59d3000 	ldr	r3, [sp]
30015968:	e5d32000 	ldrb	r2, [r3]
3001596c:	e5d31001 	ldrb	r1, [r3, #1]
30015970:	e1a01401 	lsl	r1, r1, #8
30015974:	e1812002 	orr	r2, r1, r2
30015978:	e5d31002 	ldrb	r1, [r3, #2]
3001597c:	e1a01801 	lsl	r1, r1, #16
30015980:	e1812002 	orr	r2, r1, r2
30015984:	e5d33003 	ldrb	r3, [r3, #3]
30015988:	e1a03c03 	lsl	r3, r3, #24
3001598c:	e1833002 	orr	r3, r3, r2
30015990:	ea000000 	b	30015998 <netif_set_ipaddr+0x134>
30015994:	e3a03000 	mov	r3, #0
30015998:	e59d2010 	ldr	r2, [sp, #16]
3001599c:	e5823000 	str	r3, [r2]
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
300159a0:	e59d3010 	ldr	r3, [sp, #16]
300159a4:	e593300c 	ldr	r3, [r3, #12]
300159a8:	e58d3010 	str	r3, [sp, #16]
300159ac:	e59d3010 	ldr	r3, [sp, #16]
300159b0:	e3530000 	cmp	r3, #0
300159b4:	1affffda 	bne	30015924 <netif_set_ipaddr+0xc0>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
300159b8:	e59d3000 	ldr	r3, [sp]
300159bc:	e3530000 	cmp	r3, #0
300159c0:	0a00000b 	beq	300159f4 <netif_set_ipaddr+0x190>
300159c4:	e59d3000 	ldr	r3, [sp]
300159c8:	e5d32000 	ldrb	r2, [r3]
300159cc:	e5d31001 	ldrb	r1, [r3, #1]
300159d0:	e1a01401 	lsl	r1, r1, #8
300159d4:	e1812002 	orr	r2, r1, r2
300159d8:	e5d31002 	ldrb	r1, [r3, #2]
300159dc:	e1a01801 	lsl	r1, r1, #16
300159e0:	e1812002 	orr	r2, r1, r2
300159e4:	e5d33003 	ldrb	r3, [r3, #3]
300159e8:	e1a03c03 	lsl	r3, r3, #24
300159ec:	e1833002 	orr	r3, r3, r2
300159f0:	ea000000 	b	300159f8 <netif_set_ipaddr+0x194>
300159f4:	e3a03000 	mov	r3, #0
300159f8:	e59d2004 	ldr	r2, [sp, #4]
300159fc:	e5823004 	str	r3, [r2, #4]
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
30015a00:	e28dd01c 	add	sp, sp, #28
30015a04:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30015a08:	e12fff1e 	bx	lr
30015a0c:	300eaa38 	.word	0x300eaa38
30015a10:	300eaa78 	.word	0x300eaa78

30015a14 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
30015a14:	e24dd008 	sub	sp, sp, #8
30015a18:	e58d0004 	str	r0, [sp, #4]
30015a1c:	e58d1000 	str	r1, [sp]
  ip_addr_set(&(netif->gw), gw);
30015a20:	e59d3000 	ldr	r3, [sp]
30015a24:	e3530000 	cmp	r3, #0
30015a28:	0a00000b 	beq	30015a5c <netif_set_gw+0x48>
30015a2c:	e59d3000 	ldr	r3, [sp]
30015a30:	e5d32000 	ldrb	r2, [r3]
30015a34:	e5d31001 	ldrb	r1, [r3, #1]
30015a38:	e1a01401 	lsl	r1, r1, #8
30015a3c:	e1812002 	orr	r2, r1, r2
30015a40:	e5d31002 	ldrb	r1, [r3, #2]
30015a44:	e1a01801 	lsl	r1, r1, #16
30015a48:	e1812002 	orr	r2, r1, r2
30015a4c:	e5d33003 	ldrb	r3, [r3, #3]
30015a50:	e1a03c03 	lsl	r3, r3, #24
30015a54:	e1833002 	orr	r3, r3, r2
30015a58:	ea000000 	b	30015a60 <netif_set_gw+0x4c>
30015a5c:	e3a03000 	mov	r3, #0
30015a60:	e59d2004 	ldr	r2, [sp, #4]
30015a64:	e582300c 	str	r3, [r2, #12]
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
30015a68:	e28dd008 	add	sp, sp, #8
30015a6c:	e12fff1e 	bx	lr

30015a70 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
30015a70:	e24dd008 	sub	sp, sp, #8
30015a74:	e58d0004 	str	r0, [sp, #4]
30015a78:	e58d1000 	str	r1, [sp]
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
30015a7c:	e59d3000 	ldr	r3, [sp]
30015a80:	e3530000 	cmp	r3, #0
30015a84:	0a00000b 	beq	30015ab8 <netif_set_netmask+0x48>
30015a88:	e59d3000 	ldr	r3, [sp]
30015a8c:	e5d32000 	ldrb	r2, [r3]
30015a90:	e5d31001 	ldrb	r1, [r3, #1]
30015a94:	e1a01401 	lsl	r1, r1, #8
30015a98:	e1812002 	orr	r2, r1, r2
30015a9c:	e5d31002 	ldrb	r1, [r3, #2]
30015aa0:	e1a01801 	lsl	r1, r1, #16
30015aa4:	e1812002 	orr	r2, r1, r2
30015aa8:	e5d33003 	ldrb	r3, [r3, #3]
30015aac:	e1a03c03 	lsl	r3, r3, #24
30015ab0:	e1833002 	orr	r3, r3, r2
30015ab4:	ea000000 	b	30015abc <netif_set_netmask+0x4c>
30015ab8:	e3a03000 	mov	r3, #0
30015abc:	e59d2004 	ldr	r2, [sp, #4]
30015ac0:	e5823008 	str	r3, [r2, #8]
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
30015ac4:	e28dd008 	add	sp, sp, #8
30015ac8:	e12fff1e 	bx	lr

30015acc <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
30015acc:	e24dd008 	sub	sp, sp, #8
30015ad0:	e58d0004 	str	r0, [sp, #4]
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
30015ad4:	e59f300c 	ldr	r3, [pc, #12]	; 30015ae8 <netif_set_default+0x1c>
30015ad8:	e59d2004 	ldr	r2, [sp, #4]
30015adc:	e5832000 	str	r2, [r3]
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
30015ae0:	e28dd008 	add	sp, sp, #8
30015ae4:	e12fff1e 	bx	lr
30015ae8:	302be6a8 	.word	0x302be6a8

30015aec <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
30015aec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30015af0:	e24dd00c 	sub	sp, sp, #12
30015af4:	e58d0004 	str	r0, [sp, #4]
  if ( !(netif->flags & NETIF_FLAG_UP )) {
30015af8:	e59d3004 	ldr	r3, [sp, #4]
30015afc:	e5d3302a 	ldrb	r3, [r3, #42]	; 0x2a
30015b00:	e2033001 	and	r3, r3, #1
30015b04:	e3530000 	cmp	r3, #0
30015b08:	1a000010 	bne	30015b50 <netif_set_up+0x64>
    netif->flags |= NETIF_FLAG_UP;
30015b0c:	e59d3004 	ldr	r3, [sp, #4]
30015b10:	e5d3302a 	ldrb	r3, [r3, #42]	; 0x2a
30015b14:	e3833001 	orr	r3, r3, #1
30015b18:	e20320ff 	and	r2, r3, #255	; 0xff
30015b1c:	e59d3004 	ldr	r3, [sp, #4]
30015b20:	e5c3202a 	strb	r2, [r3, #42]	; 0x2a
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
30015b24:	e59d3004 	ldr	r3, [sp, #4]
30015b28:	e5d3302a 	ldrb	r3, [r3, #42]	; 0x2a
30015b2c:	e2033020 	and	r3, r3, #32
30015b30:	e3530000 	cmp	r3, #0
30015b34:	0a000005 	beq	30015b50 <netif_set_up+0x64>
      etharp_query(netif, &(netif->ip_addr), NULL);
30015b38:	e59d3004 	ldr	r3, [sp, #4]
30015b3c:	e2833004 	add	r3, r3, #4
30015b40:	e59d0004 	ldr	r0, [sp, #4]
30015b44:	e1a01003 	mov	r1, r3
30015b48:	e3a02000 	mov	r2, #0
30015b4c:	eb00336a 	bl	300228fc <etharp_query>
    }
#endif /* LWIP_ARP */
    
  }
}
30015b50:	e28dd00c 	add	sp, sp, #12
30015b54:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30015b58:	e12fff1e 	bx	lr

30015b5c <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
30015b5c:	e24dd008 	sub	sp, sp, #8
30015b60:	e58d0004 	str	r0, [sp, #4]
  if ( netif->flags & NETIF_FLAG_UP )
30015b64:	e59d3004 	ldr	r3, [sp, #4]
30015b68:	e5d3302a 	ldrb	r3, [r3, #42]	; 0x2a
30015b6c:	e2033001 	and	r3, r3, #1
30015b70:	e20330ff 	and	r3, r3, #255	; 0xff
30015b74:	e3530000 	cmp	r3, #0
30015b78:	0a000004 	beq	30015b90 <netif_set_down+0x34>
    {
      netif->flags &= ~NETIF_FLAG_UP;
30015b7c:	e59d3004 	ldr	r3, [sp, #4]
30015b80:	e5d3302a 	ldrb	r3, [r3, #42]	; 0x2a
30015b84:	e20330fe 	and	r3, r3, #254	; 0xfe
30015b88:	e59d2004 	ldr	r2, [sp, #4]
30015b8c:	e5c2302a 	strb	r3, [r2, #42]	; 0x2a
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
30015b90:	e28dd008 	add	sp, sp, #8
30015b94:	e12fff1e 	bx	lr

30015b98 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
30015b98:	e24dd008 	sub	sp, sp, #8
30015b9c:	e58d0004 	str	r0, [sp, #4]
  return (netif->flags & NETIF_FLAG_UP)?1:0;
30015ba0:	e59d3004 	ldr	r3, [sp, #4]
30015ba4:	e5d3302a 	ldrb	r3, [r3, #42]	; 0x2a
30015ba8:	e2033001 	and	r3, r3, #1
}
30015bac:	e1a00003 	mov	r0, r3
30015bb0:	e28dd008 	add	sp, sp, #8
30015bb4:	e12fff1e 	bx	lr

30015bb8 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
30015bb8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30015bbc:	e24dd024 	sub	sp, sp, #36	; 0x24
30015bc0:	e1a03002 	mov	r3, r2
30015bc4:	e1a02000 	mov	r2, r0
30015bc8:	e5cd2007 	strb	r2, [sp, #7]
30015bcc:	e1cd10b4 	strh	r1, [sp, #4]
30015bd0:	e5cd3003 	strb	r3, [sp, #3]
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));
  
  /* determine header offset */
  offset = 0;
30015bd4:	e3a03000 	mov	r3, #0
30015bd8:	e1cd31ba 	strh	r3, [sp, #26]
  switch (layer) {
30015bdc:	e5dd3007 	ldrb	r3, [sp, #7]
30015be0:	e3530003 	cmp	r3, #3
30015be4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30015be8:	ea00000d 	b	30015c24 <pbuf_alloc+0x6c>
30015bec:	30015bfc 	.word	0x30015bfc
30015bf0:	30015c08 	.word	0x30015c08
30015bf4:	30015c14 	.word	0x30015c14
30015bf8:	30015c2c 	.word	0x30015c2c
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
30015bfc:	e1dd31ba 	ldrh	r3, [sp, #26]
30015c00:	e2833014 	add	r3, r3, #20
30015c04:	e1cd31ba 	strh	r3, [sp, #26]
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
30015c08:	e1dd31ba 	ldrh	r3, [sp, #26]
30015c0c:	e2833014 	add	r3, r3, #20
30015c10:	e1cd31ba 	strh	r3, [sp, #26]
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
30015c14:	e1dd31ba 	ldrh	r3, [sp, #26]
30015c18:	e283300e 	add	r3, r3, #14
30015c1c:	e1cd31ba 	strh	r3, [sp, #26]
    break;
30015c20:	ea000002 	b	30015c30 <pbuf_alloc+0x78>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
30015c24:	e3a03000 	mov	r3, #0
30015c28:	ea0000cd 	b	30015f64 <pbuf_alloc+0x3ac>
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    break;
30015c2c:	e1a00000 	nop			; (mov r0, r0)
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
30015c30:	e5dd3003 	ldrb	r3, [sp, #3]
30015c34:	e3530003 	cmp	r3, #3
30015c38:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30015c3c:	ea0000bf 	b	30015f40 <pbuf_alloc+0x388>
30015c40:	30015e0c 	.word	0x30015e0c
30015c44:	30015ed8 	.word	0x30015ed8
30015c48:	30015ed8 	.word	0x30015ed8
30015c4c:	30015c50 	.word	0x30015c50
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      // test for mem release. by pegasus
    //acoral_debug("\n\rnum_pbuf_alloc: %d\n\r", ++num_pbuf_alloc);

    p = memp_malloc(MEMP_PBUF_POOL);
30015c50:	e3a0000c 	mov	r0, #12
30015c54:	ebfffdb6 	bl	30015334 <memp_malloc>
30015c58:	e1a03000 	mov	r3, r0
30015c5c:	e58d300c 	str	r3, [sp, #12]
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
30015c60:	e59d300c 	ldr	r3, [sp, #12]
30015c64:	e3530000 	cmp	r3, #0
30015c68:	1a000001 	bne	30015c74 <pbuf_alloc+0xbc>
      return NULL;
30015c6c:	e3a03000 	mov	r3, #0
30015c70:	ea0000bb 	b	30015f64 <pbuf_alloc+0x3ac>
    }
    p->type = type;
30015c74:	e59d300c 	ldr	r3, [sp, #12]
30015c78:	e5dd2003 	ldrb	r2, [sp, #3]
30015c7c:	e5c3200c 	strb	r2, [r3, #12]
    p->next = NULL;
30015c80:	e59d300c 	ldr	r3, [sp, #12]
30015c84:	e3a02000 	mov	r2, #0
30015c88:	e5832000 	str	r2, [r3]

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
30015c8c:	e1dd31ba 	ldrh	r3, [sp, #26]
30015c90:	e2832010 	add	r2, r3, #16
30015c94:	e59d300c 	ldr	r3, [sp, #12]
30015c98:	e0823003 	add	r3, r2, r3
30015c9c:	e2833003 	add	r3, r3, #3
30015ca0:	e3c33003 	bic	r3, r3, #3
30015ca4:	e1a02003 	mov	r2, r3
30015ca8:	e59d300c 	ldr	r3, [sp, #12]
30015cac:	e5832004 	str	r2, [r3, #4]
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
30015cb0:	e59d300c 	ldr	r3, [sp, #12]
30015cb4:	e1dd20b4 	ldrh	r2, [sp, #4]
30015cb8:	e1c320b8 	strh	r2, [r3, #8]
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
30015cbc:	e1dd31ba 	ldrh	r3, [sp, #26]
30015cc0:	e2833003 	add	r3, r3, #3
30015cc4:	e3c33003 	bic	r3, r3, #3
30015cc8:	e2633a01 	rsb	r3, r3, #4096	; 0x1000
30015ccc:	e2833038 	add	r3, r3, #56	; 0x38
30015cd0:	e1dd20b4 	ldrh	r2, [sp, #4]
30015cd4:	e1530002 	cmp	r3, r2
30015cd8:	a1a03002 	movge	r3, r2
30015cdc:	e1a03803 	lsl	r3, r3, #16
30015ce0:	e1a02823 	lsr	r2, r3, #16
30015ce4:	e59d300c 	ldr	r3, [sp, #12]
30015ce8:	e1c320ba 	strh	r2, [r3, #10]
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
30015cec:	e59d300c 	ldr	r3, [sp, #12]
30015cf0:	e3a02001 	mov	r2, #1
30015cf4:	e1c320be 	strh	r2, [r3, #14]

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
30015cf8:	e59d300c 	ldr	r3, [sp, #12]
30015cfc:	e58d3014 	str	r3, [sp, #20]
    /* remaining length to be allocated */
    rem_len = length - p->len;
30015d00:	e1dd20b4 	ldrh	r2, [sp, #4]
30015d04:	e59d300c 	ldr	r3, [sp, #12]
30015d08:	e1d330ba 	ldrh	r3, [r3, #10]
30015d0c:	e0633002 	rsb	r3, r3, r2
30015d10:	e58d301c 	str	r3, [sp, #28]
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
30015d14:	ea000038 	b	30015dfc <pbuf_alloc+0x244>
      q = memp_malloc(MEMP_PBUF_POOL);
30015d18:	e3a0000c 	mov	r0, #12
30015d1c:	ebfffd84 	bl	30015334 <memp_malloc>
30015d20:	e1a03000 	mov	r3, r0
30015d24:	e58d3010 	str	r3, [sp, #16]
      if (q == NULL) {
30015d28:	e59d3010 	ldr	r3, [sp, #16]
30015d2c:	e3530000 	cmp	r3, #0
30015d30:	1a000003 	bne	30015d44 <pbuf_alloc+0x18c>
        /* free chain so far allocated */
        pbuf_free(p);
30015d34:	e59d000c 	ldr	r0, [sp, #12]
30015d38:	eb000150 	bl	30016280 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
30015d3c:	e3a03000 	mov	r3, #0
30015d40:	ea000087 	b	30015f64 <pbuf_alloc+0x3ac>
      }
      q->type = type;
30015d44:	e59d3010 	ldr	r3, [sp, #16]
30015d48:	e5dd2003 	ldrb	r2, [sp, #3]
30015d4c:	e5c3200c 	strb	r2, [r3, #12]
      q->flags = 0;
30015d50:	e59d3010 	ldr	r3, [sp, #16]
30015d54:	e3a02000 	mov	r2, #0
30015d58:	e5c3200d 	strb	r2, [r3, #13]
      q->next = NULL;
30015d5c:	e59d3010 	ldr	r3, [sp, #16]
30015d60:	e3a02000 	mov	r2, #0
30015d64:	e5832000 	str	r2, [r3]
      /* make previous pbuf point to this pbuf */
      r->next = q;
30015d68:	e59d3014 	ldr	r3, [sp, #20]
30015d6c:	e59d2010 	ldr	r2, [sp, #16]
30015d70:	e5832000 	str	r2, [r3]
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
30015d74:	e59d301c 	ldr	r3, [sp, #28]
30015d78:	e1a03803 	lsl	r3, r3, #16
30015d7c:	e1a02823 	lsr	r2, r3, #16
30015d80:	e59d3010 	ldr	r3, [sp, #16]
30015d84:	e1c320b8 	strh	r2, [r3, #8]
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
30015d88:	e59d301c 	ldr	r3, [sp, #28]
30015d8c:	e1a03803 	lsl	r3, r3, #16
30015d90:	e1a02823 	lsr	r2, r3, #16
30015d94:	e3a03a01 	mov	r3, #4096	; 0x1000
30015d98:	e2833037 	add	r3, r3, #55	; 0x37
30015d9c:	e1520003 	cmp	r2, r3
30015da0:	8a000003 	bhi	30015db4 <pbuf_alloc+0x1fc>
30015da4:	e59d301c 	ldr	r3, [sp, #28]
30015da8:	e1a03803 	lsl	r3, r3, #16
30015dac:	e1a03823 	lsr	r3, r3, #16
30015db0:	ea000001 	b	30015dbc <pbuf_alloc+0x204>
30015db4:	e3a03a01 	mov	r3, #4096	; 0x1000
30015db8:	e2833038 	add	r3, r3, #56	; 0x38
30015dbc:	e59d2010 	ldr	r2, [sp, #16]
30015dc0:	e1c230ba 	strh	r3, [r2, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
30015dc4:	e59d3010 	ldr	r3, [sp, #16]
30015dc8:	e2832010 	add	r2, r3, #16
30015dcc:	e59d3010 	ldr	r3, [sp, #16]
30015dd0:	e5832004 	str	r2, [r3, #4]
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
30015dd4:	e59d3010 	ldr	r3, [sp, #16]
30015dd8:	e3a02001 	mov	r2, #1
30015ddc:	e1c320be 	strh	r2, [r3, #14]
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
30015de0:	e59d3010 	ldr	r3, [sp, #16]
30015de4:	e1d330ba 	ldrh	r3, [r3, #10]
30015de8:	e59d201c 	ldr	r2, [sp, #28]
30015dec:	e0633002 	rsb	r3, r3, r2
30015df0:	e58d301c 	str	r3, [sp, #28]
      /* remember this pbuf for linkage in next iteration */
      r = q;
30015df4:	e59d3010 	ldr	r3, [sp, #16]
30015df8:	e58d3014 	str	r3, [sp, #20]
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
30015dfc:	e59d301c 	ldr	r3, [sp, #28]
30015e00:	e3530000 	cmp	r3, #0
30015e04:	caffffc3 	bgt	30015d18 <pbuf_alloc+0x160>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
30015e08:	ea00004e 	b	30015f48 <pbuf_alloc+0x390>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
30015e0c:	e1dd31ba 	ldrh	r3, [sp, #26]
30015e10:	e2833013 	add	r3, r3, #19
30015e14:	e1a03803 	lsl	r3, r3, #16
30015e18:	e1a03823 	lsr	r3, r3, #16
30015e1c:	e1a02003 	mov	r2, r3
30015e20:	e3c23003 	bic	r3, r2, #3
30015e24:	e1a03803 	lsl	r3, r3, #16
30015e28:	e1a03823 	lsr	r3, r3, #16
30015e2c:	e1a02003 	mov	r2, r3
30015e30:	e1dd30b4 	ldrh	r3, [sp, #4]
30015e34:	e2833003 	add	r3, r3, #3
30015e38:	e1a03803 	lsl	r3, r3, #16
30015e3c:	e1a03823 	lsr	r3, r3, #16
30015e40:	e3c33003 	bic	r3, r3, #3
30015e44:	e1a03803 	lsl	r3, r3, #16
30015e48:	e1a03823 	lsr	r3, r3, #16
30015e4c:	e0823003 	add	r3, r2, r3
30015e50:	e1a03803 	lsl	r3, r3, #16
30015e54:	e1a03823 	lsr	r3, r3, #16
30015e58:	e1a00003 	mov	r0, r3
30015e5c:	eb002c6c 	bl	30021014 <mem_malloc>
30015e60:	e1a03000 	mov	r3, r0
30015e64:	e58d300c 	str	r3, [sp, #12]
    if (p == NULL) {
30015e68:	e59d300c 	ldr	r3, [sp, #12]
30015e6c:	e3530000 	cmp	r3, #0
30015e70:	1a000001 	bne	30015e7c <pbuf_alloc+0x2c4>
      return NULL;
30015e74:	e3a03000 	mov	r3, #0
30015e78:	ea000039 	b	30015f64 <pbuf_alloc+0x3ac>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
30015e7c:	e1dd31ba 	ldrh	r3, [sp, #26]
30015e80:	e2832010 	add	r2, r3, #16
30015e84:	e59d300c 	ldr	r3, [sp, #12]
30015e88:	e0823003 	add	r3, r2, r3
30015e8c:	e2833003 	add	r3, r3, #3
30015e90:	e3c33003 	bic	r3, r3, #3
30015e94:	e1a02003 	mov	r2, r3
30015e98:	e59d300c 	ldr	r3, [sp, #12]
30015e9c:	e5832004 	str	r2, [r3, #4]
    p->len = p->tot_len = length;
30015ea0:	e59d300c 	ldr	r3, [sp, #12]
30015ea4:	e1dd20b4 	ldrh	r2, [sp, #4]
30015ea8:	e1c320b8 	strh	r2, [r3, #8]
30015eac:	e59d300c 	ldr	r3, [sp, #12]
30015eb0:	e1d320b8 	ldrh	r2, [r3, #8]
30015eb4:	e59d300c 	ldr	r3, [sp, #12]
30015eb8:	e1c320ba 	strh	r2, [r3, #10]
    p->next = NULL;
30015ebc:	e59d300c 	ldr	r3, [sp, #12]
30015ec0:	e3a02000 	mov	r2, #0
30015ec4:	e5832000 	str	r2, [r3]
    p->type = type;
30015ec8:	e59d300c 	ldr	r3, [sp, #12]
30015ecc:	e5dd2003 	ldrb	r2, [sp, #3]
30015ed0:	e5c3200c 	strb	r2, [r3, #12]

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
30015ed4:	ea00001b 	b	30015f48 <pbuf_alloc+0x390>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
30015ed8:	e3a0000b 	mov	r0, #11
30015edc:	ebfffd14 	bl	30015334 <memp_malloc>
30015ee0:	e1a03000 	mov	r3, r0
30015ee4:	e58d300c 	str	r3, [sp, #12]
    if (p == NULL) {
30015ee8:	e59d300c 	ldr	r3, [sp, #12]
30015eec:	e3530000 	cmp	r3, #0
30015ef0:	1a000001 	bne	30015efc <pbuf_alloc+0x344>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
30015ef4:	e3a03000 	mov	r3, #0
30015ef8:	ea000019 	b	30015f64 <pbuf_alloc+0x3ac>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
30015efc:	e59d300c 	ldr	r3, [sp, #12]
30015f00:	e3a02000 	mov	r2, #0
30015f04:	e5832004 	str	r2, [r3, #4]
    p->len = p->tot_len = length;
30015f08:	e59d300c 	ldr	r3, [sp, #12]
30015f0c:	e1dd20b4 	ldrh	r2, [sp, #4]
30015f10:	e1c320b8 	strh	r2, [r3, #8]
30015f14:	e59d300c 	ldr	r3, [sp, #12]
30015f18:	e1d320b8 	ldrh	r2, [r3, #8]
30015f1c:	e59d300c 	ldr	r3, [sp, #12]
30015f20:	e1c320ba 	strh	r2, [r3, #10]
    p->next = NULL;
30015f24:	e59d300c 	ldr	r3, [sp, #12]
30015f28:	e3a02000 	mov	r2, #0
30015f2c:	e5832000 	str	r2, [r3]
    p->type = type;
30015f30:	e59d300c 	ldr	r3, [sp, #12]
30015f34:	e5dd2003 	ldrb	r2, [sp, #3]
30015f38:	e5c3200c 	strb	r2, [r3, #12]
    break;
30015f3c:	ea000001 	b	30015f48 <pbuf_alloc+0x390>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
30015f40:	e3a03000 	mov	r3, #0
30015f44:	ea000006 	b	30015f64 <pbuf_alloc+0x3ac>
  }
  /* set reference count */
  p->ref = 1;
30015f48:	e59d300c 	ldr	r3, [sp, #12]
30015f4c:	e3a02001 	mov	r2, #1
30015f50:	e1c320be 	strh	r2, [r3, #14]
  /* set flags */
  p->flags = 0;
30015f54:	e59d300c 	ldr	r3, [sp, #12]
30015f58:	e3a02000 	mov	r2, #0
30015f5c:	e5c3200d 	strb	r2, [r3, #13]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
30015f60:	e59d300c 	ldr	r3, [sp, #12]
}
30015f64:	e1a00003 	mov	r0, r3
30015f68:	e28dd024 	add	sp, sp, #36	; 0x24
30015f6c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30015f70:	e12fff1e 	bx	lr

30015f74 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
30015f74:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30015f78:	e24dd01c 	sub	sp, sp, #28
30015f7c:	e58d0004 	str	r0, [sp, #4]
30015f80:	e1a03001 	mov	r3, r1
30015f84:	e1cd30b2 	strh	r3, [sp, #2]
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
30015f88:	e59d3004 	ldr	r3, [sp, #4]
30015f8c:	e1d330b8 	ldrh	r3, [r3, #8]
30015f90:	e1dd20b2 	ldrh	r2, [sp, #2]
30015f94:	e1520003 	cmp	r2, r3
30015f98:	2a00004f 	bcs	300160dc <pbuf_realloc+0x168>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
30015f9c:	e1dd20b2 	ldrh	r2, [sp, #2]
30015fa0:	e59d3004 	ldr	r3, [sp, #4]
30015fa4:	e1d330b8 	ldrh	r3, [r3, #8]
30015fa8:	e0633002 	rsb	r3, r3, r2
30015fac:	e58d3014 	str	r3, [sp, #20]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
30015fb0:	e1dd30b2 	ldrh	r3, [sp, #2]
30015fb4:	e1cd31b2 	strh	r3, [sp, #18]
  q = p;
30015fb8:	e59d3004 	ldr	r3, [sp, #4]
30015fbc:	e58d300c 	str	r3, [sp, #12]
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
30015fc0:	ea000011 	b	3001600c <pbuf_realloc+0x98>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
30015fc4:	e59d300c 	ldr	r3, [sp, #12]
30015fc8:	e1d330ba 	ldrh	r3, [r3, #10]
30015fcc:	e1dd21b2 	ldrh	r2, [sp, #18]
30015fd0:	e0633002 	rsb	r3, r3, r2
30015fd4:	e1cd31b2 	strh	r3, [sp, #18]
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    q->tot_len += (u16_t)grow;
30015fd8:	e59d300c 	ldr	r3, [sp, #12]
30015fdc:	e1d320b8 	ldrh	r2, [r3, #8]
30015fe0:	e59d3014 	ldr	r3, [sp, #20]
30015fe4:	e1a03803 	lsl	r3, r3, #16
30015fe8:	e1a03823 	lsr	r3, r3, #16
30015fec:	e0823003 	add	r3, r2, r3
30015ff0:	e1a03803 	lsl	r3, r3, #16
30015ff4:	e1a02823 	lsr	r2, r3, #16
30015ff8:	e59d300c 	ldr	r3, [sp, #12]
30015ffc:	e1c320b8 	strh	r2, [r3, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
30016000:	e59d300c 	ldr	r3, [sp, #12]
30016004:	e5933000 	ldr	r3, [r3]
30016008:	e58d300c 	str	r3, [sp, #12]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
3001600c:	e59d300c 	ldr	r3, [sp, #12]
30016010:	e1d330ba 	ldrh	r3, [r3, #10]
30016014:	e1dd21b2 	ldrh	r2, [sp, #18]
30016018:	e1520003 	cmp	r2, r3
3001601c:	8affffe8 	bhi	30015fc4 <pbuf_realloc+0x50>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
30016020:	e59d300c 	ldr	r3, [sp, #12]
30016024:	e5d3300c 	ldrb	r3, [r3, #12]
30016028:	e3530000 	cmp	r3, #0
3001602c:	1a000017 	bne	30016090 <pbuf_realloc+0x11c>
30016030:	e59d300c 	ldr	r3, [sp, #12]
30016034:	e1d330ba 	ldrh	r3, [r3, #10]
30016038:	e1dd21b2 	ldrh	r2, [sp, #18]
3001603c:	e1520003 	cmp	r2, r3
30016040:	0a000012 	beq	30016090 <pbuf_realloc+0x11c>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
30016044:	e59d300c 	ldr	r3, [sp, #12]
30016048:	e5933004 	ldr	r3, [r3, #4]
3001604c:	e1a03803 	lsl	r3, r3, #16
30016050:	e1a02823 	lsr	r2, r3, #16
30016054:	e59d300c 	ldr	r3, [sp, #12]
30016058:	e1a03803 	lsl	r3, r3, #16
3001605c:	e1a03823 	lsr	r3, r3, #16
30016060:	e0633002 	rsb	r3, r3, r2
30016064:	e1a03803 	lsl	r3, r3, #16
30016068:	e1a02823 	lsr	r2, r3, #16
3001606c:	e1dd31b2 	ldrh	r3, [sp, #18]
30016070:	e0823003 	add	r3, r2, r3
30016074:	e1a03803 	lsl	r3, r3, #16
30016078:	e1a03823 	lsr	r3, r3, #16
3001607c:	e59d000c 	ldr	r0, [sp, #12]
30016080:	e1a01003 	mov	r1, r3
30016084:	eb002b0d 	bl	30020cc0 <mem_realloc>
30016088:	e1a03000 	mov	r3, r0
3001608c:	e58d300c 	str	r3, [sp, #12]
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
30016090:	e59d300c 	ldr	r3, [sp, #12]
30016094:	e1dd21b2 	ldrh	r2, [sp, #18]
30016098:	e1c320ba 	strh	r2, [r3, #10]
  q->tot_len = q->len;
3001609c:	e59d300c 	ldr	r3, [sp, #12]
300160a0:	e1d320ba 	ldrh	r2, [r3, #10]
300160a4:	e59d300c 	ldr	r3, [sp, #12]
300160a8:	e1c320b8 	strh	r2, [r3, #8]

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
300160ac:	e59d300c 	ldr	r3, [sp, #12]
300160b0:	e5933000 	ldr	r3, [r3]
300160b4:	e3530000 	cmp	r3, #0
300160b8:	0a000003 	beq	300160cc <pbuf_realloc+0x158>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
300160bc:	e59d300c 	ldr	r3, [sp, #12]
300160c0:	e5933000 	ldr	r3, [r3]
300160c4:	e1a00003 	mov	r0, r3
300160c8:	eb00006c 	bl	30016280 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
300160cc:	e59d300c 	ldr	r3, [sp, #12]
300160d0:	e3a02000 	mov	r2, #0
300160d4:	e5832000 	str	r2, [r3]
300160d8:	ea000000 	b	300160e0 <pbuf_realloc+0x16c>
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
300160dc:	e1a00000 	nop			; (mov r0, r0)
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
300160e0:	e28dd01c 	add	sp, sp, #28
300160e4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300160e8:	e12fff1e 	bx	lr

300160ec <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
300160ec:	e24dd018 	sub	sp, sp, #24
300160f0:	e58d0004 	str	r0, [sp, #4]
300160f4:	e1a03001 	mov	r3, r1
300160f8:	e1cd30b2 	strh	r3, [sp, #2]
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
300160fc:	e1dd30f2 	ldrsh	r3, [sp, #2]
30016100:	e3530000 	cmp	r3, #0
30016104:	0a000002 	beq	30016114 <pbuf_header+0x28>
30016108:	e59d3004 	ldr	r3, [sp, #4]
3001610c:	e3530000 	cmp	r3, #0
30016110:	1a000001 	bne	3001611c <pbuf_header+0x30>
    return 0;
30016114:	e3a03000 	mov	r3, #0
30016118:	ea000055 	b	30016274 <pbuf_header+0x188>
 
  if (header_size_increment < 0){
3001611c:	e1dd30f2 	ldrsh	r3, [sp, #2]
30016120:	e3530000 	cmp	r3, #0
30016124:	aa000005 	bge	30016140 <pbuf_header+0x54>
    increment_magnitude = -header_size_increment;
30016128:	e1dd30b2 	ldrh	r3, [sp, #2]
3001612c:	e2633000 	rsb	r3, r3, #0
30016130:	e1a03803 	lsl	r3, r3, #16
30016134:	e1a03823 	lsr	r3, r3, #16
30016138:	e1cd31b6 	strh	r3, [sp, #22]
3001613c:	ea000001 	b	30016148 <pbuf_header+0x5c>
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
30016140:	e1dd30b2 	ldrh	r3, [sp, #2]
30016144:	e1cd31b6 	strh	r3, [sp, #22]
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
30016148:	e59d3004 	ldr	r3, [sp, #4]
3001614c:	e5d3300c 	ldrb	r3, [r3, #12]
30016150:	e1cd30be 	strh	r3, [sp, #14]
  /* remember current payload pointer */
  payload = p->payload;
30016154:	e59d3004 	ldr	r3, [sp, #4]
30016158:	e5933004 	ldr	r3, [r3, #4]
3001615c:	e58d3010 	str	r3, [sp, #16]

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
30016160:	e1dd30be 	ldrh	r3, [sp, #14]
30016164:	e3530000 	cmp	r3, #0
30016168:	0a000002 	beq	30016178 <pbuf_header+0x8c>
3001616c:	e1dd30be 	ldrh	r3, [sp, #14]
30016170:	e3530003 	cmp	r3, #3
30016174:	1a000012 	bne	300161c4 <pbuf_header+0xd8>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
30016178:	e59d3004 	ldr	r3, [sp, #4]
3001617c:	e5932004 	ldr	r2, [r3, #4]
30016180:	e1dd30f2 	ldrsh	r3, [sp, #2]
30016184:	e2633000 	rsb	r3, r3, #0
30016188:	e0822003 	add	r2, r2, r3
3001618c:	e59d3004 	ldr	r3, [sp, #4]
30016190:	e5832004 	str	r2, [r3, #4]
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
30016194:	e59d3004 	ldr	r3, [sp, #4]
30016198:	e5933004 	ldr	r3, [r3, #4]
3001619c:	e1a02003 	mov	r2, r3
300161a0:	e59d3004 	ldr	r3, [sp, #4]
300161a4:	e2833010 	add	r3, r3, #16
300161a8:	e1520003 	cmp	r2, r3
300161ac:	2a00001e 	bcs	3001622c <pbuf_header+0x140>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
300161b0:	e59d3004 	ldr	r3, [sp, #4]
300161b4:	e59d2010 	ldr	r2, [sp, #16]
300161b8:	e5832004 	str	r2, [r3, #4]
      /* bail out unsuccesfully */
      return 1;
300161bc:	e3a03001 	mov	r3, #1
300161c0:	ea00002b 	b	30016274 <pbuf_header+0x188>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
300161c4:	e1dd30be 	ldrh	r3, [sp, #14]
300161c8:	e3530002 	cmp	r3, #2
300161cc:	0a000002 	beq	300161dc <pbuf_header+0xf0>
300161d0:	e1dd30be 	ldrh	r3, [sp, #14]
300161d4:	e3530001 	cmp	r3, #1
300161d8:	1a000011 	bne	30016224 <pbuf_header+0x138>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
300161dc:	e1dd30f2 	ldrsh	r3, [sp, #2]
300161e0:	e3530000 	cmp	r3, #0
300161e4:	aa00000c 	bge	3001621c <pbuf_header+0x130>
300161e8:	e59d3004 	ldr	r3, [sp, #4]
300161ec:	e1d330ba 	ldrh	r3, [r3, #10]
300161f0:	e1dd21b6 	ldrh	r2, [sp, #22]
300161f4:	e1520003 	cmp	r2, r3
300161f8:	8a000007 	bhi	3001621c <pbuf_header+0x130>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
300161fc:	e59d3004 	ldr	r3, [sp, #4]
30016200:	e5932004 	ldr	r2, [r3, #4]
30016204:	e1dd30f2 	ldrsh	r3, [sp, #2]
30016208:	e2633000 	rsb	r3, r3, #0
3001620c:	e0822003 	add	r2, r2, r3
30016210:	e59d3004 	ldr	r3, [sp, #4]
30016214:	e5832004 	str	r2, [r3, #4]
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
30016218:	ea000004 	b	30016230 <pbuf_header+0x144>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
3001621c:	e3a03001 	mov	r3, #1
30016220:	ea000013 	b	30016274 <pbuf_header+0x188>
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
30016224:	e3a03001 	mov	r3, #1
30016228:	ea000011 	b	30016274 <pbuf_header+0x188>
  type = p->type;
  /* remember current payload pointer */
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
3001622c:	e1a00000 	nop			; (mov r0, r0)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
30016230:	e59d3004 	ldr	r3, [sp, #4]
30016234:	e1d320ba 	ldrh	r2, [r3, #10]
30016238:	e1dd30b2 	ldrh	r3, [sp, #2]
3001623c:	e0823003 	add	r3, r2, r3
30016240:	e1a03803 	lsl	r3, r3, #16
30016244:	e1a02823 	lsr	r2, r3, #16
30016248:	e59d3004 	ldr	r3, [sp, #4]
3001624c:	e1c320ba 	strh	r2, [r3, #10]
  p->tot_len += header_size_increment;
30016250:	e59d3004 	ldr	r3, [sp, #4]
30016254:	e1d320b8 	ldrh	r2, [r3, #8]
30016258:	e1dd30b2 	ldrh	r3, [sp, #2]
3001625c:	e0823003 	add	r3, r2, r3
30016260:	e1a03803 	lsl	r3, r3, #16
30016264:	e1a02823 	lsr	r2, r3, #16
30016268:	e59d3004 	ldr	r3, [sp, #4]
3001626c:	e1c320b8 	strh	r2, [r3, #8]

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
30016270:	e3a03000 	mov	r3, #0
}
30016274:	e1a00003 	mov	r0, r3
30016278:	e28dd018 	add	sp, sp, #24
3001627c:	e12fff1e 	bx	lr

30016280 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
30016280:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30016284:	e24dd01c 	sub	sp, sp, #28
30016288:	e58d0004 	str	r0, [sp, #4]
  struct pbuf *q;
  u8_t count;
  static int num_pbuf_realse = 0;  // test for mem release. by pegasus
  

  if (p == NULL) {
3001628c:	e59d3004 	ldr	r3, [sp, #4]
30016290:	e3530000 	cmp	r3, #0
30016294:	1a000001 	bne	300162a0 <pbuf_free+0x20>
    LWIP_ASSERT("p != NULL", p != NULL);
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_free(p == NULL) was called.\n"));
    return 0;
30016298:	e3a03000 	mov	r3, #0
3001629c:	ea000039 	b	30016388 <pbuf_free+0x108>

  LWIP_ASSERT("pbuf_free: sane type",
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
300162a0:	e3a03000 	mov	r3, #0
300162a4:	e5cd3011 	strb	r3, [sp, #17]
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
300162a8:	ea000032 	b	30016378 <pbuf_free+0xf8>
    u16_t ref;
    SYS_ARCH_DECL_PROTECT(old_level);
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
300162ac:	ebffad10 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300162b0:	e1a03000 	mov	r3, r0
300162b4:	e58d3014 	str	r3, [sp, #20]
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
300162b8:	e59d3004 	ldr	r3, [sp, #4]
300162bc:	e1d330be 	ldrh	r3, [r3, #14]
300162c0:	e2433001 	sub	r3, r3, #1
300162c4:	e1a03803 	lsl	r3, r3, #16
300162c8:	e1a02823 	lsr	r2, r3, #16
300162cc:	e59d3004 	ldr	r3, [sp, #4]
300162d0:	e1c320be 	strh	r2, [r3, #14]
300162d4:	e59d3004 	ldr	r3, [sp, #4]
300162d8:	e1d330be 	ldrh	r3, [r3, #14]
300162dc:	e1cd31b2 	strh	r3, [sp, #18]
    SYS_ARCH_UNPROTECT(old_level);
300162e0:	e59d0014 	ldr	r0, [sp, #20]
300162e4:	ebffad00 	bl	300016ec <HAL_INTR_RESTORE>
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
300162e8:	e1dd31b2 	ldrh	r3, [sp, #18]
300162ec:	e3530000 	cmp	r3, #0
300162f0:	1a00001e 	bne	30016370 <pbuf_free+0xf0>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
300162f4:	e59d3004 	ldr	r3, [sp, #4]
300162f8:	e5933000 	ldr	r3, [r3]
300162fc:	e58d300c 	str	r3, [sp, #12]
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
30016300:	e59d3004 	ldr	r3, [sp, #4]
30016304:	e5d3300c 	ldrb	r3, [r3, #12]
30016308:	e1cd30ba 	strh	r3, [sp, #10]
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
3001630c:	e1dd30ba 	ldrh	r3, [sp, #10]
30016310:	e3530003 	cmp	r3, #3
30016314:	1a000003 	bne	30016328 <pbuf_free+0xa8>
        // test for mem release. by pegasus
		//acoral_debug("\n\rnum_pbuf_realse: %d\n\r", ++num_pbuf_realse);
        memp_free(MEMP_PBUF_POOL, p);
30016318:	e3a0000c 	mov	r0, #12
3001631c:	e59d1004 	ldr	r1, [sp, #4]
30016320:	ebfffc68 	bl	300154c8 <memp_free>
30016324:	ea00000b 	b	30016358 <pbuf_free+0xd8>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
30016328:	e1dd30ba 	ldrh	r3, [sp, #10]
3001632c:	e3530001 	cmp	r3, #1
30016330:	0a000002 	beq	30016340 <pbuf_free+0xc0>
30016334:	e1dd30ba 	ldrh	r3, [sp, #10]
30016338:	e3530002 	cmp	r3, #2
3001633c:	1a000003 	bne	30016350 <pbuf_free+0xd0>
        memp_free(MEMP_PBUF, p);
30016340:	e3a0000b 	mov	r0, #11
30016344:	e59d1004 	ldr	r1, [sp, #4]
30016348:	ebfffc5e 	bl	300154c8 <memp_free>
      if (type == PBUF_POOL) {
        // test for mem release. by pegasus
		//acoral_debug("\n\rnum_pbuf_realse: %d\n\r", ++num_pbuf_realse);
        memp_free(MEMP_PBUF_POOL, p);
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
3001634c:	ea000001 	b	30016358 <pbuf_free+0xd8>
        memp_free(MEMP_PBUF, p);
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
30016350:	e59d0004 	ldr	r0, [sp, #4]
30016354:	eb002a04 	bl	30020b6c <mem_free>

      }
      count++;
30016358:	e5dd3011 	ldrb	r3, [sp, #17]
3001635c:	e2833001 	add	r3, r3, #1
30016360:	e5cd3011 	strb	r3, [sp, #17]
      /* proceed to next pbuf */
      p = q;
30016364:	e59d300c 	ldr	r3, [sp, #12]
30016368:	e58d3004 	str	r3, [sp, #4]
3001636c:	ea000001 	b	30016378 <pbuf_free+0xf8>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
30016370:	e3a03000 	mov	r3, #0
30016374:	e58d3004 	str	r3, [sp, #4]
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
30016378:	e59d3004 	ldr	r3, [sp, #4]
3001637c:	e3530000 	cmp	r3, #0
30016380:	1affffc9 	bne	300162ac <pbuf_free+0x2c>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
30016384:	e5dd3011 	ldrb	r3, [sp, #17]
}
30016388:	e1a00003 	mov	r0, r3
3001638c:	e28dd01c 	add	sp, sp, #28
30016390:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016394:	e12fff1e 	bx	lr

30016398 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
30016398:	e24dd010 	sub	sp, sp, #16
3001639c:	e58d0004 	str	r0, [sp, #4]
  u8_t len;

  len = 0;
300163a0:	e3a03000 	mov	r3, #0
300163a4:	e5cd300f 	strb	r3, [sp, #15]
  while (p != NULL) {
300163a8:	ea000005 	b	300163c4 <pbuf_clen+0x2c>
    ++len;
300163ac:	e5dd300f 	ldrb	r3, [sp, #15]
300163b0:	e2833001 	add	r3, r3, #1
300163b4:	e5cd300f 	strb	r3, [sp, #15]
    p = p->next;
300163b8:	e59d3004 	ldr	r3, [sp, #4]
300163bc:	e5933000 	ldr	r3, [r3]
300163c0:	e58d3004 	str	r3, [sp, #4]
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
300163c4:	e59d3004 	ldr	r3, [sp, #4]
300163c8:	e3530000 	cmp	r3, #0
300163cc:	1afffff6 	bne	300163ac <pbuf_clen+0x14>
    ++len;
    p = p->next;
  }
  return len;
300163d0:	e5dd300f 	ldrb	r3, [sp, #15]
}
300163d4:	e1a00003 	mov	r0, r3
300163d8:	e28dd010 	add	sp, sp, #16
300163dc:	e12fff1e 	bx	lr

300163e0 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
300163e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300163e4:	e24dd014 	sub	sp, sp, #20
300163e8:	e58d0004 	str	r0, [sp, #4]
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
300163ec:	e59d3004 	ldr	r3, [sp, #4]
300163f0:	e3530000 	cmp	r3, #0
300163f4:	0a00000b 	beq	30016428 <pbuf_ref+0x48>
    SYS_ARCH_PROTECT(old_level);
300163f8:	ebffacbd 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300163fc:	e1a03000 	mov	r3, r0
30016400:	e58d300c 	str	r3, [sp, #12]
    ++(p->ref);
30016404:	e59d3004 	ldr	r3, [sp, #4]
30016408:	e1d330be 	ldrh	r3, [r3, #14]
3001640c:	e2833001 	add	r3, r3, #1
30016410:	e1a03803 	lsl	r3, r3, #16
30016414:	e1a02823 	lsr	r2, r3, #16
30016418:	e59d3004 	ldr	r3, [sp, #4]
3001641c:	e1c320be 	strh	r2, [r3, #14]
    SYS_ARCH_UNPROTECT(old_level);
30016420:	e59d000c 	ldr	r0, [sp, #12]
30016424:	ebffacb0 	bl	300016ec <HAL_INTR_RESTORE>
  }
}
30016428:	e28dd014 	add	sp, sp, #20
3001642c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016430:	e12fff1e 	bx	lr

30016434 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
30016434:	e24dd010 	sub	sp, sp, #16
30016438:	e58d0004 	str	r0, [sp, #4]
3001643c:	e58d1000 	str	r1, [sp]

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
30016440:	e59d3004 	ldr	r3, [sp, #4]
30016444:	e58d300c 	str	r3, [sp, #12]
30016448:	ea00000b 	b	3001647c <pbuf_cat+0x48>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
3001644c:	e59d300c 	ldr	r3, [sp, #12]
30016450:	e1d320b8 	ldrh	r2, [r3, #8]
30016454:	e59d3000 	ldr	r3, [sp]
30016458:	e1d330b8 	ldrh	r3, [r3, #8]
3001645c:	e0823003 	add	r3, r2, r3
30016460:	e1a03803 	lsl	r3, r3, #16
30016464:	e1a02823 	lsr	r2, r3, #16
30016468:	e59d300c 	ldr	r3, [sp, #12]
3001646c:	e1c320b8 	strh	r2, [r3, #8]

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
30016470:	e59d300c 	ldr	r3, [sp, #12]
30016474:	e5933000 	ldr	r3, [r3]
30016478:	e58d300c 	str	r3, [sp, #12]
3001647c:	e59d300c 	ldr	r3, [sp, #12]
30016480:	e5933000 	ldr	r3, [r3]
30016484:	e3530000 	cmp	r3, #0
30016488:	1affffef 	bne	3001644c <pbuf_cat+0x18>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
3001648c:	e59d300c 	ldr	r3, [sp, #12]
30016490:	e1d320b8 	ldrh	r2, [r3, #8]
30016494:	e59d3000 	ldr	r3, [sp]
30016498:	e1d330b8 	ldrh	r3, [r3, #8]
3001649c:	e0823003 	add	r3, r2, r3
300164a0:	e1a03803 	lsl	r3, r3, #16
300164a4:	e1a02823 	lsr	r2, r3, #16
300164a8:	e59d300c 	ldr	r3, [sp, #12]
300164ac:	e1c320b8 	strh	r2, [r3, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
300164b0:	e59d300c 	ldr	r3, [sp, #12]
300164b4:	e59d2000 	ldr	r2, [sp]
300164b8:	e5832000 	str	r2, [r3]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
300164bc:	e28dd010 	add	sp, sp, #16
300164c0:	e12fff1e 	bx	lr

300164c4 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
300164c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300164c8:	e24dd00c 	sub	sp, sp, #12
300164cc:	e58d0004 	str	r0, [sp, #4]
300164d0:	e58d1000 	str	r1, [sp]
  pbuf_cat(h, t);
300164d4:	e59d0004 	ldr	r0, [sp, #4]
300164d8:	e59d1000 	ldr	r1, [sp]
300164dc:	ebffffd4 	bl	30016434 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
300164e0:	e59d0000 	ldr	r0, [sp]
300164e4:	ebffffbd 	bl	300163e0 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
300164e8:	e28dd00c 	add	sp, sp, #12
300164ec:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300164f0:	e12fff1e 	bx	lr

300164f4 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
300164f4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300164f8:	e24dd014 	sub	sp, sp, #20
300164fc:	e58d0004 	str	r0, [sp, #4]
  struct pbuf *q;
  u8_t tail_gone = 1;
30016500:	e3a03001 	mov	r3, #1
30016504:	e5cd300f 	strb	r3, [sp, #15]
  /* tail */
  q = p->next;
30016508:	e59d3004 	ldr	r3, [sp, #4]
3001650c:	e5933000 	ldr	r3, [r3]
30016510:	e58d3008 	str	r3, [sp, #8]
  /* pbuf has successor in chain? */
  if (q != NULL) {
30016514:	e59d3008 	ldr	r3, [sp, #8]
30016518:	e3530000 	cmp	r3, #0
3001651c:	0a000013 	beq	30016570 <pbuf_dechain+0x7c>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
30016520:	e59d3004 	ldr	r3, [sp, #4]
30016524:	e1d320b8 	ldrh	r2, [r3, #8]
30016528:	e59d3004 	ldr	r3, [sp, #4]
3001652c:	e1d330ba 	ldrh	r3, [r3, #10]
30016530:	e0633002 	rsb	r3, r3, r2
30016534:	e1a03803 	lsl	r3, r3, #16
30016538:	e1a02823 	lsr	r2, r3, #16
3001653c:	e59d3008 	ldr	r3, [sp, #8]
30016540:	e1c320b8 	strh	r2, [r3, #8]
    /* decouple pbuf from remainder */
    p->next = NULL;
30016544:	e59d3004 	ldr	r3, [sp, #4]
30016548:	e3a02000 	mov	r2, #0
3001654c:	e5832000 	str	r2, [r3]
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
30016550:	e59d3004 	ldr	r3, [sp, #4]
30016554:	e1d320ba 	ldrh	r2, [r3, #10]
30016558:	e59d3004 	ldr	r3, [sp, #4]
3001655c:	e1c320b8 	strh	r2, [r3, #8]
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
30016560:	e59d0008 	ldr	r0, [sp, #8]
30016564:	ebffff45 	bl	30016280 <pbuf_free>
30016568:	e1a03000 	mov	r3, r0
3001656c:	e5cd300f 	strb	r3, [sp, #15]
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  return ((tail_gone > 0) ? NULL : q);
30016570:	e5dd300f 	ldrb	r3, [sp, #15]
30016574:	e3530000 	cmp	r3, #0
30016578:	1a000001 	bne	30016584 <pbuf_dechain+0x90>
3001657c:	e59d3008 	ldr	r3, [sp, #8]
30016580:	ea000000 	b	30016588 <pbuf_dechain+0x94>
30016584:	e3a03000 	mov	r3, #0
}
30016588:	e1a00003 	mov	r0, r3
3001658c:	e28dd014 	add	sp, sp, #20
30016590:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016594:	e12fff1e 	bx	lr

30016598 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
30016598:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001659c:	e24dd014 	sub	sp, sp, #20
300165a0:	e58d0004 	str	r0, [sp, #4]
300165a4:	e58d1000 	str	r1, [sp]
  u16_t offset_to=0, offset_from=0, len;
300165a8:	e3a03000 	mov	r3, #0
300165ac:	e1cd30ba 	strh	r3, [sp, #10]
300165b0:	e3a03000 	mov	r3, #0
300165b4:	e1cd30bc 	strh	r3, [sp, #12]
  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
300165b8:	e59d3004 	ldr	r3, [sp, #4]
300165bc:	e1d330ba 	ldrh	r3, [r3, #10]
300165c0:	e1a02003 	mov	r2, r3
300165c4:	e1dd30ba 	ldrh	r3, [sp, #10]
300165c8:	e0632002 	rsb	r2, r3, r2
300165cc:	e59d3000 	ldr	r3, [sp]
300165d0:	e1d330ba 	ldrh	r3, [r3, #10]
300165d4:	e1a01003 	mov	r1, r3
300165d8:	e1dd30bc 	ldrh	r3, [sp, #12]
300165dc:	e0633001 	rsb	r3, r3, r1
300165e0:	e1520003 	cmp	r2, r3
300165e4:	ba000005 	blt	30016600 <pbuf_copy+0x68>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
300165e8:	e59d3000 	ldr	r3, [sp]
300165ec:	e1d320ba 	ldrh	r2, [r3, #10]
300165f0:	e1dd30bc 	ldrh	r3, [sp, #12]
300165f4:	e0633002 	rsb	r3, r3, r2
300165f8:	e1cd30be 	strh	r3, [sp, #14]
300165fc:	ea000004 	b	30016614 <pbuf_copy+0x7c>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
30016600:	e59d3004 	ldr	r3, [sp, #4]
30016604:	e1d320ba 	ldrh	r2, [r3, #10]
30016608:	e1dd30ba 	ldrh	r3, [sp, #10]
3001660c:	e0633002 	rsb	r3, r3, r2
30016610:	e1cd30be 	strh	r3, [sp, #14]
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
30016614:	e59d3004 	ldr	r3, [sp, #4]
30016618:	e5932004 	ldr	r2, [r3, #4]
3001661c:	e1dd30ba 	ldrh	r3, [sp, #10]
30016620:	e0821003 	add	r1, r2, r3
30016624:	e59d3000 	ldr	r3, [sp]
30016628:	e5932004 	ldr	r2, [r3, #4]
3001662c:	e1dd30bc 	ldrh	r3, [sp, #12]
30016630:	e0822003 	add	r2, r2, r3
30016634:	e1dd30be 	ldrh	r3, [sp, #14]
30016638:	e1a00001 	mov	r0, r1
3001663c:	e1a01002 	mov	r1, r2
30016640:	e1a02003 	mov	r2, r3
30016644:	ebffd724 	bl	3000c2dc <acoral_memcpy>
    offset_to += len;
30016648:	e1dd20ba 	ldrh	r2, [sp, #10]
3001664c:	e1dd30be 	ldrh	r3, [sp, #14]
30016650:	e0823003 	add	r3, r2, r3
30016654:	e1cd30ba 	strh	r3, [sp, #10]
    offset_from += len;
30016658:	e1dd20bc 	ldrh	r2, [sp, #12]
3001665c:	e1dd30be 	ldrh	r3, [sp, #14]
30016660:	e0823003 	add	r3, r2, r3
30016664:	e1cd30bc 	strh	r3, [sp, #12]
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
30016668:	e59d3004 	ldr	r3, [sp, #4]
3001666c:	e1d330ba 	ldrh	r3, [r3, #10]
30016670:	e1dd20ba 	ldrh	r2, [sp, #10]
30016674:	e1520003 	cmp	r2, r3
30016678:	1a000004 	bne	30016690 <pbuf_copy+0xf8>
      /* on to next p_to (if any) */
      offset_to = 0;
3001667c:	e3a03000 	mov	r3, #0
30016680:	e1cd30ba 	strh	r3, [sp, #10]
      p_to = p_to->next;
30016684:	e59d3004 	ldr	r3, [sp, #4]
30016688:	e5933000 	ldr	r3, [r3]
3001668c:	e58d3004 	str	r3, [sp, #4]
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
30016690:	e59d3000 	ldr	r3, [sp]
30016694:	e1d330ba 	ldrh	r3, [r3, #10]
30016698:	e1dd20bc 	ldrh	r2, [sp, #12]
3001669c:	e1520003 	cmp	r2, r3
300166a0:	3a000004 	bcc	300166b8 <pbuf_copy+0x120>
      /* on to next p_from (if any) */
      offset_from = 0;
300166a4:	e3a03000 	mov	r3, #0
300166a8:	e1cd30bc 	strh	r3, [sp, #12]
      p_from = p_from->next;
300166ac:	e59d3000 	ldr	r3, [sp]
300166b0:	e5933000 	ldr	r3, [r3]
300166b4:	e58d3000 	str	r3, [sp]
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
300166b8:	e59d3000 	ldr	r3, [sp]
300166bc:	e3530000 	cmp	r3, #0
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
300166c0:	e59d3004 	ldr	r3, [sp, #4]
300166c4:	e3530000 	cmp	r3, #0
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
300166c8:	e59d3000 	ldr	r3, [sp]
300166cc:	e3530000 	cmp	r3, #0
300166d0:	1affffb8 	bne	300165b8 <pbuf_copy+0x20>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
300166d4:	e3a03000 	mov	r3, #0
300166d8:	e1a03c03 	lsl	r3, r3, #24
300166dc:	e1a03c43 	asr	r3, r3, #24
}
300166e0:	e1a00003 	mov	r0, r3
300166e4:	e28dd014 	add	sp, sp, #20
300166e8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300166ec:	e12fff1e 	bx	lr

300166f0 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
300166f0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300166f4:	e24dd024 	sub	sp, sp, #36	; 0x24
300166f8:	e58d000c 	str	r0, [sp, #12]
300166fc:	e58d1008 	str	r1, [sp, #8]
30016700:	e1cd20b6 	strh	r2, [sp, #6]
30016704:	e1cd30b4 	strh	r3, [sp, #4]
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
30016708:	e3a03000 	mov	r3, #0
3001670c:	e1cd31be 	strh	r3, [sp, #30]

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);

  left = 0;
30016710:	e3a03000 	mov	r3, #0
30016714:	e1cd31ba 	strh	r3, [sp, #26]

  if((buf == NULL) || (dataptr == NULL)) {
30016718:	e59d300c 	ldr	r3, [sp, #12]
3001671c:	e3530000 	cmp	r3, #0
30016720:	0a000002 	beq	30016730 <pbuf_copy_partial+0x40>
30016724:	e59d3008 	ldr	r3, [sp, #8]
30016728:	e3530000 	cmp	r3, #0
3001672c:	1a000001 	bne	30016738 <pbuf_copy_partial+0x48>
    return 0;
30016730:	e3a03000 	mov	r3, #0
30016734:	ea00003f 	b	30016838 <pbuf_copy_partial+0x148>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
30016738:	e59d300c 	ldr	r3, [sp, #12]
3001673c:	e58d3014 	str	r3, [sp, #20]
30016740:	ea000035 	b	3001681c <pbuf_copy_partial+0x12c>
    if ((offset != 0) && (offset >= p->len)) {
30016744:	e1dd30b4 	ldrh	r3, [sp, #4]
30016748:	e3530000 	cmp	r3, #0
3001674c:	0a00000a 	beq	3001677c <pbuf_copy_partial+0x8c>
30016750:	e59d3014 	ldr	r3, [sp, #20]
30016754:	e1d330ba 	ldrh	r3, [r3, #10]
30016758:	e1dd20b4 	ldrh	r2, [sp, #4]
3001675c:	e1520003 	cmp	r2, r3
30016760:	3a000005 	bcc	3001677c <pbuf_copy_partial+0x8c>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
30016764:	e59d3014 	ldr	r3, [sp, #20]
30016768:	e1d330ba 	ldrh	r3, [r3, #10]
3001676c:	e1dd20b4 	ldrh	r2, [sp, #4]
30016770:	e0633002 	rsb	r3, r3, r2
30016774:	e1cd30b4 	strh	r3, [sp, #4]
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
30016778:	ea000024 	b	30016810 <pbuf_copy_partial+0x120>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
3001677c:	e59d3014 	ldr	r3, [sp, #20]
30016780:	e1d320ba 	ldrh	r2, [r3, #10]
30016784:	e1dd30b4 	ldrh	r3, [sp, #4]
30016788:	e0633002 	rsb	r3, r3, r2
3001678c:	e1cd31bc 	strh	r3, [sp, #28]
      if (buf_copy_len > len)
30016790:	e1dd21bc 	ldrh	r2, [sp, #28]
30016794:	e1dd30b6 	ldrh	r3, [sp, #6]
30016798:	e1520003 	cmp	r2, r3
3001679c:	9a000001 	bls	300167a8 <pbuf_copy_partial+0xb8>
          buf_copy_len = len;
300167a0:	e1dd30b6 	ldrh	r3, [sp, #6]
300167a4:	e1cd31bc 	strh	r3, [sp, #28]
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
300167a8:	e1dd21ba 	ldrh	r2, [sp, #26]
300167ac:	e59d3008 	ldr	r3, [sp, #8]
300167b0:	e0821003 	add	r1, r2, r3
300167b4:	e59d3014 	ldr	r3, [sp, #20]
300167b8:	e5932004 	ldr	r2, [r3, #4]
300167bc:	e1dd30b4 	ldrh	r3, [sp, #4]
300167c0:	e0822003 	add	r2, r2, r3
300167c4:	e1dd31bc 	ldrh	r3, [sp, #28]
300167c8:	e1a00001 	mov	r0, r1
300167cc:	e1a01002 	mov	r1, r2
300167d0:	e1a02003 	mov	r2, r3
300167d4:	ebffd6c0 	bl	3000c2dc <acoral_memcpy>
      copied_total += buf_copy_len;
300167d8:	e1dd21be 	ldrh	r2, [sp, #30]
300167dc:	e1dd31bc 	ldrh	r3, [sp, #28]
300167e0:	e0823003 	add	r3, r2, r3
300167e4:	e1cd31be 	strh	r3, [sp, #30]
      left += buf_copy_len;
300167e8:	e1dd21ba 	ldrh	r2, [sp, #26]
300167ec:	e1dd31bc 	ldrh	r3, [sp, #28]
300167f0:	e0823003 	add	r3, r2, r3
300167f4:	e1cd31ba 	strh	r3, [sp, #26]
      len -= buf_copy_len;
300167f8:	e1dd20b6 	ldrh	r2, [sp, #6]
300167fc:	e1dd31bc 	ldrh	r3, [sp, #28]
30016800:	e0633002 	rsb	r3, r3, r2
30016804:	e1cd30b6 	strh	r3, [sp, #6]
      offset = 0;
30016808:	e3a03000 	mov	r3, #0
3001680c:	e1cd30b4 	strh	r3, [sp, #4]
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
30016810:	e59d3014 	ldr	r3, [sp, #20]
30016814:	e5933000 	ldr	r3, [r3]
30016818:	e58d3014 	str	r3, [sp, #20]
3001681c:	e1dd30b6 	ldrh	r3, [sp, #6]
30016820:	e3530000 	cmp	r3, #0
30016824:	0a000002 	beq	30016834 <pbuf_copy_partial+0x144>
30016828:	e59d3014 	ldr	r3, [sp, #20]
3001682c:	e3530000 	cmp	r3, #0
30016830:	1affffc3 	bne	30016744 <pbuf_copy_partial+0x54>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
30016834:	e1dd31be 	ldrh	r3, [sp, #30]
}
30016838:	e1a00003 	mov	r0, r3
3001683c:	e28dd024 	add	sp, sp, #36	; 0x24
30016840:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016844:	e12fff1e 	bx	lr

30016848 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
30016848:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001684c:	e24dd01c 	sub	sp, sp, #28
30016850:	e58d0004 	str	r0, [sp, #4]
30016854:	e58d1000 	str	r1, [sp]
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
30016858:	e3a03000 	mov	r3, #0
3001685c:	e5cd3017 	strb	r3, [sp, #23]

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
30016860:	e59d3004 	ldr	r3, [sp, #4]
30016864:	e5933004 	ldr	r3, [r3, #4]
30016868:	e58d3010 	str	r3, [sp, #16]
  proto = IPH_PROTO(iphdr);
3001686c:	e59d3010 	ldr	r3, [sp, #16]
30016870:	e5d32008 	ldrb	r2, [r3, #8]
30016874:	e5d33009 	ldrb	r3, [r3, #9]
30016878:	e1a03403 	lsl	r3, r3, #8
3001687c:	e1833002 	orr	r3, r3, r2
30016880:	e1a03803 	lsl	r3, r3, #16
30016884:	e1a03823 	lsr	r3, r3, #16
30016888:	e1a00003 	mov	r0, r3
3001688c:	ebfff36e 	bl	3001364c <ntohs>
30016890:	e1a03000 	mov	r3, r0
30016894:	e20330ff 	and	r3, r3, #255	; 0xff
30016898:	e1cd31b4 	strh	r3, [sp, #20]

  prev = NULL;
3001689c:	e3a03000 	mov	r3, #0
300168a0:	e58d300c 	str	r3, [sp, #12]
  pcb = raw_pcbs;
300168a4:	e59f30f0 	ldr	r3, [pc, #240]	; 3001699c <raw_input+0x154>
300168a8:	e5933000 	ldr	r3, [r3]
300168ac:	e58d3008 	str	r3, [sp, #8]
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
300168b0:	ea00002e 	b	30016970 <raw_input+0x128>
    if (pcb->protocol == proto) {
300168b4:	e59d3008 	ldr	r3, [sp, #8]
300168b8:	e5d33010 	ldrb	r3, [r3, #16]
300168bc:	e1a02003 	mov	r2, r3
300168c0:	e1dd31f4 	ldrsh	r3, [sp, #20]
300168c4:	e1520003 	cmp	r2, r3
300168c8:	1a000023 	bne	3001695c <raw_input+0x114>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
300168cc:	e59d3008 	ldr	r3, [sp, #8]
300168d0:	e5933014 	ldr	r3, [r3, #20]
300168d4:	e3530000 	cmp	r3, #0
300168d8:	0a00001f 	beq	3001695c <raw_input+0x114>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
300168dc:	e59d3008 	ldr	r3, [sp, #8]
300168e0:	e593c014 	ldr	ip, [r3, #20]
300168e4:	e59d3008 	ldr	r3, [sp, #8]
300168e8:	e5932018 	ldr	r2, [r3, #24]
300168ec:	e59d3010 	ldr	r3, [sp, #16]
300168f0:	e283300c 	add	r3, r3, #12
300168f4:	e1a00002 	mov	r0, r2
300168f8:	e59d1008 	ldr	r1, [sp, #8]
300168fc:	e59d2004 	ldr	r2, [sp, #4]
30016900:	e1a0e00f 	mov	lr, pc
30016904:	e12fff1c 	bx	ip
30016908:	e1a03000 	mov	r3, r0
3001690c:	e3530000 	cmp	r3, #0
30016910:	0a000011 	beq	3001695c <raw_input+0x114>
        {
          /* receive function ate the packet */
          p = NULL;
30016914:	e3a03000 	mov	r3, #0
30016918:	e58d3004 	str	r3, [sp, #4]
          eaten = 1;
3001691c:	e3a03001 	mov	r3, #1
30016920:	e5cd3017 	strb	r3, [sp, #23]
          if (prev != NULL) {
30016924:	e59d300c 	ldr	r3, [sp, #12]
30016928:	e3530000 	cmp	r3, #0
3001692c:	0a00000a 	beq	3001695c <raw_input+0x114>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
30016930:	e59d3008 	ldr	r3, [sp, #8]
30016934:	e593200c 	ldr	r2, [r3, #12]
30016938:	e59d300c 	ldr	r3, [sp, #12]
3001693c:	e583200c 	str	r2, [r3, #12]
            pcb->next = raw_pcbs;
30016940:	e59f3054 	ldr	r3, [pc, #84]	; 3001699c <raw_input+0x154>
30016944:	e5932000 	ldr	r2, [r3]
30016948:	e59d3008 	ldr	r3, [sp, #8]
3001694c:	e583200c 	str	r2, [r3, #12]
            raw_pcbs = pcb;
30016950:	e59f3044 	ldr	r3, [pc, #68]	; 3001699c <raw_input+0x154>
30016954:	e59d2008 	ldr	r2, [sp, #8]
30016958:	e5832000 	str	r2, [r3]
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
3001695c:	e59d3008 	ldr	r3, [sp, #8]
30016960:	e58d300c 	str	r3, [sp, #12]
    pcb = pcb->next;
30016964:	e59d3008 	ldr	r3, [sp, #8]
30016968:	e593300c 	ldr	r3, [r3, #12]
3001696c:	e58d3008 	str	r3, [sp, #8]

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
30016970:	e5dd3017 	ldrb	r3, [sp, #23]
30016974:	e3530000 	cmp	r3, #0
30016978:	1a000002 	bne	30016988 <raw_input+0x140>
3001697c:	e59d3008 	ldr	r3, [sp, #8]
30016980:	e3530000 	cmp	r3, #0
30016984:	1affffca 	bne	300168b4 <raw_input+0x6c>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
30016988:	e5dd3017 	ldrb	r3, [sp, #23]
}
3001698c:	e1a00003 	mov	r0, r3
30016990:	e28dd01c 	add	sp, sp, #28
30016994:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016998:	e12fff1e 	bx	lr
3001699c:	300dbb94 	.word	0x300dbb94

300169a0 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
300169a0:	e24dd008 	sub	sp, sp, #8
300169a4:	e58d0004 	str	r0, [sp, #4]
300169a8:	e58d1000 	str	r1, [sp]
  ip_addr_set(&pcb->local_ip, ipaddr);
300169ac:	e59d3000 	ldr	r3, [sp]
300169b0:	e3530000 	cmp	r3, #0
300169b4:	0a00000b 	beq	300169e8 <raw_bind+0x48>
300169b8:	e59d3000 	ldr	r3, [sp]
300169bc:	e5d32000 	ldrb	r2, [r3]
300169c0:	e5d31001 	ldrb	r1, [r3, #1]
300169c4:	e1a01401 	lsl	r1, r1, #8
300169c8:	e1812002 	orr	r2, r1, r2
300169cc:	e5d31002 	ldrb	r1, [r3, #2]
300169d0:	e1a01801 	lsl	r1, r1, #16
300169d4:	e1812002 	orr	r2, r1, r2
300169d8:	e5d33003 	ldrb	r3, [r3, #3]
300169dc:	e1a03c03 	lsl	r3, r3, #24
300169e0:	e1833002 	orr	r3, r3, r2
300169e4:	ea000000 	b	300169ec <raw_bind+0x4c>
300169e8:	e3a03000 	mov	r3, #0
300169ec:	e59d2004 	ldr	r2, [sp, #4]
300169f0:	e5823000 	str	r3, [r2]
  return ERR_OK;
300169f4:	e3a03000 	mov	r3, #0
300169f8:	e1a03c03 	lsl	r3, r3, #24
300169fc:	e1a03c43 	asr	r3, r3, #24
}
30016a00:	e1a00003 	mov	r0, r3
30016a04:	e28dd008 	add	sp, sp, #8
30016a08:	e12fff1e 	bx	lr

30016a0c <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
30016a0c:	e24dd008 	sub	sp, sp, #8
30016a10:	e58d0004 	str	r0, [sp, #4]
30016a14:	e58d1000 	str	r1, [sp]
  ip_addr_set(&pcb->remote_ip, ipaddr);
30016a18:	e59d3000 	ldr	r3, [sp]
30016a1c:	e3530000 	cmp	r3, #0
30016a20:	0a00000b 	beq	30016a54 <raw_connect+0x48>
30016a24:	e59d3000 	ldr	r3, [sp]
30016a28:	e5d32000 	ldrb	r2, [r3]
30016a2c:	e5d31001 	ldrb	r1, [r3, #1]
30016a30:	e1a01401 	lsl	r1, r1, #8
30016a34:	e1812002 	orr	r2, r1, r2
30016a38:	e5d31002 	ldrb	r1, [r3, #2]
30016a3c:	e1a01801 	lsl	r1, r1, #16
30016a40:	e1812002 	orr	r2, r1, r2
30016a44:	e5d33003 	ldrb	r3, [r3, #3]
30016a48:	e1a03c03 	lsl	r3, r3, #24
30016a4c:	e1833002 	orr	r3, r3, r2
30016a50:	ea000000 	b	30016a58 <raw_connect+0x4c>
30016a54:	e3a03000 	mov	r3, #0
30016a58:	e59d2004 	ldr	r2, [sp, #4]
30016a5c:	e5823004 	str	r3, [r2, #4]
  return ERR_OK;
30016a60:	e3a03000 	mov	r3, #0
30016a64:	e1a03c03 	lsl	r3, r3, #24
30016a68:	e1a03c43 	asr	r3, r3, #24
}
30016a6c:	e1a00003 	mov	r0, r3
30016a70:	e28dd008 	add	sp, sp, #8
30016a74:	e12fff1e 	bx	lr

30016a78 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
30016a78:	e24dd010 	sub	sp, sp, #16
30016a7c:	e58d000c 	str	r0, [sp, #12]
30016a80:	e58d1008 	str	r1, [sp, #8]
30016a84:	e58d2004 	str	r2, [sp, #4]
  /* remember recv() callback and user data */
  pcb->recv = recv;
30016a88:	e59d300c 	ldr	r3, [sp, #12]
30016a8c:	e59d2008 	ldr	r2, [sp, #8]
30016a90:	e5832014 	str	r2, [r3, #20]
  pcb->recv_arg = recv_arg;
30016a94:	e59d300c 	ldr	r3, [sp, #12]
30016a98:	e59d2004 	ldr	r2, [sp, #4]
30016a9c:	e5832018 	str	r2, [r3, #24]
}
30016aa0:	e28dd010 	add	sp, sp, #16
30016aa4:	e12fff1e 	bx	lr

30016aa8 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
30016aa8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30016aac:	e24dd034 	sub	sp, sp, #52	; 0x34
30016ab0:	e58d001c 	str	r0, [sp, #28]
30016ab4:	e58d1018 	str	r1, [sp, #24]
30016ab8:	e58d2014 	str	r2, [sp, #20]
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
30016abc:	e59d0018 	ldr	r0, [sp, #24]
30016ac0:	e3a01014 	mov	r1, #20
30016ac4:	ebfffd88 	bl	300160ec <pbuf_header>
30016ac8:	e1a03000 	mov	r3, r0
30016acc:	e3530000 	cmp	r3, #0
30016ad0:	0a00000e 	beq	30016b10 <raw_sendto+0x68>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
30016ad4:	e3a00001 	mov	r0, #1
30016ad8:	e3a01000 	mov	r1, #0
30016adc:	e3a02000 	mov	r2, #0
30016ae0:	ebfffc34 	bl	30015bb8 <pbuf_alloc>
30016ae4:	e1a03000 	mov	r3, r0
30016ae8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
30016aec:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30016af0:	e3530000 	cmp	r3, #0
30016af4:	1a000001 	bne	30016b00 <raw_sendto+0x58>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
30016af8:	e3a030ff 	mov	r3, #255	; 0xff
30016afc:	ea000041 	b	30016c08 <raw_sendto+0x160>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
30016b00:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30016b04:	e59d1018 	ldr	r1, [sp, #24]
30016b08:	ebfffe6d 	bl	300164c4 <pbuf_chain>
30016b0c:	ea000009 	b	30016b38 <raw_sendto+0x90>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
30016b10:	e59d3018 	ldr	r3, [sp, #24]
30016b14:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    if(pbuf_header(q, -IP_HLEN)) {
30016b18:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30016b1c:	e3e01013 	mvn	r1, #19
30016b20:	ebfffd71 	bl	300160ec <pbuf_header>
30016b24:	e1a03000 	mov	r3, r0
30016b28:	e3530000 	cmp	r3, #0
30016b2c:	0a000001 	beq	30016b38 <raw_sendto+0x90>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
30016b30:	e3a030ff 	mov	r3, #255	; 0xff
30016b34:	ea000033 	b	30016c08 <raw_sendto+0x160>
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
30016b38:	e59d0014 	ldr	r0, [sp, #20]
30016b3c:	ebfff504 	bl	30013f54 <ip_route>
30016b40:	e1a03000 	mov	r3, r0
30016b44:	e58d3024 	str	r3, [sp, #36]	; 0x24
30016b48:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30016b4c:	e3530000 	cmp	r3, #0
30016b50:	1a000007 	bne	30016b74 <raw_sendto+0xcc>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
30016b54:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30016b58:	e59d3018 	ldr	r3, [sp, #24]
30016b5c:	e1520003 	cmp	r2, r3
30016b60:	0a000001 	beq	30016b6c <raw_sendto+0xc4>
      pbuf_free(q);
30016b64:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30016b68:	ebfffdc4 	bl	30016280 <pbuf_free>
    }
    return ERR_RTE;
30016b6c:	e3a030fd 	mov	r3, #253	; 0xfd
30016b70:	ea000024 	b	30016c08 <raw_sendto+0x160>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
30016b74:	e59d301c 	ldr	r3, [sp, #28]
30016b78:	e3530000 	cmp	r3, #0
30016b7c:	0a000003 	beq	30016b90 <raw_sendto+0xe8>
30016b80:	e59d301c 	ldr	r3, [sp, #28]
30016b84:	e5933000 	ldr	r3, [r3]
30016b88:	e3530000 	cmp	r3, #0
30016b8c:	1a000003 	bne	30016ba0 <raw_sendto+0xf8>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
30016b90:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30016b94:	e2833004 	add	r3, r3, #4
30016b98:	e58d3028 	str	r3, [sp, #40]	; 0x28
      pbuf_free(q);
    }
    return ERR_RTE;
  }

  if (ip_addr_isany(&pcb->local_ip)) {
30016b9c:	ea000001 	b	30016ba8 <raw_sendto+0x100>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
30016ba0:	e59d301c 	ldr	r3, [sp, #28]
30016ba4:	e58d3028 	str	r3, [sp, #40]	; 0x28
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
30016ba8:	e59d301c 	ldr	r3, [sp, #28]
30016bac:	e5d3300b 	ldrb	r3, [r3, #11]
30016bb0:	e59d201c 	ldr	r2, [sp, #28]
30016bb4:	e5d2100a 	ldrb	r1, [r2, #10]
30016bb8:	e59d201c 	ldr	r2, [sp, #28]
30016bbc:	e5d22010 	ldrb	r2, [r2, #16]
30016bc0:	e58d1000 	str	r1, [sp]
30016bc4:	e58d2004 	str	r2, [sp, #4]
30016bc8:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30016bcc:	e58d2008 	str	r2, [sp, #8]
30016bd0:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30016bd4:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
30016bd8:	e59d2014 	ldr	r2, [sp, #20]
30016bdc:	ebfff696 	bl	3001463c <ip_output_if>
30016be0:	e1a03000 	mov	r3, r0
30016be4:	e20330ff 	and	r3, r3, #255	; 0xff
30016be8:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
30016bec:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30016bf0:	e59d3018 	ldr	r3, [sp, #24]
30016bf4:	e1520003 	cmp	r2, r3
30016bf8:	0a000001 	beq	30016c04 <raw_sendto+0x15c>
    /* free the header */
    pbuf_free(q);
30016bfc:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30016c00:	ebfffd9e 	bl	30016280 <pbuf_free>
  }
  return err;
30016c04:	e5dd3023 	ldrb	r3, [sp, #35]	; 0x23
30016c08:	e1a03c03 	lsl	r3, r3, #24
30016c0c:	e1a03c43 	asr	r3, r3, #24
}
30016c10:	e1a00003 	mov	r0, r3
30016c14:	e28dd034 	add	sp, sp, #52	; 0x34
30016c18:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016c1c:	e12fff1e 	bx	lr

30016c20 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
30016c20:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30016c24:	e24dd00c 	sub	sp, sp, #12
30016c28:	e58d0004 	str	r0, [sp, #4]
30016c2c:	e58d1000 	str	r1, [sp]
  return raw_sendto(pcb, p, &pcb->remote_ip);
30016c30:	e59d3004 	ldr	r3, [sp, #4]
30016c34:	e2833004 	add	r3, r3, #4
30016c38:	e59d0004 	ldr	r0, [sp, #4]
30016c3c:	e59d1000 	ldr	r1, [sp]
30016c40:	e1a02003 	mov	r2, r3
30016c44:	ebffff97 	bl	30016aa8 <raw_sendto>
30016c48:	e1a03000 	mov	r3, r0
30016c4c:	e20330ff 	and	r3, r3, #255	; 0xff
30016c50:	e20330ff 	and	r3, r3, #255	; 0xff
30016c54:	e1a03c03 	lsl	r3, r3, #24
30016c58:	e1a03c43 	asr	r3, r3, #24
}
30016c5c:	e1a00003 	mov	r0, r3
30016c60:	e28dd00c 	add	sp, sp, #12
30016c64:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016c68:	e12fff1e 	bx	lr

30016c6c <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
30016c6c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30016c70:	e24dd014 	sub	sp, sp, #20
30016c74:	e58d0004 	str	r0, [sp, #4]
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
30016c78:	e59f3098 	ldr	r3, [pc, #152]	; 30016d18 <raw_remove+0xac>
30016c7c:	e5932000 	ldr	r2, [r3]
30016c80:	e59d3004 	ldr	r3, [sp, #4]
30016c84:	e1520003 	cmp	r2, r3
30016c88:	1a000005 	bne	30016ca4 <raw_remove+0x38>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
30016c8c:	e59f3084 	ldr	r3, [pc, #132]	; 30016d18 <raw_remove+0xac>
30016c90:	e5933000 	ldr	r3, [r3]
30016c94:	e593200c 	ldr	r2, [r3, #12]
30016c98:	e59f3078 	ldr	r3, [pc, #120]	; 30016d18 <raw_remove+0xac>
30016c9c:	e5832000 	str	r2, [r3]
30016ca0:	ea000016 	b	30016d00 <raw_remove+0x94>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
30016ca4:	e59f306c 	ldr	r3, [pc, #108]	; 30016d18 <raw_remove+0xac>
30016ca8:	e5933000 	ldr	r3, [r3]
30016cac:	e58d300c 	str	r3, [sp, #12]
30016cb0:	ea00000f 	b	30016cf4 <raw_remove+0x88>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
30016cb4:	e59d300c 	ldr	r3, [sp, #12]
30016cb8:	e593300c 	ldr	r3, [r3, #12]
30016cbc:	e3530000 	cmp	r3, #0
30016cc0:	0a000008 	beq	30016ce8 <raw_remove+0x7c>
30016cc4:	e59d300c 	ldr	r3, [sp, #12]
30016cc8:	e593200c 	ldr	r2, [r3, #12]
30016ccc:	e59d3004 	ldr	r3, [sp, #4]
30016cd0:	e1520003 	cmp	r2, r3
30016cd4:	1a000003 	bne	30016ce8 <raw_remove+0x7c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
30016cd8:	e59d3004 	ldr	r3, [sp, #4]
30016cdc:	e593200c 	ldr	r2, [r3, #12]
30016ce0:	e59d300c 	ldr	r3, [sp, #12]
30016ce4:	e583200c 	str	r2, [r3, #12]
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
30016ce8:	e59d300c 	ldr	r3, [sp, #12]
30016cec:	e593300c 	ldr	r3, [r3, #12]
30016cf0:	e58d300c 	str	r3, [sp, #12]
30016cf4:	e59d300c 	ldr	r3, [sp, #12]
30016cf8:	e3530000 	cmp	r3, #0
30016cfc:	1affffec 	bne	30016cb4 <raw_remove+0x48>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
30016d00:	e3a00000 	mov	r0, #0
30016d04:	e59d1004 	ldr	r1, [sp, #4]
30016d08:	ebfff9ee 	bl	300154c8 <memp_free>
}
30016d0c:	e28dd014 	add	sp, sp, #20
30016d10:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016d14:	e12fff1e 	bx	lr
30016d18:	300dbb94 	.word	0x300dbb94

30016d1c <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
30016d1c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30016d20:	e24dd014 	sub	sp, sp, #20
30016d24:	e1a03000 	mov	r3, r0
30016d28:	e5cd3007 	strb	r3, [sp, #7]
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
30016d2c:	e3a00000 	mov	r0, #0
30016d30:	ebfff97f 	bl	30015334 <memp_malloc>
30016d34:	e1a03000 	mov	r3, r0
30016d38:	e58d300c 	str	r3, [sp, #12]
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
30016d3c:	e59d300c 	ldr	r3, [sp, #12]
30016d40:	e3530000 	cmp	r3, #0
30016d44:	0a000010 	beq	30016d8c <raw_new+0x70>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
30016d48:	e59d000c 	ldr	r0, [sp, #12]
30016d4c:	e3a01000 	mov	r1, #0
30016d50:	e3a0201c 	mov	r2, #28
30016d54:	ebffd544 	bl	3000c26c <acoral_memset>
    pcb->protocol = proto;
30016d58:	e59d300c 	ldr	r3, [sp, #12]
30016d5c:	e5dd2007 	ldrb	r2, [sp, #7]
30016d60:	e5c32010 	strb	r2, [r3, #16]
    pcb->ttl = RAW_TTL;
30016d64:	e59d300c 	ldr	r3, [sp, #12]
30016d68:	e3e02000 	mvn	r2, #0
30016d6c:	e5c3200b 	strb	r2, [r3, #11]
    pcb->next = raw_pcbs;
30016d70:	e59f3028 	ldr	r3, [pc, #40]	; 30016da0 <raw_new+0x84>
30016d74:	e5932000 	ldr	r2, [r3]
30016d78:	e59d300c 	ldr	r3, [sp, #12]
30016d7c:	e583200c 	str	r2, [r3, #12]
    raw_pcbs = pcb;
30016d80:	e59f3018 	ldr	r3, [pc, #24]	; 30016da0 <raw_new+0x84>
30016d84:	e59d200c 	ldr	r2, [sp, #12]
30016d88:	e5832000 	str	r2, [r3]
  }
  return pcb;
30016d8c:	e59d300c 	ldr	r3, [sp, #12]
}
30016d90:	e1a00003 	mov	r0, r3
30016d94:	e28dd014 	add	sp, sp, #20
30016d98:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016d9c:	e12fff1e 	bx	lr
30016da0:	300dbb94 	.word	0x300dbb94

30016da4 <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
30016da4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30016da8:	e24dd024 	sub	sp, sp, #36	; 0x24
30016dac:	e58d0004 	str	r0, [sp, #4]
30016db0:	e58d1000 	str	r1, [sp]
30016db4:	ea000000 	b	30016dbc <sys_mbox_fetch+0x18>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
30016db8:	e1a00000 	nop			; (mov r0, r0)
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
30016dbc:	ebffd7ab 	bl	3000cc70 <sys_arch_timeouts>
30016dc0:	e1a03000 	mov	r3, r0
30016dc4:	e58d3010 	str	r3, [sp, #16]

  if (!timeouts || !timeouts->next) {
30016dc8:	e59d3010 	ldr	r3, [sp, #16]
30016dcc:	e3530000 	cmp	r3, #0
30016dd0:	0a000003 	beq	30016de4 <sys_mbox_fetch+0x40>
30016dd4:	e59d3010 	ldr	r3, [sp, #16]
30016dd8:	e5933000 	ldr	r3, [r3]
30016ddc:	e3530000 	cmp	r3, #0
30016de0:	1a000006 	bne	30016e00 <sys_mbox_fetch+0x5c>
    UNLOCK_TCPIP_CORE();
    time = sys_arch_mbox_fetch(mbox, msg, 0);
30016de4:	e59d0004 	ldr	r0, [sp, #4]
30016de8:	e59d1000 	ldr	r1, [sp]
30016dec:	e3a02000 	mov	r2, #0
30016df0:	ebffd72f 	bl	3000cab4 <sys_arch_mbox_fetch>
30016df4:	e1a03000 	mov	r3, r0
30016df8:	e58d300c 	str	r3, [sp, #12]
  void *arg;

 again:
  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
30016dfc:	ea00003e 	b	30016efc <sys_mbox_fetch+0x158>
    UNLOCK_TCPIP_CORE();
    time = sys_arch_mbox_fetch(mbox, msg, 0);
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
30016e00:	e59d3010 	ldr	r3, [sp, #16]
30016e04:	e5933000 	ldr	r3, [r3]
30016e08:	e5933004 	ldr	r3, [r3, #4]
30016e0c:	e3530000 	cmp	r3, #0
30016e10:	0a000009 	beq	30016e3c <sys_mbox_fetch+0x98>
      UNLOCK_TCPIP_CORE();
      time = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
30016e14:	e59d3010 	ldr	r3, [sp, #16]
30016e18:	e5933000 	ldr	r3, [r3]
30016e1c:	e5933004 	ldr	r3, [r3, #4]
30016e20:	e59d0004 	ldr	r0, [sp, #4]
30016e24:	e59d1000 	ldr	r1, [sp]
30016e28:	e1a02003 	mov	r2, r3
30016e2c:	ebffd720 	bl	3000cab4 <sys_arch_mbox_fetch>
30016e30:	e1a03000 	mov	r3, r0
30016e34:	e58d300c 	str	r3, [sp, #12]
30016e38:	ea000001 	b	30016e44 <sys_mbox_fetch+0xa0>
      LOCK_TCPIP_CORE();
    } else {
      time = SYS_ARCH_TIMEOUT;
30016e3c:	e3e03000 	mvn	r3, #0
30016e40:	e58d300c 	str	r3, [sp, #12]
    }

    if (time == SYS_ARCH_TIMEOUT) {
30016e44:	e59d300c 	ldr	r3, [sp, #12]
30016e48:	e3730001 	cmn	r3, #1
30016e4c:	1a000017 	bne	30016eb0 <sys_mbox_fetch+0x10c>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
30016e50:	e59d3010 	ldr	r3, [sp, #16]
30016e54:	e5933000 	ldr	r3, [r3]
30016e58:	e58d3014 	str	r3, [sp, #20]
      timeouts->next = tmptimeout->next;
30016e5c:	e59d3014 	ldr	r3, [sp, #20]
30016e60:	e5932000 	ldr	r2, [r3]
30016e64:	e59d3010 	ldr	r3, [sp, #16]
30016e68:	e5832000 	str	r2, [r3]
      h   = tmptimeout->h;
30016e6c:	e59d3014 	ldr	r3, [sp, #20]
30016e70:	e5933008 	ldr	r3, [r3, #8]
30016e74:	e58d3018 	str	r3, [sp, #24]
      arg = tmptimeout->arg;
30016e78:	e59d3014 	ldr	r3, [sp, #20]
30016e7c:	e593300c 	ldr	r3, [r3, #12]
30016e80:	e58d301c 	str	r3, [sp, #28]
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
30016e84:	e3a0000a 	mov	r0, #10
30016e88:	e59d1014 	ldr	r1, [sp, #20]
30016e8c:	ebfff98d 	bl	300154c8 <memp_free>
      if (h != NULL) {
30016e90:	e59d3018 	ldr	r3, [sp, #24]
30016e94:	e3530000 	cmp	r3, #0
30016e98:	0affffc6 	beq	30016db8 <sys_mbox_fetch+0x14>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
30016e9c:	e59d3018 	ldr	r3, [sp, #24]
30016ea0:	e59d001c 	ldr	r0, [sp, #28]
30016ea4:	e1a0e00f 	mov	lr, pc
30016ea8:	e12fff13 	bx	r3
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
30016eac:	eaffffc2 	b	30016dbc <sys_mbox_fetch+0x18>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time < timeouts->next->time) {
30016eb0:	e59d3010 	ldr	r3, [sp, #16]
30016eb4:	e5933000 	ldr	r3, [r3]
30016eb8:	e5932004 	ldr	r2, [r3, #4]
30016ebc:	e59d300c 	ldr	r3, [sp, #12]
30016ec0:	e1520003 	cmp	r2, r3
30016ec4:	9a000008 	bls	30016eec <sys_mbox_fetch+0x148>
        timeouts->next->time -= time;
30016ec8:	e59d3010 	ldr	r3, [sp, #16]
30016ecc:	e5933000 	ldr	r3, [r3]
30016ed0:	e59d2010 	ldr	r2, [sp, #16]
30016ed4:	e5922000 	ldr	r2, [r2]
30016ed8:	e5921004 	ldr	r1, [r2, #4]
30016edc:	e59d200c 	ldr	r2, [sp, #12]
30016ee0:	e0622001 	rsb	r2, r2, r1
30016ee4:	e5832004 	str	r2, [r3, #4]
30016ee8:	ea000003 	b	30016efc <sys_mbox_fetch+0x158>
      } else {
        timeouts->next->time = 0;
30016eec:	e59d3010 	ldr	r3, [sp, #16]
30016ef0:	e5933000 	ldr	r3, [r3]
30016ef4:	e3a02000 	mov	r2, #0
30016ef8:	e5832004 	str	r2, [r3, #4]
      }
    }
  }
}
30016efc:	e28dd024 	add	sp, sp, #36	; 0x24
30016f00:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30016f04:	e12fff1e 	bx	lr

30016f08 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
30016f08:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30016f0c:	e24dd024 	sub	sp, sp, #36	; 0x24
30016f10:	e58d0004 	str	r0, [sp, #4]
30016f14:	ea000000 	b	30016f1c <sys_sem_wait+0x14>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
30016f18:	e1a00000 	nop			; (mov r0, r0)
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
30016f1c:	ebffd753 	bl	3000cc70 <sys_arch_timeouts>
30016f20:	e1a03000 	mov	r3, r0
30016f24:	e58d3010 	str	r3, [sp, #16]

  if (!timeouts || !timeouts->next) {
30016f28:	e59d3010 	ldr	r3, [sp, #16]
30016f2c:	e3530000 	cmp	r3, #0
30016f30:	0a000003 	beq	30016f44 <sys_sem_wait+0x3c>
30016f34:	e59d3010 	ldr	r3, [sp, #16]
30016f38:	e5933000 	ldr	r3, [r3]
30016f3c:	e3530000 	cmp	r3, #0
30016f40:	1a000003 	bne	30016f54 <sys_sem_wait+0x4c>
    sys_arch_sem_wait(sem, 0);
30016f44:	e59d0004 	ldr	r0, [sp, #4]
30016f48:	e3a01000 	mov	r1, #0
30016f4c:	ebffd67d 	bl	3000c948 <sys_arch_sem_wait>

 again:

  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
30016f50:	ea00003d 	b	3001704c <sys_sem_wait+0x144>
    sys_arch_sem_wait(sem, 0);
  } else {
    if (timeouts->next->time > 0) {
30016f54:	e59d3010 	ldr	r3, [sp, #16]
30016f58:	e5933000 	ldr	r3, [r3]
30016f5c:	e5933004 	ldr	r3, [r3, #4]
30016f60:	e3530000 	cmp	r3, #0
30016f64:	0a000008 	beq	30016f8c <sys_sem_wait+0x84>
      time = sys_arch_sem_wait(sem, timeouts->next->time);
30016f68:	e59d3010 	ldr	r3, [sp, #16]
30016f6c:	e5933000 	ldr	r3, [r3]
30016f70:	e5933004 	ldr	r3, [r3, #4]
30016f74:	e59d0004 	ldr	r0, [sp, #4]
30016f78:	e1a01003 	mov	r1, r3
30016f7c:	ebffd671 	bl	3000c948 <sys_arch_sem_wait>
30016f80:	e1a03000 	mov	r3, r0
30016f84:	e58d300c 	str	r3, [sp, #12]
30016f88:	ea000001 	b	30016f94 <sys_sem_wait+0x8c>
    } else {
      time = SYS_ARCH_TIMEOUT;
30016f8c:	e3e03000 	mvn	r3, #0
30016f90:	e58d300c 	str	r3, [sp, #12]
    }

    if (time == SYS_ARCH_TIMEOUT) {
30016f94:	e59d300c 	ldr	r3, [sp, #12]
30016f98:	e3730001 	cmn	r3, #1
30016f9c:	1a000017 	bne	30017000 <sys_sem_wait+0xf8>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
30016fa0:	e59d3010 	ldr	r3, [sp, #16]
30016fa4:	e5933000 	ldr	r3, [r3]
30016fa8:	e58d3014 	str	r3, [sp, #20]
      timeouts->next = tmptimeout->next;
30016fac:	e59d3014 	ldr	r3, [sp, #20]
30016fb0:	e5932000 	ldr	r2, [r3]
30016fb4:	e59d3010 	ldr	r3, [sp, #16]
30016fb8:	e5832000 	str	r2, [r3]
      h = tmptimeout->h;
30016fbc:	e59d3014 	ldr	r3, [sp, #20]
30016fc0:	e5933008 	ldr	r3, [r3, #8]
30016fc4:	e58d3018 	str	r3, [sp, #24]
      arg = tmptimeout->arg;
30016fc8:	e59d3014 	ldr	r3, [sp, #20]
30016fcc:	e593300c 	ldr	r3, [r3, #12]
30016fd0:	e58d301c 	str	r3, [sp, #28]
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
30016fd4:	e3a0000a 	mov	r0, #10
30016fd8:	e59d1014 	ldr	r1, [sp, #20]
30016fdc:	ebfff939 	bl	300154c8 <memp_free>
      if (h != NULL) {
30016fe0:	e59d3018 	ldr	r3, [sp, #24]
30016fe4:	e3530000 	cmp	r3, #0
30016fe8:	0affffca 	beq	30016f18 <sys_sem_wait+0x10>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
30016fec:	e59d3018 	ldr	r3, [sp, #24]
30016ff0:	e59d001c 	ldr	r0, [sp, #28]
30016ff4:	e1a0e00f 	mov	lr, pc
30016ff8:	e12fff13 	bx	r3
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
30016ffc:	eaffffc6 	b	30016f1c <sys_sem_wait+0x14>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time < timeouts->next->time) {
30017000:	e59d3010 	ldr	r3, [sp, #16]
30017004:	e5933000 	ldr	r3, [r3]
30017008:	e5932004 	ldr	r2, [r3, #4]
3001700c:	e59d300c 	ldr	r3, [sp, #12]
30017010:	e1520003 	cmp	r2, r3
30017014:	9a000008 	bls	3001703c <sys_sem_wait+0x134>
        timeouts->next->time -= time;
30017018:	e59d3010 	ldr	r3, [sp, #16]
3001701c:	e5933000 	ldr	r3, [r3]
30017020:	e59d2010 	ldr	r2, [sp, #16]
30017024:	e5922000 	ldr	r2, [r2]
30017028:	e5921004 	ldr	r1, [r2, #4]
3001702c:	e59d200c 	ldr	r2, [sp, #12]
30017030:	e0622001 	rsb	r2, r2, r1
30017034:	e5832004 	str	r2, [r3, #4]
30017038:	ea000003 	b	3001704c <sys_sem_wait+0x144>
      } else {
        timeouts->next->time = 0;
3001703c:	e59d3010 	ldr	r3, [sp, #16]
30017040:	e5933000 	ldr	r3, [r3]
30017044:	e3a02000 	mov	r2, #0
30017048:	e5832004 	str	r2, [r3, #4]
      }
    }
  }
}
3001704c:	e28dd024 	add	sp, sp, #36	; 0x24
30017050:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30017054:	e12fff1e 	bx	lr

30017058 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
30017058:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001705c:	e24dd024 	sub	sp, sp, #36	; 0x24
30017060:	e58d000c 	str	r0, [sp, #12]
30017064:	e58d1008 	str	r1, [sp, #8]
30017068:	e58d2004 	str	r2, [sp, #4]
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
3001706c:	e3a0000a 	mov	r0, #10
30017070:	ebfff8af 	bl	30015334 <memp_malloc>
30017074:	e1a03000 	mov	r3, r0
30017078:	e58d3018 	str	r3, [sp, #24]
  if (timeout == NULL) {
3001707c:	e59d3018 	ldr	r3, [sp, #24]
30017080:	e3530000 	cmp	r3, #0
30017084:	0a000061 	beq	30017210 <sys_timeout+0x1b8>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
    return;
  }
  timeout->next = NULL;
30017088:	e59d3018 	ldr	r3, [sp, #24]
3001708c:	e3a02000 	mov	r2, #0
30017090:	e5832000 	str	r2, [r3]
  timeout->h = h;
30017094:	e59d3018 	ldr	r3, [sp, #24]
30017098:	e59d2008 	ldr	r2, [sp, #8]
3001709c:	e5832008 	str	r2, [r3, #8]
  timeout->arg = arg;
300170a0:	e59d3018 	ldr	r3, [sp, #24]
300170a4:	e59d2004 	ldr	r2, [sp, #4]
300170a8:	e583200c 	str	r2, [r3, #12]
  timeout->time = msecs;
300170ac:	e59d3018 	ldr	r3, [sp, #24]
300170b0:	e59d200c 	ldr	r2, [sp, #12]
300170b4:	e5832004 	str	r2, [r3, #4]

  timeouts = sys_arch_timeouts();
300170b8:	ebffd6ec 	bl	3000cc70 <sys_arch_timeouts>
300170bc:	e1a03000 	mov	r3, r0
300170c0:	e58d3014 	str	r3, [sp, #20]

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
300170c4:	e59d3014 	ldr	r3, [sp, #20]
300170c8:	e3530000 	cmp	r3, #0
300170cc:	0a000051 	beq	30017218 <sys_timeout+0x1c0>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
    return;
  }

  if (timeouts->next == NULL) {
300170d0:	e59d3014 	ldr	r3, [sp, #20]
300170d4:	e5933000 	ldr	r3, [r3]
300170d8:	e3530000 	cmp	r3, #0
300170dc:	1a000003 	bne	300170f0 <sys_timeout+0x98>
    timeouts->next = timeout;
300170e0:	e59d3014 	ldr	r3, [sp, #20]
300170e4:	e59d2018 	ldr	r2, [sp, #24]
300170e8:	e5832000 	str	r2, [r3]
    return;
300170ec:	ea00004a 	b	3001721c <sys_timeout+0x1c4>
  }

  if (timeouts->next->time > msecs) {
300170f0:	e59d3014 	ldr	r3, [sp, #20]
300170f4:	e5933000 	ldr	r3, [r3]
300170f8:	e5932004 	ldr	r2, [r3, #4]
300170fc:	e59d300c 	ldr	r3, [sp, #12]
30017100:	e1520003 	cmp	r2, r3
30017104:	9a00000f 	bls	30017148 <sys_timeout+0xf0>
    timeouts->next->time -= msecs;
30017108:	e59d3014 	ldr	r3, [sp, #20]
3001710c:	e5933000 	ldr	r3, [r3]
30017110:	e59d2014 	ldr	r2, [sp, #20]
30017114:	e5922000 	ldr	r2, [r2]
30017118:	e5921004 	ldr	r1, [r2, #4]
3001711c:	e59d200c 	ldr	r2, [sp, #12]
30017120:	e0622001 	rsb	r2, r2, r1
30017124:	e5832004 	str	r2, [r3, #4]
    timeout->next = timeouts->next;
30017128:	e59d3014 	ldr	r3, [sp, #20]
3001712c:	e5932000 	ldr	r2, [r3]
30017130:	e59d3018 	ldr	r3, [sp, #24]
30017134:	e5832000 	str	r2, [r3]
    timeouts->next = timeout;
30017138:	e59d3014 	ldr	r3, [sp, #20]
3001713c:	e59d2018 	ldr	r2, [sp, #24]
30017140:	e5832000 	str	r2, [r3]
30017144:	ea000034 	b	3001721c <sys_timeout+0x1c4>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
30017148:	e59d3014 	ldr	r3, [sp, #20]
3001714c:	e5933000 	ldr	r3, [r3]
30017150:	e58d301c 	str	r3, [sp, #28]
30017154:	ea000029 	b	30017200 <sys_timeout+0x1a8>
      timeout->time -= t->time;
30017158:	e59d3018 	ldr	r3, [sp, #24]
3001715c:	e5932004 	ldr	r2, [r3, #4]
30017160:	e59d301c 	ldr	r3, [sp, #28]
30017164:	e5933004 	ldr	r3, [r3, #4]
30017168:	e0632002 	rsb	r2, r3, r2
3001716c:	e59d3018 	ldr	r3, [sp, #24]
30017170:	e5832004 	str	r2, [r3, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
30017174:	e59d301c 	ldr	r3, [sp, #28]
30017178:	e5933000 	ldr	r3, [r3]
3001717c:	e3530000 	cmp	r3, #0
30017180:	0a000006 	beq	300171a0 <sys_timeout+0x148>
30017184:	e59d301c 	ldr	r3, [sp, #28]
30017188:	e5933000 	ldr	r3, [r3]
3001718c:	e5932004 	ldr	r2, [r3, #4]
30017190:	e59d3018 	ldr	r3, [sp, #24]
30017194:	e5933004 	ldr	r3, [r3, #4]
30017198:	e1520003 	cmp	r2, r3
3001719c:	9a000014 	bls	300171f4 <sys_timeout+0x19c>
        if (t->next != NULL) {
300171a0:	e59d301c 	ldr	r3, [sp, #28]
300171a4:	e5933000 	ldr	r3, [r3]
300171a8:	e3530000 	cmp	r3, #0
300171ac:	0a000008 	beq	300171d4 <sys_timeout+0x17c>
          t->next->time -= timeout->time;
300171b0:	e59d301c 	ldr	r3, [sp, #28]
300171b4:	e5933000 	ldr	r3, [r3]
300171b8:	e59d201c 	ldr	r2, [sp, #28]
300171bc:	e5922000 	ldr	r2, [r2]
300171c0:	e5921004 	ldr	r1, [r2, #4]
300171c4:	e59d2018 	ldr	r2, [sp, #24]
300171c8:	e5922004 	ldr	r2, [r2, #4]
300171cc:	e0622001 	rsb	r2, r2, r1
300171d0:	e5832004 	str	r2, [r3, #4]
        }
        timeout->next = t->next;
300171d4:	e59d301c 	ldr	r3, [sp, #28]
300171d8:	e5932000 	ldr	r2, [r3]
300171dc:	e59d3018 	ldr	r3, [sp, #24]
300171e0:	e5832000 	str	r2, [r3]
        t->next = timeout;
300171e4:	e59d301c 	ldr	r3, [sp, #28]
300171e8:	e59d2018 	ldr	r2, [sp, #24]
300171ec:	e5832000 	str	r2, [r3]
        break;
300171f0:	ea000009 	b	3001721c <sys_timeout+0x1c4>
  if (timeouts->next->time > msecs) {
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
300171f4:	e59d301c 	ldr	r3, [sp, #28]
300171f8:	e5933000 	ldr	r3, [r3]
300171fc:	e58d301c 	str	r3, [sp, #28]
30017200:	e59d301c 	ldr	r3, [sp, #28]
30017204:	e3530000 	cmp	r3, #0
30017208:	1affffd2 	bne	30017158 <sys_timeout+0x100>
3001720c:	ea000002 	b	3001721c <sys_timeout+0x1c4>
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
    return;
30017210:	e1a00000 	nop			; (mov r0, r0)
30017214:	ea000000 	b	3001721c <sys_timeout+0x1c4>
  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
    return;
30017218:	e1a00000 	nop			; (mov r0, r0)
        t->next = timeout;
        break;
      }
    }
  }
}
3001721c:	e28dd024 	add	sp, sp, #36	; 0x24
30017220:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30017224:	e12fff1e 	bx	lr

30017228 <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
30017228:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001722c:	e24dd01c 	sub	sp, sp, #28
30017230:	e58d0004 	str	r0, [sp, #4]
30017234:	e58d1000 	str	r1, [sp]
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
30017238:	ebffd68c 	bl	3000cc70 <sys_arch_timeouts>
3001723c:	e1a03000 	mov	r3, r0
30017240:	e58d300c 	str	r3, [sp, #12]

  if (timeouts == NULL) {
30017244:	e59d300c 	ldr	r3, [sp, #12]
30017248:	e3530000 	cmp	r3, #0
3001724c:	0a000039 	beq	30017338 <sys_untimeout+0x110>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
    return;
  }
  if (timeouts->next == NULL) {
30017250:	e59d300c 	ldr	r3, [sp, #12]
30017254:	e5933000 	ldr	r3, [r3]
30017258:	e3530000 	cmp	r3, #0
3001725c:	0a000037 	beq	30017340 <sys_untimeout+0x118>
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
30017260:	e59d300c 	ldr	r3, [sp, #12]
30017264:	e5933000 	ldr	r3, [r3]
30017268:	e58d3014 	str	r3, [sp, #20]
3001726c:	e3a03000 	mov	r3, #0
30017270:	e58d3010 	str	r3, [sp, #16]
30017274:	ea00002b 	b	30017328 <sys_untimeout+0x100>
    if ((t->h == h) && (t->arg == arg)) {
30017278:	e59d3014 	ldr	r3, [sp, #20]
3001727c:	e5932008 	ldr	r2, [r3, #8]
30017280:	e59d3004 	ldr	r3, [sp, #4]
30017284:	e1520003 	cmp	r2, r3
30017288:	1a000021 	bne	30017314 <sys_untimeout+0xec>
3001728c:	e59d3014 	ldr	r3, [sp, #20]
30017290:	e593200c 	ldr	r2, [r3, #12]
30017294:	e59d3000 	ldr	r3, [sp]
30017298:	e1520003 	cmp	r2, r3
3001729c:	1a00001c 	bne	30017314 <sys_untimeout+0xec>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
300172a0:	e59d3010 	ldr	r3, [sp, #16]
300172a4:	e3530000 	cmp	r3, #0
300172a8:	1a000004 	bne	300172c0 <sys_untimeout+0x98>
        timeouts->next = t->next;
300172ac:	e59d3014 	ldr	r3, [sp, #20]
300172b0:	e5932000 	ldr	r2, [r3]
300172b4:	e59d300c 	ldr	r3, [sp, #12]
300172b8:	e5832000 	str	r2, [r3]
300172bc:	ea000003 	b	300172d0 <sys_untimeout+0xa8>
      else
        prev_t->next = t->next;
300172c0:	e59d3014 	ldr	r3, [sp, #20]
300172c4:	e5932000 	ldr	r2, [r3]
300172c8:	e59d3010 	ldr	r3, [sp, #16]
300172cc:	e5832000 	str	r2, [r3]
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
300172d0:	e59d3014 	ldr	r3, [sp, #20]
300172d4:	e5933000 	ldr	r3, [r3]
300172d8:	e3530000 	cmp	r3, #0
300172dc:	0a000008 	beq	30017304 <sys_untimeout+0xdc>
        t->next->time += t->time;
300172e0:	e59d3014 	ldr	r3, [sp, #20]
300172e4:	e5933000 	ldr	r3, [r3]
300172e8:	e59d2014 	ldr	r2, [sp, #20]
300172ec:	e5922000 	ldr	r2, [r2]
300172f0:	e5921004 	ldr	r1, [r2, #4]
300172f4:	e59d2014 	ldr	r2, [sp, #20]
300172f8:	e5922004 	ldr	r2, [r2, #4]
300172fc:	e0812002 	add	r2, r1, r2
30017300:	e5832004 	str	r2, [r3, #4]
      memp_free(MEMP_SYS_TIMEOUT, t);
30017304:	e3a0000a 	mov	r0, #10
30017308:	e59d1014 	ldr	r1, [sp, #20]
3001730c:	ebfff86d 	bl	300154c8 <memp_free>
      return;
30017310:	ea00000b 	b	30017344 <sys_untimeout+0x11c>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
30017314:	e59d3014 	ldr	r3, [sp, #20]
30017318:	e58d3010 	str	r3, [sp, #16]
3001731c:	e59d3014 	ldr	r3, [sp, #20]
30017320:	e5933000 	ldr	r3, [r3]
30017324:	e58d3014 	str	r3, [sp, #20]
30017328:	e59d3014 	ldr	r3, [sp, #20]
3001732c:	e3530000 	cmp	r3, #0
30017330:	1affffd0 	bne	30017278 <sys_untimeout+0x50>
        t->next->time += t->time;
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
30017334:	ea000002 	b	30017344 <sys_untimeout+0x11c>

  timeouts = sys_arch_timeouts();

  if (timeouts == NULL) {
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
    return;
30017338:	e1a00000 	nop			; (mov r0, r0)
3001733c:	ea000000 	b	30017344 <sys_untimeout+0x11c>
  }
  if (timeouts->next == NULL) {
    return;
30017340:	e1a00000 	nop			; (mov r0, r0)
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
30017344:	e28dd01c 	add	sp, sp, #28
30017348:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001734c:	e12fff1e 	bx	lr

30017350 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
30017350:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30017354:	e24dd014 	sub	sp, sp, #20
30017358:	e58d0004 	str	r0, [sp, #4]
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;
3001735c:	e59d3004 	ldr	r3, [sp, #4]
30017360:	e58d300c 	str	r3, [sp, #12]

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
30017364:	e59d300c 	ldr	r3, [sp, #12]
30017368:	e3a02001 	mov	r2, #1
3001736c:	e1c320b0 	strh	r2, [r3]
  sys_sem_signal(*(sswt_cb->psem));
30017370:	e59d300c 	ldr	r3, [sp, #12]
30017374:	e5933004 	ldr	r3, [r3, #4]
30017378:	e5933000 	ldr	r3, [r3]
3001737c:	e1a00003 	mov	r0, r3
30017380:	ebffd568 	bl	3000c928 <sys_sem_signal>
}
30017384:	e28dd014 	add	sp, sp, #20
30017388:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001738c:	e12fff1e 	bx	lr

30017390 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
30017390:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30017394:	e24dd014 	sub	sp, sp, #20
30017398:	e58d0004 	str	r0, [sp, #4]
3001739c:	e58d1000 	str	r1, [sp]
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
300173a0:	e28d3004 	add	r3, sp, #4
300173a4:	e58d300c 	str	r3, [sp, #12]
  sswt_cb.timeflag = 0;
300173a8:	e3a03000 	mov	r3, #0
300173ac:	e1cd30b8 	strh	r3, [sp, #8]

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
300173b0:	e59d3000 	ldr	r3, [sp]
300173b4:	e3530000 	cmp	r3, #0
300173b8:	0a000004 	beq	300173d0 <sys_sem_wait_timeout+0x40>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
300173bc:	e28d3008 	add	r3, sp, #8
300173c0:	e59d0000 	ldr	r0, [sp]
300173c4:	e59f1048 	ldr	r1, [pc, #72]	; 30017414 <sys_sem_wait_timeout+0x84>
300173c8:	e1a02003 	mov	r2, r3
300173cc:	ebffff21 	bl	30017058 <sys_timeout>
  }
  sys_sem_wait(sem);
300173d0:	e59d3004 	ldr	r3, [sp, #4]
300173d4:	e1a00003 	mov	r0, r3
300173d8:	ebfffeca 	bl	30016f08 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
300173dc:	e1dd30b8 	ldrh	r3, [sp, #8]
300173e0:	e3530000 	cmp	r3, #0
300173e4:	0a000001 	beq	300173f0 <sys_sem_wait_timeout+0x60>
    /* timeout */
    return 0;
300173e8:	e3a03000 	mov	r3, #0
300173ec:	ea000004 	b	30017404 <sys_sem_wait_timeout+0x74>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
300173f0:	e28d3008 	add	r3, sp, #8
300173f4:	e59f0018 	ldr	r0, [pc, #24]	; 30017414 <sys_sem_wait_timeout+0x84>
300173f8:	e1a01003 	mov	r1, r3
300173fc:	ebffff89 	bl	30017228 <sys_untimeout>
    return 1;
30017400:	e3a03001 	mov	r3, #1
  }
}
30017404:	e1a00003 	mov	r0, r3
30017408:	e28dd014 	add	sp, sp, #20
3001740c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30017410:	e12fff1e 	bx	lr
30017414:	30017350 	.word	0x30017350

30017418 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
30017418:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001741c:	e24dd014 	sub	sp, sp, #20
30017420:	e58d0004 	str	r0, [sp, #4]
  sys_sem_t delaysem = sys_sem_new(0);
30017424:	e3a00000 	mov	r0, #0
30017428:	ebffd529 	bl	3000c8d4 <sys_sem_new>
3001742c:	e1a03000 	mov	r3, r0
30017430:	e58d300c 	str	r3, [sp, #12]

  sys_sem_wait_timeout(delaysem, ms);
30017434:	e59d000c 	ldr	r0, [sp, #12]
30017438:	e59d1004 	ldr	r1, [sp, #4]
3001743c:	ebffffd3 	bl	30017390 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
30017440:	e59d000c 	ldr	r0, [sp, #12]
30017444:	ebffd52e 	bl	3000c904 <sys_sem_free>
}
30017448:	e28dd014 	add	sp, sp, #20
3001744c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30017450:	e12fff1e 	bx	lr

30017454 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
30017454:	e92d4008 	push	{r3, lr}
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
30017458:	eb0005be 	bl	30018b58 <tcp_fasttmr>

  if (++tcp_timer & 1) {
3001745c:	e59f3034 	ldr	r3, [pc, #52]	; 30017498 <tcp_tmr+0x44>
30017460:	e5d33000 	ldrb	r3, [r3]
30017464:	e2833001 	add	r3, r3, #1
30017468:	e20320ff 	and	r2, r3, #255	; 0xff
3001746c:	e59f3024 	ldr	r3, [pc, #36]	; 30017498 <tcp_tmr+0x44>
30017470:	e5c32000 	strb	r2, [r3]
30017474:	e59f301c 	ldr	r3, [pc, #28]	; 30017498 <tcp_tmr+0x44>
30017478:	e5d33000 	ldrb	r3, [r3]
3001747c:	e2033001 	and	r3, r3, #1
30017480:	e20330ff 	and	r3, r3, #255	; 0xff
30017484:	e3530000 	cmp	r3, #0
30017488:	0a000000 	beq	30017490 <tcp_tmr+0x3c>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
3001748c:	eb0003fc 	bl	30018484 <tcp_slowtmr>
  }
}
30017490:	e8bd4008 	pop	{r3, lr}
30017494:	e12fff1e 	bx	lr
30017498:	300dbb98 	.word	0x300dbb98

3001749c <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
3001749c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300174a0:	e24dd014 	sub	sp, sp, #20
300174a4:	e58d0004 	str	r0, [sp, #4]
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
300174a8:	e59d3004 	ldr	r3, [sp, #4]
300174ac:	e5d33010 	ldrb	r3, [r3, #16]
300174b0:	e3530007 	cmp	r3, #7
300174b4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
300174b8:	ea000079 	b	300176a4 <tcp_close+0x208>
300174bc:	300174dc 	.word	0x300174dc
300174c0:	300175b0 	.word	0x300175b0
300174c4:	300175dc 	.word	0x300175dc
300174c8:	30017608 	.word	0x30017608
300174cc:	3001763c 	.word	0x3001763c
300174d0:	300176a4 	.word	0x300176a4
300174d4:	300176a4 	.word	0x300176a4
300174d8:	30017670 	.word	0x30017670
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
300174dc:	e3a03000 	mov	r3, #0
300174e0:	e5cd300f 	strb	r3, [sp, #15]
    TCP_RMV(&tcp_bound_pcbs, pcb);
300174e4:	e59f321c 	ldr	r3, [pc, #540]	; 30017708 <tcp_close+0x26c>
300174e8:	e5932000 	ldr	r2, [r3]
300174ec:	e59d3004 	ldr	r3, [sp, #4]
300174f0:	e1520003 	cmp	r2, r3
300174f4:	1a000005 	bne	30017510 <tcp_close+0x74>
300174f8:	e59f3208 	ldr	r3, [pc, #520]	; 30017708 <tcp_close+0x26c>
300174fc:	e5933000 	ldr	r3, [r3]
30017500:	e593200c 	ldr	r2, [r3, #12]
30017504:	e59f31fc 	ldr	r3, [pc, #508]	; 30017708 <tcp_close+0x26c>
30017508:	e5832000 	str	r2, [r3]
3001750c:	ea00001e 	b	3001758c <tcp_close+0xf0>
30017510:	e59f31f0 	ldr	r3, [pc, #496]	; 30017708 <tcp_close+0x26c>
30017514:	e5932000 	ldr	r2, [r3]
30017518:	e59f31ec 	ldr	r3, [pc, #492]	; 3001770c <tcp_close+0x270>
3001751c:	e5832000 	str	r2, [r3]
30017520:	ea000015 	b	3001757c <tcp_close+0xe0>
30017524:	e59f31e0 	ldr	r3, [pc, #480]	; 3001770c <tcp_close+0x270>
30017528:	e5933000 	ldr	r3, [r3]
3001752c:	e593300c 	ldr	r3, [r3, #12]
30017530:	e3530000 	cmp	r3, #0
30017534:	0a00000b 	beq	30017568 <tcp_close+0xcc>
30017538:	e59f31cc 	ldr	r3, [pc, #460]	; 3001770c <tcp_close+0x270>
3001753c:	e5933000 	ldr	r3, [r3]
30017540:	e593200c 	ldr	r2, [r3, #12]
30017544:	e59d3004 	ldr	r3, [sp, #4]
30017548:	e1520003 	cmp	r2, r3
3001754c:	1a000005 	bne	30017568 <tcp_close+0xcc>
30017550:	e59f31b4 	ldr	r3, [pc, #436]	; 3001770c <tcp_close+0x270>
30017554:	e5933000 	ldr	r3, [r3]
30017558:	e59d2004 	ldr	r2, [sp, #4]
3001755c:	e592200c 	ldr	r2, [r2, #12]
30017560:	e583200c 	str	r2, [r3, #12]
30017564:	ea000008 	b	3001758c <tcp_close+0xf0>
30017568:	e59f319c 	ldr	r3, [pc, #412]	; 3001770c <tcp_close+0x270>
3001756c:	e5933000 	ldr	r3, [r3]
30017570:	e593200c 	ldr	r2, [r3, #12]
30017574:	e59f3190 	ldr	r3, [pc, #400]	; 3001770c <tcp_close+0x270>
30017578:	e5832000 	str	r2, [r3]
3001757c:	e59f3188 	ldr	r3, [pc, #392]	; 3001770c <tcp_close+0x270>
30017580:	e5933000 	ldr	r3, [r3]
30017584:	e3530000 	cmp	r3, #0
30017588:	1affffe5 	bne	30017524 <tcp_close+0x88>
3001758c:	e59d3004 	ldr	r3, [sp, #4]
30017590:	e3a02000 	mov	r2, #0
30017594:	e583200c 	str	r2, [r3, #12]
    memp_free(MEMP_TCP_PCB, pcb);
30017598:	e3a00002 	mov	r0, #2
3001759c:	e59d1004 	ldr	r1, [sp, #4]
300175a0:	ebfff7c8 	bl	300154c8 <memp_free>
    pcb = NULL;
300175a4:	e3a03000 	mov	r3, #0
300175a8:	e58d3004 	str	r3, [sp, #4]
    break;
300175ac:	ea000046 	b	300176cc <tcp_close+0x230>
  case LISTEN:
    err = ERR_OK;
300175b0:	e3a03000 	mov	r3, #0
300175b4:	e5cd300f 	strb	r3, [sp, #15]
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
300175b8:	e59f0150 	ldr	r0, [pc, #336]	; 30017710 <tcp_close+0x274>
300175bc:	e59d1004 	ldr	r1, [sp, #4]
300175c0:	eb00076a 	bl	30019370 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
300175c4:	e3a00003 	mov	r0, #3
300175c8:	e59d1004 	ldr	r1, [sp, #4]
300175cc:	ebfff7bd 	bl	300154c8 <memp_free>
    pcb = NULL;
300175d0:	e3a03000 	mov	r3, #0
300175d4:	e58d3004 	str	r3, [sp, #4]
    break;
300175d8:	ea00003b 	b	300176cc <tcp_close+0x230>
  case SYN_SENT:
    err = ERR_OK;
300175dc:	e3a03000 	mov	r3, #0
300175e0:	e5cd300f 	strb	r3, [sp, #15]
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
300175e4:	e59f0128 	ldr	r0, [pc, #296]	; 30017714 <tcp_close+0x278>
300175e8:	e59d1004 	ldr	r1, [sp, #4]
300175ec:	eb00075f 	bl	30019370 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
300175f0:	e3a00002 	mov	r0, #2
300175f4:	e59d1004 	ldr	r1, [sp, #4]
300175f8:	ebfff7b2 	bl	300154c8 <memp_free>
    pcb = NULL;
300175fc:	e3a03000 	mov	r3, #0
30017600:	e58d3004 	str	r3, [sp, #4]
    snmp_inc_tcpattemptfails();
    break;
30017604:	ea000030 	b	300176cc <tcp_close+0x230>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
30017608:	e59d0004 	ldr	r0, [sp, #4]
3001760c:	e3a01001 	mov	r1, #1
30017610:	eb0017d7 	bl	3001d574 <tcp_send_ctrl>
30017614:	e1a03000 	mov	r3, r0
30017618:	e20330ff 	and	r3, r3, #255	; 0xff
3001761c:	e5cd300f 	strb	r3, [sp, #15]
    if (err == ERR_OK) {
30017620:	e1dd30df 	ldrsb	r3, [sp, #15]
30017624:	e3530000 	cmp	r3, #0
30017628:	1a000022 	bne	300176b8 <tcp_close+0x21c>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
3001762c:	e59d3004 	ldr	r3, [sp, #4]
30017630:	e3a02005 	mov	r2, #5
30017634:	e5c32010 	strb	r2, [r3, #16]
    }
    break;
30017638:	ea000023 	b	300176cc <tcp_close+0x230>
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
3001763c:	e59d0004 	ldr	r0, [sp, #4]
30017640:	e3a01001 	mov	r1, #1
30017644:	eb0017ca 	bl	3001d574 <tcp_send_ctrl>
30017648:	e1a03000 	mov	r3, r0
3001764c:	e20330ff 	and	r3, r3, #255	; 0xff
30017650:	e5cd300f 	strb	r3, [sp, #15]
    if (err == ERR_OK) {
30017654:	e1dd30df 	ldrsb	r3, [sp, #15]
30017658:	e3530000 	cmp	r3, #0
3001765c:	1a000017 	bne	300176c0 <tcp_close+0x224>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
30017660:	e59d3004 	ldr	r3, [sp, #4]
30017664:	e3a02005 	mov	r2, #5
30017668:	e5c32010 	strb	r2, [r3, #16]
    }
    break;
3001766c:	ea000016 	b	300176cc <tcp_close+0x230>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
30017670:	e59d0004 	ldr	r0, [sp, #4]
30017674:	e3a01001 	mov	r1, #1
30017678:	eb0017bd 	bl	3001d574 <tcp_send_ctrl>
3001767c:	e1a03000 	mov	r3, r0
30017680:	e20330ff 	and	r3, r3, #255	; 0xff
30017684:	e5cd300f 	strb	r3, [sp, #15]
    if (err == ERR_OK) {
30017688:	e1dd30df 	ldrsb	r3, [sp, #15]
3001768c:	e3530000 	cmp	r3, #0
30017690:	1a00000c 	bne	300176c8 <tcp_close+0x22c>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
30017694:	e59d3004 	ldr	r3, [sp, #4]
30017698:	e3a02009 	mov	r2, #9
3001769c:	e5c32010 	strb	r2, [r3, #16]
    }
    break;
300176a0:	ea000009 	b	300176cc <tcp_close+0x230>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
300176a4:	e3a03000 	mov	r3, #0
300176a8:	e5cd300f 	strb	r3, [sp, #15]
    pcb = NULL;
300176ac:	e3a03000 	mov	r3, #0
300176b0:	e58d3004 	str	r3, [sp, #4]
300176b4:	ea000004 	b	300176cc <tcp_close+0x230>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
300176b8:	e1a00000 	nop			; (mov r0, r0)
300176bc:	ea000002 	b	300176cc <tcp_close+0x230>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
300176c0:	e1a00000 	nop			; (mov r0, r0)
300176c4:	ea000000 	b	300176cc <tcp_close+0x230>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    }
    break;
300176c8:	e1a00000 	nop			; (mov r0, r0)
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
300176cc:	e59d3004 	ldr	r3, [sp, #4]
300176d0:	e3530000 	cmp	r3, #0
300176d4:	0a000004 	beq	300176ec <tcp_close+0x250>
300176d8:	e1dd30df 	ldrsb	r3, [sp, #15]
300176dc:	e3530000 	cmp	r3, #0
300176e0:	1a000001 	bne	300176ec <tcp_close+0x250>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
300176e4:	e59d0004 	ldr	r0, [sp, #4]
300176e8:	eb001a39 	bl	3001dfd4 <tcp_output>
  }
  return err;
300176ec:	e5dd300f 	ldrb	r3, [sp, #15]
300176f0:	e1a03c03 	lsl	r3, r3, #24
300176f4:	e1a03c43 	asr	r3, r3, #24
}
300176f8:	e1a00003 	mov	r0, r3
300176fc:	e28dd014 	add	sp, sp, #20
30017700:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30017704:	e12fff1e 	bx	lr
30017708:	3012d684 	.word	0x3012d684
3001770c:	3012a850 	.word	0x3012a850
30017710:	300eaa78 	.word	0x300eaa78
30017714:	300eaa38 	.word	0x300eaa38

30017718 <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
30017718:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001771c:	e24dd034 	sub	sp, sp, #52	; 0x34
30017720:	e58d000c 	str	r0, [sp, #12]

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
30017724:	e59d300c 	ldr	r3, [sp, #12]
30017728:	e5d33010 	ldrb	r3, [r3, #16]
3001772c:	e353000a 	cmp	r3, #10
30017730:	1a000006 	bne	30017750 <tcp_abort+0x38>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
30017734:	e59f0168 	ldr	r0, [pc, #360]	; 300178a4 <tcp_abort+0x18c>
30017738:	e59d100c 	ldr	r1, [sp, #12]
3001773c:	eb00070b 	bl	30019370 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
30017740:	e3a00002 	mov	r0, #2
30017744:	e59d100c 	ldr	r1, [sp, #12]
30017748:	ebfff75e 	bl	300154c8 <memp_free>
3001774c:	ea000051 	b	30017898 <tcp_abort+0x180>
  } else {
    seqno = pcb->snd_nxt;
30017750:	e59d300c 	ldr	r3, [sp, #12]
30017754:	e5933050 	ldr	r3, [r3, #80]	; 0x50
30017758:	e58d301c 	str	r3, [sp, #28]
    ackno = pcb->rcv_nxt;
3001775c:	e59d300c 	ldr	r3, [sp, #12]
30017760:	e5933020 	ldr	r3, [r3, #32]
30017764:	e58d3020 	str	r3, [sp, #32]
    ip_addr_set(&local_ip, &(pcb->local_ip));
30017768:	e59d300c 	ldr	r3, [sp, #12]
3001776c:	e3530000 	cmp	r3, #0
30017770:	0a000002 	beq	30017780 <tcp_abort+0x68>
30017774:	e59d300c 	ldr	r3, [sp, #12]
30017778:	e5933000 	ldr	r3, [r3]
3001777c:	ea000000 	b	30017784 <tcp_abort+0x6c>
30017780:	e3a03000 	mov	r3, #0
30017784:	e58d3014 	str	r3, [sp, #20]
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
30017788:	e59d300c 	ldr	r3, [sp, #12]
3001778c:	e2833004 	add	r3, r3, #4
30017790:	e3530000 	cmp	r3, #0
30017794:	0a000002 	beq	300177a4 <tcp_abort+0x8c>
30017798:	e59d300c 	ldr	r3, [sp, #12]
3001779c:	e5933004 	ldr	r3, [r3, #4]
300177a0:	ea000000 	b	300177a8 <tcp_abort+0x90>
300177a4:	e3a03000 	mov	r3, #0
300177a8:	e58d3018 	str	r3, [sp, #24]
    local_port = pcb->local_port;
300177ac:	e59d300c 	ldr	r3, [sp, #12]
300177b0:	e1d331b8 	ldrh	r3, [r3, #24]
300177b4:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
    remote_port = pcb->remote_port;
300177b8:	e59d300c 	ldr	r3, [sp, #12]
300177bc:	e1d331ba 	ldrh	r3, [r3, #26]
300177c0:	e1cd32b4 	strh	r3, [sp, #36]	; 0x24
#if LWIP_CALLBACK_API
    errf = pcb->errf;
300177c4:	e59d300c 	ldr	r3, [sp, #12]
300177c8:	e5933094 	ldr	r3, [r3, #148]	; 0x94
300177cc:	e58d3028 	str	r3, [sp, #40]	; 0x28
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
300177d0:	e59d300c 	ldr	r3, [sp, #12]
300177d4:	e5933014 	ldr	r3, [r3, #20]
300177d8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
300177dc:	e59f00c4 	ldr	r0, [pc, #196]	; 300178a8 <tcp_abort+0x190>
300177e0:	e59d100c 	ldr	r1, [sp, #12]
300177e4:	eb0006e1 	bl	30019370 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
300177e8:	e59d300c 	ldr	r3, [sp, #12]
300177ec:	e5933074 	ldr	r3, [r3, #116]	; 0x74
300177f0:	e3530000 	cmp	r3, #0
300177f4:	0a000003 	beq	30017808 <tcp_abort+0xf0>
      tcp_segs_free(pcb->unacked);
300177f8:	e59d300c 	ldr	r3, [sp, #12]
300177fc:	e5933074 	ldr	r3, [r3, #116]	; 0x74
30017800:	e1a00003 	mov	r0, r3
30017804:	eb00051e 	bl	30018c84 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
30017808:	e59d300c 	ldr	r3, [sp, #12]
3001780c:	e5933070 	ldr	r3, [r3, #112]	; 0x70
30017810:	e3530000 	cmp	r3, #0
30017814:	0a000003 	beq	30017828 <tcp_abort+0x110>
      tcp_segs_free(pcb->unsent);
30017818:	e59d300c 	ldr	r3, [sp, #12]
3001781c:	e5933070 	ldr	r3, [r3, #112]	; 0x70
30017820:	e1a00003 	mov	r0, r3
30017824:	eb000516 	bl	30018c84 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
30017828:	e59d300c 	ldr	r3, [sp, #12]
3001782c:	e5933078 	ldr	r3, [r3, #120]	; 0x78
30017830:	e3530000 	cmp	r3, #0
30017834:	0a000003 	beq	30017848 <tcp_abort+0x130>
      tcp_segs_free(pcb->ooseq);
30017838:	e59d300c 	ldr	r3, [sp, #12]
3001783c:	e5933078 	ldr	r3, [r3, #120]	; 0x78
30017840:	e1a00003 	mov	r0, r3
30017844:	eb00050e 	bl	30018c84 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
30017848:	e3a00002 	mov	r0, #2
3001784c:	e59d100c 	ldr	r1, [sp, #12]
30017850:	ebfff71c 	bl	300154c8 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
30017854:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30017858:	e3530000 	cmp	r3, #0
3001785c:	0a000004 	beq	30017874 <tcp_abort+0x15c>
30017860:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30017864:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30017868:	e3e01003 	mvn	r1, #3
3001786c:	e1a0e00f 	mov	lr, pc
30017870:	e12fff13 	bx	r3
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
30017874:	e28d2014 	add	r2, sp, #20
30017878:	e28d3018 	add	r3, sp, #24
3001787c:	e1dd12b6 	ldrh	r1, [sp, #38]	; 0x26
30017880:	e58d1000 	str	r1, [sp]
30017884:	e1dd12b4 	ldrh	r1, [sp, #36]	; 0x24
30017888:	e58d1004 	str	r1, [sp, #4]
3001788c:	e59d001c 	ldr	r0, [sp, #28]
30017890:	e59d1020 	ldr	r1, [sp, #32]
30017894:	eb001d05 	bl	3001ecb0 <tcp_rst>
  }
}
30017898:	e28dd034 	add	sp, sp, #52	; 0x34
3001789c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300178a0:	e12fff1e 	bx	lr
300178a4:	302be508 	.word	0x302be508
300178a8:	300eaa38 	.word	0x300eaa38

300178ac <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
300178ac:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300178b0:	e24dd01c 	sub	sp, sp, #28
300178b4:	e58d000c 	str	r0, [sp, #12]
300178b8:	e58d1008 	str	r1, [sp, #8]
300178bc:	e1a03002 	mov	r3, r2
300178c0:	e1cd30b6 	strh	r3, [sp, #6]
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);

  if (port == 0) {
300178c4:	e1dd30b6 	ldrh	r3, [sp, #6]
300178c8:	e3530000 	cmp	r3, #0
300178cc:	1a000002 	bne	300178dc <tcp_bind+0x30>
    port = tcp_new_port();
300178d0:	eb0001e5 	bl	3001806c <tcp_new_port>
300178d4:	e1a03000 	mov	r3, r0
300178d8:	e1cd30b6 	strh	r3, [sp, #6]
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
300178dc:	e59f33cc 	ldr	r3, [pc, #972]	; 30017cb0 <tcp_bind+0x404>
300178e0:	e5933000 	ldr	r3, [r3]
300178e4:	e58d3014 	str	r3, [sp, #20]
300178e8:	ea00002f 	b	300179ac <tcp_bind+0x100>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
300178ec:	e59d3014 	ldr	r3, [sp, #20]
300178f0:	e1d331b8 	ldrh	r3, [r3, #24]
300178f4:	e1dd20b6 	ldrh	r2, [sp, #6]
300178f8:	e1520003 	cmp	r2, r3
300178fc:	1a000027 	bne	300179a0 <tcp_bind+0xf4>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017900:	e59d3014 	ldr	r3, [sp, #20]
30017904:	e3530000 	cmp	r3, #0
30017908:	0a000022 	beq	30017998 <tcp_bind+0xec>
3001790c:	e59d3014 	ldr	r3, [sp, #20]
30017910:	e5933000 	ldr	r3, [r3]
30017914:	e3530000 	cmp	r3, #0
30017918:	0a00001e 	beq	30017998 <tcp_bind+0xec>
3001791c:	e59d3008 	ldr	r3, [sp, #8]
30017920:	e3530000 	cmp	r3, #0
30017924:	0a00001b 	beq	30017998 <tcp_bind+0xec>
          ip_addr_isany(ipaddr) ||
30017928:	e59d3008 	ldr	r3, [sp, #8]
3001792c:	e5d32000 	ldrb	r2, [r3]
30017930:	e5d31001 	ldrb	r1, [r3, #1]
30017934:	e1a01401 	lsl	r1, r1, #8
30017938:	e1812002 	orr	r2, r1, r2
3001793c:	e5d31002 	ldrb	r1, [r3, #2]
30017940:	e1a01801 	lsl	r1, r1, #16
30017944:	e1812002 	orr	r2, r1, r2
30017948:	e5d33003 	ldrb	r3, [r3, #3]
3001794c:	e1a03c03 	lsl	r3, r3, #24
30017950:	e1833002 	orr	r3, r3, r2
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017954:	e3530000 	cmp	r3, #0
30017958:	0a00000e 	beq	30017998 <tcp_bind+0xec>
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
3001795c:	e59d3014 	ldr	r3, [sp, #20]
30017960:	e5932000 	ldr	r2, [r3]
30017964:	e59d3008 	ldr	r3, [sp, #8]
30017968:	e5d31000 	ldrb	r1, [r3]
3001796c:	e5d30001 	ldrb	r0, [r3, #1]
30017970:	e1a00400 	lsl	r0, r0, #8
30017974:	e1801001 	orr	r1, r0, r1
30017978:	e5d30002 	ldrb	r0, [r3, #2]
3001797c:	e1a00800 	lsl	r0, r0, #16
30017980:	e1801001 	orr	r1, r0, r1
30017984:	e5d33003 	ldrb	r3, [r3, #3]
30017988:	e1a03c03 	lsl	r3, r3, #24
3001798c:	e1833001 	orr	r3, r3, r1
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017990:	e1520003 	cmp	r2, r3
30017994:	1a000001 	bne	300179a0 <tcp_bind+0xf4>
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
30017998:	e3a030f6 	mov	r3, #246	; 0xf6
3001799c:	ea0000bd 	b	30017c98 <tcp_bind+0x3ec>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
300179a0:	e59d3014 	ldr	r3, [sp, #20]
300179a4:	e593300c 	ldr	r3, [r3, #12]
300179a8:	e58d3014 	str	r3, [sp, #20]
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
300179ac:	e59d3014 	ldr	r3, [sp, #20]
300179b0:	e3530000 	cmp	r3, #0
300179b4:	1affffcc 	bne	300178ec <tcp_bind+0x40>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
300179b8:	e59f32f4 	ldr	r3, [pc, #756]	; 30017cb4 <tcp_bind+0x408>
300179bc:	e5933000 	ldr	r3, [r3]
300179c0:	e58d3014 	str	r3, [sp, #20]
300179c4:	ea00002f 	b	30017a88 <tcp_bind+0x1dc>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
300179c8:	e59d3014 	ldr	r3, [sp, #20]
300179cc:	e1d331b8 	ldrh	r3, [r3, #24]
300179d0:	e1dd20b6 	ldrh	r2, [sp, #6]
300179d4:	e1520003 	cmp	r2, r3
300179d8:	1a000027 	bne	30017a7c <tcp_bind+0x1d0>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
300179dc:	e59d3014 	ldr	r3, [sp, #20]
300179e0:	e3530000 	cmp	r3, #0
300179e4:	0a000022 	beq	30017a74 <tcp_bind+0x1c8>
300179e8:	e59d3014 	ldr	r3, [sp, #20]
300179ec:	e5933000 	ldr	r3, [r3]
300179f0:	e3530000 	cmp	r3, #0
300179f4:	0a00001e 	beq	30017a74 <tcp_bind+0x1c8>
300179f8:	e59d3008 	ldr	r3, [sp, #8]
300179fc:	e3530000 	cmp	r3, #0
30017a00:	0a00001b 	beq	30017a74 <tcp_bind+0x1c8>
          ip_addr_isany(ipaddr) ||
30017a04:	e59d3008 	ldr	r3, [sp, #8]
30017a08:	e5d32000 	ldrb	r2, [r3]
30017a0c:	e5d31001 	ldrb	r1, [r3, #1]
30017a10:	e1a01401 	lsl	r1, r1, #8
30017a14:	e1812002 	orr	r2, r1, r2
30017a18:	e5d31002 	ldrb	r1, [r3, #2]
30017a1c:	e1a01801 	lsl	r1, r1, #16
30017a20:	e1812002 	orr	r2, r1, r2
30017a24:	e5d33003 	ldrb	r3, [r3, #3]
30017a28:	e1a03c03 	lsl	r3, r3, #24
30017a2c:	e1833002 	orr	r3, r3, r2
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017a30:	e3530000 	cmp	r3, #0
30017a34:	0a00000e 	beq	30017a74 <tcp_bind+0x1c8>
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
30017a38:	e59d3014 	ldr	r3, [sp, #20]
30017a3c:	e5932000 	ldr	r2, [r3]
30017a40:	e59d3008 	ldr	r3, [sp, #8]
30017a44:	e5d31000 	ldrb	r1, [r3]
30017a48:	e5d30001 	ldrb	r0, [r3, #1]
30017a4c:	e1a00400 	lsl	r0, r0, #8
30017a50:	e1801001 	orr	r1, r0, r1
30017a54:	e5d30002 	ldrb	r0, [r3, #2]
30017a58:	e1a00800 	lsl	r0, r0, #16
30017a5c:	e1801001 	orr	r1, r0, r1
30017a60:	e5d33003 	ldrb	r3, [r3, #3]
30017a64:	e1a03c03 	lsl	r3, r3, #24
30017a68:	e1833001 	orr	r3, r3, r1
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017a6c:	e1520003 	cmp	r2, r3
30017a70:	1a000001 	bne	30017a7c <tcp_bind+0x1d0>
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
30017a74:	e3a030f6 	mov	r3, #246	; 0xf6
30017a78:	ea000086 	b	30017c98 <tcp_bind+0x3ec>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
30017a7c:	e59d3014 	ldr	r3, [sp, #20]
30017a80:	e593300c 	ldr	r3, [r3, #12]
30017a84:	e58d3014 	str	r3, [sp, #20]
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
30017a88:	e59d3014 	ldr	r3, [sp, #20]
30017a8c:	e3530000 	cmp	r3, #0
30017a90:	1affffcc 	bne	300179c8 <tcp_bind+0x11c>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
30017a94:	e59f321c 	ldr	r3, [pc, #540]	; 30017cb8 <tcp_bind+0x40c>
30017a98:	e5933000 	ldr	r3, [r3]
30017a9c:	e58d3014 	str	r3, [sp, #20]
30017aa0:	ea00002f 	b	30017b64 <tcp_bind+0x2b8>
    if (cpcb->local_port == port) {
30017aa4:	e59d3014 	ldr	r3, [sp, #20]
30017aa8:	e1d331b8 	ldrh	r3, [r3, #24]
30017aac:	e1dd20b6 	ldrh	r2, [sp, #6]
30017ab0:	e1520003 	cmp	r2, r3
30017ab4:	1a000027 	bne	30017b58 <tcp_bind+0x2ac>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017ab8:	e59d3014 	ldr	r3, [sp, #20]
30017abc:	e3530000 	cmp	r3, #0
30017ac0:	0a000022 	beq	30017b50 <tcp_bind+0x2a4>
30017ac4:	e59d3014 	ldr	r3, [sp, #20]
30017ac8:	e5933000 	ldr	r3, [r3]
30017acc:	e3530000 	cmp	r3, #0
30017ad0:	0a00001e 	beq	30017b50 <tcp_bind+0x2a4>
30017ad4:	e59d3008 	ldr	r3, [sp, #8]
30017ad8:	e3530000 	cmp	r3, #0
30017adc:	0a00001b 	beq	30017b50 <tcp_bind+0x2a4>
          ip_addr_isany(ipaddr) ||
30017ae0:	e59d3008 	ldr	r3, [sp, #8]
30017ae4:	e5d32000 	ldrb	r2, [r3]
30017ae8:	e5d31001 	ldrb	r1, [r3, #1]
30017aec:	e1a01401 	lsl	r1, r1, #8
30017af0:	e1812002 	orr	r2, r1, r2
30017af4:	e5d31002 	ldrb	r1, [r3, #2]
30017af8:	e1a01801 	lsl	r1, r1, #16
30017afc:	e1812002 	orr	r2, r1, r2
30017b00:	e5d33003 	ldrb	r3, [r3, #3]
30017b04:	e1a03c03 	lsl	r3, r3, #24
30017b08:	e1833002 	orr	r3, r3, r2
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017b0c:	e3530000 	cmp	r3, #0
30017b10:	0a00000e 	beq	30017b50 <tcp_bind+0x2a4>
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
30017b14:	e59d3014 	ldr	r3, [sp, #20]
30017b18:	e5932000 	ldr	r2, [r3]
30017b1c:	e59d3008 	ldr	r3, [sp, #8]
30017b20:	e5d31000 	ldrb	r1, [r3]
30017b24:	e5d30001 	ldrb	r0, [r3, #1]
30017b28:	e1a00400 	lsl	r0, r0, #8
30017b2c:	e1801001 	orr	r1, r0, r1
30017b30:	e5d30002 	ldrb	r0, [r3, #2]
30017b34:	e1a00800 	lsl	r0, r0, #16
30017b38:	e1801001 	orr	r1, r0, r1
30017b3c:	e5d33003 	ldrb	r3, [r3, #3]
30017b40:	e1a03c03 	lsl	r3, r3, #24
30017b44:	e1833001 	orr	r3, r3, r1
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
30017b48:	e1520003 	cmp	r2, r3
30017b4c:	1a000001 	bne	30017b58 <tcp_bind+0x2ac>
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
30017b50:	e3a030f6 	mov	r3, #246	; 0xf6
30017b54:	ea00004f 	b	30017c98 <tcp_bind+0x3ec>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
30017b58:	e59d3014 	ldr	r3, [sp, #20]
30017b5c:	e593300c 	ldr	r3, [r3, #12]
30017b60:	e58d3014 	str	r3, [sp, #20]
30017b64:	e59d3014 	ldr	r3, [sp, #20]
30017b68:	e3530000 	cmp	r3, #0
30017b6c:	1affffcc 	bne	30017aa4 <tcp_bind+0x1f8>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
30017b70:	e59f3144 	ldr	r3, [pc, #324]	; 30017cbc <tcp_bind+0x410>
30017b74:	e5933000 	ldr	r3, [r3]
30017b78:	e58d3014 	str	r3, [sp, #20]
30017b7c:	ea000018 	b	30017be4 <tcp_bind+0x338>
    if (cpcb->local_port == port) {
30017b80:	e59d3014 	ldr	r3, [sp, #20]
30017b84:	e1d331b8 	ldrh	r3, [r3, #24]
30017b88:	e1dd20b6 	ldrh	r2, [sp, #6]
30017b8c:	e1520003 	cmp	r2, r3
30017b90:	1a000010 	bne	30017bd8 <tcp_bind+0x32c>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
30017b94:	e59d3014 	ldr	r3, [sp, #20]
30017b98:	e5932000 	ldr	r2, [r3]
30017b9c:	e59d3008 	ldr	r3, [sp, #8]
30017ba0:	e5d31000 	ldrb	r1, [r3]
30017ba4:	e5d30001 	ldrb	r0, [r3, #1]
30017ba8:	e1a00400 	lsl	r0, r0, #8
30017bac:	e1801001 	orr	r1, r0, r1
30017bb0:	e5d30002 	ldrb	r0, [r3, #2]
30017bb4:	e1a00800 	lsl	r0, r0, #16
30017bb8:	e1801001 	orr	r1, r0, r1
30017bbc:	e5d33003 	ldrb	r3, [r3, #3]
30017bc0:	e1a03c03 	lsl	r3, r3, #24
30017bc4:	e1833001 	orr	r3, r3, r1
30017bc8:	e1520003 	cmp	r2, r3
30017bcc:	1a000001 	bne	30017bd8 <tcp_bind+0x32c>
        return ERR_USE;
30017bd0:	e3a030f6 	mov	r3, #246	; 0xf6
30017bd4:	ea00002f 	b	30017c98 <tcp_bind+0x3ec>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
30017bd8:	e59d3014 	ldr	r3, [sp, #20]
30017bdc:	e593300c 	ldr	r3, [r3, #12]
30017be0:	e58d3014 	str	r3, [sp, #20]
30017be4:	e59d3014 	ldr	r3, [sp, #20]
30017be8:	e3530000 	cmp	r3, #0
30017bec:	1affffe3 	bne	30017b80 <tcp_bind+0x2d4>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
30017bf0:	e59d3008 	ldr	r3, [sp, #8]
30017bf4:	e3530000 	cmp	r3, #0
30017bf8:	0a00001a 	beq	30017c68 <tcp_bind+0x3bc>
30017bfc:	e59d3008 	ldr	r3, [sp, #8]
30017c00:	e5d32000 	ldrb	r2, [r3]
30017c04:	e5d31001 	ldrb	r1, [r3, #1]
30017c08:	e1a01401 	lsl	r1, r1, #8
30017c0c:	e1812002 	orr	r2, r1, r2
30017c10:	e5d31002 	ldrb	r1, [r3, #2]
30017c14:	e1a01801 	lsl	r1, r1, #16
30017c18:	e1812002 	orr	r2, r1, r2
30017c1c:	e5d33003 	ldrb	r3, [r3, #3]
30017c20:	e1a03c03 	lsl	r3, r3, #24
30017c24:	e1833002 	orr	r3, r3, r2
30017c28:	e3530000 	cmp	r3, #0
30017c2c:	0a00000d 	beq	30017c68 <tcp_bind+0x3bc>
    //by pegasus0824
	  //pcb->local_ip = *ipaddr;
    pcb->local_ip.addr = ipaddr->addr;
30017c30:	e59d3008 	ldr	r3, [sp, #8]
30017c34:	e5d32000 	ldrb	r2, [r3]
30017c38:	e5d31001 	ldrb	r1, [r3, #1]
30017c3c:	e1a01401 	lsl	r1, r1, #8
30017c40:	e1812002 	orr	r2, r1, r2
30017c44:	e5d31002 	ldrb	r1, [r3, #2]
30017c48:	e1a01801 	lsl	r1, r1, #16
30017c4c:	e1812002 	orr	r2, r1, r2
30017c50:	e5d33003 	ldrb	r3, [r3, #3]
30017c54:	e1a03c03 	lsl	r3, r3, #24
30017c58:	e1833002 	orr	r3, r3, r2
30017c5c:	e1a02003 	mov	r2, r3
30017c60:	e59d300c 	ldr	r3, [sp, #12]
30017c64:	e5832000 	str	r2, [r3]
  }
  pcb->local_port = port;
30017c68:	e59d300c 	ldr	r3, [sp, #12]
30017c6c:	e1dd20b6 	ldrh	r2, [sp, #6]
30017c70:	e1c321b8 	strh	r2, [r3, #24]
  TCP_REG(&tcp_bound_pcbs, pcb);
30017c74:	e59f303c 	ldr	r3, [pc, #60]	; 30017cb8 <tcp_bind+0x40c>
30017c78:	e5932000 	ldr	r2, [r3]
30017c7c:	e59d300c 	ldr	r3, [sp, #12]
30017c80:	e583200c 	str	r2, [r3, #12]
30017c84:	e59f302c 	ldr	r3, [pc, #44]	; 30017cb8 <tcp_bind+0x40c>
30017c88:	e59d200c 	ldr	r2, [sp, #12]
30017c8c:	e5832000 	str	r2, [r3]
30017c90:	ebffe8f9 	bl	3001207c <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
30017c94:	e3a03000 	mov	r3, #0
30017c98:	e1a03c03 	lsl	r3, r3, #24
30017c9c:	e1a03c43 	asr	r3, r3, #24
}
30017ca0:	e1a00003 	mov	r0, r3
30017ca4:	e28dd01c 	add	sp, sp, #28
30017ca8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30017cac:	e12fff1e 	bx	lr
30017cb0:	300eaa78 	.word	0x300eaa78
30017cb4:	300eaa38 	.word	0x300eaa38
30017cb8:	3012d684 	.word	0x3012d684
30017cbc:	302be508 	.word	0x302be508

30017cc0 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
30017cc0:	e24dd010 	sub	sp, sp, #16
30017cc4:	e58d000c 	str	r0, [sp, #12]
30017cc8:	e58d1008 	str	r1, [sp, #8]
30017ccc:	e1a03002 	mov	r3, r2
30017cd0:	e5cd3007 	strb	r3, [sp, #7]
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
30017cd4:	e3a030fc 	mov	r3, #252	; 0xfc
30017cd8:	e1a03c03 	lsl	r3, r3, #24
30017cdc:	e1a03c43 	asr	r3, r3, #24
}
30017ce0:	e1a00003 	mov	r0, r3
30017ce4:	e28dd010 	add	sp, sp, #16
30017ce8:	e12fff1e 	bx	lr

30017cec <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
30017cec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30017cf0:	e24dd014 	sub	sp, sp, #20
30017cf4:	e58d0004 	str	r0, [sp, #4]
30017cf8:	e1a03001 	mov	r3, r1
30017cfc:	e5cd3003 	strb	r3, [sp, #3]

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);

  /* already listening? */
  if (pcb->state == LISTEN) {
30017d00:	e59d3004 	ldr	r3, [sp, #4]
30017d04:	e5d33010 	ldrb	r3, [r3, #16]
30017d08:	e3530001 	cmp	r3, #1
30017d0c:	1a000001 	bne	30017d18 <tcp_listen_with_backlog+0x2c>
    return pcb;
30017d10:	e59d3004 	ldr	r3, [sp, #4]
30017d14:	ea00006b 	b	30017ec8 <tcp_listen_with_backlog+0x1dc>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
30017d18:	e3a00003 	mov	r0, #3
30017d1c:	ebfff584 	bl	30015334 <memp_malloc>
30017d20:	e1a03000 	mov	r3, r0
30017d24:	e58d300c 	str	r3, [sp, #12]
  if (lpcb == NULL) {
30017d28:	e59d300c 	ldr	r3, [sp, #12]
30017d2c:	e3530000 	cmp	r3, #0
30017d30:	1a000001 	bne	30017d3c <tcp_listen_with_backlog+0x50>
    return NULL;
30017d34:	e3a03000 	mov	r3, #0
30017d38:	ea000062 	b	30017ec8 <tcp_listen_with_backlog+0x1dc>
  }
  lpcb->callback_arg = pcb->callback_arg;
30017d3c:	e59d3004 	ldr	r3, [sp, #4]
30017d40:	e5932014 	ldr	r2, [r3, #20]
30017d44:	e59d300c 	ldr	r3, [sp, #12]
30017d48:	e5832014 	str	r2, [r3, #20]
  lpcb->local_port = pcb->local_port;
30017d4c:	e59d3004 	ldr	r3, [sp, #4]
30017d50:	e1d321b8 	ldrh	r2, [r3, #24]
30017d54:	e59d300c 	ldr	r3, [sp, #12]
30017d58:	e1c321b8 	strh	r2, [r3, #24]
  lpcb->state = LISTEN;
30017d5c:	e59d300c 	ldr	r3, [sp, #12]
30017d60:	e3a02001 	mov	r2, #1
30017d64:	e5c32010 	strb	r2, [r3, #16]
  lpcb->so_options = pcb->so_options;
30017d68:	e59d3004 	ldr	r3, [sp, #4]
30017d6c:	e1d320b8 	ldrh	r2, [r3, #8]
30017d70:	e59d300c 	ldr	r3, [sp, #12]
30017d74:	e1c320b8 	strh	r2, [r3, #8]
  lpcb->so_options |= SOF_ACCEPTCONN;
30017d78:	e59d300c 	ldr	r3, [sp, #12]
30017d7c:	e1d330b8 	ldrh	r3, [r3, #8]
30017d80:	e3833002 	orr	r3, r3, #2
30017d84:	e1a03803 	lsl	r3, r3, #16
30017d88:	e1a02823 	lsr	r2, r3, #16
30017d8c:	e59d300c 	ldr	r3, [sp, #12]
30017d90:	e1c320b8 	strh	r2, [r3, #8]
  lpcb->ttl = pcb->ttl;
30017d94:	e59d3004 	ldr	r3, [sp, #4]
30017d98:	e5d3200b 	ldrb	r2, [r3, #11]
30017d9c:	e59d300c 	ldr	r3, [sp, #12]
30017da0:	e5c3200b 	strb	r2, [r3, #11]
  lpcb->tos = pcb->tos;
30017da4:	e59d3004 	ldr	r3, [sp, #4]
30017da8:	e5d3200a 	ldrb	r2, [r3, #10]
30017dac:	e59d300c 	ldr	r3, [sp, #12]
30017db0:	e5c3200a 	strb	r2, [r3, #10]
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
30017db4:	e59d3004 	ldr	r3, [sp, #4]
30017db8:	e3530000 	cmp	r3, #0
30017dbc:	0a000002 	beq	30017dcc <tcp_listen_with_backlog+0xe0>
30017dc0:	e59d3004 	ldr	r3, [sp, #4]
30017dc4:	e5933000 	ldr	r3, [r3]
30017dc8:	ea000000 	b	30017dd0 <tcp_listen_with_backlog+0xe4>
30017dcc:	e3a03000 	mov	r3, #0
30017dd0:	e59d200c 	ldr	r2, [sp, #12]
30017dd4:	e5823000 	str	r3, [r2]
  TCP_RMV(&tcp_bound_pcbs, pcb);
30017dd8:	e59f30f8 	ldr	r3, [pc, #248]	; 30017ed8 <tcp_listen_with_backlog+0x1ec>
30017ddc:	e5932000 	ldr	r2, [r3]
30017de0:	e59d3004 	ldr	r3, [sp, #4]
30017de4:	e1520003 	cmp	r2, r3
30017de8:	1a000005 	bne	30017e04 <tcp_listen_with_backlog+0x118>
30017dec:	e59f30e4 	ldr	r3, [pc, #228]	; 30017ed8 <tcp_listen_with_backlog+0x1ec>
30017df0:	e5933000 	ldr	r3, [r3]
30017df4:	e593200c 	ldr	r2, [r3, #12]
30017df8:	e59f30d8 	ldr	r3, [pc, #216]	; 30017ed8 <tcp_listen_with_backlog+0x1ec>
30017dfc:	e5832000 	str	r2, [r3]
30017e00:	ea00001e 	b	30017e80 <tcp_listen_with_backlog+0x194>
30017e04:	e59f30cc 	ldr	r3, [pc, #204]	; 30017ed8 <tcp_listen_with_backlog+0x1ec>
30017e08:	e5932000 	ldr	r2, [r3]
30017e0c:	e59f30c8 	ldr	r3, [pc, #200]	; 30017edc <tcp_listen_with_backlog+0x1f0>
30017e10:	e5832000 	str	r2, [r3]
30017e14:	ea000015 	b	30017e70 <tcp_listen_with_backlog+0x184>
30017e18:	e59f30bc 	ldr	r3, [pc, #188]	; 30017edc <tcp_listen_with_backlog+0x1f0>
30017e1c:	e5933000 	ldr	r3, [r3]
30017e20:	e593300c 	ldr	r3, [r3, #12]
30017e24:	e3530000 	cmp	r3, #0
30017e28:	0a00000b 	beq	30017e5c <tcp_listen_with_backlog+0x170>
30017e2c:	e59f30a8 	ldr	r3, [pc, #168]	; 30017edc <tcp_listen_with_backlog+0x1f0>
30017e30:	e5933000 	ldr	r3, [r3]
30017e34:	e593200c 	ldr	r2, [r3, #12]
30017e38:	e59d3004 	ldr	r3, [sp, #4]
30017e3c:	e1520003 	cmp	r2, r3
30017e40:	1a000005 	bne	30017e5c <tcp_listen_with_backlog+0x170>
30017e44:	e59f3090 	ldr	r3, [pc, #144]	; 30017edc <tcp_listen_with_backlog+0x1f0>
30017e48:	e5933000 	ldr	r3, [r3]
30017e4c:	e59d2004 	ldr	r2, [sp, #4]
30017e50:	e592200c 	ldr	r2, [r2, #12]
30017e54:	e583200c 	str	r2, [r3, #12]
30017e58:	ea000008 	b	30017e80 <tcp_listen_with_backlog+0x194>
30017e5c:	e59f3078 	ldr	r3, [pc, #120]	; 30017edc <tcp_listen_with_backlog+0x1f0>
30017e60:	e5933000 	ldr	r3, [r3]
30017e64:	e593200c 	ldr	r2, [r3, #12]
30017e68:	e59f306c 	ldr	r3, [pc, #108]	; 30017edc <tcp_listen_with_backlog+0x1f0>
30017e6c:	e5832000 	str	r2, [r3]
30017e70:	e59f3064 	ldr	r3, [pc, #100]	; 30017edc <tcp_listen_with_backlog+0x1f0>
30017e74:	e5933000 	ldr	r3, [r3]
30017e78:	e3530000 	cmp	r3, #0
30017e7c:	1affffe5 	bne	30017e18 <tcp_listen_with_backlog+0x12c>
30017e80:	e59d3004 	ldr	r3, [sp, #4]
30017e84:	e3a02000 	mov	r2, #0
30017e88:	e583200c 	str	r2, [r3, #12]
  memp_free(MEMP_TCP_PCB, pcb);
30017e8c:	e3a00002 	mov	r0, #2
30017e90:	e59d1004 	ldr	r1, [sp, #4]
30017e94:	ebfff58b 	bl	300154c8 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
30017e98:	e59d300c 	ldr	r3, [sp, #12]
30017e9c:	e59f203c 	ldr	r2, [pc, #60]	; 30017ee0 <tcp_listen_with_backlog+0x1f4>
30017ea0:	e583201c 	str	r2, [r3, #28]
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
30017ea4:	e59f3038 	ldr	r3, [pc, #56]	; 30017ee4 <tcp_listen_with_backlog+0x1f8>
30017ea8:	e5932000 	ldr	r2, [r3]
30017eac:	e59d300c 	ldr	r3, [sp, #12]
30017eb0:	e583200c 	str	r2, [r3, #12]
30017eb4:	e59f3028 	ldr	r3, [pc, #40]	; 30017ee4 <tcp_listen_with_backlog+0x1f8>
30017eb8:	e59d200c 	ldr	r2, [sp, #12]
30017ebc:	e5832000 	str	r2, [r3]
30017ec0:	ebffe86d 	bl	3001207c <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
30017ec4:	e59d300c 	ldr	r3, [sp, #12]
}
30017ec8:	e1a00003 	mov	r0, r3
30017ecc:	e28dd014 	add	sp, sp, #20
30017ed0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30017ed4:	e12fff1e 	bx	lr
30017ed8:	3012d684 	.word	0x3012d684
30017edc:	3012a850 	.word	0x3012a850
30017ee0:	30017cc0 	.word	0x30017cc0
30017ee4:	300eaa78 	.word	0x300eaa78

30017ee8 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
30017ee8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30017eec:	e24dd00c 	sub	sp, sp, #12
30017ef0:	e58d0004 	str	r0, [sp, #4]
30017ef4:	e1a03001 	mov	r3, r1
30017ef8:	e1cd30b2 	strh	r3, [sp, #2]
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
30017efc:	e59d3004 	ldr	r3, [sp, #4]
30017f00:	e1d332b4 	ldrh	r3, [r3, #36]	; 0x24
30017f04:	e1a02003 	mov	r2, r3
30017f08:	e1dd30b2 	ldrh	r3, [sp, #2]
30017f0c:	e0823003 	add	r3, r2, r3
30017f10:	e3530a02 	cmp	r3, #8192	; 0x2000
30017f14:	9a000006 	bls	30017f34 <tcp_recved+0x4c>
    pcb->rcv_wnd = TCP_WND;
30017f18:	e59d3004 	ldr	r3, [sp, #4]
30017f1c:	e3a02a02 	mov	r2, #8192	; 0x2000
30017f20:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
    pcb->rcv_ann_wnd = TCP_WND;
30017f24:	e59d3004 	ldr	r3, [sp, #4]
30017f28:	e3a02a02 	mov	r2, #8192	; 0x2000
30017f2c:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
30017f30:	ea000011 	b	30017f7c <tcp_recved+0x94>
  } else {
    pcb->rcv_wnd += len;
30017f34:	e59d3004 	ldr	r3, [sp, #4]
30017f38:	e1d322b4 	ldrh	r2, [r3, #36]	; 0x24
30017f3c:	e1dd30b2 	ldrh	r3, [sp, #2]
30017f40:	e0823003 	add	r3, r2, r3
30017f44:	e1a03803 	lsl	r3, r3, #16
30017f48:	e1a02823 	lsr	r2, r3, #16
30017f4c:	e59d3004 	ldr	r3, [sp, #4]
30017f50:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
    if (pcb->rcv_wnd >= pcb->mss) {
30017f54:	e59d3004 	ldr	r3, [sp, #4]
30017f58:	e1d322b4 	ldrh	r2, [r3, #36]	; 0x24
30017f5c:	e59d3004 	ldr	r3, [sp, #4]
30017f60:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
30017f64:	e1520003 	cmp	r2, r3
30017f68:	3a000003 	bcc	30017f7c <tcp_recved+0x94>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
30017f6c:	e59d3004 	ldr	r3, [sp, #4]
30017f70:	e1d322b4 	ldrh	r2, [r3, #36]	; 0x24
30017f74:	e59d3004 	ldr	r3, [sp, #4]
30017f78:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
30017f7c:	e59d3004 	ldr	r3, [sp, #4]
30017f80:	e5d3301c 	ldrb	r3, [r3, #28]
30017f84:	e2033001 	and	r3, r3, #1
30017f88:	e3530000 	cmp	r3, #0
30017f8c:	1a00001f 	bne	30018010 <tcp_recved+0x128>
     !(pcb->flags & TF_ACK_NOW)) {
30017f90:	e59d3004 	ldr	r3, [sp, #4]
30017f94:	e5d3301c 	ldrb	r3, [r3, #28]
30017f98:	e2033002 	and	r3, r3, #2
    if (pcb->rcv_wnd >= pcb->mss) {
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
30017f9c:	e3530000 	cmp	r3, #0
30017fa0:	1a00001a 	bne	30018010 <tcp_recved+0x128>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
30017fa4:	e59d3004 	ldr	r3, [sp, #4]
30017fa8:	e5d3301c 	ldrb	r3, [r3, #28]
30017fac:	e2033001 	and	r3, r3, #1
30017fb0:	e20330ff 	and	r3, r3, #255	; 0xff
30017fb4:	e3530000 	cmp	r3, #0
30017fb8:	0a00000d 	beq	30017ff4 <tcp_recved+0x10c>
30017fbc:	e59d3004 	ldr	r3, [sp, #4]
30017fc0:	e5d3301c 	ldrb	r3, [r3, #28]
30017fc4:	e20330fe 	and	r3, r3, #254	; 0xfe
30017fc8:	e59d2004 	ldr	r2, [sp, #4]
30017fcc:	e5c2301c 	strb	r3, [r2, #28]
30017fd0:	e59d3004 	ldr	r3, [sp, #4]
30017fd4:	e5d3301c 	ldrb	r3, [r3, #28]
30017fd8:	e3833002 	orr	r3, r3, #2
30017fdc:	e20320ff 	and	r2, r3, #255	; 0xff
30017fe0:	e59d3004 	ldr	r3, [sp, #4]
30017fe4:	e5c3201c 	strb	r2, [r3, #28]
30017fe8:	e59d0004 	ldr	r0, [sp, #4]
30017fec:	eb0017f8 	bl	3001dfd4 <tcp_output>
    if (pcb->rcv_wnd >= pcb->mss) {
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
30017ff0:	ea00001a 	b	30018060 <tcp_recved+0x178>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
30017ff4:	e59d3004 	ldr	r3, [sp, #4]
30017ff8:	e5d3301c 	ldrb	r3, [r3, #28]
30017ffc:	e3833001 	orr	r3, r3, #1
30018000:	e20320ff 	and	r2, r3, #255	; 0xff
30018004:	e59d3004 	ldr	r3, [sp, #4]
30018008:	e5c3201c 	strb	r2, [r3, #28]
    if (pcb->rcv_wnd >= pcb->mss) {
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
3001800c:	ea000013 	b	30018060 <tcp_recved+0x178>
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
30018010:	e59d3004 	ldr	r3, [sp, #4]
30018014:	e5d3301c 	ldrb	r3, [r3, #28]
30018018:	e2033001 	and	r3, r3, #1
3001801c:	e20330ff 	and	r3, r3, #255	; 0xff
30018020:	e3530000 	cmp	r3, #0
30018024:	0a00000d 	beq	30018060 <tcp_recved+0x178>
30018028:	e59d3004 	ldr	r3, [sp, #4]
3001802c:	e1d322b4 	ldrh	r2, [r3, #36]	; 0x24
30018030:	e3a03eff 	mov	r3, #4080	; 0xff0
30018034:	e283300f 	add	r3, r3, #15
30018038:	e1520003 	cmp	r2, r3
3001803c:	9a000007 	bls	30018060 <tcp_recved+0x178>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
30018040:	e59d3004 	ldr	r3, [sp, #4]
30018044:	e5d3301c 	ldrb	r3, [r3, #28]
30018048:	e3833002 	orr	r3, r3, #2
3001804c:	e20320ff 	and	r2, r3, #255	; 0xff
30018050:	e59d3004 	ldr	r3, [sp, #4]
30018054:	e5c3201c 	strb	r2, [r3, #28]
30018058:	e59d0004 	ldr	r0, [sp, #4]
3001805c:	eb0017dc 	bl	3001dfd4 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
30018060:	e28dd00c 	add	sp, sp, #12
30018064:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30018068:	e12fff1e 	bx	lr

3001806c <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
3001806c:	e24dd008 	sub	sp, sp, #8
30018070:	ea000004 	b	30018088 <tcp_new_port+0x1c>
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
30018074:	e1a00000 	nop			; (mov r0, r0)
30018078:	ea000002 	b	30018088 <tcp_new_port+0x1c>
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
3001807c:	e1a00000 	nop			; (mov r0, r0)
30018080:	ea000000 	b	30018088 <tcp_new_port+0x1c>
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
30018084:	e1a00000 	nop			; (mov r0, r0)
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
30018088:	e59f310c 	ldr	r3, [pc, #268]	; 3001819c <tcp_new_port+0x130>
3001808c:	e1d330b0 	ldrh	r3, [r3]
30018090:	e2833001 	add	r3, r3, #1
30018094:	e1a03803 	lsl	r3, r3, #16
30018098:	e1a02823 	lsr	r2, r3, #16
3001809c:	e59f30f8 	ldr	r3, [pc, #248]	; 3001819c <tcp_new_port+0x130>
300180a0:	e1c320b0 	strh	r2, [r3]
300180a4:	e59f30f0 	ldr	r3, [pc, #240]	; 3001819c <tcp_new_port+0x130>
300180a8:	e1d330b0 	ldrh	r3, [r3]
300180ac:	e1a03803 	lsl	r3, r3, #16
300180b0:	e1a03843 	asr	r3, r3, #16
300180b4:	e3530000 	cmp	r3, #0
300180b8:	aa000002 	bge	300180c8 <tcp_new_port+0x5c>
    port = TCP_LOCAL_PORT_RANGE_START;
300180bc:	e59f30d8 	ldr	r3, [pc, #216]	; 3001819c <tcp_new_port+0x130>
300180c0:	e3a02a01 	mov	r2, #4096	; 0x1000
300180c4:	e1c320b0 	strh	r2, [r3]
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
300180c8:	e59f30d0 	ldr	r3, [pc, #208]	; 300181a0 <tcp_new_port+0x134>
300180cc:	e5933000 	ldr	r3, [r3]
300180d0:	e58d3004 	str	r3, [sp, #4]
300180d4:	ea000008 	b	300180fc <tcp_new_port+0x90>
    if (pcb->local_port == port) {
300180d8:	e59d3004 	ldr	r3, [sp, #4]
300180dc:	e1d321b8 	ldrh	r2, [r3, #24]
300180e0:	e59f30b4 	ldr	r3, [pc, #180]	; 3001819c <tcp_new_port+0x130>
300180e4:	e1d330b0 	ldrh	r3, [r3]
300180e8:	e1520003 	cmp	r2, r3
300180ec:	0affffe0 	beq	30018074 <tcp_new_port+0x8>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
300180f0:	e59d3004 	ldr	r3, [sp, #4]
300180f4:	e593300c 	ldr	r3, [r3, #12]
300180f8:	e58d3004 	str	r3, [sp, #4]
300180fc:	e59d3004 	ldr	r3, [sp, #4]
30018100:	e3530000 	cmp	r3, #0
30018104:	1afffff3 	bne	300180d8 <tcp_new_port+0x6c>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
30018108:	e59f3094 	ldr	r3, [pc, #148]	; 300181a4 <tcp_new_port+0x138>
3001810c:	e5933000 	ldr	r3, [r3]
30018110:	e58d3004 	str	r3, [sp, #4]
30018114:	ea000008 	b	3001813c <tcp_new_port+0xd0>
    if (pcb->local_port == port) {
30018118:	e59d3004 	ldr	r3, [sp, #4]
3001811c:	e1d321b8 	ldrh	r2, [r3, #24]
30018120:	e59f3074 	ldr	r3, [pc, #116]	; 3001819c <tcp_new_port+0x130>
30018124:	e1d330b0 	ldrh	r3, [r3]
30018128:	e1520003 	cmp	r2, r3
3001812c:	0affffd2 	beq	3001807c <tcp_new_port+0x10>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
30018130:	e59d3004 	ldr	r3, [sp, #4]
30018134:	e593300c 	ldr	r3, [r3, #12]
30018138:	e58d3004 	str	r3, [sp, #4]
3001813c:	e59d3004 	ldr	r3, [sp, #4]
30018140:	e3530000 	cmp	r3, #0
30018144:	1afffff3 	bne	30018118 <tcp_new_port+0xac>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
30018148:	e59f3058 	ldr	r3, [pc, #88]	; 300181a8 <tcp_new_port+0x13c>
3001814c:	e5933000 	ldr	r3, [r3]
30018150:	e58d3004 	str	r3, [sp, #4]
30018154:	ea000008 	b	3001817c <tcp_new_port+0x110>
    if (pcb->local_port == port) {
30018158:	e59d3004 	ldr	r3, [sp, #4]
3001815c:	e1d321b8 	ldrh	r2, [r3, #24]
30018160:	e59f3034 	ldr	r3, [pc, #52]	; 3001819c <tcp_new_port+0x130>
30018164:	e1d330b0 	ldrh	r3, [r3]
30018168:	e1520003 	cmp	r2, r3
3001816c:	0affffc4 	beq	30018084 <tcp_new_port+0x18>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
30018170:	e59d3004 	ldr	r3, [sp, #4]
30018174:	e593300c 	ldr	r3, [r3, #12]
30018178:	e58d3004 	str	r3, [sp, #4]
3001817c:	e59d3004 	ldr	r3, [sp, #4]
30018180:	e3530000 	cmp	r3, #0
30018184:	1afffff3 	bne	30018158 <tcp_new_port+0xec>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
30018188:	e59f300c 	ldr	r3, [pc, #12]	; 3001819c <tcp_new_port+0x130>
3001818c:	e1d330b0 	ldrh	r3, [r3]
}
30018190:	e1a00003 	mov	r0, r3
30018194:	e28dd008 	add	sp, sp, #8
30018198:	e12fff1e 	bx	lr
3001819c:	300466c4 	.word	0x300466c4
300181a0:	300eaa38 	.word	0x300eaa38
300181a4:	302be508 	.word	0x302be508
300181a8:	300eaa78 	.word	0x300eaa78

300181ac <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
300181ac:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300181b0:	e24dd034 	sub	sp, sp, #52	; 0x34
300181b4:	e58d001c 	str	r0, [sp, #28]
300181b8:	e58d1018 	str	r1, [sp, #24]
300181bc:	e58d3010 	str	r3, [sp, #16]
300181c0:	e1cd21b6 	strh	r2, [sp, #22]
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
300181c4:	e59d3018 	ldr	r3, [sp, #24]
300181c8:	e3530000 	cmp	r3, #0
300181cc:	0a000015 	beq	30018228 <tcp_connect+0x7c>
    //by pegasus0824
	//pcb->remote_ip = *ipaddr;
    pcb->remote_ip.addr = ipaddr->addr;
300181d0:	e59d3018 	ldr	r3, [sp, #24]
300181d4:	e5d32000 	ldrb	r2, [r3]
300181d8:	e5d31001 	ldrb	r1, [r3, #1]
300181dc:	e1a01401 	lsl	r1, r1, #8
300181e0:	e1812002 	orr	r2, r1, r2
300181e4:	e5d31002 	ldrb	r1, [r3, #2]
300181e8:	e1a01801 	lsl	r1, r1, #16
300181ec:	e1812002 	orr	r2, r1, r2
300181f0:	e5d33003 	ldrb	r3, [r3, #3]
300181f4:	e1a03c03 	lsl	r3, r3, #24
300181f8:	e1833002 	orr	r3, r3, r2
300181fc:	e1a02003 	mov	r2, r3
30018200:	e59d301c 	ldr	r3, [sp, #28]
30018204:	e5832004 	str	r2, [r3, #4]
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
30018208:	e59d301c 	ldr	r3, [sp, #28]
3001820c:	e1dd21b6 	ldrh	r2, [sp, #22]
30018210:	e1c321ba 	strh	r2, [r3, #26]
  if (pcb->local_port == 0) {
30018214:	e59d301c 	ldr	r3, [sp, #28]
30018218:	e1d331b8 	ldrh	r3, [r3, #24]
3001821c:	e3530000 	cmp	r3, #0
30018220:	0a000002 	beq	30018230 <tcp_connect+0x84>
30018224:	ea000006 	b	30018244 <tcp_connect+0x98>
  if (ipaddr != NULL) {
    //by pegasus0824
	//pcb->remote_ip = *ipaddr;
    pcb->remote_ip.addr = ipaddr->addr;
  } else {
    return ERR_VAL;
30018228:	e3a030f8 	mov	r3, #248	; 0xf8
3001822c:	ea00008b 	b	30018460 <tcp_connect+0x2b4>
  }
  pcb->remote_port = port;
  if (pcb->local_port == 0) {
    pcb->local_port = tcp_new_port();
30018230:	ebffff8d 	bl	3001806c <tcp_new_port>
30018234:	e1a03000 	mov	r3, r0
30018238:	e1a02003 	mov	r2, r3
3001823c:	e59d301c 	ldr	r3, [sp, #28]
30018240:	e1c321b8 	strh	r2, [r3, #24]
  }
  iss = tcp_next_iss();
30018244:	eb000499 	bl	300194b0 <tcp_next_iss>
30018248:	e1a03000 	mov	r3, r0
3001824c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  pcb->rcv_nxt = 0;
30018250:	e59d301c 	ldr	r3, [sp, #28]
30018254:	e3a02000 	mov	r2, #0
30018258:	e5832020 	str	r2, [r3, #32]
  pcb->snd_nxt = iss;
3001825c:	e59d301c 	ldr	r3, [sp, #28]
30018260:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30018264:	e5832050 	str	r2, [r3, #80]	; 0x50
  pcb->lastack = iss - 1;
30018268:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3001826c:	e2432001 	sub	r2, r3, #1
30018270:	e59d301c 	ldr	r3, [sp, #28]
30018274:	e5832044 	str	r2, [r3, #68]	; 0x44
  pcb->snd_lbb = iss - 1;
30018278:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3001827c:	e2432001 	sub	r2, r3, #1
30018280:	e59d301c 	ldr	r3, [sp, #28]
30018284:	e5832064 	str	r2, [r3, #100]	; 0x64
  pcb->rcv_wnd = TCP_WND;
30018288:	e59d301c 	ldr	r3, [sp, #28]
3001828c:	e3a02a02 	mov	r2, #8192	; 0x2000
30018290:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
  pcb->rcv_ann_wnd = TCP_WND;
30018294:	e59d301c 	ldr	r3, [sp, #28]
30018298:	e3a02a02 	mov	r2, #8192	; 0x2000
3001829c:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
  pcb->snd_wnd = TCP_WND;
300182a0:	e59d301c 	ldr	r3, [sp, #28]
300182a4:	e3a02a02 	mov	r2, #8192	; 0x2000
300182a8:	e1c325b8 	strh	r2, [r3, #88]	; 0x58
  /* The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
300182ac:	e59d301c 	ldr	r3, [sp, #28]
300182b0:	e3a02f86 	mov	r2, #536	; 0x218
300182b4:	e1c323b0 	strh	r2, [r3, #48]	; 0x30
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
300182b8:	e59d301c 	ldr	r3, [sp, #28]
300182bc:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
300182c0:	e1a00003 	mov	r0, r3
300182c4:	e59d1018 	ldr	r1, [sp, #24]
300182c8:	eb000485 	bl	300194e4 <tcp_eff_send_mss>
300182cc:	e1a03000 	mov	r3, r0
300182d0:	e1a02003 	mov	r2, r3
300182d4:	e59d301c 	ldr	r3, [sp, #28]
300182d8:	e1c323b0 	strh	r2, [r3, #48]	; 0x30
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
300182dc:	e59d301c 	ldr	r3, [sp, #28]
300182e0:	e3a02001 	mov	r2, #1
300182e4:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
  pcb->ssthresh = pcb->mss * 10;
300182e8:	e59d301c 	ldr	r3, [sp, #28]
300182ec:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
300182f0:	e1a02003 	mov	r2, r3
300182f4:	e1a02102 	lsl	r2, r2, #2
300182f8:	e0823003 	add	r3, r2, r3
300182fc:	e1a03083 	lsl	r3, r3, #1
30018300:	e1a03803 	lsl	r3, r3, #16
30018304:	e1a02823 	lsr	r2, r3, #16
30018308:	e59d301c 	ldr	r3, [sp, #28]
3001830c:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
  pcb->state = SYN_SENT;
30018310:	e59d301c 	ldr	r3, [sp, #28]
30018314:	e3a02002 	mov	r2, #2
30018318:	e5c32010 	strb	r2, [r3, #16]
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
3001831c:	e59d301c 	ldr	r3, [sp, #28]
30018320:	e59d2010 	ldr	r2, [sp, #16]
30018324:	e5832088 	str	r2, [r3, #136]	; 0x88
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
30018328:	e59f3148 	ldr	r3, [pc, #328]	; 30018478 <tcp_connect+0x2cc>
3001832c:	e5932000 	ldr	r2, [r3]
30018330:	e59d301c 	ldr	r3, [sp, #28]
30018334:	e1520003 	cmp	r2, r3
30018338:	1a000005 	bne	30018354 <tcp_connect+0x1a8>
3001833c:	e59f3134 	ldr	r3, [pc, #308]	; 30018478 <tcp_connect+0x2cc>
30018340:	e5933000 	ldr	r3, [r3]
30018344:	e593200c 	ldr	r2, [r3, #12]
30018348:	e59f3128 	ldr	r3, [pc, #296]	; 30018478 <tcp_connect+0x2cc>
3001834c:	e5832000 	str	r2, [r3]
30018350:	ea00001e 	b	300183d0 <tcp_connect+0x224>
30018354:	e59f311c 	ldr	r3, [pc, #284]	; 30018478 <tcp_connect+0x2cc>
30018358:	e5932000 	ldr	r2, [r3]
3001835c:	e59f3118 	ldr	r3, [pc, #280]	; 3001847c <tcp_connect+0x2d0>
30018360:	e5832000 	str	r2, [r3]
30018364:	ea000015 	b	300183c0 <tcp_connect+0x214>
30018368:	e59f310c 	ldr	r3, [pc, #268]	; 3001847c <tcp_connect+0x2d0>
3001836c:	e5933000 	ldr	r3, [r3]
30018370:	e593300c 	ldr	r3, [r3, #12]
30018374:	e3530000 	cmp	r3, #0
30018378:	0a00000b 	beq	300183ac <tcp_connect+0x200>
3001837c:	e59f30f8 	ldr	r3, [pc, #248]	; 3001847c <tcp_connect+0x2d0>
30018380:	e5933000 	ldr	r3, [r3]
30018384:	e593200c 	ldr	r2, [r3, #12]
30018388:	e59d301c 	ldr	r3, [sp, #28]
3001838c:	e1520003 	cmp	r2, r3
30018390:	1a000005 	bne	300183ac <tcp_connect+0x200>
30018394:	e59f30e0 	ldr	r3, [pc, #224]	; 3001847c <tcp_connect+0x2d0>
30018398:	e5933000 	ldr	r3, [r3]
3001839c:	e59d201c 	ldr	r2, [sp, #28]
300183a0:	e592200c 	ldr	r2, [r2, #12]
300183a4:	e583200c 	str	r2, [r3, #12]
300183a8:	ea000008 	b	300183d0 <tcp_connect+0x224>
300183ac:	e59f30c8 	ldr	r3, [pc, #200]	; 3001847c <tcp_connect+0x2d0>
300183b0:	e5933000 	ldr	r3, [r3]
300183b4:	e593200c 	ldr	r2, [r3, #12]
300183b8:	e59f30bc 	ldr	r3, [pc, #188]	; 3001847c <tcp_connect+0x2d0>
300183bc:	e5832000 	str	r2, [r3]
300183c0:	e59f30b4 	ldr	r3, [pc, #180]	; 3001847c <tcp_connect+0x2d0>
300183c4:	e5933000 	ldr	r3, [r3]
300183c8:	e3530000 	cmp	r3, #0
300183cc:	1affffe5 	bne	30018368 <tcp_connect+0x1bc>
300183d0:	e59d301c 	ldr	r3, [sp, #28]
300183d4:	e3a02000 	mov	r2, #0
300183d8:	e583200c 	str	r2, [r3, #12]
  TCP_REG(&tcp_active_pcbs, pcb);
300183dc:	e59f309c 	ldr	r3, [pc, #156]	; 30018480 <tcp_connect+0x2d4>
300183e0:	e5932000 	ldr	r2, [r3]
300183e4:	e59d301c 	ldr	r3, [sp, #28]
300183e8:	e583200c 	str	r2, [r3, #12]
300183ec:	e59f308c 	ldr	r3, [pc, #140]	; 30018480 <tcp_connect+0x2d4>
300183f0:	e59d201c 	ldr	r2, [sp, #28]
300183f4:	e5832000 	str	r2, [r3]
300183f8:	ebffe71f 	bl	3001207c <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
300183fc:	e3a00781 	mov	r0, #33816576	; 0x2040000
30018400:	e2800a01 	add	r0, r0, #4096	; 0x1000
30018404:	ebffec9c 	bl	3001367c <htonl>
30018408:	e1a03000 	mov	r3, r0
3001840c:	e58d3024 	str	r3, [sp, #36]	; 0x24

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
30018410:	e28d3024 	add	r3, sp, #36	; 0x24
30018414:	e3a02000 	mov	r2, #0
30018418:	e58d2000 	str	r2, [sp]
3001841c:	e58d3004 	str	r3, [sp, #4]
30018420:	e3a03004 	mov	r3, #4
30018424:	e58d3008 	str	r3, [sp, #8]
30018428:	e59d001c 	ldr	r0, [sp, #28]
3001842c:	e3a01000 	mov	r1, #0
30018430:	e3a02000 	mov	r2, #0
30018434:	e3a03002 	mov	r3, #2
30018438:	eb001498 	bl	3001d6a0 <tcp_enqueue>
3001843c:	e1a03000 	mov	r3, r0
30018440:	e20330ff 	and	r3, r3, #255	; 0xff
30018444:	e5cd302b 	strb	r3, [sp, #43]	; 0x2b
  if (ret == ERR_OK) { 
30018448:	e1dd32db 	ldrsb	r3, [sp, #43]	; 0x2b
3001844c:	e3530000 	cmp	r3, #0
30018450:	1a000001 	bne	3001845c <tcp_connect+0x2b0>
    tcp_output(pcb);
30018454:	e59d001c 	ldr	r0, [sp, #28]
30018458:	eb0016dd 	bl	3001dfd4 <tcp_output>
  }
  return ret;
3001845c:	e5dd302b 	ldrb	r3, [sp, #43]	; 0x2b
30018460:	e1a03c03 	lsl	r3, r3, #24
30018464:	e1a03c43 	asr	r3, r3, #24
} 
30018468:	e1a00003 	mov	r0, r3
3001846c:	e28dd034 	add	sp, sp, #52	; 0x34
30018470:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30018474:	e12fff1e 	bx	lr
30018478:	3012d684 	.word	0x3012d684
3001847c:	3012a850 	.word	0x3012a850
30018480:	300eaa38 	.word	0x300eaa38

30018484 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
30018484:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30018488:	e24dd014 	sub	sp, sp, #20
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
3001848c:	e3a03000 	mov	r3, #0
30018490:	e5cd300f 	strb	r3, [sp, #15]

  ++tcp_ticks;
30018494:	e59f36a4 	ldr	r3, [pc, #1700]	; 30018b40 <tcp_slowtmr+0x6bc>
30018498:	e5933000 	ldr	r3, [r3]
3001849c:	e2832001 	add	r2, r3, #1
300184a0:	e59f3698 	ldr	r3, [pc, #1688]	; 30018b40 <tcp_slowtmr+0x6bc>
300184a4:	e5832000 	str	r2, [r3]

  /* Steps through all of the active PCBs. */
  prev = NULL;
300184a8:	e3a03000 	mov	r3, #0
300184ac:	e58d3008 	str	r3, [sp, #8]
  pcb = tcp_active_pcbs;
300184b0:	e59f368c 	ldr	r3, [pc, #1676]	; 30018b44 <tcp_slowtmr+0x6c0>
300184b4:	e5933000 	ldr	r3, [r3]
300184b8:	e58d3000 	str	r3, [sp]
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
300184bc:	ea000165 	b	30018a58 <tcp_slowtmr+0x5d4>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
300184c0:	e3a03000 	mov	r3, #0
300184c4:	e5cd300e 	strb	r3, [sp, #14]

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
300184c8:	e59d3000 	ldr	r3, [sp]
300184cc:	e5d33010 	ldrb	r3, [r3, #16]
300184d0:	e3530002 	cmp	r3, #2
300184d4:	1a000007 	bne	300184f8 <tcp_slowtmr+0x74>
300184d8:	e59d3000 	ldr	r3, [sp]
300184dc:	e5d33042 	ldrb	r3, [r3, #66]	; 0x42
300184e0:	e3530006 	cmp	r3, #6
300184e4:	1a000003 	bne	300184f8 <tcp_slowtmr+0x74>
      ++pcb_remove;
300184e8:	e5dd300e 	ldrb	r3, [sp, #14]
300184ec:	e2833001 	add	r3, r3, #1
300184f0:	e5cd300e 	strb	r3, [sp, #14]
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
300184f4:	ea000084 	b	3001870c <tcp_slowtmr+0x288>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
300184f8:	e59d3000 	ldr	r3, [sp]
300184fc:	e5d33042 	ldrb	r3, [r3, #66]	; 0x42
30018500:	e353000c 	cmp	r3, #12
30018504:	1a000003 	bne	30018518 <tcp_slowtmr+0x94>
      ++pcb_remove;
30018508:	e5dd300e 	ldrb	r3, [sp, #14]
3001850c:	e2833001 	add	r3, r3, #1
30018510:	e5cd300e 	strb	r3, [sp, #14]
30018514:	ea00007c 	b	3001870c <tcp_slowtmr+0x288>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
30018518:	e59d3000 	ldr	r3, [sp]
3001851c:	e5d330a0 	ldrb	r3, [r3, #160]	; 0xa0
30018520:	e3530000 	cmp	r3, #0
30018524:	0a00001d 	beq	300185a0 <tcp_slowtmr+0x11c>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
30018528:	e59d3000 	ldr	r3, [sp]
3001852c:	e593309c 	ldr	r3, [r3, #156]	; 0x9c
30018530:	e2832001 	add	r2, r3, #1
30018534:	e59d3000 	ldr	r3, [sp]
30018538:	e583209c 	str	r2, [r3, #156]	; 0x9c
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
3001853c:	e59d3000 	ldr	r3, [sp]
30018540:	e593209c 	ldr	r2, [r3, #156]	; 0x9c
30018544:	e59d3000 	ldr	r3, [sp]
30018548:	e5d330a0 	ldrb	r3, [r3, #160]	; 0xa0
3001854c:	e2433001 	sub	r3, r3, #1
30018550:	e59f15f0 	ldr	r1, [pc, #1520]	; 30018b48 <tcp_slowtmr+0x6c4>
30018554:	e7d13003 	ldrb	r3, [r1, r3]
30018558:	e1520003 	cmp	r2, r3
3001855c:	3a000069 	bcc	30018708 <tcp_slowtmr+0x284>
          pcb->persist_cnt = 0;
30018560:	e59d3000 	ldr	r3, [sp]
30018564:	e3a02000 	mov	r2, #0
30018568:	e583209c 	str	r2, [r3, #156]	; 0x9c
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
3001856c:	e59d3000 	ldr	r3, [sp]
30018570:	e5d330a0 	ldrb	r3, [r3, #160]	; 0xa0
30018574:	e3530006 	cmp	r3, #6
30018578:	8a000005 	bhi	30018594 <tcp_slowtmr+0x110>
            pcb->persist_backoff++;
3001857c:	e59d3000 	ldr	r3, [sp]
30018580:	e5d330a0 	ldrb	r3, [r3, #160]	; 0xa0
30018584:	e2833001 	add	r3, r3, #1
30018588:	e20320ff 	and	r2, r3, #255	; 0xff
3001858c:	e59d3000 	ldr	r3, [sp]
30018590:	e5c320a0 	strb	r2, [r3, #160]	; 0xa0
          }
          tcp_zero_window_probe(pcb);
30018594:	e59d0000 	ldr	r0, [sp]
30018598:	eb001c04 	bl	3001f5b0 <tcp_zero_window_probe>
3001859c:	ea00005a 	b	3001870c <tcp_slowtmr+0x288>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
300185a0:	e59d3000 	ldr	r3, [sp]
300185a4:	e1d332be 	ldrh	r3, [r3, #46]	; 0x2e
300185a8:	e1a03803 	lsl	r3, r3, #16
300185ac:	e1a03843 	asr	r3, r3, #16
300185b0:	e3530000 	cmp	r3, #0
300185b4:	ba000006 	blt	300185d4 <tcp_slowtmr+0x150>
          ++pcb->rtime;
300185b8:	e59d3000 	ldr	r3, [sp]
300185bc:	e1d332be 	ldrh	r3, [r3, #46]	; 0x2e
300185c0:	e2833001 	add	r3, r3, #1
300185c4:	e1a03803 	lsl	r3, r3, #16
300185c8:	e1a02823 	lsr	r2, r3, #16
300185cc:	e59d3000 	ldr	r3, [sp]
300185d0:	e1c322be 	strh	r2, [r3, #46]	; 0x2e

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
300185d4:	e59d3000 	ldr	r3, [sp]
300185d8:	e5933074 	ldr	r3, [r3, #116]	; 0x74
300185dc:	e3530000 	cmp	r3, #0
300185e0:	0a000049 	beq	3001870c <tcp_slowtmr+0x288>
300185e4:	e59d3000 	ldr	r3, [sp]
300185e8:	e1d322be 	ldrh	r2, [r3, #46]	; 0x2e
300185ec:	e59d3000 	ldr	r3, [sp]
300185f0:	e1d334b0 	ldrh	r3, [r3, #64]	; 0x40
300185f4:	e1a02802 	lsl	r2, r2, #16
300185f8:	e1a02842 	asr	r2, r2, #16
300185fc:	e1a03803 	lsl	r3, r3, #16
30018600:	e1a03843 	asr	r3, r3, #16
30018604:	e1520003 	cmp	r2, r3
30018608:	ba00003f 	blt	3001870c <tcp_slowtmr+0x288>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
3001860c:	e59d3000 	ldr	r3, [sp]
30018610:	e5d33010 	ldrb	r3, [r3, #16]
30018614:	e3530002 	cmp	r3, #2
30018618:	0a000016 	beq	30018678 <tcp_slowtmr+0x1f4>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
3001861c:	e59d3000 	ldr	r3, [sp]
30018620:	e1d333bc 	ldrh	r3, [r3, #60]	; 0x3c
30018624:	e1a03803 	lsl	r3, r3, #16
30018628:	e1a03843 	asr	r3, r3, #16
3001862c:	e1a031c3 	asr	r3, r3, #3
30018630:	e1a03803 	lsl	r3, r3, #16
30018634:	e1a03823 	lsr	r3, r3, #16
30018638:	e1a03803 	lsl	r3, r3, #16
3001863c:	e1a02843 	asr	r2, r3, #16
30018640:	e59d3000 	ldr	r3, [sp]
30018644:	e1d333be 	ldrh	r3, [r3, #62]	; 0x3e
30018648:	e1a03803 	lsl	r3, r3, #16
3001864c:	e1a03843 	asr	r3, r3, #16
30018650:	e0822003 	add	r2, r2, r3
30018654:	e59d3000 	ldr	r3, [sp]
30018658:	e5d33042 	ldrb	r3, [r3, #66]	; 0x42
3001865c:	e59f14e8 	ldr	r1, [pc, #1256]	; 30018b4c <tcp_slowtmr+0x6c8>
30018660:	e7d13003 	ldrb	r3, [r1, r3]
30018664:	e1a03312 	lsl	r3, r2, r3
30018668:	e1a03803 	lsl	r3, r3, #16
3001866c:	e1a02823 	lsr	r2, r3, #16
30018670:	e59d3000 	ldr	r3, [sp]
30018674:	e1c324b0 	strh	r2, [r3, #64]	; 0x40
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
30018678:	e59d3000 	ldr	r3, [sp]
3001867c:	e3a02000 	mov	r2, #0
30018680:	e1c322be 	strh	r2, [r3, #46]	; 0x2e

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
30018684:	e59d3000 	ldr	r3, [sp]
30018688:	e1d325b8 	ldrh	r2, [r3, #88]	; 0x58
3001868c:	e59d3000 	ldr	r3, [sp]
30018690:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
30018694:	e1520003 	cmp	r2, r3
30018698:	31a03002 	movcc	r3, r2
3001869c:	e1cd30bc 	strh	r3, [sp, #12]
          pcb->ssthresh = eff_wnd >> 1;
300186a0:	e1dd30bc 	ldrh	r3, [sp, #12]
300186a4:	e1a030a3 	lsr	r3, r3, #1
300186a8:	e1a03803 	lsl	r3, r3, #16
300186ac:	e1a02823 	lsr	r2, r3, #16
300186b0:	e59d3000 	ldr	r3, [sp]
300186b4:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
          if (pcb->ssthresh < pcb->mss) {
300186b8:	e59d3000 	ldr	r3, [sp]
300186bc:	e1d324bc 	ldrh	r2, [r3, #76]	; 0x4c
300186c0:	e59d3000 	ldr	r3, [sp]
300186c4:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
300186c8:	e1520003 	cmp	r2, r3
300186cc:	2a000006 	bcs	300186ec <tcp_slowtmr+0x268>
            pcb->ssthresh = pcb->mss * 2;
300186d0:	e59d3000 	ldr	r3, [sp]
300186d4:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
300186d8:	e1a03083 	lsl	r3, r3, #1
300186dc:	e1a03803 	lsl	r3, r3, #16
300186e0:	e1a02823 	lsr	r2, r3, #16
300186e4:	e59d3000 	ldr	r3, [sp]
300186e8:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
          }
          pcb->cwnd = pcb->mss;
300186ec:	e59d3000 	ldr	r3, [sp]
300186f0:	e1d323b0 	ldrh	r2, [r3, #48]	; 0x30
300186f4:	e59d3000 	ldr	r3, [sp]
300186f8:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
300186fc:	e59d0000 	ldr	r0, [sp]
30018700:	eb001a4a 	bl	3001f030 <tcp_rexmit_rto>
30018704:	ea000000 	b	3001870c <tcp_slowtmr+0x288>
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
          pcb->persist_cnt = 0;
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
            pcb->persist_backoff++;
          }
          tcp_zero_window_probe(pcb);
30018708:	e1a00000 	nop			; (mov r0, r0)
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
3001870c:	e59d3000 	ldr	r3, [sp]
30018710:	e5d33010 	ldrb	r3, [r3, #16]
30018714:	e3530006 	cmp	r3, #6
30018718:	1a000009 	bne	30018744 <tcp_slowtmr+0x2c0>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
3001871c:	e59f341c 	ldr	r3, [pc, #1052]	; 30018b40 <tcp_slowtmr+0x6bc>
30018720:	e5932000 	ldr	r2, [r3]
30018724:	e59d3000 	ldr	r3, [sp]
30018728:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3001872c:	e0633002 	rsb	r3, r3, r2
30018730:	e3530028 	cmp	r3, #40	; 0x28
30018734:	9a000002 	bls	30018744 <tcp_slowtmr+0x2c0>
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
30018738:	e5dd300e 	ldrb	r3, [sp, #14]
3001873c:	e2833001 	add	r3, r3, #1
30018740:	e5cd300e 	strb	r3, [sp, #14]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
30018744:	e59d3000 	ldr	r3, [sp]
30018748:	e1d330b8 	ldrh	r3, [r3, #8]
3001874c:	e2033008 	and	r3, r3, #8
30018750:	e3530000 	cmp	r3, #0
30018754:	0a00003b 	beq	30018848 <tcp_slowtmr+0x3c4>
       ((pcb->state == ESTABLISHED) || 
30018758:	e59d3000 	ldr	r3, [sp]
3001875c:	e5d33010 	ldrb	r3, [r3, #16]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
30018760:	e3530004 	cmp	r3, #4
30018764:	0a000003 	beq	30018778 <tcp_slowtmr+0x2f4>
       ((pcb->state == ESTABLISHED) || 
        (pcb->state == CLOSE_WAIT))) {
30018768:	e59d3000 	ldr	r3, [sp]
3001876c:	e5d33010 	ldrb	r3, [r3, #16]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
30018770:	e3530007 	cmp	r3, #7
30018774:	1a000033 	bne	30018848 <tcp_slowtmr+0x3c4>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
30018778:	e59f33c0 	ldr	r3, [pc, #960]	; 30018b40 <tcp_slowtmr+0x6bc>
3001877c:	e5932000 	ldr	r2, [r3]
30018780:	e59d3000 	ldr	r3, [sp]
30018784:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30018788:	e0632002 	rsb	r2, r3, r2
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
3001878c:	e59d3000 	ldr	r3, [sp]
30018790:	e5933098 	ldr	r3, [r3, #152]	; 0x98
30018794:	e2833929 	add	r3, r3, #671744	; 0xa4000
30018798:	e2833ecb 	add	r3, r3, #3248	; 0xcb0
3001879c:	e2833008 	add	r3, r3, #8
300187a0:	e59f13a8 	ldr	r1, [pc, #936]	; 30018b50 <tcp_slowtmr+0x6cc>
300187a4:	e0830391 	umull	r0, r3, r1, r3
300187a8:	e1a032a3 	lsr	r3, r3, #5
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
300187ac:	e1520003 	cmp	r2, r3
300187b0:	9a000002 	bls	300187c0 <tcp_slowtmr+0x33c>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
300187b4:	e59d0000 	ldr	r0, [sp]
300187b8:	ebfffbd6 	bl	30017718 <tcp_abort>
300187bc:	ea000021 	b	30018848 <tcp_slowtmr+0x3c4>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
300187c0:	e59f3378 	ldr	r3, [pc, #888]	; 30018b40 <tcp_slowtmr+0x6bc>
300187c4:	e5932000 	ldr	r2, [r3]
300187c8:	e59d3000 	ldr	r3, [sp]
300187cc:	e5933028 	ldr	r3, [r3, #40]	; 0x28
300187d0:	e0631002 	rsb	r1, r3, r2
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
300187d4:	e59d3000 	ldr	r3, [sp]
300187d8:	e5930098 	ldr	r0, [r3, #152]	; 0x98
300187dc:	e59d3000 	ldr	r3, [sp]
300187e0:	e5d330a1 	ldrb	r3, [r3, #161]	; 0xa1
300187e4:	e1a02003 	mov	r2, r3
300187e8:	e1a03002 	mov	r3, r2
300187ec:	e1a03283 	lsl	r3, r3, #5
300187f0:	e0623003 	rsb	r3, r2, r3
300187f4:	e1a03103 	lsl	r3, r3, #2
300187f8:	e0833002 	add	r3, r3, r2
300187fc:	e1a02103 	lsl	r2, r3, #2
30018800:	e0833002 	add	r3, r3, r2
30018804:	e1a02203 	lsl	r2, r3, #4
30018808:	e0632002 	rsb	r2, r3, r2
3001880c:	e1a03182 	lsl	r3, r2, #3
30018810:	e0802003 	add	r2, r0, r3
              / TCP_SLOW_INTERVAL)
30018814:	e59f3334 	ldr	r3, [pc, #820]	; 30018b50 <tcp_slowtmr+0x6cc>
30018818:	e0830392 	umull	r0, r3, r2, r3
3001881c:	e1a032a3 	lsr	r3, r3, #5
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
30018820:	e1510003 	cmp	r1, r3
30018824:	9a000007 	bls	30018848 <tcp_slowtmr+0x3c4>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
30018828:	e59d0000 	ldr	r0, [sp]
3001882c:	eb001a77 	bl	3001f210 <tcp_keepalive>
        pcb->keep_cnt_sent++;
30018830:	e59d3000 	ldr	r3, [sp]
30018834:	e5d330a1 	ldrb	r3, [r3, #161]	; 0xa1
30018838:	e2833001 	add	r3, r3, #1
3001883c:	e20320ff 	and	r2, r3, #255	; 0xff
30018840:	e59d3000 	ldr	r3, [sp]
30018844:	e5c320a1 	strb	r2, [r3, #161]	; 0xa1

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
30018848:	e59d3000 	ldr	r3, [sp]
3001884c:	e5933078 	ldr	r3, [r3, #120]	; 0x78
30018850:	e3530000 	cmp	r3, #0
30018854:	0a000015 	beq	300188b0 <tcp_slowtmr+0x42c>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
30018858:	e59f32e0 	ldr	r3, [pc, #736]	; 30018b40 <tcp_slowtmr+0x6bc>
3001885c:	e5932000 	ldr	r2, [r3]
30018860:	e59d3000 	ldr	r3, [sp]
30018864:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30018868:	e0631002 	rsb	r1, r3, r2
3001886c:	e59d3000 	ldr	r3, [sp]
30018870:	e1d334b0 	ldrh	r3, [r3, #64]	; 0x40
30018874:	e1a03803 	lsl	r3, r3, #16
30018878:	e1a02843 	asr	r2, r3, #16
3001887c:	e1a03002 	mov	r3, r2
30018880:	e1a03083 	lsl	r3, r3, #1
30018884:	e0833002 	add	r3, r3, r2
30018888:	e1a03083 	lsl	r3, r3, #1

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
3001888c:	e1510003 	cmp	r1, r3
30018890:	3a000006 	bcc	300188b0 <tcp_slowtmr+0x42c>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
30018894:	e59d3000 	ldr	r3, [sp]
30018898:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001889c:	e1a00003 	mov	r0, r3
300188a0:	eb0000f7 	bl	30018c84 <tcp_segs_free>
      pcb->ooseq = NULL;
300188a4:	e59d3000 	ldr	r3, [sp]
300188a8:	e3a02000 	mov	r2, #0
300188ac:	e5832078 	str	r2, [r3, #120]	; 0x78
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
300188b0:	e59d3000 	ldr	r3, [sp]
300188b4:	e5d33010 	ldrb	r3, [r3, #16]
300188b8:	e3530003 	cmp	r3, #3
300188bc:	1a000009 	bne	300188e8 <tcp_slowtmr+0x464>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
300188c0:	e59f3278 	ldr	r3, [pc, #632]	; 30018b40 <tcp_slowtmr+0x6bc>
300188c4:	e5932000 	ldr	r2, [r3]
300188c8:	e59d3000 	ldr	r3, [sp]
300188cc:	e5933028 	ldr	r3, [r3, #40]	; 0x28
300188d0:	e0633002 	rsb	r3, r3, r2
300188d4:	e3530028 	cmp	r3, #40	; 0x28
300188d8:	9a000002 	bls	300188e8 <tcp_slowtmr+0x464>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
300188dc:	e5dd300e 	ldrb	r3, [sp, #14]
300188e0:	e2833001 	add	r3, r3, #1
300188e4:	e5cd300e 	strb	r3, [sp, #14]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
300188e8:	e59d3000 	ldr	r3, [sp]
300188ec:	e5d33010 	ldrb	r3, [r3, #16]
300188f0:	e3530009 	cmp	r3, #9
300188f4:	1a000009 	bne	30018920 <tcp_slowtmr+0x49c>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
300188f8:	e59f3240 	ldr	r3, [pc, #576]	; 30018b40 <tcp_slowtmr+0x6bc>
300188fc:	e5932000 	ldr	r2, [r3]
30018900:	e59d3000 	ldr	r3, [sp]
30018904:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30018908:	e0633002 	rsb	r3, r3, r2
3001890c:	e35300f0 	cmp	r3, #240	; 0xf0
30018910:	9a000002 	bls	30018920 <tcp_slowtmr+0x49c>
        ++pcb_remove;
30018914:	e5dd300e 	ldrb	r3, [sp, #14]
30018918:	e2833001 	add	r3, r3, #1
3001891c:	e5cd300e 	strb	r3, [sp, #14]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
30018920:	e5dd300e 	ldrb	r3, [sp, #14]
30018924:	e3530000 	cmp	r3, #0
30018928:	0a000022 	beq	300189b8 <tcp_slowtmr+0x534>
      tcp_pcb_purge(pcb);      
3001892c:	e59d0000 	ldr	r0, [sp]
30018930:	eb000258 	bl	30019298 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
30018934:	e59d3008 	ldr	r3, [sp, #8]
30018938:	e3530000 	cmp	r3, #0
3001893c:	0a000004 	beq	30018954 <tcp_slowtmr+0x4d0>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
30018940:	e59d3000 	ldr	r3, [sp]
30018944:	e593200c 	ldr	r2, [r3, #12]
30018948:	e59d3008 	ldr	r3, [sp, #8]
3001894c:	e583200c 	str	r2, [r3, #12]
30018950:	ea000003 	b	30018964 <tcp_slowtmr+0x4e0>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
30018954:	e59d3000 	ldr	r3, [sp]
30018958:	e593200c 	ldr	r2, [r3, #12]
3001895c:	e59f31e0 	ldr	r3, [pc, #480]	; 30018b44 <tcp_slowtmr+0x6c0>
30018960:	e5832000 	str	r2, [r3]
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
30018964:	e59d3000 	ldr	r3, [sp]
30018968:	e5933094 	ldr	r3, [r3, #148]	; 0x94
3001896c:	e3530000 	cmp	r3, #0
30018970:	0a000007 	beq	30018994 <tcp_slowtmr+0x510>
30018974:	e59d3000 	ldr	r3, [sp]
30018978:	e5933094 	ldr	r3, [r3, #148]	; 0x94
3001897c:	e59d2000 	ldr	r2, [sp]
30018980:	e5922014 	ldr	r2, [r2, #20]
30018984:	e1a00002 	mov	r0, r2
30018988:	e3e01003 	mvn	r1, #3
3001898c:	e1a0e00f 	mov	lr, pc
30018990:	e12fff13 	bx	r3

      pcb2 = pcb->next;
30018994:	e59d3000 	ldr	r3, [sp]
30018998:	e593300c 	ldr	r3, [r3, #12]
3001899c:	e58d3004 	str	r3, [sp, #4]
      memp_free(MEMP_TCP_PCB, pcb);
300189a0:	e3a00002 	mov	r0, #2
300189a4:	e59d1000 	ldr	r1, [sp]
300189a8:	ebfff2c6 	bl	300154c8 <memp_free>
      pcb = pcb2;
300189ac:	e59d3004 	ldr	r3, [sp, #4]
300189b0:	e58d3000 	str	r3, [sp]
300189b4:	ea000027 	b	30018a58 <tcp_slowtmr+0x5d4>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
300189b8:	e59d3000 	ldr	r3, [sp]
300189bc:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
300189c0:	e2833001 	add	r3, r3, #1
300189c4:	e20320ff 	and	r2, r3, #255	; 0xff
300189c8:	e59d3000 	ldr	r3, [sp]
300189cc:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
      if (pcb->polltmr >= pcb->pollinterval) {
300189d0:	e59d3000 	ldr	r3, [sp]
300189d4:	e5d3202c 	ldrb	r2, [r3, #44]	; 0x2c
300189d8:	e59d3000 	ldr	r3, [sp]
300189dc:	e5d3302d 	ldrb	r3, [r3, #45]	; 0x2d
300189e0:	e1520003 	cmp	r2, r3
300189e4:	3a000016 	bcc	30018a44 <tcp_slowtmr+0x5c0>
        pcb->polltmr = 0;
300189e8:	e59d3000 	ldr	r3, [sp]
300189ec:	e3a02000 	mov	r2, #0
300189f0:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
300189f4:	e59d3000 	ldr	r3, [sp]
300189f8:	e5933090 	ldr	r3, [r3, #144]	; 0x90
300189fc:	e3530000 	cmp	r3, #0
30018a00:	0a00000a 	beq	30018a30 <tcp_slowtmr+0x5ac>
30018a04:	e59d3000 	ldr	r3, [sp]
30018a08:	e5933090 	ldr	r3, [r3, #144]	; 0x90
30018a0c:	e59d2000 	ldr	r2, [sp]
30018a10:	e5922014 	ldr	r2, [r2, #20]
30018a14:	e1a00002 	mov	r0, r2
30018a18:	e59d1000 	ldr	r1, [sp]
30018a1c:	e1a0e00f 	mov	lr, pc
30018a20:	e12fff13 	bx	r3
30018a24:	e1a03000 	mov	r3, r0
30018a28:	e20330ff 	and	r3, r3, #255	; 0xff
30018a2c:	e5cd300f 	strb	r3, [sp, #15]
        if (err == ERR_OK) {
30018a30:	e1dd30df 	ldrsb	r3, [sp, #15]
30018a34:	e3530000 	cmp	r3, #0
30018a38:	1a000001 	bne	30018a44 <tcp_slowtmr+0x5c0>
          tcp_output(pcb);
30018a3c:	e59d0000 	ldr	r0, [sp]
30018a40:	eb001563 	bl	3001dfd4 <tcp_output>
        }
      }
      
      prev = pcb;
30018a44:	e59d3000 	ldr	r3, [sp]
30018a48:	e58d3008 	str	r3, [sp, #8]
      pcb = pcb->next;
30018a4c:	e59d3000 	ldr	r3, [sp]
30018a50:	e593300c 	ldr	r3, [r3, #12]
30018a54:	e58d3000 	str	r3, [sp]
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
30018a58:	e59d3000 	ldr	r3, [sp]
30018a5c:	e3530000 	cmp	r3, #0
30018a60:	1afffe96 	bne	300184c0 <tcp_slowtmr+0x3c>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
30018a64:	e3a03000 	mov	r3, #0
30018a68:	e58d3008 	str	r3, [sp, #8]
  pcb = tcp_tw_pcbs;
30018a6c:	e59f30e0 	ldr	r3, [pc, #224]	; 30018b54 <tcp_slowtmr+0x6d0>
30018a70:	e5933000 	ldr	r3, [r3]
30018a74:	e58d3000 	str	r3, [sp]
  while (pcb != NULL) {
30018a78:	ea00002a 	b	30018b28 <tcp_slowtmr+0x6a4>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    pcb_remove = 0;
30018a7c:	e3a03000 	mov	r3, #0
30018a80:	e5cd300e 	strb	r3, [sp, #14]

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
30018a84:	e59f30b4 	ldr	r3, [pc, #180]	; 30018b40 <tcp_slowtmr+0x6bc>
30018a88:	e5932000 	ldr	r2, [r3]
30018a8c:	e59d3000 	ldr	r3, [sp]
30018a90:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30018a94:	e0633002 	rsb	r3, r3, r2
30018a98:	e35300f0 	cmp	r3, #240	; 0xf0
30018a9c:	9a000002 	bls	30018aac <tcp_slowtmr+0x628>
      ++pcb_remove;
30018aa0:	e5dd300e 	ldrb	r3, [sp, #14]
30018aa4:	e2833001 	add	r3, r3, #1
30018aa8:	e5cd300e 	strb	r3, [sp, #14]
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
30018aac:	e5dd300e 	ldrb	r3, [sp, #14]
30018ab0:	e3530000 	cmp	r3, #0
30018ab4:	0a000016 	beq	30018b14 <tcp_slowtmr+0x690>
      tcp_pcb_purge(pcb);      
30018ab8:	e59d0000 	ldr	r0, [sp]
30018abc:	eb0001f5 	bl	30019298 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
30018ac0:	e59d3008 	ldr	r3, [sp, #8]
30018ac4:	e3530000 	cmp	r3, #0
30018ac8:	0a000004 	beq	30018ae0 <tcp_slowtmr+0x65c>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
30018acc:	e59d3000 	ldr	r3, [sp]
30018ad0:	e593200c 	ldr	r2, [r3, #12]
30018ad4:	e59d3008 	ldr	r3, [sp, #8]
30018ad8:	e583200c 	str	r2, [r3, #12]
30018adc:	ea000003 	b	30018af0 <tcp_slowtmr+0x66c>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
30018ae0:	e59d3000 	ldr	r3, [sp]
30018ae4:	e593200c 	ldr	r2, [r3, #12]
30018ae8:	e59f3064 	ldr	r3, [pc, #100]	; 30018b54 <tcp_slowtmr+0x6d0>
30018aec:	e5832000 	str	r2, [r3]
      }
      pcb2 = pcb->next;
30018af0:	e59d3000 	ldr	r3, [sp]
30018af4:	e593300c 	ldr	r3, [r3, #12]
30018af8:	e58d3004 	str	r3, [sp, #4]
      memp_free(MEMP_TCP_PCB, pcb);
30018afc:	e3a00002 	mov	r0, #2
30018b00:	e59d1000 	ldr	r1, [sp]
30018b04:	ebfff26f 	bl	300154c8 <memp_free>
      pcb = pcb2;
30018b08:	e59d3004 	ldr	r3, [sp, #4]
30018b0c:	e58d3000 	str	r3, [sp]
30018b10:	ea000004 	b	30018b28 <tcp_slowtmr+0x6a4>
    } else {
      prev = pcb;
30018b14:	e59d3000 	ldr	r3, [sp]
30018b18:	e58d3008 	str	r3, [sp, #8]
      pcb = pcb->next;
30018b1c:	e59d3000 	ldr	r3, [sp]
30018b20:	e593300c 	ldr	r3, [r3, #12]
30018b24:	e58d3000 	str	r3, [sp]

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
30018b28:	e59d3000 	ldr	r3, [sp]
30018b2c:	e3530000 	cmp	r3, #0
30018b30:	1affffd1 	bne	30018a7c <tcp_slowtmr+0x5f8>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
30018b34:	e28dd014 	add	sp, sp, #20
30018b38:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30018b3c:	e12fff1e 	bx	lr
30018b40:	300eaa74 	.word	0x300eaa74
30018b44:	300eaa38 	.word	0x300eaa38
30018b48:	30045720 	.word	0x30045720
30018b4c:	30045710 	.word	0x30045710
30018b50:	10624dd3 	.word	0x10624dd3
30018b54:	302be508 	.word	0x302be508

30018b58 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
30018b58:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30018b5c:	e24dd00c 	sub	sp, sp, #12
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
30018b60:	e59f3118 	ldr	r3, [pc, #280]	; 30018c80 <tcp_fasttmr+0x128>
30018b64:	e5933000 	ldr	r3, [r3]
30018b68:	e58d3000 	str	r3, [sp]
30018b6c:	ea00003d 	b	30018c68 <tcp_fasttmr+0x110>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
30018b70:	e59d3000 	ldr	r3, [sp]
30018b74:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
30018b78:	e3530000 	cmp	r3, #0
30018b7c:	0a000023 	beq	30018c10 <tcp_fasttmr+0xb8>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
30018b80:	e59d3000 	ldr	r3, [sp]
30018b84:	e5933084 	ldr	r3, [r3, #132]	; 0x84
30018b88:	e3530000 	cmp	r3, #0
30018b8c:	0a00000f 	beq	30018bd0 <tcp_fasttmr+0x78>
30018b90:	e59d3000 	ldr	r3, [sp]
30018b94:	e593c084 	ldr	ip, [r3, #132]	; 0x84
30018b98:	e59d3000 	ldr	r3, [sp]
30018b9c:	e5932014 	ldr	r2, [r3, #20]
30018ba0:	e59d3000 	ldr	r3, [sp]
30018ba4:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
30018ba8:	e1a00002 	mov	r0, r2
30018bac:	e59d1000 	ldr	r1, [sp]
30018bb0:	e1a02003 	mov	r2, r3
30018bb4:	e3a03000 	mov	r3, #0
30018bb8:	e1a0e00f 	mov	lr, pc
30018bbc:	e12fff1c 	bx	ip
30018bc0:	e1a03000 	mov	r3, r0
30018bc4:	e20330ff 	and	r3, r3, #255	; 0xff
30018bc8:	e5cd3007 	strb	r3, [sp, #7]
30018bcc:	ea000009 	b	30018bf8 <tcp_fasttmr+0xa0>
30018bd0:	e3a03000 	mov	r3, #0
30018bd4:	e5cd3007 	strb	r3, [sp, #7]
30018bd8:	e59d3000 	ldr	r3, [sp]
30018bdc:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
30018be0:	e3530000 	cmp	r3, #0
30018be4:	0a000003 	beq	30018bf8 <tcp_fasttmr+0xa0>
30018be8:	e59d3000 	ldr	r3, [sp]
30018bec:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
30018bf0:	e1a00003 	mov	r0, r3
30018bf4:	ebfff5a1 	bl	30016280 <pbuf_free>
      if (err == ERR_OK) {
30018bf8:	e1dd30d7 	ldrsb	r3, [sp, #7]
30018bfc:	e3530000 	cmp	r3, #0
30018c00:	1a000002 	bne	30018c10 <tcp_fasttmr+0xb8>
        pcb->refused_data = NULL;
30018c04:	e59d3000 	ldr	r3, [sp]
30018c08:	e3a02000 	mov	r2, #0
30018c0c:	e583207c 	str	r2, [r3, #124]	; 0x7c
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
30018c10:	e59d3000 	ldr	r3, [sp]
30018c14:	e5d3301c 	ldrb	r3, [r3, #28]
30018c18:	e2033001 	and	r3, r3, #1
30018c1c:	e20330ff 	and	r3, r3, #255	; 0xff
30018c20:	e3530000 	cmp	r3, #0
30018c24:	0a00000c 	beq	30018c5c <tcp_fasttmr+0x104>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
30018c28:	e59d3000 	ldr	r3, [sp]
30018c2c:	e5d3301c 	ldrb	r3, [r3, #28]
30018c30:	e3833002 	orr	r3, r3, #2
30018c34:	e20320ff 	and	r2, r3, #255	; 0xff
30018c38:	e59d3000 	ldr	r3, [sp]
30018c3c:	e5c3201c 	strb	r2, [r3, #28]
30018c40:	e59d0000 	ldr	r0, [sp]
30018c44:	eb0014e2 	bl	3001dfd4 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
30018c48:	e59d3000 	ldr	r3, [sp]
30018c4c:	e5d3301c 	ldrb	r3, [r3, #28]
30018c50:	e20330fc 	and	r3, r3, #252	; 0xfc
30018c54:	e59d2000 	ldr	r2, [sp]
30018c58:	e5c2301c 	strb	r3, [r2, #28]
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
30018c5c:	e59d3000 	ldr	r3, [sp]
30018c60:	e593300c 	ldr	r3, [r3, #12]
30018c64:	e58d3000 	str	r3, [sp]
30018c68:	e59d3000 	ldr	r3, [sp]
30018c6c:	e3530000 	cmp	r3, #0
30018c70:	1affffbe 	bne	30018b70 <tcp_fasttmr+0x18>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
30018c74:	e28dd00c 	add	sp, sp, #12
30018c78:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30018c7c:	e12fff1e 	bx	lr
30018c80:	300eaa38 	.word	0x300eaa38

30018c84 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
30018c84:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30018c88:	e24dd014 	sub	sp, sp, #20
30018c8c:	e58d0004 	str	r0, [sp, #4]
  u8_t count = 0;
30018c90:	e3a03000 	mov	r3, #0
30018c94:	e5cd300b 	strb	r3, [sp, #11]
  struct tcp_seg *next;
  while (seg != NULL) {
30018c98:	ea00000b 	b	30018ccc <tcp_segs_free+0x48>
    next = seg->next;
30018c9c:	e59d3004 	ldr	r3, [sp, #4]
30018ca0:	e5933000 	ldr	r3, [r3]
30018ca4:	e58d300c 	str	r3, [sp, #12]
    count += tcp_seg_free(seg);
30018ca8:	e59d0004 	ldr	r0, [sp, #4]
30018cac:	eb00000e 	bl	30018cec <tcp_seg_free>
30018cb0:	e1a03000 	mov	r3, r0
30018cb4:	e1a02003 	mov	r2, r3
30018cb8:	e5dd300b 	ldrb	r3, [sp, #11]
30018cbc:	e0823003 	add	r3, r2, r3
30018cc0:	e5cd300b 	strb	r3, [sp, #11]
    seg = next;
30018cc4:	e59d300c 	ldr	r3, [sp, #12]
30018cc8:	e58d3004 	str	r3, [sp, #4]
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
30018ccc:	e59d3004 	ldr	r3, [sp, #4]
30018cd0:	e3530000 	cmp	r3, #0
30018cd4:	1afffff0 	bne	30018c9c <tcp_segs_free+0x18>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
30018cd8:	e5dd300b 	ldrb	r3, [sp, #11]
}
30018cdc:	e1a00003 	mov	r0, r3
30018ce0:	e28dd014 	add	sp, sp, #20
30018ce4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30018ce8:	e12fff1e 	bx	lr

30018cec <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
30018cec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30018cf0:	e24dd014 	sub	sp, sp, #20
30018cf4:	e58d0004 	str	r0, [sp, #4]
  u8_t count = 0;
30018cf8:	e3a03000 	mov	r3, #0
30018cfc:	e5cd300f 	strb	r3, [sp, #15]
  
  if (seg != NULL) {
30018d00:	e59d3004 	ldr	r3, [sp, #4]
30018d04:	e3530000 	cmp	r3, #0
30018d08:	0a00000c 	beq	30018d40 <tcp_seg_free+0x54>
    if (seg->p != NULL) {
30018d0c:	e59d3004 	ldr	r3, [sp, #4]
30018d10:	e5933004 	ldr	r3, [r3, #4]
30018d14:	e3530000 	cmp	r3, #0
30018d18:	0a000005 	beq	30018d34 <tcp_seg_free+0x48>
      count = pbuf_free(seg->p);
30018d1c:	e59d3004 	ldr	r3, [sp, #4]
30018d20:	e5933004 	ldr	r3, [r3, #4]
30018d24:	e1a00003 	mov	r0, r3
30018d28:	ebfff554 	bl	30016280 <pbuf_free>
30018d2c:	e1a03000 	mov	r3, r0
30018d30:	e5cd300f 	strb	r3, [sp, #15]
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
30018d34:	e3a00004 	mov	r0, #4
30018d38:	e59d1004 	ldr	r1, [sp, #4]
30018d3c:	ebfff1e1 	bl	300154c8 <memp_free>
  }
  return count;
30018d40:	e5dd300f 	ldrb	r3, [sp, #15]
}
30018d44:	e1a00003 	mov	r0, r3
30018d48:	e28dd014 	add	sp, sp, #20
30018d4c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30018d50:	e12fff1e 	bx	lr

30018d54 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
30018d54:	e24dd008 	sub	sp, sp, #8
30018d58:	e58d0004 	str	r0, [sp, #4]
30018d5c:	e1a03001 	mov	r3, r1
30018d60:	e5cd3003 	strb	r3, [sp, #3]
  pcb->prio = prio;
30018d64:	e59d3004 	ldr	r3, [sp, #4]
30018d68:	e5dd2003 	ldrb	r2, [sp, #3]
30018d6c:	e5c32011 	strb	r2, [r3, #17]
}
30018d70:	e28dd008 	add	sp, sp, #8
30018d74:	e12fff1e 	bx	lr

30018d78 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
30018d78:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30018d7c:	e24dd014 	sub	sp, sp, #20
30018d80:	e58d0004 	str	r0, [sp, #4]
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
30018d84:	e3a00004 	mov	r0, #4
30018d88:	ebfff169 	bl	30015334 <memp_malloc>
30018d8c:	e1a03000 	mov	r3, r0
30018d90:	e58d300c 	str	r3, [sp, #12]
  if (cseg == NULL) {
30018d94:	e59d300c 	ldr	r3, [sp, #12]
30018d98:	e3530000 	cmp	r3, #0
30018d9c:	1a000001 	bne	30018da8 <tcp_seg_copy+0x30>
    return NULL;
30018da0:	e3a03000 	mov	r3, #0
30018da4:	ea000008 	b	30018dcc <tcp_seg_copy+0x54>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
30018da8:	e59d000c 	ldr	r0, [sp, #12]
30018dac:	e59d1004 	ldr	r1, [sp, #4]
30018db0:	e3a02014 	mov	r2, #20
30018db4:	ebffcd48 	bl	3000c2dc <acoral_memcpy>
  pbuf_ref(cseg->p);
30018db8:	e59d300c 	ldr	r3, [sp, #12]
30018dbc:	e5933004 	ldr	r3, [r3, #4]
30018dc0:	e1a00003 	mov	r0, r3
30018dc4:	ebfff585 	bl	300163e0 <pbuf_ref>
  return cseg;
30018dc8:	e59d300c 	ldr	r3, [sp, #12]
}
30018dcc:	e1a00003 	mov	r0, r3
30018dd0:	e28dd014 	add	sp, sp, #20
30018dd4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30018dd8:	e12fff1e 	bx	lr

30018ddc <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
30018ddc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30018de0:	e24dd014 	sub	sp, sp, #20
30018de4:	e58d000c 	str	r0, [sp, #12]
30018de8:	e58d1008 	str	r1, [sp, #8]
30018dec:	e58d2004 	str	r2, [sp, #4]
30018df0:	e5cd3003 	strb	r3, [sp, #3]
  arg = arg;
  if (p != NULL) {
30018df4:	e59d3004 	ldr	r3, [sp, #4]
30018df8:	e3530000 	cmp	r3, #0
30018dfc:	0a000002 	beq	30018e0c <tcp_recv_null+0x30>
    pbuf_free(p);
30018e00:	e59d0004 	ldr	r0, [sp, #4]
30018e04:	ebfff51d 	bl	30016280 <pbuf_free>
30018e08:	ea000008 	b	30018e30 <tcp_recv_null+0x54>
  } else if (err == ERR_OK) {
30018e0c:	e1dd30d3 	ldrsb	r3, [sp, #3]
30018e10:	e3530000 	cmp	r3, #0
30018e14:	1a000005 	bne	30018e30 <tcp_recv_null+0x54>
    return tcp_close(pcb);
30018e18:	e59d0008 	ldr	r0, [sp, #8]
30018e1c:	ebfff99e 	bl	3001749c <tcp_close>
30018e20:	e1a03000 	mov	r3, r0
30018e24:	e20330ff 	and	r3, r3, #255	; 0xff
30018e28:	e20330ff 	and	r3, r3, #255	; 0xff
30018e2c:	ea000000 	b	30018e34 <tcp_recv_null+0x58>
  }
  return ERR_OK;
30018e30:	e3a03000 	mov	r3, #0
30018e34:	e1a03c03 	lsl	r3, r3, #24
30018e38:	e1a03c43 	asr	r3, r3, #24
}
30018e3c:	e1a00003 	mov	r0, r3
30018e40:	e28dd014 	add	sp, sp, #20
30018e44:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30018e48:	e12fff1e 	bx	lr

30018e4c <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
30018e4c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30018e50:	e24dd01c 	sub	sp, sp, #28
30018e54:	e1a03000 	mov	r3, r0
30018e58:	e5cd3007 	strb	r3, [sp, #7]
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
30018e5c:	e3a0307f 	mov	r3, #127	; 0x7f
30018e60:	e5cd3017 	strb	r3, [sp, #23]
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
30018e64:	e3a03000 	mov	r3, #0
30018e68:	e58d3010 	str	r3, [sp, #16]
  inactive = NULL;
30018e6c:	e3a03000 	mov	r3, #0
30018e70:	e58d300c 	str	r3, [sp, #12]
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
30018e74:	e59f30b4 	ldr	r3, [pc, #180]	; 30018f30 <tcp_kill_prio+0xe4>
30018e78:	e5933000 	ldr	r3, [r3]
30018e7c:	e58d3008 	str	r3, [sp, #8]
30018e80:	ea00001f 	b	30018f04 <tcp_kill_prio+0xb8>
    if (pcb->prio <= prio &&
30018e84:	e59d3008 	ldr	r3, [sp, #8]
30018e88:	e5d33011 	ldrb	r3, [r3, #17]
30018e8c:	e5dd2007 	ldrb	r2, [sp, #7]
30018e90:	e1520003 	cmp	r2, r3
30018e94:	3a000017 	bcc	30018ef8 <tcp_kill_prio+0xac>
       pcb->prio <= mprio &&
30018e98:	e59d3008 	ldr	r3, [sp, #8]
30018e9c:	e5d33011 	ldrb	r3, [r3, #17]
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
30018ea0:	e5dd2017 	ldrb	r2, [sp, #23]
30018ea4:	e1520003 	cmp	r2, r3
30018ea8:	3a000012 	bcc	30018ef8 <tcp_kill_prio+0xac>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
30018eac:	e59f3080 	ldr	r3, [pc, #128]	; 30018f34 <tcp_kill_prio+0xe8>
30018eb0:	e5932000 	ldr	r2, [r3]
30018eb4:	e59d3008 	ldr	r3, [sp, #8]
30018eb8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30018ebc:	e0632002 	rsb	r2, r3, r2
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
30018ec0:	e59d3010 	ldr	r3, [sp, #16]
30018ec4:	e1520003 	cmp	r2, r3
30018ec8:	3a00000a 	bcc	30018ef8 <tcp_kill_prio+0xac>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
30018ecc:	e59f3060 	ldr	r3, [pc, #96]	; 30018f34 <tcp_kill_prio+0xe8>
30018ed0:	e5932000 	ldr	r2, [r3]
30018ed4:	e59d3008 	ldr	r3, [sp, #8]
30018ed8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30018edc:	e0633002 	rsb	r3, r3, r2
30018ee0:	e58d3010 	str	r3, [sp, #16]
      inactive = pcb;
30018ee4:	e59d3008 	ldr	r3, [sp, #8]
30018ee8:	e58d300c 	str	r3, [sp, #12]
      mprio = pcb->prio;
30018eec:	e59d3008 	ldr	r3, [sp, #8]
30018ef0:	e5d33011 	ldrb	r3, [r3, #17]
30018ef4:	e5cd3017 	strb	r3, [sp, #23]
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
30018ef8:	e59d3008 	ldr	r3, [sp, #8]
30018efc:	e593300c 	ldr	r3, [r3, #12]
30018f00:	e58d3008 	str	r3, [sp, #8]
30018f04:	e59d3008 	ldr	r3, [sp, #8]
30018f08:	e3530000 	cmp	r3, #0
30018f0c:	1affffdc 	bne	30018e84 <tcp_kill_prio+0x38>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
30018f10:	e59d300c 	ldr	r3, [sp, #12]
30018f14:	e3530000 	cmp	r3, #0
30018f18:	0a000001 	beq	30018f24 <tcp_kill_prio+0xd8>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
30018f1c:	e59d000c 	ldr	r0, [sp, #12]
30018f20:	ebfff9fc 	bl	30017718 <tcp_abort>
  }      
}
30018f24:	e28dd01c 	add	sp, sp, #28
30018f28:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30018f2c:	e12fff1e 	bx	lr
30018f30:	300eaa38 	.word	0x300eaa38
30018f34:	300eaa74 	.word	0x300eaa74

30018f38 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
30018f38:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30018f3c:	e24dd014 	sub	sp, sp, #20
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
30018f40:	e3a03000 	mov	r3, #0
30018f44:	e58d300c 	str	r3, [sp, #12]
  inactive = NULL;
30018f48:	e3a03000 	mov	r3, #0
30018f4c:	e58d3008 	str	r3, [sp, #8]
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
30018f50:	e59f3080 	ldr	r3, [pc, #128]	; 30018fd8 <tcp_kill_timewait+0xa0>
30018f54:	e5933000 	ldr	r3, [r3]
30018f58:	e58d3004 	str	r3, [sp, #4]
30018f5c:	ea000012 	b	30018fac <tcp_kill_timewait+0x74>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
30018f60:	e59f3074 	ldr	r3, [pc, #116]	; 30018fdc <tcp_kill_timewait+0xa4>
30018f64:	e5932000 	ldr	r2, [r3]
30018f68:	e59d3004 	ldr	r3, [sp, #4]
30018f6c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30018f70:	e0632002 	rsb	r2, r3, r2
30018f74:	e59d300c 	ldr	r3, [sp, #12]
30018f78:	e1520003 	cmp	r2, r3
30018f7c:	3a000007 	bcc	30018fa0 <tcp_kill_timewait+0x68>
      inactivity = tcp_ticks - pcb->tmr;
30018f80:	e59f3054 	ldr	r3, [pc, #84]	; 30018fdc <tcp_kill_timewait+0xa4>
30018f84:	e5932000 	ldr	r2, [r3]
30018f88:	e59d3004 	ldr	r3, [sp, #4]
30018f8c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30018f90:	e0633002 	rsb	r3, r3, r2
30018f94:	e58d300c 	str	r3, [sp, #12]
      inactive = pcb;
30018f98:	e59d3004 	ldr	r3, [sp, #4]
30018f9c:	e58d3008 	str	r3, [sp, #8]
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
30018fa0:	e59d3004 	ldr	r3, [sp, #4]
30018fa4:	e593300c 	ldr	r3, [r3, #12]
30018fa8:	e58d3004 	str	r3, [sp, #4]
30018fac:	e59d3004 	ldr	r3, [sp, #4]
30018fb0:	e3530000 	cmp	r3, #0
30018fb4:	1affffe9 	bne	30018f60 <tcp_kill_timewait+0x28>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
30018fb8:	e59d3008 	ldr	r3, [sp, #8]
30018fbc:	e3530000 	cmp	r3, #0
30018fc0:	0a000001 	beq	30018fcc <tcp_kill_timewait+0x94>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
30018fc4:	e59d0008 	ldr	r0, [sp, #8]
30018fc8:	ebfff9d2 	bl	30017718 <tcp_abort>
  }      
}
30018fcc:	e28dd014 	add	sp, sp, #20
30018fd0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30018fd4:	e12fff1e 	bx	lr
30018fd8:	302be508 	.word	0x302be508
30018fdc:	300eaa74 	.word	0x300eaa74

30018fe0 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
30018fe0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30018fe4:	e24dd014 	sub	sp, sp, #20
30018fe8:	e1a03000 	mov	r3, r0
30018fec:	e5cd3007 	strb	r3, [sp, #7]
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
30018ff0:	e3a00002 	mov	r0, #2
30018ff4:	ebfff0ce 	bl	30015334 <memp_malloc>
30018ff8:	e1a03000 	mov	r3, r0
30018ffc:	e58d3008 	str	r3, [sp, #8]
  if (pcb == NULL) {
30019000:	e59d3008 	ldr	r3, [sp, #8]
30019004:	e3530000 	cmp	r3, #0
30019008:	1a00000e 	bne	30019048 <tcp_alloc+0x68>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
3001900c:	ebffffc9 	bl	30018f38 <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
30019010:	e3a00002 	mov	r0, #2
30019014:	ebfff0c6 	bl	30015334 <memp_malloc>
30019018:	e1a03000 	mov	r3, r0
3001901c:	e58d3008 	str	r3, [sp, #8]
    if (pcb == NULL) {
30019020:	e59d3008 	ldr	r3, [sp, #8]
30019024:	e3530000 	cmp	r3, #0
30019028:	1a000006 	bne	30019048 <tcp_alloc+0x68>
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
3001902c:	e5dd3007 	ldrb	r3, [sp, #7]
30019030:	e1a00003 	mov	r0, r3
30019034:	ebffff84 	bl	30018e4c <tcp_kill_prio>
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
30019038:	e3a00002 	mov	r0, #2
3001903c:	ebfff0bc 	bl	30015334 <memp_malloc>
30019040:	e1a03000 	mov	r3, r0
30019044:	e58d3008 	str	r3, [sp, #8]
    }
  }
  if (pcb != NULL) {
30019048:	e59d3008 	ldr	r3, [sp, #8]
3001904c:	e3530000 	cmp	r3, #0
30019050:	0a00004d 	beq	3001918c <tcp_alloc+0x1ac>
    memset(pcb, 0, sizeof(struct tcp_pcb));
30019054:	e59d0008 	ldr	r0, [sp, #8]
30019058:	e3a01000 	mov	r1, #0
3001905c:	e3a020a4 	mov	r2, #164	; 0xa4
30019060:	ebffcc81 	bl	3000c26c <acoral_memset>
    pcb->prio = TCP_PRIO_NORMAL;
30019064:	e59d3008 	ldr	r3, [sp, #8]
30019068:	e3a02040 	mov	r2, #64	; 0x40
3001906c:	e5c32011 	strb	r2, [r3, #17]
    pcb->snd_buf = TCP_SND_BUF;
30019070:	e59d3008 	ldr	r3, [sp, #8]
30019074:	e3a02a02 	mov	r2, #8192	; 0x2000
30019078:	e1c326ba 	strh	r2, [r3, #106]	; 0x6a
    pcb->snd_queuelen = 0;
3001907c:	e59d3008 	ldr	r3, [sp, #8]
30019080:	e3a02000 	mov	r2, #0
30019084:	e1c326bc 	strh	r2, [r3, #108]	; 0x6c
    pcb->rcv_wnd = TCP_WND;
30019088:	e59d3008 	ldr	r3, [sp, #8]
3001908c:	e3a02a02 	mov	r2, #8192	; 0x2000
30019090:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
    pcb->rcv_ann_wnd = TCP_WND;
30019094:	e59d3008 	ldr	r3, [sp, #8]
30019098:	e3a02a02 	mov	r2, #8192	; 0x2000
3001909c:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
    pcb->tos = 0;
300190a0:	e59d3008 	ldr	r3, [sp, #8]
300190a4:	e3a02000 	mov	r2, #0
300190a8:	e5c3200a 	strb	r2, [r3, #10]
    pcb->ttl = TCP_TTL;
300190ac:	e59d3008 	ldr	r3, [sp, #8]
300190b0:	e3e02000 	mvn	r2, #0
300190b4:	e5c3200b 	strb	r2, [r3, #11]
    /* The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
300190b8:	e59d3008 	ldr	r3, [sp, #8]
300190bc:	e3a02f86 	mov	r2, #536	; 0x218
300190c0:	e1c323b0 	strh	r2, [r3, #48]	; 0x30
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
300190c4:	e59d3008 	ldr	r3, [sp, #8]
300190c8:	e3a02006 	mov	r2, #6
300190cc:	e1c324b0 	strh	r2, [r3, #64]	; 0x40
    pcb->sa = 0;
300190d0:	e59d3008 	ldr	r3, [sp, #8]
300190d4:	e3a02000 	mov	r2, #0
300190d8:	e1c323bc 	strh	r2, [r3, #60]	; 0x3c
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
300190dc:	e59d3008 	ldr	r3, [sp, #8]
300190e0:	e3a02006 	mov	r2, #6
300190e4:	e1c323be 	strh	r2, [r3, #62]	; 0x3e
    pcb->rtime = -1;
300190e8:	e59d3008 	ldr	r3, [sp, #8]
300190ec:	e3e02000 	mvn	r2, #0
300190f0:	e1c322be 	strh	r2, [r3, #46]	; 0x2e
    pcb->cwnd = 1;
300190f4:	e59d3008 	ldr	r3, [sp, #8]
300190f8:	e3a02001 	mov	r2, #1
300190fc:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
    iss = tcp_next_iss();
30019100:	eb0000ea 	bl	300194b0 <tcp_next_iss>
30019104:	e1a03000 	mov	r3, r0
30019108:	e58d300c 	str	r3, [sp, #12]
    pcb->snd_wl2 = iss;
3001910c:	e59d3008 	ldr	r3, [sp, #8]
30019110:	e59d200c 	ldr	r2, [sp, #12]
30019114:	e5832060 	str	r2, [r3, #96]	; 0x60
    pcb->snd_nxt = iss;
30019118:	e59d3008 	ldr	r3, [sp, #8]
3001911c:	e59d200c 	ldr	r2, [sp, #12]
30019120:	e5832050 	str	r2, [r3, #80]	; 0x50
    pcb->snd_max = iss;
30019124:	e59d3008 	ldr	r3, [sp, #8]
30019128:	e59d200c 	ldr	r2, [sp, #12]
3001912c:	e5832054 	str	r2, [r3, #84]	; 0x54
    pcb->lastack = iss;
30019130:	e59d3008 	ldr	r3, [sp, #8]
30019134:	e59d200c 	ldr	r2, [sp, #12]
30019138:	e5832044 	str	r2, [r3, #68]	; 0x44
    pcb->snd_lbb = iss;   
3001913c:	e59d3008 	ldr	r3, [sp, #8]
30019140:	e59d200c 	ldr	r2, [sp, #12]
30019144:	e5832064 	str	r2, [r3, #100]	; 0x64
    pcb->tmr = tcp_ticks;
30019148:	e59f3050 	ldr	r3, [pc, #80]	; 300191a0 <tcp_alloc+0x1c0>
3001914c:	e5932000 	ldr	r2, [r3]
30019150:	e59d3008 	ldr	r3, [sp, #8]
30019154:	e5832028 	str	r2, [r3, #40]	; 0x28

    pcb->polltmr = 0;
30019158:	e59d3008 	ldr	r3, [sp, #8]
3001915c:	e3a02000 	mov	r2, #0
30019160:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
30019164:	e59d3008 	ldr	r3, [sp, #8]
30019168:	e59f2034 	ldr	r2, [pc, #52]	; 300191a4 <tcp_alloc+0x1c4>
3001916c:	e5832084 	str	r2, [r3, #132]	; 0x84
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
30019170:	e59d2008 	ldr	r2, [sp, #8]
30019174:	e3a0386d 	mov	r3, #7143424	; 0x6d0000
30019178:	e2833cdd 	add	r3, r3, #56576	; 0xdd00
3001917c:	e5823098 	str	r3, [r2, #152]	; 0x98
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
30019180:	e59d3008 	ldr	r3, [sp, #8]
30019184:	e3a02000 	mov	r2, #0
30019188:	e5c320a1 	strb	r2, [r3, #161]	; 0xa1
  }
  return pcb;
3001918c:	e59d3008 	ldr	r3, [sp, #8]
}
30019190:	e1a00003 	mov	r0, r3
30019194:	e28dd014 	add	sp, sp, #20
30019198:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001919c:	e12fff1e 	bx	lr
300191a0:	300eaa74 	.word	0x300eaa74
300191a4:	30018ddc 	.word	0x30018ddc

300191a8 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
300191a8:	e92d4008 	push	{r3, lr}
  return tcp_alloc(TCP_PRIO_NORMAL);
300191ac:	e3a00040 	mov	r0, #64	; 0x40
300191b0:	ebffff8a 	bl	30018fe0 <tcp_alloc>
300191b4:	e1a03000 	mov	r3, r0
}
300191b8:	e1a00003 	mov	r0, r3
300191bc:	e8bd4008 	pop	{r3, lr}
300191c0:	e12fff1e 	bx	lr

300191c4 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
300191c4:	e24dd008 	sub	sp, sp, #8
300191c8:	e58d0004 	str	r0, [sp, #4]
300191cc:	e58d1000 	str	r1, [sp]
  pcb->callback_arg = arg;
300191d0:	e59d3004 	ldr	r3, [sp, #4]
300191d4:	e59d2000 	ldr	r2, [sp]
300191d8:	e5832014 	str	r2, [r3, #20]
}
300191dc:	e28dd008 	add	sp, sp, #8
300191e0:	e12fff1e 	bx	lr

300191e4 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
300191e4:	e24dd008 	sub	sp, sp, #8
300191e8:	e58d0004 	str	r0, [sp, #4]
300191ec:	e58d1000 	str	r1, [sp]
  pcb->recv = recv;
300191f0:	e59d3004 	ldr	r3, [sp, #4]
300191f4:	e59d2000 	ldr	r2, [sp]
300191f8:	e5832084 	str	r2, [r3, #132]	; 0x84
}
300191fc:	e28dd008 	add	sp, sp, #8
30019200:	e12fff1e 	bx	lr

30019204 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
30019204:	e24dd008 	sub	sp, sp, #8
30019208:	e58d0004 	str	r0, [sp, #4]
3001920c:	e58d1000 	str	r1, [sp]
  pcb->sent = sent;
30019210:	e59d3004 	ldr	r3, [sp, #4]
30019214:	e59d2000 	ldr	r2, [sp]
30019218:	e5832080 	str	r2, [r3, #128]	; 0x80
}
3001921c:	e28dd008 	add	sp, sp, #8
30019220:	e12fff1e 	bx	lr

30019224 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
30019224:	e24dd008 	sub	sp, sp, #8
30019228:	e58d0004 	str	r0, [sp, #4]
3001922c:	e58d1000 	str	r1, [sp]
  pcb->errf = errf;
30019230:	e59d3004 	ldr	r3, [sp, #4]
30019234:	e59d2000 	ldr	r2, [sp]
30019238:	e5832094 	str	r2, [r3, #148]	; 0x94
}
3001923c:	e28dd008 	add	sp, sp, #8
30019240:	e12fff1e 	bx	lr

30019244 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
30019244:	e24dd008 	sub	sp, sp, #8
30019248:	e58d0004 	str	r0, [sp, #4]
3001924c:	e58d1000 	str	r1, [sp]
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
30019250:	e59d3004 	ldr	r3, [sp, #4]
30019254:	e59d2000 	ldr	r2, [sp]
30019258:	e583201c 	str	r2, [r3, #28]
}
3001925c:	e28dd008 	add	sp, sp, #8
30019260:	e12fff1e 	bx	lr

30019264 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
30019264:	e24dd010 	sub	sp, sp, #16
30019268:	e58d000c 	str	r0, [sp, #12]
3001926c:	e58d1008 	str	r1, [sp, #8]
30019270:	e1a03002 	mov	r3, r2
30019274:	e5cd3007 	strb	r3, [sp, #7]
#if LWIP_CALLBACK_API
  pcb->poll = poll;
30019278:	e59d300c 	ldr	r3, [sp, #12]
3001927c:	e59d2008 	ldr	r2, [sp, #8]
30019280:	e5832090 	str	r2, [r3, #144]	; 0x90
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
30019284:	e59d300c 	ldr	r3, [sp, #12]
30019288:	e5dd2007 	ldrb	r2, [sp, #7]
3001928c:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
}
30019290:	e28dd010 	add	sp, sp, #16
30019294:	e12fff1e 	bx	lr

30019298 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
30019298:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001929c:	e24dd00c 	sub	sp, sp, #12
300192a0:	e58d0004 	str	r0, [sp, #4]
  if (pcb->state != CLOSED &&
300192a4:	e59d3004 	ldr	r3, [sp, #4]
300192a8:	e5d33010 	ldrb	r3, [r3, #16]
300192ac:	e3530000 	cmp	r3, #0
300192b0:	0a00002b 	beq	30019364 <tcp_pcb_purge+0xcc>
     pcb->state != TIME_WAIT &&
300192b4:	e59d3004 	ldr	r3, [sp, #4]
300192b8:	e5d33010 	ldrb	r3, [r3, #16]
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
300192bc:	e353000a 	cmp	r3, #10
300192c0:	0a000027 	beq	30019364 <tcp_pcb_purge+0xcc>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
300192c4:	e59d3004 	ldr	r3, [sp, #4]
300192c8:	e5d33010 	ldrb	r3, [r3, #16]
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
300192cc:	e3530001 	cmp	r3, #1
300192d0:	0a000023 	beq	30019364 <tcp_pcb_purge+0xcc>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
300192d4:	e59d3004 	ldr	r3, [sp, #4]
300192d8:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
300192dc:	e3530000 	cmp	r3, #0
300192e0:	0a000006 	beq	30019300 <tcp_pcb_purge+0x68>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
300192e4:	e59d3004 	ldr	r3, [sp, #4]
300192e8:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
300192ec:	e1a00003 	mov	r0, r3
300192f0:	ebfff3e2 	bl	30016280 <pbuf_free>
      pcb->refused_data = NULL;
300192f4:	e59d3004 	ldr	r3, [sp, #4]
300192f8:	e3a02000 	mov	r2, #0
300192fc:	e583207c 	str	r2, [r3, #124]	; 0x7c
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
30019300:	e59d3004 	ldr	r3, [sp, #4]
30019304:	e3e02000 	mvn	r2, #0
30019308:	e1c322be 	strh	r2, [r3, #46]	; 0x2e

    tcp_segs_free(pcb->ooseq);
3001930c:	e59d3004 	ldr	r3, [sp, #4]
30019310:	e5933078 	ldr	r3, [r3, #120]	; 0x78
30019314:	e1a00003 	mov	r0, r3
30019318:	ebfffe59 	bl	30018c84 <tcp_segs_free>
    pcb->ooseq = NULL;
3001931c:	e59d3004 	ldr	r3, [sp, #4]
30019320:	e3a02000 	mov	r2, #0
30019324:	e5832078 	str	r2, [r3, #120]	; 0x78
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
30019328:	e59d3004 	ldr	r3, [sp, #4]
3001932c:	e5933070 	ldr	r3, [r3, #112]	; 0x70
30019330:	e1a00003 	mov	r0, r3
30019334:	ebfffe52 	bl	30018c84 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
30019338:	e59d3004 	ldr	r3, [sp, #4]
3001933c:	e5933074 	ldr	r3, [r3, #116]	; 0x74
30019340:	e1a00003 	mov	r0, r3
30019344:	ebfffe4e 	bl	30018c84 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
30019348:	e59d3004 	ldr	r3, [sp, #4]
3001934c:	e3a02000 	mov	r2, #0
30019350:	e5832070 	str	r2, [r3, #112]	; 0x70
30019354:	e59d3004 	ldr	r3, [sp, #4]
30019358:	e5932070 	ldr	r2, [r3, #112]	; 0x70
3001935c:	e59d3004 	ldr	r3, [sp, #4]
30019360:	e5832074 	str	r2, [r3, #116]	; 0x74
  }
}
30019364:	e28dd00c 	add	sp, sp, #12
30019368:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001936c:	e12fff1e 	bx	lr

30019370 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
30019370:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30019374:	e24dd00c 	sub	sp, sp, #12
30019378:	e58d0004 	str	r0, [sp, #4]
3001937c:	e58d1000 	str	r1, [sp]
  TCP_RMV(pcblist, pcb);
30019380:	e59d3004 	ldr	r3, [sp, #4]
30019384:	e5932000 	ldr	r2, [r3]
30019388:	e59d3000 	ldr	r3, [sp]
3001938c:	e1520003 	cmp	r2, r3
30019390:	1a000005 	bne	300193ac <tcp_pcb_remove+0x3c>
30019394:	e59d3004 	ldr	r3, [sp, #4]
30019398:	e5933000 	ldr	r3, [r3]
3001939c:	e593200c 	ldr	r2, [r3, #12]
300193a0:	e59d3004 	ldr	r3, [sp, #4]
300193a4:	e5832000 	str	r2, [r3]
300193a8:	ea00001e 	b	30019428 <tcp_pcb_remove+0xb8>
300193ac:	e59d3004 	ldr	r3, [sp, #4]
300193b0:	e5932000 	ldr	r2, [r3]
300193b4:	e59f30f0 	ldr	r3, [pc, #240]	; 300194ac <tcp_pcb_remove+0x13c>
300193b8:	e5832000 	str	r2, [r3]
300193bc:	ea000015 	b	30019418 <tcp_pcb_remove+0xa8>
300193c0:	e59f30e4 	ldr	r3, [pc, #228]	; 300194ac <tcp_pcb_remove+0x13c>
300193c4:	e5933000 	ldr	r3, [r3]
300193c8:	e593300c 	ldr	r3, [r3, #12]
300193cc:	e3530000 	cmp	r3, #0
300193d0:	0a00000b 	beq	30019404 <tcp_pcb_remove+0x94>
300193d4:	e59f30d0 	ldr	r3, [pc, #208]	; 300194ac <tcp_pcb_remove+0x13c>
300193d8:	e5933000 	ldr	r3, [r3]
300193dc:	e593200c 	ldr	r2, [r3, #12]
300193e0:	e59d3000 	ldr	r3, [sp]
300193e4:	e1520003 	cmp	r2, r3
300193e8:	1a000005 	bne	30019404 <tcp_pcb_remove+0x94>
300193ec:	e59f30b8 	ldr	r3, [pc, #184]	; 300194ac <tcp_pcb_remove+0x13c>
300193f0:	e5933000 	ldr	r3, [r3]
300193f4:	e59d2000 	ldr	r2, [sp]
300193f8:	e592200c 	ldr	r2, [r2, #12]
300193fc:	e583200c 	str	r2, [r3, #12]
30019400:	ea000008 	b	30019428 <tcp_pcb_remove+0xb8>
30019404:	e59f30a0 	ldr	r3, [pc, #160]	; 300194ac <tcp_pcb_remove+0x13c>
30019408:	e5933000 	ldr	r3, [r3]
3001940c:	e593200c 	ldr	r2, [r3, #12]
30019410:	e59f3094 	ldr	r3, [pc, #148]	; 300194ac <tcp_pcb_remove+0x13c>
30019414:	e5832000 	str	r2, [r3]
30019418:	e59f308c 	ldr	r3, [pc, #140]	; 300194ac <tcp_pcb_remove+0x13c>
3001941c:	e5933000 	ldr	r3, [r3]
30019420:	e3530000 	cmp	r3, #0
30019424:	1affffe5 	bne	300193c0 <tcp_pcb_remove+0x50>
30019428:	e59d3000 	ldr	r3, [sp]
3001942c:	e3a02000 	mov	r2, #0
30019430:	e583200c 	str	r2, [r3, #12]

  tcp_pcb_purge(pcb);
30019434:	e59d0000 	ldr	r0, [sp]
30019438:	ebffff96 	bl	30019298 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
3001943c:	e59d3000 	ldr	r3, [sp]
30019440:	e5d33010 	ldrb	r3, [r3, #16]
30019444:	e353000a 	cmp	r3, #10
30019448:	0a000011 	beq	30019494 <tcp_pcb_remove+0x124>
     pcb->state != LISTEN &&
3001944c:	e59d3000 	ldr	r3, [sp]
30019450:	e5d33010 	ldrb	r3, [r3, #16]
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
30019454:	e3530001 	cmp	r3, #1
30019458:	0a00000d 	beq	30019494 <tcp_pcb_remove+0x124>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
3001945c:	e59d3000 	ldr	r3, [sp]
30019460:	e5d3301c 	ldrb	r3, [r3, #28]
30019464:	e2033001 	and	r3, r3, #1
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
30019468:	e20330ff 	and	r3, r3, #255	; 0xff
3001946c:	e3530000 	cmp	r3, #0
30019470:	0a000007 	beq	30019494 <tcp_pcb_remove+0x124>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
30019474:	e59d3000 	ldr	r3, [sp]
30019478:	e5d3301c 	ldrb	r3, [r3, #28]
3001947c:	e3833002 	orr	r3, r3, #2
30019480:	e20320ff 	and	r2, r3, #255	; 0xff
30019484:	e59d3000 	ldr	r3, [sp]
30019488:	e5c3201c 	strb	r2, [r3, #28]
    tcp_output(pcb);
3001948c:	e59d0000 	ldr	r0, [sp]
30019490:	eb0012cf 	bl	3001dfd4 <tcp_output>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
30019494:	e59d3000 	ldr	r3, [sp]
30019498:	e3a02000 	mov	r2, #0
3001949c:	e5c32010 	strb	r2, [r3, #16]

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
300194a0:	e28dd00c 	add	sp, sp, #12
300194a4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300194a8:	e12fff1e 	bx	lr
300194ac:	3012a850 	.word	0x3012a850

300194b0 <tcp_next_iss>:
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
300194b0:	e59f3024 	ldr	r3, [pc, #36]	; 300194dc <tcp_next_iss+0x2c>
300194b4:	e5932000 	ldr	r2, [r3]
300194b8:	e59f3020 	ldr	r3, [pc, #32]	; 300194e0 <tcp_next_iss+0x30>
300194bc:	e5933000 	ldr	r3, [r3]
300194c0:	e0822003 	add	r2, r2, r3
300194c4:	e59f3010 	ldr	r3, [pc, #16]	; 300194dc <tcp_next_iss+0x2c>
300194c8:	e5832000 	str	r2, [r3]
  return iss;
300194cc:	e59f3008 	ldr	r3, [pc, #8]	; 300194dc <tcp_next_iss+0x2c>
300194d0:	e5933000 	ldr	r3, [r3]
}
300194d4:	e1a00003 	mov	r0, r3
300194d8:	e12fff1e 	bx	lr
300194dc:	300466c0 	.word	0x300466c0
300194e0:	300eaa74 	.word	0x300eaa74

300194e4 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
300194e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300194e8:	e24dd014 	sub	sp, sp, #20
300194ec:	e1a03000 	mov	r3, r0
300194f0:	e58d1000 	str	r1, [sp]
300194f4:	e1cd30b6 	strh	r3, [sp, #6]
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
300194f8:	e59d0000 	ldr	r0, [sp]
300194fc:	ebffea94 	bl	30013f54 <ip_route>
30019500:	e1a03000 	mov	r3, r0
30019504:	e58d300c 	str	r3, [sp, #12]
  if ((outif != NULL) && (outif->mtu != 0)) {
30019508:	e59d300c 	ldr	r3, [sp, #12]
3001950c:	e3530000 	cmp	r3, #0
30019510:	0a00000c 	beq	30019548 <tcp_eff_send_mss+0x64>
30019514:	e59d300c 	ldr	r3, [sp, #12]
30019518:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
3001951c:	e3530000 	cmp	r3, #0
30019520:	0a000008 	beq	30019548 <tcp_eff_send_mss+0x64>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
30019524:	e59d300c 	ldr	r3, [sp, #12]
30019528:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
3001952c:	e2433028 	sub	r3, r3, #40	; 0x28
30019530:	e1cd30ba 	strh	r3, [sp, #10]
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
30019534:	e1dd20ba 	ldrh	r2, [sp, #10]
30019538:	e1dd30b6 	ldrh	r3, [sp, #6]
3001953c:	e1520003 	cmp	r2, r3
30019540:	31a03002 	movcc	r3, r2
30019544:	e1cd30b6 	strh	r3, [sp, #6]
  }
  return sendmss;
30019548:	e1dd30b6 	ldrh	r3, [sp, #6]
}
3001954c:	e1a00003 	mov	r0, r3
30019550:	e28dd014 	add	sp, sp, #20
30019554:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30019558:	e12fff1e 	bx	lr

3001955c <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
3001955c:	e92d4010 	push	{r4, lr}
30019560:	e24dd030 	sub	sp, sp, #48	; 0x30
30019564:	e58d000c 	str	r0, [sp, #12]
30019568:	e58d1008 	str	r1, [sp, #8]
	//===============
	// test by pegasus
		struct pbuf *q;
		int i, plen = p->tot_len;
3001956c:	e59d300c 	ldr	r3, [sp, #12]
30019570:	e1d330b8 	ldrh	r3, [r3, #8]
30019574:	e58d3018 	str	r3, [sp, #24]
  u8_t hdrlen;
  err_t err;

  PERF_START;

  TCP_STATS_INC(tcp.recv);
30019578:	e59f3e08 	ldr	r3, [pc, #3592]	; 3001a388 <tcp_input+0xe2c>
3001957c:	e1d33ab0 	ldrh	r3, [r3, #160]	; 0xa0
30019580:	e2833001 	add	r3, r3, #1
30019584:	e1a03803 	lsl	r3, r3, #16
30019588:	e1a02823 	lsr	r2, r3, #16
3001958c:	e59f3df4 	ldr	r3, [pc, #3572]	; 3001a388 <tcp_input+0xe2c>
30019590:	e1c32ab0 	strh	r2, [r3, #160]	; 0xa0
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
30019594:	e59d300c 	ldr	r3, [sp, #12]
30019598:	e5933004 	ldr	r3, [r3, #4]
3001959c:	e1a02003 	mov	r2, r3
300195a0:	e59f3df0 	ldr	r3, [pc, #3568]	; 3001a398 <tcp_input+0xe3c>
300195a4:	e5832000 	str	r2, [r3]
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
300195a8:	e59d300c 	ldr	r3, [sp, #12]
300195ac:	e5933004 	ldr	r3, [r3, #4]
300195b0:	e1a04003 	mov	r4, r3
300195b4:	e59f3ddc 	ldr	r3, [pc, #3548]	; 3001a398 <tcp_input+0xe3c>
300195b8:	e5933000 	ldr	r3, [r3]
300195bc:	e5d32000 	ldrb	r2, [r3]
300195c0:	e5d33001 	ldrb	r3, [r3, #1]
300195c4:	e1a03403 	lsl	r3, r3, #8
300195c8:	e1833002 	orr	r3, r3, r2
300195cc:	e1a03803 	lsl	r3, r3, #16
300195d0:	e1a03823 	lsr	r3, r3, #16
300195d4:	e1a00003 	mov	r0, r3
300195d8:	ebffe81b 	bl	3001364c <ntohs>
300195dc:	e1a03000 	mov	r3, r0
300195e0:	e1a03423 	lsr	r3, r3, #8
300195e4:	e1a03803 	lsl	r3, r3, #16
300195e8:	e1a03823 	lsr	r3, r3, #16
300195ec:	e203300f 	and	r3, r3, #15
300195f0:	e1a03103 	lsl	r3, r3, #2
300195f4:	e0842003 	add	r2, r4, r3
300195f8:	e59f3d9c 	ldr	r3, [pc, #3484]	; 3001a39c <tcp_input+0xe40>
300195fc:	e5832000 	str	r2, [r3]
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
30019600:	e59f3d90 	ldr	r3, [pc, #3472]	; 3001a398 <tcp_input+0xe3c>
30019604:	e5933000 	ldr	r3, [r3]
30019608:	e5d32000 	ldrb	r2, [r3]
3001960c:	e5d33001 	ldrb	r3, [r3, #1]
30019610:	e1a03403 	lsl	r3, r3, #8
30019614:	e1833002 	orr	r3, r3, r2
30019618:	e1a03803 	lsl	r3, r3, #16
3001961c:	e1a03823 	lsr	r3, r3, #16
30019620:	e1a00003 	mov	r0, r3
30019624:	ebffe808 	bl	3001364c <ntohs>
30019628:	e1a03000 	mov	r3, r0
3001962c:	e1a03423 	lsr	r3, r3, #8
30019630:	e1a03803 	lsl	r3, r3, #16
30019634:	e1a03823 	lsr	r3, r3, #16
30019638:	e203300f 	and	r3, r3, #15
3001963c:	e1a03103 	lsl	r3, r3, #2
30019640:	e1a03803 	lsl	r3, r3, #16
30019644:	e1a03823 	lsr	r3, r3, #16
30019648:	e2633000 	rsb	r3, r3, #0
3001964c:	e1a03803 	lsl	r3, r3, #16
30019650:	e1a03823 	lsr	r3, r3, #16
30019654:	e1a03803 	lsl	r3, r3, #16
30019658:	e1a03843 	asr	r3, r3, #16
3001965c:	e59d000c 	ldr	r0, [sp, #12]
30019660:	e1a01003 	mov	r1, r3
30019664:	ebfff2a0 	bl	300160ec <pbuf_header>
30019668:	e1a03000 	mov	r3, r0
3001966c:	e3530000 	cmp	r3, #0
30019670:	1a000003 	bne	30019684 <tcp_input+0x128>
30019674:	e59d300c 	ldr	r3, [sp, #12]
30019678:	e1d330b8 	ldrh	r3, [r3, #8]
3001967c:	e3530013 	cmp	r3, #19
30019680:	8a000010 	bhi	300196c8 <tcp_input+0x16c>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
30019684:	e59f3cfc 	ldr	r3, [pc, #3324]	; 3001a388 <tcp_input+0xe2c>
30019688:	e1d33ab8 	ldrh	r3, [r3, #168]	; 0xa8
3001968c:	e2833001 	add	r3, r3, #1
30019690:	e1a03803 	lsl	r3, r3, #16
30019694:	e1a02823 	lsr	r2, r3, #16
30019698:	e59f3ce8 	ldr	r3, [pc, #3304]	; 3001a388 <tcp_input+0xe2c>
3001969c:	e1c32ab8 	strh	r2, [r3, #168]	; 0xa8
    TCP_STATS_INC(tcp.drop);
300196a0:	e59f3ce0 	ldr	r3, [pc, #3296]	; 3001a388 <tcp_input+0xe2c>
300196a4:	e1d33ab4 	ldrh	r3, [r3, #164]	; 0xa4
300196a8:	e2833001 	add	r3, r3, #1
300196ac:	e1a03803 	lsl	r3, r3, #16
300196b0:	e1a02823 	lsr	r2, r3, #16
300196b4:	e59f3ccc 	ldr	r3, [pc, #3276]	; 3001a388 <tcp_input+0xe2c>
300196b8:	e1c32ab4 	strh	r2, [r3, #164]	; 0xa4
    snmp_inc_tcpinerrs();
    pbuf_free(p);
300196bc:	e59d000c 	ldr	r0, [sp, #12]
300196c0:	ebfff2ee 	bl	30016280 <pbuf_free>
    return;
300196c4:	ea000377 	b	3001a4a8 <tcp_input+0xf4c>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
300196c8:	e59f3cc8 	ldr	r3, [pc, #3272]	; 3001a398 <tcp_input+0xe3c>
300196cc:	e5933000 	ldr	r3, [r3]
300196d0:	e2833010 	add	r3, r3, #16
300196d4:	e1a00003 	mov	r0, r3
300196d8:	e59d1008 	ldr	r1, [sp, #8]
300196dc:	ebffed5d 	bl	30014c58 <ip_addr_isbroadcast>
300196e0:	e1a03000 	mov	r3, r0
300196e4:	e3530000 	cmp	r3, #0
300196e8:	1a000015 	bne	30019744 <tcp_input+0x1e8>
      ip_addr_ismulticast(&(iphdr->dest))) {
300196ec:	e59f3ca4 	ldr	r3, [pc, #3236]	; 3001a398 <tcp_input+0xe3c>
300196f0:	e5933000 	ldr	r3, [r3]
300196f4:	e5d32010 	ldrb	r2, [r3, #16]
300196f8:	e5d31011 	ldrb	r1, [r3, #17]
300196fc:	e1a01401 	lsl	r1, r1, #8
30019700:	e1812002 	orr	r2, r1, r2
30019704:	e5d31012 	ldrb	r1, [r3, #18]
30019708:	e1a01801 	lsl	r1, r1, #16
3001970c:	e1812002 	orr	r2, r1, r2
30019710:	e5d33013 	ldrb	r3, [r3, #19]
30019714:	e1a03c03 	lsl	r3, r3, #24
30019718:	e1833002 	orr	r3, r3, r2
3001971c:	e1a04003 	mov	r4, r3
30019720:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
30019724:	ebffe7e6 	bl	300136c4 <ntohl>
30019728:	e1a03000 	mov	r3, r0
3001972c:	e0044003 	and	r4, r4, r3
30019730:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
30019734:	ebffe7e2 	bl	300136c4 <ntohl>
30019738:	e1a03000 	mov	r3, r0
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
3001973c:	e1540003 	cmp	r4, r3
30019740:	1a000010 	bne	30019788 <tcp_input+0x22c>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
30019744:	e59f3c3c 	ldr	r3, [pc, #3132]	; 3001a388 <tcp_input+0xe2c>
30019748:	e1d33abe 	ldrh	r3, [r3, #174]	; 0xae
3001974c:	e2833001 	add	r3, r3, #1
30019750:	e1a03803 	lsl	r3, r3, #16
30019754:	e1a02823 	lsr	r2, r3, #16
30019758:	e59f3c28 	ldr	r3, [pc, #3112]	; 3001a388 <tcp_input+0xe2c>
3001975c:	e1c32abe 	strh	r2, [r3, #174]	; 0xae
    TCP_STATS_INC(tcp.drop);
30019760:	e59f3c20 	ldr	r3, [pc, #3104]	; 3001a388 <tcp_input+0xe2c>
30019764:	e1d33ab4 	ldrh	r3, [r3, #164]	; 0xa4
30019768:	e2833001 	add	r3, r3, #1
3001976c:	e1a03803 	lsl	r3, r3, #16
30019770:	e1a02823 	lsr	r2, r3, #16
30019774:	e59f3c0c 	ldr	r3, [pc, #3084]	; 3001a388 <tcp_input+0xe2c>
30019778:	e1c32ab4 	strh	r2, [r3, #164]	; 0xa4
    snmp_inc_tcpinerrs();
    pbuf_free(p);
3001977c:	e59d000c 	ldr	r0, [sp, #12]
30019780:	ebfff2be 	bl	30016280 <pbuf_free>
    return;
30019784:	ea000347 	b	3001a4a8 <tcp_input+0xf4c>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
30019788:	e59f3c08 	ldr	r3, [pc, #3080]	; 3001a398 <tcp_input+0xe3c>
3001978c:	e5933000 	ldr	r3, [r3]
30019790:	e283200c 	add	r2, r3, #12
      (struct ip_addr *)&(iphdr->dest),
30019794:	e59f3bfc 	ldr	r3, [pc, #3068]	; 3001a398 <tcp_input+0xe3c>
30019798:	e5933000 	ldr	r3, [r3]
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
3001979c:	e2833010 	add	r3, r3, #16
300197a0:	e59d100c 	ldr	r1, [sp, #12]
300197a4:	e1d110b8 	ldrh	r1, [r1, #8]
300197a8:	e58d1000 	str	r1, [sp]
300197ac:	e59d000c 	ldr	r0, [sp, #12]
300197b0:	e1a01002 	mov	r1, r2
300197b4:	e1a02003 	mov	r2, r3
300197b8:	e3a03006 	mov	r3, #6
300197bc:	ebffe816 	bl	3001381c <inet_chksum_pseudo>
300197c0:	e1a03000 	mov	r3, r0
300197c4:	e3530000 	cmp	r3, #0
300197c8:	0a000010 	beq	30019810 <tcp_input+0x2b4>
        inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src), (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len)));
#if TCP_DEBUG
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
300197cc:	e59f3bb4 	ldr	r3, [pc, #2996]	; 3001a388 <tcp_input+0xe2c>
300197d0:	e1d33ab6 	ldrh	r3, [r3, #166]	; 0xa6
300197d4:	e2833001 	add	r3, r3, #1
300197d8:	e1a03803 	lsl	r3, r3, #16
300197dc:	e1a02823 	lsr	r2, r3, #16
300197e0:	e59f3ba0 	ldr	r3, [pc, #2976]	; 3001a388 <tcp_input+0xe2c>
300197e4:	e1c32ab6 	strh	r2, [r3, #166]	; 0xa6
    TCP_STATS_INC(tcp.drop);
300197e8:	e59f3b98 	ldr	r3, [pc, #2968]	; 3001a388 <tcp_input+0xe2c>
300197ec:	e1d33ab4 	ldrh	r3, [r3, #164]	; 0xa4
300197f0:	e2833001 	add	r3, r3, #1
300197f4:	e1a03803 	lsl	r3, r3, #16
300197f8:	e1a02823 	lsr	r2, r3, #16
300197fc:	e59f3b84 	ldr	r3, [pc, #2948]	; 3001a388 <tcp_input+0xe2c>
30019800:	e1c32ab4 	strh	r2, [r3, #164]	; 0xa4
    snmp_inc_tcpinerrs();
    pbuf_free(p);
30019804:	e59d000c 	ldr	r0, [sp, #12]
30019808:	ebfff29c 	bl	30016280 <pbuf_free>
    return;
3001980c:	ea000325 	b	3001a4a8 <tcp_input+0xf4c>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
30019810:	e59f3b84 	ldr	r3, [pc, #2948]	; 3001a39c <tcp_input+0xe40>
30019814:	e5933000 	ldr	r3, [r3]
30019818:	e5d3200c 	ldrb	r2, [r3, #12]
3001981c:	e5d3300d 	ldrb	r3, [r3, #13]
30019820:	e1a03403 	lsl	r3, r3, #8
30019824:	e1833002 	orr	r3, r3, r2
30019828:	e1a03803 	lsl	r3, r3, #16
3001982c:	e1a03823 	lsr	r3, r3, #16
30019830:	e1a00003 	mov	r0, r3
30019834:	ebffe784 	bl	3001364c <ntohs>
30019838:	e1a03000 	mov	r3, r0
3001983c:	e1a03623 	lsr	r3, r3, #12
30019840:	e1a03803 	lsl	r3, r3, #16
30019844:	e1a03823 	lsr	r3, r3, #16
30019848:	e5cd302e 	strb	r3, [sp, #46]	; 0x2e
  if(pbuf_header(p, -(hdrlen * 4))){
3001984c:	e5dd302e 	ldrb	r3, [sp, #46]	; 0x2e
30019850:	e1a02003 	mov	r2, r3
30019854:	e1a02702 	lsl	r2, r2, #14
30019858:	e0633002 	rsb	r3, r3, r2
3001985c:	e1a03103 	lsl	r3, r3, #2
30019860:	e1a03803 	lsl	r3, r3, #16
30019864:	e1a03823 	lsr	r3, r3, #16
30019868:	e1a03803 	lsl	r3, r3, #16
3001986c:	e1a03843 	asr	r3, r3, #16
30019870:	e59d000c 	ldr	r0, [sp, #12]
30019874:	e1a01003 	mov	r1, r3
30019878:	ebfff21b 	bl	300160ec <pbuf_header>
3001987c:	e1a03000 	mov	r3, r0
30019880:	e3530000 	cmp	r3, #0
30019884:	0a000010 	beq	300198cc <tcp_input+0x370>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
30019888:	e59f3af8 	ldr	r3, [pc, #2808]	; 3001a388 <tcp_input+0xe2c>
3001988c:	e1d33ab8 	ldrh	r3, [r3, #168]	; 0xa8
30019890:	e2833001 	add	r3, r3, #1
30019894:	e1a03803 	lsl	r3, r3, #16
30019898:	e1a02823 	lsr	r2, r3, #16
3001989c:	e59f3ae4 	ldr	r3, [pc, #2788]	; 3001a388 <tcp_input+0xe2c>
300198a0:	e1c32ab8 	strh	r2, [r3, #168]	; 0xa8
    TCP_STATS_INC(tcp.drop);
300198a4:	e59f3adc 	ldr	r3, [pc, #2780]	; 3001a388 <tcp_input+0xe2c>
300198a8:	e1d33ab4 	ldrh	r3, [r3, #164]	; 0xa4
300198ac:	e2833001 	add	r3, r3, #1
300198b0:	e1a03803 	lsl	r3, r3, #16
300198b4:	e1a02823 	lsr	r2, r3, #16
300198b8:	e59f3ac8 	ldr	r3, [pc, #2760]	; 3001a388 <tcp_input+0xe2c>
300198bc:	e1c32ab4 	strh	r2, [r3, #164]	; 0xa4
    snmp_inc_tcpinerrs();
    pbuf_free(p);
300198c0:	e59d000c 	ldr	r0, [sp, #12]
300198c4:	ebfff26d 	bl	30016280 <pbuf_free>
    return;
300198c8:	ea0002f6 	b	3001a4a8 <tcp_input+0xf4c>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
300198cc:	e59f3ac8 	ldr	r3, [pc, #2760]	; 3001a39c <tcp_input+0xe40>
300198d0:	e5934000 	ldr	r4, [r3]
300198d4:	e59f3ac0 	ldr	r3, [pc, #2752]	; 3001a39c <tcp_input+0xe40>
300198d8:	e5933000 	ldr	r3, [r3]
300198dc:	e5d32000 	ldrb	r2, [r3]
300198e0:	e5d33001 	ldrb	r3, [r3, #1]
300198e4:	e1a03403 	lsl	r3, r3, #8
300198e8:	e1833002 	orr	r3, r3, r2
300198ec:	e1a03803 	lsl	r3, r3, #16
300198f0:	e1a03823 	lsr	r3, r3, #16
300198f4:	e1a00003 	mov	r0, r3
300198f8:	ebffe753 	bl	3001364c <ntohs>
300198fc:	e1a03000 	mov	r3, r0
30019900:	e20320ff 	and	r2, r3, #255	; 0xff
30019904:	e3a01000 	mov	r1, #0
30019908:	e1812002 	orr	r2, r1, r2
3001990c:	e5c42000 	strb	r2, [r4]
30019910:	e1a03423 	lsr	r3, r3, #8
30019914:	e1a03803 	lsl	r3, r3, #16
30019918:	e1a03823 	lsr	r3, r3, #16
3001991c:	e3a02000 	mov	r2, #0
30019920:	e1823003 	orr	r3, r2, r3
30019924:	e5c43001 	strb	r3, [r4, #1]
  tcphdr->dest = ntohs(tcphdr->dest);
30019928:	e59f3a6c 	ldr	r3, [pc, #2668]	; 3001a39c <tcp_input+0xe40>
3001992c:	e5934000 	ldr	r4, [r3]
30019930:	e59f3a64 	ldr	r3, [pc, #2660]	; 3001a39c <tcp_input+0xe40>
30019934:	e5933000 	ldr	r3, [r3]
30019938:	e5d32002 	ldrb	r2, [r3, #2]
3001993c:	e5d33003 	ldrb	r3, [r3, #3]
30019940:	e1a03403 	lsl	r3, r3, #8
30019944:	e1833002 	orr	r3, r3, r2
30019948:	e1a03803 	lsl	r3, r3, #16
3001994c:	e1a03823 	lsr	r3, r3, #16
30019950:	e1a00003 	mov	r0, r3
30019954:	ebffe73c 	bl	3001364c <ntohs>
30019958:	e1a03000 	mov	r3, r0
3001995c:	e20320ff 	and	r2, r3, #255	; 0xff
30019960:	e3a01000 	mov	r1, #0
30019964:	e1812002 	orr	r2, r1, r2
30019968:	e5c42002 	strb	r2, [r4, #2]
3001996c:	e1a03423 	lsr	r3, r3, #8
30019970:	e1a03803 	lsl	r3, r3, #16
30019974:	e1a03823 	lsr	r3, r3, #16
30019978:	e3a02000 	mov	r2, #0
3001997c:	e1823003 	orr	r3, r2, r3
30019980:	e5c43003 	strb	r3, [r4, #3]
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
30019984:	e59f3a10 	ldr	r3, [pc, #2576]	; 3001a39c <tcp_input+0xe40>
30019988:	e5934000 	ldr	r4, [r3]
3001998c:	e59f3a08 	ldr	r3, [pc, #2568]	; 3001a39c <tcp_input+0xe40>
30019990:	e5933000 	ldr	r3, [r3]
30019994:	e5d32004 	ldrb	r2, [r3, #4]
30019998:	e5d31005 	ldrb	r1, [r3, #5]
3001999c:	e1a01401 	lsl	r1, r1, #8
300199a0:	e1812002 	orr	r2, r1, r2
300199a4:	e5d31006 	ldrb	r1, [r3, #6]
300199a8:	e1a01801 	lsl	r1, r1, #16
300199ac:	e1812002 	orr	r2, r1, r2
300199b0:	e5d33007 	ldrb	r3, [r3, #7]
300199b4:	e1a03c03 	lsl	r3, r3, #24
300199b8:	e1833002 	orr	r3, r3, r2
300199bc:	e1a00003 	mov	r0, r3
300199c0:	ebffe73f 	bl	300136c4 <ntohl>
300199c4:	e1a03000 	mov	r3, r0
300199c8:	e20320ff 	and	r2, r3, #255	; 0xff
300199cc:	e3a01000 	mov	r1, #0
300199d0:	e1812002 	orr	r2, r1, r2
300199d4:	e5c42004 	strb	r2, [r4, #4]
300199d8:	e1a02423 	lsr	r2, r3, #8
300199dc:	e20220ff 	and	r2, r2, #255	; 0xff
300199e0:	e3a01000 	mov	r1, #0
300199e4:	e1812002 	orr	r2, r1, r2
300199e8:	e5c42005 	strb	r2, [r4, #5]
300199ec:	e1a02823 	lsr	r2, r3, #16
300199f0:	e20220ff 	and	r2, r2, #255	; 0xff
300199f4:	e3a01000 	mov	r1, #0
300199f8:	e1812002 	orr	r2, r1, r2
300199fc:	e5c42006 	strb	r2, [r4, #6]
30019a00:	e1a03c23 	lsr	r3, r3, #24
30019a04:	e3a02000 	mov	r2, #0
30019a08:	e1823003 	orr	r3, r2, r3
30019a0c:	e5c43007 	strb	r3, [r4, #7]
30019a10:	e5d43004 	ldrb	r3, [r4, #4]
30019a14:	e5d42005 	ldrb	r2, [r4, #5]
30019a18:	e1a02402 	lsl	r2, r2, #8
30019a1c:	e1823003 	orr	r3, r2, r3
30019a20:	e5d42006 	ldrb	r2, [r4, #6]
30019a24:	e1a02802 	lsl	r2, r2, #16
30019a28:	e1823003 	orr	r3, r2, r3
30019a2c:	e5d42007 	ldrb	r2, [r4, #7]
30019a30:	e1a02c02 	lsl	r2, r2, #24
30019a34:	e1823003 	orr	r3, r2, r3
30019a38:	e1a02003 	mov	r2, r3
30019a3c:	e59f3950 	ldr	r3, [pc, #2384]	; 3001a394 <tcp_input+0xe38>
30019a40:	e5832000 	str	r2, [r3]
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
30019a44:	e59f3950 	ldr	r3, [pc, #2384]	; 3001a39c <tcp_input+0xe40>
30019a48:	e5934000 	ldr	r4, [r3]
30019a4c:	e59f3948 	ldr	r3, [pc, #2376]	; 3001a39c <tcp_input+0xe40>
30019a50:	e5933000 	ldr	r3, [r3]
30019a54:	e5d32008 	ldrb	r2, [r3, #8]
30019a58:	e5d31009 	ldrb	r1, [r3, #9]
30019a5c:	e1a01401 	lsl	r1, r1, #8
30019a60:	e1812002 	orr	r2, r1, r2
30019a64:	e5d3100a 	ldrb	r1, [r3, #10]
30019a68:	e1a01801 	lsl	r1, r1, #16
30019a6c:	e1812002 	orr	r2, r1, r2
30019a70:	e5d3300b 	ldrb	r3, [r3, #11]
30019a74:	e1a03c03 	lsl	r3, r3, #24
30019a78:	e1833002 	orr	r3, r3, r2
30019a7c:	e1a00003 	mov	r0, r3
30019a80:	ebffe70f 	bl	300136c4 <ntohl>
30019a84:	e1a03000 	mov	r3, r0
30019a88:	e20320ff 	and	r2, r3, #255	; 0xff
30019a8c:	e3a01000 	mov	r1, #0
30019a90:	e1812002 	orr	r2, r1, r2
30019a94:	e5c42008 	strb	r2, [r4, #8]
30019a98:	e1a02423 	lsr	r2, r3, #8
30019a9c:	e20220ff 	and	r2, r2, #255	; 0xff
30019aa0:	e3a01000 	mov	r1, #0
30019aa4:	e1812002 	orr	r2, r1, r2
30019aa8:	e5c42009 	strb	r2, [r4, #9]
30019aac:	e1a02823 	lsr	r2, r3, #16
30019ab0:	e20220ff 	and	r2, r2, #255	; 0xff
30019ab4:	e3a01000 	mov	r1, #0
30019ab8:	e1812002 	orr	r2, r1, r2
30019abc:	e5c4200a 	strb	r2, [r4, #10]
30019ac0:	e1a03c23 	lsr	r3, r3, #24
30019ac4:	e3a02000 	mov	r2, #0
30019ac8:	e1823003 	orr	r3, r2, r3
30019acc:	e5c4300b 	strb	r3, [r4, #11]
30019ad0:	e5d43008 	ldrb	r3, [r4, #8]
30019ad4:	e5d42009 	ldrb	r2, [r4, #9]
30019ad8:	e1a02402 	lsl	r2, r2, #8
30019adc:	e1823003 	orr	r3, r2, r3
30019ae0:	e5d4200a 	ldrb	r2, [r4, #10]
30019ae4:	e1a02802 	lsl	r2, r2, #16
30019ae8:	e1823003 	orr	r3, r2, r3
30019aec:	e5d4200b 	ldrb	r2, [r4, #11]
30019af0:	e1a02c02 	lsl	r2, r2, #24
30019af4:	e1823003 	orr	r3, r2, r3
30019af8:	e1a02003 	mov	r2, r3
30019afc:	e59f3888 	ldr	r3, [pc, #2184]	; 3001a38c <tcp_input+0xe30>
30019b00:	e5832000 	str	r2, [r3]
  tcphdr->wnd = ntohs(tcphdr->wnd);
30019b04:	e59f3890 	ldr	r3, [pc, #2192]	; 3001a39c <tcp_input+0xe40>
30019b08:	e5934000 	ldr	r4, [r3]
30019b0c:	e59f3888 	ldr	r3, [pc, #2184]	; 3001a39c <tcp_input+0xe40>
30019b10:	e5933000 	ldr	r3, [r3]
30019b14:	e5d3200e 	ldrb	r2, [r3, #14]
30019b18:	e5d3300f 	ldrb	r3, [r3, #15]
30019b1c:	e1a03403 	lsl	r3, r3, #8
30019b20:	e1833002 	orr	r3, r3, r2
30019b24:	e1a03803 	lsl	r3, r3, #16
30019b28:	e1a03823 	lsr	r3, r3, #16
30019b2c:	e1a00003 	mov	r0, r3
30019b30:	ebffe6c5 	bl	3001364c <ntohs>
30019b34:	e1a03000 	mov	r3, r0
30019b38:	e20320ff 	and	r2, r3, #255	; 0xff
30019b3c:	e3a01000 	mov	r1, #0
30019b40:	e1812002 	orr	r2, r1, r2
30019b44:	e5c4200e 	strb	r2, [r4, #14]
30019b48:	e1a03423 	lsr	r3, r3, #8
30019b4c:	e1a03803 	lsl	r3, r3, #16
30019b50:	e1a03823 	lsr	r3, r3, #16
30019b54:	e3a02000 	mov	r2, #0
30019b58:	e1823003 	orr	r3, r2, r3
30019b5c:	e5c4300f 	strb	r3, [r4, #15]

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
30019b60:	e59f3834 	ldr	r3, [pc, #2100]	; 3001a39c <tcp_input+0xe40>
30019b64:	e5933000 	ldr	r3, [r3]
30019b68:	e5d3200c 	ldrb	r2, [r3, #12]
30019b6c:	e5d3300d 	ldrb	r3, [r3, #13]
30019b70:	e1a03403 	lsl	r3, r3, #8
30019b74:	e1833002 	orr	r3, r3, r2
30019b78:	e1a03803 	lsl	r3, r3, #16
30019b7c:	e1a03823 	lsr	r3, r3, #16
30019b80:	e1a00003 	mov	r0, r3
30019b84:	ebffe6b0 	bl	3001364c <ntohs>
30019b88:	e1a03000 	mov	r3, r0
30019b8c:	e20330ff 	and	r3, r3, #255	; 0xff
30019b90:	e203303f 	and	r3, r3, #63	; 0x3f
30019b94:	e59f27cc 	ldr	r2, [pc, #1996]	; 3001a368 <tcp_input+0xe0c>
30019b98:	e5c23000 	strb	r3, [r2]
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
30019b9c:	e59d300c 	ldr	r3, [sp, #12]
30019ba0:	e1d320b8 	ldrh	r2, [r3, #8]
30019ba4:	e59f37bc 	ldr	r3, [pc, #1980]	; 3001a368 <tcp_input+0xe0c>
30019ba8:	e5d33000 	ldrb	r3, [r3]
30019bac:	e2033001 	and	r3, r3, #1
30019bb0:	e20330ff 	and	r3, r3, #255	; 0xff
30019bb4:	e3530000 	cmp	r3, #0
30019bb8:	1a000004 	bne	30019bd0 <tcp_input+0x674>
30019bbc:	e59f37a4 	ldr	r3, [pc, #1956]	; 3001a368 <tcp_input+0xe0c>
30019bc0:	e5d33000 	ldrb	r3, [r3]
30019bc4:	e2033002 	and	r3, r3, #2
30019bc8:	e3530000 	cmp	r3, #0
30019bcc:	0a000001 	beq	30019bd8 <tcp_input+0x67c>
30019bd0:	e3a03001 	mov	r3, #1
30019bd4:	ea000000 	b	30019bdc <tcp_input+0x680>
30019bd8:	e3a03000 	mov	r3, #0
30019bdc:	e1a03803 	lsl	r3, r3, #16
30019be0:	e1a03823 	lsr	r3, r3, #16
30019be4:	e0823003 	add	r3, r2, r3
30019be8:	e1a03803 	lsl	r3, r3, #16
30019bec:	e1a02823 	lsr	r2, r3, #16
30019bf0:	e59f3798 	ldr	r3, [pc, #1944]	; 3001a390 <tcp_input+0xe34>
30019bf4:	e1c320b0 	strh	r2, [r3]

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
30019bf8:	e3a03000 	mov	r3, #0
30019bfc:	e58d3024 	str	r3, [sp, #36]	; 0x24

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
30019c00:	e59f3764 	ldr	r3, [pc, #1892]	; 3001a36c <tcp_input+0xe10>
30019c04:	e5933000 	ldr	r3, [r3]
30019c08:	e58d3020 	str	r3, [sp, #32]
30019c0c:	ea00004b 	b	30019d40 <tcp_input+0x7e4>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
30019c10:	e59d3020 	ldr	r3, [sp, #32]
30019c14:	e1d321ba 	ldrh	r2, [r3, #26]
30019c18:	e59f377c 	ldr	r3, [pc, #1916]	; 3001a39c <tcp_input+0xe40>
30019c1c:	e5933000 	ldr	r3, [r3]
30019c20:	e5d31000 	ldrb	r1, [r3]
30019c24:	e5d33001 	ldrb	r3, [r3, #1]
30019c28:	e1a03403 	lsl	r3, r3, #8
30019c2c:	e1833001 	orr	r3, r3, r1
30019c30:	e1a03803 	lsl	r3, r3, #16
30019c34:	e1a03823 	lsr	r3, r3, #16
30019c38:	e1520003 	cmp	r2, r3
30019c3c:	1a00003a 	bne	30019d2c <tcp_input+0x7d0>
       pcb->local_port == tcphdr->dest &&
30019c40:	e59d3020 	ldr	r3, [sp, #32]
30019c44:	e1d321b8 	ldrh	r2, [r3, #24]
30019c48:	e59f374c 	ldr	r3, [pc, #1868]	; 3001a39c <tcp_input+0xe40>
30019c4c:	e5933000 	ldr	r3, [r3]
30019c50:	e5d31002 	ldrb	r1, [r3, #2]
30019c54:	e5d33003 	ldrb	r3, [r3, #3]
30019c58:	e1a03403 	lsl	r3, r3, #8
30019c5c:	e1833001 	orr	r3, r3, r1
30019c60:	e1a03803 	lsl	r3, r3, #16
30019c64:	e1a03823 	lsr	r3, r3, #16
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
30019c68:	e1520003 	cmp	r2, r3
30019c6c:	1a00002e 	bne	30019d2c <tcp_input+0x7d0>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
30019c70:	e59d3020 	ldr	r3, [sp, #32]
30019c74:	e5932004 	ldr	r2, [r3, #4]
30019c78:	e59f3718 	ldr	r3, [pc, #1816]	; 3001a398 <tcp_input+0xe3c>
30019c7c:	e5933000 	ldr	r3, [r3]
30019c80:	e5d3100c 	ldrb	r1, [r3, #12]
30019c84:	e5d3000d 	ldrb	r0, [r3, #13]
30019c88:	e1a00400 	lsl	r0, r0, #8
30019c8c:	e1801001 	orr	r1, r0, r1
30019c90:	e5d3000e 	ldrb	r0, [r3, #14]
30019c94:	e1a00800 	lsl	r0, r0, #16
30019c98:	e1801001 	orr	r1, r0, r1
30019c9c:	e5d3300f 	ldrb	r3, [r3, #15]
30019ca0:	e1a03c03 	lsl	r3, r3, #24
30019ca4:	e1833001 	orr	r3, r3, r1
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
30019ca8:	e1520003 	cmp	r2, r3
30019cac:	1a00001e 	bne	30019d2c <tcp_input+0x7d0>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
30019cb0:	e59d3020 	ldr	r3, [sp, #32]
30019cb4:	e5932000 	ldr	r2, [r3]
30019cb8:	e59f36d8 	ldr	r3, [pc, #1752]	; 3001a398 <tcp_input+0xe3c>
30019cbc:	e5933000 	ldr	r3, [r3]
30019cc0:	e5d31010 	ldrb	r1, [r3, #16]
30019cc4:	e5d30011 	ldrb	r0, [r3, #17]
30019cc8:	e1a00400 	lsl	r0, r0, #8
30019ccc:	e1801001 	orr	r1, r0, r1
30019cd0:	e5d30012 	ldrb	r0, [r3, #18]
30019cd4:	e1a00800 	lsl	r0, r0, #16
30019cd8:	e1801001 	orr	r1, r0, r1
30019cdc:	e5d33013 	ldrb	r3, [r3, #19]
30019ce0:	e1a03c03 	lsl	r3, r3, #24
30019ce4:	e1833001 	orr	r3, r3, r1
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
30019ce8:	e1520003 	cmp	r2, r3
30019cec:	1a00000e 	bne	30019d2c <tcp_input+0x7d0>

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
30019cf0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30019cf4:	e3530000 	cmp	r3, #0
30019cf8:	0a000014 	beq	30019d50 <tcp_input+0x7f4>
        prev->next = pcb->next;
30019cfc:	e59d3020 	ldr	r3, [sp, #32]
30019d00:	e593200c 	ldr	r2, [r3, #12]
30019d04:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30019d08:	e583200c 	str	r2, [r3, #12]
        pcb->next = tcp_active_pcbs;
30019d0c:	e59f3658 	ldr	r3, [pc, #1624]	; 3001a36c <tcp_input+0xe10>
30019d10:	e5932000 	ldr	r2, [r3]
30019d14:	e59d3020 	ldr	r3, [sp, #32]
30019d18:	e583200c 	str	r2, [r3, #12]
        tcp_active_pcbs = pcb;
30019d1c:	e59f3648 	ldr	r3, [pc, #1608]	; 3001a36c <tcp_input+0xe10>
30019d20:	e59d2020 	ldr	r2, [sp, #32]
30019d24:	e5832000 	str	r2, [r3]
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
30019d28:	ea000009 	b	30019d54 <tcp_input+0x7f8>
    }
    prev = pcb;
30019d2c:	e59d3020 	ldr	r3, [sp, #32]
30019d30:	e58d3024 	str	r3, [sp, #36]	; 0x24
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
30019d34:	e59d3020 	ldr	r3, [sp, #32]
30019d38:	e593300c 	ldr	r3, [r3, #12]
30019d3c:	e58d3020 	str	r3, [sp, #32]
30019d40:	e59d3020 	ldr	r3, [sp, #32]
30019d44:	e3530000 	cmp	r3, #0
30019d48:	1affffb0 	bne	30019c10 <tcp_input+0x6b4>
30019d4c:	ea000000 	b	30019d54 <tcp_input+0x7f8>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
30019d50:	e1a00000 	nop			; (mov r0, r0)
    }
    prev = pcb;
  }

  if (pcb == NULL) {
30019d54:	e59d3020 	ldr	r3, [sp, #32]
30019d58:	e3530000 	cmp	r3, #0
30019d5c:	1a00008a 	bne	30019f8c <tcp_input+0xa30>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
30019d60:	e59f3608 	ldr	r3, [pc, #1544]	; 3001a370 <tcp_input+0xe14>
30019d64:	e5933000 	ldr	r3, [r3]
30019d68:	e58d3020 	str	r3, [sp, #32]
30019d6c:	ea00003f 	b	30019e70 <tcp_input+0x914>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
30019d70:	e59d3020 	ldr	r3, [sp, #32]
30019d74:	e1d321ba 	ldrh	r2, [r3, #26]
30019d78:	e59f361c 	ldr	r3, [pc, #1564]	; 3001a39c <tcp_input+0xe40>
30019d7c:	e5933000 	ldr	r3, [r3]
30019d80:	e5d31000 	ldrb	r1, [r3]
30019d84:	e5d33001 	ldrb	r3, [r3, #1]
30019d88:	e1a03403 	lsl	r3, r3, #8
30019d8c:	e1833001 	orr	r3, r3, r1
30019d90:	e1a03803 	lsl	r3, r3, #16
30019d94:	e1a03823 	lsr	r3, r3, #16
30019d98:	e1520003 	cmp	r2, r3
30019d9c:	1a000030 	bne	30019e64 <tcp_input+0x908>
         pcb->local_port == tcphdr->dest &&
30019da0:	e59d3020 	ldr	r3, [sp, #32]
30019da4:	e1d321b8 	ldrh	r2, [r3, #24]
30019da8:	e59f35ec 	ldr	r3, [pc, #1516]	; 3001a39c <tcp_input+0xe40>
30019dac:	e5933000 	ldr	r3, [r3]
30019db0:	e5d31002 	ldrb	r1, [r3, #2]
30019db4:	e5d33003 	ldrb	r3, [r3, #3]
30019db8:	e1a03403 	lsl	r3, r3, #8
30019dbc:	e1833001 	orr	r3, r3, r1
30019dc0:	e1a03803 	lsl	r3, r3, #16
30019dc4:	e1a03823 	lsr	r3, r3, #16
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
30019dc8:	e1520003 	cmp	r2, r3
30019dcc:	1a000024 	bne	30019e64 <tcp_input+0x908>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
30019dd0:	e59d3020 	ldr	r3, [sp, #32]
30019dd4:	e5932004 	ldr	r2, [r3, #4]
30019dd8:	e59f35b8 	ldr	r3, [pc, #1464]	; 3001a398 <tcp_input+0xe3c>
30019ddc:	e5933000 	ldr	r3, [r3]
30019de0:	e5d3100c 	ldrb	r1, [r3, #12]
30019de4:	e5d3000d 	ldrb	r0, [r3, #13]
30019de8:	e1a00400 	lsl	r0, r0, #8
30019dec:	e1801001 	orr	r1, r0, r1
30019df0:	e5d3000e 	ldrb	r0, [r3, #14]
30019df4:	e1a00800 	lsl	r0, r0, #16
30019df8:	e1801001 	orr	r1, r0, r1
30019dfc:	e5d3300f 	ldrb	r3, [r3, #15]
30019e00:	e1a03c03 	lsl	r3, r3, #24
30019e04:	e1833001 	orr	r3, r3, r1
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
30019e08:	e1520003 	cmp	r2, r3
30019e0c:	1a000014 	bne	30019e64 <tcp_input+0x908>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
30019e10:	e59d3020 	ldr	r3, [sp, #32]
30019e14:	e5932000 	ldr	r2, [r3]
30019e18:	e59f3578 	ldr	r3, [pc, #1400]	; 3001a398 <tcp_input+0xe3c>
30019e1c:	e5933000 	ldr	r3, [r3]
30019e20:	e5d31010 	ldrb	r1, [r3, #16]
30019e24:	e5d30011 	ldrb	r0, [r3, #17]
30019e28:	e1a00400 	lsl	r0, r0, #8
30019e2c:	e1801001 	orr	r1, r0, r1
30019e30:	e5d30012 	ldrb	r0, [r3, #18]
30019e34:	e1a00800 	lsl	r0, r0, #16
30019e38:	e1801001 	orr	r1, r0, r1
30019e3c:	e5d33013 	ldrb	r3, [r3, #19]
30019e40:	e1a03c03 	lsl	r3, r3, #24
30019e44:	e1833001 	orr	r3, r3, r1
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
30019e48:	e1520003 	cmp	r2, r3
30019e4c:	1a000004 	bne	30019e64 <tcp_input+0x908>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
30019e50:	e59d0020 	ldr	r0, [sp, #32]
30019e54:	eb000275 	bl	3001a830 <tcp_timewait_input>
        pbuf_free(p);
30019e58:	e59d000c 	ldr	r0, [sp, #12]
30019e5c:	ebfff107 	bl	30016280 <pbuf_free>
        return;
30019e60:	ea000190 	b	3001a4a8 <tcp_input+0xf4c>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
30019e64:	e59d3020 	ldr	r3, [sp, #32]
30019e68:	e593300c 	ldr	r3, [r3, #12]
30019e6c:	e58d3020 	str	r3, [sp, #32]
30019e70:	e59d3020 	ldr	r3, [sp, #32]
30019e74:	e3530000 	cmp	r3, #0
30019e78:	1affffbc 	bne	30019d70 <tcp_input+0x814>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
30019e7c:	e3a03000 	mov	r3, #0
30019e80:	e58d3024 	str	r3, [sp, #36]	; 0x24
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
30019e84:	e59f34e8 	ldr	r3, [pc, #1256]	; 3001a374 <tcp_input+0xe18>
30019e88:	e5933000 	ldr	r3, [r3]
30019e8c:	e58d3028 	str	r3, [sp, #40]	; 0x28
30019e90:	ea00003a 	b	30019f80 <tcp_input+0xa24>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
30019e94:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30019e98:	e3530000 	cmp	r3, #0
30019e9c:	0a000013 	beq	30019ef0 <tcp_input+0x994>
30019ea0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30019ea4:	e5933000 	ldr	r3, [r3]
30019ea8:	e3530000 	cmp	r3, #0
30019eac:	0a00000f 	beq	30019ef0 <tcp_input+0x994>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
30019eb0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30019eb4:	e5932000 	ldr	r2, [r3]
30019eb8:	e59f34d8 	ldr	r3, [pc, #1240]	; 3001a398 <tcp_input+0xe3c>
30019ebc:	e5933000 	ldr	r3, [r3]
30019ec0:	e5d31010 	ldrb	r1, [r3, #16]
30019ec4:	e5d30011 	ldrb	r0, [r3, #17]
30019ec8:	e1a00400 	lsl	r0, r0, #8
30019ecc:	e1801001 	orr	r1, r0, r1
30019ed0:	e5d30012 	ldrb	r0, [r3, #18]
30019ed4:	e1a00800 	lsl	r0, r0, #16
30019ed8:	e1801001 	orr	r1, r0, r1
30019edc:	e5d33013 	ldrb	r3, [r3, #19]
30019ee0:	e1a03c03 	lsl	r3, r3, #24
30019ee4:	e1833001 	orr	r3, r3, r1

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
30019ee8:	e1520003 	cmp	r2, r3
30019eec:	1a00001e 	bne	30019f6c <tcp_input+0xa10>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
30019ef0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30019ef4:	e1d321b8 	ldrh	r2, [r3, #24]
30019ef8:	e59f349c 	ldr	r3, [pc, #1180]	; 3001a39c <tcp_input+0xe40>
30019efc:	e5933000 	ldr	r3, [r3]
30019f00:	e5d31002 	ldrb	r1, [r3, #2]
30019f04:	e5d33003 	ldrb	r3, [r3, #3]
30019f08:	e1a03403 	lsl	r3, r3, #8
30019f0c:	e1833001 	orr	r3, r3, r1
30019f10:	e1a03803 	lsl	r3, r3, #16
30019f14:	e1a03823 	lsr	r3, r3, #16

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
30019f18:	e1520003 	cmp	r2, r3
30019f1c:	1a000012 	bne	30019f6c <tcp_input+0xa10>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
30019f20:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30019f24:	e3530000 	cmp	r3, #0
30019f28:	0a00000a 	beq	30019f58 <tcp_input+0x9fc>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
30019f2c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30019f30:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30019f34:	e592200c 	ldr	r2, [r2, #12]
30019f38:	e583200c 	str	r2, [r3, #12]
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
30019f3c:	e59f3430 	ldr	r3, [pc, #1072]	; 3001a374 <tcp_input+0xe18>
30019f40:	e5932000 	ldr	r2, [r3]
30019f44:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30019f48:	e583200c 	str	r2, [r3, #12]
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
30019f4c:	e59f3420 	ldr	r3, [pc, #1056]	; 3001a374 <tcp_input+0xe18>
30019f50:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30019f54:	e5832000 	str	r2, [r3]
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
30019f58:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
30019f5c:	eb000154 	bl	3001a4b4 <tcp_listen_input>
        pbuf_free(p);
30019f60:	e59d000c 	ldr	r0, [sp, #12]
30019f64:	ebfff0c5 	bl	30016280 <pbuf_free>
        return;
30019f68:	ea00014e 	b	3001a4a8 <tcp_input+0xf4c>
      }
      prev = (struct tcp_pcb *)lpcb;
30019f6c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30019f70:	e58d3024 	str	r3, [sp, #36]	; 0x24
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
30019f74:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30019f78:	e593300c 	ldr	r3, [r3, #12]
30019f7c:	e58d3028 	str	r3, [sp, #40]	; 0x28
30019f80:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30019f84:	e3530000 	cmp	r3, #0
30019f88:	1affffc1 	bne	30019e94 <tcp_input+0x938>
			lwip_printf("\r\n<*<*<*>*>*>\r\n");

		}
		lwip_printf("\r\n+++++++++++++++++++++\r\n");
		/**/
  if (pcb != NULL) {
30019f8c:	e59d3020 	ldr	r3, [sp, #32]
30019f90:	e3530000 	cmp	r3, #0
30019f94:	0a000101 	beq	3001a3a0 <tcp_input+0xe44>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
30019f98:	e59f33d8 	ldr	r3, [pc, #984]	; 3001a378 <tcp_input+0xe1c>
30019f9c:	e3a02000 	mov	r2, #0
30019fa0:	e5832000 	str	r2, [r3]
    inseg.len = p->tot_len;
30019fa4:	e59d300c 	ldr	r3, [sp, #12]
30019fa8:	e1d320b8 	ldrh	r2, [r3, #8]
30019fac:	e59f33c4 	ldr	r3, [pc, #964]	; 3001a378 <tcp_input+0xe1c>
30019fb0:	e1c320bc 	strh	r2, [r3, #12]
    inseg.dataptr = p->payload;
30019fb4:	e59d300c 	ldr	r3, [sp, #12]
30019fb8:	e5932004 	ldr	r2, [r3, #4]
30019fbc:	e59f33b4 	ldr	r3, [pc, #948]	; 3001a378 <tcp_input+0xe1c>
30019fc0:	e5832008 	str	r2, [r3, #8]
    inseg.p = p;
30019fc4:	e59f33ac 	ldr	r3, [pc, #940]	; 3001a378 <tcp_input+0xe1c>
30019fc8:	e59d200c 	ldr	r2, [sp, #12]
30019fcc:	e5832004 	str	r2, [r3, #4]
    inseg.tcphdr = tcphdr;
30019fd0:	e59f33c4 	ldr	r3, [pc, #964]	; 3001a39c <tcp_input+0xe40>
30019fd4:	e5932000 	ldr	r2, [r3]
30019fd8:	e59f3398 	ldr	r3, [pc, #920]	; 3001a378 <tcp_input+0xe1c>
30019fdc:	e5832010 	str	r2, [r3, #16]

    recv_data = NULL;
30019fe0:	e59f3394 	ldr	r3, [pc, #916]	; 3001a37c <tcp_input+0xe20>
30019fe4:	e3a02000 	mov	r2, #0
30019fe8:	e5832000 	str	r2, [r3]
    recv_flags = 0;
30019fec:	e59f338c 	ldr	r3, [pc, #908]	; 3001a380 <tcp_input+0xe24>
30019ff0:	e3a02000 	mov	r2, #0
30019ff4:	e5c32000 	strb	r2, [r3]

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
30019ff8:	e59d3020 	ldr	r3, [sp, #32]
30019ffc:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
3001a000:	e3530000 	cmp	r3, #0
3001a004:	0a00002e 	beq	3001a0c4 <tcp_input+0xb68>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
3001a008:	e59d3020 	ldr	r3, [sp, #32]
3001a00c:	e5933084 	ldr	r3, [r3, #132]	; 0x84
3001a010:	e3530000 	cmp	r3, #0
3001a014:	0a00000f 	beq	3001a058 <tcp_input+0xafc>
3001a018:	e59d3020 	ldr	r3, [sp, #32]
3001a01c:	e593c084 	ldr	ip, [r3, #132]	; 0x84
3001a020:	e59d3020 	ldr	r3, [sp, #32]
3001a024:	e5932014 	ldr	r2, [r3, #20]
3001a028:	e59d3020 	ldr	r3, [sp, #32]
3001a02c:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
3001a030:	e1a00002 	mov	r0, r2
3001a034:	e59d1020 	ldr	r1, [sp, #32]
3001a038:	e1a02003 	mov	r2, r3
3001a03c:	e3a03000 	mov	r3, #0
3001a040:	e1a0e00f 	mov	lr, pc
3001a044:	e12fff1c 	bx	ip
3001a048:	e1a03000 	mov	r3, r0
3001a04c:	e20330ff 	and	r3, r3, #255	; 0xff
3001a050:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
3001a054:	ea000009 	b	3001a080 <tcp_input+0xb24>
3001a058:	e3a03000 	mov	r3, #0
3001a05c:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
3001a060:	e59d3020 	ldr	r3, [sp, #32]
3001a064:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
3001a068:	e3530000 	cmp	r3, #0
3001a06c:	0a000003 	beq	3001a080 <tcp_input+0xb24>
3001a070:	e59d3020 	ldr	r3, [sp, #32]
3001a074:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
3001a078:	e1a00003 	mov	r0, r3
3001a07c:	ebfff07f 	bl	30016280 <pbuf_free>
      //lwip_printf("\r\n1111111111\r\n");
      if (err == ERR_OK) {
3001a080:	e1dd32df 	ldrsb	r3, [sp, #47]	; 0x2f
3001a084:	e3530000 	cmp	r3, #0
3001a088:	1a000003 	bne	3001a09c <tcp_input+0xb40>
        pcb->refused_data = NULL;
3001a08c:	e59d3020 	ldr	r3, [sp, #32]
3001a090:	e3a02000 	mov	r2, #0
3001a094:	e583207c 	str	r2, [r3, #124]	; 0x7c
3001a098:	ea000009 	b	3001a0c4 <tcp_input+0xb68>
      } else {
      	//lwip_printf("\r\n222222\r\n");
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
3001a09c:	e59f32e4 	ldr	r3, [pc, #740]	; 3001a388 <tcp_input+0xe2c>
3001a0a0:	e1d33ab4 	ldrh	r3, [r3, #164]	; 0xa4
3001a0a4:	e2833001 	add	r3, r3, #1
3001a0a8:	e1a03803 	lsl	r3, r3, #16
3001a0ac:	e1a02823 	lsr	r2, r3, #16
3001a0b0:	e59f32d0 	ldr	r3, [pc, #720]	; 3001a388 <tcp_input+0xe2c>
3001a0b4:	e1c32ab4 	strh	r2, [r3, #164]	; 0xa4
        snmp_inc_tcpinerrs();
        pbuf_free(p);
3001a0b8:	e59d000c 	ldr	r0, [sp, #12]
3001a0bc:	ebfff06f 	bl	30016280 <pbuf_free>
        return;
3001a0c0:	ea0000f8 	b	3001a4a8 <tcp_input+0xf4c>
      }
    }

    tcp_input_pcb = pcb;
3001a0c4:	e59f32b8 	ldr	r3, [pc, #696]	; 3001a384 <tcp_input+0xe28>
3001a0c8:	e59d2020 	ldr	r2, [sp, #32]
3001a0cc:	e5832000 	str	r2, [r3]
    err = tcp_process(pcb);
3001a0d0:	e59d0020 	ldr	r0, [sp, #32]
3001a0d4:	eb000204 	bl	3001a8ec <tcp_process>
3001a0d8:	e1a03000 	mov	r3, r0
3001a0dc:	e20330ff 	and	r3, r3, #255	; 0xff
3001a0e0:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
    tcp_input_pcb = NULL;
3001a0e4:	e59f3298 	ldr	r3, [pc, #664]	; 3001a384 <tcp_input+0xe28>
3001a0e8:	e3a02000 	mov	r2, #0
3001a0ec:	e5832000 	str	r2, [r3]
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
3001a0f0:	e1dd32df 	ldrsb	r3, [sp, #47]	; 0x2f
3001a0f4:	e3730004 	cmn	r3, #4
3001a0f8:	0a00008e 	beq	3001a338 <tcp_input+0xddc>
      if (recv_flags & TF_RESET) {
3001a0fc:	e59f327c 	ldr	r3, [pc, #636]	; 3001a380 <tcp_input+0xe24>
3001a100:	e5d33000 	ldrb	r3, [r3]
3001a104:	e2033008 	and	r3, r3, #8
3001a108:	e3530000 	cmp	r3, #0
3001a10c:	0a000012 	beq	3001a15c <tcp_input+0xc00>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        //lwip_printf("\r\n33333333333\r\n");
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
3001a110:	e59d3020 	ldr	r3, [sp, #32]
3001a114:	e5933094 	ldr	r3, [r3, #148]	; 0x94
3001a118:	e3530000 	cmp	r3, #0
3001a11c:	0a000007 	beq	3001a140 <tcp_input+0xbe4>
3001a120:	e59d3020 	ldr	r3, [sp, #32]
3001a124:	e5933094 	ldr	r3, [r3, #148]	; 0x94
3001a128:	e59d2020 	ldr	r2, [sp, #32]
3001a12c:	e5922014 	ldr	r2, [r2, #20]
3001a130:	e1a00002 	mov	r0, r2
3001a134:	e3e01004 	mvn	r1, #4
3001a138:	e1a0e00f 	mov	lr, pc
3001a13c:	e12fff13 	bx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
3001a140:	e59f0224 	ldr	r0, [pc, #548]	; 3001a36c <tcp_input+0xe10>
3001a144:	e59d1020 	ldr	r1, [sp, #32]
3001a148:	ebfffc88 	bl	30019370 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
3001a14c:	e3a00002 	mov	r0, #2
3001a150:	e59d1020 	ldr	r1, [sp, #32]
3001a154:	ebffecdb 	bl	300154c8 <memp_free>
3001a158:	ea000076 	b	3001a338 <tcp_input+0xddc>
      } else if (recv_flags & TF_CLOSED) {
3001a15c:	e59f321c 	ldr	r3, [pc, #540]	; 3001a380 <tcp_input+0xe24>
3001a160:	e5d33000 	ldrb	r3, [r3]
3001a164:	e2033010 	and	r3, r3, #16
3001a168:	e3530000 	cmp	r3, #0
3001a16c:	0a000006 	beq	3001a18c <tcp_input+0xc30>
        /* The connection has been closed and we will deallocate the
           PCB. */
        //lwip_printf("\r\n444444444\r\n");
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
3001a170:	e59f01f4 	ldr	r0, [pc, #500]	; 3001a36c <tcp_input+0xe10>
3001a174:	e59d1020 	ldr	r1, [sp, #32]
3001a178:	ebfffc7c 	bl	30019370 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
3001a17c:	e3a00002 	mov	r0, #2
3001a180:	e59d1020 	ldr	r1, [sp, #32]
3001a184:	ebffeccf 	bl	300154c8 <memp_free>
3001a188:	ea00006a 	b	3001a338 <tcp_input+0xddc>
      } else {
      	//lwip_printf("\r\n555555555555\r\n");
        err = ERR_OK;
3001a18c:	e3a03000 	mov	r3, #0
3001a190:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
3001a194:	e59d3020 	ldr	r3, [sp, #32]
3001a198:	e1d336b8 	ldrh	r3, [r3, #104]	; 0x68
3001a19c:	e3530000 	cmp	r3, #0
3001a1a0:	0a000010 	beq	3001a1e8 <tcp_input+0xc8c>
			lwip_printf("\r\n<*<*<*>*>*>\r\n");

		}
		lwip_printf("\r\n+++++++++++++++++++++\r\n");
		/**/
          TCP_EVENT_SENT(pcb, pcb->acked, err);
3001a1a4:	e59d3020 	ldr	r3, [sp, #32]
3001a1a8:	e5933080 	ldr	r3, [r3, #128]	; 0x80
3001a1ac:	e3530000 	cmp	r3, #0
3001a1b0:	0a00000c 	beq	3001a1e8 <tcp_input+0xc8c>
3001a1b4:	e59d3020 	ldr	r3, [sp, #32]
3001a1b8:	e5933080 	ldr	r3, [r3, #128]	; 0x80
3001a1bc:	e59d2020 	ldr	r2, [sp, #32]
3001a1c0:	e5921014 	ldr	r1, [r2, #20]
3001a1c4:	e59d2020 	ldr	r2, [sp, #32]
3001a1c8:	e1d226b8 	ldrh	r2, [r2, #104]	; 0x68
3001a1cc:	e1a00001 	mov	r0, r1
3001a1d0:	e59d1020 	ldr	r1, [sp, #32]
3001a1d4:	e1a0e00f 	mov	lr, pc
3001a1d8:	e12fff13 	bx	r3
3001a1dc:	e1a03000 	mov	r3, r0
3001a1e0:	e20330ff 	and	r3, r3, #255	; 0xff
3001a1e4:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
        }
      
        if (recv_data != NULL) {
3001a1e8:	e59f318c 	ldr	r3, [pc, #396]	; 3001a37c <tcp_input+0xe20>
3001a1ec:	e5933000 	ldr	r3, [r3]
3001a1f0:	e3530000 	cmp	r3, #0
3001a1f4:	0a000031 	beq	3001a2c0 <tcp_input+0xd64>
          if(flags & TCP_PSH) {
3001a1f8:	e59f3168 	ldr	r3, [pc, #360]	; 3001a368 <tcp_input+0xe0c>
3001a1fc:	e5d33000 	ldrb	r3, [r3]
3001a200:	e2033008 	and	r3, r3, #8
3001a204:	e3530000 	cmp	r3, #0
3001a208:	0a000007 	beq	3001a22c <tcp_input+0xcd0>
            recv_data->flags |= PBUF_FLAG_PUSH;
3001a20c:	e59f3168 	ldr	r3, [pc, #360]	; 3001a37c <tcp_input+0xe20>
3001a210:	e5933000 	ldr	r3, [r3]
3001a214:	e59f2160 	ldr	r2, [pc, #352]	; 3001a37c <tcp_input+0xe20>
3001a218:	e5922000 	ldr	r2, [r2]
3001a21c:	e5d2200d 	ldrb	r2, [r2, #13]
3001a220:	e3822001 	orr	r2, r2, #1
3001a224:	e20220ff 	and	r2, r2, #255	; 0xff
3001a228:	e5c3200d 	strb	r2, [r3, #13]
          }
		  //lwip_printf("\r\n7777777777\r\n");
          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
3001a22c:	e59d3020 	ldr	r3, [sp, #32]
3001a230:	e5933084 	ldr	r3, [r3, #132]	; 0x84
3001a234:	e3530000 	cmp	r3, #0
3001a238:	0a00000f 	beq	3001a27c <tcp_input+0xd20>
3001a23c:	e59d3020 	ldr	r3, [sp, #32]
3001a240:	e593c084 	ldr	ip, [r3, #132]	; 0x84
3001a244:	e59d3020 	ldr	r3, [sp, #32]
3001a248:	e5932014 	ldr	r2, [r3, #20]
3001a24c:	e59f3128 	ldr	r3, [pc, #296]	; 3001a37c <tcp_input+0xe20>
3001a250:	e5933000 	ldr	r3, [r3]
3001a254:	e1a00002 	mov	r0, r2
3001a258:	e59d1020 	ldr	r1, [sp, #32]
3001a25c:	e1a02003 	mov	r2, r3
3001a260:	e3a03000 	mov	r3, #0
3001a264:	e1a0e00f 	mov	lr, pc
3001a268:	e12fff1c 	bx	ip
3001a26c:	e1a03000 	mov	r3, r0
3001a270:	e20330ff 	and	r3, r3, #255	; 0xff
3001a274:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
3001a278:	ea000009 	b	3001a2a4 <tcp_input+0xd48>
3001a27c:	e3a03000 	mov	r3, #0
3001a280:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
3001a284:	e59f30f0 	ldr	r3, [pc, #240]	; 3001a37c <tcp_input+0xe20>
3001a288:	e5933000 	ldr	r3, [r3]
3001a28c:	e3530000 	cmp	r3, #0
3001a290:	0a000003 	beq	3001a2a4 <tcp_input+0xd48>
3001a294:	e59f30e0 	ldr	r3, [pc, #224]	; 3001a37c <tcp_input+0xe20>
3001a298:	e5933000 	ldr	r3, [r3]
3001a29c:	e1a00003 	mov	r0, r3
3001a2a0:	ebffeff6 	bl	30016280 <pbuf_free>

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
3001a2a4:	e1dd32df 	ldrsb	r3, [sp, #47]	; 0x2f
3001a2a8:	e3530000 	cmp	r3, #0
3001a2ac:	0a000003 	beq	3001a2c0 <tcp_input+0xd64>
            pcb->refused_data = recv_data;
3001a2b0:	e59f30c4 	ldr	r3, [pc, #196]	; 3001a37c <tcp_input+0xe20>
3001a2b4:	e5932000 	ldr	r2, [r3]
3001a2b8:	e59d3020 	ldr	r3, [sp, #32]
3001a2bc:	e583207c 	str	r2, [r3, #124]	; 0x7c
          }
        }
		//lwip_printf("\r\n888888888\r\n");
        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
3001a2c0:	e59f30b8 	ldr	r3, [pc, #184]	; 3001a380 <tcp_input+0xe24>
3001a2c4:	e5d33000 	ldrb	r3, [r3]
3001a2c8:	e2033020 	and	r3, r3, #32
3001a2cc:	e3530000 	cmp	r3, #0
3001a2d0:	0a000013 	beq	3001a324 <tcp_input+0xdc8>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
3001a2d4:	e59d3020 	ldr	r3, [sp, #32]
3001a2d8:	e5933084 	ldr	r3, [r3, #132]	; 0x84
3001a2dc:	e3530000 	cmp	r3, #0
3001a2e0:	0a00000d 	beq	3001a31c <tcp_input+0xdc0>
3001a2e4:	e59d3020 	ldr	r3, [sp, #32]
3001a2e8:	e593c084 	ldr	ip, [r3, #132]	; 0x84
3001a2ec:	e59d3020 	ldr	r3, [sp, #32]
3001a2f0:	e5933014 	ldr	r3, [r3, #20]
3001a2f4:	e1a00003 	mov	r0, r3
3001a2f8:	e59d1020 	ldr	r1, [sp, #32]
3001a2fc:	e3a02000 	mov	r2, #0
3001a300:	e3a03000 	mov	r3, #0
3001a304:	e1a0e00f 	mov	lr, pc
3001a308:	e12fff1c 	bx	ip
3001a30c:	e1a03000 	mov	r3, r0
3001a310:	e20330ff 	and	r3, r3, #255	; 0xff
3001a314:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
3001a318:	ea000001 	b	3001a324 <tcp_input+0xdc8>
3001a31c:	e3a03000 	mov	r3, #0
3001a320:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
        }
		//lwip_printf("\r\n9999999999999\r\n");
        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
3001a324:	e1dd32df 	ldrsb	r3, [sp, #47]	; 0x2f
3001a328:	e3530000 	cmp	r3, #0
3001a32c:	1a000001 	bne	3001a338 <tcp_input+0xddc>
        	//lwip_printf("\r\n000000000000\r\n");
            tcp_output(pcb);
3001a330:	e59d0020 	ldr	r0, [sp, #32]
3001a334:	eb000f26 	bl	3001dfd4 <tcp_output>
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
3001a338:	e59f3038 	ldr	r3, [pc, #56]	; 3001a378 <tcp_input+0xe1c>
3001a33c:	e5933004 	ldr	r3, [r3, #4]
3001a340:	e3530000 	cmp	r3, #0
3001a344:	0a000056 	beq	3001a4a4 <tcp_input+0xf48>
    {
      pbuf_free(inseg.p);
3001a348:	e59f3028 	ldr	r3, [pc, #40]	; 3001a378 <tcp_input+0xe1c>
3001a34c:	e5933004 	ldr	r3, [r3, #4]
3001a350:	e1a00003 	mov	r0, r3
3001a354:	ebffefc9 	bl	30016280 <pbuf_free>
      inseg.p = NULL;
3001a358:	e59f3018 	ldr	r3, [pc, #24]	; 3001a378 <tcp_input+0xe1c>
3001a35c:	e3a02000 	mov	r2, #0
3001a360:	e5832004 	str	r2, [r3, #4]
3001a364:	ea00004f 	b	3001a4a8 <tcp_input+0xf4c>
3001a368:	300dbbc0 	.word	0x300dbbc0
3001a36c:	300eaa38 	.word	0x300eaa38
3001a370:	302be508 	.word	0x302be508
3001a374:	300eaa78 	.word	0x300eaa78
3001a378:	300dbb9c 	.word	0x300dbb9c
3001a37c:	300dbbc8 	.word	0x300dbbc8
3001a380:	300dbbc4 	.word	0x300dbbc4
3001a384:	3012ac98 	.word	0x3012ac98
3001a388:	302be570 	.word	0x302be570
3001a38c:	300dbbbc 	.word	0x300dbbbc
3001a390:	300dbbc2 	.word	0x300dbbc2
3001a394:	300dbbb8 	.word	0x300dbbb8
3001a398:	300dbbb4 	.word	0x300dbbb4
3001a39c:	300dbbb0 	.word	0x300dbbb0
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
3001a3a0:	e51f300c 	ldr	r3, [pc, #-12]	; 3001a39c <tcp_input+0xe40>
3001a3a4:	e5933000 	ldr	r3, [r3]
3001a3a8:	e5d3200c 	ldrb	r2, [r3, #12]
3001a3ac:	e5d3300d 	ldrb	r3, [r3, #13]
3001a3b0:	e1a03403 	lsl	r3, r3, #8
3001a3b4:	e1833002 	orr	r3, r3, r2
3001a3b8:	e1a03803 	lsl	r3, r3, #16
3001a3bc:	e1a03823 	lsr	r3, r3, #16
3001a3c0:	e1a00003 	mov	r0, r3
3001a3c4:	ebffe4a0 	bl	3001364c <ntohs>
3001a3c8:	e1a03000 	mov	r3, r0
3001a3cc:	e2033004 	and	r3, r3, #4
3001a3d0:	e3530000 	cmp	r3, #0
3001a3d4:	1a00002f 	bne	3001a498 <tcp_input+0xf3c>
      TCP_STATS_INC(tcp.proterr);
3001a3d8:	e51f3058 	ldr	r3, [pc, #-88]	; 3001a388 <tcp_input+0xe2c>
3001a3dc:	e1d33abe 	ldrh	r3, [r3, #174]	; 0xae
3001a3e0:	e2833001 	add	r3, r3, #1
3001a3e4:	e1a03803 	lsl	r3, r3, #16
3001a3e8:	e1a02823 	lsr	r2, r3, #16
3001a3ec:	e51f306c 	ldr	r3, [pc, #-108]	; 3001a388 <tcp_input+0xe2c>
3001a3f0:	e1c32abe 	strh	r2, [r3, #174]	; 0xae
      TCP_STATS_INC(tcp.drop);
3001a3f4:	e51f3074 	ldr	r3, [pc, #-116]	; 3001a388 <tcp_input+0xe2c>
3001a3f8:	e1d33ab4 	ldrh	r3, [r3, #164]	; 0xa4
3001a3fc:	e2833001 	add	r3, r3, #1
3001a400:	e1a03803 	lsl	r3, r3, #16
3001a404:	e1a02823 	lsr	r2, r3, #16
3001a408:	e51f3088 	ldr	r3, [pc, #-136]	; 3001a388 <tcp_input+0xe2c>
3001a40c:	e1c32ab4 	strh	r2, [r3, #164]	; 0xa4
      tcp_rst(ackno, seqno + tcplen,
3001a410:	e51f308c 	ldr	r3, [pc, #-140]	; 3001a38c <tcp_input+0xe30>
3001a414:	e5930000 	ldr	r0, [r3]
3001a418:	e51f3090 	ldr	r3, [pc, #-144]	; 3001a390 <tcp_input+0xe34>
3001a41c:	e1d330b0 	ldrh	r3, [r3]
3001a420:	e1a02003 	mov	r2, r3
3001a424:	e51f3098 	ldr	r3, [pc, #-152]	; 3001a394 <tcp_input+0xe38>
3001a428:	e5933000 	ldr	r3, [r3]
3001a42c:	e0821003 	add	r1, r2, r3
        &(iphdr->dest), &(iphdr->src),
3001a430:	e51f30a0 	ldr	r3, [pc, #-160]	; 3001a398 <tcp_input+0xe3c>
3001a434:	e5933000 	ldr	r3, [r3]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
3001a438:	e2832010 	add	r2, r3, #16
        &(iphdr->dest), &(iphdr->src),
3001a43c:	e51f30ac 	ldr	r3, [pc, #-172]	; 3001a398 <tcp_input+0xe3c>
3001a440:	e5933000 	ldr	r3, [r3]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
3001a444:	e283c00c 	add	ip, r3, #12
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
3001a448:	e51f30b4 	ldr	r3, [pc, #-180]	; 3001a39c <tcp_input+0xe40>
3001a44c:	e5933000 	ldr	r3, [r3]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
3001a450:	e5d3e002 	ldrb	lr, [r3, #2]
3001a454:	e5d33003 	ldrb	r3, [r3, #3]
3001a458:	e1a03403 	lsl	r3, r3, #8
3001a45c:	e183300e 	orr	r3, r3, lr
3001a460:	e1a03803 	lsl	r3, r3, #16
3001a464:	e1a0e823 	lsr	lr, r3, #16
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
3001a468:	e51f30d4 	ldr	r3, [pc, #-212]	; 3001a39c <tcp_input+0xe40>
3001a46c:	e5933000 	ldr	r3, [r3]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
3001a470:	e5d34000 	ldrb	r4, [r3]
3001a474:	e5d33001 	ldrb	r3, [r3, #1]
3001a478:	e1a03403 	lsl	r3, r3, #8
3001a47c:	e1833004 	orr	r3, r3, r4
3001a480:	e1a03803 	lsl	r3, r3, #16
3001a484:	e1a03823 	lsr	r3, r3, #16
3001a488:	e58de000 	str	lr, [sp]
3001a48c:	e58d3004 	str	r3, [sp, #4]
3001a490:	e1a0300c 	mov	r3, ip
3001a494:	eb001205 	bl	3001ecb0 <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
3001a498:	e59d000c 	ldr	r0, [sp, #12]
3001a49c:	ebffef77 	bl	30016280 <pbuf_free>
3001a4a0:	ea000000 	b	3001a4a8 <tcp_input+0xf4c>

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
    {
      pbuf_free(inseg.p);
      inseg.p = NULL;
3001a4a4:	e1a00000 	nop			; (mov r0, r0)
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
3001a4a8:	e28dd030 	add	sp, sp, #48	; 0x30
3001a4ac:	e8bd4010 	pop	{r4, lr}
3001a4b0:	e12fff1e 	bx	lr

3001a4b4 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
3001a4b4:	e92d4010 	push	{r4, lr}
3001a4b8:	e24dd020 	sub	sp, sp, #32
3001a4bc:	e58d0014 	str	r0, [sp, #20]
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
3001a4c0:	e59f3348 	ldr	r3, [pc, #840]	; 3001a810 <tcp_listen_input+0x35c>
3001a4c4:	e5d33000 	ldrb	r3, [r3]
3001a4c8:	e2033010 	and	r3, r3, #16
3001a4cc:	e3530000 	cmp	r3, #0
3001a4d0:	0a000023 	beq	3001a564 <tcp_listen_input+0xb0>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
3001a4d4:	e59f3338 	ldr	r3, [pc, #824]	; 3001a814 <tcp_listen_input+0x360>
3001a4d8:	e5933000 	ldr	r3, [r3]
3001a4dc:	e2830001 	add	r0, r3, #1
3001a4e0:	e59f3330 	ldr	r3, [pc, #816]	; 3001a818 <tcp_listen_input+0x364>
3001a4e4:	e1d330b0 	ldrh	r3, [r3]
3001a4e8:	e1a02003 	mov	r2, r3
3001a4ec:	e59f3328 	ldr	r3, [pc, #808]	; 3001a81c <tcp_listen_input+0x368>
3001a4f0:	e5933000 	ldr	r3, [r3]
3001a4f4:	e0821003 	add	r1, r2, r3
      &(iphdr->dest), &(iphdr->src),
3001a4f8:	e59f3320 	ldr	r3, [pc, #800]	; 3001a820 <tcp_listen_input+0x36c>
3001a4fc:	e5933000 	ldr	r3, [r3]
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
3001a500:	e2832010 	add	r2, r3, #16
      &(iphdr->dest), &(iphdr->src),
3001a504:	e59f3314 	ldr	r3, [pc, #788]	; 3001a820 <tcp_listen_input+0x36c>
3001a508:	e5933000 	ldr	r3, [r3]
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
3001a50c:	e283c00c 	add	ip, r3, #12
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
3001a510:	e59f330c 	ldr	r3, [pc, #780]	; 3001a824 <tcp_listen_input+0x370>
3001a514:	e5933000 	ldr	r3, [r3]
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
3001a518:	e5d3e002 	ldrb	lr, [r3, #2]
3001a51c:	e5d33003 	ldrb	r3, [r3, #3]
3001a520:	e1a03403 	lsl	r3, r3, #8
3001a524:	e183300e 	orr	r3, r3, lr
3001a528:	e1a03803 	lsl	r3, r3, #16
3001a52c:	e1a0e823 	lsr	lr, r3, #16
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
3001a530:	e59f32ec 	ldr	r3, [pc, #748]	; 3001a824 <tcp_listen_input+0x370>
3001a534:	e5933000 	ldr	r3, [r3]
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
3001a538:	e5d34000 	ldrb	r4, [r3]
3001a53c:	e5d33001 	ldrb	r3, [r3, #1]
3001a540:	e1a03403 	lsl	r3, r3, #8
3001a544:	e1833004 	orr	r3, r3, r4
3001a548:	e1a03803 	lsl	r3, r3, #16
3001a54c:	e1a03823 	lsr	r3, r3, #16
3001a550:	e58de000 	str	lr, [sp]
3001a554:	e58d3004 	str	r3, [sp, #4]
3001a558:	e1a0300c 	mov	r3, ip
3001a55c:	eb0011d3 	bl	3001ecb0 <tcp_rst>
3001a560:	ea0000a3 	b	3001a7f4 <tcp_listen_input+0x340>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
3001a564:	e59f32a4 	ldr	r3, [pc, #676]	; 3001a810 <tcp_listen_input+0x35c>
3001a568:	e5d33000 	ldrb	r3, [r3]
3001a56c:	e2033002 	and	r3, r3, #2
3001a570:	e3530000 	cmp	r3, #0
3001a574:	0a00009e 	beq	3001a7f4 <tcp_listen_input+0x340>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
3001a578:	e59d3014 	ldr	r3, [sp, #20]
3001a57c:	e5d33011 	ldrb	r3, [r3, #17]
3001a580:	e1a00003 	mov	r0, r3
3001a584:	ebfffa95 	bl	30018fe0 <tcp_alloc>
3001a588:	e1a03000 	mov	r3, r0
3001a58c:	e58d301c 	str	r3, [sp, #28]
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
3001a590:	e59d301c 	ldr	r3, [sp, #28]
3001a594:	e3530000 	cmp	r3, #0
3001a598:	1a000008 	bne	3001a5c0 <tcp_listen_input+0x10c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
3001a59c:	e59f3284 	ldr	r3, [pc, #644]	; 3001a828 <tcp_listen_input+0x374>
3001a5a0:	e1d33aba 	ldrh	r3, [r3, #170]	; 0xaa
3001a5a4:	e2833001 	add	r3, r3, #1
3001a5a8:	e1a03803 	lsl	r3, r3, #16
3001a5ac:	e1a02823 	lsr	r2, r3, #16
3001a5b0:	e59f3270 	ldr	r3, [pc, #624]	; 3001a828 <tcp_listen_input+0x374>
3001a5b4:	e1c32aba 	strh	r2, [r3, #170]	; 0xaa
      return ERR_MEM;
3001a5b8:	e3a030ff 	mov	r3, #255	; 0xff
3001a5bc:	ea00008d 	b	3001a7f8 <tcp_listen_input+0x344>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
3001a5c0:	e59f3258 	ldr	r3, [pc, #600]	; 3001a820 <tcp_listen_input+0x36c>
3001a5c4:	e5933000 	ldr	r3, [r3]
3001a5c8:	e2833010 	add	r3, r3, #16
3001a5cc:	e3530000 	cmp	r3, #0
3001a5d0:	0a00000c 	beq	3001a608 <tcp_listen_input+0x154>
3001a5d4:	e59f3244 	ldr	r3, [pc, #580]	; 3001a820 <tcp_listen_input+0x36c>
3001a5d8:	e5933000 	ldr	r3, [r3]
3001a5dc:	e5d32010 	ldrb	r2, [r3, #16]
3001a5e0:	e5d31011 	ldrb	r1, [r3, #17]
3001a5e4:	e1a01401 	lsl	r1, r1, #8
3001a5e8:	e1812002 	orr	r2, r1, r2
3001a5ec:	e5d31012 	ldrb	r1, [r3, #18]
3001a5f0:	e1a01801 	lsl	r1, r1, #16
3001a5f4:	e1812002 	orr	r2, r1, r2
3001a5f8:	e5d33013 	ldrb	r3, [r3, #19]
3001a5fc:	e1a03c03 	lsl	r3, r3, #24
3001a600:	e1833002 	orr	r3, r3, r2
3001a604:	ea000000 	b	3001a60c <tcp_listen_input+0x158>
3001a608:	e3a03000 	mov	r3, #0
3001a60c:	e59d201c 	ldr	r2, [sp, #28]
3001a610:	e5823000 	str	r3, [r2]
    npcb->local_port = pcb->local_port;
3001a614:	e59d3014 	ldr	r3, [sp, #20]
3001a618:	e1d321b8 	ldrh	r2, [r3, #24]
3001a61c:	e59d301c 	ldr	r3, [sp, #28]
3001a620:	e1c321b8 	strh	r2, [r3, #24]
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
3001a624:	e59f31f4 	ldr	r3, [pc, #500]	; 3001a820 <tcp_listen_input+0x36c>
3001a628:	e5933000 	ldr	r3, [r3]
3001a62c:	e283300c 	add	r3, r3, #12
3001a630:	e3530000 	cmp	r3, #0
3001a634:	0a00000c 	beq	3001a66c <tcp_listen_input+0x1b8>
3001a638:	e59f31e0 	ldr	r3, [pc, #480]	; 3001a820 <tcp_listen_input+0x36c>
3001a63c:	e5933000 	ldr	r3, [r3]
3001a640:	e5d3200c 	ldrb	r2, [r3, #12]
3001a644:	e5d3100d 	ldrb	r1, [r3, #13]
3001a648:	e1a01401 	lsl	r1, r1, #8
3001a64c:	e1812002 	orr	r2, r1, r2
3001a650:	e5d3100e 	ldrb	r1, [r3, #14]
3001a654:	e1a01801 	lsl	r1, r1, #16
3001a658:	e1812002 	orr	r2, r1, r2
3001a65c:	e5d3300f 	ldrb	r3, [r3, #15]
3001a660:	e1a03c03 	lsl	r3, r3, #24
3001a664:	e1833002 	orr	r3, r3, r2
3001a668:	ea000000 	b	3001a670 <tcp_listen_input+0x1bc>
3001a66c:	e3a03000 	mov	r3, #0
3001a670:	e59d201c 	ldr	r2, [sp, #28]
3001a674:	e5823004 	str	r3, [r2, #4]
    npcb->remote_port = tcphdr->src;
3001a678:	e59f31a4 	ldr	r3, [pc, #420]	; 3001a824 <tcp_listen_input+0x370>
3001a67c:	e5933000 	ldr	r3, [r3]
3001a680:	e5d32000 	ldrb	r2, [r3]
3001a684:	e5d33001 	ldrb	r3, [r3, #1]
3001a688:	e1a03403 	lsl	r3, r3, #8
3001a68c:	e1833002 	orr	r3, r3, r2
3001a690:	e1a03803 	lsl	r3, r3, #16
3001a694:	e1a02823 	lsr	r2, r3, #16
3001a698:	e59d301c 	ldr	r3, [sp, #28]
3001a69c:	e1c321ba 	strh	r2, [r3, #26]
    npcb->state = SYN_RCVD;
3001a6a0:	e59d301c 	ldr	r3, [sp, #28]
3001a6a4:	e3a02003 	mov	r2, #3
3001a6a8:	e5c32010 	strb	r2, [r3, #16]
    npcb->rcv_nxt = seqno + 1;
3001a6ac:	e59f3168 	ldr	r3, [pc, #360]	; 3001a81c <tcp_listen_input+0x368>
3001a6b0:	e5933000 	ldr	r3, [r3]
3001a6b4:	e2832001 	add	r2, r3, #1
3001a6b8:	e59d301c 	ldr	r3, [sp, #28]
3001a6bc:	e5832020 	str	r2, [r3, #32]
    npcb->snd_wnd = tcphdr->wnd;
3001a6c0:	e59f315c 	ldr	r3, [pc, #348]	; 3001a824 <tcp_listen_input+0x370>
3001a6c4:	e5933000 	ldr	r3, [r3]
3001a6c8:	e5d3200e 	ldrb	r2, [r3, #14]
3001a6cc:	e5d3300f 	ldrb	r3, [r3, #15]
3001a6d0:	e1a03403 	lsl	r3, r3, #8
3001a6d4:	e1833002 	orr	r3, r3, r2
3001a6d8:	e1a03803 	lsl	r3, r3, #16
3001a6dc:	e1a02823 	lsr	r2, r3, #16
3001a6e0:	e59d301c 	ldr	r3, [sp, #28]
3001a6e4:	e1c325b8 	strh	r2, [r3, #88]	; 0x58
    npcb->ssthresh = npcb->snd_wnd;
3001a6e8:	e59d301c 	ldr	r3, [sp, #28]
3001a6ec:	e1d325b8 	ldrh	r2, [r3, #88]	; 0x58
3001a6f0:	e59d301c 	ldr	r3, [sp, #28]
3001a6f4:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
3001a6f8:	e59f311c 	ldr	r3, [pc, #284]	; 3001a81c <tcp_listen_input+0x368>
3001a6fc:	e5933000 	ldr	r3, [r3]
3001a700:	e2432001 	sub	r2, r3, #1
3001a704:	e59d301c 	ldr	r3, [sp, #28]
3001a708:	e583205c 	str	r2, [r3, #92]	; 0x5c
    npcb->callback_arg = pcb->callback_arg;
3001a70c:	e59d3014 	ldr	r3, [sp, #20]
3001a710:	e5932014 	ldr	r2, [r3, #20]
3001a714:	e59d301c 	ldr	r3, [sp, #28]
3001a718:	e5832014 	str	r2, [r3, #20]
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
3001a71c:	e59d3014 	ldr	r3, [sp, #20]
3001a720:	e593201c 	ldr	r2, [r3, #28]
3001a724:	e59d301c 	ldr	r3, [sp, #28]
3001a728:	e583208c 	str	r2, [r3, #140]	; 0x8c
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
3001a72c:	e59d3014 	ldr	r3, [sp, #20]
3001a730:	e1d330b8 	ldrh	r3, [r3, #8]
3001a734:	e3c33066 	bic	r3, r3, #102	; 0x66
3001a738:	e1a03b83 	lsl	r3, r3, #23
3001a73c:	e1a03ba3 	lsr	r3, r3, #23
3001a740:	e59d201c 	ldr	r2, [sp, #28]
3001a744:	e1c230b8 	strh	r3, [r2, #8]
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
3001a748:	e59f30dc 	ldr	r3, [pc, #220]	; 3001a82c <tcp_listen_input+0x378>
3001a74c:	e5932000 	ldr	r2, [r3]
3001a750:	e59d301c 	ldr	r3, [sp, #28]
3001a754:	e583200c 	str	r2, [r3, #12]
3001a758:	e59f30cc 	ldr	r3, [pc, #204]	; 3001a82c <tcp_listen_input+0x378>
3001a75c:	e59d201c 	ldr	r2, [sp, #28]
3001a760:	e5832000 	str	r2, [r3]
3001a764:	ebffde44 	bl	3001207c <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
3001a768:	e59d001c 	ldr	r0, [sp, #28]
3001a76c:	eb000b0a 	bl	3001d39c <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
3001a770:	e59d301c 	ldr	r3, [sp, #28]
3001a774:	e1d323b0 	ldrh	r2, [r3, #48]	; 0x30
3001a778:	e59d301c 	ldr	r3, [sp, #28]
3001a77c:	e2833004 	add	r3, r3, #4
3001a780:	e1a00002 	mov	r0, r2
3001a784:	e1a01003 	mov	r1, r3
3001a788:	ebfffb55 	bl	300194e4 <tcp_eff_send_mss>
3001a78c:	e1a03000 	mov	r3, r0
3001a790:	e1a02003 	mov	r2, r3
3001a794:	e59d301c 	ldr	r3, [sp, #28]
3001a798:	e1c323b0 	strh	r2, [r3, #48]	; 0x30
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
3001a79c:	e3a00781 	mov	r0, #33816576	; 0x2040000
3001a7a0:	e2800a01 	add	r0, r0, #4096	; 0x1000
3001a7a4:	ebffe3b4 	bl	3001367c <htonl>
3001a7a8:	e1a03000 	mov	r3, r0
3001a7ac:	e58d3018 	str	r3, [sp, #24]
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
3001a7b0:	e28d3018 	add	r3, sp, #24
3001a7b4:	e3a02000 	mov	r2, #0
3001a7b8:	e58d2000 	str	r2, [sp]
3001a7bc:	e58d3004 	str	r3, [sp, #4]
3001a7c0:	e3a03004 	mov	r3, #4
3001a7c4:	e58d3008 	str	r3, [sp, #8]
3001a7c8:	e59d001c 	ldr	r0, [sp, #28]
3001a7cc:	e3a01000 	mov	r1, #0
3001a7d0:	e3a02000 	mov	r2, #0
3001a7d4:	e3a03012 	mov	r3, #18
3001a7d8:	eb000bb0 	bl	3001d6a0 <tcp_enqueue>
    return tcp_output(npcb);
3001a7dc:	e59d001c 	ldr	r0, [sp, #28]
3001a7e0:	eb000dfb 	bl	3001dfd4 <tcp_output>
3001a7e4:	e1a03000 	mov	r3, r0
3001a7e8:	e20330ff 	and	r3, r3, #255	; 0xff
3001a7ec:	e20330ff 	and	r3, r3, #255	; 0xff
3001a7f0:	ea000000 	b	3001a7f8 <tcp_listen_input+0x344>
  }
  return ERR_OK;
3001a7f4:	e3a03000 	mov	r3, #0
3001a7f8:	e1a03c03 	lsl	r3, r3, #24
3001a7fc:	e1a03c43 	asr	r3, r3, #24
}
3001a800:	e1a00003 	mov	r0, r3
3001a804:	e28dd020 	add	sp, sp, #32
3001a808:	e8bd4010 	pop	{r4, lr}
3001a80c:	e12fff1e 	bx	lr
3001a810:	300dbbc0 	.word	0x300dbbc0
3001a814:	300dbbbc 	.word	0x300dbbbc
3001a818:	300dbbc2 	.word	0x300dbbc2
3001a81c:	300dbbb8 	.word	0x300dbbb8
3001a820:	300dbbb4 	.word	0x300dbbb4
3001a824:	300dbbb0 	.word	0x300dbbb0
3001a828:	302be570 	.word	0x302be570
3001a82c:	300eaa38 	.word	0x300eaa38

3001a830 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
3001a830:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001a834:	e24dd00c 	sub	sp, sp, #12
3001a838:	e58d0004 	str	r0, [sp, #4]
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
3001a83c:	e59f30a0 	ldr	r3, [pc, #160]	; 3001a8e4 <tcp_timewait_input+0xb4>
3001a840:	e1d330b0 	ldrh	r3, [r3]
3001a844:	e1a02003 	mov	r2, r3
3001a848:	e59f3098 	ldr	r3, [pc, #152]	; 3001a8e8 <tcp_timewait_input+0xb8>
3001a84c:	e5933000 	ldr	r3, [r3]
3001a850:	e0822003 	add	r2, r2, r3
3001a854:	e59d3004 	ldr	r3, [sp, #4]
3001a858:	e5933020 	ldr	r3, [r3, #32]
3001a85c:	e0633002 	rsb	r3, r3, r2
3001a860:	e3530000 	cmp	r3, #0
3001a864:	da000007 	ble	3001a888 <tcp_timewait_input+0x58>
    pcb->rcv_nxt = seqno + tcplen;
3001a868:	e59f3074 	ldr	r3, [pc, #116]	; 3001a8e4 <tcp_timewait_input+0xb4>
3001a86c:	e1d330b0 	ldrh	r3, [r3]
3001a870:	e1a02003 	mov	r2, r3
3001a874:	e59f306c 	ldr	r3, [pc, #108]	; 3001a8e8 <tcp_timewait_input+0xb8>
3001a878:	e5933000 	ldr	r3, [r3]
3001a87c:	e0822003 	add	r2, r2, r3
3001a880:	e59d3004 	ldr	r3, [sp, #4]
3001a884:	e5832020 	str	r2, [r3, #32]
  }
  if (tcplen > 0) {
3001a888:	e59f3054 	ldr	r3, [pc, #84]	; 3001a8e4 <tcp_timewait_input+0xb4>
3001a88c:	e1d330b0 	ldrh	r3, [r3]
3001a890:	e3530000 	cmp	r3, #0
3001a894:	0a000007 	beq	3001a8b8 <tcp_timewait_input+0x88>
    tcp_ack_now(pcb);
3001a898:	e59d3004 	ldr	r3, [sp, #4]
3001a89c:	e5d3301c 	ldrb	r3, [r3, #28]
3001a8a0:	e3833002 	orr	r3, r3, #2
3001a8a4:	e20320ff 	and	r2, r3, #255	; 0xff
3001a8a8:	e59d3004 	ldr	r3, [sp, #4]
3001a8ac:	e5c3201c 	strb	r2, [r3, #28]
3001a8b0:	e59d0004 	ldr	r0, [sp, #4]
3001a8b4:	eb000dc6 	bl	3001dfd4 <tcp_output>
  }
  return tcp_output(pcb);
3001a8b8:	e59d0004 	ldr	r0, [sp, #4]
3001a8bc:	eb000dc4 	bl	3001dfd4 <tcp_output>
3001a8c0:	e1a03000 	mov	r3, r0
3001a8c4:	e20330ff 	and	r3, r3, #255	; 0xff
3001a8c8:	e20330ff 	and	r3, r3, #255	; 0xff
3001a8cc:	e1a03c03 	lsl	r3, r3, #24
3001a8d0:	e1a03c43 	asr	r3, r3, #24
}
3001a8d4:	e1a00003 	mov	r0, r3
3001a8d8:	e28dd00c 	add	sp, sp, #12
3001a8dc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001a8e0:	e12fff1e 	bx	lr
3001a8e4:	300dbbc2 	.word	0x300dbbc2
3001a8e8:	300dbbb8 	.word	0x300dbbb8

3001a8ec <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
3001a8ec:	e92d4010 	push	{r4, lr}
3001a8f0:	e24dd020 	sub	sp, sp, #32
3001a8f4:	e58d000c 	str	r0, [sp, #12]
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
3001a8f8:	e3a03000 	mov	r3, #0
3001a8fc:	e5cd301b 	strb	r3, [sp, #27]
  err_t err;
  u8_t accepted_inseq;

  err = ERR_OK;
3001a900:	e3a03000 	mov	r3, #0
3001a904:	e5cd301c 	strb	r3, [sp, #28]

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
3001a908:	e59f3b80 	ldr	r3, [pc, #2944]	; 3001b490 <tcp_process+0xba4>
3001a90c:	e5d33000 	ldrb	r3, [r3]
3001a910:	e2033004 	and	r3, r3, #4
3001a914:	e3530000 	cmp	r3, #0
3001a918:	0a000030 	beq	3001a9e0 <tcp_process+0xf4>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
3001a91c:	e59d300c 	ldr	r3, [sp, #12]
3001a920:	e5d33010 	ldrb	r3, [r3, #16]
3001a924:	e3530002 	cmp	r3, #2
3001a928:	1a000008 	bne	3001a950 <tcp_process+0x64>
      if (ackno == pcb->snd_nxt) {
3001a92c:	e59d300c 	ldr	r3, [sp, #12]
3001a930:	e5932050 	ldr	r2, [r3, #80]	; 0x50
3001a934:	e59f3b58 	ldr	r3, [pc, #2904]	; 3001b494 <tcp_process+0xba8>
3001a938:	e5933000 	ldr	r3, [r3]
3001a93c:	e1520003 	cmp	r2, r3
3001a940:	1a000016 	bne	3001a9a0 <tcp_process+0xb4>
        acceptable = 1;
3001a944:	e3a03001 	mov	r3, #1
3001a948:	e5cd301b 	strb	r3, [sp, #27]
3001a94c:	ea000014 	b	3001a9a4 <tcp_process+0xb8>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
3001a950:	e59f3b40 	ldr	r3, [pc, #2880]	; 3001b498 <tcp_process+0xbac>
3001a954:	e5932000 	ldr	r2, [r3]
3001a958:	e59d300c 	ldr	r3, [sp, #12]
3001a95c:	e5933020 	ldr	r3, [r3, #32]
3001a960:	e0633002 	rsb	r3, r3, r2
3001a964:	e3530000 	cmp	r3, #0
3001a968:	ba00000d 	blt	3001a9a4 <tcp_process+0xb8>
3001a96c:	e59f3b24 	ldr	r3, [pc, #2852]	; 3001b498 <tcp_process+0xbac>
3001a970:	e5932000 	ldr	r2, [r3]
3001a974:	e59d300c 	ldr	r3, [sp, #12]
3001a978:	e5931020 	ldr	r1, [r3, #32]
3001a97c:	e59d300c 	ldr	r3, [sp, #12]
3001a980:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
3001a984:	e0813003 	add	r3, r1, r3
3001a988:	e0633002 	rsb	r3, r3, r2
3001a98c:	e3530000 	cmp	r3, #0
3001a990:	ca000003 	bgt	3001a9a4 <tcp_process+0xb8>
                          pcb->rcv_nxt+pcb->rcv_ann_wnd)) {
        acceptable = 1;
3001a994:	e3a03001 	mov	r3, #1
3001a998:	e5cd301b 	strb	r3, [sp, #27]
3001a99c:	ea000000 	b	3001a9a4 <tcp_process+0xb8>
  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
3001a9a0:	e1a00000 	nop			; (mov r0, r0)
                          pcb->rcv_nxt+pcb->rcv_ann_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
3001a9a4:	e5dd301b 	ldrb	r3, [sp, #27]
3001a9a8:	e3530000 	cmp	r3, #0
3001a9ac:	0a000009 	beq	3001a9d8 <tcp_process+0xec>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags = TF_RESET;
3001a9b0:	e59f3ae4 	ldr	r3, [pc, #2788]	; 3001b49c <tcp_process+0xbb0>
3001a9b4:	e3a02008 	mov	r2, #8
3001a9b8:	e5c32000 	strb	r2, [r3]
      pcb->flags &= ~TF_ACK_DELAY;
3001a9bc:	e59d300c 	ldr	r3, [sp, #12]
3001a9c0:	e5d3301c 	ldrb	r3, [r3, #28]
3001a9c4:	e20330fe 	and	r3, r3, #254	; 0xfe
3001a9c8:	e59d200c 	ldr	r2, [sp, #12]
3001a9cc:	e5c2301c 	strb	r3, [r2, #28]
      return ERR_RST;
3001a9d0:	e3a030fb 	mov	r3, #251	; 0xfb
3001a9d4:	ea0002a7 	b	3001b478 <tcp_process+0xb8c>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
3001a9d8:	e3a03000 	mov	r3, #0
3001a9dc:	ea0002a5 	b	3001b478 <tcp_process+0xb8c>
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
3001a9e0:	e59f3ab8 	ldr	r3, [pc, #2744]	; 3001b4a0 <tcp_process+0xbb4>
3001a9e4:	e5932000 	ldr	r2, [r3]
3001a9e8:	e59d300c 	ldr	r3, [sp, #12]
3001a9ec:	e5832028 	str	r2, [r3, #40]	; 0x28
  pcb->keep_cnt_sent = 0;
3001a9f0:	e59d300c 	ldr	r3, [sp, #12]
3001a9f4:	e3a02000 	mov	r2, #0
3001a9f8:	e5c320a1 	strb	r2, [r3, #161]	; 0xa1

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
3001a9fc:	e59d300c 	ldr	r3, [sp, #12]
3001aa00:	e5d33010 	ldrb	r3, [r3, #16]
3001aa04:	e2433002 	sub	r3, r3, #2
3001aa08:	e3530007 	cmp	r3, #7
3001aa0c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3001aa10:	ea000297 	b	3001b474 <tcp_process+0xb88>
3001aa14:	3001aa34 	.word	0x3001aa34
3001aa18:	3001ad4c 	.word	0x3001ad4c
3001aa1c:	3001af4c 	.word	0x3001af4c
3001aa20:	3001afb0 	.word	0x3001afb0
3001aa24:	3001b178 	.word	0x3001b178
3001aa28:	3001af4c 	.word	0x3001af4c
3001aa2c:	3001b2a4 	.word	0x3001b2a4
3001aa30:	3001b3e4 	.word	0x3001b3e4
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
3001aa34:	e59f3a54 	ldr	r3, [pc, #2644]	; 3001b490 <tcp_process+0xba4>
3001aa38:	e5d33000 	ldrb	r3, [r3]
3001aa3c:	e2033010 	and	r3, r3, #16
3001aa40:	e3530000 	cmp	r3, #0
3001aa44:	0a000098 	beq	3001acac <tcp_process+0x3c0>
3001aa48:	e59f3a40 	ldr	r3, [pc, #2624]	; 3001b490 <tcp_process+0xba4>
3001aa4c:	e5d33000 	ldrb	r3, [r3]
3001aa50:	e2033002 	and	r3, r3, #2
3001aa54:	e3530000 	cmp	r3, #0
3001aa58:	0a000093 	beq	3001acac <tcp_process+0x3c0>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
3001aa5c:	e59d300c 	ldr	r3, [sp, #12]
3001aa60:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001aa64:	e5933010 	ldr	r3, [r3, #16]
3001aa68:	e5d32004 	ldrb	r2, [r3, #4]
3001aa6c:	e5d31005 	ldrb	r1, [r3, #5]
3001aa70:	e1a01401 	lsl	r1, r1, #8
3001aa74:	e1812002 	orr	r2, r1, r2
3001aa78:	e5d31006 	ldrb	r1, [r3, #6]
3001aa7c:	e1a01801 	lsl	r1, r1, #16
3001aa80:	e1812002 	orr	r2, r1, r2
3001aa84:	e5d33007 	ldrb	r3, [r3, #7]
3001aa88:	e1a03c03 	lsl	r3, r3, #24
3001aa8c:	e1833002 	orr	r3, r3, r2
3001aa90:	e1a00003 	mov	r0, r3
3001aa94:	ebffe30a 	bl	300136c4 <ntohl>
3001aa98:	e1a03000 	mov	r3, r0
3001aa9c:	e2832001 	add	r2, r3, #1
3001aaa0:	e59f39ec 	ldr	r3, [pc, #2540]	; 3001b494 <tcp_process+0xba8>
3001aaa4:	e5933000 	ldr	r3, [r3]
  switch (pcb->state) {
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
3001aaa8:	e1520003 	cmp	r2, r3
3001aaac:	1a00007e 	bne	3001acac <tcp_process+0x3c0>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
3001aab0:	e59d300c 	ldr	r3, [sp, #12]
3001aab4:	e1d336ba 	ldrh	r3, [r3, #106]	; 0x6a
3001aab8:	e2833001 	add	r3, r3, #1
3001aabc:	e1a03803 	lsl	r3, r3, #16
3001aac0:	e1a02823 	lsr	r2, r3, #16
3001aac4:	e59d300c 	ldr	r3, [sp, #12]
3001aac8:	e1c326ba 	strh	r2, [r3, #106]	; 0x6a
      pcb->rcv_nxt = seqno + 1;
3001aacc:	e59f39c4 	ldr	r3, [pc, #2500]	; 3001b498 <tcp_process+0xbac>
3001aad0:	e5933000 	ldr	r3, [r3]
3001aad4:	e2832001 	add	r2, r3, #1
3001aad8:	e59d300c 	ldr	r3, [sp, #12]
3001aadc:	e5832020 	str	r2, [r3, #32]
      pcb->lastack = ackno;
3001aae0:	e59f39ac 	ldr	r3, [pc, #2476]	; 3001b494 <tcp_process+0xba8>
3001aae4:	e5932000 	ldr	r2, [r3]
3001aae8:	e59d300c 	ldr	r3, [sp, #12]
3001aaec:	e5832044 	str	r2, [r3, #68]	; 0x44
      pcb->snd_wnd = tcphdr->wnd;
3001aaf0:	e59f39ac 	ldr	r3, [pc, #2476]	; 3001b4a4 <tcp_process+0xbb8>
3001aaf4:	e5933000 	ldr	r3, [r3]
3001aaf8:	e5d3200e 	ldrb	r2, [r3, #14]
3001aafc:	e5d3300f 	ldrb	r3, [r3, #15]
3001ab00:	e1a03403 	lsl	r3, r3, #8
3001ab04:	e1833002 	orr	r3, r3, r2
3001ab08:	e1a03803 	lsl	r3, r3, #16
3001ab0c:	e1a02823 	lsr	r2, r3, #16
3001ab10:	e59d300c 	ldr	r3, [sp, #12]
3001ab14:	e1c325b8 	strh	r2, [r3, #88]	; 0x58
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
3001ab18:	e59f3978 	ldr	r3, [pc, #2424]	; 3001b498 <tcp_process+0xbac>
3001ab1c:	e5933000 	ldr	r3, [r3]
3001ab20:	e2432001 	sub	r2, r3, #1
3001ab24:	e59d300c 	ldr	r3, [sp, #12]
3001ab28:	e583205c 	str	r2, [r3, #92]	; 0x5c
      pcb->state = ESTABLISHED;
3001ab2c:	e59d300c 	ldr	r3, [sp, #12]
3001ab30:	e3a02004 	mov	r2, #4
3001ab34:	e5c32010 	strb	r2, [r3, #16]

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
3001ab38:	e59d000c 	ldr	r0, [sp, #12]
3001ab3c:	eb000a16 	bl	3001d39c <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
3001ab40:	e59d300c 	ldr	r3, [sp, #12]
3001ab44:	e1d323b0 	ldrh	r2, [r3, #48]	; 0x30
3001ab48:	e59d300c 	ldr	r3, [sp, #12]
3001ab4c:	e2833004 	add	r3, r3, #4
3001ab50:	e1a00002 	mov	r0, r2
3001ab54:	e1a01003 	mov	r1, r3
3001ab58:	ebfffa61 	bl	300194e4 <tcp_eff_send_mss>
3001ab5c:	e1a03000 	mov	r3, r0
3001ab60:	e1a02003 	mov	r2, r3
3001ab64:	e59d300c 	ldr	r3, [sp, #12]
3001ab68:	e1c323b0 	strh	r2, [r3, #48]	; 0x30
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
3001ab6c:	e59d300c 	ldr	r3, [sp, #12]
3001ab70:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001ab74:	e1a02003 	mov	r2, r3
3001ab78:	e1a02102 	lsl	r2, r2, #2
3001ab7c:	e0823003 	add	r3, r2, r3
3001ab80:	e1a03083 	lsl	r3, r3, #1
3001ab84:	e1a03803 	lsl	r3, r3, #16
3001ab88:	e1a02823 	lsr	r2, r3, #16
3001ab8c:	e59d300c 	ldr	r3, [sp, #12]
3001ab90:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
3001ab94:	e59d300c 	ldr	r3, [sp, #12]
3001ab98:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
3001ab9c:	e3530001 	cmp	r3, #1
3001aba0:	1a000005 	bne	3001abbc <tcp_process+0x2d0>
3001aba4:	e59d300c 	ldr	r3, [sp, #12]
3001aba8:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001abac:	e1a03083 	lsl	r3, r3, #1
3001abb0:	e1a03803 	lsl	r3, r3, #16
3001abb4:	e1a03823 	lsr	r3, r3, #16
3001abb8:	ea000001 	b	3001abc4 <tcp_process+0x2d8>
3001abbc:	e59d300c 	ldr	r3, [sp, #12]
3001abc0:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001abc4:	e59d200c 	ldr	r2, [sp, #12]
3001abc8:	e1c234ba 	strh	r3, [r2, #74]	; 0x4a
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
3001abcc:	e59d300c 	ldr	r3, [sp, #12]
3001abd0:	e1d336bc 	ldrh	r3, [r3, #108]	; 0x6c
3001abd4:	e2433001 	sub	r3, r3, #1
3001abd8:	e1a03803 	lsl	r3, r3, #16
3001abdc:	e1a02823 	lsr	r2, r3, #16
3001abe0:	e59d300c 	ldr	r3, [sp, #12]
3001abe4:	e1c326bc 	strh	r2, [r3, #108]	; 0x6c
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
3001abe8:	e59d300c 	ldr	r3, [sp, #12]
3001abec:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001abf0:	e58d3014 	str	r3, [sp, #20]
      pcb->unacked = rseg->next;
3001abf4:	e59d3014 	ldr	r3, [sp, #20]
3001abf8:	e5932000 	ldr	r2, [r3]
3001abfc:	e59d300c 	ldr	r3, [sp, #12]
3001ac00:	e5832074 	str	r2, [r3, #116]	; 0x74

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
3001ac04:	e59d300c 	ldr	r3, [sp, #12]
3001ac08:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001ac0c:	e3530000 	cmp	r3, #0
3001ac10:	1a000003 	bne	3001ac24 <tcp_process+0x338>
        pcb->rtime = -1;
3001ac14:	e59d300c 	ldr	r3, [sp, #12]
3001ac18:	e3e02000 	mvn	r2, #0
3001ac1c:	e1c322be 	strh	r2, [r3, #46]	; 0x2e
3001ac20:	ea000005 	b	3001ac3c <tcp_process+0x350>
      else {
        pcb->rtime = 0;
3001ac24:	e59d300c 	ldr	r3, [sp, #12]
3001ac28:	e3a02000 	mov	r2, #0
3001ac2c:	e1c322be 	strh	r2, [r3, #46]	; 0x2e
        pcb->nrtx = 0;
3001ac30:	e59d300c 	ldr	r3, [sp, #12]
3001ac34:	e3a02000 	mov	r2, #0
3001ac38:	e5c32042 	strb	r2, [r3, #66]	; 0x42
      }

      tcp_seg_free(rseg);
3001ac3c:	e59d0014 	ldr	r0, [sp, #20]
3001ac40:	ebfff829 	bl	30018cec <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
3001ac44:	e59d300c 	ldr	r3, [sp, #12]
3001ac48:	e5933088 	ldr	r3, [r3, #136]	; 0x88
3001ac4c:	e3530000 	cmp	r3, #0
3001ac50:	0a00000b 	beq	3001ac84 <tcp_process+0x398>
3001ac54:	e59d300c 	ldr	r3, [sp, #12]
3001ac58:	e5933088 	ldr	r3, [r3, #136]	; 0x88
3001ac5c:	e59d200c 	ldr	r2, [sp, #12]
3001ac60:	e5922014 	ldr	r2, [r2, #20]
3001ac64:	e1a00002 	mov	r0, r2
3001ac68:	e59d100c 	ldr	r1, [sp, #12]
3001ac6c:	e3a02000 	mov	r2, #0
3001ac70:	e1a0e00f 	mov	lr, pc
3001ac74:	e12fff13 	bx	r3
3001ac78:	e1a03000 	mov	r3, r0
3001ac7c:	e20330ff 	and	r3, r3, #255	; 0xff
3001ac80:	e5cd301c 	strb	r3, [sp, #28]
      tcp_ack_now(pcb);
3001ac84:	e59d300c 	ldr	r3, [sp, #12]
3001ac88:	e5d3301c 	ldrb	r3, [r3, #28]
3001ac8c:	e3833002 	orr	r3, r3, #2
3001ac90:	e20320ff 	and	r2, r3, #255	; 0xff
3001ac94:	e59d300c 	ldr	r3, [sp, #12]
3001ac98:	e5c3201c 	strb	r2, [r3, #28]
3001ac9c:	e59d000c 	ldr	r0, [sp, #12]
3001aca0:	eb000ccb 	bl	3001dfd4 <tcp_output>
  switch (pcb->state) {
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
3001aca4:	e1a00000 	nop			; (mov r0, r0)
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
3001aca8:	ea0001f1 	b	3001b474 <tcp_process+0xb88>
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
3001acac:	e59f37dc 	ldr	r3, [pc, #2012]	; 3001b490 <tcp_process+0xba4>
3001acb0:	e5d33000 	ldrb	r3, [r3]
3001acb4:	e2033010 	and	r3, r3, #16
3001acb8:	e3530000 	cmp	r3, #0
3001acbc:	0a0001d9 	beq	3001b428 <tcp_process+0xb3c>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
3001acc0:	e59f37cc 	ldr	r3, [pc, #1996]	; 3001b494 <tcp_process+0xba8>
3001acc4:	e5930000 	ldr	r0, [r3]
3001acc8:	e59f37d8 	ldr	r3, [pc, #2008]	; 3001b4a8 <tcp_process+0xbbc>
3001accc:	e1d330b0 	ldrh	r3, [r3]
3001acd0:	e1a02003 	mov	r2, r3
3001acd4:	e59f37bc 	ldr	r3, [pc, #1980]	; 3001b498 <tcp_process+0xbac>
3001acd8:	e5933000 	ldr	r3, [r3]
3001acdc:	e0821003 	add	r1, r2, r3
3001ace0:	e59f37c4 	ldr	r3, [pc, #1988]	; 3001b4ac <tcp_process+0xbc0>
3001ace4:	e5933000 	ldr	r3, [r3]
3001ace8:	e2832010 	add	r2, r3, #16
3001acec:	e59f37b8 	ldr	r3, [pc, #1976]	; 3001b4ac <tcp_process+0xbc0>
3001acf0:	e5933000 	ldr	r3, [r3]
3001acf4:	e283c00c 	add	ip, r3, #12
        tcphdr->dest, tcphdr->src);
3001acf8:	e59f37a4 	ldr	r3, [pc, #1956]	; 3001b4a4 <tcp_process+0xbb8>
3001acfc:	e5933000 	ldr	r3, [r3]
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
3001ad00:	e5d3e002 	ldrb	lr, [r3, #2]
3001ad04:	e5d33003 	ldrb	r3, [r3, #3]
3001ad08:	e1a03403 	lsl	r3, r3, #8
3001ad0c:	e183300e 	orr	r3, r3, lr
3001ad10:	e1a03803 	lsl	r3, r3, #16
3001ad14:	e1a0e823 	lsr	lr, r3, #16
        tcphdr->dest, tcphdr->src);
3001ad18:	e59f3784 	ldr	r3, [pc, #1924]	; 3001b4a4 <tcp_process+0xbb8>
3001ad1c:	e5933000 	ldr	r3, [r3]
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
3001ad20:	e5d34000 	ldrb	r4, [r3]
3001ad24:	e5d33001 	ldrb	r3, [r3, #1]
3001ad28:	e1a03403 	lsl	r3, r3, #8
3001ad2c:	e1833004 	orr	r3, r3, r4
3001ad30:	e1a03803 	lsl	r3, r3, #16
3001ad34:	e1a03823 	lsr	r3, r3, #16
3001ad38:	e58de000 	str	lr, [sp]
3001ad3c:	e58d3004 	str	r3, [sp, #4]
3001ad40:	e1a0300c 	mov	r3, ip
3001ad44:	eb000fd9 	bl	3001ecb0 <tcp_rst>
        tcphdr->dest, tcphdr->src);
    }
    break;
3001ad48:	ea0001c9 	b	3001b474 <tcp_process+0xb88>
  case SYN_RCVD:
    if (flags & TCP_ACK &&
3001ad4c:	e59f373c 	ldr	r3, [pc, #1852]	; 3001b490 <tcp_process+0xba4>
3001ad50:	e5d33000 	ldrb	r3, [r3]
3001ad54:	e2033010 	and	r3, r3, #16
3001ad58:	e3530000 	cmp	r3, #0
3001ad5c:	0a0001b3 	beq	3001b430 <tcp_process+0xb44>
       !(flags & TCP_RST)) {
3001ad60:	e59f3728 	ldr	r3, [pc, #1832]	; 3001b490 <tcp_process+0xba4>
3001ad64:	e5d33000 	ldrb	r3, [r3]
3001ad68:	e2033004 	and	r3, r3, #4
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
3001ad6c:	e3530000 	cmp	r3, #0
3001ad70:	1a0001b0 	bne	3001b438 <tcp_process+0xb4c>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
3001ad74:	e59d300c 	ldr	r3, [sp, #12]
3001ad78:	e5933044 	ldr	r3, [r3, #68]	; 0x44
3001ad7c:	e1e02003 	mvn	r2, r3
3001ad80:	e59f370c 	ldr	r3, [pc, #1804]	; 3001b494 <tcp_process+0xba8>
3001ad84:	e5933000 	ldr	r3, [r3]
3001ad88:	e0823003 	add	r3, r2, r3
3001ad8c:	e3530000 	cmp	r3, #0
3001ad90:	ba00004a 	blt	3001aec0 <tcp_process+0x5d4>
3001ad94:	e59f36f8 	ldr	r3, [pc, #1784]	; 3001b494 <tcp_process+0xba8>
3001ad98:	e5932000 	ldr	r2, [r3]
3001ad9c:	e59d300c 	ldr	r3, [sp, #12]
3001ada0:	e5933050 	ldr	r3, [r3, #80]	; 0x50
3001ada4:	e0633002 	rsb	r3, r3, r2
3001ada8:	e3530000 	cmp	r3, #0
3001adac:	ca000043 	bgt	3001aec0 <tcp_process+0x5d4>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
3001adb0:	e59d300c 	ldr	r3, [sp, #12]
3001adb4:	e3a02004 	mov	r2, #4
3001adb8:	e5c32010 	strb	r2, [r3, #16]
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
3001adbc:	e59d300c 	ldr	r3, [sp, #12]
3001adc0:	e593308c 	ldr	r3, [r3, #140]	; 0x8c
3001adc4:	e3530000 	cmp	r3, #0
3001adc8:	0a00000b 	beq	3001adfc <tcp_process+0x510>
3001adcc:	e59d300c 	ldr	r3, [sp, #12]
3001add0:	e593308c 	ldr	r3, [r3, #140]	; 0x8c
3001add4:	e59d200c 	ldr	r2, [sp, #12]
3001add8:	e5922014 	ldr	r2, [r2, #20]
3001addc:	e1a00002 	mov	r0, r2
3001ade0:	e59d100c 	ldr	r1, [sp, #12]
3001ade4:	e3a02000 	mov	r2, #0
3001ade8:	e1a0e00f 	mov	lr, pc
3001adec:	e12fff13 	bx	r3
3001adf0:	e1a03000 	mov	r3, r0
3001adf4:	e20330ff 	and	r3, r3, #255	; 0xff
3001adf8:	e5cd301c 	strb	r3, [sp, #28]
        if (err != ERR_OK) {
3001adfc:	e1dd31dc 	ldrsb	r3, [sp, #28]
3001ae00:	e3530000 	cmp	r3, #0
3001ae04:	0a000003 	beq	3001ae18 <tcp_process+0x52c>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
3001ae08:	e59d000c 	ldr	r0, [sp, #12]
3001ae0c:	ebfff241 	bl	30017718 <tcp_abort>
          return ERR_ABRT;
3001ae10:	e3a030fc 	mov	r3, #252	; 0xfc
3001ae14:	ea000197 	b	3001b478 <tcp_process+0xb8c>
        }
        old_cwnd = pcb->cwnd;
3001ae18:	e59d300c 	ldr	r3, [sp, #12]
3001ae1c:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
3001ae20:	e1cd31be 	strh	r3, [sp, #30]
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
3001ae24:	e59d000c 	ldr	r0, [sp, #12]
3001ae28:	eb0001a3 	bl	3001b4bc <tcp_receive>
3001ae2c:	e1a03000 	mov	r3, r0
3001ae30:	e5cd301d 	strb	r3, [sp, #29]

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
3001ae34:	e1dd31be 	ldrh	r3, [sp, #30]
3001ae38:	e3530001 	cmp	r3, #1
3001ae3c:	1a000005 	bne	3001ae58 <tcp_process+0x56c>
3001ae40:	e59d300c 	ldr	r3, [sp, #12]
3001ae44:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001ae48:	e1a03083 	lsl	r3, r3, #1
3001ae4c:	e1a03803 	lsl	r3, r3, #16
3001ae50:	e1a03823 	lsr	r3, r3, #16
3001ae54:	ea000001 	b	3001ae60 <tcp_process+0x574>
3001ae58:	e59d300c 	ldr	r3, [sp, #12]
3001ae5c:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001ae60:	e59d200c 	ldr	r2, [sp, #12]
3001ae64:	e1c234ba 	strh	r3, [r2, #74]	; 0x4a

        if ((flags & TCP_FIN) && accepted_inseq) {
3001ae68:	e59f3620 	ldr	r3, [pc, #1568]	; 3001b490 <tcp_process+0xba4>
3001ae6c:	e5d33000 	ldrb	r3, [r3]
3001ae70:	e2033001 	and	r3, r3, #1
3001ae74:	e20330ff 	and	r3, r3, #255	; 0xff
3001ae78:	e3530000 	cmp	r3, #0
3001ae7c:	0a00000d 	beq	3001aeb8 <tcp_process+0x5cc>
3001ae80:	e5dd301d 	ldrb	r3, [sp, #29]
3001ae84:	e3530000 	cmp	r3, #0
3001ae88:	0a00000a 	beq	3001aeb8 <tcp_process+0x5cc>
          tcp_ack_now(pcb);
3001ae8c:	e59d300c 	ldr	r3, [sp, #12]
3001ae90:	e5d3301c 	ldrb	r3, [r3, #28]
3001ae94:	e3833002 	orr	r3, r3, #2
3001ae98:	e20320ff 	and	r2, r3, #255	; 0xff
3001ae9c:	e59d300c 	ldr	r3, [sp, #12]
3001aea0:	e5c3201c 	strb	r2, [r3, #28]
3001aea4:	e59d000c 	ldr	r0, [sp, #12]
3001aea8:	eb000c49 	bl	3001dfd4 <tcp_output>
          pcb->state = CLOSE_WAIT;
3001aeac:	e59d300c 	ldr	r3, [sp, #12]
3001aeb0:	e3a02007 	mov	r2, #7
3001aeb4:	e5c32010 	strb	r2, [r3, #16]
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
3001aeb8:	e1a00000 	nop			; (mov r0, r0)
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
3001aebc:	ea00016c 	b	3001b474 <tcp_process+0xb88>
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
3001aec0:	e59f35cc 	ldr	r3, [pc, #1484]	; 3001b494 <tcp_process+0xba8>
3001aec4:	e5930000 	ldr	r0, [r3]
3001aec8:	e59f35d8 	ldr	r3, [pc, #1496]	; 3001b4a8 <tcp_process+0xbbc>
3001aecc:	e1d330b0 	ldrh	r3, [r3]
3001aed0:	e1a02003 	mov	r2, r3
3001aed4:	e59f35bc 	ldr	r3, [pc, #1468]	; 3001b498 <tcp_process+0xbac>
3001aed8:	e5933000 	ldr	r3, [r3]
3001aedc:	e0821003 	add	r1, r2, r3
3001aee0:	e59f35c4 	ldr	r3, [pc, #1476]	; 3001b4ac <tcp_process+0xbc0>
3001aee4:	e5933000 	ldr	r3, [r3]
3001aee8:	e2832010 	add	r2, r3, #16
3001aeec:	e59f35b8 	ldr	r3, [pc, #1464]	; 3001b4ac <tcp_process+0xbc0>
3001aef0:	e5933000 	ldr	r3, [r3]
3001aef4:	e283c00c 	add	ip, r3, #12
                tcphdr->dest, tcphdr->src);
3001aef8:	e59f35a4 	ldr	r3, [pc, #1444]	; 3001b4a4 <tcp_process+0xbb8>
3001aefc:	e5933000 	ldr	r3, [r3]
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
3001af00:	e5d3e002 	ldrb	lr, [r3, #2]
3001af04:	e5d33003 	ldrb	r3, [r3, #3]
3001af08:	e1a03403 	lsl	r3, r3, #8
3001af0c:	e183300e 	orr	r3, r3, lr
3001af10:	e1a03803 	lsl	r3, r3, #16
3001af14:	e1a0e823 	lsr	lr, r3, #16
                tcphdr->dest, tcphdr->src);
3001af18:	e59f3584 	ldr	r3, [pc, #1412]	; 3001b4a4 <tcp_process+0xbb8>
3001af1c:	e5933000 	ldr	r3, [r3]
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
3001af20:	e5d34000 	ldrb	r4, [r3]
3001af24:	e5d33001 	ldrb	r3, [r3, #1]
3001af28:	e1a03403 	lsl	r3, r3, #8
3001af2c:	e1833004 	orr	r3, r3, r4
3001af30:	e1a03803 	lsl	r3, r3, #16
3001af34:	e1a03823 	lsr	r3, r3, #16
3001af38:	e58de000 	str	lr, [sp]
3001af3c:	e58d3004 	str	r3, [sp, #4]
3001af40:	e1a0300c 	mov	r3, ip
3001af44:	eb000f59 	bl	3001ecb0 <tcp_rst>
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
3001af48:	ea000149 	b	3001b474 <tcp_process+0xb88>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
3001af4c:	e59d000c 	ldr	r0, [sp, #12]
3001af50:	eb000159 	bl	3001b4bc <tcp_receive>
3001af54:	e1a03000 	mov	r3, r0
3001af58:	e5cd301d 	strb	r3, [sp, #29]
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
3001af5c:	e59f352c 	ldr	r3, [pc, #1324]	; 3001b490 <tcp_process+0xba4>
3001af60:	e5d33000 	ldrb	r3, [r3]
3001af64:	e2033001 	and	r3, r3, #1
3001af68:	e20330ff 	and	r3, r3, #255	; 0xff
3001af6c:	e3530000 	cmp	r3, #0
3001af70:	0a000132 	beq	3001b440 <tcp_process+0xb54>
3001af74:	e5dd301d 	ldrb	r3, [sp, #29]
3001af78:	e3530000 	cmp	r3, #0
3001af7c:	0a000131 	beq	3001b448 <tcp_process+0xb5c>
      tcp_ack_now(pcb);
3001af80:	e59d300c 	ldr	r3, [sp, #12]
3001af84:	e5d3301c 	ldrb	r3, [r3, #28]
3001af88:	e3833002 	orr	r3, r3, #2
3001af8c:	e20320ff 	and	r2, r3, #255	; 0xff
3001af90:	e59d300c 	ldr	r3, [sp, #12]
3001af94:	e5c3201c 	strb	r2, [r3, #28]
3001af98:	e59d000c 	ldr	r0, [sp, #12]
3001af9c:	eb000c0c 	bl	3001dfd4 <tcp_output>
      pcb->state = CLOSE_WAIT;
3001afa0:	e59d300c 	ldr	r3, [sp, #12]
3001afa4:	e3a02007 	mov	r2, #7
3001afa8:	e5c32010 	strb	r2, [r3, #16]
    }
    break;
3001afac:	ea000130 	b	3001b474 <tcp_process+0xb88>
  case FIN_WAIT_1:
    tcp_receive(pcb);
3001afb0:	e59d000c 	ldr	r0, [sp, #12]
3001afb4:	eb000140 	bl	3001b4bc <tcp_receive>
    if (flags & TCP_FIN) {
3001afb8:	e59f34d0 	ldr	r3, [pc, #1232]	; 3001b490 <tcp_process+0xba4>
3001afbc:	e5d33000 	ldrb	r3, [r3]
3001afc0:	e2033001 	and	r3, r3, #1
3001afc4:	e20330ff 	and	r3, r3, #255	; 0xff
3001afc8:	e3530000 	cmp	r3, #0
3001afcc:	0a00005a 	beq	3001b13c <tcp_process+0x850>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
3001afd0:	e59f34b8 	ldr	r3, [pc, #1208]	; 3001b490 <tcp_process+0xba4>
3001afd4:	e5d33000 	ldrb	r3, [r3]
3001afd8:	e2033010 	and	r3, r3, #16
3001afdc:	e3530000 	cmp	r3, #0
3001afe0:	0a000049 	beq	3001b10c <tcp_process+0x820>
3001afe4:	e59d300c 	ldr	r3, [sp, #12]
3001afe8:	e5932050 	ldr	r2, [r3, #80]	; 0x50
3001afec:	e59f34a0 	ldr	r3, [pc, #1184]	; 3001b494 <tcp_process+0xba8>
3001aff0:	e5933000 	ldr	r3, [r3]
3001aff4:	e1520003 	cmp	r2, r3
3001aff8:	1a000043 	bne	3001b10c <tcp_process+0x820>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
3001affc:	e59d300c 	ldr	r3, [sp, #12]
3001b000:	e5d3301c 	ldrb	r3, [r3, #28]
3001b004:	e3833002 	orr	r3, r3, #2
3001b008:	e20320ff 	and	r2, r3, #255	; 0xff
3001b00c:	e59d300c 	ldr	r3, [sp, #12]
3001b010:	e5c3201c 	strb	r2, [r3, #28]
3001b014:	e59d000c 	ldr	r0, [sp, #12]
3001b018:	eb000bed 	bl	3001dfd4 <tcp_output>
        tcp_pcb_purge(pcb);
3001b01c:	e59d000c 	ldr	r0, [sp, #12]
3001b020:	ebfff89c 	bl	30019298 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
3001b024:	e59f3484 	ldr	r3, [pc, #1156]	; 3001b4b0 <tcp_process+0xbc4>
3001b028:	e5932000 	ldr	r2, [r3]
3001b02c:	e59d300c 	ldr	r3, [sp, #12]
3001b030:	e1520003 	cmp	r2, r3
3001b034:	1a000005 	bne	3001b050 <tcp_process+0x764>
3001b038:	e59f3470 	ldr	r3, [pc, #1136]	; 3001b4b0 <tcp_process+0xbc4>
3001b03c:	e5933000 	ldr	r3, [r3]
3001b040:	e593200c 	ldr	r2, [r3, #12]
3001b044:	e59f3464 	ldr	r3, [pc, #1124]	; 3001b4b0 <tcp_process+0xbc4>
3001b048:	e5832000 	str	r2, [r3]
3001b04c:	ea00001e 	b	3001b0cc <tcp_process+0x7e0>
3001b050:	e59f3458 	ldr	r3, [pc, #1112]	; 3001b4b0 <tcp_process+0xbc4>
3001b054:	e5932000 	ldr	r2, [r3]
3001b058:	e59f3454 	ldr	r3, [pc, #1108]	; 3001b4b4 <tcp_process+0xbc8>
3001b05c:	e5832000 	str	r2, [r3]
3001b060:	ea000015 	b	3001b0bc <tcp_process+0x7d0>
3001b064:	e59f3448 	ldr	r3, [pc, #1096]	; 3001b4b4 <tcp_process+0xbc8>
3001b068:	e5933000 	ldr	r3, [r3]
3001b06c:	e593300c 	ldr	r3, [r3, #12]
3001b070:	e3530000 	cmp	r3, #0
3001b074:	0a00000b 	beq	3001b0a8 <tcp_process+0x7bc>
3001b078:	e59f3434 	ldr	r3, [pc, #1076]	; 3001b4b4 <tcp_process+0xbc8>
3001b07c:	e5933000 	ldr	r3, [r3]
3001b080:	e593200c 	ldr	r2, [r3, #12]
3001b084:	e59d300c 	ldr	r3, [sp, #12]
3001b088:	e1520003 	cmp	r2, r3
3001b08c:	1a000005 	bne	3001b0a8 <tcp_process+0x7bc>
3001b090:	e59f341c 	ldr	r3, [pc, #1052]	; 3001b4b4 <tcp_process+0xbc8>
3001b094:	e5933000 	ldr	r3, [r3]
3001b098:	e59d200c 	ldr	r2, [sp, #12]
3001b09c:	e592200c 	ldr	r2, [r2, #12]
3001b0a0:	e583200c 	str	r2, [r3, #12]
3001b0a4:	ea000008 	b	3001b0cc <tcp_process+0x7e0>
3001b0a8:	e59f3404 	ldr	r3, [pc, #1028]	; 3001b4b4 <tcp_process+0xbc8>
3001b0ac:	e5933000 	ldr	r3, [r3]
3001b0b0:	e593200c 	ldr	r2, [r3, #12]
3001b0b4:	e59f33f8 	ldr	r3, [pc, #1016]	; 3001b4b4 <tcp_process+0xbc8>
3001b0b8:	e5832000 	str	r2, [r3]
3001b0bc:	e59f33f0 	ldr	r3, [pc, #1008]	; 3001b4b4 <tcp_process+0xbc8>
3001b0c0:	e5933000 	ldr	r3, [r3]
3001b0c4:	e3530000 	cmp	r3, #0
3001b0c8:	1affffe5 	bne	3001b064 <tcp_process+0x778>
3001b0cc:	e59d300c 	ldr	r3, [sp, #12]
3001b0d0:	e3a02000 	mov	r2, #0
3001b0d4:	e583200c 	str	r2, [r3, #12]
        pcb->state = TIME_WAIT;
3001b0d8:	e59d300c 	ldr	r3, [sp, #12]
3001b0dc:	e3a0200a 	mov	r2, #10
3001b0e0:	e5c32010 	strb	r2, [r3, #16]
        TCP_REG(&tcp_tw_pcbs, pcb);
3001b0e4:	e59f33cc 	ldr	r3, [pc, #972]	; 3001b4b8 <tcp_process+0xbcc>
3001b0e8:	e5932000 	ldr	r2, [r3]
3001b0ec:	e59d300c 	ldr	r3, [sp, #12]
3001b0f0:	e583200c 	str	r2, [r3, #12]
3001b0f4:	e59f33bc 	ldr	r3, [pc, #956]	; 3001b4b8 <tcp_process+0xbcc>
3001b0f8:	e59d200c 	ldr	r2, [sp, #12]
3001b0fc:	e5832000 	str	r2, [r3]
3001b100:	ebffdbdd 	bl	3001207c <tcp_timer_needed>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
    if (flags & TCP_FIN) {
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
3001b104:	e1a00000 	nop			; (mov r0, r0)
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
3001b108:	ea0000d9 	b	3001b474 <tcp_process+0xb88>
        tcp_pcb_purge(pcb);
        TCP_RMV(&tcp_active_pcbs, pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
3001b10c:	e59d300c 	ldr	r3, [sp, #12]
3001b110:	e5d3301c 	ldrb	r3, [r3, #28]
3001b114:	e3833002 	orr	r3, r3, #2
3001b118:	e20320ff 	and	r2, r3, #255	; 0xff
3001b11c:	e59d300c 	ldr	r3, [sp, #12]
3001b120:	e5c3201c 	strb	r2, [r3, #28]
3001b124:	e59d000c 	ldr	r0, [sp, #12]
3001b128:	eb000ba9 	bl	3001dfd4 <tcp_output>
        pcb->state = CLOSING;
3001b12c:	e59d300c 	ldr	r3, [sp, #12]
3001b130:	e3a02008 	mov	r2, #8
3001b134:	e5c32010 	strb	r2, [r3, #16]
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
3001b138:	ea0000cd 	b	3001b474 <tcp_process+0xb88>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
3001b13c:	e59f334c 	ldr	r3, [pc, #844]	; 3001b490 <tcp_process+0xba4>
3001b140:	e5d33000 	ldrb	r3, [r3]
3001b144:	e2033010 	and	r3, r3, #16
3001b148:	e3530000 	cmp	r3, #0
3001b14c:	0a0000bf 	beq	3001b450 <tcp_process+0xb64>
3001b150:	e59d300c 	ldr	r3, [sp, #12]
3001b154:	e5932050 	ldr	r2, [r3, #80]	; 0x50
3001b158:	e59f3334 	ldr	r3, [pc, #820]	; 3001b494 <tcp_process+0xba8>
3001b15c:	e5933000 	ldr	r3, [r3]
3001b160:	e1520003 	cmp	r2, r3
3001b164:	1a0000bb 	bne	3001b458 <tcp_process+0xb6c>
      pcb->state = FIN_WAIT_2;
3001b168:	e59d300c 	ldr	r3, [sp, #12]
3001b16c:	e3a02006 	mov	r2, #6
3001b170:	e5c32010 	strb	r2, [r3, #16]
    }
    break;
3001b174:	ea0000be 	b	3001b474 <tcp_process+0xb88>
  case FIN_WAIT_2:
    tcp_receive(pcb);
3001b178:	e59d000c 	ldr	r0, [sp, #12]
3001b17c:	eb0000ce 	bl	3001b4bc <tcp_receive>
    if (flags & TCP_FIN) {
3001b180:	e59f3308 	ldr	r3, [pc, #776]	; 3001b490 <tcp_process+0xba4>
3001b184:	e5d33000 	ldrb	r3, [r3]
3001b188:	e2033001 	and	r3, r3, #1
3001b18c:	e20330ff 	and	r3, r3, #255	; 0xff
3001b190:	e3530000 	cmp	r3, #0
3001b194:	0a0000b1 	beq	3001b460 <tcp_process+0xb74>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
3001b198:	e59d300c 	ldr	r3, [sp, #12]
3001b19c:	e5d3301c 	ldrb	r3, [r3, #28]
3001b1a0:	e3833002 	orr	r3, r3, #2
3001b1a4:	e20320ff 	and	r2, r3, #255	; 0xff
3001b1a8:	e59d300c 	ldr	r3, [sp, #12]
3001b1ac:	e5c3201c 	strb	r2, [r3, #28]
3001b1b0:	e59d000c 	ldr	r0, [sp, #12]
3001b1b4:	eb000b86 	bl	3001dfd4 <tcp_output>
      tcp_pcb_purge(pcb);
3001b1b8:	e59d000c 	ldr	r0, [sp, #12]
3001b1bc:	ebfff835 	bl	30019298 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
3001b1c0:	e59f32e8 	ldr	r3, [pc, #744]	; 3001b4b0 <tcp_process+0xbc4>
3001b1c4:	e5932000 	ldr	r2, [r3]
3001b1c8:	e59d300c 	ldr	r3, [sp, #12]
3001b1cc:	e1520003 	cmp	r2, r3
3001b1d0:	1a000005 	bne	3001b1ec <tcp_process+0x900>
3001b1d4:	e59f32d4 	ldr	r3, [pc, #724]	; 3001b4b0 <tcp_process+0xbc4>
3001b1d8:	e5933000 	ldr	r3, [r3]
3001b1dc:	e593200c 	ldr	r2, [r3, #12]
3001b1e0:	e59f32c8 	ldr	r3, [pc, #712]	; 3001b4b0 <tcp_process+0xbc4>
3001b1e4:	e5832000 	str	r2, [r3]
3001b1e8:	ea00001e 	b	3001b268 <tcp_process+0x97c>
3001b1ec:	e59f32bc 	ldr	r3, [pc, #700]	; 3001b4b0 <tcp_process+0xbc4>
3001b1f0:	e5932000 	ldr	r2, [r3]
3001b1f4:	e59f32b8 	ldr	r3, [pc, #696]	; 3001b4b4 <tcp_process+0xbc8>
3001b1f8:	e5832000 	str	r2, [r3]
3001b1fc:	ea000015 	b	3001b258 <tcp_process+0x96c>
3001b200:	e59f32ac 	ldr	r3, [pc, #684]	; 3001b4b4 <tcp_process+0xbc8>
3001b204:	e5933000 	ldr	r3, [r3]
3001b208:	e593300c 	ldr	r3, [r3, #12]
3001b20c:	e3530000 	cmp	r3, #0
3001b210:	0a00000b 	beq	3001b244 <tcp_process+0x958>
3001b214:	e59f3298 	ldr	r3, [pc, #664]	; 3001b4b4 <tcp_process+0xbc8>
3001b218:	e5933000 	ldr	r3, [r3]
3001b21c:	e593200c 	ldr	r2, [r3, #12]
3001b220:	e59d300c 	ldr	r3, [sp, #12]
3001b224:	e1520003 	cmp	r2, r3
3001b228:	1a000005 	bne	3001b244 <tcp_process+0x958>
3001b22c:	e59f3280 	ldr	r3, [pc, #640]	; 3001b4b4 <tcp_process+0xbc8>
3001b230:	e5933000 	ldr	r3, [r3]
3001b234:	e59d200c 	ldr	r2, [sp, #12]
3001b238:	e592200c 	ldr	r2, [r2, #12]
3001b23c:	e583200c 	str	r2, [r3, #12]
3001b240:	ea000008 	b	3001b268 <tcp_process+0x97c>
3001b244:	e59f3268 	ldr	r3, [pc, #616]	; 3001b4b4 <tcp_process+0xbc8>
3001b248:	e5933000 	ldr	r3, [r3]
3001b24c:	e593200c 	ldr	r2, [r3, #12]
3001b250:	e59f325c 	ldr	r3, [pc, #604]	; 3001b4b4 <tcp_process+0xbc8>
3001b254:	e5832000 	str	r2, [r3]
3001b258:	e59f3254 	ldr	r3, [pc, #596]	; 3001b4b4 <tcp_process+0xbc8>
3001b25c:	e5933000 	ldr	r3, [r3]
3001b260:	e3530000 	cmp	r3, #0
3001b264:	1affffe5 	bne	3001b200 <tcp_process+0x914>
3001b268:	e59d300c 	ldr	r3, [sp, #12]
3001b26c:	e3a02000 	mov	r2, #0
3001b270:	e583200c 	str	r2, [r3, #12]
      pcb->state = TIME_WAIT;
3001b274:	e59d300c 	ldr	r3, [sp, #12]
3001b278:	e3a0200a 	mov	r2, #10
3001b27c:	e5c32010 	strb	r2, [r3, #16]
      TCP_REG(&tcp_tw_pcbs, pcb);
3001b280:	e59f3230 	ldr	r3, [pc, #560]	; 3001b4b8 <tcp_process+0xbcc>
3001b284:	e5932000 	ldr	r2, [r3]
3001b288:	e59d300c 	ldr	r3, [sp, #12]
3001b28c:	e583200c 	str	r2, [r3, #12]
3001b290:	e59f3220 	ldr	r3, [pc, #544]	; 3001b4b8 <tcp_process+0xbcc>
3001b294:	e59d200c 	ldr	r2, [sp, #12]
3001b298:	e5832000 	str	r2, [r3]
3001b29c:	ebffdb76 	bl	3001207c <tcp_timer_needed>
    }
    break;
3001b2a0:	ea000073 	b	3001b474 <tcp_process+0xb88>
  case CLOSING:
    tcp_receive(pcb);
3001b2a4:	e59d000c 	ldr	r0, [sp, #12]
3001b2a8:	eb000083 	bl	3001b4bc <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
3001b2ac:	e59f31dc 	ldr	r3, [pc, #476]	; 3001b490 <tcp_process+0xba4>
3001b2b0:	e5d33000 	ldrb	r3, [r3]
3001b2b4:	e2033010 	and	r3, r3, #16
3001b2b8:	e3530000 	cmp	r3, #0
3001b2bc:	0a000069 	beq	3001b468 <tcp_process+0xb7c>
3001b2c0:	e59d300c 	ldr	r3, [sp, #12]
3001b2c4:	e5932050 	ldr	r2, [r3, #80]	; 0x50
3001b2c8:	e59f31c4 	ldr	r3, [pc, #452]	; 3001b494 <tcp_process+0xba8>
3001b2cc:	e5933000 	ldr	r3, [r3]
3001b2d0:	e1520003 	cmp	r2, r3
3001b2d4:	1a000065 	bne	3001b470 <tcp_process+0xb84>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
3001b2d8:	e59d300c 	ldr	r3, [sp, #12]
3001b2dc:	e5d3301c 	ldrb	r3, [r3, #28]
3001b2e0:	e3833002 	orr	r3, r3, #2
3001b2e4:	e20320ff 	and	r2, r3, #255	; 0xff
3001b2e8:	e59d300c 	ldr	r3, [sp, #12]
3001b2ec:	e5c3201c 	strb	r2, [r3, #28]
3001b2f0:	e59d000c 	ldr	r0, [sp, #12]
3001b2f4:	eb000b36 	bl	3001dfd4 <tcp_output>
      tcp_pcb_purge(pcb);
3001b2f8:	e59d000c 	ldr	r0, [sp, #12]
3001b2fc:	ebfff7e5 	bl	30019298 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
3001b300:	e59f31a8 	ldr	r3, [pc, #424]	; 3001b4b0 <tcp_process+0xbc4>
3001b304:	e5932000 	ldr	r2, [r3]
3001b308:	e59d300c 	ldr	r3, [sp, #12]
3001b30c:	e1520003 	cmp	r2, r3
3001b310:	1a000005 	bne	3001b32c <tcp_process+0xa40>
3001b314:	e59f3194 	ldr	r3, [pc, #404]	; 3001b4b0 <tcp_process+0xbc4>
3001b318:	e5933000 	ldr	r3, [r3]
3001b31c:	e593200c 	ldr	r2, [r3, #12]
3001b320:	e59f3188 	ldr	r3, [pc, #392]	; 3001b4b0 <tcp_process+0xbc4>
3001b324:	e5832000 	str	r2, [r3]
3001b328:	ea00001e 	b	3001b3a8 <tcp_process+0xabc>
3001b32c:	e59f317c 	ldr	r3, [pc, #380]	; 3001b4b0 <tcp_process+0xbc4>
3001b330:	e5932000 	ldr	r2, [r3]
3001b334:	e59f3178 	ldr	r3, [pc, #376]	; 3001b4b4 <tcp_process+0xbc8>
3001b338:	e5832000 	str	r2, [r3]
3001b33c:	ea000015 	b	3001b398 <tcp_process+0xaac>
3001b340:	e59f316c 	ldr	r3, [pc, #364]	; 3001b4b4 <tcp_process+0xbc8>
3001b344:	e5933000 	ldr	r3, [r3]
3001b348:	e593300c 	ldr	r3, [r3, #12]
3001b34c:	e3530000 	cmp	r3, #0
3001b350:	0a00000b 	beq	3001b384 <tcp_process+0xa98>
3001b354:	e59f3158 	ldr	r3, [pc, #344]	; 3001b4b4 <tcp_process+0xbc8>
3001b358:	e5933000 	ldr	r3, [r3]
3001b35c:	e593200c 	ldr	r2, [r3, #12]
3001b360:	e59d300c 	ldr	r3, [sp, #12]
3001b364:	e1520003 	cmp	r2, r3
3001b368:	1a000005 	bne	3001b384 <tcp_process+0xa98>
3001b36c:	e59f3140 	ldr	r3, [pc, #320]	; 3001b4b4 <tcp_process+0xbc8>
3001b370:	e5933000 	ldr	r3, [r3]
3001b374:	e59d200c 	ldr	r2, [sp, #12]
3001b378:	e592200c 	ldr	r2, [r2, #12]
3001b37c:	e583200c 	str	r2, [r3, #12]
3001b380:	ea000008 	b	3001b3a8 <tcp_process+0xabc>
3001b384:	e59f3128 	ldr	r3, [pc, #296]	; 3001b4b4 <tcp_process+0xbc8>
3001b388:	e5933000 	ldr	r3, [r3]
3001b38c:	e593200c 	ldr	r2, [r3, #12]
3001b390:	e59f311c 	ldr	r3, [pc, #284]	; 3001b4b4 <tcp_process+0xbc8>
3001b394:	e5832000 	str	r2, [r3]
3001b398:	e59f3114 	ldr	r3, [pc, #276]	; 3001b4b4 <tcp_process+0xbc8>
3001b39c:	e5933000 	ldr	r3, [r3]
3001b3a0:	e3530000 	cmp	r3, #0
3001b3a4:	1affffe5 	bne	3001b340 <tcp_process+0xa54>
3001b3a8:	e59d300c 	ldr	r3, [sp, #12]
3001b3ac:	e3a02000 	mov	r2, #0
3001b3b0:	e583200c 	str	r2, [r3, #12]
      pcb->state = TIME_WAIT;
3001b3b4:	e59d300c 	ldr	r3, [sp, #12]
3001b3b8:	e3a0200a 	mov	r2, #10
3001b3bc:	e5c32010 	strb	r2, [r3, #16]
      TCP_REG(&tcp_tw_pcbs, pcb);
3001b3c0:	e59f30f0 	ldr	r3, [pc, #240]	; 3001b4b8 <tcp_process+0xbcc>
3001b3c4:	e5932000 	ldr	r2, [r3]
3001b3c8:	e59d300c 	ldr	r3, [sp, #12]
3001b3cc:	e583200c 	str	r2, [r3, #12]
3001b3d0:	e59f30e0 	ldr	r3, [pc, #224]	; 3001b4b8 <tcp_process+0xbcc>
3001b3d4:	e59d200c 	ldr	r2, [sp, #12]
3001b3d8:	e5832000 	str	r2, [r3]
3001b3dc:	ebffdb26 	bl	3001207c <tcp_timer_needed>
    }
    break;
3001b3e0:	ea000023 	b	3001b474 <tcp_process+0xb88>
  case LAST_ACK:
    tcp_receive(pcb);
3001b3e4:	e59d000c 	ldr	r0, [sp, #12]
3001b3e8:	eb000033 	bl	3001b4bc <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
3001b3ec:	e59f309c 	ldr	r3, [pc, #156]	; 3001b490 <tcp_process+0xba4>
3001b3f0:	e5d33000 	ldrb	r3, [r3]
3001b3f4:	e2033010 	and	r3, r3, #16
3001b3f8:	e3530000 	cmp	r3, #0
3001b3fc:	0a00001c 	beq	3001b474 <tcp_process+0xb88>
3001b400:	e59d300c 	ldr	r3, [sp, #12]
3001b404:	e5932050 	ldr	r2, [r3, #80]	; 0x50
3001b408:	e59f3084 	ldr	r3, [pc, #132]	; 3001b494 <tcp_process+0xba8>
3001b40c:	e5933000 	ldr	r3, [r3]
3001b410:	e1520003 	cmp	r2, r3
3001b414:	1a000016 	bne	3001b474 <tcp_process+0xb88>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
3001b418:	e59f307c 	ldr	r3, [pc, #124]	; 3001b49c <tcp_process+0xbb0>
3001b41c:	e3a02010 	mov	r2, #16
3001b420:	e5c32000 	strb	r2, [r3]
3001b424:	ea000012 	b	3001b474 <tcp_process+0xb88>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
3001b428:	e1a00000 	nop			; (mov r0, r0)
3001b42c:	ea000010 	b	3001b474 <tcp_process+0xb88>
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
3001b430:	e1a00000 	nop			; (mov r0, r0)
3001b434:	ea00000e 	b	3001b474 <tcp_process+0xb88>
3001b438:	e1a00000 	nop			; (mov r0, r0)
3001b43c:	ea00000c 	b	3001b474 <tcp_process+0xb88>
    accepted_inseq = tcp_receive(pcb);
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
3001b440:	e1a00000 	nop			; (mov r0, r0)
3001b444:	ea00000a 	b	3001b474 <tcp_process+0xb88>
3001b448:	e1a00000 	nop			; (mov r0, r0)
3001b44c:	ea000008 	b	3001b474 <tcp_process+0xb88>
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
3001b450:	e1a00000 	nop			; (mov r0, r0)
3001b454:	ea000006 	b	3001b474 <tcp_process+0xb88>
3001b458:	e1a00000 	nop			; (mov r0, r0)
3001b45c:	ea000004 	b	3001b474 <tcp_process+0xb88>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
3001b460:	e1a00000 	nop			; (mov r0, r0)
3001b464:	ea000002 	b	3001b474 <tcp_process+0xb88>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
3001b468:	e1a00000 	nop			; (mov r0, r0)
3001b46c:	ea000000 	b	3001b474 <tcp_process+0xb88>
3001b470:	e1a00000 	nop			; (mov r0, r0)
    }
    break;
  default:
    break;
  }
  return ERR_OK;
3001b474:	e3a03000 	mov	r3, #0
3001b478:	e1a03c03 	lsl	r3, r3, #24
3001b47c:	e1a03c43 	asr	r3, r3, #24
}
3001b480:	e1a00003 	mov	r0, r3
3001b484:	e28dd020 	add	sp, sp, #32
3001b488:	e8bd4010 	pop	{r4, lr}
3001b48c:	e12fff1e 	bx	lr
3001b490:	300dbbc0 	.word	0x300dbbc0
3001b494:	300dbbbc 	.word	0x300dbbbc
3001b498:	300dbbb8 	.word	0x300dbbb8
3001b49c:	300dbbc4 	.word	0x300dbbc4
3001b4a0:	300eaa74 	.word	0x300eaa74
3001b4a4:	300dbbb0 	.word	0x300dbbb0
3001b4a8:	300dbbc2 	.word	0x300dbbc2
3001b4ac:	300dbbb4 	.word	0x300dbbb4
3001b4b0:	300eaa38 	.word	0x300eaa38
3001b4b4:	3012a850 	.word	0x3012a850
3001b4b8:	302be508 	.word	0x302be508

3001b4bc <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
3001b4bc:	e92d4070 	push	{r4, r5, r6, lr}
3001b4c0:	e24dd030 	sub	sp, sp, #48	; 0x30
3001b4c4:	e58d0004 	str	r0, [sp, #4]
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
3001b4c8:	e3a03000 	mov	r3, #0
3001b4cc:	e5cd3029 	strb	r3, [sp, #41]	; 0x29

  if (flags & TCP_ACK) {
3001b4d0:	e59f3e50 	ldr	r3, [pc, #3664]	; 3001c328 <tcp_receive+0xe6c>
3001b4d4:	e5d33000 	ldrb	r3, [r3]
3001b4d8:	e2033010 	and	r3, r3, #16
3001b4dc:	e3530000 	cmp	r3, #0
3001b4e0:	0a000298 	beq	3001bf48 <tcp_receive+0xa8c>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
3001b4e4:	e59d3004 	ldr	r3, [sp, #4]
3001b4e8:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
3001b4ec:	e1a02003 	mov	r2, r3
3001b4f0:	e59d3004 	ldr	r3, [sp, #4]
3001b4f4:	e593305c 	ldr	r3, [r3, #92]	; 0x5c
3001b4f8:	e0823003 	add	r3, r2, r3
3001b4fc:	e58d3020 	str	r3, [sp, #32]

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
3001b500:	e59d3004 	ldr	r3, [sp, #4]
3001b504:	e593205c 	ldr	r2, [r3, #92]	; 0x5c
3001b508:	e59f3e38 	ldr	r3, [pc, #3640]	; 3001c348 <tcp_receive+0xe8c>
3001b50c:	e5933000 	ldr	r3, [r3]
3001b510:	e0633002 	rsb	r3, r3, r2
3001b514:	e3530000 	cmp	r3, #0
3001b518:	ba00001e 	blt	3001b598 <tcp_receive+0xdc>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
3001b51c:	e59d3004 	ldr	r3, [sp, #4]
3001b520:	e593205c 	ldr	r2, [r3, #92]	; 0x5c
3001b524:	e59f3e1c 	ldr	r3, [pc, #3612]	; 3001c348 <tcp_receive+0xe8c>
3001b528:	e5933000 	ldr	r3, [r3]

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
3001b52c:	e1520003 	cmp	r2, r3
3001b530:	1a000006 	bne	3001b550 <tcp_receive+0x94>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
3001b534:	e59d3004 	ldr	r3, [sp, #4]
3001b538:	e5932060 	ldr	r2, [r3, #96]	; 0x60
3001b53c:	e59f3de8 	ldr	r3, [pc, #3560]	; 3001c32c <tcp_receive+0xe70>
3001b540:	e5933000 	ldr	r3, [r3]
3001b544:	e0633002 	rsb	r3, r3, r2

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
3001b548:	e3530000 	cmp	r3, #0
3001b54c:	ba000011 	blt	3001b598 <tcp_receive+0xdc>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
3001b550:	e59d3004 	ldr	r3, [sp, #4]
3001b554:	e5932060 	ldr	r2, [r3, #96]	; 0x60
3001b558:	e59f3dcc 	ldr	r3, [pc, #3532]	; 3001c32c <tcp_receive+0xe70>
3001b55c:	e5933000 	ldr	r3, [r3]

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
3001b560:	e1520003 	cmp	r2, r3
3001b564:	1a000028 	bne	3001b60c <tcp_receive+0x150>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
3001b568:	e59f3dc0 	ldr	r3, [pc, #3520]	; 3001c330 <tcp_receive+0xe74>
3001b56c:	e5933000 	ldr	r3, [r3]
3001b570:	e5d3200e 	ldrb	r2, [r3, #14]
3001b574:	e5d3300f 	ldrb	r3, [r3, #15]
3001b578:	e1a03403 	lsl	r3, r3, #8
3001b57c:	e1833002 	orr	r3, r3, r2
3001b580:	e1a03803 	lsl	r3, r3, #16
3001b584:	e1a02823 	lsr	r2, r3, #16
3001b588:	e59d3004 	ldr	r3, [sp, #4]
3001b58c:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
3001b590:	e1520003 	cmp	r2, r3
3001b594:	9a00001c 	bls	3001b60c <tcp_receive+0x150>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
3001b598:	e59f3d90 	ldr	r3, [pc, #3472]	; 3001c330 <tcp_receive+0xe74>
3001b59c:	e5933000 	ldr	r3, [r3]
3001b5a0:	e5d3200e 	ldrb	r2, [r3, #14]
3001b5a4:	e5d3300f 	ldrb	r3, [r3, #15]
3001b5a8:	e1a03403 	lsl	r3, r3, #8
3001b5ac:	e1833002 	orr	r3, r3, r2
3001b5b0:	e1a03803 	lsl	r3, r3, #16
3001b5b4:	e1a02823 	lsr	r2, r3, #16
3001b5b8:	e59d3004 	ldr	r3, [sp, #4]
3001b5bc:	e1c325b8 	strh	r2, [r3, #88]	; 0x58
      pcb->snd_wl1 = seqno;
3001b5c0:	e59f3d80 	ldr	r3, [pc, #3456]	; 3001c348 <tcp_receive+0xe8c>
3001b5c4:	e5932000 	ldr	r2, [r3]
3001b5c8:	e59d3004 	ldr	r3, [sp, #4]
3001b5cc:	e583205c 	str	r2, [r3, #92]	; 0x5c
      pcb->snd_wl2 = ackno;
3001b5d0:	e59f3d54 	ldr	r3, [pc, #3412]	; 3001c32c <tcp_receive+0xe70>
3001b5d4:	e5932000 	ldr	r2, [r3]
3001b5d8:	e59d3004 	ldr	r3, [sp, #4]
3001b5dc:	e5832060 	str	r2, [r3, #96]	; 0x60
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
3001b5e0:	e59d3004 	ldr	r3, [sp, #4]
3001b5e4:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
3001b5e8:	e3530000 	cmp	r3, #0
3001b5ec:	0a000006 	beq	3001b60c <tcp_receive+0x150>
3001b5f0:	e59d3004 	ldr	r3, [sp, #4]
3001b5f4:	e5d330a0 	ldrb	r3, [r3, #160]	; 0xa0
3001b5f8:	e3530000 	cmp	r3, #0
3001b5fc:	0a000002 	beq	3001b60c <tcp_receive+0x150>
          pcb->persist_backoff = 0;
3001b600:	e59d3004 	ldr	r3, [sp, #4]
3001b604:	e3a02000 	mov	r2, #0
3001b608:	e5c320a0 	strb	r2, [r3, #160]	; 0xa0
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
3001b60c:	e59d3004 	ldr	r3, [sp, #4]
3001b610:	e5932044 	ldr	r2, [r3, #68]	; 0x44
3001b614:	e59f3d10 	ldr	r3, [pc, #3344]	; 3001c32c <tcp_receive+0xe70>
3001b618:	e5933000 	ldr	r3, [r3]
3001b61c:	e1520003 	cmp	r2, r3
3001b620:	1a00006d 	bne	3001b7dc <tcp_receive+0x320>
      pcb->acked = 0;
3001b624:	e59d3004 	ldr	r3, [sp, #4]
3001b628:	e3a02000 	mov	r2, #0
3001b62c:	e1c326b8 	strh	r2, [r3, #104]	; 0x68

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
3001b630:	e59d3004 	ldr	r3, [sp, #4]
3001b634:	e593205c 	ldr	r2, [r3, #92]	; 0x5c
3001b638:	e59d3004 	ldr	r3, [sp, #4]
3001b63c:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
3001b640:	e0822003 	add	r2, r2, r3
3001b644:	e59d3020 	ldr	r3, [sp, #32]
3001b648:	e1520003 	cmp	r2, r3
3001b64c:	1a000189 	bne	3001bc78 <tcp_receive+0x7bc>
        ++pcb->dupacks;
3001b650:	e59d3004 	ldr	r3, [sp, #4]
3001b654:	e5d33048 	ldrb	r3, [r3, #72]	; 0x48
3001b658:	e2833001 	add	r3, r3, #1
3001b65c:	e20320ff 	and	r2, r3, #255	; 0xff
3001b660:	e59d3004 	ldr	r3, [sp, #4]
3001b664:	e5c32048 	strb	r2, [r3, #72]	; 0x48
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
3001b668:	e59d3004 	ldr	r3, [sp, #4]
3001b66c:	e5d33048 	ldrb	r3, [r3, #72]	; 0x48
3001b670:	e3530002 	cmp	r3, #2
3001b674:	9a000181 	bls	3001bc80 <tcp_receive+0x7c4>
3001b678:	e59d3004 	ldr	r3, [sp, #4]
3001b67c:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001b680:	e3530000 	cmp	r3, #0
3001b684:	0a00017f 	beq	3001bc88 <tcp_receive+0x7cc>
          if (!(pcb->flags & TF_INFR)) {
3001b688:	e59d3004 	ldr	r3, [sp, #4]
3001b68c:	e5d3301c 	ldrb	r3, [r3, #28]
3001b690:	e2033004 	and	r3, r3, #4
3001b694:	e3530000 	cmp	r3, #0
3001b698:	1a00003a 	bne	3001b788 <tcp_receive+0x2cc>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
3001b69c:	e59d0004 	ldr	r0, [sp, #4]
3001b6a0:	eb000ea1 	bl	3001f12c <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
3001b6a4:	e59d3004 	ldr	r3, [sp, #4]
3001b6a8:	e1d324ba 	ldrh	r2, [r3, #74]	; 0x4a
3001b6ac:	e59d3004 	ldr	r3, [sp, #4]
3001b6b0:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
3001b6b4:	e1520003 	cmp	r2, r3
3001b6b8:	9a000007 	bls	3001b6dc <tcp_receive+0x220>
              pcb->ssthresh = pcb->snd_wnd / 2;
3001b6bc:	e59d3004 	ldr	r3, [sp, #4]
3001b6c0:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
3001b6c4:	e1a030a3 	lsr	r3, r3, #1
3001b6c8:	e1a03803 	lsl	r3, r3, #16
3001b6cc:	e1a02823 	lsr	r2, r3, #16
3001b6d0:	e59d3004 	ldr	r3, [sp, #4]
3001b6d4:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
3001b6d8:	ea000006 	b	3001b6f8 <tcp_receive+0x23c>
            else
              pcb->ssthresh = pcb->cwnd / 2;
3001b6dc:	e59d3004 	ldr	r3, [sp, #4]
3001b6e0:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
3001b6e4:	e1a030a3 	lsr	r3, r3, #1
3001b6e8:	e1a03803 	lsl	r3, r3, #16
3001b6ec:	e1a02823 	lsr	r2, r3, #16
3001b6f0:	e59d3004 	ldr	r3, [sp, #4]
3001b6f4:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
3001b6f8:	e59d3004 	ldr	r3, [sp, #4]
3001b6fc:	e1d334bc 	ldrh	r3, [r3, #76]	; 0x4c
3001b700:	e1a02003 	mov	r2, r3
3001b704:	e59d3004 	ldr	r3, [sp, #4]
3001b708:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001b70c:	e1a03083 	lsl	r3, r3, #1
3001b710:	e1520003 	cmp	r2, r3
3001b714:	aa000006 	bge	3001b734 <tcp_receive+0x278>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
3001b718:	e59d3004 	ldr	r3, [sp, #4]
3001b71c:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001b720:	e1a03083 	lsl	r3, r3, #1
3001b724:	e1a03803 	lsl	r3, r3, #16
3001b728:	e1a02823 	lsr	r2, r3, #16
3001b72c:	e59d3004 	ldr	r3, [sp, #4]
3001b730:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
3001b734:	e59d3004 	ldr	r3, [sp, #4]
3001b738:	e1d324bc 	ldrh	r2, [r3, #76]	; 0x4c
3001b73c:	e59d3004 	ldr	r3, [sp, #4]
3001b740:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001b744:	e1a01003 	mov	r1, r3
3001b748:	e1a01081 	lsl	r1, r1, #1
3001b74c:	e0813003 	add	r3, r1, r3
3001b750:	e1a03803 	lsl	r3, r3, #16
3001b754:	e1a03823 	lsr	r3, r3, #16
3001b758:	e0823003 	add	r3, r2, r3
3001b75c:	e1a03803 	lsl	r3, r3, #16
3001b760:	e1a02823 	lsr	r2, r3, #16
3001b764:	e59d3004 	ldr	r3, [sp, #4]
3001b768:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
            pcb->flags |= TF_INFR;
3001b76c:	e59d3004 	ldr	r3, [sp, #4]
3001b770:	e5d3301c 	ldrb	r3, [r3, #28]
3001b774:	e3833004 	orr	r3, r3, #4
3001b778:	e20320ff 	and	r2, r3, #255	; 0xff
3001b77c:	e59d3004 	ldr	r3, [sp, #4]
3001b780:	e5c3201c 	strb	r2, [r3, #28]
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
3001b784:	ea000142 	b	3001bc94 <tcp_receive+0x7d8>
            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
            pcb->flags |= TF_INFR;
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
3001b788:	e59d3004 	ldr	r3, [sp, #4]
3001b78c:	e1d324ba 	ldrh	r2, [r3, #74]	; 0x4a
3001b790:	e59d3004 	ldr	r3, [sp, #4]
3001b794:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001b798:	e0823003 	add	r3, r2, r3
3001b79c:	e1a03803 	lsl	r3, r3, #16
3001b7a0:	e1a02823 	lsr	r2, r3, #16
3001b7a4:	e59d3004 	ldr	r3, [sp, #4]
3001b7a8:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
3001b7ac:	e1520003 	cmp	r2, r3
3001b7b0:	9a000136 	bls	3001bc90 <tcp_receive+0x7d4>
              pcb->cwnd += pcb->mss;
3001b7b4:	e59d3004 	ldr	r3, [sp, #4]
3001b7b8:	e1d324ba 	ldrh	r2, [r3, #74]	; 0x4a
3001b7bc:	e59d3004 	ldr	r3, [sp, #4]
3001b7c0:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001b7c4:	e0823003 	add	r3, r2, r3
3001b7c8:	e1a03803 	lsl	r3, r3, #16
3001b7cc:	e1a02823 	lsr	r2, r3, #16
3001b7d0:	e59d3004 	ldr	r3, [sp, #4]
3001b7d4:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
3001b7d8:	ea00012d 	b	3001bc94 <tcp_receive+0x7d8>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
3001b7dc:	e59d3004 	ldr	r3, [sp, #4]
3001b7e0:	e5933044 	ldr	r3, [r3, #68]	; 0x44
3001b7e4:	e1e02003 	mvn	r2, r3
3001b7e8:	e59f3b3c 	ldr	r3, [pc, #2876]	; 3001c32c <tcp_receive+0xe70>
3001b7ec:	e5933000 	ldr	r3, [r3]
3001b7f0:	e0823003 	add	r3, r2, r3
3001b7f4:	e3530000 	cmp	r3, #0
3001b7f8:	ba0000ed 	blt	3001bbb4 <tcp_receive+0x6f8>
3001b7fc:	e59f3b28 	ldr	r3, [pc, #2856]	; 3001c32c <tcp_receive+0xe70>
3001b800:	e5932000 	ldr	r2, [r3]
3001b804:	e59d3004 	ldr	r3, [sp, #4]
3001b808:	e5933054 	ldr	r3, [r3, #84]	; 0x54
3001b80c:	e0633002 	rsb	r3, r3, r2
3001b810:	e3530000 	cmp	r3, #0
3001b814:	ca0000e6 	bgt	3001bbb4 <tcp_receive+0x6f8>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
3001b818:	e59d3004 	ldr	r3, [sp, #4]
3001b81c:	e5d3301c 	ldrb	r3, [r3, #28]
3001b820:	e2033004 	and	r3, r3, #4
3001b824:	e3530000 	cmp	r3, #0
3001b828:	0a000008 	beq	3001b850 <tcp_receive+0x394>
        pcb->flags &= ~TF_INFR;
3001b82c:	e59d3004 	ldr	r3, [sp, #4]
3001b830:	e5d3301c 	ldrb	r3, [r3, #28]
3001b834:	e20330fb 	and	r3, r3, #251	; 0xfb
3001b838:	e59d2004 	ldr	r2, [sp, #4]
3001b83c:	e5c2301c 	strb	r3, [r2, #28]
        pcb->cwnd = pcb->ssthresh;
3001b840:	e59d3004 	ldr	r3, [sp, #4]
3001b844:	e1d324bc 	ldrh	r2, [r3, #76]	; 0x4c
3001b848:	e59d3004 	ldr	r3, [sp, #4]
3001b84c:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
3001b850:	e59d3004 	ldr	r3, [sp, #4]
3001b854:	e3a02000 	mov	r2, #0
3001b858:	e5c32042 	strb	r2, [r3, #66]	; 0x42

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
3001b85c:	e59d3004 	ldr	r3, [sp, #4]
3001b860:	e1d333bc 	ldrh	r3, [r3, #60]	; 0x3c
3001b864:	e1a03803 	lsl	r3, r3, #16
3001b868:	e1a03843 	asr	r3, r3, #16
3001b86c:	e1a031c3 	asr	r3, r3, #3
3001b870:	e1a03803 	lsl	r3, r3, #16
3001b874:	e1a03823 	lsr	r3, r3, #16
3001b878:	e1a03803 	lsl	r3, r3, #16
3001b87c:	e1a02823 	lsr	r2, r3, #16
3001b880:	e59d3004 	ldr	r3, [sp, #4]
3001b884:	e1d333be 	ldrh	r3, [r3, #62]	; 0x3e
3001b888:	e1a03803 	lsl	r3, r3, #16
3001b88c:	e1a03823 	lsr	r3, r3, #16
3001b890:	e0823003 	add	r3, r2, r3
3001b894:	e1a03803 	lsl	r3, r3, #16
3001b898:	e1a03823 	lsr	r3, r3, #16
3001b89c:	e1a02003 	mov	r2, r3
3001b8a0:	e59d3004 	ldr	r3, [sp, #4]
3001b8a4:	e1c324b0 	strh	r2, [r3, #64]	; 0x40

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
3001b8a8:	e59f3a7c 	ldr	r3, [pc, #2684]	; 3001c32c <tcp_receive+0xe70>
3001b8ac:	e5933000 	ldr	r3, [r3]
3001b8b0:	e1a03803 	lsl	r3, r3, #16
3001b8b4:	e1a02823 	lsr	r2, r3, #16
3001b8b8:	e59d3004 	ldr	r3, [sp, #4]
3001b8bc:	e5933044 	ldr	r3, [r3, #68]	; 0x44
3001b8c0:	e1a03803 	lsl	r3, r3, #16
3001b8c4:	e1a03823 	lsr	r3, r3, #16
3001b8c8:	e0633002 	rsb	r3, r3, r2
3001b8cc:	e1a03803 	lsl	r3, r3, #16
3001b8d0:	e1a02823 	lsr	r2, r3, #16
3001b8d4:	e59d3004 	ldr	r3, [sp, #4]
3001b8d8:	e1c326b8 	strh	r2, [r3, #104]	; 0x68

      pcb->snd_buf += pcb->acked;
3001b8dc:	e59d3004 	ldr	r3, [sp, #4]
3001b8e0:	e1d326ba 	ldrh	r2, [r3, #106]	; 0x6a
3001b8e4:	e59d3004 	ldr	r3, [sp, #4]
3001b8e8:	e1d336b8 	ldrh	r3, [r3, #104]	; 0x68
3001b8ec:	e0823003 	add	r3, r2, r3
3001b8f0:	e1a03803 	lsl	r3, r3, #16
3001b8f4:	e1a02823 	lsr	r2, r3, #16
3001b8f8:	e59d3004 	ldr	r3, [sp, #4]
3001b8fc:	e1c326ba 	strh	r2, [r3, #106]	; 0x6a

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
3001b900:	e59d3004 	ldr	r3, [sp, #4]
3001b904:	e3a02000 	mov	r2, #0
3001b908:	e5c32048 	strb	r2, [r3, #72]	; 0x48
      pcb->lastack = ackno;
3001b90c:	e59f3a18 	ldr	r3, [pc, #2584]	; 3001c32c <tcp_receive+0xe70>
3001b910:	e5932000 	ldr	r2, [r3]
3001b914:	e59d3004 	ldr	r3, [sp, #4]
3001b918:	e5832044 	str	r2, [r3, #68]	; 0x44

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
3001b91c:	e59d3004 	ldr	r3, [sp, #4]
3001b920:	e5d33010 	ldrb	r3, [r3, #16]
3001b924:	e3530003 	cmp	r3, #3
3001b928:	9a00004b 	bls	3001ba5c <tcp_receive+0x5a0>
        if (pcb->cwnd < pcb->ssthresh) {
3001b92c:	e59d3004 	ldr	r3, [sp, #4]
3001b930:	e1d324ba 	ldrh	r2, [r3, #74]	; 0x4a
3001b934:	e59d3004 	ldr	r3, [sp, #4]
3001b938:	e1d334bc 	ldrh	r3, [r3, #76]	; 0x4c
3001b93c:	e1520003 	cmp	r2, r3
3001b940:	2a000014 	bcs	3001b998 <tcp_receive+0x4dc>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
3001b944:	e59d3004 	ldr	r3, [sp, #4]
3001b948:	e1d324ba 	ldrh	r2, [r3, #74]	; 0x4a
3001b94c:	e59d3004 	ldr	r3, [sp, #4]
3001b950:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001b954:	e0823003 	add	r3, r2, r3
3001b958:	e1a03803 	lsl	r3, r3, #16
3001b95c:	e1a02823 	lsr	r2, r3, #16
3001b960:	e59d3004 	ldr	r3, [sp, #4]
3001b964:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
3001b968:	e1520003 	cmp	r2, r3
3001b96c:	9a00003c 	bls	3001ba64 <tcp_receive+0x5a8>
            pcb->cwnd += pcb->mss;
3001b970:	e59d3004 	ldr	r3, [sp, #4]
3001b974:	e1d324ba 	ldrh	r2, [r3, #74]	; 0x4a
3001b978:	e59d3004 	ldr	r3, [sp, #4]
3001b97c:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001b980:	e0823003 	add	r3, r2, r3
3001b984:	e1a03803 	lsl	r3, r3, #16
3001b988:	e1a02823 	lsr	r2, r3, #16
3001b98c:	e59d3004 	ldr	r3, [sp, #4]
3001b990:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
3001b994:	ea000035 	b	3001ba70 <tcp_receive+0x5b4>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
            pcb->cwnd += pcb->mss;
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
3001b998:	e59d3004 	ldr	r3, [sp, #4]
3001b99c:	e1d344ba 	ldrh	r4, [r3, #74]	; 0x4a
3001b9a0:	e59d3004 	ldr	r3, [sp, #4]
3001b9a4:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
3001b9a8:	e59d2004 	ldr	r2, [sp, #4]
3001b9ac:	e1d223b0 	ldrh	r2, [r2, #48]	; 0x30
3001b9b0:	e0020293 	mul	r2, r3, r2
3001b9b4:	e59d3004 	ldr	r3, [sp, #4]
3001b9b8:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
3001b9bc:	e1a00002 	mov	r0, r2
3001b9c0:	e1a01003 	mov	r1, r3
3001b9c4:	eb00a0fa 	bl	30043db4 <__aeabi_idiv>
3001b9c8:	e1a03000 	mov	r3, r0
3001b9cc:	e1a03803 	lsl	r3, r3, #16
3001b9d0:	e1a03823 	lsr	r3, r3, #16
3001b9d4:	e0843003 	add	r3, r4, r3
3001b9d8:	e1cd32ba 	strh	r3, [sp, #42]	; 0x2a
          if (new_cwnd > pcb->cwnd) {
3001b9dc:	e59d3004 	ldr	r3, [sp, #4]
3001b9e0:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
3001b9e4:	e1dd22ba 	ldrh	r2, [sp, #42]	; 0x2a
3001b9e8:	e1520003 	cmp	r2, r3
3001b9ec:	9a00001e 	bls	3001ba6c <tcp_receive+0x5b0>
            pcb->cwnd = new_cwnd;
3001b9f0:	e59d3004 	ldr	r3, [sp, #4]
3001b9f4:	e1dd22ba 	ldrh	r2, [sp, #42]	; 0x2a
3001b9f8:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
3001b9fc:	ea00001b 	b	3001ba70 <tcp_receive+0x5b4>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
3001ba00:	e59d3004 	ldr	r3, [sp, #4]
3001ba04:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001ba08:	e58d3008 	str	r3, [sp, #8]
        pcb->unacked = pcb->unacked->next;
3001ba0c:	e59d3004 	ldr	r3, [sp, #4]
3001ba10:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001ba14:	e5932000 	ldr	r2, [r3]
3001ba18:	e59d3004 	ldr	r3, [sp, #4]
3001ba1c:	e5832074 	str	r2, [r3, #116]	; 0x74

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
        pcb->snd_queuelen -= pbuf_clen(next->p);
3001ba20:	e59d3004 	ldr	r3, [sp, #4]
3001ba24:	e1d346bc 	ldrh	r4, [r3, #108]	; 0x6c
3001ba28:	e59d3008 	ldr	r3, [sp, #8]
3001ba2c:	e5933004 	ldr	r3, [r3, #4]
3001ba30:	e1a00003 	mov	r0, r3
3001ba34:	ebffea57 	bl	30016398 <pbuf_clen>
3001ba38:	e1a03000 	mov	r3, r0
3001ba3c:	e0633004 	rsb	r3, r3, r4
3001ba40:	e1a03803 	lsl	r3, r3, #16
3001ba44:	e1a02823 	lsr	r2, r3, #16
3001ba48:	e59d3004 	ldr	r3, [sp, #4]
3001ba4c:	e1c326bc 	strh	r2, [r3, #108]	; 0x6c
        tcp_seg_free(next);
3001ba50:	e59d0008 	ldr	r0, [sp, #8]
3001ba54:	ebfff4a4 	bl	30018cec <tcp_seg_free>
3001ba58:	ea000004 	b	3001ba70 <tcp_receive+0x5b4>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
3001ba5c:	e1a00000 	nop			; (mov r0, r0)
3001ba60:	ea000002 	b	3001ba70 <tcp_receive+0x5b4>
3001ba64:	e1a00000 	nop			; (mov r0, r0)
3001ba68:	ea000000 	b	3001ba70 <tcp_receive+0x5b4>
3001ba6c:	e1a00000 	nop			; (mov r0, r0)
3001ba70:	e59d3004 	ldr	r3, [sp, #4]
3001ba74:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001ba78:	e3530000 	cmp	r3, #0
3001ba7c:	0a00003c 	beq	3001bb74 <tcp_receive+0x6b8>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
3001ba80:	e59d3004 	ldr	r3, [sp, #4]
3001ba84:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001ba88:	e5933010 	ldr	r3, [r3, #16]
3001ba8c:	e5d32004 	ldrb	r2, [r3, #4]
3001ba90:	e5d31005 	ldrb	r1, [r3, #5]
3001ba94:	e1a01401 	lsl	r1, r1, #8
3001ba98:	e1812002 	orr	r2, r1, r2
3001ba9c:	e5d31006 	ldrb	r1, [r3, #6]
3001baa0:	e1a01801 	lsl	r1, r1, #16
3001baa4:	e1812002 	orr	r2, r1, r2
3001baa8:	e5d33007 	ldrb	r3, [r3, #7]
3001baac:	e1a03c03 	lsl	r3, r3, #24
3001bab0:	e1833002 	orr	r3, r3, r2
3001bab4:	e1a00003 	mov	r0, r3
3001bab8:	ebffdf01 	bl	300136c4 <ntohl>
3001babc:	e1a04000 	mov	r4, r0
3001bac0:	e59d3004 	ldr	r3, [sp, #4]
3001bac4:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001bac8:	e1d330bc 	ldrh	r3, [r3, #12]
3001bacc:	e1a05003 	mov	r5, r3
3001bad0:	e59d3004 	ldr	r3, [sp, #4]
3001bad4:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001bad8:	e5933010 	ldr	r3, [r3, #16]
3001badc:	e5d3200c 	ldrb	r2, [r3, #12]
3001bae0:	e5d3300d 	ldrb	r3, [r3, #13]
3001bae4:	e1a03403 	lsl	r3, r3, #8
3001bae8:	e1833002 	orr	r3, r3, r2
3001baec:	e1a03803 	lsl	r3, r3, #16
3001baf0:	e1a03823 	lsr	r3, r3, #16
3001baf4:	e1a00003 	mov	r0, r3
3001baf8:	ebffded3 	bl	3001364c <ntohs>
3001bafc:	e1a03000 	mov	r3, r0
3001bb00:	e2033001 	and	r3, r3, #1
3001bb04:	e20330ff 	and	r3, r3, #255	; 0xff
3001bb08:	e3530000 	cmp	r3, #0
3001bb0c:	1a00000e 	bne	3001bb4c <tcp_receive+0x690>
3001bb10:	e59d3004 	ldr	r3, [sp, #4]
3001bb14:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001bb18:	e5933010 	ldr	r3, [r3, #16]
3001bb1c:	e5d3200c 	ldrb	r2, [r3, #12]
3001bb20:	e5d3300d 	ldrb	r3, [r3, #13]
3001bb24:	e1a03403 	lsl	r3, r3, #8
3001bb28:	e1833002 	orr	r3, r3, r2
3001bb2c:	e1a03803 	lsl	r3, r3, #16
3001bb30:	e1a03823 	lsr	r3, r3, #16
3001bb34:	e1a00003 	mov	r0, r3
3001bb38:	ebffdec3 	bl	3001364c <ntohs>
3001bb3c:	e1a03000 	mov	r3, r0
3001bb40:	e2033002 	and	r3, r3, #2
3001bb44:	e3530000 	cmp	r3, #0
3001bb48:	0a000001 	beq	3001bb54 <tcp_receive+0x698>
3001bb4c:	e3a03001 	mov	r3, #1
3001bb50:	ea000000 	b	3001bb58 <tcp_receive+0x69c>
3001bb54:	e3a03000 	mov	r3, #0
3001bb58:	e0853003 	add	r3, r5, r3
3001bb5c:	e0842003 	add	r2, r4, r3
3001bb60:	e59f37c4 	ldr	r3, [pc, #1988]	; 3001c32c <tcp_receive+0xe70>
3001bb64:	e5933000 	ldr	r3, [r3]
3001bb68:	e0633002 	rsb	r3, r3, r2
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
3001bb6c:	e3530000 	cmp	r3, #0
3001bb70:	daffffa2 	ble	3001ba00 <tcp_receive+0x544>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
3001bb74:	e59d3004 	ldr	r3, [sp, #4]
3001bb78:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001bb7c:	e3530000 	cmp	r3, #0
3001bb80:	1a000003 	bne	3001bb94 <tcp_receive+0x6d8>
        pcb->rtime = -1;
3001bb84:	e59d3004 	ldr	r3, [sp, #4]
3001bb88:	e3e02000 	mvn	r2, #0
3001bb8c:	e1c322be 	strh	r2, [r3, #46]	; 0x2e
3001bb90:	ea000002 	b	3001bba0 <tcp_receive+0x6e4>
      else
        pcb->rtime = 0;
3001bb94:	e59d3004 	ldr	r3, [sp, #4]
3001bb98:	e3a02000 	mov	r2, #0
3001bb9c:	e1c322be 	strh	r2, [r3, #46]	; 0x2e

      pcb->polltmr = 0;
3001bba0:	e59d3004 	ldr	r3, [sp, #4]
3001bba4:	e3a02000 	mov	r2, #0
3001bba8:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
3001bbac:	e1a00000 	nop			; (mov r0, r0)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
3001bbb0:	ea000037 	b	3001bc94 <tcp_receive+0x7d8>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
3001bbb4:	e59d3004 	ldr	r3, [sp, #4]
3001bbb8:	e3a02000 	mov	r2, #0
3001bbbc:	e1c326b8 	strh	r2, [r3, #104]	; 0x68
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
3001bbc0:	ea000033 	b	3001bc94 <tcp_receive+0x7d8>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
3001bbc4:	e59d3004 	ldr	r3, [sp, #4]
3001bbc8:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001bbcc:	e58d3008 	str	r3, [sp, #8]
      pcb->unsent = pcb->unsent->next;
3001bbd0:	e59d3004 	ldr	r3, [sp, #4]
3001bbd4:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001bbd8:	e5932000 	ldr	r2, [r3]
3001bbdc:	e59d3004 	ldr	r3, [sp, #4]
3001bbe0:	e5832070 	str	r2, [r3, #112]	; 0x70
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
      pcb->snd_queuelen -= pbuf_clen(next->p);
3001bbe4:	e59d3004 	ldr	r3, [sp, #4]
3001bbe8:	e1d346bc 	ldrh	r4, [r3, #108]	; 0x6c
3001bbec:	e59d3008 	ldr	r3, [sp, #8]
3001bbf0:	e5933004 	ldr	r3, [r3, #4]
3001bbf4:	e1a00003 	mov	r0, r3
3001bbf8:	ebffe9e6 	bl	30016398 <pbuf_clen>
3001bbfc:	e1a03000 	mov	r3, r0
3001bc00:	e0633004 	rsb	r3, r3, r4
3001bc04:	e1a03803 	lsl	r3, r3, #16
3001bc08:	e1a02823 	lsr	r2, r3, #16
3001bc0c:	e59d3004 	ldr	r3, [sp, #4]
3001bc10:	e1c326bc 	strh	r2, [r3, #108]	; 0x6c
      tcp_seg_free(next);
3001bc14:	e59d0008 	ldr	r0, [sp, #8]
3001bc18:	ebfff433 	bl	30018cec <tcp_seg_free>
      if (pcb->snd_queuelen != 0) {
        LWIP_ASSERT("tcp_receive: valid queue length",
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
3001bc1c:	e59d3004 	ldr	r3, [sp, #4]
3001bc20:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001bc24:	e3530000 	cmp	r3, #0
3001bc28:	0a000019 	beq	3001bc94 <tcp_receive+0x7d8>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
3001bc2c:	e59d3004 	ldr	r3, [sp, #4]
3001bc30:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001bc34:	e5933010 	ldr	r3, [r3, #16]
3001bc38:	e5d32004 	ldrb	r2, [r3, #4]
3001bc3c:	e5d31005 	ldrb	r1, [r3, #5]
3001bc40:	e1a01401 	lsl	r1, r1, #8
3001bc44:	e1812002 	orr	r2, r1, r2
3001bc48:	e5d31006 	ldrb	r1, [r3, #6]
3001bc4c:	e1a01801 	lsl	r1, r1, #16
3001bc50:	e1812002 	orr	r2, r1, r2
3001bc54:	e5d33007 	ldrb	r3, [r3, #7]
3001bc58:	e1a03c03 	lsl	r3, r3, #24
3001bc5c:	e1833002 	orr	r3, r3, r2
3001bc60:	e1a00003 	mov	r0, r3
3001bc64:	ebffde84 	bl	3001367c <htonl>
3001bc68:	e1a02000 	mov	r2, r0
3001bc6c:	e59d3004 	ldr	r3, [sp, #4]
3001bc70:	e5832050 	str	r2, [r3, #80]	; 0x50
3001bc74:	ea000006 	b	3001bc94 <tcp_receive+0x7d8>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
3001bc78:	e1a00000 	nop			; (mov r0, r0)
3001bc7c:	ea000004 	b	3001bc94 <tcp_receive+0x7d8>
3001bc80:	e1a00000 	nop			; (mov r0, r0)
3001bc84:	ea000002 	b	3001bc94 <tcp_receive+0x7d8>
3001bc88:	e1a00000 	nop			; (mov r0, r0)
3001bc8c:	ea000000 	b	3001bc94 <tcp_receive+0x7d8>
3001bc90:	e1a00000 	nop			; (mov r0, r0)
3001bc94:	e59d3004 	ldr	r3, [sp, #4]
3001bc98:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001bc9c:	e3530000 	cmp	r3, #0
3001bca0:	0a000043 	beq	3001bdb4 <tcp_receive+0x8f8>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
3001bca4:	e59f3680 	ldr	r3, [pc, #1664]	; 3001c32c <tcp_receive+0xe70>
3001bca8:	e5934000 	ldr	r4, [r3]
3001bcac:	e59d3004 	ldr	r3, [sp, #4]
3001bcb0:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001bcb4:	e5933010 	ldr	r3, [r3, #16]
3001bcb8:	e5d32004 	ldrb	r2, [r3, #4]
3001bcbc:	e5d31005 	ldrb	r1, [r3, #5]
3001bcc0:	e1a01401 	lsl	r1, r1, #8
3001bcc4:	e1812002 	orr	r2, r1, r2
3001bcc8:	e5d31006 	ldrb	r1, [r3, #6]
3001bccc:	e1a01801 	lsl	r1, r1, #16
3001bcd0:	e1812002 	orr	r2, r1, r2
3001bcd4:	e5d33007 	ldrb	r3, [r3, #7]
3001bcd8:	e1a03c03 	lsl	r3, r3, #24
3001bcdc:	e1833002 	orr	r3, r3, r2
3001bce0:	e1a00003 	mov	r0, r3
3001bce4:	ebffde76 	bl	300136c4 <ntohl>
3001bce8:	e1a05000 	mov	r5, r0
3001bcec:	e59d3004 	ldr	r3, [sp, #4]
3001bcf0:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001bcf4:	e1d330bc 	ldrh	r3, [r3, #12]
3001bcf8:	e1a06003 	mov	r6, r3
3001bcfc:	e59d3004 	ldr	r3, [sp, #4]
3001bd00:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001bd04:	e5933010 	ldr	r3, [r3, #16]
3001bd08:	e5d3200c 	ldrb	r2, [r3, #12]
3001bd0c:	e5d3300d 	ldrb	r3, [r3, #13]
3001bd10:	e1a03403 	lsl	r3, r3, #8
3001bd14:	e1833002 	orr	r3, r3, r2
3001bd18:	e1a03803 	lsl	r3, r3, #16
3001bd1c:	e1a03823 	lsr	r3, r3, #16
3001bd20:	e1a00003 	mov	r0, r3
3001bd24:	ebffde48 	bl	3001364c <ntohs>
3001bd28:	e1a03000 	mov	r3, r0
3001bd2c:	e2033001 	and	r3, r3, #1
3001bd30:	e20330ff 	and	r3, r3, #255	; 0xff
3001bd34:	e3530000 	cmp	r3, #0
3001bd38:	1a00000e 	bne	3001bd78 <tcp_receive+0x8bc>
3001bd3c:	e59d3004 	ldr	r3, [sp, #4]
3001bd40:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001bd44:	e5933010 	ldr	r3, [r3, #16]
3001bd48:	e5d3200c 	ldrb	r2, [r3, #12]
3001bd4c:	e5d3300d 	ldrb	r3, [r3, #13]
3001bd50:	e1a03403 	lsl	r3, r3, #8
3001bd54:	e1833002 	orr	r3, r3, r2
3001bd58:	e1a03803 	lsl	r3, r3, #16
3001bd5c:	e1a03823 	lsr	r3, r3, #16
3001bd60:	e1a00003 	mov	r0, r3
3001bd64:	ebffde38 	bl	3001364c <ntohs>
3001bd68:	e1a03000 	mov	r3, r0
3001bd6c:	e2033002 	and	r3, r3, #2
3001bd70:	e3530000 	cmp	r3, #0
3001bd74:	0a000001 	beq	3001bd80 <tcp_receive+0x8c4>
3001bd78:	e3a03001 	mov	r3, #1
3001bd7c:	ea000000 	b	3001bd84 <tcp_receive+0x8c8>
3001bd80:	e3a03000 	mov	r3, #0
3001bd84:	e0863003 	add	r3, r6, r3
3001bd88:	e0853003 	add	r3, r5, r3
3001bd8c:	e0633004 	rsb	r3, r3, r4
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
3001bd90:	e3530000 	cmp	r3, #0
3001bd94:	ba000006 	blt	3001bdb4 <tcp_receive+0x8f8>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
3001bd98:	e59f358c 	ldr	r3, [pc, #1420]	; 3001c32c <tcp_receive+0xe70>
3001bd9c:	e5932000 	ldr	r2, [r3]
3001bda0:	e59d3004 	ldr	r3, [sp, #4]
3001bda4:	e5933054 	ldr	r3, [r3, #84]	; 0x54
3001bda8:	e0633002 	rsb	r3, r3, r2
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
3001bdac:	e3530000 	cmp	r3, #0
3001bdb0:	daffff83 	ble	3001bbc4 <tcp_receive+0x708>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
3001bdb4:	e59d3004 	ldr	r3, [sp, #4]
3001bdb8:	e5933034 	ldr	r3, [r3, #52]	; 0x34
3001bdbc:	e3530000 	cmp	r3, #0
3001bdc0:	0a000060 	beq	3001bf48 <tcp_receive+0xa8c>
3001bdc4:	e59d3004 	ldr	r3, [sp, #4]
3001bdc8:	e5932038 	ldr	r2, [r3, #56]	; 0x38
3001bdcc:	e59f3558 	ldr	r3, [pc, #1368]	; 3001c32c <tcp_receive+0xe70>
3001bdd0:	e5933000 	ldr	r3, [r3]
3001bdd4:	e0633002 	rsb	r3, r3, r2
3001bdd8:	e3530000 	cmp	r3, #0
3001bddc:	aa000059 	bge	3001bf48 <tcp_receive+0xa8c>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
3001bde0:	e59f354c 	ldr	r3, [pc, #1356]	; 3001c334 <tcp_receive+0xe78>
3001bde4:	e5933000 	ldr	r3, [r3]
3001bde8:	e1a03803 	lsl	r3, r3, #16
3001bdec:	e1a02823 	lsr	r2, r3, #16
3001bdf0:	e59d3004 	ldr	r3, [sp, #4]
3001bdf4:	e5933034 	ldr	r3, [r3, #52]	; 0x34
3001bdf8:	e1a03803 	lsl	r3, r3, #16
3001bdfc:	e1a03823 	lsr	r3, r3, #16
3001be00:	e0633002 	rsb	r3, r3, r2
3001be04:	e1a03803 	lsl	r3, r3, #16
3001be08:	e1a03823 	lsr	r3, r3, #16
3001be0c:	e1cd31be 	strh	r3, [sp, #30]

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
3001be10:	e1dd21be 	ldrh	r2, [sp, #30]
3001be14:	e59d3004 	ldr	r3, [sp, #4]
3001be18:	e1d333bc 	ldrh	r3, [r3, #60]	; 0x3c
3001be1c:	e1a03803 	lsl	r3, r3, #16
3001be20:	e1a03843 	asr	r3, r3, #16
3001be24:	e1a031c3 	asr	r3, r3, #3
3001be28:	e1a03803 	lsl	r3, r3, #16
3001be2c:	e1a03823 	lsr	r3, r3, #16
3001be30:	e1a03803 	lsl	r3, r3, #16
3001be34:	e1a03823 	lsr	r3, r3, #16
3001be38:	e0633002 	rsb	r3, r3, r2
3001be3c:	e1a03803 	lsl	r3, r3, #16
3001be40:	e1a03823 	lsr	r3, r3, #16
3001be44:	e1cd31be 	strh	r3, [sp, #30]
      pcb->sa += m;
3001be48:	e59d3004 	ldr	r3, [sp, #4]
3001be4c:	e1d333bc 	ldrh	r3, [r3, #60]	; 0x3c
3001be50:	e1a03803 	lsl	r3, r3, #16
3001be54:	e1a02823 	lsr	r2, r3, #16
3001be58:	e1dd31be 	ldrh	r3, [sp, #30]
3001be5c:	e0823003 	add	r3, r2, r3
3001be60:	e1a03803 	lsl	r3, r3, #16
3001be64:	e1a03823 	lsr	r3, r3, #16
3001be68:	e1a02003 	mov	r2, r3
3001be6c:	e59d3004 	ldr	r3, [sp, #4]
3001be70:	e1c323bc 	strh	r2, [r3, #60]	; 0x3c
      if (m < 0) {
3001be74:	e1dd31fe 	ldrsh	r3, [sp, #30]
3001be78:	e3530000 	cmp	r3, #0
3001be7c:	aa000002 	bge	3001be8c <tcp_receive+0x9d0>
        m = -m;
3001be80:	e1dd31be 	ldrh	r3, [sp, #30]
3001be84:	e2633000 	rsb	r3, r3, #0
3001be88:	e1cd31be 	strh	r3, [sp, #30]
      }
      m = m - (pcb->sv >> 2);
3001be8c:	e1dd21be 	ldrh	r2, [sp, #30]
3001be90:	e59d3004 	ldr	r3, [sp, #4]
3001be94:	e1d333be 	ldrh	r3, [r3, #62]	; 0x3e
3001be98:	e1a03803 	lsl	r3, r3, #16
3001be9c:	e1a03843 	asr	r3, r3, #16
3001bea0:	e1a03143 	asr	r3, r3, #2
3001bea4:	e1a03803 	lsl	r3, r3, #16
3001bea8:	e1a03823 	lsr	r3, r3, #16
3001beac:	e1a03803 	lsl	r3, r3, #16
3001beb0:	e1a03823 	lsr	r3, r3, #16
3001beb4:	e0633002 	rsb	r3, r3, r2
3001beb8:	e1a03803 	lsl	r3, r3, #16
3001bebc:	e1a03823 	lsr	r3, r3, #16
3001bec0:	e1cd31be 	strh	r3, [sp, #30]
      pcb->sv += m;
3001bec4:	e59d3004 	ldr	r3, [sp, #4]
3001bec8:	e1d333be 	ldrh	r3, [r3, #62]	; 0x3e
3001becc:	e1a03803 	lsl	r3, r3, #16
3001bed0:	e1a02823 	lsr	r2, r3, #16
3001bed4:	e1dd31be 	ldrh	r3, [sp, #30]
3001bed8:	e0823003 	add	r3, r2, r3
3001bedc:	e1a03803 	lsl	r3, r3, #16
3001bee0:	e1a03823 	lsr	r3, r3, #16
3001bee4:	e1a02003 	mov	r2, r3
3001bee8:	e59d3004 	ldr	r3, [sp, #4]
3001beec:	e1c323be 	strh	r2, [r3, #62]	; 0x3e
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
3001bef0:	e59d3004 	ldr	r3, [sp, #4]
3001bef4:	e1d333bc 	ldrh	r3, [r3, #60]	; 0x3c
3001bef8:	e1a03803 	lsl	r3, r3, #16
3001befc:	e1a03843 	asr	r3, r3, #16
3001bf00:	e1a031c3 	asr	r3, r3, #3
3001bf04:	e1a03803 	lsl	r3, r3, #16
3001bf08:	e1a03823 	lsr	r3, r3, #16
3001bf0c:	e1a03803 	lsl	r3, r3, #16
3001bf10:	e1a02823 	lsr	r2, r3, #16
3001bf14:	e59d3004 	ldr	r3, [sp, #4]
3001bf18:	e1d333be 	ldrh	r3, [r3, #62]	; 0x3e
3001bf1c:	e1a03803 	lsl	r3, r3, #16
3001bf20:	e1a03823 	lsr	r3, r3, #16
3001bf24:	e0823003 	add	r3, r2, r3
3001bf28:	e1a03803 	lsl	r3, r3, #16
3001bf2c:	e1a03823 	lsr	r3, r3, #16
3001bf30:	e1a02003 	mov	r2, r3
3001bf34:	e59d3004 	ldr	r3, [sp, #4]
3001bf38:	e1c324b0 	strh	r2, [r3, #64]	; 0x40

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
3001bf3c:	e59d3004 	ldr	r3, [sp, #4]
3001bf40:	e3a02000 	mov	r2, #0
3001bf44:	e5832034 	str	r2, [r3, #52]	; 0x34
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
3001bf48:	e59f33e8 	ldr	r3, [pc, #1000]	; 3001c338 <tcp_receive+0xe7c>
3001bf4c:	e1d330b0 	ldrh	r3, [r3]
3001bf50:	e3530000 	cmp	r3, #0
3001bf54:	0a0004ee 	beq	3001d314 <tcp_receive+0x1e58>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
3001bf58:	e59d3004 	ldr	r3, [sp, #4]
3001bf5c:	e5932020 	ldr	r2, [r3, #32]
3001bf60:	e59f33e0 	ldr	r3, [pc, #992]	; 3001c348 <tcp_receive+0xe8c>
3001bf64:	e5933000 	ldr	r3, [r3]
3001bf68:	e1e03003 	mvn	r3, r3
3001bf6c:	e0823003 	add	r3, r2, r3
3001bf70:	e3530000 	cmp	r3, #0
3001bf74:	ba000082 	blt	3001c184 <tcp_receive+0xcc8>
3001bf78:	e59d3004 	ldr	r3, [sp, #4]
3001bf7c:	e5932020 	ldr	r2, [r3, #32]
3001bf80:	e59f33b0 	ldr	r3, [pc, #944]	; 3001c338 <tcp_receive+0xe7c>
3001bf84:	e1d330b0 	ldrh	r3, [r3]
3001bf88:	e1a01003 	mov	r1, r3
3001bf8c:	e59f33b4 	ldr	r3, [pc, #948]	; 3001c348 <tcp_receive+0xe8c>
3001bf90:	e5933000 	ldr	r3, [r3]
3001bf94:	e0813003 	add	r3, r1, r3
3001bf98:	e0633002 	rsb	r3, r3, r2
3001bf9c:	e2833001 	add	r3, r3, #1
3001bfa0:	e3530000 	cmp	r3, #0
3001bfa4:	ca000076 	bgt	3001c184 <tcp_receive+0xcc8>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
3001bfa8:	e59d3004 	ldr	r3, [sp, #4]
3001bfac:	e5932020 	ldr	r2, [r3, #32]
3001bfb0:	e59f3390 	ldr	r3, [pc, #912]	; 3001c348 <tcp_receive+0xe8c>
3001bfb4:	e5933000 	ldr	r3, [r3]
3001bfb8:	e0633002 	rsb	r3, r3, r2
3001bfbc:	e58d3018 	str	r3, [sp, #24]
      p = inseg.p;
3001bfc0:	e59f337c 	ldr	r3, [pc, #892]	; 3001c344 <tcp_receive+0xe88>
3001bfc4:	e5933004 	ldr	r3, [r3, #4]
3001bfc8:	e58d3014 	str	r3, [sp, #20]
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
3001bfcc:	e59f3370 	ldr	r3, [pc, #880]	; 3001c344 <tcp_receive+0xe88>
3001bfd0:	e5933004 	ldr	r3, [r3, #4]
3001bfd4:	e1d330ba 	ldrh	r3, [r3, #10]
3001bfd8:	e1a02003 	mov	r2, r3
3001bfdc:	e59d3018 	ldr	r3, [sp, #24]
3001bfe0:	e1520003 	cmp	r2, r3
3001bfe4:	aa000028 	bge	3001c08c <tcp_receive+0xbd0>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
3001bfe8:	e59f3354 	ldr	r3, [pc, #852]	; 3001c344 <tcp_receive+0xe88>
3001bfec:	e5933004 	ldr	r3, [r3, #4]
3001bff0:	e1d320b8 	ldrh	r2, [r3, #8]
3001bff4:	e59d3018 	ldr	r3, [sp, #24]
3001bff8:	e1a03803 	lsl	r3, r3, #16
3001bffc:	e1a03823 	lsr	r3, r3, #16
3001c000:	e0633002 	rsb	r3, r3, r2
3001c004:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
        while (p->len < off) {
3001c008:	ea00000d 	b	3001c044 <tcp_receive+0xb88>
          off -= p->len;
3001c00c:	e59d3014 	ldr	r3, [sp, #20]
3001c010:	e1d330ba 	ldrh	r3, [r3, #10]
3001c014:	e59d2018 	ldr	r2, [sp, #24]
3001c018:	e0633002 	rsb	r3, r3, r2
3001c01c:	e58d3018 	str	r3, [sp, #24]
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
3001c020:	e59d3014 	ldr	r3, [sp, #20]
3001c024:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
3001c028:	e1c320b8 	strh	r2, [r3, #8]
          p->len = 0;
3001c02c:	e59d3014 	ldr	r3, [sp, #20]
3001c030:	e3a02000 	mov	r2, #0
3001c034:	e1c320ba 	strh	r2, [r3, #10]
          p = p->next;
3001c038:	e59d3014 	ldr	r3, [sp, #20]
3001c03c:	e5933000 	ldr	r3, [r3]
3001c040:	e58d3014 	str	r3, [sp, #20]
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
3001c044:	e59d3014 	ldr	r3, [sp, #20]
3001c048:	e1d330ba 	ldrh	r3, [r3, #10]
3001c04c:	e1a02003 	mov	r2, r3
3001c050:	e59d3018 	ldr	r3, [sp, #24]
3001c054:	e1520003 	cmp	r2, r3
3001c058:	baffffeb 	blt	3001c00c <tcp_receive+0xb50>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
3001c05c:	e59d3018 	ldr	r3, [sp, #24]
3001c060:	e1a03803 	lsl	r3, r3, #16
3001c064:	e1a03823 	lsr	r3, r3, #16
3001c068:	e2633000 	rsb	r3, r3, #0
3001c06c:	e1a03803 	lsl	r3, r3, #16
3001c070:	e1a03823 	lsr	r3, r3, #16
3001c074:	e1a03803 	lsl	r3, r3, #16
3001c078:	e1a03843 	asr	r3, r3, #16
3001c07c:	e59d0014 	ldr	r0, [sp, #20]
3001c080:	e1a01003 	mov	r1, r3
3001c084:	ebffe818 	bl	300160ec <pbuf_header>
3001c088:	ea00000c 	b	3001c0c0 <tcp_receive+0xc04>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
3001c08c:	e59f32b0 	ldr	r3, [pc, #688]	; 3001c344 <tcp_receive+0xe88>
3001c090:	e5932004 	ldr	r2, [r3, #4]
3001c094:	e59d3018 	ldr	r3, [sp, #24]
3001c098:	e1a03803 	lsl	r3, r3, #16
3001c09c:	e1a03823 	lsr	r3, r3, #16
3001c0a0:	e2633000 	rsb	r3, r3, #0
3001c0a4:	e1a03803 	lsl	r3, r3, #16
3001c0a8:	e1a03823 	lsr	r3, r3, #16
3001c0ac:	e1a03803 	lsl	r3, r3, #16
3001c0b0:	e1a03843 	asr	r3, r3, #16
3001c0b4:	e1a00002 	mov	r0, r2
3001c0b8:	e1a01003 	mov	r1, r3
3001c0bc:	ebffe80a 	bl	300160ec <pbuf_header>
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
3001c0c0:	e59d3014 	ldr	r3, [sp, #20]
3001c0c4:	e5932004 	ldr	r2, [r3, #4]
3001c0c8:	e59f3274 	ldr	r3, [pc, #628]	; 3001c344 <tcp_receive+0xe88>
3001c0cc:	e5832008 	str	r2, [r3, #8]
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
3001c0d0:	e59f326c 	ldr	r3, [pc, #620]	; 3001c344 <tcp_receive+0xe88>
3001c0d4:	e1d320bc 	ldrh	r2, [r3, #12]
3001c0d8:	e59f3268 	ldr	r3, [pc, #616]	; 3001c348 <tcp_receive+0xe8c>
3001c0dc:	e5933000 	ldr	r3, [r3]
3001c0e0:	e1a03803 	lsl	r3, r3, #16
3001c0e4:	e1a01823 	lsr	r1, r3, #16
3001c0e8:	e59d3004 	ldr	r3, [sp, #4]
3001c0ec:	e5933020 	ldr	r3, [r3, #32]
3001c0f0:	e1a03803 	lsl	r3, r3, #16
3001c0f4:	e1a03823 	lsr	r3, r3, #16
3001c0f8:	e0633001 	rsb	r3, r3, r1
3001c0fc:	e1a03803 	lsl	r3, r3, #16
3001c100:	e1a03823 	lsr	r3, r3, #16
3001c104:	e0823003 	add	r3, r2, r3
3001c108:	e1a03803 	lsl	r3, r3, #16
3001c10c:	e1a02823 	lsr	r2, r3, #16
3001c110:	e59f322c 	ldr	r3, [pc, #556]	; 3001c344 <tcp_receive+0xe88>
3001c114:	e1c320bc 	strh	r2, [r3, #12]
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
3001c118:	e59f3224 	ldr	r3, [pc, #548]	; 3001c344 <tcp_receive+0xe88>
3001c11c:	e5933010 	ldr	r3, [r3, #16]
3001c120:	e59d2004 	ldr	r2, [sp, #4]
3001c124:	e5921020 	ldr	r1, [r2, #32]
3001c128:	e59f2218 	ldr	r2, [pc, #536]	; 3001c348 <tcp_receive+0xe8c>
3001c12c:	e5821000 	str	r1, [r2]
3001c130:	e59f2210 	ldr	r2, [pc, #528]	; 3001c348 <tcp_receive+0xe8c>
3001c134:	e5922000 	ldr	r2, [r2]
3001c138:	e20210ff 	and	r1, r2, #255	; 0xff
3001c13c:	e3a00000 	mov	r0, #0
3001c140:	e1801001 	orr	r1, r0, r1
3001c144:	e5c31004 	strb	r1, [r3, #4]
3001c148:	e1a01422 	lsr	r1, r2, #8
3001c14c:	e20110ff 	and	r1, r1, #255	; 0xff
3001c150:	e3a00000 	mov	r0, #0
3001c154:	e1801001 	orr	r1, r0, r1
3001c158:	e5c31005 	strb	r1, [r3, #5]
3001c15c:	e1a01822 	lsr	r1, r2, #16
3001c160:	e20110ff 	and	r1, r1, #255	; 0xff
3001c164:	e3a00000 	mov	r0, #0
3001c168:	e1801001 	orr	r1, r0, r1
3001c16c:	e5c31006 	strb	r1, [r3, #6]
3001c170:	e1a02c22 	lsr	r2, r2, #24
3001c174:	e3a01000 	mov	r1, #0
3001c178:	e1812002 	orr	r2, r1, r2
3001c17c:	e5c32007 	strb	r2, [r3, #7]
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
3001c180:	ea00000e 	b	3001c1c0 <tcp_receive+0xd04>
      inseg.dataptr = p->payload;
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
3001c184:	e59f31bc 	ldr	r3, [pc, #444]	; 3001c348 <tcp_receive+0xe8c>
3001c188:	e5932000 	ldr	r2, [r3]
3001c18c:	e59d3004 	ldr	r3, [sp, #4]
3001c190:	e5933020 	ldr	r3, [r3, #32]
3001c194:	e0633002 	rsb	r3, r3, r2
3001c198:	e3530000 	cmp	r3, #0
3001c19c:	aa000007 	bge	3001c1c0 <tcp_receive+0xd04>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
3001c1a0:	e59d3004 	ldr	r3, [sp, #4]
3001c1a4:	e5d3301c 	ldrb	r3, [r3, #28]
3001c1a8:	e3833002 	orr	r3, r3, #2
3001c1ac:	e20320ff 	and	r2, r3, #255	; 0xff
3001c1b0:	e59d3004 	ldr	r3, [sp, #4]
3001c1b4:	e5c3201c 	strb	r2, [r3, #28]
3001c1b8:	e59d0004 	ldr	r0, [sp, #4]
3001c1bc:	eb000784 	bl	3001dfd4 <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
3001c1c0:	e59f3180 	ldr	r3, [pc, #384]	; 3001c348 <tcp_receive+0xe8c>
3001c1c4:	e5932000 	ldr	r2, [r3]
3001c1c8:	e59d3004 	ldr	r3, [sp, #4]
3001c1cc:	e5933020 	ldr	r3, [r3, #32]
3001c1d0:	e0633002 	rsb	r3, r3, r2
3001c1d4:	e3530000 	cmp	r3, #0
3001c1d8:	ba000432 	blt	3001d2a8 <tcp_receive+0x1dec>
3001c1dc:	e59f3164 	ldr	r3, [pc, #356]	; 3001c348 <tcp_receive+0xe8c>
3001c1e0:	e5932000 	ldr	r2, [r3]
3001c1e4:	e59d3004 	ldr	r3, [sp, #4]
3001c1e8:	e5931020 	ldr	r1, [r3, #32]
3001c1ec:	e59d3004 	ldr	r3, [sp, #4]
3001c1f0:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
3001c1f4:	e0813003 	add	r3, r1, r3
3001c1f8:	e0633002 	rsb	r3, r3, r2
3001c1fc:	e2833001 	add	r3, r3, #1
3001c200:	e3530000 	cmp	r3, #0
3001c204:	ca000427 	bgt	3001d2a8 <tcp_receive+0x1dec>
                        pcb->rcv_nxt + pcb->rcv_ann_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
3001c208:	e59d3004 	ldr	r3, [sp, #4]
3001c20c:	e5932020 	ldr	r2, [r3, #32]
3001c210:	e59f3130 	ldr	r3, [pc, #304]	; 3001c348 <tcp_receive+0xe8c>
3001c214:	e5933000 	ldr	r3, [r3]
3001c218:	e1520003 	cmp	r2, r3
3001c21c:	1a000246 	bne	3001cb3c <tcp_receive+0x1680>
        accepted_inseq = 1; 
3001c220:	e3a03001 	mov	r3, #1
3001c224:	e5cd3029 	strb	r3, [sp, #41]	; 0x29
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
3001c228:	e59d3004 	ldr	r3, [sp, #4]
3001c22c:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c230:	e3530000 	cmp	r3, #0
3001c234:	0a00006b 	beq	3001c3e8 <tcp_receive+0xf2c>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
3001c238:	e59d3004 	ldr	r3, [sp, #4]
3001c23c:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c240:	e5933010 	ldr	r3, [r3, #16]
3001c244:	e5d32004 	ldrb	r2, [r3, #4]
3001c248:	e5d31005 	ldrb	r1, [r3, #5]
3001c24c:	e1a01401 	lsl	r1, r1, #8
3001c250:	e1812002 	orr	r2, r1, r2
3001c254:	e5d31006 	ldrb	r1, [r3, #6]
3001c258:	e1a01801 	lsl	r1, r1, #16
3001c25c:	e1812002 	orr	r2, r1, r2
3001c260:	e5d33007 	ldrb	r3, [r3, #7]
3001c264:	e1a03c03 	lsl	r3, r3, #24
3001c268:	e1833002 	orr	r3, r3, r2
3001c26c:	e1a02003 	mov	r2, r3
3001c270:	e59f30cc 	ldr	r3, [pc, #204]	; 3001c344 <tcp_receive+0xe88>
3001c274:	e1d330bc 	ldrh	r3, [r3, #12]
3001c278:	e1a01003 	mov	r1, r3
3001c27c:	e59f30c4 	ldr	r3, [pc, #196]	; 3001c348 <tcp_receive+0xe8c>
3001c280:	e5933000 	ldr	r3, [r3]
3001c284:	e0813003 	add	r3, r1, r3
3001c288:	e0633002 	rsb	r3, r3, r2
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
3001c28c:	e3530000 	cmp	r3, #0
3001c290:	ca000054 	bgt	3001c3e8 <tcp_receive+0xf2c>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
3001c294:	e59d3004 	ldr	r3, [sp, #4]
3001c298:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c29c:	e1d330bc 	ldrh	r3, [r3, #12]
3001c2a0:	e3530000 	cmp	r3, #0
3001c2a4:	0a000028 	beq	3001c34c <tcp_receive+0xe90>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
3001c2a8:	e59d3004 	ldr	r3, [sp, #4]
3001c2ac:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c2b0:	e5933010 	ldr	r3, [r3, #16]
3001c2b4:	e5d32004 	ldrb	r2, [r3, #4]
3001c2b8:	e5d31005 	ldrb	r1, [r3, #5]
3001c2bc:	e1a01401 	lsl	r1, r1, #8
3001c2c0:	e1812002 	orr	r2, r1, r2
3001c2c4:	e5d31006 	ldrb	r1, [r3, #6]
3001c2c8:	e1a01801 	lsl	r1, r1, #16
3001c2cc:	e1812002 	orr	r2, r1, r2
3001c2d0:	e5d33007 	ldrb	r3, [r3, #7]
3001c2d4:	e1a03c03 	lsl	r3, r3, #24
3001c2d8:	e1833002 	orr	r3, r3, r2
3001c2dc:	e1a03803 	lsl	r3, r3, #16
3001c2e0:	e1a02823 	lsr	r2, r3, #16
3001c2e4:	e59f305c 	ldr	r3, [pc, #92]	; 3001c348 <tcp_receive+0xe8c>
3001c2e8:	e5933000 	ldr	r3, [r3]
3001c2ec:	e1a03803 	lsl	r3, r3, #16
3001c2f0:	e1a03823 	lsr	r3, r3, #16
3001c2f4:	e0633002 	rsb	r3, r3, r2
3001c2f8:	e1a03803 	lsl	r3, r3, #16
3001c2fc:	e1a02823 	lsr	r2, r3, #16
3001c300:	e59f303c 	ldr	r3, [pc, #60]	; 3001c344 <tcp_receive+0xe88>
3001c304:	e1c320bc 	strh	r2, [r3, #12]
            pbuf_realloc(inseg.p, inseg.len);
3001c308:	e59f3034 	ldr	r3, [pc, #52]	; 3001c344 <tcp_receive+0xe88>
3001c30c:	e5932004 	ldr	r2, [r3, #4]
3001c310:	e59f302c 	ldr	r3, [pc, #44]	; 3001c344 <tcp_receive+0xe88>
3001c314:	e1d330bc 	ldrh	r3, [r3, #12]
3001c318:	e1a00002 	mov	r0, r2
3001c31c:	e1a01003 	mov	r1, r3
3001c320:	ebffe713 	bl	30015f74 <pbuf_realloc>
3001c324:	ea00002f 	b	3001c3e8 <tcp_receive+0xf2c>
3001c328:	300dbbc0 	.word	0x300dbbc0
3001c32c:	300dbbbc 	.word	0x300dbbbc
3001c330:	300dbbb0 	.word	0x300dbbb0
3001c334:	300eaa74 	.word	0x300eaa74
3001c338:	300dbbc2 	.word	0x300dbbc2
3001c33c:	300dbbc8 	.word	0x300dbbc8
3001c340:	300dbbc4 	.word	0x300dbbc4
3001c344:	300dbb9c 	.word	0x300dbb9c
3001c348:	300dbbb8 	.word	0x300dbbb8
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
3001c34c:	e51f3010 	ldr	r3, [pc, #-16]	; 3001c344 <tcp_receive+0xe88>
3001c350:	e5933010 	ldr	r3, [r3, #16]
3001c354:	e5d3200c 	ldrb	r2, [r3, #12]
3001c358:	e5d3300d 	ldrb	r3, [r3, #13]
3001c35c:	e1a03403 	lsl	r3, r3, #8
3001c360:	e1833002 	orr	r3, r3, r2
3001c364:	e1a03803 	lsl	r3, r3, #16
3001c368:	e1a03823 	lsr	r3, r3, #16
3001c36c:	e1a00003 	mov	r0, r3
3001c370:	ebffdcb5 	bl	3001364c <ntohs>
3001c374:	e1a03000 	mov	r3, r0
3001c378:	e1a04003 	mov	r4, r3
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
3001c37c:	e59d3004 	ldr	r3, [sp, #4]
3001c380:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c384:	e5933010 	ldr	r3, [r3, #16]
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
3001c388:	e5d3200c 	ldrb	r2, [r3, #12]
3001c38c:	e5d3300d 	ldrb	r3, [r3, #13]
3001c390:	e1a03403 	lsl	r3, r3, #8
3001c394:	e1833002 	orr	r3, r3, r2
3001c398:	e1a03803 	lsl	r3, r3, #16
3001c39c:	e1a03823 	lsr	r3, r3, #16
3001c3a0:	e1a00003 	mov	r0, r3
3001c3a4:	ebffdca8 	bl	3001364c <ntohs>
3001c3a8:	e1a03000 	mov	r3, r0
3001c3ac:	e0243003 	eor	r3, r4, r3
3001c3b0:	e2033003 	and	r3, r3, #3
3001c3b4:	e3530000 	cmp	r3, #0
3001c3b8:	1a00000a 	bne	3001c3e8 <tcp_receive+0xf2c>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
3001c3bc:	e59d3004 	ldr	r3, [sp, #4]
3001c3c0:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c3c4:	e58d302c 	str	r3, [sp, #44]	; 0x2c
              pcb->ooseq = pcb->ooseq->next;
3001c3c8:	e59d3004 	ldr	r3, [sp, #4]
3001c3cc:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c3d0:	e5932000 	ldr	r2, [r3]
3001c3d4:	e59d3004 	ldr	r3, [sp, #4]
3001c3d8:	e5832078 	str	r2, [r3, #120]	; 0x78
              memp_free(MEMP_TCP_SEG, old_ooseq);
3001c3dc:	e3a00004 	mov	r0, #4
3001c3e0:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
3001c3e4:	ebffe437 	bl	300154c8 <memp_free>
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
3001c3e8:	e51f30ac 	ldr	r3, [pc, #-172]	; 3001c344 <tcp_receive+0xe88>
3001c3ec:	e1d340bc 	ldrh	r4, [r3, #12]
3001c3f0:	e51f30b4 	ldr	r3, [pc, #-180]	; 3001c344 <tcp_receive+0xe88>
3001c3f4:	e5933010 	ldr	r3, [r3, #16]
3001c3f8:	e5d3200c 	ldrb	r2, [r3, #12]
3001c3fc:	e5d3300d 	ldrb	r3, [r3, #13]
3001c400:	e1a03403 	lsl	r3, r3, #8
3001c404:	e1833002 	orr	r3, r3, r2
3001c408:	e1a03803 	lsl	r3, r3, #16
3001c40c:	e1a03823 	lsr	r3, r3, #16
3001c410:	e1a00003 	mov	r0, r3
3001c414:	ebffdc8c 	bl	3001364c <ntohs>
3001c418:	e1a03000 	mov	r3, r0
3001c41c:	e2033001 	and	r3, r3, #1
3001c420:	e20330ff 	and	r3, r3, #255	; 0xff
3001c424:	e3530000 	cmp	r3, #0
3001c428:	1a00000d 	bne	3001c464 <tcp_receive+0xfa8>
3001c42c:	e51f30f0 	ldr	r3, [pc, #-240]	; 3001c344 <tcp_receive+0xe88>
3001c430:	e5933010 	ldr	r3, [r3, #16]
3001c434:	e5d3200c 	ldrb	r2, [r3, #12]
3001c438:	e5d3300d 	ldrb	r3, [r3, #13]
3001c43c:	e1a03403 	lsl	r3, r3, #8
3001c440:	e1833002 	orr	r3, r3, r2
3001c444:	e1a03803 	lsl	r3, r3, #16
3001c448:	e1a03823 	lsr	r3, r3, #16
3001c44c:	e1a00003 	mov	r0, r3
3001c450:	ebffdc7d 	bl	3001364c <ntohs>
3001c454:	e1a03000 	mov	r3, r0
3001c458:	e2033002 	and	r3, r3, #2
3001c45c:	e3530000 	cmp	r3, #0
3001c460:	0a000001 	beq	3001c46c <tcp_receive+0xfb0>
3001c464:	e3a03001 	mov	r3, #1
3001c468:	ea000000 	b	3001c470 <tcp_receive+0xfb4>
3001c46c:	e3a03000 	mov	r3, #0
3001c470:	e1a03803 	lsl	r3, r3, #16
3001c474:	e1a03823 	lsr	r3, r3, #16
3001c478:	e0843003 	add	r3, r4, r3
3001c47c:	e1a03803 	lsl	r3, r3, #16
3001c480:	e1a02823 	lsr	r2, r3, #16
3001c484:	e51f3154 	ldr	r3, [pc, #-340]	; 3001c338 <tcp_receive+0xe7c>
3001c488:	e1c320b0 	strh	r2, [r3]

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
3001c48c:	e59d3004 	ldr	r3, [sp, #4]
3001c490:	e5d33010 	ldrb	r3, [r3, #16]
3001c494:	e3530007 	cmp	r3, #7
3001c498:	0a000006 	beq	3001c4b8 <tcp_receive+0xffc>
          pcb->rcv_nxt += tcplen;
3001c49c:	e59d3004 	ldr	r3, [sp, #4]
3001c4a0:	e5932020 	ldr	r2, [r3, #32]
3001c4a4:	e51f3174 	ldr	r3, [pc, #-372]	; 3001c338 <tcp_receive+0xe7c>
3001c4a8:	e1d330b0 	ldrh	r3, [r3]
3001c4ac:	e0822003 	add	r2, r2, r3
3001c4b0:	e59d3004 	ldr	r3, [sp, #4]
3001c4b4:	e5832020 	str	r2, [r3, #32]
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
3001c4b8:	e59d3004 	ldr	r3, [sp, #4]
3001c4bc:	e1d322b4 	ldrh	r2, [r3, #36]	; 0x24
3001c4c0:	e51f3190 	ldr	r3, [pc, #-400]	; 3001c338 <tcp_receive+0xe7c>
3001c4c4:	e1d330b0 	ldrh	r3, [r3]
3001c4c8:	e1520003 	cmp	r2, r3
3001c4cc:	2a000003 	bcs	3001c4e0 <tcp_receive+0x1024>
          pcb->rcv_wnd = 0;
3001c4d0:	e59d3004 	ldr	r3, [sp, #4]
3001c4d4:	e3a02000 	mov	r2, #0
3001c4d8:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
3001c4dc:	ea000008 	b	3001c504 <tcp_receive+0x1048>
        } else {
          pcb->rcv_wnd -= tcplen;
3001c4e0:	e59d3004 	ldr	r3, [sp, #4]
3001c4e4:	e1d322b4 	ldrh	r2, [r3, #36]	; 0x24
3001c4e8:	e51f31b8 	ldr	r3, [pc, #-440]	; 3001c338 <tcp_receive+0xe7c>
3001c4ec:	e1d330b0 	ldrh	r3, [r3]
3001c4f0:	e0633002 	rsb	r3, r3, r2
3001c4f4:	e1a03803 	lsl	r3, r3, #16
3001c4f8:	e1a02823 	lsr	r2, r3, #16
3001c4fc:	e59d3004 	ldr	r3, [sp, #4]
3001c500:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
        }

        if (pcb->rcv_ann_wnd < tcplen) {
3001c504:	e59d3004 	ldr	r3, [sp, #4]
3001c508:	e1d322b6 	ldrh	r2, [r3, #38]	; 0x26
3001c50c:	e51f31dc 	ldr	r3, [pc, #-476]	; 3001c338 <tcp_receive+0xe7c>
3001c510:	e1d330b0 	ldrh	r3, [r3]
3001c514:	e1520003 	cmp	r2, r3
3001c518:	2a000003 	bcs	3001c52c <tcp_receive+0x1070>
          pcb->rcv_ann_wnd = 0;
3001c51c:	e59d3004 	ldr	r3, [sp, #4]
3001c520:	e3a02000 	mov	r2, #0
3001c524:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
3001c528:	ea000008 	b	3001c550 <tcp_receive+0x1094>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
3001c52c:	e59d3004 	ldr	r3, [sp, #4]
3001c530:	e1d322b6 	ldrh	r2, [r3, #38]	; 0x26
3001c534:	e51f3204 	ldr	r3, [pc, #-516]	; 3001c338 <tcp_receive+0xe7c>
3001c538:	e1d330b0 	ldrh	r3, [r3]
3001c53c:	e0633002 	rsb	r3, r3, r2
3001c540:	e1a03803 	lsl	r3, r3, #16
3001c544:	e1a02823 	lsr	r2, r3, #16
3001c548:	e59d3004 	ldr	r3, [sp, #4]
3001c54c:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
3001c550:	e51f3214 	ldr	r3, [pc, #-532]	; 3001c344 <tcp_receive+0xe88>
3001c554:	e5933004 	ldr	r3, [r3, #4]
3001c558:	e1d330b8 	ldrh	r3, [r3, #8]
3001c55c:	e3530000 	cmp	r3, #0
3001c560:	0a000006 	beq	3001c580 <tcp_receive+0x10c4>
          recv_data = inseg.p;
3001c564:	e51f3228 	ldr	r3, [pc, #-552]	; 3001c344 <tcp_receive+0xe88>
3001c568:	e5932004 	ldr	r2, [r3, #4]
3001c56c:	e51f3238 	ldr	r3, [pc, #-568]	; 3001c33c <tcp_receive+0xe80>
3001c570:	e5832000 	str	r2, [r3]
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
3001c574:	e51f3238 	ldr	r3, [pc, #-568]	; 3001c344 <tcp_receive+0xe88>
3001c578:	e3a02000 	mov	r2, #0
3001c57c:	e5832004 	str	r2, [r3, #4]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
3001c580:	e51f3244 	ldr	r3, [pc, #-580]	; 3001c344 <tcp_receive+0xe88>
3001c584:	e5933010 	ldr	r3, [r3, #16]
3001c588:	e5d3200c 	ldrb	r2, [r3, #12]
3001c58c:	e5d3300d 	ldrb	r3, [r3, #13]
3001c590:	e1a03403 	lsl	r3, r3, #8
3001c594:	e1833002 	orr	r3, r3, r2
3001c598:	e1a03803 	lsl	r3, r3, #16
3001c59c:	e1a03823 	lsr	r3, r3, #16
3001c5a0:	e1a00003 	mov	r0, r3
3001c5a4:	ebffdc28 	bl	3001364c <ntohs>
3001c5a8:	e1a03000 	mov	r3, r0
3001c5ac:	e2033001 	and	r3, r3, #1
3001c5b0:	e20330ff 	and	r3, r3, #255	; 0xff
3001c5b4:	e3530000 	cmp	r3, #0
3001c5b8:	0a00012d 	beq	3001ca74 <tcp_receive+0x15b8>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
3001c5bc:	e51f3284 	ldr	r3, [pc, #-644]	; 3001c340 <tcp_receive+0xe84>
3001c5c0:	e3a02020 	mov	r2, #32
3001c5c4:	e5c32000 	strb	r2, [r3]
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
3001c5c8:	ea00012a 	b	3001ca78 <tcp_receive+0x15bc>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
3001c5cc:	e59d3004 	ldr	r3, [sp, #4]
3001c5d0:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c5d4:	e58d3010 	str	r3, [sp, #16]
          seqno = pcb->ooseq->tcphdr->seqno;
3001c5d8:	e59d3004 	ldr	r3, [sp, #4]
3001c5dc:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001c5e0:	e5933010 	ldr	r3, [r3, #16]
3001c5e4:	e5d32004 	ldrb	r2, [r3, #4]
3001c5e8:	e5d31005 	ldrb	r1, [r3, #5]
3001c5ec:	e1a01401 	lsl	r1, r1, #8
3001c5f0:	e1812002 	orr	r2, r1, r2
3001c5f4:	e5d31006 	ldrb	r1, [r3, #6]
3001c5f8:	e1a01801 	lsl	r1, r1, #16
3001c5fc:	e1812002 	orr	r2, r1, r2
3001c600:	e5d33007 	ldrb	r3, [r3, #7]
3001c604:	e1a03c03 	lsl	r3, r3, #24
3001c608:	e1833002 	orr	r3, r3, r2
3001c60c:	e1a02003 	mov	r2, r3
3001c610:	e51f32d0 	ldr	r3, [pc, #-720]	; 3001c348 <tcp_receive+0xe8c>
3001c614:	e5832000 	str	r2, [r3]

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
3001c618:	e59d3004 	ldr	r3, [sp, #4]
3001c61c:	e5934020 	ldr	r4, [r3, #32]
3001c620:	e59d3010 	ldr	r3, [sp, #16]
3001c624:	e1d330bc 	ldrh	r3, [r3, #12]
3001c628:	e1a05003 	mov	r5, r3
3001c62c:	e59d3010 	ldr	r3, [sp, #16]
3001c630:	e5933010 	ldr	r3, [r3, #16]
3001c634:	e5d3200c 	ldrb	r2, [r3, #12]
3001c638:	e5d3300d 	ldrb	r3, [r3, #13]
3001c63c:	e1a03403 	lsl	r3, r3, #8
3001c640:	e1833002 	orr	r3, r3, r2
3001c644:	e1a03803 	lsl	r3, r3, #16
3001c648:	e1a03823 	lsr	r3, r3, #16
3001c64c:	e1a00003 	mov	r0, r3
3001c650:	ebffdbfd 	bl	3001364c <ntohs>
3001c654:	e1a03000 	mov	r3, r0
3001c658:	e2033001 	and	r3, r3, #1
3001c65c:	e20330ff 	and	r3, r3, #255	; 0xff
3001c660:	e3530000 	cmp	r3, #0
3001c664:	1a00000d 	bne	3001c6a0 <tcp_receive+0x11e4>
3001c668:	e59d3010 	ldr	r3, [sp, #16]
3001c66c:	e5933010 	ldr	r3, [r3, #16]
3001c670:	e5d3200c 	ldrb	r2, [r3, #12]
3001c674:	e5d3300d 	ldrb	r3, [r3, #13]
3001c678:	e1a03403 	lsl	r3, r3, #8
3001c67c:	e1833002 	orr	r3, r3, r2
3001c680:	e1a03803 	lsl	r3, r3, #16
3001c684:	e1a03823 	lsr	r3, r3, #16
3001c688:	e1a00003 	mov	r0, r3
3001c68c:	ebffdbee 	bl	3001364c <ntohs>
3001c690:	e1a03000 	mov	r3, r0
3001c694:	e2033002 	and	r3, r3, #2
3001c698:	e3530000 	cmp	r3, #0
3001c69c:	0a000001 	beq	3001c6a8 <tcp_receive+0x11ec>
3001c6a0:	e3a03001 	mov	r3, #1
3001c6a4:	ea000000 	b	3001c6ac <tcp_receive+0x11f0>
3001c6a8:	e3a03000 	mov	r3, #0
3001c6ac:	e0853003 	add	r3, r5, r3
3001c6b0:	e0842003 	add	r2, r4, r3
3001c6b4:	e59d3004 	ldr	r3, [sp, #4]
3001c6b8:	e5832020 	str	r2, [r3, #32]
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
3001c6bc:	e59d3004 	ldr	r3, [sp, #4]
3001c6c0:	e1d332b4 	ldrh	r3, [r3, #36]	; 0x24
3001c6c4:	e1a04003 	mov	r4, r3
3001c6c8:	e59d3010 	ldr	r3, [sp, #16]
3001c6cc:	e1d330bc 	ldrh	r3, [r3, #12]
3001c6d0:	e1a05003 	mov	r5, r3
3001c6d4:	e59d3010 	ldr	r3, [sp, #16]
3001c6d8:	e5933010 	ldr	r3, [r3, #16]
3001c6dc:	e5d3200c 	ldrb	r2, [r3, #12]
3001c6e0:	e5d3300d 	ldrb	r3, [r3, #13]
3001c6e4:	e1a03403 	lsl	r3, r3, #8
3001c6e8:	e1833002 	orr	r3, r3, r2
3001c6ec:	e1a03803 	lsl	r3, r3, #16
3001c6f0:	e1a03823 	lsr	r3, r3, #16
3001c6f4:	e1a00003 	mov	r0, r3
3001c6f8:	ebffdbd3 	bl	3001364c <ntohs>
3001c6fc:	e1a03000 	mov	r3, r0
3001c700:	e2033001 	and	r3, r3, #1
3001c704:	e20330ff 	and	r3, r3, #255	; 0xff
3001c708:	e3530000 	cmp	r3, #0
3001c70c:	1a00000d 	bne	3001c748 <tcp_receive+0x128c>
3001c710:	e59d3010 	ldr	r3, [sp, #16]
3001c714:	e5933010 	ldr	r3, [r3, #16]
3001c718:	e5d3200c 	ldrb	r2, [r3, #12]
3001c71c:	e5d3300d 	ldrb	r3, [r3, #13]
3001c720:	e1a03403 	lsl	r3, r3, #8
3001c724:	e1833002 	orr	r3, r3, r2
3001c728:	e1a03803 	lsl	r3, r3, #16
3001c72c:	e1a03823 	lsr	r3, r3, #16
3001c730:	e1a00003 	mov	r0, r3
3001c734:	ebffdbc4 	bl	3001364c <ntohs>
3001c738:	e1a03000 	mov	r3, r0
3001c73c:	e2033002 	and	r3, r3, #2
3001c740:	e3530000 	cmp	r3, #0
3001c744:	0a000001 	beq	3001c750 <tcp_receive+0x1294>
3001c748:	e3a03001 	mov	r3, #1
3001c74c:	ea000000 	b	3001c754 <tcp_receive+0x1298>
3001c750:	e3a03000 	mov	r3, #0
3001c754:	e0853003 	add	r3, r5, r3
3001c758:	e1540003 	cmp	r4, r3
3001c75c:	aa000003 	bge	3001c770 <tcp_receive+0x12b4>
            pcb->rcv_wnd = 0;
3001c760:	e59d3004 	ldr	r3, [sp, #4]
3001c764:	e3a02000 	mov	r2, #0
3001c768:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
3001c76c:	ea00002d 	b	3001c828 <tcp_receive+0x136c>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
3001c770:	e59d3004 	ldr	r3, [sp, #4]
3001c774:	e1d342b4 	ldrh	r4, [r3, #36]	; 0x24
3001c778:	e59d3010 	ldr	r3, [sp, #16]
3001c77c:	e1d350bc 	ldrh	r5, [r3, #12]
3001c780:	e59d3010 	ldr	r3, [sp, #16]
3001c784:	e5933010 	ldr	r3, [r3, #16]
3001c788:	e5d3200c 	ldrb	r2, [r3, #12]
3001c78c:	e5d3300d 	ldrb	r3, [r3, #13]
3001c790:	e1a03403 	lsl	r3, r3, #8
3001c794:	e1833002 	orr	r3, r3, r2
3001c798:	e1a03803 	lsl	r3, r3, #16
3001c79c:	e1a03823 	lsr	r3, r3, #16
3001c7a0:	e1a00003 	mov	r0, r3
3001c7a4:	ebffdba8 	bl	3001364c <ntohs>
3001c7a8:	e1a03000 	mov	r3, r0
3001c7ac:	e2033001 	and	r3, r3, #1
3001c7b0:	e20330ff 	and	r3, r3, #255	; 0xff
3001c7b4:	e3530000 	cmp	r3, #0
3001c7b8:	1a00000d 	bne	3001c7f4 <tcp_receive+0x1338>
3001c7bc:	e59d3010 	ldr	r3, [sp, #16]
3001c7c0:	e5933010 	ldr	r3, [r3, #16]
3001c7c4:	e5d3200c 	ldrb	r2, [r3, #12]
3001c7c8:	e5d3300d 	ldrb	r3, [r3, #13]
3001c7cc:	e1a03403 	lsl	r3, r3, #8
3001c7d0:	e1833002 	orr	r3, r3, r2
3001c7d4:	e1a03803 	lsl	r3, r3, #16
3001c7d8:	e1a03823 	lsr	r3, r3, #16
3001c7dc:	e1a00003 	mov	r0, r3
3001c7e0:	ebffdb99 	bl	3001364c <ntohs>
3001c7e4:	e1a03000 	mov	r3, r0
3001c7e8:	e2033002 	and	r3, r3, #2
3001c7ec:	e3530000 	cmp	r3, #0
3001c7f0:	0a000001 	beq	3001c7fc <tcp_receive+0x1340>
3001c7f4:	e3a03001 	mov	r3, #1
3001c7f8:	ea000000 	b	3001c800 <tcp_receive+0x1344>
3001c7fc:	e3a03000 	mov	r3, #0
3001c800:	e1a03803 	lsl	r3, r3, #16
3001c804:	e1a03823 	lsr	r3, r3, #16
3001c808:	e0853003 	add	r3, r5, r3
3001c80c:	e1a03803 	lsl	r3, r3, #16
3001c810:	e1a03823 	lsr	r3, r3, #16
3001c814:	e0633004 	rsb	r3, r3, r4
3001c818:	e1a03803 	lsl	r3, r3, #16
3001c81c:	e1a02823 	lsr	r2, r3, #16
3001c820:	e59d3004 	ldr	r3, [sp, #4]
3001c824:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
3001c828:	e59d3004 	ldr	r3, [sp, #4]
3001c82c:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
3001c830:	e1a04003 	mov	r4, r3
3001c834:	e59d3010 	ldr	r3, [sp, #16]
3001c838:	e1d330bc 	ldrh	r3, [r3, #12]
3001c83c:	e1a05003 	mov	r5, r3
3001c840:	e59d3010 	ldr	r3, [sp, #16]
3001c844:	e5933010 	ldr	r3, [r3, #16]
3001c848:	e5d3200c 	ldrb	r2, [r3, #12]
3001c84c:	e5d3300d 	ldrb	r3, [r3, #13]
3001c850:	e1a03403 	lsl	r3, r3, #8
3001c854:	e1833002 	orr	r3, r3, r2
3001c858:	e1a03803 	lsl	r3, r3, #16
3001c85c:	e1a03823 	lsr	r3, r3, #16
3001c860:	e1a00003 	mov	r0, r3
3001c864:	ebffdb78 	bl	3001364c <ntohs>
3001c868:	e1a03000 	mov	r3, r0
3001c86c:	e2033001 	and	r3, r3, #1
3001c870:	e20330ff 	and	r3, r3, #255	; 0xff
3001c874:	e3530000 	cmp	r3, #0
3001c878:	1a00000d 	bne	3001c8b4 <tcp_receive+0x13f8>
3001c87c:	e59d3010 	ldr	r3, [sp, #16]
3001c880:	e5933010 	ldr	r3, [r3, #16]
3001c884:	e5d3200c 	ldrb	r2, [r3, #12]
3001c888:	e5d3300d 	ldrb	r3, [r3, #13]
3001c88c:	e1a03403 	lsl	r3, r3, #8
3001c890:	e1833002 	orr	r3, r3, r2
3001c894:	e1a03803 	lsl	r3, r3, #16
3001c898:	e1a03823 	lsr	r3, r3, #16
3001c89c:	e1a00003 	mov	r0, r3
3001c8a0:	ebffdb69 	bl	3001364c <ntohs>
3001c8a4:	e1a03000 	mov	r3, r0
3001c8a8:	e2033002 	and	r3, r3, #2
3001c8ac:	e3530000 	cmp	r3, #0
3001c8b0:	0a000001 	beq	3001c8bc <tcp_receive+0x1400>
3001c8b4:	e3a03001 	mov	r3, #1
3001c8b8:	ea000000 	b	3001c8c0 <tcp_receive+0x1404>
3001c8bc:	e3a03000 	mov	r3, #0
3001c8c0:	e0853003 	add	r3, r5, r3
3001c8c4:	e1540003 	cmp	r4, r3
3001c8c8:	aa000003 	bge	3001c8dc <tcp_receive+0x1420>
            pcb->rcv_ann_wnd = 0;
3001c8cc:	e59d3004 	ldr	r3, [sp, #4]
3001c8d0:	e3a02000 	mov	r2, #0
3001c8d4:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
3001c8d8:	ea00002d 	b	3001c994 <tcp_receive+0x14d8>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
3001c8dc:	e59d3004 	ldr	r3, [sp, #4]
3001c8e0:	e1d342b6 	ldrh	r4, [r3, #38]	; 0x26
3001c8e4:	e59d3010 	ldr	r3, [sp, #16]
3001c8e8:	e1d350bc 	ldrh	r5, [r3, #12]
3001c8ec:	e59d3010 	ldr	r3, [sp, #16]
3001c8f0:	e5933010 	ldr	r3, [r3, #16]
3001c8f4:	e5d3200c 	ldrb	r2, [r3, #12]
3001c8f8:	e5d3300d 	ldrb	r3, [r3, #13]
3001c8fc:	e1a03403 	lsl	r3, r3, #8
3001c900:	e1833002 	orr	r3, r3, r2
3001c904:	e1a03803 	lsl	r3, r3, #16
3001c908:	e1a03823 	lsr	r3, r3, #16
3001c90c:	e1a00003 	mov	r0, r3
3001c910:	ebffdb4d 	bl	3001364c <ntohs>
3001c914:	e1a03000 	mov	r3, r0
3001c918:	e2033001 	and	r3, r3, #1
3001c91c:	e20330ff 	and	r3, r3, #255	; 0xff
3001c920:	e3530000 	cmp	r3, #0
3001c924:	1a00000d 	bne	3001c960 <tcp_receive+0x14a4>
3001c928:	e59d3010 	ldr	r3, [sp, #16]
3001c92c:	e5933010 	ldr	r3, [r3, #16]
3001c930:	e5d3200c 	ldrb	r2, [r3, #12]
3001c934:	e5d3300d 	ldrb	r3, [r3, #13]
3001c938:	e1a03403 	lsl	r3, r3, #8
3001c93c:	e1833002 	orr	r3, r3, r2
3001c940:	e1a03803 	lsl	r3, r3, #16
3001c944:	e1a03823 	lsr	r3, r3, #16
3001c948:	e1a00003 	mov	r0, r3
3001c94c:	ebffdb3e 	bl	3001364c <ntohs>
3001c950:	e1a03000 	mov	r3, r0
3001c954:	e2033002 	and	r3, r3, #2
3001c958:	e3530000 	cmp	r3, #0
3001c95c:	0a000001 	beq	3001c968 <tcp_receive+0x14ac>
3001c960:	e3a03001 	mov	r3, #1
3001c964:	ea000000 	b	3001c96c <tcp_receive+0x14b0>
3001c968:	e3a03000 	mov	r3, #0
3001c96c:	e1a03803 	lsl	r3, r3, #16
3001c970:	e1a03823 	lsr	r3, r3, #16
3001c974:	e0853003 	add	r3, r5, r3
3001c978:	e1a03803 	lsl	r3, r3, #16
3001c97c:	e1a03823 	lsr	r3, r3, #16
3001c980:	e0633004 	rsb	r3, r3, r4
3001c984:	e1a03803 	lsl	r3, r3, #16
3001c988:	e1a02823 	lsr	r2, r3, #16
3001c98c:	e59d3004 	ldr	r3, [sp, #4]
3001c990:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
          }

          if (cseg->p->tot_len > 0) {
3001c994:	e59d3010 	ldr	r3, [sp, #16]
3001c998:	e5933004 	ldr	r3, [r3, #4]
3001c99c:	e1d330b8 	ldrh	r3, [r3, #8]
3001c9a0:	e3530000 	cmp	r3, #0
3001c9a4:	0a000012 	beq	3001c9f4 <tcp_receive+0x1538>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
3001c9a8:	e51f3674 	ldr	r3, [pc, #-1652]	; 3001c33c <tcp_receive+0xe80>
3001c9ac:	e5933000 	ldr	r3, [r3]
3001c9b0:	e3530000 	cmp	r3, #0
3001c9b4:	0a000007 	beq	3001c9d8 <tcp_receive+0x151c>
              pbuf_cat(recv_data, cseg->p);
3001c9b8:	e51f3684 	ldr	r3, [pc, #-1668]	; 3001c33c <tcp_receive+0xe80>
3001c9bc:	e5932000 	ldr	r2, [r3]
3001c9c0:	e59d3010 	ldr	r3, [sp, #16]
3001c9c4:	e5933004 	ldr	r3, [r3, #4]
3001c9c8:	e1a00002 	mov	r0, r2
3001c9cc:	e1a01003 	mov	r1, r3
3001c9d0:	ebffe697 	bl	30016434 <pbuf_cat>
3001c9d4:	ea000003 	b	3001c9e8 <tcp_receive+0x152c>
            } else {
              recv_data = cseg->p;
3001c9d8:	e59d3010 	ldr	r3, [sp, #16]
3001c9dc:	e5932004 	ldr	r2, [r3, #4]
3001c9e0:	e51f36ac 	ldr	r3, [pc, #-1708]	; 3001c33c <tcp_receive+0xe80>
3001c9e4:	e5832000 	str	r2, [r3]
            }
            cseg->p = NULL;
3001c9e8:	e59d3010 	ldr	r3, [sp, #16]
3001c9ec:	e3a02000 	mov	r2, #0
3001c9f0:	e5832004 	str	r2, [r3, #4]
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
3001c9f4:	e59d3010 	ldr	r3, [sp, #16]
3001c9f8:	e5933010 	ldr	r3, [r3, #16]
3001c9fc:	e5d3200c 	ldrb	r2, [r3, #12]
3001ca00:	e5d3300d 	ldrb	r3, [r3, #13]
3001ca04:	e1a03403 	lsl	r3, r3, #8
3001ca08:	e1833002 	orr	r3, r3, r2
3001ca0c:	e1a03803 	lsl	r3, r3, #16
3001ca10:	e1a03823 	lsr	r3, r3, #16
3001ca14:	e1a00003 	mov	r0, r3
3001ca18:	ebffdb0b 	bl	3001364c <ntohs>
3001ca1c:	e1a03000 	mov	r3, r0
3001ca20:	e2033001 	and	r3, r3, #1
3001ca24:	e20330ff 	and	r3, r3, #255	; 0xff
3001ca28:	e3530000 	cmp	r3, #0
3001ca2c:	0a000009 	beq	3001ca58 <tcp_receive+0x159c>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
3001ca30:	e51f36f8 	ldr	r3, [pc, #-1784]	; 3001c340 <tcp_receive+0xe84>
3001ca34:	e3a02020 	mov	r2, #32
3001ca38:	e5c32000 	strb	r2, [r3]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
3001ca3c:	e59d3004 	ldr	r3, [sp, #4]
3001ca40:	e5d33010 	ldrb	r3, [r3, #16]
3001ca44:	e3530004 	cmp	r3, #4
3001ca48:	1a000002 	bne	3001ca58 <tcp_receive+0x159c>
              pcb->state = CLOSE_WAIT;
3001ca4c:	e59d3004 	ldr	r3, [sp, #4]
3001ca50:	e3a02007 	mov	r2, #7
3001ca54:	e5c32010 	strb	r2, [r3, #16]
            } 
          }


          pcb->ooseq = cseg->next;
3001ca58:	e59d3010 	ldr	r3, [sp, #16]
3001ca5c:	e5932000 	ldr	r2, [r3]
3001ca60:	e59d3004 	ldr	r3, [sp, #4]
3001ca64:	e5832078 	str	r2, [r3, #120]	; 0x78
          tcp_seg_free(cseg);
3001ca68:	e59d0010 	ldr	r0, [sp, #16]
3001ca6c:	ebfff09e 	bl	30018cec <tcp_seg_free>
3001ca70:	ea000000 	b	3001ca78 <tcp_receive+0x15bc>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
3001ca74:	e1a00000 	nop			; (mov r0, r0)
3001ca78:	e59d3004 	ldr	r3, [sp, #4]
3001ca7c:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001ca80:	e3530000 	cmp	r3, #0
3001ca84:	0a000011 	beq	3001cad0 <tcp_receive+0x1614>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
3001ca88:	e59d3004 	ldr	r3, [sp, #4]
3001ca8c:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001ca90:	e5933010 	ldr	r3, [r3, #16]
3001ca94:	e5d32004 	ldrb	r2, [r3, #4]
3001ca98:	e5d31005 	ldrb	r1, [r3, #5]
3001ca9c:	e1a01401 	lsl	r1, r1, #8
3001caa0:	e1812002 	orr	r2, r1, r2
3001caa4:	e5d31006 	ldrb	r1, [r3, #6]
3001caa8:	e1a01801 	lsl	r1, r1, #16
3001caac:	e1812002 	orr	r2, r1, r2
3001cab0:	e5d33007 	ldrb	r3, [r3, #7]
3001cab4:	e1a03c03 	lsl	r3, r3, #24
3001cab8:	e1833002 	orr	r3, r3, r2
3001cabc:	e1a02003 	mov	r2, r3
3001cac0:	e59d3004 	ldr	r3, [sp, #4]
3001cac4:	e5933020 	ldr	r3, [r3, #32]
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
3001cac8:	e1520003 	cmp	r2, r3
3001cacc:	0afffebe 	beq	3001c5cc <tcp_receive+0x1110>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
3001cad0:	e59d3004 	ldr	r3, [sp, #4]
3001cad4:	e5d3301c 	ldrb	r3, [r3, #28]
3001cad8:	e2033001 	and	r3, r3, #1
3001cadc:	e20330ff 	and	r3, r3, #255	; 0xff
3001cae0:	e3530000 	cmp	r3, #0
3001cae4:	0a00000d 	beq	3001cb20 <tcp_receive+0x1664>
3001cae8:	e59d3004 	ldr	r3, [sp, #4]
3001caec:	e5d3301c 	ldrb	r3, [r3, #28]
3001caf0:	e20330fe 	and	r3, r3, #254	; 0xfe
3001caf4:	e59d2004 	ldr	r2, [sp, #4]
3001caf8:	e5c2301c 	strb	r3, [r2, #28]
3001cafc:	e59d3004 	ldr	r3, [sp, #4]
3001cb00:	e5d3301c 	ldrb	r3, [r3, #28]
3001cb04:	e3833002 	orr	r3, r3, #2
3001cb08:	e20320ff 	and	r2, r3, #255	; 0xff
3001cb0c:	e59d3004 	ldr	r3, [sp, #4]
3001cb10:	e5c3201c 	strb	r2, [r3, #28]
3001cb14:	e59d0004 	ldr	r0, [sp, #4]
3001cb18:	eb00052d 	bl	3001dfd4 <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
3001cb1c:	ea000218 	b	3001d384 <tcp_receive+0x1ec8>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
3001cb20:	e59d3004 	ldr	r3, [sp, #4]
3001cb24:	e5d3301c 	ldrb	r3, [r3, #28]
3001cb28:	e3833001 	orr	r3, r3, #1
3001cb2c:	e20320ff 	and	r2, r3, #255	; 0xff
3001cb30:	e59d3004 	ldr	r3, [sp, #4]
3001cb34:	e5c3201c 	strb	r2, [r3, #28]
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
3001cb38:	ea000211 	b	3001d384 <tcp_receive+0x1ec8>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
3001cb3c:	e59d3004 	ldr	r3, [sp, #4]
3001cb40:	e5d3301c 	ldrb	r3, [r3, #28]
3001cb44:	e3833002 	orr	r3, r3, #2
3001cb48:	e20320ff 	and	r2, r3, #255	; 0xff
3001cb4c:	e59d3004 	ldr	r3, [sp, #4]
3001cb50:	e5c3201c 	strb	r2, [r3, #28]
3001cb54:	e59d0004 	ldr	r0, [sp, #4]
3001cb58:	eb00051d 	bl	3001dfd4 <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
3001cb5c:	e59d3004 	ldr	r3, [sp, #4]
3001cb60:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001cb64:	e3530000 	cmp	r3, #0
3001cb68:	1a000005 	bne	3001cb84 <tcp_receive+0x16c8>
          pcb->ooseq = tcp_seg_copy(&inseg);
3001cb6c:	e51f0830 	ldr	r0, [pc, #-2096]	; 3001c344 <tcp_receive+0xe88>
3001cb70:	ebfff080 	bl	30018d78 <tcp_seg_copy>
3001cb74:	e1a02000 	mov	r2, r0
3001cb78:	e59d3004 	ldr	r3, [sp, #4]
3001cb7c:	e5832078 	str	r2, [r3, #120]	; 0x78
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
3001cb80:	ea0001ff 	b	3001d384 <tcp_receive+0x1ec8>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
3001cb84:	e3a03000 	mov	r3, #0
3001cb88:	e58d300c 	str	r3, [sp, #12]
          for(next = pcb->ooseq; next != NULL; next = next->next) {
3001cb8c:	e59d3004 	ldr	r3, [sp, #4]
3001cb90:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3001cb94:	e58d3008 	str	r3, [sp, #8]
3001cb98:	ea0001ad 	b	3001d254 <tcp_receive+0x1d98>
            if (seqno == next->tcphdr->seqno) {
3001cb9c:	e59d3008 	ldr	r3, [sp, #8]
3001cba0:	e5933010 	ldr	r3, [r3, #16]
3001cba4:	e5d32004 	ldrb	r2, [r3, #4]
3001cba8:	e5d31005 	ldrb	r1, [r3, #5]
3001cbac:	e1a01401 	lsl	r1, r1, #8
3001cbb0:	e1812002 	orr	r2, r1, r2
3001cbb4:	e5d31006 	ldrb	r1, [r3, #6]
3001cbb8:	e1a01801 	lsl	r1, r1, #16
3001cbbc:	e1812002 	orr	r2, r1, r2
3001cbc0:	e5d33007 	ldrb	r3, [r3, #7]
3001cbc4:	e1a03c03 	lsl	r3, r3, #24
3001cbc8:	e1833002 	orr	r3, r3, r2
3001cbcc:	e1a02003 	mov	r2, r3
3001cbd0:	e51f3890 	ldr	r3, [pc, #-2192]	; 3001c348 <tcp_receive+0xe8c>
3001cbd4:	e5933000 	ldr	r3, [r3]
3001cbd8:	e1520003 	cmp	r2, r3
3001cbdc:	1a000057 	bne	3001cd40 <tcp_receive+0x1884>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
3001cbe0:	e51f38a4 	ldr	r3, [pc, #-2212]	; 3001c344 <tcp_receive+0xe88>
3001cbe4:	e1d320bc 	ldrh	r2, [r3, #12]
3001cbe8:	e59d3008 	ldr	r3, [sp, #8]
3001cbec:	e1d330bc 	ldrh	r3, [r3, #12]
3001cbf0:	e1520003 	cmp	r2, r3
3001cbf4:	9a00019a 	bls	3001d264 <tcp_receive+0x1da8>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
3001cbf8:	e51f08bc 	ldr	r0, [pc, #-2236]	; 3001c344 <tcp_receive+0xe88>
3001cbfc:	ebfff05d 	bl	30018d78 <tcp_seg_copy>
3001cc00:	e1a03000 	mov	r3, r0
3001cc04:	e58d3010 	str	r3, [sp, #16]
                if (cseg != NULL) {
3001cc08:	e59d3010 	ldr	r3, [sp, #16]
3001cc0c:	e3530000 	cmp	r3, #0
3001cc10:	0a00000d 	beq	3001cc4c <tcp_receive+0x1790>
                  cseg->next = next->next;
3001cc14:	e59d3008 	ldr	r3, [sp, #8]
3001cc18:	e5932000 	ldr	r2, [r3]
3001cc1c:	e59d3010 	ldr	r3, [sp, #16]
3001cc20:	e5832000 	str	r2, [r3]
                  if (prev != NULL) {
3001cc24:	e59d300c 	ldr	r3, [sp, #12]
3001cc28:	e3530000 	cmp	r3, #0
3001cc2c:	0a000003 	beq	3001cc40 <tcp_receive+0x1784>
                    prev->next = cseg;
3001cc30:	e59d300c 	ldr	r3, [sp, #12]
3001cc34:	e59d2010 	ldr	r2, [sp, #16]
3001cc38:	e5832000 	str	r2, [r3]
3001cc3c:	ea000002 	b	3001cc4c <tcp_receive+0x1790>
                  } else {
                    pcb->ooseq = cseg;
3001cc40:	e59d3004 	ldr	r3, [sp, #4]
3001cc44:	e59d2010 	ldr	r2, [sp, #16]
3001cc48:	e5832078 	str	r2, [r3, #120]	; 0x78
                  }
                }
                tcp_seg_free(next);
3001cc4c:	e59d0008 	ldr	r0, [sp, #8]
3001cc50:	ebfff025 	bl	30018cec <tcp_seg_free>
                if (cseg->next != NULL) {
3001cc54:	e59d3010 	ldr	r3, [sp, #16]
3001cc58:	e5933000 	ldr	r3, [r3]
3001cc5c:	e3530000 	cmp	r3, #0
3001cc60:	0a000181 	beq	3001d26c <tcp_receive+0x1db0>
                  next = cseg->next;
3001cc64:	e59d3010 	ldr	r3, [sp, #16]
3001cc68:	e5933000 	ldr	r3, [r3]
3001cc6c:	e58d3008 	str	r3, [sp, #8]
                  if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
3001cc70:	e59d3010 	ldr	r3, [sp, #16]
3001cc74:	e1d330bc 	ldrh	r3, [r3, #12]
3001cc78:	e1a02003 	mov	r2, r3
3001cc7c:	e51f393c 	ldr	r3, [pc, #-2364]	; 3001c348 <tcp_receive+0xe8c>
3001cc80:	e5933000 	ldr	r3, [r3]
3001cc84:	e0822003 	add	r2, r2, r3
3001cc88:	e59d3008 	ldr	r3, [sp, #8]
3001cc8c:	e5933010 	ldr	r3, [r3, #16]
3001cc90:	e5d31004 	ldrb	r1, [r3, #4]
3001cc94:	e5d30005 	ldrb	r0, [r3, #5]
3001cc98:	e1a00400 	lsl	r0, r0, #8
3001cc9c:	e1801001 	orr	r1, r0, r1
3001cca0:	e5d30006 	ldrb	r0, [r3, #6]
3001cca4:	e1a00800 	lsl	r0, r0, #16
3001cca8:	e1801001 	orr	r1, r0, r1
3001ccac:	e5d33007 	ldrb	r3, [r3, #7]
3001ccb0:	e1a03c03 	lsl	r3, r3, #24
3001ccb4:	e1833001 	orr	r3, r3, r1
3001ccb8:	e0633002 	rsb	r3, r3, r2
3001ccbc:	e3530000 	cmp	r3, #0
3001ccc0:	da00016b 	ble	3001d274 <tcp_receive+0x1db8>
                    /* We need to trim the incoming segment. */
                    cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
3001ccc4:	e59d3008 	ldr	r3, [sp, #8]
3001ccc8:	e5933010 	ldr	r3, [r3, #16]
3001cccc:	e5d32004 	ldrb	r2, [r3, #4]
3001ccd0:	e5d31005 	ldrb	r1, [r3, #5]
3001ccd4:	e1a01401 	lsl	r1, r1, #8
3001ccd8:	e1812002 	orr	r2, r1, r2
3001ccdc:	e5d31006 	ldrb	r1, [r3, #6]
3001cce0:	e1a01801 	lsl	r1, r1, #16
3001cce4:	e1812002 	orr	r2, r1, r2
3001cce8:	e5d33007 	ldrb	r3, [r3, #7]
3001ccec:	e1a03c03 	lsl	r3, r3, #24
3001ccf0:	e1833002 	orr	r3, r3, r2
3001ccf4:	e1a03803 	lsl	r3, r3, #16
3001ccf8:	e1a02823 	lsr	r2, r3, #16
3001ccfc:	e51f39bc 	ldr	r3, [pc, #-2492]	; 3001c348 <tcp_receive+0xe8c>
3001cd00:	e5933000 	ldr	r3, [r3]
3001cd04:	e1a03803 	lsl	r3, r3, #16
3001cd08:	e1a03823 	lsr	r3, r3, #16
3001cd0c:	e0633002 	rsb	r3, r3, r2
3001cd10:	e1a03803 	lsl	r3, r3, #16
3001cd14:	e1a02823 	lsr	r2, r3, #16
3001cd18:	e59d3010 	ldr	r3, [sp, #16]
3001cd1c:	e1c320bc 	strh	r2, [r3, #12]
                    pbuf_realloc(cseg->p, cseg->len);
3001cd20:	e59d3010 	ldr	r3, [sp, #16]
3001cd24:	e5932004 	ldr	r2, [r3, #4]
3001cd28:	e59d3010 	ldr	r3, [sp, #16]
3001cd2c:	e1d330bc 	ldrh	r3, [r3, #12]
3001cd30:	e1a00002 	mov	r0, r2
3001cd34:	e1a01003 	mov	r1, r3
3001cd38:	ebffe48d 	bl	30015f74 <pbuf_realloc>
                  }
                }
                break;
3001cd3c:	ea000157 	b	3001d2a0 <tcp_receive+0x1de4>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
3001cd40:	e59d300c 	ldr	r3, [sp, #12]
3001cd44:	e3530000 	cmp	r3, #0
3001cd48:	1a000051 	bne	3001ce94 <tcp_receive+0x19d8>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
3001cd4c:	e51f3a0c 	ldr	r3, [pc, #-2572]	; 3001c348 <tcp_receive+0xe8c>
3001cd50:	e5932000 	ldr	r2, [r3]
3001cd54:	e59d3008 	ldr	r3, [sp, #8]
3001cd58:	e5933010 	ldr	r3, [r3, #16]
3001cd5c:	e5d31004 	ldrb	r1, [r3, #4]
3001cd60:	e5d30005 	ldrb	r0, [r3, #5]
3001cd64:	e1a00400 	lsl	r0, r0, #8
3001cd68:	e1801001 	orr	r1, r0, r1
3001cd6c:	e5d30006 	ldrb	r0, [r3, #6]
3001cd70:	e1a00800 	lsl	r0, r0, #16
3001cd74:	e1801001 	orr	r1, r0, r1
3001cd78:	e5d33007 	ldrb	r3, [r3, #7]
3001cd7c:	e1a03c03 	lsl	r3, r3, #24
3001cd80:	e1833001 	orr	r3, r3, r1
3001cd84:	e0633002 	rsb	r3, r3, r2
3001cd88:	e3530000 	cmp	r3, #0
3001cd8c:	aa0000d8 	bge	3001d0f4 <tcp_receive+0x1c38>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
3001cd90:	e51f3a54 	ldr	r3, [pc, #-2644]	; 3001c344 <tcp_receive+0xe88>
3001cd94:	e1d330bc 	ldrh	r3, [r3, #12]
3001cd98:	e1a02003 	mov	r2, r3
3001cd9c:	e51f3a5c 	ldr	r3, [pc, #-2652]	; 3001c348 <tcp_receive+0xe8c>
3001cda0:	e5933000 	ldr	r3, [r3]
3001cda4:	e0822003 	add	r2, r2, r3
3001cda8:	e59d3008 	ldr	r3, [sp, #8]
3001cdac:	e5933010 	ldr	r3, [r3, #16]
3001cdb0:	e5d31004 	ldrb	r1, [r3, #4]
3001cdb4:	e5d30005 	ldrb	r0, [r3, #5]
3001cdb8:	e1a00400 	lsl	r0, r0, #8
3001cdbc:	e1801001 	orr	r1, r0, r1
3001cdc0:	e5d30006 	ldrb	r0, [r3, #6]
3001cdc4:	e1a00800 	lsl	r0, r0, #16
3001cdc8:	e1801001 	orr	r1, r0, r1
3001cdcc:	e5d33007 	ldrb	r3, [r3, #7]
3001cdd0:	e1a03c03 	lsl	r3, r3, #24
3001cdd4:	e1833001 	orr	r3, r3, r1
3001cdd8:	e0633002 	rsb	r3, r3, r2
3001cddc:	e3530000 	cmp	r3, #0
3001cde0:	da00001d 	ble	3001ce5c <tcp_receive+0x19a0>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
3001cde4:	e59d3008 	ldr	r3, [sp, #8]
3001cde8:	e5933010 	ldr	r3, [r3, #16]
3001cdec:	e5d32004 	ldrb	r2, [r3, #4]
3001cdf0:	e5d31005 	ldrb	r1, [r3, #5]
3001cdf4:	e1a01401 	lsl	r1, r1, #8
3001cdf8:	e1812002 	orr	r2, r1, r2
3001cdfc:	e5d31006 	ldrb	r1, [r3, #6]
3001ce00:	e1a01801 	lsl	r1, r1, #16
3001ce04:	e1812002 	orr	r2, r1, r2
3001ce08:	e5d33007 	ldrb	r3, [r3, #7]
3001ce0c:	e1a03c03 	lsl	r3, r3, #24
3001ce10:	e1833002 	orr	r3, r3, r2
3001ce14:	e1a03803 	lsl	r3, r3, #16
3001ce18:	e1a02823 	lsr	r2, r3, #16
3001ce1c:	e51f3adc 	ldr	r3, [pc, #-2780]	; 3001c348 <tcp_receive+0xe8c>
3001ce20:	e5933000 	ldr	r3, [r3]
3001ce24:	e1a03803 	lsl	r3, r3, #16
3001ce28:	e1a03823 	lsr	r3, r3, #16
3001ce2c:	e0633002 	rsb	r3, r3, r2
3001ce30:	e1a03803 	lsl	r3, r3, #16
3001ce34:	e1a02823 	lsr	r2, r3, #16
3001ce38:	e51f3afc 	ldr	r3, [pc, #-2812]	; 3001c344 <tcp_receive+0xe88>
3001ce3c:	e1c320bc 	strh	r2, [r3, #12]
                    pbuf_realloc(inseg.p, inseg.len);
3001ce40:	e51f3b04 	ldr	r3, [pc, #-2820]	; 3001c344 <tcp_receive+0xe88>
3001ce44:	e5932004 	ldr	r2, [r3, #4]
3001ce48:	e51f3b0c 	ldr	r3, [pc, #-2828]	; 3001c344 <tcp_receive+0xe88>
3001ce4c:	e1d330bc 	ldrh	r3, [r3, #12]
3001ce50:	e1a00002 	mov	r0, r2
3001ce54:	e1a01003 	mov	r1, r3
3001ce58:	ebffe445 	bl	30015f74 <pbuf_realloc>
                  }
                  cseg = tcp_seg_copy(&inseg);
3001ce5c:	e51f0b20 	ldr	r0, [pc, #-2848]	; 3001c344 <tcp_receive+0xe88>
3001ce60:	ebffefc4 	bl	30018d78 <tcp_seg_copy>
3001ce64:	e1a03000 	mov	r3, r0
3001ce68:	e58d3010 	str	r3, [sp, #16]
                  if (cseg != NULL) {
3001ce6c:	e59d3010 	ldr	r3, [sp, #16]
3001ce70:	e3530000 	cmp	r3, #0
3001ce74:	0a000100 	beq	3001d27c <tcp_receive+0x1dc0>
                    cseg->next = next;
3001ce78:	e59d3010 	ldr	r3, [sp, #16]
3001ce7c:	e59d2008 	ldr	r2, [sp, #8]
3001ce80:	e5832000 	str	r2, [r3]
                    pcb->ooseq = cseg;
3001ce84:	e59d3004 	ldr	r3, [sp, #4]
3001ce88:	e59d2010 	ldr	r2, [sp, #16]
3001ce8c:	e5832078 	str	r2, [r3, #120]	; 0x78
                  }
                  break;
3001ce90:	ea000102 	b	3001d2a0 <tcp_receive+0x1de4>
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
3001ce94:	e59d300c 	ldr	r3, [sp, #12]
3001ce98:	e5933010 	ldr	r3, [r3, #16]
3001ce9c:	e5d32004 	ldrb	r2, [r3, #4]
3001cea0:	e5d31005 	ldrb	r1, [r3, #5]
3001cea4:	e1a01401 	lsl	r1, r1, #8
3001cea8:	e1812002 	orr	r2, r1, r2
3001ceac:	e5d31006 	ldrb	r1, [r3, #6]
3001ceb0:	e1a01801 	lsl	r1, r1, #16
3001ceb4:	e1812002 	orr	r2, r1, r2
3001ceb8:	e5d33007 	ldrb	r3, [r3, #7]
3001cebc:	e1a03c03 	lsl	r3, r3, #24
3001cec0:	e1833002 	orr	r3, r3, r2
3001cec4:	e1e02003 	mvn	r2, r3
3001cec8:	e51f3b88 	ldr	r3, [pc, #-2952]	; 3001c348 <tcp_receive+0xe8c>
3001cecc:	e5933000 	ldr	r3, [r3]
3001ced0:	e0823003 	add	r3, r2, r3
3001ced4:	e3530000 	cmp	r3, #0
3001ced8:	ba000086 	blt	3001d0f8 <tcp_receive+0x1c3c>
3001cedc:	e51f3b9c 	ldr	r3, [pc, #-2972]	; 3001c348 <tcp_receive+0xe8c>
3001cee0:	e5932000 	ldr	r2, [r3]
3001cee4:	e59d3008 	ldr	r3, [sp, #8]
3001cee8:	e5933010 	ldr	r3, [r3, #16]
3001ceec:	e5d31004 	ldrb	r1, [r3, #4]
3001cef0:	e5d30005 	ldrb	r0, [r3, #5]
3001cef4:	e1a00400 	lsl	r0, r0, #8
3001cef8:	e1801001 	orr	r1, r0, r1
3001cefc:	e5d30006 	ldrb	r0, [r3, #6]
3001cf00:	e1a00800 	lsl	r0, r0, #16
3001cf04:	e1801001 	orr	r1, r0, r1
3001cf08:	e5d33007 	ldrb	r3, [r3, #7]
3001cf0c:	e1a03c03 	lsl	r3, r3, #24
3001cf10:	e1833001 	orr	r3, r3, r1
3001cf14:	e0633002 	rsb	r3, r3, r2
3001cf18:	e2833001 	add	r3, r3, #1
3001cf1c:	e3530000 	cmp	r3, #0
3001cf20:	ca000074 	bgt	3001d0f8 <tcp_receive+0x1c3c>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
3001cf24:	e51f3be8 	ldr	r3, [pc, #-3048]	; 3001c344 <tcp_receive+0xe88>
3001cf28:	e1d330bc 	ldrh	r3, [r3, #12]
3001cf2c:	e1a02003 	mov	r2, r3
3001cf30:	e51f3bf0 	ldr	r3, [pc, #-3056]	; 3001c348 <tcp_receive+0xe8c>
3001cf34:	e5933000 	ldr	r3, [r3]
3001cf38:	e0822003 	add	r2, r2, r3
3001cf3c:	e59d3008 	ldr	r3, [sp, #8]
3001cf40:	e5933010 	ldr	r3, [r3, #16]
3001cf44:	e5d31004 	ldrb	r1, [r3, #4]
3001cf48:	e5d30005 	ldrb	r0, [r3, #5]
3001cf4c:	e1a00400 	lsl	r0, r0, #8
3001cf50:	e1801001 	orr	r1, r0, r1
3001cf54:	e5d30006 	ldrb	r0, [r3, #6]
3001cf58:	e1a00800 	lsl	r0, r0, #16
3001cf5c:	e1801001 	orr	r1, r0, r1
3001cf60:	e5d33007 	ldrb	r3, [r3, #7]
3001cf64:	e1a03c03 	lsl	r3, r3, #24
3001cf68:	e1833001 	orr	r3, r3, r1
3001cf6c:	e0633002 	rsb	r3, r3, r2
3001cf70:	e3530000 	cmp	r3, #0
3001cf74:	da00001d 	ble	3001cff0 <tcp_receive+0x1b34>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
3001cf78:	e59d3008 	ldr	r3, [sp, #8]
3001cf7c:	e5933010 	ldr	r3, [r3, #16]
3001cf80:	e5d32004 	ldrb	r2, [r3, #4]
3001cf84:	e5d31005 	ldrb	r1, [r3, #5]
3001cf88:	e1a01401 	lsl	r1, r1, #8
3001cf8c:	e1812002 	orr	r2, r1, r2
3001cf90:	e5d31006 	ldrb	r1, [r3, #6]
3001cf94:	e1a01801 	lsl	r1, r1, #16
3001cf98:	e1812002 	orr	r2, r1, r2
3001cf9c:	e5d33007 	ldrb	r3, [r3, #7]
3001cfa0:	e1a03c03 	lsl	r3, r3, #24
3001cfa4:	e1833002 	orr	r3, r3, r2
3001cfa8:	e1a03803 	lsl	r3, r3, #16
3001cfac:	e1a02823 	lsr	r2, r3, #16
3001cfb0:	e51f3c70 	ldr	r3, [pc, #-3184]	; 3001c348 <tcp_receive+0xe8c>
3001cfb4:	e5933000 	ldr	r3, [r3]
3001cfb8:	e1a03803 	lsl	r3, r3, #16
3001cfbc:	e1a03823 	lsr	r3, r3, #16
3001cfc0:	e0633002 	rsb	r3, r3, r2
3001cfc4:	e1a03803 	lsl	r3, r3, #16
3001cfc8:	e1a02823 	lsr	r2, r3, #16
3001cfcc:	e51f3c90 	ldr	r3, [pc, #-3216]	; 3001c344 <tcp_receive+0xe88>
3001cfd0:	e1c320bc 	strh	r2, [r3, #12]
                  pbuf_realloc(inseg.p, inseg.len);
3001cfd4:	e51f3c98 	ldr	r3, [pc, #-3224]	; 3001c344 <tcp_receive+0xe88>
3001cfd8:	e5932004 	ldr	r2, [r3, #4]
3001cfdc:	e51f3ca0 	ldr	r3, [pc, #-3232]	; 3001c344 <tcp_receive+0xe88>
3001cfe0:	e1d330bc 	ldrh	r3, [r3, #12]
3001cfe4:	e1a00002 	mov	r0, r2
3001cfe8:	e1a01003 	mov	r1, r3
3001cfec:	ebffe3e0 	bl	30015f74 <pbuf_realloc>
                }

                cseg = tcp_seg_copy(&inseg);
3001cff0:	e51f0cb4 	ldr	r0, [pc, #-3252]	; 3001c344 <tcp_receive+0xe88>
3001cff4:	ebffef5f 	bl	30018d78 <tcp_seg_copy>
3001cff8:	e1a03000 	mov	r3, r0
3001cffc:	e58d3010 	str	r3, [sp, #16]
                if (cseg != NULL) {
3001d000:	e59d3010 	ldr	r3, [sp, #16]
3001d004:	e3530000 	cmp	r3, #0
3001d008:	0a00009d 	beq	3001d284 <tcp_receive+0x1dc8>
                  cseg->next = next;
3001d00c:	e59d3010 	ldr	r3, [sp, #16]
3001d010:	e59d2008 	ldr	r2, [sp, #8]
3001d014:	e5832000 	str	r2, [r3]
                  prev->next = cseg;
3001d018:	e59d300c 	ldr	r3, [sp, #12]
3001d01c:	e59d2010 	ldr	r2, [sp, #16]
3001d020:	e5832000 	str	r2, [r3]
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
3001d024:	e59d300c 	ldr	r3, [sp, #12]
3001d028:	e5933010 	ldr	r3, [r3, #16]
3001d02c:	e5d32004 	ldrb	r2, [r3, #4]
3001d030:	e5d31005 	ldrb	r1, [r3, #5]
3001d034:	e1a01401 	lsl	r1, r1, #8
3001d038:	e1812002 	orr	r2, r1, r2
3001d03c:	e5d31006 	ldrb	r1, [r3, #6]
3001d040:	e1a01801 	lsl	r1, r1, #16
3001d044:	e1812002 	orr	r2, r1, r2
3001d048:	e5d33007 	ldrb	r3, [r3, #7]
3001d04c:	e1a03c03 	lsl	r3, r3, #24
3001d050:	e1833002 	orr	r3, r3, r2
3001d054:	e1a02003 	mov	r2, r3
3001d058:	e59d300c 	ldr	r3, [sp, #12]
3001d05c:	e1d330bc 	ldrh	r3, [r3, #12]
3001d060:	e0822003 	add	r2, r2, r3
3001d064:	e51f3d24 	ldr	r3, [pc, #-3364]	; 3001c348 <tcp_receive+0xe8c>
3001d068:	e5933000 	ldr	r3, [r3]
3001d06c:	e0633002 	rsb	r3, r3, r2
3001d070:	e3530000 	cmp	r3, #0
3001d074:	da000084 	ble	3001d28c <tcp_receive+0x1dd0>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
3001d078:	e51f3d38 	ldr	r3, [pc, #-3384]	; 3001c348 <tcp_receive+0xe8c>
3001d07c:	e5933000 	ldr	r3, [r3]
3001d080:	e1a03803 	lsl	r3, r3, #16
3001d084:	e1a02823 	lsr	r2, r3, #16
3001d088:	e59d300c 	ldr	r3, [sp, #12]
3001d08c:	e5933010 	ldr	r3, [r3, #16]
3001d090:	e5d31004 	ldrb	r1, [r3, #4]
3001d094:	e5d30005 	ldrb	r0, [r3, #5]
3001d098:	e1a00400 	lsl	r0, r0, #8
3001d09c:	e1801001 	orr	r1, r0, r1
3001d0a0:	e5d30006 	ldrb	r0, [r3, #6]
3001d0a4:	e1a00800 	lsl	r0, r0, #16
3001d0a8:	e1801001 	orr	r1, r0, r1
3001d0ac:	e5d33007 	ldrb	r3, [r3, #7]
3001d0b0:	e1a03c03 	lsl	r3, r3, #24
3001d0b4:	e1833001 	orr	r3, r3, r1
3001d0b8:	e1a03803 	lsl	r3, r3, #16
3001d0bc:	e1a03823 	lsr	r3, r3, #16
3001d0c0:	e0633002 	rsb	r3, r3, r2
3001d0c4:	e1a03803 	lsl	r3, r3, #16
3001d0c8:	e1a02823 	lsr	r2, r3, #16
3001d0cc:	e59d300c 	ldr	r3, [sp, #12]
3001d0d0:	e1c320bc 	strh	r2, [r3, #12]
                    pbuf_realloc(prev->p, prev->len);
3001d0d4:	e59d300c 	ldr	r3, [sp, #12]
3001d0d8:	e5932004 	ldr	r2, [r3, #4]
3001d0dc:	e59d300c 	ldr	r3, [sp, #12]
3001d0e0:	e1d330bc 	ldrh	r3, [r3, #12]
3001d0e4:	e1a00002 	mov	r0, r2
3001d0e8:	e1a01003 	mov	r1, r3
3001d0ec:	ebffe3a0 	bl	30015f74 <pbuf_realloc>
                  }
                }
                break;
3001d0f0:	ea00006a 	b	3001d2a0 <tcp_receive+0x1de4>
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    cseg->next = next;
                    pcb->ooseq = cseg;
                  }
                  break;
3001d0f4:	e1a00000 	nop			; (mov r0, r0)
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
3001d0f8:	e59d3008 	ldr	r3, [sp, #8]
3001d0fc:	e5933000 	ldr	r3, [r3]
3001d100:	e3530000 	cmp	r3, #0
3001d104:	1a00004d 	bne	3001d240 <tcp_receive+0x1d84>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
3001d108:	e51f3dc8 	ldr	r3, [pc, #-3528]	; 3001c348 <tcp_receive+0xe8c>
3001d10c:	e5932000 	ldr	r2, [r3]
3001d110:	e59d3008 	ldr	r3, [sp, #8]
3001d114:	e5933010 	ldr	r3, [r3, #16]
3001d118:	e5d31004 	ldrb	r1, [r3, #4]
3001d11c:	e5d30005 	ldrb	r0, [r3, #5]
3001d120:	e1a00400 	lsl	r0, r0, #8
3001d124:	e1801001 	orr	r1, r0, r1
3001d128:	e5d30006 	ldrb	r0, [r3, #6]
3001d12c:	e1a00800 	lsl	r0, r0, #16
3001d130:	e1801001 	orr	r1, r0, r1
3001d134:	e5d33007 	ldrb	r3, [r3, #7]
3001d138:	e1a03c03 	lsl	r3, r3, #24
3001d13c:	e1833001 	orr	r3, r3, r1
3001d140:	e0633002 	rsb	r3, r3, r2
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
3001d144:	e3530000 	cmp	r3, #0
3001d148:	da00003c 	ble	3001d240 <tcp_receive+0x1d84>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
3001d14c:	e51f0e10 	ldr	r0, [pc, #-3600]	; 3001c344 <tcp_receive+0xe88>
3001d150:	ebffef08 	bl	30018d78 <tcp_seg_copy>
3001d154:	e1a02000 	mov	r2, r0
3001d158:	e59d3008 	ldr	r3, [sp, #8]
3001d15c:	e5832000 	str	r2, [r3]
                if (next->next != NULL) {
3001d160:	e59d3008 	ldr	r3, [sp, #8]
3001d164:	e5933000 	ldr	r3, [r3]
3001d168:	e3530000 	cmp	r3, #0
3001d16c:	0a000048 	beq	3001d294 <tcp_receive+0x1dd8>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
3001d170:	e59d3008 	ldr	r3, [sp, #8]
3001d174:	e5933010 	ldr	r3, [r3, #16]
3001d178:	e5d32004 	ldrb	r2, [r3, #4]
3001d17c:	e5d31005 	ldrb	r1, [r3, #5]
3001d180:	e1a01401 	lsl	r1, r1, #8
3001d184:	e1812002 	orr	r2, r1, r2
3001d188:	e5d31006 	ldrb	r1, [r3, #6]
3001d18c:	e1a01801 	lsl	r1, r1, #16
3001d190:	e1812002 	orr	r2, r1, r2
3001d194:	e5d33007 	ldrb	r3, [r3, #7]
3001d198:	e1a03c03 	lsl	r3, r3, #24
3001d19c:	e1833002 	orr	r3, r3, r2
3001d1a0:	e1a02003 	mov	r2, r3
3001d1a4:	e59d3008 	ldr	r3, [sp, #8]
3001d1a8:	e1d330bc 	ldrh	r3, [r3, #12]
3001d1ac:	e0822003 	add	r2, r2, r3
3001d1b0:	e51f3e70 	ldr	r3, [pc, #-3696]	; 3001c348 <tcp_receive+0xe8c>
3001d1b4:	e5933000 	ldr	r3, [r3]
3001d1b8:	e0633002 	rsb	r3, r3, r2
3001d1bc:	e3530000 	cmp	r3, #0
3001d1c0:	da000035 	ble	3001d29c <tcp_receive+0x1de0>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
3001d1c4:	e51f3e84 	ldr	r3, [pc, #-3716]	; 3001c348 <tcp_receive+0xe8c>
3001d1c8:	e5933000 	ldr	r3, [r3]
3001d1cc:	e1a03803 	lsl	r3, r3, #16
3001d1d0:	e1a02823 	lsr	r2, r3, #16
3001d1d4:	e59d3008 	ldr	r3, [sp, #8]
3001d1d8:	e5933010 	ldr	r3, [r3, #16]
3001d1dc:	e5d31004 	ldrb	r1, [r3, #4]
3001d1e0:	e5d30005 	ldrb	r0, [r3, #5]
3001d1e4:	e1a00400 	lsl	r0, r0, #8
3001d1e8:	e1801001 	orr	r1, r0, r1
3001d1ec:	e5d30006 	ldrb	r0, [r3, #6]
3001d1f0:	e1a00800 	lsl	r0, r0, #16
3001d1f4:	e1801001 	orr	r1, r0, r1
3001d1f8:	e5d33007 	ldrb	r3, [r3, #7]
3001d1fc:	e1a03c03 	lsl	r3, r3, #24
3001d200:	e1833001 	orr	r3, r3, r1
3001d204:	e1a03803 	lsl	r3, r3, #16
3001d208:	e1a03823 	lsr	r3, r3, #16
3001d20c:	e0633002 	rsb	r3, r3, r2
3001d210:	e1a03803 	lsl	r3, r3, #16
3001d214:	e1a02823 	lsr	r2, r3, #16
3001d218:	e59d3008 	ldr	r3, [sp, #8]
3001d21c:	e1c320bc 	strh	r2, [r3, #12]
                    pbuf_realloc(next->p, next->len);
3001d220:	e59d3008 	ldr	r3, [sp, #8]
3001d224:	e5932004 	ldr	r2, [r3, #4]
3001d228:	e59d3008 	ldr	r3, [sp, #8]
3001d22c:	e1d330bc 	ldrh	r3, [r3, #12]
3001d230:	e1a00002 	mov	r0, r2
3001d234:	e1a01003 	mov	r1, r3
3001d238:	ebffe34d 	bl	30015f74 <pbuf_realloc>
                  }
                }
                break;
3001d23c:	ea000017 	b	3001d2a0 <tcp_receive+0x1de4>
              }
            }
            prev = next;
3001d240:	e59d3008 	ldr	r3, [sp, #8]
3001d244:	e58d300c 	str	r3, [sp, #12]
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
3001d248:	e59d3008 	ldr	r3, [sp, #8]
3001d24c:	e5933000 	ldr	r3, [r3]
3001d250:	e58d3008 	str	r3, [sp, #8]
3001d254:	e59d3008 	ldr	r3, [sp, #8]
3001d258:	e3530000 	cmp	r3, #0
3001d25c:	1afffe4e 	bne	3001cb9c <tcp_receive+0x16e0>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
3001d260:	ea000047 	b	3001d384 <tcp_receive+0x1ec8>
                break;
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
3001d264:	e1a00000 	nop			; (mov r0, r0)
3001d268:	ea00000c 	b	3001d2a0 <tcp_receive+0x1de4>
                    /* We need to trim the incoming segment. */
                    cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
                    pbuf_realloc(cseg->p, cseg->len);
                  }
                }
                break;
3001d26c:	e1a00000 	nop			; (mov r0, r0)
3001d270:	ea00000a 	b	3001d2a0 <tcp_receive+0x1de4>
3001d274:	e1a00000 	nop			; (mov r0, r0)
3001d278:	ea000008 	b	3001d2a0 <tcp_receive+0x1de4>
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    cseg->next = next;
                    pcb->ooseq = cseg;
                  }
                  break;
3001d27c:	e1a00000 	nop			; (mov r0, r0)
3001d280:	ea000006 	b	3001d2a0 <tcp_receive+0x1de4>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
                    pbuf_realloc(prev->p, prev->len);
                  }
                }
                break;
3001d284:	e1a00000 	nop			; (mov r0, r0)
3001d288:	ea000004 	b	3001d2a0 <tcp_receive+0x1de4>
3001d28c:	e1a00000 	nop			; (mov r0, r0)
3001d290:	ea000002 	b	3001d2a0 <tcp_receive+0x1de4>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
                    pbuf_realloc(next->p, next->len);
                  }
                }
                break;
3001d294:	e1a00000 	nop			; (mov r0, r0)
3001d298:	ea000000 	b	3001d2a0 <tcp_receive+0x1de4>
3001d29c:	e1a00000 	nop			; (mov r0, r0)
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
3001d2a0:	e1a00000 	nop			; (mov r0, r0)
3001d2a4:	ea000036 	b	3001d384 <tcp_receive+0x1ec8>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
3001d2a8:	e51f3f68 	ldr	r3, [pc, #-3944]	; 3001c348 <tcp_receive+0xe8c>
3001d2ac:	e5932000 	ldr	r2, [r3]
3001d2b0:	e59d3004 	ldr	r3, [sp, #4]
3001d2b4:	e5933020 	ldr	r3, [r3, #32]
3001d2b8:	e0633002 	rsb	r3, r3, r2
3001d2bc:	e3530000 	cmp	r3, #0
3001d2c0:	ba00000a 	blt	3001d2f0 <tcp_receive+0x1e34>
3001d2c4:	e51f3f84 	ldr	r3, [pc, #-3972]	; 3001c348 <tcp_receive+0xe8c>
3001d2c8:	e5932000 	ldr	r2, [r3]
3001d2cc:	e59d3004 	ldr	r3, [sp, #4]
3001d2d0:	e5931020 	ldr	r1, [r3, #32]
3001d2d4:	e59d3004 	ldr	r3, [sp, #4]
3001d2d8:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
3001d2dc:	e0813003 	add	r3, r1, r3
3001d2e0:	e0633002 	rsb	r3, r3, r2
3001d2e4:	e2833001 	add	r3, r3, #1
3001d2e8:	e3530000 	cmp	r3, #0
3001d2ec:	da000023 	ble	3001d380 <tcp_receive+0x1ec4>
                          pcb->rcv_nxt + pcb->rcv_ann_wnd-1)){
        tcp_ack_now(pcb);
3001d2f0:	e59d3004 	ldr	r3, [sp, #4]
3001d2f4:	e5d3301c 	ldrb	r3, [r3, #28]
3001d2f8:	e3833002 	orr	r3, r3, #2
3001d2fc:	e20320ff 	and	r2, r3, #255	; 0xff
3001d300:	e59d3004 	ldr	r3, [sp, #4]
3001d304:	e5c3201c 	strb	r2, [r3, #28]
3001d308:	e59d0004 	ldr	r0, [sp, #4]
3001d30c:	eb000330 	bl	3001dfd4 <tcp_output>
3001d310:	ea00001b 	b	3001d384 <tcp_receive+0x1ec8>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
3001d314:	e59f307c 	ldr	r3, [pc, #124]	; 3001d398 <tcp_receive+0x1edc>
3001d318:	e5932000 	ldr	r2, [r3]
3001d31c:	e59d3004 	ldr	r3, [sp, #4]
3001d320:	e5933020 	ldr	r3, [r3, #32]
3001d324:	e0633002 	rsb	r3, r3, r2
3001d328:	e3530000 	cmp	r3, #0
3001d32c:	ba00000a 	blt	3001d35c <tcp_receive+0x1ea0>
3001d330:	e59f3060 	ldr	r3, [pc, #96]	; 3001d398 <tcp_receive+0x1edc>
3001d334:	e5932000 	ldr	r2, [r3]
3001d338:	e59d3004 	ldr	r3, [sp, #4]
3001d33c:	e5931020 	ldr	r1, [r3, #32]
3001d340:	e59d3004 	ldr	r3, [sp, #4]
3001d344:	e1d332b4 	ldrh	r3, [r3, #36]	; 0x24
3001d348:	e0813003 	add	r3, r1, r3
3001d34c:	e0633002 	rsb	r3, r3, r2
3001d350:	e2833001 	add	r3, r3, #1
3001d354:	e3530000 	cmp	r3, #0
3001d358:	da000009 	ble	3001d384 <tcp_receive+0x1ec8>
      tcp_ack_now(pcb);
3001d35c:	e59d3004 	ldr	r3, [sp, #4]
3001d360:	e5d3301c 	ldrb	r3, [r3, #28]
3001d364:	e3833002 	orr	r3, r3, #2
3001d368:	e20320ff 	and	r2, r3, #255	; 0xff
3001d36c:	e59d3004 	ldr	r3, [sp, #4]
3001d370:	e5c3201c 	strb	r2, [r3, #28]
3001d374:	e59d0004 	ldr	r0, [sp, #4]
3001d378:	eb000315 	bl	3001dfd4 <tcp_output>
3001d37c:	ea000000 	b	3001d384 <tcp_receive+0x1ec8>

      }
    } else {
      if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                          pcb->rcv_nxt + pcb->rcv_ann_wnd-1)){
        tcp_ack_now(pcb);
3001d380:	e1a00000 	nop			; (mov r0, r0)
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
  return accepted_inseq;
3001d384:	e5dd3029 	ldrb	r3, [sp, #41]	; 0x29
}
3001d388:	e1a00003 	mov	r0, r3
3001d38c:	e28dd030 	add	sp, sp, #48	; 0x30
3001d390:	e8bd4070 	pop	{r4, r5, r6, lr}
3001d394:	e12fff1e 	bx	lr
3001d398:	300dbbb8 	.word	0x300dbbb8

3001d39c <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
3001d39c:	e92d4010 	push	{r4, lr}
3001d3a0:	e24dd018 	sub	sp, sp, #24
3001d3a4:	e58d0004 	str	r0, [sp, #4]
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
3001d3a8:	e59f31c0 	ldr	r3, [pc, #448]	; 3001d570 <tcp_parseopt+0x1d4>
3001d3ac:	e5933000 	ldr	r3, [r3]
3001d3b0:	e2833014 	add	r3, r3, #20
3001d3b4:	e58d3010 	str	r3, [sp, #16]

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
3001d3b8:	e59f31b0 	ldr	r3, [pc, #432]	; 3001d570 <tcp_parseopt+0x1d4>
3001d3bc:	e5933000 	ldr	r3, [r3]
3001d3c0:	e5d3200c 	ldrb	r2, [r3, #12]
3001d3c4:	e5d3300d 	ldrb	r3, [r3, #13]
3001d3c8:	e1a03403 	lsl	r3, r3, #8
3001d3cc:	e1833002 	orr	r3, r3, r2
3001d3d0:	e1a03803 	lsl	r3, r3, #16
3001d3d4:	e1a03823 	lsr	r3, r3, #16
3001d3d8:	e1a00003 	mov	r0, r3
3001d3dc:	ebffd89a 	bl	3001364c <ntohs>
3001d3e0:	e1a03000 	mov	r3, r0
3001d3e4:	e1a03623 	lsr	r3, r3, #12
3001d3e8:	e1a03803 	lsl	r3, r3, #16
3001d3ec:	e1a03823 	lsr	r3, r3, #16
3001d3f0:	e3530005 	cmp	r3, #5
3001d3f4:	9a00005a 	bls	3001d564 <tcp_parseopt+0x1c8>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
3001d3f8:	e3a03000 	mov	r3, #0
3001d3fc:	e5cd300f 	strb	r3, [sp, #15]
3001d400:	ea000040 	b	3001d508 <tcp_parseopt+0x16c>
      opt = opts[c];
3001d404:	e5dd200f 	ldrb	r2, [sp, #15]
3001d408:	e59d3010 	ldr	r3, [sp, #16]
3001d40c:	e0823003 	add	r3, r2, r3
3001d410:	e5d33000 	ldrb	r3, [r3]
3001d414:	e5cd3015 	strb	r3, [sp, #21]
      if (opt == 0x00) {
3001d418:	e5dd3015 	ldrb	r3, [sp, #21]
3001d41c:	e3530000 	cmp	r3, #0
3001d420:	0a00004c 	beq	3001d558 <tcp_parseopt+0x1bc>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
3001d424:	e5dd3015 	ldrb	r3, [sp, #21]
3001d428:	e3530001 	cmp	r3, #1
3001d42c:	1a000003 	bne	3001d440 <tcp_parseopt+0xa4>
        ++c;
3001d430:	e5dd300f 	ldrb	r3, [sp, #15]
3001d434:	e2833001 	add	r3, r3, #1
3001d438:	e5cd300f 	strb	r3, [sp, #15]
3001d43c:	ea000031 	b	3001d508 <tcp_parseopt+0x16c>
        /* NOP option. */
      } else if (opt == 0x02 &&
3001d440:	e5dd3015 	ldrb	r3, [sp, #21]
3001d444:	e3530002 	cmp	r3, #2
3001d448:	1a00001f 	bne	3001d4cc <tcp_parseopt+0x130>
        opts[c + 1] == 0x04) {
3001d44c:	e5dd300f 	ldrb	r3, [sp, #15]
3001d450:	e2832001 	add	r2, r3, #1
3001d454:	e59d3010 	ldr	r3, [sp, #16]
3001d458:	e0823003 	add	r3, r2, r3
3001d45c:	e5d33000 	ldrb	r3, [r3]
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
        /* NOP option. */
      } else if (opt == 0x02 &&
3001d460:	e3530004 	cmp	r3, #4
3001d464:	1a000018 	bne	3001d4cc <tcp_parseopt+0x130>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
3001d468:	e5dd300f 	ldrb	r3, [sp, #15]
3001d46c:	e2832002 	add	r2, r3, #2
3001d470:	e59d3010 	ldr	r3, [sp, #16]
3001d474:	e0823003 	add	r3, r2, r3
3001d478:	e5d33000 	ldrb	r3, [r3]
3001d47c:	e1a03403 	lsl	r3, r3, #8
3001d480:	e1a03803 	lsl	r3, r3, #16
3001d484:	e1a02823 	lsr	r2, r3, #16
3001d488:	e5dd300f 	ldrb	r3, [sp, #15]
3001d48c:	e2831003 	add	r1, r3, #3
3001d490:	e59d3010 	ldr	r3, [sp, #16]
3001d494:	e0813003 	add	r3, r1, r3
3001d498:	e5d33000 	ldrb	r3, [r3]
3001d49c:	e1823003 	orr	r3, r2, r3
3001d4a0:	e1a03803 	lsl	r3, r3, #16
3001d4a4:	e1a03823 	lsr	r3, r3, #16
3001d4a8:	e1cd31b6 	strh	r3, [sp, #22]
        pcb->mss = mss > TCP_MSS? TCP_MSS: mss;
3001d4ac:	e1dd31b6 	ldrh	r3, [sp, #22]
3001d4b0:	e3530a01 	cmp	r3, #4096	; 0x1000
3001d4b4:	23a03a01 	movcs	r3, #4096	; 0x1000
3001d4b8:	e1a03803 	lsl	r3, r3, #16
3001d4bc:	e1a02823 	lsr	r2, r3, #16
3001d4c0:	e59d3004 	ldr	r3, [sp, #4]
3001d4c4:	e1c323b0 	strh	r2, [r3, #48]	; 0x30

        /* And we are done processing options. */
        break;
3001d4c8:	ea000025 	b	3001d564 <tcp_parseopt+0x1c8>
      } else {
        if (opts[c + 1] == 0) {
3001d4cc:	e5dd300f 	ldrb	r3, [sp, #15]
3001d4d0:	e2832001 	add	r2, r3, #1
3001d4d4:	e59d3010 	ldr	r3, [sp, #16]
3001d4d8:	e0823003 	add	r3, r2, r3
3001d4dc:	e5d33000 	ldrb	r3, [r3]
3001d4e0:	e3530000 	cmp	r3, #0
3001d4e4:	0a00001d 	beq	3001d560 <tcp_parseopt+0x1c4>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
3001d4e8:	e5dd300f 	ldrb	r3, [sp, #15]
3001d4ec:	e2832001 	add	r2, r3, #1
3001d4f0:	e59d3010 	ldr	r3, [sp, #16]
3001d4f4:	e0823003 	add	r3, r2, r3
3001d4f8:	e5d32000 	ldrb	r2, [r3]
3001d4fc:	e5dd300f 	ldrb	r3, [sp, #15]
3001d500:	e0823003 	add	r3, r2, r3
3001d504:	e5cd300f 	strb	r3, [sp, #15]

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
3001d508:	e5dd400f 	ldrb	r4, [sp, #15]
3001d50c:	e59f305c 	ldr	r3, [pc, #92]	; 3001d570 <tcp_parseopt+0x1d4>
3001d510:	e5933000 	ldr	r3, [r3]
3001d514:	e5d3200c 	ldrb	r2, [r3, #12]
3001d518:	e5d3300d 	ldrb	r3, [r3, #13]
3001d51c:	e1a03403 	lsl	r3, r3, #8
3001d520:	e1833002 	orr	r3, r3, r2
3001d524:	e1a03803 	lsl	r3, r3, #16
3001d528:	e1a03823 	lsr	r3, r3, #16
3001d52c:	e1a00003 	mov	r0, r3
3001d530:	ebffd845 	bl	3001364c <ntohs>
3001d534:	e1a03000 	mov	r3, r0
3001d538:	e1a03623 	lsr	r3, r3, #12
3001d53c:	e1a03803 	lsl	r3, r3, #16
3001d540:	e1a03823 	lsr	r3, r3, #16
3001d544:	e2433005 	sub	r3, r3, #5
3001d548:	e1a03103 	lsl	r3, r3, #2
3001d54c:	e1540003 	cmp	r4, r3
3001d550:	baffffab 	blt	3001d404 <tcp_parseopt+0x68>
3001d554:	ea000002 	b	3001d564 <tcp_parseopt+0x1c8>
      opt = opts[c];
      if (opt == 0x00) {
        /* End of options. */
        break;
3001d558:	e1a00000 	nop			; (mov r0, r0)
3001d55c:	ea000000 	b	3001d564 <tcp_parseopt+0x1c8>
        break;
      } else {
        if (opts[c + 1] == 0) {
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          break;
3001d560:	e1a00000 	nop			; (mov r0, r0)
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
3001d564:	e28dd018 	add	sp, sp, #24
3001d568:	e8bd4010 	pop	{r4, lr}
3001d56c:	e12fff1e 	bx	lr
3001d570:	300dbbb0 	.word	0x300dbbb0

3001d574 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
3001d574:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001d578:	e24dd01c 	sub	sp, sp, #28
3001d57c:	e58d0014 	str	r0, [sp, #20]
3001d580:	e1a03001 	mov	r3, r1
3001d584:	e5cd3013 	strb	r3, [sp, #19]
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
3001d588:	e5dd3013 	ldrb	r3, [sp, #19]
3001d58c:	e3a02001 	mov	r2, #1
3001d590:	e58d2000 	str	r2, [sp]
3001d594:	e3a02000 	mov	r2, #0
3001d598:	e58d2004 	str	r2, [sp, #4]
3001d59c:	e3a02000 	mov	r2, #0
3001d5a0:	e58d2008 	str	r2, [sp, #8]
3001d5a4:	e59d0014 	ldr	r0, [sp, #20]
3001d5a8:	e3a01000 	mov	r1, #0
3001d5ac:	e3a02000 	mov	r2, #0
3001d5b0:	eb00003a 	bl	3001d6a0 <tcp_enqueue>
3001d5b4:	e1a03000 	mov	r3, r0
3001d5b8:	e20330ff 	and	r3, r3, #255	; 0xff
3001d5bc:	e20330ff 	and	r3, r3, #255	; 0xff
3001d5c0:	e1a03c03 	lsl	r3, r3, #24
3001d5c4:	e1a03c43 	asr	r3, r3, #24
}
3001d5c8:	e1a00003 	mov	r0, r3
3001d5cc:	e28dd01c 	add	sp, sp, #28
3001d5d0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001d5d4:	e12fff1e 	bx	lr

3001d5d8 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
3001d5d8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001d5dc:	e24dd024 	sub	sp, sp, #36	; 0x24
3001d5e0:	e58d001c 	str	r0, [sp, #28]
3001d5e4:	e58d1018 	str	r1, [sp, #24]
3001d5e8:	e1cd21b6 	strh	r2, [sp, #22]
3001d5ec:	e5cd3015 	strb	r3, [sp, #21]
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
3001d5f0:	e59d301c 	ldr	r3, [sp, #28]
3001d5f4:	e5d33010 	ldrb	r3, [r3, #16]
3001d5f8:	e3530004 	cmp	r3, #4
3001d5fc:	0a00000b 	beq	3001d630 <tcp_write+0x58>
     pcb->state == CLOSE_WAIT ||
3001d600:	e59d301c 	ldr	r3, [sp, #28]
3001d604:	e5d33010 	ldrb	r3, [r3, #16]
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
3001d608:	e3530007 	cmp	r3, #7
3001d60c:	0a000007 	beq	3001d630 <tcp_write+0x58>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
3001d610:	e59d301c 	ldr	r3, [sp, #28]
3001d614:	e5d33010 	ldrb	r3, [r3, #16]
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
3001d618:	e3530002 	cmp	r3, #2
3001d61c:	0a000003 	beq	3001d630 <tcp_write+0x58>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
3001d620:	e59d301c 	ldr	r3, [sp, #28]
3001d624:	e5d33010 	ldrb	r3, [r3, #16]
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
3001d628:	e3530003 	cmp	r3, #3
3001d62c:	1a000014 	bne	3001d684 <tcp_write+0xac>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
3001d630:	e1dd31b6 	ldrh	r3, [sp, #22]
3001d634:	e3530000 	cmp	r3, #0
3001d638:	0a00000f 	beq	3001d67c <tcp_write+0xa4>
      //acoral_prints("\r\ntcp_write\r\n");
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
3001d63c:	e1dd31b6 	ldrh	r3, [sp, #22]
3001d640:	e5dd2015 	ldrb	r2, [sp, #21]
3001d644:	e58d2000 	str	r2, [sp]
3001d648:	e3a02000 	mov	r2, #0
3001d64c:	e58d2004 	str	r2, [sp, #4]
3001d650:	e3a02000 	mov	r2, #0
3001d654:	e58d2008 	str	r2, [sp, #8]
3001d658:	e59d001c 	ldr	r0, [sp, #28]
3001d65c:	e59d1018 	ldr	r1, [sp, #24]
3001d660:	e1a02003 	mov	r2, r3
3001d664:	e3a03000 	mov	r3, #0
3001d668:	eb00000c 	bl	3001d6a0 <tcp_enqueue>
3001d66c:	e1a03000 	mov	r3, r0
3001d670:	e20330ff 	and	r3, r3, #255	; 0xff
3001d674:	e20330ff 	and	r3, r3, #255	; 0xff
3001d678:	ea000002 	b	3001d688 <tcp_write+0xb0>
    }
    return ERR_OK;
3001d67c:	e3a03000 	mov	r3, #0
3001d680:	ea000000 	b	3001d688 <tcp_write+0xb0>
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
3001d684:	e3a030f9 	mov	r3, #249	; 0xf9
3001d688:	e1a03c03 	lsl	r3, r3, #24
3001d68c:	e1a03c43 	asr	r3, r3, #24
  }
}
3001d690:	e1a00003 	mov	r0, r3
3001d694:	e28dd024 	add	sp, sp, #36	; 0x24
3001d698:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001d69c:	e12fff1e 	bx	lr

3001d6a0 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
3001d6a0:	e92d4030 	push	{r4, r5, lr}
3001d6a4:	e24dd034 	sub	sp, sp, #52	; 0x34
3001d6a8:	e58d000c 	str	r0, [sp, #12]
3001d6ac:	e58d1008 	str	r1, [sp, #8]
3001d6b0:	e1cd20b6 	strh	r2, [sp, #6]
3001d6b4:	e5cd3005 	strb	r3, [sp, #5]
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
3001d6b8:	e59d300c 	ldr	r3, [sp, #12]
3001d6bc:	e1d336ba 	ldrh	r3, [r3, #106]	; 0x6a
3001d6c0:	e1dd20b6 	ldrh	r2, [sp, #6]
3001d6c4:	e1520003 	cmp	r2, r3
3001d6c8:	9a000008 	bls	3001d6f0 <tcp_enqueue+0x50>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
3001d6cc:	e59d300c 	ldr	r3, [sp, #12]
3001d6d0:	e5d3301c 	ldrb	r3, [r3, #28]
3001d6d4:	e1e03c83 	mvn	r3, r3, lsl #25
3001d6d8:	e1e03ca3 	mvn	r3, r3, lsr #25
3001d6dc:	e20320ff 	and	r2, r3, #255	; 0xff
3001d6e0:	e59d300c 	ldr	r3, [sp, #12]
3001d6e4:	e5c3201c 	strb	r2, [r3, #28]
    return ERR_MEM;
3001d6e8:	e3a030ff 	mov	r3, #255	; 0xff
3001d6ec:	ea000231 	b	3001dfb8 <tcp_enqueue+0x918>
  }
  left = len;
3001d6f0:	e1dd30b6 	ldrh	r3, [sp, #6]
3001d6f4:	e1cd32b4 	strh	r3, [sp, #36]	; 0x24
  ptr = arg;
3001d6f8:	e59d3008 	ldr	r3, [sp, #8]
3001d6fc:	e58d3028 	str	r3, [sp, #40]	; 0x28

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
3001d700:	e59d300c 	ldr	r3, [sp, #12]
3001d704:	e5933064 	ldr	r3, [r3, #100]	; 0x64
3001d708:	e58d3020 	str	r3, [sp, #32]

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
3001d70c:	e59d300c 	ldr	r3, [sp, #12]
3001d710:	e1d336bc 	ldrh	r3, [r3, #108]	; 0x6c
3001d714:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
3001d718:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3001d71c:	e35300ff 	cmp	r3, #255	; 0xff
3001d720:	8a000004 	bhi	3001d738 <tcp_enqueue+0x98>
3001d724:	e1dd22be 	ldrh	r2, [sp, #46]	; 0x2e
3001d728:	e3a03cff 	mov	r3, #65280	; 0xff00
3001d72c:	e28330fc 	add	r3, r3, #252	; 0xfc
3001d730:	e1520003 	cmp	r2, r3
3001d734:	9a00000f 	bls	3001d778 <tcp_enqueue+0xd8>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
3001d738:	e59f3890 	ldr	r3, [pc, #2192]	; 3001dfd0 <tcp_enqueue+0x930>
3001d73c:	e1d33aba 	ldrh	r3, [r3, #170]	; 0xaa
3001d740:	e2833001 	add	r3, r3, #1
3001d744:	e1a03803 	lsl	r3, r3, #16
3001d748:	e1a02823 	lsr	r2, r3, #16
3001d74c:	e59f387c 	ldr	r3, [pc, #2172]	; 3001dfd0 <tcp_enqueue+0x930>
3001d750:	e1c32aba 	strh	r2, [r3, #170]	; 0xaa
    pcb->flags |= TF_NAGLEMEMERR;
3001d754:	e59d300c 	ldr	r3, [sp, #12]
3001d758:	e5d3301c 	ldrb	r3, [r3, #28]
3001d75c:	e1e03c83 	mvn	r3, r3, lsl #25
3001d760:	e1e03ca3 	mvn	r3, r3, lsr #25
3001d764:	e20320ff 	and	r2, r3, #255	; 0xff
3001d768:	e59d300c 	ldr	r3, [sp, #12]
3001d76c:	e5c3201c 	strb	r2, [r3, #28]
    return ERR_MEM;
3001d770:	e3a030ff 	mov	r3, #255	; 0xff
3001d774:	ea00020f 	b	3001dfb8 <tcp_enqueue+0x918>
      pcb->unacked == NULL && pcb->unsent == NULL);
  }

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
3001d778:	e3a03000 	mov	r3, #0
3001d77c:	e58d3014 	str	r3, [sp, #20]
3001d780:	e59d3014 	ldr	r3, [sp, #20]
3001d784:	e58d301c 	str	r3, [sp, #28]
3001d788:	e59d301c 	ldr	r3, [sp, #28]
3001d78c:	e58d3018 	str	r3, [sp, #24]
  seglen = 0;
3001d790:	e3a03000 	mov	r3, #0
3001d794:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
  while (queue == NULL || left > 0) {
3001d798:	ea000174 	b	3001dd70 <tcp_enqueue+0x6d0>

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
3001d79c:	e59d300c 	ldr	r3, [sp, #12]
3001d7a0:	e1d323b0 	ldrh	r2, [r3, #48]	; 0x30
3001d7a4:	e1dd32b4 	ldrh	r3, [sp, #36]	; 0x24
3001d7a8:	e1520003 	cmp	r2, r3
3001d7ac:	31a03002 	movcc	r3, r2
3001d7b0:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
3001d7b4:	e3a00004 	mov	r0, #4
3001d7b8:	ebffdedd 	bl	30015334 <memp_malloc>
3001d7bc:	e1a03000 	mov	r3, r0
3001d7c0:	e58d3014 	str	r3, [sp, #20]
    if (seg == NULL) {
3001d7c4:	e59d3014 	ldr	r3, [sp, #20]
3001d7c8:	e3530000 	cmp	r3, #0
3001d7cc:	0a0001de 	beq	3001df4c <tcp_enqueue+0x8ac>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
3001d7d0:	e59d3014 	ldr	r3, [sp, #20]
3001d7d4:	e3a02000 	mov	r2, #0
3001d7d8:	e5832000 	str	r2, [r3]
    seg->p = NULL;
3001d7dc:	e59d3014 	ldr	r3, [sp, #20]
3001d7e0:	e3a02000 	mov	r2, #0
3001d7e4:	e5832004 	str	r2, [r3, #4]

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
3001d7e8:	e59d301c 	ldr	r3, [sp, #28]
3001d7ec:	e3530000 	cmp	r3, #0
3001d7f0:	1a000002 	bne	3001d800 <tcp_enqueue+0x160>
      queue = seg;
3001d7f4:	e59d3014 	ldr	r3, [sp, #20]
3001d7f8:	e58d301c 	str	r3, [sp, #28]
3001d7fc:	ea000002 	b	3001d80c <tcp_enqueue+0x16c>
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
      useg->next = seg;
3001d800:	e59d3018 	ldr	r3, [sp, #24]
3001d804:	e59d2014 	ldr	r2, [sp, #20]
3001d808:	e5832000 	str	r2, [r3]
    }
    /* remember last segment of to-be-queued data for next iteration */
    useg = seg;
3001d80c:	e59d3014 	ldr	r3, [sp, #20]
3001d810:	e58d3018 	str	r3, [sp, #24]
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
3001d814:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
3001d818:	e3530000 	cmp	r3, #0
3001d81c:	0a00001a 	beq	3001d88c <tcp_enqueue+0x1ec>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
3001d820:	e5dd3048 	ldrb	r3, [sp, #72]	; 0x48
3001d824:	e3a00000 	mov	r0, #0
3001d828:	e1a01003 	mov	r1, r3
3001d82c:	e3a02000 	mov	r2, #0
3001d830:	ebffe0e0 	bl	30015bb8 <pbuf_alloc>
3001d834:	e1a02000 	mov	r2, r0
3001d838:	e59d3014 	ldr	r3, [sp, #20]
3001d83c:	e5832004 	str	r2, [r3, #4]
3001d840:	e59d3014 	ldr	r3, [sp, #20]
3001d844:	e5933004 	ldr	r3, [r3, #4]
3001d848:	e3530000 	cmp	r3, #0
3001d84c:	0a0001c0 	beq	3001df54 <tcp_enqueue+0x8b4>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
3001d850:	e59d3014 	ldr	r3, [sp, #20]
3001d854:	e5933004 	ldr	r3, [r3, #4]
3001d858:	e1a00003 	mov	r0, r3
3001d85c:	ebffe2cd 	bl	30016398 <pbuf_clen>
3001d860:	e1a03000 	mov	r3, r0
3001d864:	e1a02003 	mov	r2, r3
3001d868:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3001d86c:	e0823003 	add	r3, r2, r3
3001d870:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
      seg->dataptr = seg->p->payload;
3001d874:	e59d3014 	ldr	r3, [sp, #20]
3001d878:	e5933004 	ldr	r3, [r3, #4]
3001d87c:	e5932004 	ldr	r2, [r3, #4]
3001d880:	e59d3014 	ldr	r3, [sp, #20]
3001d884:	e5832008 	str	r2, [r3, #8]
3001d888:	ea00005b 	b	3001d9fc <tcp_enqueue+0x35c>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
3001d88c:	e5dd3040 	ldrb	r3, [sp, #64]	; 0x40
3001d890:	e2033001 	and	r3, r3, #1
3001d894:	e20330ff 	and	r3, r3, #255	; 0xff
3001d898:	e3530000 	cmp	r3, #0
3001d89c:	0a000025 	beq	3001d938 <tcp_enqueue+0x298>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
3001d8a0:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3001d8a4:	e3a00000 	mov	r0, #0
3001d8a8:	e1a01003 	mov	r1, r3
3001d8ac:	e3a02000 	mov	r2, #0
3001d8b0:	ebffe0c0 	bl	30015bb8 <pbuf_alloc>
3001d8b4:	e1a02000 	mov	r2, r0
3001d8b8:	e59d3014 	ldr	r3, [sp, #20]
3001d8bc:	e5832004 	str	r2, [r3, #4]
3001d8c0:	e59d3014 	ldr	r3, [sp, #20]
3001d8c4:	e5933004 	ldr	r3, [r3, #4]
3001d8c8:	e3530000 	cmp	r3, #0
3001d8cc:	0a0001a2 	beq	3001df5c <tcp_enqueue+0x8bc>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
3001d8d0:	e59d3014 	ldr	r3, [sp, #20]
3001d8d4:	e5933004 	ldr	r3, [r3, #4]
3001d8d8:	e1a00003 	mov	r0, r3
3001d8dc:	ebffe2ad 	bl	30016398 <pbuf_clen>
3001d8e0:	e1a03000 	mov	r3, r0
3001d8e4:	e1a02003 	mov	r2, r3
3001d8e8:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3001d8ec:	e0823003 	add	r3, r2, r3
3001d8f0:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
      if (arg != NULL) {
3001d8f4:	e59d3008 	ldr	r3, [sp, #8]
3001d8f8:	e3530000 	cmp	r3, #0
3001d8fc:	0a000007 	beq	3001d920 <tcp_enqueue+0x280>
        MEMCPY(seg->p->payload, ptr, seglen);
3001d900:	e59d3014 	ldr	r3, [sp, #20]
3001d904:	e5933004 	ldr	r3, [r3, #4]
3001d908:	e5932004 	ldr	r2, [r3, #4]
3001d90c:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3001d910:	e1a00002 	mov	r0, r2
3001d914:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3001d918:	e1a02003 	mov	r2, r3
3001d91c:	ebffba6e 	bl	3000c2dc <acoral_memcpy>
      }
      seg->dataptr = seg->p->payload;
3001d920:	e59d3014 	ldr	r3, [sp, #20]
3001d924:	e5933004 	ldr	r3, [r3, #4]
3001d928:	e5932004 	ldr	r2, [r3, #4]
3001d92c:	e59d3014 	ldr	r3, [sp, #20]
3001d930:	e5832008 	str	r2, [r3, #8]
3001d934:	ea000030 	b	3001d9fc <tcp_enqueue+0x35c>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
3001d938:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3001d93c:	e3a00000 	mov	r0, #0
3001d940:	e1a01003 	mov	r1, r3
3001d944:	e3a02001 	mov	r2, #1
3001d948:	ebffe09a 	bl	30015bb8 <pbuf_alloc>
3001d94c:	e1a03000 	mov	r3, r0
3001d950:	e58d3010 	str	r3, [sp, #16]
3001d954:	e59d3010 	ldr	r3, [sp, #16]
3001d958:	e3530000 	cmp	r3, #0
3001d95c:	0a000180 	beq	3001df64 <tcp_enqueue+0x8c4>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
3001d960:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3001d964:	e2833001 	add	r3, r3, #1
3001d968:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
      /* reference the non-volatile payload data */
      p->payload = ptr;
3001d96c:	e59d3010 	ldr	r3, [sp, #16]
3001d970:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
3001d974:	e5832004 	str	r2, [r3, #4]
      seg->dataptr = ptr;
3001d978:	e59d3014 	ldr	r3, [sp, #20]
3001d97c:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
3001d980:	e5832008 	str	r2, [r3, #8]

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
3001d984:	e3a00000 	mov	r0, #0
3001d988:	e3a01000 	mov	r1, #0
3001d98c:	e3a02000 	mov	r2, #0
3001d990:	ebffe088 	bl	30015bb8 <pbuf_alloc>
3001d994:	e1a02000 	mov	r2, r0
3001d998:	e59d3014 	ldr	r3, [sp, #20]
3001d99c:	e5832004 	str	r2, [r3, #4]
3001d9a0:	e59d3014 	ldr	r3, [sp, #20]
3001d9a4:	e5933004 	ldr	r3, [r3, #4]
3001d9a8:	e3530000 	cmp	r3, #0
3001d9ac:	1a000002 	bne	3001d9bc <tcp_enqueue+0x31c>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
3001d9b0:	e59d0010 	ldr	r0, [sp, #16]
3001d9b4:	ebffe231 	bl	30016280 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
3001d9b8:	ea00016a 	b	3001df68 <tcp_enqueue+0x8c8>
      }
      queuelen += pbuf_clen(seg->p);
3001d9bc:	e59d3014 	ldr	r3, [sp, #20]
3001d9c0:	e5933004 	ldr	r3, [r3, #4]
3001d9c4:	e1a00003 	mov	r0, r3
3001d9c8:	ebffe272 	bl	30016398 <pbuf_clen>
3001d9cc:	e1a03000 	mov	r3, r0
3001d9d0:	e1a02003 	mov	r2, r3
3001d9d4:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3001d9d8:	e0823003 	add	r3, r2, r3
3001d9dc:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
3001d9e0:	e59d3014 	ldr	r3, [sp, #20]
3001d9e4:	e5933004 	ldr	r3, [r3, #4]
3001d9e8:	e1a00003 	mov	r0, r3
3001d9ec:	e59d1010 	ldr	r1, [sp, #16]
3001d9f0:	ebffe28f 	bl	30016434 <pbuf_cat>
      p = NULL;
3001d9f4:	e3a03000 	mov	r3, #0
3001d9f8:	e58d3010 	str	r3, [sp, #16]
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
3001d9fc:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3001da00:	e3530c01 	cmp	r3, #256	; 0x100
3001da04:	8a000157 	bhi	3001df68 <tcp_enqueue+0x8c8>
3001da08:	e1dd22be 	ldrh	r2, [sp, #46]	; 0x2e
3001da0c:	e3a03cff 	mov	r3, #65280	; 0xff00
3001da10:	e28330fc 	add	r3, r3, #252	; 0xfc
3001da14:	e1520003 	cmp	r2, r3
3001da18:	8a000152 	bhi	3001df68 <tcp_enqueue+0x8c8>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
3001da1c:	e59d3014 	ldr	r3, [sp, #20]
3001da20:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
3001da24:	e1c320bc 	strh	r2, [r3, #12]

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
3001da28:	e59d3014 	ldr	r3, [sp, #20]
3001da2c:	e5933004 	ldr	r3, [r3, #4]
3001da30:	e1a00003 	mov	r0, r3
3001da34:	e3a01014 	mov	r1, #20
3001da38:	ebffe1ab 	bl	300160ec <pbuf_header>
3001da3c:	e1a03000 	mov	r3, r0
3001da40:	e3530000 	cmp	r3, #0
3001da44:	0a000007 	beq	3001da68 <tcp_enqueue+0x3c8>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
3001da48:	e59f3580 	ldr	r3, [pc, #1408]	; 3001dfd0 <tcp_enqueue+0x930>
3001da4c:	e1d33bb2 	ldrh	r3, [r3, #178]	; 0xb2
3001da50:	e2833001 	add	r3, r3, #1
3001da54:	e1a03803 	lsl	r3, r3, #16
3001da58:	e1a02823 	lsr	r2, r3, #16
3001da5c:	e59f356c 	ldr	r3, [pc, #1388]	; 3001dfd0 <tcp_enqueue+0x930>
3001da60:	e1c32bb2 	strh	r2, [r3, #178]	; 0xb2
      goto memerr;
3001da64:	ea00013f 	b	3001df68 <tcp_enqueue+0x8c8>
    }
    seg->tcphdr = seg->p->payload;
3001da68:	e59d3014 	ldr	r3, [sp, #20]
3001da6c:	e5933004 	ldr	r3, [r3, #4]
3001da70:	e5933004 	ldr	r3, [r3, #4]
3001da74:	e1a02003 	mov	r2, r3
3001da78:	e59d3014 	ldr	r3, [sp, #20]
3001da7c:	e5832010 	str	r2, [r3, #16]
    seg->tcphdr->src = htons(pcb->local_port);
3001da80:	e59d3014 	ldr	r3, [sp, #20]
3001da84:	e5934010 	ldr	r4, [r3, #16]
3001da88:	e59d300c 	ldr	r3, [sp, #12]
3001da8c:	e1d331b8 	ldrh	r3, [r3, #24]
3001da90:	e1a00003 	mov	r0, r3
3001da94:	ebffd6d9 	bl	30013600 <htons>
3001da98:	e1a03000 	mov	r3, r0
3001da9c:	e20320ff 	and	r2, r3, #255	; 0xff
3001daa0:	e3a01000 	mov	r1, #0
3001daa4:	e1812002 	orr	r2, r1, r2
3001daa8:	e5c42000 	strb	r2, [r4]
3001daac:	e1a03423 	lsr	r3, r3, #8
3001dab0:	e1a03803 	lsl	r3, r3, #16
3001dab4:	e1a03823 	lsr	r3, r3, #16
3001dab8:	e3a02000 	mov	r2, #0
3001dabc:	e1823003 	orr	r3, r2, r3
3001dac0:	e5c43001 	strb	r3, [r4, #1]
    seg->tcphdr->dest = htons(pcb->remote_port);
3001dac4:	e59d3014 	ldr	r3, [sp, #20]
3001dac8:	e5934010 	ldr	r4, [r3, #16]
3001dacc:	e59d300c 	ldr	r3, [sp, #12]
3001dad0:	e1d331ba 	ldrh	r3, [r3, #26]
3001dad4:	e1a00003 	mov	r0, r3
3001dad8:	ebffd6c8 	bl	30013600 <htons>
3001dadc:	e1a03000 	mov	r3, r0
3001dae0:	e20320ff 	and	r2, r3, #255	; 0xff
3001dae4:	e3a01000 	mov	r1, #0
3001dae8:	e1812002 	orr	r2, r1, r2
3001daec:	e5c42002 	strb	r2, [r4, #2]
3001daf0:	e1a03423 	lsr	r3, r3, #8
3001daf4:	e1a03803 	lsl	r3, r3, #16
3001daf8:	e1a03823 	lsr	r3, r3, #16
3001dafc:	e3a02000 	mov	r2, #0
3001db00:	e1823003 	orr	r3, r2, r3
3001db04:	e5c43003 	strb	r3, [r4, #3]
    seg->tcphdr->seqno = htonl(seqno);
3001db08:	e59d3014 	ldr	r3, [sp, #20]
3001db0c:	e5934010 	ldr	r4, [r3, #16]
3001db10:	e59d0020 	ldr	r0, [sp, #32]
3001db14:	ebffd6d8 	bl	3001367c <htonl>
3001db18:	e1a03000 	mov	r3, r0
3001db1c:	e20320ff 	and	r2, r3, #255	; 0xff
3001db20:	e3a01000 	mov	r1, #0
3001db24:	e1812002 	orr	r2, r1, r2
3001db28:	e5c42004 	strb	r2, [r4, #4]
3001db2c:	e1a02423 	lsr	r2, r3, #8
3001db30:	e20220ff 	and	r2, r2, #255	; 0xff
3001db34:	e3a01000 	mov	r1, #0
3001db38:	e1812002 	orr	r2, r1, r2
3001db3c:	e5c42005 	strb	r2, [r4, #5]
3001db40:	e1a02823 	lsr	r2, r3, #16
3001db44:	e20220ff 	and	r2, r2, #255	; 0xff
3001db48:	e3a01000 	mov	r1, #0
3001db4c:	e1812002 	orr	r2, r1, r2
3001db50:	e5c42006 	strb	r2, [r4, #6]
3001db54:	e1a03c23 	lsr	r3, r3, #24
3001db58:	e3a02000 	mov	r2, #0
3001db5c:	e1823003 	orr	r3, r2, r3
3001db60:	e5c43007 	strb	r3, [r4, #7]
    seg->tcphdr->urgp = 0;
3001db64:	e59d3014 	ldr	r3, [sp, #20]
3001db68:	e5933010 	ldr	r3, [r3, #16]
3001db6c:	e3a02000 	mov	r2, #0
3001db70:	e5c32012 	strb	r2, [r3, #18]
3001db74:	e3a02000 	mov	r2, #0
3001db78:	e5c32013 	strb	r2, [r3, #19]
    TCPH_FLAGS_SET(seg->tcphdr, flags);
3001db7c:	e59d3014 	ldr	r3, [sp, #20]
3001db80:	e5934010 	ldr	r4, [r3, #16]
3001db84:	e59d3014 	ldr	r3, [sp, #20]
3001db88:	e5933010 	ldr	r3, [r3, #16]
3001db8c:	e5d3200c 	ldrb	r2, [r3, #12]
3001db90:	e5d3300d 	ldrb	r3, [r3, #13]
3001db94:	e1a03403 	lsl	r3, r3, #8
3001db98:	e1833002 	orr	r3, r3, r2
3001db9c:	e1a03803 	lsl	r3, r3, #16
3001dba0:	e1a03823 	lsr	r3, r3, #16
3001dba4:	e1a00003 	mov	r0, r3
3001dba8:	ebffd6a7 	bl	3001364c <ntohs>
3001dbac:	e1a03000 	mov	r3, r0
3001dbb0:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3001dbb4:	e1a03803 	lsl	r3, r3, #16
3001dbb8:	e1a03823 	lsr	r3, r3, #16
3001dbbc:	e5dd2005 	ldrb	r2, [sp, #5]
3001dbc0:	e1833002 	orr	r3, r3, r2
3001dbc4:	e1a03803 	lsl	r3, r3, #16
3001dbc8:	e1a03823 	lsr	r3, r3, #16
3001dbcc:	e1a00003 	mov	r0, r3
3001dbd0:	ebffd68a 	bl	30013600 <htons>
3001dbd4:	e1a03000 	mov	r3, r0
3001dbd8:	e20320ff 	and	r2, r3, #255	; 0xff
3001dbdc:	e3a01000 	mov	r1, #0
3001dbe0:	e1812002 	orr	r2, r1, r2
3001dbe4:	e5c4200c 	strb	r2, [r4, #12]
3001dbe8:	e1a03423 	lsr	r3, r3, #8
3001dbec:	e1a03803 	lsl	r3, r3, #16
3001dbf0:	e1a03823 	lsr	r3, r3, #16
3001dbf4:	e3a02000 	mov	r2, #0
3001dbf8:	e1823003 	orr	r3, r2, r3
3001dbfc:	e5c4300d 	strb	r3, [r4, #13]
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
3001dc00:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
3001dc04:	e3530000 	cmp	r3, #0
3001dc08:	1a00001e 	bne	3001dc88 <tcp_enqueue+0x5e8>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
3001dc0c:	e59d3014 	ldr	r3, [sp, #20]
3001dc10:	e5934010 	ldr	r4, [r3, #16]
3001dc14:	e59d3014 	ldr	r3, [sp, #20]
3001dc18:	e5933010 	ldr	r3, [r3, #16]
3001dc1c:	e5d3200c 	ldrb	r2, [r3, #12]
3001dc20:	e5d3300d 	ldrb	r3, [r3, #13]
3001dc24:	e1a03403 	lsl	r3, r3, #8
3001dc28:	e1833002 	orr	r3, r3, r2
3001dc2c:	e1a03803 	lsl	r3, r3, #16
3001dc30:	e1a03823 	lsr	r3, r3, #16
3001dc34:	e1a00003 	mov	r0, r3
3001dc38:	ebffd683 	bl	3001364c <ntohs>
3001dc3c:	e1a03000 	mov	r3, r0
3001dc40:	e203303f 	and	r3, r3, #63	; 0x3f
3001dc44:	e3833a05 	orr	r3, r3, #20480	; 0x5000
3001dc48:	e1a03803 	lsl	r3, r3, #16
3001dc4c:	e1a03823 	lsr	r3, r3, #16
3001dc50:	e1a00003 	mov	r0, r3
3001dc54:	ebffd669 	bl	30013600 <htons>
3001dc58:	e1a03000 	mov	r3, r0
3001dc5c:	e20320ff 	and	r2, r3, #255	; 0xff
3001dc60:	e3a01000 	mov	r1, #0
3001dc64:	e1812002 	orr	r2, r1, r2
3001dc68:	e5c4200c 	strb	r2, [r4, #12]
3001dc6c:	e1a03423 	lsr	r3, r3, #8
3001dc70:	e1a03803 	lsl	r3, r3, #16
3001dc74:	e1a03823 	lsr	r3, r3, #16
3001dc78:	e3a02000 	mov	r2, #0
3001dc7c:	e1823003 	orr	r3, r2, r3
3001dc80:	e5c4300d 	strb	r3, [r4, #13]
3001dc84:	ea00002d 	b	3001dd40 <tcp_enqueue+0x6a0>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
3001dc88:	e59d3014 	ldr	r3, [sp, #20]
3001dc8c:	e5934010 	ldr	r4, [r3, #16]
3001dc90:	e5dd3048 	ldrb	r3, [sp, #72]	; 0x48
3001dc94:	e1a03123 	lsr	r3, r3, #2
3001dc98:	e20330ff 	and	r3, r3, #255	; 0xff
3001dc9c:	e2833005 	add	r3, r3, #5
3001dca0:	e1a03803 	lsl	r3, r3, #16
3001dca4:	e1a03823 	lsr	r3, r3, #16
3001dca8:	e1a03603 	lsl	r3, r3, #12
3001dcac:	e1a03803 	lsl	r3, r3, #16
3001dcb0:	e1a05823 	lsr	r5, r3, #16
3001dcb4:	e59d3014 	ldr	r3, [sp, #20]
3001dcb8:	e5933010 	ldr	r3, [r3, #16]
3001dcbc:	e5d3200c 	ldrb	r2, [r3, #12]
3001dcc0:	e5d3300d 	ldrb	r3, [r3, #13]
3001dcc4:	e1a03403 	lsl	r3, r3, #8
3001dcc8:	e1833002 	orr	r3, r3, r2
3001dccc:	e1a03803 	lsl	r3, r3, #16
3001dcd0:	e1a03823 	lsr	r3, r3, #16
3001dcd4:	e1a00003 	mov	r0, r3
3001dcd8:	ebffd65b 	bl	3001364c <ntohs>
3001dcdc:	e1a03000 	mov	r3, r0
3001dce0:	e203303f 	and	r3, r3, #63	; 0x3f
3001dce4:	e1853003 	orr	r3, r5, r3
3001dce8:	e1a03803 	lsl	r3, r3, #16
3001dcec:	e1a03823 	lsr	r3, r3, #16
3001dcf0:	e1a00003 	mov	r0, r3
3001dcf4:	ebffd641 	bl	30013600 <htons>
3001dcf8:	e1a03000 	mov	r3, r0
3001dcfc:	e20320ff 	and	r2, r3, #255	; 0xff
3001dd00:	e3a01000 	mov	r1, #0
3001dd04:	e1812002 	orr	r2, r1, r2
3001dd08:	e5c4200c 	strb	r2, [r4, #12]
3001dd0c:	e1a03423 	lsr	r3, r3, #8
3001dd10:	e1a03803 	lsl	r3, r3, #16
3001dd14:	e1a03823 	lsr	r3, r3, #16
3001dd18:	e3a02000 	mov	r2, #0
3001dd1c:	e1823003 	orr	r3, r2, r3
3001dd20:	e5c4300d 	strb	r3, [r4, #13]
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
3001dd24:	e59d3014 	ldr	r3, [sp, #20]
3001dd28:	e5932008 	ldr	r2, [r3, #8]
3001dd2c:	e5dd3048 	ldrb	r3, [sp, #72]	; 0x48
3001dd30:	e1a00002 	mov	r0, r2
3001dd34:	e59d1044 	ldr	r1, [sp, #68]	; 0x44
3001dd38:	e1a02003 	mov	r2, r3
3001dd3c:	ebffb966 	bl	3000c2dc <acoral_memcpy>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
3001dd40:	e1dd22b4 	ldrh	r2, [sp, #36]	; 0x24
3001dd44:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3001dd48:	e0633002 	rsb	r3, r3, r2
3001dd4c:	e1cd32b4 	strh	r3, [sp, #36]	; 0x24
    seqno += seglen;
3001dd50:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3001dd54:	e59d2020 	ldr	r2, [sp, #32]
3001dd58:	e0823003 	add	r3, r2, r3
3001dd5c:	e58d3020 	str	r3, [sp, #32]
    ptr = (void *)((u8_t *)ptr + seglen);
3001dd60:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3001dd64:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
3001dd68:	e0823003 	add	r3, r2, r3
3001dd6c:	e58d3028 	str	r3, [sp, #40]	; 0x28

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
3001dd70:	e59d301c 	ldr	r3, [sp, #28]
3001dd74:	e3530000 	cmp	r3, #0
3001dd78:	0afffe87 	beq	3001d79c <tcp_enqueue+0xfc>
3001dd7c:	e1dd32b4 	ldrh	r3, [sp, #36]	; 0x24
3001dd80:	e3530000 	cmp	r3, #0
3001dd84:	1afffe84 	bne	3001d79c <tcp_enqueue+0xfc>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
3001dd88:	e59d300c 	ldr	r3, [sp, #12]
3001dd8c:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001dd90:	e3530000 	cmp	r3, #0
3001dd94:	1a000002 	bne	3001dda4 <tcp_enqueue+0x704>
    useg = NULL;
3001dd98:	e3a03000 	mov	r3, #0
3001dd9c:	e58d3018 	str	r3, [sp, #24]
3001dda0:	ea00000a 	b	3001ddd0 <tcp_enqueue+0x730>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
3001dda4:	e59d300c 	ldr	r3, [sp, #12]
3001dda8:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001ddac:	e58d3018 	str	r3, [sp, #24]
3001ddb0:	ea000002 	b	3001ddc0 <tcp_enqueue+0x720>
3001ddb4:	e59d3018 	ldr	r3, [sp, #24]
3001ddb8:	e5933000 	ldr	r3, [r3]
3001ddbc:	e58d3018 	str	r3, [sp, #24]
3001ddc0:	e59d3018 	ldr	r3, [sp, #24]
3001ddc4:	e5933000 	ldr	r3, [r3]
3001ddc8:	e3530000 	cmp	r3, #0
3001ddcc:	1afffff8 	bne	3001ddb4 <tcp_enqueue+0x714>
    }
    memp_free(MEMP_TCP_SEG, queue);
  }
  else {*/
    /* empty list */
    if (useg == NULL) {
3001ddd0:	e59d3018 	ldr	r3, [sp, #24]
3001ddd4:	e3530000 	cmp	r3, #0
3001ddd8:	1a000003 	bne	3001ddec <tcp_enqueue+0x74c>
      /* initialize list with this segment */
      pcb->unsent = queue;
3001dddc:	e59d300c 	ldr	r3, [sp, #12]
3001dde0:	e59d201c 	ldr	r2, [sp, #28]
3001dde4:	e5832070 	str	r2, [r3, #112]	; 0x70
3001dde8:	ea000002 	b	3001ddf8 <tcp_enqueue+0x758>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
3001ddec:	e59d3018 	ldr	r3, [sp, #24]
3001ddf0:	e59d201c 	ldr	r2, [sp, #28]
3001ddf4:	e5832000 	str	r2, [r3]
    }
 // }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
3001ddf8:	e5dd3005 	ldrb	r3, [sp, #5]
3001ddfc:	e2033002 	and	r3, r3, #2
3001de00:	e3530000 	cmp	r3, #0
3001de04:	1a000004 	bne	3001de1c <tcp_enqueue+0x77c>
3001de08:	e5dd3005 	ldrb	r3, [sp, #5]
3001de0c:	e2033001 	and	r3, r3, #1
3001de10:	e20330ff 	and	r3, r3, #255	; 0xff
3001de14:	e3530000 	cmp	r3, #0
3001de18:	0a000002 	beq	3001de28 <tcp_enqueue+0x788>
    ++len;
3001de1c:	e1dd30b6 	ldrh	r3, [sp, #6]
3001de20:	e2833001 	add	r3, r3, #1
3001de24:	e1cd30b6 	strh	r3, [sp, #6]
  }
  if (flags & TCP_FIN) {
3001de28:	e5dd3005 	ldrb	r3, [sp, #5]
3001de2c:	e2033001 	and	r3, r3, #1
3001de30:	e20330ff 	and	r3, r3, #255	; 0xff
3001de34:	e3530000 	cmp	r3, #0
3001de38:	0a000005 	beq	3001de54 <tcp_enqueue+0x7b4>
    pcb->flags |= TF_FIN;
3001de3c:	e59d300c 	ldr	r3, [sp, #12]
3001de40:	e5d3301c 	ldrb	r3, [r3, #28]
3001de44:	e3833020 	orr	r3, r3, #32
3001de48:	e20320ff 	and	r2, r3, #255	; 0xff
3001de4c:	e59d300c 	ldr	r3, [sp, #12]
3001de50:	e5c3201c 	strb	r2, [r3, #28]
  }
  pcb->snd_lbb += len;
3001de54:	e59d300c 	ldr	r3, [sp, #12]
3001de58:	e5932064 	ldr	r2, [r3, #100]	; 0x64
3001de5c:	e1dd30b6 	ldrh	r3, [sp, #6]
3001de60:	e0822003 	add	r2, r2, r3
3001de64:	e59d300c 	ldr	r3, [sp, #12]
3001de68:	e5832064 	str	r2, [r3, #100]	; 0x64

  pcb->snd_buf -= len;
3001de6c:	e59d300c 	ldr	r3, [sp, #12]
3001de70:	e1d326ba 	ldrh	r2, [r3, #106]	; 0x6a
3001de74:	e1dd30b6 	ldrh	r3, [sp, #6]
3001de78:	e0633002 	rsb	r3, r3, r2
3001de7c:	e1a03803 	lsl	r3, r3, #16
3001de80:	e1a02823 	lsr	r2, r3, #16
3001de84:	e59d300c 	ldr	r3, [sp, #12]
3001de88:	e1c326ba 	strh	r2, [r3, #106]	; 0x6a

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
3001de8c:	e59d300c 	ldr	r3, [sp, #12]
3001de90:	e1dd22be 	ldrh	r2, [sp, #46]	; 0x2e
3001de94:	e1c326bc 	strh	r2, [r3, #108]	; 0x6c
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
3001de98:	e59d3014 	ldr	r3, [sp, #20]
3001de9c:	e3530000 	cmp	r3, #0
3001dea0:	0a000027 	beq	3001df44 <tcp_enqueue+0x8a4>
3001dea4:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
3001dea8:	e3530000 	cmp	r3, #0
3001deac:	0a000024 	beq	3001df44 <tcp_enqueue+0x8a4>
3001deb0:	e59d3014 	ldr	r3, [sp, #20]
3001deb4:	e5933010 	ldr	r3, [r3, #16]
3001deb8:	e3530000 	cmp	r3, #0
3001debc:	0a000020 	beq	3001df44 <tcp_enqueue+0x8a4>
3001dec0:	e5dd3040 	ldrb	r3, [sp, #64]	; 0x40
3001dec4:	e2033002 	and	r3, r3, #2
3001dec8:	e3530000 	cmp	r3, #0
3001decc:	1a00001c 	bne	3001df44 <tcp_enqueue+0x8a4>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
3001ded0:	e59d3014 	ldr	r3, [sp, #20]
3001ded4:	e5934010 	ldr	r4, [r3, #16]
3001ded8:	e59d3014 	ldr	r3, [sp, #20]
3001dedc:	e5933010 	ldr	r3, [r3, #16]
3001dee0:	e5d3200c 	ldrb	r2, [r3, #12]
3001dee4:	e5d3300d 	ldrb	r3, [r3, #13]
3001dee8:	e1a03403 	lsl	r3, r3, #8
3001deec:	e1833002 	orr	r3, r3, r2
3001def0:	e1a03803 	lsl	r3, r3, #16
3001def4:	e1a03823 	lsr	r3, r3, #16
3001def8:	e1a00003 	mov	r0, r3
3001defc:	ebffd5d2 	bl	3001364c <ntohs>
3001df00:	e1a03000 	mov	r3, r0
3001df04:	e3833008 	orr	r3, r3, #8
3001df08:	e1a03803 	lsl	r3, r3, #16
3001df0c:	e1a03823 	lsr	r3, r3, #16
3001df10:	e1a00003 	mov	r0, r3
3001df14:	ebffd5b9 	bl	30013600 <htons>
3001df18:	e1a03000 	mov	r3, r0
3001df1c:	e20320ff 	and	r2, r3, #255	; 0xff
3001df20:	e3a01000 	mov	r1, #0
3001df24:	e1812002 	orr	r2, r1, r2
3001df28:	e5c4200c 	strb	r2, [r4, #12]
3001df2c:	e1a03423 	lsr	r3, r3, #8
3001df30:	e1a03803 	lsl	r3, r3, #16
3001df34:	e1a03823 	lsr	r3, r3, #16
3001df38:	e3a02000 	mov	r2, #0
3001df3c:	e1823003 	orr	r3, r2, r3
3001df40:	e5c4300d 	strb	r3, [r4, #13]
  }

  return ERR_OK;
3001df44:	e3a03000 	mov	r3, #0
3001df48:	ea00001a 	b	3001dfb8 <tcp_enqueue+0x918>

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
    if (seg == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
3001df4c:	e1a00000 	nop			; (mov r0, r0)
3001df50:	ea000004 	b	3001df68 <tcp_enqueue+0x8c8>
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
        goto memerr;
3001df54:	e1a00000 	nop			; (mov r0, r0)
3001df58:	ea000002 	b	3001df68 <tcp_enqueue+0x8c8>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
3001df5c:	e1a00000 	nop			; (mov r0, r0)
3001df60:	ea000000 	b	3001df68 <tcp_enqueue+0x8c8>
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
3001df64:	e1a00000 	nop			; (mov r0, r0)
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
3001df68:	e59d300c 	ldr	r3, [sp, #12]
3001df6c:	e5d3301c 	ldrb	r3, [r3, #28]
3001df70:	e1e03c83 	mvn	r3, r3, lsl #25
3001df74:	e1e03ca3 	mvn	r3, r3, lsr #25
3001df78:	e20320ff 	and	r2, r3, #255	; 0xff
3001df7c:	e59d300c 	ldr	r3, [sp, #12]
3001df80:	e5c3201c 	strb	r2, [r3, #28]
  TCP_STATS_INC(tcp.memerr);
3001df84:	e59f3044 	ldr	r3, [pc, #68]	; 3001dfd0 <tcp_enqueue+0x930>
3001df88:	e1d33aba 	ldrh	r3, [r3, #170]	; 0xaa
3001df8c:	e2833001 	add	r3, r3, #1
3001df90:	e1a03803 	lsl	r3, r3, #16
3001df94:	e1a02823 	lsr	r2, r3, #16
3001df98:	e59f3030 	ldr	r3, [pc, #48]	; 3001dfd0 <tcp_enqueue+0x930>
3001df9c:	e1c32aba 	strh	r2, [r3, #170]	; 0xaa

  if (queue != NULL) {
3001dfa0:	e59d301c 	ldr	r3, [sp, #28]
3001dfa4:	e3530000 	cmp	r3, #0
3001dfa8:	0a000001 	beq	3001dfb4 <tcp_enqueue+0x914>
    tcp_segs_free(queue);
3001dfac:	e59d001c 	ldr	r0, [sp, #28]
3001dfb0:	ebffeb33 	bl	30018c84 <tcp_segs_free>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
3001dfb4:	e3a030ff 	mov	r3, #255	; 0xff
3001dfb8:	e1a03c03 	lsl	r3, r3, #24
3001dfbc:	e1a03c43 	asr	r3, r3, #24
}
3001dfc0:	e1a00003 	mov	r0, r3
3001dfc4:	e28dd034 	add	sp, sp, #52	; 0x34
3001dfc8:	e8bd4030 	pop	{r4, r5, lr}
3001dfcc:	e12fff1e 	bx	lr
3001dfd0:	302be570 	.word	0x302be570

3001dfd4 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
3001dfd4:	e92d4030 	push	{r4, r5, lr}
3001dfd8:	e24dd02c 	sub	sp, sp, #44	; 0x2c
3001dfdc:	e58d000c 	str	r0, [sp, #12]

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
3001dfe0:	e59f3998 	ldr	r3, [pc, #2456]	; 3001e980 <tcp_output+0x9ac>
3001dfe4:	e5932000 	ldr	r2, [r3]
3001dfe8:	e59d300c 	ldr	r3, [sp, #12]
3001dfec:	e1520003 	cmp	r2, r3
3001dff0:	1a000001 	bne	3001dffc <tcp_output+0x28>
    //acoral_prints("\r\n==output--0\r\n");
    return ERR_OK;
3001dff4:	e3a03000 	mov	r3, #0
3001dff8:	ea00025a 	b	3001e968 <tcp_output+0x994>
  }
  //acoral_prints("\r\n==output--1\r\n");
  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
3001dffc:	e59d300c 	ldr	r3, [sp, #12]
3001e000:	e1d324ba 	ldrh	r2, [r3, #74]	; 0x4a
3001e004:	e59d300c 	ldr	r3, [sp, #12]
3001e008:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
3001e00c:	e1520003 	cmp	r2, r3
3001e010:	31a03002 	movcc	r3, r2
3001e014:	e1a03803 	lsl	r3, r3, #16
3001e018:	e1a03823 	lsr	r3, r3, #16
3001e01c:	e58d3024 	str	r3, [sp, #36]	; 0x24

  seg = pcb->unsent;
3001e020:	e59d300c 	ldr	r3, [sp, #12]
3001e024:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001e028:	e58d301c 	str	r3, [sp, #28]

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
3001e02c:	e59d300c 	ldr	r3, [sp, #12]
3001e030:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001e034:	e58d3020 	str	r3, [sp, #32]
  if (useg != NULL) {
3001e038:	e59d3020 	ldr	r3, [sp, #32]
3001e03c:	e3530000 	cmp	r3, #0
3001e040:	0a000007 	beq	3001e064 <tcp_output+0x90>
    //acoral_prints("\r\n==output--2\r\n");
    for (; useg->next != NULL; useg = useg->next);
3001e044:	ea000002 	b	3001e054 <tcp_output+0x80>
3001e048:	e59d3020 	ldr	r3, [sp, #32]
3001e04c:	e5933000 	ldr	r3, [r3]
3001e050:	e58d3020 	str	r3, [sp, #32]
3001e054:	e59d3020 	ldr	r3, [sp, #32]
3001e058:	e5933000 	ldr	r3, [r3]
3001e05c:	e3530000 	cmp	r3, #0
3001e060:	1afffff8 	bne	3001e048 <tcp_output+0x74>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
3001e064:	e59d300c 	ldr	r3, [sp, #12]
3001e068:	e5d3301c 	ldrb	r3, [r3, #28]
3001e06c:	e2033002 	and	r3, r3, #2
3001e070:	e3530000 	cmp	r3, #0
3001e074:	0a0001f0 	beq	3001e83c <tcp_output+0x868>
3001e078:	e59d301c 	ldr	r3, [sp, #28]
3001e07c:	e3530000 	cmp	r3, #0
3001e080:	0a000017 	beq	3001e0e4 <tcp_output+0x110>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
3001e084:	e59d301c 	ldr	r3, [sp, #28]
3001e088:	e5933010 	ldr	r3, [r3, #16]
3001e08c:	e5d32004 	ldrb	r2, [r3, #4]
3001e090:	e5d31005 	ldrb	r1, [r3, #5]
3001e094:	e1a01401 	lsl	r1, r1, #8
3001e098:	e1812002 	orr	r2, r1, r2
3001e09c:	e5d31006 	ldrb	r1, [r3, #6]
3001e0a0:	e1a01801 	lsl	r1, r1, #16
3001e0a4:	e1812002 	orr	r2, r1, r2
3001e0a8:	e5d33007 	ldrb	r3, [r3, #7]
3001e0ac:	e1a03c03 	lsl	r3, r3, #24
3001e0b0:	e1833002 	orr	r3, r3, r2
3001e0b4:	e1a00003 	mov	r0, r3
3001e0b8:	ebffd581 	bl	300136c4 <ntohl>
3001e0bc:	e1a02000 	mov	r2, r0
3001e0c0:	e59d300c 	ldr	r3, [sp, #12]
3001e0c4:	e5933044 	ldr	r3, [r3, #68]	; 0x44
3001e0c8:	e0632002 	rsb	r2, r3, r2
3001e0cc:	e59d301c 	ldr	r3, [sp, #28]
3001e0d0:	e1d330bc 	ldrh	r3, [r3, #12]
3001e0d4:	e0822003 	add	r2, r2, r3
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
3001e0d8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001e0dc:	e1520003 	cmp	r2, r3
3001e0e0:	9a0001d5 	bls	3001e83c <tcp_output+0x868>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
3001e0e4:	e3a00001 	mov	r0, #1
3001e0e8:	e3a01014 	mov	r1, #20
3001e0ec:	e3a02000 	mov	r2, #0
3001e0f0:	ebffdeb0 	bl	30015bb8 <pbuf_alloc>
3001e0f4:	e1a03000 	mov	r3, r0
3001e0f8:	e58d3014 	str	r3, [sp, #20]
    //acoral_prints("\r\n==output--3\r\n");
    if (p == NULL) {
3001e0fc:	e59d3014 	ldr	r3, [sp, #20]
3001e100:	e3530000 	cmp	r3, #0
3001e104:	1a000001 	bne	3001e110 <tcp_output+0x13c>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
3001e108:	e3a030fe 	mov	r3, #254	; 0xfe
3001e10c:	ea000215 	b	3001e968 <tcp_output+0x994>
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
3001e110:	e59d300c 	ldr	r3, [sp, #12]
3001e114:	e5d3301c 	ldrb	r3, [r3, #28]
3001e118:	e20330fc 	and	r3, r3, #252	; 0xfc
3001e11c:	e59d200c 	ldr	r2, [sp, #12]
3001e120:	e5c2301c 	strb	r3, [r2, #28]

    tcphdr = p->payload;
3001e124:	e59d3014 	ldr	r3, [sp, #20]
3001e128:	e5933004 	ldr	r3, [r3, #4]
3001e12c:	e58d3018 	str	r3, [sp, #24]
    tcphdr->src = htons(pcb->local_port);
3001e130:	e59d300c 	ldr	r3, [sp, #12]
3001e134:	e1d331b8 	ldrh	r3, [r3, #24]
3001e138:	e1a00003 	mov	r0, r3
3001e13c:	ebffd52f 	bl	30013600 <htons>
3001e140:	e1a03000 	mov	r3, r0
3001e144:	e1a02003 	mov	r2, r3
3001e148:	e59d3018 	ldr	r3, [sp, #24]
3001e14c:	e20210ff 	and	r1, r2, #255	; 0xff
3001e150:	e3a00000 	mov	r0, #0
3001e154:	e1801001 	orr	r1, r0, r1
3001e158:	e5c31000 	strb	r1, [r3]
3001e15c:	e1a02422 	lsr	r2, r2, #8
3001e160:	e1a02802 	lsl	r2, r2, #16
3001e164:	e1a02822 	lsr	r2, r2, #16
3001e168:	e3a01000 	mov	r1, #0
3001e16c:	e1812002 	orr	r2, r1, r2
3001e170:	e5c32001 	strb	r2, [r3, #1]
    tcphdr->dest = htons(pcb->remote_port);
3001e174:	e59d300c 	ldr	r3, [sp, #12]
3001e178:	e1d331ba 	ldrh	r3, [r3, #26]
3001e17c:	e1a00003 	mov	r0, r3
3001e180:	ebffd51e 	bl	30013600 <htons>
3001e184:	e1a03000 	mov	r3, r0
3001e188:	e1a02003 	mov	r2, r3
3001e18c:	e59d3018 	ldr	r3, [sp, #24]
3001e190:	e20210ff 	and	r1, r2, #255	; 0xff
3001e194:	e3a00000 	mov	r0, #0
3001e198:	e1801001 	orr	r1, r0, r1
3001e19c:	e5c31002 	strb	r1, [r3, #2]
3001e1a0:	e1a02422 	lsr	r2, r2, #8
3001e1a4:	e1a02802 	lsl	r2, r2, #16
3001e1a8:	e1a02822 	lsr	r2, r2, #16
3001e1ac:	e3a01000 	mov	r1, #0
3001e1b0:	e1812002 	orr	r2, r1, r2
3001e1b4:	e5c32003 	strb	r2, [r3, #3]
    tcphdr->seqno = htonl(pcb->snd_nxt);
3001e1b8:	e59d300c 	ldr	r3, [sp, #12]
3001e1bc:	e5933050 	ldr	r3, [r3, #80]	; 0x50
3001e1c0:	e1a00003 	mov	r0, r3
3001e1c4:	ebffd52c 	bl	3001367c <htonl>
3001e1c8:	e1a02000 	mov	r2, r0
3001e1cc:	e59d3018 	ldr	r3, [sp, #24]
3001e1d0:	e20210ff 	and	r1, r2, #255	; 0xff
3001e1d4:	e3a00000 	mov	r0, #0
3001e1d8:	e1801001 	orr	r1, r0, r1
3001e1dc:	e5c31004 	strb	r1, [r3, #4]
3001e1e0:	e1a01422 	lsr	r1, r2, #8
3001e1e4:	e20110ff 	and	r1, r1, #255	; 0xff
3001e1e8:	e3a00000 	mov	r0, #0
3001e1ec:	e1801001 	orr	r1, r0, r1
3001e1f0:	e5c31005 	strb	r1, [r3, #5]
3001e1f4:	e1a01822 	lsr	r1, r2, #16
3001e1f8:	e20110ff 	and	r1, r1, #255	; 0xff
3001e1fc:	e3a00000 	mov	r0, #0
3001e200:	e1801001 	orr	r1, r0, r1
3001e204:	e5c31006 	strb	r1, [r3, #6]
3001e208:	e1a02c22 	lsr	r2, r2, #24
3001e20c:	e3a01000 	mov	r1, #0
3001e210:	e1812002 	orr	r2, r1, r2
3001e214:	e5c32007 	strb	r2, [r3, #7]
    tcphdr->ackno = htonl(pcb->rcv_nxt);
3001e218:	e59d300c 	ldr	r3, [sp, #12]
3001e21c:	e5933020 	ldr	r3, [r3, #32]
3001e220:	e1a00003 	mov	r0, r3
3001e224:	ebffd514 	bl	3001367c <htonl>
3001e228:	e1a02000 	mov	r2, r0
3001e22c:	e59d3018 	ldr	r3, [sp, #24]
3001e230:	e20210ff 	and	r1, r2, #255	; 0xff
3001e234:	e3a00000 	mov	r0, #0
3001e238:	e1801001 	orr	r1, r0, r1
3001e23c:	e5c31008 	strb	r1, [r3, #8]
3001e240:	e1a01422 	lsr	r1, r2, #8
3001e244:	e20110ff 	and	r1, r1, #255	; 0xff
3001e248:	e3a00000 	mov	r0, #0
3001e24c:	e1801001 	orr	r1, r0, r1
3001e250:	e5c31009 	strb	r1, [r3, #9]
3001e254:	e1a01822 	lsr	r1, r2, #16
3001e258:	e20110ff 	and	r1, r1, #255	; 0xff
3001e25c:	e3a00000 	mov	r0, #0
3001e260:	e1801001 	orr	r1, r0, r1
3001e264:	e5c3100a 	strb	r1, [r3, #10]
3001e268:	e1a02c22 	lsr	r2, r2, #24
3001e26c:	e3a01000 	mov	r1, #0
3001e270:	e1812002 	orr	r2, r1, r2
3001e274:	e5c3200b 	strb	r2, [r3, #11]
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
3001e278:	e59d3018 	ldr	r3, [sp, #24]
3001e27c:	e5d3200c 	ldrb	r2, [r3, #12]
3001e280:	e5d3300d 	ldrb	r3, [r3, #13]
3001e284:	e1a03403 	lsl	r3, r3, #8
3001e288:	e1833002 	orr	r3, r3, r2
3001e28c:	e1a03803 	lsl	r3, r3, #16
3001e290:	e1a03823 	lsr	r3, r3, #16
3001e294:	e1a00003 	mov	r0, r3
3001e298:	ebffd4eb 	bl	3001364c <ntohs>
3001e29c:	e1a03000 	mov	r3, r0
3001e2a0:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3001e2a4:	e1a03803 	lsl	r3, r3, #16
3001e2a8:	e1a03823 	lsr	r3, r3, #16
3001e2ac:	e3833010 	orr	r3, r3, #16
3001e2b0:	e1a03803 	lsl	r3, r3, #16
3001e2b4:	e1a03823 	lsr	r3, r3, #16
3001e2b8:	e1a00003 	mov	r0, r3
3001e2bc:	ebffd4cf 	bl	30013600 <htons>
3001e2c0:	e1a03000 	mov	r3, r0
3001e2c4:	e1a02003 	mov	r2, r3
3001e2c8:	e59d3018 	ldr	r3, [sp, #24]
3001e2cc:	e20210ff 	and	r1, r2, #255	; 0xff
3001e2d0:	e3a00000 	mov	r0, #0
3001e2d4:	e1801001 	orr	r1, r0, r1
3001e2d8:	e5c3100c 	strb	r1, [r3, #12]
3001e2dc:	e1a02422 	lsr	r2, r2, #8
3001e2e0:	e1a02802 	lsl	r2, r2, #16
3001e2e4:	e1a02822 	lsr	r2, r2, #16
3001e2e8:	e3a01000 	mov	r1, #0
3001e2ec:	e1812002 	orr	r2, r1, r2
3001e2f0:	e5c3200d 	strb	r2, [r3, #13]
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
3001e2f4:	e59d300c 	ldr	r3, [sp, #12]
3001e2f8:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
3001e2fc:	e1a00003 	mov	r0, r3
3001e300:	ebffd4be 	bl	30013600 <htons>
3001e304:	e1a03000 	mov	r3, r0
3001e308:	e1a02003 	mov	r2, r3
3001e30c:	e59d3018 	ldr	r3, [sp, #24]
3001e310:	e20210ff 	and	r1, r2, #255	; 0xff
3001e314:	e3a00000 	mov	r0, #0
3001e318:	e1801001 	orr	r1, r0, r1
3001e31c:	e5c3100e 	strb	r1, [r3, #14]
3001e320:	e1a02422 	lsr	r2, r2, #8
3001e324:	e1a02802 	lsl	r2, r2, #16
3001e328:	e1a02822 	lsr	r2, r2, #16
3001e32c:	e3a01000 	mov	r1, #0
3001e330:	e1812002 	orr	r2, r1, r2
3001e334:	e5c3200f 	strb	r2, [r3, #15]
    tcphdr->urgp = 0;
3001e338:	e59d3018 	ldr	r3, [sp, #24]
3001e33c:	e3a02000 	mov	r2, #0
3001e340:	e5c32012 	strb	r2, [r3, #18]
3001e344:	e3a02000 	mov	r2, #0
3001e348:	e5c32013 	strb	r2, [r3, #19]
    TCPH_HDRLEN_SET(tcphdr, 5);
3001e34c:	e59d3018 	ldr	r3, [sp, #24]
3001e350:	e5d3200c 	ldrb	r2, [r3, #12]
3001e354:	e5d3300d 	ldrb	r3, [r3, #13]
3001e358:	e1a03403 	lsl	r3, r3, #8
3001e35c:	e1833002 	orr	r3, r3, r2
3001e360:	e1a03803 	lsl	r3, r3, #16
3001e364:	e1a03823 	lsr	r3, r3, #16
3001e368:	e1a00003 	mov	r0, r3
3001e36c:	ebffd4b6 	bl	3001364c <ntohs>
3001e370:	e1a03000 	mov	r3, r0
3001e374:	e203303f 	and	r3, r3, #63	; 0x3f
3001e378:	e3833a05 	orr	r3, r3, #20480	; 0x5000
3001e37c:	e1a03803 	lsl	r3, r3, #16
3001e380:	e1a03823 	lsr	r3, r3, #16
3001e384:	e1a00003 	mov	r0, r3
3001e388:	ebffd49c 	bl	30013600 <htons>
3001e38c:	e1a03000 	mov	r3, r0
3001e390:	e1a02003 	mov	r2, r3
3001e394:	e59d3018 	ldr	r3, [sp, #24]
3001e398:	e20210ff 	and	r1, r2, #255	; 0xff
3001e39c:	e3a00000 	mov	r0, #0
3001e3a0:	e1801001 	orr	r1, r0, r1
3001e3a4:	e5c3100c 	strb	r1, [r3, #12]
3001e3a8:	e1a02422 	lsr	r2, r2, #8
3001e3ac:	e1a02802 	lsl	r2, r2, #16
3001e3b0:	e1a02822 	lsr	r2, r2, #16
3001e3b4:	e3a01000 	mov	r1, #0
3001e3b8:	e1812002 	orr	r2, r1, r2
3001e3bc:	e5c3200d 	strb	r2, [r3, #13]

    tcphdr->chksum = 0;
3001e3c0:	e59d3018 	ldr	r3, [sp, #24]
3001e3c4:	e3a02000 	mov	r2, #0
3001e3c8:	e5c32010 	strb	r2, [r3, #16]
3001e3cc:	e3a02000 	mov	r2, #0
3001e3d0:	e5c32011 	strb	r2, [r3, #17]
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
3001e3d4:	e59d200c 	ldr	r2, [sp, #12]
3001e3d8:	e59d300c 	ldr	r3, [sp, #12]
3001e3dc:	e2833004 	add	r3, r3, #4
3001e3e0:	e59d1014 	ldr	r1, [sp, #20]
3001e3e4:	e1d110b8 	ldrh	r1, [r1, #8]
3001e3e8:	e58d1000 	str	r1, [sp]
3001e3ec:	e59d0014 	ldr	r0, [sp, #20]
3001e3f0:	e1a01002 	mov	r1, r2
3001e3f4:	e1a02003 	mov	r2, r3
3001e3f8:	e3a03006 	mov	r3, #6
3001e3fc:	ebffd506 	bl	3001381c <inet_chksum_pseudo>
3001e400:	e1a03000 	mov	r3, r0
3001e404:	e1a02003 	mov	r2, r3
3001e408:	e59d3018 	ldr	r3, [sp, #24]
3001e40c:	e20210ff 	and	r1, r2, #255	; 0xff
3001e410:	e3a00000 	mov	r0, #0
3001e414:	e1801001 	orr	r1, r0, r1
3001e418:	e5c31010 	strb	r1, [r3, #16]
3001e41c:	e1a02422 	lsr	r2, r2, #8
3001e420:	e1a02802 	lsl	r2, r2, #16
3001e424:	e1a02822 	lsr	r2, r2, #16
3001e428:	e3a01000 	mov	r1, #0
3001e42c:	e1812002 	orr	r2, r1, r2
3001e430:	e5c32011 	strb	r2, [r3, #17]
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
3001e434:	e59d100c 	ldr	r1, [sp, #12]
3001e438:	e59d300c 	ldr	r3, [sp, #12]
3001e43c:	e2832004 	add	r2, r3, #4
3001e440:	e59d300c 	ldr	r3, [sp, #12]
3001e444:	e5d3300b 	ldrb	r3, [r3, #11]
3001e448:	e59d000c 	ldr	r0, [sp, #12]
3001e44c:	e5d0000a 	ldrb	r0, [r0, #10]
3001e450:	e58d0000 	str	r0, [sp]
3001e454:	e3a00006 	mov	r0, #6
3001e458:	e58d0004 	str	r0, [sp, #4]
3001e45c:	e59d0014 	ldr	r0, [sp, #20]
3001e460:	ebffd9d9 	bl	30014bcc <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
3001e464:	e59d0014 	ldr	r0, [sp, #20]
3001e468:	ebffdf84 	bl	30016280 <pbuf_free>
    //acoral_prints("\r\n==output--4\r\n");
    return ERR_OK;
3001e46c:	e3a03000 	mov	r3, #0
3001e470:	ea00013c 	b	3001e968 <tcp_output+0x994>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
3001e474:	e59d300c 	ldr	r3, [sp, #12]
3001e478:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001e47c:	e3530000 	cmp	r3, #0
3001e480:	0a00000d 	beq	3001e4bc <tcp_output+0x4e8>
3001e484:	e59d300c 	ldr	r3, [sp, #12]
3001e488:	e5d3301c 	ldrb	r3, [r3, #28]
3001e48c:	e2033040 	and	r3, r3, #64	; 0x40
3001e490:	e3530000 	cmp	r3, #0
3001e494:	1a000008 	bne	3001e4bc <tcp_output+0x4e8>
3001e498:	e59d300c 	ldr	r3, [sp, #12]
3001e49c:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001e4a0:	e3530000 	cmp	r3, #0
3001e4a4:	0a000006 	beq	3001e4c4 <tcp_output+0x4f0>
3001e4a8:	e59d300c 	ldr	r3, [sp, #12]
3001e4ac:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001e4b0:	e5933000 	ldr	r3, [r3]
3001e4b4:	e3530000 	cmp	r3, #0
3001e4b8:	0a000001 	beq	3001e4c4 <tcp_output+0x4f0>
3001e4bc:	e3a03001 	mov	r3, #1
3001e4c0:	ea000000 	b	3001e4c8 <tcp_output+0x4f4>
3001e4c4:	e3a03000 	mov	r3, #0
3001e4c8:	e3530000 	cmp	r3, #0
3001e4cc:	1a000004 	bne	3001e4e4 <tcp_output+0x510>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
3001e4d0:	e59d300c 	ldr	r3, [sp, #12]
3001e4d4:	e5d3301c 	ldrb	r3, [r3, #28]
3001e4d8:	e20330a0 	and	r3, r3, #160	; 0xa0
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
3001e4dc:	e3530000 	cmp	r3, #0
3001e4e0:	0a0000f1 	beq	3001e8ac <tcp_output+0x8d8>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */
	//acoral_prints("\r\n==output--7\r\n");
    pcb->unsent = seg->next;
3001e4e4:	e59d301c 	ldr	r3, [sp, #28]
3001e4e8:	e5932000 	ldr	r2, [r3]
3001e4ec:	e59d300c 	ldr	r3, [sp, #12]
3001e4f0:	e5832070 	str	r2, [r3, #112]	; 0x70

    if (pcb->state != SYN_SENT) {
3001e4f4:	e59d300c 	ldr	r3, [sp, #12]
3001e4f8:	e5d33010 	ldrb	r3, [r3, #16]
3001e4fc:	e3530002 	cmp	r3, #2
3001e500:	0a000021 	beq	3001e58c <tcp_output+0x5b8>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
3001e504:	e59d301c 	ldr	r3, [sp, #28]
3001e508:	e5934010 	ldr	r4, [r3, #16]
3001e50c:	e59d301c 	ldr	r3, [sp, #28]
3001e510:	e5933010 	ldr	r3, [r3, #16]
3001e514:	e5d3200c 	ldrb	r2, [r3, #12]
3001e518:	e5d3300d 	ldrb	r3, [r3, #13]
3001e51c:	e1a03403 	lsl	r3, r3, #8
3001e520:	e1833002 	orr	r3, r3, r2
3001e524:	e1a03803 	lsl	r3, r3, #16
3001e528:	e1a03823 	lsr	r3, r3, #16
3001e52c:	e1a00003 	mov	r0, r3
3001e530:	ebffd445 	bl	3001364c <ntohs>
3001e534:	e1a03000 	mov	r3, r0
3001e538:	e3833010 	orr	r3, r3, #16
3001e53c:	e1a03803 	lsl	r3, r3, #16
3001e540:	e1a03823 	lsr	r3, r3, #16
3001e544:	e1a00003 	mov	r0, r3
3001e548:	ebffd42c 	bl	30013600 <htons>
3001e54c:	e1a03000 	mov	r3, r0
3001e550:	e20320ff 	and	r2, r3, #255	; 0xff
3001e554:	e3a01000 	mov	r1, #0
3001e558:	e1812002 	orr	r2, r1, r2
3001e55c:	e5c4200c 	strb	r2, [r4, #12]
3001e560:	e1a03423 	lsr	r3, r3, #8
3001e564:	e1a03803 	lsl	r3, r3, #16
3001e568:	e1a03823 	lsr	r3, r3, #16
3001e56c:	e3a02000 	mov	r2, #0
3001e570:	e1823003 	orr	r3, r2, r3
3001e574:	e5c4300d 	strb	r3, [r4, #13]
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
3001e578:	e59d300c 	ldr	r3, [sp, #12]
3001e57c:	e5d3301c 	ldrb	r3, [r3, #28]
3001e580:	e20330fc 	and	r3, r3, #252	; 0xfc
3001e584:	e59d200c 	ldr	r2, [sp, #12]
3001e588:	e5c2301c 	strb	r3, [r2, #28]
    }
	//acoral_print("\r\ntOutS\r\n");
    tcp_output_segment(seg, pcb);
3001e58c:	e59d001c 	ldr	r0, [sp, #28]
3001e590:	e59d100c 	ldr	r1, [sp, #12]
3001e594:	eb0000fb 	bl	3001e988 <tcp_output_segment>
    //acoral_print("\r\ntOutE\r\n");
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
3001e598:	e59d301c 	ldr	r3, [sp, #28]
3001e59c:	e5933010 	ldr	r3, [r3, #16]
3001e5a0:	e5d32004 	ldrb	r2, [r3, #4]
3001e5a4:	e5d31005 	ldrb	r1, [r3, #5]
3001e5a8:	e1a01401 	lsl	r1, r1, #8
3001e5ac:	e1812002 	orr	r2, r1, r2
3001e5b0:	e5d31006 	ldrb	r1, [r3, #6]
3001e5b4:	e1a01801 	lsl	r1, r1, #16
3001e5b8:	e1812002 	orr	r2, r1, r2
3001e5bc:	e5d33007 	ldrb	r3, [r3, #7]
3001e5c0:	e1a03c03 	lsl	r3, r3, #24
3001e5c4:	e1833002 	orr	r3, r3, r2
3001e5c8:	e1a00003 	mov	r0, r3
3001e5cc:	ebffd43c 	bl	300136c4 <ntohl>
3001e5d0:	e1a04000 	mov	r4, r0
3001e5d4:	e59d301c 	ldr	r3, [sp, #28]
3001e5d8:	e1d330bc 	ldrh	r3, [r3, #12]
3001e5dc:	e1a05003 	mov	r5, r3
3001e5e0:	e59d301c 	ldr	r3, [sp, #28]
3001e5e4:	e5933010 	ldr	r3, [r3, #16]
3001e5e8:	e5d3200c 	ldrb	r2, [r3, #12]
3001e5ec:	e5d3300d 	ldrb	r3, [r3, #13]
3001e5f0:	e1a03403 	lsl	r3, r3, #8
3001e5f4:	e1833002 	orr	r3, r3, r2
3001e5f8:	e1a03803 	lsl	r3, r3, #16
3001e5fc:	e1a03823 	lsr	r3, r3, #16
3001e600:	e1a00003 	mov	r0, r3
3001e604:	ebffd410 	bl	3001364c <ntohs>
3001e608:	e1a03000 	mov	r3, r0
3001e60c:	e2033001 	and	r3, r3, #1
3001e610:	e20330ff 	and	r3, r3, #255	; 0xff
3001e614:	e3530000 	cmp	r3, #0
3001e618:	1a00000d 	bne	3001e654 <tcp_output+0x680>
3001e61c:	e59d301c 	ldr	r3, [sp, #28]
3001e620:	e5933010 	ldr	r3, [r3, #16]
3001e624:	e5d3200c 	ldrb	r2, [r3, #12]
3001e628:	e5d3300d 	ldrb	r3, [r3, #13]
3001e62c:	e1a03403 	lsl	r3, r3, #8
3001e630:	e1833002 	orr	r3, r3, r2
3001e634:	e1a03803 	lsl	r3, r3, #16
3001e638:	e1a03823 	lsr	r3, r3, #16
3001e63c:	e1a00003 	mov	r0, r3
3001e640:	ebffd401 	bl	3001364c <ntohs>
3001e644:	e1a03000 	mov	r3, r0
3001e648:	e2033002 	and	r3, r3, #2
3001e64c:	e3530000 	cmp	r3, #0
3001e650:	0a000001 	beq	3001e65c <tcp_output+0x688>
3001e654:	e3a03001 	mov	r3, #1
3001e658:	ea000000 	b	3001e660 <tcp_output+0x68c>
3001e65c:	e3a03000 	mov	r3, #0
3001e660:	e0853003 	add	r3, r5, r3
3001e664:	e0842003 	add	r2, r4, r3
3001e668:	e59d300c 	ldr	r3, [sp, #12]
3001e66c:	e5832050 	str	r2, [r3, #80]	; 0x50
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
3001e670:	e59d300c 	ldr	r3, [sp, #12]
3001e674:	e5932054 	ldr	r2, [r3, #84]	; 0x54
3001e678:	e59d300c 	ldr	r3, [sp, #12]
3001e67c:	e5933050 	ldr	r3, [r3, #80]	; 0x50
3001e680:	e0633002 	rsb	r3, r3, r2
3001e684:	e3530000 	cmp	r3, #0
3001e688:	aa000003 	bge	3001e69c <tcp_output+0x6c8>
      pcb->snd_max = pcb->snd_nxt;
3001e68c:	e59d300c 	ldr	r3, [sp, #12]
3001e690:	e5932050 	ldr	r2, [r3, #80]	; 0x50
3001e694:	e59d300c 	ldr	r3, [sp, #12]
3001e698:	e5832054 	str	r2, [r3, #84]	; 0x54
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
3001e69c:	e59d301c 	ldr	r3, [sp, #28]
3001e6a0:	e1d330bc 	ldrh	r3, [r3, #12]
3001e6a4:	e1a04003 	mov	r4, r3
3001e6a8:	e59d301c 	ldr	r3, [sp, #28]
3001e6ac:	e5933010 	ldr	r3, [r3, #16]
3001e6b0:	e5d3200c 	ldrb	r2, [r3, #12]
3001e6b4:	e5d3300d 	ldrb	r3, [r3, #13]
3001e6b8:	e1a03403 	lsl	r3, r3, #8
3001e6bc:	e1833002 	orr	r3, r3, r2
3001e6c0:	e1a03803 	lsl	r3, r3, #16
3001e6c4:	e1a03823 	lsr	r3, r3, #16
3001e6c8:	e1a00003 	mov	r0, r3
3001e6cc:	ebffd3de 	bl	3001364c <ntohs>
3001e6d0:	e1a03000 	mov	r3, r0
3001e6d4:	e2033001 	and	r3, r3, #1
3001e6d8:	e20330ff 	and	r3, r3, #255	; 0xff
3001e6dc:	e3530000 	cmp	r3, #0
3001e6e0:	1a00000d 	bne	3001e71c <tcp_output+0x748>
3001e6e4:	e59d301c 	ldr	r3, [sp, #28]
3001e6e8:	e5933010 	ldr	r3, [r3, #16]
3001e6ec:	e5d3200c 	ldrb	r2, [r3, #12]
3001e6f0:	e5d3300d 	ldrb	r3, [r3, #13]
3001e6f4:	e1a03403 	lsl	r3, r3, #8
3001e6f8:	e1833002 	orr	r3, r3, r2
3001e6fc:	e1a03803 	lsl	r3, r3, #16
3001e700:	e1a03823 	lsr	r3, r3, #16
3001e704:	e1a00003 	mov	r0, r3
3001e708:	ebffd3cf 	bl	3001364c <ntohs>
3001e70c:	e1a03000 	mov	r3, r0
3001e710:	e2033002 	and	r3, r3, #2
3001e714:	e3530000 	cmp	r3, #0
3001e718:	0a000001 	beq	3001e724 <tcp_output+0x750>
3001e71c:	e3a03001 	mov	r3, #1
3001e720:	ea000000 	b	3001e728 <tcp_output+0x754>
3001e724:	e3a03000 	mov	r3, #0
3001e728:	e0843003 	add	r3, r4, r3
3001e72c:	e3530000 	cmp	r3, #0
3001e730:	da00003c 	ble	3001e828 <tcp_output+0x854>
      seg->next = NULL;
3001e734:	e59d301c 	ldr	r3, [sp, #28]
3001e738:	e3a02000 	mov	r2, #0
3001e73c:	e5832000 	str	r2, [r3]
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
3001e740:	e59d300c 	ldr	r3, [sp, #12]
3001e744:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001e748:	e3530000 	cmp	r3, #0
3001e74c:	1a000005 	bne	3001e768 <tcp_output+0x794>
        pcb->unacked = seg;
3001e750:	e59d300c 	ldr	r3, [sp, #12]
3001e754:	e59d201c 	ldr	r2, [sp, #28]
3001e758:	e5832074 	str	r2, [r3, #116]	; 0x74
        useg = seg;
3001e75c:	e59d301c 	ldr	r3, [sp, #28]
3001e760:	e58d3020 	str	r3, [sp, #32]
          seg->next = pcb->unacked;
          pcb->unacked = seg;
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
          useg = useg->next;
3001e764:	ea000031 	b	3001e830 <tcp_output+0x85c>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
3001e768:	e59d301c 	ldr	r3, [sp, #28]
3001e76c:	e5933010 	ldr	r3, [r3, #16]
3001e770:	e5d32004 	ldrb	r2, [r3, #4]
3001e774:	e5d31005 	ldrb	r1, [r3, #5]
3001e778:	e1a01401 	lsl	r1, r1, #8
3001e77c:	e1812002 	orr	r2, r1, r2
3001e780:	e5d31006 	ldrb	r1, [r3, #6]
3001e784:	e1a01801 	lsl	r1, r1, #16
3001e788:	e1812002 	orr	r2, r1, r2
3001e78c:	e5d33007 	ldrb	r3, [r3, #7]
3001e790:	e1a03c03 	lsl	r3, r3, #24
3001e794:	e1833002 	orr	r3, r3, r2
3001e798:	e1a00003 	mov	r0, r3
3001e79c:	ebffd3c8 	bl	300136c4 <ntohl>
3001e7a0:	e1a04000 	mov	r4, r0
3001e7a4:	e59d3020 	ldr	r3, [sp, #32]
3001e7a8:	e5933010 	ldr	r3, [r3, #16]
3001e7ac:	e5d32004 	ldrb	r2, [r3, #4]
3001e7b0:	e5d31005 	ldrb	r1, [r3, #5]
3001e7b4:	e1a01401 	lsl	r1, r1, #8
3001e7b8:	e1812002 	orr	r2, r1, r2
3001e7bc:	e5d31006 	ldrb	r1, [r3, #6]
3001e7c0:	e1a01801 	lsl	r1, r1, #16
3001e7c4:	e1812002 	orr	r2, r1, r2
3001e7c8:	e5d33007 	ldrb	r3, [r3, #7]
3001e7cc:	e1a03c03 	lsl	r3, r3, #24
3001e7d0:	e1833002 	orr	r3, r3, r2
3001e7d4:	e1a00003 	mov	r0, r3
3001e7d8:	ebffd3b9 	bl	300136c4 <ntohl>
3001e7dc:	e1a03000 	mov	r3, r0
3001e7e0:	e0633004 	rsb	r3, r3, r4
3001e7e4:	e3530000 	cmp	r3, #0
3001e7e8:	aa000007 	bge	3001e80c <tcp_output+0x838>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
3001e7ec:	e59d300c 	ldr	r3, [sp, #12]
3001e7f0:	e5932074 	ldr	r2, [r3, #116]	; 0x74
3001e7f4:	e59d301c 	ldr	r3, [sp, #28]
3001e7f8:	e5832000 	str	r2, [r3]
          pcb->unacked = seg;
3001e7fc:	e59d300c 	ldr	r3, [sp, #12]
3001e800:	e59d201c 	ldr	r2, [sp, #28]
3001e804:	e5832074 	str	r2, [r3, #116]	; 0x74
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
          useg = useg->next;
3001e808:	ea000008 	b	3001e830 <tcp_output+0x85c>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
          pcb->unacked = seg;
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
3001e80c:	e59d3020 	ldr	r3, [sp, #32]
3001e810:	e59d201c 	ldr	r2, [sp, #28]
3001e814:	e5832000 	str	r2, [r3]
          useg = useg->next;
3001e818:	e59d3020 	ldr	r3, [sp, #32]
3001e81c:	e5933000 	ldr	r3, [r3]
3001e820:	e58d3020 	str	r3, [sp, #32]
3001e824:	ea000001 	b	3001e830 <tcp_output+0x85c>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
3001e828:	e59d001c 	ldr	r0, [sp, #28]
3001e82c:	ebffe92e 	bl	30018cec <tcp_seg_free>
    }
    seg = pcb->unsent;
3001e830:	e59d300c 	ldr	r3, [sp, #12]
3001e834:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001e838:	e58d301c 	str	r3, [sp, #28]
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  //acoral_prints("\r\n==output--5\r\n");
  while (seg != NULL &&
3001e83c:	e59d301c 	ldr	r3, [sp, #28]
3001e840:	e3530000 	cmp	r3, #0
3001e844:	0a000019 	beq	3001e8b0 <tcp_output+0x8dc>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
3001e848:	e59d301c 	ldr	r3, [sp, #28]
3001e84c:	e5933010 	ldr	r3, [r3, #16]
3001e850:	e5d32004 	ldrb	r2, [r3, #4]
3001e854:	e5d31005 	ldrb	r1, [r3, #5]
3001e858:	e1a01401 	lsl	r1, r1, #8
3001e85c:	e1812002 	orr	r2, r1, r2
3001e860:	e5d31006 	ldrb	r1, [r3, #6]
3001e864:	e1a01801 	lsl	r1, r1, #16
3001e868:	e1812002 	orr	r2, r1, r2
3001e86c:	e5d33007 	ldrb	r3, [r3, #7]
3001e870:	e1a03c03 	lsl	r3, r3, #24
3001e874:	e1833002 	orr	r3, r3, r2
3001e878:	e1a00003 	mov	r0, r3
3001e87c:	ebffd390 	bl	300136c4 <ntohl>
3001e880:	e1a02000 	mov	r2, r0
3001e884:	e59d300c 	ldr	r3, [sp, #12]
3001e888:	e5933044 	ldr	r3, [r3, #68]	; 0x44
3001e88c:	e0632002 	rsb	r2, r3, r2
3001e890:	e59d301c 	ldr	r3, [sp, #28]
3001e894:	e1d330bc 	ldrh	r3, [r3, #12]
3001e898:	e0822003 	add	r2, r2, r3
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  //acoral_prints("\r\n==output--5\r\n");
  while (seg != NULL &&
3001e89c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001e8a0:	e1520003 	cmp	r2, r3
3001e8a4:	9afffef2 	bls	3001e474 <tcp_output+0x4a0>
3001e8a8:	ea000000 	b	3001e8b0 <tcp_output+0x8dc>
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      //acoral_prints("\r\n==output--6\r\n");
      break;
3001e8ac:	e1a00000 	nop			; (mov r0, r0)
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
  //acoral_prints("\r\n==output--8\r\n");
  if (seg != NULL && pcb->persist_backoff == 0 && 
3001e8b0:	e59d301c 	ldr	r3, [sp, #28]
3001e8b4:	e3530000 	cmp	r3, #0
3001e8b8:	0a000024 	beq	3001e950 <tcp_output+0x97c>
3001e8bc:	e59d300c 	ldr	r3, [sp, #12]
3001e8c0:	e5d330a0 	ldrb	r3, [r3, #160]	; 0xa0
3001e8c4:	e3530000 	cmp	r3, #0
3001e8c8:	1a000020 	bne	3001e950 <tcp_output+0x97c>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
3001e8cc:	e59d301c 	ldr	r3, [sp, #28]
3001e8d0:	e5933010 	ldr	r3, [r3, #16]
3001e8d4:	e5d32004 	ldrb	r2, [r3, #4]
3001e8d8:	e5d31005 	ldrb	r1, [r3, #5]
3001e8dc:	e1a01401 	lsl	r1, r1, #8
3001e8e0:	e1812002 	orr	r2, r1, r2
3001e8e4:	e5d31006 	ldrb	r1, [r3, #6]
3001e8e8:	e1a01801 	lsl	r1, r1, #16
3001e8ec:	e1812002 	orr	r2, r1, r2
3001e8f0:	e5d33007 	ldrb	r3, [r3, #7]
3001e8f4:	e1a03c03 	lsl	r3, r3, #24
3001e8f8:	e1833002 	orr	r3, r3, r2
3001e8fc:	e1a00003 	mov	r0, r3
3001e900:	ebffd36f 	bl	300136c4 <ntohl>
3001e904:	e1a02000 	mov	r2, r0
3001e908:	e59d300c 	ldr	r3, [sp, #12]
3001e90c:	e5933044 	ldr	r3, [r3, #68]	; 0x44
3001e910:	e0632002 	rsb	r2, r3, r2
3001e914:	e59d301c 	ldr	r3, [sp, #28]
3001e918:	e1d330bc 	ldrh	r3, [r3, #12]
3001e91c:	e0822003 	add	r2, r2, r3
3001e920:	e59d300c 	ldr	r3, [sp, #12]
3001e924:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
  //acoral_prints("\r\n==output--8\r\n");
  if (seg != NULL && pcb->persist_backoff == 0 && 
3001e928:	e1520003 	cmp	r2, r3
3001e92c:	9a000007 	bls	3001e950 <tcp_output+0x97c>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    acoral_prints("\r\n==output--9\r\n");
3001e930:	e59f004c 	ldr	r0, [pc, #76]	; 3001e984 <tcp_output+0x9b0>
3001e934:	ebffb264 	bl	3000b2cc <acoral_prints>
    pcb->persist_cnt = 0;
3001e938:	e59d300c 	ldr	r3, [sp, #12]
3001e93c:	e3a02000 	mov	r2, #0
3001e940:	e583209c 	str	r2, [r3, #156]	; 0x9c
    pcb->persist_backoff = 1;
3001e944:	e59d300c 	ldr	r3, [sp, #12]
3001e948:	e3a02001 	mov	r2, #1
3001e94c:	e5c320a0 	strb	r2, [r3, #160]	; 0xa0
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
3001e950:	e59d300c 	ldr	r3, [sp, #12]
3001e954:	e5d3301c 	ldrb	r3, [r3, #28]
3001e958:	e203307f 	and	r3, r3, #127	; 0x7f
3001e95c:	e59d200c 	ldr	r2, [sp, #12]
3001e960:	e5c2301c 	strb	r3, [r2, #28]
  return ERR_OK;
3001e964:	e3a03000 	mov	r3, #0
3001e968:	e1a03c03 	lsl	r3, r3, #24
3001e96c:	e1a03c43 	asr	r3, r3, #24
}
3001e970:	e1a00003 	mov	r0, r3
3001e974:	e28dd02c 	add	sp, sp, #44	; 0x2c
3001e978:	e8bd4030 	pop	{r4, r5, lr}
3001e97c:	e12fff1e 	bx	lr
3001e980:	3012ac98 	.word	0x3012ac98
3001e984:	30045728 	.word	0x30045728

3001e988 <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
3001e988:	e92d4010 	push	{r4, lr}
3001e98c:	e24dd018 	sub	sp, sp, #24
3001e990:	e58d000c 	str	r0, [sp, #12]
3001e994:	e58d1008 	str	r1, [sp, #8]
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
3001e998:	e59d300c 	ldr	r3, [sp, #12]
3001e99c:	e5934010 	ldr	r4, [r3, #16]
3001e9a0:	e59d3008 	ldr	r3, [sp, #8]
3001e9a4:	e5933020 	ldr	r3, [r3, #32]
3001e9a8:	e1a00003 	mov	r0, r3
3001e9ac:	ebffd332 	bl	3001367c <htonl>
3001e9b0:	e1a03000 	mov	r3, r0
3001e9b4:	e20320ff 	and	r2, r3, #255	; 0xff
3001e9b8:	e3a01000 	mov	r1, #0
3001e9bc:	e1812002 	orr	r2, r1, r2
3001e9c0:	e5c42008 	strb	r2, [r4, #8]
3001e9c4:	e1a02423 	lsr	r2, r3, #8
3001e9c8:	e20220ff 	and	r2, r2, #255	; 0xff
3001e9cc:	e3a01000 	mov	r1, #0
3001e9d0:	e1812002 	orr	r2, r1, r2
3001e9d4:	e5c42009 	strb	r2, [r4, #9]
3001e9d8:	e1a02823 	lsr	r2, r3, #16
3001e9dc:	e20220ff 	and	r2, r2, #255	; 0xff
3001e9e0:	e3a01000 	mov	r1, #0
3001e9e4:	e1812002 	orr	r2, r1, r2
3001e9e8:	e5c4200a 	strb	r2, [r4, #10]
3001e9ec:	e1a03c23 	lsr	r3, r3, #24
3001e9f0:	e3a02000 	mov	r2, #0
3001e9f4:	e1823003 	orr	r3, r2, r3
3001e9f8:	e5c4300b 	strb	r3, [r4, #11]

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
3001e9fc:	e59d300c 	ldr	r3, [sp, #12]
3001ea00:	e5934010 	ldr	r4, [r3, #16]
3001ea04:	e59d3008 	ldr	r3, [sp, #8]
3001ea08:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
3001ea0c:	e1a00003 	mov	r0, r3
3001ea10:	ebffd2fa 	bl	30013600 <htons>
3001ea14:	e1a03000 	mov	r3, r0
3001ea18:	e20320ff 	and	r2, r3, #255	; 0xff
3001ea1c:	e3a01000 	mov	r1, #0
3001ea20:	e1812002 	orr	r2, r1, r2
3001ea24:	e5c4200e 	strb	r2, [r4, #14]
3001ea28:	e1a03423 	lsr	r3, r3, #8
3001ea2c:	e1a03803 	lsl	r3, r3, #16
3001ea30:	e1a03823 	lsr	r3, r3, #16
3001ea34:	e3a02000 	mov	r2, #0
3001ea38:	e1823003 	orr	r3, r2, r3
3001ea3c:	e5c4300f 	strb	r3, [r4, #15]

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
3001ea40:	e59d3008 	ldr	r3, [sp, #8]
3001ea44:	e3530000 	cmp	r3, #0
3001ea48:	0a000003 	beq	3001ea5c <tcp_output_segment+0xd4>
3001ea4c:	e59d3008 	ldr	r3, [sp, #8]
3001ea50:	e5933000 	ldr	r3, [r3]
3001ea54:	e3530000 	cmp	r3, #0
3001ea58:	1a000012 	bne	3001eaa8 <tcp_output_segment+0x120>
    netif = ip_route(&(pcb->remote_ip));
3001ea5c:	e59d3008 	ldr	r3, [sp, #8]
3001ea60:	e2833004 	add	r3, r3, #4
3001ea64:	e1a00003 	mov	r0, r3
3001ea68:	ebffd539 	bl	30013f54 <ip_route>
3001ea6c:	e1a03000 	mov	r3, r0
3001ea70:	e58d3014 	str	r3, [sp, #20]
    if (netif == NULL) {
3001ea74:	e59d3014 	ldr	r3, [sp, #20]
3001ea78:	e3530000 	cmp	r3, #0
3001ea7c:	0a000085 	beq	3001ec98 <tcp_output_segment+0x310>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
3001ea80:	e59d3014 	ldr	r3, [sp, #20]
3001ea84:	e2833004 	add	r3, r3, #4
3001ea88:	e3530000 	cmp	r3, #0
3001ea8c:	0a000002 	beq	3001ea9c <tcp_output_segment+0x114>
3001ea90:	e59d3014 	ldr	r3, [sp, #20]
3001ea94:	e5933004 	ldr	r3, [r3, #4]
3001ea98:	ea000000 	b	3001eaa0 <tcp_output_segment+0x118>
3001ea9c:	e3a03000 	mov	r3, #0
3001eaa0:	e59d2008 	ldr	r2, [sp, #8]
3001eaa4:	e5823000 	str	r3, [r2]
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
3001eaa8:	e59d3008 	ldr	r3, [sp, #8]
3001eaac:	e1d332be 	ldrh	r3, [r3, #46]	; 0x2e
3001eab0:	e1a03803 	lsl	r3, r3, #16
3001eab4:	e1a03843 	asr	r3, r3, #16
3001eab8:	e3730001 	cmn	r3, #1
3001eabc:	1a000002 	bne	3001eacc <tcp_output_segment+0x144>
    pcb->rtime = 0;
3001eac0:	e59d3008 	ldr	r3, [sp, #8]
3001eac4:	e3a02000 	mov	r2, #0
3001eac8:	e1c322be 	strh	r2, [r3, #46]	; 0x2e

  if (pcb->rttest == 0) {
3001eacc:	e59d3008 	ldr	r3, [sp, #8]
3001ead0:	e5933034 	ldr	r3, [r3, #52]	; 0x34
3001ead4:	e3530000 	cmp	r3, #0
3001ead8:	1a000014 	bne	3001eb30 <tcp_output_segment+0x1a8>
    pcb->rttest = tcp_ticks;
3001eadc:	e59f31c4 	ldr	r3, [pc, #452]	; 3001eca8 <tcp_output_segment+0x320>
3001eae0:	e5932000 	ldr	r2, [r3]
3001eae4:	e59d3008 	ldr	r3, [sp, #8]
3001eae8:	e5832034 	str	r2, [r3, #52]	; 0x34
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
3001eaec:	e59d300c 	ldr	r3, [sp, #12]
3001eaf0:	e5933010 	ldr	r3, [r3, #16]
3001eaf4:	e5d32004 	ldrb	r2, [r3, #4]
3001eaf8:	e5d31005 	ldrb	r1, [r3, #5]
3001eafc:	e1a01401 	lsl	r1, r1, #8
3001eb00:	e1812002 	orr	r2, r1, r2
3001eb04:	e5d31006 	ldrb	r1, [r3, #6]
3001eb08:	e1a01801 	lsl	r1, r1, #16
3001eb0c:	e1812002 	orr	r2, r1, r2
3001eb10:	e5d33007 	ldrb	r3, [r3, #7]
3001eb14:	e1a03c03 	lsl	r3, r3, #24
3001eb18:	e1833002 	orr	r3, r3, r2
3001eb1c:	e1a00003 	mov	r0, r3
3001eb20:	ebffd2e7 	bl	300136c4 <ntohl>
3001eb24:	e1a02000 	mov	r2, r0
3001eb28:	e59d3008 	ldr	r3, [sp, #8]
3001eb2c:	e5832038 	str	r2, [r3, #56]	; 0x38
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
3001eb30:	e59d300c 	ldr	r3, [sp, #12]
3001eb34:	e5933010 	ldr	r3, [r3, #16]
3001eb38:	e1a03803 	lsl	r3, r3, #16
3001eb3c:	e1a02823 	lsr	r2, r3, #16
3001eb40:	e59d300c 	ldr	r3, [sp, #12]
3001eb44:	e5933004 	ldr	r3, [r3, #4]
3001eb48:	e5933004 	ldr	r3, [r3, #4]
3001eb4c:	e1a03803 	lsl	r3, r3, #16
3001eb50:	e1a03823 	lsr	r3, r3, #16
3001eb54:	e0633002 	rsb	r3, r3, r2
3001eb58:	e1cd31b2 	strh	r3, [sp, #18]

  seg->p->len -= len;
3001eb5c:	e59d300c 	ldr	r3, [sp, #12]
3001eb60:	e5933004 	ldr	r3, [r3, #4]
3001eb64:	e59d200c 	ldr	r2, [sp, #12]
3001eb68:	e5922004 	ldr	r2, [r2, #4]
3001eb6c:	e1d210ba 	ldrh	r1, [r2, #10]
3001eb70:	e1dd21b2 	ldrh	r2, [sp, #18]
3001eb74:	e0622001 	rsb	r2, r2, r1
3001eb78:	e1a02802 	lsl	r2, r2, #16
3001eb7c:	e1a02822 	lsr	r2, r2, #16
3001eb80:	e1c320ba 	strh	r2, [r3, #10]
  seg->p->tot_len -= len;
3001eb84:	e59d300c 	ldr	r3, [sp, #12]
3001eb88:	e5933004 	ldr	r3, [r3, #4]
3001eb8c:	e59d200c 	ldr	r2, [sp, #12]
3001eb90:	e5922004 	ldr	r2, [r2, #4]
3001eb94:	e1d210b8 	ldrh	r1, [r2, #8]
3001eb98:	e1dd21b2 	ldrh	r2, [sp, #18]
3001eb9c:	e0622001 	rsb	r2, r2, r1
3001eba0:	e1a02802 	lsl	r2, r2, #16
3001eba4:	e1a02822 	lsr	r2, r2, #16
3001eba8:	e1c320b8 	strh	r2, [r3, #8]

  seg->p->payload = seg->tcphdr;
3001ebac:	e59d300c 	ldr	r3, [sp, #12]
3001ebb0:	e5933004 	ldr	r3, [r3, #4]
3001ebb4:	e59d200c 	ldr	r2, [sp, #12]
3001ebb8:	e5922010 	ldr	r2, [r2, #16]
3001ebbc:	e5832004 	str	r2, [r3, #4]

  seg->tcphdr->chksum = 0;
3001ebc0:	e59d300c 	ldr	r3, [sp, #12]
3001ebc4:	e5933010 	ldr	r3, [r3, #16]
3001ebc8:	e3a02000 	mov	r2, #0
3001ebcc:	e5c32010 	strb	r2, [r3, #16]
3001ebd0:	e3a02000 	mov	r2, #0
3001ebd4:	e5c32011 	strb	r2, [r3, #17]
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
3001ebd8:	e59d300c 	ldr	r3, [sp, #12]
3001ebdc:	e5934010 	ldr	r4, [r3, #16]
3001ebe0:	e59d300c 	ldr	r3, [sp, #12]
3001ebe4:	e5931004 	ldr	r1, [r3, #4]
3001ebe8:	e59d2008 	ldr	r2, [sp, #8]
3001ebec:	e59d3008 	ldr	r3, [sp, #8]
3001ebf0:	e2833004 	add	r3, r3, #4
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
3001ebf4:	e59d000c 	ldr	r0, [sp, #12]
3001ebf8:	e5900004 	ldr	r0, [r0, #4]

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
3001ebfc:	e1d000b8 	ldrh	r0, [r0, #8]
3001ec00:	e58d0000 	str	r0, [sp]
3001ec04:	e1a00001 	mov	r0, r1
3001ec08:	e1a01002 	mov	r1, r2
3001ec0c:	e1a02003 	mov	r2, r3
3001ec10:	e3a03006 	mov	r3, #6
3001ec14:	ebffd300 	bl	3001381c <inet_chksum_pseudo>
3001ec18:	e1a03000 	mov	r3, r0
3001ec1c:	e20320ff 	and	r2, r3, #255	; 0xff
3001ec20:	e3a01000 	mov	r1, #0
3001ec24:	e1812002 	orr	r2, r1, r2
3001ec28:	e5c42010 	strb	r2, [r4, #16]
3001ec2c:	e1a03423 	lsr	r3, r3, #8
3001ec30:	e1a03803 	lsl	r3, r3, #16
3001ec34:	e1a03823 	lsr	r3, r3, #16
3001ec38:	e3a02000 	mov	r2, #0
3001ec3c:	e1823003 	orr	r3, r2, r3
3001ec40:	e5c43011 	strb	r3, [r4, #17]
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
3001ec44:	e59f3060 	ldr	r3, [pc, #96]	; 3001ecac <tcp_output_segment+0x324>
3001ec48:	e1d339bc 	ldrh	r3, [r3, #156]	; 0x9c
3001ec4c:	e2833001 	add	r3, r3, #1
3001ec50:	e1a03803 	lsl	r3, r3, #16
3001ec54:	e1a02823 	lsr	r2, r3, #16
3001ec58:	e59f304c 	ldr	r3, [pc, #76]	; 3001ecac <tcp_output_segment+0x324>
3001ec5c:	e1c329bc 	strh	r2, [r3, #156]	; 0x9c
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  //acoral_print("\r\ntOutS-S1\r\n");
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
3001ec60:	e59d300c 	ldr	r3, [sp, #12]
3001ec64:	e5930004 	ldr	r0, [r3, #4]
3001ec68:	e59d1008 	ldr	r1, [sp, #8]
3001ec6c:	e59d3008 	ldr	r3, [sp, #8]
3001ec70:	e2832004 	add	r2, r3, #4
3001ec74:	e59d3008 	ldr	r3, [sp, #8]
3001ec78:	e5d3300b 	ldrb	r3, [r3, #11]
3001ec7c:	e59dc008 	ldr	ip, [sp, #8]
3001ec80:	e5dcc00a 	ldrb	ip, [ip, #10]
3001ec84:	e58dc000 	str	ip, [sp]
3001ec88:	e3a0c006 	mov	ip, #6
3001ec8c:	e58dc004 	str	ip, [sp, #4]
3001ec90:	ebffd7cd 	bl	30014bcc <ip_output>
3001ec94:	ea000000 	b	3001ec9c <tcp_output_segment+0x314>
  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    netif = ip_route(&(pcb->remote_ip));
    if (netif == NULL) {
      return;
3001ec98:	e1a00000 	nop			; (mov r0, r0)
  //acoral_print("\r\ntOutS-S1\r\n");
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
  //acoral_print("\r\ntOutE-S1\r\n");
#endif /* LWIP_NETIF_HWADDRHINT*/
}
3001ec9c:	e28dd018 	add	sp, sp, #24
3001eca0:	e8bd4010 	pop	{r4, lr}
3001eca4:	e12fff1e 	bx	lr
3001eca8:	300eaa74 	.word	0x300eaa74
3001ecac:	302be570 	.word	0x302be570

3001ecb0 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
3001ecb0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001ecb4:	e24dd024 	sub	sp, sp, #36	; 0x24
3001ecb8:	e58d0014 	str	r0, [sp, #20]
3001ecbc:	e58d1010 	str	r1, [sp, #16]
3001ecc0:	e58d200c 	str	r2, [sp, #12]
3001ecc4:	e58d3008 	str	r3, [sp, #8]
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
3001ecc8:	e3a00001 	mov	r0, #1
3001eccc:	e3a01014 	mov	r1, #20
3001ecd0:	e3a02000 	mov	r2, #0
3001ecd4:	ebffdbb7 	bl	30015bb8 <pbuf_alloc>
3001ecd8:	e1a03000 	mov	r3, r0
3001ecdc:	e58d3018 	str	r3, [sp, #24]
  if (p == NULL) {
3001ece0:	e59d3018 	ldr	r3, [sp, #24]
3001ece4:	e3530000 	cmp	r3, #0
3001ece8:	0a0000cb 	beq	3001f01c <tcp_rst+0x36c>
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
3001ecec:	e59d3018 	ldr	r3, [sp, #24]
3001ecf0:	e5933004 	ldr	r3, [r3, #4]
3001ecf4:	e58d301c 	str	r3, [sp, #28]
  tcphdr->src = htons(local_port);
3001ecf8:	e1dd32b8 	ldrh	r3, [sp, #40]	; 0x28
3001ecfc:	e1a00003 	mov	r0, r3
3001ed00:	ebffd23e 	bl	30013600 <htons>
3001ed04:	e1a03000 	mov	r3, r0
3001ed08:	e1a02003 	mov	r2, r3
3001ed0c:	e59d301c 	ldr	r3, [sp, #28]
3001ed10:	e20210ff 	and	r1, r2, #255	; 0xff
3001ed14:	e3a00000 	mov	r0, #0
3001ed18:	e1801001 	orr	r1, r0, r1
3001ed1c:	e5c31000 	strb	r1, [r3]
3001ed20:	e1a02422 	lsr	r2, r2, #8
3001ed24:	e1a02802 	lsl	r2, r2, #16
3001ed28:	e1a02822 	lsr	r2, r2, #16
3001ed2c:	e3a01000 	mov	r1, #0
3001ed30:	e1812002 	orr	r2, r1, r2
3001ed34:	e5c32001 	strb	r2, [r3, #1]
  tcphdr->dest = htons(remote_port);
3001ed38:	e1dd32bc 	ldrh	r3, [sp, #44]	; 0x2c
3001ed3c:	e1a00003 	mov	r0, r3
3001ed40:	ebffd22e 	bl	30013600 <htons>
3001ed44:	e1a03000 	mov	r3, r0
3001ed48:	e1a02003 	mov	r2, r3
3001ed4c:	e59d301c 	ldr	r3, [sp, #28]
3001ed50:	e20210ff 	and	r1, r2, #255	; 0xff
3001ed54:	e3a00000 	mov	r0, #0
3001ed58:	e1801001 	orr	r1, r0, r1
3001ed5c:	e5c31002 	strb	r1, [r3, #2]
3001ed60:	e1a02422 	lsr	r2, r2, #8
3001ed64:	e1a02802 	lsl	r2, r2, #16
3001ed68:	e1a02822 	lsr	r2, r2, #16
3001ed6c:	e3a01000 	mov	r1, #0
3001ed70:	e1812002 	orr	r2, r1, r2
3001ed74:	e5c32003 	strb	r2, [r3, #3]
  tcphdr->seqno = htonl(seqno);
3001ed78:	e59d0014 	ldr	r0, [sp, #20]
3001ed7c:	ebffd23e 	bl	3001367c <htonl>
3001ed80:	e1a02000 	mov	r2, r0
3001ed84:	e59d301c 	ldr	r3, [sp, #28]
3001ed88:	e20210ff 	and	r1, r2, #255	; 0xff
3001ed8c:	e3a00000 	mov	r0, #0
3001ed90:	e1801001 	orr	r1, r0, r1
3001ed94:	e5c31004 	strb	r1, [r3, #4]
3001ed98:	e1a01422 	lsr	r1, r2, #8
3001ed9c:	e20110ff 	and	r1, r1, #255	; 0xff
3001eda0:	e3a00000 	mov	r0, #0
3001eda4:	e1801001 	orr	r1, r0, r1
3001eda8:	e5c31005 	strb	r1, [r3, #5]
3001edac:	e1a01822 	lsr	r1, r2, #16
3001edb0:	e20110ff 	and	r1, r1, #255	; 0xff
3001edb4:	e3a00000 	mov	r0, #0
3001edb8:	e1801001 	orr	r1, r0, r1
3001edbc:	e5c31006 	strb	r1, [r3, #6]
3001edc0:	e1a02c22 	lsr	r2, r2, #24
3001edc4:	e3a01000 	mov	r1, #0
3001edc8:	e1812002 	orr	r2, r1, r2
3001edcc:	e5c32007 	strb	r2, [r3, #7]
  tcphdr->ackno = htonl(ackno);
3001edd0:	e59d0010 	ldr	r0, [sp, #16]
3001edd4:	ebffd228 	bl	3001367c <htonl>
3001edd8:	e1a02000 	mov	r2, r0
3001eddc:	e59d301c 	ldr	r3, [sp, #28]
3001ede0:	e20210ff 	and	r1, r2, #255	; 0xff
3001ede4:	e3a00000 	mov	r0, #0
3001ede8:	e1801001 	orr	r1, r0, r1
3001edec:	e5c31008 	strb	r1, [r3, #8]
3001edf0:	e1a01422 	lsr	r1, r2, #8
3001edf4:	e20110ff 	and	r1, r1, #255	; 0xff
3001edf8:	e3a00000 	mov	r0, #0
3001edfc:	e1801001 	orr	r1, r0, r1
3001ee00:	e5c31009 	strb	r1, [r3, #9]
3001ee04:	e1a01822 	lsr	r1, r2, #16
3001ee08:	e20110ff 	and	r1, r1, #255	; 0xff
3001ee0c:	e3a00000 	mov	r0, #0
3001ee10:	e1801001 	orr	r1, r0, r1
3001ee14:	e5c3100a 	strb	r1, [r3, #10]
3001ee18:	e1a02c22 	lsr	r2, r2, #24
3001ee1c:	e3a01000 	mov	r1, #0
3001ee20:	e1812002 	orr	r2, r1, r2
3001ee24:	e5c3200b 	strb	r2, [r3, #11]
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
3001ee28:	e59d301c 	ldr	r3, [sp, #28]
3001ee2c:	e5d3200c 	ldrb	r2, [r3, #12]
3001ee30:	e5d3300d 	ldrb	r3, [r3, #13]
3001ee34:	e1a03403 	lsl	r3, r3, #8
3001ee38:	e1833002 	orr	r3, r3, r2
3001ee3c:	e1a03803 	lsl	r3, r3, #16
3001ee40:	e1a03823 	lsr	r3, r3, #16
3001ee44:	e1a00003 	mov	r0, r3
3001ee48:	ebffd1ff 	bl	3001364c <ntohs>
3001ee4c:	e1a03000 	mov	r3, r0
3001ee50:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3001ee54:	e1a03803 	lsl	r3, r3, #16
3001ee58:	e1a03823 	lsr	r3, r3, #16
3001ee5c:	e3833014 	orr	r3, r3, #20
3001ee60:	e1a03803 	lsl	r3, r3, #16
3001ee64:	e1a03823 	lsr	r3, r3, #16
3001ee68:	e1a00003 	mov	r0, r3
3001ee6c:	ebffd1e3 	bl	30013600 <htons>
3001ee70:	e1a03000 	mov	r3, r0
3001ee74:	e1a02003 	mov	r2, r3
3001ee78:	e59d301c 	ldr	r3, [sp, #28]
3001ee7c:	e20210ff 	and	r1, r2, #255	; 0xff
3001ee80:	e3a00000 	mov	r0, #0
3001ee84:	e1801001 	orr	r1, r0, r1
3001ee88:	e5c3100c 	strb	r1, [r3, #12]
3001ee8c:	e1a02422 	lsr	r2, r2, #8
3001ee90:	e1a02802 	lsl	r2, r2, #16
3001ee94:	e1a02822 	lsr	r2, r2, #16
3001ee98:	e3a01000 	mov	r1, #0
3001ee9c:	e1812002 	orr	r2, r1, r2
3001eea0:	e5c3200d 	strb	r2, [r3, #13]
  tcphdr->wnd = htons(TCP_WND);
3001eea4:	e3a00a02 	mov	r0, #8192	; 0x2000
3001eea8:	ebffd1d4 	bl	30013600 <htons>
3001eeac:	e1a03000 	mov	r3, r0
3001eeb0:	e1a02003 	mov	r2, r3
3001eeb4:	e59d301c 	ldr	r3, [sp, #28]
3001eeb8:	e20210ff 	and	r1, r2, #255	; 0xff
3001eebc:	e3a00000 	mov	r0, #0
3001eec0:	e1801001 	orr	r1, r0, r1
3001eec4:	e5c3100e 	strb	r1, [r3, #14]
3001eec8:	e1a02422 	lsr	r2, r2, #8
3001eecc:	e1a02802 	lsl	r2, r2, #16
3001eed0:	e1a02822 	lsr	r2, r2, #16
3001eed4:	e3a01000 	mov	r1, #0
3001eed8:	e1812002 	orr	r2, r1, r2
3001eedc:	e5c3200f 	strb	r2, [r3, #15]
  tcphdr->urgp = 0;
3001eee0:	e59d301c 	ldr	r3, [sp, #28]
3001eee4:	e3a02000 	mov	r2, #0
3001eee8:	e5c32012 	strb	r2, [r3, #18]
3001eeec:	e3a02000 	mov	r2, #0
3001eef0:	e5c32013 	strb	r2, [r3, #19]
  TCPH_HDRLEN_SET(tcphdr, 5);
3001eef4:	e59d301c 	ldr	r3, [sp, #28]
3001eef8:	e5d3200c 	ldrb	r2, [r3, #12]
3001eefc:	e5d3300d 	ldrb	r3, [r3, #13]
3001ef00:	e1a03403 	lsl	r3, r3, #8
3001ef04:	e1833002 	orr	r3, r3, r2
3001ef08:	e1a03803 	lsl	r3, r3, #16
3001ef0c:	e1a03823 	lsr	r3, r3, #16
3001ef10:	e1a00003 	mov	r0, r3
3001ef14:	ebffd1cc 	bl	3001364c <ntohs>
3001ef18:	e1a03000 	mov	r3, r0
3001ef1c:	e203303f 	and	r3, r3, #63	; 0x3f
3001ef20:	e3833a05 	orr	r3, r3, #20480	; 0x5000
3001ef24:	e1a03803 	lsl	r3, r3, #16
3001ef28:	e1a03823 	lsr	r3, r3, #16
3001ef2c:	e1a00003 	mov	r0, r3
3001ef30:	ebffd1b2 	bl	30013600 <htons>
3001ef34:	e1a03000 	mov	r3, r0
3001ef38:	e1a02003 	mov	r2, r3
3001ef3c:	e59d301c 	ldr	r3, [sp, #28]
3001ef40:	e20210ff 	and	r1, r2, #255	; 0xff
3001ef44:	e3a00000 	mov	r0, #0
3001ef48:	e1801001 	orr	r1, r0, r1
3001ef4c:	e5c3100c 	strb	r1, [r3, #12]
3001ef50:	e1a02422 	lsr	r2, r2, #8
3001ef54:	e1a02802 	lsl	r2, r2, #16
3001ef58:	e1a02822 	lsr	r2, r2, #16
3001ef5c:	e3a01000 	mov	r1, #0
3001ef60:	e1812002 	orr	r2, r1, r2
3001ef64:	e5c3200d 	strb	r2, [r3, #13]

  tcphdr->chksum = 0;
3001ef68:	e59d301c 	ldr	r3, [sp, #28]
3001ef6c:	e3a02000 	mov	r2, #0
3001ef70:	e5c32010 	strb	r2, [r3, #16]
3001ef74:	e3a02000 	mov	r2, #0
3001ef78:	e5c32011 	strb	r2, [r3, #17]
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
3001ef7c:	e59d3018 	ldr	r3, [sp, #24]
3001ef80:	e1d330b8 	ldrh	r3, [r3, #8]
3001ef84:	e58d3000 	str	r3, [sp]
3001ef88:	e59d0018 	ldr	r0, [sp, #24]
3001ef8c:	e59d100c 	ldr	r1, [sp, #12]
3001ef90:	e59d2008 	ldr	r2, [sp, #8]
3001ef94:	e3a03006 	mov	r3, #6
3001ef98:	ebffd21f 	bl	3001381c <inet_chksum_pseudo>
3001ef9c:	e1a03000 	mov	r3, r0
3001efa0:	e1a02003 	mov	r2, r3
3001efa4:	e59d301c 	ldr	r3, [sp, #28]
3001efa8:	e20210ff 	and	r1, r2, #255	; 0xff
3001efac:	e3a00000 	mov	r0, #0
3001efb0:	e1801001 	orr	r1, r0, r1
3001efb4:	e5c31010 	strb	r1, [r3, #16]
3001efb8:	e1a02422 	lsr	r2, r2, #8
3001efbc:	e1a02802 	lsl	r2, r2, #16
3001efc0:	e1a02822 	lsr	r2, r2, #16
3001efc4:	e3a01000 	mov	r1, #0
3001efc8:	e1812002 	orr	r2, r1, r2
3001efcc:	e5c32011 	strb	r2, [r3, #17]
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
3001efd0:	e59f3054 	ldr	r3, [pc, #84]	; 3001f02c <tcp_rst+0x37c>
3001efd4:	e1d339bc 	ldrh	r3, [r3, #156]	; 0x9c
3001efd8:	e2833001 	add	r3, r3, #1
3001efdc:	e1a03803 	lsl	r3, r3, #16
3001efe0:	e1a02823 	lsr	r2, r3, #16
3001efe4:	e59f3040 	ldr	r3, [pc, #64]	; 3001f02c <tcp_rst+0x37c>
3001efe8:	e1c329bc 	strh	r2, [r3, #156]	; 0x9c
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
3001efec:	e3a03000 	mov	r3, #0
3001eff0:	e58d3000 	str	r3, [sp]
3001eff4:	e3a03006 	mov	r3, #6
3001eff8:	e58d3004 	str	r3, [sp, #4]
3001effc:	e59d0018 	ldr	r0, [sp, #24]
3001f000:	e59d100c 	ldr	r1, [sp, #12]
3001f004:	e59d2008 	ldr	r2, [sp, #8]
3001f008:	e3a030ff 	mov	r3, #255	; 0xff
3001f00c:	ebffd6ee 	bl	30014bcc <ip_output>
  pbuf_free(p);
3001f010:	e59d0018 	ldr	r0, [sp, #24]
3001f014:	ebffdc99 	bl	30016280 <pbuf_free>
3001f018:	ea000000 	b	3001f020 <tcp_rst+0x370>
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
3001f01c:	e1a00000 	nop			; (mov r0, r0)
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
3001f020:	e28dd024 	add	sp, sp, #36	; 0x24
3001f024:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001f028:	e12fff1e 	bx	lr
3001f02c:	302be570 	.word	0x302be570

3001f030 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
3001f030:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001f034:	e24dd014 	sub	sp, sp, #20
3001f038:	e58d0004 	str	r0, [sp, #4]
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
3001f03c:	e59d3004 	ldr	r3, [sp, #4]
3001f040:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001f044:	e3530000 	cmp	r3, #0
3001f048:	0a000033 	beq	3001f11c <tcp_rexmit_rto+0xec>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
3001f04c:	e59d3004 	ldr	r3, [sp, #4]
3001f050:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001f054:	e58d300c 	str	r3, [sp, #12]
3001f058:	ea000002 	b	3001f068 <tcp_rexmit_rto+0x38>
3001f05c:	e59d300c 	ldr	r3, [sp, #12]
3001f060:	e5933000 	ldr	r3, [r3]
3001f064:	e58d300c 	str	r3, [sp, #12]
3001f068:	e59d300c 	ldr	r3, [sp, #12]
3001f06c:	e5933000 	ldr	r3, [r3]
3001f070:	e3530000 	cmp	r3, #0
3001f074:	1afffff8 	bne	3001f05c <tcp_rexmit_rto+0x2c>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
3001f078:	e59d3004 	ldr	r3, [sp, #4]
3001f07c:	e5932070 	ldr	r2, [r3, #112]	; 0x70
3001f080:	e59d300c 	ldr	r3, [sp, #12]
3001f084:	e5832000 	str	r2, [r3]
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
3001f088:	e59d3004 	ldr	r3, [sp, #4]
3001f08c:	e5932074 	ldr	r2, [r3, #116]	; 0x74
3001f090:	e59d3004 	ldr	r3, [sp, #4]
3001f094:	e5832070 	str	r2, [r3, #112]	; 0x70
  /* unacked queue is now empty */
  pcb->unacked = NULL;
3001f098:	e59d3004 	ldr	r3, [sp, #4]
3001f09c:	e3a02000 	mov	r2, #0
3001f0a0:	e5832074 	str	r2, [r3, #116]	; 0x74

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
3001f0a4:	e59d3004 	ldr	r3, [sp, #4]
3001f0a8:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001f0ac:	e5933010 	ldr	r3, [r3, #16]
3001f0b0:	e5d32004 	ldrb	r2, [r3, #4]
3001f0b4:	e5d31005 	ldrb	r1, [r3, #5]
3001f0b8:	e1a01401 	lsl	r1, r1, #8
3001f0bc:	e1812002 	orr	r2, r1, r2
3001f0c0:	e5d31006 	ldrb	r1, [r3, #6]
3001f0c4:	e1a01801 	lsl	r1, r1, #16
3001f0c8:	e1812002 	orr	r2, r1, r2
3001f0cc:	e5d33007 	ldrb	r3, [r3, #7]
3001f0d0:	e1a03c03 	lsl	r3, r3, #24
3001f0d4:	e1833002 	orr	r3, r3, r2
3001f0d8:	e1a00003 	mov	r0, r3
3001f0dc:	ebffd178 	bl	300136c4 <ntohl>
3001f0e0:	e1a02000 	mov	r2, r0
3001f0e4:	e59d3004 	ldr	r3, [sp, #4]
3001f0e8:	e5832050 	str	r2, [r3, #80]	; 0x50
  /* increment number of retransmissions */
  ++pcb->nrtx;
3001f0ec:	e59d3004 	ldr	r3, [sp, #4]
3001f0f0:	e5d33042 	ldrb	r3, [r3, #66]	; 0x42
3001f0f4:	e2833001 	add	r3, r3, #1
3001f0f8:	e20320ff 	and	r2, r3, #255	; 0xff
3001f0fc:	e59d3004 	ldr	r3, [sp, #4]
3001f100:	e5c32042 	strb	r2, [r3, #66]	; 0x42

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
3001f104:	e59d3004 	ldr	r3, [sp, #4]
3001f108:	e3a02000 	mov	r2, #0
3001f10c:	e5832034 	str	r2, [r3, #52]	; 0x34

  /* Do the actual retransmission */
  tcp_output(pcb);
3001f110:	e59d0004 	ldr	r0, [sp, #4]
3001f114:	ebfffbae 	bl	3001dfd4 <tcp_output>
3001f118:	ea000000 	b	3001f120 <tcp_rexmit_rto+0xf0>
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
3001f11c:	e1a00000 	nop			; (mov r0, r0)
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
}
3001f120:	e28dd014 	add	sp, sp, #20
3001f124:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001f128:	e12fff1e 	bx	lr

3001f12c <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
3001f12c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001f130:	e24dd014 	sub	sp, sp, #20
3001f134:	e58d0004 	str	r0, [sp, #4]
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
3001f138:	e59d3004 	ldr	r3, [sp, #4]
3001f13c:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001f140:	e3530000 	cmp	r3, #0
3001f144:	0a00002d 	beq	3001f200 <tcp_rexmit+0xd4>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
3001f148:	e59d3004 	ldr	r3, [sp, #4]
3001f14c:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001f150:	e5933000 	ldr	r3, [r3]
3001f154:	e58d300c 	str	r3, [sp, #12]
  pcb->unacked->next = pcb->unsent;
3001f158:	e59d3004 	ldr	r3, [sp, #4]
3001f15c:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001f160:	e59d2004 	ldr	r2, [sp, #4]
3001f164:	e5922070 	ldr	r2, [r2, #112]	; 0x70
3001f168:	e5832000 	str	r2, [r3]
  pcb->unsent = pcb->unacked;
3001f16c:	e59d3004 	ldr	r3, [sp, #4]
3001f170:	e5932074 	ldr	r2, [r3, #116]	; 0x74
3001f174:	e59d3004 	ldr	r3, [sp, #4]
3001f178:	e5832070 	str	r2, [r3, #112]	; 0x70
  pcb->unacked = seg;
3001f17c:	e59d3004 	ldr	r3, [sp, #4]
3001f180:	e59d200c 	ldr	r2, [sp, #12]
3001f184:	e5832074 	str	r2, [r3, #116]	; 0x74

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
3001f188:	e59d3004 	ldr	r3, [sp, #4]
3001f18c:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001f190:	e5933010 	ldr	r3, [r3, #16]
3001f194:	e5d32004 	ldrb	r2, [r3, #4]
3001f198:	e5d31005 	ldrb	r1, [r3, #5]
3001f19c:	e1a01401 	lsl	r1, r1, #8
3001f1a0:	e1812002 	orr	r2, r1, r2
3001f1a4:	e5d31006 	ldrb	r1, [r3, #6]
3001f1a8:	e1a01801 	lsl	r1, r1, #16
3001f1ac:	e1812002 	orr	r2, r1, r2
3001f1b0:	e5d33007 	ldrb	r3, [r3, #7]
3001f1b4:	e1a03c03 	lsl	r3, r3, #24
3001f1b8:	e1833002 	orr	r3, r3, r2
3001f1bc:	e1a00003 	mov	r0, r3
3001f1c0:	ebffd13f 	bl	300136c4 <ntohl>
3001f1c4:	e1a02000 	mov	r2, r0
3001f1c8:	e59d3004 	ldr	r3, [sp, #4]
3001f1cc:	e5832050 	str	r2, [r3, #80]	; 0x50

  ++pcb->nrtx;
3001f1d0:	e59d3004 	ldr	r3, [sp, #4]
3001f1d4:	e5d33042 	ldrb	r3, [r3, #66]	; 0x42
3001f1d8:	e2833001 	add	r3, r3, #1
3001f1dc:	e20320ff 	and	r2, r3, #255	; 0xff
3001f1e0:	e59d3004 	ldr	r3, [sp, #4]
3001f1e4:	e5c32042 	strb	r2, [r3, #66]	; 0x42

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
3001f1e8:	e59d3004 	ldr	r3, [sp, #4]
3001f1ec:	e3a02000 	mov	r2, #0
3001f1f0:	e5832034 	str	r2, [r3, #52]	; 0x34

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
3001f1f4:	e59d0004 	ldr	r0, [sp, #4]
3001f1f8:	ebfffb75 	bl	3001dfd4 <tcp_output>
3001f1fc:	ea000000 	b	3001f204 <tcp_rexmit+0xd8>
tcp_rexmit(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
3001f200:	e1a00000 	nop			; (mov r0, r0)
  pcb->rttest = 0;

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
}
3001f204:	e28dd014 	add	sp, sp, #20
3001f208:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001f20c:	e12fff1e 	bx	lr

3001f210 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
3001f210:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001f214:	e24dd01c 	sub	sp, sp, #28
3001f218:	e58d000c 	str	r0, [sp, #12]
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
3001f21c:	e3a00001 	mov	r0, #1
3001f220:	e3a01014 	mov	r1, #20
3001f224:	e3a02000 	mov	r2, #0
3001f228:	ebffda62 	bl	30015bb8 <pbuf_alloc>
3001f22c:	e1a03000 	mov	r3, r0
3001f230:	e58d3010 	str	r3, [sp, #16]
   
  if(p == NULL) {
3001f234:	e59d3010 	ldr	r3, [sp, #16]
3001f238:	e3530000 	cmp	r3, #0
3001f23c:	0a0000d6 	beq	3001f59c <tcp_keepalive+0x38c>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
3001f240:	e59d3010 	ldr	r3, [sp, #16]
3001f244:	e5933004 	ldr	r3, [r3, #4]
3001f248:	e58d3014 	str	r3, [sp, #20]
  tcphdr->src = htons(pcb->local_port);
3001f24c:	e59d300c 	ldr	r3, [sp, #12]
3001f250:	e1d331b8 	ldrh	r3, [r3, #24]
3001f254:	e1a00003 	mov	r0, r3
3001f258:	ebffd0e8 	bl	30013600 <htons>
3001f25c:	e1a03000 	mov	r3, r0
3001f260:	e1a02003 	mov	r2, r3
3001f264:	e59d3014 	ldr	r3, [sp, #20]
3001f268:	e20210ff 	and	r1, r2, #255	; 0xff
3001f26c:	e3a00000 	mov	r0, #0
3001f270:	e1801001 	orr	r1, r0, r1
3001f274:	e5c31000 	strb	r1, [r3]
3001f278:	e1a02422 	lsr	r2, r2, #8
3001f27c:	e1a02802 	lsl	r2, r2, #16
3001f280:	e1a02822 	lsr	r2, r2, #16
3001f284:	e3a01000 	mov	r1, #0
3001f288:	e1812002 	orr	r2, r1, r2
3001f28c:	e5c32001 	strb	r2, [r3, #1]
  tcphdr->dest = htons(pcb->remote_port);
3001f290:	e59d300c 	ldr	r3, [sp, #12]
3001f294:	e1d331ba 	ldrh	r3, [r3, #26]
3001f298:	e1a00003 	mov	r0, r3
3001f29c:	ebffd0d7 	bl	30013600 <htons>
3001f2a0:	e1a03000 	mov	r3, r0
3001f2a4:	e1a02003 	mov	r2, r3
3001f2a8:	e59d3014 	ldr	r3, [sp, #20]
3001f2ac:	e20210ff 	and	r1, r2, #255	; 0xff
3001f2b0:	e3a00000 	mov	r0, #0
3001f2b4:	e1801001 	orr	r1, r0, r1
3001f2b8:	e5c31002 	strb	r1, [r3, #2]
3001f2bc:	e1a02422 	lsr	r2, r2, #8
3001f2c0:	e1a02802 	lsl	r2, r2, #16
3001f2c4:	e1a02822 	lsr	r2, r2, #16
3001f2c8:	e3a01000 	mov	r1, #0
3001f2cc:	e1812002 	orr	r2, r1, r2
3001f2d0:	e5c32003 	strb	r2, [r3, #3]
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
3001f2d4:	e59d300c 	ldr	r3, [sp, #12]
3001f2d8:	e5933050 	ldr	r3, [r3, #80]	; 0x50
3001f2dc:	e2433001 	sub	r3, r3, #1
3001f2e0:	e1a00003 	mov	r0, r3
3001f2e4:	ebffd0e4 	bl	3001367c <htonl>
3001f2e8:	e1a02000 	mov	r2, r0
3001f2ec:	e59d3014 	ldr	r3, [sp, #20]
3001f2f0:	e20210ff 	and	r1, r2, #255	; 0xff
3001f2f4:	e3a00000 	mov	r0, #0
3001f2f8:	e1801001 	orr	r1, r0, r1
3001f2fc:	e5c31004 	strb	r1, [r3, #4]
3001f300:	e1a01422 	lsr	r1, r2, #8
3001f304:	e20110ff 	and	r1, r1, #255	; 0xff
3001f308:	e3a00000 	mov	r0, #0
3001f30c:	e1801001 	orr	r1, r0, r1
3001f310:	e5c31005 	strb	r1, [r3, #5]
3001f314:	e1a01822 	lsr	r1, r2, #16
3001f318:	e20110ff 	and	r1, r1, #255	; 0xff
3001f31c:	e3a00000 	mov	r0, #0
3001f320:	e1801001 	orr	r1, r0, r1
3001f324:	e5c31006 	strb	r1, [r3, #6]
3001f328:	e1a02c22 	lsr	r2, r2, #24
3001f32c:	e3a01000 	mov	r1, #0
3001f330:	e1812002 	orr	r2, r1, r2
3001f334:	e5c32007 	strb	r2, [r3, #7]
  tcphdr->ackno = htonl(pcb->rcv_nxt);
3001f338:	e59d300c 	ldr	r3, [sp, #12]
3001f33c:	e5933020 	ldr	r3, [r3, #32]
3001f340:	e1a00003 	mov	r0, r3
3001f344:	ebffd0cc 	bl	3001367c <htonl>
3001f348:	e1a02000 	mov	r2, r0
3001f34c:	e59d3014 	ldr	r3, [sp, #20]
3001f350:	e20210ff 	and	r1, r2, #255	; 0xff
3001f354:	e3a00000 	mov	r0, #0
3001f358:	e1801001 	orr	r1, r0, r1
3001f35c:	e5c31008 	strb	r1, [r3, #8]
3001f360:	e1a01422 	lsr	r1, r2, #8
3001f364:	e20110ff 	and	r1, r1, #255	; 0xff
3001f368:	e3a00000 	mov	r0, #0
3001f36c:	e1801001 	orr	r1, r0, r1
3001f370:	e5c31009 	strb	r1, [r3, #9]
3001f374:	e1a01822 	lsr	r1, r2, #16
3001f378:	e20110ff 	and	r1, r1, #255	; 0xff
3001f37c:	e3a00000 	mov	r0, #0
3001f380:	e1801001 	orr	r1, r0, r1
3001f384:	e5c3100a 	strb	r1, [r3, #10]
3001f388:	e1a02c22 	lsr	r2, r2, #24
3001f38c:	e3a01000 	mov	r1, #0
3001f390:	e1812002 	orr	r2, r1, r2
3001f394:	e5c3200b 	strb	r2, [r3, #11]
  TCPH_FLAGS_SET(tcphdr, 0);
3001f398:	e59d3014 	ldr	r3, [sp, #20]
3001f39c:	e5d3200c 	ldrb	r2, [r3, #12]
3001f3a0:	e5d3300d 	ldrb	r3, [r3, #13]
3001f3a4:	e1a03403 	lsl	r3, r3, #8
3001f3a8:	e1833002 	orr	r3, r3, r2
3001f3ac:	e1a03803 	lsl	r3, r3, #16
3001f3b0:	e1a03823 	lsr	r3, r3, #16
3001f3b4:	e1a00003 	mov	r0, r3
3001f3b8:	ebffd0a3 	bl	3001364c <ntohs>
3001f3bc:	e1a03000 	mov	r3, r0
3001f3c0:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3001f3c4:	e1a03803 	lsl	r3, r3, #16
3001f3c8:	e1a03823 	lsr	r3, r3, #16
3001f3cc:	e1a00003 	mov	r0, r3
3001f3d0:	ebffd08a 	bl	30013600 <htons>
3001f3d4:	e1a03000 	mov	r3, r0
3001f3d8:	e1a02003 	mov	r2, r3
3001f3dc:	e59d3014 	ldr	r3, [sp, #20]
3001f3e0:	e20210ff 	and	r1, r2, #255	; 0xff
3001f3e4:	e3a00000 	mov	r0, #0
3001f3e8:	e1801001 	orr	r1, r0, r1
3001f3ec:	e5c3100c 	strb	r1, [r3, #12]
3001f3f0:	e1a02422 	lsr	r2, r2, #8
3001f3f4:	e1a02802 	lsl	r2, r2, #16
3001f3f8:	e1a02822 	lsr	r2, r2, #16
3001f3fc:	e3a01000 	mov	r1, #0
3001f400:	e1812002 	orr	r2, r1, r2
3001f404:	e5c3200d 	strb	r2, [r3, #13]
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
3001f408:	e59d300c 	ldr	r3, [sp, #12]
3001f40c:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
3001f410:	e1a00003 	mov	r0, r3
3001f414:	ebffd079 	bl	30013600 <htons>
3001f418:	e1a03000 	mov	r3, r0
3001f41c:	e1a02003 	mov	r2, r3
3001f420:	e59d3014 	ldr	r3, [sp, #20]
3001f424:	e20210ff 	and	r1, r2, #255	; 0xff
3001f428:	e3a00000 	mov	r0, #0
3001f42c:	e1801001 	orr	r1, r0, r1
3001f430:	e5c3100e 	strb	r1, [r3, #14]
3001f434:	e1a02422 	lsr	r2, r2, #8
3001f438:	e1a02802 	lsl	r2, r2, #16
3001f43c:	e1a02822 	lsr	r2, r2, #16
3001f440:	e3a01000 	mov	r1, #0
3001f444:	e1812002 	orr	r2, r1, r2
3001f448:	e5c3200f 	strb	r2, [r3, #15]
  tcphdr->urgp = 0;
3001f44c:	e59d3014 	ldr	r3, [sp, #20]
3001f450:	e3a02000 	mov	r2, #0
3001f454:	e5c32012 	strb	r2, [r3, #18]
3001f458:	e3a02000 	mov	r2, #0
3001f45c:	e5c32013 	strb	r2, [r3, #19]
  TCPH_HDRLEN_SET(tcphdr, 5);
3001f460:	e59d3014 	ldr	r3, [sp, #20]
3001f464:	e5d3200c 	ldrb	r2, [r3, #12]
3001f468:	e5d3300d 	ldrb	r3, [r3, #13]
3001f46c:	e1a03403 	lsl	r3, r3, #8
3001f470:	e1833002 	orr	r3, r3, r2
3001f474:	e1a03803 	lsl	r3, r3, #16
3001f478:	e1a03823 	lsr	r3, r3, #16
3001f47c:	e1a00003 	mov	r0, r3
3001f480:	ebffd071 	bl	3001364c <ntohs>
3001f484:	e1a03000 	mov	r3, r0
3001f488:	e203303f 	and	r3, r3, #63	; 0x3f
3001f48c:	e3833a05 	orr	r3, r3, #20480	; 0x5000
3001f490:	e1a03803 	lsl	r3, r3, #16
3001f494:	e1a03823 	lsr	r3, r3, #16
3001f498:	e1a00003 	mov	r0, r3
3001f49c:	ebffd057 	bl	30013600 <htons>
3001f4a0:	e1a03000 	mov	r3, r0
3001f4a4:	e1a02003 	mov	r2, r3
3001f4a8:	e59d3014 	ldr	r3, [sp, #20]
3001f4ac:	e20210ff 	and	r1, r2, #255	; 0xff
3001f4b0:	e3a00000 	mov	r0, #0
3001f4b4:	e1801001 	orr	r1, r0, r1
3001f4b8:	e5c3100c 	strb	r1, [r3, #12]
3001f4bc:	e1a02422 	lsr	r2, r2, #8
3001f4c0:	e1a02802 	lsl	r2, r2, #16
3001f4c4:	e1a02822 	lsr	r2, r2, #16
3001f4c8:	e3a01000 	mov	r1, #0
3001f4cc:	e1812002 	orr	r2, r1, r2
3001f4d0:	e5c3200d 	strb	r2, [r3, #13]

  tcphdr->chksum = 0;
3001f4d4:	e59d3014 	ldr	r3, [sp, #20]
3001f4d8:	e3a02000 	mov	r2, #0
3001f4dc:	e5c32010 	strb	r2, [r3, #16]
3001f4e0:	e3a02000 	mov	r2, #0
3001f4e4:	e5c32011 	strb	r2, [r3, #17]
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
3001f4e8:	e59d200c 	ldr	r2, [sp, #12]
3001f4ec:	e59d300c 	ldr	r3, [sp, #12]
3001f4f0:	e2833004 	add	r3, r3, #4
3001f4f4:	e59d1010 	ldr	r1, [sp, #16]
3001f4f8:	e1d110b8 	ldrh	r1, [r1, #8]
3001f4fc:	e58d1000 	str	r1, [sp]
3001f500:	e59d0010 	ldr	r0, [sp, #16]
3001f504:	e1a01002 	mov	r1, r2
3001f508:	e1a02003 	mov	r2, r3
3001f50c:	e3a03006 	mov	r3, #6
3001f510:	ebffd0c1 	bl	3001381c <inet_chksum_pseudo>
3001f514:	e1a03000 	mov	r3, r0
3001f518:	e1a02003 	mov	r2, r3
3001f51c:	e59d3014 	ldr	r3, [sp, #20]
3001f520:	e20210ff 	and	r1, r2, #255	; 0xff
3001f524:	e3a00000 	mov	r0, #0
3001f528:	e1801001 	orr	r1, r0, r1
3001f52c:	e5c31010 	strb	r1, [r3, #16]
3001f530:	e1a02422 	lsr	r2, r2, #8
3001f534:	e1a02802 	lsl	r2, r2, #16
3001f538:	e1a02822 	lsr	r2, r2, #16
3001f53c:	e3a01000 	mov	r1, #0
3001f540:	e1812002 	orr	r2, r1, r2
3001f544:	e5c32011 	strb	r2, [r3, #17]
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
3001f548:	e59f305c 	ldr	r3, [pc, #92]	; 3001f5ac <tcp_keepalive+0x39c>
3001f54c:	e1d339bc 	ldrh	r3, [r3, #156]	; 0x9c
3001f550:	e2833001 	add	r3, r3, #1
3001f554:	e1a03803 	lsl	r3, r3, #16
3001f558:	e1a02823 	lsr	r2, r3, #16
3001f55c:	e59f3048 	ldr	r3, [pc, #72]	; 3001f5ac <tcp_keepalive+0x39c>
3001f560:	e1c329bc 	strh	r2, [r3, #156]	; 0x9c
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
3001f564:	e59d100c 	ldr	r1, [sp, #12]
3001f568:	e59d300c 	ldr	r3, [sp, #12]
3001f56c:	e2832004 	add	r2, r3, #4
3001f570:	e59d300c 	ldr	r3, [sp, #12]
3001f574:	e5d3300b 	ldrb	r3, [r3, #11]
3001f578:	e3a00000 	mov	r0, #0
3001f57c:	e58d0000 	str	r0, [sp]
3001f580:	e3a00006 	mov	r0, #6
3001f584:	e58d0004 	str	r0, [sp, #4]
3001f588:	e59d0010 	ldr	r0, [sp, #16]
3001f58c:	ebffd58e 	bl	30014bcc <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
3001f590:	e59d0010 	ldr	r0, [sp, #16]
3001f594:	ebffdb39 	bl	30016280 <pbuf_free>
3001f598:	ea000000 	b	3001f5a0 <tcp_keepalive+0x390>
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
   
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
3001f59c:	e1a00000 	nop			; (mov r0, r0)

  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
3001f5a0:	e28dd01c 	add	sp, sp, #28
3001f5a4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001f5a8:	e12fff1e 	bx	lr
3001f5ac:	302be570 	.word	0x302be570

3001f5b0 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
3001f5b0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3001f5b4:	e24dd024 	sub	sp, sp, #36	; 0x24
3001f5b8:	e58d000c 	str	r0, [sp, #12]
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
3001f5bc:	e59d300c 	ldr	r3, [sp, #12]
3001f5c0:	e5933074 	ldr	r3, [r3, #116]	; 0x74
3001f5c4:	e58d301c 	str	r3, [sp, #28]

  if(seg == NULL)
3001f5c8:	e59d301c 	ldr	r3, [sp, #28]
3001f5cc:	e3530000 	cmp	r3, #0
3001f5d0:	1a000002 	bne	3001f5e0 <tcp_zero_window_probe+0x30>
    seg = pcb->unsent;
3001f5d4:	e59d300c 	ldr	r3, [sp, #12]
3001f5d8:	e5933070 	ldr	r3, [r3, #112]	; 0x70
3001f5dc:	e58d301c 	str	r3, [sp, #28]

  if(seg == NULL)
3001f5e0:	e59d301c 	ldr	r3, [sp, #28]
3001f5e4:	e3530000 	cmp	r3, #0
3001f5e8:	0a0000ed 	beq	3001f9a4 <tcp_zero_window_probe+0x3f4>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
3001f5ec:	e3a00001 	mov	r0, #1
3001f5f0:	e3a01015 	mov	r1, #21
3001f5f4:	e3a02000 	mov	r2, #0
3001f5f8:	ebffd96e 	bl	30015bb8 <pbuf_alloc>
3001f5fc:	e1a03000 	mov	r3, r0
3001f600:	e58d3014 	str	r3, [sp, #20]
   
  if(p == NULL) {
3001f604:	e59d3014 	ldr	r3, [sp, #20]
3001f608:	e3530000 	cmp	r3, #0
3001f60c:	0a0000e6 	beq	3001f9ac <tcp_zero_window_probe+0x3fc>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
3001f610:	e59d3014 	ldr	r3, [sp, #20]
3001f614:	e5933004 	ldr	r3, [r3, #4]
3001f618:	e58d3018 	str	r3, [sp, #24]
  tcphdr->src = htons(pcb->local_port);
3001f61c:	e59d300c 	ldr	r3, [sp, #12]
3001f620:	e1d331b8 	ldrh	r3, [r3, #24]
3001f624:	e1a00003 	mov	r0, r3
3001f628:	ebffcff4 	bl	30013600 <htons>
3001f62c:	e1a03000 	mov	r3, r0
3001f630:	e1a02003 	mov	r2, r3
3001f634:	e59d3018 	ldr	r3, [sp, #24]
3001f638:	e20210ff 	and	r1, r2, #255	; 0xff
3001f63c:	e3a00000 	mov	r0, #0
3001f640:	e1801001 	orr	r1, r0, r1
3001f644:	e5c31000 	strb	r1, [r3]
3001f648:	e1a02422 	lsr	r2, r2, #8
3001f64c:	e1a02802 	lsl	r2, r2, #16
3001f650:	e1a02822 	lsr	r2, r2, #16
3001f654:	e3a01000 	mov	r1, #0
3001f658:	e1812002 	orr	r2, r1, r2
3001f65c:	e5c32001 	strb	r2, [r3, #1]
  tcphdr->dest = htons(pcb->remote_port);
3001f660:	e59d300c 	ldr	r3, [sp, #12]
3001f664:	e1d331ba 	ldrh	r3, [r3, #26]
3001f668:	e1a00003 	mov	r0, r3
3001f66c:	ebffcfe3 	bl	30013600 <htons>
3001f670:	e1a03000 	mov	r3, r0
3001f674:	e1a02003 	mov	r2, r3
3001f678:	e59d3018 	ldr	r3, [sp, #24]
3001f67c:	e20210ff 	and	r1, r2, #255	; 0xff
3001f680:	e3a00000 	mov	r0, #0
3001f684:	e1801001 	orr	r1, r0, r1
3001f688:	e5c31002 	strb	r1, [r3, #2]
3001f68c:	e1a02422 	lsr	r2, r2, #8
3001f690:	e1a02802 	lsl	r2, r2, #16
3001f694:	e1a02822 	lsr	r2, r2, #16
3001f698:	e3a01000 	mov	r1, #0
3001f69c:	e1812002 	orr	r2, r1, r2
3001f6a0:	e5c32003 	strb	r2, [r3, #3]
  tcphdr->seqno = seg->tcphdr->seqno;
3001f6a4:	e59d301c 	ldr	r3, [sp, #28]
3001f6a8:	e5933010 	ldr	r3, [r3, #16]
3001f6ac:	e5d32004 	ldrb	r2, [r3, #4]
3001f6b0:	e5d31005 	ldrb	r1, [r3, #5]
3001f6b4:	e1a01401 	lsl	r1, r1, #8
3001f6b8:	e1812002 	orr	r2, r1, r2
3001f6bc:	e5d31006 	ldrb	r1, [r3, #6]
3001f6c0:	e1a01801 	lsl	r1, r1, #16
3001f6c4:	e1812002 	orr	r2, r1, r2
3001f6c8:	e5d33007 	ldrb	r3, [r3, #7]
3001f6cc:	e1a03c03 	lsl	r3, r3, #24
3001f6d0:	e1833002 	orr	r3, r3, r2
3001f6d4:	e1a02003 	mov	r2, r3
3001f6d8:	e59d3018 	ldr	r3, [sp, #24]
3001f6dc:	e20210ff 	and	r1, r2, #255	; 0xff
3001f6e0:	e3a00000 	mov	r0, #0
3001f6e4:	e1801001 	orr	r1, r0, r1
3001f6e8:	e5c31004 	strb	r1, [r3, #4]
3001f6ec:	e1a01422 	lsr	r1, r2, #8
3001f6f0:	e20110ff 	and	r1, r1, #255	; 0xff
3001f6f4:	e3a00000 	mov	r0, #0
3001f6f8:	e1801001 	orr	r1, r0, r1
3001f6fc:	e5c31005 	strb	r1, [r3, #5]
3001f700:	e1a01822 	lsr	r1, r2, #16
3001f704:	e20110ff 	and	r1, r1, #255	; 0xff
3001f708:	e3a00000 	mov	r0, #0
3001f70c:	e1801001 	orr	r1, r0, r1
3001f710:	e5c31006 	strb	r1, [r3, #6]
3001f714:	e1a02c22 	lsr	r2, r2, #24
3001f718:	e3a01000 	mov	r1, #0
3001f71c:	e1812002 	orr	r2, r1, r2
3001f720:	e5c32007 	strb	r2, [r3, #7]
  tcphdr->ackno = htonl(pcb->rcv_nxt);
3001f724:	e59d300c 	ldr	r3, [sp, #12]
3001f728:	e5933020 	ldr	r3, [r3, #32]
3001f72c:	e1a00003 	mov	r0, r3
3001f730:	ebffcfd1 	bl	3001367c <htonl>
3001f734:	e1a02000 	mov	r2, r0
3001f738:	e59d3018 	ldr	r3, [sp, #24]
3001f73c:	e20210ff 	and	r1, r2, #255	; 0xff
3001f740:	e3a00000 	mov	r0, #0
3001f744:	e1801001 	orr	r1, r0, r1
3001f748:	e5c31008 	strb	r1, [r3, #8]
3001f74c:	e1a01422 	lsr	r1, r2, #8
3001f750:	e20110ff 	and	r1, r1, #255	; 0xff
3001f754:	e3a00000 	mov	r0, #0
3001f758:	e1801001 	orr	r1, r0, r1
3001f75c:	e5c31009 	strb	r1, [r3, #9]
3001f760:	e1a01822 	lsr	r1, r2, #16
3001f764:	e20110ff 	and	r1, r1, #255	; 0xff
3001f768:	e3a00000 	mov	r0, #0
3001f76c:	e1801001 	orr	r1, r0, r1
3001f770:	e5c3100a 	strb	r1, [r3, #10]
3001f774:	e1a02c22 	lsr	r2, r2, #24
3001f778:	e3a01000 	mov	r1, #0
3001f77c:	e1812002 	orr	r2, r1, r2
3001f780:	e5c3200b 	strb	r2, [r3, #11]
  TCPH_FLAGS_SET(tcphdr, 0);
3001f784:	e59d3018 	ldr	r3, [sp, #24]
3001f788:	e5d3200c 	ldrb	r2, [r3, #12]
3001f78c:	e5d3300d 	ldrb	r3, [r3, #13]
3001f790:	e1a03403 	lsl	r3, r3, #8
3001f794:	e1833002 	orr	r3, r3, r2
3001f798:	e1a03803 	lsl	r3, r3, #16
3001f79c:	e1a03823 	lsr	r3, r3, #16
3001f7a0:	e1a00003 	mov	r0, r3
3001f7a4:	ebffcfa8 	bl	3001364c <ntohs>
3001f7a8:	e1a03000 	mov	r3, r0
3001f7ac:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3001f7b0:	e1a03803 	lsl	r3, r3, #16
3001f7b4:	e1a03823 	lsr	r3, r3, #16
3001f7b8:	e1a00003 	mov	r0, r3
3001f7bc:	ebffcf8f 	bl	30013600 <htons>
3001f7c0:	e1a03000 	mov	r3, r0
3001f7c4:	e1a02003 	mov	r2, r3
3001f7c8:	e59d3018 	ldr	r3, [sp, #24]
3001f7cc:	e20210ff 	and	r1, r2, #255	; 0xff
3001f7d0:	e3a00000 	mov	r0, #0
3001f7d4:	e1801001 	orr	r1, r0, r1
3001f7d8:	e5c3100c 	strb	r1, [r3, #12]
3001f7dc:	e1a02422 	lsr	r2, r2, #8
3001f7e0:	e1a02802 	lsl	r2, r2, #16
3001f7e4:	e1a02822 	lsr	r2, r2, #16
3001f7e8:	e3a01000 	mov	r1, #0
3001f7ec:	e1812002 	orr	r2, r1, r2
3001f7f0:	e5c3200d 	strb	r2, [r3, #13]
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
3001f7f4:	e59d300c 	ldr	r3, [sp, #12]
3001f7f8:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
3001f7fc:	e1a00003 	mov	r0, r3
3001f800:	ebffcf7e 	bl	30013600 <htons>
3001f804:	e1a03000 	mov	r3, r0
3001f808:	e1a02003 	mov	r2, r3
3001f80c:	e59d3018 	ldr	r3, [sp, #24]
3001f810:	e20210ff 	and	r1, r2, #255	; 0xff
3001f814:	e3a00000 	mov	r0, #0
3001f818:	e1801001 	orr	r1, r0, r1
3001f81c:	e5c3100e 	strb	r1, [r3, #14]
3001f820:	e1a02422 	lsr	r2, r2, #8
3001f824:	e1a02802 	lsl	r2, r2, #16
3001f828:	e1a02822 	lsr	r2, r2, #16
3001f82c:	e3a01000 	mov	r1, #0
3001f830:	e1812002 	orr	r2, r1, r2
3001f834:	e5c3200f 	strb	r2, [r3, #15]
  tcphdr->urgp = 0;
3001f838:	e59d3018 	ldr	r3, [sp, #24]
3001f83c:	e3a02000 	mov	r2, #0
3001f840:	e5c32012 	strb	r2, [r3, #18]
3001f844:	e3a02000 	mov	r2, #0
3001f848:	e5c32013 	strb	r2, [r3, #19]
  TCPH_HDRLEN_SET(tcphdr, 5);
3001f84c:	e59d3018 	ldr	r3, [sp, #24]
3001f850:	e5d3200c 	ldrb	r2, [r3, #12]
3001f854:	e5d3300d 	ldrb	r3, [r3, #13]
3001f858:	e1a03403 	lsl	r3, r3, #8
3001f85c:	e1833002 	orr	r3, r3, r2
3001f860:	e1a03803 	lsl	r3, r3, #16
3001f864:	e1a03823 	lsr	r3, r3, #16
3001f868:	e1a00003 	mov	r0, r3
3001f86c:	ebffcf76 	bl	3001364c <ntohs>
3001f870:	e1a03000 	mov	r3, r0
3001f874:	e203303f 	and	r3, r3, #63	; 0x3f
3001f878:	e3833a05 	orr	r3, r3, #20480	; 0x5000
3001f87c:	e1a03803 	lsl	r3, r3, #16
3001f880:	e1a03823 	lsr	r3, r3, #16
3001f884:	e1a00003 	mov	r0, r3
3001f888:	ebffcf5c 	bl	30013600 <htons>
3001f88c:	e1a03000 	mov	r3, r0
3001f890:	e1a02003 	mov	r2, r3
3001f894:	e59d3018 	ldr	r3, [sp, #24]
3001f898:	e20210ff 	and	r1, r2, #255	; 0xff
3001f89c:	e3a00000 	mov	r0, #0
3001f8a0:	e1801001 	orr	r1, r0, r1
3001f8a4:	e5c3100c 	strb	r1, [r3, #12]
3001f8a8:	e1a02422 	lsr	r2, r2, #8
3001f8ac:	e1a02802 	lsl	r2, r2, #16
3001f8b0:	e1a02822 	lsr	r2, r2, #16
3001f8b4:	e3a01000 	mov	r1, #0
3001f8b8:	e1812002 	orr	r2, r1, r2
3001f8bc:	e5c3200d 	strb	r2, [r3, #13]

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
3001f8c0:	e59d3014 	ldr	r3, [sp, #20]
3001f8c4:	e5933004 	ldr	r3, [r3, #4]
3001f8c8:	e2833014 	add	r3, r3, #20
3001f8cc:	e59d201c 	ldr	r2, [sp, #28]
3001f8d0:	e5922008 	ldr	r2, [r2, #8]
3001f8d4:	e5d22000 	ldrb	r2, [r2]
3001f8d8:	e5c32000 	strb	r2, [r3]

  tcphdr->chksum = 0;
3001f8dc:	e59d3018 	ldr	r3, [sp, #24]
3001f8e0:	e3a02000 	mov	r2, #0
3001f8e4:	e5c32010 	strb	r2, [r3, #16]
3001f8e8:	e3a02000 	mov	r2, #0
3001f8ec:	e5c32011 	strb	r2, [r3, #17]
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
3001f8f0:	e59d200c 	ldr	r2, [sp, #12]
3001f8f4:	e59d300c 	ldr	r3, [sp, #12]
3001f8f8:	e2833004 	add	r3, r3, #4
3001f8fc:	e59d1014 	ldr	r1, [sp, #20]
3001f900:	e1d110b8 	ldrh	r1, [r1, #8]
3001f904:	e58d1000 	str	r1, [sp]
3001f908:	e59d0014 	ldr	r0, [sp, #20]
3001f90c:	e1a01002 	mov	r1, r2
3001f910:	e1a02003 	mov	r2, r3
3001f914:	e3a03006 	mov	r3, #6
3001f918:	ebffcfbf 	bl	3001381c <inet_chksum_pseudo>
3001f91c:	e1a03000 	mov	r3, r0
3001f920:	e1a02003 	mov	r2, r3
3001f924:	e59d3018 	ldr	r3, [sp, #24]
3001f928:	e20210ff 	and	r1, r2, #255	; 0xff
3001f92c:	e3a00000 	mov	r0, #0
3001f930:	e1801001 	orr	r1, r0, r1
3001f934:	e5c31010 	strb	r1, [r3, #16]
3001f938:	e1a02422 	lsr	r2, r2, #8
3001f93c:	e1a02802 	lsl	r2, r2, #16
3001f940:	e1a02822 	lsr	r2, r2, #16
3001f944:	e3a01000 	mov	r1, #0
3001f948:	e1812002 	orr	r2, r1, r2
3001f94c:	e5c32011 	strb	r2, [r3, #17]
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
3001f950:	e59f3064 	ldr	r3, [pc, #100]	; 3001f9bc <tcp_zero_window_probe+0x40c>
3001f954:	e1d339bc 	ldrh	r3, [r3, #156]	; 0x9c
3001f958:	e2833001 	add	r3, r3, #1
3001f95c:	e1a03803 	lsl	r3, r3, #16
3001f960:	e1a02823 	lsr	r2, r3, #16
3001f964:	e59f3050 	ldr	r3, [pc, #80]	; 3001f9bc <tcp_zero_window_probe+0x40c>
3001f968:	e1c329bc 	strh	r2, [r3, #156]	; 0x9c
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
3001f96c:	e59d100c 	ldr	r1, [sp, #12]
3001f970:	e59d300c 	ldr	r3, [sp, #12]
3001f974:	e2832004 	add	r2, r3, #4
3001f978:	e59d300c 	ldr	r3, [sp, #12]
3001f97c:	e5d3300b 	ldrb	r3, [r3, #11]
3001f980:	e3a00000 	mov	r0, #0
3001f984:	e58d0000 	str	r0, [sp]
3001f988:	e3a00006 	mov	r0, #6
3001f98c:	e58d0004 	str	r0, [sp, #4]
3001f990:	e59d0014 	ldr	r0, [sp, #20]
3001f994:	ebffd48c 	bl	30014bcc <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
3001f998:	e59d0014 	ldr	r0, [sp, #20]
3001f99c:	ebffda37 	bl	30016280 <pbuf_free>
3001f9a0:	ea000002 	b	3001f9b0 <tcp_zero_window_probe+0x400>

  if(seg == NULL)
    seg = pcb->unsent;

  if(seg == NULL)
    return;
3001f9a4:	e1a00000 	nop			; (mov r0, r0)
3001f9a8:	ea000000 	b	3001f9b0 <tcp_zero_window_probe+0x400>

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
   
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
3001f9ac:	e1a00000 	nop			; (mov r0, r0)
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
3001f9b0:	e28dd024 	add	sp, sp, #36	; 0x24
3001f9b4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3001f9b8:	e12fff1e 	bx	lr
3001f9bc:	302be570 	.word	0x302be570

3001f9c0 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
3001f9c0:	e92d4010 	push	{r4, lr}
3001f9c4:	e24dd030 	sub	sp, sp, #48	; 0x30
3001f9c8:	e58d000c 	str	r0, [sp, #12]
3001f9cc:	e58d1008 	str	r1, [sp, #8]
  u8_t local_match;

  PERF_START;

  //acoral_prints("\nudp: udp_input \n");
  UDP_STATS_INC(udp.recv);
3001f9d0:	e59f3654 	ldr	r3, [pc, #1620]	; 3002002c <udp_input+0x66c>
3001f9d4:	e1d338b6 	ldrh	r3, [r3, #134]	; 0x86
3001f9d8:	e2833001 	add	r3, r3, #1
3001f9dc:	e1a03803 	lsl	r3, r3, #16
3001f9e0:	e1a02823 	lsr	r2, r3, #16
3001f9e4:	e59f3640 	ldr	r3, [pc, #1600]	; 3002002c <udp_input+0x66c>
3001f9e8:	e1c328b6 	strh	r2, [r3, #134]	; 0x86

  iphdr = p->payload;
3001f9ec:	e59d300c 	ldr	r3, [sp, #12]
3001f9f0:	e5933004 	ldr	r3, [r3, #4]
3001f9f4:	e58d3024 	str	r3, [sp, #36]	; 0x24

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
3001f9f8:	e59d300c 	ldr	r3, [sp, #12]
3001f9fc:	e1d330b8 	ldrh	r3, [r3, #8]
3001fa00:	e1a04003 	mov	r4, r3
3001fa04:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001fa08:	e5d32000 	ldrb	r2, [r3]
3001fa0c:	e5d33001 	ldrb	r3, [r3, #1]
3001fa10:	e1a03403 	lsl	r3, r3, #8
3001fa14:	e1833002 	orr	r3, r3, r2
3001fa18:	e1a03803 	lsl	r3, r3, #16
3001fa1c:	e1a03823 	lsr	r3, r3, #16
3001fa20:	e1a00003 	mov	r0, r3
3001fa24:	ebffcf08 	bl	3001364c <ntohs>
3001fa28:	e1a03000 	mov	r3, r0
3001fa2c:	e1a03423 	lsr	r3, r3, #8
3001fa30:	e1a03803 	lsl	r3, r3, #16
3001fa34:	e1a03823 	lsr	r3, r3, #16
3001fa38:	e203300f 	and	r3, r3, #15
3001fa3c:	e2833002 	add	r3, r3, #2
3001fa40:	e1a03103 	lsl	r3, r3, #2
3001fa44:	e1540003 	cmp	r4, r3
3001fa48:	ba00001b 	blt	3001fabc <udp_input+0xfc>
3001fa4c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001fa50:	e5d32000 	ldrb	r2, [r3]
3001fa54:	e5d33001 	ldrb	r3, [r3, #1]
3001fa58:	e1a03403 	lsl	r3, r3, #8
3001fa5c:	e1833002 	orr	r3, r3, r2
3001fa60:	e1a03803 	lsl	r3, r3, #16
3001fa64:	e1a03823 	lsr	r3, r3, #16
3001fa68:	e1a00003 	mov	r0, r3
3001fa6c:	ebffcef6 	bl	3001364c <ntohs>
3001fa70:	e1a03000 	mov	r3, r0
3001fa74:	e1a03423 	lsr	r3, r3, #8
3001fa78:	e1a03803 	lsl	r3, r3, #16
3001fa7c:	e1a03823 	lsr	r3, r3, #16
3001fa80:	e203300f 	and	r3, r3, #15
3001fa84:	e1a03103 	lsl	r3, r3, #2
3001fa88:	e1a03803 	lsl	r3, r3, #16
3001fa8c:	e1a03823 	lsr	r3, r3, #16
3001fa90:	e2633000 	rsb	r3, r3, #0
3001fa94:	e1a03803 	lsl	r3, r3, #16
3001fa98:	e1a03823 	lsr	r3, r3, #16
3001fa9c:	e1a03803 	lsl	r3, r3, #16
3001faa0:	e1a03843 	asr	r3, r3, #16
3001faa4:	e59d000c 	ldr	r0, [sp, #12]
3001faa8:	e1a01003 	mov	r1, r3
3001faac:	ebffd98e 	bl	300160ec <pbuf_header>
3001fab0:	e1a03000 	mov	r3, r0
3001fab4:	e3530000 	cmp	r3, #0
3001fab8:	0a000010 	beq	3001fb00 <udp_input+0x140>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
3001fabc:	e59f3568 	ldr	r3, [pc, #1384]	; 3002002c <udp_input+0x66c>
3001fac0:	e1d338be 	ldrh	r3, [r3, #142]	; 0x8e
3001fac4:	e2833001 	add	r3, r3, #1
3001fac8:	e1a03803 	lsl	r3, r3, #16
3001facc:	e1a02823 	lsr	r2, r3, #16
3001fad0:	e59f3554 	ldr	r3, [pc, #1364]	; 3002002c <udp_input+0x66c>
3001fad4:	e1c328be 	strh	r2, [r3, #142]	; 0x8e
    UDP_STATS_INC(udp.drop);
3001fad8:	e59f354c 	ldr	r3, [pc, #1356]	; 3002002c <udp_input+0x66c>
3001fadc:	e1d338ba 	ldrh	r3, [r3, #138]	; 0x8a
3001fae0:	e2833001 	add	r3, r3, #1
3001fae4:	e1a03803 	lsl	r3, r3, #16
3001fae8:	e1a02823 	lsr	r2, r3, #16
3001faec:	e59f3538 	ldr	r3, [pc, #1336]	; 3002002c <udp_input+0x66c>
3001faf0:	e1c328ba 	strh	r2, [r3, #138]	; 0x8a
    snmp_inc_udpinerrors();
    pbuf_free(p);
3001faf4:	e59d000c 	ldr	r0, [sp, #12]
3001faf8:	ebffd9e0 	bl	30016280 <pbuf_free>
    //acoral_prints("\nudp: udp is error in len\n");
    goto end;
3001fafc:	ea000147 	b	30020020 <udp_input+0x660>
  }

  udphdr = (struct udp_hdr *)p->payload;
3001fb00:	e59d300c 	ldr	r3, [sp, #12]
3001fb04:	e5933004 	ldr	r3, [r3, #4]
3001fb08:	e58d3014 	str	r3, [sp, #20]

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
3001fb0c:	e59d3014 	ldr	r3, [sp, #20]
3001fb10:	e5d32000 	ldrb	r2, [r3]
3001fb14:	e5d33001 	ldrb	r3, [r3, #1]
3001fb18:	e1a03403 	lsl	r3, r3, #8
3001fb1c:	e1833002 	orr	r3, r3, r2
3001fb20:	e1a03803 	lsl	r3, r3, #16
3001fb24:	e1a03823 	lsr	r3, r3, #16
3001fb28:	e1a00003 	mov	r0, r3
3001fb2c:	ebffcec6 	bl	3001364c <ntohs>
3001fb30:	e1a03000 	mov	r3, r0
3001fb34:	e1cd32ba 	strh	r3, [sp, #42]	; 0x2a
  dest = ntohs(udphdr->dest);
3001fb38:	e59d3014 	ldr	r3, [sp, #20]
3001fb3c:	e5d32002 	ldrb	r2, [r3, #2]
3001fb40:	e5d33003 	ldrb	r3, [r3, #3]
3001fb44:	e1a03403 	lsl	r3, r3, #8
3001fb48:	e1833002 	orr	r3, r3, r2
3001fb4c:	e1a03803 	lsl	r3, r3, #16
3001fb50:	e1a03823 	lsr	r3, r3, #16
3001fb54:	e1a00003 	mov	r0, r3
3001fb58:	ebffcebb 	bl	3001364c <ntohs>
3001fb5c:	e1a03000 	mov	r3, r0
3001fb60:	e1cd32bc 	strh	r3, [sp, #44]	; 0x2c
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
3001fb64:	e3a03000 	mov	r3, #0
3001fb68:	e58d301c 	str	r3, [sp, #28]
    local_match = 0;
3001fb6c:	e3a03000 	mov	r3, #0
3001fb70:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
    uncon_pcb = NULL;
3001fb74:	e3a03000 	mov	r3, #0
3001fb78:	e58d3020 	str	r3, [sp, #32]
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    //acoral_prints("\nudp: start find pcb\n");
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
3001fb7c:	e59f34ac 	ldr	r3, [pc, #1196]	; 30020030 <udp_input+0x670>
3001fb80:	e5933000 	ldr	r3, [r3]
3001fb84:	e58d3018 	str	r3, [sp, #24]
3001fb88:	ea00006b 	b	3001fd3c <udp_input+0x37c>
      local_match = 0;
3001fb8c:	e3a03000 	mov	r3, #0
3001fb90:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
3001fb94:	e59d3018 	ldr	r3, [sp, #24]
3001fb98:	e1d331b2 	ldrh	r3, [r3, #18]
3001fb9c:	e1dd22bc 	ldrh	r2, [sp, #44]	; 0x2c
3001fba0:	e1520003 	cmp	r2, r3
3001fba4:	1a000029 	bne	3001fc50 <udp_input+0x290>
          (ip_addr_isany(&pcb->local_ip) ||
3001fba8:	e59d3018 	ldr	r3, [sp, #24]
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
3001fbac:	e3530000 	cmp	r3, #0
3001fbb0:	0a00001a 	beq	3001fc20 <udp_input+0x260>
          (ip_addr_isany(&pcb->local_ip) ||
3001fbb4:	e59d3018 	ldr	r3, [sp, #24]
3001fbb8:	e5933000 	ldr	r3, [r3]
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
3001fbbc:	e3530000 	cmp	r3, #0
3001fbc0:	0a000016 	beq	3001fc20 <udp_input+0x260>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
3001fbc4:	e59d3018 	ldr	r3, [sp, #24]
3001fbc8:	e5932000 	ldr	r2, [r3]
3001fbcc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001fbd0:	e5d31010 	ldrb	r1, [r3, #16]
3001fbd4:	e5d30011 	ldrb	r0, [r3, #17]
3001fbd8:	e1a00400 	lsl	r0, r0, #8
3001fbdc:	e1801001 	orr	r1, r0, r1
3001fbe0:	e5d30012 	ldrb	r0, [r3, #18]
3001fbe4:	e1a00800 	lsl	r0, r0, #16
3001fbe8:	e1801001 	orr	r1, r0, r1
3001fbec:	e5d33013 	ldrb	r3, [r3, #19]
3001fbf0:	e1a03c03 	lsl	r3, r3, #24
3001fbf4:	e1833001 	orr	r3, r3, r1
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
3001fbf8:	e1520003 	cmp	r2, r3
3001fbfc:	0a000007 	beq	3001fc20 <udp_input+0x260>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
3001fc00:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001fc04:	e2833010 	add	r3, r3, #16
3001fc08:	e1a00003 	mov	r0, r3
3001fc0c:	e59d1008 	ldr	r1, [sp, #8]
3001fc10:	ebffd410 	bl	30014c58 <ip_addr_isbroadcast>
3001fc14:	e1a03000 	mov	r3, r0
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
3001fc18:	e3530000 	cmp	r3, #0
3001fc1c:	0a00000b 	beq	3001fc50 <udp_input+0x290>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
3001fc20:	e3a03001 	mov	r3, #1
3001fc24:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
        if ((uncon_pcb == NULL) && 
3001fc28:	e59d3020 	ldr	r3, [sp, #32]
3001fc2c:	e3530000 	cmp	r3, #0
3001fc30:	1a000006 	bne	3001fc50 <udp_input+0x290>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
3001fc34:	e59d3018 	ldr	r3, [sp, #24]
3001fc38:	e5d33010 	ldrb	r3, [r3, #16]
3001fc3c:	e2033004 	and	r3, r3, #4
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
3001fc40:	e3530000 	cmp	r3, #0
3001fc44:	1a000001 	bne	3001fc50 <udp_input+0x290>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
3001fc48:	e59d3018 	ldr	r3, [sp, #24]
3001fc4c:	e58d3020 	str	r3, [sp, #32]
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
3001fc50:	e5dd302f 	ldrb	r3, [sp, #47]	; 0x2f
3001fc54:	e3530000 	cmp	r3, #0
3001fc58:	0a000032 	beq	3001fd28 <udp_input+0x368>
          (pcb->remote_port == src) &&
3001fc5c:	e59d3018 	ldr	r3, [sp, #24]
3001fc60:	e1d331b4 	ldrh	r3, [r3, #20]
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
3001fc64:	e1dd22ba 	ldrh	r2, [sp, #42]	; 0x2a
3001fc68:	e1520003 	cmp	r2, r3
3001fc6c:	1a00002d 	bne	3001fd28 <udp_input+0x368>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
3001fc70:	e59d3018 	ldr	r3, [sp, #24]
3001fc74:	e2833004 	add	r3, r3, #4
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
3001fc78:	e3530000 	cmp	r3, #0
3001fc7c:	0a000012 	beq	3001fccc <udp_input+0x30c>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
3001fc80:	e59d3018 	ldr	r3, [sp, #24]
3001fc84:	e5933004 	ldr	r3, [r3, #4]
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
3001fc88:	e3530000 	cmp	r3, #0
3001fc8c:	0a00000e 	beq	3001fccc <udp_input+0x30c>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
3001fc90:	e59d3018 	ldr	r3, [sp, #24]
3001fc94:	e5932004 	ldr	r2, [r3, #4]
3001fc98:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001fc9c:	e5d3100c 	ldrb	r1, [r3, #12]
3001fca0:	e5d3000d 	ldrb	r0, [r3, #13]
3001fca4:	e1a00400 	lsl	r0, r0, #8
3001fca8:	e1801001 	orr	r1, r0, r1
3001fcac:	e5d3000e 	ldrb	r0, [r3, #14]
3001fcb0:	e1a00800 	lsl	r0, r0, #16
3001fcb4:	e1801001 	orr	r1, r0, r1
3001fcb8:	e5d3300f 	ldrb	r3, [r3, #15]
3001fcbc:	e1a03c03 	lsl	r3, r3, #24
3001fcc0:	e1833001 	orr	r3, r3, r1
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
3001fcc4:	e1520003 	cmp	r2, r3
3001fcc8:	1a000016 	bne	3001fd28 <udp_input+0x368>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
3001fccc:	e59d301c 	ldr	r3, [sp, #28]
3001fcd0:	e3530000 	cmp	r3, #0
3001fcd4:	0a00000b 	beq	3001fd08 <udp_input+0x348>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
3001fcd8:	e59d3018 	ldr	r3, [sp, #24]
3001fcdc:	e593200c 	ldr	r2, [r3, #12]
3001fce0:	e59d301c 	ldr	r3, [sp, #28]
3001fce4:	e583200c 	str	r2, [r3, #12]
          pcb->next = udp_pcbs;
3001fce8:	e59f3340 	ldr	r3, [pc, #832]	; 30020030 <udp_input+0x670>
3001fcec:	e5932000 	ldr	r2, [r3]
3001fcf0:	e59d3018 	ldr	r3, [sp, #24]
3001fcf4:	e583200c 	str	r2, [r3, #12]
          udp_pcbs = pcb;
3001fcf8:	e59f3330 	ldr	r3, [pc, #816]	; 30020030 <udp_input+0x670>
3001fcfc:	e59d2018 	ldr	r2, [sp, #24]
3001fd00:	e5832000 	str	r2, [r3]
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
3001fd04:	ea00000f 	b	3001fd48 <udp_input+0x388>
             found faster next time */
          prev->next = pcb->next;
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
3001fd08:	e59f331c 	ldr	r3, [pc, #796]	; 3002002c <udp_input+0x66c>
3001fd0c:	e1d339ba 	ldrh	r3, [r3, #154]	; 0x9a
3001fd10:	e2833001 	add	r3, r3, #1
3001fd14:	e1a03803 	lsl	r3, r3, #16
3001fd18:	e1a02823 	lsr	r2, r3, #16
3001fd1c:	e59f3308 	ldr	r3, [pc, #776]	; 3002002c <udp_input+0x66c>
3001fd20:	e1c329ba 	strh	r2, [r3, #154]	; 0x9a
        }
        break;
3001fd24:	ea000007 	b	3001fd48 <udp_input+0x388>
      }
      prev = pcb;
3001fd28:	e59d3018 	ldr	r3, [sp, #24]
3001fd2c:	e58d301c 	str	r3, [sp, #28]
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    //acoral_prints("\nudp: start find pcb\n");
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
3001fd30:	e59d3018 	ldr	r3, [sp, #24]
3001fd34:	e593300c 	ldr	r3, [r3, #12]
3001fd38:	e58d3018 	str	r3, [sp, #24]
3001fd3c:	e59d3018 	ldr	r3, [sp, #24]
3001fd40:	e3530000 	cmp	r3, #0
3001fd44:	1affff90 	bne	3001fb8c <udp_input+0x1cc>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
3001fd48:	e59d3018 	ldr	r3, [sp, #24]
3001fd4c:	e3530000 	cmp	r3, #0
3001fd50:	1a000001 	bne	3001fd5c <udp_input+0x39c>
      pcb = uncon_pcb;
3001fd54:	e59d3020 	ldr	r3, [sp, #32]
3001fd58:	e58d3018 	str	r3, [sp, #24]
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
3001fd5c:	e59d3018 	ldr	r3, [sp, #24]
3001fd60:	e3530000 	cmp	r3, #0
3001fd64:	1a00000e 	bne	3001fda4 <udp_input+0x3e4>
3001fd68:	e59d3008 	ldr	r3, [sp, #8]
3001fd6c:	e5932004 	ldr	r2, [r3, #4]
3001fd70:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001fd74:	e5d31010 	ldrb	r1, [r3, #16]
3001fd78:	e5d30011 	ldrb	r0, [r3, #17]
3001fd7c:	e1a00400 	lsl	r0, r0, #8
3001fd80:	e1801001 	orr	r1, r0, r1
3001fd84:	e5d30012 	ldrb	r0, [r3, #18]
3001fd88:	e1a00800 	lsl	r0, r0, #16
3001fd8c:	e1801001 	orr	r1, r0, r1
3001fd90:	e5d33013 	ldrb	r3, [r3, #19]
3001fd94:	e1a03c03 	lsl	r3, r3, #24
3001fd98:	e1833001 	orr	r3, r3, r1
3001fd9c:	e1520003 	cmp	r2, r3
3001fda0:	1a00009c 	bne	30020018 <udp_input+0x658>
    acoral_prints("\nudp:pub is not null\n");
3001fda4:	e59f0288 	ldr	r0, [pc, #648]	; 30020034 <udp_input+0x674>
3001fda8:	ebffad47 	bl	3000b2cc <acoral_prints>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
3001fdac:	e59d3014 	ldr	r3, [sp, #20]
3001fdb0:	e5d32006 	ldrb	r2, [r3, #6]
3001fdb4:	e5d33007 	ldrb	r3, [r3, #7]
3001fdb8:	e1a03403 	lsl	r3, r3, #8
3001fdbc:	e1833002 	orr	r3, r3, r2
3001fdc0:	e1a03803 	lsl	r3, r3, #16
3001fdc4:	e1a03823 	lsr	r3, r3, #16
3001fdc8:	e3530000 	cmp	r3, #0
3001fdcc:	0a00001f 	beq	3001fe50 <udp_input+0x490>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
3001fdd0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001fdd4:	e283200c 	add	r2, r3, #12
3001fdd8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001fddc:	e2833010 	add	r3, r3, #16
3001fde0:	e59d100c 	ldr	r1, [sp, #12]
3001fde4:	e1d110b8 	ldrh	r1, [r1, #8]
3001fde8:	e58d1000 	str	r1, [sp]
3001fdec:	e59d000c 	ldr	r0, [sp, #12]
3001fdf0:	e1a01002 	mov	r1, r2
3001fdf4:	e1a02003 	mov	r2, r3
3001fdf8:	e3a03011 	mov	r3, #17
3001fdfc:	ebffce86 	bl	3001381c <inet_chksum_pseudo>
3001fe00:	e1a03000 	mov	r3, r0
3001fe04:	e3530000 	cmp	r3, #0
3001fe08:	0a000010 	beq	3001fe50 <udp_input+0x490>
                               (struct ip_addr *)&(iphdr->dest),
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
3001fe0c:	e59f3218 	ldr	r3, [pc, #536]	; 3002002c <udp_input+0x66c>
3001fe10:	e1d338bc 	ldrh	r3, [r3, #140]	; 0x8c
3001fe14:	e2833001 	add	r3, r3, #1
3001fe18:	e1a03803 	lsl	r3, r3, #16
3001fe1c:	e1a02823 	lsr	r2, r3, #16
3001fe20:	e59f3204 	ldr	r3, [pc, #516]	; 3002002c <udp_input+0x66c>
3001fe24:	e1c328bc 	strh	r2, [r3, #140]	; 0x8c
          UDP_STATS_INC(udp.drop);
3001fe28:	e59f31fc 	ldr	r3, [pc, #508]	; 3002002c <udp_input+0x66c>
3001fe2c:	e1d338ba 	ldrh	r3, [r3, #138]	; 0x8a
3001fe30:	e2833001 	add	r3, r3, #1
3001fe34:	e1a03803 	lsl	r3, r3, #16
3001fe38:	e1a02823 	lsr	r2, r3, #16
3001fe3c:	e59f31e8 	ldr	r3, [pc, #488]	; 3002002c <udp_input+0x66c>
3001fe40:	e1c328ba 	strh	r2, [r3, #138]	; 0x8a
          snmp_inc_udpinerrors();
          pbuf_free(p);
3001fe44:	e59d000c 	ldr	r0, [sp, #12]
3001fe48:	ebffd90c 	bl	30016280 <pbuf_free>
          goto end;
3001fe4c:	ea000073 	b	30020020 <udp_input+0x660>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
3001fe50:	e59d000c 	ldr	r0, [sp, #12]
3001fe54:	e3e01007 	mvn	r1, #7
3001fe58:	ebffd8a3 	bl	300160ec <pbuf_header>
3001fe5c:	e1a03000 	mov	r3, r0
3001fe60:	e3530000 	cmp	r3, #0
3001fe64:	0a000009 	beq	3001fe90 <udp_input+0x4d0>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      UDP_STATS_INC(udp.drop);
3001fe68:	e59f31bc 	ldr	r3, [pc, #444]	; 3002002c <udp_input+0x66c>
3001fe6c:	e1d338ba 	ldrh	r3, [r3, #138]	; 0x8a
3001fe70:	e2833001 	add	r3, r3, #1
3001fe74:	e1a03803 	lsl	r3, r3, #16
3001fe78:	e1a02823 	lsr	r2, r3, #16
3001fe7c:	e59f31a8 	ldr	r3, [pc, #424]	; 3002002c <udp_input+0x66c>
3001fe80:	e1c328ba 	strh	r2, [r3, #138]	; 0x8a
      snmp_inc_udpinerrors();
      pbuf_free(p);
3001fe84:	e59d000c 	ldr	r0, [sp, #12]
3001fe88:	ebffd8fc 	bl	30016280 <pbuf_free>
      goto end;
3001fe8c:	ea000063 	b	30020020 <udp_input+0x660>
    }
    if (pcb != NULL) {
3001fe90:	e59d3018 	ldr	r3, [sp, #24]
3001fe94:	e3530000 	cmp	r3, #0
3001fe98:	0a000014 	beq	3001fef0 <udp_input+0x530>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
3001fe9c:	e59d3018 	ldr	r3, [sp, #24]
3001fea0:	e5933018 	ldr	r3, [r3, #24]
3001fea4:	e3530000 	cmp	r3, #0
3001fea8:	0a00000d 	beq	3001fee4 <udp_input+0x524>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
3001feac:	e59d3018 	ldr	r3, [sp, #24]
3001feb0:	e593c018 	ldr	ip, [r3, #24]
3001feb4:	e59d3018 	ldr	r3, [sp, #24]
3001feb8:	e593201c 	ldr	r2, [r3, #28]
3001febc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001fec0:	e283300c 	add	r3, r3, #12
3001fec4:	e1dd12ba 	ldrh	r1, [sp, #42]	; 0x2a
3001fec8:	e58d1000 	str	r1, [sp]
3001fecc:	e1a00002 	mov	r0, r2
3001fed0:	e59d1018 	ldr	r1, [sp, #24]
3001fed4:	e59d200c 	ldr	r2, [sp, #12]
3001fed8:	e1a0e00f 	mov	lr, pc
3001fedc:	e12fff1c 	bx	ip
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
3001fee0:	ea00004e 	b	30020020 <udp_input+0x660>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
3001fee4:	e59d000c 	ldr	r0, [sp, #12]
3001fee8:	ebffd8e4 	bl	30016280 <pbuf_free>
        goto end;
3001feec:	ea00004b 	b	30020020 <udp_input+0x660>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
3001fef0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001fef4:	e2833010 	add	r3, r3, #16
3001fef8:	e1a00003 	mov	r0, r3
3001fefc:	e59d1008 	ldr	r1, [sp, #8]
3001ff00:	ebffd354 	bl	30014c58 <ip_addr_isbroadcast>
3001ff04:	e1a03000 	mov	r3, r0
3001ff08:	e3530000 	cmp	r3, #0
3001ff0c:	1a000030 	bne	3001ffd4 <udp_input+0x614>
          !ip_addr_ismulticast(&iphdr->dest)) {
3001ff10:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001ff14:	e5d32010 	ldrb	r2, [r3, #16]
3001ff18:	e5d31011 	ldrb	r1, [r3, #17]
3001ff1c:	e1a01401 	lsl	r1, r1, #8
3001ff20:	e1812002 	orr	r2, r1, r2
3001ff24:	e5d31012 	ldrb	r1, [r3, #18]
3001ff28:	e1a01801 	lsl	r1, r1, #16
3001ff2c:	e1812002 	orr	r2, r1, r2
3001ff30:	e5d33013 	ldrb	r3, [r3, #19]
3001ff34:	e1a03c03 	lsl	r3, r3, #24
3001ff38:	e1833002 	orr	r3, r3, r2
3001ff3c:	e1a04003 	mov	r4, r3
3001ff40:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
3001ff44:	ebffcdde 	bl	300136c4 <ntohl>
3001ff48:	e1a03000 	mov	r3, r0
3001ff4c:	e0044003 	and	r4, r4, r3
3001ff50:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
3001ff54:	ebffcdda 	bl	300136c4 <ntohl>
3001ff58:	e1a03000 	mov	r3, r0
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
3001ff5c:	e1540003 	cmp	r4, r3
3001ff60:	0a00001b 	beq	3001ffd4 <udp_input+0x614>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
3001ff64:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3001ff68:	e5d32000 	ldrb	r2, [r3]
3001ff6c:	e5d33001 	ldrb	r3, [r3, #1]
3001ff70:	e1a03403 	lsl	r3, r3, #8
3001ff74:	e1833002 	orr	r3, r3, r2
3001ff78:	e1a03803 	lsl	r3, r3, #16
3001ff7c:	e1a03823 	lsr	r3, r3, #16
3001ff80:	e1a00003 	mov	r0, r3
3001ff84:	ebffcdb0 	bl	3001364c <ntohs>
3001ff88:	e1a03000 	mov	r3, r0
3001ff8c:	e1a03423 	lsr	r3, r3, #8
3001ff90:	e1a03803 	lsl	r3, r3, #16
3001ff94:	e1a03823 	lsr	r3, r3, #16
3001ff98:	e203300f 	and	r3, r3, #15
3001ff9c:	e2833002 	add	r3, r3, #2
3001ffa0:	e1a03803 	lsl	r3, r3, #16
3001ffa4:	e1a03823 	lsr	r3, r3, #16
3001ffa8:	e1a03103 	lsl	r3, r3, #2
3001ffac:	e1a03803 	lsl	r3, r3, #16
3001ffb0:	e1a03823 	lsr	r3, r3, #16
3001ffb4:	e1a03803 	lsl	r3, r3, #16
3001ffb8:	e1a03843 	asr	r3, r3, #16
3001ffbc:	e59d000c 	ldr	r0, [sp, #12]
3001ffc0:	e1a01003 	mov	r1, r3
3001ffc4:	ebffd848 	bl	300160ec <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
3001ffc8:	e59d000c 	ldr	r0, [sp, #12]
3001ffcc:	e3a01003 	mov	r1, #3
3001ffd0:	ebffcb85 	bl	30012dec <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
3001ffd4:	e59f3050 	ldr	r3, [pc, #80]	; 3002002c <udp_input+0x66c>
3001ffd8:	e1d339b4 	ldrh	r3, [r3, #148]	; 0x94
3001ffdc:	e2833001 	add	r3, r3, #1
3001ffe0:	e1a03803 	lsl	r3, r3, #16
3001ffe4:	e1a02823 	lsr	r2, r3, #16
3001ffe8:	e59f303c 	ldr	r3, [pc, #60]	; 3002002c <udp_input+0x66c>
3001ffec:	e1c329b4 	strh	r2, [r3, #148]	; 0x94
      UDP_STATS_INC(udp.drop);
3001fff0:	e59f3034 	ldr	r3, [pc, #52]	; 3002002c <udp_input+0x66c>
3001fff4:	e1d338ba 	ldrh	r3, [r3, #138]	; 0x8a
3001fff8:	e2833001 	add	r3, r3, #1
3001fffc:	e1a03803 	lsl	r3, r3, #16
30020000:	e1a02823 	lsr	r2, r3, #16
30020004:	e59f3020 	ldr	r3, [pc, #32]	; 3002002c <udp_input+0x66c>
30020008:	e1c328ba 	strh	r2, [r3, #138]	; 0x8a
      snmp_inc_udpnoports();
      pbuf_free(p);
3002000c:	e59d000c 	ldr	r0, [sp, #12]
30020010:	ebffd89a 	bl	30016280 <pbuf_free>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
30020014:	ea000001 	b	30020020 <udp_input+0x660>
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
  	//acoral_prints("\nudp: pcb is null\n");
    pbuf_free(p);
30020018:	e59d000c 	ldr	r0, [sp, #12]
3002001c:	ebffd897 	bl	30016280 <pbuf_free>
  }
end:
  PERF_STOP("udp_input");
}
30020020:	e28dd030 	add	sp, sp, #48	; 0x30
30020024:	e8bd4010 	pop	{r4, lr}
30020028:	e12fff1e 	bx	lr
3002002c:	302be570 	.word	0x302be570
30020030:	300eaa3c 	.word	0x300eaa3c
30020034:	30045738 	.word	0x30045738

30020038 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
30020038:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002003c:	e24dd00c 	sub	sp, sp, #12
30020040:	e58d0004 	str	r0, [sp, #4]
30020044:	e58d1000 	str	r1, [sp]
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
30020048:	e59d3004 	ldr	r3, [sp, #4]
3002004c:	e2832004 	add	r2, r3, #4
30020050:	e59d3004 	ldr	r3, [sp, #4]
30020054:	e1d331b4 	ldrh	r3, [r3, #20]
30020058:	e59d0004 	ldr	r0, [sp, #4]
3002005c:	e59d1000 	ldr	r1, [sp]
30020060:	eb000008 	bl	30020088 <udp_sendto>
30020064:	e1a03000 	mov	r3, r0
30020068:	e20330ff 	and	r3, r3, #255	; 0xff
3002006c:	e20330ff 	and	r3, r3, #255	; 0xff
30020070:	e1a03c03 	lsl	r3, r3, #24
30020074:	e1a03c43 	asr	r3, r3, #24
}
30020078:	e1a00003 	mov	r0, r3
3002007c:	e28dd00c 	add	sp, sp, #12
30020080:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30020084:	e12fff1e 	bx	lr

30020088 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
30020088:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002008c:	e24dd024 	sub	sp, sp, #36	; 0x24
30020090:	e58d0014 	str	r0, [sp, #20]
30020094:	e58d1010 	str	r1, [sp, #16]
30020098:	e58d200c 	str	r2, [sp, #12]
3002009c:	e1cd30ba 	strh	r3, [sp, #10]

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
300200a0:	e59d000c 	ldr	r0, [sp, #12]
300200a4:	ebffcfaa 	bl	30013f54 <ip_route>
300200a8:	e1a03000 	mov	r3, r0
300200ac:	e58d301c 	str	r3, [sp, #28]
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
300200b0:	e59d301c 	ldr	r3, [sp, #28]
300200b4:	e3530000 	cmp	r3, #0
300200b8:	1a000008 	bne	300200e0 <udp_sendto+0x58>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
300200bc:	e59f305c 	ldr	r3, [pc, #92]	; 30020120 <udp_sendto+0x98>
300200c0:	e1d339b2 	ldrh	r3, [r3, #146]	; 0x92
300200c4:	e2833001 	add	r3, r3, #1
300200c8:	e1a03803 	lsl	r3, r3, #16
300200cc:	e1a02823 	lsr	r2, r3, #16
300200d0:	e59f3048 	ldr	r3, [pc, #72]	; 30020120 <udp_sendto+0x98>
300200d4:	e1c329b2 	strh	r2, [r3, #146]	; 0x92
    return ERR_RTE;
300200d8:	e3a030fd 	mov	r3, #253	; 0xfd
300200dc:	ea000009 	b	30020108 <udp_sendto+0x80>
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
300200e0:	e1dd30ba 	ldrh	r3, [sp, #10]
300200e4:	e59d201c 	ldr	r2, [sp, #28]
300200e8:	e58d2000 	str	r2, [sp]
300200ec:	e59d0014 	ldr	r0, [sp, #20]
300200f0:	e59d1010 	ldr	r1, [sp, #16]
300200f4:	e59d200c 	ldr	r2, [sp, #12]
300200f8:	eb000009 	bl	30020124 <udp_sendto_if>
300200fc:	e1a03000 	mov	r3, r0
30020100:	e20330ff 	and	r3, r3, #255	; 0xff
30020104:	e20330ff 	and	r3, r3, #255	; 0xff
30020108:	e1a03c03 	lsl	r3, r3, #24
3002010c:	e1a03c43 	asr	r3, r3, #24
}
30020110:	e1a00003 	mov	r0, r3
30020114:	e28dd024 	add	sp, sp, #36	; 0x24
30020118:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002011c:	e12fff1e 	bx	lr
30020120:	302be570 	.word	0x302be570

30020124 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
30020124:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30020128:	e24dd034 	sub	sp, sp, #52	; 0x34
3002012c:	e58d001c 	str	r0, [sp, #28]
30020130:	e58d1018 	str	r1, [sp, #24]
30020134:	e58d2014 	str	r2, [sp, #20]
30020138:	e1cd31b2 	strh	r3, [sp, #18]
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
3002013c:	e59d301c 	ldr	r3, [sp, #28]
30020140:	e1d331b2 	ldrh	r3, [r3, #18]
30020144:	e3530000 	cmp	r3, #0
30020148:	1a00000e 	bne	30020188 <udp_sendto_if+0x64>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
3002014c:	e59d201c 	ldr	r2, [sp, #28]
30020150:	e59d301c 	ldr	r3, [sp, #28]
30020154:	e1d331b2 	ldrh	r3, [r3, #18]
30020158:	e59d001c 	ldr	r0, [sp, #28]
3002015c:	e1a01002 	mov	r1, r2
30020160:	e1a02003 	mov	r2, r3
30020164:	eb0000c4 	bl	3002047c <udp_bind>
30020168:	e1a03000 	mov	r3, r0
3002016c:	e20330ff 	and	r3, r3, #255	; 0xff
30020170:	e5cd302b 	strb	r3, [sp, #43]	; 0x2b
    if (err != ERR_OK) {
30020174:	e1dd32db 	ldrsb	r3, [sp, #43]	; 0x2b
30020178:	e3530000 	cmp	r3, #0
3002017c:	0a000001 	beq	30020188 <udp_sendto_if+0x64>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: forced port bind failed\n"));
      return err;
30020180:	e5dd302b 	ldrb	r3, [sp, #43]	; 0x2b
30020184:	ea0000b5 	b	30020460 <udp_sendto_if+0x33c>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
30020188:	e59d0018 	ldr	r0, [sp, #24]
3002018c:	e3a01008 	mov	r1, #8
30020190:	ebffd7d5 	bl	300160ec <pbuf_header>
30020194:	e1a03000 	mov	r3, r0
30020198:	e3530000 	cmp	r3, #0
3002019c:	0a00000e 	beq	300201dc <udp_sendto_if+0xb8>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
300201a0:	e3a00001 	mov	r0, #1
300201a4:	e3a01008 	mov	r1, #8
300201a8:	e3a02000 	mov	r2, #0
300201ac:	ebffd681 	bl	30015bb8 <pbuf_alloc>
300201b0:	e1a03000 	mov	r3, r0
300201b4:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
300201b8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300201bc:	e3530000 	cmp	r3, #0
300201c0:	1a000001 	bne	300201cc <udp_sendto_if+0xa8>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
300201c4:	e3a030ff 	mov	r3, #255	; 0xff
300201c8:	ea0000a4 	b	30020460 <udp_sendto_if+0x33c>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
300201cc:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
300201d0:	e59d1018 	ldr	r1, [sp, #24]
300201d4:	ebffd8ba 	bl	300164c4 <pbuf_chain>
300201d8:	ea000001 	b	300201e4 <udp_sendto_if+0xc0>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
300201dc:	e59d3018 	ldr	r3, [sp, #24]
300201e0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
300201e4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300201e8:	e5933004 	ldr	r3, [r3, #4]
300201ec:	e58d3020 	str	r3, [sp, #32]
  udphdr->src = htons(pcb->local_port);
300201f0:	e59d301c 	ldr	r3, [sp, #28]
300201f4:	e1d331b2 	ldrh	r3, [r3, #18]
300201f8:	e1a00003 	mov	r0, r3
300201fc:	ebffccff 	bl	30013600 <htons>
30020200:	e1a03000 	mov	r3, r0
30020204:	e1a02003 	mov	r2, r3
30020208:	e59d3020 	ldr	r3, [sp, #32]
3002020c:	e20210ff 	and	r1, r2, #255	; 0xff
30020210:	e3a00000 	mov	r0, #0
30020214:	e1801001 	orr	r1, r0, r1
30020218:	e5c31000 	strb	r1, [r3]
3002021c:	e1a02422 	lsr	r2, r2, #8
30020220:	e1a02802 	lsl	r2, r2, #16
30020224:	e1a02822 	lsr	r2, r2, #16
30020228:	e3a01000 	mov	r1, #0
3002022c:	e1812002 	orr	r2, r1, r2
30020230:	e5c32001 	strb	r2, [r3, #1]
  udphdr->dest = htons(dst_port);
30020234:	e1dd31b2 	ldrh	r3, [sp, #18]
30020238:	e1a00003 	mov	r0, r3
3002023c:	ebffccef 	bl	30013600 <htons>
30020240:	e1a03000 	mov	r3, r0
30020244:	e1a02003 	mov	r2, r3
30020248:	e59d3020 	ldr	r3, [sp, #32]
3002024c:	e20210ff 	and	r1, r2, #255	; 0xff
30020250:	e3a00000 	mov	r0, #0
30020254:	e1801001 	orr	r1, r0, r1
30020258:	e5c31002 	strb	r1, [r3, #2]
3002025c:	e1a02422 	lsr	r2, r2, #8
30020260:	e1a02802 	lsl	r2, r2, #16
30020264:	e1a02822 	lsr	r2, r2, #16
30020268:	e3a01000 	mov	r1, #0
3002026c:	e1812002 	orr	r2, r1, r2
30020270:	e5c32003 	strb	r2, [r3, #3]
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
30020274:	e59d3020 	ldr	r3, [sp, #32]
30020278:	e3a02000 	mov	r2, #0
3002027c:	e5c32006 	strb	r2, [r3, #6]
30020280:	e3a02000 	mov	r2, #0
30020284:	e5c32007 	strb	r2, [r3, #7]

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
30020288:	e59d301c 	ldr	r3, [sp, #28]
3002028c:	e3530000 	cmp	r3, #0
30020290:	0a000003 	beq	300202a4 <udp_sendto_if+0x180>
30020294:	e59d301c 	ldr	r3, [sp, #28]
30020298:	e5933000 	ldr	r3, [r3]
3002029c:	e3530000 	cmp	r3, #0
300202a0:	1a000003 	bne	300202b4 <udp_sendto_if+0x190>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
300202a4:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
300202a8:	e2833004 	add	r3, r3, #4
300202ac:	e58d3024 	str	r3, [sp, #36]	; 0x24
  udphdr->dest = htons(dst_port);
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
300202b0:	ea000011 	b	300202fc <udp_sendto_if+0x1d8>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
300202b4:	e59d301c 	ldr	r3, [sp, #28]
300202b8:	e5932000 	ldr	r2, [r3]
300202bc:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
300202c0:	e5933004 	ldr	r3, [r3, #4]
300202c4:	e1520003 	cmp	r2, r3
300202c8:	0a000009 	beq	300202f4 <udp_sendto_if+0x1d0>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
300202cc:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
300202d0:	e59d3018 	ldr	r3, [sp, #24]
300202d4:	e1520003 	cmp	r2, r3
300202d8:	0a000003 	beq	300202ec <udp_sendto_if+0x1c8>
        /* free the header pbuf */
        pbuf_free(q);
300202dc:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
300202e0:	ebffd7e6 	bl	30016280 <pbuf_free>
        q = NULL;
300202e4:	e3a03000 	mov	r3, #0
300202e8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
300202ec:	e3a030f8 	mov	r3, #248	; 0xf8
300202f0:	ea00005a 	b	30020460 <udp_sendto_if+0x33c>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
300202f4:	e59d301c 	ldr	r3, [sp, #28]
300202f8:	e58d3024 	str	r3, [sp, #36]	; 0x24
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
300202fc:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30020300:	e1d330b8 	ldrh	r3, [r3, #8]
30020304:	e1a00003 	mov	r0, r3
30020308:	ebffccbc 	bl	30013600 <htons>
3002030c:	e1a03000 	mov	r3, r0
30020310:	e1a02003 	mov	r2, r3
30020314:	e59d3020 	ldr	r3, [sp, #32]
30020318:	e20210ff 	and	r1, r2, #255	; 0xff
3002031c:	e3a00000 	mov	r0, #0
30020320:	e1801001 	orr	r1, r0, r1
30020324:	e5c31004 	strb	r1, [r3, #4]
30020328:	e1a02422 	lsr	r2, r2, #8
3002032c:	e1a02802 	lsl	r2, r2, #16
30020330:	e1a02822 	lsr	r2, r2, #16
30020334:	e3a01000 	mov	r1, #0
30020338:	e1812002 	orr	r2, r1, r2
3002033c:	e5c32005 	strb	r2, [r3, #5]
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
30020340:	e59d301c 	ldr	r3, [sp, #28]
30020344:	e5d33010 	ldrb	r3, [r3, #16]
30020348:	e2033001 	and	r3, r3, #1
3002034c:	e3530000 	cmp	r3, #0
30020350:	1a000022 	bne	300203e0 <udp_sendto_if+0x2bc>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
30020354:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30020358:	e1d330b8 	ldrh	r3, [r3, #8]
3002035c:	e58d3000 	str	r3, [sp]
30020360:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30020364:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
30020368:	e59d2014 	ldr	r2, [sp, #20]
3002036c:	e3a03011 	mov	r3, #17
30020370:	ebffcd29 	bl	3001381c <inet_chksum_pseudo>
30020374:	e1a03000 	mov	r3, r0
30020378:	e1a02003 	mov	r2, r3
3002037c:	e59d3020 	ldr	r3, [sp, #32]
30020380:	e20210ff 	and	r1, r2, #255	; 0xff
30020384:	e3a00000 	mov	r0, #0
30020388:	e1801001 	orr	r1, r0, r1
3002038c:	e5c31006 	strb	r1, [r3, #6]
30020390:	e1a02422 	lsr	r2, r2, #8
30020394:	e1a02802 	lsl	r2, r2, #16
30020398:	e1a02822 	lsr	r2, r2, #16
3002039c:	e3a01000 	mov	r1, #0
300203a0:	e1812002 	orr	r2, r1, r2
300203a4:	e5c32007 	strb	r2, [r3, #7]
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
300203a8:	e59d3020 	ldr	r3, [sp, #32]
300203ac:	e5d32006 	ldrb	r2, [r3, #6]
300203b0:	e5d33007 	ldrb	r3, [r3, #7]
300203b4:	e1a03403 	lsl	r3, r3, #8
300203b8:	e1833002 	orr	r3, r3, r2
300203bc:	e1a03803 	lsl	r3, r3, #16
300203c0:	e1a03823 	lsr	r3, r3, #16
300203c4:	e3530000 	cmp	r3, #0
300203c8:	1a000004 	bne	300203e0 <udp_sendto_if+0x2bc>
300203cc:	e59d3020 	ldr	r3, [sp, #32]
300203d0:	e3e02000 	mvn	r2, #0
300203d4:	e5c32006 	strb	r2, [r3, #6]
300203d8:	e3e02000 	mvn	r2, #0
300203dc:	e5c32007 	strb	r2, [r3, #7]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
300203e0:	e59d301c 	ldr	r3, [sp, #28]
300203e4:	e5d3300b 	ldrb	r3, [r3, #11]
300203e8:	e59d201c 	ldr	r2, [sp, #28]
300203ec:	e5d2200a 	ldrb	r2, [r2, #10]
300203f0:	e58d2000 	str	r2, [sp]
300203f4:	e3a02011 	mov	r2, #17
300203f8:	e58d2004 	str	r2, [sp, #4]
300203fc:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
30020400:	e58d2008 	str	r2, [sp, #8]
30020404:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30020408:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
3002040c:	e59d2014 	ldr	r2, [sp, #20]
30020410:	ebffd089 	bl	3001463c <ip_output_if>
30020414:	e1a03000 	mov	r3, r0
30020418:	e20330ff 	and	r3, r3, #255	; 0xff
3002041c:	e5cd302b 	strb	r3, [sp, #43]	; 0x2b
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
30020420:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30020424:	e59d3018 	ldr	r3, [sp, #24]
30020428:	e1520003 	cmp	r2, r3
3002042c:	0a000003 	beq	30020440 <udp_sendto_if+0x31c>
    /* free the header pbuf */
    pbuf_free(q);
30020430:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30020434:	ebffd791 	bl	30016280 <pbuf_free>
    q = NULL;
30020438:	e3a03000 	mov	r3, #0
3002043c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
30020440:	e59f3030 	ldr	r3, [pc, #48]	; 30020478 <udp_sendto_if+0x354>
30020444:	e1d338b2 	ldrh	r3, [r3, #130]	; 0x82
30020448:	e2833001 	add	r3, r3, #1
3002044c:	e1a03803 	lsl	r3, r3, #16
30020450:	e1a02823 	lsr	r2, r3, #16
30020454:	e59f301c 	ldr	r3, [pc, #28]	; 30020478 <udp_sendto_if+0x354>
30020458:	e1c328b2 	strh	r2, [r3, #130]	; 0x82
  return err;
3002045c:	e5dd302b 	ldrb	r3, [sp, #43]	; 0x2b
30020460:	e1a03c03 	lsl	r3, r3, #24
30020464:	e1a03c43 	asr	r3, r3, #24
}
30020468:	e1a00003 	mov	r0, r3
3002046c:	e28dd034 	add	sp, sp, #52	; 0x34
30020470:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30020474:	e12fff1e 	bx	lr
30020478:	302be570 	.word	0x302be570

3002047c <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
3002047c:	e24dd018 	sub	sp, sp, #24
30020480:	e58d000c 	str	r0, [sp, #12]
30020484:	e58d1008 	str	r1, [sp, #8]
30020488:	e1a03002 	mov	r3, r2
3002048c:	e1cd30b6 	strh	r3, [sp, #6]

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
30020490:	e3a03000 	mov	r3, #0
30020494:	e5cd3017 	strb	r3, [sp, #23]
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
30020498:	e59f3160 	ldr	r3, [pc, #352]	; 30020600 <udp_bind+0x184>
3002049c:	e5933000 	ldr	r3, [r3]
300204a0:	e58d3010 	str	r3, [sp, #16]
300204a4:	ea000008 	b	300204cc <udp_bind+0x50>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
300204a8:	e59d200c 	ldr	r2, [sp, #12]
300204ac:	e59d3010 	ldr	r3, [sp, #16]
300204b0:	e1520003 	cmp	r2, r3
300204b4:	1a000001 	bne	300204c0 <udp_bind+0x44>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
300204b8:	e3a03001 	mov	r3, #1
300204bc:	e5cd3017 	strb	r3, [sp, #23]
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
300204c0:	e59d3010 	ldr	r3, [sp, #16]
300204c4:	e593300c 	ldr	r3, [r3, #12]
300204c8:	e58d3010 	str	r3, [sp, #16]
300204cc:	e59d3010 	ldr	r3, [sp, #16]
300204d0:	e3530000 	cmp	r3, #0
300204d4:	1afffff3 	bne	300204a8 <udp_bind+0x2c>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
300204d8:	e59d3008 	ldr	r3, [sp, #8]
300204dc:	e3530000 	cmp	r3, #0
300204e0:	0a00000b 	beq	30020514 <udp_bind+0x98>
300204e4:	e59d3008 	ldr	r3, [sp, #8]
300204e8:	e5d32000 	ldrb	r2, [r3]
300204ec:	e5d31001 	ldrb	r1, [r3, #1]
300204f0:	e1a01401 	lsl	r1, r1, #8
300204f4:	e1812002 	orr	r2, r1, r2
300204f8:	e5d31002 	ldrb	r1, [r3, #2]
300204fc:	e1a01801 	lsl	r1, r1, #16
30020500:	e1812002 	orr	r2, r1, r2
30020504:	e5d33003 	ldrb	r3, [r3, #3]
30020508:	e1a03c03 	lsl	r3, r3, #24
3002050c:	e1833002 	orr	r3, r3, r2
30020510:	ea000000 	b	30020518 <udp_bind+0x9c>
30020514:	e3a03000 	mov	r3, #0
30020518:	e59d200c 	ldr	r2, [sp, #12]
3002051c:	e5823000 	str	r3, [r2]

  /* no port specified? */
  if (port == 0) {
30020520:	e1dd30b6 	ldrh	r3, [sp, #6]
30020524:	e3530000 	cmp	r3, #0
30020528:	1a000021 	bne	300205b4 <udp_bind+0x138>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
3002052c:	e3a03a01 	mov	r3, #4096	; 0x1000
30020530:	e1cd30b6 	strh	r3, [sp, #6]
    ipcb = udp_pcbs;
30020534:	e59f30c4 	ldr	r3, [pc, #196]	; 30020600 <udp_bind+0x184>
30020538:	e5933000 	ldr	r3, [r3]
3002053c:	e58d3010 	str	r3, [sp, #16]
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
30020540:	ea00000e 	b	30020580 <udp_bind+0x104>
      if (ipcb->local_port == port) {
30020544:	e59d3010 	ldr	r3, [sp, #16]
30020548:	e1d331b2 	ldrh	r3, [r3, #18]
3002054c:	e1dd20b6 	ldrh	r2, [sp, #6]
30020550:	e1520003 	cmp	r2, r3
30020554:	1a000006 	bne	30020574 <udp_bind+0xf8>
        /* port is already used by another udp_pcb */
        port++;
30020558:	e1dd30b6 	ldrh	r3, [sp, #6]
3002055c:	e2833001 	add	r3, r3, #1
30020560:	e1cd30b6 	strh	r3, [sp, #6]
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
30020564:	e59f3094 	ldr	r3, [pc, #148]	; 30020600 <udp_bind+0x184>
30020568:	e5933000 	ldr	r3, [r3]
3002056c:	e58d3010 	str	r3, [sp, #16]
30020570:	ea000002 	b	30020580 <udp_bind+0x104>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
30020574:	e59d3010 	ldr	r3, [sp, #16]
30020578:	e593300c 	ldr	r3, [r3, #12]
3002057c:	e58d3010 	str	r3, [sp, #16]
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
30020580:	e59d3010 	ldr	r3, [sp, #16]
30020584:	e3530000 	cmp	r3, #0
30020588:	0a000004 	beq	300205a0 <udp_bind+0x124>
3002058c:	e1dd20b6 	ldrh	r2, [sp, #6]
30020590:	e3a03c7f 	mov	r3, #32512	; 0x7f00
30020594:	e28330ff 	add	r3, r3, #255	; 0xff
30020598:	e1520003 	cmp	r2, r3
3002059c:	1affffe8 	bne	30020544 <udp_bind+0xc8>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
300205a0:	e59d3010 	ldr	r3, [sp, #16]
300205a4:	e3530000 	cmp	r3, #0
300205a8:	0a000001 	beq	300205b4 <udp_bind+0x138>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
300205ac:	e3a030f6 	mov	r3, #246	; 0xf6
300205b0:	ea00000d 	b	300205ec <udp_bind+0x170>
    }
  }
  pcb->local_port = port;
300205b4:	e59d300c 	ldr	r3, [sp, #12]
300205b8:	e1dd20b6 	ldrh	r2, [sp, #6]
300205bc:	e1c321b2 	strh	r2, [r3, #18]
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
300205c0:	e5dd3017 	ldrb	r3, [sp, #23]
300205c4:	e3530000 	cmp	r3, #0
300205c8:	1a000006 	bne	300205e8 <udp_bind+0x16c>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
300205cc:	e59f302c 	ldr	r3, [pc, #44]	; 30020600 <udp_bind+0x184>
300205d0:	e5932000 	ldr	r2, [r3]
300205d4:	e59d300c 	ldr	r3, [sp, #12]
300205d8:	e583200c 	str	r2, [r3, #12]
    udp_pcbs = pcb;
300205dc:	e59f301c 	ldr	r3, [pc, #28]	; 30020600 <udp_bind+0x184>
300205e0:	e59d200c 	ldr	r2, [sp, #12]
300205e4:	e5832000 	str	r2, [r3]
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
300205e8:	e3a03000 	mov	r3, #0
300205ec:	e1a03c03 	lsl	r3, r3, #24
300205f0:	e1a03c43 	asr	r3, r3, #24
}
300205f4:	e1a00003 	mov	r0, r3
300205f8:	e28dd018 	add	sp, sp, #24
300205fc:	e12fff1e 	bx	lr
30020600:	300eaa3c 	.word	0x300eaa3c

30020604 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
30020604:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30020608:	e24dd01c 	sub	sp, sp, #28
3002060c:	e58d000c 	str	r0, [sp, #12]
30020610:	e58d1008 	str	r1, [sp, #8]
30020614:	e1a03002 	mov	r3, r2
30020618:	e1cd30b6 	strh	r3, [sp, #6]
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
3002061c:	e59d300c 	ldr	r3, [sp, #12]
30020620:	e1d331b2 	ldrh	r3, [r3, #18]
30020624:	e3530000 	cmp	r3, #0
30020628:	1a00000e 	bne	30020668 <udp_connect+0x64>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
3002062c:	e59d200c 	ldr	r2, [sp, #12]
30020630:	e59d300c 	ldr	r3, [sp, #12]
30020634:	e1d331b2 	ldrh	r3, [r3, #18]
30020638:	e59d000c 	ldr	r0, [sp, #12]
3002063c:	e1a01002 	mov	r1, r2
30020640:	e1a02003 	mov	r2, r3
30020644:	ebffff8c 	bl	3002047c <udp_bind>
30020648:	e1a03000 	mov	r3, r0
3002064c:	e20330ff 	and	r3, r3, #255	; 0xff
30020650:	e5cd3017 	strb	r3, [sp, #23]
    if (err != ERR_OK)
30020654:	e1dd31d7 	ldrsb	r3, [sp, #23]
30020658:	e3530000 	cmp	r3, #0
3002065c:	0a000001 	beq	30020668 <udp_connect+0x64>
      return err;
30020660:	e5dd3017 	ldrb	r3, [sp, #23]
30020664:	ea000032 	b	30020734 <udp_connect+0x130>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
30020668:	e59d3008 	ldr	r3, [sp, #8]
3002066c:	e3530000 	cmp	r3, #0
30020670:	0a00000b 	beq	300206a4 <udp_connect+0xa0>
30020674:	e59d3008 	ldr	r3, [sp, #8]
30020678:	e5d32000 	ldrb	r2, [r3]
3002067c:	e5d31001 	ldrb	r1, [r3, #1]
30020680:	e1a01401 	lsl	r1, r1, #8
30020684:	e1812002 	orr	r2, r1, r2
30020688:	e5d31002 	ldrb	r1, [r3, #2]
3002068c:	e1a01801 	lsl	r1, r1, #16
30020690:	e1812002 	orr	r2, r1, r2
30020694:	e5d33003 	ldrb	r3, [r3, #3]
30020698:	e1a03c03 	lsl	r3, r3, #24
3002069c:	e1833002 	orr	r3, r3, r2
300206a0:	ea000000 	b	300206a8 <udp_connect+0xa4>
300206a4:	e3a03000 	mov	r3, #0
300206a8:	e59d200c 	ldr	r2, [sp, #12]
300206ac:	e5823004 	str	r3, [r2, #4]
  pcb->remote_port = port;
300206b0:	e59d300c 	ldr	r3, [sp, #12]
300206b4:	e1dd20b6 	ldrh	r2, [sp, #6]
300206b8:	e1c321b4 	strh	r2, [r3, #20]
  pcb->flags |= UDP_FLAGS_CONNECTED;
300206bc:	e59d300c 	ldr	r3, [sp, #12]
300206c0:	e5d33010 	ldrb	r3, [r3, #16]
300206c4:	e3833004 	orr	r3, r3, #4
300206c8:	e20320ff 	and	r2, r3, #255	; 0xff
300206cc:	e59d300c 	ldr	r3, [sp, #12]
300206d0:	e5c32010 	strb	r2, [r3, #16]
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
300206d4:	e59f3070 	ldr	r3, [pc, #112]	; 3002074c <udp_connect+0x148>
300206d8:	e5933000 	ldr	r3, [r3]
300206dc:	e58d3010 	str	r3, [sp, #16]
300206e0:	ea000008 	b	30020708 <udp_connect+0x104>
    if (pcb == ipcb) {
300206e4:	e59d200c 	ldr	r2, [sp, #12]
300206e8:	e59d3010 	ldr	r3, [sp, #16]
300206ec:	e1520003 	cmp	r2, r3
300206f0:	1a000001 	bne	300206fc <udp_connect+0xf8>
      /* already on the list, just return */
      return ERR_OK;
300206f4:	e3a03000 	mov	r3, #0
300206f8:	ea00000d 	b	30020734 <udp_connect+0x130>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
300206fc:	e59d3010 	ldr	r3, [sp, #16]
30020700:	e593300c 	ldr	r3, [r3, #12]
30020704:	e58d3010 	str	r3, [sp, #16]
30020708:	e59d3010 	ldr	r3, [sp, #16]
3002070c:	e3530000 	cmp	r3, #0
30020710:	1afffff3 	bne	300206e4 <udp_connect+0xe0>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
30020714:	e59f3030 	ldr	r3, [pc, #48]	; 3002074c <udp_connect+0x148>
30020718:	e5932000 	ldr	r2, [r3]
3002071c:	e59d300c 	ldr	r3, [sp, #12]
30020720:	e583200c 	str	r2, [r3, #12]
  udp_pcbs = pcb;
30020724:	e59f3020 	ldr	r3, [pc, #32]	; 3002074c <udp_connect+0x148>
30020728:	e59d200c 	ldr	r2, [sp, #12]
3002072c:	e5832000 	str	r2, [r3]
  return ERR_OK;
30020730:	e3a03000 	mov	r3, #0
30020734:	e1a03c03 	lsl	r3, r3, #24
30020738:	e1a03c43 	asr	r3, r3, #24
}
3002073c:	e1a00003 	mov	r0, r3
30020740:	e28dd01c 	add	sp, sp, #28
30020744:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30020748:	e12fff1e 	bx	lr
3002074c:	300eaa3c 	.word	0x300eaa3c

30020750 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
30020750:	e24dd008 	sub	sp, sp, #8
30020754:	e58d0004 	str	r0, [sp, #4]
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
30020758:	e59f3058 	ldr	r3, [pc, #88]	; 300207b8 <udp_disconnect+0x68>
3002075c:	e5d32000 	ldrb	r2, [r3]
30020760:	e5d31001 	ldrb	r1, [r3, #1]
30020764:	e1a01401 	lsl	r1, r1, #8
30020768:	e1812002 	orr	r2, r1, r2
3002076c:	e5d31002 	ldrb	r1, [r3, #2]
30020770:	e1a01801 	lsl	r1, r1, #16
30020774:	e1812002 	orr	r2, r1, r2
30020778:	e5d33003 	ldrb	r3, [r3, #3]
3002077c:	e1a03c03 	lsl	r3, r3, #24
30020780:	e1833002 	orr	r3, r3, r2
30020784:	e1a02003 	mov	r2, r3
30020788:	e59d3004 	ldr	r3, [sp, #4]
3002078c:	e5832004 	str	r2, [r3, #4]
  pcb->remote_port = 0;
30020790:	e59d3004 	ldr	r3, [sp, #4]
30020794:	e3a02000 	mov	r2, #0
30020798:	e1c321b4 	strh	r2, [r3, #20]
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
3002079c:	e59d3004 	ldr	r3, [sp, #4]
300207a0:	e5d33010 	ldrb	r3, [r3, #16]
300207a4:	e20330fb 	and	r3, r3, #251	; 0xfb
300207a8:	e59d2004 	ldr	r2, [sp, #4]
300207ac:	e5c23010 	strb	r3, [r2, #16]
}
300207b0:	e28dd008 	add	sp, sp, #8
300207b4:	e12fff1e 	bx	lr
300207b8:	300456d0 	.word	0x300456d0

300207bc <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
300207bc:	e24dd010 	sub	sp, sp, #16
300207c0:	e58d000c 	str	r0, [sp, #12]
300207c4:	e58d1008 	str	r1, [sp, #8]
300207c8:	e58d2004 	str	r2, [sp, #4]
  /* remember recv() callback and user data */
  pcb->recv = recv;
300207cc:	e59d300c 	ldr	r3, [sp, #12]
300207d0:	e59d2008 	ldr	r2, [sp, #8]
300207d4:	e5832018 	str	r2, [r3, #24]
  pcb->recv_arg = recv_arg;
300207d8:	e59d300c 	ldr	r3, [sp, #12]
300207dc:	e59d2004 	ldr	r2, [sp, #4]
300207e0:	e583201c 	str	r2, [r3, #28]
}
300207e4:	e28dd010 	add	sp, sp, #16
300207e8:	e12fff1e 	bx	lr

300207ec <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
300207ec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300207f0:	e24dd014 	sub	sp, sp, #20
300207f4:	e58d0004 	str	r0, [sp, #4]
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
300207f8:	e59f3098 	ldr	r3, [pc, #152]	; 30020898 <udp_remove+0xac>
300207fc:	e5932000 	ldr	r2, [r3]
30020800:	e59d3004 	ldr	r3, [sp, #4]
30020804:	e1520003 	cmp	r2, r3
30020808:	1a000005 	bne	30020824 <udp_remove+0x38>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
3002080c:	e59f3084 	ldr	r3, [pc, #132]	; 30020898 <udp_remove+0xac>
30020810:	e5933000 	ldr	r3, [r3]
30020814:	e593200c 	ldr	r2, [r3, #12]
30020818:	e59f3078 	ldr	r3, [pc, #120]	; 30020898 <udp_remove+0xac>
3002081c:	e5832000 	str	r2, [r3]
30020820:	ea000016 	b	30020880 <udp_remove+0x94>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
30020824:	e59f306c 	ldr	r3, [pc, #108]	; 30020898 <udp_remove+0xac>
30020828:	e5933000 	ldr	r3, [r3]
3002082c:	e58d300c 	str	r3, [sp, #12]
30020830:	ea00000f 	b	30020874 <udp_remove+0x88>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
30020834:	e59d300c 	ldr	r3, [sp, #12]
30020838:	e593300c 	ldr	r3, [r3, #12]
3002083c:	e3530000 	cmp	r3, #0
30020840:	0a000008 	beq	30020868 <udp_remove+0x7c>
30020844:	e59d300c 	ldr	r3, [sp, #12]
30020848:	e593200c 	ldr	r2, [r3, #12]
3002084c:	e59d3004 	ldr	r3, [sp, #4]
30020850:	e1520003 	cmp	r2, r3
30020854:	1a000003 	bne	30020868 <udp_remove+0x7c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
30020858:	e59d3004 	ldr	r3, [sp, #4]
3002085c:	e593200c 	ldr	r2, [r3, #12]
30020860:	e59d300c 	ldr	r3, [sp, #12]
30020864:	e583200c 	str	r2, [r3, #12]
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
30020868:	e59d300c 	ldr	r3, [sp, #12]
3002086c:	e593300c 	ldr	r3, [r3, #12]
30020870:	e58d300c 	str	r3, [sp, #12]
30020874:	e59d300c 	ldr	r3, [sp, #12]
30020878:	e3530000 	cmp	r3, #0
3002087c:	1affffec 	bne	30020834 <udp_remove+0x48>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
30020880:	e3a00001 	mov	r0, #1
30020884:	e59d1004 	ldr	r1, [sp, #4]
30020888:	ebffd30e 	bl	300154c8 <memp_free>
}
3002088c:	e28dd014 	add	sp, sp, #20
30020890:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30020894:	e12fff1e 	bx	lr
30020898:	300eaa3c 	.word	0x300eaa3c

3002089c <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
3002089c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300208a0:	e24dd00c 	sub	sp, sp, #12
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
300208a4:	e3a00001 	mov	r0, #1
300208a8:	ebffd2a1 	bl	30015334 <memp_malloc>
300208ac:	e1a03000 	mov	r3, r0
300208b0:	e58d3004 	str	r3, [sp, #4]
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
300208b4:	e59d3004 	ldr	r3, [sp, #4]
300208b8:	e3530000 	cmp	r3, #0
300208bc:	0a000006 	beq	300208dc <udp_new+0x40>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
300208c0:	e59d0004 	ldr	r0, [sp, #4]
300208c4:	e3a01000 	mov	r1, #0
300208c8:	e3a02020 	mov	r2, #32
300208cc:	ebffae66 	bl	3000c26c <acoral_memset>
    pcb->ttl = UDP_TTL;
300208d0:	e59d3004 	ldr	r3, [sp, #4]
300208d4:	e3e02000 	mvn	r2, #0
300208d8:	e5c3200b 	strb	r2, [r3, #11]
  }
  return pcb;
300208dc:	e59d3004 	ldr	r3, [sp, #4]
}
300208e0:	e1a00003 	mov	r0, r3
300208e4:	e28dd00c 	add	sp, sp, #12
300208e8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300208ec:	e12fff1e 	bx	lr

300208f0 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
300208f0:	e24dd010 	sub	sp, sp, #16
300208f4:	e58d0004 	str	r0, [sp, #4]
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = (struct mem *)&ram[mem->next];
300208f8:	e59f3174 	ldr	r3, [pc, #372]	; 30020a74 <plug_holes+0x184>
300208fc:	e5933000 	ldr	r3, [r3]
30020900:	e1a02003 	mov	r2, r3
30020904:	e59d3004 	ldr	r3, [sp, #4]
30020908:	e1d330b0 	ldrh	r3, [r3]
3002090c:	e0823003 	add	r3, r2, r3
30020910:	e58d3008 	str	r3, [sp, #8]
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
30020914:	e59d2004 	ldr	r2, [sp, #4]
30020918:	e59d3008 	ldr	r3, [sp, #8]
3002091c:	e1520003 	cmp	r2, r3
30020920:	0a000025 	beq	300209bc <plug_holes+0xcc>
30020924:	e59d3008 	ldr	r3, [sp, #8]
30020928:	e5d33004 	ldrb	r3, [r3, #4]
3002092c:	e3530000 	cmp	r3, #0
30020930:	1a000021 	bne	300209bc <plug_holes+0xcc>
30020934:	e59d2008 	ldr	r2, [sp, #8]
30020938:	e59f3138 	ldr	r3, [pc, #312]	; 30020a78 <plug_holes+0x188>
3002093c:	e5933000 	ldr	r3, [r3]
30020940:	e1520003 	cmp	r2, r3
30020944:	0a00001c 	beq	300209bc <plug_holes+0xcc>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
30020948:	e59f312c 	ldr	r3, [pc, #300]	; 30020a7c <plug_holes+0x18c>
3002094c:	e5932000 	ldr	r2, [r3]
30020950:	e59d3008 	ldr	r3, [sp, #8]
30020954:	e1520003 	cmp	r2, r3
30020958:	1a000002 	bne	30020968 <plug_holes+0x78>
      lfree = mem;
3002095c:	e59f3118 	ldr	r3, [pc, #280]	; 30020a7c <plug_holes+0x18c>
30020960:	e59d2004 	ldr	r2, [sp, #4]
30020964:	e5832000 	str	r2, [r3]
    }
    mem->next = nmem->next;
30020968:	e59d3008 	ldr	r3, [sp, #8]
3002096c:	e1d320b0 	ldrh	r2, [r3]
30020970:	e59d3004 	ldr	r3, [sp, #4]
30020974:	e1c320b0 	strh	r2, [r3]
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
30020978:	e59f30f4 	ldr	r3, [pc, #244]	; 30020a74 <plug_holes+0x184>
3002097c:	e5933000 	ldr	r3, [r3]
30020980:	e1a02003 	mov	r2, r3
30020984:	e59d3008 	ldr	r3, [sp, #8]
30020988:	e1d330b0 	ldrh	r3, [r3]
3002098c:	e0823003 	add	r3, r2, r3
30020990:	e59d2004 	ldr	r2, [sp, #4]
30020994:	e1a02802 	lsl	r2, r2, #16
30020998:	e1a01822 	lsr	r1, r2, #16
3002099c:	e59f20d0 	ldr	r2, [pc, #208]	; 30020a74 <plug_holes+0x184>
300209a0:	e5922000 	ldr	r2, [r2]
300209a4:	e1a02802 	lsl	r2, r2, #16
300209a8:	e1a02822 	lsr	r2, r2, #16
300209ac:	e0622001 	rsb	r2, r2, r1
300209b0:	e1a02802 	lsl	r2, r2, #16
300209b4:	e1a02822 	lsr	r2, r2, #16
300209b8:	e1c320b2 	strh	r2, [r3, #2]
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
300209bc:	e59f30b0 	ldr	r3, [pc, #176]	; 30020a74 <plug_holes+0x184>
300209c0:	e5933000 	ldr	r3, [r3]
300209c4:	e1a02003 	mov	r2, r3
300209c8:	e59d3004 	ldr	r3, [sp, #4]
300209cc:	e1d330b2 	ldrh	r3, [r3, #2]
300209d0:	e0823003 	add	r3, r2, r3
300209d4:	e58d300c 	str	r3, [sp, #12]
  if (pmem != mem && pmem->used == 0) {
300209d8:	e59d200c 	ldr	r2, [sp, #12]
300209dc:	e59d3004 	ldr	r3, [sp, #4]
300209e0:	e1520003 	cmp	r2, r3
300209e4:	0a000020 	beq	30020a6c <plug_holes+0x17c>
300209e8:	e59d300c 	ldr	r3, [sp, #12]
300209ec:	e5d33004 	ldrb	r3, [r3, #4]
300209f0:	e3530000 	cmp	r3, #0
300209f4:	1a00001c 	bne	30020a6c <plug_holes+0x17c>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
300209f8:	e59f307c 	ldr	r3, [pc, #124]	; 30020a7c <plug_holes+0x18c>
300209fc:	e5932000 	ldr	r2, [r3]
30020a00:	e59d3004 	ldr	r3, [sp, #4]
30020a04:	e1520003 	cmp	r2, r3
30020a08:	1a000002 	bne	30020a18 <plug_holes+0x128>
      lfree = pmem;
30020a0c:	e59f3068 	ldr	r3, [pc, #104]	; 30020a7c <plug_holes+0x18c>
30020a10:	e59d200c 	ldr	r2, [sp, #12]
30020a14:	e5832000 	str	r2, [r3]
    }
    pmem->next = mem->next;
30020a18:	e59d3004 	ldr	r3, [sp, #4]
30020a1c:	e1d320b0 	ldrh	r2, [r3]
30020a20:	e59d300c 	ldr	r3, [sp, #12]
30020a24:	e1c320b0 	strh	r2, [r3]
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
30020a28:	e59f3044 	ldr	r3, [pc, #68]	; 30020a74 <plug_holes+0x184>
30020a2c:	e5933000 	ldr	r3, [r3]
30020a30:	e1a02003 	mov	r2, r3
30020a34:	e59d3004 	ldr	r3, [sp, #4]
30020a38:	e1d330b0 	ldrh	r3, [r3]
30020a3c:	e0823003 	add	r3, r2, r3
30020a40:	e59d200c 	ldr	r2, [sp, #12]
30020a44:	e1a02802 	lsl	r2, r2, #16
30020a48:	e1a01822 	lsr	r1, r2, #16
30020a4c:	e59f2020 	ldr	r2, [pc, #32]	; 30020a74 <plug_holes+0x184>
30020a50:	e5922000 	ldr	r2, [r2]
30020a54:	e1a02802 	lsl	r2, r2, #16
30020a58:	e1a02822 	lsr	r2, r2, #16
30020a5c:	e0622001 	rsb	r2, r2, r1
30020a60:	e1a02802 	lsl	r2, r2, #16
30020a64:	e1a02822 	lsr	r2, r2, #16
30020a68:	e1c320b2 	strh	r2, [r3, #2]
  }
}
30020a6c:	e28dd010 	add	sp, sp, #16
30020a70:	e12fff1e 	bx	lr
30020a74:	300e3be0 	.word	0x300e3be0
30020a78:	300e3be4 	.word	0x300e3be4
30020a7c:	300e3be8 	.word	0x300e3be8

30020a80 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
30020a80:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30020a84:	e24dd00c 	sub	sp, sp, #12

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
30020a88:	e59f30c4 	ldr	r3, [pc, #196]	; 30020b54 <mem_init+0xd4>
30020a8c:	e2833003 	add	r3, r3, #3
30020a90:	e3c33003 	bic	r3, r3, #3
30020a94:	e1a02003 	mov	r2, r3
30020a98:	e59f30b8 	ldr	r3, [pc, #184]	; 30020b58 <mem_init+0xd8>
30020a9c:	e5832000 	str	r2, [r3]
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
30020aa0:	e59f30b0 	ldr	r3, [pc, #176]	; 30020b58 <mem_init+0xd8>
30020aa4:	e5933000 	ldr	r3, [r3]
30020aa8:	e58d3004 	str	r3, [sp, #4]
  mem->next = MEM_SIZE_ALIGNED;
30020aac:	e59d3004 	ldr	r3, [sp, #4]
30020ab0:	e3a02902 	mov	r2, #32768	; 0x8000
30020ab4:	e1c320b0 	strh	r2, [r3]
  mem->prev = 0;
30020ab8:	e59d3004 	ldr	r3, [sp, #4]
30020abc:	e3a02000 	mov	r2, #0
30020ac0:	e1c320b2 	strh	r2, [r3, #2]
  mem->used = 0;
30020ac4:	e59d3004 	ldr	r3, [sp, #4]
30020ac8:	e3a02000 	mov	r2, #0
30020acc:	e5c32004 	strb	r2, [r3, #4]
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
30020ad0:	e59f3080 	ldr	r3, [pc, #128]	; 30020b58 <mem_init+0xd8>
30020ad4:	e5933000 	ldr	r3, [r3]
30020ad8:	e2832902 	add	r2, r3, #32768	; 0x8000
30020adc:	e59f3078 	ldr	r3, [pc, #120]	; 30020b5c <mem_init+0xdc>
30020ae0:	e5832000 	str	r2, [r3]
  ram_end->used = 1;
30020ae4:	e59f3070 	ldr	r3, [pc, #112]	; 30020b5c <mem_init+0xdc>
30020ae8:	e5933000 	ldr	r3, [r3]
30020aec:	e3a02001 	mov	r2, #1
30020af0:	e5c32004 	strb	r2, [r3, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
30020af4:	e59f3060 	ldr	r3, [pc, #96]	; 30020b5c <mem_init+0xdc>
30020af8:	e5933000 	ldr	r3, [r3]
30020afc:	e3a02902 	mov	r2, #32768	; 0x8000
30020b00:	e1c320b0 	strh	r2, [r3]
  ram_end->prev = MEM_SIZE_ALIGNED;
30020b04:	e59f3050 	ldr	r3, [pc, #80]	; 30020b5c <mem_init+0xdc>
30020b08:	e5933000 	ldr	r3, [r3]
30020b0c:	e3a02902 	mov	r2, #32768	; 0x8000
30020b10:	e1c320b2 	strh	r2, [r3, #2]

  mem_sem = sys_sem_new(1);
30020b14:	e3a00001 	mov	r0, #1
30020b18:	ebffaf6d 	bl	3000c8d4 <sys_sem_new>
30020b1c:	e1a02000 	mov	r2, r0
30020b20:	e59f3038 	ldr	r3, [pc, #56]	; 30020b60 <mem_init+0xe0>
30020b24:	e5832000 	str	r2, [r3]

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
30020b28:	e59f3028 	ldr	r3, [pc, #40]	; 30020b58 <mem_init+0xd8>
30020b2c:	e5933000 	ldr	r3, [r3]
30020b30:	e1a02003 	mov	r2, r3
30020b34:	e59f3028 	ldr	r3, [pc, #40]	; 30020b64 <mem_init+0xe4>
30020b38:	e5832000 	str	r2, [r3]

#if MEM_STATS
  lwip_stats.mem.avail = MEM_SIZE_ALIGNED;
30020b3c:	e59f3024 	ldr	r3, [pc, #36]	; 30020b68 <mem_init+0xe8>
30020b40:	e3a02902 	mov	r2, #32768	; 0x8000
30020b44:	e1c32bb6 	strh	r2, [r3, #182]	; 0xb6
#endif /* MEM_STATS */
}
30020b48:	e28dd00c 	add	sp, sp, #12
30020b4c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30020b50:	e12fff1e 	bx	lr
30020b54:	300dbbcc 	.word	0x300dbbcc
30020b58:	300e3be0 	.word	0x300e3be0
30020b5c:	300e3be4 	.word	0x300e3be4
30020b60:	300e3bec 	.word	0x300e3bec
30020b64:	300e3be8 	.word	0x300e3be8
30020b68:	302be570 	.word	0x302be570

30020b6c <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
30020b6c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30020b70:	e24dd014 	sub	sp, sp, #20
30020b74:	e58d0004 	str	r0, [sp, #4]
  struct mem *mem;

  if (rmem == NULL) {
30020b78:	e59d3004 	ldr	r3, [sp, #4]
30020b7c:	e3530000 	cmp	r3, #0
30020b80:	0a000045 	beq	30020c9c <mem_free+0x130>
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
30020b84:	e59f3120 	ldr	r3, [pc, #288]	; 30020cac <mem_free+0x140>
30020b88:	e5933000 	ldr	r3, [r3]
30020b8c:	e1a00003 	mov	r0, r3
30020b90:	e3a01000 	mov	r1, #0
30020b94:	ebffaf6b 	bl	3000c948 <sys_arch_sem_wait>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
30020b98:	e59d2004 	ldr	r2, [sp, #4]
30020b9c:	e59f310c 	ldr	r3, [pc, #268]	; 30020cb0 <mem_free+0x144>
30020ba0:	e5933000 	ldr	r3, [r3]
30020ba4:	e1520003 	cmp	r2, r3
30020ba8:	3a000004 	bcc	30020bc0 <mem_free+0x54>
30020bac:	e59d2004 	ldr	r2, [sp, #4]
30020bb0:	e59f30fc 	ldr	r3, [pc, #252]	; 30020cb4 <mem_free+0x148>
30020bb4:	e5933000 	ldr	r3, [r3]
30020bb8:	e1520003 	cmp	r2, r3
30020bbc:	3a00000b 	bcc	30020bf0 <mem_free+0x84>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_free: illegal memory\n"));
#if MEM_STATS
    ++lwip_stats.mem.err;
30020bc0:	e59f30f0 	ldr	r3, [pc, #240]	; 30020cb8 <mem_free+0x14c>
30020bc4:	e1d33bbc 	ldrh	r3, [r3, #188]	; 0xbc
30020bc8:	e2833001 	add	r3, r3, #1
30020bcc:	e1a03803 	lsl	r3, r3, #16
30020bd0:	e1a02823 	lsr	r2, r3, #16
30020bd4:	e59f30dc 	ldr	r3, [pc, #220]	; 30020cb8 <mem_free+0x14c>
30020bd8:	e1c32bbc 	strh	r2, [r3, #188]	; 0xbc
#endif /* MEM_STATS */
    sys_sem_signal(mem_sem);
30020bdc:	e59f30c8 	ldr	r3, [pc, #200]	; 30020cac <mem_free+0x140>
30020be0:	e5933000 	ldr	r3, [r3]
30020be4:	e1a00003 	mov	r0, r3
30020be8:	ebffaf4e 	bl	3000c928 <sys_sem_signal>
    return;
30020bec:	ea00002b 	b	30020ca0 <mem_free+0x134>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
30020bf0:	e59d3004 	ldr	r3, [sp, #4]
30020bf4:	e2433008 	sub	r3, r3, #8
30020bf8:	e58d300c 	str	r3, [sp, #12]
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
30020bfc:	e59d300c 	ldr	r3, [sp, #12]
30020c00:	e3a02000 	mov	r2, #0
30020c04:	e5c32004 	strb	r2, [r3, #4]

  if (mem < lfree) {
30020c08:	e59f30ac 	ldr	r3, [pc, #172]	; 30020cbc <mem_free+0x150>
30020c0c:	e5933000 	ldr	r3, [r3]
30020c10:	e59d200c 	ldr	r2, [sp, #12]
30020c14:	e1520003 	cmp	r2, r3
30020c18:	2a000002 	bcs	30020c28 <mem_free+0xbc>
    /* the newly freed struct is now the lowest */
    lfree = mem;
30020c1c:	e59f3098 	ldr	r3, [pc, #152]	; 30020cbc <mem_free+0x150>
30020c20:	e59d200c 	ldr	r2, [sp, #12]
30020c24:	e5832000 	str	r2, [r3]
  }

#if MEM_STATS
  lwip_stats.mem.used -= mem->next - ((u8_t *)mem - ram);
30020c28:	e59f3088 	ldr	r3, [pc, #136]	; 30020cb8 <mem_free+0x14c>
30020c2c:	e1d32bb8 	ldrh	r2, [r3, #184]	; 0xb8
30020c30:	e59d300c 	ldr	r3, [sp, #12]
30020c34:	e1a03803 	lsl	r3, r3, #16
30020c38:	e1a01823 	lsr	r1, r3, #16
30020c3c:	e59f306c 	ldr	r3, [pc, #108]	; 30020cb0 <mem_free+0x144>
30020c40:	e5933000 	ldr	r3, [r3]
30020c44:	e1a03803 	lsl	r3, r3, #16
30020c48:	e1a03823 	lsr	r3, r3, #16
30020c4c:	e0633001 	rsb	r3, r3, r1
30020c50:	e1a03803 	lsl	r3, r3, #16
30020c54:	e1a01823 	lsr	r1, r3, #16
30020c58:	e59d300c 	ldr	r3, [sp, #12]
30020c5c:	e1d330b0 	ldrh	r3, [r3]
30020c60:	e0633001 	rsb	r3, r3, r1
30020c64:	e1a03803 	lsl	r3, r3, #16
30020c68:	e1a03823 	lsr	r3, r3, #16
30020c6c:	e0823003 	add	r3, r2, r3
30020c70:	e1a03803 	lsl	r3, r3, #16
30020c74:	e1a02823 	lsr	r2, r3, #16
30020c78:	e59f3038 	ldr	r3, [pc, #56]	; 30020cb8 <mem_free+0x14c>
30020c7c:	e1c32bb8 	strh	r2, [r3, #184]	; 0xb8
#endif /* MEM_STATS */

  /* finally, see if prev or next are free also */
  plug_holes(mem);
30020c80:	e59d000c 	ldr	r0, [sp, #12]
30020c84:	ebffff19 	bl	300208f0 <plug_holes>
  sys_sem_signal(mem_sem);
30020c88:	e59f301c 	ldr	r3, [pc, #28]	; 30020cac <mem_free+0x140>
30020c8c:	e5933000 	ldr	r3, [r3]
30020c90:	e1a00003 	mov	r0, r3
30020c94:	ebffaf23 	bl	3000c928 <sys_sem_signal>
30020c98:	ea000000 	b	30020ca0 <mem_free+0x134>
{
  struct mem *mem;

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
30020c9c:	e1a00000 	nop			; (mov r0, r0)
#endif /* MEM_STATS */

  /* finally, see if prev or next are free also */
  plug_holes(mem);
  sys_sem_signal(mem_sem);
}
30020ca0:	e28dd014 	add	sp, sp, #20
30020ca4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30020ca8:	e12fff1e 	bx	lr
30020cac:	300e3bec 	.word	0x300e3bec
30020cb0:	300e3be0 	.word	0x300e3be0
30020cb4:	300e3be4 	.word	0x300e3be4
30020cb8:	302be570 	.word	0x302be570
30020cbc:	300e3be8 	.word	0x300e3be8

30020cc0 <mem_realloc>:
 *                equal to the previous size)
 * @return for compatibility reasons: is always == rmem, at the moment
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
30020cc0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30020cc4:	e24dd024 	sub	sp, sp, #36	; 0x24
30020cc8:	e58d0004 	str	r0, [sp, #4]
30020ccc:	e1a03001 	mov	r3, r1
30020cd0:	e1cd30b2 	strh	r3, [sp, #2]
  mem_size_t ptr, ptr2;
  struct mem *mem, *mem2;

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
30020cd4:	e1dd30b2 	ldrh	r3, [sp, #2]
30020cd8:	e2833003 	add	r3, r3, #3
30020cdc:	e1a03803 	lsl	r3, r3, #16
30020ce0:	e1a03823 	lsr	r3, r3, #16
30020ce4:	e3c33003 	bic	r3, r3, #3
30020ce8:	e1cd30b2 	strh	r3, [sp, #2]

  if(newsize < MIN_SIZE_ALIGNED) {
30020cec:	e1dd30b2 	ldrh	r3, [sp, #2]
30020cf0:	e353000b 	cmp	r3, #11
30020cf4:	8a000001 	bhi	30020d00 <mem_realloc+0x40>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
30020cf8:	e3a0300c 	mov	r3, #12
30020cfc:	e1cd30b2 	strh	r3, [sp, #2]
  }

  if (newsize > MEM_SIZE_ALIGNED) {
30020d00:	e1dd30b2 	ldrh	r3, [sp, #2]
30020d04:	e3530902 	cmp	r3, #32768	; 0x8000
30020d08:	9a000001 	bls	30020d14 <mem_realloc+0x54>
    return NULL;
30020d0c:	e3a03000 	mov	r3, #0
30020d10:	ea0000b6 	b	30020ff0 <mem_realloc+0x330>
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
30020d14:	e59d2004 	ldr	r2, [sp, #4]
30020d18:	e59f32e0 	ldr	r3, [pc, #736]	; 30021000 <mem_realloc+0x340>
30020d1c:	e5933000 	ldr	r3, [r3]
30020d20:	e1520003 	cmp	r2, r3
30020d24:	3a000004 	bcc	30020d3c <mem_realloc+0x7c>
30020d28:	e59d2004 	ldr	r2, [sp, #4]
30020d2c:	e59f32d0 	ldr	r3, [pc, #720]	; 30021004 <mem_realloc+0x344>
30020d30:	e5933000 	ldr	r3, [r3]
30020d34:	e1520003 	cmp	r2, r3
30020d38:	3a000001 	bcc	30020d44 <mem_realloc+0x84>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_realloc: illegal memory\n"));
    return rmem;
30020d3c:	e59d3004 	ldr	r3, [sp, #4]
30020d40:	ea0000aa 	b	30020ff0 <mem_realloc+0x330>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
30020d44:	e59d3004 	ldr	r3, [sp, #4]
30020d48:	e2433008 	sub	r3, r3, #8
30020d4c:	e58d3014 	str	r3, [sp, #20]
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
30020d50:	e59d3014 	ldr	r3, [sp, #20]
30020d54:	e1a03803 	lsl	r3, r3, #16
30020d58:	e1a02823 	lsr	r2, r3, #16
30020d5c:	e59f329c 	ldr	r3, [pc, #668]	; 30021000 <mem_realloc+0x340>
30020d60:	e5933000 	ldr	r3, [r3]
30020d64:	e1a03803 	lsl	r3, r3, #16
30020d68:	e1a03823 	lsr	r3, r3, #16
30020d6c:	e0633002 	rsb	r3, r3, r2
30020d70:	e1cd31b0 	strh	r3, [sp, #16]

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
30020d74:	e59d3014 	ldr	r3, [sp, #20]
30020d78:	e1d320b0 	ldrh	r2, [r3]
30020d7c:	e1dd31b0 	ldrh	r3, [sp, #16]
30020d80:	e0633002 	rsb	r3, r3, r2
30020d84:	e1a03803 	lsl	r3, r3, #16
30020d88:	e1a03823 	lsr	r3, r3, #16
30020d8c:	e2433008 	sub	r3, r3, #8
30020d90:	e1cd30be 	strh	r3, [sp, #14]
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  if (newsize > size) {
30020d94:	e1dd20b2 	ldrh	r2, [sp, #2]
30020d98:	e1dd30be 	ldrh	r3, [sp, #14]
30020d9c:	e1520003 	cmp	r2, r3
30020da0:	9a000001 	bls	30020dac <mem_realloc+0xec>
    /* not supported */
    return NULL;
30020da4:	e3a03000 	mov	r3, #0
30020da8:	ea000090 	b	30020ff0 <mem_realloc+0x330>
  }
  if (newsize == size) {
30020dac:	e1dd20b2 	ldrh	r2, [sp, #2]
30020db0:	e1dd30be 	ldrh	r3, [sp, #14]
30020db4:	e1520003 	cmp	r2, r3
30020db8:	1a000001 	bne	30020dc4 <mem_realloc+0x104>
    /* No change in size, simply return */
    return rmem;
30020dbc:	e59d3004 	ldr	r3, [sp, #4]
30020dc0:	ea00008a 	b	30020ff0 <mem_realloc+0x330>
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
30020dc4:	e59f323c 	ldr	r3, [pc, #572]	; 30021008 <mem_realloc+0x348>
30020dc8:	e5933000 	ldr	r3, [r3]
30020dcc:	e1a00003 	mov	r0, r3
30020dd0:	e3a01000 	mov	r1, #0
30020dd4:	ebffaedb 	bl	3000c948 <sys_arch_sem_wait>

#if MEM_STATS
  lwip_stats.mem.used -= (size - newsize);
30020dd8:	e59f322c 	ldr	r3, [pc, #556]	; 3002100c <mem_realloc+0x34c>
30020ddc:	e1d32bb8 	ldrh	r2, [r3, #184]	; 0xb8
30020de0:	e1dd10b2 	ldrh	r1, [sp, #2]
30020de4:	e1dd30be 	ldrh	r3, [sp, #14]
30020de8:	e0633001 	rsb	r3, r3, r1
30020dec:	e1a03803 	lsl	r3, r3, #16
30020df0:	e1a03823 	lsr	r3, r3, #16
30020df4:	e0823003 	add	r3, r2, r3
30020df8:	e1a03803 	lsl	r3, r3, #16
30020dfc:	e1a02823 	lsr	r2, r3, #16
30020e00:	e59f3204 	ldr	r3, [pc, #516]	; 3002100c <mem_realloc+0x34c>
30020e04:	e1c32bb8 	strh	r2, [r3, #184]	; 0xb8
#endif /* MEM_STATS */

  mem2 = (struct mem *)&ram[mem->next];
30020e08:	e59f31f0 	ldr	r3, [pc, #496]	; 30021000 <mem_realloc+0x340>
30020e0c:	e5933000 	ldr	r3, [r3]
30020e10:	e1a02003 	mov	r2, r3
30020e14:	e59d3014 	ldr	r3, [sp, #20]
30020e18:	e1d330b0 	ldrh	r3, [r3]
30020e1c:	e0823003 	add	r3, r2, r3
30020e20:	e58d3018 	str	r3, [sp, #24]
  if(mem2->used == 0) {
30020e24:	e59d3018 	ldr	r3, [sp, #24]
30020e28:	e5d33004 	ldrb	r3, [r3, #4]
30020e2c:	e3530000 	cmp	r3, #0
30020e30:	1a000034 	bne	30020f08 <mem_realloc+0x248>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
30020e34:	e59d3018 	ldr	r3, [sp, #24]
30020e38:	e1d330b0 	ldrh	r3, [r3]
30020e3c:	e1cd31be 	strh	r3, [sp, #30]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
30020e40:	e1dd21b0 	ldrh	r2, [sp, #16]
30020e44:	e1dd30b2 	ldrh	r3, [sp, #2]
30020e48:	e0823003 	add	r3, r2, r3
30020e4c:	e1a03803 	lsl	r3, r3, #16
30020e50:	e1a03823 	lsr	r3, r3, #16
30020e54:	e2833008 	add	r3, r3, #8
30020e58:	e1cd31b2 	strh	r3, [sp, #18]
    if (lfree == mem2) {
30020e5c:	e59f31ac 	ldr	r3, [pc, #428]	; 30021010 <mem_realloc+0x350>
30020e60:	e5932000 	ldr	r2, [r3]
30020e64:	e59d3018 	ldr	r3, [sp, #24]
30020e68:	e1520003 	cmp	r2, r3
30020e6c:	1a000006 	bne	30020e8c <mem_realloc+0x1cc>
      lfree = (struct mem *)&ram[ptr2];
30020e70:	e59f3188 	ldr	r3, [pc, #392]	; 30021000 <mem_realloc+0x340>
30020e74:	e5933000 	ldr	r3, [r3]
30020e78:	e1a02003 	mov	r2, r3
30020e7c:	e1dd31b2 	ldrh	r3, [sp, #18]
30020e80:	e0822003 	add	r2, r2, r3
30020e84:	e59f3184 	ldr	r3, [pc, #388]	; 30021010 <mem_realloc+0x350>
30020e88:	e5832000 	str	r2, [r3]
    }
    mem2 = (struct mem *)&ram[ptr2];
30020e8c:	e59f316c 	ldr	r3, [pc, #364]	; 30021000 <mem_realloc+0x340>
30020e90:	e5933000 	ldr	r3, [r3]
30020e94:	e1a02003 	mov	r2, r3
30020e98:	e1dd31b2 	ldrh	r3, [sp, #18]
30020e9c:	e0823003 	add	r3, r2, r3
30020ea0:	e58d3018 	str	r3, [sp, #24]
    mem2->used = 0;
30020ea4:	e59d3018 	ldr	r3, [sp, #24]
30020ea8:	e3a02000 	mov	r2, #0
30020eac:	e5c32004 	strb	r2, [r3, #4]
    /* restore the next pointer */
    mem2->next = next;
30020eb0:	e59d3018 	ldr	r3, [sp, #24]
30020eb4:	e1dd21be 	ldrh	r2, [sp, #30]
30020eb8:	e1c320b0 	strh	r2, [r3]
    /* link it back to mem */
    mem2->prev = ptr;
30020ebc:	e59d3018 	ldr	r3, [sp, #24]
30020ec0:	e1dd21b0 	ldrh	r2, [sp, #16]
30020ec4:	e1c320b2 	strh	r2, [r3, #2]
    /* link mem to it */
    mem->next = ptr2;
30020ec8:	e59d3014 	ldr	r3, [sp, #20]
30020ecc:	e1dd21b2 	ldrh	r2, [sp, #18]
30020ed0:	e1c320b0 	strh	r2, [r3]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
30020ed4:	e59d3018 	ldr	r3, [sp, #24]
30020ed8:	e1d330b0 	ldrh	r3, [r3]
30020edc:	e3530902 	cmp	r3, #32768	; 0x8000
30020ee0:	0a00003c 	beq	30020fd8 <mem_realloc+0x318>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
30020ee4:	e59f3114 	ldr	r3, [pc, #276]	; 30021000 <mem_realloc+0x340>
30020ee8:	e5933000 	ldr	r3, [r3]
30020eec:	e1a02003 	mov	r2, r3
30020ef0:	e59d3018 	ldr	r3, [sp, #24]
30020ef4:	e1d330b0 	ldrh	r3, [r3]
30020ef8:	e0823003 	add	r3, r2, r3
30020efc:	e1dd21b2 	ldrh	r2, [sp, #18]
30020f00:	e1c320b2 	strh	r2, [r3, #2]
30020f04:	ea000034 	b	30020fdc <mem_realloc+0x31c>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
30020f08:	e1dd30b2 	ldrh	r3, [sp, #2]
30020f0c:	e2832014 	add	r2, r3, #20
30020f10:	e1dd30be 	ldrh	r3, [sp, #14]
30020f14:	e1520003 	cmp	r2, r3
30020f18:	8a00002f 	bhi	30020fdc <mem_realloc+0x31c>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
30020f1c:	e1dd21b0 	ldrh	r2, [sp, #16]
30020f20:	e1dd30b2 	ldrh	r3, [sp, #2]
30020f24:	e0823003 	add	r3, r2, r3
30020f28:	e1a03803 	lsl	r3, r3, #16
30020f2c:	e1a03823 	lsr	r3, r3, #16
30020f30:	e2833008 	add	r3, r3, #8
30020f34:	e1cd31b2 	strh	r3, [sp, #18]
    mem2 = (struct mem *)&ram[ptr2];
30020f38:	e59f30c0 	ldr	r3, [pc, #192]	; 30021000 <mem_realloc+0x340>
30020f3c:	e5933000 	ldr	r3, [r3]
30020f40:	e1a02003 	mov	r2, r3
30020f44:	e1dd31b2 	ldrh	r3, [sp, #18]
30020f48:	e0823003 	add	r3, r2, r3
30020f4c:	e58d3018 	str	r3, [sp, #24]
    if (mem2 < lfree) {
30020f50:	e59f30b8 	ldr	r3, [pc, #184]	; 30021010 <mem_realloc+0x350>
30020f54:	e5933000 	ldr	r3, [r3]
30020f58:	e59d2018 	ldr	r2, [sp, #24]
30020f5c:	e1520003 	cmp	r2, r3
30020f60:	2a000002 	bcs	30020f70 <mem_realloc+0x2b0>
      lfree = mem2;
30020f64:	e59f30a4 	ldr	r3, [pc, #164]	; 30021010 <mem_realloc+0x350>
30020f68:	e59d2018 	ldr	r2, [sp, #24]
30020f6c:	e5832000 	str	r2, [r3]
    }
    mem2->used = 0;
30020f70:	e59d3018 	ldr	r3, [sp, #24]
30020f74:	e3a02000 	mov	r2, #0
30020f78:	e5c32004 	strb	r2, [r3, #4]
    mem2->next = mem->next;
30020f7c:	e59d3014 	ldr	r3, [sp, #20]
30020f80:	e1d320b0 	ldrh	r2, [r3]
30020f84:	e59d3018 	ldr	r3, [sp, #24]
30020f88:	e1c320b0 	strh	r2, [r3]
    mem2->prev = ptr;
30020f8c:	e59d3018 	ldr	r3, [sp, #24]
30020f90:	e1dd21b0 	ldrh	r2, [sp, #16]
30020f94:	e1c320b2 	strh	r2, [r3, #2]
    mem->next = ptr2;
30020f98:	e59d3014 	ldr	r3, [sp, #20]
30020f9c:	e1dd21b2 	ldrh	r2, [sp, #18]
30020fa0:	e1c320b0 	strh	r2, [r3]
    if (mem2->next != MEM_SIZE_ALIGNED) {
30020fa4:	e59d3018 	ldr	r3, [sp, #24]
30020fa8:	e1d330b0 	ldrh	r3, [r3]
30020fac:	e3530902 	cmp	r3, #32768	; 0x8000
30020fb0:	0a000009 	beq	30020fdc <mem_realloc+0x31c>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
30020fb4:	e59f3044 	ldr	r3, [pc, #68]	; 30021000 <mem_realloc+0x340>
30020fb8:	e5933000 	ldr	r3, [r3]
30020fbc:	e1a02003 	mov	r2, r3
30020fc0:	e59d3018 	ldr	r3, [sp, #24]
30020fc4:	e1d330b0 	ldrh	r3, [r3]
30020fc8:	e0823003 	add	r3, r2, r3
30020fcc:	e1dd21b2 	ldrh	r2, [sp, #18]
30020fd0:	e1c320b2 	strh	r2, [r3, #2]
30020fd4:	ea000000 	b	30020fdc <mem_realloc+0x31c>
    mem->next = ptr2;
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
30020fd8:	e1a00000 	nop			; (mov r0, r0)
    next struct mem is used but size between mem and mem2 is not big enough
    to create another struct mem
    -> don't do anyhting. 
    -> the remaining space stays unused since it is too small
  } */
  sys_sem_signal(mem_sem);
30020fdc:	e59f3024 	ldr	r3, [pc, #36]	; 30021008 <mem_realloc+0x348>
30020fe0:	e5933000 	ldr	r3, [r3]
30020fe4:	e1a00003 	mov	r0, r3
30020fe8:	ebffae4e 	bl	3000c928 <sys_sem_signal>
  return rmem;
30020fec:	e59d3004 	ldr	r3, [sp, #4]
}
30020ff0:	e1a00003 	mov	r0, r3
30020ff4:	e28dd024 	add	sp, sp, #36	; 0x24
30020ff8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30020ffc:	e12fff1e 	bx	lr
30021000:	300e3be0 	.word	0x300e3be0
30021004:	300e3be4 	.word	0x300e3be4
30021008:	300e3bec 	.word	0x300e3bec
3002100c:	302be570 	.word	0x302be570
30021010:	300e3be8 	.word	0x300e3be8

30021014 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
30021014:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30021018:	e24dd01c 	sub	sp, sp, #28
3002101c:	e1a03000 	mov	r3, r0
30021020:	e1cd30b6 	strh	r3, [sp, #6]
  mem_size_t ptr, ptr2;
  struct mem *mem, *mem2;

  if (size == 0) {
30021024:	e1dd30b6 	ldrh	r3, [sp, #6]
30021028:	e3530000 	cmp	r3, #0
3002102c:	1a000001 	bne	30021038 <mem_malloc+0x24>
    return NULL;
30021030:	e3a03000 	mov	r3, #0
30021034:	ea0000d9 	b	300213a0 <mem_malloc+0x38c>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
30021038:	e1dd30b6 	ldrh	r3, [sp, #6]
3002103c:	e2833003 	add	r3, r3, #3
30021040:	e1a03803 	lsl	r3, r3, #16
30021044:	e1a03823 	lsr	r3, r3, #16
30021048:	e3c33003 	bic	r3, r3, #3
3002104c:	e1cd30b6 	strh	r3, [sp, #6]

  if(size < MIN_SIZE_ALIGNED) {
30021050:	e1dd30b6 	ldrh	r3, [sp, #6]
30021054:	e353000b 	cmp	r3, #11
30021058:	8a000001 	bhi	30021064 <mem_malloc+0x50>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
3002105c:	e3a0300c 	mov	r3, #12
30021060:	e1cd30b6 	strh	r3, [sp, #6]
  }

  if (size > MEM_SIZE_ALIGNED) {
30021064:	e1dd30b6 	ldrh	r3, [sp, #6]
30021068:	e3530902 	cmp	r3, #32768	; 0x8000
3002106c:	9a000001 	bls	30021078 <mem_malloc+0x64>
    return NULL;
30021070:	e3a03000 	mov	r3, #0
30021074:	ea0000c9 	b	300213a0 <mem_malloc+0x38c>
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
30021078:	e59f3330 	ldr	r3, [pc, #816]	; 300213b0 <mem_malloc+0x39c>
3002107c:	e5933000 	ldr	r3, [r3]
30021080:	e1a00003 	mov	r0, r3
30021084:	e3a01000 	mov	r1, #0
30021088:	ebffae2e 	bl	3000c948 <sys_arch_sem_wait>

  /* Scan through the heap searching for a free block that is big enough,
   * beginning with the lowest free block.
   */
  for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
3002108c:	e59f3320 	ldr	r3, [pc, #800]	; 300213b4 <mem_malloc+0x3a0>
30021090:	e5933000 	ldr	r3, [r3]
30021094:	e1a03803 	lsl	r3, r3, #16
30021098:	e1a02823 	lsr	r2, r3, #16
3002109c:	e59f3314 	ldr	r3, [pc, #788]	; 300213b8 <mem_malloc+0x3a4>
300210a0:	e5933000 	ldr	r3, [r3]
300210a4:	e1a03803 	lsl	r3, r3, #16
300210a8:	e1a03823 	lsr	r3, r3, #16
300210ac:	e0633002 	rsb	r3, r3, r2
300210b0:	e1cd30bc 	strh	r3, [sp, #12]
300210b4:	ea0000a8 	b	3002135c <mem_malloc+0x348>
       ptr = ((struct mem *)&ram[ptr])->next) {
    mem = (struct mem *)&ram[ptr];
300210b8:	e59f32f8 	ldr	r3, [pc, #760]	; 300213b8 <mem_malloc+0x3a4>
300210bc:	e5933000 	ldr	r3, [r3]
300210c0:	e1a02003 	mov	r2, r3
300210c4:	e1dd30bc 	ldrh	r3, [sp, #12]
300210c8:	e0823003 	add	r3, r2, r3
300210cc:	e58d3010 	str	r3, [sp, #16]

    if ((!mem->used) &&
300210d0:	e59d3010 	ldr	r3, [sp, #16]
300210d4:	e5d33004 	ldrb	r3, [r3, #4]
300210d8:	e3530000 	cmp	r3, #0
300210dc:	1a000097 	bne	30021340 <mem_malloc+0x32c>
        (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
300210e0:	e59d3010 	ldr	r3, [sp, #16]
300210e4:	e1d330b0 	ldrh	r3, [r3]
300210e8:	e1a02003 	mov	r2, r3
300210ec:	e1dd30bc 	ldrh	r3, [sp, #12]
300210f0:	e0633002 	rsb	r3, r3, r2
300210f4:	e2432008 	sub	r2, r3, #8
300210f8:	e1dd30b6 	ldrh	r3, [sp, #6]
   */
  for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
       ptr = ((struct mem *)&ram[ptr])->next) {
    mem = (struct mem *)&ram[ptr];

    if ((!mem->used) &&
300210fc:	e1520003 	cmp	r2, r3
30021100:	3a00008e 	bcc	30021340 <mem_malloc+0x32c>
        (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
      /* mem is not used and at least perfect fit is possible:
       * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

      if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
30021104:	e59d3010 	ldr	r3, [sp, #16]
30021108:	e1d330b0 	ldrh	r3, [r3]
3002110c:	e1a02003 	mov	r2, r3
30021110:	e1dd30bc 	ldrh	r3, [sp, #12]
30021114:	e0633002 	rsb	r3, r3, r2
30021118:	e2432008 	sub	r2, r3, #8
3002111c:	e1dd30b6 	ldrh	r3, [sp, #6]
30021120:	e2833014 	add	r3, r3, #20
30021124:	e1520003 	cmp	r2, r3
30021128:	3a00003e 	bcc	30021228 <mem_malloc+0x214>
         * struct mem would fit in but no data between mem2 and mem2->next
         * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
         *       region that couldn't hold data, but when mem->next gets freed,
         *       the 2 regions would be combined, resulting in more free memory
         */
        ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
3002112c:	e1dd20bc 	ldrh	r2, [sp, #12]
30021130:	e1dd30b6 	ldrh	r3, [sp, #6]
30021134:	e0823003 	add	r3, r2, r3
30021138:	e1a03803 	lsl	r3, r3, #16
3002113c:	e1a03823 	lsr	r3, r3, #16
30021140:	e2833008 	add	r3, r3, #8
30021144:	e1cd30be 	strh	r3, [sp, #14]
        /* create mem2 struct */
        mem2 = (struct mem *)&ram[ptr2];
30021148:	e59f3268 	ldr	r3, [pc, #616]	; 300213b8 <mem_malloc+0x3a4>
3002114c:	e5933000 	ldr	r3, [r3]
30021150:	e1a02003 	mov	r2, r3
30021154:	e1dd30be 	ldrh	r3, [sp, #14]
30021158:	e0823003 	add	r3, r2, r3
3002115c:	e58d3014 	str	r3, [sp, #20]
        mem2->used = 0;
30021160:	e59d3014 	ldr	r3, [sp, #20]
30021164:	e3a02000 	mov	r2, #0
30021168:	e5c32004 	strb	r2, [r3, #4]
        mem2->next = mem->next;
3002116c:	e59d3010 	ldr	r3, [sp, #16]
30021170:	e1d320b0 	ldrh	r2, [r3]
30021174:	e59d3014 	ldr	r3, [sp, #20]
30021178:	e1c320b0 	strh	r2, [r3]
        mem2->prev = ptr;
3002117c:	e59d3014 	ldr	r3, [sp, #20]
30021180:	e1dd20bc 	ldrh	r2, [sp, #12]
30021184:	e1c320b2 	strh	r2, [r3, #2]
        /* and insert it between mem and mem->next */
        mem->next = ptr2;
30021188:	e59d3010 	ldr	r3, [sp, #16]
3002118c:	e1dd20be 	ldrh	r2, [sp, #14]
30021190:	e1c320b0 	strh	r2, [r3]
        mem->used = 1;
30021194:	e59d3010 	ldr	r3, [sp, #16]
30021198:	e3a02001 	mov	r2, #1
3002119c:	e5c32004 	strb	r2, [r3, #4]

        if (mem2->next != MEM_SIZE_ALIGNED) {
300211a0:	e59d3014 	ldr	r3, [sp, #20]
300211a4:	e1d330b0 	ldrh	r3, [r3]
300211a8:	e3530902 	cmp	r3, #32768	; 0x8000
300211ac:	0a000007 	beq	300211d0 <mem_malloc+0x1bc>
          ((struct mem *)&ram[mem2->next])->prev = ptr2;
300211b0:	e59f3200 	ldr	r3, [pc, #512]	; 300213b8 <mem_malloc+0x3a4>
300211b4:	e5933000 	ldr	r3, [r3]
300211b8:	e1a02003 	mov	r2, r3
300211bc:	e59d3014 	ldr	r3, [sp, #20]
300211c0:	e1d330b0 	ldrh	r3, [r3]
300211c4:	e0823003 	add	r3, r2, r3
300211c8:	e1dd20be 	ldrh	r2, [sp, #14]
300211cc:	e1c320b2 	strh	r2, [r3, #2]
        }
#if MEM_STATS
        lwip_stats.mem.used += (size + SIZEOF_STRUCT_MEM);
300211d0:	e59f31e4 	ldr	r3, [pc, #484]	; 300213bc <mem_malloc+0x3a8>
300211d4:	e1d32bb8 	ldrh	r2, [r3, #184]	; 0xb8
300211d8:	e1dd30b6 	ldrh	r3, [sp, #6]
300211dc:	e0823003 	add	r3, r2, r3
300211e0:	e1a03803 	lsl	r3, r3, #16
300211e4:	e1a03823 	lsr	r3, r3, #16
300211e8:	e2833008 	add	r3, r3, #8
300211ec:	e1a03803 	lsl	r3, r3, #16
300211f0:	e1a02823 	lsr	r2, r3, #16
300211f4:	e59f31c0 	ldr	r3, [pc, #448]	; 300213bc <mem_malloc+0x3a8>
300211f8:	e1c32bb8 	strh	r2, [r3, #184]	; 0xb8
        if (lwip_stats.mem.max < lwip_stats.mem.used) {
300211fc:	e59f31b8 	ldr	r3, [pc, #440]	; 300213bc <mem_malloc+0x3a8>
30021200:	e1d32bba 	ldrh	r2, [r3, #186]	; 0xba
30021204:	e59f31b0 	ldr	r3, [pc, #432]	; 300213bc <mem_malloc+0x3a8>
30021208:	e1d33bb8 	ldrh	r3, [r3, #184]	; 0xb8
3002120c:	e1520003 	cmp	r2, r3
30021210:	2a000028 	bcs	300212b8 <mem_malloc+0x2a4>
          lwip_stats.mem.max = lwip_stats.mem.used;
30021214:	e59f31a0 	ldr	r3, [pc, #416]	; 300213bc <mem_malloc+0x3a8>
30021218:	e1d32bb8 	ldrh	r2, [r3, #184]	; 0xb8
3002121c:	e59f3198 	ldr	r3, [pc, #408]	; 300213bc <mem_malloc+0x3a8>
30021220:	e1c32bba 	strh	r2, [r3, #186]	; 0xba
30021224:	ea000024 	b	300212bc <mem_malloc+0x2a8>
         * take care of this).
         * -> near fit or excact fit: do not split, no mem2 creation
         * also can't move mem->next directly behind mem, since mem->next
         * will always be used at this point!
         */
        mem->used = 1;
30021228:	e59d3010 	ldr	r3, [sp, #16]
3002122c:	e3a02001 	mov	r2, #1
30021230:	e5c32004 	strb	r2, [r3, #4]
#if MEM_STATS
        lwip_stats.mem.used += mem->next - ((u8_t *)mem - ram);
30021234:	e59f3180 	ldr	r3, [pc, #384]	; 300213bc <mem_malloc+0x3a8>
30021238:	e1d32bb8 	ldrh	r2, [r3, #184]	; 0xb8
3002123c:	e59d3010 	ldr	r3, [sp, #16]
30021240:	e1d310b0 	ldrh	r1, [r3]
30021244:	e59f316c 	ldr	r3, [pc, #364]	; 300213b8 <mem_malloc+0x3a4>
30021248:	e5933000 	ldr	r3, [r3]
3002124c:	e1a03803 	lsl	r3, r3, #16
30021250:	e1a00823 	lsr	r0, r3, #16
30021254:	e59d3010 	ldr	r3, [sp, #16]
30021258:	e1a03803 	lsl	r3, r3, #16
3002125c:	e1a03823 	lsr	r3, r3, #16
30021260:	e0633000 	rsb	r3, r3, r0
30021264:	e1a03803 	lsl	r3, r3, #16
30021268:	e1a03823 	lsr	r3, r3, #16
3002126c:	e0813003 	add	r3, r1, r3
30021270:	e1a03803 	lsl	r3, r3, #16
30021274:	e1a03823 	lsr	r3, r3, #16
30021278:	e0823003 	add	r3, r2, r3
3002127c:	e1a03803 	lsl	r3, r3, #16
30021280:	e1a02823 	lsr	r2, r3, #16
30021284:	e59f3130 	ldr	r3, [pc, #304]	; 300213bc <mem_malloc+0x3a8>
30021288:	e1c32bb8 	strh	r2, [r3, #184]	; 0xb8
        if (lwip_stats.mem.max < lwip_stats.mem.used) {
3002128c:	e59f3128 	ldr	r3, [pc, #296]	; 300213bc <mem_malloc+0x3a8>
30021290:	e1d32bba 	ldrh	r2, [r3, #186]	; 0xba
30021294:	e59f3120 	ldr	r3, [pc, #288]	; 300213bc <mem_malloc+0x3a8>
30021298:	e1d33bb8 	ldrh	r3, [r3, #184]	; 0xb8
3002129c:	e1520003 	cmp	r2, r3
300212a0:	2a000005 	bcs	300212bc <mem_malloc+0x2a8>
          lwip_stats.mem.max = lwip_stats.mem.used;
300212a4:	e59f3110 	ldr	r3, [pc, #272]	; 300213bc <mem_malloc+0x3a8>
300212a8:	e1d32bb8 	ldrh	r2, [r3, #184]	; 0xb8
300212ac:	e59f3108 	ldr	r3, [pc, #264]	; 300213bc <mem_malloc+0x3a8>
300212b0:	e1c32bba 	strh	r2, [r3, #186]	; 0xba
300212b4:	ea000000 	b	300212bc <mem_malloc+0x2a8>
          ((struct mem *)&ram[mem2->next])->prev = ptr2;
        }
#if MEM_STATS
        lwip_stats.mem.used += (size + SIZEOF_STRUCT_MEM);
        if (lwip_stats.mem.max < lwip_stats.mem.used) {
          lwip_stats.mem.max = lwip_stats.mem.used;
300212b8:	e1a00000 	nop			; (mov r0, r0)
          lwip_stats.mem.max = lwip_stats.mem.used;
        }
#endif /* MEM_STATS */
      }

      if (mem == lfree) {
300212bc:	e59f30f0 	ldr	r3, [pc, #240]	; 300213b4 <mem_malloc+0x3a0>
300212c0:	e5933000 	ldr	r3, [r3]
300212c4:	e59d2010 	ldr	r2, [sp, #16]
300212c8:	e1520003 	cmp	r2, r3
300212cc:	1a000014 	bne	30021324 <mem_malloc+0x310>
        /* Find next free block after mem and update lowest free pointer */
        while (lfree->used && lfree != ram_end) {
300212d0:	ea000008 	b	300212f8 <mem_malloc+0x2e4>
          lfree = (struct mem *)&ram[lfree->next];
300212d4:	e59f30dc 	ldr	r3, [pc, #220]	; 300213b8 <mem_malloc+0x3a4>
300212d8:	e5933000 	ldr	r3, [r3]
300212dc:	e1a02003 	mov	r2, r3
300212e0:	e59f30cc 	ldr	r3, [pc, #204]	; 300213b4 <mem_malloc+0x3a0>
300212e4:	e5933000 	ldr	r3, [r3]
300212e8:	e1d330b0 	ldrh	r3, [r3]
300212ec:	e0822003 	add	r2, r2, r3
300212f0:	e59f30bc 	ldr	r3, [pc, #188]	; 300213b4 <mem_malloc+0x3a0>
300212f4:	e5832000 	str	r2, [r3]
#endif /* MEM_STATS */
      }

      if (mem == lfree) {
        /* Find next free block after mem and update lowest free pointer */
        while (lfree->used && lfree != ram_end) {
300212f8:	e59f30b4 	ldr	r3, [pc, #180]	; 300213b4 <mem_malloc+0x3a0>
300212fc:	e5933000 	ldr	r3, [r3]
30021300:	e5d33004 	ldrb	r3, [r3, #4]
30021304:	e3530000 	cmp	r3, #0
30021308:	0a000005 	beq	30021324 <mem_malloc+0x310>
3002130c:	e59f30a0 	ldr	r3, [pc, #160]	; 300213b4 <mem_malloc+0x3a0>
30021310:	e5932000 	ldr	r2, [r3]
30021314:	e59f30a4 	ldr	r3, [pc, #164]	; 300213c0 <mem_malloc+0x3ac>
30021318:	e5933000 	ldr	r3, [r3]
3002131c:	e1520003 	cmp	r2, r3
30021320:	1affffeb 	bne	300212d4 <mem_malloc+0x2c0>
          lfree = (struct mem *)&ram[lfree->next];
        }
        LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
      }
      sys_sem_signal(mem_sem);
30021324:	e59f3084 	ldr	r3, [pc, #132]	; 300213b0 <mem_malloc+0x39c>
30021328:	e5933000 	ldr	r3, [r3]
3002132c:	e1a00003 	mov	r0, r3
30021330:	ebffad7c 	bl	3000c928 <sys_sem_signal>
      LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
       (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
      LWIP_ASSERT("mem_malloc: sanity check alignment",
        (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

      return (u8_t *)mem + SIZEOF_STRUCT_MEM;
30021334:	e59d3010 	ldr	r3, [sp, #16]
30021338:	e2833008 	add	r3, r3, #8
3002133c:	ea000017 	b	300213a0 <mem_malloc+0x38c>

  /* Scan through the heap searching for a free block that is big enough,
   * beginning with the lowest free block.
   */
  for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
       ptr = ((struct mem *)&ram[ptr])->next) {
30021340:	e59f3070 	ldr	r3, [pc, #112]	; 300213b8 <mem_malloc+0x3a4>
30021344:	e5933000 	ldr	r3, [r3]
30021348:	e1a02003 	mov	r2, r3
3002134c:	e1dd30bc 	ldrh	r3, [sp, #12]
30021350:	e0823003 	add	r3, r2, r3
30021354:	e1d330b0 	ldrh	r3, [r3]
30021358:	e1cd30bc 	strh	r3, [sp, #12]
  sys_arch_sem_wait(mem_sem, 0);

  /* Scan through the heap searching for a free block that is big enough,
   * beginning with the lowest free block.
   */
  for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
3002135c:	e1dd20bc 	ldrh	r2, [sp, #12]
30021360:	e1dd30b6 	ldrh	r3, [sp, #6]
30021364:	e2633902 	rsb	r3, r3, #32768	; 0x8000
30021368:	e1520003 	cmp	r2, r3
3002136c:	baffff51 	blt	300210b8 <mem_malloc+0xa4>
      return (u8_t *)mem + SIZEOF_STRUCT_MEM;
    }
  }
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
#if MEM_STATS
  ++lwip_stats.mem.err;
30021370:	e59f3044 	ldr	r3, [pc, #68]	; 300213bc <mem_malloc+0x3a8>
30021374:	e1d33bbc 	ldrh	r3, [r3, #188]	; 0xbc
30021378:	e2833001 	add	r3, r3, #1
3002137c:	e1a03803 	lsl	r3, r3, #16
30021380:	e1a02823 	lsr	r2, r3, #16
30021384:	e59f3030 	ldr	r3, [pc, #48]	; 300213bc <mem_malloc+0x3a8>
30021388:	e1c32bbc 	strh	r2, [r3, #188]	; 0xbc
#endif /* MEM_STATS */
  sys_sem_signal(mem_sem);
3002138c:	e59f301c 	ldr	r3, [pc, #28]	; 300213b0 <mem_malloc+0x39c>
30021390:	e5933000 	ldr	r3, [r3]
30021394:	e1a00003 	mov	r0, r3
30021398:	ebffad62 	bl	3000c928 <sys_sem_signal>
  return NULL;
3002139c:	e3a03000 	mov	r3, #0
}
300213a0:	e1a00003 	mov	r0, r3
300213a4:	e28dd01c 	add	sp, sp, #28
300213a8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300213ac:	e12fff1e 	bx	lr
300213b0:	300e3bec 	.word	0x300e3bec
300213b4:	300e3be8 	.word	0x300e3be8
300213b8:	300e3be0 	.word	0x300e3be0
300213bc:	302be570 	.word	0x302be570
300213c0:	300e3be4 	.word	0x300e3be4

300213c4 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
300213c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300213c8:	e24dd014 	sub	sp, sp, #20
300213cc:	e1a02000 	mov	r2, r0
300213d0:	e1a03001 	mov	r3, r1
300213d4:	e1cd20b6 	strh	r2, [sp, #6]
300213d8:	e1cd30b4 	strh	r3, [sp, #4]
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
300213dc:	e1dd30b6 	ldrh	r3, [sp, #6]
300213e0:	e1dd20b4 	ldrh	r2, [sp, #4]
300213e4:	e0030392 	mul	r3, r2, r3
300213e8:	e1a03803 	lsl	r3, r3, #16
300213ec:	e1a03823 	lsr	r3, r3, #16
300213f0:	e1a00003 	mov	r0, r3
300213f4:	ebffff06 	bl	30021014 <mem_malloc>
300213f8:	e1a03000 	mov	r3, r0
300213fc:	e58d300c 	str	r3, [sp, #12]
  if (p) {
30021400:	e59d300c 	ldr	r3, [sp, #12]
30021404:	e3530000 	cmp	r3, #0
30021408:	0a000006 	beq	30021428 <mem_calloc+0x64>
    /* zero the memory */
    memset(p, 0, count * size);
3002140c:	e1dd30b6 	ldrh	r3, [sp, #6]
30021410:	e1dd20b4 	ldrh	r2, [sp, #4]
30021414:	e0030392 	mul	r3, r2, r3
30021418:	e59d000c 	ldr	r0, [sp, #12]
3002141c:	e3a01000 	mov	r1, #0
30021420:	e1a02003 	mov	r2, r3
30021424:	ebffab90 	bl	3000c26c <acoral_memset>
  }
  return p;
30021428:	e59d300c 	ldr	r3, [sp, #12]
}
3002142c:	e1a00003 	mov	r0, r3
30021430:	e28dd014 	add	sp, sp, #20
30021434:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30021438:	e12fff1e 	bx	lr

3002143c <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
3002143c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30021440:	e24dd014 	sub	sp, sp, #20
30021444:	e58d0004 	str	r0, [sp, #4]
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
30021448:	ea00000b 	b	3002147c <free_etharp_q+0x40>
    r = q;
3002144c:	e59d3004 	ldr	r3, [sp, #4]
30021450:	e58d300c 	str	r3, [sp, #12]
    q = q->next;
30021454:	e59d3004 	ldr	r3, [sp, #4]
30021458:	e5933000 	ldr	r3, [r3]
3002145c:	e58d3004 	str	r3, [sp, #4]
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
30021460:	e59d300c 	ldr	r3, [sp, #12]
30021464:	e5933004 	ldr	r3, [r3, #4]
30021468:	e1a00003 	mov	r0, r3
3002146c:	ebffd383 	bl	30016280 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
30021470:	e3a00009 	mov	r0, #9
30021474:	e59d100c 	ldr	r1, [sp, #12]
30021478:	ebffd012 	bl	300154c8 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
3002147c:	e59d3004 	ldr	r3, [sp, #4]
30021480:	e3530000 	cmp	r3, #0
30021484:	1afffff0 	bne	3002144c <free_etharp_q+0x10>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
30021488:	e28dd014 	add	sp, sp, #20
3002148c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30021490:	e12fff1e 	bx	lr

30021494 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
30021494:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30021498:	e24dd00c 	sub	sp, sp, #12
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
3002149c:	e3a03000 	mov	r3, #0
300214a0:	e5cd3007 	strb	r3, [sp, #7]
300214a4:	ea000070 	b	3002166c <etharp_tmr+0x1d8>
    arp_table[i].ctime++;
300214a8:	e5dd2007 	ldrb	r2, [sp, #7]
300214ac:	e59f01d0 	ldr	r0, [pc, #464]	; 30021684 <etharp_tmr+0x1f0>
300214b0:	e3a01008 	mov	r1, #8
300214b4:	e1a03002 	mov	r3, r2
300214b8:	e1a03103 	lsl	r3, r3, #2
300214bc:	e0833002 	add	r3, r3, r2
300214c0:	e1a03103 	lsl	r3, r3, #2
300214c4:	e0833000 	add	r3, r3, r0
300214c8:	e0833001 	add	r3, r3, r1
300214cc:	e5d33007 	ldrb	r3, [r3, #7]
300214d0:	e2833001 	add	r3, r3, #1
300214d4:	e20310ff 	and	r1, r3, #255	; 0xff
300214d8:	e59fc1a4 	ldr	ip, [pc, #420]	; 30021684 <etharp_tmr+0x1f0>
300214dc:	e3a00008 	mov	r0, #8
300214e0:	e1a03002 	mov	r3, r2
300214e4:	e1a03103 	lsl	r3, r3, #2
300214e8:	e0833002 	add	r3, r3, r2
300214ec:	e1a03103 	lsl	r3, r3, #2
300214f0:	e083300c 	add	r3, r3, ip
300214f4:	e0833000 	add	r3, r3, r0
300214f8:	e1a02001 	mov	r2, r1
300214fc:	e5c32007 	strb	r2, [r3, #7]
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
30021500:	e5dd2007 	ldrb	r2, [sp, #7]
30021504:	e59f0178 	ldr	r0, [pc, #376]	; 30021684 <etharp_tmr+0x1f0>
30021508:	e3a01008 	mov	r1, #8
3002150c:	e1a03002 	mov	r3, r2
30021510:	e1a03103 	lsl	r3, r3, #2
30021514:	e0833002 	add	r3, r3, r2
30021518:	e1a03103 	lsl	r3, r3, #2
3002151c:	e0833000 	add	r3, r3, r0
30021520:	e0833001 	add	r3, r3, r1
30021524:	e5d33006 	ldrb	r3, [r3, #6]
30021528:	e3530002 	cmp	r3, #2
3002152c:	1a00000b 	bne	30021560 <etharp_tmr+0xcc>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
30021530:	e5dd2007 	ldrb	r2, [sp, #7]
30021534:	e59f0148 	ldr	r0, [pc, #328]	; 30021684 <etharp_tmr+0x1f0>
30021538:	e3a01008 	mov	r1, #8
3002153c:	e1a03002 	mov	r3, r2
30021540:	e1a03103 	lsl	r3, r3, #2
30021544:	e0833002 	add	r3, r3, r2
30021548:	e1a03103 	lsl	r3, r3, #2
3002154c:	e0833000 	add	r3, r3, r0
30021550:	e0833001 	add	r3, r3, r1
30021554:	e5d33007 	ldrb	r3, [r3, #7]

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
30021558:	e35300ef 	cmp	r3, #239	; 0xef
3002155c:	8a000017 	bhi	300215c0 <etharp_tmr+0x12c>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
30021560:	e5dd2007 	ldrb	r2, [sp, #7]
30021564:	e59f0118 	ldr	r0, [pc, #280]	; 30021684 <etharp_tmr+0x1f0>
30021568:	e3a01008 	mov	r1, #8
3002156c:	e1a03002 	mov	r3, r2
30021570:	e1a03103 	lsl	r3, r3, #2
30021574:	e0833002 	add	r3, r3, r2
30021578:	e1a03103 	lsl	r3, r3, #2
3002157c:	e0833000 	add	r3, r3, r0
30021580:	e0833001 	add	r3, r3, r1
30021584:	e5d33006 	ldrb	r3, [r3, #6]

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
30021588:	e3530001 	cmp	r3, #1
3002158c:	1a000033 	bne	30021660 <etharp_tmr+0x1cc>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
         (arp_table[i].ctime >= ARP_MAXPENDING))) {
30021590:	e5dd2007 	ldrb	r2, [sp, #7]
30021594:	e59f00e8 	ldr	r0, [pc, #232]	; 30021684 <etharp_tmr+0x1f0>
30021598:	e3a01008 	mov	r1, #8
3002159c:	e1a03002 	mov	r3, r2
300215a0:	e1a03103 	lsl	r3, r3, #2
300215a4:	e0833002 	add	r3, r3, r2
300215a8:	e1a03103 	lsl	r3, r3, #2
300215ac:	e0833000 	add	r3, r3, r0
300215b0:	e0833001 	add	r3, r3, r1
300215b4:	e5d33007 	ldrb	r3, [r3, #7]

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
300215b8:	e3530001 	cmp	r3, #1
300215bc:	9a000027 	bls	30021660 <etharp_tmr+0x1cc>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
300215c0:	e5dd2007 	ldrb	r2, [sp, #7]
300215c4:	e59f10b8 	ldr	r1, [pc, #184]	; 30021684 <etharp_tmr+0x1f0>
300215c8:	e1a03002 	mov	r3, r2
300215cc:	e1a03103 	lsl	r3, r3, #2
300215d0:	e0833002 	add	r3, r3, r2
300215d4:	e1a03103 	lsl	r3, r3, #2
300215d8:	e0833001 	add	r3, r3, r1
300215dc:	e5933000 	ldr	r3, [r3]
300215e0:	e3530000 	cmp	r3, #0
300215e4:	0a000012 	beq	30021634 <etharp_tmr+0x1a0>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
300215e8:	e5dd2007 	ldrb	r2, [sp, #7]
300215ec:	e59f1090 	ldr	r1, [pc, #144]	; 30021684 <etharp_tmr+0x1f0>
300215f0:	e1a03002 	mov	r3, r2
300215f4:	e1a03103 	lsl	r3, r3, #2
300215f8:	e0833002 	add	r3, r3, r2
300215fc:	e1a03103 	lsl	r3, r3, #2
30021600:	e0833001 	add	r3, r3, r1
30021604:	e5933000 	ldr	r3, [r3]
30021608:	e1a00003 	mov	r0, r3
3002160c:	ebffff8a 	bl	3002143c <free_etharp_q>
        arp_table[i].q = NULL;
30021610:	e5dd2007 	ldrb	r2, [sp, #7]
30021614:	e59f1068 	ldr	r1, [pc, #104]	; 30021684 <etharp_tmr+0x1f0>
30021618:	e1a03002 	mov	r3, r2
3002161c:	e1a03103 	lsl	r3, r3, #2
30021620:	e0833002 	add	r3, r3, r2
30021624:	e1a03103 	lsl	r3, r3, #2
30021628:	e0833001 	add	r3, r3, r1
3002162c:	e3a02000 	mov	r2, #0
30021630:	e5832000 	str	r2, [r3]
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
30021634:	e5dd2007 	ldrb	r2, [sp, #7]
30021638:	e59f0044 	ldr	r0, [pc, #68]	; 30021684 <etharp_tmr+0x1f0>
3002163c:	e3a01008 	mov	r1, #8
30021640:	e1a03002 	mov	r3, r2
30021644:	e1a03103 	lsl	r3, r3, #2
30021648:	e0833002 	add	r3, r3, r2
3002164c:	e1a03103 	lsl	r3, r3, #2
30021650:	e0833000 	add	r3, r3, r0
30021654:	e0833001 	add	r3, r3, r1
30021658:	e3a02000 	mov	r2, #0
3002165c:	e5c32006 	strb	r2, [r3, #6]
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
30021660:	e5dd3007 	ldrb	r3, [sp, #7]
30021664:	e2833001 	add	r3, r3, #1
30021668:	e5cd3007 	strb	r3, [sp, #7]
3002166c:	e5dd3007 	ldrb	r3, [sp, #7]
30021670:	e3530009 	cmp	r3, #9
30021674:	9affff8b 	bls	300214a8 <etharp_tmr+0x14>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
30021678:	e28dd00c 	add	sp, sp, #12
3002167c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30021680:	e12fff1e 	bx	lr
30021684:	300e3bf0 	.word	0x300e3bf0

30021688 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
30021688:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002168c:	e24dd014 	sub	sp, sp, #20
30021690:	e58d0004 	str	r0, [sp, #4]
30021694:	e1a03001 	mov	r3, r1
30021698:	e5cd3003 	strb	r3, [sp, #3]
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
3002169c:	e3a0300a 	mov	r3, #10
300216a0:	e5cd3008 	strb	r3, [sp, #8]
300216a4:	e3a0300a 	mov	r3, #10
300216a8:	e5cd3009 	strb	r3, [sp, #9]
  s8_t empty = ARP_TABLE_SIZE;
300216ac:	e3a0300a 	mov	r3, #10
300216b0:	e5cd300a 	strb	r3, [sp, #10]
  u8_t i = 0, age_pending = 0, age_stable = 0;
300216b4:	e3a03000 	mov	r3, #0
300216b8:	e5cd300b 	strb	r3, [sp, #11]
300216bc:	e3a03000 	mov	r3, #0
300216c0:	e5cd300c 	strb	r3, [sp, #12]
300216c4:	e3a03000 	mov	r3, #0
300216c8:	e5cd300d 	strb	r3, [sp, #13]
#if ARP_QUEUEING
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
300216cc:	e3a0300a 	mov	r3, #10
300216d0:	e5cd300e 	strb	r3, [sp, #14]
  /* its age */
  u8_t age_queue = 0;
300216d4:	e3a03000 	mov	r3, #0
300216d8:	e5cd300f 	strb	r3, [sp, #15]
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
300216dc:	e59d3004 	ldr	r3, [sp, #4]
300216e0:	e3530000 	cmp	r3, #0
300216e4:	0a000031 	beq	300217b0 <find_entry+0x128>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
300216e8:	e59f35e4 	ldr	r3, [pc, #1508]	; 30021cd4 <find_entry+0x64c>
300216ec:	e5d33000 	ldrb	r3, [r3]
300216f0:	e1a02003 	mov	r2, r3
300216f4:	e59f05dc 	ldr	r0, [pc, #1500]	; 30021cd8 <find_entry+0x650>
300216f8:	e3a01008 	mov	r1, #8
300216fc:	e1a03002 	mov	r3, r2
30021700:	e1a03103 	lsl	r3, r3, #2
30021704:	e0833002 	add	r3, r3, r2
30021708:	e1a03103 	lsl	r3, r3, #2
3002170c:	e0833000 	add	r3, r3, r0
30021710:	e0833001 	add	r3, r3, r1
30021714:	e5d33006 	ldrb	r3, [r3, #6]
30021718:	e3530002 	cmp	r3, #2
3002171c:	1a000023 	bne	300217b0 <find_entry+0x128>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
30021720:	e59d3004 	ldr	r3, [sp, #4]
30021724:	e5d32000 	ldrb	r2, [r3]
30021728:	e5d31001 	ldrb	r1, [r3, #1]
3002172c:	e1a01401 	lsl	r1, r1, #8
30021730:	e1812002 	orr	r2, r1, r2
30021734:	e5d31002 	ldrb	r1, [r3, #2]
30021738:	e1a01801 	lsl	r1, r1, #16
3002173c:	e1812002 	orr	r2, r1, r2
30021740:	e5d33003 	ldrb	r3, [r3, #3]
30021744:	e1a03c03 	lsl	r3, r3, #24
30021748:	e1833002 	orr	r3, r3, r2
3002174c:	e1a01003 	mov	r1, r3
30021750:	e59f357c 	ldr	r3, [pc, #1404]	; 30021cd4 <find_entry+0x64c>
30021754:	e5d33000 	ldrb	r3, [r3]
30021758:	e1a02003 	mov	r2, r3
3002175c:	e59fc574 	ldr	ip, [pc, #1396]	; 30021cd8 <find_entry+0x650>
30021760:	e3a00004 	mov	r0, #4
30021764:	e1a03002 	mov	r3, r2
30021768:	e1a03103 	lsl	r3, r3, #2
3002176c:	e0833002 	add	r3, r3, r2
30021770:	e1a03103 	lsl	r3, r3, #2
30021774:	e083300c 	add	r3, r3, ip
30021778:	e0833000 	add	r3, r3, r0
3002177c:	e5933000 	ldr	r3, [r3]
30021780:	e1510003 	cmp	r1, r3
30021784:	1a000009 	bne	300217b0 <find_entry+0x128>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
30021788:	e59f354c 	ldr	r3, [pc, #1356]	; 30021cdc <find_entry+0x654>
3002178c:	e1d333b2 	ldrh	r3, [r3, #50]	; 0x32
30021790:	e2833001 	add	r3, r3, #1
30021794:	e1a03803 	lsl	r3, r3, #16
30021798:	e1a02823 	lsr	r2, r3, #16
3002179c:	e59f3538 	ldr	r3, [pc, #1336]	; 30021cdc <find_entry+0x654>
300217a0:	e1c323b2 	strh	r2, [r3, #50]	; 0x32
        return etharp_cached_entry;
300217a4:	e59f3528 	ldr	r3, [pc, #1320]	; 30021cd4 <find_entry+0x64c>
300217a8:	e5d33000 	ldrb	r3, [r3]
300217ac:	ea000142 	b	30021cbc <find_entry+0x634>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
300217b0:	e3a03000 	mov	r3, #0
300217b4:	e5cd300b 	strb	r3, [sp, #11]
300217b8:	ea0000ca 	b	30021ae8 <find_entry+0x460>
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
300217bc:	e1dd30da 	ldrsb	r3, [sp, #10]
300217c0:	e353000a 	cmp	r3, #10
300217c4:	1a00000e 	bne	30021804 <find_entry+0x17c>
300217c8:	e5dd200b 	ldrb	r2, [sp, #11]
300217cc:	e59f0504 	ldr	r0, [pc, #1284]	; 30021cd8 <find_entry+0x650>
300217d0:	e3a01008 	mov	r1, #8
300217d4:	e1a03002 	mov	r3, r2
300217d8:	e1a03103 	lsl	r3, r3, #2
300217dc:	e0833002 	add	r3, r3, r2
300217e0:	e1a03103 	lsl	r3, r3, #2
300217e4:	e0833000 	add	r3, r3, r0
300217e8:	e0833001 	add	r3, r3, r1
300217ec:	e5d33006 	ldrb	r3, [r3, #6]
300217f0:	e3530000 	cmp	r3, #0
300217f4:	1a000002 	bne	30021804 <find_entry+0x17c>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
300217f8:	e5dd300b 	ldrb	r3, [sp, #11]
300217fc:	e5cd300a 	strb	r3, [sp, #10]
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
30021800:	ea0000b5 	b	30021adc <find_entry+0x454>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
30021804:	e5dd200b 	ldrb	r2, [sp, #11]
30021808:	e59f04c8 	ldr	r0, [pc, #1224]	; 30021cd8 <find_entry+0x650>
3002180c:	e3a01008 	mov	r1, #8
30021810:	e1a03002 	mov	r3, r2
30021814:	e1a03103 	lsl	r3, r3, #2
30021818:	e0833002 	add	r3, r3, r2
3002181c:	e1a03103 	lsl	r3, r3, #2
30021820:	e0833000 	add	r3, r3, r0
30021824:	e0833001 	add	r3, r3, r1
30021828:	e5d33006 	ldrb	r3, [r3, #6]
3002182c:	e3530001 	cmp	r3, #1
30021830:	1a00005f 	bne	300219b4 <find_entry+0x32c>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
30021834:	e59d3004 	ldr	r3, [sp, #4]
30021838:	e3530000 	cmp	r3, #0
3002183c:	0a00001c 	beq	300218b4 <find_entry+0x22c>
30021840:	e59d3004 	ldr	r3, [sp, #4]
30021844:	e5d32000 	ldrb	r2, [r3]
30021848:	e5d31001 	ldrb	r1, [r3, #1]
3002184c:	e1a01401 	lsl	r1, r1, #8
30021850:	e1812002 	orr	r2, r1, r2
30021854:	e5d31002 	ldrb	r1, [r3, #2]
30021858:	e1a01801 	lsl	r1, r1, #16
3002185c:	e1812002 	orr	r2, r1, r2
30021860:	e5d33003 	ldrb	r3, [r3, #3]
30021864:	e1a03c03 	lsl	r3, r3, #24
30021868:	e1833002 	orr	r3, r3, r2
3002186c:	e1a01003 	mov	r1, r3
30021870:	e5dd200b 	ldrb	r2, [sp, #11]
30021874:	e59fc45c 	ldr	ip, [pc, #1116]	; 30021cd8 <find_entry+0x650>
30021878:	e3a00004 	mov	r0, #4
3002187c:	e1a03002 	mov	r3, r2
30021880:	e1a03103 	lsl	r3, r3, #2
30021884:	e0833002 	add	r3, r3, r2
30021888:	e1a03103 	lsl	r3, r3, #2
3002188c:	e083300c 	add	r3, r3, ip
30021890:	e0833000 	add	r3, r3, r0
30021894:	e5933000 	ldr	r3, [r3]
30021898:	e1510003 	cmp	r1, r3
3002189c:	1a000004 	bne	300218b4 <find_entry+0x22c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
300218a0:	e59f342c 	ldr	r3, [pc, #1068]	; 30021cd4 <find_entry+0x64c>
300218a4:	e5dd200b 	ldrb	r2, [sp, #11]
300218a8:	e5c32000 	strb	r2, [r3]
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
300218ac:	e5dd300b 	ldrb	r3, [sp, #11]
300218b0:	ea000101 	b	30021cbc <find_entry+0x634>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
300218b4:	e5dd200b 	ldrb	r2, [sp, #11]
300218b8:	e59f1418 	ldr	r1, [pc, #1048]	; 30021cd8 <find_entry+0x650>
300218bc:	e1a03002 	mov	r3, r2
300218c0:	e1a03103 	lsl	r3, r3, #2
300218c4:	e0833002 	add	r3, r3, r2
300218c8:	e1a03103 	lsl	r3, r3, #2
300218cc:	e0833001 	add	r3, r3, r1
300218d0:	e5933000 	ldr	r3, [r3]
300218d4:	e3530000 	cmp	r3, #0
300218d8:	0a00001a 	beq	30021948 <find_entry+0x2c0>
        if (arp_table[i].ctime >= age_queue) {
300218dc:	e5dd200b 	ldrb	r2, [sp, #11]
300218e0:	e59f03f0 	ldr	r0, [pc, #1008]	; 30021cd8 <find_entry+0x650>
300218e4:	e3a01008 	mov	r1, #8
300218e8:	e1a03002 	mov	r3, r2
300218ec:	e1a03103 	lsl	r3, r3, #2
300218f0:	e0833002 	add	r3, r3, r2
300218f4:	e1a03103 	lsl	r3, r3, #2
300218f8:	e0833000 	add	r3, r3, r0
300218fc:	e0833001 	add	r3, r3, r1
30021900:	e5d33007 	ldrb	r3, [r3, #7]
30021904:	e5dd200f 	ldrb	r2, [sp, #15]
30021908:	e1520003 	cmp	r2, r3
3002190c:	8a00006f 	bhi	30021ad0 <find_entry+0x448>
          old_queue = i;
30021910:	e5dd300b 	ldrb	r3, [sp, #11]
30021914:	e5cd300e 	strb	r3, [sp, #14]
          age_queue = arp_table[i].ctime;
30021918:	e5dd200b 	ldrb	r2, [sp, #11]
3002191c:	e59f03b4 	ldr	r0, [pc, #948]	; 30021cd8 <find_entry+0x650>
30021920:	e3a01008 	mov	r1, #8
30021924:	e1a03002 	mov	r3, r2
30021928:	e1a03103 	lsl	r3, r3, #2
3002192c:	e0833002 	add	r3, r3, r2
30021930:	e1a03103 	lsl	r3, r3, #2
30021934:	e0833000 	add	r3, r3, r0
30021938:	e0833001 	add	r3, r3, r1
3002193c:	e5d33007 	ldrb	r3, [r3, #7]
30021940:	e5cd300f 	strb	r3, [sp, #15]
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
          old_pending = i;
          age_pending = arp_table[i].ctime;
30021944:	ea000064 	b	30021adc <find_entry+0x454>
          age_queue = arp_table[i].ctime;
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
30021948:	e5dd200b 	ldrb	r2, [sp, #11]
3002194c:	e59f0384 	ldr	r0, [pc, #900]	; 30021cd8 <find_entry+0x650>
30021950:	e3a01008 	mov	r1, #8
30021954:	e1a03002 	mov	r3, r2
30021958:	e1a03103 	lsl	r3, r3, #2
3002195c:	e0833002 	add	r3, r3, r2
30021960:	e1a03103 	lsl	r3, r3, #2
30021964:	e0833000 	add	r3, r3, r0
30021968:	e0833001 	add	r3, r3, r1
3002196c:	e5d33007 	ldrb	r3, [r3, #7]
30021970:	e5dd200c 	ldrb	r2, [sp, #12]
30021974:	e1520003 	cmp	r2, r3
30021978:	8a000056 	bhi	30021ad8 <find_entry+0x450>
          old_pending = i;
3002197c:	e5dd300b 	ldrb	r3, [sp, #11]
30021980:	e5cd3008 	strb	r3, [sp, #8]
          age_pending = arp_table[i].ctime;
30021984:	e5dd200b 	ldrb	r2, [sp, #11]
30021988:	e59f0348 	ldr	r0, [pc, #840]	; 30021cd8 <find_entry+0x650>
3002198c:	e3a01008 	mov	r1, #8
30021990:	e1a03002 	mov	r3, r2
30021994:	e1a03103 	lsl	r3, r3, #2
30021998:	e0833002 	add	r3, r3, r2
3002199c:	e1a03103 	lsl	r3, r3, #2
300219a0:	e0833000 	add	r3, r3, r0
300219a4:	e0833001 	add	r3, r3, r1
300219a8:	e5d33007 	ldrb	r3, [r3, #7]
300219ac:	e5cd300c 	strb	r3, [sp, #12]
300219b0:	ea000049 	b	30021adc <find_entry+0x454>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
300219b4:	e5dd200b 	ldrb	r2, [sp, #11]
300219b8:	e59f0318 	ldr	r0, [pc, #792]	; 30021cd8 <find_entry+0x650>
300219bc:	e3a01008 	mov	r1, #8
300219c0:	e1a03002 	mov	r3, r2
300219c4:	e1a03103 	lsl	r3, r3, #2
300219c8:	e0833002 	add	r3, r3, r2
300219cc:	e1a03103 	lsl	r3, r3, #2
300219d0:	e0833000 	add	r3, r3, r0
300219d4:	e0833001 	add	r3, r3, r1
300219d8:	e5d33006 	ldrb	r3, [r3, #6]
300219dc:	e3530002 	cmp	r3, #2
300219e0:	1a00003d 	bne	30021adc <find_entry+0x454>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
300219e4:	e59d3004 	ldr	r3, [sp, #4]
300219e8:	e3530000 	cmp	r3, #0
300219ec:	0a00001c 	beq	30021a64 <find_entry+0x3dc>
300219f0:	e59d3004 	ldr	r3, [sp, #4]
300219f4:	e5d32000 	ldrb	r2, [r3]
300219f8:	e5d31001 	ldrb	r1, [r3, #1]
300219fc:	e1a01401 	lsl	r1, r1, #8
30021a00:	e1812002 	orr	r2, r1, r2
30021a04:	e5d31002 	ldrb	r1, [r3, #2]
30021a08:	e1a01801 	lsl	r1, r1, #16
30021a0c:	e1812002 	orr	r2, r1, r2
30021a10:	e5d33003 	ldrb	r3, [r3, #3]
30021a14:	e1a03c03 	lsl	r3, r3, #24
30021a18:	e1833002 	orr	r3, r3, r2
30021a1c:	e1a01003 	mov	r1, r3
30021a20:	e5dd200b 	ldrb	r2, [sp, #11]
30021a24:	e59fc2ac 	ldr	ip, [pc, #684]	; 30021cd8 <find_entry+0x650>
30021a28:	e3a00004 	mov	r0, #4
30021a2c:	e1a03002 	mov	r3, r2
30021a30:	e1a03103 	lsl	r3, r3, #2
30021a34:	e0833002 	add	r3, r3, r2
30021a38:	e1a03103 	lsl	r3, r3, #2
30021a3c:	e083300c 	add	r3, r3, ip
30021a40:	e0833000 	add	r3, r3, r0
30021a44:	e5933000 	ldr	r3, [r3]
30021a48:	e1510003 	cmp	r1, r3
30021a4c:	1a000004 	bne	30021a64 <find_entry+0x3dc>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
30021a50:	e59f327c 	ldr	r3, [pc, #636]	; 30021cd4 <find_entry+0x64c>
30021a54:	e5dd200b 	ldrb	r2, [sp, #11]
30021a58:	e5c32000 	strb	r2, [r3]
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
30021a5c:	e5dd300b 	ldrb	r3, [sp, #11]
30021a60:	ea000095 	b	30021cbc <find_entry+0x634>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
30021a64:	e5dd200b 	ldrb	r2, [sp, #11]
30021a68:	e59f0268 	ldr	r0, [pc, #616]	; 30021cd8 <find_entry+0x650>
30021a6c:	e3a01008 	mov	r1, #8
30021a70:	e1a03002 	mov	r3, r2
30021a74:	e1a03103 	lsl	r3, r3, #2
30021a78:	e0833002 	add	r3, r3, r2
30021a7c:	e1a03103 	lsl	r3, r3, #2
30021a80:	e0833000 	add	r3, r3, r0
30021a84:	e0833001 	add	r3, r3, r1
30021a88:	e5d33007 	ldrb	r3, [r3, #7]
30021a8c:	e5dd200d 	ldrb	r2, [sp, #13]
30021a90:	e1520003 	cmp	r2, r3
30021a94:	8a000010 	bhi	30021adc <find_entry+0x454>
        old_stable = i;
30021a98:	e5dd300b 	ldrb	r3, [sp, #11]
30021a9c:	e5cd3009 	strb	r3, [sp, #9]
        age_stable = arp_table[i].ctime;
30021aa0:	e5dd200b 	ldrb	r2, [sp, #11]
30021aa4:	e59f022c 	ldr	r0, [pc, #556]	; 30021cd8 <find_entry+0x650>
30021aa8:	e3a01008 	mov	r1, #8
30021aac:	e1a03002 	mov	r3, r2
30021ab0:	e1a03103 	lsl	r3, r3, #2
30021ab4:	e0833002 	add	r3, r3, r2
30021ab8:	e1a03103 	lsl	r3, r3, #2
30021abc:	e0833000 	add	r3, r3, r0
30021ac0:	e0833001 	add	r3, r3, r1
30021ac4:	e5d33007 	ldrb	r3, [r3, #7]
30021ac8:	e5cd300d 	strb	r3, [sp, #13]
30021acc:	ea000002 	b	30021adc <find_entry+0x454>
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
          old_pending = i;
          age_pending = arp_table[i].ctime;
30021ad0:	e1a00000 	nop			; (mov r0, r0)
30021ad4:	ea000000 	b	30021adc <find_entry+0x454>
30021ad8:	e1a00000 	nop			; (mov r0, r0)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
30021adc:	e5dd300b 	ldrb	r3, [sp, #11]
30021ae0:	e2833001 	add	r3, r3, #1
30021ae4:	e5cd300b 	strb	r3, [sp, #11]
30021ae8:	e5dd300b 	ldrb	r3, [sp, #11]
30021aec:	e3530009 	cmp	r3, #9
30021af0:	9affff31 	bls	300217bc <find_entry+0x134>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
30021af4:	e1dd30da 	ldrsb	r3, [sp, #10]
30021af8:	e353000a 	cmp	r3, #10
30021afc:	1a000003 	bne	30021b10 <find_entry+0x488>
30021b00:	e5dd3003 	ldrb	r3, [sp, #3]
30021b04:	e2033001 	and	r3, r3, #1
30021b08:	e3530000 	cmp	r3, #0
30021b0c:	0a000003 	beq	30021b20 <find_entry+0x498>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
30021b10:	e5dd3003 	ldrb	r3, [sp, #3]
30021b14:	e2033002 	and	r3, r3, #2
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
30021b18:	e3530000 	cmp	r3, #0
30021b1c:	0a000001 	beq	30021b28 <find_entry+0x4a0>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
30021b20:	e3a030ff 	mov	r3, #255	; 0xff
30021b24:	ea000064 	b	30021cbc <find_entry+0x634>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
30021b28:	e1dd30da 	ldrsb	r3, [sp, #10]
30021b2c:	e3530009 	cmp	r3, #9
30021b30:	ca000002 	bgt	30021b40 <find_entry+0x4b8>
    i = empty;
30021b34:	e5dd300a 	ldrb	r3, [sp, #10]
30021b38:	e5cd300b 	strb	r3, [sp, #11]
30021b3c:	ea000026 	b	30021bdc <find_entry+0x554>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
30021b40:	e1dd30d9 	ldrsb	r3, [sp, #9]
30021b44:	e3530009 	cmp	r3, #9
30021b48:	ca000002 	bgt	30021b58 <find_entry+0x4d0>
    /* recycle oldest stable*/
    i = old_stable;
30021b4c:	e5dd3009 	ldrb	r3, [sp, #9]
30021b50:	e5cd300b 	strb	r3, [sp, #11]
30021b54:	ea000020 	b	30021bdc <find_entry+0x554>
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
30021b58:	e1dd30d8 	ldrsb	r3, [sp, #8]
30021b5c:	e3530009 	cmp	r3, #9
30021b60:	ca000002 	bgt	30021b70 <find_entry+0x4e8>
    /* recycle oldest pending */
    i = old_pending;
30021b64:	e5dd3008 	ldrb	r3, [sp, #8]
30021b68:	e5cd300b 	strb	r3, [sp, #11]
30021b6c:	ea00001a 	b	30021bdc <find_entry+0x554>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
30021b70:	e1dd30de 	ldrsb	r3, [sp, #14]
30021b74:	e3530009 	cmp	r3, #9
30021b78:	ca000015 	bgt	30021bd4 <find_entry+0x54c>
    /* recycle oldest pending */
    i = old_queue;
30021b7c:	e5dd300e 	ldrb	r3, [sp, #14]
30021b80:	e5cd300b 	strb	r3, [sp, #11]
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
30021b84:	e5dd200b 	ldrb	r2, [sp, #11]
30021b88:	e59f1148 	ldr	r1, [pc, #328]	; 30021cd8 <find_entry+0x650>
30021b8c:	e1a03002 	mov	r3, r2
30021b90:	e1a03103 	lsl	r3, r3, #2
30021b94:	e0833002 	add	r3, r3, r2
30021b98:	e1a03103 	lsl	r3, r3, #2
30021b9c:	e0833001 	add	r3, r3, r1
30021ba0:	e5933000 	ldr	r3, [r3]
30021ba4:	e1a00003 	mov	r0, r3
30021ba8:	ebfffe23 	bl	3002143c <free_etharp_q>
    arp_table[i].q = NULL;
30021bac:	e5dd200b 	ldrb	r2, [sp, #11]
30021bb0:	e59f1120 	ldr	r1, [pc, #288]	; 30021cd8 <find_entry+0x650>
30021bb4:	e1a03002 	mov	r3, r2
30021bb8:	e1a03103 	lsl	r3, r3, #2
30021bbc:	e0833002 	add	r3, r3, r2
30021bc0:	e1a03103 	lsl	r3, r3, #2
30021bc4:	e0833001 	add	r3, r3, r1
30021bc8:	e3a02000 	mov	r2, #0
30021bcc:	e5832000 	str	r2, [r3]
30021bd0:	ea000001 	b	30021bdc <find_entry+0x554>
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
30021bd4:	e3a030ff 	mov	r3, #255	; 0xff
30021bd8:	ea000037 	b	30021cbc <find_entry+0x634>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
30021bdc:	e5dd200b 	ldrb	r2, [sp, #11]
30021be0:	e59f00f0 	ldr	r0, [pc, #240]	; 30021cd8 <find_entry+0x650>
30021be4:	e3a01008 	mov	r1, #8
30021be8:	e1a03002 	mov	r3, r2
30021bec:	e1a03103 	lsl	r3, r3, #2
30021bf0:	e0833002 	add	r3, r3, r2
30021bf4:	e1a03103 	lsl	r3, r3, #2
30021bf8:	e0833000 	add	r3, r3, r0
30021bfc:	e0833001 	add	r3, r3, r1
30021c00:	e3a02000 	mov	r2, #0
30021c04:	e5c32006 	strb	r2, [r3, #6]

  /* IP address given? */
  if (ipaddr != NULL) {
30021c08:	e59d3004 	ldr	r3, [sp, #4]
30021c0c:	e3530000 	cmp	r3, #0
30021c10:	0a00001a 	beq	30021c80 <find_entry+0x5f8>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
30021c14:	e5dd100b 	ldrb	r1, [sp, #11]
30021c18:	e59d3004 	ldr	r3, [sp, #4]
30021c1c:	e3530000 	cmp	r3, #0
30021c20:	0a00000c 	beq	30021c58 <find_entry+0x5d0>
30021c24:	e59d3004 	ldr	r3, [sp, #4]
30021c28:	e5d32000 	ldrb	r2, [r3]
30021c2c:	e5d30001 	ldrb	r0, [r3, #1]
30021c30:	e1a00400 	lsl	r0, r0, #8
30021c34:	e1802002 	orr	r2, r0, r2
30021c38:	e5d30002 	ldrb	r0, [r3, #2]
30021c3c:	e1a00800 	lsl	r0, r0, #16
30021c40:	e1802002 	orr	r2, r0, r2
30021c44:	e5d33003 	ldrb	r3, [r3, #3]
30021c48:	e1a03c03 	lsl	r3, r3, #24
30021c4c:	e1833002 	orr	r3, r3, r2
30021c50:	e1a02003 	mov	r2, r3
30021c54:	ea000000 	b	30021c5c <find_entry+0x5d4>
30021c58:	e3a02000 	mov	r2, #0
30021c5c:	e59fc074 	ldr	ip, [pc, #116]	; 30021cd8 <find_entry+0x650>
30021c60:	e3a00004 	mov	r0, #4
30021c64:	e1a03001 	mov	r3, r1
30021c68:	e1a03103 	lsl	r3, r3, #2
30021c6c:	e0833001 	add	r3, r3, r1
30021c70:	e1a03103 	lsl	r3, r3, #2
30021c74:	e083300c 	add	r3, r3, ip
30021c78:	e0833000 	add	r3, r3, r0
30021c7c:	e5832000 	str	r2, [r3]
  }
  arp_table[i].ctime = 0;
30021c80:	e5dd200b 	ldrb	r2, [sp, #11]
30021c84:	e59f004c 	ldr	r0, [pc, #76]	; 30021cd8 <find_entry+0x650>
30021c88:	e3a01008 	mov	r1, #8
30021c8c:	e1a03002 	mov	r3, r2
30021c90:	e1a03103 	lsl	r3, r3, #2
30021c94:	e0833002 	add	r3, r3, r2
30021c98:	e1a03103 	lsl	r3, r3, #2
30021c9c:	e0833000 	add	r3, r3, r0
30021ca0:	e0833001 	add	r3, r3, r1
30021ca4:	e3a02000 	mov	r2, #0
30021ca8:	e5c32007 	strb	r2, [r3, #7]
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
30021cac:	e59f3020 	ldr	r3, [pc, #32]	; 30021cd4 <find_entry+0x64c>
30021cb0:	e5dd200b 	ldrb	r2, [sp, #11]
30021cb4:	e5c32000 	strb	r2, [r3]
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
30021cb8:	e5dd300b 	ldrb	r3, [sp, #11]
30021cbc:	e1a03c03 	lsl	r3, r3, #24
30021cc0:	e1a03c43 	asr	r3, r3, #24
}
30021cc4:	e1a00003 	mov	r0, r3
30021cc8:	e28dd014 	add	sp, sp, #20
30021ccc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30021cd0:	e12fff1e 	bx	lr
30021cd4:	300e3cb8 	.word	0x300e3cb8
30021cd8:	300e3bf0 	.word	0x300e3bf0
30021cdc:	302be570 	.word	0x302be570

30021ce0 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
30021ce0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30021ce4:	e24dd01c 	sub	sp, sp, #28
30021ce8:	e58d000c 	str	r0, [sp, #12]
30021cec:	e58d1008 	str	r1, [sp, #8]
30021cf0:	e58d2004 	str	r2, [sp, #4]
30021cf4:	e58d3000 	str	r3, [sp]
  struct eth_hdr *ethhdr = p->payload;
30021cf8:	e59d3008 	ldr	r3, [sp, #8]
30021cfc:	e5933004 	ldr	r3, [r3, #4]
30021d00:	e58d3010 	str	r3, [sp, #16]
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
30021d04:	e3a03006 	mov	r3, #6
30021d08:	e5cd3017 	strb	r3, [sp, #23]
  while(k > 0) {
30021d0c:	ea000011 	b	30021d58 <etharp_send_ip+0x78>
    k--;
30021d10:	e5dd3017 	ldrb	r3, [sp, #23]
30021d14:	e2433001 	sub	r3, r3, #1
30021d18:	e5cd3017 	strb	r3, [sp, #23]
    ethhdr->dest.addr[k] = dst->addr[k];
30021d1c:	e5dd3017 	ldrb	r3, [sp, #23]
30021d20:	e5dd2017 	ldrb	r2, [sp, #23]
30021d24:	e59d1000 	ldr	r1, [sp]
30021d28:	e7d11002 	ldrb	r1, [r1, r2]
30021d2c:	e59d2010 	ldr	r2, [sp, #16]
30021d30:	e7c21003 	strb	r1, [r2, r3]
    ethhdr->src.addr[k]  = src->addr[k];
30021d34:	e5dd0017 	ldrb	r0, [sp, #23]
30021d38:	e5dd3017 	ldrb	r3, [sp, #23]
30021d3c:	e59d2004 	ldr	r2, [sp, #4]
30021d40:	e7d22003 	ldrb	r2, [r2, r3]
30021d44:	e59d1010 	ldr	r1, [sp, #16]
30021d48:	e3a03006 	mov	r3, #6
30021d4c:	e0801001 	add	r1, r0, r1
30021d50:	e0813003 	add	r3, r1, r3
30021d54:	e5c32000 	strb	r2, [r3]
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
30021d58:	e5dd3017 	ldrb	r3, [sp, #23]
30021d5c:	e3530000 	cmp	r3, #0
30021d60:	1affffea 	bne	30021d10 <etharp_send_ip+0x30>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
30021d64:	e3a00b02 	mov	r0, #2048	; 0x800
30021d68:	ebffc624 	bl	30013600 <htons>
30021d6c:	e1a03000 	mov	r3, r0
30021d70:	e1a02003 	mov	r2, r3
30021d74:	e59d3010 	ldr	r3, [sp, #16]
30021d78:	e20210ff 	and	r1, r2, #255	; 0xff
30021d7c:	e3a00000 	mov	r0, #0
30021d80:	e1801001 	orr	r1, r0, r1
30021d84:	e5c3100c 	strb	r1, [r3, #12]
30021d88:	e1a02422 	lsr	r2, r2, #8
30021d8c:	e1a02802 	lsl	r2, r2, #16
30021d90:	e1a02822 	lsr	r2, r2, #16
30021d94:	e3a01000 	mov	r1, #0
30021d98:	e1812002 	orr	r2, r1, r2
30021d9c:	e5c3200d 	strb	r2, [r3, #13]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
30021da0:	e59d300c 	ldr	r3, [sp, #12]
30021da4:	e5933018 	ldr	r3, [r3, #24]
30021da8:	e59d000c 	ldr	r0, [sp, #12]
30021dac:	e59d1008 	ldr	r1, [sp, #8]
30021db0:	e1a0e00f 	mov	lr, pc
30021db4:	e12fff13 	bx	r3
30021db8:	e1a03000 	mov	r3, r0
30021dbc:	e20330ff 	and	r3, r3, #255	; 0xff
30021dc0:	e20330ff 	and	r3, r3, #255	; 0xff
30021dc4:	e1a03c03 	lsl	r3, r3, #24
30021dc8:	e1a03c43 	asr	r3, r3, #24
}
30021dcc:	e1a00003 	mov	r0, r3
30021dd0:	e28dd01c 	add	sp, sp, #28
30021dd4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30021dd8:	e12fff1e 	bx	lr

30021ddc <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
30021ddc:	e92d4010 	push	{r4, lr}
30021de0:	e24dd020 	sub	sp, sp, #32
30021de4:	e58d000c 	str	r0, [sp, #12]
30021de8:	e58d1008 	str	r1, [sp, #8]
30021dec:	e58d2004 	str	r2, [sp, #4]
30021df0:	e5cd3003 	strb	r3, [sp, #3]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
30021df4:	e59d3008 	ldr	r3, [sp, #8]
30021df8:	e3530000 	cmp	r3, #0
30021dfc:	0a000027 	beq	30021ea0 <update_arp_entry+0xc4>
30021e00:	e59d3008 	ldr	r3, [sp, #8]
30021e04:	e5d32000 	ldrb	r2, [r3]
30021e08:	e5d31001 	ldrb	r1, [r3, #1]
30021e0c:	e1a01401 	lsl	r1, r1, #8
30021e10:	e1812002 	orr	r2, r1, r2
30021e14:	e5d31002 	ldrb	r1, [r3, #2]
30021e18:	e1a01801 	lsl	r1, r1, #16
30021e1c:	e1812002 	orr	r2, r1, r2
30021e20:	e5d33003 	ldrb	r3, [r3, #3]
30021e24:	e1a03c03 	lsl	r3, r3, #24
30021e28:	e1833002 	orr	r3, r3, r2
30021e2c:	e3530000 	cmp	r3, #0
30021e30:	0a00001a 	beq	30021ea0 <update_arp_entry+0xc4>
      ip_addr_isbroadcast(ipaddr, netif) ||
30021e34:	e59d0008 	ldr	r0, [sp, #8]
30021e38:	e59d100c 	ldr	r1, [sp, #12]
30021e3c:	ebffcb85 	bl	30014c58 <ip_addr_isbroadcast>
30021e40:	e1a03000 	mov	r3, r0
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
30021e44:	e3530000 	cmp	r3, #0
30021e48:	1a000014 	bne	30021ea0 <update_arp_entry+0xc4>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
30021e4c:	e59d3008 	ldr	r3, [sp, #8]
30021e50:	e5d32000 	ldrb	r2, [r3]
30021e54:	e5d31001 	ldrb	r1, [r3, #1]
30021e58:	e1a01401 	lsl	r1, r1, #8
30021e5c:	e1812002 	orr	r2, r1, r2
30021e60:	e5d31002 	ldrb	r1, [r3, #2]
30021e64:	e1a01801 	lsl	r1, r1, #16
30021e68:	e1812002 	orr	r2, r1, r2
30021e6c:	e5d33003 	ldrb	r3, [r3, #3]
30021e70:	e1a03c03 	lsl	r3, r3, #24
30021e74:	e1833002 	orr	r3, r3, r2
30021e78:	e1a04003 	mov	r4, r3
30021e7c:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
30021e80:	ebffc60f 	bl	300136c4 <ntohl>
30021e84:	e1a03000 	mov	r3, r0
30021e88:	e0044003 	and	r4, r4, r3
30021e8c:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
30021e90:	ebffc60b 	bl	300136c4 <ntohl>
30021e94:	e1a03000 	mov	r3, r0
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
30021e98:	e1540003 	cmp	r4, r3
30021e9c:	1a000001 	bne	30021ea8 <update_arp_entry+0xcc>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
30021ea0:	e3a030f7 	mov	r3, #247	; 0xf7
30021ea4:	ea000073 	b	30022078 <update_arp_entry+0x29c>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
30021ea8:	e5dd3003 	ldrb	r3, [sp, #3]
30021eac:	e59d0008 	ldr	r0, [sp, #8]
30021eb0:	e1a01003 	mov	r1, r3
30021eb4:	ebfffdf3 	bl	30021688 <find_entry>
30021eb8:	e1a03000 	mov	r3, r0
30021ebc:	e20330ff 	and	r3, r3, #255	; 0xff
30021ec0:	e5cd3016 	strb	r3, [sp, #22]
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
30021ec4:	e1dd31d6 	ldrsb	r3, [sp, #22]
30021ec8:	e3530000 	cmp	r3, #0
30021ecc:	aa000001 	bge	30021ed8 <update_arp_entry+0xfc>
    return (err_t)i;
30021ed0:	e5dd3016 	ldrb	r3, [sp, #22]
30021ed4:	ea000067 	b	30022078 <update_arp_entry+0x29c>
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
30021ed8:	e1dd21d6 	ldrsb	r2, [sp, #22]
30021edc:	e59f01ac 	ldr	r0, [pc, #428]	; 30022090 <update_arp_entry+0x2b4>
30021ee0:	e3a01008 	mov	r1, #8
30021ee4:	e1a03002 	mov	r3, r2
30021ee8:	e1a03103 	lsl	r3, r3, #2
30021eec:	e0833002 	add	r3, r3, r2
30021ef0:	e1a03103 	lsl	r3, r3, #2
30021ef4:	e0833000 	add	r3, r3, r0
30021ef8:	e0833001 	add	r3, r3, r1
30021efc:	e3a02002 	mov	r2, #2
30021f00:	e5c32006 	strb	r2, [r3, #6]
  /* record network interface */
  arp_table[i].netif = netif;
30021f04:	e1dd21d6 	ldrsb	r2, [sp, #22]
30021f08:	e59f0180 	ldr	r0, [pc, #384]	; 30022090 <update_arp_entry+0x2b4>
30021f0c:	e3a01010 	mov	r1, #16
30021f10:	e1a03002 	mov	r3, r2
30021f14:	e1a03103 	lsl	r3, r3, #2
30021f18:	e0833002 	add	r3, r3, r2
30021f1c:	e1a03103 	lsl	r3, r3, #2
30021f20:	e0833000 	add	r3, r3, r0
30021f24:	e0833001 	add	r3, r3, r1
30021f28:	e59d200c 	ldr	r2, [sp, #12]
30021f2c:	e5832000 	str	r2, [r3]
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
30021f30:	e3a03006 	mov	r3, #6
30021f34:	e5cd3017 	strb	r3, [sp, #23]
  while (k > 0) {
30021f38:	ea000012 	b	30021f88 <update_arp_entry+0x1ac>
    k--;
30021f3c:	e5dd3017 	ldrb	r3, [sp, #23]
30021f40:	e2433001 	sub	r3, r3, #1
30021f44:	e5cd3017 	strb	r3, [sp, #23]
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
30021f48:	e1dd21d6 	ldrsb	r2, [sp, #22]
30021f4c:	e5dd4017 	ldrb	r4, [sp, #23]
30021f50:	e5dd3017 	ldrb	r3, [sp, #23]
30021f54:	e59d1004 	ldr	r1, [sp, #4]
30021f58:	e7d11003 	ldrb	r1, [r1, r3]
30021f5c:	e59fc12c 	ldr	ip, [pc, #300]	; 30022090 <update_arp_entry+0x2b4>
30021f60:	e3a00008 	mov	r0, #8
30021f64:	e1a03002 	mov	r3, r2
30021f68:	e1a03103 	lsl	r3, r3, #2
30021f6c:	e0833002 	add	r3, r3, r2
30021f70:	e1a03103 	lsl	r3, r3, #2
30021f74:	e0833004 	add	r3, r3, r4
30021f78:	e083300c 	add	r3, r3, ip
30021f7c:	e0833000 	add	r3, r3, r0
30021f80:	e1a02001 	mov	r2, r1
30021f84:	e5c32000 	strb	r2, [r3]
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
30021f88:	e5dd3017 	ldrb	r3, [sp, #23]
30021f8c:	e3530000 	cmp	r3, #0
30021f90:	1affffe9 	bne	30021f3c <update_arp_entry+0x160>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
30021f94:	e1dd21d6 	ldrsb	r2, [sp, #22]
30021f98:	e59f00f0 	ldr	r0, [pc, #240]	; 30022090 <update_arp_entry+0x2b4>
30021f9c:	e3a01008 	mov	r1, #8
30021fa0:	e1a03002 	mov	r3, r2
30021fa4:	e1a03103 	lsl	r3, r3, #2
30021fa8:	e0833002 	add	r3, r3, r2
30021fac:	e1a03103 	lsl	r3, r3, #2
30021fb0:	e0833000 	add	r3, r3, r0
30021fb4:	e0833001 	add	r3, r3, r1
30021fb8:	e3a02000 	mov	r2, #0
30021fbc:	e5c32007 	strb	r2, [r3, #7]
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
30021fc0:	ea000021 	b	3002204c <update_arp_entry+0x270>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
30021fc4:	e1dd21d6 	ldrsb	r2, [sp, #22]
30021fc8:	e59f10c0 	ldr	r1, [pc, #192]	; 30022090 <update_arp_entry+0x2b4>
30021fcc:	e1a03002 	mov	r3, r2
30021fd0:	e1a03103 	lsl	r3, r3, #2
30021fd4:	e0833002 	add	r3, r3, r2
30021fd8:	e1a03103 	lsl	r3, r3, #2
30021fdc:	e0833001 	add	r3, r3, r1
30021fe0:	e5933000 	ldr	r3, [r3]
30021fe4:	e58d301c 	str	r3, [sp, #28]
    /* pop first item off the queue */
    arp_table[i].q = q->next;
30021fe8:	e1dd21d6 	ldrsb	r2, [sp, #22]
30021fec:	e59d301c 	ldr	r3, [sp, #28]
30021ff0:	e5931000 	ldr	r1, [r3]
30021ff4:	e59f0094 	ldr	r0, [pc, #148]	; 30022090 <update_arp_entry+0x2b4>
30021ff8:	e1a03002 	mov	r3, r2
30021ffc:	e1a03103 	lsl	r3, r3, #2
30022000:	e0833002 	add	r3, r3, r2
30022004:	e1a03103 	lsl	r3, r3, #2
30022008:	e0833000 	add	r3, r3, r0
3002200c:	e5831000 	str	r1, [r3]
    /* get the packet pointer */
    p = q->p;
30022010:	e59d301c 	ldr	r3, [sp, #28]
30022014:	e5933004 	ldr	r3, [r3, #4]
30022018:	e58d3018 	str	r3, [sp, #24]
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
3002201c:	e3a00009 	mov	r0, #9
30022020:	e59d101c 	ldr	r1, [sp, #28]
30022024:	ebffcd27 	bl	300154c8 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
30022028:	e59d300c 	ldr	r3, [sp, #12]
3002202c:	e2833021 	add	r3, r3, #33	; 0x21
30022030:	e59d000c 	ldr	r0, [sp, #12]
30022034:	e59d1018 	ldr	r1, [sp, #24]
30022038:	e1a02003 	mov	r2, r3
3002203c:	e59d3004 	ldr	r3, [sp, #4]
30022040:	ebffff26 	bl	30021ce0 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
30022044:	e59d0018 	ldr	r0, [sp, #24]
30022048:	ebffd08c 	bl	30016280 <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
3002204c:	e1dd21d6 	ldrsb	r2, [sp, #22]
30022050:	e59f1038 	ldr	r1, [pc, #56]	; 30022090 <update_arp_entry+0x2b4>
30022054:	e1a03002 	mov	r3, r2
30022058:	e1a03103 	lsl	r3, r3, #2
3002205c:	e0833002 	add	r3, r3, r2
30022060:	e1a03103 	lsl	r3, r3, #2
30022064:	e0833001 	add	r3, r3, r1
30022068:	e5933000 	ldr	r3, [r3]
3002206c:	e3530000 	cmp	r3, #0
30022070:	1affffd3 	bne	30021fc4 <update_arp_entry+0x1e8>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
30022074:	e3a03000 	mov	r3, #0
30022078:	e1a03c03 	lsl	r3, r3, #24
3002207c:	e1a03c43 	asr	r3, r3, #24
}
30022080:	e1a00003 	mov	r0, r3
30022084:	e28dd020 	add	sp, sp, #32
30022088:	e8bd4010 	pop	{r4, lr}
3002208c:	e12fff1e 	bx	lr
30022090:	300e3bf0 	.word	0x300e3bf0

30022094 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
30022094:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30022098:	e24dd01c 	sub	sp, sp, #28
3002209c:	e58d000c 	str	r0, [sp, #12]
300220a0:	e58d1008 	str	r1, [sp, #8]
300220a4:	e58d2004 	str	r2, [sp, #4]
300220a8:	e58d3000 	str	r3, [sp]
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
300220ac:	e59d0008 	ldr	r0, [sp, #8]
300220b0:	e3a01002 	mov	r1, #2
300220b4:	ebfffd73 	bl	30021688 <find_entry>
300220b8:	e1a03000 	mov	r3, r0
300220bc:	e20330ff 	and	r3, r3, #255	; 0xff
300220c0:	e5cd3017 	strb	r3, [sp, #23]
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
300220c4:	e1dd31d7 	ldrsb	r3, [sp, #23]
300220c8:	e3530000 	cmp	r3, #0
300220cc:	ba000021 	blt	30022158 <etharp_find_addr+0xc4>
300220d0:	e1dd21d7 	ldrsb	r2, [sp, #23]
300220d4:	e59f0098 	ldr	r0, [pc, #152]	; 30022174 <etharp_find_addr+0xe0>
300220d8:	e3a01008 	mov	r1, #8
300220dc:	e1a03002 	mov	r3, r2
300220e0:	e1a03103 	lsl	r3, r3, #2
300220e4:	e0833002 	add	r3, r3, r2
300220e8:	e1a03103 	lsl	r3, r3, #2
300220ec:	e0833000 	add	r3, r3, r0
300220f0:	e0833001 	add	r3, r3, r1
300220f4:	e5d33006 	ldrb	r3, [r3, #6]
300220f8:	e3530002 	cmp	r3, #2
300220fc:	1a000015 	bne	30022158 <etharp_find_addr+0xc4>
      *eth_ret = &arp_table[i].ethaddr;
30022100:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022104:	e1a03002 	mov	r3, r2
30022108:	e1a03103 	lsl	r3, r3, #2
3002210c:	e0833002 	add	r3, r3, r2
30022110:	e1a03103 	lsl	r3, r3, #2
30022114:	e2832008 	add	r2, r3, #8
30022118:	e59f3054 	ldr	r3, [pc, #84]	; 30022174 <etharp_find_addr+0xe0>
3002211c:	e0822003 	add	r2, r2, r3
30022120:	e59d3004 	ldr	r3, [sp, #4]
30022124:	e5832000 	str	r2, [r3]
      *ip_ret = &arp_table[i].ipaddr;
30022128:	e1dd21d7 	ldrsb	r2, [sp, #23]
3002212c:	e1a03002 	mov	r3, r2
30022130:	e1a03103 	lsl	r3, r3, #2
30022134:	e0833002 	add	r3, r3, r2
30022138:	e1a02103 	lsl	r2, r3, #2
3002213c:	e59f3030 	ldr	r3, [pc, #48]	; 30022174 <etharp_find_addr+0xe0>
30022140:	e0823003 	add	r3, r2, r3
30022144:	e2832004 	add	r2, r3, #4
30022148:	e59d3000 	ldr	r3, [sp]
3002214c:	e5832000 	str	r2, [r3]
      return i;
30022150:	e5dd3017 	ldrb	r3, [sp, #23]
30022154:	ea000000 	b	3002215c <etharp_find_addr+0xc8>
  }
  return -1;
30022158:	e3a030ff 	mov	r3, #255	; 0xff
3002215c:	e1a03c03 	lsl	r3, r3, #24
30022160:	e1a03c43 	asr	r3, r3, #24
}
30022164:	e1a00003 	mov	r0, r3
30022168:	e28dd01c 	add	sp, sp, #28
3002216c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30022170:	e12fff1e 	bx	lr
30022174:	300e3bf0 	.word	0x300e3bf0

30022178 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
30022178:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002217c:	e24dd014 	sub	sp, sp, #20
30022180:	e58d0004 	str	r0, [sp, #4]
30022184:	e58d1000 	str	r1, [sp]
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
30022188:	e59d3000 	ldr	r3, [sp]
3002218c:	e5933004 	ldr	r3, [r3, #4]
30022190:	e58d300c 	str	r3, [sp, #12]
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
30022194:	e59d300c 	ldr	r3, [sp, #12]
30022198:	e5d3201a 	ldrb	r2, [r3, #26]
3002219c:	e5d3101b 	ldrb	r1, [r3, #27]
300221a0:	e1a01401 	lsl	r1, r1, #8
300221a4:	e1812002 	orr	r2, r1, r2
300221a8:	e5d3101c 	ldrb	r1, [r3, #28]
300221ac:	e1a01801 	lsl	r1, r1, #16
300221b0:	e1812002 	orr	r2, r1, r2
300221b4:	e5d3301d 	ldrb	r3, [r3, #29]
300221b8:	e1a03c03 	lsl	r3, r3, #24
300221bc:	e1833002 	orr	r3, r3, r2
300221c0:	e1a02003 	mov	r2, r3
300221c4:	e59d3004 	ldr	r3, [sp, #4]
300221c8:	e5933004 	ldr	r3, [r3, #4]
300221cc:	e0222003 	eor	r2, r2, r3
300221d0:	e59d3004 	ldr	r3, [sp, #4]
300221d4:	e5933008 	ldr	r3, [r3, #8]
300221d8:	e0023003 	and	r3, r2, r3
300221dc:	e3530000 	cmp	r3, #0
300221e0:	1a000009 	bne	3002220c <etharp_ip_input+0x94>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
300221e4:	e59d300c 	ldr	r3, [sp, #12]
300221e8:	e283201a 	add	r2, r3, #26
300221ec:	e59d300c 	ldr	r3, [sp, #12]
300221f0:	e2833006 	add	r3, r3, #6
300221f4:	e59d0004 	ldr	r0, [sp, #4]
300221f8:	e1a01002 	mov	r1, r2
300221fc:	e1a02003 	mov	r2, r3
30022200:	e3a03000 	mov	r3, #0
30022204:	ebfffef4 	bl	30021ddc <update_arp_entry>
30022208:	ea000000 	b	30022210 <etharp_ip_input+0x98>
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
    /* do nothing */
    return;
3002220c:	e1a00000 	nop			; (mov r0, r0)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
}
30022210:	e28dd014 	add	sp, sp, #20
30022214:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30022218:	e12fff1e 	bx	lr

3002221c <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
3002221c:	e92d4010 	push	{r4, lr}
30022220:	e24dd020 	sub	sp, sp, #32
30022224:	e58d000c 	str	r0, [sp, #12]
30022228:	e58d1008 	str	r1, [sp, #8]
3002222c:	e58d2004 	str	r2, [sp, #4]

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
30022230:	e59d3004 	ldr	r3, [sp, #4]
30022234:	e1d330ba 	ldrh	r3, [r3, #10]
30022238:	e3530029 	cmp	r3, #41	; 0x29
3002223c:	8a000010 	bhi	30022284 <etharp_arp_input+0x68>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
30022240:	e59f3410 	ldr	r3, [pc, #1040]	; 30022658 <etharp_arp_input+0x43c>
30022244:	e1d332b6 	ldrh	r3, [r3, #38]	; 0x26
30022248:	e2833001 	add	r3, r3, #1
3002224c:	e1a03803 	lsl	r3, r3, #16
30022250:	e1a02823 	lsr	r2, r3, #16
30022254:	e59f33fc 	ldr	r3, [pc, #1020]	; 30022658 <etharp_arp_input+0x43c>
30022258:	e1c322b6 	strh	r2, [r3, #38]	; 0x26
    ETHARP_STATS_INC(etharp.drop);
3002225c:	e59f33f4 	ldr	r3, [pc, #1012]	; 30022658 <etharp_arp_input+0x43c>
30022260:	e1d332b2 	ldrh	r3, [r3, #34]	; 0x22
30022264:	e2833001 	add	r3, r3, #1
30022268:	e1a03803 	lsl	r3, r3, #16
3002226c:	e1a02823 	lsr	r2, r3, #16
30022270:	e59f33e0 	ldr	r3, [pc, #992]	; 30022658 <etharp_arp_input+0x43c>
30022274:	e1c322b2 	strh	r2, [r3, #34]	; 0x22
    pbuf_free(p);
30022278:	e59d0004 	ldr	r0, [sp, #4]
3002227c:	ebffcfff 	bl	30016280 <pbuf_free>
    return;
30022280:	ea0000f1 	b	3002264c <etharp_arp_input+0x430>
  }

  hdr = p->payload;
30022284:	e59d3004 	ldr	r3, [sp, #4]
30022288:	e5933004 	ldr	r3, [r3, #4]
3002228c:	e58d3018 	str	r3, [sp, #24]

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
30022290:	e59d3018 	ldr	r3, [sp, #24]
30022294:	e5d3200e 	ldrb	r2, [r3, #14]
30022298:	e5d3300f 	ldrb	r3, [r3, #15]
3002229c:	e1a03403 	lsl	r3, r3, #8
300222a0:	e1833002 	orr	r3, r3, r2
300222a4:	e1a03803 	lsl	r3, r3, #16
300222a8:	e1a04823 	lsr	r4, r3, #16
300222ac:	e3a00001 	mov	r0, #1
300222b0:	ebffc4d2 	bl	30013600 <htons>
300222b4:	e1a03000 	mov	r3, r0
300222b8:	e1540003 	cmp	r4, r3
300222bc:	1a000025 	bne	30022358 <etharp_arp_input+0x13c>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
300222c0:	e59d3018 	ldr	r3, [sp, #24]
300222c4:	e5d32012 	ldrb	r2, [r3, #18]
300222c8:	e5d33013 	ldrb	r3, [r3, #19]
300222cc:	e1a03403 	lsl	r3, r3, #8
300222d0:	e1833002 	orr	r3, r3, r2
300222d4:	e1a03803 	lsl	r3, r3, #16
300222d8:	e1a04823 	lsr	r4, r3, #16
300222dc:	e3a00c06 	mov	r0, #1536	; 0x600
300222e0:	e2800004 	add	r0, r0, #4
300222e4:	ebffc4c5 	bl	30013600 <htons>
300222e8:	e1a03000 	mov	r3, r0
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
300222ec:	e1540003 	cmp	r4, r3
300222f0:	1a000018 	bne	30022358 <etharp_arp_input+0x13c>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
300222f4:	e59d3018 	ldr	r3, [sp, #24]
300222f8:	e5d32010 	ldrb	r2, [r3, #16]
300222fc:	e5d33011 	ldrb	r3, [r3, #17]
30022300:	e1a03403 	lsl	r3, r3, #8
30022304:	e1833002 	orr	r3, r3, r2
30022308:	e1a03803 	lsl	r3, r3, #16
3002230c:	e1a04823 	lsr	r4, r3, #16
30022310:	e3a00b02 	mov	r0, #2048	; 0x800
30022314:	ebffc4b9 	bl	30013600 <htons>
30022318:	e1a03000 	mov	r3, r0
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
3002231c:	e1540003 	cmp	r4, r3
30022320:	1a00000c 	bne	30022358 <etharp_arp_input+0x13c>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
30022324:	e59d3018 	ldr	r3, [sp, #24]
30022328:	e5d3200c 	ldrb	r2, [r3, #12]
3002232c:	e5d3300d 	ldrb	r3, [r3, #13]
30022330:	e1a03403 	lsl	r3, r3, #8
30022334:	e1833002 	orr	r3, r3, r2
30022338:	e1a03803 	lsl	r3, r3, #16
3002233c:	e1a04823 	lsr	r4, r3, #16
30022340:	e3a00b02 	mov	r0, #2048	; 0x800
30022344:	e2800006 	add	r0, r0, #6
30022348:	ebffc4ac 	bl	30013600 <htons>
3002234c:	e1a03000 	mov	r3, r0
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
30022350:	e1540003 	cmp	r4, r3
30022354:	0a000010 	beq	3002239c <etharp_arp_input+0x180>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
30022358:	e59f32f8 	ldr	r3, [pc, #760]	; 30022658 <etharp_arp_input+0x43c>
3002235c:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
30022360:	e2833001 	add	r3, r3, #1
30022364:	e1a03803 	lsl	r3, r3, #16
30022368:	e1a02823 	lsr	r2, r3, #16
3002236c:	e59f32e4 	ldr	r3, [pc, #740]	; 30022658 <etharp_arp_input+0x43c>
30022370:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
    ETHARP_STATS_INC(etharp.drop);
30022374:	e59f32dc 	ldr	r3, [pc, #732]	; 30022658 <etharp_arp_input+0x43c>
30022378:	e1d332b2 	ldrh	r3, [r3, #34]	; 0x22
3002237c:	e2833001 	add	r3, r3, #1
30022380:	e1a03803 	lsl	r3, r3, #16
30022384:	e1a02823 	lsr	r2, r3, #16
30022388:	e59f32c8 	ldr	r3, [pc, #712]	; 30022658 <etharp_arp_input+0x43c>
3002238c:	e1c322b2 	strh	r2, [r3, #34]	; 0x22
    pbuf_free(p);
30022390:	e59d0004 	ldr	r0, [sp, #4]
30022394:	ebffcfb9 	bl	30016280 <pbuf_free>
    return;
30022398:	ea0000ab 	b	3002264c <etharp_arp_input+0x430>
  }
  ETHARP_STATS_INC(etharp.recv);
3002239c:	e59f32b4 	ldr	r3, [pc, #692]	; 30022658 <etharp_arp_input+0x43c>
300223a0:	e1d331be 	ldrh	r3, [r3, #30]
300223a4:	e2833001 	add	r3, r3, #1
300223a8:	e1a03803 	lsl	r3, r3, #16
300223ac:	e1a02823 	lsr	r2, r3, #16
300223b0:	e59f32a0 	ldr	r3, [pc, #672]	; 30022658 <etharp_arp_input+0x43c>
300223b4:	e1c321be 	strh	r2, [r3, #30]
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
300223b8:	e59d3018 	ldr	r3, [sp, #24]
300223bc:	e283301c 	add	r3, r3, #28
300223c0:	e28d2014 	add	r2, sp, #20
300223c4:	e1a00002 	mov	r0, r2
300223c8:	e1a01003 	mov	r1, r3
300223cc:	e3a02004 	mov	r2, #4
300223d0:	ebffa7c1 	bl	3000c2dc <acoral_memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
300223d4:	e59d3018 	ldr	r3, [sp, #24]
300223d8:	e2833026 	add	r3, r3, #38	; 0x26
300223dc:	e28d2010 	add	r2, sp, #16
300223e0:	e1a00002 	mov	r0, r2
300223e4:	e1a01003 	mov	r1, r3
300223e8:	e3a02004 	mov	r2, #4
300223ec:	ebffa7ba 	bl	3000c2dc <acoral_memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
300223f0:	e59d300c 	ldr	r3, [sp, #12]
300223f4:	e5933004 	ldr	r3, [r3, #4]
300223f8:	e3530000 	cmp	r3, #0
300223fc:	1a000002 	bne	3002240c <etharp_arp_input+0x1f0>
    for_us = 0;
30022400:	e3a03000 	mov	r3, #0
30022404:	e5cd301f 	strb	r3, [sp, #31]
30022408:	ea000006 	b	30022428 <etharp_arp_input+0x20c>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
3002240c:	e59d2010 	ldr	r2, [sp, #16]
30022410:	e59d300c 	ldr	r3, [sp, #12]
30022414:	e5933004 	ldr	r3, [r3, #4]
30022418:	e1520003 	cmp	r2, r3
3002241c:	13a03000 	movne	r3, #0
30022420:	03a03001 	moveq	r3, #1
30022424:	e5cd301f 	strb	r3, [sp, #31]
  }

  /* ARP message directed to us? */
  if (for_us) {
30022428:	e5dd301f 	ldrb	r3, [sp, #31]
3002242c:	e3530000 	cmp	r3, #0
30022430:	0a000008 	beq	30022458 <etharp_arp_input+0x23c>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
30022434:	e59d3018 	ldr	r3, [sp, #24]
30022438:	e2833016 	add	r3, r3, #22
3002243c:	e28d2014 	add	r2, sp, #20
30022440:	e59d000c 	ldr	r0, [sp, #12]
30022444:	e1a01002 	mov	r1, r2
30022448:	e1a02003 	mov	r2, r3
3002244c:	e3a03001 	mov	r3, #1
30022450:	ebfffe61 	bl	30021ddc <update_arp_entry>
30022454:	ea000007 	b	30022478 <etharp_arp_input+0x25c>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
30022458:	e59d3018 	ldr	r3, [sp, #24]
3002245c:	e2833016 	add	r3, r3, #22
30022460:	e28d2014 	add	r2, sp, #20
30022464:	e59d000c 	ldr	r0, [sp, #12]
30022468:	e1a01002 	mov	r1, r2
3002246c:	e1a02003 	mov	r2, r3
30022470:	e3a03000 	mov	r3, #0
30022474:	ebfffe58 	bl	30021ddc <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
30022478:	e59d3018 	ldr	r3, [sp, #24]
3002247c:	e5d32014 	ldrb	r2, [r3, #20]
30022480:	e5d33015 	ldrb	r3, [r3, #21]
30022484:	e1a03403 	lsl	r3, r3, #8
30022488:	e1833002 	orr	r3, r3, r2
3002248c:	e1a03803 	lsl	r3, r3, #16
30022490:	e1a03823 	lsr	r3, r3, #16
30022494:	e1a00003 	mov	r0, r3
30022498:	ebffc458 	bl	30013600 <htons>
3002249c:	e1a03000 	mov	r3, r0
300224a0:	e3530001 	cmp	r3, #1
300224a4:	0a000002 	beq	300224b4 <etharp_arp_input+0x298>
300224a8:	e3530002 	cmp	r3, #2
300224ac:	0a000061 	beq	30022638 <etharp_arp_input+0x41c>
300224b0:	ea000058 	b	30022618 <etharp_arp_input+0x3fc>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
300224b4:	e5dd301f 	ldrb	r3, [sp, #31]
300224b8:	e3530000 	cmp	r3, #0
300224bc:	0a00005f 	beq	30022640 <etharp_arp_input+0x424>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
300224c0:	e3a00002 	mov	r0, #2
300224c4:	ebffc44d 	bl	30013600 <htons>
300224c8:	e1a03000 	mov	r3, r0
300224cc:	e1a02003 	mov	r2, r3
300224d0:	e59d3018 	ldr	r3, [sp, #24]
300224d4:	e20210ff 	and	r1, r2, #255	; 0xff
300224d8:	e3a00000 	mov	r0, #0
300224dc:	e1801001 	orr	r1, r0, r1
300224e0:	e5c31014 	strb	r1, [r3, #20]
300224e4:	e1a02422 	lsr	r2, r2, #8
300224e8:	e1a02802 	lsl	r2, r2, #16
300224ec:	e1a02822 	lsr	r2, r2, #16
300224f0:	e3a01000 	mov	r1, #0
300224f4:	e1812002 	orr	r2, r1, r2
300224f8:	e5c32015 	strb	r2, [r3, #21]
	  
	  //by pegasus0824
      //hdr->dipaddr = hdr->sipaddr;
      //hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
	  SMEMCPY(&hdr->dipaddr, &hdr->sipaddr, sizeof(sipaddr));
300224fc:	e59d3018 	ldr	r3, [sp, #24]
30022500:	e2832026 	add	r2, r3, #38	; 0x26
30022504:	e59d3018 	ldr	r3, [sp, #24]
30022508:	e283301c 	add	r3, r3, #28
3002250c:	e1a00002 	mov	r0, r2
30022510:	e1a01003 	mov	r1, r3
30022514:	e3a02004 	mov	r2, #4
30022518:	ebffa76f 	bl	3000c2dc <acoral_memcpy>
	  SMEMCPY(&hdr->sipaddr, (struct ip_addr2 *)&netif->ip_addr, sizeof(dipaddr));
3002251c:	e59d3018 	ldr	r3, [sp, #24]
30022520:	e283201c 	add	r2, r3, #28
30022524:	e59d300c 	ldr	r3, [sp, #12]
30022528:	e2833004 	add	r3, r3, #4
3002252c:	e1a00002 	mov	r0, r2
30022530:	e1a01003 	mov	r1, r3
30022534:	e3a02004 	mov	r2, #4
30022538:	ebffa767 	bl	3000c2dc <acoral_memcpy>

     
	  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
      i = ETHARP_HWADDR_LEN;
3002253c:	e3a03006 	mov	r3, #6
30022540:	e5cd301e 	strb	r3, [sp, #30]
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
30022544:	ea000029 	b	300225f0 <etharp_arp_input+0x3d4>
        i--;
30022548:	e5dd301e 	ldrb	r3, [sp, #30]
3002254c:	e2433001 	sub	r3, r3, #1
30022550:	e5cd301e 	strb	r3, [sp, #30]
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
30022554:	e5dd001e 	ldrb	r0, [sp, #30]
30022558:	e5dd101e 	ldrb	r1, [sp, #30]
3002255c:	e59d2018 	ldr	r2, [sp, #24]
30022560:	e3a03016 	mov	r3, #22
30022564:	e0812002 	add	r2, r1, r2
30022568:	e0823003 	add	r3, r2, r3
3002256c:	e5d32000 	ldrb	r2, [r3]
30022570:	e59d1018 	ldr	r1, [sp, #24]
30022574:	e3a03020 	mov	r3, #32
30022578:	e0801001 	add	r1, r0, r1
3002257c:	e0813003 	add	r3, r1, r3
30022580:	e5c32000 	strb	r2, [r3]
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
30022584:	e5dd301e 	ldrb	r3, [sp, #30]
30022588:	e5dd001e 	ldrb	r0, [sp, #30]
3002258c:	e59d1018 	ldr	r1, [sp, #24]
30022590:	e3a02016 	mov	r2, #22
30022594:	e0801001 	add	r1, r0, r1
30022598:	e0812002 	add	r2, r1, r2
3002259c:	e5d21000 	ldrb	r1, [r2]
300225a0:	e59d2018 	ldr	r2, [sp, #24]
300225a4:	e7c21003 	strb	r1, [r2, r3]
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
300225a8:	e5dd001e 	ldrb	r0, [sp, #30]
300225ac:	e5dd301e 	ldrb	r3, [sp, #30]
300225b0:	e59d2008 	ldr	r2, [sp, #8]
300225b4:	e7d22003 	ldrb	r2, [r2, r3]
300225b8:	e59d1018 	ldr	r1, [sp, #24]
300225bc:	e3a03016 	mov	r3, #22
300225c0:	e0801001 	add	r1, r0, r1
300225c4:	e0813003 	add	r3, r1, r3
300225c8:	e5c32000 	strb	r2, [r3]
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
300225cc:	e5dd001e 	ldrb	r0, [sp, #30]
300225d0:	e5dd301e 	ldrb	r3, [sp, #30]
300225d4:	e59d2008 	ldr	r2, [sp, #8]
300225d8:	e7d22003 	ldrb	r2, [r2, r3]
300225dc:	e59d1018 	ldr	r1, [sp, #24]
300225e0:	e3a03006 	mov	r3, #6
300225e4:	e0801001 	add	r1, r0, r1
300225e8:	e0813003 	add	r3, r1, r3
300225ec:	e5c32000 	strb	r2, [r3]
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
300225f0:	e5dd301e 	ldrb	r3, [sp, #30]
300225f4:	e3530000 	cmp	r3, #0
300225f8:	1affffd2 	bne	30022548 <etharp_arp_input+0x32c>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
300225fc:	e59d300c 	ldr	r3, [sp, #12]
30022600:	e5933018 	ldr	r3, [r3, #24]
30022604:	e59d000c 	ldr	r0, [sp, #12]
30022608:	e59d1004 	ldr	r1, [sp, #4]
3002260c:	e1a0e00f 	mov	lr, pc
30022610:	e12fff13 	bx	r3
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
30022614:	ea00000a 	b	30022644 <etharp_arp_input+0x428>
    dhcp_arp_reply(netif, &sipaddr);
#endif
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
30022618:	e59f3038 	ldr	r3, [pc, #56]	; 30022658 <etharp_arp_input+0x43c>
3002261c:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
30022620:	e2833001 	add	r3, r3, #1
30022624:	e1a03803 	lsl	r3, r3, #16
30022628:	e1a02823 	lsr	r2, r3, #16
3002262c:	e59f3024 	ldr	r3, [pc, #36]	; 30022658 <etharp_arp_input+0x43c>
30022630:	e1c323b0 	strh	r2, [r3, #48]	; 0x30
30022634:	ea000002 	b	30022644 <etharp_arp_input+0x428>
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
#endif
    break;
30022638:	e1a00000 	nop			; (mov r0, r0)
3002263c:	ea000000 	b	30022644 <etharp_arp_input+0x428>
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
30022640:	e1a00000 	nop			; (mov r0, r0)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
30022644:	e59d0004 	ldr	r0, [sp, #4]
30022648:	ebffcf0c 	bl	30016280 <pbuf_free>
}
3002264c:	e28dd020 	add	sp, sp, #32
30022650:	e8bd4010 	pop	{r4, lr}
30022654:	e12fff1e 	bx	lr
30022658:	302be570 	.word	0x302be570

3002265c <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
3002265c:	e92d4010 	push	{r4, lr}
30022660:	e24dd020 	sub	sp, sp, #32
30022664:	e58d000c 	str	r0, [sp, #12]
30022668:	e58d1008 	str	r1, [sp, #8]
3002266c:	e58d2004 	str	r2, [sp, #4]
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
30022670:	e59d0008 	ldr	r0, [sp, #8]
30022674:	e3a0100e 	mov	r1, #14
30022678:	ebffce9b 	bl	300160ec <pbuf_header>
3002267c:	e1a03000 	mov	r3, r0
30022680:	e3530000 	cmp	r3, #0
30022684:	0a000008 	beq	300226ac <etharp_output+0x50>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
30022688:	e59f3264 	ldr	r3, [pc, #612]	; 300228f4 <etharp_output+0x298>
3002268c:	e1d330bc 	ldrh	r3, [r3, #12]
30022690:	e2833001 	add	r3, r3, #1
30022694:	e1a03803 	lsl	r3, r3, #16
30022698:	e1a02823 	lsr	r2, r3, #16
3002269c:	e59f3250 	ldr	r3, [pc, #592]	; 300228f4 <etharp_output+0x298>
300226a0:	e1c320bc 	strh	r2, [r3, #12]
    return ERR_BUF;
300226a4:	e3a030fe 	mov	r3, #254	; 0xfe
300226a8:	ea00008b 	b	300228dc <etharp_output+0x280>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
300226ac:	e3a03000 	mov	r3, #0
300226b0:	e58d301c 	str	r3, [sp, #28]
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
300226b4:	e59d0004 	ldr	r0, [sp, #4]
300226b8:	e59d100c 	ldr	r1, [sp, #12]
300226bc:	ebffc965 	bl	30014c58 <ip_addr_isbroadcast>
300226c0:	e1a03000 	mov	r3, r0
300226c4:	e3530000 	cmp	r3, #0
300226c8:	0a000002 	beq	300226d8 <etharp_output+0x7c>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
300226cc:	e59f3224 	ldr	r3, [pc, #548]	; 300228f8 <etharp_output+0x29c>
300226d0:	e58d301c 	str	r3, [sp, #28]
300226d4:	ea000076 	b	300228b4 <etharp_output+0x258>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
300226d8:	e59d3004 	ldr	r3, [sp, #4]
300226dc:	e5d32000 	ldrb	r2, [r3]
300226e0:	e5d31001 	ldrb	r1, [r3, #1]
300226e4:	e1a01401 	lsl	r1, r1, #8
300226e8:	e1812002 	orr	r2, r1, r2
300226ec:	e5d31002 	ldrb	r1, [r3, #2]
300226f0:	e1a01801 	lsl	r1, r1, #16
300226f4:	e1812002 	orr	r2, r1, r2
300226f8:	e5d33003 	ldrb	r3, [r3, #3]
300226fc:	e1a03c03 	lsl	r3, r3, #24
30022700:	e1833002 	orr	r3, r3, r2
30022704:	e1a04003 	mov	r4, r3
30022708:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
3002270c:	ebffc3ec 	bl	300136c4 <ntohl>
30022710:	e1a03000 	mov	r3, r0
30022714:	e0044003 	and	r4, r4, r3
30022718:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
3002271c:	ebffc3e8 	bl	300136c4 <ntohl>
30022720:	e1a03000 	mov	r3, r0
30022724:	e1540003 	cmp	r4, r3
30022728:	1a00003b 	bne	3002281c <etharp_output+0x1c0>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
3002272c:	e3a03001 	mov	r3, #1
30022730:	e5cd3014 	strb	r3, [sp, #20]
    mcastaddr.addr[1] = 0x00;
30022734:	e3a03000 	mov	r3, #0
30022738:	e5cd3015 	strb	r3, [sp, #21]
    mcastaddr.addr[2] = 0x5e;
3002273c:	e3a0305e 	mov	r3, #94	; 0x5e
30022740:	e5cd3016 	strb	r3, [sp, #22]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
30022744:	e59d3004 	ldr	r3, [sp, #4]
30022748:	e5d32000 	ldrb	r2, [r3]
3002274c:	e5d31001 	ldrb	r1, [r3, #1]
30022750:	e1a01401 	lsl	r1, r1, #8
30022754:	e1812002 	orr	r2, r1, r2
30022758:	e5d31002 	ldrb	r1, [r3, #2]
3002275c:	e1a01801 	lsl	r1, r1, #16
30022760:	e1812002 	orr	r2, r1, r2
30022764:	e5d33003 	ldrb	r3, [r3, #3]
30022768:	e1a03c03 	lsl	r3, r3, #24
3002276c:	e1833002 	orr	r3, r3, r2
30022770:	e1a00003 	mov	r0, r3
30022774:	ebffc3d2 	bl	300136c4 <ntohl>
30022778:	e1a03000 	mov	r3, r0
3002277c:	e1a03823 	lsr	r3, r3, #16
30022780:	e20330ff 	and	r3, r3, #255	; 0xff
30022784:	e203307f 	and	r3, r3, #127	; 0x7f
30022788:	e5cd3017 	strb	r3, [sp, #23]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
3002278c:	e59d3004 	ldr	r3, [sp, #4]
30022790:	e5d32000 	ldrb	r2, [r3]
30022794:	e5d31001 	ldrb	r1, [r3, #1]
30022798:	e1a01401 	lsl	r1, r1, #8
3002279c:	e1812002 	orr	r2, r1, r2
300227a0:	e5d31002 	ldrb	r1, [r3, #2]
300227a4:	e1a01801 	lsl	r1, r1, #16
300227a8:	e1812002 	orr	r2, r1, r2
300227ac:	e5d33003 	ldrb	r3, [r3, #3]
300227b0:	e1a03c03 	lsl	r3, r3, #24
300227b4:	e1833002 	orr	r3, r3, r2
300227b8:	e1a00003 	mov	r0, r3
300227bc:	ebffc3c0 	bl	300136c4 <ntohl>
300227c0:	e1a03000 	mov	r3, r0
300227c4:	e1a03423 	lsr	r3, r3, #8
300227c8:	e20330ff 	and	r3, r3, #255	; 0xff
300227cc:	e5cd3018 	strb	r3, [sp, #24]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
300227d0:	e59d3004 	ldr	r3, [sp, #4]
300227d4:	e5d32000 	ldrb	r2, [r3]
300227d8:	e5d31001 	ldrb	r1, [r3, #1]
300227dc:	e1a01401 	lsl	r1, r1, #8
300227e0:	e1812002 	orr	r2, r1, r2
300227e4:	e5d31002 	ldrb	r1, [r3, #2]
300227e8:	e1a01801 	lsl	r1, r1, #16
300227ec:	e1812002 	orr	r2, r1, r2
300227f0:	e5d33003 	ldrb	r3, [r3, #3]
300227f4:	e1a03c03 	lsl	r3, r3, #24
300227f8:	e1833002 	orr	r3, r3, r2
300227fc:	e1a00003 	mov	r0, r3
30022800:	ebffc3af 	bl	300136c4 <ntohl>
30022804:	e1a03000 	mov	r3, r0
30022808:	e20330ff 	and	r3, r3, #255	; 0xff
3002280c:	e5cd3019 	strb	r3, [sp, #25]
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
30022810:	e28d3014 	add	r3, sp, #20
30022814:	e58d301c 	str	r3, [sp, #28]
30022818:	ea000025 	b	300228b4 <etharp_output+0x258>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
3002281c:	e59d3004 	ldr	r3, [sp, #4]
30022820:	e5d32000 	ldrb	r2, [r3]
30022824:	e5d31001 	ldrb	r1, [r3, #1]
30022828:	e1a01401 	lsl	r1, r1, #8
3002282c:	e1812002 	orr	r2, r1, r2
30022830:	e5d31002 	ldrb	r1, [r3, #2]
30022834:	e1a01801 	lsl	r1, r1, #16
30022838:	e1812002 	orr	r2, r1, r2
3002283c:	e5d33003 	ldrb	r3, [r3, #3]
30022840:	e1a03c03 	lsl	r3, r3, #24
30022844:	e1833002 	orr	r3, r3, r2
30022848:	e1a02003 	mov	r2, r3
3002284c:	e59d300c 	ldr	r3, [sp, #12]
30022850:	e5933004 	ldr	r3, [r3, #4]
30022854:	e0222003 	eor	r2, r2, r3
30022858:	e59d300c 	ldr	r3, [sp, #12]
3002285c:	e5933008 	ldr	r3, [r3, #8]
30022860:	e0023003 	and	r3, r2, r3
30022864:	e3530000 	cmp	r3, #0
30022868:	0a000009 	beq	30022894 <etharp_output+0x238>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
3002286c:	e59d300c 	ldr	r3, [sp, #12]
30022870:	e593300c 	ldr	r3, [r3, #12]
30022874:	e3530000 	cmp	r3, #0
30022878:	0a000003 	beq	3002288c <etharp_output+0x230>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
3002287c:	e59d300c 	ldr	r3, [sp, #12]
30022880:	e283300c 	add	r3, r3, #12
30022884:	e58d3004 	str	r3, [sp, #4]
30022888:	ea000001 	b	30022894 <etharp_output+0x238>
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
3002288c:	e3a030fd 	mov	r3, #253	; 0xfd
30022890:	ea000011 	b	300228dc <etharp_output+0x280>
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
30022894:	e59d000c 	ldr	r0, [sp, #12]
30022898:	e59d1004 	ldr	r1, [sp, #4]
3002289c:	e59d2008 	ldr	r2, [sp, #8]
300228a0:	eb000015 	bl	300228fc <etharp_query>
300228a4:	e1a03000 	mov	r3, r0
300228a8:	e20330ff 	and	r3, r3, #255	; 0xff
300228ac:	e20330ff 	and	r3, r3, #255	; 0xff
300228b0:	ea000009 	b	300228dc <etharp_output+0x280>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
300228b4:	e59d300c 	ldr	r3, [sp, #12]
300228b8:	e2833021 	add	r3, r3, #33	; 0x21
300228bc:	e59d000c 	ldr	r0, [sp, #12]
300228c0:	e59d1008 	ldr	r1, [sp, #8]
300228c4:	e1a02003 	mov	r2, r3
300228c8:	e59d301c 	ldr	r3, [sp, #28]
300228cc:	ebfffd03 	bl	30021ce0 <etharp_send_ip>
300228d0:	e1a03000 	mov	r3, r0
300228d4:	e20330ff 	and	r3, r3, #255	; 0xff
300228d8:	e20330ff 	and	r3, r3, #255	; 0xff
300228dc:	e1a03c03 	lsl	r3, r3, #24
300228e0:	e1a03c43 	asr	r3, r3, #24
}
300228e4:	e1a00003 	mov	r0, r3
300228e8:	e28dd020 	add	sp, sp, #32
300228ec:	e8bd4010 	pop	{r4, lr}
300228f0:	e12fff1e 	bx	lr
300228f4:	302be570 	.word	0x302be570
300228f8:	30045750 	.word	0x30045750

300228fc <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
300228fc:	e92d4010 	push	{r4, lr}
30022900:	e24dd028 	sub	sp, sp, #40	; 0x28
30022904:	e58d000c 	str	r0, [sp, #12]
30022908:	e58d1008 	str	r1, [sp, #8]
3002290c:	e58d2004 	str	r2, [sp, #4]
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
30022910:	e59d300c 	ldr	r3, [sp, #12]
30022914:	e2833021 	add	r3, r3, #33	; 0x21
30022918:	e58d3010 	str	r3, [sp, #16]
  err_t result = ERR_MEM;
3002291c:	e3e03000 	mvn	r3, #0
30022920:	e5cd3016 	strb	r3, [sp, #22]
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
30022924:	e59d0008 	ldr	r0, [sp, #8]
30022928:	e59d100c 	ldr	r1, [sp, #12]
3002292c:	ebffc8c9 	bl	30014c58 <ip_addr_isbroadcast>
30022930:	e1a03000 	mov	r3, r0
30022934:	e3530000 	cmp	r3, #0
30022938:	1a000024 	bne	300229d0 <etharp_query+0xd4>
      ip_addr_ismulticast(ipaddr) ||
3002293c:	e59d3008 	ldr	r3, [sp, #8]
30022940:	e5d32000 	ldrb	r2, [r3]
30022944:	e5d31001 	ldrb	r1, [r3, #1]
30022948:	e1a01401 	lsl	r1, r1, #8
3002294c:	e1812002 	orr	r2, r1, r2
30022950:	e5d31002 	ldrb	r1, [r3, #2]
30022954:	e1a01801 	lsl	r1, r1, #16
30022958:	e1812002 	orr	r2, r1, r2
3002295c:	e5d33003 	ldrb	r3, [r3, #3]
30022960:	e1a03c03 	lsl	r3, r3, #24
30022964:	e1833002 	orr	r3, r3, r2
30022968:	e1a04003 	mov	r4, r3
3002296c:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
30022970:	ebffc353 	bl	300136c4 <ntohl>
30022974:	e1a03000 	mov	r3, r0
30022978:	e0044003 	and	r4, r4, r3
3002297c:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
30022980:	ebffc34f 	bl	300136c4 <ntohl>
30022984:	e1a03000 	mov	r3, r0
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
30022988:	e1540003 	cmp	r4, r3
3002298c:	0a00000f 	beq	300229d0 <etharp_query+0xd4>
30022990:	e59d3008 	ldr	r3, [sp, #8]
30022994:	e3530000 	cmp	r3, #0
30022998:	0a00000c 	beq	300229d0 <etharp_query+0xd4>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
3002299c:	e59d3008 	ldr	r3, [sp, #8]
300229a0:	e5d32000 	ldrb	r2, [r3]
300229a4:	e5d31001 	ldrb	r1, [r3, #1]
300229a8:	e1a01401 	lsl	r1, r1, #8
300229ac:	e1812002 	orr	r2, r1, r2
300229b0:	e5d31002 	ldrb	r1, [r3, #2]
300229b4:	e1a01801 	lsl	r1, r1, #16
300229b8:	e1812002 	orr	r2, r1, r2
300229bc:	e5d33003 	ldrb	r3, [r3, #3]
300229c0:	e1a03c03 	lsl	r3, r3, #24
300229c4:	e1833002 	orr	r3, r3, r2
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
300229c8:	e3530000 	cmp	r3, #0
300229cc:	1a000001 	bne	300229d8 <etharp_query+0xdc>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
300229d0:	e3a030f7 	mov	r3, #247	; 0xf7
300229d4:	ea0000e5 	b	30022d70 <etharp_query+0x474>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
300229d8:	e59d0008 	ldr	r0, [sp, #8]
300229dc:	e3a01001 	mov	r1, #1
300229e0:	ebfffb28 	bl	30021688 <find_entry>
300229e4:	e1a03000 	mov	r3, r0
300229e8:	e20330ff 	and	r3, r3, #255	; 0xff
300229ec:	e5cd3017 	strb	r3, [sp, #23]
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
300229f0:	e1dd31d7 	ldrsb	r3, [sp, #23]
300229f4:	e3530000 	cmp	r3, #0
300229f8:	aa00000b 	bge	30022a2c <etharp_query+0x130>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
300229fc:	e59d3004 	ldr	r3, [sp, #4]
30022a00:	e3530000 	cmp	r3, #0
30022a04:	0a000006 	beq	30022a24 <etharp_query+0x128>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
30022a08:	e59f3378 	ldr	r3, [pc, #888]	; 30022d88 <etharp_query+0x48c>
30022a0c:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
30022a10:	e2833001 	add	r3, r3, #1
30022a14:	e1a03803 	lsl	r3, r3, #16
30022a18:	e1a02823 	lsr	r2, r3, #16
30022a1c:	e59f3364 	ldr	r3, [pc, #868]	; 30022d88 <etharp_query+0x48c>
30022a20:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
    }
    return (err_t)i;
30022a24:	e5dd3017 	ldrb	r3, [sp, #23]
30022a28:	ea0000d0 	b	30022d70 <etharp_query+0x474>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
30022a2c:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022a30:	e59f0354 	ldr	r0, [pc, #852]	; 30022d8c <etharp_query+0x490>
30022a34:	e3a01008 	mov	r1, #8
30022a38:	e1a03002 	mov	r3, r2
30022a3c:	e1a03103 	lsl	r3, r3, #2
30022a40:	e0833002 	add	r3, r3, r2
30022a44:	e1a03103 	lsl	r3, r3, #2
30022a48:	e0833000 	add	r3, r3, r0
30022a4c:	e0833001 	add	r3, r3, r1
30022a50:	e5d33006 	ldrb	r3, [r3, #6]
30022a54:	e3530000 	cmp	r3, #0
30022a58:	1a00000a 	bne	30022a88 <etharp_query+0x18c>
    arp_table[i].state = ETHARP_STATE_PENDING;
30022a5c:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022a60:	e59f0324 	ldr	r0, [pc, #804]	; 30022d8c <etharp_query+0x490>
30022a64:	e3a01008 	mov	r1, #8
30022a68:	e1a03002 	mov	r3, r2
30022a6c:	e1a03103 	lsl	r3, r3, #2
30022a70:	e0833002 	add	r3, r3, r2
30022a74:	e1a03103 	lsl	r3, r3, #2
30022a78:	e0833000 	add	r3, r3, r0
30022a7c:	e0833001 	add	r3, r3, r1
30022a80:	e3a02001 	mov	r2, #1
30022a84:	e5c32006 	strb	r2, [r3, #6]
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
30022a88:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022a8c:	e59f02f8 	ldr	r0, [pc, #760]	; 30022d8c <etharp_query+0x490>
30022a90:	e3a01008 	mov	r1, #8
30022a94:	e1a03002 	mov	r3, r2
30022a98:	e1a03103 	lsl	r3, r3, #2
30022a9c:	e0833002 	add	r3, r3, r2
30022aa0:	e1a03103 	lsl	r3, r3, #2
30022aa4:	e0833000 	add	r3, r3, r0
30022aa8:	e0833001 	add	r3, r3, r1
30022aac:	e5d33006 	ldrb	r3, [r3, #6]
30022ab0:	e3530001 	cmp	r3, #1
30022ab4:	0a000002 	beq	30022ac4 <etharp_query+0x1c8>
30022ab8:	e59d3004 	ldr	r3, [sp, #4]
30022abc:	e3530000 	cmp	r3, #0
30022ac0:	1a000005 	bne	30022adc <etharp_query+0x1e0>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
30022ac4:	e59d000c 	ldr	r0, [sp, #12]
30022ac8:	e59d1008 	ldr	r1, [sp, #8]
30022acc:	eb00016c 	bl	30023084 <etharp_request>
30022ad0:	e1a03000 	mov	r3, r0
30022ad4:	e20330ff 	and	r3, r3, #255	; 0xff
30022ad8:	e5cd3016 	strb	r3, [sp, #22]
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
30022adc:	e59d3004 	ldr	r3, [sp, #4]
30022ae0:	e3530000 	cmp	r3, #0
30022ae4:	0a0000a0 	beq	30022d6c <etharp_query+0x470>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
30022ae8:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022aec:	e59f0298 	ldr	r0, [pc, #664]	; 30022d8c <etharp_query+0x490>
30022af0:	e3a01008 	mov	r1, #8
30022af4:	e1a03002 	mov	r3, r2
30022af8:	e1a03103 	lsl	r3, r3, #2
30022afc:	e0833002 	add	r3, r3, r2
30022b00:	e1a03103 	lsl	r3, r3, #2
30022b04:	e0833000 	add	r3, r3, r0
30022b08:	e0833001 	add	r3, r3, r1
30022b0c:	e5d33006 	ldrb	r3, [r3, #6]
30022b10:	e3530002 	cmp	r3, #2
30022b14:	1a00000f 	bne	30022b58 <etharp_query+0x25c>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
30022b18:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022b1c:	e1a03002 	mov	r3, r2
30022b20:	e1a03103 	lsl	r3, r3, #2
30022b24:	e0833002 	add	r3, r3, r2
30022b28:	e1a03103 	lsl	r3, r3, #2
30022b2c:	e2832008 	add	r2, r3, #8
30022b30:	e59f3254 	ldr	r3, [pc, #596]	; 30022d8c <etharp_query+0x490>
30022b34:	e0823003 	add	r3, r2, r3
30022b38:	e59d000c 	ldr	r0, [sp, #12]
30022b3c:	e59d1004 	ldr	r1, [sp, #4]
30022b40:	e59d2010 	ldr	r2, [sp, #16]
30022b44:	ebfffc65 	bl	30021ce0 <etharp_send_ip>
30022b48:	e1a03000 	mov	r3, r0
30022b4c:	e20330ff 	and	r3, r3, #255	; 0xff
30022b50:	e5cd3016 	strb	r3, [sp, #22]
30022b54:	ea000084 	b	30022d6c <etharp_query+0x470>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
30022b58:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022b5c:	e59f0228 	ldr	r0, [pc, #552]	; 30022d8c <etharp_query+0x490>
30022b60:	e3a01008 	mov	r1, #8
30022b64:	e1a03002 	mov	r3, r2
30022b68:	e1a03103 	lsl	r3, r3, #2
30022b6c:	e0833002 	add	r3, r3, r2
30022b70:	e1a03103 	lsl	r3, r3, #2
30022b74:	e0833000 	add	r3, r3, r0
30022b78:	e0833001 	add	r3, r3, r1
30022b7c:	e5d33006 	ldrb	r3, [r3, #6]
30022b80:	e3530001 	cmp	r3, #1
30022b84:	1a000078 	bne	30022d6c <etharp_query+0x470>
#if ARP_QUEUEING /* queue the given q packet */
      struct pbuf *p;
      int copy_needed = 0;
30022b88:	e3a03000 	mov	r3, #0
30022b8c:	e58d301c 	str	r3, [sp, #28]
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
30022b90:	e59d3004 	ldr	r3, [sp, #4]
30022b94:	e58d3018 	str	r3, [sp, #24]
      while (p) {
30022b98:	ea000009 	b	30022bc4 <etharp_query+0x2c8>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
        if(p->type != PBUF_ROM) {
30022b9c:	e59d3018 	ldr	r3, [sp, #24]
30022ba0:	e5d3300c 	ldrb	r3, [r3, #12]
30022ba4:	e3530001 	cmp	r3, #1
30022ba8:	0a000002 	beq	30022bb8 <etharp_query+0x2bc>
          copy_needed = 1;
30022bac:	e3a03001 	mov	r3, #1
30022bb0:	e58d301c 	str	r3, [sp, #28]
          break;
30022bb4:	ea000005 	b	30022bd0 <etharp_query+0x2d4>
        }
        p = p->next;
30022bb8:	e59d3018 	ldr	r3, [sp, #24]
30022bbc:	e5933000 	ldr	r3, [r3]
30022bc0:	e58d3018 	str	r3, [sp, #24]
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
30022bc4:	e59d3018 	ldr	r3, [sp, #24]
30022bc8:	e3530000 	cmp	r3, #0
30022bcc:	1afffff2 	bne	30022b9c <etharp_query+0x2a0>
          copy_needed = 1;
          break;
        }
        p = p->next;
      }
      if(copy_needed) {
30022bd0:	e59d301c 	ldr	r3, [sp, #28]
30022bd4:	e3530000 	cmp	r3, #0
30022bd8:	0a000016 	beq	30022c38 <etharp_query+0x33c>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
30022bdc:	e59d3018 	ldr	r3, [sp, #24]
30022be0:	e1d330b8 	ldrh	r3, [r3, #8]
30022be4:	e3a00003 	mov	r0, #3
30022be8:	e1a01003 	mov	r1, r3
30022bec:	e3a02000 	mov	r2, #0
30022bf0:	ebffcbf0 	bl	30015bb8 <pbuf_alloc>
30022bf4:	e1a03000 	mov	r3, r0
30022bf8:	e58d3018 	str	r3, [sp, #24]
        if(p != NULL) {
30022bfc:	e59d3018 	ldr	r3, [sp, #24]
30022c00:	e3530000 	cmp	r3, #0
30022c04:	0a000010 	beq	30022c4c <etharp_query+0x350>
          if (pbuf_copy(p, q) != ERR_OK) {
30022c08:	e59d0018 	ldr	r0, [sp, #24]
30022c0c:	e59d1004 	ldr	r1, [sp, #4]
30022c10:	ebffce60 	bl	30016598 <pbuf_copy>
30022c14:	e1a03000 	mov	r3, r0
30022c18:	e20330ff 	and	r3, r3, #255	; 0xff
30022c1c:	e3530000 	cmp	r3, #0
30022c20:	0a00000b 	beq	30022c54 <etharp_query+0x358>
            pbuf_free(p);
30022c24:	e59d0018 	ldr	r0, [sp, #24]
30022c28:	ebffcd94 	bl	30016280 <pbuf_free>
            p = NULL;
30022c2c:	e3a03000 	mov	r3, #0
30022c30:	e58d3018 	str	r3, [sp, #24]
30022c34:	ea000007 	b	30022c58 <etharp_query+0x35c>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
30022c38:	e59d3004 	ldr	r3, [sp, #4]
30022c3c:	e58d3018 	str	r3, [sp, #24]
        pbuf_ref(p);
30022c40:	e59d0018 	ldr	r0, [sp, #24]
30022c44:	ebffcde5 	bl	300163e0 <pbuf_ref>
30022c48:	ea000002 	b	30022c58 <etharp_query+0x35c>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
        if(p != NULL) {
          if (pbuf_copy(p, q) != ERR_OK) {
            pbuf_free(p);
            p = NULL;
30022c4c:	e1a00000 	nop			; (mov r0, r0)
30022c50:	ea000000 	b	30022c58 <etharp_query+0x35c>
30022c54:	e1a00000 	nop			; (mov r0, r0)
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
      }
      /* packet could be taken over? */
      if (p != NULL) {
30022c58:	e59d3018 	ldr	r3, [sp, #24]
30022c5c:	e3530000 	cmp	r3, #0
30022c60:	0a00003a 	beq	30022d50 <etharp_query+0x454>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
30022c64:	e3a00009 	mov	r0, #9
30022c68:	ebffc9b1 	bl	30015334 <memp_malloc>
30022c6c:	e1a03000 	mov	r3, r0
30022c70:	e58d3020 	str	r3, [sp, #32]
        if (new_entry != NULL) {
30022c74:	e59d3020 	ldr	r3, [sp, #32]
30022c78:	e3530000 	cmp	r3, #0
30022c7c:	0a000030 	beq	30022d44 <etharp_query+0x448>
          new_entry->next = 0;
30022c80:	e59d3020 	ldr	r3, [sp, #32]
30022c84:	e3a02000 	mov	r2, #0
30022c88:	e5832000 	str	r2, [r3]
          new_entry->p = p;
30022c8c:	e59d3020 	ldr	r3, [sp, #32]
30022c90:	e59d2018 	ldr	r2, [sp, #24]
30022c94:	e5832004 	str	r2, [r3, #4]
          if(arp_table[i].q != NULL) {
30022c98:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022c9c:	e59f10e8 	ldr	r1, [pc, #232]	; 30022d8c <etharp_query+0x490>
30022ca0:	e1a03002 	mov	r3, r2
30022ca4:	e1a03103 	lsl	r3, r3, #2
30022ca8:	e0833002 	add	r3, r3, r2
30022cac:	e1a03103 	lsl	r3, r3, #2
30022cb0:	e0833001 	add	r3, r3, r1
30022cb4:	e5933000 	ldr	r3, [r3]
30022cb8:	e3530000 	cmp	r3, #0
30022cbc:	0a000014 	beq	30022d14 <etharp_query+0x418>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
30022cc0:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022cc4:	e59f10c0 	ldr	r1, [pc, #192]	; 30022d8c <etharp_query+0x490>
30022cc8:	e1a03002 	mov	r3, r2
30022ccc:	e1a03103 	lsl	r3, r3, #2
30022cd0:	e0833002 	add	r3, r3, r2
30022cd4:	e1a03103 	lsl	r3, r3, #2
30022cd8:	e0833001 	add	r3, r3, r1
30022cdc:	e5933000 	ldr	r3, [r3]
30022ce0:	e58d3024 	str	r3, [sp, #36]	; 0x24
            while (r->next != NULL) {
30022ce4:	ea000002 	b	30022cf4 <etharp_query+0x3f8>
              r = r->next;
30022ce8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30022cec:	e5933000 	ldr	r3, [r3]
30022cf0:	e58d3024 	str	r3, [sp, #36]	; 0x24
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
30022cf4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30022cf8:	e5933000 	ldr	r3, [r3]
30022cfc:	e3530000 	cmp	r3, #0
30022d00:	1afffff8 	bne	30022ce8 <etharp_query+0x3ec>
              r = r->next;
            }
            r->next = new_entry;
30022d04:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30022d08:	e59d2020 	ldr	r2, [sp, #32]
30022d0c:	e5832000 	str	r2, [r3]
30022d10:	ea000008 	b	30022d38 <etharp_query+0x43c>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
30022d14:	e1dd21d7 	ldrsb	r2, [sp, #23]
30022d18:	e59f106c 	ldr	r1, [pc, #108]	; 30022d8c <etharp_query+0x490>
30022d1c:	e1a03002 	mov	r3, r2
30022d20:	e1a03103 	lsl	r3, r3, #2
30022d24:	e0833002 	add	r3, r3, r2
30022d28:	e1a03103 	lsl	r3, r3, #2
30022d2c:	e0833001 	add	r3, r3, r1
30022d30:	e59d2020 	ldr	r2, [sp, #32]
30022d34:	e5832000 	str	r2, [r3]
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
30022d38:	e3a03000 	mov	r3, #0
30022d3c:	e5cd3016 	strb	r3, [sp, #22]
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
30022d40:	ea000009 	b	30022d6c <etharp_query+0x470>
30022d44:	e59d0018 	ldr	r0, [sp, #24]
30022d48:	ebffcd4c 	bl	30016280 <pbuf_free>
30022d4c:	ea000006 	b	30022d6c <etharp_query+0x470>
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
          /* { result == ERR_MEM } through initialization */
        }
      } else {
        ETHARP_STATS_INC(etharp.memerr);
30022d50:	e59f3030 	ldr	r3, [pc, #48]	; 30022d88 <etharp_query+0x48c>
30022d54:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
30022d58:	e2833001 	add	r3, r3, #1
30022d5c:	e1a03803 	lsl	r3, r3, #16
30022d60:	e1a02823 	lsr	r2, r3, #16
30022d64:	e59f301c 	ldr	r3, [pc, #28]	; 30022d88 <etharp_query+0x48c>
30022d68:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
      /* { result == ERR_MEM } through initialization */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
30022d6c:	e5dd3016 	ldrb	r3, [sp, #22]
30022d70:	e1a03c03 	lsl	r3, r3, #24
30022d74:	e1a03c43 	asr	r3, r3, #24
}
30022d78:	e1a00003 	mov	r0, r3
30022d7c:	e28dd028 	add	sp, sp, #40	; 0x28
30022d80:	e8bd4010 	pop	{r4, lr}
30022d84:	e12fff1e 	bx	lr
30022d88:	302be570 	.word	0x302be570
30022d8c:	300e3bf0 	.word	0x300e3bf0

30022d90 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const struct ip_addr *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const struct ip_addr *ipdst_addr,
           const u16_t opcode)
{
30022d90:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30022d94:	e24dd024 	sub	sp, sp, #36	; 0x24
30022d98:	e58d000c 	str	r0, [sp, #12]
30022d9c:	e58d1008 	str	r1, [sp, #8]
30022da0:	e58d2004 	str	r2, [sp, #4]
30022da4:	e58d3000 	str	r3, [sp]
  struct pbuf *p;
  err_t result = ERR_OK;
30022da8:	e3a03000 	mov	r3, #0
30022dac:	e5cd301a 	strb	r3, [sp, #26]
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
30022db0:	e3a00002 	mov	r0, #2
30022db4:	e3a0102a 	mov	r1, #42	; 0x2a
30022db8:	e3a02000 	mov	r2, #0
30022dbc:	ebffcb7d 	bl	30015bb8 <pbuf_alloc>
30022dc0:	e1a03000 	mov	r3, r0
30022dc4:	e58d3014 	str	r3, [sp, #20]
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
30022dc8:	e59d3014 	ldr	r3, [sp, #20]
30022dcc:	e3530000 	cmp	r3, #0
30022dd0:	1a000008 	bne	30022df8 <etharp_raw+0x68>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
30022dd4:	e59f32a4 	ldr	r3, [pc, #676]	; 30023080 <etharp_raw+0x2f0>
30022dd8:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
30022ddc:	e2833001 	add	r3, r3, #1
30022de0:	e1a03803 	lsl	r3, r3, #16
30022de4:	e1a02823 	lsr	r2, r3, #16
30022de8:	e59f3290 	ldr	r3, [pc, #656]	; 30023080 <etharp_raw+0x2f0>
30022dec:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
    return ERR_MEM;
30022df0:	e3a030ff 	mov	r3, #255	; 0xff
30022df4:	ea00009b 	b	30023068 <etharp_raw+0x2d8>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
30022df8:	e59d3014 	ldr	r3, [sp, #20]
30022dfc:	e5933004 	ldr	r3, [r3, #4]
30022e00:	e58d301c 	str	r3, [sp, #28]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
30022e04:	e1dd33b4 	ldrh	r3, [sp, #52]	; 0x34
30022e08:	e1a00003 	mov	r0, r3
30022e0c:	ebffc1fb 	bl	30013600 <htons>
30022e10:	e1a03000 	mov	r3, r0
30022e14:	e1a02003 	mov	r2, r3
30022e18:	e59d301c 	ldr	r3, [sp, #28]
30022e1c:	e20210ff 	and	r1, r2, #255	; 0xff
30022e20:	e3a00000 	mov	r0, #0
30022e24:	e1801001 	orr	r1, r0, r1
30022e28:	e5c31014 	strb	r1, [r3, #20]
30022e2c:	e1a02422 	lsr	r2, r2, #8
30022e30:	e1a02802 	lsl	r2, r2, #16
30022e34:	e1a02822 	lsr	r2, r2, #16
30022e38:	e3a01000 	mov	r1, #0
30022e3c:	e1812002 	orr	r2, r1, r2
30022e40:	e5c32015 	strb	r2, [r3, #21]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
30022e44:	e3a03006 	mov	r3, #6
30022e48:	e5cd301b 	strb	r3, [sp, #27]
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
30022e4c:	ea000023 	b	30022ee0 <etharp_raw+0x150>
    k--;
30022e50:	e5dd301b 	ldrb	r3, [sp, #27]
30022e54:	e2433001 	sub	r3, r3, #1
30022e58:	e5cd301b 	strb	r3, [sp, #27]
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
30022e5c:	e5dd001b 	ldrb	r0, [sp, #27]
30022e60:	e5dd301b 	ldrb	r3, [sp, #27]
30022e64:	e59d2000 	ldr	r2, [sp]
30022e68:	e7d22003 	ldrb	r2, [r2, r3]
30022e6c:	e59d101c 	ldr	r1, [sp, #28]
30022e70:	e3a03016 	mov	r3, #22
30022e74:	e0801001 	add	r1, r0, r1
30022e78:	e0813003 	add	r3, r1, r3
30022e7c:	e5c32000 	strb	r2, [r3]
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
30022e80:	e5dd001b 	ldrb	r0, [sp, #27]
30022e84:	e5dd301b 	ldrb	r3, [sp, #27]
30022e88:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30022e8c:	e7d22003 	ldrb	r2, [r2, r3]
30022e90:	e59d101c 	ldr	r1, [sp, #28]
30022e94:	e3a03020 	mov	r3, #32
30022e98:	e0801001 	add	r1, r0, r1
30022e9c:	e0813003 	add	r3, r1, r3
30022ea0:	e5c32000 	strb	r2, [r3]
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
30022ea4:	e5dd301b 	ldrb	r3, [sp, #27]
30022ea8:	e5dd201b 	ldrb	r2, [sp, #27]
30022eac:	e59d1004 	ldr	r1, [sp, #4]
30022eb0:	e7d11002 	ldrb	r1, [r1, r2]
30022eb4:	e59d201c 	ldr	r2, [sp, #28]
30022eb8:	e7c21003 	strb	r1, [r2, r3]
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
30022ebc:	e5dd001b 	ldrb	r0, [sp, #27]
30022ec0:	e5dd301b 	ldrb	r3, [sp, #27]
30022ec4:	e59d2008 	ldr	r2, [sp, #8]
30022ec8:	e7d22003 	ldrb	r2, [r2, r3]
30022ecc:	e59d101c 	ldr	r1, [sp, #28]
30022ed0:	e3a03006 	mov	r3, #6
30022ed4:	e0801001 	add	r1, r0, r1
30022ed8:	e0813003 	add	r3, r1, r3
30022edc:	e5c32000 	strb	r2, [r3]
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
30022ee0:	e5dd301b 	ldrb	r3, [sp, #27]
30022ee4:	e3530000 	cmp	r3, #0
30022ee8:	1affffd8 	bne	30022e50 <etharp_raw+0xc0>
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  //by pegasus0824
  //hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  //hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  SMEMCPY(&hdr->sipaddr, (struct ip_addr2 *)ipsrc_addr, sizeof(hdr->sipaddr));
30022eec:	e59d301c 	ldr	r3, [sp, #28]
30022ef0:	e283301c 	add	r3, r3, #28
30022ef4:	e1a00003 	mov	r0, r3
30022ef8:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
30022efc:	e3a02004 	mov	r2, #4
30022f00:	ebffa4f5 	bl	3000c2dc <acoral_memcpy>
  SMEMCPY(&hdr->dipaddr, (struct ip_addr2 *)ipdst_addr, sizeof(hdr->dipaddr));
30022f04:	e59d301c 	ldr	r3, [sp, #28]
30022f08:	e2833026 	add	r3, r3, #38	; 0x26
30022f0c:	e1a00003 	mov	r0, r3
30022f10:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
30022f14:	e3a02004 	mov	r2, #4
30022f18:	ebffa4ef 	bl	3000c2dc <acoral_memcpy>


  hdr->hwtype = htons(HWTYPE_ETHERNET);
30022f1c:	e3a00001 	mov	r0, #1
30022f20:	ebffc1b6 	bl	30013600 <htons>
30022f24:	e1a03000 	mov	r3, r0
30022f28:	e1a02003 	mov	r2, r3
30022f2c:	e59d301c 	ldr	r3, [sp, #28]
30022f30:	e20210ff 	and	r1, r2, #255	; 0xff
30022f34:	e3a00000 	mov	r0, #0
30022f38:	e1801001 	orr	r1, r0, r1
30022f3c:	e5c3100e 	strb	r1, [r3, #14]
30022f40:	e1a02422 	lsr	r2, r2, #8
30022f44:	e1a02802 	lsl	r2, r2, #16
30022f48:	e1a02822 	lsr	r2, r2, #16
30022f4c:	e3a01000 	mov	r1, #0
30022f50:	e1812002 	orr	r2, r1, r2
30022f54:	e5c3200f 	strb	r2, [r3, #15]
  hdr->proto = htons(ETHTYPE_IP);
30022f58:	e3a00b02 	mov	r0, #2048	; 0x800
30022f5c:	ebffc1a7 	bl	30013600 <htons>
30022f60:	e1a03000 	mov	r3, r0
30022f64:	e1a02003 	mov	r2, r3
30022f68:	e59d301c 	ldr	r3, [sp, #28]
30022f6c:	e20210ff 	and	r1, r2, #255	; 0xff
30022f70:	e3a00000 	mov	r0, #0
30022f74:	e1801001 	orr	r1, r0, r1
30022f78:	e5c31010 	strb	r1, [r3, #16]
30022f7c:	e1a02422 	lsr	r2, r2, #8
30022f80:	e1a02802 	lsl	r2, r2, #16
30022f84:	e1a02822 	lsr	r2, r2, #16
30022f88:	e3a01000 	mov	r1, #0
30022f8c:	e1812002 	orr	r2, r1, r2
30022f90:	e5c32011 	strb	r2, [r3, #17]
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
30022f94:	e3a00c06 	mov	r0, #1536	; 0x600
30022f98:	e2800004 	add	r0, r0, #4
30022f9c:	ebffc197 	bl	30013600 <htons>
30022fa0:	e1a03000 	mov	r3, r0
30022fa4:	e1a02003 	mov	r2, r3
30022fa8:	e59d301c 	ldr	r3, [sp, #28]
30022fac:	e20210ff 	and	r1, r2, #255	; 0xff
30022fb0:	e3a00000 	mov	r0, #0
30022fb4:	e1801001 	orr	r1, r0, r1
30022fb8:	e5c31012 	strb	r1, [r3, #18]
30022fbc:	e1a02422 	lsr	r2, r2, #8
30022fc0:	e1a02802 	lsl	r2, r2, #16
30022fc4:	e1a02822 	lsr	r2, r2, #16
30022fc8:	e3a01000 	mov	r1, #0
30022fcc:	e1812002 	orr	r2, r1, r2
30022fd0:	e5c32013 	strb	r2, [r3, #19]

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
30022fd4:	e3a00b02 	mov	r0, #2048	; 0x800
30022fd8:	e2800006 	add	r0, r0, #6
30022fdc:	ebffc187 	bl	30013600 <htons>
30022fe0:	e1a03000 	mov	r3, r0
30022fe4:	e1a02003 	mov	r2, r3
30022fe8:	e59d301c 	ldr	r3, [sp, #28]
30022fec:	e20210ff 	and	r1, r2, #255	; 0xff
30022ff0:	e3a00000 	mov	r0, #0
30022ff4:	e1801001 	orr	r1, r0, r1
30022ff8:	e5c3100c 	strb	r1, [r3, #12]
30022ffc:	e1a02422 	lsr	r2, r2, #8
30023000:	e1a02802 	lsl	r2, r2, #16
30023004:	e1a02822 	lsr	r2, r2, #16
30023008:	e3a01000 	mov	r1, #0
3002300c:	e1812002 	orr	r2, r1, r2
30023010:	e5c3200d 	strb	r2, [r3, #13]
  /* send ARP query */
  result = netif->linkoutput(netif, p);
30023014:	e59d300c 	ldr	r3, [sp, #12]
30023018:	e5933018 	ldr	r3, [r3, #24]
3002301c:	e59d000c 	ldr	r0, [sp, #12]
30023020:	e59d1014 	ldr	r1, [sp, #20]
30023024:	e1a0e00f 	mov	lr, pc
30023028:	e12fff13 	bx	r3
3002302c:	e1a03000 	mov	r3, r0
30023030:	e20330ff 	and	r3, r3, #255	; 0xff
30023034:	e5cd301a 	strb	r3, [sp, #26]
  ETHARP_STATS_INC(etharp.xmit);
30023038:	e59f3040 	ldr	r3, [pc, #64]	; 30023080 <etharp_raw+0x2f0>
3002303c:	e1d331ba 	ldrh	r3, [r3, #26]
30023040:	e2833001 	add	r3, r3, #1
30023044:	e1a03803 	lsl	r3, r3, #16
30023048:	e1a02823 	lsr	r2, r3, #16
3002304c:	e59f302c 	ldr	r3, [pc, #44]	; 30023080 <etharp_raw+0x2f0>
30023050:	e1c321ba 	strh	r2, [r3, #26]
  /* free ARP query packet */
  pbuf_free(p);
30023054:	e59d0014 	ldr	r0, [sp, #20]
30023058:	ebffcc88 	bl	30016280 <pbuf_free>
  p = NULL;
3002305c:	e3a03000 	mov	r3, #0
30023060:	e58d3014 	str	r3, [sp, #20]
  /* could not allocate pbuf for ARP request */

  return result;
30023064:	e5dd301a 	ldrb	r3, [sp, #26]
30023068:	e1a03c03 	lsl	r3, r3, #24
3002306c:	e1a03c43 	asr	r3, r3, #24
}
30023070:	e1a00003 	mov	r0, r3
30023074:	e28dd024 	add	sp, sp, #36	; 0x24
30023078:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002307c:	e12fff1e 	bx	lr
30023080:	302be570 	.word	0x302be570

30023084 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
30023084:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023088:	e24dd01c 	sub	sp, sp, #28
3002308c:	e58d0014 	str	r0, [sp, #20]
30023090:	e58d1010 	str	r1, [sp, #16]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
30023094:	e59d3014 	ldr	r3, [sp, #20]
30023098:	e2833021 	add	r3, r3, #33	; 0x21
3002309c:	e1a02003 	mov	r2, r3
300230a0:	e59d3014 	ldr	r3, [sp, #20]
300230a4:	e2833021 	add	r3, r3, #33	; 0x21
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
300230a8:	e59d1014 	ldr	r1, [sp, #20]
300230ac:	e2811004 	add	r1, r1, #4
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
300230b0:	e58d1000 	str	r1, [sp]
300230b4:	e59f1044 	ldr	r1, [pc, #68]	; 30023100 <etharp_request+0x7c>
300230b8:	e58d1004 	str	r1, [sp, #4]
300230bc:	e59d1010 	ldr	r1, [sp, #16]
300230c0:	e58d1008 	str	r1, [sp, #8]
300230c4:	e3a01001 	mov	r1, #1
300230c8:	e58d100c 	str	r1, [sp, #12]
300230cc:	e59d0014 	ldr	r0, [sp, #20]
300230d0:	e1a01002 	mov	r1, r2
300230d4:	e59f2028 	ldr	r2, [pc, #40]	; 30023104 <etharp_request+0x80>
300230d8:	ebffff2c 	bl	30022d90 <etharp_raw>
300230dc:	e1a03000 	mov	r3, r0
300230e0:	e20330ff 	and	r3, r3, #255	; 0xff
300230e4:	e20330ff 	and	r3, r3, #255	; 0xff
300230e8:	e1a03c03 	lsl	r3, r3, #24
300230ec:	e1a03c43 	asr	r3, r3, #24
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
300230f0:	e1a00003 	mov	r0, r3
300230f4:	e28dd01c 	add	sp, sp, #28
300230f8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300230fc:	e12fff1e 	bx	lr
30023100:	30045758 	.word	0x30045758
30023104:	30045750 	.word	0x30045750

30023108 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
30023108:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002310c:	e24dd014 	sub	sp, sp, #20
30023110:	e58d0004 	str	r0, [sp, #4]
30023114:	e58d1000 	str	r1, [sp]
  struct eth_hdr* ethhdr;

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
30023118:	e59d3004 	ldr	r3, [sp, #4]
3002311c:	e5933004 	ldr	r3, [r3, #4]
30023120:	e58d300c 	str	r3, [sp, #12]
  
  switch (htons(ethhdr->type)) {
30023124:	e59d300c 	ldr	r3, [sp, #12]
30023128:	e5d3200c 	ldrb	r2, [r3, #12]
3002312c:	e5d3300d 	ldrb	r3, [r3, #13]
30023130:	e1a03403 	lsl	r3, r3, #8
30023134:	e1833002 	orr	r3, r3, r2
30023138:	e1a03803 	lsl	r3, r3, #16
3002313c:	e1a03823 	lsr	r3, r3, #16
30023140:	e1a00003 	mov	r0, r3
30023144:	ebffc12d 	bl	30013600 <htons>
30023148:	e1a03000 	mov	r3, r0
3002314c:	e1a02003 	mov	r2, r3
30023150:	e3520b02 	cmp	r2, #2048	; 0x800
30023154:	0a000004 	beq	3002316c <ethernet_input+0x64>
30023158:	e3a03b02 	mov	r3, #2048	; 0x800
3002315c:	e2833006 	add	r3, r3, #6
30023160:	e1520003 	cmp	r2, r3
30023164:	0a00001c 	beq	300231dc <ethernet_input+0xd4>
30023168:	ea000022 	b	300231f8 <ethernet_input+0xf0>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
3002316c:	e59d0000 	ldr	r0, [sp]
30023170:	e59d1004 	ldr	r1, [sp, #4]
30023174:	ebfffbff 	bl	30022178 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
30023178:	e59d0004 	ldr	r0, [sp, #4]
3002317c:	e3e0100d 	mvn	r1, #13
30023180:	ebffcbd9 	bl	300160ec <pbuf_header>
30023184:	e1a03000 	mov	r3, r0
30023188:	e3530000 	cmp	r3, #0
3002318c:	0a00000e 	beq	300231cc <ethernet_input+0xc4>
        LWIP_ASSERT("Can't move over header in packet", 0);
        acoral_debug("\nethernet_input1 == %d\n", ++pbuf_release);
30023190:	e59f30b4 	ldr	r3, [pc, #180]	; 3002324c <ethernet_input+0x144>
30023194:	e5933000 	ldr	r3, [r3]
30023198:	e2832001 	add	r2, r3, #1
3002319c:	e59f30a8 	ldr	r3, [pc, #168]	; 3002324c <ethernet_input+0x144>
300231a0:	e5832000 	str	r2, [r3]
300231a4:	e59f30a0 	ldr	r3, [pc, #160]	; 3002324c <ethernet_input+0x144>
300231a8:	e5933000 	ldr	r3, [r3]
300231ac:	e59f009c 	ldr	r0, [pc, #156]	; 30023250 <ethernet_input+0x148>
300231b0:	e1a01003 	mov	r1, r3
300231b4:	ebffa084 	bl	3000b3cc <acoral_debug>
        pbuf_free(p);
300231b8:	e59d0004 	ldr	r0, [sp, #4]
300231bc:	ebffcc2f 	bl	30016280 <pbuf_free>
        p = NULL;
300231c0:	e3a03000 	mov	r3, #0
300231c4:	e58d3004 	str	r3, [sp, #4]
      } else {
		//acoral_prints("\nip_input:ethernet_input_enter\n");
        ip_input(p, netif);
        //acoral_prints("\nip_input:ethernet_input_exit\n");
      }
      break;
300231c8:	ea000018 	b	30023230 <ethernet_input+0x128>
        acoral_debug("\nethernet_input1 == %d\n", ++pbuf_release);
        pbuf_free(p);
        p = NULL;
      } else {
		//acoral_prints("\nip_input:ethernet_input_enter\n");
        ip_input(p, netif);
300231cc:	e59d0004 	ldr	r0, [sp, #4]
300231d0:	e59d1000 	ldr	r1, [sp]
300231d4:	ebffc3a3 	bl	30014068 <ip_input>
        //acoral_prints("\nip_input:ethernet_input_exit\n");
      }
      break;
300231d8:	ea000014 	b	30023230 <ethernet_input+0x128>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
300231dc:	e59d3000 	ldr	r3, [sp]
300231e0:	e2833021 	add	r3, r3, #33	; 0x21
300231e4:	e59d0000 	ldr	r0, [sp]
300231e8:	e1a01003 	mov	r1, r3
300231ec:	e59d2004 	ldr	r2, [sp, #4]
300231f0:	ebfffc09 	bl	3002221c <etharp_arp_input>
      break;
300231f4:	ea00000d 	b	30023230 <ethernet_input+0x128>
      pppoe_data_input(netif, p);
      break;
#endif /* PPPOE_SUPPORT */

    default:
      acoral_debug("\nethernet_input2 == %d\n", ++pbuf_release);
300231f8:	e59f304c 	ldr	r3, [pc, #76]	; 3002324c <ethernet_input+0x144>
300231fc:	e5933000 	ldr	r3, [r3]
30023200:	e2832001 	add	r2, r3, #1
30023204:	e59f3040 	ldr	r3, [pc, #64]	; 3002324c <ethernet_input+0x144>
30023208:	e5832000 	str	r2, [r3]
3002320c:	e59f3038 	ldr	r3, [pc, #56]	; 3002324c <ethernet_input+0x144>
30023210:	e5933000 	ldr	r3, [r3]
30023214:	e59f0038 	ldr	r0, [pc, #56]	; 30023254 <ethernet_input+0x14c>
30023218:	e1a01003 	mov	r1, r3
3002321c:	ebffa06a 	bl	3000b3cc <acoral_debug>
      pbuf_free(p);
30023220:	e59d0004 	ldr	r0, [sp, #4]
30023224:	ebffcc15 	bl	30016280 <pbuf_free>
      p = NULL;
30023228:	e3a03000 	mov	r3, #0
3002322c:	e58d3004 	str	r3, [sp, #4]
      break;
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
30023230:	e3a03000 	mov	r3, #0
30023234:	e1a03c03 	lsl	r3, r3, #24
30023238:	e1a03c43 	asr	r3, r3, #24
}
3002323c:	e1a00003 	mov	r0, r3
30023240:	e28dd014 	add	sp, sp, #20
30023244:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023248:	e12fff1e 	bx	lr
3002324c:	300ca5e0 	.word	0x300ca5e0
30023250:	30045760 	.word	0x30045760
30023254:	30045778 	.word	0x30045778

30023258 <low_level_init>:
 * @param netif the already initialized lwip network interface structure
 *        for this ethernetif
 */
static void
low_level_init(struct netif *netif)
{
30023258:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002325c:	e24dd00c 	sub	sp, sp, #12
30023260:	e58d0004 	str	r0, [sp, #4]
	/* set MAC hardware address length */
	netif->hwaddr_len = ETHARP_HWADDR_LEN;
30023264:	e59d3004 	ldr	r3, [sp, #4]
30023268:	e3a02006 	mov	r2, #6
3002326c:	e5c32020 	strb	r2, [r3, #32]

	/* set MAC hardware address */
	/* MAC地址 */
	netif->hwaddr[0] = 0x00;
30023270:	e59d3004 	ldr	r3, [sp, #4]
30023274:	e3a02000 	mov	r2, #0
30023278:	e5c32021 	strb	r2, [r3, #33]	; 0x21
	netif->hwaddr[1] = 0x11;
3002327c:	e59d3004 	ldr	r3, [sp, #4]
30023280:	e3a02011 	mov	r2, #17
30023284:	e5c32022 	strb	r2, [r3, #34]	; 0x22
	netif->hwaddr[2] = 0x22;
30023288:	e59d3004 	ldr	r3, [sp, #4]
3002328c:	e3a02022 	mov	r2, #34	; 0x22
30023290:	e5c32023 	strb	r2, [r3, #35]	; 0x23
	netif->hwaddr[3] = 0x33;
30023294:	e59d3004 	ldr	r3, [sp, #4]
30023298:	e3a02033 	mov	r2, #51	; 0x33
3002329c:	e5c32024 	strb	r2, [r3, #36]	; 0x24
	netif->hwaddr[4] = 0x44;     
300232a0:	e59d3004 	ldr	r3, [sp, #4]
300232a4:	e3a02044 	mov	r2, #68	; 0x44
300232a8:	e5c32025 	strb	r2, [r3, #37]	; 0x25
	netif->hwaddr[5] = 0x55;
300232ac:	e59d3004 	ldr	r3, [sp, #4]
300232b0:	e3a02055 	mov	r2, #85	; 0x55
300232b4:	e5c32026 	strb	r2, [r3, #38]	; 0x26

	/* maximum transfer unit */
	/* 最大传输单元 */
	netif->mtu = 1500;
300232b8:	e59d2004 	ldr	r2, [sp, #4]
300232bc:	e3a03e5d 	mov	r3, #1488	; 0x5d0
300232c0:	e283300c 	add	r3, r3, #12
300232c4:	e1c232b8 	strh	r3, [r2, #40]	; 0x28
  
	/* device capabilities */
	/* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
	netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
300232c8:	e59d3004 	ldr	r3, [sp, #4]
300232cc:	e3a02032 	mov	r2, #50	; 0x32
300232d0:	e5c3202a 	strb	r2, [r3, #42]	; 0x2a
	/* 初始化enc28j60 */
	
	// pegasus0809
	// hw_init(netif->hwaddr);
		
	net_dev_id = acoral_dev_open("netdev");
300232d4:	e59f0058 	ldr	r0, [pc, #88]	; 30023334 <low_level_init+0xdc>
300232d8:	eb0074c1 	bl	300405e4 <acoral_dev_open>
300232dc:	e1a02000 	mov	r2, r0
300232e0:	e59f3050 	ldr	r3, [pc, #80]	; 30023338 <low_level_init+0xe0>
300232e4:	e5832000 	str	r2, [r3]
	if (net_dev_id == ACORAL_DEV_ERR_ID)
300232e8:	e59f3048 	ldr	r3, [pc, #72]	; 30023338 <low_level_init+0xe0>
300232ec:	e5933000 	ldr	r3, [r3]
300232f0:	e3730001 	cmn	r3, #1
300232f4:	1a000002 	bne	30023304 <low_level_init+0xac>
	{
		acoral_printerr("Not Found Net Device\n");
300232f8:	e59f003c 	ldr	r0, [pc, #60]	; 3002333c <low_level_init+0xe4>
300232fc:	ebff9fcf 	bl	3000b240 <acoral_print>
		return;
30023300:	ea000008 	b	30023328 <low_level_init+0xd0>
	}
	acoral_dev_config(net_dev_id, NET_DEV_INIT, netif->hwaddr, 0);
30023304:	e59f302c 	ldr	r3, [pc, #44]	; 30023338 <low_level_init+0xe0>
30023308:	e5932000 	ldr	r2, [r3]
3002330c:	e59d3004 	ldr	r3, [sp, #4]
30023310:	e2833021 	add	r3, r3, #33	; 0x21
30023314:	e1a00002 	mov	r0, r2
30023318:	e3a01001 	mov	r1, #1
3002331c:	e1a02003 	mov	r2, r3
30023320:	e3a03000 	mov	r3, #0
30023324:	eb00751f 	bl	300407a8 <acoral_dev_config>
}
30023328:	e28dd00c 	add	sp, sp, #12
3002332c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023330:	e12fff1e 	bx	lr
30023334:	30045790 	.word	0x30045790
30023338:	300466c8 	.word	0x300466c8
3002333c:	30045798 	.word	0x30045798

30023340 <low_level_output>:
 *       to become availale since the stack doesn't retry to send a packet
 *       dropped because of memory failure (except for the TCP timers).
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
30023340:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023344:	e24dd014 	sub	sp, sp, #20
30023348:	e58d000c 	str	r0, [sp, #12]
3002334c:	e58d1008 	str	r1, [sp, #8]
#if ETH_PAD_SIZE
	pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
#endif
	//acoral_prints("\r\nlowLOutput=sta\r\n");
	//hw_sendPacket(p);
	acoral_dev_write(net_dev_id, p, 0, 0, 0);
30023350:	e59f3054 	ldr	r3, [pc, #84]	; 300233ac <low_level_output+0x6c>
30023354:	e5933000 	ldr	r3, [r3]
30023358:	e3a02000 	mov	r2, #0
3002335c:	e58d2000 	str	r2, [sp]
30023360:	e1a00003 	mov	r0, r3
30023364:	e59d1008 	ldr	r1, [sp, #8]
30023368:	e3a02000 	mov	r2, #0
3002336c:	e3a03000 	mov	r3, #0
30023370:	eb0074c0 	bl	30040678 <acoral_dev_write>
	//acoral_prints("\r\nlowLOutput=end\r\n");
#if ETH_PAD_SIZE
	pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
#endif
  
	LINK_STATS_INC(link.xmit);
30023374:	e59f3034 	ldr	r3, [pc, #52]	; 300233b0 <low_level_output+0x70>
30023378:	e1d330b0 	ldrh	r3, [r3]
3002337c:	e2833001 	add	r3, r3, #1
30023380:	e1a03803 	lsl	r3, r3, #16
30023384:	e1a02823 	lsr	r2, r3, #16
30023388:	e59f3020 	ldr	r3, [pc, #32]	; 300233b0 <low_level_output+0x70>
3002338c:	e1c320b0 	strh	r2, [r3]

	return ERR_OK;
30023390:	e3a03000 	mov	r3, #0
30023394:	e1a03c03 	lsl	r3, r3, #24
30023398:	e1a03c43 	asr	r3, r3, #24
}
3002339c:	e1a00003 	mov	r0, r3
300233a0:	e28dd014 	add	sp, sp, #20
300233a4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300233a8:	e12fff1e 	bx	lr
300233ac:	300466c8 	.word	0x300466c8
300233b0:	302be570 	.word	0x302be570

300233b4 <ethernetif_input>:
 * the appropriate input function is called.
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
void ethernetif_input(void *arg)
{
300233b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300233b8:	e24dd024 	sub	sp, sp, #36	; 0x24
300233bc:	e58d000c 	str	r0, [sp, #12]
	struct eth_hdr *ethhdr;
	struct pbuf *p;
	
	struct netif *netif = (struct netif *)arg;
300233c0:	e59d300c 	ldr	r3, [sp, #12]
300233c4:	e58d301c 	str	r3, [sp, #28]
	
	if(net_dev_id==ACORAL_DEV_ERR_ID)
300233c8:	e59f30fc 	ldr	r3, [pc, #252]	; 300234cc <ethernetif_input+0x118>
300233cc:	e5933000 	ldr	r3, [r3]
300233d0:	e3730001 	cmn	r3, #1
300233d4:	0a000039 	beq	300234c0 <ethernetif_input+0x10c>
	do
	{
		/* move received packet into a new pbuf */
		//p = hw_getPacket(/*netif,*/ &flag);
		
		acoral_dev_read(net_dev_id, &p, 0, 0,0);
300233d8:	e59f30ec 	ldr	r3, [pc, #236]	; 300234cc <ethernetif_input+0x118>
300233dc:	e5932000 	ldr	r2, [r3]
300233e0:	e28d3014 	add	r3, sp, #20
300233e4:	e3a01000 	mov	r1, #0
300233e8:	e58d1000 	str	r1, [sp]
300233ec:	e1a00002 	mov	r0, r2
300233f0:	e1a01003 	mov	r1, r3
300233f4:	e3a02000 	mov	r2, #0
300233f8:	e3a03000 	mov	r3, #0
300233fc:	eb0074c3 	bl	30040710 <acoral_dev_read>
		
		/* no packet could be read, silently ignore this */
		if (p == NULL) 
30023400:	e59d3014 	ldr	r3, [sp, #20]
30023404:	e3530000 	cmp	r3, #0
30023408:	1a000000 	bne	30023410 <ethernetif_input+0x5c>
			continue;
3002340c:	ea00002a 	b	300234bc <ethernetif_input+0x108>
		/* points to packet payload, which starts with an Ethernet header */
		ethhdr = p->payload;
30023410:	e59d3014 	ldr	r3, [sp, #20]
30023414:	e5933004 	ldr	r3, [r3, #4]
30023418:	e58d3018 	str	r3, [sp, #24]

		switch (htons(ethhdr->type)) 
3002341c:	e59d3018 	ldr	r3, [sp, #24]
30023420:	e5d3200c 	ldrb	r2, [r3, #12]
30023424:	e5d3300d 	ldrb	r3, [r3, #13]
30023428:	e1a03403 	lsl	r3, r3, #8
3002342c:	e1833002 	orr	r3, r3, r2
30023430:	e1a03803 	lsl	r3, r3, #16
30023434:	e1a03823 	lsr	r3, r3, #16
30023438:	e1a00003 	mov	r0, r3
3002343c:	ebffc06f 	bl	30013600 <htons>
30023440:	e1a03000 	mov	r3, r0
30023444:	e1a02003 	mov	r2, r3
30023448:	e3520b02 	cmp	r2, #2048	; 0x800
3002344c:	0a000003 	beq	30023460 <ethernetif_input+0xac>
30023450:	e3a03b02 	mov	r3, #2048	; 0x800
30023454:	e2833006 	add	r3, r3, #6
30023458:	e1520003 	cmp	r2, r3
3002345c:	1a000010 	bne	300234a4 <ethernetif_input+0xf0>
			/* PPPoE packet? */
			case ETHTYPE_PPPOEDISC:
			case ETHTYPE_PPPOE:
			#endif /* PPPOE_SUPPORT */
			/* full packet send to tcpip_thread to process */
			if (netif->input(p, netif)!=ERR_OK)
30023460:	e59d301c 	ldr	r3, [sp, #28]
30023464:	e5933010 	ldr	r3, [r3, #16]
30023468:	e59d2014 	ldr	r2, [sp, #20]
3002346c:	e1a00002 	mov	r0, r2
30023470:	e59d101c 	ldr	r1, [sp, #28]
30023474:	e1a0e00f 	mov	lr, pc
30023478:	e12fff13 	bx	r3
3002347c:	e1a03000 	mov	r3, r0
30023480:	e20330ff 	and	r3, r3, #255	; 0xff
30023484:	e3530000 	cmp	r3, #0
30023488:	0a000004 	beq	300234a0 <ethernetif_input+0xec>
			{ 
				
				LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
				pbuf_free(p);
3002348c:	e59d3014 	ldr	r3, [sp, #20]
30023490:	e1a00003 	mov	r0, r3
30023494:	ebffcb79 	bl	30016280 <pbuf_free>
                               // acoral_delay_self(400); 
				p = NULL;
30023498:	e3a03000 	mov	r3, #0
3002349c:	e58d3014 	str	r3, [sp, #20]
			}
			break;
300234a0:	ea000005 	b	300234bc <ethernetif_input+0x108>

		    default:
			pbuf_free(p);
300234a4:	e59d3014 	ldr	r3, [sp, #20]
300234a8:	e1a00003 	mov	r0, r3
300234ac:	ebffcb73 	bl	30016280 <pbuf_free>
			p = NULL;
300234b0:	e3a03000 	mov	r3, #0
300234b4:	e58d3014 	str	r3, [sp, #20]
			break;
		}
	}while(1);
300234b8:	eaffffc6 	b	300233d8 <ethernetif_input+0x24>
300234bc:	eaffffc5 	b	300233d8 <ethernetif_input+0x24>
}
300234c0:	e28dd024 	add	sp, sp, #36	; 0x24
300234c4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300234c8:	e12fff1e 	bx	lr
300234cc:	300466c8 	.word	0x300466c8

300234d0 <ethernetif_init>:
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t 
ethernetif_init(struct netif *netif)
{
300234d0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300234d4:	e24dd014 	sub	sp, sp, #20
300234d8:	e58d0004 	str	r0, [sp, #4]
	struct ethernetif *ethernetif;


	LWIP_ASSERT("netif != NULL", (netif != NULL));
    
	ethernetif = mem_malloc(sizeof(struct ethernetif));
300234dc:	e3a00004 	mov	r0, #4
300234e0:	ebfff6cb 	bl	30021014 <mem_malloc>
300234e4:	e1a03000 	mov	r3, r0
300234e8:	e58d300c 	str	r3, [sp, #12]
	if (ethernetif == NULL) 
300234ec:	e59d300c 	ldr	r3, [sp, #12]
300234f0:	e3530000 	cmp	r3, #0
300234f4:	1a000001 	bne	30023500 <ethernetif_init+0x30>
	{
		LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
		return ERR_MEM;
300234f8:	e3a030ff 	mov	r3, #255	; 0xff
300234fc:	ea000016 	b	3002355c <ethernetif_init+0x8c>
     * of bits per second.
     */
	//下面这句不知为什么,先注释掉
	//NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, ???);

	netif->state = ethernetif;
30023500:	e59d3004 	ldr	r3, [sp, #4]
30023504:	e59d200c 	ldr	r2, [sp, #12]
30023508:	e583201c 	str	r2, [r3, #28]
	netif->name[0] = IFNAME0;
3002350c:	e59d3004 	ldr	r3, [sp, #4]
30023510:	e3a02065 	mov	r2, #101	; 0x65
30023514:	e5c3202b 	strb	r2, [r3, #43]	; 0x2b
	netif->name[1] = IFNAME1;
30023518:	e59d3004 	ldr	r3, [sp, #4]
3002351c:	e3a0206e 	mov	r2, #110	; 0x6e
30023520:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
	/* We directly use etharp_output() here to save a function call.
     * You can instead declare your own function an call etharp_output()
     * from it if you have to do some checks before sending (e.g. if link
     * is available...) 
	 */
	netif->output = etharp_output;
30023524:	e59d3004 	ldr	r3, [sp, #4]
30023528:	e59f2044 	ldr	r2, [pc, #68]	; 30023574 <ethernetif_init+0xa4>
3002352c:	e5832014 	str	r2, [r3, #20]
	netif->linkoutput = low_level_output;
30023530:	e59d3004 	ldr	r3, [sp, #4]
30023534:	e59f203c 	ldr	r2, [pc, #60]	; 30023578 <ethernetif_init+0xa8>
30023538:	e5832018 	str	r2, [r3, #24]
  
	ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
3002353c:	e59d3004 	ldr	r3, [sp, #4]
30023540:	e2833021 	add	r3, r3, #33	; 0x21
30023544:	e1a02003 	mov	r2, r3
30023548:	e59d300c 	ldr	r3, [sp, #12]
3002354c:	e5832000 	str	r2, [r3]
  
	/* initialize the hardware */
	low_level_init(netif);
30023550:	e59d0004 	ldr	r0, [sp, #4]
30023554:	ebffff3f 	bl	30023258 <low_level_init>

	return ERR_OK;
30023558:	e3a03000 	mov	r3, #0
3002355c:	e1a03c03 	lsl	r3, r3, #24
30023560:	e1a03c43 	asr	r3, r3, #24
}
30023564:	e1a00003 	mov	r0, r3
30023568:	e28dd014 	add	sp, sp, #20
3002356c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023570:	e12fff1e 	bx	lr
30023574:	3002265c 	.word	0x3002265c
30023578:	30023340 	.word	0x30023340

3002357c <StrToFDTName>:
**
** ȫֱ: 
** ģ: 
********************************************************************************************************/
        acoral_u8 StrToFDTName(acoral_char *FDTName, acoral_char *Str)
{
3002357c:	e24dd010 	sub	sp, sp, #16
30023580:	e58d0004 	str	r0, [sp, #4]
30023584:	e58d1000 	str	r1, [sp]
    acoral_u8 i, temp;
    
    /* ļ\Ŀ¼ǷЧ */
    if (Str[0] == 0x20 || Str[0] == 0)
30023588:	e59d3000 	ldr	r3, [sp]
3002358c:	e5d33000 	ldrb	r3, [r3]
30023590:	e3530020 	cmp	r3, #32
30023594:	0a000003 	beq	300235a8 <StrToFDTName+0x2c>
30023598:	e59d3000 	ldr	r3, [sp]
3002359c:	e5d33000 	ldrb	r3, [r3]
300235a0:	e3530000 	cmp	r3, #0
300235a4:	1a000001 	bne	300235b0 <StrToFDTName+0x34>
    {
        return FILE_NAME_ERR; 
300235a8:	e3a03010 	mov	r3, #16
300235ac:	ea000090 	b	300237f4 <StrToFDTName+0x278>
    }

    for (i = 11; i != 0; i--)
300235b0:	e3a0300b 	mov	r3, #11
300235b4:	e5cd300e 	strb	r3, [sp, #14]
300235b8:	ea000008 	b	300235e0 <StrToFDTName+0x64>
    {
        *FDTName++ = 0x20;
300235bc:	e59d3004 	ldr	r3, [sp, #4]
300235c0:	e3a02020 	mov	r2, #32
300235c4:	e5c32000 	strb	r2, [r3]
300235c8:	e59d3004 	ldr	r3, [sp, #4]
300235cc:	e2833001 	add	r3, r3, #1
300235d0:	e58d3004 	str	r3, [sp, #4]
    if (Str[0] == 0x20 || Str[0] == 0)
    {
        return FILE_NAME_ERR; 
    }

    for (i = 11; i != 0; i--)
300235d4:	e5dd300e 	ldrb	r3, [sp, #14]
300235d8:	e2433001 	sub	r3, r3, #1
300235dc:	e5cd300e 	strb	r3, [sp, #14]
300235e0:	e5dd300e 	ldrb	r3, [sp, #14]
300235e4:	e3530000 	cmp	r3, #0
300235e8:	1afffff3 	bne	300235bc <StrToFDTName+0x40>
    {
        *FDTName++ = 0x20;
    }
    FDTName -= 11;
300235ec:	e59d3004 	ldr	r3, [sp, #4]
300235f0:	e243300b 	sub	r3, r3, #11
300235f4:	e58d3004 	str	r3, [sp, #4]
    

    /* ǷΪ"." */
    if (Str[0] == '.')
300235f8:	e59d3000 	ldr	r3, [sp]
300235fc:	e5d33000 	ldrb	r3, [r3]
30023600:	e353002e 	cmp	r3, #46	; 0x2e
30023604:	1a000013 	bne	30023658 <StrToFDTName+0xdc>
    if (Str[1] == 0 || Str[1] == '\\' || Str[1] == '/')
30023608:	e59d3000 	ldr	r3, [sp]
3002360c:	e2833001 	add	r3, r3, #1
30023610:	e5d33000 	ldrb	r3, [r3]
30023614:	e3530000 	cmp	r3, #0
30023618:	0a000009 	beq	30023644 <StrToFDTName+0xc8>
3002361c:	e59d3000 	ldr	r3, [sp]
30023620:	e2833001 	add	r3, r3, #1
30023624:	e5d33000 	ldrb	r3, [r3]
30023628:	e353005c 	cmp	r3, #92	; 0x5c
3002362c:	0a000004 	beq	30023644 <StrToFDTName+0xc8>
30023630:	e59d3000 	ldr	r3, [sp]
30023634:	e2833001 	add	r3, r3, #1
30023638:	e5d33000 	ldrb	r3, [r3]
3002363c:	e353002f 	cmp	r3, #47	; 0x2f
30023640:	1a000004 	bne	30023658 <StrToFDTName+0xdc>
    {
        FDTName[0] = '.';
30023644:	e59d3004 	ldr	r3, [sp, #4]
30023648:	e3a0202e 	mov	r2, #46	; 0x2e
3002364c:	e5c32000 	strb	r2, [r3]
        return RETURN_OK;
30023650:	e3a03000 	mov	r3, #0
30023654:	ea000066 	b	300237f4 <StrToFDTName+0x278>
    }

    /* ǷΪ".." */
    if (Str[0] == '.')
30023658:	e59d3000 	ldr	r3, [sp]
3002365c:	e5d33000 	ldrb	r3, [r3]
30023660:	e353002e 	cmp	r3, #46	; 0x2e
30023664:	1a00001c 	bne	300236dc <StrToFDTName+0x160>
    if (Str[1] == '.' )
30023668:	e59d3000 	ldr	r3, [sp]
3002366c:	e2833001 	add	r3, r3, #1
30023670:	e5d33000 	ldrb	r3, [r3]
30023674:	e353002e 	cmp	r3, #46	; 0x2e
30023678:	1a000017 	bne	300236dc <StrToFDTName+0x160>
    if (Str[2] == 0 || Str[2] == '\\' || Str[2] == '/')
3002367c:	e59d3000 	ldr	r3, [sp]
30023680:	e2833002 	add	r3, r3, #2
30023684:	e5d33000 	ldrb	r3, [r3]
30023688:	e3530000 	cmp	r3, #0
3002368c:	0a000009 	beq	300236b8 <StrToFDTName+0x13c>
30023690:	e59d3000 	ldr	r3, [sp]
30023694:	e2833002 	add	r3, r3, #2
30023698:	e5d33000 	ldrb	r3, [r3]
3002369c:	e353005c 	cmp	r3, #92	; 0x5c
300236a0:	0a000004 	beq	300236b8 <StrToFDTName+0x13c>
300236a4:	e59d3000 	ldr	r3, [sp]
300236a8:	e2833002 	add	r3, r3, #2
300236ac:	e5d33000 	ldrb	r3, [r3]
300236b0:	e353002f 	cmp	r3, #47	; 0x2f
300236b4:	1a000008 	bne	300236dc <StrToFDTName+0x160>
    {
        FDTName[0] = '.';
300236b8:	e59d3004 	ldr	r3, [sp, #4]
300236bc:	e3a0202e 	mov	r2, #46	; 0x2e
300236c0:	e5c32000 	strb	r2, [r3]
        FDTName[1] = '.';
300236c4:	e59d3004 	ldr	r3, [sp, #4]
300236c8:	e2833001 	add	r3, r3, #1
300236cc:	e3a0202e 	mov	r2, #46	; 0x2e
300236d0:	e5c32000 	strb	r2, [r3]
        return RETURN_OK;
300236d4:	e3a03000 	mov	r3, #0
300236d8:	ea000045 	b	300237f4 <StrToFDTName+0x278>
    }
    
    /* ȡļ/Ŀ¼ */
    for (i = 8; i != 0; i--)
300236dc:	e3a03008 	mov	r3, #8
300236e0:	e5cd300e 	strb	r3, [sp, #14]
300236e4:	ea00001a 	b	30023754 <StrToFDTName+0x1d8>
    {
        temp = *Str;
300236e8:	e59d3000 	ldr	r3, [sp]
300236ec:	e5d33000 	ldrb	r3, [r3]
300236f0:	e5cd300f 	strb	r3, [sp, #15]
        if (temp == 0 || temp == '\\' || temp == '/')
300236f4:	e5dd300f 	ldrb	r3, [sp, #15]
300236f8:	e3530000 	cmp	r3, #0
300236fc:	0a000019 	beq	30023768 <StrToFDTName+0x1ec>
30023700:	e5dd300f 	ldrb	r3, [sp, #15]
30023704:	e353005c 	cmp	r3, #92	; 0x5c
30023708:	0a000016 	beq	30023768 <StrToFDTName+0x1ec>
3002370c:	e5dd300f 	ldrb	r3, [sp, #15]
30023710:	e353002f 	cmp	r3, #47	; 0x2f
30023714:	0a000013 	beq	30023768 <StrToFDTName+0x1ec>
        {
            break;
        }
        Str++;
30023718:	e59d3000 	ldr	r3, [sp]
3002371c:	e2833001 	add	r3, r3, #1
30023720:	e58d3000 	str	r3, [sp]
        if (temp == '.')
30023724:	e5dd300f 	ldrb	r3, [sp, #15]
30023728:	e353002e 	cmp	r3, #46	; 0x2e
3002372c:	0a00000c 	beq	30023764 <StrToFDTName+0x1e8>
        {
            break;
        }
        *FDTName++ = temp;
30023730:	e59d3004 	ldr	r3, [sp, #4]
30023734:	e5dd200f 	ldrb	r2, [sp, #15]
30023738:	e5c32000 	strb	r2, [r3]
3002373c:	e59d3004 	ldr	r3, [sp, #4]
30023740:	e2833001 	add	r3, r3, #1
30023744:	e58d3004 	str	r3, [sp, #4]
        FDTName[1] = '.';
        return RETURN_OK;
    }
    
    /* ȡļ/Ŀ¼ */
    for (i = 8; i != 0; i--)
30023748:	e5dd300e 	ldrb	r3, [sp, #14]
3002374c:	e2433001 	sub	r3, r3, #1
30023750:	e5cd300e 	strb	r3, [sp, #14]
30023754:	e5dd300e 	ldrb	r3, [sp, #14]
30023758:	e3530000 	cmp	r3, #0
3002375c:	1affffe1 	bne	300236e8 <StrToFDTName+0x16c>
30023760:	ea000000 	b	30023768 <StrToFDTName+0x1ec>
            break;
        }
        Str++;
        if (temp == '.')
        {
            break;
30023764:	e1a00000 	nop			; (mov r0, r0)
        }
        *FDTName++ = temp;
    }
    FDTName += i;
30023768:	e5dd300e 	ldrb	r3, [sp, #14]
3002376c:	e59d2004 	ldr	r2, [sp, #4]
30023770:	e0823003 	add	r3, r2, r3
30023774:	e58d3004 	str	r3, [sp, #4]
    
    /* ȡļ\Ŀ¼չ */
    for (i = 3; i != 0; i--)
30023778:	e3a03003 	mov	r3, #3
3002377c:	e5cd300e 	strb	r3, [sp, #14]
30023780:	ea000017 	b	300237e4 <StrToFDTName+0x268>
    {
        temp = *Str;
30023784:	e59d3000 	ldr	r3, [sp]
30023788:	e5d33000 	ldrb	r3, [r3]
3002378c:	e5cd300f 	strb	r3, [sp, #15]
        if (temp == 0 || temp == '\\' || temp == '/')
30023790:	e5dd300f 	ldrb	r3, [sp, #15]
30023794:	e3530000 	cmp	r3, #0
30023798:	0a000014 	beq	300237f0 <StrToFDTName+0x274>
3002379c:	e5dd300f 	ldrb	r3, [sp, #15]
300237a0:	e353005c 	cmp	r3, #92	; 0x5c
300237a4:	0a000011 	beq	300237f0 <StrToFDTName+0x274>
300237a8:	e5dd300f 	ldrb	r3, [sp, #15]
300237ac:	e353002f 	cmp	r3, #47	; 0x2f
300237b0:	0a00000e 	beq	300237f0 <StrToFDTName+0x274>
        {
            break;
        }
        Str++;
300237b4:	e59d3000 	ldr	r3, [sp]
300237b8:	e2833001 	add	r3, r3, #1
300237bc:	e58d3000 	str	r3, [sp]
        *FDTName++ = temp;
300237c0:	e59d3004 	ldr	r3, [sp, #4]
300237c4:	e5dd200f 	ldrb	r2, [sp, #15]
300237c8:	e5c32000 	strb	r2, [r3]
300237cc:	e59d3004 	ldr	r3, [sp, #4]
300237d0:	e2833001 	add	r3, r3, #1
300237d4:	e58d3004 	str	r3, [sp, #4]
        *FDTName++ = temp;
    }
    FDTName += i;
    
    /* ȡļ\Ŀ¼չ */
    for (i = 3; i != 0; i--)
300237d8:	e5dd300e 	ldrb	r3, [sp, #14]
300237dc:	e2433001 	sub	r3, r3, #1
300237e0:	e5cd300e 	strb	r3, [sp, #14]
300237e4:	e5dd300e 	ldrb	r3, [sp, #14]
300237e8:	e3530000 	cmp	r3, #0
300237ec:	1affffe4 	bne	30023784 <StrToFDTName+0x208>
            break;
        }
        Str++;
        *FDTName++ = temp;
    }
    return RETURN_OK;
300237f0:	e3a03000 	mov	r3, #0
}
300237f4:	e1a00003 	mov	r0, r3
300237f8:	e28dd010 	add	sp, sp, #16
300237fc:	e12fff1e 	bx	lr

30023800 <_GetFDTInfo>:
**         
** ȫֱ: 
** ģ: GetDirClusIndex,StrToFDTName
********************************************************************************************************/
        acoral_u32 _GetFDTInfo(acoral_char *FDTName, acoral_char *DirFileName)
{
30023800:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023804:	e24dd01c 	sub	sp, sp, #28
30023808:	e58d0004 	str	r0, [sp, #4]
3002380c:	e58d1000 	str	r1, [sp]
    acoral_u32 Rt;
    acoral_char *temp;
    acoral_u8 i;

    /* ȡַλ */
    temp = DirFileName;
30023810:	e59d3000 	ldr	r3, [sp]
30023814:	e58d3010 	str	r3, [sp, #16]
    while (*temp != 0)
30023818:	ea000002 	b	30023828 <_GetFDTInfo+0x28>
    {
         temp++;
3002381c:	e59d3010 	ldr	r3, [sp, #16]
30023820:	e2833001 	add	r3, r3, #1
30023824:	e58d3010 	str	r3, [sp, #16]
    acoral_char *temp;
    acoral_u8 i;

    /* ȡַλ */
    temp = DirFileName;
    while (*temp != 0)
30023828:	e59d3010 	ldr	r3, [sp, #16]
3002382c:	e5d33000 	ldrb	r3, [r3]
30023830:	e3530000 	cmp	r3, #0
30023834:	1afffff8 	bne	3002381c <_GetFDTInfo+0x1c>
    {
         temp++;
    }
    temp--;
30023838:	e59d3010 	ldr	r3, [sp, #16]
3002383c:	e2433001 	sub	r3, r3, #1
30023840:	e58d3010 	str	r3, [sp, #16]
    if (*temp == '\\' || *temp == '/')  /* ַΪ\Чļ/Ŀ¼ */
30023844:	e59d3010 	ldr	r3, [sp, #16]
30023848:	e5d33000 	ldrb	r3, [r3]
3002384c:	e353005c 	cmp	r3, #92	; 0x5c
30023850:	0a000003 	beq	30023864 <_GetFDTInfo+0x64>
30023854:	e59d3010 	ldr	r3, [sp, #16]
30023858:	e5d33000 	ldrb	r3, [r3]
3002385c:	e353002f 	cmp	r3, #47	; 0x2f
30023860:	1a000001 	bne	3002386c <_GetFDTInfo+0x6c>
    {
        return BAD_CLUS;
30023864:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
30023868:	ea000034 	b	30023940 <_GetFDTInfo+0x140>
    }

    
    /* ȡĿ¼ʼغ */
    Rt = BAD_CLUS;
3002386c:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
30023870:	e58d300c 	str	r3, [sp, #12]
    while (1)
    {
        if (*temp == '\\' || *temp == '/' || *temp == ':')
30023874:	e59d3010 	ldr	r3, [sp, #16]
30023878:	e5d33000 	ldrb	r3, [r3]
3002387c:	e353005c 	cmp	r3, #92	; 0x5c
30023880:	0a000007 	beq	300238a4 <_GetFDTInfo+0xa4>
30023884:	e59d3010 	ldr	r3, [sp, #16]
30023888:	e5d33000 	ldrb	r3, [r3]
3002388c:	e353002f 	cmp	r3, #47	; 0x2f
30023890:	0a000003 	beq	300238a4 <_GetFDTInfo+0xa4>
30023894:	e59d3010 	ldr	r3, [sp, #16]
30023898:	e5d33000 	ldrb	r3, [r3]
3002389c:	e353003a 	cmp	r3, #58	; 0x3a
300238a0:	1a000010 	bne	300238e8 <_GetFDTInfo+0xe8>
        {
            /* ҵĿ¼ָ'\'  */
            /* ҵ߼̷ָ':'ָ߼̵ǰĿ¼ */
            temp++;
300238a4:	e59d3010 	ldr	r3, [sp, #16]
300238a8:	e2833001 	add	r3, r3, #1
300238ac:	e58d3010 	str	r3, [sp, #16]
            i = *temp;
300238b0:	e59d3010 	ldr	r3, [sp, #16]
300238b4:	e5d33000 	ldrb	r3, [r3]
300238b8:	e5cd3017 	strb	r3, [sp, #23]
            *temp = 0;
300238bc:	e59d3010 	ldr	r3, [sp, #16]
300238c0:	e3a02000 	mov	r2, #0
300238c4:	e5c32000 	strb	r2, [r3]
            Rt = GetDirClusIndex(DirFileName);
300238c8:	e59d0000 	ldr	r0, [sp]
300238cc:	eb00006a 	bl	30023a7c <GetDirClusIndex>
300238d0:	e1a03000 	mov	r3, r0
300238d4:	e58d300c 	str	r3, [sp, #12]
            *temp = i;
300238d8:	e59d3010 	ldr	r3, [sp, #16]
300238dc:	e5dd2017 	ldrb	r2, [sp, #23]
300238e0:	e5c32000 	strb	r2, [r3]
            break;
300238e4:	ea00000c 	b	3002391c <_GetFDTInfo+0x11c>
        }
        if (temp == DirFileName)
300238e8:	e59d2010 	ldr	r2, [sp, #16]
300238ec:	e59d3000 	ldr	r3, [sp]
300238f0:	e1520003 	cmp	r2, r3
300238f4:	1a000004 	bne	3002390c <_GetFDTInfo+0x10c>
        {
            /* ֻļ\Ŀ¼ǵǰ߼̵ǰĿ¼ */
            Rt = GetDirClusIndex(".");
300238f8:	e59f0050 	ldr	r0, [pc, #80]	; 30023950 <_GetFDTInfo+0x150>
300238fc:	eb00005e 	bl	30023a7c <GetDirClusIndex>
30023900:	e1a03000 	mov	r3, r0
30023904:	e58d300c 	str	r3, [sp, #12]
            break;
30023908:	ea000003 	b	3002391c <_GetFDTInfo+0x11c>
        }
        temp--;
3002390c:	e59d3010 	ldr	r3, [sp, #16]
30023910:	e2433001 	sub	r3, r3, #1
30023914:	e58d3010 	str	r3, [sp, #16]
    }
30023918:	eaffffd5 	b	30023874 <_GetFDTInfo+0x74>
    /* ȡϵͳļ\Ŀ¼ */
    if (StrToFDTName(FDTName, temp) != RETURN_OK)
3002391c:	e59d0004 	ldr	r0, [sp, #4]
30023920:	e59d1010 	ldr	r1, [sp, #16]
30023924:	ebffff14 	bl	3002357c <StrToFDTName>
30023928:	e1a03000 	mov	r3, r0
3002392c:	e3530000 	cmp	r3, #0
30023930:	0a000001 	beq	3002393c <_GetFDTInfo+0x13c>
    {
        Rt = BAD_CLUS;
30023934:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
30023938:	e58d300c 	str	r3, [sp, #12]
    }
    return Rt;
3002393c:	e59d300c 	ldr	r3, [sp, #12]
}
30023940:	e1a00003 	mov	r0, r3
30023944:	e28dd01c 	add	sp, sp, #28
30023948:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002394c:	e12fff1e 	bx	lr
30023950:	300457b0 	.word	0x300457b0

30023954 <GetDrive>:
**
** ȫֱ: 
** ģ: 
********************************************************************************************************/
        acoral_u8 GetDrive(const acoral_char *Path)
{
30023954:	e24dd010 	sub	sp, sp, #16
30023958:	e58d0004 	str	r0, [sp, #4]
    acoral_u8 Drive;

    Drive = CurrentDrive;
3002395c:	e59f3078 	ldr	r3, [pc, #120]	; 300239dc <GetDrive+0x88>
30023960:	e5d33000 	ldrb	r3, [r3]
30023964:	e5cd300f 	strb	r3, [sp, #15]
    if (Path != NULL)
30023968:	e59d3004 	ldr	r3, [sp, #4]
3002396c:	e3530000 	cmp	r3, #0
30023970:	0a000015 	beq	300239cc <GetDrive+0x78>
    {
//        strupr(Path);                           /* Ϊд */
        if (Path[1] == ':')
30023974:	e59d3004 	ldr	r3, [sp, #4]
30023978:	e2833001 	add	r3, r3, #1
3002397c:	e5d33000 	ldrb	r3, [r3]
30023980:	e353003a 	cmp	r3, #58	; 0x3a
30023984:	1a000010 	bne	300239cc <GetDrive+0x78>
        {
        	if(Path[0]>='A' && Path[0]<='Z')
30023988:	e59d3004 	ldr	r3, [sp, #4]
3002398c:	e5d33000 	ldrb	r3, [r3]
30023990:	e3530040 	cmp	r3, #64	; 0x40
30023994:	9a000008 	bls	300239bc <GetDrive+0x68>
30023998:	e59d3004 	ldr	r3, [sp, #4]
3002399c:	e5d33000 	ldrb	r3, [r3]
300239a0:	e353005a 	cmp	r3, #90	; 0x5a
300239a4:	8a000004 	bhi	300239bc <GetDrive+0x68>
            	Drive = Path[0] - 'A';
300239a8:	e59d3004 	ldr	r3, [sp, #4]
300239ac:	e5d33000 	ldrb	r3, [r3]
300239b0:	e2433041 	sub	r3, r3, #65	; 0x41
300239b4:	e5cd300f 	strb	r3, [sp, #15]
    if (Path != NULL)
    {
//        strupr(Path);                           /* Ϊд */
        if (Path[1] == ':')
        {
        	if(Path[0]>='A' && Path[0]<='Z')
300239b8:	ea000003 	b	300239cc <GetDrive+0x78>
            	Drive = Path[0] - 'A';
            else
            	Drive = Path[0] - 'a';
300239bc:	e59d3004 	ldr	r3, [sp, #4]
300239c0:	e5d33000 	ldrb	r3, [r3]
300239c4:	e2433061 	sub	r3, r3, #97	; 0x61
300239c8:	e5cd300f 	strb	r3, [sp, #15]
            	
        }
    }
    return Drive;
300239cc:	e5dd300f 	ldrb	r3, [sp, #15]
}
300239d0:	e1a00003 	mov	r0, r3
300239d4:	e28dd010 	add	sp, sp, #16
300239d8:	e12fff1e 	bx	lr
300239dc:	3012b640 	.word	0x3012b640

300239e0 <ChangeDrive>:
**        PARAMETER_ERR:Ƿ
** ȫֱ: 
** ģ: strupr,GetDiskInfo
********************************************************************************************************/
        acoral_u8 ChangeDrive(acoral_char *Drive)
{
300239e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300239e4:	e24dd014 	sub	sp, sp, #20
300239e8:	e58d0004 	str	r0, [sp, #4]
    acoral_u8 Rt;
    Disk_Info *Disk;
    
    Rt = PARAMETER_ERR;
300239ec:	e3e03000 	mvn	r3, #0
300239f0:	e5cd300b 	strb	r3, [sp, #11]
    strupr(Drive);                           /* Ϊд */
300239f4:	e59d0004 	ldr	r0, [sp, #4]
300239f8:	eb0019ae 	bl	3002a0b8 <strupr>
    if (Drive[1] == ':')
300239fc:	e59d3004 	ldr	r3, [sp, #4]
30023a00:	e2833001 	add	r3, r3, #1
30023a04:	e5d33000 	ldrb	r3, [r3]
30023a08:	e353003a 	cmp	r3, #58	; 0x3a
30023a0c:	1a000014 	bne	30023a64 <ChangeDrive+0x84>
    {
        Rt = NOT_FIND_DISK;
30023a10:	e3a03001 	mov	r3, #1
30023a14:	e5cd300b 	strb	r3, [sp, #11]
        Disk = GetDiskInfo(Drive[0] - 'A');
30023a18:	e59d3004 	ldr	r3, [sp, #4]
30023a1c:	e5d33000 	ldrb	r3, [r3]
30023a20:	e2433041 	sub	r3, r3, #65	; 0x41
30023a24:	e20330ff 	and	r3, r3, #255	; 0xff
30023a28:	e1a00003 	mov	r0, r3
30023a2c:	eb00027b 	bl	30024420 <GetDiskInfo>
30023a30:	e1a03000 	mov	r3, r0
30023a34:	e58d300c 	str	r3, [sp, #12]
        if (Disk != NULL)
30023a38:	e59d300c 	ldr	r3, [sp, #12]
30023a3c:	e3530000 	cmp	r3, #0
30023a40:	0a000007 	beq	30023a64 <ChangeDrive+0x84>
        {
            CurrentDrive = Drive[0] - 'A';
30023a44:	e59d3004 	ldr	r3, [sp, #4]
30023a48:	e5d33000 	ldrb	r3, [r3]
30023a4c:	e2433041 	sub	r3, r3, #65	; 0x41
30023a50:	e20320ff 	and	r2, r3, #255	; 0xff
30023a54:	e59f301c 	ldr	r3, [pc, #28]	; 30023a78 <ChangeDrive+0x98>
30023a58:	e5c32000 	strb	r2, [r3]
            Rt = RETURN_OK;
30023a5c:	e3a03000 	mov	r3, #0
30023a60:	e5cd300b 	strb	r3, [sp, #11]
        }
    }
    return Rt;    
30023a64:	e5dd300b 	ldrb	r3, [sp, #11]
}
30023a68:	e1a00003 	mov	r0, r3
30023a6c:	e28dd014 	add	sp, sp, #20
30023a70:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023a74:	e12fff1e 	bx	lr
30023a78:	3012b640 	.word	0x3012b640

30023a7c <GetDirClusIndex>:
**
** ȫֱ: 
** ģ: strupr,GetDiskInfo,FindFDTInfo
********************************************************************************************************/
        acoral_u32 GetDirClusIndex(acoral_char *Path)
{
30023a7c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023a80:	e24dd044 	sub	sp, sp, #68	; 0x44
30023a84:	e58d0004 	str	r0, [sp, #4]
    acoral_u8 Drive;
    acoral_u32 Rt;
    FDT temp;
    Disk_Info *Disk;
    
    Rt = BAD_CLUS;
30023a88:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
30023a8c:	e58d3038 	str	r3, [sp, #56]	; 0x38
    if (Path != NULL)
30023a90:	e59d3004 	ldr	r3, [sp, #4]
30023a94:	e3530000 	cmp	r3, #0
30023a98:	0a00009f 	beq	30023d1c <GetDirClusIndex+0x2a0>
    {
        strupr(Path);                           /* Ϊд */
30023a9c:	e59d0004 	ldr	r0, [sp, #4]
30023aa0:	eb001984 	bl	3002a0b8 <strupr>
        Drive = GetDrive(Path);                 /* ȡ·̷ */
30023aa4:	e59d0004 	ldr	r0, [sp, #4]
30023aa8:	ebffffa9 	bl	30023954 <GetDrive>
30023aac:	e1a03000 	mov	r3, r0
30023ab0:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
        if (Path[1] == ':')
30023ab4:	e59d3004 	ldr	r3, [sp, #4]
30023ab8:	e2833001 	add	r3, r3, #1
30023abc:	e5d33000 	ldrb	r3, [r3]
30023ac0:	e353003a 	cmp	r3, #58	; 0x3a
30023ac4:	1a000002 	bne	30023ad4 <GetDirClusIndex+0x58>
        {
            Path += 2;
30023ac8:	e59d3004 	ldr	r3, [sp, #4]
30023acc:	e2833002 	add	r3, r3, #2
30023ad0:	e58d3004 	str	r3, [sp, #4]
        }
        Disk = GetDiskInfo(Drive);              /* ȡ߼Ϣ */
30023ad4:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
30023ad8:	e1a00003 	mov	r0, r3
30023adc:	eb00024f 	bl	30024420 <GetDiskInfo>
30023ae0:	e1a03000 	mov	r3, r0
30023ae4:	e58d303c 	str	r3, [sp, #60]	; 0x3c
        if (Disk != NULL)
30023ae8:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30023aec:	e3530000 	cmp	r3, #0
30023af0:	0a00007b 	beq	30023ce4 <GetDirClusIndex+0x268>
        {
            Rt = 0;
30023af4:	e3a03000 	mov	r3, #0
30023af8:	e58d3038 	str	r3, [sp, #56]	; 0x38
            if (Disk->FATType == FAT32)         /* FAT32 Ŀ¼ */
30023afc:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30023b00:	e5d33001 	ldrb	r3, [r3, #1]
30023b04:	e3530002 	cmp	r3, #2
30023b08:	1a000002 	bne	30023b18 <GetDirClusIndex+0x9c>
            {
                Rt = Disk->RootDirTable;
30023b0c:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30023b10:	e5933010 	ldr	r3, [r3, #16]
30023b14:	e58d3038 	str	r3, [sp, #56]	; 0x38
            }
            if (Path[0] != '\\' || Path[0] != '/')                /* Ŀ¼ָţǵǰ· */
30023b18:	e59d3004 	ldr	r3, [sp, #4]
30023b1c:	e5d33000 	ldrb	r3, [r3]
30023b20:	e353005c 	cmp	r3, #92	; 0x5c
30023b24:	1a000003 	bne	30023b38 <GetDirClusIndex+0xbc>
30023b28:	e59d3004 	ldr	r3, [sp, #4]
30023b2c:	e5d33000 	ldrb	r3, [r3]
30023b30:	e353002f 	cmp	r3, #47	; 0x2f
30023b34:	0a000003 	beq	30023b48 <GetDirClusIndex+0xcc>
            {
                Rt = Disk->PathClusIndex;
30023b38:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30023b3c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30023b40:	e58d3038 	str	r3, [sp, #56]	; 0x38
            Rt = 0;
            if (Disk->FATType == FAT32)         /* FAT32 Ŀ¼ */
            {
                Rt = Disk->RootDirTable;
            }
            if (Path[0] != '\\' || Path[0] != '/')                /* Ŀ¼ָţǵǰ· */
30023b44:	ea000002 	b	30023b54 <GetDirClusIndex+0xd8>
            {
                Rt = Disk->PathClusIndex;
            }
            else
            {
                Path++;
30023b48:	e59d3004 	ldr	r3, [sp, #4]
30023b4c:	e2833001 	add	r3, r3, #1
30023b50:	e58d3004 	str	r3, [sp, #4]
            }
            if (Path[0] == '.')             /* '\.'ǵǰ· */
30023b54:	e59d3004 	ldr	r3, [sp, #4]
30023b58:	e5d33000 	ldrb	r3, [r3]
30023b5c:	e353002e 	cmp	r3, #46	; 0x2e
30023b60:	1a000014 	bne	30023bb8 <GetDirClusIndex+0x13c>
            {
                Rt = Disk->PathClusIndex;
30023b64:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30023b68:	e5933028 	ldr	r3, [r3, #40]	; 0x28
30023b6c:	e58d3038 	str	r3, [sp, #56]	; 0x38
                if (Path[1] == 0 || Path[1] == '\\' || Path[1] == '/')
30023b70:	e59d3004 	ldr	r3, [sp, #4]
30023b74:	e2833001 	add	r3, r3, #1
30023b78:	e5d33000 	ldrb	r3, [r3]
30023b7c:	e3530000 	cmp	r3, #0
30023b80:	0a000009 	beq	30023bac <GetDirClusIndex+0x130>
30023b84:	e59d3004 	ldr	r3, [sp, #4]
30023b88:	e2833001 	add	r3, r3, #1
30023b8c:	e5d33000 	ldrb	r3, [r3]
30023b90:	e353005c 	cmp	r3, #92	; 0x5c
30023b94:	0a000004 	beq	30023bac <GetDirClusIndex+0x130>
30023b98:	e59d3004 	ldr	r3, [sp, #4]
30023b9c:	e2833001 	add	r3, r3, #1
30023ba0:	e5d33000 	ldrb	r3, [r3]
30023ba4:	e353002f 	cmp	r3, #47	; 0x2f
30023ba8:	1a000002 	bne	30023bb8 <GetDirClusIndex+0x13c>
                {
                    Path++;
30023bac:	e59d3004 	ldr	r3, [sp, #4]
30023bb0:	e2833001 	add	r3, r3, #1
30023bb4:	e58d3004 	str	r3, [sp, #4]
                }
            }
            if (Path[0] == '\\' || Path[0] == '/')
30023bb8:	e59d3004 	ldr	r3, [sp, #4]
30023bbc:	e5d33000 	ldrb	r3, [r3]
30023bc0:	e353005c 	cmp	r3, #92	; 0x5c
30023bc4:	0a000003 	beq	30023bd8 <GetDirClusIndex+0x15c>
30023bc8:	e59d3004 	ldr	r3, [sp, #4]
30023bcc:	e5d33000 	ldrb	r3, [r3]
30023bd0:	e353002f 	cmp	r3, #47	; 0x2f
30023bd4:	1a000002 	bne	30023be4 <GetDirClusIndex+0x168>
            {
                Path++;
30023bd8:	e59d3004 	ldr	r3, [sp, #4]
30023bdc:	e2833001 	add	r3, r3, #1
30023be0:	e58d3004 	str	r3, [sp, #4]
            }
            
            DirName[11] = 0;
30023be4:	e3a03000 	mov	r3, #0
30023be8:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
            while (Path[0] != 0)
30023bec:	ea000038 	b	30023cd4 <GetDirClusIndex+0x258>
            {
                /* ȡĿ¼ */
                StrToFDTName(DirName , Path);
30023bf0:	e28d3028 	add	r3, sp, #40	; 0x28
30023bf4:	e1a00003 	mov	r0, r3
30023bf8:	e59d1004 	ldr	r1, [sp, #4]
30023bfc:	ebfffe5e 	bl	3002357c <StrToFDTName>

                /* Ŀ¼ʼغ */
                if (DirName[0] == 0x20)
30023c00:	e5dd3028 	ldrb	r3, [sp, #40]	; 0x28
30023c04:	e3530020 	cmp	r3, #32
30023c08:	1a000002 	bne	30023c18 <GetDirClusIndex+0x19c>
                {
                    Rt = BAD_CLUS;
30023c0c:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
30023c10:	e58d3038 	str	r3, [sp, #56]	; 0x38
                    break;
30023c14:	ea000032 	b	30023ce4 <GetDirClusIndex+0x268>
                }
                /* ȡFDTϢ */
                if (FindFDTInfo(&temp, Drive, Rt, DirName) != RETURN_OK)
30023c18:	e28d1008 	add	r1, sp, #8
30023c1c:	e5dd2037 	ldrb	r2, [sp, #55]	; 0x37
30023c20:	e28d3028 	add	r3, sp, #40	; 0x28
30023c24:	e1a00001 	mov	r0, r1
30023c28:	e1a01002 	mov	r1, r2
30023c2c:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
30023c30:	eb000cdf 	bl	30026fb4 <FindFDTInfo>
30023c34:	e1a03000 	mov	r3, r0
30023c38:	e3530000 	cmp	r3, #0
30023c3c:	0a000002 	beq	30023c4c <GetDirClusIndex+0x1d0>
                {
                    Rt = BAD_CLUS;
30023c40:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
30023c44:	e58d3038 	str	r3, [sp, #56]	; 0x38
                    break;
30023c48:	ea000025 	b	30023ce4 <GetDirClusIndex+0x268>
                }
                /* FDTǷĿ¼ */
                if ((temp.Attr & ATTR_DIRECTORY) == 0)
30023c4c:	e5dd3013 	ldrb	r3, [sp, #19]
30023c50:	e2033010 	and	r3, r3, #16
30023c54:	e3530000 	cmp	r3, #0
30023c58:	1a000002 	bne	30023c68 <GetDirClusIndex+0x1ec>
                {
                    Rt = BAD_CLUS;
30023c5c:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
30023c60:	e58d3038 	str	r3, [sp, #56]	; 0x38
                    break;
30023c64:	ea00001e 	b	30023ce4 <GetDirClusIndex+0x268>
                }
                Rt = temp.FstClusLO + ((acoral_u32)(temp.FstClusHI) << 16);
30023c68:	e1dd32b2 	ldrh	r3, [sp, #34]	; 0x22
30023c6c:	e1a02003 	mov	r2, r3
30023c70:	e1dd31bc 	ldrh	r3, [sp, #28]
30023c74:	e1a03803 	lsl	r3, r3, #16
30023c78:	e0823003 	add	r3, r2, r3
30023c7c:	e58d3038 	str	r3, [sp, #56]	; 0x38
                /* ַһĿ¼ */
                while (1)
                {
                    if (*Path == '\\' || *Path == '/')
30023c80:	e59d3004 	ldr	r3, [sp, #4]
30023c84:	e5d33000 	ldrb	r3, [r3]
30023c88:	e353005c 	cmp	r3, #92	; 0x5c
30023c8c:	0a000003 	beq	30023ca0 <GetDirClusIndex+0x224>
30023c90:	e59d3004 	ldr	r3, [sp, #4]
30023c94:	e5d33000 	ldrb	r3, [r3]
30023c98:	e353002f 	cmp	r3, #47	; 0x2f
30023c9c:	1a000003 	bne	30023cb0 <GetDirClusIndex+0x234>
                    {
                        Path++;
30023ca0:	e59d3004 	ldr	r3, [sp, #4]
30023ca4:	e2833001 	add	r3, r3, #1
30023ca8:	e58d3004 	str	r3, [sp, #4]
                        break;
30023cac:	ea000008 	b	30023cd4 <GetDirClusIndex+0x258>
                    }
                    if (*Path == 0)
30023cb0:	e59d3004 	ldr	r3, [sp, #4]
30023cb4:	e5d33000 	ldrb	r3, [r3]
30023cb8:	e3530000 	cmp	r3, #0
30023cbc:	0a000003 	beq	30023cd0 <GetDirClusIndex+0x254>
                    {
                        break;
                    }
                    Path++;
30023cc0:	e59d3004 	ldr	r3, [sp, #4]
30023cc4:	e2833001 	add	r3, r3, #1
30023cc8:	e58d3004 	str	r3, [sp, #4]
                }
30023ccc:	eaffffeb 	b	30023c80 <GetDirClusIndex+0x204>
                        Path++;
                        break;
                    }
                    if (*Path == 0)
                    {
                        break;
30023cd0:	e1a00000 	nop			; (mov r0, r0)
            {
                Path++;
            }
            
            DirName[11] = 0;
            while (Path[0] != 0)
30023cd4:	e59d3004 	ldr	r3, [sp, #4]
30023cd8:	e5d33000 	ldrb	r3, [r3]
30023cdc:	e3530000 	cmp	r3, #0
30023ce0:	1affffc2 	bne	30023bf0 <GetDirClusIndex+0x174>
                    }
                    Path++;
                }
            }
        }
        if (Disk->FATType == FAT32)
30023ce4:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30023ce8:	e5d33001 	ldrb	r3, [r3, #1]
30023cec:	e3530002 	cmp	r3, #2
30023cf0:	1a000009 	bne	30023d1c <GetDirClusIndex+0x2a0>
        if (Rt != BAD_CLUS)
30023cf4:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30023cf8:	e373029f 	cmn	r3, #-268435447	; 0xf0000009
30023cfc:	0a000006 	beq	30023d1c <GetDirClusIndex+0x2a0>
        if (Rt == Disk->RootDirTable)
30023d00:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30023d04:	e5932010 	ldr	r2, [r3, #16]
30023d08:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30023d0c:	e1520003 	cmp	r2, r3
30023d10:	1a000001 	bne	30023d1c <GetDirClusIndex+0x2a0>
        {
            Rt = 0;
30023d14:	e3a03000 	mov	r3, #0
30023d18:	e58d3038 	str	r3, [sp, #56]	; 0x38
        }
    }
    return Rt;
30023d1c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
}
30023d20:	e1a00003 	mov	r0, r3
30023d24:	e28dd044 	add	sp, sp, #68	; 0x44
30023d28:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023d2c:	e12fff1e 	bx	lr

30023d30 <MakeDir>:
**        οfat.hйڷֵ˵
** ȫֱ: 
** ģ: strupr,ClearClus,AddFDT
********************************************************************************************************/
        acoral_u8 MakeDir(acoral_char *Path)
{
30023d30:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023d34:	e24dd03c 	sub	sp, sp, #60	; 0x3c
30023d38:	e58d0004 	str	r0, [sp, #4]
    acoral_u32 ClusIndex, Temp1;
    acoral_u8 Drive, Rt;
    FDT temp;
    
    strupr(Path);                       /* Ϊд */
30023d3c:	e59d0004 	ldr	r0, [sp, #4]
30023d40:	eb0018dc 	bl	3002a0b8 <strupr>

    ClusIndex = _GetFDTInfo(temp.Name, Path);
30023d44:	e28d300c 	add	r3, sp, #12
30023d48:	e1a00003 	mov	r0, r3
30023d4c:	e59d1004 	ldr	r1, [sp, #4]
30023d50:	ebfffeaa 	bl	30023800 <_GetFDTInfo>
30023d54:	e1a03000 	mov	r3, r0
30023d58:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    if (ClusIndex == BAD_CLUS)
30023d5c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30023d60:	e373029f 	cmn	r3, #-268435447	; 0xf0000009
30023d64:	1a000001 	bne	30023d70 <MakeDir+0x40>
    {
        return PATH_NOT_FIND;
30023d68:	e3a0300e 	mov	r3, #14
30023d6c:	ea00007d 	b	30023f68 <MakeDir+0x238>
    }

    Drive = GetDrive(Path);
30023d70:	e59d0004 	ldr	r0, [sp, #4]
30023d74:	ebfffef6 	bl	30023954 <GetDrive>
30023d78:	e1a03000 	mov	r3, r0
30023d7c:	e5cd3036 	strb	r3, [sp, #54]	; 0x36
    
    /* FDTǷ */
    Rt = FDTIsLie(Drive, ClusIndex, temp.Name);
30023d80:	e5dd2036 	ldrb	r2, [sp, #54]	; 0x36
30023d84:	e28d300c 	add	r3, sp, #12
30023d88:	e1a00002 	mov	r0, r2
30023d8c:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
30023d90:	e1a02003 	mov	r2, r3
30023d94:	eb000ed0 	bl	300278dc <FDTIsLie>
30023d98:	e1a03000 	mov	r3, r0
30023d9c:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
    if (Rt != NOT_FIND_FDT)
30023da0:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
30023da4:	e3530007 	cmp	r3, #7
30023da8:	0a000001 	beq	30023db4 <MakeDir+0x84>
    {
        return Rt;
30023dac:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
30023db0:	ea00006c 	b	30023f68 <MakeDir+0x238>
    }
    
    /*  */
    Temp1 = FATAddClus(Drive, 0);               /* ȡĿ¼̿ռ */
30023db4:	e5dd3036 	ldrb	r3, [sp, #54]	; 0x36
30023db8:	e1a00003 	mov	r0, r3
30023dbc:	e3a01000 	mov	r1, #0
30023dc0:	eb0007bb 	bl	30025cb4 <FATAddClus>
30023dc4:	e1a03000 	mov	r3, r0
30023dc8:	e58d3030 	str	r3, [sp, #48]	; 0x30
    if ((Temp1 <= EMPTY_CLUS_1) || (Temp1 >= BAD_CLUS))
30023dcc:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30023dd0:	e3530001 	cmp	r3, #1
30023dd4:	9a000002 	bls	30023de4 <MakeDir+0xb4>
30023dd8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30023ddc:	e37302af 	cmn	r3, #-268435446	; 0xf000000a
30023de0:	9a000001 	bls	30023dec <MakeDir+0xbc>
    {
        /* ûппռ */
        return  DISK_FULL;
30023de4:	e3a03002 	mov	r3, #2
30023de8:	ea00005e 	b	30023f68 <MakeDir+0x238>
    }

    ClearClus(Drive, Temp1);                /* մ */
30023dec:	e5dd3036 	ldrb	r3, [sp, #54]	; 0x36
30023df0:	e1a00003 	mov	r0, r3
30023df4:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
30023df8:	eb000856 	bl	30025f58 <ClearClus>
        
        /* FDT */
    temp.Attr = ATTR_DIRECTORY;             
30023dfc:	e3a03010 	mov	r3, #16
30023e00:	e5cd3017 	strb	r3, [sp, #23]
    temp.FileSize = 0;
30023e04:	e3a03000 	mov	r3, #0
30023e08:	e58d3028 	str	r3, [sp, #40]	; 0x28

    temp.NTRes = 0;
30023e0c:	e3a03000 	mov	r3, #0
30023e10:	e5cd3018 	strb	r3, [sp, #24]
    temp.CrtTimeTenth = 0;
30023e14:	e3a03000 	mov	r3, #0
30023e18:	e5cd3019 	strb	r3, [sp, #25]
    temp.CrtTime = 0;
30023e1c:	e3a03000 	mov	r3, #0
30023e20:	e1cd31ba 	strh	r3, [sp, #26]
    temp.CrtDate = 0;
30023e24:	e3a03000 	mov	r3, #0
30023e28:	e1cd31bc 	strh	r3, [sp, #28]
    temp.LstAccDate = 0;
30023e2c:	e3a03000 	mov	r3, #0
30023e30:	e1cd31be 	strh	r3, [sp, #30]
    temp.WrtTime = 0;
30023e34:	e3a03000 	mov	r3, #0
30023e38:	e1cd32b2 	strh	r3, [sp, #34]	; 0x22
    temp.WrtDate = 0;
30023e3c:	e3a03000 	mov	r3, #0
30023e40:	e1cd32b4 	strh	r3, [sp, #36]	; 0x24

    temp.FstClusLO = Temp1 & 0xffff;
30023e44:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30023e48:	e1a03803 	lsl	r3, r3, #16
30023e4c:	e1a03823 	lsr	r3, r3, #16
30023e50:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
    temp.FstClusHI = Temp1 / 0x10000;
30023e54:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30023e58:	e1a03823 	lsr	r3, r3, #16
30023e5c:	e1a03803 	lsl	r3, r3, #16
30023e60:	e1a03823 	lsr	r3, r3, #16
30023e64:	e1cd32b0 	strh	r3, [sp, #32]

    Rt = AddFDT(Drive, ClusIndex, &temp);       /* Ŀ¼ */
30023e68:	e5dd2036 	ldrb	r2, [sp, #54]	; 0x36
30023e6c:	e28d300c 	add	r3, sp, #12
30023e70:	e1a00002 	mov	r0, r2
30023e74:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
30023e78:	e1a02003 	mov	r2, r3
30023e7c:	eb000cd3 	bl	300271d0 <AddFDT>
30023e80:	e1a03000 	mov	r3, r0
30023e84:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
    if (Rt == RETURN_OK)
30023e88:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
30023e8c:	e3530000 	cmp	r3, #0
30023e90:	1a00002f 	bne	30023f54 <MakeDir+0x224>
    {
        /* '.'Ŀ¼ */
        temp.Name[0] = '.';
30023e94:	e3a0302e 	mov	r3, #46	; 0x2e
30023e98:	e5cd300c 	strb	r3, [sp, #12]
        temp.Name[1] = 0x20;
30023e9c:	e3a03020 	mov	r3, #32
30023ea0:	e5cd300d 	strb	r3, [sp, #13]
        temp.Name[2] = 0x20;
30023ea4:	e3a03020 	mov	r3, #32
30023ea8:	e5cd300e 	strb	r3, [sp, #14]
        temp.Name[3] = 0x20;
30023eac:	e3a03020 	mov	r3, #32
30023eb0:	e5cd300f 	strb	r3, [sp, #15]
        temp.Name[4] = 0x20;
30023eb4:	e3a03020 	mov	r3, #32
30023eb8:	e5cd3010 	strb	r3, [sp, #16]
        temp.Name[5] = 0x20;
30023ebc:	e3a03020 	mov	r3, #32
30023ec0:	e5cd3011 	strb	r3, [sp, #17]
        temp.Name[6] = 0x20;
30023ec4:	e3a03020 	mov	r3, #32
30023ec8:	e5cd3012 	strb	r3, [sp, #18]
        temp.Name[7] = 0x20;
30023ecc:	e3a03020 	mov	r3, #32
30023ed0:	e5cd3013 	strb	r3, [sp, #19]
        temp.Name[8] = 0x20;
30023ed4:	e3a03020 	mov	r3, #32
30023ed8:	e5cd3014 	strb	r3, [sp, #20]
        temp.Name[9] = 0x20;
30023edc:	e3a03020 	mov	r3, #32
30023ee0:	e5cd3015 	strb	r3, [sp, #21]
        temp.Name[10] = 0x20;
30023ee4:	e3a03020 	mov	r3, #32
30023ee8:	e5cd3016 	strb	r3, [sp, #22]
        
        AddFDT(Drive, Temp1, &temp);
30023eec:	e5dd2036 	ldrb	r2, [sp, #54]	; 0x36
30023ef0:	e28d300c 	add	r3, sp, #12
30023ef4:	e1a00002 	mov	r0, r2
30023ef8:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
30023efc:	e1a02003 	mov	r2, r3
30023f00:	eb000cb2 	bl	300271d0 <AddFDT>

        /* '..'Ŀ¼ */
        temp.Name[1] = '.';
30023f04:	e3a0302e 	mov	r3, #46	; 0x2e
30023f08:	e5cd300d 	strb	r3, [sp, #13]
        
        temp.FstClusLO = ClusIndex & 0xffff;
30023f0c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30023f10:	e1a03803 	lsl	r3, r3, #16
30023f14:	e1a03823 	lsr	r3, r3, #16
30023f18:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
        temp.FstClusHI = ClusIndex / 0x10000;
30023f1c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30023f20:	e1a03823 	lsr	r3, r3, #16
30023f24:	e1a03803 	lsl	r3, r3, #16
30023f28:	e1a03823 	lsr	r3, r3, #16
30023f2c:	e1cd32b0 	strh	r3, [sp, #32]
        Rt = AddFDT(Drive, Temp1, &temp);
30023f30:	e5dd2036 	ldrb	r2, [sp, #54]	; 0x36
30023f34:	e28d300c 	add	r3, sp, #12
30023f38:	e1a00002 	mov	r0, r2
30023f3c:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
30023f40:	e1a02003 	mov	r2, r3
30023f44:	eb000ca1 	bl	300271d0 <AddFDT>
30023f48:	e1a03000 	mov	r3, r0
30023f4c:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
30023f50:	ea000003 	b	30023f64 <MakeDir+0x234>
    }
    else
    {
        FATDelClusChain(Drive, Temp1);
30023f54:	e5dd3036 	ldrb	r3, [sp, #54]	; 0x36
30023f58:	e1a00003 	mov	r0, r3
30023f5c:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
30023f60:	eb0007d1 	bl	30025eac <FATDelClusChain>
    }
    
    return Rt;
30023f64:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
}
30023f68:	e1a00003 	mov	r0, r3
30023f6c:	e28dd03c 	add	sp, sp, #60	; 0x3c
30023f70:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30023f74:	e12fff1e 	bx	lr

30023f78 <RemoveDir>:
**        οfat.hйڷֵ˵
** ȫֱ: 
** ģ: strupr,DelFDT
********************************************************************************************************/
        acoral_u8 RemoveDir(acoral_char *Path)
{
30023f78:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30023f7c:	e24dd044 	sub	sp, sp, #68	; 0x44
30023f80:	e58d0004 	str	r0, [sp, #4]
    acoral_u32 ClusIndex, ClusIndex1;
    acoral_u8 Drive, Rt;
    acoral_char DirName[12];
    FDT temp;
    
    strupr(Path);                       /* Ϊд */
30023f84:	e59d0004 	ldr	r0, [sp, #4]
30023f88:	eb00184a 	bl	3002a0b8 <strupr>

    ClusIndex = _GetFDTInfo(DirName, Path);
30023f8c:	e28d3028 	add	r3, sp, #40	; 0x28
30023f90:	e1a00003 	mov	r0, r3
30023f94:	e59d1004 	ldr	r1, [sp, #4]
30023f98:	ebfffe18 	bl	30023800 <_GetFDTInfo>
30023f9c:	e1a03000 	mov	r3, r0
30023fa0:	e58d3034 	str	r3, [sp, #52]	; 0x34
    if (ClusIndex == BAD_CLUS)
30023fa4:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30023fa8:	e373029f 	cmn	r3, #-268435447	; 0xf0000009
30023fac:	1a000001 	bne	30023fb8 <RemoveDir+0x40>
    {
        return PATH_NOT_FIND;
30023fb0:	e3a0300e 	mov	r3, #14
30023fb4:	ea000033 	b	30024088 <RemoveDir+0x110>
    }

    Drive = GetDrive(Path);
30023fb8:	e59d0004 	ldr	r0, [sp, #4]
30023fbc:	ebfffe64 	bl	30023954 <GetDrive>
30023fc0:	e1a03000 	mov	r3, r0
30023fc4:	e5cd303e 	strb	r3, [sp, #62]	; 0x3e
    
    /* ȡFDTϢ */
    Rt = FindFDTInfo(&temp, Drive, ClusIndex, DirName);
30023fc8:	e28d1008 	add	r1, sp, #8
30023fcc:	e5dd203e 	ldrb	r2, [sp, #62]	; 0x3e
30023fd0:	e28d3028 	add	r3, sp, #40	; 0x28
30023fd4:	e1a00001 	mov	r0, r1
30023fd8:	e1a01002 	mov	r1, r2
30023fdc:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
30023fe0:	eb000bf3 	bl	30026fb4 <FindFDTInfo>
30023fe4:	e1a03000 	mov	r3, r0
30023fe8:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
    if (Rt == RETURN_OK)
30023fec:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
30023ff0:	e3530000 	cmp	r3, #0
30023ff4:	1a000022 	bne	30024084 <RemoveDir+0x10c>
    {
        /* ǷĿ¼ */
        if ((temp.Attr & ATTR_DIRECTORY) != 0)
30023ff8:	e5dd3013 	ldrb	r3, [sp, #19]
30023ffc:	e2033010 	and	r3, r3, #16
30024000:	e3530000 	cmp	r3, #0
30024004:	0a00001b 	beq	30024078 <RemoveDir+0x100>
        {
            /*  */
            ClusIndex1 = temp.FstClusLO + ((acoral_u32)(temp.FstClusHI) << 16);
30024008:	e1dd32b2 	ldrh	r3, [sp, #34]	; 0x22
3002400c:	e1a02003 	mov	r2, r3
30024010:	e1dd31bc 	ldrh	r3, [sp, #28]
30024014:	e1a03803 	lsl	r3, r3, #16
30024018:	e0823003 	add	r3, r2, r3
3002401c:	e58d3038 	str	r3, [sp, #56]	; 0x38
            /* ǷǿĿ¼ */
            Rt = DirIsEmpty(Drive, ClusIndex1);
30024020:	e5dd303e 	ldrb	r3, [sp, #62]	; 0x3e
30024024:	e1a00003 	mov	r0, r3
30024028:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
3002402c:	eb000de5 	bl	300277c8 <DirIsEmpty>
30024030:	e1a03000 	mov	r3, r0
30024034:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
            if (Rt == DIR_EMPTY)
30024038:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
3002403c:	e353000c 	cmp	r3, #12
30024040:	1a00000e 	bne	30024080 <RemoveDir+0x108>
            {
                /* ǣɾ */
                FATDelClusChain(Drive, ClusIndex1);
30024044:	e5dd303e 	ldrb	r3, [sp, #62]	; 0x3e
30024048:	e1a00003 	mov	r0, r3
3002404c:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
30024050:	eb000795 	bl	30025eac <FATDelClusChain>
                Rt = DelFDT(Drive, ClusIndex, DirName);
30024054:	e5dd203e 	ldrb	r2, [sp, #62]	; 0x3e
30024058:	e28d3028 	add	r3, sp, #40	; 0x28
3002405c:	e1a00002 	mov	r0, r2
30024060:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
30024064:	e1a02003 	mov	r2, r3
30024068:	eb000cde 	bl	300273e8 <DelFDT>
3002406c:	e1a03000 	mov	r3, r0
30024070:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
30024074:	ea000002 	b	30024084 <RemoveDir+0x10c>
            }
        }
        else
        {
            return PATH_NOT_FIND;
30024078:	e3a0300e 	mov	r3, #14
3002407c:	ea000001 	b	30024088 <RemoveDir+0x110>
            Rt = DirIsEmpty(Drive, ClusIndex1);
            if (Rt == DIR_EMPTY)
            {
                /* ǣɾ */
                FATDelClusChain(Drive, ClusIndex1);
                Rt = DelFDT(Drive, ClusIndex, DirName);
30024080:	e1a00000 	nop			; (mov r0, r0)
        else
        {
            return PATH_NOT_FIND;
        }
    }
    return Rt;
30024084:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
}
30024088:	e1a00003 	mov	r0, r3
3002408c:	e28dd044 	add	sp, sp, #68	; 0x44
30024090:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30024094:	e12fff1e 	bx	lr

30024098 <ChangeDir>:
**        οfat.hйڷֵ˵
** ȫֱ: 
** ģ: GetDirClusIndex,GetDiskInfo
********************************************************************************************************/
        acoral_u8 ChangeDir(acoral_char *Path)
{
30024098:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002409c:	e24dd01c 	sub	sp, sp, #28
300240a0:	e58d0004 	str	r0, [sp, #4]
    acoral_u32 ClusIndex;
    acoral_u8 Rt, Drive;
    Disk_Info *Disk;

    Rt = PATH_NOT_FIND;
300240a4:	e3a0300e 	mov	r3, #14
300240a8:	e5cd3012 	strb	r3, [sp, #18]
    ClusIndex = GetDirClusIndex(Path);
300240ac:	e59d0004 	ldr	r0, [sp, #4]
300240b0:	ebfffe71 	bl	30023a7c <GetDirClusIndex>
300240b4:	e1a03000 	mov	r3, r0
300240b8:	e58d300c 	str	r3, [sp, #12]
    if (ClusIndex != BAD_CLUS)
300240bc:	e59d300c 	ldr	r3, [sp, #12]
300240c0:	e373029f 	cmn	r3, #-268435447	; 0xf0000009
300240c4:	0a000012 	beq	30024114 <ChangeDir+0x7c>
    {
        Drive = GetDrive(Path);
300240c8:	e59d0004 	ldr	r0, [sp, #4]
300240cc:	ebfffe20 	bl	30023954 <GetDrive>
300240d0:	e1a03000 	mov	r3, r0
300240d4:	e5cd3013 	strb	r3, [sp, #19]
        Disk = GetDiskInfo(Drive);
300240d8:	e5dd3013 	ldrb	r3, [sp, #19]
300240dc:	e1a00003 	mov	r0, r3
300240e0:	eb0000ce 	bl	30024420 <GetDiskInfo>
300240e4:	e1a03000 	mov	r3, r0
300240e8:	e58d3014 	str	r3, [sp, #20]
        Rt = NOT_FIND_DISK;
300240ec:	e3a03001 	mov	r3, #1
300240f0:	e5cd3012 	strb	r3, [sp, #18]
        if (Disk != NULL)
300240f4:	e59d3014 	ldr	r3, [sp, #20]
300240f8:	e3530000 	cmp	r3, #0
300240fc:	0a000004 	beq	30024114 <ChangeDir+0x7c>
        {
            Rt = RETURN_OK;
30024100:	e3a03000 	mov	r3, #0
30024104:	e5cd3012 	strb	r3, [sp, #18]
            Disk->PathClusIndex = ClusIndex;
30024108:	e59d3014 	ldr	r3, [sp, #20]
3002410c:	e59d200c 	ldr	r2, [sp, #12]
30024110:	e5832028 	str	r2, [r3, #40]	; 0x28
        }
    }
    return Rt;
30024114:	e5dd3012 	ldrb	r3, [sp, #18]
}
30024118:	e1a00003 	mov	r0, r3
3002411c:	e28dd01c 	add	sp, sp, #28
30024120:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30024124:	e12fff1e 	bx	lr

30024128 <DiskInit>:
**         
** ȫֱ: DiskInfo
** ģ: 
********************************************************************************************************/
        void DiskInit(void)
{
30024128:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002412c:	e24dd00c 	sub	sp, sp, #12
    acoral_u8 i;
    
    for (i = 0; i < MAX_DRIVES; i++)
30024130:	e3a03000 	mov	r3, #0
30024134:	e5cd3007 	strb	r3, [sp, #7]
30024138:	ea0000b0 	b	30024400 <DiskInit+0x2d8>
    {
        DiskInfo[i].Drive = EMPTY_DRIVE;    // ûз
3002413c:	e5dd2007 	ldrb	r2, [sp, #7]
30024140:	e59f12d4 	ldr	r1, [pc, #724]	; 3002441c <DiskInit+0x2f4>
30024144:	e1a03002 	mov	r3, r2
30024148:	e1a03083 	lsl	r3, r3, #1
3002414c:	e0833002 	add	r3, r3, r2
30024150:	e1a03103 	lsl	r3, r3, #2
30024154:	e0833002 	add	r3, r3, r2
30024158:	e1a03103 	lsl	r3, r3, #2
3002415c:	e0833001 	add	r3, r3, r1
30024160:	e3e02000 	mvn	r2, #0
30024164:	e5c32000 	strb	r2, [r3]
        DiskInfo[i].FATType = 0xff;         // Чļϵͳ
30024168:	e5dd2007 	ldrb	r2, [sp, #7]
3002416c:	e59f12a8 	ldr	r1, [pc, #680]	; 3002441c <DiskInit+0x2f4>
30024170:	e1a03002 	mov	r3, r2
30024174:	e1a03083 	lsl	r3, r3, #1
30024178:	e0833002 	add	r3, r3, r2
3002417c:	e1a03103 	lsl	r3, r3, #2
30024180:	e0833002 	add	r3, r3, r2
30024184:	e1a03103 	lsl	r3, r3, #2
30024188:	e0833001 	add	r3, r3, r1
3002418c:	e3e02000 	mvn	r2, #0
30024190:	e5c32001 	strb	r2, [r3, #1]
        DiskInfo[i].SecPerClus = 0;         // ÿ
30024194:	e5dd2007 	ldrb	r2, [sp, #7]
30024198:	e59f127c 	ldr	r1, [pc, #636]	; 3002441c <DiskInit+0x2f4>
3002419c:	e1a03002 	mov	r3, r2
300241a0:	e1a03083 	lsl	r3, r3, #1
300241a4:	e0833002 	add	r3, r3, r2
300241a8:	e1a03103 	lsl	r3, r3, #2
300241ac:	e0833002 	add	r3, r3, r2
300241b0:	e1a03103 	lsl	r3, r3, #2
300241b4:	e0833001 	add	r3, r3, r1
300241b8:	e3a02000 	mov	r2, #0
300241bc:	e5c32002 	strb	r2, [r3, #2]
        DiskInfo[i].NumFATs = 0;            // FAT
300241c0:	e5dd2007 	ldrb	r2, [sp, #7]
300241c4:	e59f1250 	ldr	r1, [pc, #592]	; 3002441c <DiskInit+0x2f4>
300241c8:	e1a03002 	mov	r3, r2
300241cc:	e1a03083 	lsl	r3, r3, #1
300241d0:	e0833002 	add	r3, r3, r2
300241d4:	e1a03103 	lsl	r3, r3, #2
300241d8:	e0833002 	add	r3, r3, r2
300241dc:	e1a03103 	lsl	r3, r3, #2
300241e0:	e0833001 	add	r3, r3, r1
300241e4:	e3a02000 	mov	r2, #0
300241e8:	e5c32003 	strb	r2, [r3, #3]
        DiskInfo[i].DevId= -1;
300241ec:	e5dd2007 	ldrb	r2, [sp, #7]
300241f0:	e59f0224 	ldr	r0, [pc, #548]	; 3002441c <DiskInit+0x2f4>
300241f4:	e3a01004 	mov	r1, #4
300241f8:	e1a03002 	mov	r3, r2
300241fc:	e1a03083 	lsl	r3, r3, #1
30024200:	e0833002 	add	r3, r3, r2
30024204:	e1a03103 	lsl	r3, r3, #2
30024208:	e0833002 	add	r3, r3, r2
3002420c:	e1a03103 	lsl	r3, r3, #2
30024210:	e0833000 	add	r3, r3, r0
30024214:	e0833001 	add	r3, r3, r1
30024218:	e3e02000 	mvn	r2, #0
3002421c:	e5832000 	str	r2, [r3]
        DiskInfo[i].SecPerDisk = 0xffffffff;// ߼
30024220:	e5dd2007 	ldrb	r2, [sp, #7]
30024224:	e59f01f0 	ldr	r0, [pc, #496]	; 3002441c <DiskInit+0x2f4>
30024228:	e3a01008 	mov	r1, #8
3002422c:	e1a03002 	mov	r3, r2
30024230:	e1a03083 	lsl	r3, r3, #1
30024234:	e0833002 	add	r3, r3, r2
30024238:	e1a03103 	lsl	r3, r3, #2
3002423c:	e0833002 	add	r3, r3, r2
30024240:	e1a03103 	lsl	r3, r3, #2
30024244:	e0833000 	add	r3, r3, r0
30024248:	e0833001 	add	r3, r3, r1
3002424c:	e3e02000 	mvn	r2, #0
30024250:	e5832000 	str	r2, [r3]
        DiskInfo[i].BytsPerSec = 0;         // ÿֽ
30024254:	e5dd2007 	ldrb	r2, [sp, #7]
30024258:	e59f01bc 	ldr	r0, [pc, #444]	; 3002441c <DiskInit+0x2f4>
3002425c:	e3a0100c 	mov	r1, #12
30024260:	e1a03002 	mov	r3, r2
30024264:	e1a03083 	lsl	r3, r3, #1
30024268:	e0833002 	add	r3, r3, r2
3002426c:	e1a03103 	lsl	r3, r3, #2
30024270:	e0833002 	add	r3, r3, r2
30024274:	e1a03103 	lsl	r3, r3, #2
30024278:	e0833000 	add	r3, r3, r0
3002427c:	e0833001 	add	r3, r3, r1
30024280:	e3a02000 	mov	r2, #0
30024284:	e5832000 	str	r2, [r3]
        DiskInfo[i].RootDirTable = 0;       // Ŀ¼ʼţFAT32Ϊʼغţ
30024288:	e5dd2007 	ldrb	r2, [sp, #7]
3002428c:	e59f0188 	ldr	r0, [pc, #392]	; 3002441c <DiskInit+0x2f4>
30024290:	e3a01010 	mov	r1, #16
30024294:	e1a03002 	mov	r3, r2
30024298:	e1a03083 	lsl	r3, r3, #1
3002429c:	e0833002 	add	r3, r3, r2
300242a0:	e1a03103 	lsl	r3, r3, #2
300242a4:	e0833002 	add	r3, r3, r2
300242a8:	e1a03103 	lsl	r3, r3, #2
300242ac:	e0833000 	add	r3, r3, r0
300242b0:	e0833001 	add	r3, r3, r1
300242b4:	e3a02000 	mov	r2, #0
300242b8:	e5832000 	str	r2, [r3]
        DiskInfo[i].RootSecCnt = 0;         // Ŀ¼ռ
300242bc:	e5dd2007 	ldrb	r2, [sp, #7]
300242c0:	e59f0154 	ldr	r0, [pc, #340]	; 3002441c <DiskInit+0x2f4>
300242c4:	e3a01014 	mov	r1, #20
300242c8:	e1a03002 	mov	r3, r2
300242cc:	e1a03083 	lsl	r3, r3, #1
300242d0:	e0833002 	add	r3, r3, r2
300242d4:	e1a03103 	lsl	r3, r3, #2
300242d8:	e0833002 	add	r3, r3, r2
300242dc:	e1a03103 	lsl	r3, r3, #2
300242e0:	e0833000 	add	r3, r3, r0
300242e4:	e0833001 	add	r3, r3, r1
300242e8:	e3a02000 	mov	r2, #0
300242ec:	e5832000 	str	r2, [r3]
        DiskInfo[i].FATStartSec = 0;        // FATʼ
300242f0:	e5dd2007 	ldrb	r2, [sp, #7]
300242f4:	e59f0120 	ldr	r0, [pc, #288]	; 3002441c <DiskInit+0x2f4>
300242f8:	e3a01018 	mov	r1, #24
300242fc:	e1a03002 	mov	r3, r2
30024300:	e1a03083 	lsl	r3, r3, #1
30024304:	e0833002 	add	r3, r3, r2
30024308:	e1a03103 	lsl	r3, r3, #2
3002430c:	e0833002 	add	r3, r3, r2
30024310:	e1a03103 	lsl	r3, r3, #2
30024314:	e0833000 	add	r3, r3, r0
30024318:	e0833001 	add	r3, r3, r1
3002431c:	e3a02000 	mov	r2, #0
30024320:	e5832000 	str	r2, [r3]
        DiskInfo[i].FATSecCnt = 0;          // ÿFATռ
30024324:	e5dd2007 	ldrb	r2, [sp, #7]
30024328:	e59f00ec 	ldr	r0, [pc, #236]	; 3002441c <DiskInit+0x2f4>
3002432c:	e3a0101c 	mov	r1, #28
30024330:	e1a03002 	mov	r3, r2
30024334:	e1a03083 	lsl	r3, r3, #1
30024338:	e0833002 	add	r3, r3, r2
3002433c:	e1a03103 	lsl	r3, r3, #2
30024340:	e0833002 	add	r3, r3, r2
30024344:	e1a03103 	lsl	r3, r3, #2
30024348:	e0833000 	add	r3, r3, r0
3002434c:	e0833001 	add	r3, r3, r1
30024350:	e3a02000 	mov	r2, #0
30024354:	e5832000 	str	r2, [r3]
        DiskInfo[i].DataStartSec = 0;       // ʼ
30024358:	e5dd2007 	ldrb	r2, [sp, #7]
3002435c:	e59f00b8 	ldr	r0, [pc, #184]	; 3002441c <DiskInit+0x2f4>
30024360:	e3a01020 	mov	r1, #32
30024364:	e1a03002 	mov	r3, r2
30024368:	e1a03083 	lsl	r3, r3, #1
3002436c:	e0833002 	add	r3, r3, r2
30024370:	e1a03103 	lsl	r3, r3, #2
30024374:	e0833002 	add	r3, r3, r2
30024378:	e1a03103 	lsl	r3, r3, #2
3002437c:	e0833000 	add	r3, r3, r0
30024380:	e0833001 	add	r3, r3, r1
30024384:	e3a02000 	mov	r2, #0
30024388:	e5832000 	str	r2, [r3]
        DiskInfo[i].PathClusIndex = 0;      // ǰĿ¼
3002438c:	e5dd2007 	ldrb	r2, [sp, #7]
30024390:	e59f0084 	ldr	r0, [pc, #132]	; 3002441c <DiskInit+0x2f4>
30024394:	e3a01028 	mov	r1, #40	; 0x28
30024398:	e1a03002 	mov	r3, r2
3002439c:	e1a03083 	lsl	r3, r3, #1
300243a0:	e0833002 	add	r3, r3, r2
300243a4:	e1a03103 	lsl	r3, r3, #2
300243a8:	e0833002 	add	r3, r3, r2
300243ac:	e1a03103 	lsl	r3, r3, #2
300243b0:	e0833000 	add	r3, r3, r0
300243b4:	e0833001 	add	r3, r3, r1
300243b8:	e3a02000 	mov	r2, #0
300243bc:	e5832000 	str	r2, [r3]
        DiskInfo[i].DiakCommand = NULL;     // 
300243c0:	e5dd2007 	ldrb	r2, [sp, #7]
300243c4:	e59f0050 	ldr	r0, [pc, #80]	; 3002441c <DiskInit+0x2f4>
300243c8:	e3a01030 	mov	r1, #48	; 0x30
300243cc:	e1a03002 	mov	r3, r2
300243d0:	e1a03083 	lsl	r3, r3, #1
300243d4:	e0833002 	add	r3, r3, r2
300243d8:	e1a03103 	lsl	r3, r3, #2
300243dc:	e0833002 	add	r3, r3, r2
300243e0:	e1a03103 	lsl	r3, r3, #2
300243e4:	e0833000 	add	r3, r3, r0
300243e8:	e0833001 	add	r3, r3, r1
300243ec:	e3a02000 	mov	r2, #0
300243f0:	e5832000 	str	r2, [r3]
********************************************************************************************************/
        void DiskInit(void)
{
    acoral_u8 i;
    
    for (i = 0; i < MAX_DRIVES; i++)
300243f4:	e5dd3007 	ldrb	r3, [sp, #7]
300243f8:	e2833001 	add	r3, r3, #1
300243fc:	e5cd3007 	strb	r3, [sp, #7]
30024400:	e5dd3007 	ldrb	r3, [sp, #7]
30024404:	e3530000 	cmp	r3, #0
30024408:	0affff4b 	beq	3002413c <DiskInit+0x14>
        DiskInfo[i].FATSecCnt = 0;          // ÿFATռ
        DiskInfo[i].DataStartSec = 0;       // ʼ
        DiskInfo[i].PathClusIndex = 0;      // ǰĿ¼
        DiskInfo[i].DiakCommand = NULL;     // 
    }
    CacheInit();                //ʼcache
3002440c:	eb001d60 	bl	3002b994 <CacheInit>
}
30024410:	e28dd00c 	add	sp, sp, #12
30024414:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30024418:	e12fff1e 	bx	lr
3002441c:	300eab48 	.word	0x300eab48

30024420 <GetDiskInfo>:
**         
** ȫֱ: DiskInfo
** ģ: 
********************************************************************************************************/
        Disk_Info * GetDiskInfo(acoral_u8 Drive)
{
30024420:	e24dd010 	sub	sp, sp, #16
30024424:	e1a03000 	mov	r3, r0
30024428:	e5cd3007 	strb	r3, [sp, #7]
    Disk_Info *Rt;
    Rt = NULL;
3002442c:	e3a03000 	mov	r3, #0
30024430:	e58d300c 	str	r3, [sp, #12]
    if (Drive < MAX_DRIVES)
30024434:	e5dd3007 	ldrb	r3, [sp, #7]
30024438:	e3530000 	cmp	r3, #0
3002443c:	1a000016 	bne	3002449c <GetDiskInfo+0x7c>
    {
        if (DiskInfo[Drive].Drive != EMPTY_DRIVE)
30024440:	e5dd2007 	ldrb	r2, [sp, #7]
30024444:	e59f1060 	ldr	r1, [pc, #96]	; 300244ac <GetDiskInfo+0x8c>
30024448:	e1a03002 	mov	r3, r2
3002444c:	e1a03083 	lsl	r3, r3, #1
30024450:	e0833002 	add	r3, r3, r2
30024454:	e1a03103 	lsl	r3, r3, #2
30024458:	e0833002 	add	r3, r3, r2
3002445c:	e1a03103 	lsl	r3, r3, #2
30024460:	e0833001 	add	r3, r3, r1
30024464:	e5d33000 	ldrb	r3, [r3]
30024468:	e35300ff 	cmp	r3, #255	; 0xff
3002446c:	0a00000a 	beq	3002449c <GetDiskInfo+0x7c>
        {
            Rt = DiskInfo + Drive;
30024470:	e5dd2007 	ldrb	r2, [sp, #7]
30024474:	e1a03002 	mov	r3, r2
30024478:	e1a03083 	lsl	r3, r3, #1
3002447c:	e0833002 	add	r3, r3, r2
30024480:	e1a03103 	lsl	r3, r3, #2
30024484:	e0833002 	add	r3, r3, r2
30024488:	e1a03103 	lsl	r3, r3, #2
3002448c:	e1a02003 	mov	r2, r3
30024490:	e59f3014 	ldr	r3, [pc, #20]	; 300244ac <GetDiskInfo+0x8c>
30024494:	e0823003 	add	r3, r2, r3
30024498:	e58d300c 	str	r3, [sp, #12]
        }
    }
    return Rt;
3002449c:	e59d300c 	ldr	r3, [sp, #12]
}
300244a0:	e1a00003 	mov	r0, r3
300244a4:	e28dd010 	add	sp, sp, #16
300244a8:	e12fff1e 	bx	lr
300244ac:	300eab48 	.word	0x300eab48

300244b0 <AddFileDriver>:
** ȫֱ: DiskInfo
** ģ: 
********************************************************************************************************/
static acoral_u8 Buf[512];
        acoral_32 AddFileDriver(acoral_u16  (* DiakCommand)(acoral_u8 Cammand, void *Parameter),acoral_char *devname,acoral_u8 drive)
{
300244b0:	e92d4010 	push	{r4, lr}
300244b4:	e24dd028 	sub	sp, sp, #40	; 0x28
300244b8:	e58d000c 	str	r0, [sp, #12]
300244bc:	e58d1008 	str	r1, [sp, #8]
300244c0:	e1a03002 	mov	r3, r2
300244c4:	e5cd3007 	strb	r3, [sp, #7]
	Disk_RW_Parameter Pa;
    acoral_u16 temp;
    acoral_u32 temp1;
    Pa.Drive=drive;
300244c8:	e5dd3007 	ldrb	r3, [sp, #7]
300244cc:	e5cd3010 	strb	r3, [sp, #16]
    Pa.Buf=(acoral_u8 *)devname;
300244d0:	e59d3008 	ldr	r3, [sp, #8]
300244d4:	e58d301c 	str	r3, [sp, #28]
    if(DiskInfo[drive].Drive!=EMPTY_DRIVE)
300244d8:	e5dd2007 	ldrb	r2, [sp, #7]
300244dc:	e59f1970 	ldr	r1, [pc, #2416]	; 30024e54 <AddFileDriver+0x9a4>
300244e0:	e1a03002 	mov	r3, r2
300244e4:	e1a03083 	lsl	r3, r3, #1
300244e8:	e0833002 	add	r3, r3, r2
300244ec:	e1a03103 	lsl	r3, r3, #2
300244f0:	e0833002 	add	r3, r3, r2
300244f4:	e1a03103 	lsl	r3, r3, #2
300244f8:	e0833001 	add	r3, r3, r1
300244fc:	e5d33000 	ldrb	r3, [r3]
30024500:	e35300ff 	cmp	r3, #255	; 0xff
30024504:	0a000001 	beq	30024510 <AddFileDriver+0x60>
    	return -1;
30024508:	e3e03000 	mvn	r3, #0
3002450c:	ea00024c 	b	30024e44 <AddFileDriver+0x994>
    else
    	DiskInfo[drive].Drive=drive;
30024510:	e5dd2007 	ldrb	r2, [sp, #7]
30024514:	e59f1938 	ldr	r1, [pc, #2360]	; 30024e54 <AddFileDriver+0x9a4>
30024518:	e1a03002 	mov	r3, r2
3002451c:	e1a03083 	lsl	r3, r3, #1
30024520:	e0833002 	add	r3, r3, r2
30024524:	e1a03103 	lsl	r3, r3, #2
30024528:	e0833002 	add	r3, r3, r2
3002452c:	e1a03103 	lsl	r3, r3, #2
30024530:	e0833001 	add	r3, r3, r1
30024534:	e5dd2007 	ldrb	r2, [sp, #7]
30024538:	e5c32000 	strb	r2, [r3]
    
    
    if (DiakCommand == NULL)        // Ч˳
3002453c:	e59d300c 	ldr	r3, [sp, #12]
30024540:	e3530000 	cmp	r3, #0
30024544:	1a000001 	bne	30024550 <AddFileDriver+0xa0>
    {
        return -1;
30024548:	e3e03000 	mvn	r3, #0
3002454c:	ea00023c 	b	30024e44 <AddFileDriver+0x994>
    }

    if (DiakCommand(DISK_INIT, &Pa) == DISK_INIT_NOT_OK)   // ײʼɹ˳
30024550:	e28d2010 	add	r2, sp, #16
30024554:	e59d300c 	ldr	r3, [sp, #12]
30024558:	e3a00000 	mov	r0, #0
3002455c:	e1a01002 	mov	r1, r2
30024560:	e1a0e00f 	mov	lr, pc
30024564:	e12fff13 	bx	r3
30024568:	e1a03000 	mov	r3, r0
3002456c:	e3530083 	cmp	r3, #131	; 0x83
30024570:	1a000001 	bne	3002457c <AddFileDriver+0xcc>
    {
        return -1;
30024574:	e3e03000 	mvn	r3, #0
30024578:	ea000231 	b	30024e44 <AddFileDriver+0x994>
    }

	/*ʱCurrentDriveΪӦ豸*/
	CurrentDrive=drive;
3002457c:	e59f38d4 	ldr	r3, [pc, #2260]	; 30024e58 <AddFileDriver+0x9a8>
30024580:	e5dd2007 	ldrb	r2, [sp, #7]
30024584:	e5c32000 	strb	r2, [r3]
	/*豸ID豸ṹ*/
   /*	if(DiskInfo[i].DevId==ACORAL_DEV_ERR_ID)
		DiskInfo[i].DevId=acoral_dev_open(devname);
    *///Buf = OpenSec(DiskInfo[i].Drive, 0);    /* 0 */
    ReadSuperSec(drive,Buf);
30024588:	e5dd3007 	ldrb	r3, [sp, #7]
3002458c:	e1a00003 	mov	r0, r3
30024590:	e59f18c4 	ldr	r1, [pc, #2244]	; 30024e5c <AddFileDriver+0x9ac>
30024594:	eb001ea8 	bl	3002c03c <ReadSuperSec>
    if (Buf != NULL)
    {
        /* ÿֽ */
        DiskInfo[drive].BytsPerSec = Buf[11] | (Buf[12] << 8);
30024598:	e5dd2007 	ldrb	r2, [sp, #7]
3002459c:	e59f38b8 	ldr	r3, [pc, #2232]	; 30024e5c <AddFileDriver+0x9ac>
300245a0:	e5d3300b 	ldrb	r3, [r3, #11]
300245a4:	e1a01003 	mov	r1, r3
300245a8:	e59f38ac 	ldr	r3, [pc, #2220]	; 30024e5c <AddFileDriver+0x9ac>
300245ac:	e5d3300c 	ldrb	r3, [r3, #12]
300245b0:	e1a03403 	lsl	r3, r3, #8
300245b4:	e1813003 	orr	r3, r1, r3
300245b8:	e1a01003 	mov	r1, r3
300245bc:	e59fc890 	ldr	ip, [pc, #2192]	; 30024e54 <AddFileDriver+0x9a4>
300245c0:	e3a0000c 	mov	r0, #12
300245c4:	e1a03002 	mov	r3, r2
300245c8:	e1a03083 	lsl	r3, r3, #1
300245cc:	e0833002 	add	r3, r3, r2
300245d0:	e1a03103 	lsl	r3, r3, #2
300245d4:	e0833002 	add	r3, r3, r2
300245d8:	e1a03103 	lsl	r3, r3, #2
300245dc:	e083300c 	add	r3, r3, ip
300245e0:	e0833000 	add	r3, r3, r0
300245e4:	e5831000 	str	r1, [r3]
        /* ÿ */
        DiskInfo[drive].SecPerClus = Buf[13];
300245e8:	e5dd2007 	ldrb	r2, [sp, #7]
300245ec:	e59f3868 	ldr	r3, [pc, #2152]	; 30024e5c <AddFileDriver+0x9ac>
300245f0:	e5d3100d 	ldrb	r1, [r3, #13]
300245f4:	e59f0858 	ldr	r0, [pc, #2136]	; 30024e54 <AddFileDriver+0x9a4>
300245f8:	e1a03002 	mov	r3, r2
300245fc:	e1a03083 	lsl	r3, r3, #1
30024600:	e0833002 	add	r3, r3, r2
30024604:	e1a03103 	lsl	r3, r3, #2
30024608:	e0833002 	add	r3, r3, r2
3002460c:	e1a03103 	lsl	r3, r3, #2
30024610:	e0833000 	add	r3, r3, r0
30024614:	e1a02001 	mov	r2, r1
30024618:	e5c32002 	strb	r2, [r3, #2]
        /* FATʼ */
        DiskInfo[drive].FATStartSec = Buf[14] | (Buf[15] << 8);
3002461c:	e5dd2007 	ldrb	r2, [sp, #7]
30024620:	e59f3834 	ldr	r3, [pc, #2100]	; 30024e5c <AddFileDriver+0x9ac>
30024624:	e5d3300e 	ldrb	r3, [r3, #14]
30024628:	e1a01003 	mov	r1, r3
3002462c:	e59f3828 	ldr	r3, [pc, #2088]	; 30024e5c <AddFileDriver+0x9ac>
30024630:	e5d3300f 	ldrb	r3, [r3, #15]
30024634:	e1a03403 	lsl	r3, r3, #8
30024638:	e1813003 	orr	r3, r1, r3
3002463c:	e1a01003 	mov	r1, r3
30024640:	e59fc80c 	ldr	ip, [pc, #2060]	; 30024e54 <AddFileDriver+0x9a4>
30024644:	e3a00018 	mov	r0, #24
30024648:	e1a03002 	mov	r3, r2
3002464c:	e1a03083 	lsl	r3, r3, #1
30024650:	e0833002 	add	r3, r3, r2
30024654:	e1a03103 	lsl	r3, r3, #2
30024658:	e0833002 	add	r3, r3, r2
3002465c:	e1a03103 	lsl	r3, r3, #2
30024660:	e083300c 	add	r3, r3, ip
30024664:	e0833000 	add	r3, r3, r0
30024668:	e5831000 	str	r1, [r3]
        /* FAT */
        DiskInfo[drive].NumFATs = Buf[16];
3002466c:	e5dd2007 	ldrb	r2, [sp, #7]
30024670:	e59f37e4 	ldr	r3, [pc, #2020]	; 30024e5c <AddFileDriver+0x9ac>
30024674:	e5d31010 	ldrb	r1, [r3, #16]
30024678:	e59f07d4 	ldr	r0, [pc, #2004]	; 30024e54 <AddFileDriver+0x9a4>
3002467c:	e1a03002 	mov	r3, r2
30024680:	e1a03083 	lsl	r3, r3, #1
30024684:	e0833002 	add	r3, r3, r2
30024688:	e1a03103 	lsl	r3, r3, #2
3002468c:	e0833002 	add	r3, r3, r2
30024690:	e1a03103 	lsl	r3, r3, #2
30024694:	e0833000 	add	r3, r3, r0
30024698:	e1a02001 	mov	r2, r1
3002469c:	e5c32003 	strb	r2, [r3, #3]
        /* Ŀ¼ռ */ 
        DiskInfo[drive].RootSecCnt = ((Buf[17] | (Buf[18] << 8)) * 32 + 
300246a0:	e5dd4007 	ldrb	r4, [sp, #7]
300246a4:	e59f37b0 	ldr	r3, [pc, #1968]	; 30024e5c <AddFileDriver+0x9ac>
300246a8:	e5d33011 	ldrb	r3, [r3, #17]
300246ac:	e1a02003 	mov	r2, r3
300246b0:	e59f37a4 	ldr	r3, [pc, #1956]	; 30024e5c <AddFileDriver+0x9ac>
300246b4:	e5d33012 	ldrb	r3, [r3, #18]
300246b8:	e1a03403 	lsl	r3, r3, #8
300246bc:	e1823003 	orr	r3, r2, r3
300246c0:	e1a03283 	lsl	r3, r3, #5
                                   DiskInfo[drive].BytsPerSec - 1) /
300246c4:	e1a01003 	mov	r1, r3
300246c8:	e5dd2007 	ldrb	r2, [sp, #7]
300246cc:	e59fc780 	ldr	ip, [pc, #1920]	; 30024e54 <AddFileDriver+0x9a4>
300246d0:	e3a0000c 	mov	r0, #12
300246d4:	e1a03002 	mov	r3, r2
300246d8:	e1a03083 	lsl	r3, r3, #1
300246dc:	e0833002 	add	r3, r3, r2
300246e0:	e1a03103 	lsl	r3, r3, #2
300246e4:	e0833002 	add	r3, r3, r2
300246e8:	e1a03103 	lsl	r3, r3, #2
300246ec:	e083300c 	add	r3, r3, ip
300246f0:	e0833000 	add	r3, r3, r0
300246f4:	e5933000 	ldr	r3, [r3]
300246f8:	e0813003 	add	r3, r1, r3
        /* FATʼ */
        DiskInfo[drive].FATStartSec = Buf[14] | (Buf[15] << 8);
        /* FAT */
        DiskInfo[drive].NumFATs = Buf[16];
        /* Ŀ¼ռ */ 
        DiskInfo[drive].RootSecCnt = ((Buf[17] | (Buf[18] << 8)) * 32 + 
300246fc:	e2431001 	sub	r1, r3, #1
30024700:	e5dd2007 	ldrb	r2, [sp, #7]
30024704:	e59fc748 	ldr	ip, [pc, #1864]	; 30024e54 <AddFileDriver+0x9a4>
30024708:	e3a0000c 	mov	r0, #12
3002470c:	e1a03002 	mov	r3, r2
30024710:	e1a03083 	lsl	r3, r3, #1
30024714:	e0833002 	add	r3, r3, r2
30024718:	e1a03103 	lsl	r3, r3, #2
3002471c:	e0833002 	add	r3, r3, r2
30024720:	e1a03103 	lsl	r3, r3, #2
30024724:	e083300c 	add	r3, r3, ip
30024728:	e0833000 	add	r3, r3, r0
3002472c:	e5933000 	ldr	r3, [r3]
30024730:	e1a00001 	mov	r0, r1
30024734:	e1a01003 	mov	r1, r3
30024738:	eb007d58 	bl	30043ca0 <__aeabi_uidiv>
3002473c:	e1a03000 	mov	r3, r0
30024740:	e1a02003 	mov	r2, r3
30024744:	e59f0708 	ldr	r0, [pc, #1800]	; 30024e54 <AddFileDriver+0x9a4>
30024748:	e3a01014 	mov	r1, #20
3002474c:	e1a03004 	mov	r3, r4
30024750:	e1a03083 	lsl	r3, r3, #1
30024754:	e0833004 	add	r3, r3, r4
30024758:	e1a03103 	lsl	r3, r3, #2
3002475c:	e0833004 	add	r3, r3, r4
30024760:	e1a03103 	lsl	r3, r3, #2
30024764:	e0833000 	add	r3, r3, r0
30024768:	e0833001 	add	r3, r3, r1
3002476c:	e5832000 	str	r2, [r3]
                                   DiskInfo[drive].BytsPerSec - 1) /
                                   DiskInfo[drive].BytsPerSec;
        /* ߼̣ռ */
        temp = Buf[19] | (Buf[20] << 8);
30024770:	e59f36e4 	ldr	r3, [pc, #1764]	; 30024e5c <AddFileDriver+0x9ac>
30024774:	e5d33013 	ldrb	r3, [r3, #19]
30024778:	e1a02003 	mov	r2, r3
3002477c:	e59f36d8 	ldr	r3, [pc, #1752]	; 30024e5c <AddFileDriver+0x9ac>
30024780:	e5d33014 	ldrb	r3, [r3, #20]
30024784:	e1a03403 	lsl	r3, r3, #8
30024788:	e1a03803 	lsl	r3, r3, #16
3002478c:	e1a03823 	lsr	r3, r3, #16
30024790:	e1823003 	orr	r3, r2, r3
30024794:	e1a03803 	lsl	r3, r3, #16
30024798:	e1a03823 	lsr	r3, r3, #16
3002479c:	e1cd32b2 	strh	r3, [sp, #34]	; 0x22
        if (temp != 0)
300247a0:	e1dd32b2 	ldrh	r3, [sp, #34]	; 0x22
300247a4:	e3530000 	cmp	r3, #0
300247a8:	0a00000d 	beq	300247e4 <AddFileDriver+0x334>
        {
            DiskInfo[drive].SecPerDisk = temp;
300247ac:	e5dd2007 	ldrb	r2, [sp, #7]
300247b0:	e1dd12b2 	ldrh	r1, [sp, #34]	; 0x22
300247b4:	e59fc698 	ldr	ip, [pc, #1688]	; 30024e54 <AddFileDriver+0x9a4>
300247b8:	e3a00008 	mov	r0, #8
300247bc:	e1a03002 	mov	r3, r2
300247c0:	e1a03083 	lsl	r3, r3, #1
300247c4:	e0833002 	add	r3, r3, r2
300247c8:	e1a03103 	lsl	r3, r3, #2
300247cc:	e0833002 	add	r3, r3, r2
300247d0:	e1a03103 	lsl	r3, r3, #2
300247d4:	e083300c 	add	r3, r3, ip
300247d8:	e0833000 	add	r3, r3, r0
300247dc:	e5831000 	str	r1, [r3]
300247e0:	ea000033 	b	300248b4 <AddFileDriver+0x404>
        }
        else
        {
            DiskInfo[drive].SecPerDisk = Buf[32] | (Buf[33] << 8);
300247e4:	e5dd2007 	ldrb	r2, [sp, #7]
300247e8:	e59f366c 	ldr	r3, [pc, #1644]	; 30024e5c <AddFileDriver+0x9ac>
300247ec:	e5d33020 	ldrb	r3, [r3, #32]
300247f0:	e1a01003 	mov	r1, r3
300247f4:	e59f3660 	ldr	r3, [pc, #1632]	; 30024e5c <AddFileDriver+0x9ac>
300247f8:	e5d33021 	ldrb	r3, [r3, #33]	; 0x21
300247fc:	e1a03403 	lsl	r3, r3, #8
30024800:	e1813003 	orr	r3, r1, r3
30024804:	e1a01003 	mov	r1, r3
30024808:	e59fc644 	ldr	ip, [pc, #1604]	; 30024e54 <AddFileDriver+0x9a4>
3002480c:	e3a00008 	mov	r0, #8
30024810:	e1a03002 	mov	r3, r2
30024814:	e1a03083 	lsl	r3, r3, #1
30024818:	e0833002 	add	r3, r3, r2
3002481c:	e1a03103 	lsl	r3, r3, #2
30024820:	e0833002 	add	r3, r3, r2
30024824:	e1a03103 	lsl	r3, r3, #2
30024828:	e083300c 	add	r3, r3, ip
3002482c:	e0833000 	add	r3, r3, r0
30024830:	e5831000 	str	r1, [r3]
            DiskInfo[drive].SecPerDisk |= (((acoral_u32)Buf[34] << 16) | ((acoral_u32)Buf[35] << 24));
30024834:	e5dd2007 	ldrb	r2, [sp, #7]
30024838:	e5dd1007 	ldrb	r1, [sp, #7]
3002483c:	e59fc610 	ldr	ip, [pc, #1552]	; 30024e54 <AddFileDriver+0x9a4>
30024840:	e3a00008 	mov	r0, #8
30024844:	e1a03001 	mov	r3, r1
30024848:	e1a03083 	lsl	r3, r3, #1
3002484c:	e0833001 	add	r3, r3, r1
30024850:	e1a03103 	lsl	r3, r3, #2
30024854:	e0833001 	add	r3, r3, r1
30024858:	e1a03103 	lsl	r3, r3, #2
3002485c:	e083300c 	add	r3, r3, ip
30024860:	e0833000 	add	r3, r3, r0
30024864:	e5931000 	ldr	r1, [r3]
30024868:	e59f35ec 	ldr	r3, [pc, #1516]	; 30024e5c <AddFileDriver+0x9ac>
3002486c:	e5d33022 	ldrb	r3, [r3, #34]	; 0x22
30024870:	e1a00803 	lsl	r0, r3, #16
30024874:	e59f35e0 	ldr	r3, [pc, #1504]	; 30024e5c <AddFileDriver+0x9ac>
30024878:	e5d33023 	ldrb	r3, [r3, #35]	; 0x23
3002487c:	e1a03c03 	lsl	r3, r3, #24
30024880:	e1803003 	orr	r3, r0, r3
30024884:	e1811003 	orr	r1, r1, r3
30024888:	e59fc5c4 	ldr	ip, [pc, #1476]	; 30024e54 <AddFileDriver+0x9a4>
3002488c:	e3a00008 	mov	r0, #8
30024890:	e1a03002 	mov	r3, r2
30024894:	e1a03083 	lsl	r3, r3, #1
30024898:	e0833002 	add	r3, r3, r2
3002489c:	e1a03103 	lsl	r3, r3, #2
300248a0:	e0833002 	add	r3, r3, r2
300248a4:	e1a03103 	lsl	r3, r3, #2
300248a8:	e083300c 	add	r3, r3, ip
300248ac:	e0833000 	add	r3, r3, r0
300248b0:	e5831000 	str	r1, [r3]
        }
        /* FATռ */
        temp = Buf[22] | (Buf[23] << 8);
300248b4:	e59f35a0 	ldr	r3, [pc, #1440]	; 30024e5c <AddFileDriver+0x9ac>
300248b8:	e5d33016 	ldrb	r3, [r3, #22]
300248bc:	e1a02003 	mov	r2, r3
300248c0:	e59f3594 	ldr	r3, [pc, #1428]	; 30024e5c <AddFileDriver+0x9ac>
300248c4:	e5d33017 	ldrb	r3, [r3, #23]
300248c8:	e1a03403 	lsl	r3, r3, #8
300248cc:	e1a03803 	lsl	r3, r3, #16
300248d0:	e1a03823 	lsr	r3, r3, #16
300248d4:	e1823003 	orr	r3, r2, r3
300248d8:	e1a03803 	lsl	r3, r3, #16
300248dc:	e1a03823 	lsr	r3, r3, #16
300248e0:	e1cd32b2 	strh	r3, [sp, #34]	; 0x22
        if (temp != 0)
300248e4:	e1dd32b2 	ldrh	r3, [sp, #34]	; 0x22
300248e8:	e3530000 	cmp	r3, #0
300248ec:	0a00000d 	beq	30024928 <AddFileDriver+0x478>
        {
            DiskInfo[drive].FATSecCnt = temp;
300248f0:	e5dd2007 	ldrb	r2, [sp, #7]
300248f4:	e1dd12b2 	ldrh	r1, [sp, #34]	; 0x22
300248f8:	e59fc554 	ldr	ip, [pc, #1364]	; 30024e54 <AddFileDriver+0x9a4>
300248fc:	e3a0001c 	mov	r0, #28
30024900:	e1a03002 	mov	r3, r2
30024904:	e1a03083 	lsl	r3, r3, #1
30024908:	e0833002 	add	r3, r3, r2
3002490c:	e1a03103 	lsl	r3, r3, #2
30024910:	e0833002 	add	r3, r3, r2
30024914:	e1a03103 	lsl	r3, r3, #2
30024918:	e083300c 	add	r3, r3, ip
3002491c:	e0833000 	add	r3, r3, r0
30024920:	e5831000 	str	r1, [r3]
30024924:	ea000033 	b	300249f8 <AddFileDriver+0x548>
        }
        else
        {
            DiskInfo[drive].FATSecCnt = Buf[36] | (Buf[37] << 8);
30024928:	e5dd2007 	ldrb	r2, [sp, #7]
3002492c:	e59f3528 	ldr	r3, [pc, #1320]	; 30024e5c <AddFileDriver+0x9ac>
30024930:	e5d33024 	ldrb	r3, [r3, #36]	; 0x24
30024934:	e1a01003 	mov	r1, r3
30024938:	e59f351c 	ldr	r3, [pc, #1308]	; 30024e5c <AddFileDriver+0x9ac>
3002493c:	e5d33025 	ldrb	r3, [r3, #37]	; 0x25
30024940:	e1a03403 	lsl	r3, r3, #8
30024944:	e1813003 	orr	r3, r1, r3
30024948:	e1a01003 	mov	r1, r3
3002494c:	e59fc500 	ldr	ip, [pc, #1280]	; 30024e54 <AddFileDriver+0x9a4>
30024950:	e3a0001c 	mov	r0, #28
30024954:	e1a03002 	mov	r3, r2
30024958:	e1a03083 	lsl	r3, r3, #1
3002495c:	e0833002 	add	r3, r3, r2
30024960:	e1a03103 	lsl	r3, r3, #2
30024964:	e0833002 	add	r3, r3, r2
30024968:	e1a03103 	lsl	r3, r3, #2
3002496c:	e083300c 	add	r3, r3, ip
30024970:	e0833000 	add	r3, r3, r0
30024974:	e5831000 	str	r1, [r3]
            DiskInfo[drive].FATSecCnt |= (((acoral_u32)Buf[38] << 16) | (acoral_u32)(Buf[39] << 24));
30024978:	e5dd2007 	ldrb	r2, [sp, #7]
3002497c:	e5dd1007 	ldrb	r1, [sp, #7]
30024980:	e59fc4cc 	ldr	ip, [pc, #1228]	; 30024e54 <AddFileDriver+0x9a4>
30024984:	e3a0001c 	mov	r0, #28
30024988:	e1a03001 	mov	r3, r1
3002498c:	e1a03083 	lsl	r3, r3, #1
30024990:	e0833001 	add	r3, r3, r1
30024994:	e1a03103 	lsl	r3, r3, #2
30024998:	e0833001 	add	r3, r3, r1
3002499c:	e1a03103 	lsl	r3, r3, #2
300249a0:	e083300c 	add	r3, r3, ip
300249a4:	e0833000 	add	r3, r3, r0
300249a8:	e5931000 	ldr	r1, [r3]
300249ac:	e59f34a8 	ldr	r3, [pc, #1192]	; 30024e5c <AddFileDriver+0x9ac>
300249b0:	e5d33026 	ldrb	r3, [r3, #38]	; 0x26
300249b4:	e1a00803 	lsl	r0, r3, #16
300249b8:	e59f349c 	ldr	r3, [pc, #1180]	; 30024e5c <AddFileDriver+0x9ac>
300249bc:	e5d33027 	ldrb	r3, [r3, #39]	; 0x27
300249c0:	e1a03c03 	lsl	r3, r3, #24
300249c4:	e1803003 	orr	r3, r0, r3
300249c8:	e1811003 	orr	r1, r1, r3
300249cc:	e59fc480 	ldr	ip, [pc, #1152]	; 30024e54 <AddFileDriver+0x9a4>
300249d0:	e3a0001c 	mov	r0, #28
300249d4:	e1a03002 	mov	r3, r2
300249d8:	e1a03083 	lsl	r3, r3, #1
300249dc:	e0833002 	add	r3, r3, r2
300249e0:	e1a03103 	lsl	r3, r3, #2
300249e4:	e0833002 	add	r3, r3, r2
300249e8:	e1a03103 	lsl	r3, r3, #2
300249ec:	e083300c 	add	r3, r3, ip
300249f0:	e0833000 	add	r3, r3, r0
300249f4:	e5831000 	str	r1, [r3]
        }
        
        /* ǰĿ¼ΪĿ¼ */
        DiskInfo[drive].PathClusIndex = 0;
300249f8:	e5dd2007 	ldrb	r2, [sp, #7]
300249fc:	e59f0450 	ldr	r0, [pc, #1104]	; 30024e54 <AddFileDriver+0x9a4>
30024a00:	e3a01028 	mov	r1, #40	; 0x28
30024a04:	e1a03002 	mov	r3, r2
30024a08:	e1a03083 	lsl	r3, r3, #1
30024a0c:	e0833002 	add	r3, r3, r2
30024a10:	e1a03103 	lsl	r3, r3, #2
30024a14:	e0833002 	add	r3, r3, r2
30024a18:	e1a03103 	lsl	r3, r3, #2
30024a1c:	e0833000 	add	r3, r3, r0
30024a20:	e0833001 	add	r3, r3, r1
30024a24:	e3a02000 	mov	r2, #0
30024a28:	e5832000 	str	r2, [r3]
    }
    /* Ŀ¼ʼ */
    DiskInfo[drive].RootDirTable = DiskInfo[drive].NumFATs * DiskInfo[drive].FATSecCnt + 
30024a2c:	e5dd2007 	ldrb	r2, [sp, #7]
30024a30:	e5dd1007 	ldrb	r1, [sp, #7]
30024a34:	e59f0418 	ldr	r0, [pc, #1048]	; 30024e54 <AddFileDriver+0x9a4>
30024a38:	e1a03001 	mov	r3, r1
30024a3c:	e1a03083 	lsl	r3, r3, #1
30024a40:	e0833001 	add	r3, r3, r1
30024a44:	e1a03103 	lsl	r3, r3, #2
30024a48:	e0833001 	add	r3, r3, r1
30024a4c:	e1a03103 	lsl	r3, r3, #2
30024a50:	e0833000 	add	r3, r3, r0
30024a54:	e5d33003 	ldrb	r3, [r3, #3]
30024a58:	e1a00003 	mov	r0, r3
30024a5c:	e5dd1007 	ldrb	r1, [sp, #7]
30024a60:	e59fe3ec 	ldr	lr, [pc, #1004]	; 30024e54 <AddFileDriver+0x9a4>
30024a64:	e3a0c01c 	mov	ip, #28
30024a68:	e1a03001 	mov	r3, r1
30024a6c:	e1a03083 	lsl	r3, r3, #1
30024a70:	e0833001 	add	r3, r3, r1
30024a74:	e1a03103 	lsl	r3, r3, #2
30024a78:	e0833001 	add	r3, r3, r1
30024a7c:	e1a03103 	lsl	r3, r3, #2
30024a80:	e083300e 	add	r3, r3, lr
30024a84:	e083300c 	add	r3, r3, ip
30024a88:	e5933000 	ldr	r3, [r3]
30024a8c:	e0000093 	mul	r0, r3, r0
30024a90:	e5dd1007 	ldrb	r1, [sp, #7]
30024a94:	e59fe3b8 	ldr	lr, [pc, #952]	; 30024e54 <AddFileDriver+0x9a4>
30024a98:	e3a0c018 	mov	ip, #24
30024a9c:	e1a03001 	mov	r3, r1
30024aa0:	e1a03083 	lsl	r3, r3, #1
30024aa4:	e0833001 	add	r3, r3, r1
30024aa8:	e1a03103 	lsl	r3, r3, #2
30024aac:	e0833001 	add	r3, r3, r1
30024ab0:	e1a03103 	lsl	r3, r3, #2
30024ab4:	e083300e 	add	r3, r3, lr
30024ab8:	e083300c 	add	r3, r3, ip
30024abc:	e5933000 	ldr	r3, [r3]
30024ac0:	e0801003 	add	r1, r0, r3
30024ac4:	e59fc388 	ldr	ip, [pc, #904]	; 30024e54 <AddFileDriver+0x9a4>
30024ac8:	e3a00010 	mov	r0, #16
30024acc:	e1a03002 	mov	r3, r2
30024ad0:	e1a03083 	lsl	r3, r3, #1
30024ad4:	e0833002 	add	r3, r3, r2
30024ad8:	e1a03103 	lsl	r3, r3, #2
30024adc:	e0833002 	add	r3, r3, r2
30024ae0:	e1a03103 	lsl	r3, r3, #2
30024ae4:	e083300c 	add	r3, r3, ip
30024ae8:	e0833000 	add	r3, r3, r0
30024aec:	e5831000 	str	r1, [r3]
                               DiskInfo[drive].FATStartSec;
    /* ʼ */
    DiskInfo[drive].DataStartSec = DiskInfo[drive].RootDirTable + DiskInfo[drive].RootSecCnt;
30024af0:	e5dd2007 	ldrb	r2, [sp, #7]
30024af4:	e5dd1007 	ldrb	r1, [sp, #7]
30024af8:	e59fc354 	ldr	ip, [pc, #852]	; 30024e54 <AddFileDriver+0x9a4>
30024afc:	e3a00010 	mov	r0, #16
30024b00:	e1a03001 	mov	r3, r1
30024b04:	e1a03083 	lsl	r3, r3, #1
30024b08:	e0833001 	add	r3, r3, r1
30024b0c:	e1a03103 	lsl	r3, r3, #2
30024b10:	e0833001 	add	r3, r3, r1
30024b14:	e1a03103 	lsl	r3, r3, #2
30024b18:	e083300c 	add	r3, r3, ip
30024b1c:	e0833000 	add	r3, r3, r0
30024b20:	e5930000 	ldr	r0, [r3]
30024b24:	e5dd1007 	ldrb	r1, [sp, #7]
30024b28:	e59fe324 	ldr	lr, [pc, #804]	; 30024e54 <AddFileDriver+0x9a4>
30024b2c:	e3a0c014 	mov	ip, #20
30024b30:	e1a03001 	mov	r3, r1
30024b34:	e1a03083 	lsl	r3, r3, #1
30024b38:	e0833001 	add	r3, r3, r1
30024b3c:	e1a03103 	lsl	r3, r3, #2
30024b40:	e0833001 	add	r3, r3, r1
30024b44:	e1a03103 	lsl	r3, r3, #2
30024b48:	e083300e 	add	r3, r3, lr
30024b4c:	e083300c 	add	r3, r3, ip
30024b50:	e5933000 	ldr	r3, [r3]
30024b54:	e0801003 	add	r1, r0, r3
30024b58:	e59fc2f4 	ldr	ip, [pc, #756]	; 30024e54 <AddFileDriver+0x9a4>
30024b5c:	e3a00020 	mov	r0, #32
30024b60:	e1a03002 	mov	r3, r2
30024b64:	e1a03083 	lsl	r3, r3, #1
30024b68:	e0833002 	add	r3, r3, r2
30024b6c:	e1a03103 	lsl	r3, r3, #2
30024b70:	e0833002 	add	r3, r3, r2
30024b74:	e1a03103 	lsl	r3, r3, #2
30024b78:	e083300c 	add	r3, r3, ip
30024b7c:	e0833000 	add	r3, r3, r0
30024b80:	e5831000 	str	r1, [r3]
    temp1 = DiskInfo[drive].SecPerDisk - DiskInfo[drive].DataStartSec;
30024b84:	e5dd2007 	ldrb	r2, [sp, #7]
30024b88:	e59f02c4 	ldr	r0, [pc, #708]	; 30024e54 <AddFileDriver+0x9a4>
30024b8c:	e3a01008 	mov	r1, #8
30024b90:	e1a03002 	mov	r3, r2
30024b94:	e1a03083 	lsl	r3, r3, #1
30024b98:	e0833002 	add	r3, r3, r2
30024b9c:	e1a03103 	lsl	r3, r3, #2
30024ba0:	e0833002 	add	r3, r3, r2
30024ba4:	e1a03103 	lsl	r3, r3, #2
30024ba8:	e0833000 	add	r3, r3, r0
30024bac:	e0833001 	add	r3, r3, r1
30024bb0:	e5931000 	ldr	r1, [r3]
30024bb4:	e5dd2007 	ldrb	r2, [sp, #7]
30024bb8:	e59fc294 	ldr	ip, [pc, #660]	; 30024e54 <AddFileDriver+0x9a4>
30024bbc:	e3a00020 	mov	r0, #32
30024bc0:	e1a03002 	mov	r3, r2
30024bc4:	e1a03083 	lsl	r3, r3, #1
30024bc8:	e0833002 	add	r3, r3, r2
30024bcc:	e1a03103 	lsl	r3, r3, #2
30024bd0:	e0833002 	add	r3, r3, r2
30024bd4:	e1a03103 	lsl	r3, r3, #2
30024bd8:	e083300c 	add	r3, r3, ip
30024bdc:	e0833000 	add	r3, r3, r0
30024be0:	e5933000 	ldr	r3, [r3]
30024be4:	e0633001 	rsb	r3, r3, r1
30024be8:	e58d3024 	str	r3, [sp, #36]	; 0x24
    temp1 = temp1 / DiskInfo[drive].SecPerClus;
30024bec:	e5dd2007 	ldrb	r2, [sp, #7]
30024bf0:	e59f125c 	ldr	r1, [pc, #604]	; 30024e54 <AddFileDriver+0x9a4>
30024bf4:	e1a03002 	mov	r3, r2
30024bf8:	e1a03083 	lsl	r3, r3, #1
30024bfc:	e0833002 	add	r3, r3, r2
30024c00:	e1a03103 	lsl	r3, r3, #2
30024c04:	e0833002 	add	r3, r3, r2
30024c08:	e1a03103 	lsl	r3, r3, #2
30024c0c:	e0833001 	add	r3, r3, r1
30024c10:	e5d33002 	ldrb	r3, [r3, #2]
30024c14:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
30024c18:	e1a01003 	mov	r1, r3
30024c1c:	eb007c1f 	bl	30043ca0 <__aeabi_uidiv>
30024c20:	e1a03000 	mov	r3, r0
30024c24:	e58d3024 	str	r3, [sp, #36]	; 0x24
    DiskInfo[drive].ClusPerData = temp1;
30024c28:	e5dd2007 	ldrb	r2, [sp, #7]
30024c2c:	e59f0220 	ldr	r0, [pc, #544]	; 30024e54 <AddFileDriver+0x9a4>
30024c30:	e3a01024 	mov	r1, #36	; 0x24
30024c34:	e1a03002 	mov	r3, r2
30024c38:	e1a03083 	lsl	r3, r3, #1
30024c3c:	e0833002 	add	r3, r3, r2
30024c40:	e1a03103 	lsl	r3, r3, #2
30024c44:	e0833002 	add	r3, r3, r2
30024c48:	e1a03103 	lsl	r3, r3, #2
30024c4c:	e0833000 	add	r3, r3, r0
30024c50:	e0833001 	add	r3, r3, r1
30024c54:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30024c58:	e5832000 	str	r2, [r3]
    /* жFAT12FAT16FAT32 */
    if (temp1 < 4085)
30024c5c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30024c60:	e3a03eff 	mov	r3, #4080	; 0xff0
30024c64:	e2833004 	add	r3, r3, #4
30024c68:	e1520003 	cmp	r2, r3
30024c6c:	8a00000b 	bhi	30024ca0 <AddFileDriver+0x7f0>
    {
        DiskInfo[drive].FATType = FAT12;
30024c70:	e5dd2007 	ldrb	r2, [sp, #7]
30024c74:	e59f11d8 	ldr	r1, [pc, #472]	; 30024e54 <AddFileDriver+0x9a4>
30024c78:	e1a03002 	mov	r3, r2
30024c7c:	e1a03083 	lsl	r3, r3, #1
30024c80:	e0833002 	add	r3, r3, r2
30024c84:	e1a03103 	lsl	r3, r3, #2
30024c88:	e0833002 	add	r3, r3, r2
30024c8c:	e1a03103 	lsl	r3, r3, #2
30024c90:	e0833001 	add	r3, r3, r1
30024c94:	e3a02000 	mov	r2, #0
30024c98:	e5c32001 	strb	r2, [r3, #1]
30024c9c:	ea000067 	b	30024e40 <AddFileDriver+0x990>
    }
    else if (temp1 < 65525)
30024ca0:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30024ca4:	e3a03cff 	mov	r3, #65280	; 0xff00
30024ca8:	e28330f4 	add	r3, r3, #244	; 0xf4
30024cac:	e1520003 	cmp	r2, r3
30024cb0:	8a00000b 	bhi	30024ce4 <AddFileDriver+0x834>
    {
        DiskInfo[drive].FATType = FAT16;
30024cb4:	e5dd2007 	ldrb	r2, [sp, #7]
30024cb8:	e59f1194 	ldr	r1, [pc, #404]	; 30024e54 <AddFileDriver+0x9a4>
30024cbc:	e1a03002 	mov	r3, r2
30024cc0:	e1a03083 	lsl	r3, r3, #1
30024cc4:	e0833002 	add	r3, r3, r2
30024cc8:	e1a03103 	lsl	r3, r3, #2
30024ccc:	e0833002 	add	r3, r3, r2
30024cd0:	e1a03103 	lsl	r3, r3, #2
30024cd4:	e0833001 	add	r3, r3, r1
30024cd8:	e3a02001 	mov	r2, #1
30024cdc:	e5c32001 	strb	r2, [r3, #1]
30024ce0:	ea000056 	b	30024e40 <AddFileDriver+0x990>
    }
    else
    {
        DiskInfo[drive].FATType = FAT32;
30024ce4:	e5dd2007 	ldrb	r2, [sp, #7]
30024ce8:	e59f1164 	ldr	r1, [pc, #356]	; 30024e54 <AddFileDriver+0x9a4>
30024cec:	e1a03002 	mov	r3, r2
30024cf0:	e1a03083 	lsl	r3, r3, #1
30024cf4:	e0833002 	add	r3, r3, r2
30024cf8:	e1a03103 	lsl	r3, r3, #2
30024cfc:	e0833002 	add	r3, r3, r2
30024d00:	e1a03103 	lsl	r3, r3, #2
30024d04:	e0833001 	add	r3, r3, r1
30024d08:	e3a02002 	mov	r2, #2
30024d0c:	e5c32001 	strb	r2, [r3, #1]
        /* FAT32 RootDirTableΪʼغ */
        DiskInfo[drive].RootDirTable = Buf[44] | (Buf[45] << 8);
30024d10:	e5dd2007 	ldrb	r2, [sp, #7]
30024d14:	e59f3140 	ldr	r3, [pc, #320]	; 30024e5c <AddFileDriver+0x9ac>
30024d18:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
30024d1c:	e1a01003 	mov	r1, r3
30024d20:	e59f3134 	ldr	r3, [pc, #308]	; 30024e5c <AddFileDriver+0x9ac>
30024d24:	e5d3302d 	ldrb	r3, [r3, #45]	; 0x2d
30024d28:	e1a03403 	lsl	r3, r3, #8
30024d2c:	e1813003 	orr	r3, r1, r3
30024d30:	e1a01003 	mov	r1, r3
30024d34:	e59fc118 	ldr	ip, [pc, #280]	; 30024e54 <AddFileDriver+0x9a4>
30024d38:	e3a00010 	mov	r0, #16
30024d3c:	e1a03002 	mov	r3, r2
30024d40:	e1a03083 	lsl	r3, r3, #1
30024d44:	e0833002 	add	r3, r3, r2
30024d48:	e1a03103 	lsl	r3, r3, #2
30024d4c:	e0833002 	add	r3, r3, r2
30024d50:	e1a03103 	lsl	r3, r3, #2
30024d54:	e083300c 	add	r3, r3, ip
30024d58:	e0833000 	add	r3, r3, r0
30024d5c:	e5831000 	str	r1, [r3]
        DiskInfo[drive].RootDirTable |= (((acoral_u32)Buf[46] << 16) | ((acoral_u32)Buf[47] << 24));
30024d60:	e5dd2007 	ldrb	r2, [sp, #7]
30024d64:	e5dd1007 	ldrb	r1, [sp, #7]
30024d68:	e59fc0e4 	ldr	ip, [pc, #228]	; 30024e54 <AddFileDriver+0x9a4>
30024d6c:	e3a00010 	mov	r0, #16
30024d70:	e1a03001 	mov	r3, r1
30024d74:	e1a03083 	lsl	r3, r3, #1
30024d78:	e0833001 	add	r3, r3, r1
30024d7c:	e1a03103 	lsl	r3, r3, #2
30024d80:	e0833001 	add	r3, r3, r1
30024d84:	e1a03103 	lsl	r3, r3, #2
30024d88:	e083300c 	add	r3, r3, ip
30024d8c:	e0833000 	add	r3, r3, r0
30024d90:	e5931000 	ldr	r1, [r3]
30024d94:	e59f30c0 	ldr	r3, [pc, #192]	; 30024e5c <AddFileDriver+0x9ac>
30024d98:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
30024d9c:	e1a00803 	lsl	r0, r3, #16
30024da0:	e59f30b4 	ldr	r3, [pc, #180]	; 30024e5c <AddFileDriver+0x9ac>
30024da4:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
30024da8:	e1a03c03 	lsl	r3, r3, #24
30024dac:	e1803003 	orr	r3, r0, r3
30024db0:	e1811003 	orr	r1, r1, r3
30024db4:	e59fc098 	ldr	ip, [pc, #152]	; 30024e54 <AddFileDriver+0x9a4>
30024db8:	e3a00010 	mov	r0, #16
30024dbc:	e1a03002 	mov	r3, r2
30024dc0:	e1a03083 	lsl	r3, r3, #1
30024dc4:	e0833002 	add	r3, r3, r2
30024dc8:	e1a03103 	lsl	r3, r3, #2
30024dcc:	e0833002 	add	r3, r3, r2
30024dd0:	e1a03103 	lsl	r3, r3, #2
30024dd4:	e083300c 	add	r3, r3, ip
30024dd8:	e0833000 	add	r3, r3, r0
30024ddc:	e5831000 	str	r1, [r3]
        DiskInfo[drive].PathClusIndex = DiskInfo[drive].RootDirTable;
30024de0:	e5dd2007 	ldrb	r2, [sp, #7]
30024de4:	e5dd1007 	ldrb	r1, [sp, #7]
30024de8:	e59fc064 	ldr	ip, [pc, #100]	; 30024e54 <AddFileDriver+0x9a4>
30024dec:	e3a00010 	mov	r0, #16
30024df0:	e1a03001 	mov	r3, r1
30024df4:	e1a03083 	lsl	r3, r3, #1
30024df8:	e0833001 	add	r3, r3, r1
30024dfc:	e1a03103 	lsl	r3, r3, #2
30024e00:	e0833001 	add	r3, r3, r1
30024e04:	e1a03103 	lsl	r3, r3, #2
30024e08:	e083300c 	add	r3, r3, ip
30024e0c:	e0833000 	add	r3, r3, r0
30024e10:	e5931000 	ldr	r1, [r3]
30024e14:	e59fc038 	ldr	ip, [pc, #56]	; 30024e54 <AddFileDriver+0x9a4>
30024e18:	e3a00028 	mov	r0, #40	; 0x28
30024e1c:	e1a03002 	mov	r3, r2
30024e20:	e1a03083 	lsl	r3, r3, #1
30024e24:	e0833002 	add	r3, r3, r2
30024e28:	e1a03103 	lsl	r3, r3, #2
30024e2c:	e0833002 	add	r3, r3, r2
30024e30:	e1a03103 	lsl	r3, r3, #2
30024e34:	e083300c 	add	r3, r3, ip
30024e38:	e0833000 	add	r3, r3, r0
30024e3c:	e5831000 	str	r1, [r3]
    }
            //CloseSec(DiskInfo[drive].Drive, 0);     /* ر */
    return 0;
30024e40:	e3a03000 	mov	r3, #0
}
30024e44:	e1a00003 	mov	r0, r3
30024e48:	e28dd028 	add	sp, sp, #40	; 0x28
30024e4c:	e8bd4010 	pop	{r4, lr}
30024e50:	e12fff1e 	bx	lr
30024e54:	300eab48 	.word	0x300eab48
30024e58:	3012b640 	.word	0x3012b640
30024e5c:	300e3cbc 	.word	0x300e3cbc

30024e60 <RemoveFileDriver>:
**         
** ȫֱ: DiskInfo
** ģ: 
********************************************************************************************************/
        void RemoveFileDriver(acoral_u8 Drive)
{
30024e60:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30024e64:	e24dd01c 	sub	sp, sp, #28
30024e68:	e1a03000 	mov	r3, r0
30024e6c:	e5cd3007 	strb	r3, [sp, #7]
    Disk_RW_Parameter Pa;
    
    if (Drive < MAX_DRIVES)
30024e70:	e5dd3007 	ldrb	r3, [sp, #7]
30024e74:	e3530000 	cmp	r3, #0
30024e78:	1a0000da 	bne	300251e8 <RemoveFileDriver+0x388>
    if (DiskInfo[Drive].Drive != EMPTY_DRIVE)
30024e7c:	e5dd2007 	ldrb	r2, [sp, #7]
30024e80:	e59f136c 	ldr	r1, [pc, #876]	; 300251f4 <RemoveFileDriver+0x394>
30024e84:	e1a03002 	mov	r3, r2
30024e88:	e1a03083 	lsl	r3, r3, #1
30024e8c:	e0833002 	add	r3, r3, r2
30024e90:	e1a03103 	lsl	r3, r3, #2
30024e94:	e0833002 	add	r3, r3, r2
30024e98:	e1a03103 	lsl	r3, r3, #2
30024e9c:	e0833001 	add	r3, r3, r1
30024ea0:	e5d33000 	ldrb	r3, [r3]
30024ea4:	e35300ff 	cmp	r3, #255	; 0xff
30024ea8:	0a0000ce 	beq	300251e8 <RemoveFileDriver+0x388>
    {
        AllCacheWriteBack();
30024eac:	eb001b3b 	bl	3002bba0 <AllCacheWriteBack>
        Pa.Drive = Drive;
30024eb0:	e5dd3007 	ldrb	r3, [sp, #7]
30024eb4:	e5cd3008 	strb	r3, [sp, #8]
        Pa.RsvdForLow = DiskInfo[Drive].RsvdForLow;
30024eb8:	e5dd2007 	ldrb	r2, [sp, #7]
30024ebc:	e59f0330 	ldr	r0, [pc, #816]	; 300251f4 <RemoveFileDriver+0x394>
30024ec0:	e3a0102c 	mov	r1, #44	; 0x2c
30024ec4:	e1a03002 	mov	r3, r2
30024ec8:	e1a03083 	lsl	r3, r3, #1
30024ecc:	e0833002 	add	r3, r3, r2
30024ed0:	e1a03103 	lsl	r3, r3, #2
30024ed4:	e0833002 	add	r3, r3, r2
30024ed8:	e1a03103 	lsl	r3, r3, #2
30024edc:	e0833000 	add	r3, r3, r0
30024ee0:	e0833001 	add	r3, r3, r1
30024ee4:	e5933000 	ldr	r3, [r3]
30024ee8:	e58d3010 	str	r3, [sp, #16]
        DiskInfo[Drive].DiakCommand(DISK_CLOSE, &Pa);
30024eec:	e5dd2007 	ldrb	r2, [sp, #7]
30024ef0:	e59f02fc 	ldr	r0, [pc, #764]	; 300251f4 <RemoveFileDriver+0x394>
30024ef4:	e3a01030 	mov	r1, #48	; 0x30
30024ef8:	e1a03002 	mov	r3, r2
30024efc:	e1a03083 	lsl	r3, r3, #1
30024f00:	e0833002 	add	r3, r3, r2
30024f04:	e1a03103 	lsl	r3, r3, #2
30024f08:	e0833002 	add	r3, r3, r2
30024f0c:	e1a03103 	lsl	r3, r3, #2
30024f10:	e0833000 	add	r3, r3, r0
30024f14:	e0833001 	add	r3, r3, r1
30024f18:	e5933000 	ldr	r3, [r3]
30024f1c:	e28d2008 	add	r2, sp, #8
30024f20:	e3a00001 	mov	r0, #1
30024f24:	e1a01002 	mov	r1, r2
30024f28:	e1a0e00f 	mov	lr, pc
30024f2c:	e12fff13 	bx	r3

        DiskInfo[Drive].Drive = EMPTY_DRIVE;    // ûз
30024f30:	e5dd2007 	ldrb	r2, [sp, #7]
30024f34:	e59f12b8 	ldr	r1, [pc, #696]	; 300251f4 <RemoveFileDriver+0x394>
30024f38:	e1a03002 	mov	r3, r2
30024f3c:	e1a03083 	lsl	r3, r3, #1
30024f40:	e0833002 	add	r3, r3, r2
30024f44:	e1a03103 	lsl	r3, r3, #2
30024f48:	e0833002 	add	r3, r3, r2
30024f4c:	e1a03103 	lsl	r3, r3, #2
30024f50:	e0833001 	add	r3, r3, r1
30024f54:	e3e02000 	mvn	r2, #0
30024f58:	e5c32000 	strb	r2, [r3]
        DiskInfo[Drive].FATType = 0xff;         // Чļϵͳ
30024f5c:	e5dd2007 	ldrb	r2, [sp, #7]
30024f60:	e59f128c 	ldr	r1, [pc, #652]	; 300251f4 <RemoveFileDriver+0x394>
30024f64:	e1a03002 	mov	r3, r2
30024f68:	e1a03083 	lsl	r3, r3, #1
30024f6c:	e0833002 	add	r3, r3, r2
30024f70:	e1a03103 	lsl	r3, r3, #2
30024f74:	e0833002 	add	r3, r3, r2
30024f78:	e1a03103 	lsl	r3, r3, #2
30024f7c:	e0833001 	add	r3, r3, r1
30024f80:	e3e02000 	mvn	r2, #0
30024f84:	e5c32001 	strb	r2, [r3, #1]
        DiskInfo[Drive].SecPerClus = 0;         // ÿ
30024f88:	e5dd2007 	ldrb	r2, [sp, #7]
30024f8c:	e59f1260 	ldr	r1, [pc, #608]	; 300251f4 <RemoveFileDriver+0x394>
30024f90:	e1a03002 	mov	r3, r2
30024f94:	e1a03083 	lsl	r3, r3, #1
30024f98:	e0833002 	add	r3, r3, r2
30024f9c:	e1a03103 	lsl	r3, r3, #2
30024fa0:	e0833002 	add	r3, r3, r2
30024fa4:	e1a03103 	lsl	r3, r3, #2
30024fa8:	e0833001 	add	r3, r3, r1
30024fac:	e3a02000 	mov	r2, #0
30024fb0:	e5c32002 	strb	r2, [r3, #2]
        DiskInfo[Drive].NumFATs = 0;            // FAT
30024fb4:	e5dd2007 	ldrb	r2, [sp, #7]
30024fb8:	e59f1234 	ldr	r1, [pc, #564]	; 300251f4 <RemoveFileDriver+0x394>
30024fbc:	e1a03002 	mov	r3, r2
30024fc0:	e1a03083 	lsl	r3, r3, #1
30024fc4:	e0833002 	add	r3, r3, r2
30024fc8:	e1a03103 	lsl	r3, r3, #2
30024fcc:	e0833002 	add	r3, r3, r2
30024fd0:	e1a03103 	lsl	r3, r3, #2
30024fd4:	e0833001 	add	r3, r3, r1
30024fd8:	e3a02000 	mov	r2, #0
30024fdc:	e5c32003 	strb	r2, [r3, #3]
        DiskInfo[Drive].DevId=-1;
30024fe0:	e5dd2007 	ldrb	r2, [sp, #7]
30024fe4:	e59f0208 	ldr	r0, [pc, #520]	; 300251f4 <RemoveFileDriver+0x394>
30024fe8:	e3a01004 	mov	r1, #4
30024fec:	e1a03002 	mov	r3, r2
30024ff0:	e1a03083 	lsl	r3, r3, #1
30024ff4:	e0833002 	add	r3, r3, r2
30024ff8:	e1a03103 	lsl	r3, r3, #2
30024ffc:	e0833002 	add	r3, r3, r2
30025000:	e1a03103 	lsl	r3, r3, #2
30025004:	e0833000 	add	r3, r3, r0
30025008:	e0833001 	add	r3, r3, r1
3002500c:	e3e02000 	mvn	r2, #0
30025010:	e5832000 	str	r2, [r3]
        DiskInfo[Drive].SecPerDisk = 0xffffffff;// ߼
30025014:	e5dd2007 	ldrb	r2, [sp, #7]
30025018:	e59f01d4 	ldr	r0, [pc, #468]	; 300251f4 <RemoveFileDriver+0x394>
3002501c:	e3a01008 	mov	r1, #8
30025020:	e1a03002 	mov	r3, r2
30025024:	e1a03083 	lsl	r3, r3, #1
30025028:	e0833002 	add	r3, r3, r2
3002502c:	e1a03103 	lsl	r3, r3, #2
30025030:	e0833002 	add	r3, r3, r2
30025034:	e1a03103 	lsl	r3, r3, #2
30025038:	e0833000 	add	r3, r3, r0
3002503c:	e0833001 	add	r3, r3, r1
30025040:	e3e02000 	mvn	r2, #0
30025044:	e5832000 	str	r2, [r3]
        DiskInfo[Drive].BytsPerSec = 0;         // ÿֽ
30025048:	e5dd2007 	ldrb	r2, [sp, #7]
3002504c:	e59f01a0 	ldr	r0, [pc, #416]	; 300251f4 <RemoveFileDriver+0x394>
30025050:	e3a0100c 	mov	r1, #12
30025054:	e1a03002 	mov	r3, r2
30025058:	e1a03083 	lsl	r3, r3, #1
3002505c:	e0833002 	add	r3, r3, r2
30025060:	e1a03103 	lsl	r3, r3, #2
30025064:	e0833002 	add	r3, r3, r2
30025068:	e1a03103 	lsl	r3, r3, #2
3002506c:	e0833000 	add	r3, r3, r0
30025070:	e0833001 	add	r3, r3, r1
30025074:	e3a02000 	mov	r2, #0
30025078:	e5832000 	str	r2, [r3]
        DiskInfo[Drive].RootDirTable = 0;       // Ŀ¼ʼţFAT32Ϊʼغţ
3002507c:	e5dd2007 	ldrb	r2, [sp, #7]
30025080:	e59f016c 	ldr	r0, [pc, #364]	; 300251f4 <RemoveFileDriver+0x394>
30025084:	e3a01010 	mov	r1, #16
30025088:	e1a03002 	mov	r3, r2
3002508c:	e1a03083 	lsl	r3, r3, #1
30025090:	e0833002 	add	r3, r3, r2
30025094:	e1a03103 	lsl	r3, r3, #2
30025098:	e0833002 	add	r3, r3, r2
3002509c:	e1a03103 	lsl	r3, r3, #2
300250a0:	e0833000 	add	r3, r3, r0
300250a4:	e0833001 	add	r3, r3, r1
300250a8:	e3a02000 	mov	r2, #0
300250ac:	e5832000 	str	r2, [r3]
        DiskInfo[Drive].RootSecCnt = 0;         // Ŀ¼ռ
300250b0:	e5dd2007 	ldrb	r2, [sp, #7]
300250b4:	e59f0138 	ldr	r0, [pc, #312]	; 300251f4 <RemoveFileDriver+0x394>
300250b8:	e3a01014 	mov	r1, #20
300250bc:	e1a03002 	mov	r3, r2
300250c0:	e1a03083 	lsl	r3, r3, #1
300250c4:	e0833002 	add	r3, r3, r2
300250c8:	e1a03103 	lsl	r3, r3, #2
300250cc:	e0833002 	add	r3, r3, r2
300250d0:	e1a03103 	lsl	r3, r3, #2
300250d4:	e0833000 	add	r3, r3, r0
300250d8:	e0833001 	add	r3, r3, r1
300250dc:	e3a02000 	mov	r2, #0
300250e0:	e5832000 	str	r2, [r3]
        DiskInfo[Drive].FATStartSec = 0;        // FATʼ
300250e4:	e5dd2007 	ldrb	r2, [sp, #7]
300250e8:	e59f0104 	ldr	r0, [pc, #260]	; 300251f4 <RemoveFileDriver+0x394>
300250ec:	e3a01018 	mov	r1, #24
300250f0:	e1a03002 	mov	r3, r2
300250f4:	e1a03083 	lsl	r3, r3, #1
300250f8:	e0833002 	add	r3, r3, r2
300250fc:	e1a03103 	lsl	r3, r3, #2
30025100:	e0833002 	add	r3, r3, r2
30025104:	e1a03103 	lsl	r3, r3, #2
30025108:	e0833000 	add	r3, r3, r0
3002510c:	e0833001 	add	r3, r3, r1
30025110:	e3a02000 	mov	r2, #0
30025114:	e5832000 	str	r2, [r3]
        DiskInfo[Drive].FATSecCnt = 0;          // ÿFATռ
30025118:	e5dd2007 	ldrb	r2, [sp, #7]
3002511c:	e59f00d0 	ldr	r0, [pc, #208]	; 300251f4 <RemoveFileDriver+0x394>
30025120:	e3a0101c 	mov	r1, #28
30025124:	e1a03002 	mov	r3, r2
30025128:	e1a03083 	lsl	r3, r3, #1
3002512c:	e0833002 	add	r3, r3, r2
30025130:	e1a03103 	lsl	r3, r3, #2
30025134:	e0833002 	add	r3, r3, r2
30025138:	e1a03103 	lsl	r3, r3, #2
3002513c:	e0833000 	add	r3, r3, r0
30025140:	e0833001 	add	r3, r3, r1
30025144:	e3a02000 	mov	r2, #0
30025148:	e5832000 	str	r2, [r3]
        DiskInfo[Drive].DataStartSec = 0;       // ʼ
3002514c:	e5dd2007 	ldrb	r2, [sp, #7]
30025150:	e59f009c 	ldr	r0, [pc, #156]	; 300251f4 <RemoveFileDriver+0x394>
30025154:	e3a01020 	mov	r1, #32
30025158:	e1a03002 	mov	r3, r2
3002515c:	e1a03083 	lsl	r3, r3, #1
30025160:	e0833002 	add	r3, r3, r2
30025164:	e1a03103 	lsl	r3, r3, #2
30025168:	e0833002 	add	r3, r3, r2
3002516c:	e1a03103 	lsl	r3, r3, #2
30025170:	e0833000 	add	r3, r3, r0
30025174:	e0833001 	add	r3, r3, r1
30025178:	e3a02000 	mov	r2, #0
3002517c:	e5832000 	str	r2, [r3]
        DiskInfo[Drive].PathClusIndex = 0;      // ǰĿ¼
30025180:	e5dd2007 	ldrb	r2, [sp, #7]
30025184:	e59f0068 	ldr	r0, [pc, #104]	; 300251f4 <RemoveFileDriver+0x394>
30025188:	e3a01028 	mov	r1, #40	; 0x28
3002518c:	e1a03002 	mov	r3, r2
30025190:	e1a03083 	lsl	r3, r3, #1
30025194:	e0833002 	add	r3, r3, r2
30025198:	e1a03103 	lsl	r3, r3, #2
3002519c:	e0833002 	add	r3, r3, r2
300251a0:	e1a03103 	lsl	r3, r3, #2
300251a4:	e0833000 	add	r3, r3, r0
300251a8:	e0833001 	add	r3, r3, r1
300251ac:	e3a02000 	mov	r2, #0
300251b0:	e5832000 	str	r2, [r3]
        DiskInfo[Drive].DiakCommand = NULL;     // 
300251b4:	e5dd2007 	ldrb	r2, [sp, #7]
300251b8:	e59f0034 	ldr	r0, [pc, #52]	; 300251f4 <RemoveFileDriver+0x394>
300251bc:	e3a01030 	mov	r1, #48	; 0x30
300251c0:	e1a03002 	mov	r3, r2
300251c4:	e1a03083 	lsl	r3, r3, #1
300251c8:	e0833002 	add	r3, r3, r2
300251cc:	e1a03103 	lsl	r3, r3, #2
300251d0:	e0833002 	add	r3, r3, r2
300251d4:	e1a03103 	lsl	r3, r3, #2
300251d8:	e0833000 	add	r3, r3, r0
300251dc:	e0833001 	add	r3, r3, r1
300251e0:	e3a02000 	mov	r2, #0
300251e4:	e5832000 	str	r2, [r3]
    }
}
300251e8:	e28dd01c 	add	sp, sp, #28
300251ec:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300251f0:	e12fff1e 	bx	lr
300251f4:	300eab48 	.word	0x300eab48

300251f8 <FATGetNextClus>:
**         
** ȫ�ֱ���: ��
** ����ģ��: ��
********************************************************************************************************/
        acoral_u32 FATGetNextClus(acoral_u8 Drive, acoral_u32 Index)
{
300251f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300251fc:	e24dd024 	sub	sp, sp, #36	; 0x24
30025200:	e1a03000 	mov	r3, r0
30025204:	e58d1000 	str	r1, [sp]
30025208:	e5cd3007 	strb	r3, [sp, #7]
    acoral_u32 SecIndex;
    acoral_u8 *Buf;
    Disk_Info * Disk;
    acoral_u32 Rt;
    
    Disk = GetDiskInfo(Drive);
3002520c:	e5dd3007 	ldrb	r3, [sp, #7]
30025210:	e1a00003 	mov	r0, r3
30025214:	ebfffc81 	bl	30024420 <GetDiskInfo>
30025218:	e1a03000 	mov	r3, r0
3002521c:	e58d3018 	str	r3, [sp, #24]
    if (Disk == NULL)
30025220:	e59d3018 	ldr	r3, [sp, #24]
30025224:	e3530000 	cmp	r3, #0
30025228:	1a000001 	bne	30025234 <FATGetNextClus+0x3c>
    {
        return BAD_CLUS;
3002522c:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
30025230:	ea000129 	b	300256dc <FATGetNextClus+0x4e4>
    }

    if (Index >= (Disk->ClusPerData))
30025234:	e59d3018 	ldr	r3, [sp, #24]
30025238:	e5932024 	ldr	r2, [r3, #36]	; 0x24
3002523c:	e59d3000 	ldr	r3, [sp]
30025240:	e1520003 	cmp	r2, r3
30025244:	8a000001 	bhi	30025250 <FATGetNextClus+0x58>
    {
        return BAD_CLUS;
30025248:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
3002524c:	ea000122 	b	300256dc <FATGetNextClus+0x4e4>
    }
    
    /* ��������ź��ֽ����� */
    switch (Disk->FATType)
30025250:	e59d3018 	ldr	r3, [sp, #24]
30025254:	e5d33001 	ldrb	r3, [r3, #1]
30025258:	e3530001 	cmp	r3, #1
3002525c:	0a000028 	beq	30025304 <FATGetNextClus+0x10c>
30025260:	e3530002 	cmp	r3, #2
30025264:	0a000043 	beq	30025378 <FATGetNextClus+0x180>
30025268:	e3530000 	cmp	r3, #0
3002526c:	1a00005e 	bne	300253ec <FATGetNextClus+0x1f4>
    {
        case FAT12:
            SecIndex = Index * 3 / (2 * Disk->BytsPerSec);
30025270:	e59d2000 	ldr	r2, [sp]
30025274:	e1a03002 	mov	r3, r2
30025278:	e1a03083 	lsl	r3, r3, #1
3002527c:	e0832002 	add	r2, r3, r2
30025280:	e59d3018 	ldr	r3, [sp, #24]
30025284:	e593300c 	ldr	r3, [r3, #12]
30025288:	e1a03083 	lsl	r3, r3, #1
3002528c:	e1a00002 	mov	r0, r2
30025290:	e1a01003 	mov	r1, r3
30025294:	eb007a81 	bl	30043ca0 <__aeabi_uidiv>
30025298:	e1a03000 	mov	r3, r0
3002529c:	e58d3010 	str	r3, [sp, #16]
            ByteIndex = ((Index * 3) / 2) - (SecIndex * Disk->BytsPerSec);
300252a0:	e59d2000 	ldr	r2, [sp]
300252a4:	e1a03002 	mov	r3, r2
300252a8:	e1a03083 	lsl	r3, r3, #1
300252ac:	e0833002 	add	r3, r3, r2
300252b0:	e1a030a3 	lsr	r3, r3, #1
300252b4:	e1a03803 	lsl	r3, r3, #16
300252b8:	e1a02823 	lsr	r2, r3, #16
300252bc:	e59d3018 	ldr	r3, [sp, #24]
300252c0:	e593300c 	ldr	r3, [r3, #12]
300252c4:	e1a03803 	lsl	r3, r3, #16
300252c8:	e1a03823 	lsr	r3, r3, #16
300252cc:	e59d1010 	ldr	r1, [sp, #16]
300252d0:	e1a01801 	lsl	r1, r1, #16
300252d4:	e1a01821 	lsr	r1, r1, #16
300252d8:	e0030391 	mul	r3, r1, r3
300252dc:	e1a03803 	lsl	r3, r3, #16
300252e0:	e1a03823 	lsr	r3, r3, #16
300252e4:	e0633002 	rsb	r3, r3, r2
300252e8:	e1cd30be 	strh	r3, [sp, #14]
            SecIndex += Disk->FATStartSec;
300252ec:	e59d3018 	ldr	r3, [sp, #24]
300252f0:	e5933018 	ldr	r3, [r3, #24]
300252f4:	e59d2010 	ldr	r2, [sp, #16]
300252f8:	e0823003 	add	r3, r2, r3
300252fc:	e58d3010 	str	r3, [sp, #16]
            break;
30025300:	ea00003b 	b	300253f4 <FATGetNextClus+0x1fc>
        case FAT16:
            SecIndex = Index * 2 / Disk->BytsPerSec + Disk->FATStartSec;
30025304:	e59d3000 	ldr	r3, [sp]
30025308:	e1a02083 	lsl	r2, r3, #1
3002530c:	e59d3018 	ldr	r3, [sp, #24]
30025310:	e593300c 	ldr	r3, [r3, #12]
30025314:	e1a00002 	mov	r0, r2
30025318:	e1a01003 	mov	r1, r3
3002531c:	eb007a5f 	bl	30043ca0 <__aeabi_uidiv>
30025320:	e1a03000 	mov	r3, r0
30025324:	e1a02003 	mov	r2, r3
30025328:	e59d3018 	ldr	r3, [sp, #24]
3002532c:	e5933018 	ldr	r3, [r3, #24]
30025330:	e0823003 	add	r3, r2, r3
30025334:	e58d3010 	str	r3, [sp, #16]
            ByteIndex = (Index * 2) & (Disk->BytsPerSec - 1);
30025338:	e59d3000 	ldr	r3, [sp]
3002533c:	e1a03803 	lsl	r3, r3, #16
30025340:	e1a03823 	lsr	r3, r3, #16
30025344:	e1a03083 	lsl	r3, r3, #1
30025348:	e1a03803 	lsl	r3, r3, #16
3002534c:	e1a02823 	lsr	r2, r3, #16
30025350:	e59d3018 	ldr	r3, [sp, #24]
30025354:	e593300c 	ldr	r3, [r3, #12]
30025358:	e1a03803 	lsl	r3, r3, #16
3002535c:	e1a03823 	lsr	r3, r3, #16
30025360:	e2433001 	sub	r3, r3, #1
30025364:	e1a03803 	lsl	r3, r3, #16
30025368:	e1a03823 	lsr	r3, r3, #16
3002536c:	e0023003 	and	r3, r2, r3
30025370:	e1cd30be 	strh	r3, [sp, #14]
            break;
30025374:	ea00001e 	b	300253f4 <FATGetNextClus+0x1fc>
        case FAT32:
            SecIndex = Index * 4 / Disk->BytsPerSec + Disk->FATStartSec;
30025378:	e59d3000 	ldr	r3, [sp]
3002537c:	e1a02103 	lsl	r2, r3, #2
30025380:	e59d3018 	ldr	r3, [sp, #24]
30025384:	e593300c 	ldr	r3, [r3, #12]
30025388:	e1a00002 	mov	r0, r2
3002538c:	e1a01003 	mov	r1, r3
30025390:	eb007a42 	bl	30043ca0 <__aeabi_uidiv>
30025394:	e1a03000 	mov	r3, r0
30025398:	e1a02003 	mov	r2, r3
3002539c:	e59d3018 	ldr	r3, [sp, #24]
300253a0:	e5933018 	ldr	r3, [r3, #24]
300253a4:	e0823003 	add	r3, r2, r3
300253a8:	e58d3010 	str	r3, [sp, #16]
            ByteIndex = (Index * 4) & (Disk->BytsPerSec - 1);
300253ac:	e59d3000 	ldr	r3, [sp]
300253b0:	e1a03803 	lsl	r3, r3, #16
300253b4:	e1a03823 	lsr	r3, r3, #16
300253b8:	e1a03103 	lsl	r3, r3, #2
300253bc:	e1a03803 	lsl	r3, r3, #16
300253c0:	e1a02823 	lsr	r2, r3, #16
300253c4:	e59d3018 	ldr	r3, [sp, #24]
300253c8:	e593300c 	ldr	r3, [r3, #12]
300253cc:	e1a03803 	lsl	r3, r3, #16
300253d0:	e1a03823 	lsr	r3, r3, #16
300253d4:	e2433001 	sub	r3, r3, #1
300253d8:	e1a03803 	lsl	r3, r3, #16
300253dc:	e1a03823 	lsr	r3, r3, #16
300253e0:	e0023003 	and	r3, r2, r3
300253e4:	e1cd30be 	strh	r3, [sp, #14]
            break;
300253e8:	ea000001 	b	300253f4 <FATGetNextClus+0x1fc>
        default:
            return BAD_CLUS;
300253ec:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
300253f0:	ea0000b9 	b	300256dc <FATGetNextClus+0x4e4>
    }

    Buf = OpenSec(Drive, SecIndex);
300253f4:	e5dd3007 	ldrb	r3, [sp, #7]
300253f8:	e1a00003 	mov	r0, r3
300253fc:	e59d1010 	ldr	r1, [sp, #16]
30025400:	eb001a88 	bl	3002be28 <OpenSec>
30025404:	e1a03000 	mov	r3, r0
30025408:	e58d3014 	str	r3, [sp, #20]
    if (Buf == NULL)
3002540c:	e59d3014 	ldr	r3, [sp, #20]
30025410:	e3530000 	cmp	r3, #0
30025414:	1a000001 	bne	30025420 <FATGetNextClus+0x228>
    {
        return BAD_CLUS;
30025418:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
3002541c:	ea0000ae 	b	300256dc <FATGetNextClus+0x4e4>
    }
    ReadSec(Drive, SecIndex);
30025420:	e5dd3007 	ldrb	r3, [sp, #7]
30025424:	e1a00003 	mov	r0, r3
30025428:	e59d1010 	ldr	r1, [sp, #16]
3002542c:	eb001b21 	bl	3002c0b8 <ReadSec>
    
    /* ��ȡFAT����� */
    switch (Disk->FATType)
30025430:	e59d3018 	ldr	r3, [sp, #24]
30025434:	e5d33001 	ldrb	r3, [r3, #1]
30025438:	e3530001 	cmp	r3, #1
3002543c:	0a00005d 	beq	300255b8 <FATGetNextClus+0x3c0>
30025440:	e3530002 	cmp	r3, #2
30025444:	0a000078 	beq	3002562c <FATGetNextClus+0x434>
30025448:	e3530000 	cmp	r3, #0
3002544c:	1a000097 	bne	300256b0 <FATGetNextClus+0x4b8>
    {
        case FAT12:
            temp = Buf[ByteIndex];
30025450:	e1dd20be 	ldrh	r2, [sp, #14]
30025454:	e59d3014 	ldr	r3, [sp, #20]
30025458:	e0823003 	add	r3, r2, r3
3002545c:	e5d33000 	ldrb	r3, [r3]
30025460:	e1cd30bc 	strh	r3, [sp, #12]
            ByteIndex++;
30025464:	e1dd30be 	ldrh	r3, [sp, #14]
30025468:	e2833001 	add	r3, r3, #1
3002546c:	e1cd30be 	strh	r3, [sp, #14]
            if (ByteIndex >= Disk->BytsPerSec)          /* ��һ���ֽ��Ƿ�����һ������ */
30025470:	e1dd20be 	ldrh	r2, [sp, #14]
30025474:	e59d3018 	ldr	r3, [sp, #24]
30025478:	e593300c 	ldr	r3, [r3, #12]
3002547c:	e1520003 	cmp	r2, r3
30025480:	3a000023 	bcc	30025514 <FATGetNextClus+0x31c>
            {
                Buf = OpenSec(Drive, SecIndex + 1);
30025484:	e59d3010 	ldr	r3, [sp, #16]
30025488:	e2833001 	add	r3, r3, #1
3002548c:	e5dd2007 	ldrb	r2, [sp, #7]
30025490:	e1a00002 	mov	r0, r2
30025494:	e1a01003 	mov	r1, r3
30025498:	eb001a62 	bl	3002be28 <OpenSec>
3002549c:	e1a03000 	mov	r3, r0
300254a0:	e58d3014 	str	r3, [sp, #20]
                if (Buf == NULL)
300254a4:	e59d3014 	ldr	r3, [sp, #20]
300254a8:	e3530000 	cmp	r3, #0
300254ac:	1a000001 	bne	300254b8 <FATGetNextClus+0x2c0>
                {
                    return BAD_CLUS;
300254b0:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
300254b4:	ea000088 	b	300256dc <FATGetNextClus+0x4e4>
                }
                ReadSec(Drive, SecIndex + 1);
300254b8:	e59d3010 	ldr	r3, [sp, #16]
300254bc:	e2833001 	add	r3, r3, #1
300254c0:	e5dd2007 	ldrb	r2, [sp, #7]
300254c4:	e1a00002 	mov	r0, r2
300254c8:	e1a01003 	mov	r1, r3
300254cc:	eb001af9 	bl	3002c0b8 <ReadSec>
                temp = temp | (Buf[0] << 8);
300254d0:	e59d3014 	ldr	r3, [sp, #20]
300254d4:	e5d33000 	ldrb	r3, [r3]
300254d8:	e1a03403 	lsl	r3, r3, #8
300254dc:	e1a03803 	lsl	r3, r3, #16
300254e0:	e1a02823 	lsr	r2, r3, #16
300254e4:	e1dd30bc 	ldrh	r3, [sp, #12]
300254e8:	e1823003 	orr	r3, r2, r3
300254ec:	e1a03803 	lsl	r3, r3, #16
300254f0:	e1a03823 	lsr	r3, r3, #16
300254f4:	e1cd30bc 	strh	r3, [sp, #12]
                CloseSec(Drive, SecIndex + 1);
300254f8:	e59d3010 	ldr	r3, [sp, #16]
300254fc:	e2833001 	add	r3, r3, #1
30025500:	e5dd2007 	ldrb	r2, [sp, #7]
30025504:	e1a00002 	mov	r0, r2
30025508:	e1a01003 	mov	r1, r3
3002550c:	eb00193d 	bl	3002ba08 <CloseSec>
30025510:	ea00000b 	b	30025544 <FATGetNextClus+0x34c>
            }
            else
            {
                temp = temp | (Buf[ByteIndex] << 8);
30025514:	e1dd20be 	ldrh	r2, [sp, #14]
30025518:	e59d3014 	ldr	r3, [sp, #20]
3002551c:	e0823003 	add	r3, r2, r3
30025520:	e5d33000 	ldrb	r3, [r3]
30025524:	e1a03403 	lsl	r3, r3, #8
30025528:	e1a03803 	lsl	r3, r3, #16
3002552c:	e1a02823 	lsr	r2, r3, #16
30025530:	e1dd30bc 	ldrh	r3, [sp, #12]
30025534:	e1823003 	orr	r3, r2, r3
30025538:	e1a03803 	lsl	r3, r3, #16
3002553c:	e1a03823 	lsr	r3, r3, #16
30025540:	e1cd30bc 	strh	r3, [sp, #12]
            }
            if ((Index & 0x01) != 0)                /* �ж���12λ��Ч */
30025544:	e59d3000 	ldr	r3, [sp]
30025548:	e2033001 	and	r3, r3, #1
3002554c:	e20330ff 	and	r3, r3, #255	; 0xff
30025550:	e3530000 	cmp	r3, #0
30025554:	0a000003 	beq	30025568 <FATGetNextClus+0x370>
            {
                temp = temp / 16;
30025558:	e1dd30bc 	ldrh	r3, [sp, #12]
3002555c:	e1a03223 	lsr	r3, r3, #4
30025560:	e1cd30bc 	strh	r3, [sp, #12]
30025564:	ea000003 	b	30025578 <FATGetNextClus+0x380>
            }
            else
            {
                temp = temp & 0x0fff;
30025568:	e1dd30bc 	ldrh	r3, [sp, #12]
3002556c:	e1a03a03 	lsl	r3, r3, #20
30025570:	e1a03a23 	lsr	r3, r3, #20
30025574:	e1cd30bc 	strh	r3, [sp, #12]
            }
            Rt = temp;
30025578:	e1dd30bc 	ldrh	r3, [sp, #12]
3002557c:	e58d301c 	str	r3, [sp, #28]
            if (temp >= (BAD_CLUS & 0x0fff))        /* �Ƿ����������� */
30025580:	e1dd20bc 	ldrh	r2, [sp, #12]
30025584:	e3a03eff 	mov	r3, #4080	; 0xff0
30025588:	e2833006 	add	r3, r3, #6
3002558c:	e1520003 	cmp	r2, r3
30025590:	9a000049 	bls	300256bc <FATGetNextClus+0x4c4>
            {
                Rt = ((acoral_u32)0x0fffL << 16) | (temp | 0xf000);
30025594:	e1dd30bc 	ldrh	r3, [sp, #12]
30025598:	e1e03a03 	mvn	r3, r3, lsl #20
3002559c:	e1e03a23 	mvn	r3, r3, lsr #20
300255a0:	e1a03803 	lsl	r3, r3, #16
300255a4:	e1a03823 	lsr	r3, r3, #16
300255a8:	e38336ff 	orr	r3, r3, #267386880	; 0xff00000
300255ac:	e383380f 	orr	r3, r3, #983040	; 0xf0000
300255b0:	e58d301c 	str	r3, [sp, #28]
            }
            break;
300255b4:	ea000043 	b	300256c8 <FATGetNextClus+0x4d0>
        case FAT16:
            temp = Buf[ByteIndex] | (Buf[ByteIndex + 1] << 8);
300255b8:	e1dd20be 	ldrh	r2, [sp, #14]
300255bc:	e59d3014 	ldr	r3, [sp, #20]
300255c0:	e0823003 	add	r3, r2, r3
300255c4:	e5d33000 	ldrb	r3, [r3]
300255c8:	e1a02003 	mov	r2, r3
300255cc:	e1dd30be 	ldrh	r3, [sp, #14]
300255d0:	e2831001 	add	r1, r3, #1
300255d4:	e59d3014 	ldr	r3, [sp, #20]
300255d8:	e0813003 	add	r3, r1, r3
300255dc:	e5d33000 	ldrb	r3, [r3]
300255e0:	e1a03403 	lsl	r3, r3, #8
300255e4:	e1a03803 	lsl	r3, r3, #16
300255e8:	e1a03823 	lsr	r3, r3, #16
300255ec:	e1823003 	orr	r3, r2, r3
300255f0:	e1a03803 	lsl	r3, r3, #16
300255f4:	e1a03823 	lsr	r3, r3, #16
300255f8:	e1cd30bc 	strh	r3, [sp, #12]
            Rt = temp;
300255fc:	e1dd30bc 	ldrh	r3, [sp, #12]
30025600:	e58d301c 	str	r3, [sp, #28]
            if (temp >= (BAD_CLUS & 0xffff))        /* �Ƿ����������� */
30025604:	e1dd20bc 	ldrh	r2, [sp, #12]
30025608:	e3a03cff 	mov	r3, #65280	; 0xff00
3002560c:	e28330f6 	add	r3, r3, #246	; 0xf6
30025610:	e1520003 	cmp	r2, r3
30025614:	9a00002a 	bls	300256c4 <FATGetNextClus+0x4cc>
            {
                Rt = ((acoral_u32)0x0fffL << 16) | temp;
30025618:	e1dd30bc 	ldrh	r3, [sp, #12]
3002561c:	e38336ff 	orr	r3, r3, #267386880	; 0xff00000
30025620:	e383380f 	orr	r3, r3, #983040	; 0xf0000
30025624:	e58d301c 	str	r3, [sp, #28]
            }
            break;
30025628:	ea000026 	b	300256c8 <FATGetNextClus+0x4d0>
        case FAT32:
            Rt = Buf[ByteIndex] | (Buf[ByteIndex + 1] << 8);
3002562c:	e1dd20be 	ldrh	r2, [sp, #14]
30025630:	e59d3014 	ldr	r3, [sp, #20]
30025634:	e0823003 	add	r3, r2, r3
30025638:	e5d33000 	ldrb	r3, [r3]
3002563c:	e1a02003 	mov	r2, r3
30025640:	e1dd30be 	ldrh	r3, [sp, #14]
30025644:	e2831001 	add	r1, r3, #1
30025648:	e59d3014 	ldr	r3, [sp, #20]
3002564c:	e0813003 	add	r3, r1, r3
30025650:	e5d33000 	ldrb	r3, [r3]
30025654:	e1a03403 	lsl	r3, r3, #8
30025658:	e1823003 	orr	r3, r2, r3
3002565c:	e58d301c 	str	r3, [sp, #28]
            Rt |= ((acoral_u32)Buf[ByteIndex + 2] << 16) | ((acoral_u32)Buf[ByteIndex + 3] << 24);
30025660:	e1dd30be 	ldrh	r3, [sp, #14]
30025664:	e2832002 	add	r2, r3, #2
30025668:	e59d3014 	ldr	r3, [sp, #20]
3002566c:	e0823003 	add	r3, r2, r3
30025670:	e5d33000 	ldrb	r3, [r3]
30025674:	e1a02803 	lsl	r2, r3, #16
30025678:	e1dd30be 	ldrh	r3, [sp, #14]
3002567c:	e2831003 	add	r1, r3, #3
30025680:	e59d3014 	ldr	r3, [sp, #20]
30025684:	e0813003 	add	r3, r1, r3
30025688:	e5d33000 	ldrb	r3, [r3]
3002568c:	e1a03c03 	lsl	r3, r3, #24
30025690:	e1823003 	orr	r3, r2, r3
30025694:	e59d201c 	ldr	r2, [sp, #28]
30025698:	e1823003 	orr	r3, r2, r3
3002569c:	e58d301c 	str	r3, [sp, #28]
            Rt = Rt & 0x0fffffff;
300256a0:	e59d301c 	ldr	r3, [sp, #28]
300256a4:	e3c3320f 	bic	r3, r3, #-268435456	; 0xf0000000
300256a8:	e58d301c 	str	r3, [sp, #28]
            break;
300256ac:	ea000005 	b	300256c8 <FATGetNextClus+0x4d0>
        default:
            Rt = BAD_CLUS;
300256b0:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
300256b4:	e58d301c 	str	r3, [sp, #28]
300256b8:	ea000002 	b	300256c8 <FATGetNextClus+0x4d0>
            Rt = temp;
            if (temp >= (BAD_CLUS & 0x0fff))        /* �Ƿ����������� */
            {
                Rt = ((acoral_u32)0x0fffL << 16) | (temp | 0xf000);
            }
            break;
300256bc:	e1a00000 	nop			; (mov r0, r0)
300256c0:	ea000000 	b	300256c8 <FATGetNextClus+0x4d0>
            Rt = temp;
            if (temp >= (BAD_CLUS & 0xffff))        /* �Ƿ����������� */
            {
                Rt = ((acoral_u32)0x0fffL << 16) | temp;
            }
            break;
300256c4:	e1a00000 	nop			; (mov r0, r0)
            break;
        default:
            Rt = BAD_CLUS;
            break;
    }
    CloseSec(Drive, SecIndex);
300256c8:	e5dd3007 	ldrb	r3, [sp, #7]
300256cc:	e1a00003 	mov	r0, r3
300256d0:	e59d1010 	ldr	r1, [sp, #16]
300256d4:	eb0018cb 	bl	3002ba08 <CloseSec>
    return Rt;
300256d8:	e59d301c 	ldr	r3, [sp, #28]
}
300256dc:	e1a00003 	mov	r0, r3
300256e0:	e28dd024 	add	sp, sp, #36	; 0x24
300256e4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300256e8:	e12fff1e 	bx	lr

300256ec <FATSetNextClus>:
**         
** ȫ�ֱ���: ��
** ����ģ��: ��
********************************************************************************************************/
        void FATSetNextClus(acoral_u8 Drive, acoral_u32 Index, acoral_u32 Next)
{
300256ec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300256f0:	e24dd024 	sub	sp, sp, #36	; 0x24
300256f4:	e1a03000 	mov	r3, r0
300256f8:	e58d1008 	str	r1, [sp, #8]
300256fc:	e58d2004 	str	r2, [sp, #4]
30025700:	e5cd300f 	strb	r3, [sp, #15]
    acoral_u16 temp;
    acoral_u16 SecIndex, ByteIndex;
    acoral_u8 *Buf;
    Disk_Info * Disk;
    
    Disk = GetDiskInfo(Drive);
30025704:	e5dd300f 	ldrb	r3, [sp, #15]
30025708:	e1a00003 	mov	r0, r3
3002570c:	ebfffb43 	bl	30024420 <GetDiskInfo>
30025710:	e1a03000 	mov	r3, r0
30025714:	e58d301c 	str	r3, [sp, #28]
    if (Disk == NULL)
30025718:	e59d301c 	ldr	r3, [sp, #28]
3002571c:	e3530000 	cmp	r3, #0
30025720:	0a000157 	beq	30025c84 <FATSetNextClus+0x598>
    {
        return;
    }
    if (Index <= EMPTY_CLUS_1)
30025724:	e59d3008 	ldr	r3, [sp, #8]
30025728:	e3530001 	cmp	r3, #1
3002572c:	9a000156 	bls	30025c8c <FATSetNextClus+0x5a0>
    {
        return;
    }

    if (Index >= Disk->ClusPerData)
30025730:	e59d301c 	ldr	r3, [sp, #28]
30025734:	e5932024 	ldr	r2, [r3, #36]	; 0x24
30025738:	e59d3008 	ldr	r3, [sp, #8]
3002573c:	e1520003 	cmp	r2, r3
30025740:	9a000153 	bls	30025c94 <FATSetNextClus+0x5a8>
    {
        return;
    }
    
    /* ��������ź��ֽ����� */
    switch (Disk->FATType)
30025744:	e59d301c 	ldr	r3, [sp, #28]
30025748:	e5d33001 	ldrb	r3, [r3, #1]
3002574c:	e3530001 	cmp	r3, #1
30025750:	0a000028 	beq	300257f8 <FATSetNextClus+0x10c>
30025754:	e3530002 	cmp	r3, #2
30025758:	0a000046 	beq	30025878 <FATSetNextClus+0x18c>
3002575c:	e3530000 	cmp	r3, #0
30025760:	1a00014d 	bne	30025c9c <FATSetNextClus+0x5b0>
    {
        case FAT12:
            SecIndex = Index * 3 / (2 * Disk->BytsPerSec);
30025764:	e59d2008 	ldr	r2, [sp, #8]
30025768:	e1a03002 	mov	r3, r2
3002576c:	e1a03083 	lsl	r3, r3, #1
30025770:	e0832002 	add	r2, r3, r2
30025774:	e59d301c 	ldr	r3, [sp, #28]
30025778:	e593300c 	ldr	r3, [r3, #12]
3002577c:	e1a03083 	lsl	r3, r3, #1
30025780:	e1a00002 	mov	r0, r2
30025784:	e1a01003 	mov	r1, r3
30025788:	eb007944 	bl	30043ca0 <__aeabi_uidiv>
3002578c:	e1a03000 	mov	r3, r0
30025790:	e1cd31b4 	strh	r3, [sp, #20]
            ByteIndex = ((Index * 3) / 2) - (SecIndex * Disk->BytsPerSec);
30025794:	e59d2008 	ldr	r2, [sp, #8]
30025798:	e1a03002 	mov	r3, r2
3002579c:	e1a03083 	lsl	r3, r3, #1
300257a0:	e0833002 	add	r3, r3, r2
300257a4:	e1a030a3 	lsr	r3, r3, #1
300257a8:	e1a03803 	lsl	r3, r3, #16
300257ac:	e1a02823 	lsr	r2, r3, #16
300257b0:	e59d301c 	ldr	r3, [sp, #28]
300257b4:	e593300c 	ldr	r3, [r3, #12]
300257b8:	e1a03803 	lsl	r3, r3, #16
300257bc:	e1a03823 	lsr	r3, r3, #16
300257c0:	e1dd11b4 	ldrh	r1, [sp, #20]
300257c4:	e0030391 	mul	r3, r1, r3
300257c8:	e1a03803 	lsl	r3, r3, #16
300257cc:	e1a03823 	lsr	r3, r3, #16
300257d0:	e0633002 	rsb	r3, r3, r2
300257d4:	e1cd31b6 	strh	r3, [sp, #22]
            SecIndex += Disk->FATStartSec;
300257d8:	e59d301c 	ldr	r3, [sp, #28]
300257dc:	e5933018 	ldr	r3, [r3, #24]
300257e0:	e1a03803 	lsl	r3, r3, #16
300257e4:	e1a02823 	lsr	r2, r3, #16
300257e8:	e1dd31b4 	ldrh	r3, [sp, #20]
300257ec:	e0823003 	add	r3, r2, r3
300257f0:	e1cd31b4 	strh	r3, [sp, #20]
            break;
300257f4:	ea00003f 	b	300258f8 <FATSetNextClus+0x20c>
        case FAT16:
            SecIndex = Index * 2 / Disk->BytsPerSec + Disk->FATStartSec;
300257f8:	e59d3008 	ldr	r3, [sp, #8]
300257fc:	e1a02083 	lsl	r2, r3, #1
30025800:	e59d301c 	ldr	r3, [sp, #28]
30025804:	e593300c 	ldr	r3, [r3, #12]
30025808:	e1a00002 	mov	r0, r2
3002580c:	e1a01003 	mov	r1, r3
30025810:	eb007922 	bl	30043ca0 <__aeabi_uidiv>
30025814:	e1a03000 	mov	r3, r0
30025818:	e1a03803 	lsl	r3, r3, #16
3002581c:	e1a02823 	lsr	r2, r3, #16
30025820:	e59d301c 	ldr	r3, [sp, #28]
30025824:	e5933018 	ldr	r3, [r3, #24]
30025828:	e1a03803 	lsl	r3, r3, #16
3002582c:	e1a03823 	lsr	r3, r3, #16
30025830:	e0823003 	add	r3, r2, r3
30025834:	e1cd31b4 	strh	r3, [sp, #20]
            ByteIndex = (Index * 2) & (Disk->BytsPerSec - 1);
30025838:	e59d3008 	ldr	r3, [sp, #8]
3002583c:	e1a03803 	lsl	r3, r3, #16
30025840:	e1a03823 	lsr	r3, r3, #16
30025844:	e1a03083 	lsl	r3, r3, #1
30025848:	e1a03803 	lsl	r3, r3, #16
3002584c:	e1a02823 	lsr	r2, r3, #16
30025850:	e59d301c 	ldr	r3, [sp, #28]
30025854:	e593300c 	ldr	r3, [r3, #12]
30025858:	e1a03803 	lsl	r3, r3, #16
3002585c:	e1a03823 	lsr	r3, r3, #16
30025860:	e2433001 	sub	r3, r3, #1
30025864:	e1a03803 	lsl	r3, r3, #16
30025868:	e1a03823 	lsr	r3, r3, #16
3002586c:	e0023003 	and	r3, r2, r3
30025870:	e1cd31b6 	strh	r3, [sp, #22]
            break;
30025874:	ea00001f 	b	300258f8 <FATSetNextClus+0x20c>
        case FAT32:
            SecIndex = Index * 4 / Disk->BytsPerSec + Disk->FATStartSec;
30025878:	e59d3008 	ldr	r3, [sp, #8]
3002587c:	e1a02103 	lsl	r2, r3, #2
30025880:	e59d301c 	ldr	r3, [sp, #28]
30025884:	e593300c 	ldr	r3, [r3, #12]
30025888:	e1a00002 	mov	r0, r2
3002588c:	e1a01003 	mov	r1, r3
30025890:	eb007902 	bl	30043ca0 <__aeabi_uidiv>
30025894:	e1a03000 	mov	r3, r0
30025898:	e1a03803 	lsl	r3, r3, #16
3002589c:	e1a02823 	lsr	r2, r3, #16
300258a0:	e59d301c 	ldr	r3, [sp, #28]
300258a4:	e5933018 	ldr	r3, [r3, #24]
300258a8:	e1a03803 	lsl	r3, r3, #16
300258ac:	e1a03823 	lsr	r3, r3, #16
300258b0:	e0823003 	add	r3, r2, r3
300258b4:	e1cd31b4 	strh	r3, [sp, #20]
            ByteIndex = (Index * 4) & (Disk->BytsPerSec - 1);
300258b8:	e59d3008 	ldr	r3, [sp, #8]
300258bc:	e1a03803 	lsl	r3, r3, #16
300258c0:	e1a03823 	lsr	r3, r3, #16
300258c4:	e1a03103 	lsl	r3, r3, #2
300258c8:	e1a03803 	lsl	r3, r3, #16
300258cc:	e1a02823 	lsr	r2, r3, #16
300258d0:	e59d301c 	ldr	r3, [sp, #28]
300258d4:	e593300c 	ldr	r3, [r3, #12]
300258d8:	e1a03803 	lsl	r3, r3, #16
300258dc:	e1a03823 	lsr	r3, r3, #16
300258e0:	e2433001 	sub	r3, r3, #1
300258e4:	e1a03803 	lsl	r3, r3, #16
300258e8:	e1a03823 	lsr	r3, r3, #16
300258ec:	e0023003 	and	r3, r2, r3
300258f0:	e1cd31b6 	strh	r3, [sp, #22]
            break;
300258f4:	e1a00000 	nop			; (mov r0, r0)
        default:
            return;
    }

    Buf = OpenSec(Drive, SecIndex);
300258f8:	e1dd31b4 	ldrh	r3, [sp, #20]
300258fc:	e5dd200f 	ldrb	r2, [sp, #15]
30025900:	e1a00002 	mov	r0, r2
30025904:	e1a01003 	mov	r1, r3
30025908:	eb001946 	bl	3002be28 <OpenSec>
3002590c:	e1a03000 	mov	r3, r0
30025910:	e58d3018 	str	r3, [sp, #24]
    if (Buf == NULL)
30025914:	e59d3018 	ldr	r3, [sp, #24]
30025918:	e3530000 	cmp	r3, #0
3002591c:	0a0000e0 	beq	30025ca4 <FATSetNextClus+0x5b8>
    {
        return;
    }
    ReadSec(Drive, SecIndex);
30025920:	e1dd31b4 	ldrh	r3, [sp, #20]
30025924:	e5dd200f 	ldrb	r2, [sp, #15]
30025928:	e1a00002 	mov	r0, r2
3002592c:	e1a01003 	mov	r1, r3
30025930:	eb0019e0 	bl	3002c0b8 <ReadSec>

    switch (Disk->FATType)
30025934:	e59d301c 	ldr	r3, [sp, #28]
30025938:	e5d33001 	ldrb	r3, [r3, #1]
3002593c:	e3530001 	cmp	r3, #1
30025940:	0a00008a 	beq	30025b70 <FATSetNextClus+0x484>
30025944:	e3530002 	cmp	r3, #2
30025948:	0a000097 	beq	30025bac <FATSetNextClus+0x4c0>
3002594c:	e3530000 	cmp	r3, #0
30025950:	1a0000bf 	bne	30025c54 <FATSetNextClus+0x568>
    {
        case FAT12:
            temp = Next & 0x0fff;
30025954:	e59d3004 	ldr	r3, [sp, #4]
30025958:	e1a03803 	lsl	r3, r3, #16
3002595c:	e1a03823 	lsr	r3, r3, #16
30025960:	e1a03a03 	lsl	r3, r3, #20
30025964:	e1a03a23 	lsr	r3, r3, #20
30025968:	e1cd31b2 	strh	r3, [sp, #18]
            if ((Index & 0x01) != 0)                /* �ж���12λ��Ч */
3002596c:	e59d3008 	ldr	r3, [sp, #8]
30025970:	e2033001 	and	r3, r3, #1
30025974:	e20330ff 	and	r3, r3, #255	; 0xff
30025978:	e3530000 	cmp	r3, #0
3002597c:	0a000017 	beq	300259e0 <FATSetNextClus+0x2f4>
            {
                temp = temp * 16;
30025980:	e1dd31b2 	ldrh	r3, [sp, #18]
30025984:	e1a03203 	lsl	r3, r3, #4
30025988:	e1cd31b2 	strh	r3, [sp, #18]
                temp |= (Buf[ByteIndex] & 0x0f);
3002598c:	e1dd21b6 	ldrh	r2, [sp, #22]
30025990:	e59d3018 	ldr	r3, [sp, #24]
30025994:	e0823003 	add	r3, r2, r3
30025998:	e5d33000 	ldrb	r3, [r3]
3002599c:	e1a03803 	lsl	r3, r3, #16
300259a0:	e1a03823 	lsr	r3, r3, #16
300259a4:	e203300f 	and	r3, r3, #15
300259a8:	e1dd11b2 	ldrh	r1, [sp, #18]
300259ac:	e1a02003 	mov	r2, r3
300259b0:	e1a03001 	mov	r3, r1
300259b4:	e1823003 	orr	r3, r2, r3
300259b8:	e1a03803 	lsl	r3, r3, #16
300259bc:	e1a03823 	lsr	r3, r3, #16
300259c0:	e1cd31b2 	strh	r3, [sp, #18]
                Buf[ByteIndex] = temp;
300259c4:	e1dd21b6 	ldrh	r2, [sp, #22]
300259c8:	e59d3018 	ldr	r3, [sp, #24]
300259cc:	e0823003 	add	r3, r2, r3
300259d0:	e1dd21b2 	ldrh	r2, [sp, #18]
300259d4:	e20220ff 	and	r2, r2, #255	; 0xff
300259d8:	e5c32000 	strb	r2, [r3]
300259dc:	ea000005 	b	300259f8 <FATSetNextClus+0x30c>
            }
            else
            {
                Buf[ByteIndex] = temp;
300259e0:	e1dd21b6 	ldrh	r2, [sp, #22]
300259e4:	e59d3018 	ldr	r3, [sp, #24]
300259e8:	e0823003 	add	r3, r2, r3
300259ec:	e1dd21b2 	ldrh	r2, [sp, #18]
300259f0:	e20220ff 	and	r2, r2, #255	; 0xff
300259f4:	e5c32000 	strb	r2, [r3]
            }
            ByteIndex++;
300259f8:	e1dd31b6 	ldrh	r3, [sp, #22]
300259fc:	e2833001 	add	r3, r3, #1
30025a00:	e1cd31b6 	strh	r3, [sp, #22]
            temp = temp >> 8;
30025a04:	e1dd31b2 	ldrh	r3, [sp, #18]
30025a08:	e1a03423 	lsr	r3, r3, #8
30025a0c:	e1cd31b2 	strh	r3, [sp, #18]
            if (ByteIndex >= Disk->BytsPerSec)          /* ��һ���ֽ��Ƿ�����һ������ */
30025a10:	e1dd21b6 	ldrh	r2, [sp, #22]
30025a14:	e59d301c 	ldr	r3, [sp, #28]
30025a18:	e593300c 	ldr	r3, [r3, #12]
30025a1c:	e1520003 	cmp	r2, r3
30025a20:	3a000034 	bcc	30025af8 <FATSetNextClus+0x40c>
            {
                Buf = OpenSec(Drive, SecIndex + 1);
30025a24:	e1dd31b4 	ldrh	r3, [sp, #20]
30025a28:	e2833001 	add	r3, r3, #1
30025a2c:	e5dd200f 	ldrb	r2, [sp, #15]
30025a30:	e1a00002 	mov	r0, r2
30025a34:	e1a01003 	mov	r1, r3
30025a38:	eb0018fa 	bl	3002be28 <OpenSec>
30025a3c:	e1a03000 	mov	r3, r0
30025a40:	e58d3018 	str	r3, [sp, #24]
                if (Buf == NULL)
30025a44:	e59d3018 	ldr	r3, [sp, #24]
30025a48:	e3530000 	cmp	r3, #0
30025a4c:	0a00007f 	beq	30025c50 <FATSetNextClus+0x564>
                {
                    break;
                }
                ReadSec(Drive, SecIndex + 1);
30025a50:	e1dd31b4 	ldrh	r3, [sp, #20]
30025a54:	e2833001 	add	r3, r3, #1
30025a58:	e5dd200f 	ldrb	r2, [sp, #15]
30025a5c:	e1a00002 	mov	r0, r2
30025a60:	e1a01003 	mov	r1, r3
30025a64:	eb001993 	bl	3002c0b8 <ReadSec>
                if ((Index & 0x01) != 0)                /* �ж���12λ��Ч */
30025a68:	e59d3008 	ldr	r3, [sp, #8]
30025a6c:	e2033001 	and	r3, r3, #1
30025a70:	e20330ff 	and	r3, r3, #255	; 0xff
30025a74:	e3530000 	cmp	r3, #0
30025a78:	0a000004 	beq	30025a90 <FATSetNextClus+0x3a4>
                {
                    Buf[0] = temp;
30025a7c:	e1dd31b2 	ldrh	r3, [sp, #18]
30025a80:	e20320ff 	and	r2, r3, #255	; 0xff
30025a84:	e59d3018 	ldr	r3, [sp, #24]
30025a88:	e5c32000 	strb	r2, [r3]
30025a8c:	ea00000c 	b	30025ac4 <FATSetNextClus+0x3d8>
                }
                else
                {
                    Buf[0] = (Buf[0] & 0xf0) | temp;
30025a90:	e59d3018 	ldr	r3, [sp, #24]
30025a94:	e5d33000 	ldrb	r3, [r3]
30025a98:	e20330ff 	and	r3, r3, #255	; 0xff
30025a9c:	e20330f0 	and	r3, r3, #240	; 0xf0
30025aa0:	e1dd21b2 	ldrh	r2, [sp, #18]
30025aa4:	e20210ff 	and	r1, r2, #255	; 0xff
30025aa8:	e1a02003 	mov	r2, r3
30025aac:	e1a03001 	mov	r3, r1
30025ab0:	e1823003 	orr	r3, r2, r3
30025ab4:	e20330ff 	and	r3, r3, #255	; 0xff
30025ab8:	e20320ff 	and	r2, r3, #255	; 0xff
30025abc:	e59d3018 	ldr	r3, [sp, #24]
30025ac0:	e5c32000 	strb	r2, [r3]
                }
                WriteSec(Drive, SecIndex + 1);
30025ac4:	e1dd31b4 	ldrh	r3, [sp, #20]
30025ac8:	e2833001 	add	r3, r3, #1
30025acc:	e5dd200f 	ldrb	r2, [sp, #15]
30025ad0:	e1a00002 	mov	r0, r2
30025ad4:	e1a01003 	mov	r1, r3
30025ad8:	eb0019d9 	bl	3002c244 <WriteSec>
                CloseSec(Drive, SecIndex + 1);
30025adc:	e1dd31b4 	ldrh	r3, [sp, #20]
30025ae0:	e2833001 	add	r3, r3, #1
30025ae4:	e5dd200f 	ldrb	r2, [sp, #15]
30025ae8:	e1a00002 	mov	r0, r2
30025aec:	e1a01003 	mov	r1, r3
30025af0:	eb0017c4 	bl	3002ba08 <CloseSec>
                else
                {
                    Buf[ByteIndex] = (Buf[ByteIndex] & 0xf0) | temp;
                }
            }
            break;
30025af4:	ea000056 	b	30025c54 <FATSetNextClus+0x568>
                WriteSec(Drive, SecIndex + 1);
                CloseSec(Drive, SecIndex + 1);
            }
            else
            {
                if ((Index & 0x01) != 0)                /* �ж���12λ��Ч */
30025af8:	e59d3008 	ldr	r3, [sp, #8]
30025afc:	e2033001 	and	r3, r3, #1
30025b00:	e20330ff 	and	r3, r3, #255	; 0xff
30025b04:	e3530000 	cmp	r3, #0
30025b08:	0a000006 	beq	30025b28 <FATSetNextClus+0x43c>
                {
                    Buf[ByteIndex] = temp;
30025b0c:	e1dd21b6 	ldrh	r2, [sp, #22]
30025b10:	e59d3018 	ldr	r3, [sp, #24]
30025b14:	e0823003 	add	r3, r2, r3
30025b18:	e1dd21b2 	ldrh	r2, [sp, #18]
30025b1c:	e20220ff 	and	r2, r2, #255	; 0xff
30025b20:	e5c32000 	strb	r2, [r3]
                else
                {
                    Buf[ByteIndex] = (Buf[ByteIndex] & 0xf0) | temp;
                }
            }
            break;
30025b24:	ea00004a 	b	30025c54 <FATSetNextClus+0x568>
                {
                    Buf[ByteIndex] = temp;
                }
                else
                {
                    Buf[ByteIndex] = (Buf[ByteIndex] & 0xf0) | temp;
30025b28:	e1dd21b6 	ldrh	r2, [sp, #22]
30025b2c:	e59d3018 	ldr	r3, [sp, #24]
30025b30:	e0822003 	add	r2, r2, r3
30025b34:	e1dd11b6 	ldrh	r1, [sp, #22]
30025b38:	e59d3018 	ldr	r3, [sp, #24]
30025b3c:	e0813003 	add	r3, r1, r3
30025b40:	e5d33000 	ldrb	r3, [r3]
30025b44:	e20330ff 	and	r3, r3, #255	; 0xff
30025b48:	e20330f0 	and	r3, r3, #240	; 0xf0
30025b4c:	e1dd11b2 	ldrh	r1, [sp, #18]
30025b50:	e20100ff 	and	r0, r1, #255	; 0xff
30025b54:	e1a01003 	mov	r1, r3
30025b58:	e1a03000 	mov	r3, r0
30025b5c:	e1813003 	orr	r3, r1, r3
30025b60:	e20330ff 	and	r3, r3, #255	; 0xff
30025b64:	e20330ff 	and	r3, r3, #255	; 0xff
30025b68:	e5c23000 	strb	r3, [r2]
                }
            }
            break;
30025b6c:	ea000038 	b	30025c54 <FATSetNextClus+0x568>
        case FAT16:
            Buf[ByteIndex] = Next;
30025b70:	e1dd21b6 	ldrh	r2, [sp, #22]
30025b74:	e59d3018 	ldr	r3, [sp, #24]
30025b78:	e0823003 	add	r3, r2, r3
30025b7c:	e59d2004 	ldr	r2, [sp, #4]
30025b80:	e20220ff 	and	r2, r2, #255	; 0xff
30025b84:	e5c32000 	strb	r2, [r3]
            Buf[ByteIndex + 1] = Next >> 8;
30025b88:	e1dd31b6 	ldrh	r3, [sp, #22]
30025b8c:	e2832001 	add	r2, r3, #1
30025b90:	e59d3018 	ldr	r3, [sp, #24]
30025b94:	e0823003 	add	r3, r2, r3
30025b98:	e59d2004 	ldr	r2, [sp, #4]
30025b9c:	e1a02422 	lsr	r2, r2, #8
30025ba0:	e20220ff 	and	r2, r2, #255	; 0xff
30025ba4:	e5c32000 	strb	r2, [r3]
            break;
30025ba8:	ea000029 	b	30025c54 <FATSetNextClus+0x568>
        case FAT32:
            Buf[ByteIndex] = Next;
30025bac:	e1dd21b6 	ldrh	r2, [sp, #22]
30025bb0:	e59d3018 	ldr	r3, [sp, #24]
30025bb4:	e0823003 	add	r3, r2, r3
30025bb8:	e59d2004 	ldr	r2, [sp, #4]
30025bbc:	e20220ff 	and	r2, r2, #255	; 0xff
30025bc0:	e5c32000 	strb	r2, [r3]
            Buf[ByteIndex + 1] = Next >> 8;
30025bc4:	e1dd31b6 	ldrh	r3, [sp, #22]
30025bc8:	e2832001 	add	r2, r3, #1
30025bcc:	e59d3018 	ldr	r3, [sp, #24]
30025bd0:	e0823003 	add	r3, r2, r3
30025bd4:	e59d2004 	ldr	r2, [sp, #4]
30025bd8:	e1a02422 	lsr	r2, r2, #8
30025bdc:	e20220ff 	and	r2, r2, #255	; 0xff
30025be0:	e5c32000 	strb	r2, [r3]
            Buf[ByteIndex + 2] = Next >> 16;
30025be4:	e1dd31b6 	ldrh	r3, [sp, #22]
30025be8:	e2832002 	add	r2, r3, #2
30025bec:	e59d3018 	ldr	r3, [sp, #24]
30025bf0:	e0823003 	add	r3, r2, r3
30025bf4:	e59d2004 	ldr	r2, [sp, #4]
30025bf8:	e1a02822 	lsr	r2, r2, #16
30025bfc:	e20220ff 	and	r2, r2, #255	; 0xff
30025c00:	e5c32000 	strb	r2, [r3]
            Buf[ByteIndex + 3] = (Buf[ByteIndex + 3] & 0xf0) | ((Next >> 24) & 0x0f);
30025c04:	e1dd31b6 	ldrh	r3, [sp, #22]
30025c08:	e2832003 	add	r2, r3, #3
30025c0c:	e59d3018 	ldr	r3, [sp, #24]
30025c10:	e0821003 	add	r1, r2, r3
30025c14:	e1dd31b6 	ldrh	r3, [sp, #22]
30025c18:	e2832003 	add	r2, r3, #3
30025c1c:	e59d3018 	ldr	r3, [sp, #24]
30025c20:	e0823003 	add	r3, r2, r3
30025c24:	e5d33000 	ldrb	r3, [r3]
30025c28:	e1a02003 	mov	r2, r3
30025c2c:	e20220f0 	and	r2, r2, #240	; 0xf0
30025c30:	e59d3004 	ldr	r3, [sp, #4]
30025c34:	e1a03c23 	lsr	r3, r3, #24
30025c38:	e20330ff 	and	r3, r3, #255	; 0xff
30025c3c:	e203300f 	and	r3, r3, #15
30025c40:	e1823003 	orr	r3, r2, r3
30025c44:	e20330ff 	and	r3, r3, #255	; 0xff
30025c48:	e5c13000 	strb	r3, [r1]
30025c4c:	ea000000 	b	30025c54 <FATSetNextClus+0x568>
            if (ByteIndex >= Disk->BytsPerSec)          /* ��һ���ֽ��Ƿ�����һ������ */
            {
                Buf = OpenSec(Drive, SecIndex + 1);
                if (Buf == NULL)
                {
                    break;
30025c50:	e1a00000 	nop			; (mov r0, r0)
            Buf[ByteIndex + 3] = (Buf[ByteIndex + 3] & 0xf0) | ((Next >> 24) & 0x0f);
            break;
        default:
            break;
    }
    WriteSec(Drive, SecIndex);
30025c54:	e1dd31b4 	ldrh	r3, [sp, #20]
30025c58:	e5dd200f 	ldrb	r2, [sp, #15]
30025c5c:	e1a00002 	mov	r0, r2
30025c60:	e1a01003 	mov	r1, r3
30025c64:	eb001976 	bl	3002c244 <WriteSec>
    CloseSec(Drive, SecIndex);
30025c68:	e1dd31b4 	ldrh	r3, [sp, #20]
30025c6c:	e5dd200f 	ldrb	r2, [sp, #15]
30025c70:	e1a00002 	mov	r0, r2
30025c74:	e1a01003 	mov	r1, r3
30025c78:	eb001762 	bl	3002ba08 <CloseSec>
    return ;
30025c7c:	e1a00000 	nop			; (mov r0, r0)
30025c80:	ea000008 	b	30025ca8 <FATSetNextClus+0x5bc>
    Disk_Info * Disk;
    
    Disk = GetDiskInfo(Drive);
    if (Disk == NULL)
    {
        return;
30025c84:	e1a00000 	nop			; (mov r0, r0)
30025c88:	ea000006 	b	30025ca8 <FATSetNextClus+0x5bc>
    }
    if (Index <= EMPTY_CLUS_1)
    {
        return;
30025c8c:	e1a00000 	nop			; (mov r0, r0)
30025c90:	ea000004 	b	30025ca8 <FATSetNextClus+0x5bc>
    }

    if (Index >= Disk->ClusPerData)
    {
        return;
30025c94:	e1a00000 	nop			; (mov r0, r0)
30025c98:	ea000002 	b	30025ca8 <FATSetNextClus+0x5bc>
        case FAT32:
            SecIndex = Index * 4 / Disk->BytsPerSec + Disk->FATStartSec;
            ByteIndex = (Index * 4) & (Disk->BytsPerSec - 1);
            break;
        default:
            return;
30025c9c:	e1a00000 	nop			; (mov r0, r0)
30025ca0:	ea000000 	b	30025ca8 <FATSetNextClus+0x5bc>
    }

    Buf = OpenSec(Drive, SecIndex);
    if (Buf == NULL)
    {
        return;
30025ca4:	e1a00000 	nop			; (mov r0, r0)
            break;
    }
    WriteSec(Drive, SecIndex);
    CloseSec(Drive, SecIndex);
    return ;
}
30025ca8:	e28dd024 	add	sp, sp, #36	; 0x24
30025cac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30025cb0:	e12fff1e 	bx	lr

30025cb4 <FATAddClus>:
**         
** ȫ�ֱ���: ��
** ����ģ��: ��
********************************************************************************************************/
        acoral_u32 FATAddClus(acoral_u8 Drive, acoral_u32 Index)
{
30025cb4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30025cb8:	e24dd01c 	sub	sp, sp, #28
30025cbc:	e1a03000 	mov	r3, r0
30025cc0:	e58d1000 	str	r1, [sp]
30025cc4:	e5cd3007 	strb	r3, [sp, #7]
    acoral_u32 NextClus,ThisClus,MaxClus;
    Disk_Info * Disk;

    Disk = GetDiskInfo(Drive);
30025cc8:	e5dd3007 	ldrb	r3, [sp, #7]
30025ccc:	e1a00003 	mov	r0, r3
30025cd0:	ebfff9d2 	bl	30024420 <GetDiskInfo>
30025cd4:	e1a03000 	mov	r3, r0
30025cd8:	e58d3014 	str	r3, [sp, #20]
    if (Disk == NULL)
30025cdc:	e59d3014 	ldr	r3, [sp, #20]
30025ce0:	e3530000 	cmp	r3, #0
30025ce4:	1a000001 	bne	30025cf0 <FATAddClus+0x3c>
    {
        return BAD_CLUS;
30025ce8:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
30025cec:	ea00006a 	b	30025e9c <FATAddClus+0x1e8>
    }
    
    if (Index >= BAD_CLUS)
30025cf0:	e59d3000 	ldr	r3, [sp]
30025cf4:	e37302af 	cmn	r3, #-268435446	; 0xf000000a
30025cf8:	9a000001 	bls	30025d04 <FATAddClus+0x50>
    {
        return BAD_CLUS;
30025cfc:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
30025d00:	ea000065 	b	30025e9c <FATAddClus+0x1e8>
    }
    
    
    MaxClus = Disk->ClusPerData;
30025d04:	e59d3014 	ldr	r3, [sp, #20]
30025d08:	e5933024 	ldr	r3, [r3, #36]	; 0x24
30025d0c:	e58d3010 	str	r3, [sp, #16]

    /* �������һ���� */
    ThisClus = Index;
30025d10:	e59d3000 	ldr	r3, [sp]
30025d14:	e58d300c 	str	r3, [sp, #12]
    if (ThisClus != EMPTY_CLUS && ThisClus != EMPTY_CLUS_1)
30025d18:	e59d300c 	ldr	r3, [sp, #12]
30025d1c:	e3530000 	cmp	r3, #0
30025d20:	0a000019 	beq	30025d8c <FATAddClus+0xd8>
30025d24:	e59d300c 	ldr	r3, [sp, #12]
30025d28:	e3530001 	cmp	r3, #1
30025d2c:	0a000016 	beq	30025d8c <FATAddClus+0xd8>
    {
        while (1)
        {
            NextClus = FATGetNextClus(Drive, ThisClus);
30025d30:	e5dd3007 	ldrb	r3, [sp, #7]
30025d34:	e1a00003 	mov	r0, r3
30025d38:	e59d100c 	ldr	r1, [sp, #12]
30025d3c:	ebfffd2d 	bl	300251f8 <FATGetNextClus>
30025d40:	e1a03000 	mov	r3, r0
30025d44:	e58d3008 	str	r3, [sp, #8]
            if (NextClus >= EOF_CLUS_1)
30025d48:	e59d3008 	ldr	r3, [sp, #8]
30025d4c:	e373029f 	cmn	r3, #-268435447	; 0xf0000009
30025d50:	9a000000 	bls	30025d58 <FATAddClus+0xa4>
            {
                break;
30025d54:	ea00000b 	b	30025d88 <FATAddClus+0xd4>
            }
            if (NextClus <= EMPTY_CLUS_1)
30025d58:	e59d3008 	ldr	r3, [sp, #8]
30025d5c:	e3530001 	cmp	r3, #1
30025d60:	8a000000 	bhi	30025d68 <FATAddClus+0xb4>
            {
                break;
30025d64:	ea000007 	b	30025d88 <FATAddClus+0xd4>
            }
            if (NextClus == BAD_CLUS)
30025d68:	e59d3008 	ldr	r3, [sp, #8]
30025d6c:	e373029f 	cmn	r3, #-268435447	; 0xf0000009
30025d70:	1a000001 	bne	30025d7c <FATAddClus+0xc8>
            {
                return BAD_CLUS;
30025d74:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
30025d78:	ea000047 	b	30025e9c <FATAddClus+0x1e8>
            }
            ThisClus = NextClus;
30025d7c:	e59d3008 	ldr	r3, [sp, #8]
30025d80:	e58d300c 	str	r3, [sp, #12]
        }
30025d84:	eaffffe9 	b	30025d30 <FATAddClus+0x7c>
    
    MaxClus = Disk->ClusPerData;

    /* �������һ���� */
    ThisClus = Index;
    if (ThisClus != EMPTY_CLUS && ThisClus != EMPTY_CLUS_1)
30025d88:	ea000001 	b	30025d94 <FATAddClus+0xe0>
            ThisClus = NextClus;
        }
    }
    else
    {
        ThisClus = EMPTY_CLUS_1;
30025d8c:	e3a03001 	mov	r3, #1
30025d90:	e58d300c 	str	r3, [sp, #12]
    }
    
    for (NextClus = ThisClus + 1; NextClus < MaxClus; NextClus++)
30025d94:	e59d300c 	ldr	r3, [sp, #12]
30025d98:	e2833001 	add	r3, r3, #1
30025d9c:	e58d3008 	str	r3, [sp, #8]
30025da0:	ea000009 	b	30025dcc <FATAddClus+0x118>
    {
        if (FATGetNextClus(Drive, NextClus) == EMPTY_CLUS)
30025da4:	e5dd3007 	ldrb	r3, [sp, #7]
30025da8:	e1a00003 	mov	r0, r3
30025dac:	e59d1008 	ldr	r1, [sp, #8]
30025db0:	ebfffd10 	bl	300251f8 <FATGetNextClus>
30025db4:	e1a03000 	mov	r3, r0
30025db8:	e3530000 	cmp	r3, #0
30025dbc:	0a000007 	beq	30025de0 <FATAddClus+0x12c>
    else
    {
        ThisClus = EMPTY_CLUS_1;
    }
    
    for (NextClus = ThisClus + 1; NextClus < MaxClus; NextClus++)
30025dc0:	e59d3008 	ldr	r3, [sp, #8]
30025dc4:	e2833001 	add	r3, r3, #1
30025dc8:	e58d3008 	str	r3, [sp, #8]
30025dcc:	e59d2008 	ldr	r2, [sp, #8]
30025dd0:	e59d3010 	ldr	r3, [sp, #16]
30025dd4:	e1520003 	cmp	r2, r3
30025dd8:	3afffff1 	bcc	30025da4 <FATAddClus+0xf0>
30025ddc:	ea000000 	b	30025de4 <FATAddClus+0x130>
    {
        if (FATGetNextClus(Drive, NextClus) == EMPTY_CLUS)
        {
            break;
30025de0:	e1a00000 	nop			; (mov r0, r0)
        }
    }
    if (NextClus >= MaxClus)
30025de4:	e59d2008 	ldr	r2, [sp, #8]
30025de8:	e59d3010 	ldr	r3, [sp, #16]
30025dec:	e1520003 	cmp	r2, r3
30025df0:	3a000012 	bcc	30025e40 <FATAddClus+0x18c>
    {
        for (NextClus = EMPTY_CLUS_1 + 1; NextClus < ThisClus; NextClus++)
30025df4:	e3a03002 	mov	r3, #2
30025df8:	e58d3008 	str	r3, [sp, #8]
30025dfc:	ea000009 	b	30025e28 <FATAddClus+0x174>
        {
            if (FATGetNextClus(Drive, NextClus) == EMPTY_CLUS)
30025e00:	e5dd3007 	ldrb	r3, [sp, #7]
30025e04:	e1a00003 	mov	r0, r3
30025e08:	e59d1008 	ldr	r1, [sp, #8]
30025e0c:	ebfffcf9 	bl	300251f8 <FATGetNextClus>
30025e10:	e1a03000 	mov	r3, r0
30025e14:	e3530000 	cmp	r3, #0
30025e18:	0a000007 	beq	30025e3c <FATAddClus+0x188>
            break;
        }
    }
    if (NextClus >= MaxClus)
    {
        for (NextClus = EMPTY_CLUS_1 + 1; NextClus < ThisClus; NextClus++)
30025e1c:	e59d3008 	ldr	r3, [sp, #8]
30025e20:	e2833001 	add	r3, r3, #1
30025e24:	e58d3008 	str	r3, [sp, #8]
30025e28:	e59d2008 	ldr	r2, [sp, #8]
30025e2c:	e59d300c 	ldr	r3, [sp, #12]
30025e30:	e1520003 	cmp	r2, r3
30025e34:	3afffff1 	bcc	30025e00 <FATAddClus+0x14c>
30025e38:	ea000000 	b	30025e40 <FATAddClus+0x18c>
        {
            if (FATGetNextClus(Drive, NextClus) == EMPTY_CLUS)
            {
                break;
30025e3c:	e1a00000 	nop			; (mov r0, r0)
            }
        }
    }
    if (FATGetNextClus(Drive, NextClus) == EMPTY_CLUS)
30025e40:	e5dd3007 	ldrb	r3, [sp, #7]
30025e44:	e1a00003 	mov	r0, r3
30025e48:	e59d1008 	ldr	r1, [sp, #8]
30025e4c:	ebfffce9 	bl	300251f8 <FATGetNextClus>
30025e50:	e1a03000 	mov	r3, r0
30025e54:	e3530000 	cmp	r3, #0
30025e58:	1a00000e 	bne	30025e98 <FATAddClus+0x1e4>
    {
        if (ThisClus > EMPTY_CLUS_1)
30025e5c:	e59d300c 	ldr	r3, [sp, #12]
30025e60:	e3530001 	cmp	r3, #1
30025e64:	9a000004 	bls	30025e7c <FATAddClus+0x1c8>
        {
            FATSetNextClus(Drive, ThisClus, NextClus);
30025e68:	e5dd3007 	ldrb	r3, [sp, #7]
30025e6c:	e1a00003 	mov	r0, r3
30025e70:	e59d100c 	ldr	r1, [sp, #12]
30025e74:	e59d2008 	ldr	r2, [sp, #8]
30025e78:	ebfffe1b 	bl	300256ec <FATSetNextClus>
        }
        FATSetNextClus(Drive, NextClus, EOF_CLUS_END);
30025e7c:	e5dd3007 	ldrb	r3, [sp, #7]
30025e80:	e1a00003 	mov	r0, r3
30025e84:	e59d1008 	ldr	r1, [sp, #8]
30025e88:	e3e0220f 	mvn	r2, #-268435456	; 0xf0000000
30025e8c:	ebfffe16 	bl	300256ec <FATSetNextClus>
        return NextClus;
30025e90:	e59d3008 	ldr	r3, [sp, #8]
30025e94:	ea000000 	b	30025e9c <FATAddClus+0x1e8>
    }
    else
    {
        return BAD_CLUS;
30025e98:	e3e0328f 	mvn	r3, #-268435448	; 0xf0000008
    }
}
30025e9c:	e1a00003 	mov	r0, r3
30025ea0:	e28dd01c 	add	sp, sp, #28
30025ea4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30025ea8:	e12fff1e 	bx	lr

30025eac <FATDelClusChain>:
**         
** ȫ�ֱ���: ��
** ����ģ��: FATGetNextClus,FATSetNextClus
********************************************************************************************************/
        void FATDelClusChain(acoral_u8 Drive, acoral_u32 Index)
{
30025eac:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30025eb0:	e24dd014 	sub	sp, sp, #20
30025eb4:	e1a03000 	mov	r3, r0
30025eb8:	e58d1000 	str	r1, [sp]
30025ebc:	e5cd3007 	strb	r3, [sp, #7]
    acoral_u32 NextClus, ThisClus;
    
    if (Index <= EMPTY_CLUS_1)
30025ec0:	e59d3000 	ldr	r3, [sp]
30025ec4:	e3530001 	cmp	r3, #1
30025ec8:	9a000018 	bls	30025f30 <FATDelClusChain+0x84>
    {
        return;
    }
    if (Index >= BAD_CLUS)
30025ecc:	e59d3000 	ldr	r3, [sp]
30025ed0:	e37302af 	cmn	r3, #-268435446	; 0xf000000a
30025ed4:	8a000017 	bhi	30025f38 <FATDelClusChain+0x8c>
    {
        return;
    }
    ThisClus = Index;
30025ed8:	e59d3000 	ldr	r3, [sp]
30025edc:	e58d300c 	str	r3, [sp, #12]
    while (1)
    {
        NextClus = FATGetNextClus(Drive, ThisClus);
30025ee0:	e5dd3007 	ldrb	r3, [sp, #7]
30025ee4:	e1a00003 	mov	r0, r3
30025ee8:	e59d100c 	ldr	r1, [sp, #12]
30025eec:	ebfffcc1 	bl	300251f8 <FATGetNextClus>
30025ef0:	e1a03000 	mov	r3, r0
30025ef4:	e58d3008 	str	r3, [sp, #8]
        FATSetNextClus(Drive, ThisClus, EMPTY_CLUS);
30025ef8:	e5dd3007 	ldrb	r3, [sp, #7]
30025efc:	e1a00003 	mov	r0, r3
30025f00:	e59d100c 	ldr	r1, [sp, #12]
30025f04:	e3a02000 	mov	r2, #0
30025f08:	ebfffdf7 	bl	300256ec <FATSetNextClus>
        if (NextClus >= BAD_CLUS)
30025f0c:	e59d3008 	ldr	r3, [sp, #8]
30025f10:	e37302af 	cmn	r3, #-268435446	; 0xf000000a
30025f14:	8a000009 	bhi	30025f40 <FATDelClusChain+0x94>
        {
            break;
        }
        if (NextClus <= EMPTY_CLUS_1)
30025f18:	e59d3008 	ldr	r3, [sp, #8]
30025f1c:	e3530001 	cmp	r3, #1
30025f20:	9a000008 	bls	30025f48 <FATDelClusChain+0x9c>
        {
            break;
        }
        ThisClus = NextClus;
30025f24:	e59d3008 	ldr	r3, [sp, #8]
30025f28:	e58d300c 	str	r3, [sp, #12]
    }
30025f2c:	eaffffeb 	b	30025ee0 <FATDelClusChain+0x34>
{
    acoral_u32 NextClus, ThisClus;
    
    if (Index <= EMPTY_CLUS_1)
    {
        return;
30025f30:	e1a00000 	nop			; (mov r0, r0)
30025f34:	ea000004 	b	30025f4c <FATDelClusChain+0xa0>
    }
    if (Index >= BAD_CLUS)
    {
        return;
30025f38:	e1a00000 	nop			; (mov r0, r0)
30025f3c:	ea000002 	b	30025f4c <FATDelClusChain+0xa0>
    {
        NextClus = FATGetNextClus(Drive, ThisClus);
        FATSetNextClus(Drive, ThisClus, EMPTY_CLUS);
        if (NextClus >= BAD_CLUS)
        {
            break;
30025f40:	e1a00000 	nop			; (mov r0, r0)
30025f44:	ea000000 	b	30025f4c <FATDelClusChain+0xa0>
        }
        if (NextClus <= EMPTY_CLUS_1)
        {
            break;
30025f48:	e1a00000 	nop			; (mov r0, r0)
        }
        ThisClus = NextClus;
    }
}
30025f4c:	e28dd014 	add	sp, sp, #20
30025f50:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30025f54:	e12fff1e 	bx	lr

30025f58 <ClearClus>:
**        οfat.hйڷֵ˵
** ȫֱ: 
** ģ: GetDiskInfo,OpenSec,WriteSec,CloseSec
********************************************************************************************************/
        acoral_u8 ClearClus(acoral_u8 Drive, acoral_u32 Index)
{
30025f58:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30025f5c:	e24dd024 	sub	sp, sp, #36	; 0x24
30025f60:	e1a03000 	mov	r3, r0
30025f64:	e58d1000 	str	r1, [sp]
30025f68:	e5cd3007 	strb	r3, [sp, #7]
    acoral_u8 *Buf;
    acoral_u32 SecIndex;
    acoral_u16 j;
    Disk_Info *Disk;

    Disk = GetDiskInfo(Drive);
30025f6c:	e5dd3007 	ldrb	r3, [sp, #7]
30025f70:	e1a00003 	mov	r0, r3
30025f74:	ebfff929 	bl	30024420 <GetDiskInfo>
30025f78:	e1a03000 	mov	r3, r0
30025f7c:	e58d301c 	str	r3, [sp, #28]
    if (Disk != NULL)
30025f80:	e59d301c 	ldr	r3, [sp, #28]
30025f84:	e3530000 	cmp	r3, #0
30025f88:	0a000043 	beq	3002609c <ClearClus+0x144>
    {
        if (Index < Disk->ClusPerData)
30025f8c:	e59d301c 	ldr	r3, [sp, #28]
30025f90:	e5932024 	ldr	r2, [r3, #36]	; 0x24
30025f94:	e59d3000 	ldr	r3, [sp]
30025f98:	e1520003 	cmp	r2, r3
30025f9c:	9a00003c 	bls	30026094 <ClearClus+0x13c>
        {
            temp = Disk->SecPerClus;
30025fa0:	e59d301c 	ldr	r3, [sp, #28]
30025fa4:	e5d33002 	ldrb	r3, [r3, #2]
30025fa8:	e5cd300f 	strb	r3, [sp, #15]
            Index -= 2;                     /* 2 */
30025fac:	e59d3000 	ldr	r3, [sp]
30025fb0:	e2433002 	sub	r3, r3, #2
30025fb4:	e58d3000 	str	r3, [sp]
            SecIndex = Disk->DataStartSec + Index * temp;
30025fb8:	e59d301c 	ldr	r3, [sp, #28]
30025fbc:	e5932020 	ldr	r2, [r3, #32]
30025fc0:	e5dd300f 	ldrb	r3, [sp, #15]
30025fc4:	e59d1000 	ldr	r1, [sp]
30025fc8:	e0030391 	mul	r3, r1, r3
30025fcc:	e0823003 	add	r3, r2, r3
30025fd0:	e58d3014 	str	r3, [sp, #20]
            for (i = 0; i < temp; i++)
30025fd4:	e3a03000 	mov	r3, #0
30025fd8:	e5cd300e 	strb	r3, [sp, #14]
30025fdc:	ea000026 	b	3002607c <ClearClus+0x124>
            {
                Buf=OpenSec(Drive, SecIndex);
30025fe0:	e5dd3007 	ldrb	r3, [sp, #7]
30025fe4:	e1a00003 	mov	r0, r3
30025fe8:	e59d1014 	ldr	r1, [sp, #20]
30025fec:	eb00178d 	bl	3002be28 <OpenSec>
30025ff0:	e1a03000 	mov	r3, r0
30025ff4:	e58d3010 	str	r3, [sp, #16]
                if(Buf!=NULL)  //ѾڻҪ
30025ff8:	e59d3010 	ldr	r3, [sp, #16]
30025ffc:	e3530000 	cmp	r3, #0
30026000:	0a00000f 	beq	30026044 <ClearClus+0xec>
                {
                	for(j=0;j<Disk->BytsPerSec;j++)
30026004:	e3a03000 	mov	r3, #0
30026008:	e1cd31ba 	strh	r3, [sp, #26]
3002600c:	ea000007 	b	30026030 <ClearClus+0xd8>
                		Buf[j]=0;
30026010:	e1dd21ba 	ldrh	r2, [sp, #26]
30026014:	e59d3010 	ldr	r3, [sp, #16]
30026018:	e0823003 	add	r3, r2, r3
3002601c:	e3a02000 	mov	r2, #0
30026020:	e5c32000 	strb	r2, [r3]
            for (i = 0; i < temp; i++)
            {
                Buf=OpenSec(Drive, SecIndex);
                if(Buf!=NULL)  //ѾڻҪ
                {
                	for(j=0;j<Disk->BytsPerSec;j++)
30026024:	e1dd31ba 	ldrh	r3, [sp, #26]
30026028:	e2833001 	add	r3, r3, #1
3002602c:	e1cd31ba 	strh	r3, [sp, #26]
30026030:	e1dd21ba 	ldrh	r2, [sp, #26]
30026034:	e59d301c 	ldr	r3, [sp, #28]
30026038:	e593300c 	ldr	r3, [r3, #12]
3002603c:	e1520003 	cmp	r2, r3
30026040:	3afffff2 	bcc	30026010 <ClearClus+0xb8>
                		Buf[j]=0;
                }
                WriteSec(Drive, SecIndex);
30026044:	e5dd3007 	ldrb	r3, [sp, #7]
30026048:	e1a00003 	mov	r0, r3
3002604c:	e59d1014 	ldr	r1, [sp, #20]
30026050:	eb00187b 	bl	3002c244 <WriteSec>
                CloseSec(Drive, SecIndex);
30026054:	e5dd3007 	ldrb	r3, [sp, #7]
30026058:	e1a00003 	mov	r0, r3
3002605c:	e59d1014 	ldr	r1, [sp, #20]
30026060:	eb001668 	bl	3002ba08 <CloseSec>
                SecIndex++;
30026064:	e59d3014 	ldr	r3, [sp, #20]
30026068:	e2833001 	add	r3, r3, #1
3002606c:	e58d3014 	str	r3, [sp, #20]
        if (Index < Disk->ClusPerData)
        {
            temp = Disk->SecPerClus;
            Index -= 2;                     /* 2 */
            SecIndex = Disk->DataStartSec + Index * temp;
            for (i = 0; i < temp; i++)
30026070:	e5dd300e 	ldrb	r3, [sp, #14]
30026074:	e2833001 	add	r3, r3, #1
30026078:	e5cd300e 	strb	r3, [sp, #14]
3002607c:	e5dd200e 	ldrb	r2, [sp, #14]
30026080:	e5dd300f 	ldrb	r3, [sp, #15]
30026084:	e1520003 	cmp	r2, r3
30026088:	3affffd4 	bcc	30025fe0 <ClearClus+0x88>
                }
                WriteSec(Drive, SecIndex);
                CloseSec(Drive, SecIndex);
                SecIndex++;
            }
            return RETURN_OK;
3002608c:	e3a03000 	mov	r3, #0
30026090:	ea000002 	b	300260a0 <ClearClus+0x148>
        }
        else
        {
            return CLUSTER_NOT_IN_DISK;
30026094:	e3a03006 	mov	r3, #6
30026098:	ea000000 	b	300260a0 <ClearClus+0x148>
        }
    }
    else
    {
        return NOT_FIND_DISK;
3002609c:	e3a03001 	mov	r3, #1
    }
}
300260a0:	e1a00003 	mov	r0, r3
300260a4:	e28dd024 	add	sp, sp, #36	; 0x24
300260a8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300260ac:	e12fff1e 	bx	lr

300260b0 <ReadFDTInfo>:
**        οfat.hйڷֵ˵
** ȫֱ: 
** ģ: OpenSec,ReadSec,CloseSec
********************************************************************************************************/
        acoral_u8  ReadFDTInfo(FDT *Rt, acoral_u8 Drive, acoral_u32 SecIndex, acoral_u16 ByteIndex)
{
300260b0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300260b4:	e24dd01c 	sub	sp, sp, #28
300260b8:	e58d000c 	str	r0, [sp, #12]
300260bc:	e58d2004 	str	r2, [sp, #4]
300260c0:	e1a02001 	mov	r2, r1
300260c4:	e5cd200b 	strb	r2, [sp, #11]
300260c8:	e1cd30b2 	strh	r3, [sp, #2]
    acoral_u8 *Buf;
    acoral_u8 temp;
    
    Buf = OpenSec(Drive, SecIndex);
300260cc:	e5dd300b 	ldrb	r3, [sp, #11]
300260d0:	e1a00003 	mov	r0, r3
300260d4:	e59d1004 	ldr	r1, [sp, #4]
300260d8:	eb001752 	bl	3002be28 <OpenSec>
300260dc:	e1a03000 	mov	r3, r0
300260e0:	e58d3010 	str	r3, [sp, #16]
    temp = NOT_EMPTY_CACHE;
300260e4:	e3a03004 	mov	r3, #4
300260e8:	e5cd3017 	strb	r3, [sp, #23]
    if (Buf != NULL)
300260ec:	e59d3010 	ldr	r3, [sp, #16]
300260f0:	e3530000 	cmp	r3, #0
300260f4:	0a000104 	beq	3002650c <ReadFDTInfo+0x45c>
    {

        temp = ReadSec(Drive, SecIndex);
300260f8:	e5dd300b 	ldrb	r3, [sp, #11]
300260fc:	e1a00003 	mov	r0, r3
30026100:	e59d1004 	ldr	r1, [sp, #4]
30026104:	eb0017eb 	bl	3002c0b8 <ReadSec>
30026108:	e1a03000 	mov	r3, r0
3002610c:	e5cd3017 	strb	r3, [sp, #23]
        if (temp == RETURN_OK)
30026110:	e5dd3017 	ldrb	r3, [sp, #23]
30026114:	e3530000 	cmp	r3, #0
30026118:	1a0000f7 	bne	300264fc <ReadFDTInfo+0x44c>
        {
            Buf = Buf + ByteIndex;
3002611c:	e1dd30b2 	ldrh	r3, [sp, #2]
30026120:	e59d2010 	ldr	r2, [sp, #16]
30026124:	e0823003 	add	r3, r2, r3
30026128:	e58d3010 	str	r3, [sp, #16]
            Rt->Name[0] = *Buf++;
3002612c:	e59d3010 	ldr	r3, [sp, #16]
30026130:	e5d32000 	ldrb	r2, [r3]
30026134:	e59d300c 	ldr	r3, [sp, #12]
30026138:	e5c32000 	strb	r2, [r3]
3002613c:	e59d3010 	ldr	r3, [sp, #16]
30026140:	e2833001 	add	r3, r3, #1
30026144:	e58d3010 	str	r3, [sp, #16]
            Rt->Name[1] = *Buf++;
30026148:	e59d3010 	ldr	r3, [sp, #16]
3002614c:	e5d32000 	ldrb	r2, [r3]
30026150:	e59d300c 	ldr	r3, [sp, #12]
30026154:	e5c32001 	strb	r2, [r3, #1]
30026158:	e59d3010 	ldr	r3, [sp, #16]
3002615c:	e2833001 	add	r3, r3, #1
30026160:	e58d3010 	str	r3, [sp, #16]
            Rt->Name[2] = *Buf++;
30026164:	e59d3010 	ldr	r3, [sp, #16]
30026168:	e5d32000 	ldrb	r2, [r3]
3002616c:	e59d300c 	ldr	r3, [sp, #12]
30026170:	e5c32002 	strb	r2, [r3, #2]
30026174:	e59d3010 	ldr	r3, [sp, #16]
30026178:	e2833001 	add	r3, r3, #1
3002617c:	e58d3010 	str	r3, [sp, #16]
            Rt->Name[3] = *Buf++;
30026180:	e59d3010 	ldr	r3, [sp, #16]
30026184:	e5d32000 	ldrb	r2, [r3]
30026188:	e59d300c 	ldr	r3, [sp, #12]
3002618c:	e5c32003 	strb	r2, [r3, #3]
30026190:	e59d3010 	ldr	r3, [sp, #16]
30026194:	e2833001 	add	r3, r3, #1
30026198:	e58d3010 	str	r3, [sp, #16]
            Rt->Name[4] = *Buf++;
3002619c:	e59d3010 	ldr	r3, [sp, #16]
300261a0:	e5d32000 	ldrb	r2, [r3]
300261a4:	e59d300c 	ldr	r3, [sp, #12]
300261a8:	e5c32004 	strb	r2, [r3, #4]
300261ac:	e59d3010 	ldr	r3, [sp, #16]
300261b0:	e2833001 	add	r3, r3, #1
300261b4:	e58d3010 	str	r3, [sp, #16]
            Rt->Name[5] = *Buf++;
300261b8:	e59d3010 	ldr	r3, [sp, #16]
300261bc:	e5d32000 	ldrb	r2, [r3]
300261c0:	e59d300c 	ldr	r3, [sp, #12]
300261c4:	e5c32005 	strb	r2, [r3, #5]
300261c8:	e59d3010 	ldr	r3, [sp, #16]
300261cc:	e2833001 	add	r3, r3, #1
300261d0:	e58d3010 	str	r3, [sp, #16]
            Rt->Name[6] = *Buf++;
300261d4:	e59d3010 	ldr	r3, [sp, #16]
300261d8:	e5d32000 	ldrb	r2, [r3]
300261dc:	e59d300c 	ldr	r3, [sp, #12]
300261e0:	e5c32006 	strb	r2, [r3, #6]
300261e4:	e59d3010 	ldr	r3, [sp, #16]
300261e8:	e2833001 	add	r3, r3, #1
300261ec:	e58d3010 	str	r3, [sp, #16]
            Rt->Name[7] = *Buf++;
300261f0:	e59d3010 	ldr	r3, [sp, #16]
300261f4:	e5d32000 	ldrb	r2, [r3]
300261f8:	e59d300c 	ldr	r3, [sp, #12]
300261fc:	e5c32007 	strb	r2, [r3, #7]
30026200:	e59d3010 	ldr	r3, [sp, #16]
30026204:	e2833001 	add	r3, r3, #1
30026208:	e58d3010 	str	r3, [sp, #16]
            Rt->Name[8] = *Buf++;
3002620c:	e59d3010 	ldr	r3, [sp, #16]
30026210:	e5d32000 	ldrb	r2, [r3]
30026214:	e59d300c 	ldr	r3, [sp, #12]
30026218:	e5c32008 	strb	r2, [r3, #8]
3002621c:	e59d3010 	ldr	r3, [sp, #16]
30026220:	e2833001 	add	r3, r3, #1
30026224:	e58d3010 	str	r3, [sp, #16]
            Rt->Name[9] = *Buf++;
30026228:	e59d3010 	ldr	r3, [sp, #16]
3002622c:	e5d32000 	ldrb	r2, [r3]
30026230:	e59d300c 	ldr	r3, [sp, #12]
30026234:	e5c32009 	strb	r2, [r3, #9]
30026238:	e59d3010 	ldr	r3, [sp, #16]
3002623c:	e2833001 	add	r3, r3, #1
30026240:	e58d3010 	str	r3, [sp, #16]
            Rt->Name[10] = *Buf++;
30026244:	e59d3010 	ldr	r3, [sp, #16]
30026248:	e5d32000 	ldrb	r2, [r3]
3002624c:	e59d300c 	ldr	r3, [sp, #12]
30026250:	e5c3200a 	strb	r2, [r3, #10]
30026254:	e59d3010 	ldr	r3, [sp, #16]
30026258:	e2833001 	add	r3, r3, #1
3002625c:	e58d3010 	str	r3, [sp, #16]
            Rt->Attr = *Buf++;
30026260:	e59d3010 	ldr	r3, [sp, #16]
30026264:	e5d32000 	ldrb	r2, [r3]
30026268:	e59d300c 	ldr	r3, [sp, #12]
3002626c:	e5c3200b 	strb	r2, [r3, #11]
30026270:	e59d3010 	ldr	r3, [sp, #16]
30026274:	e2833001 	add	r3, r3, #1
30026278:	e58d3010 	str	r3, [sp, #16]
            Rt->NTRes = *Buf++;
3002627c:	e59d3010 	ldr	r3, [sp, #16]
30026280:	e5d32000 	ldrb	r2, [r3]
30026284:	e59d300c 	ldr	r3, [sp, #12]
30026288:	e5c3200c 	strb	r2, [r3, #12]
3002628c:	e59d3010 	ldr	r3, [sp, #16]
30026290:	e2833001 	add	r3, r3, #1
30026294:	e58d3010 	str	r3, [sp, #16]
            Rt->CrtTimeTenth = *Buf++;
30026298:	e59d3010 	ldr	r3, [sp, #16]
3002629c:	e5d32000 	ldrb	r2, [r3]
300262a0:	e59d300c 	ldr	r3, [sp, #12]
300262a4:	e5c3200d 	strb	r2, [r3, #13]
300262a8:	e59d3010 	ldr	r3, [sp, #16]
300262ac:	e2833001 	add	r3, r3, #1
300262b0:	e58d3010 	str	r3, [sp, #16]
            Rt->CrtTime = Buf[0] | (Buf[1] << 8);
300262b4:	e59d3010 	ldr	r3, [sp, #16]
300262b8:	e5d33000 	ldrb	r3, [r3]
300262bc:	e1a02003 	mov	r2, r3
300262c0:	e59d3010 	ldr	r3, [sp, #16]
300262c4:	e2833001 	add	r3, r3, #1
300262c8:	e5d33000 	ldrb	r3, [r3]
300262cc:	e1a03403 	lsl	r3, r3, #8
300262d0:	e1a03803 	lsl	r3, r3, #16
300262d4:	e1a03823 	lsr	r3, r3, #16
300262d8:	e1823003 	orr	r3, r2, r3
300262dc:	e1a03803 	lsl	r3, r3, #16
300262e0:	e1a03823 	lsr	r3, r3, #16
300262e4:	e1a03803 	lsl	r3, r3, #16
300262e8:	e1a02823 	lsr	r2, r3, #16
300262ec:	e59d300c 	ldr	r3, [sp, #12]
300262f0:	e1c320be 	strh	r2, [r3, #14]
            Rt->CrtDate = Buf[2] | (Buf[3] << 8);
300262f4:	e59d3010 	ldr	r3, [sp, #16]
300262f8:	e2833002 	add	r3, r3, #2
300262fc:	e5d33000 	ldrb	r3, [r3]
30026300:	e1a02003 	mov	r2, r3
30026304:	e59d3010 	ldr	r3, [sp, #16]
30026308:	e2833003 	add	r3, r3, #3
3002630c:	e5d33000 	ldrb	r3, [r3]
30026310:	e1a03403 	lsl	r3, r3, #8
30026314:	e1a03803 	lsl	r3, r3, #16
30026318:	e1a03823 	lsr	r3, r3, #16
3002631c:	e1823003 	orr	r3, r2, r3
30026320:	e1a03803 	lsl	r3, r3, #16
30026324:	e1a03823 	lsr	r3, r3, #16
30026328:	e1a03803 	lsl	r3, r3, #16
3002632c:	e1a02823 	lsr	r2, r3, #16
30026330:	e59d300c 	ldr	r3, [sp, #12]
30026334:	e1c321b0 	strh	r2, [r3, #16]
            Rt->LstAccDate = Buf[4] | (Buf[5] << 8);
30026338:	e59d3010 	ldr	r3, [sp, #16]
3002633c:	e2833004 	add	r3, r3, #4
30026340:	e5d33000 	ldrb	r3, [r3]
30026344:	e1a02003 	mov	r2, r3
30026348:	e59d3010 	ldr	r3, [sp, #16]
3002634c:	e2833005 	add	r3, r3, #5
30026350:	e5d33000 	ldrb	r3, [r3]
30026354:	e1a03403 	lsl	r3, r3, #8
30026358:	e1a03803 	lsl	r3, r3, #16
3002635c:	e1a03823 	lsr	r3, r3, #16
30026360:	e1823003 	orr	r3, r2, r3
30026364:	e1a03803 	lsl	r3, r3, #16
30026368:	e1a03823 	lsr	r3, r3, #16
3002636c:	e1a03803 	lsl	r3, r3, #16
30026370:	e1a02823 	lsr	r2, r3, #16
30026374:	e59d300c 	ldr	r3, [sp, #12]
30026378:	e1c321b2 	strh	r2, [r3, #18]
            Rt->FstClusHI = Buf[6] | (Buf[7] << 8);
3002637c:	e59d3010 	ldr	r3, [sp, #16]
30026380:	e2833006 	add	r3, r3, #6
30026384:	e5d33000 	ldrb	r3, [r3]
30026388:	e1a02003 	mov	r2, r3
3002638c:	e59d3010 	ldr	r3, [sp, #16]
30026390:	e2833007 	add	r3, r3, #7
30026394:	e5d33000 	ldrb	r3, [r3]
30026398:	e1a03403 	lsl	r3, r3, #8
3002639c:	e1a03803 	lsl	r3, r3, #16
300263a0:	e1a03823 	lsr	r3, r3, #16
300263a4:	e1823003 	orr	r3, r2, r3
300263a8:	e1a03803 	lsl	r3, r3, #16
300263ac:	e1a03823 	lsr	r3, r3, #16
300263b0:	e1a03803 	lsl	r3, r3, #16
300263b4:	e1a02823 	lsr	r2, r3, #16
300263b8:	e59d300c 	ldr	r3, [sp, #12]
300263bc:	e1c321b4 	strh	r2, [r3, #20]
            Rt->WrtTime = Buf[8] | (Buf[9] << 8);
300263c0:	e59d3010 	ldr	r3, [sp, #16]
300263c4:	e2833008 	add	r3, r3, #8
300263c8:	e5d33000 	ldrb	r3, [r3]
300263cc:	e1a02003 	mov	r2, r3
300263d0:	e59d3010 	ldr	r3, [sp, #16]
300263d4:	e2833009 	add	r3, r3, #9
300263d8:	e5d33000 	ldrb	r3, [r3]
300263dc:	e1a03403 	lsl	r3, r3, #8
300263e0:	e1a03803 	lsl	r3, r3, #16
300263e4:	e1a03823 	lsr	r3, r3, #16
300263e8:	e1823003 	orr	r3, r2, r3
300263ec:	e1a03803 	lsl	r3, r3, #16
300263f0:	e1a03823 	lsr	r3, r3, #16
300263f4:	e1a03803 	lsl	r3, r3, #16
300263f8:	e1a02823 	lsr	r2, r3, #16
300263fc:	e59d300c 	ldr	r3, [sp, #12]
30026400:	e1c321b6 	strh	r2, [r3, #22]
            Rt->WrtDate = Buf[10] | (Buf[11] << 8);
30026404:	e59d3010 	ldr	r3, [sp, #16]
30026408:	e283300a 	add	r3, r3, #10
3002640c:	e5d33000 	ldrb	r3, [r3]
30026410:	e1a02003 	mov	r2, r3
30026414:	e59d3010 	ldr	r3, [sp, #16]
30026418:	e283300b 	add	r3, r3, #11
3002641c:	e5d33000 	ldrb	r3, [r3]
30026420:	e1a03403 	lsl	r3, r3, #8
30026424:	e1a03803 	lsl	r3, r3, #16
30026428:	e1a03823 	lsr	r3, r3, #16
3002642c:	e1823003 	orr	r3, r2, r3
30026430:	e1a03803 	lsl	r3, r3, #16
30026434:	e1a03823 	lsr	r3, r3, #16
30026438:	e1a03803 	lsl	r3, r3, #16
3002643c:	e1a02823 	lsr	r2, r3, #16
30026440:	e59d300c 	ldr	r3, [sp, #12]
30026444:	e1c321b8 	strh	r2, [r3, #24]
            Rt->FstClusLO = Buf[12] | (Buf[13] << 8);
30026448:	e59d3010 	ldr	r3, [sp, #16]
3002644c:	e283300c 	add	r3, r3, #12
30026450:	e5d33000 	ldrb	r3, [r3]
30026454:	e1a02003 	mov	r2, r3
30026458:	e59d3010 	ldr	r3, [sp, #16]
3002645c:	e283300d 	add	r3, r3, #13
30026460:	e5d33000 	ldrb	r3, [r3]
30026464:	e1a03403 	lsl	r3, r3, #8
30026468:	e1a03803 	lsl	r3, r3, #16
3002646c:	e1a03823 	lsr	r3, r3, #16
30026470:	e1823003 	orr	r3, r2, r3
30026474:	e1a03803 	lsl	r3, r3, #16
30026478:	e1a03823 	lsr	r3, r3, #16
3002647c:	e1a03803 	lsl	r3, r3, #16
30026480:	e1a02823 	lsr	r2, r3, #16
30026484:	e59d300c 	ldr	r3, [sp, #12]
30026488:	e1c321ba 	strh	r2, [r3, #26]
            Rt->FileSize = Buf[14]  | (Buf[15] << 8);
3002648c:	e59d3010 	ldr	r3, [sp, #16]
30026490:	e283300e 	add	r3, r3, #14
30026494:	e5d33000 	ldrb	r3, [r3]
30026498:	e1a02003 	mov	r2, r3
3002649c:	e59d3010 	ldr	r3, [sp, #16]
300264a0:	e283300f 	add	r3, r3, #15
300264a4:	e5d33000 	ldrb	r3, [r3]
300264a8:	e1a03403 	lsl	r3, r3, #8
300264ac:	e1823003 	orr	r3, r2, r3
300264b0:	e1a02003 	mov	r2, r3
300264b4:	e59d300c 	ldr	r3, [sp, #12]
300264b8:	e583201c 	str	r2, [r3, #28]
            Rt->FileSize |= (((acoral_u32)Buf[16] << 16) | ((acoral_u32)Buf[17] << 24));
300264bc:	e59d300c 	ldr	r3, [sp, #12]
300264c0:	e593201c 	ldr	r2, [r3, #28]
300264c4:	e59d3010 	ldr	r3, [sp, #16]
300264c8:	e2833010 	add	r3, r3, #16
300264cc:	e5d33000 	ldrb	r3, [r3]
300264d0:	e1a01803 	lsl	r1, r3, #16
300264d4:	e59d3010 	ldr	r3, [sp, #16]
300264d8:	e2833011 	add	r3, r3, #17
300264dc:	e5d33000 	ldrb	r3, [r3]
300264e0:	e1a03c03 	lsl	r3, r3, #24
300264e4:	e1813003 	orr	r3, r1, r3
300264e8:	e1822003 	orr	r2, r2, r3
300264ec:	e59d300c 	ldr	r3, [sp, #12]
300264f0:	e583201c 	str	r2, [r3, #28]
            temp = RETURN_OK;
300264f4:	e3a03000 	mov	r3, #0
300264f8:	e5cd3017 	strb	r3, [sp, #23]
        }
        CloseSec(Drive, SecIndex);
300264fc:	e5dd300b 	ldrb	r3, [sp, #11]
30026500:	e1a00003 	mov	r0, r3
30026504:	e59d1004 	ldr	r1, [sp, #4]
30026508:	eb00153e 	bl	3002ba08 <CloseSec>
    }
    return temp;
3002650c:	e5dd3017 	ldrb	r3, [sp, #23]
}
30026510:	e1a00003 	mov	r0, r3
30026514:	e28dd01c 	add	sp, sp, #28
30026518:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002651c:	e12fff1e 	bx	lr

30026520 <WriteFDTInfo>:
**        οfat.hйڷֵ˵
** ȫֱ: 
** ģ: OpenSec,ReadSec,CloseSec
********************************************************************************************************/
        acoral_u8  WriteFDTInfo(acoral_u8 Drive, acoral_u32 SecIndex, acoral_u16 ByteIndex, FDT *FDTData)
{
30026520:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30026524:	e24dd01c 	sub	sp, sp, #28
30026528:	e58d1008 	str	r1, [sp, #8]
3002652c:	e58d3000 	str	r3, [sp]
30026530:	e1a03000 	mov	r3, r0
30026534:	e5cd300f 	strb	r3, [sp, #15]
30026538:	e1cd20b6 	strh	r2, [sp, #6]
    acoral_u8 *Buf;
    acoral_u8 temp;
    
    temp = NOT_EMPTY_CACHE;
3002653c:	e3a03004 	mov	r3, #4
30026540:	e5cd3017 	strb	r3, [sp, #23]
    Buf = OpenSec(Drive, SecIndex);
30026544:	e5dd300f 	ldrb	r3, [sp, #15]
30026548:	e1a00003 	mov	r0, r3
3002654c:	e59d1008 	ldr	r1, [sp, #8]
30026550:	eb001634 	bl	3002be28 <OpenSec>
30026554:	e1a03000 	mov	r3, r0
30026558:	e58d3010 	str	r3, [sp, #16]
    if (Buf != NULL)
3002655c:	e59d3010 	ldr	r3, [sp, #16]
30026560:	e3530000 	cmp	r3, #0
30026564:	0a00011b 	beq	300269d8 <WriteFDTInfo+0x4b8>
    {
        temp = ReadSec(Drive, SecIndex);
30026568:	e5dd300f 	ldrb	r3, [sp, #15]
3002656c:	e1a00003 	mov	r0, r3
30026570:	e59d1008 	ldr	r1, [sp, #8]
30026574:	eb0016cf 	bl	3002c0b8 <ReadSec>
30026578:	e1a03000 	mov	r3, r0
3002657c:	e5cd3017 	strb	r3, [sp, #23]
        if (temp == RETURN_OK)
30026580:	e5dd3017 	ldrb	r3, [sp, #23]
30026584:	e3530000 	cmp	r3, #0
30026588:	1a00010e 	bne	300269c8 <WriteFDTInfo+0x4a8>
        {
            Buf = Buf + ByteIndex;
3002658c:	e1dd30b6 	ldrh	r3, [sp, #6]
30026590:	e59d2010 	ldr	r2, [sp, #16]
30026594:	e0823003 	add	r3, r2, r3
30026598:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->Name[0];
3002659c:	e59d3000 	ldr	r3, [sp]
300265a0:	e5d32000 	ldrb	r2, [r3]
300265a4:	e59d3010 	ldr	r3, [sp, #16]
300265a8:	e5c32000 	strb	r2, [r3]
300265ac:	e59d3010 	ldr	r3, [sp, #16]
300265b0:	e2833001 	add	r3, r3, #1
300265b4:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->Name[1];
300265b8:	e59d3000 	ldr	r3, [sp]
300265bc:	e5d32001 	ldrb	r2, [r3, #1]
300265c0:	e59d3010 	ldr	r3, [sp, #16]
300265c4:	e5c32000 	strb	r2, [r3]
300265c8:	e59d3010 	ldr	r3, [sp, #16]
300265cc:	e2833001 	add	r3, r3, #1
300265d0:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->Name[2];
300265d4:	e59d3000 	ldr	r3, [sp]
300265d8:	e5d32002 	ldrb	r2, [r3, #2]
300265dc:	e59d3010 	ldr	r3, [sp, #16]
300265e0:	e5c32000 	strb	r2, [r3]
300265e4:	e59d3010 	ldr	r3, [sp, #16]
300265e8:	e2833001 	add	r3, r3, #1
300265ec:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->Name[3];
300265f0:	e59d3000 	ldr	r3, [sp]
300265f4:	e5d32003 	ldrb	r2, [r3, #3]
300265f8:	e59d3010 	ldr	r3, [sp, #16]
300265fc:	e5c32000 	strb	r2, [r3]
30026600:	e59d3010 	ldr	r3, [sp, #16]
30026604:	e2833001 	add	r3, r3, #1
30026608:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->Name[4];
3002660c:	e59d3000 	ldr	r3, [sp]
30026610:	e5d32004 	ldrb	r2, [r3, #4]
30026614:	e59d3010 	ldr	r3, [sp, #16]
30026618:	e5c32000 	strb	r2, [r3]
3002661c:	e59d3010 	ldr	r3, [sp, #16]
30026620:	e2833001 	add	r3, r3, #1
30026624:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->Name[5];
30026628:	e59d3000 	ldr	r3, [sp]
3002662c:	e5d32005 	ldrb	r2, [r3, #5]
30026630:	e59d3010 	ldr	r3, [sp, #16]
30026634:	e5c32000 	strb	r2, [r3]
30026638:	e59d3010 	ldr	r3, [sp, #16]
3002663c:	e2833001 	add	r3, r3, #1
30026640:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->Name[6];
30026644:	e59d3000 	ldr	r3, [sp]
30026648:	e5d32006 	ldrb	r2, [r3, #6]
3002664c:	e59d3010 	ldr	r3, [sp, #16]
30026650:	e5c32000 	strb	r2, [r3]
30026654:	e59d3010 	ldr	r3, [sp, #16]
30026658:	e2833001 	add	r3, r3, #1
3002665c:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->Name[7];
30026660:	e59d3000 	ldr	r3, [sp]
30026664:	e5d32007 	ldrb	r2, [r3, #7]
30026668:	e59d3010 	ldr	r3, [sp, #16]
3002666c:	e5c32000 	strb	r2, [r3]
30026670:	e59d3010 	ldr	r3, [sp, #16]
30026674:	e2833001 	add	r3, r3, #1
30026678:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->Name[8];
3002667c:	e59d3000 	ldr	r3, [sp]
30026680:	e5d32008 	ldrb	r2, [r3, #8]
30026684:	e59d3010 	ldr	r3, [sp, #16]
30026688:	e5c32000 	strb	r2, [r3]
3002668c:	e59d3010 	ldr	r3, [sp, #16]
30026690:	e2833001 	add	r3, r3, #1
30026694:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->Name[9];
30026698:	e59d3000 	ldr	r3, [sp]
3002669c:	e5d32009 	ldrb	r2, [r3, #9]
300266a0:	e59d3010 	ldr	r3, [sp, #16]
300266a4:	e5c32000 	strb	r2, [r3]
300266a8:	e59d3010 	ldr	r3, [sp, #16]
300266ac:	e2833001 	add	r3, r3, #1
300266b0:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->Name[10];
300266b4:	e59d3000 	ldr	r3, [sp]
300266b8:	e5d3200a 	ldrb	r2, [r3, #10]
300266bc:	e59d3010 	ldr	r3, [sp, #16]
300266c0:	e5c32000 	strb	r2, [r3]
300266c4:	e59d3010 	ldr	r3, [sp, #16]
300266c8:	e2833001 	add	r3, r3, #1
300266cc:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->Attr;
300266d0:	e59d3000 	ldr	r3, [sp]
300266d4:	e5d3200b 	ldrb	r2, [r3, #11]
300266d8:	e59d3010 	ldr	r3, [sp, #16]
300266dc:	e5c32000 	strb	r2, [r3]
300266e0:	e59d3010 	ldr	r3, [sp, #16]
300266e4:	e2833001 	add	r3, r3, #1
300266e8:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->NTRes;
300266ec:	e59d3000 	ldr	r3, [sp]
300266f0:	e5d3200c 	ldrb	r2, [r3, #12]
300266f4:	e59d3010 	ldr	r3, [sp, #16]
300266f8:	e5c32000 	strb	r2, [r3]
300266fc:	e59d3010 	ldr	r3, [sp, #16]
30026700:	e2833001 	add	r3, r3, #1
30026704:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->CrtTimeTenth;
30026708:	e59d3000 	ldr	r3, [sp]
3002670c:	e5d3200d 	ldrb	r2, [r3, #13]
30026710:	e59d3010 	ldr	r3, [sp, #16]
30026714:	e5c32000 	strb	r2, [r3]
30026718:	e59d3010 	ldr	r3, [sp, #16]
3002671c:	e2833001 	add	r3, r3, #1
30026720:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->CrtTime;
30026724:	e59d3000 	ldr	r3, [sp]
30026728:	e1d330be 	ldrh	r3, [r3, #14]
3002672c:	e20320ff 	and	r2, r3, #255	; 0xff
30026730:	e59d3010 	ldr	r3, [sp, #16]
30026734:	e5c32000 	strb	r2, [r3]
30026738:	e59d3010 	ldr	r3, [sp, #16]
3002673c:	e2833001 	add	r3, r3, #1
30026740:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = (FDTData->CrtTime) >> 8;
30026744:	e59d3000 	ldr	r3, [sp]
30026748:	e1d330be 	ldrh	r3, [r3, #14]
3002674c:	e1a03423 	lsr	r3, r3, #8
30026750:	e1a03803 	lsl	r3, r3, #16
30026754:	e1a03823 	lsr	r3, r3, #16
30026758:	e20320ff 	and	r2, r3, #255	; 0xff
3002675c:	e59d3010 	ldr	r3, [sp, #16]
30026760:	e5c32000 	strb	r2, [r3]
30026764:	e59d3010 	ldr	r3, [sp, #16]
30026768:	e2833001 	add	r3, r3, #1
3002676c:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->CrtDate;
30026770:	e59d3000 	ldr	r3, [sp]
30026774:	e1d331b0 	ldrh	r3, [r3, #16]
30026778:	e20320ff 	and	r2, r3, #255	; 0xff
3002677c:	e59d3010 	ldr	r3, [sp, #16]
30026780:	e5c32000 	strb	r2, [r3]
30026784:	e59d3010 	ldr	r3, [sp, #16]
30026788:	e2833001 	add	r3, r3, #1
3002678c:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = (FDTData->CrtDate) >> 8;
30026790:	e59d3000 	ldr	r3, [sp]
30026794:	e1d331b0 	ldrh	r3, [r3, #16]
30026798:	e1a03423 	lsr	r3, r3, #8
3002679c:	e1a03803 	lsl	r3, r3, #16
300267a0:	e1a03823 	lsr	r3, r3, #16
300267a4:	e20320ff 	and	r2, r3, #255	; 0xff
300267a8:	e59d3010 	ldr	r3, [sp, #16]
300267ac:	e5c32000 	strb	r2, [r3]
300267b0:	e59d3010 	ldr	r3, [sp, #16]
300267b4:	e2833001 	add	r3, r3, #1
300267b8:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->LstAccDate;
300267bc:	e59d3000 	ldr	r3, [sp]
300267c0:	e1d331b2 	ldrh	r3, [r3, #18]
300267c4:	e20320ff 	and	r2, r3, #255	; 0xff
300267c8:	e59d3010 	ldr	r3, [sp, #16]
300267cc:	e5c32000 	strb	r2, [r3]
300267d0:	e59d3010 	ldr	r3, [sp, #16]
300267d4:	e2833001 	add	r3, r3, #1
300267d8:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = (FDTData->LstAccDate) >> 8;
300267dc:	e59d3000 	ldr	r3, [sp]
300267e0:	e1d331b2 	ldrh	r3, [r3, #18]
300267e4:	e1a03423 	lsr	r3, r3, #8
300267e8:	e1a03803 	lsl	r3, r3, #16
300267ec:	e1a03823 	lsr	r3, r3, #16
300267f0:	e20320ff 	and	r2, r3, #255	; 0xff
300267f4:	e59d3010 	ldr	r3, [sp, #16]
300267f8:	e5c32000 	strb	r2, [r3]
300267fc:	e59d3010 	ldr	r3, [sp, #16]
30026800:	e2833001 	add	r3, r3, #1
30026804:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->FstClusHI;
30026808:	e59d3000 	ldr	r3, [sp]
3002680c:	e1d331b4 	ldrh	r3, [r3, #20]
30026810:	e20320ff 	and	r2, r3, #255	; 0xff
30026814:	e59d3010 	ldr	r3, [sp, #16]
30026818:	e5c32000 	strb	r2, [r3]
3002681c:	e59d3010 	ldr	r3, [sp, #16]
30026820:	e2833001 	add	r3, r3, #1
30026824:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = (FDTData->FstClusHI) >> 8;
30026828:	e59d3000 	ldr	r3, [sp]
3002682c:	e1d331b4 	ldrh	r3, [r3, #20]
30026830:	e1a03423 	lsr	r3, r3, #8
30026834:	e1a03803 	lsl	r3, r3, #16
30026838:	e1a03823 	lsr	r3, r3, #16
3002683c:	e20320ff 	and	r2, r3, #255	; 0xff
30026840:	e59d3010 	ldr	r3, [sp, #16]
30026844:	e5c32000 	strb	r2, [r3]
30026848:	e59d3010 	ldr	r3, [sp, #16]
3002684c:	e2833001 	add	r3, r3, #1
30026850:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->WrtTime;
30026854:	e59d3000 	ldr	r3, [sp]
30026858:	e1d331b6 	ldrh	r3, [r3, #22]
3002685c:	e20320ff 	and	r2, r3, #255	; 0xff
30026860:	e59d3010 	ldr	r3, [sp, #16]
30026864:	e5c32000 	strb	r2, [r3]
30026868:	e59d3010 	ldr	r3, [sp, #16]
3002686c:	e2833001 	add	r3, r3, #1
30026870:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = (FDTData->WrtTime) >> 8;
30026874:	e59d3000 	ldr	r3, [sp]
30026878:	e1d331b6 	ldrh	r3, [r3, #22]
3002687c:	e1a03423 	lsr	r3, r3, #8
30026880:	e1a03803 	lsl	r3, r3, #16
30026884:	e1a03823 	lsr	r3, r3, #16
30026888:	e20320ff 	and	r2, r3, #255	; 0xff
3002688c:	e59d3010 	ldr	r3, [sp, #16]
30026890:	e5c32000 	strb	r2, [r3]
30026894:	e59d3010 	ldr	r3, [sp, #16]
30026898:	e2833001 	add	r3, r3, #1
3002689c:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->WrtDate;
300268a0:	e59d3000 	ldr	r3, [sp]
300268a4:	e1d331b8 	ldrh	r3, [r3, #24]
300268a8:	e20320ff 	and	r2, r3, #255	; 0xff
300268ac:	e59d3010 	ldr	r3, [sp, #16]
300268b0:	e5c32000 	strb	r2, [r3]
300268b4:	e59d3010 	ldr	r3, [sp, #16]
300268b8:	e2833001 	add	r3, r3, #1
300268bc:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = (FDTData->WrtDate) >> 8;
300268c0:	e59d3000 	ldr	r3, [sp]
300268c4:	e1d331b8 	ldrh	r3, [r3, #24]
300268c8:	e1a03423 	lsr	r3, r3, #8
300268cc:	e1a03803 	lsl	r3, r3, #16
300268d0:	e1a03823 	lsr	r3, r3, #16
300268d4:	e20320ff 	and	r2, r3, #255	; 0xff
300268d8:	e59d3010 	ldr	r3, [sp, #16]
300268dc:	e5c32000 	strb	r2, [r3]
300268e0:	e59d3010 	ldr	r3, [sp, #16]
300268e4:	e2833001 	add	r3, r3, #1
300268e8:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = FDTData->FstClusLO;
300268ec:	e59d3000 	ldr	r3, [sp]
300268f0:	e1d331ba 	ldrh	r3, [r3, #26]
300268f4:	e20320ff 	and	r2, r3, #255	; 0xff
300268f8:	e59d3010 	ldr	r3, [sp, #16]
300268fc:	e5c32000 	strb	r2, [r3]
30026900:	e59d3010 	ldr	r3, [sp, #16]
30026904:	e2833001 	add	r3, r3, #1
30026908:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = (FDTData->FstClusLO) >> 8;
3002690c:	e59d3000 	ldr	r3, [sp]
30026910:	e1d331ba 	ldrh	r3, [r3, #26]
30026914:	e1a03423 	lsr	r3, r3, #8
30026918:	e1a03803 	lsl	r3, r3, #16
3002691c:	e1a03823 	lsr	r3, r3, #16
30026920:	e20320ff 	and	r2, r3, #255	; 0xff
30026924:	e59d3010 	ldr	r3, [sp, #16]
30026928:	e5c32000 	strb	r2, [r3]
3002692c:	e59d3010 	ldr	r3, [sp, #16]
30026930:	e2833001 	add	r3, r3, #1
30026934:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = (FDTData->FileSize);
30026938:	e59d3000 	ldr	r3, [sp]
3002693c:	e593301c 	ldr	r3, [r3, #28]
30026940:	e20320ff 	and	r2, r3, #255	; 0xff
30026944:	e59d3010 	ldr	r3, [sp, #16]
30026948:	e5c32000 	strb	r2, [r3]
3002694c:	e59d3010 	ldr	r3, [sp, #16]
30026950:	e2833001 	add	r3, r3, #1
30026954:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = (FDTData->FileSize) >> 8;
30026958:	e59d3000 	ldr	r3, [sp]
3002695c:	e593301c 	ldr	r3, [r3, #28]
30026960:	e1a03423 	lsr	r3, r3, #8
30026964:	e20320ff 	and	r2, r3, #255	; 0xff
30026968:	e59d3010 	ldr	r3, [sp, #16]
3002696c:	e5c32000 	strb	r2, [r3]
30026970:	e59d3010 	ldr	r3, [sp, #16]
30026974:	e2833001 	add	r3, r3, #1
30026978:	e58d3010 	str	r3, [sp, #16]
            *Buf++ = (FDTData->FileSize) >> 16;
3002697c:	e59d3000 	ldr	r3, [sp]
30026980:	e593301c 	ldr	r3, [r3, #28]
30026984:	e1a03823 	lsr	r3, r3, #16
30026988:	e20320ff 	and	r2, r3, #255	; 0xff
3002698c:	e59d3010 	ldr	r3, [sp, #16]
30026990:	e5c32000 	strb	r2, [r3]
30026994:	e59d3010 	ldr	r3, [sp, #16]
30026998:	e2833001 	add	r3, r3, #1
3002699c:	e58d3010 	str	r3, [sp, #16]
            *Buf = (FDTData->FileSize) >> 24;
300269a0:	e59d3000 	ldr	r3, [sp]
300269a4:	e593301c 	ldr	r3, [r3, #28]
300269a8:	e1a03c23 	lsr	r3, r3, #24
300269ac:	e20320ff 	and	r2, r3, #255	; 0xff
300269b0:	e59d3010 	ldr	r3, [sp, #16]
300269b4:	e5c32000 	strb	r2, [r3]
            WriteSec(Drive, SecIndex);
300269b8:	e5dd300f 	ldrb	r3, [sp, #15]
300269bc:	e1a00003 	mov	r0, r3
300269c0:	e59d1008 	ldr	r1, [sp, #8]
300269c4:	eb00161e 	bl	3002c244 <WriteSec>
        }
        CloseSec(Drive, SecIndex);
300269c8:	e5dd300f 	ldrb	r3, [sp, #15]
300269cc:	e1a00003 	mov	r0, r3
300269d0:	e59d1008 	ldr	r1, [sp, #8]
300269d4:	eb00140b 	bl	3002ba08 <CloseSec>
    }
    return temp;
300269d8:	e5dd3017 	ldrb	r3, [sp, #23]
}
300269dc:	e1a00003 	mov	r0, r3
300269e0:	e28dd01c 	add	sp, sp, #28
300269e4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300269e8:	e12fff1e 	bx	lr

300269ec <GetRootFDTInfo>:
**        οfat.hйڷֵ˵
** ȫֱ: 
** ģ: GetDiskInfo,GetFDTInfo,ReadFDTInfo
********************************************************************************************************/
        acoral_u8 GetRootFDTInfo(FDT *Rt, acoral_u8 Drive, acoral_u32 Index)
{
300269ec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300269f0:	e24dd024 	sub	sp, sp, #36	; 0x24
300269f4:	e58d000c 	str	r0, [sp, #12]
300269f8:	e1a03001 	mov	r3, r1
300269fc:	e58d2004 	str	r2, [sp, #4]
30026a00:	e5cd300b 	strb	r3, [sp, #11]
    Disk_Info * Disk;
    acoral_u16 ByteIndex;
    acoral_u32 SecIndex;
    acoral_u8 temp;
    
    temp = NOT_FIND_DISK;
30026a04:	e3a03001 	mov	r3, #1
30026a08:	e5cd301f 	strb	r3, [sp, #31]
    Disk = GetDiskInfo(Drive);
30026a0c:	e5dd300b 	ldrb	r3, [sp, #11]
30026a10:	e1a00003 	mov	r0, r3
30026a14:	ebfff681 	bl	30024420 <GetDiskInfo>
30026a18:	e1a03000 	mov	r3, r0
30026a1c:	e58d3010 	str	r3, [sp, #16]
    if (Disk != NULL)
30026a20:	e59d3010 	ldr	r3, [sp, #16]
30026a24:	e3530000 	cmp	r3, #0
30026a28:	0a000031 	beq	30026af4 <GetRootFDTInfo+0x108>
    {
        temp = NOT_FAT_DISK;
30026a2c:	e3a03008 	mov	r3, #8
30026a30:	e5cd301f 	strb	r3, [sp, #31]
        Index = Index * 32;        /* 32:sizeof(FDT ) */
30026a34:	e59d3004 	ldr	r3, [sp, #4]
30026a38:	e1a03283 	lsl	r3, r3, #5
30026a3c:	e58d3004 	str	r3, [sp, #4]
        if (Disk->FATType == FAT12 || Disk->FATType == FAT16)
30026a40:	e59d3010 	ldr	r3, [sp, #16]
30026a44:	e5d33001 	ldrb	r3, [r3, #1]
30026a48:	e3530000 	cmp	r3, #0
30026a4c:	0a000003 	beq	30026a60 <GetRootFDTInfo+0x74>
30026a50:	e59d3010 	ldr	r3, [sp, #16]
30026a54:	e5d33001 	ldrb	r3, [r3, #1]
30026a58:	e3530001 	cmp	r3, #1
30026a5c:	1a000024 	bne	30026af4 <GetRootFDTInfo+0x108>
        {
            temp = FDT_OVER;
30026a60:	e3a03009 	mov	r3, #9
30026a64:	e5cd301f 	strb	r3, [sp, #31]
            if (Index < (Disk->RootSecCnt * Disk->BytsPerSec))
30026a68:	e59d3010 	ldr	r3, [sp, #16]
30026a6c:	e5933014 	ldr	r3, [r3, #20]
30026a70:	e59d2010 	ldr	r2, [sp, #16]
30026a74:	e592200c 	ldr	r2, [r2, #12]
30026a78:	e0020293 	mul	r2, r3, r2
30026a7c:	e59d3004 	ldr	r3, [sp, #4]
30026a80:	e1520003 	cmp	r2, r3
30026a84:	9a00001a 	bls	30026af4 <GetRootFDTInfo+0x108>
            {
                ByteIndex = Index % Disk->BytsPerSec;
30026a88:	e59d3010 	ldr	r3, [sp, #16]
30026a8c:	e593300c 	ldr	r3, [r3, #12]
30026a90:	e59d2004 	ldr	r2, [sp, #4]
30026a94:	e1a00002 	mov	r0, r2
30026a98:	e1a01003 	mov	r1, r3
30026a9c:	eb0074bc 	bl	30043d94 <__aeabi_uidivmod>
30026aa0:	e1a03001 	mov	r3, r1
30026aa4:	e1cd31b6 	strh	r3, [sp, #22]
                SecIndex = Index / Disk->BytsPerSec + Disk->RootDirTable;
30026aa8:	e59d3010 	ldr	r3, [sp, #16]
30026aac:	e593300c 	ldr	r3, [r3, #12]
30026ab0:	e59d0004 	ldr	r0, [sp, #4]
30026ab4:	e1a01003 	mov	r1, r3
30026ab8:	eb007478 	bl	30043ca0 <__aeabi_uidiv>
30026abc:	e1a03000 	mov	r3, r0
30026ac0:	e1a02003 	mov	r2, r3
30026ac4:	e59d3010 	ldr	r3, [sp, #16]
30026ac8:	e5933010 	ldr	r3, [r3, #16]
30026acc:	e0823003 	add	r3, r2, r3
30026ad0:	e58d3018 	str	r3, [sp, #24]
                temp = ReadFDTInfo(Rt, Drive, SecIndex, ByteIndex);
30026ad4:	e5dd200b 	ldrb	r2, [sp, #11]
30026ad8:	e1dd31b6 	ldrh	r3, [sp, #22]
30026adc:	e59d000c 	ldr	r0, [sp, #12]
30026ae0:	e1a01002 	mov	r1, r2
30026ae4:	e59d2018 	ldr	r2, [sp, #24]
30026ae8:	ebfffd70 	bl	300260b0 <ReadFDTInfo>
30026aec:	e1a03000 	mov	r3, r0
30026af0:	e5cd301f 	strb	r3, [sp, #31]
            }
        }
    }
    return temp;
30026af4:	e5dd301f 	ldrb	r3, [sp, #31]
}
30026af8:	e1a00003 	mov	r0, r3
30026afc:	e28dd024 	add	sp, sp, #36	; 0x24
30026b00:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30026b04:	e12fff1e 	bx	lr

30026b08 <GetFDTInfo>:
**        οfat.hйڷֵ˵
** ȫֱ: 
** ģ: GetDiskInfo,ReadFDTInfo
********************************************************************************************************/
        acoral_u8 GetFDTInfo(FDT *Rt,acoral_u8 Drive, acoral_u32 ClusIndex, acoral_u32 Index)
{
30026b08:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30026b0c:	e24dd024 	sub	sp, sp, #36	; 0x24
30026b10:	e58d000c 	str	r0, [sp, #12]
30026b14:	e58d2004 	str	r2, [sp, #4]
30026b18:	e58d3000 	str	r3, [sp]
30026b1c:	e1a03001 	mov	r3, r1
30026b20:	e5cd300b 	strb	r3, [sp, #11]
    Disk_Info * Disk;
    acoral_u16 ByteIndex;
    acoral_u32 SecIndex, i;

    Disk = GetDiskInfo(Drive);
30026b24:	e5dd300b 	ldrb	r3, [sp, #11]
30026b28:	e1a00003 	mov	r0, r3
30026b2c:	ebfff63b 	bl	30024420 <GetDiskInfo>
30026b30:	e1a03000 	mov	r3, r0
30026b34:	e58d3010 	str	r3, [sp, #16]
    if (Disk == NULL)
30026b38:	e59d3010 	ldr	r3, [sp, #16]
30026b3c:	e3530000 	cmp	r3, #0
30026b40:	1a000001 	bne	30026b4c <GetFDTInfo+0x44>
    {
        return NOT_FIND_DISK;
30026b44:	e3a03001 	mov	r3, #1
30026b48:	ea00005c 	b	30026cc0 <GetFDTInfo+0x1b8>
    }

    if (ClusIndex == EMPTY_CLUS)
30026b4c:	e59d3004 	ldr	r3, [sp, #4]
30026b50:	e3530000 	cmp	r3, #0
30026b54:	1a00000e 	bne	30026b94 <GetFDTInfo+0x8c>
    {
        if (Disk->FATType == FAT32)
30026b58:	e59d3010 	ldr	r3, [sp, #16]
30026b5c:	e5d33001 	ldrb	r3, [r3, #1]
30026b60:	e3530002 	cmp	r3, #2
30026b64:	1a000003 	bne	30026b78 <GetFDTInfo+0x70>
        {
            ClusIndex = Disk->RootDirTable;
30026b68:	e59d3010 	ldr	r3, [sp, #16]
30026b6c:	e5933010 	ldr	r3, [r3, #16]
30026b70:	e58d3004 	str	r3, [sp, #4]
30026b74:	ea000006 	b	30026b94 <GetFDTInfo+0x8c>
        }
        else
        {
            return GetRootFDTInfo(Rt, Drive, Index);
30026b78:	e5dd300b 	ldrb	r3, [sp, #11]
30026b7c:	e59d000c 	ldr	r0, [sp, #12]
30026b80:	e1a01003 	mov	r1, r3
30026b84:	e59d2000 	ldr	r2, [sp]
30026b88:	ebffff97 	bl	300269ec <GetRootFDTInfo>
30026b8c:	e1a03000 	mov	r3, r0
30026b90:	ea00004a 	b	30026cc0 <GetFDTInfo+0x1b8>
        }
    }

    if (Disk->FATType == FAT12 ||
30026b94:	e59d3010 	ldr	r3, [sp, #16]
30026b98:	e5d33001 	ldrb	r3, [r3, #1]
30026b9c:	e3530000 	cmp	r3, #0
30026ba0:	0a000007 	beq	30026bc4 <GetFDTInfo+0xbc>
        Disk->FATType == FAT16 ||
30026ba4:	e59d3010 	ldr	r3, [sp, #16]
30026ba8:	e5d33001 	ldrb	r3, [r3, #1]
        {
            return GetRootFDTInfo(Rt, Drive, Index);
        }
    }

    if (Disk->FATType == FAT12 ||
30026bac:	e3530001 	cmp	r3, #1
30026bb0:	0a000003 	beq	30026bc4 <GetFDTInfo+0xbc>
        Disk->FATType == FAT16 ||
        Disk->FATType == FAT32)
30026bb4:	e59d3010 	ldr	r3, [sp, #16]
30026bb8:	e5d33001 	ldrb	r3, [r3, #1]
        {
            return GetRootFDTInfo(Rt, Drive, Index);
        }
    }

    if (Disk->FATType == FAT12 ||
30026bbc:	e3530002 	cmp	r3, #2
30026bc0:	1a00003d 	bne	30026cbc <GetFDTInfo+0x1b4>
        Disk->FATType == FAT16 ||
        Disk->FATType == FAT32)
    {
        Index = Index * 32;
30026bc4:	e59d3000 	ldr	r3, [sp]
30026bc8:	e1a03283 	lsl	r3, r3, #5
30026bcc:	e58d3000 	str	r3, [sp]
        ByteIndex = Index % Disk->BytsPerSec;
30026bd0:	e59d3010 	ldr	r3, [sp, #16]
30026bd4:	e593300c 	ldr	r3, [r3, #12]
30026bd8:	e59d2000 	ldr	r2, [sp]
30026bdc:	e1a00002 	mov	r0, r2
30026be0:	e1a01003 	mov	r1, r3
30026be4:	eb00746a 	bl	30043d94 <__aeabi_uidivmod>
30026be8:	e1a03001 	mov	r3, r1
30026bec:	e1cd31b6 	strh	r3, [sp, #22]
        SecIndex = Index / Disk->BytsPerSec;
30026bf0:	e59d3010 	ldr	r3, [sp, #16]
30026bf4:	e593300c 	ldr	r3, [r3, #12]
30026bf8:	e59d0000 	ldr	r0, [sp]
30026bfc:	e1a01003 	mov	r1, r3
30026c00:	eb007426 	bl	30043ca0 <__aeabi_uidiv>
30026c04:	e1a03000 	mov	r3, r0
30026c08:	e58d3018 	str	r3, [sp, #24]
        /* Ŀ¼ */
        i = Disk->SecPerClus;
30026c0c:	e59d3010 	ldr	r3, [sp, #16]
30026c10:	e5d33002 	ldrb	r3, [r3, #2]
30026c14:	e58d301c 	str	r3, [sp, #28]
        while(SecIndex >= i)
30026c18:	ea000011 	b	30026c64 <GetFDTInfo+0x15c>
        {
            ClusIndex = FATGetNextClus(Drive, ClusIndex);
30026c1c:	e5dd300b 	ldrb	r3, [sp, #11]
30026c20:	e1a00003 	mov	r0, r3
30026c24:	e59d1004 	ldr	r1, [sp, #4]
30026c28:	ebfff972 	bl	300251f8 <FATGetNextClus>
30026c2c:	e1a03000 	mov	r3, r0
30026c30:	e58d3004 	str	r3, [sp, #4]
            if (ClusIndex <= EMPTY_CLUS_1 ||
30026c34:	e59d3004 	ldr	r3, [sp, #4]
30026c38:	e3530001 	cmp	r3, #1
30026c3c:	9a000002 	bls	30026c4c <GetFDTInfo+0x144>
30026c40:	e59d3004 	ldr	r3, [sp, #4]
30026c44:	e37302af 	cmn	r3, #-268435446	; 0xf000000a
30026c48:	9a000001 	bls	30026c54 <GetFDTInfo+0x14c>
                ClusIndex >= BAD_CLUS) 
            {
                return FDT_OVER;
30026c4c:	e3a03009 	mov	r3, #9
30026c50:	ea00001a 	b	30026cc0 <GetFDTInfo+0x1b8>
            }
            SecIndex -= i;
30026c54:	e59d2018 	ldr	r2, [sp, #24]
30026c58:	e59d301c 	ldr	r3, [sp, #28]
30026c5c:	e0633002 	rsb	r3, r3, r2
30026c60:	e58d3018 	str	r3, [sp, #24]
        Index = Index * 32;
        ByteIndex = Index % Disk->BytsPerSec;
        SecIndex = Index / Disk->BytsPerSec;
        /* Ŀ¼ */
        i = Disk->SecPerClus;
        while(SecIndex >= i)
30026c64:	e59d2018 	ldr	r2, [sp, #24]
30026c68:	e59d301c 	ldr	r3, [sp, #28]
30026c6c:	e1520003 	cmp	r2, r3
30026c70:	2affffe9 	bcs	30026c1c <GetFDTInfo+0x114>
            {
                return FDT_OVER;
            }
            SecIndex -= i;
        }
        SecIndex = (ClusIndex - 2) * i + SecIndex + Disk->DataStartSec;
30026c74:	e59d3004 	ldr	r3, [sp, #4]
30026c78:	e2433002 	sub	r3, r3, #2
30026c7c:	e59d201c 	ldr	r2, [sp, #28]
30026c80:	e0020293 	mul	r2, r3, r2
30026c84:	e59d3018 	ldr	r3, [sp, #24]
30026c88:	e0822003 	add	r2, r2, r3
30026c8c:	e59d3010 	ldr	r3, [sp, #16]
30026c90:	e5933020 	ldr	r3, [r3, #32]
30026c94:	e0823003 	add	r3, r2, r3
30026c98:	e58d3018 	str	r3, [sp, #24]
        return ReadFDTInfo(Rt, Drive, SecIndex, ByteIndex);
30026c9c:	e5dd200b 	ldrb	r2, [sp, #11]
30026ca0:	e1dd31b6 	ldrh	r3, [sp, #22]
30026ca4:	e59d000c 	ldr	r0, [sp, #12]
30026ca8:	e1a01002 	mov	r1, r2
30026cac:	e59d2018 	ldr	r2, [sp, #24]
30026cb0:	ebfffcfe 	bl	300260b0 <ReadFDTInfo>
30026cb4:	e1a03000 	mov	r3, r0
30026cb8:	ea000000 	b	30026cc0 <GetFDTInfo+0x1b8>
    }
    return NOT_FAT_DISK;
30026cbc:	e3a03008 	mov	r3, #8
}
30026cc0:	e1a00003 	mov	r0, r3
30026cc4:	e28dd024 	add	sp, sp, #36	; 0x24
30026cc8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30026ccc:	e12fff1e 	bx	lr

30026cd0 <SetRootFDTInfo>:
**        οfat.hйڷֵ˵
** ȫֱ: 
** ģ: GetDiskInfo,SetFDTInfo,WriteFDTInfo
********************************************************************************************************/
        acoral_u8 SetRootFDTInfo(acoral_u8 Drive, acoral_u32 Index, FDT *FDTData)
{
30026cd0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30026cd4:	e24dd024 	sub	sp, sp, #36	; 0x24
30026cd8:	e1a03000 	mov	r3, r0
30026cdc:	e58d1008 	str	r1, [sp, #8]
30026ce0:	e58d2004 	str	r2, [sp, #4]
30026ce4:	e5cd300f 	strb	r3, [sp, #15]
    Disk_Info * Disk;
    acoral_u16 ByteIndex;
    acoral_u32 SecIndex;
    acoral_u8 Rt;
    
    Rt = NOT_FIND_DISK;
30026ce8:	e3a03001 	mov	r3, #1
30026cec:	e5cd301f 	strb	r3, [sp, #31]
    Disk = GetDiskInfo(Drive);
30026cf0:	e5dd300f 	ldrb	r3, [sp, #15]
30026cf4:	e1a00003 	mov	r0, r3
30026cf8:	ebfff5c8 	bl	30024420 <GetDiskInfo>
30026cfc:	e1a03000 	mov	r3, r0
30026d00:	e58d3010 	str	r3, [sp, #16]
    if (Disk != NULL)
30026d04:	e59d3010 	ldr	r3, [sp, #16]
30026d08:	e3530000 	cmp	r3, #0
30026d0c:	0a000030 	beq	30026dd4 <SetRootFDTInfo+0x104>
    {
        Index = Index * 32;        /* 32:sizeof(FDT ) */
30026d10:	e59d3008 	ldr	r3, [sp, #8]
30026d14:	e1a03283 	lsl	r3, r3, #5
30026d18:	e58d3008 	str	r3, [sp, #8]
        if (Disk->FATType == FAT12 || Disk->FATType == FAT16)
30026d1c:	e59d3010 	ldr	r3, [sp, #16]
30026d20:	e5d33001 	ldrb	r3, [r3, #1]
30026d24:	e3530000 	cmp	r3, #0
30026d28:	0a000003 	beq	30026d3c <SetRootFDTInfo+0x6c>
30026d2c:	e59d3010 	ldr	r3, [sp, #16]
30026d30:	e5d33001 	ldrb	r3, [r3, #1]
30026d34:	e3530001 	cmp	r3, #1
30026d38:	1a000025 	bne	30026dd4 <SetRootFDTInfo+0x104>
        {
            Rt = FDT_OVER;
30026d3c:	e3a03009 	mov	r3, #9
30026d40:	e5cd301f 	strb	r3, [sp, #31]
            if (Index < (Disk->RootSecCnt * Disk->BytsPerSec))
30026d44:	e59d3010 	ldr	r3, [sp, #16]
30026d48:	e5933014 	ldr	r3, [r3, #20]
30026d4c:	e59d2010 	ldr	r2, [sp, #16]
30026d50:	e592200c 	ldr	r2, [r2, #12]
30026d54:	e0020293 	mul	r2, r3, r2
30026d58:	e59d3008 	ldr	r3, [sp, #8]
30026d5c:	e1520003 	cmp	r2, r3
30026d60:	9a00001b 	bls	30026dd4 <SetRootFDTInfo+0x104>
            {
                ByteIndex = Index % Disk->BytsPerSec;
30026d64:	e59d3010 	ldr	r3, [sp, #16]
30026d68:	e593300c 	ldr	r3, [r3, #12]
30026d6c:	e59d2008 	ldr	r2, [sp, #8]
30026d70:	e1a00002 	mov	r0, r2
30026d74:	e1a01003 	mov	r1, r3
30026d78:	eb007405 	bl	30043d94 <__aeabi_uidivmod>
30026d7c:	e1a03001 	mov	r3, r1
30026d80:	e1cd31b6 	strh	r3, [sp, #22]
                SecIndex = Index / Disk->BytsPerSec + Disk->RootDirTable;
30026d84:	e59d3010 	ldr	r3, [sp, #16]
30026d88:	e593300c 	ldr	r3, [r3, #12]
30026d8c:	e59d0008 	ldr	r0, [sp, #8]
30026d90:	e1a01003 	mov	r1, r3
30026d94:	eb0073c1 	bl	30043ca0 <__aeabi_uidiv>
30026d98:	e1a03000 	mov	r3, r0
30026d9c:	e1a02003 	mov	r2, r3
30026da0:	e59d3010 	ldr	r3, [sp, #16]
30026da4:	e5933010 	ldr	r3, [r3, #16]
30026da8:	e0823003 	add	r3, r2, r3
30026dac:	e58d3018 	str	r3, [sp, #24]
                Rt = WriteFDTInfo(Drive, SecIndex, ByteIndex, FDTData);
30026db0:	e5dd200f 	ldrb	r2, [sp, #15]
30026db4:	e1dd31b6 	ldrh	r3, [sp, #22]
30026db8:	e1a00002 	mov	r0, r2
30026dbc:	e59d1018 	ldr	r1, [sp, #24]
30026dc0:	e1a02003 	mov	r2, r3
30026dc4:	e59d3004 	ldr	r3, [sp, #4]
30026dc8:	ebfffdd4 	bl	30026520 <WriteFDTInfo>
30026dcc:	e1a03000 	mov	r3, r0
30026dd0:	e5cd301f 	strb	r3, [sp, #31]
            }
        }
    }
    return Rt;
30026dd4:	e5dd301f 	ldrb	r3, [sp, #31]
}
30026dd8:	e1a00003 	mov	r0, r3
30026ddc:	e28dd024 	add	sp, sp, #36	; 0x24
30026de0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30026de4:	e12fff1e 	bx	lr

30026de8 <SetFDTInfo>:
**        οfat.hйڷֵ˵
** ȫֱ: 
** ģ: GetDiskInfo,WriteFDTInfo
********************************************************************************************************/
        acoral_u8 SetFDTInfo(acoral_u8 Drive, acoral_u32 ClusIndex, acoral_u32 Index, FDT *FDTData)
{
30026de8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30026dec:	e24dd024 	sub	sp, sp, #36	; 0x24
30026df0:	e58d1008 	str	r1, [sp, #8]
30026df4:	e58d2004 	str	r2, [sp, #4]
30026df8:	e58d3000 	str	r3, [sp]
30026dfc:	e1a03000 	mov	r3, r0
30026e00:	e5cd300f 	strb	r3, [sp, #15]
    Disk_Info * Disk;
    acoral_u16 ByteIndex;
    acoral_u32 SecIndex;
    acoral_u8 i;
    
    Disk = GetDiskInfo(Drive);
30026e04:	e5dd300f 	ldrb	r3, [sp, #15]
30026e08:	e1a00003 	mov	r0, r3
30026e0c:	ebfff583 	bl	30024420 <GetDiskInfo>
30026e10:	e1a03000 	mov	r3, r0
30026e14:	e58d3010 	str	r3, [sp, #16]
    if (Disk == NULL)
30026e18:	e59d3010 	ldr	r3, [sp, #16]
30026e1c:	e3530000 	cmp	r3, #0
30026e20:	1a000001 	bne	30026e2c <SetFDTInfo+0x44>
    {
        return NOT_FIND_DISK;
30026e24:	e3a03001 	mov	r3, #1
30026e28:	ea00005d 	b	30026fa4 <SetFDTInfo+0x1bc>
    }

    if (ClusIndex == EMPTY_CLUS)
30026e2c:	e59d3008 	ldr	r3, [sp, #8]
30026e30:	e3530000 	cmp	r3, #0
30026e34:	1a00000e 	bne	30026e74 <SetFDTInfo+0x8c>
    {
        if (Disk->FATType == FAT32)
30026e38:	e59d3010 	ldr	r3, [sp, #16]
30026e3c:	e5d33001 	ldrb	r3, [r3, #1]
30026e40:	e3530002 	cmp	r3, #2
30026e44:	1a000003 	bne	30026e58 <SetFDTInfo+0x70>
        {
            ClusIndex = Disk->RootDirTable;
30026e48:	e59d3010 	ldr	r3, [sp, #16]
30026e4c:	e5933010 	ldr	r3, [r3, #16]
30026e50:	e58d3008 	str	r3, [sp, #8]
30026e54:	ea000006 	b	30026e74 <SetFDTInfo+0x8c>
        }
        else
        {
            return SetRootFDTInfo(Drive, Index, FDTData);
30026e58:	e5dd300f 	ldrb	r3, [sp, #15]
30026e5c:	e1a00003 	mov	r0, r3
30026e60:	e59d1004 	ldr	r1, [sp, #4]
30026e64:	e59d2000 	ldr	r2, [sp]
30026e68:	ebffff98 	bl	30026cd0 <SetRootFDTInfo>
30026e6c:	e1a03000 	mov	r3, r0
30026e70:	ea00004b 	b	30026fa4 <SetFDTInfo+0x1bc>
        }
    }

    if (Disk->FATType == FAT12 ||
30026e74:	e59d3010 	ldr	r3, [sp, #16]
30026e78:	e5d33001 	ldrb	r3, [r3, #1]
30026e7c:	e3530000 	cmp	r3, #0
30026e80:	0a000007 	beq	30026ea4 <SetFDTInfo+0xbc>
        Disk->FATType == FAT16 ||
30026e84:	e59d3010 	ldr	r3, [sp, #16]
30026e88:	e5d33001 	ldrb	r3, [r3, #1]
        {
            return SetRootFDTInfo(Drive, Index, FDTData);
        }
    }

    if (Disk->FATType == FAT12 ||
30026e8c:	e3530001 	cmp	r3, #1
30026e90:	0a000003 	beq	30026ea4 <SetFDTInfo+0xbc>
        Disk->FATType == FAT16 ||
        Disk->FATType == FAT32)
30026e94:	e59d3010 	ldr	r3, [sp, #16]
30026e98:	e5d33001 	ldrb	r3, [r3, #1]
        {
            return SetRootFDTInfo(Drive, Index, FDTData);
        }
    }

    if (Disk->FATType == FAT12 ||
30026e9c:	e3530002 	cmp	r3, #2
30026ea0:	1a00003e 	bne	30026fa0 <SetFDTInfo+0x1b8>
        Disk->FATType == FAT16 ||
        Disk->FATType == FAT32)
    {
        Index = Index * 32;
30026ea4:	e59d3004 	ldr	r3, [sp, #4]
30026ea8:	e1a03283 	lsl	r3, r3, #5
30026eac:	e58d3004 	str	r3, [sp, #4]
        ByteIndex = Index % Disk->BytsPerSec;
30026eb0:	e59d3010 	ldr	r3, [sp, #16]
30026eb4:	e593300c 	ldr	r3, [r3, #12]
30026eb8:	e59d2004 	ldr	r2, [sp, #4]
30026ebc:	e1a00002 	mov	r0, r2
30026ec0:	e1a01003 	mov	r1, r3
30026ec4:	eb0073b2 	bl	30043d94 <__aeabi_uidivmod>
30026ec8:	e1a03001 	mov	r3, r1
30026ecc:	e1cd31b6 	strh	r3, [sp, #22]
        SecIndex = Index / Disk->BytsPerSec;
30026ed0:	e59d3010 	ldr	r3, [sp, #16]
30026ed4:	e593300c 	ldr	r3, [r3, #12]
30026ed8:	e59d0004 	ldr	r0, [sp, #4]
30026edc:	e1a01003 	mov	r1, r3
30026ee0:	eb00736e 	bl	30043ca0 <__aeabi_uidiv>
30026ee4:	e1a03000 	mov	r3, r0
30026ee8:	e58d3018 	str	r3, [sp, #24]
        /* Ŀ¼ */
        i = Disk->SecPerClus;
30026eec:	e59d3010 	ldr	r3, [sp, #16]
30026ef0:	e5d33002 	ldrb	r3, [r3, #2]
30026ef4:	e5cd301f 	strb	r3, [sp, #31]
        while(SecIndex >= i)
30026ef8:	ea000011 	b	30026f44 <SetFDTInfo+0x15c>
        {
            ClusIndex = FATGetNextClus(Drive, ClusIndex);
30026efc:	e5dd300f 	ldrb	r3, [sp, #15]
30026f00:	e1a00003 	mov	r0, r3
30026f04:	e59d1008 	ldr	r1, [sp, #8]
30026f08:	ebfff8ba 	bl	300251f8 <FATGetNextClus>
30026f0c:	e1a03000 	mov	r3, r0
30026f10:	e58d3008 	str	r3, [sp, #8]
            if (ClusIndex <= EMPTY_CLUS_1 ||
30026f14:	e59d3008 	ldr	r3, [sp, #8]
30026f18:	e3530001 	cmp	r3, #1
30026f1c:	9a000002 	bls	30026f2c <SetFDTInfo+0x144>
30026f20:	e59d3008 	ldr	r3, [sp, #8]
30026f24:	e37302af 	cmn	r3, #-268435446	; 0xf000000a
30026f28:	9a000001 	bls	30026f34 <SetFDTInfo+0x14c>
                ClusIndex >= BAD_CLUS) 
            {
                return FDT_OVER;
30026f2c:	e3a03009 	mov	r3, #9
30026f30:	ea00001b 	b	30026fa4 <SetFDTInfo+0x1bc>
            }
            SecIndex -= i;
30026f34:	e5dd301f 	ldrb	r3, [sp, #31]
30026f38:	e59d2018 	ldr	r2, [sp, #24]
30026f3c:	e0633002 	rsb	r3, r3, r2
30026f40:	e58d3018 	str	r3, [sp, #24]
        Index = Index * 32;
        ByteIndex = Index % Disk->BytsPerSec;
        SecIndex = Index / Disk->BytsPerSec;
        /* Ŀ¼ */
        i = Disk->SecPerClus;
        while(SecIndex >= i)
30026f44:	e5dd201f 	ldrb	r2, [sp, #31]
30026f48:	e59d3018 	ldr	r3, [sp, #24]
30026f4c:	e1520003 	cmp	r2, r3
30026f50:	9affffe9 	bls	30026efc <SetFDTInfo+0x114>
            {
                return FDT_OVER;
            }
            SecIndex -= i;
        }
        SecIndex = (ClusIndex - 2) * i + SecIndex + Disk->DataStartSec;
30026f54:	e59d3008 	ldr	r3, [sp, #8]
30026f58:	e2433002 	sub	r3, r3, #2
30026f5c:	e5dd201f 	ldrb	r2, [sp, #31]
30026f60:	e0020293 	mul	r2, r3, r2
30026f64:	e59d3018 	ldr	r3, [sp, #24]
30026f68:	e0822003 	add	r2, r2, r3
30026f6c:	e59d3010 	ldr	r3, [sp, #16]
30026f70:	e5933020 	ldr	r3, [r3, #32]
30026f74:	e0823003 	add	r3, r2, r3
30026f78:	e58d3018 	str	r3, [sp, #24]

        return WriteFDTInfo(Drive, SecIndex, ByteIndex, FDTData);
30026f7c:	e5dd200f 	ldrb	r2, [sp, #15]
30026f80:	e1dd31b6 	ldrh	r3, [sp, #22]
30026f84:	e1a00002 	mov	r0, r2
30026f88:	e59d1018 	ldr	r1, [sp, #24]
30026f8c:	e1a02003 	mov	r2, r3
30026f90:	e59d3000 	ldr	r3, [sp]
30026f94:	ebfffd61 	bl	30026520 <WriteFDTInfo>
30026f98:	e1a03000 	mov	r3, r0
30026f9c:	ea000000 	b	30026fa4 <SetFDTInfo+0x1bc>
    }
    return NOT_FAT_DISK;
30026fa0:	e3a03008 	mov	r3, #8
}
30026fa4:	e1a00003 	mov	r0, r3
30026fa8:	e28dd024 	add	sp, sp, #36	; 0x24
30026fac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30026fb0:	e12fff1e 	bx	lr

30026fb4 <FindFDTInfo>:
**        οfat.hйڷֵ˵
** ȫֱ: 
** ģ: GetDiskInfo,GetFDTInfo
********************************************************************************************************/
        acoral_u8 FindFDTInfo(FDT *Rt,acoral_u8 Drive, acoral_u32 ClusIndex, acoral_char FileName[])
{
30026fb4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30026fb8:	e24dd01c 	sub	sp, sp, #28
30026fbc:	e58d000c 	str	r0, [sp, #12]
30026fc0:	e58d2004 	str	r2, [sp, #4]
30026fc4:	e58d3000 	str	r3, [sp]
30026fc8:	e1a03001 	mov	r3, r1
30026fcc:	e5cd300b 	strb	r3, [sp, #11]
    acoral_u32 i;
    acoral_u8 temp;
    

    i = 0;
30026fd0:	e3a03000 	mov	r3, #0
30026fd4:	e58d3010 	str	r3, [sp, #16]
    if (FileName[0] == DEL_FDT)
30026fd8:	e59d3000 	ldr	r3, [sp]
30026fdc:	e5d33000 	ldrb	r3, [r3]
30026fe0:	e35300e5 	cmp	r3, #229	; 0xe5
30026fe4:	1a000002 	bne	30026ff4 <FindFDTInfo+0x40>
    {
        FileName[0] = ESC_FDT;
30026fe8:	e59d3000 	ldr	r3, [sp]
30026fec:	e3a02005 	mov	r2, #5
30026ff0:	e5c32000 	strb	r2, [r3]
    }
    while (1)
    {
        temp = GetFDTInfo(Rt, Drive, ClusIndex, i);
30026ff4:	e5dd300b 	ldrb	r3, [sp, #11]
30026ff8:	e59d000c 	ldr	r0, [sp, #12]
30026ffc:	e1a01003 	mov	r1, r3
30027000:	e59d2004 	ldr	r2, [sp, #4]
30027004:	e59d3010 	ldr	r3, [sp, #16]
30027008:	ebfffebe 	bl	30026b08 <GetFDTInfo>
3002700c:	e1a03000 	mov	r3, r0
30027010:	e5cd3017 	strb	r3, [sp, #23]
        if (temp != RETURN_OK)
30027014:	e5dd3017 	ldrb	r3, [sp, #23]
30027018:	e3530000 	cmp	r3, #0
3002701c:	1a00005e 	bne	3002719c <FindFDTInfo+0x1e8>
        {
            break;
        }

        if (Rt->Name[0] == EMPTY_FDT)
30027020:	e59d300c 	ldr	r3, [sp, #12]
30027024:	e5d33000 	ldrb	r3, [r3]
30027028:	e3530000 	cmp	r3, #0
3002702c:	1a000002 	bne	3002703c <FindFDTInfo+0x88>
        {
            temp = NOT_FIND_FDT;
30027030:	e3a03007 	mov	r3, #7
30027034:	e5cd3017 	strb	r3, [sp, #23]
            break;
30027038:	ea000058 	b	300271a0 <FindFDTInfo+0x1ec>
        }
        if ((Rt->Attr & ATTR_VOLUME_ID) == 0)
3002703c:	e59d300c 	ldr	r3, [sp, #12]
30027040:	e5d3300b 	ldrb	r3, [r3, #11]
30027044:	e2033008 	and	r3, r3, #8
30027048:	e3530000 	cmp	r3, #0
3002704c:	1a00004e 	bne	3002718c <FindFDTInfo+0x1d8>
        if (FileName[0] == Rt->Name[0])
30027050:	e59d3000 	ldr	r3, [sp]
30027054:	e5d32000 	ldrb	r2, [r3]
30027058:	e59d300c 	ldr	r3, [sp, #12]
3002705c:	e5d33000 	ldrb	r3, [r3]
30027060:	e1520003 	cmp	r2, r3
30027064:	1a000048 	bne	3002718c <FindFDTInfo+0x1d8>
        if (FileName[1] == Rt->Name[1])
30027068:	e59d3000 	ldr	r3, [sp]
3002706c:	e2833001 	add	r3, r3, #1
30027070:	e5d32000 	ldrb	r2, [r3]
30027074:	e59d300c 	ldr	r3, [sp, #12]
30027078:	e5d33001 	ldrb	r3, [r3, #1]
3002707c:	e1520003 	cmp	r2, r3
30027080:	1a000041 	bne	3002718c <FindFDTInfo+0x1d8>
        if (FileName[2] == Rt->Name[2])
30027084:	e59d3000 	ldr	r3, [sp]
30027088:	e2833002 	add	r3, r3, #2
3002708c:	e5d32000 	ldrb	r2, [r3]
30027090:	e59d300c 	ldr	r3, [sp, #12]
30027094:	e5d33002 	ldrb	r3, [r3, #2]
30027098:	e1520003 	cmp	r2, r3
3002709c:	1a00003a 	bne	3002718c <FindFDTInfo+0x1d8>
        if (FileName[3] == Rt->Name[3])
300270a0:	e59d3000 	ldr	r3, [sp]
300270a4:	e2833003 	add	r3, r3, #3
300270a8:	e5d32000 	ldrb	r2, [r3]
300270ac:	e59d300c 	ldr	r3, [sp, #12]
300270b0:	e5d33003 	ldrb	r3, [r3, #3]
300270b4:	e1520003 	cmp	r2, r3
300270b8:	1a000033 	bne	3002718c <FindFDTInfo+0x1d8>
        if (FileName[4] == Rt->Name[4])
300270bc:	e59d3000 	ldr	r3, [sp]
300270c0:	e2833004 	add	r3, r3, #4
300270c4:	e5d32000 	ldrb	r2, [r3]
300270c8:	e59d300c 	ldr	r3, [sp, #12]
300270cc:	e5d33004 	ldrb	r3, [r3, #4]
300270d0:	e1520003 	cmp	r2, r3
300270d4:	1a00002c 	bne	3002718c <FindFDTInfo+0x1d8>
        if (FileName[5] == Rt->Name[5])
300270d8:	e59d3000 	ldr	r3, [sp]
300270dc:	e2833005 	add	r3, r3, #5
300270e0:	e5d32000 	ldrb	r2, [r3]
300270e4:	e59d300c 	ldr	r3, [sp, #12]
300270e8:	e5d33005 	ldrb	r3, [r3, #5]
300270ec:	e1520003 	cmp	r2, r3
300270f0:	1a000025 	bne	3002718c <FindFDTInfo+0x1d8>
        if (FileName[6] == Rt->Name[6])
300270f4:	e59d3000 	ldr	r3, [sp]
300270f8:	e2833006 	add	r3, r3, #6
300270fc:	e5d32000 	ldrb	r2, [r3]
30027100:	e59d300c 	ldr	r3, [sp, #12]
30027104:	e5d33006 	ldrb	r3, [r3, #6]
30027108:	e1520003 	cmp	r2, r3
3002710c:	1a00001e 	bne	3002718c <FindFDTInfo+0x1d8>
        if (FileName[7] == Rt->Name[7])
30027110:	e59d3000 	ldr	r3, [sp]
30027114:	e2833007 	add	r3, r3, #7
30027118:	e5d32000 	ldrb	r2, [r3]
3002711c:	e59d300c 	ldr	r3, [sp, #12]
30027120:	e5d33007 	ldrb	r3, [r3, #7]
30027124:	e1520003 	cmp	r2, r3
30027128:	1a000017 	bne	3002718c <FindFDTInfo+0x1d8>
        if (FileName[8] == Rt->Name[8])
3002712c:	e59d3000 	ldr	r3, [sp]
30027130:	e2833008 	add	r3, r3, #8
30027134:	e5d32000 	ldrb	r2, [r3]
30027138:	e59d300c 	ldr	r3, [sp, #12]
3002713c:	e5d33008 	ldrb	r3, [r3, #8]
30027140:	e1520003 	cmp	r2, r3
30027144:	1a000010 	bne	3002718c <FindFDTInfo+0x1d8>
        if (FileName[9] == Rt->Name[9])
30027148:	e59d3000 	ldr	r3, [sp]
3002714c:	e2833009 	add	r3, r3, #9
30027150:	e5d32000 	ldrb	r2, [r3]
30027154:	e59d300c 	ldr	r3, [sp, #12]
30027158:	e5d33009 	ldrb	r3, [r3, #9]
3002715c:	e1520003 	cmp	r2, r3
30027160:	1a000009 	bne	3002718c <FindFDTInfo+0x1d8>
        if (FileName[10] == Rt->Name[10])
30027164:	e59d3000 	ldr	r3, [sp]
30027168:	e283300a 	add	r3, r3, #10
3002716c:	e5d32000 	ldrb	r2, [r3]
30027170:	e59d300c 	ldr	r3, [sp, #12]
30027174:	e5d3300a 	ldrb	r3, [r3, #10]
30027178:	e1520003 	cmp	r2, r3
3002717c:	1a000002 	bne	3002718c <FindFDTInfo+0x1d8>
        {
            temp = RETURN_OK;
30027180:	e3a03000 	mov	r3, #0
30027184:	e5cd3017 	strb	r3, [sp, #23]
            break;
30027188:	ea000004 	b	300271a0 <FindFDTInfo+0x1ec>
        }
        i++;
3002718c:	e59d3010 	ldr	r3, [sp, #16]
30027190:	e2833001 	add	r3, r3, #1
30027194:	e58d3010 	str	r3, [sp, #16]
    }
30027198:	eaffff95 	b	30026ff4 <FindFDTInfo+0x40>
    while (1)
    {
        temp = GetFDTInfo(Rt, Drive, ClusIndex, i);
        if (temp != RETURN_OK)
        {
            break;
3002719c:	e1a00000 	nop			; (mov r0, r0)
            temp = RETURN_OK;
            break;
        }
        i++;
    }
    if (FileName[0] == ESC_FDT)
300271a0:	e59d3000 	ldr	r3, [sp]
300271a4:	e5d33000 	ldrb	r3, [r3]
300271a8:	e3530005 	cmp	r3, #5
300271ac:	1a000002 	bne	300271bc <FindFDTInfo+0x208>
    {
        FileName[0] = DEL_FDT;
300271b0:	e59d3000 	ldr	r3, [sp]
300271b4:	e3e0201a 	mvn	r2, #26
300271b8:	e5c32000 	strb	r2, [r3]
    }
    return temp;
300271bc:	e5dd3017 	ldrb	r3, [sp, #23]
}
300271c0:	e1a00003 	mov	r0, r3
300271c4:	e28dd01c 	add	sp, sp, #28
300271c8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300271cc:	e12fff1e 	bx	lr

300271d0 <AddFDT>:
**        οfat.hйڷֵ˵
** ȫֱ: 
** ģ: FindFDTInfo,GetFDTInfo,SetFDTInfo
********************************************************************************************************/
        acoral_u8 AddFDT(acoral_u8 Drive, acoral_u32 ClusIndex, FDT *FDTData)
{
300271d0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300271d4:	e24dd044 	sub	sp, sp, #68	; 0x44
300271d8:	e1a03000 	mov	r3, r0
300271dc:	e58d1008 	str	r1, [sp, #8]
300271e0:	e58d2004 	str	r2, [sp, #4]
300271e4:	e5cd300f 	strb	r3, [sp, #15]
    Disk_Info * Disk;
    acoral_u32 i;
    FDT TempFDT;
    acoral_u8 temp;

    Disk = GetDiskInfo(Drive);
300271e8:	e5dd300f 	ldrb	r3, [sp, #15]
300271ec:	e1a00003 	mov	r0, r3
300271f0:	ebfff48a 	bl	30024420 <GetDiskInfo>
300271f4:	e1a03000 	mov	r3, r0
300271f8:	e58d3034 	str	r3, [sp, #52]	; 0x34
    if (Disk == NULL)
300271fc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30027200:	e3530000 	cmp	r3, #0
30027204:	1a000001 	bne	30027210 <AddFDT+0x40>
    {
        return NOT_FIND_DISK;
30027208:	e3a03001 	mov	r3, #1
3002720c:	ea000071 	b	300273d8 <AddFDT+0x208>
    }

    if (ClusIndex == EMPTY_CLUS)
30027210:	e59d3008 	ldr	r3, [sp, #8]
30027214:	e3530000 	cmp	r3, #0
30027218:	1a000006 	bne	30027238 <AddFDT+0x68>
    if (Disk->FATType == FAT32)
3002721c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30027220:	e5d33001 	ldrb	r3, [r3, #1]
30027224:	e3530002 	cmp	r3, #2
30027228:	1a000002 	bne	30027238 <AddFDT+0x68>
    {
        ClusIndex = Disk->RootDirTable;
3002722c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30027230:	e5933010 	ldr	r3, [r3, #16]
30027234:	e58d3008 	str	r3, [sp, #8]
    }

    temp = FindFDTInfo(&TempFDT, Drive, ClusIndex, FDTData->Name);
30027238:	e59d3004 	ldr	r3, [sp, #4]
3002723c:	e28d1014 	add	r1, sp, #20
30027240:	e5dd200f 	ldrb	r2, [sp, #15]
30027244:	e1a00001 	mov	r0, r1
30027248:	e1a01002 	mov	r1, r2
3002724c:	e59d2008 	ldr	r2, [sp, #8]
30027250:	ebffff57 	bl	30026fb4 <FindFDTInfo>
30027254:	e1a03000 	mov	r3, r0
30027258:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
    if (temp == RETURN_OK)
3002725c:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
30027260:	e3530000 	cmp	r3, #0
30027264:	1a000001 	bne	30027270 <AddFDT+0xa0>
    {
        return FDT_EXISTS;
30027268:	e3a0300a 	mov	r3, #10
3002726c:	ea000059 	b	300273d8 <AddFDT+0x208>
    }
    if (temp != NOT_FIND_FDT)
30027270:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
30027274:	e3530007 	cmp	r3, #7
30027278:	0a000004 	beq	30027290 <AddFDT+0xc0>
    if (temp != FDT_OVER)
3002727c:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
30027280:	e3530009 	cmp	r3, #9
30027284:	0a000001 	beq	30027290 <AddFDT+0xc0>
    {
        return temp;
30027288:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
3002728c:	ea000051 	b	300273d8 <AddFDT+0x208>
    }

    if (FDTData->Name[0] == DEL_FDT)
30027290:	e59d3004 	ldr	r3, [sp, #4]
30027294:	e5d33000 	ldrb	r3, [r3]
30027298:	e35300e5 	cmp	r3, #229	; 0xe5
3002729c:	1a000002 	bne	300272ac <AddFDT+0xdc>
    {
        FDTData->Name[0] = ESC_FDT;
300272a0:	e59d3004 	ldr	r3, [sp, #4]
300272a4:	e3a02005 	mov	r2, #5
300272a8:	e5c32000 	strb	r2, [r3]
    }

    i = 0;
300272ac:	e3a03000 	mov	r3, #0
300272b0:	e58d3038 	str	r3, [sp, #56]	; 0x38
    temp = RETURN_OK;
300272b4:	e3a03000 	mov	r3, #0
300272b8:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
    while (temp == RETURN_OK)
300272bc:	ea00001d 	b	30027338 <AddFDT+0x168>
    {
        temp = GetFDTInfo(&TempFDT, Drive, ClusIndex, i);
300272c0:	e28d2014 	add	r2, sp, #20
300272c4:	e5dd300f 	ldrb	r3, [sp, #15]
300272c8:	e1a00002 	mov	r0, r2
300272cc:	e1a01003 	mov	r1, r3
300272d0:	e59d2008 	ldr	r2, [sp, #8]
300272d4:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
300272d8:	ebfffe0a 	bl	30026b08 <GetFDTInfo>
300272dc:	e1a03000 	mov	r3, r0
300272e0:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
        if (temp == RETURN_OK)
300272e4:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
300272e8:	e3530000 	cmp	r3, #0
300272ec:	1a00000e 	bne	3002732c <AddFDT+0x15c>
        {
            if (TempFDT.Name[0] == DEL_FDT || TempFDT.Name[0] == EMPTY_FDT)
300272f0:	e5dd3014 	ldrb	r3, [sp, #20]
300272f4:	e35300e5 	cmp	r3, #229	; 0xe5
300272f8:	0a000002 	beq	30027308 <AddFDT+0x138>
300272fc:	e5dd3014 	ldrb	r3, [sp, #20]
30027300:	e3530000 	cmp	r3, #0
30027304:	1a000008 	bne	3002732c <AddFDT+0x15c>
            {
                temp = SetFDTInfo(Drive, ClusIndex, i, FDTData);
30027308:	e5dd300f 	ldrb	r3, [sp, #15]
3002730c:	e1a00003 	mov	r0, r3
30027310:	e59d1008 	ldr	r1, [sp, #8]
30027314:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
30027318:	e59d3004 	ldr	r3, [sp, #4]
3002731c:	ebfffeb1 	bl	30026de8 <SetFDTInfo>
30027320:	e1a03000 	mov	r3, r0
30027324:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
                break;
30027328:	ea000005 	b	30027344 <AddFDT+0x174>
            }
        }
        i++;
3002732c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30027330:	e2833001 	add	r3, r3, #1
30027334:	e58d3038 	str	r3, [sp, #56]	; 0x38
        FDTData->Name[0] = ESC_FDT;
    }

    i = 0;
    temp = RETURN_OK;
    while (temp == RETURN_OK)
30027338:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
3002733c:	e3530000 	cmp	r3, #0
30027340:	0affffde 	beq	300272c0 <AddFDT+0xf0>
                break;
            }
        }
        i++;
    }
    if (temp == FDT_OVER)
30027344:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
30027348:	e3530009 	cmp	r3, #9
3002734c:	1a000019 	bne	300273b8 <AddFDT+0x1e8>
    if (ClusIndex != EMPTY_CLUS)
30027350:	e59d3008 	ldr	r3, [sp, #8]
30027354:	e3530000 	cmp	r3, #0
30027358:	0a000016 	beq	300273b8 <AddFDT+0x1e8>
    {
        i = FATAddClus(Drive, ClusIndex);
3002735c:	e5dd300f 	ldrb	r3, [sp, #15]
30027360:	e1a00003 	mov	r0, r3
30027364:	e59d1008 	ldr	r1, [sp, #8]
30027368:	ebfffa51 	bl	30025cb4 <FATAddClus>
3002736c:	e1a03000 	mov	r3, r0
30027370:	e58d3038 	str	r3, [sp, #56]	; 0x38
        temp = DISK_FULL;
30027374:	e3a03002 	mov	r3, #2
30027378:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
        if (i != BAD_CLUS)
3002737c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30027380:	e373029f 	cmn	r3, #-268435447	; 0xf0000009
30027384:	0a00000b 	beq	300273b8 <AddFDT+0x1e8>
        {
            ClearClus(Drive, i); 
30027388:	e5dd300f 	ldrb	r3, [sp, #15]
3002738c:	e1a00003 	mov	r0, r3
30027390:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
30027394:	ebfffaef 	bl	30025f58 <ClearClus>
            temp = SetFDTInfo(Drive, i, 0, FDTData);
30027398:	e5dd300f 	ldrb	r3, [sp, #15]
3002739c:	e1a00003 	mov	r0, r3
300273a0:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
300273a4:	e3a02000 	mov	r2, #0
300273a8:	e59d3004 	ldr	r3, [sp, #4]
300273ac:	ebfffe8d 	bl	30026de8 <SetFDTInfo>
300273b0:	e1a03000 	mov	r3, r0
300273b4:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
        }
    }
    if (FDTData->Name[0] == ESC_FDT)
300273b8:	e59d3004 	ldr	r3, [sp, #4]
300273bc:	e5d33000 	ldrb	r3, [r3]
300273c0:	e3530005 	cmp	r3, #5
300273c4:	1a000002 	bne	300273d4 <AddFDT+0x204>
    {
        FDTData->Name[0] = DEL_FDT;
300273c8:	e59d3004 	ldr	r3, [sp, #4]
300273cc:	e3e0201a 	mvn	r2, #26
300273d0:	e5c32000 	strb	r2, [r3]
    }
    return temp;
300273d4:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
}
300273d8:	e1a00003 	mov	r0, r3
300273dc:	e28dd044 	add	sp, sp, #68	; 0x44
300273e0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300273e4:	e12fff1e 	bx	lr

300273e8 <DelFDT>:
**        οfat.hйڷֵ˵
** ȫֱ: 
** ģ: GetDiskInfo,GetFDTInfo,SetFDTInfo
********************************************************************************************************/
        acoral_u8 DelFDT(acoral_u8 Drive, acoral_u32 ClusIndex, acoral_char FileName[])
{
300273e8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300273ec:	e24dd03c 	sub	sp, sp, #60	; 0x3c
300273f0:	e1a03000 	mov	r3, r0
300273f4:	e58d1008 	str	r1, [sp, #8]
300273f8:	e58d2004 	str	r2, [sp, #4]
300273fc:	e5cd300f 	strb	r3, [sp, #15]
    acoral_u32 i;
    FDT TempFDT;
    acoral_u8 temp;
    
    i = 0;
30027400:	e3a03000 	mov	r3, #0
30027404:	e58d3030 	str	r3, [sp, #48]	; 0x30
    if (FileName[0] == DEL_FDT)
30027408:	e59d3004 	ldr	r3, [sp, #4]
3002740c:	e5d33000 	ldrb	r3, [r3]
30027410:	e35300e5 	cmp	r3, #229	; 0xe5
30027414:	1a000002 	bne	30027424 <DelFDT+0x3c>
    {
        FileName[0] = ESC_FDT;
30027418:	e59d3004 	ldr	r3, [sp, #4]
3002741c:	e3a02005 	mov	r2, #5
30027420:	e5c32000 	strb	r2, [r3]
    }
        
    while (1)
    {
        temp = GetFDTInfo(&TempFDT, Drive, ClusIndex, i);
30027424:	e28d2010 	add	r2, sp, #16
30027428:	e5dd300f 	ldrb	r3, [sp, #15]
3002742c:	e1a00002 	mov	r0, r2
30027430:	e1a01003 	mov	r1, r3
30027434:	e59d2008 	ldr	r2, [sp, #8]
30027438:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3002743c:	ebfffdb1 	bl	30026b08 <GetFDTInfo>
30027440:	e1a03000 	mov	r3, r0
30027444:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
        if (temp != RETURN_OK)
30027448:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
3002744c:	e3530000 	cmp	r3, #0
30027450:	1a000059 	bne	300275bc <DelFDT+0x1d4>
        {
            break;
        }
            
        if (TempFDT.Name[0] == EMPTY_FDT)
30027454:	e5dd3010 	ldrb	r3, [sp, #16]
30027458:	e3530000 	cmp	r3, #0
3002745c:	1a000002 	bne	3002746c <DelFDT+0x84>
        {
            temp = NOT_FIND_FDT;
30027460:	e3a03007 	mov	r3, #7
30027464:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
            break;
30027468:	ea000054 	b	300275c0 <DelFDT+0x1d8>
        }
        if ((TempFDT.Attr & ATTR_VOLUME_ID) == 0)
3002746c:	e5dd301b 	ldrb	r3, [sp, #27]
30027470:	e2033008 	and	r3, r3, #8
30027474:	e3530000 	cmp	r3, #0
30027478:	1a00004b 	bne	300275ac <DelFDT+0x1c4>
        if (FileName[0] == TempFDT.Name[0])
3002747c:	e59d3004 	ldr	r3, [sp, #4]
30027480:	e5d32000 	ldrb	r2, [r3]
30027484:	e5dd3010 	ldrb	r3, [sp, #16]
30027488:	e1520003 	cmp	r2, r3
3002748c:	1a000046 	bne	300275ac <DelFDT+0x1c4>
        if (FileName[1] == TempFDT.Name[1])
30027490:	e59d3004 	ldr	r3, [sp, #4]
30027494:	e2833001 	add	r3, r3, #1
30027498:	e5d32000 	ldrb	r2, [r3]
3002749c:	e5dd3011 	ldrb	r3, [sp, #17]
300274a0:	e1520003 	cmp	r2, r3
300274a4:	1a000040 	bne	300275ac <DelFDT+0x1c4>
        if (FileName[2] == TempFDT.Name[2])
300274a8:	e59d3004 	ldr	r3, [sp, #4]
300274ac:	e2833002 	add	r3, r3, #2
300274b0:	e5d32000 	ldrb	r2, [r3]
300274b4:	e5dd3012 	ldrb	r3, [sp, #18]
300274b8:	e1520003 	cmp	r2, r3
300274bc:	1a00003a 	bne	300275ac <DelFDT+0x1c4>
        if (FileName[3] == TempFDT.Name[3])
300274c0:	e59d3004 	ldr	r3, [sp, #4]
300274c4:	e2833003 	add	r3, r3, #3
300274c8:	e5d32000 	ldrb	r2, [r3]
300274cc:	e5dd3013 	ldrb	r3, [sp, #19]
300274d0:	e1520003 	cmp	r2, r3
300274d4:	1a000034 	bne	300275ac <DelFDT+0x1c4>
        if (FileName[4] == TempFDT.Name[4])
300274d8:	e59d3004 	ldr	r3, [sp, #4]
300274dc:	e2833004 	add	r3, r3, #4
300274e0:	e5d32000 	ldrb	r2, [r3]
300274e4:	e5dd3014 	ldrb	r3, [sp, #20]
300274e8:	e1520003 	cmp	r2, r3
300274ec:	1a00002e 	bne	300275ac <DelFDT+0x1c4>
        if (FileName[5] == TempFDT.Name[5])
300274f0:	e59d3004 	ldr	r3, [sp, #4]
300274f4:	e2833005 	add	r3, r3, #5
300274f8:	e5d32000 	ldrb	r2, [r3]
300274fc:	e5dd3015 	ldrb	r3, [sp, #21]
30027500:	e1520003 	cmp	r2, r3
30027504:	1a000028 	bne	300275ac <DelFDT+0x1c4>
        if (FileName[6] == TempFDT.Name[6])
30027508:	e59d3004 	ldr	r3, [sp, #4]
3002750c:	e2833006 	add	r3, r3, #6
30027510:	e5d32000 	ldrb	r2, [r3]
30027514:	e5dd3016 	ldrb	r3, [sp, #22]
30027518:	e1520003 	cmp	r2, r3
3002751c:	1a000022 	bne	300275ac <DelFDT+0x1c4>
        if (FileName[7] == TempFDT.Name[7])
30027520:	e59d3004 	ldr	r3, [sp, #4]
30027524:	e2833007 	add	r3, r3, #7
30027528:	e5d32000 	ldrb	r2, [r3]
3002752c:	e5dd3017 	ldrb	r3, [sp, #23]
30027530:	e1520003 	cmp	r2, r3
30027534:	1a00001c 	bne	300275ac <DelFDT+0x1c4>
        if (FileName[8] == TempFDT.Name[8])
30027538:	e59d3004 	ldr	r3, [sp, #4]
3002753c:	e2833008 	add	r3, r3, #8
30027540:	e5d32000 	ldrb	r2, [r3]
30027544:	e5dd3018 	ldrb	r3, [sp, #24]
30027548:	e1520003 	cmp	r2, r3
3002754c:	1a000016 	bne	300275ac <DelFDT+0x1c4>
        if (FileName[9] == TempFDT.Name[9])
30027550:	e59d3004 	ldr	r3, [sp, #4]
30027554:	e2833009 	add	r3, r3, #9
30027558:	e5d32000 	ldrb	r2, [r3]
3002755c:	e5dd3019 	ldrb	r3, [sp, #25]
30027560:	e1520003 	cmp	r2, r3
30027564:	1a000010 	bne	300275ac <DelFDT+0x1c4>
        if (FileName[10] == TempFDT.Name[10])
30027568:	e59d3004 	ldr	r3, [sp, #4]
3002756c:	e283300a 	add	r3, r3, #10
30027570:	e5d32000 	ldrb	r2, [r3]
30027574:	e5dd301a 	ldrb	r3, [sp, #26]
30027578:	e1520003 	cmp	r2, r3
3002757c:	1a00000a 	bne	300275ac <DelFDT+0x1c4>
        {
            TempFDT.Name[0] = DEL_FDT;
30027580:	e3e0301a 	mvn	r3, #26
30027584:	e5cd3010 	strb	r3, [sp, #16]
            temp = SetFDTInfo(Drive, ClusIndex, i, &TempFDT);
30027588:	e5dd200f 	ldrb	r2, [sp, #15]
3002758c:	e28d3010 	add	r3, sp, #16
30027590:	e1a00002 	mov	r0, r2
30027594:	e59d1008 	ldr	r1, [sp, #8]
30027598:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
3002759c:	ebfffe11 	bl	30026de8 <SetFDTInfo>
300275a0:	e1a03000 	mov	r3, r0
300275a4:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
            break;
300275a8:	ea000004 	b	300275c0 <DelFDT+0x1d8>
        }
        i++;
300275ac:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
300275b0:	e2833001 	add	r3, r3, #1
300275b4:	e58d3030 	str	r3, [sp, #48]	; 0x30
    }
300275b8:	eaffff99 	b	30027424 <DelFDT+0x3c>
    while (1)
    {
        temp = GetFDTInfo(&TempFDT, Drive, ClusIndex, i);
        if (temp != RETURN_OK)
        {
            break;
300275bc:	e1a00000 	nop			; (mov r0, r0)
            temp = SetFDTInfo(Drive, ClusIndex, i, &TempFDT);
            break;
        }
        i++;
    }
    if (FileName[0] == ESC_FDT)
300275c0:	e59d3004 	ldr	r3, [sp, #4]
300275c4:	e5d33000 	ldrb	r3, [r3]
300275c8:	e3530005 	cmp	r3, #5
300275cc:	1a000002 	bne	300275dc <DelFDT+0x1f4>
    {
        FileName[0] = DEL_FDT;
300275d0:	e59d3004 	ldr	r3, [sp, #4]
300275d4:	e3e0201a 	mvn	r2, #26
300275d8:	e5c32000 	strb	r2, [r3]
    }
    return temp;
300275dc:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
}
300275e0:	e1a00003 	mov	r0, r3
300275e4:	e28dd03c 	add	sp, sp, #60	; 0x3c
300275e8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300275ec:	e12fff1e 	bx	lr

300275f0 <ChangeFDT>:
**        οfat.hйڷֵ˵
** ȫֱ: 
** ģ: GetDiskInfo,GetFDTInfo,SetFDTInfo
********************************************************************************************************/
        acoral_u8 ChangeFDT(acoral_u8 Drive, acoral_u32 ClusIndex, FDT *FDTData)
{
300275f0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300275f4:	e24dd03c 	sub	sp, sp, #60	; 0x3c
300275f8:	e1a03000 	mov	r3, r0
300275fc:	e58d1008 	str	r1, [sp, #8]
30027600:	e58d2004 	str	r2, [sp, #4]
30027604:	e5cd300f 	strb	r3, [sp, #15]
    acoral_u32 i;
    acoral_u8 temp;
    FDT TempFDT;

    i = 0;
30027608:	e3a03000 	mov	r3, #0
3002760c:	e58d3030 	str	r3, [sp, #48]	; 0x30
    if (FDTData->Name[0] == DEL_FDT)
30027610:	e59d3004 	ldr	r3, [sp, #4]
30027614:	e5d33000 	ldrb	r3, [r3]
30027618:	e35300e5 	cmp	r3, #229	; 0xe5
3002761c:	1a000002 	bne	3002762c <ChangeFDT+0x3c>
    {
        FDTData->Name[0] = ESC_FDT;
30027620:	e59d3004 	ldr	r3, [sp, #4]
30027624:	e3a02005 	mov	r2, #5
30027628:	e5c32000 	strb	r2, [r3]
    }
    while (1)
    {
        temp = GetFDTInfo(&TempFDT, Drive, ClusIndex, i);
3002762c:	e28d2010 	add	r2, sp, #16
30027630:	e5dd300f 	ldrb	r3, [sp, #15]
30027634:	e1a00002 	mov	r0, r2
30027638:	e1a01003 	mov	r1, r3
3002763c:	e59d2008 	ldr	r2, [sp, #8]
30027640:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30027644:	ebfffd2f 	bl	30026b08 <GetFDTInfo>
30027648:	e1a03000 	mov	r3, r0
3002764c:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
        if (temp != RETURN_OK)
30027650:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
30027654:	e3530000 	cmp	r3, #0
30027658:	1a00004d 	bne	30027794 <ChangeFDT+0x1a4>
        {
            break;
        }
            
        if (TempFDT.Name[0] == EMPTY_FDT)
3002765c:	e5dd3010 	ldrb	r3, [sp, #16]
30027660:	e3530000 	cmp	r3, #0
30027664:	1a000002 	bne	30027674 <ChangeFDT+0x84>
        {
            temp = NOT_FIND_FDT;
30027668:	e3a03007 	mov	r3, #7
3002766c:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
            break;
30027670:	ea000048 	b	30027798 <ChangeFDT+0x1a8>
        }
        if ((TempFDT.Attr & ATTR_VOLUME_ID) == 0)
30027674:	e5dd301b 	ldrb	r3, [sp, #27]
30027678:	e2033008 	and	r3, r3, #8
3002767c:	e3530000 	cmp	r3, #0
30027680:	1a00003f 	bne	30027784 <ChangeFDT+0x194>
        if (FDTData->Name[0] == TempFDT.Name[0])
30027684:	e59d3004 	ldr	r3, [sp, #4]
30027688:	e5d32000 	ldrb	r2, [r3]
3002768c:	e5dd3010 	ldrb	r3, [sp, #16]
30027690:	e1520003 	cmp	r2, r3
30027694:	1a00003a 	bne	30027784 <ChangeFDT+0x194>
        if (FDTData->Name[1] == TempFDT.Name[1])
30027698:	e59d3004 	ldr	r3, [sp, #4]
3002769c:	e5d32001 	ldrb	r2, [r3, #1]
300276a0:	e5dd3011 	ldrb	r3, [sp, #17]
300276a4:	e1520003 	cmp	r2, r3
300276a8:	1a000035 	bne	30027784 <ChangeFDT+0x194>
        if (FDTData->Name[2] == TempFDT.Name[2])
300276ac:	e59d3004 	ldr	r3, [sp, #4]
300276b0:	e5d32002 	ldrb	r2, [r3, #2]
300276b4:	e5dd3012 	ldrb	r3, [sp, #18]
300276b8:	e1520003 	cmp	r2, r3
300276bc:	1a000030 	bne	30027784 <ChangeFDT+0x194>
        if (FDTData->Name[3] == TempFDT.Name[3])
300276c0:	e59d3004 	ldr	r3, [sp, #4]
300276c4:	e5d32003 	ldrb	r2, [r3, #3]
300276c8:	e5dd3013 	ldrb	r3, [sp, #19]
300276cc:	e1520003 	cmp	r2, r3
300276d0:	1a00002b 	bne	30027784 <ChangeFDT+0x194>
        if (FDTData->Name[4] == TempFDT.Name[4])
300276d4:	e59d3004 	ldr	r3, [sp, #4]
300276d8:	e5d32004 	ldrb	r2, [r3, #4]
300276dc:	e5dd3014 	ldrb	r3, [sp, #20]
300276e0:	e1520003 	cmp	r2, r3
300276e4:	1a000026 	bne	30027784 <ChangeFDT+0x194>
        if (FDTData->Name[5] == TempFDT.Name[5])
300276e8:	e59d3004 	ldr	r3, [sp, #4]
300276ec:	e5d32005 	ldrb	r2, [r3, #5]
300276f0:	e5dd3015 	ldrb	r3, [sp, #21]
300276f4:	e1520003 	cmp	r2, r3
300276f8:	1a000021 	bne	30027784 <ChangeFDT+0x194>
        if (FDTData->Name[6] == TempFDT.Name[6])
300276fc:	e59d3004 	ldr	r3, [sp, #4]
30027700:	e5d32006 	ldrb	r2, [r3, #6]
30027704:	e5dd3016 	ldrb	r3, [sp, #22]
30027708:	e1520003 	cmp	r2, r3
3002770c:	1a00001c 	bne	30027784 <ChangeFDT+0x194>
        if (FDTData->Name[7] == TempFDT.Name[7])
30027710:	e59d3004 	ldr	r3, [sp, #4]
30027714:	e5d32007 	ldrb	r2, [r3, #7]
30027718:	e5dd3017 	ldrb	r3, [sp, #23]
3002771c:	e1520003 	cmp	r2, r3
30027720:	1a000017 	bne	30027784 <ChangeFDT+0x194>
        if (FDTData->Name[8] == TempFDT.Name[8])
30027724:	e59d3004 	ldr	r3, [sp, #4]
30027728:	e5d32008 	ldrb	r2, [r3, #8]
3002772c:	e5dd3018 	ldrb	r3, [sp, #24]
30027730:	e1520003 	cmp	r2, r3
30027734:	1a000012 	bne	30027784 <ChangeFDT+0x194>
        if (FDTData->Name[9] == TempFDT.Name[9])
30027738:	e59d3004 	ldr	r3, [sp, #4]
3002773c:	e5d32009 	ldrb	r2, [r3, #9]
30027740:	e5dd3019 	ldrb	r3, [sp, #25]
30027744:	e1520003 	cmp	r2, r3
30027748:	1a00000d 	bne	30027784 <ChangeFDT+0x194>
        if (FDTData->Name[10] == TempFDT.Name[10])
3002774c:	e59d3004 	ldr	r3, [sp, #4]
30027750:	e5d3200a 	ldrb	r2, [r3, #10]
30027754:	e5dd301a 	ldrb	r3, [sp, #26]
30027758:	e1520003 	cmp	r2, r3
3002775c:	1a000008 	bne	30027784 <ChangeFDT+0x194>
        {
            temp = SetFDTInfo(Drive, ClusIndex, i, FDTData);
30027760:	e5dd300f 	ldrb	r3, [sp, #15]
30027764:	e1a00003 	mov	r0, r3
30027768:	e59d1008 	ldr	r1, [sp, #8]
3002776c:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
30027770:	e59d3004 	ldr	r3, [sp, #4]
30027774:	ebfffd9b 	bl	30026de8 <SetFDTInfo>
30027778:	e1a03000 	mov	r3, r0
3002777c:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
            break;
30027780:	ea000004 	b	30027798 <ChangeFDT+0x1a8>
        }
        i++;
30027784:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30027788:	e2833001 	add	r3, r3, #1
3002778c:	e58d3030 	str	r3, [sp, #48]	; 0x30
    }
30027790:	eaffffa5 	b	3002762c <ChangeFDT+0x3c>
    while (1)
    {
        temp = GetFDTInfo(&TempFDT, Drive, ClusIndex, i);
        if (temp != RETURN_OK)
        {
            break;
30027794:	e1a00000 	nop			; (mov r0, r0)
            temp = SetFDTInfo(Drive, ClusIndex, i, FDTData);
            break;
        }
        i++;
    }
    if (FDTData->Name[0] == ESC_FDT)
30027798:	e59d3004 	ldr	r3, [sp, #4]
3002779c:	e5d33000 	ldrb	r3, [r3]
300277a0:	e3530005 	cmp	r3, #5
300277a4:	1a000002 	bne	300277b4 <ChangeFDT+0x1c4>
    {
        FDTData->Name[0] = DEL_FDT;
300277a8:	e59d3004 	ldr	r3, [sp, #4]
300277ac:	e3e0201a 	mvn	r2, #26
300277b0:	e5c32000 	strb	r2, [r3]
    }
    return temp;
300277b4:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
}
300277b8:	e1a00003 	mov	r0, r3
300277bc:	e28dd03c 	add	sp, sp, #60	; 0x3c
300277c0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300277c4:	e12fff1e 	bx	lr

300277c8 <DirIsEmpty>:
**        οfat.hйڷֵ˵
** ȫֱ: 
** ģ: GetFDTInfo
********************************************************************************************************/
        acoral_u8 DirIsEmpty(acoral_u8 Drive, acoral_u32 ClusIndex)
{
300277c8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300277cc:	e24dd03c 	sub	sp, sp, #60	; 0x3c
300277d0:	e1a03000 	mov	r3, r0
300277d4:	e58d1000 	str	r1, [sp]
300277d8:	e5cd3007 	strb	r3, [sp, #7]
    FDT TempFDT;
    acoral_u8 temp;
    Disk_Info * Disk;

    
    if (ClusIndex == EMPTY_CLUS)
300277dc:	e59d3000 	ldr	r3, [sp]
300277e0:	e3530000 	cmp	r3, #0
300277e4:	1a000001 	bne	300277f0 <DirIsEmpty+0x28>
    {
        return DIR_NOT_EMPTY;
300277e8:	e3a0300d 	mov	r3, #13
300277ec:	ea000036 	b	300278cc <DirIsEmpty+0x104>
    }
/* жǷfat32 ĸĿ¼ */
    Disk = GetDiskInfo(Drive);
300277f0:	e5dd3007 	ldrb	r3, [sp, #7]
300277f4:	e1a00003 	mov	r0, r3
300277f8:	ebfff308 	bl	30024420 <GetDiskInfo>
300277fc:	e1a03000 	mov	r3, r0
30027800:	e58d3034 	str	r3, [sp, #52]	; 0x34
    if (Disk == NULL)
30027804:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30027808:	e3530000 	cmp	r3, #0
3002780c:	1a000001 	bne	30027818 <DirIsEmpty+0x50>
    {
        return NOT_FIND_DISK;
30027810:	e3a03001 	mov	r3, #1
30027814:	ea00002c 	b	300278cc <DirIsEmpty+0x104>
    }
    if (Disk->FATType == FAT32)
30027818:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3002781c:	e5d33001 	ldrb	r3, [r3, #1]
30027820:	e3530002 	cmp	r3, #2
30027824:	1a000006 	bne	30027844 <DirIsEmpty+0x7c>
    if (ClusIndex == Disk->RootDirTable )
30027828:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3002782c:	e5932010 	ldr	r2, [r3, #16]
30027830:	e59d3000 	ldr	r3, [sp]
30027834:	e1520003 	cmp	r2, r3
30027838:	1a000001 	bne	30027844 <DirIsEmpty+0x7c>
    {
        return DIR_NOT_EMPTY;
3002783c:	e3a0300d 	mov	r3, #13
30027840:	ea000021 	b	300278cc <DirIsEmpty+0x104>
    }
    
    i = 2;
30027844:	e3a03002 	mov	r3, #2
30027848:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    while (1)
    {
        temp = GetFDTInfo(&TempFDT, Drive, ClusIndex, i);
3002784c:	e28d200c 	add	r2, sp, #12
30027850:	e5dd3007 	ldrb	r3, [sp, #7]
30027854:	e1a00002 	mov	r0, r2
30027858:	e1a01003 	mov	r1, r3
3002785c:	e59d2000 	ldr	r2, [sp]
30027860:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30027864:	ebfffca7 	bl	30026b08 <GetFDTInfo>
30027868:	e1a03000 	mov	r3, r0
3002786c:	e5cd3033 	strb	r3, [sp, #51]	; 0x33
        if (temp != RETURN_OK)
30027870:	e5dd3033 	ldrb	r3, [sp, #51]	; 0x33
30027874:	e3530000 	cmp	r3, #0
30027878:	0a000001 	beq	30027884 <DirIsEmpty+0xbc>
        {
           return temp; 
3002787c:	e5dd3033 	ldrb	r3, [sp, #51]	; 0x33
30027880:	ea000011 	b	300278cc <DirIsEmpty+0x104>
        }
    
        if ((TempFDT.Attr & ATTR_VOLUME_ID) == 0)
30027884:	e5dd3017 	ldrb	r3, [sp, #23]
30027888:	e2033008 	and	r3, r3, #8
3002788c:	e3530000 	cmp	r3, #0
30027890:	1a000006 	bne	300278b0 <DirIsEmpty+0xe8>
        if (TempFDT.Name[0] != DEL_FDT)
30027894:	e5dd300c 	ldrb	r3, [sp, #12]
30027898:	e35300e5 	cmp	r3, #229	; 0xe5
3002789c:	0a000003 	beq	300278b0 <DirIsEmpty+0xe8>
        {
            break;
        }
        i++;
    }
    if (TempFDT.Name[0] == EMPTY_FDT)
300278a0:	e5dd300c 	ldrb	r3, [sp, #12]
300278a4:	e3530000 	cmp	r3, #0
300278a8:	0a000004 	beq	300278c0 <DirIsEmpty+0xf8>
300278ac:	ea000005 	b	300278c8 <DirIsEmpty+0x100>
        if ((TempFDT.Attr & ATTR_VOLUME_ID) == 0)
        if (TempFDT.Name[0] != DEL_FDT)
        {
            break;
        }
        i++;
300278b0:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300278b4:	e2833001 	add	r3, r3, #1
300278b8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    }
300278bc:	eaffffe2 	b	3002784c <DirIsEmpty+0x84>
    if (TempFDT.Name[0] == EMPTY_FDT)
    {
        return DIR_EMPTY;
300278c0:	e3a0300c 	mov	r3, #12
300278c4:	ea000000 	b	300278cc <DirIsEmpty+0x104>
    }
    else
    {
        return DIR_NOT_EMPTY;
300278c8:	e3a0300d 	mov	r3, #13
    }
}
300278cc:	e1a00003 	mov	r0, r3
300278d0:	e28dd03c 	add	sp, sp, #60	; 0x3c
300278d4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300278d8:	e12fff1e 	bx	lr

300278dc <FDTIsLie>:
**        οfat.hйڷֵ˵
** ȫֱ: 
** ģ: GetDiskInfo,GetFDTInfo
********************************************************************************************************/
        acoral_u8 FDTIsLie(acoral_u8 Drive, acoral_u32 ClusIndex, acoral_char FileName[])
{
300278dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300278e0:	e24dd03c 	sub	sp, sp, #60	; 0x3c
300278e4:	e1a03000 	mov	r3, r0
300278e8:	e58d1008 	str	r1, [sp, #8]
300278ec:	e58d2004 	str	r2, [sp, #4]
300278f0:	e5cd300f 	strb	r3, [sp, #15]
    acoral_u32 i;
    acoral_u8 temp;
    FDT temp1;
    
    i = 0;
300278f4:	e3a03000 	mov	r3, #0
300278f8:	e58d3030 	str	r3, [sp, #48]	; 0x30
    if (FileName[0] == DEL_FDT)
300278fc:	e59d3004 	ldr	r3, [sp, #4]
30027900:	e5d33000 	ldrb	r3, [r3]
30027904:	e35300e5 	cmp	r3, #229	; 0xe5
30027908:	1a000002 	bne	30027918 <FDTIsLie+0x3c>
    {
        FileName[0] = ESC_FDT;
3002790c:	e59d3004 	ldr	r3, [sp, #4]
30027910:	e3a02005 	mov	r2, #5
30027914:	e5c32000 	strb	r2, [r3]
    }
    while (1)
    {
        temp = GetFDTInfo(&temp1, Drive, ClusIndex, i);
30027918:	e28d2010 	add	r2, sp, #16
3002791c:	e5dd300f 	ldrb	r3, [sp, #15]
30027920:	e1a00002 	mov	r0, r2
30027924:	e1a01003 	mov	r1, r3
30027928:	e59d2008 	ldr	r2, [sp, #8]
3002792c:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30027930:	ebfffc74 	bl	30026b08 <GetFDTInfo>
30027934:	e1a03000 	mov	r3, r0
30027938:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
        if (temp == FDT_OVER)
3002793c:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
30027940:	e3530009 	cmp	r3, #9
30027944:	1a000002 	bne	30027954 <FDTIsLie+0x78>
        {
            temp = NOT_FIND_FDT;
30027948:	e3a03007 	mov	r3, #7
3002794c:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
            break;
30027950:	ea000054 	b	30027aa8 <FDTIsLie+0x1cc>
        }

        if (temp != RETURN_OK)
30027954:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
30027958:	e3530000 	cmp	r3, #0
3002795c:	1a000050 	bne	30027aa4 <FDTIsLie+0x1c8>
        {
            break;
        }

        if (temp1.Name[0] == EMPTY_FDT)
30027960:	e5dd3010 	ldrb	r3, [sp, #16]
30027964:	e3530000 	cmp	r3, #0
30027968:	1a000002 	bne	30027978 <FDTIsLie+0x9c>
        {
            temp = NOT_FIND_FDT;
3002796c:	e3a03007 	mov	r3, #7
30027970:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
            break;
30027974:	ea00004b 	b	30027aa8 <FDTIsLie+0x1cc>
        }
        if ((temp1.Attr & ATTR_VOLUME_ID) == 0)
30027978:	e5dd301b 	ldrb	r3, [sp, #27]
3002797c:	e2033008 	and	r3, r3, #8
30027980:	e3530000 	cmp	r3, #0
30027984:	1a000042 	bne	30027a94 <FDTIsLie+0x1b8>
        if (FileName[0] == temp1.Name[0])
30027988:	e59d3004 	ldr	r3, [sp, #4]
3002798c:	e5d32000 	ldrb	r2, [r3]
30027990:	e5dd3010 	ldrb	r3, [sp, #16]
30027994:	e1520003 	cmp	r2, r3
30027998:	1a00003d 	bne	30027a94 <FDTIsLie+0x1b8>
        if (FileName[1] == temp1.Name[1])
3002799c:	e59d3004 	ldr	r3, [sp, #4]
300279a0:	e2833001 	add	r3, r3, #1
300279a4:	e5d32000 	ldrb	r2, [r3]
300279a8:	e5dd3011 	ldrb	r3, [sp, #17]
300279ac:	e1520003 	cmp	r2, r3
300279b0:	1a000037 	bne	30027a94 <FDTIsLie+0x1b8>
        if (FileName[2] == temp1.Name[2])
300279b4:	e59d3004 	ldr	r3, [sp, #4]
300279b8:	e2833002 	add	r3, r3, #2
300279bc:	e5d32000 	ldrb	r2, [r3]
300279c0:	e5dd3012 	ldrb	r3, [sp, #18]
300279c4:	e1520003 	cmp	r2, r3
300279c8:	1a000031 	bne	30027a94 <FDTIsLie+0x1b8>
        if (FileName[3] == temp1.Name[3])
300279cc:	e59d3004 	ldr	r3, [sp, #4]
300279d0:	e2833003 	add	r3, r3, #3
300279d4:	e5d32000 	ldrb	r2, [r3]
300279d8:	e5dd3013 	ldrb	r3, [sp, #19]
300279dc:	e1520003 	cmp	r2, r3
300279e0:	1a00002b 	bne	30027a94 <FDTIsLie+0x1b8>
        if (FileName[4] == temp1.Name[4])
300279e4:	e59d3004 	ldr	r3, [sp, #4]
300279e8:	e2833004 	add	r3, r3, #4
300279ec:	e5d32000 	ldrb	r2, [r3]
300279f0:	e5dd3014 	ldrb	r3, [sp, #20]
300279f4:	e1520003 	cmp	r2, r3
300279f8:	1a000025 	bne	30027a94 <FDTIsLie+0x1b8>
        if (FileName[5] == temp1.Name[5])
300279fc:	e59d3004 	ldr	r3, [sp, #4]
30027a00:	e2833005 	add	r3, r3, #5
30027a04:	e5d32000 	ldrb	r2, [r3]
30027a08:	e5dd3015 	ldrb	r3, [sp, #21]
30027a0c:	e1520003 	cmp	r2, r3
30027a10:	1a00001f 	bne	30027a94 <FDTIsLie+0x1b8>
        if (FileName[6] == temp1.Name[6])
30027a14:	e59d3004 	ldr	r3, [sp, #4]
30027a18:	e2833006 	add	r3, r3, #6
30027a1c:	e5d32000 	ldrb	r2, [r3]
30027a20:	e5dd3016 	ldrb	r3, [sp, #22]
30027a24:	e1520003 	cmp	r2, r3
30027a28:	1a000019 	bne	30027a94 <FDTIsLie+0x1b8>
        if (FileName[7] == temp1.Name[7])
30027a2c:	e59d3004 	ldr	r3, [sp, #4]
30027a30:	e2833007 	add	r3, r3, #7
30027a34:	e5d32000 	ldrb	r2, [r3]
30027a38:	e5dd3017 	ldrb	r3, [sp, #23]
30027a3c:	e1520003 	cmp	r2, r3
30027a40:	1a000013 	bne	30027a94 <FDTIsLie+0x1b8>
        if (FileName[8] == temp1.Name[8])
30027a44:	e59d3004 	ldr	r3, [sp, #4]
30027a48:	e2833008 	add	r3, r3, #8
30027a4c:	e5d32000 	ldrb	r2, [r3]
30027a50:	e5dd3018 	ldrb	r3, [sp, #24]
30027a54:	e1520003 	cmp	r2, r3
30027a58:	1a00000d 	bne	30027a94 <FDTIsLie+0x1b8>
        if (FileName[9] == temp1.Name[9])
30027a5c:	e59d3004 	ldr	r3, [sp, #4]
30027a60:	e2833009 	add	r3, r3, #9
30027a64:	e5d32000 	ldrb	r2, [r3]
30027a68:	e5dd3019 	ldrb	r3, [sp, #25]
30027a6c:	e1520003 	cmp	r2, r3
30027a70:	1a000007 	bne	30027a94 <FDTIsLie+0x1b8>
        if (FileName[10] == temp1.Name[10])
30027a74:	e59d3004 	ldr	r3, [sp, #4]
30027a78:	e283300a 	add	r3, r3, #10
30027a7c:	e5d32000 	ldrb	r2, [r3]
30027a80:	e5dd301a 	ldrb	r3, [sp, #26]
30027a84:	e1520003 	cmp	r2, r3
30027a88:	1a000001 	bne	30027a94 <FDTIsLie+0x1b8>
        {
            temp = FDT_EXISTS;
30027a8c:	e3a0300a 	mov	r3, #10
30027a90:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
        }
        i++;
30027a94:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30027a98:	e2833001 	add	r3, r3, #1
30027a9c:	e58d3030 	str	r3, [sp, #48]	; 0x30
    }
30027aa0:	eaffff9c 	b	30027918 <FDTIsLie+0x3c>
            break;
        }

        if (temp != RETURN_OK)
        {
            break;
30027aa4:	e1a00000 	nop			; (mov r0, r0)
        {
            temp = FDT_EXISTS;
        }
        i++;
    }
    if (FileName[0] == ESC_FDT)
30027aa8:	e59d3004 	ldr	r3, [sp, #4]
30027aac:	e5d33000 	ldrb	r3, [r3]
30027ab0:	e3530005 	cmp	r3, #5
30027ab4:	1a000002 	bne	30027ac4 <FDTIsLie+0x1e8>
    {
        FileName[0] = DEL_FDT;
30027ab8:	e59d3004 	ldr	r3, [sp, #4]
30027abc:	e3e0201a 	mvn	r2, #26
30027ac0:	e5c32000 	strb	r2, [r3]
    }
    return temp;
30027ac4:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
}
30027ac8:	e1a00003 	mov	r0, r3
30027acc:	e28dd03c 	add	sp, sp, #60	; 0x3c
30027ad0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30027ad4:	e12fff1e 	bx	lr

30027ad8 <FileInit>:
**         
** ȫ�ֱ���: ��
** ����ģ��: ��
********************************************************************************************************/
        void FileInit(void)
{
30027ad8:	e24dd008 	sub	sp, sp, #8
    HANDLE i;
    
    for (i = 0; i < MAX_OPEN_FILES; i++)
30027adc:	e3a03000 	mov	r3, #0
30027ae0:	e58d3004 	str	r3, [sp, #4]
30027ae4:	ea00000b 	b	30027b18 <FileInit+0x40>
    {
        FileInfo[i].Flags = 0;
30027ae8:	e59d2004 	ldr	r2, [sp, #4]
30027aec:	e59f1038 	ldr	r1, [pc, #56]	; 30027b2c <FileInit+0x54>
30027af0:	e1a03002 	mov	r3, r2
30027af4:	e1a03183 	lsl	r3, r3, #3
30027af8:	e0833002 	add	r3, r3, r2
30027afc:	e1a03103 	lsl	r3, r3, #2
30027b00:	e0833001 	add	r3, r3, r1
30027b04:	e3a02000 	mov	r2, #0
30027b08:	e5c32000 	strb	r2, [r3]
********************************************************************************************************/
        void FileInit(void)
{
    HANDLE i;
    
    for (i = 0; i < MAX_OPEN_FILES; i++)
30027b0c:	e59d3004 	ldr	r3, [sp, #4]
30027b10:	e2833001 	add	r3, r3, #1
30027b14:	e58d3004 	str	r3, [sp, #4]
30027b18:	e59d3004 	ldr	r3, [sp, #4]
30027b1c:	e3530009 	cmp	r3, #9
30027b20:	dafffff0 	ble	30027ae8 <FileInit+0x10>
    {
        FileInfo[i].Flags = 0;
    }
}
30027b24:	e28dd008 	add	sp, sp, #8
30027b28:	e12fff1e 	bx	lr
30027b2c:	300e3ebc 	.word	0x300e3ebc

30027b30 <FindOpenFile>:
**         
** ȫ�ֱ���: FileInfo
** ����ģ��: _GetFDTInfo,GetDrive,FindFDTInfo,
********************************************************************************************************/
        HANDLE FindOpenFile(acoral_u8 Drive, acoral_u32 DirClus, acoral_char FileName[11])
{
30027b30:	e24dd018 	sub	sp, sp, #24
30027b34:	e1a03000 	mov	r3, r0
30027b38:	e58d1008 	str	r1, [sp, #8]
30027b3c:	e58d2004 	str	r2, [sp, #4]
30027b40:	e5cd300f 	strb	r3, [sp, #15]
    HANDLE Rt;
    MY_FILE *fp;
    
    fp = FileInfo;
30027b44:	e59f31c4 	ldr	r3, [pc, #452]	; 30027d10 <FindOpenFile+0x1e0>
30027b48:	e58d3014 	str	r3, [sp, #20]
    for (Rt = 0; Rt < MAX_OPEN_FILES; Rt++)
30027b4c:	e3a03000 	mov	r3, #0
30027b50:	e58d3010 	str	r3, [sp, #16]
30027b54:	ea00005f 	b	30027cd8 <FindOpenFile+0x1a8>
    {
        if (fp->Flags != 0)
30027b58:	e59d3014 	ldr	r3, [sp, #20]
30027b5c:	e5d33000 	ldrb	r3, [r3]
30027b60:	e3530000 	cmp	r3, #0
30027b64:	0a000055 	beq	30027cc0 <FindOpenFile+0x190>
        if (fp->Drive == Drive)
30027b68:	e59d3014 	ldr	r3, [sp, #20]
30027b6c:	e5d3300c 	ldrb	r3, [r3, #12]
30027b70:	e5dd200f 	ldrb	r2, [sp, #15]
30027b74:	e1520003 	cmp	r2, r3
30027b78:	1a000050 	bne	30027cc0 <FindOpenFile+0x190>
        if (fp->DirClus == DirClus)
30027b7c:	e59d3014 	ldr	r3, [sp, #20]
30027b80:	e5932010 	ldr	r2, [r3, #16]
30027b84:	e59d3008 	ldr	r3, [sp, #8]
30027b88:	e1520003 	cmp	r2, r3
30027b8c:	1a00004b 	bne	30027cc0 <FindOpenFile+0x190>
        if (fp->Name[0] == FileName[0])
30027b90:	e59d3014 	ldr	r3, [sp, #20]
30027b94:	e5d32001 	ldrb	r2, [r3, #1]
30027b98:	e59d3004 	ldr	r3, [sp, #4]
30027b9c:	e5d33000 	ldrb	r3, [r3]
30027ba0:	e1520003 	cmp	r2, r3
30027ba4:	1a000045 	bne	30027cc0 <FindOpenFile+0x190>
        if (fp->Name[1] == FileName[1])
30027ba8:	e59d3014 	ldr	r3, [sp, #20]
30027bac:	e5d32002 	ldrb	r2, [r3, #2]
30027bb0:	e59d3004 	ldr	r3, [sp, #4]
30027bb4:	e2833001 	add	r3, r3, #1
30027bb8:	e5d33000 	ldrb	r3, [r3]
30027bbc:	e1520003 	cmp	r2, r3
30027bc0:	1a00003e 	bne	30027cc0 <FindOpenFile+0x190>
        if (fp->Name[2] == FileName[2])
30027bc4:	e59d3014 	ldr	r3, [sp, #20]
30027bc8:	e5d32003 	ldrb	r2, [r3, #3]
30027bcc:	e59d3004 	ldr	r3, [sp, #4]
30027bd0:	e2833002 	add	r3, r3, #2
30027bd4:	e5d33000 	ldrb	r3, [r3]
30027bd8:	e1520003 	cmp	r2, r3
30027bdc:	1a000037 	bne	30027cc0 <FindOpenFile+0x190>
        if (fp->Name[3] == FileName[3])
30027be0:	e59d3014 	ldr	r3, [sp, #20]
30027be4:	e5d32004 	ldrb	r2, [r3, #4]
30027be8:	e59d3004 	ldr	r3, [sp, #4]
30027bec:	e2833003 	add	r3, r3, #3
30027bf0:	e5d33000 	ldrb	r3, [r3]
30027bf4:	e1520003 	cmp	r2, r3
30027bf8:	1a000030 	bne	30027cc0 <FindOpenFile+0x190>
        if (fp->Name[4] == FileName[4])
30027bfc:	e59d3014 	ldr	r3, [sp, #20]
30027c00:	e5d32005 	ldrb	r2, [r3, #5]
30027c04:	e59d3004 	ldr	r3, [sp, #4]
30027c08:	e2833004 	add	r3, r3, #4
30027c0c:	e5d33000 	ldrb	r3, [r3]
30027c10:	e1520003 	cmp	r2, r3
30027c14:	1a000029 	bne	30027cc0 <FindOpenFile+0x190>
        if (fp->Name[5] == FileName[5])
30027c18:	e59d3014 	ldr	r3, [sp, #20]
30027c1c:	e5d32006 	ldrb	r2, [r3, #6]
30027c20:	e59d3004 	ldr	r3, [sp, #4]
30027c24:	e2833005 	add	r3, r3, #5
30027c28:	e5d33000 	ldrb	r3, [r3]
30027c2c:	e1520003 	cmp	r2, r3
30027c30:	1a000022 	bne	30027cc0 <FindOpenFile+0x190>
        if (fp->Name[6] == FileName[6])
30027c34:	e59d3014 	ldr	r3, [sp, #20]
30027c38:	e5d32007 	ldrb	r2, [r3, #7]
30027c3c:	e59d3004 	ldr	r3, [sp, #4]
30027c40:	e2833006 	add	r3, r3, #6
30027c44:	e5d33000 	ldrb	r3, [r3]
30027c48:	e1520003 	cmp	r2, r3
30027c4c:	1a00001b 	bne	30027cc0 <FindOpenFile+0x190>
        if (fp->Name[7] == FileName[7])
30027c50:	e59d3014 	ldr	r3, [sp, #20]
30027c54:	e5d32008 	ldrb	r2, [r3, #8]
30027c58:	e59d3004 	ldr	r3, [sp, #4]
30027c5c:	e2833007 	add	r3, r3, #7
30027c60:	e5d33000 	ldrb	r3, [r3]
30027c64:	e1520003 	cmp	r2, r3
30027c68:	1a000014 	bne	30027cc0 <FindOpenFile+0x190>
        if (fp->Name[8] == FileName[8])
30027c6c:	e59d3014 	ldr	r3, [sp, #20]
30027c70:	e5d32009 	ldrb	r2, [r3, #9]
30027c74:	e59d3004 	ldr	r3, [sp, #4]
30027c78:	e2833008 	add	r3, r3, #8
30027c7c:	e5d33000 	ldrb	r3, [r3]
30027c80:	e1520003 	cmp	r2, r3
30027c84:	1a00000d 	bne	30027cc0 <FindOpenFile+0x190>
        if (fp->Name[9] == FileName[9])
30027c88:	e59d3014 	ldr	r3, [sp, #20]
30027c8c:	e5d3200a 	ldrb	r2, [r3, #10]
30027c90:	e59d3004 	ldr	r3, [sp, #4]
30027c94:	e2833009 	add	r3, r3, #9
30027c98:	e5d33000 	ldrb	r3, [r3]
30027c9c:	e1520003 	cmp	r2, r3
30027ca0:	1a000006 	bne	30027cc0 <FindOpenFile+0x190>
        if (fp->Name[10] == FileName[10])
30027ca4:	e59d3014 	ldr	r3, [sp, #20]
30027ca8:	e5d3200b 	ldrb	r2, [r3, #11]
30027cac:	e59d3004 	ldr	r3, [sp, #4]
30027cb0:	e283300a 	add	r3, r3, #10
30027cb4:	e5d33000 	ldrb	r3, [r3]
30027cb8:	e1520003 	cmp	r2, r3
30027cbc:	0a000009 	beq	30027ce8 <FindOpenFile+0x1b8>
        {
            break;
        }
        fp++;
30027cc0:	e59d3014 	ldr	r3, [sp, #20]
30027cc4:	e2833024 	add	r3, r3, #36	; 0x24
30027cc8:	e58d3014 	str	r3, [sp, #20]
{
    HANDLE Rt;
    MY_FILE *fp;
    
    fp = FileInfo;
    for (Rt = 0; Rt < MAX_OPEN_FILES; Rt++)
30027ccc:	e59d3010 	ldr	r3, [sp, #16]
30027cd0:	e2833001 	add	r3, r3, #1
30027cd4:	e58d3010 	str	r3, [sp, #16]
30027cd8:	e59d3010 	ldr	r3, [sp, #16]
30027cdc:	e3530009 	cmp	r3, #9
30027ce0:	daffff9c 	ble	30027b58 <FindOpenFile+0x28>
30027ce4:	ea000000 	b	30027cec <FindOpenFile+0x1bc>
        if (fp->Name[7] == FileName[7])
        if (fp->Name[8] == FileName[8])
        if (fp->Name[9] == FileName[9])
        if (fp->Name[10] == FileName[10])
        {
            break;
30027ce8:	e1a00000 	nop			; (mov r0, r0)
        }
        fp++;
    }
    if (Rt >= MAX_OPEN_FILES)
30027cec:	e59d3010 	ldr	r3, [sp, #16]
30027cf0:	e3530009 	cmp	r3, #9
30027cf4:	da000001 	ble	30027d00 <FindOpenFile+0x1d0>
    {
        Rt = Not_Open_FILE;
30027cf8:	e3e03000 	mvn	r3, #0
30027cfc:	e58d3010 	str	r3, [sp, #16]
    }
    return Rt;
30027d00:	e59d3010 	ldr	r3, [sp, #16]
}
30027d04:	e1a00003 	mov	r0, r3
30027d08:	e28dd018 	add	sp, sp, #24
30027d0c:	e12fff1e 	bx	lr
30027d10:	300e3ebc 	.word	0x300e3ebc

30027d14 <RemoveFile>:
**        ����ο�fat.h�й��ڷ���ֵ��˵��
** ȫ�ֱ���: ��
** ����ģ��: strupr,_GetFDTInfo,GetDrive,FindFDTInfo,FATDelClusChain,DelFDT
********************************************************************************************************/
        acoral_u8 RemoveFile(acoral_char *DirFileName)
{
30027d14:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30027d18:	e24dd044 	sub	sp, sp, #68	; 0x44
30027d1c:	e58d0004 	str	r0, [sp, #4]
    acoral_u32 ClusIndex, ClusIndex1;
    acoral_u8 Drive, Rt;
    acoral_char DirName[12];
    FDT temp;
    
    strupr(DirFileName);                       /* ��Ϊ��д */
30027d20:	e59d0004 	ldr	r0, [sp, #4]
30027d24:	eb0008e3 	bl	3002a0b8 <strupr>
    ClusIndex = _GetFDTInfo(DirName, DirFileName);
30027d28:	e28d3028 	add	r3, sp, #40	; 0x28
30027d2c:	e1a00003 	mov	r0, r3
30027d30:	e59d1004 	ldr	r1, [sp, #4]
30027d34:	ebffeeb1 	bl	30023800 <_GetFDTInfo>
30027d38:	e1a03000 	mov	r3, r0
30027d3c:	e58d3034 	str	r3, [sp, #52]	; 0x34
    Rt = PATH_NOT_FIND;
30027d40:	e3a0300e 	mov	r3, #14
30027d44:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
    if (ClusIndex != BAD_CLUS)
30027d48:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30027d4c:	e373029f 	cmn	r3, #-268435447	; 0xf0000009
30027d50:	0a000032 	beq	30027e20 <RemoveFile+0x10c>
    {
        Drive = GetDrive(DirFileName);     /* ��ȡ�ļ������߼��̺� */
30027d54:	e59d0004 	ldr	r0, [sp, #4]
30027d58:	ebffeefd 	bl	30023954 <GetDrive>
30027d5c:	e1a03000 	mov	r3, r0
30027d60:	e5cd303e 	strb	r3, [sp, #62]	; 0x3e
        Rt = FindFDTInfo(&temp, Drive, ClusIndex, DirName);
30027d64:	e28d1008 	add	r1, sp, #8
30027d68:	e5dd203e 	ldrb	r2, [sp, #62]	; 0x3e
30027d6c:	e28d3028 	add	r3, sp, #40	; 0x28
30027d70:	e1a00001 	mov	r0, r1
30027d74:	e1a01002 	mov	r1, r2
30027d78:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
30027d7c:	ebfffc8c 	bl	30026fb4 <FindFDTInfo>
30027d80:	e1a03000 	mov	r3, r0
30027d84:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
        if (Rt == RETURN_OK)
30027d88:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
30027d8c:	e3530000 	cmp	r3, #0
30027d90:	1a000022 	bne	30027e20 <RemoveFile+0x10c>
        {
            Rt = NOT_FIND_FILE;
30027d94:	e3a03013 	mov	r3, #19
30027d98:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
            if ((temp.Attr & ATTR_DIRECTORY) == 0)  /* ���ļ���ɾ�� */
30027d9c:	e5dd3013 	ldrb	r3, [sp, #19]
30027da0:	e2033010 	and	r3, r3, #16
30027da4:	e3530000 	cmp	r3, #0
30027da8:	1a00001c 	bne	30027e20 <RemoveFile+0x10c>
            {
                Rt = FILE_LOCK;
30027dac:	e3a03012 	mov	r3, #18
30027db0:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
		/****************MODIFY BY GAOPAN*****************/
       //         if (FindOpenFile(Drive, ClusIndex, DirName) < MAX_OPEN_FILES)
                if (FindOpenFile(Drive, ClusIndex, DirName) == Not_Open_FILE)
30027db4:	e5dd203e 	ldrb	r2, [sp, #62]	; 0x3e
30027db8:	e28d3028 	add	r3, sp, #40	; 0x28
30027dbc:	e1a00002 	mov	r0, r2
30027dc0:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
30027dc4:	e1a02003 	mov	r2, r3
30027dc8:	ebffff58 	bl	30027b30 <FindOpenFile>
30027dcc:	e1a03000 	mov	r3, r0
30027dd0:	e3730001 	cmn	r3, #1
30027dd4:	1a000011 	bne	30027e20 <RemoveFile+0x10c>
		/****************MODIFY BY GAOPAN******END*******/

                {
                    /* �ļ�û�д򿪲�ɾ�� */
                    ClusIndex1 = temp.FstClusLO + ((acoral_u32)(temp.FstClusHI) << 16);
30027dd8:	e1dd32b2 	ldrh	r3, [sp, #34]	; 0x22
30027ddc:	e1a02003 	mov	r2, r3
30027de0:	e1dd31bc 	ldrh	r3, [sp, #28]
30027de4:	e1a03803 	lsl	r3, r3, #16
30027de8:	e0823003 	add	r3, r2, r3
30027dec:	e58d3038 	str	r3, [sp, #56]	; 0x38
                    FATDelClusChain(Drive, ClusIndex1);
30027df0:	e5dd303e 	ldrb	r3, [sp, #62]	; 0x3e
30027df4:	e1a00003 	mov	r0, r3
30027df8:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
30027dfc:	ebfff82a 	bl	30025eac <FATDelClusChain>
                    Rt = DelFDT(Drive, ClusIndex, DirName);
30027e00:	e5dd203e 	ldrb	r2, [sp, #62]	; 0x3e
30027e04:	e28d3028 	add	r3, sp, #40	; 0x28
30027e08:	e1a00002 	mov	r0, r2
30027e0c:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
30027e10:	e1a02003 	mov	r2, r3
30027e14:	ebfffd73 	bl	300273e8 <DelFDT>
30027e18:	e1a03000 	mov	r3, r0
30027e1c:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
                }
            }
        }
    }
    return Rt;
30027e20:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
}
30027e24:	e1a00003 	mov	r0, r3
30027e28:	e28dd044 	add	sp, sp, #68	; 0x44
30027e2c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30027e30:	e12fff1e 	bx	lr

30027e34 <FindOpenFileW>:
**         
** ȫ�ֱ���: FileInfo
** ����ģ��: _GetFDTInfo,GetDrive,FindFDTInfo,
********************************************************************************************************/
        HANDLE FindOpenFileW(acoral_u8 Drive, acoral_u32 DirClus, acoral_char FileName[11])
{
30027e34:	e24dd018 	sub	sp, sp, #24
30027e38:	e1a03000 	mov	r3, r0
30027e3c:	e58d1008 	str	r1, [sp, #8]
30027e40:	e58d2004 	str	r2, [sp, #4]
30027e44:	e5cd300f 	strb	r3, [sp, #15]
    HANDLE Rt;
    MY_FILE *fp;
    
    fp = FileInfo;
30027e48:	e59f31c8 	ldr	r3, [pc, #456]	; 30028018 <FindOpenFileW+0x1e4>
30027e4c:	e58d3014 	str	r3, [sp, #20]
    for (Rt = 0; Rt < MAX_OPEN_FILES; Rt++)
30027e50:	e3a03000 	mov	r3, #0
30027e54:	e58d3010 	str	r3, [sp, #16]
30027e58:	ea000060 	b	30027fe0 <FindOpenFileW+0x1ac>
    {
        if ((fp->Flags & FILE_FLAGS_WRITE) != 0)
30027e5c:	e59d3014 	ldr	r3, [sp, #20]
30027e60:	e5d33000 	ldrb	r3, [r3]
30027e64:	e2033002 	and	r3, r3, #2
30027e68:	e3530000 	cmp	r3, #0
30027e6c:	0a000055 	beq	30027fc8 <FindOpenFileW+0x194>
        if (fp->Drive == Drive)
30027e70:	e59d3014 	ldr	r3, [sp, #20]
30027e74:	e5d3300c 	ldrb	r3, [r3, #12]
30027e78:	e5dd200f 	ldrb	r2, [sp, #15]
30027e7c:	e1520003 	cmp	r2, r3
30027e80:	1a000050 	bne	30027fc8 <FindOpenFileW+0x194>
        if (fp->DirClus == DirClus)
30027e84:	e59d3014 	ldr	r3, [sp, #20]
30027e88:	e5932010 	ldr	r2, [r3, #16]
30027e8c:	e59d3008 	ldr	r3, [sp, #8]
30027e90:	e1520003 	cmp	r2, r3
30027e94:	1a00004b 	bne	30027fc8 <FindOpenFileW+0x194>
        if (fp->Name[0] == FileName[0])
30027e98:	e59d3014 	ldr	r3, [sp, #20]
30027e9c:	e5d32001 	ldrb	r2, [r3, #1]
30027ea0:	e59d3004 	ldr	r3, [sp, #4]
30027ea4:	e5d33000 	ldrb	r3, [r3]
30027ea8:	e1520003 	cmp	r2, r3
30027eac:	1a000045 	bne	30027fc8 <FindOpenFileW+0x194>
        if (fp->Name[1] == FileName[1])
30027eb0:	e59d3014 	ldr	r3, [sp, #20]
30027eb4:	e5d32002 	ldrb	r2, [r3, #2]
30027eb8:	e59d3004 	ldr	r3, [sp, #4]
30027ebc:	e2833001 	add	r3, r3, #1
30027ec0:	e5d33000 	ldrb	r3, [r3]
30027ec4:	e1520003 	cmp	r2, r3
30027ec8:	1a00003e 	bne	30027fc8 <FindOpenFileW+0x194>
        if (fp->Name[2] == FileName[2])
30027ecc:	e59d3014 	ldr	r3, [sp, #20]
30027ed0:	e5d32003 	ldrb	r2, [r3, #3]
30027ed4:	e59d3004 	ldr	r3, [sp, #4]
30027ed8:	e2833002 	add	r3, r3, #2
30027edc:	e5d33000 	ldrb	r3, [r3]
30027ee0:	e1520003 	cmp	r2, r3
30027ee4:	1a000037 	bne	30027fc8 <FindOpenFileW+0x194>
        if (fp->Name[3] == FileName[3])
30027ee8:	e59d3014 	ldr	r3, [sp, #20]
30027eec:	e5d32004 	ldrb	r2, [r3, #4]
30027ef0:	e59d3004 	ldr	r3, [sp, #4]
30027ef4:	e2833003 	add	r3, r3, #3
30027ef8:	e5d33000 	ldrb	r3, [r3]
30027efc:	e1520003 	cmp	r2, r3
30027f00:	1a000030 	bne	30027fc8 <FindOpenFileW+0x194>
        if (fp->Name[4] == FileName[4])
30027f04:	e59d3014 	ldr	r3, [sp, #20]
30027f08:	e5d32005 	ldrb	r2, [r3, #5]
30027f0c:	e59d3004 	ldr	r3, [sp, #4]
30027f10:	e2833004 	add	r3, r3, #4
30027f14:	e5d33000 	ldrb	r3, [r3]
30027f18:	e1520003 	cmp	r2, r3
30027f1c:	1a000029 	bne	30027fc8 <FindOpenFileW+0x194>
        if (fp->Name[5] == FileName[5])
30027f20:	e59d3014 	ldr	r3, [sp, #20]
30027f24:	e5d32006 	ldrb	r2, [r3, #6]
30027f28:	e59d3004 	ldr	r3, [sp, #4]
30027f2c:	e2833005 	add	r3, r3, #5
30027f30:	e5d33000 	ldrb	r3, [r3]
30027f34:	e1520003 	cmp	r2, r3
30027f38:	1a000022 	bne	30027fc8 <FindOpenFileW+0x194>
        if (fp->Name[6] == FileName[6])
30027f3c:	e59d3014 	ldr	r3, [sp, #20]
30027f40:	e5d32007 	ldrb	r2, [r3, #7]
30027f44:	e59d3004 	ldr	r3, [sp, #4]
30027f48:	e2833006 	add	r3, r3, #6
30027f4c:	e5d33000 	ldrb	r3, [r3]
30027f50:	e1520003 	cmp	r2, r3
30027f54:	1a00001b 	bne	30027fc8 <FindOpenFileW+0x194>
        if (fp->Name[7] == FileName[7])
30027f58:	e59d3014 	ldr	r3, [sp, #20]
30027f5c:	e5d32008 	ldrb	r2, [r3, #8]
30027f60:	e59d3004 	ldr	r3, [sp, #4]
30027f64:	e2833007 	add	r3, r3, #7
30027f68:	e5d33000 	ldrb	r3, [r3]
30027f6c:	e1520003 	cmp	r2, r3
30027f70:	1a000014 	bne	30027fc8 <FindOpenFileW+0x194>
        if (fp->Name[8] == FileName[8])
30027f74:	e59d3014 	ldr	r3, [sp, #20]
30027f78:	e5d32009 	ldrb	r2, [r3, #9]
30027f7c:	e59d3004 	ldr	r3, [sp, #4]
30027f80:	e2833008 	add	r3, r3, #8
30027f84:	e5d33000 	ldrb	r3, [r3]
30027f88:	e1520003 	cmp	r2, r3
30027f8c:	1a00000d 	bne	30027fc8 <FindOpenFileW+0x194>
        if (fp->Name[9] == FileName[9])
30027f90:	e59d3014 	ldr	r3, [sp, #20]
30027f94:	e5d3200a 	ldrb	r2, [r3, #10]
30027f98:	e59d3004 	ldr	r3, [sp, #4]
30027f9c:	e2833009 	add	r3, r3, #9
30027fa0:	e5d33000 	ldrb	r3, [r3]
30027fa4:	e1520003 	cmp	r2, r3
30027fa8:	1a000006 	bne	30027fc8 <FindOpenFileW+0x194>
        if (fp->Name[10] == FileName[10])
30027fac:	e59d3014 	ldr	r3, [sp, #20]
30027fb0:	e5d3200b 	ldrb	r2, [r3, #11]
30027fb4:	e59d3004 	ldr	r3, [sp, #4]
30027fb8:	e283300a 	add	r3, r3, #10
30027fbc:	e5d33000 	ldrb	r3, [r3]
30027fc0:	e1520003 	cmp	r2, r3
30027fc4:	0a000009 	beq	30027ff0 <FindOpenFileW+0x1bc>
        {
            break;
        }
        fp++;
30027fc8:	e59d3014 	ldr	r3, [sp, #20]
30027fcc:	e2833024 	add	r3, r3, #36	; 0x24
30027fd0:	e58d3014 	str	r3, [sp, #20]
{
    HANDLE Rt;
    MY_FILE *fp;
    
    fp = FileInfo;
    for (Rt = 0; Rt < MAX_OPEN_FILES; Rt++)
30027fd4:	e59d3010 	ldr	r3, [sp, #16]
30027fd8:	e2833001 	add	r3, r3, #1
30027fdc:	e58d3010 	str	r3, [sp, #16]
30027fe0:	e59d3010 	ldr	r3, [sp, #16]
30027fe4:	e3530009 	cmp	r3, #9
30027fe8:	daffff9b 	ble	30027e5c <FindOpenFileW+0x28>
30027fec:	ea000000 	b	30027ff4 <FindOpenFileW+0x1c0>
        if (fp->Name[7] == FileName[7])
        if (fp->Name[8] == FileName[8])
        if (fp->Name[9] == FileName[9])
        if (fp->Name[10] == FileName[10])
        {
            break;
30027ff0:	e1a00000 	nop			; (mov r0, r0)
        }
        fp++;
    }
    if (Rt >= MAX_OPEN_FILES)
30027ff4:	e59d3010 	ldr	r3, [sp, #16]
30027ff8:	e3530009 	cmp	r3, #9
30027ffc:	da000001 	ble	30028008 <FindOpenFileW+0x1d4>
    {
        Rt = Not_Open_FILE;
30028000:	e3e03000 	mvn	r3, #0
30028004:	e58d3010 	str	r3, [sp, #16]
    }
    return Rt;
30028008:	e59d3010 	ldr	r3, [sp, #16]
}
3002800c:	e1a00003 	mov	r0, r3
30028010:	e28dd018 	add	sp, sp, #24
30028014:	e12fff1e 	bx	lr
30028018:	300e3ebc 	.word	0x300e3ebc

3002801c <_FileOpenR>:
**         
** ȫ�ֱ���: FileInfo
** ����ģ��: _GetFDTInfo,GetDrive,FindFDTInfo,
********************************************************************************************************/
        HANDLE _FileOpenR(acoral_char *DirFileName)
{
3002801c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30028020:	e24dd034 	sub	sp, sp, #52	; 0x34
30028024:	e58d0004 	str	r0, [sp, #4]
    MY_FILE *fp;
    HANDLE Rt;
    FDT FileFDT;
    
    /* ���ҿ����ļ��Ǽ��� */
    for (Rt = 0; Rt < MAX_OPEN_FILES; Rt++)
30028028:	e3a03000 	mov	r3, #0
3002802c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
30028030:	ea00000c 	b	30028068 <_FileOpenR+0x4c>
    {
        if (FileInfo[Rt].Flags == 0)
30028034:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30028038:	e59f115c 	ldr	r1, [pc, #348]	; 3002819c <_FileOpenR+0x180>
3002803c:	e1a03002 	mov	r3, r2
30028040:	e1a03183 	lsl	r3, r3, #3
30028044:	e0833002 	add	r3, r3, r2
30028048:	e1a03103 	lsl	r3, r3, #2
3002804c:	e0833001 	add	r3, r3, r1
30028050:	e5d33000 	ldrb	r3, [r3]
30028054:	e3530000 	cmp	r3, #0
30028058:	0a000006 	beq	30028078 <_FileOpenR+0x5c>
    MY_FILE *fp;
    HANDLE Rt;
    FDT FileFDT;
    
    /* ���ҿ����ļ��Ǽ��� */
    for (Rt = 0; Rt < MAX_OPEN_FILES; Rt++)
3002805c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30028060:	e2833001 	add	r3, r3, #1
30028064:	e58d302c 	str	r3, [sp, #44]	; 0x2c
30028068:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3002806c:	e3530009 	cmp	r3, #9
30028070:	daffffef 	ble	30028034 <_FileOpenR+0x18>
30028074:	ea000000 	b	3002807c <_FileOpenR+0x60>
    {
        if (FileInfo[Rt].Flags == 0)
        {
            break;
30028078:	e1a00000 	nop			; (mov r0, r0)
        }
    }
    
    if (Rt < MAX_OPEN_FILES)
3002807c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30028080:	e3530009 	cmp	r3, #9
30028084:	ca00003f 	bgt	30028188 <_FileOpenR+0x16c>
    {
        fp = FileInfo + Rt;
30028088:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
3002808c:	e1a03002 	mov	r3, r2
30028090:	e1a03183 	lsl	r3, r3, #3
30028094:	e0833002 	add	r3, r3, r2
30028098:	e1a03103 	lsl	r3, r3, #2
3002809c:	e1a02003 	mov	r2, r3
300280a0:	e59f30f4 	ldr	r3, [pc, #244]	; 3002819c <_FileOpenR+0x180>
300280a4:	e0823003 	add	r3, r2, r3
300280a8:	e58d3028 	str	r3, [sp, #40]	; 0x28
        
        /* ��ȡĿ¼��ʼ�غź��ļ��� */
        fp->DirClus = _GetFDTInfo(fp->Name, DirFileName);
300280ac:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300280b0:	e2833001 	add	r3, r3, #1
300280b4:	e1a00003 	mov	r0, r3
300280b8:	e59d1004 	ldr	r1, [sp, #4]
300280bc:	ebffedcf 	bl	30023800 <_GetFDTInfo>
300280c0:	e1a02000 	mov	r2, r0
300280c4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300280c8:	e5832010 	str	r2, [r3, #16]
        if (fp->DirClus < BAD_CLUS)
300280cc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300280d0:	e5933010 	ldr	r3, [r3, #16]
300280d4:	e37302af 	cmn	r3, #-268435446	; 0xf000000a
300280d8:	8a00002a 	bhi	30028188 <_FileOpenR+0x16c>
        {
            fp->Drive = GetDrive(DirFileName);     /* ��ȡ�ļ������߼��̺� */
300280dc:	e59d0004 	ldr	r0, [sp, #4]
300280e0:	ebffee1b 	bl	30023954 <GetDrive>
300280e4:	e1a03000 	mov	r3, r0
300280e8:	e1a02003 	mov	r2, r3
300280ec:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300280f0:	e5c3200c 	strb	r2, [r3, #12]
            
            /* ��ȡ�ļ���Ϣ */
            if (FindFDTInfo(&FileFDT, fp->Drive, fp->DirClus, fp->Name) == RETURN_OK)
300280f4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300280f8:	e5d3100c 	ldrb	r1, [r3, #12]
300280fc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30028100:	e5932010 	ldr	r2, [r3, #16]
30028104:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30028108:	e2833001 	add	r3, r3, #1
3002810c:	e28d0008 	add	r0, sp, #8
30028110:	ebfffba7 	bl	30026fb4 <FindFDTInfo>
30028114:	e1a03000 	mov	r3, r0
30028118:	e3530000 	cmp	r3, #0
3002811c:	1a000019 	bne	30028188 <_FileOpenR+0x16c>
            {
                if ((FileFDT.Attr & ATTR_DIRECTORY) == 0)
30028120:	e5dd3013 	ldrb	r3, [sp, #19]
30028124:	e2033010 	and	r3, r3, #16
30028128:	e3530000 	cmp	r3, #0
3002812c:	1a000015 	bne	30028188 <_FileOpenR+0x16c>
                {
                    fp->Flags = FILE_FLAGS_READ;
30028130:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30028134:	e3a02001 	mov	r2, #1
30028138:	e5c32000 	strb	r2, [r3]
                    fp->FileSize = FileFDT.FileSize;
3002813c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30028140:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30028144:	e5832014 	str	r2, [r3, #20]
                    fp->FstClus = FileFDT.FstClusLO | (acoral_u32)FileFDT.FstClusHI << 16;
30028148:	e1dd32b2 	ldrh	r3, [sp, #34]	; 0x22
3002814c:	e1a02003 	mov	r2, r3
30028150:	e1dd31bc 	ldrh	r3, [sp, #28]
30028154:	e1a03803 	lsl	r3, r3, #16
30028158:	e1822003 	orr	r2, r2, r3
3002815c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30028160:	e5832018 	str	r2, [r3, #24]
                    fp->Clus = fp->FstClus;
30028164:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30028168:	e5932018 	ldr	r2, [r3, #24]
3002816c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30028170:	e583201c 	str	r2, [r3, #28]
                    fp->Offset = 0;
30028174:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30028178:	e3a02000 	mov	r2, #0
3002817c:	e5832020 	str	r2, [r3, #32]
                    return Rt;
30028180:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30028184:	ea000000 	b	3002818c <_FileOpenR+0x170>
                }
            }
        }
    }
    return Not_Open_FILE;
30028188:	e3e03000 	mvn	r3, #0
}
3002818c:	e1a00003 	mov	r0, r3
30028190:	e28dd034 	add	sp, sp, #52	; 0x34
30028194:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30028198:	e12fff1e 	bx	lr
3002819c:	300e3ebc 	.word	0x300e3ebc

300281a0 <_FileOpenW>:
**         
** ȫ�ֱ���: FileInfo
** ����ģ��: _GetFDTInfo,GetDrive,FindFDTInfo,
********************************************************************************************************/
        HANDLE _FileOpenW(acoral_char *DirFileName)
{
300281a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300281a4:	e24dd03c 	sub	sp, sp, #60	; 0x3c
300281a8:	e58d0004 	str	r0, [sp, #4]
    MY_FILE *fp;
    FDT temp;
    HANDLE Rt;
    acoral_u8 i;

    for (Rt = 0; Rt < MAX_OPEN_FILES; Rt++)
300281ac:	e3a03000 	mov	r3, #0
300281b0:	e58d3030 	str	r3, [sp, #48]	; 0x30
300281b4:	ea00000c 	b	300281ec <_FileOpenW+0x4c>
    {
        if (FileInfo[Rt].Flags == 0)
300281b8:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
300281bc:	e59f127c 	ldr	r1, [pc, #636]	; 30028440 <_FileOpenW+0x2a0>
300281c0:	e1a03002 	mov	r3, r2
300281c4:	e1a03183 	lsl	r3, r3, #3
300281c8:	e0833002 	add	r3, r3, r2
300281cc:	e1a03103 	lsl	r3, r3, #2
300281d0:	e0833001 	add	r3, r3, r1
300281d4:	e5d33000 	ldrb	r3, [r3]
300281d8:	e3530000 	cmp	r3, #0
300281dc:	0a000006 	beq	300281fc <_FileOpenW+0x5c>
    MY_FILE *fp;
    FDT temp;
    HANDLE Rt;
    acoral_u8 i;

    for (Rt = 0; Rt < MAX_OPEN_FILES; Rt++)
300281e0:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
300281e4:	e2833001 	add	r3, r3, #1
300281e8:	e58d3030 	str	r3, [sp, #48]	; 0x30
300281ec:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
300281f0:	e3530009 	cmp	r3, #9
300281f4:	daffffef 	ble	300281b8 <_FileOpenW+0x18>
300281f8:	ea000000 	b	30028200 <_FileOpenW+0x60>
    {
        if (FileInfo[Rt].Flags == 0)
        {
            break;
300281fc:	e1a00000 	nop			; (mov r0, r0)
        }
    }
    
    if (Rt < MAX_OPEN_FILES)
30028200:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30028204:	e3530009 	cmp	r3, #9
30028208:	ca000087 	bgt	3002842c <_FileOpenW+0x28c>
    {
        fp = FileInfo + Rt;
3002820c:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
30028210:	e1a03002 	mov	r3, r2
30028214:	e1a03183 	lsl	r3, r3, #3
30028218:	e0833002 	add	r3, r3, r2
3002821c:	e1a03103 	lsl	r3, r3, #2
30028220:	e1a02003 	mov	r2, r3
30028224:	e59f3214 	ldr	r3, [pc, #532]	; 30028440 <_FileOpenW+0x2a0>
30028228:	e0823003 	add	r3, r2, r3
3002822c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
        
        /* ��ȡĿ¼��ʼ�غź��ļ��� */
        fp->DirClus = _GetFDTInfo(fp->Name, DirFileName);
30028230:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30028234:	e2833001 	add	r3, r3, #1
30028238:	e1a00003 	mov	r0, r3
3002823c:	e59d1004 	ldr	r1, [sp, #4]
30028240:	ebffed6e 	bl	30023800 <_GetFDTInfo>
30028244:	e1a02000 	mov	r2, r0
30028248:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3002824c:	e5832010 	str	r2, [r3, #16]
        if (fp->DirClus < BAD_CLUS)
30028250:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30028254:	e5933010 	ldr	r3, [r3, #16]
30028258:	e37302af 	cmn	r3, #-268435446	; 0xf000000a
3002825c:	8a000072 	bhi	3002842c <_FileOpenW+0x28c>
        {
            fp->Drive = GetDrive(DirFileName);     /* ��ȡ�ļ������߼��̺� */
30028260:	e59d0004 	ldr	r0, [sp, #4]
30028264:	ebffedba 	bl	30023954 <GetDrive>
30028268:	e1a03000 	mov	r3, r0
3002826c:	e1a02003 	mov	r2, r3
30028270:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30028274:	e5c3200c 	strb	r2, [r3, #12]

            /* �ļ��Ѿ��Զ�д��ʽ�򿪣������ٴ��Զ�д��ʽ�� */
            if (FindOpenFileW(fp->Drive, fp->DirClus, fp->Name) == Not_Open_FILE)
30028278:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3002827c:	e5d3100c 	ldrb	r1, [r3, #12]
30028280:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30028284:	e5932010 	ldr	r2, [r3, #16]
30028288:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3002828c:	e2833001 	add	r3, r3, #1
30028290:	e1a00001 	mov	r0, r1
30028294:	e1a01002 	mov	r1, r2
30028298:	e1a02003 	mov	r2, r3
3002829c:	ebfffee4 	bl	30027e34 <FindOpenFileW>
300282a0:	e1a03000 	mov	r3, r0
300282a4:	e3730001 	cmn	r3, #1
300282a8:	1a00005f 	bne	3002842c <_FileOpenW+0x28c>
            {
                if (FindFDTInfo(&temp, fp->Drive, fp->DirClus, fp->Name) == RETURN_OK)
300282ac:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300282b0:	e5d3100c 	ldrb	r1, [r3, #12]
300282b4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300282b8:	e5932010 	ldr	r2, [r3, #16]
300282bc:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300282c0:	e2833001 	add	r3, r3, #1
300282c4:	e28d000c 	add	r0, sp, #12
300282c8:	ebfffb39 	bl	30026fb4 <FindFDTInfo>
300282cc:	e1a03000 	mov	r3, r0
300282d0:	e3530000 	cmp	r3, #0
300282d4:	1a00000c 	bne	3002830c <_FileOpenW+0x16c>
                {
                    if ((temp.Attr & ATTR_DIRECTORY) != 0)
300282d8:	e5dd3017 	ldrb	r3, [sp, #23]
300282dc:	e2033010 	and	r3, r3, #16
300282e0:	e3530000 	cmp	r3, #0
300282e4:	0a000001 	beq	300282f0 <_FileOpenW+0x150>
                    {
                       return Not_Open_FILE;
300282e8:	e3e03000 	mvn	r3, #0
300282ec:	ea00004f 	b	30028430 <_FileOpenW+0x290>
                    }
                    if (RemoveFile(DirFileName) != RETURN_OK)   /* ɾ���ļ� */
300282f0:	e59d0004 	ldr	r0, [sp, #4]
300282f4:	ebfffe86 	bl	30027d14 <RemoveFile>
300282f8:	e1a03000 	mov	r3, r0
300282fc:	e3530000 	cmp	r3, #0
30028300:	0a000001 	beq	3002830c <_FileOpenW+0x16c>
                    {
                       return Not_Open_FILE;
30028304:	e3e03000 	mvn	r3, #0
30028308:	ea000048 	b	30028430 <_FileOpenW+0x290>
                    }
                }
                /* �����ļ� */
                for (i = 0; i < 11; i++)
3002830c:	e3a03000 	mov	r3, #0
30028310:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
30028314:	ea00000e 	b	30028354 <_FileOpenW+0x1b4>
                {
                    temp.Name[i] = fp->Name[i];
30028318:	e5dd1037 	ldrb	r1, [sp, #55]	; 0x37
3002831c:	e5dd2037 	ldrb	r2, [sp, #55]	; 0x37
30028320:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
30028324:	e3a03001 	mov	r3, #1
30028328:	e0802002 	add	r2, r0, r2
3002832c:	e0823003 	add	r3, r2, r3
30028330:	e5d32000 	ldrb	r2, [r3]
30028334:	e3e0302b 	mvn	r3, #43	; 0x2b
30028338:	e28d0038 	add	r0, sp, #56	; 0x38
3002833c:	e0801001 	add	r1, r0, r1
30028340:	e0813003 	add	r3, r1, r3
30028344:	e5c32000 	strb	r2, [r3]
                    {
                       return Not_Open_FILE;
                    }
                }
                /* �����ļ� */
                for (i = 0; i < 11; i++)
30028348:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
3002834c:	e2833001 	add	r3, r3, #1
30028350:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
30028354:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
30028358:	e353000a 	cmp	r3, #10
3002835c:	9affffed 	bls	30028318 <_FileOpenW+0x178>
                {
                    temp.Name[i] = fp->Name[i];
                }
                temp.Attr = 0;
30028360:	e3a03000 	mov	r3, #0
30028364:	e5cd3017 	strb	r3, [sp, #23]
                temp.FileSize = 0;
30028368:	e3a03000 	mov	r3, #0
3002836c:	e58d3028 	str	r3, [sp, #40]	; 0x28

                temp.NTRes = 0;
30028370:	e3a03000 	mov	r3, #0
30028374:	e5cd3018 	strb	r3, [sp, #24]
                temp.CrtTimeTenth = 0;
30028378:	e3a03000 	mov	r3, #0
3002837c:	e5cd3019 	strb	r3, [sp, #25]
                temp.CrtTime = 0;
30028380:	e3a03000 	mov	r3, #0
30028384:	e1cd31ba 	strh	r3, [sp, #26]
                temp.CrtDate = 0;
30028388:	e3a03000 	mov	r3, #0
3002838c:	e1cd31bc 	strh	r3, [sp, #28]
                temp.LstAccDate = 0;
30028390:	e3a03000 	mov	r3, #0
30028394:	e1cd31be 	strh	r3, [sp, #30]
                temp.WrtTime = 0;
30028398:	e3a03000 	mov	r3, #0
3002839c:	e1cd32b2 	strh	r3, [sp, #34]	; 0x22
                temp.WrtDate = 0;
300283a0:	e3a03000 	mov	r3, #0
300283a4:	e1cd32b4 	strh	r3, [sp, #36]	; 0x24

                temp.FstClusLO = 0;
300283a8:	e3a03000 	mov	r3, #0
300283ac:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
                temp.FstClusHI = 0;
300283b0:	e3a03000 	mov	r3, #0
300283b4:	e1cd32b0 	strh	r3, [sp, #32]
                if (AddFDT(fp->Drive, fp->DirClus, &temp) == RETURN_OK)       /* �����ļ� */
300283b8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300283bc:	e5d3100c 	ldrb	r1, [r3, #12]
300283c0:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300283c4:	e5932010 	ldr	r2, [r3, #16]
300283c8:	e28d300c 	add	r3, sp, #12
300283cc:	e1a00001 	mov	r0, r1
300283d0:	e1a01002 	mov	r1, r2
300283d4:	e1a02003 	mov	r2, r3
300283d8:	ebfffb7c 	bl	300271d0 <AddFDT>
300283dc:	e1a03000 	mov	r3, r0
300283e0:	e3530000 	cmp	r3, #0
300283e4:	1a000010 	bne	3002842c <_FileOpenW+0x28c>
                {
                    /* �����ļ���Ϣ */
                    fp->Flags = FILE_FLAGS_READ | FILE_FLAGS_WRITE;
300283e8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300283ec:	e3a02003 	mov	r2, #3
300283f0:	e5c32000 	strb	r2, [r3]
                    fp->FileSize = 0;
300283f4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300283f8:	e3a02000 	mov	r2, #0
300283fc:	e5832014 	str	r2, [r3, #20]
                    fp->FstClus = 0;
30028400:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30028404:	e3a02000 	mov	r2, #0
30028408:	e5832018 	str	r2, [r3, #24]
                    fp->Clus = 0;
3002840c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30028410:	e3a02000 	mov	r2, #0
30028414:	e583201c 	str	r2, [r3, #28]
                    fp->Offset = 0;
30028418:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3002841c:	e3a02000 	mov	r2, #0
30028420:	e5832020 	str	r2, [r3, #32]
                    return Rt;
30028424:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30028428:	ea000000 	b	30028430 <_FileOpenW+0x290>
                }
            }
        }
    }
    return Not_Open_FILE;
3002842c:	e3e03000 	mvn	r3, #0
}
30028430:	e1a00003 	mov	r0, r3
30028434:	e28dd03c 	add	sp, sp, #60	; 0x3c
30028438:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002843c:	e12fff1e 	bx	lr
30028440:	300e3ebc 	.word	0x300e3ebc

30028444 <_FileOpenRW>:
**         
** ȫ�ֱ���: ��
** ����ģ��: _FileOpenR,_FileOpenW
********************************************************************************************************/
        HANDLE _FileOpenRW(acoral_char *DirFileName)
{
30028444:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30028448:	e24dd014 	sub	sp, sp, #20
3002844c:	e58d0004 	str	r0, [sp, #4]
    HANDLE Rt;
    
    Rt = _FileOpenR(DirFileName);
30028450:	e59d0004 	ldr	r0, [sp, #4]
30028454:	ebfffef0 	bl	3002801c <_FileOpenR>
30028458:	e1a03000 	mov	r3, r0
3002845c:	e58d300c 	str	r3, [sp, #12]
    if (Rt == Not_Open_FILE)
30028460:	e59d300c 	ldr	r3, [sp, #12]
30028464:	e3730001 	cmn	r3, #1
30028468:	1a000004 	bne	30028480 <_FileOpenRW+0x3c>
    {
        Rt = _FileOpenW(DirFileName);
3002846c:	e59d0004 	ldr	r0, [sp, #4]
30028470:	ebffff4a 	bl	300281a0 <_FileOpenW>
30028474:	e1a03000 	mov	r3, r0
30028478:	e58d300c 	str	r3, [sp, #12]
3002847c:	ea00003f 	b	30028580 <_FileOpenRW+0x13c>
    }
    else
    {
        if (FindOpenFileW(FileInfo[Rt].Drive, FileInfo[Rt].DirClus, FileInfo[Rt].Name) == Not_Open_FILE)
30028480:	e59d200c 	ldr	r2, [sp, #12]
30028484:	e59f0108 	ldr	r0, [pc, #264]	; 30028594 <_FileOpenRW+0x150>
30028488:	e3a01008 	mov	r1, #8
3002848c:	e1a03002 	mov	r3, r2
30028490:	e1a03183 	lsl	r3, r3, #3
30028494:	e0833002 	add	r3, r3, r2
30028498:	e1a03103 	lsl	r3, r3, #2
3002849c:	e0833000 	add	r3, r3, r0
300284a0:	e0833001 	add	r3, r3, r1
300284a4:	e5d30004 	ldrb	r0, [r3, #4]
300284a8:	e59d200c 	ldr	r2, [sp, #12]
300284ac:	e59fc0e0 	ldr	ip, [pc, #224]	; 30028594 <_FileOpenRW+0x150>
300284b0:	e3a01010 	mov	r1, #16
300284b4:	e1a03002 	mov	r3, r2
300284b8:	e1a03183 	lsl	r3, r3, #3
300284bc:	e0833002 	add	r3, r3, r2
300284c0:	e1a03103 	lsl	r3, r3, #2
300284c4:	e083300c 	add	r3, r3, ip
300284c8:	e0833001 	add	r3, r3, r1
300284cc:	e5931000 	ldr	r1, [r3]
300284d0:	e59d200c 	ldr	r2, [sp, #12]
300284d4:	e1a03002 	mov	r3, r2
300284d8:	e1a03183 	lsl	r3, r3, #3
300284dc:	e0833002 	add	r3, r3, r2
300284e0:	e1a02103 	lsl	r2, r3, #2
300284e4:	e59f30a8 	ldr	r3, [pc, #168]	; 30028594 <_FileOpenRW+0x150>
300284e8:	e0823003 	add	r3, r2, r3
300284ec:	e2833001 	add	r3, r3, #1
300284f0:	e1a02003 	mov	r2, r3
300284f4:	ebfffe4e 	bl	30027e34 <FindOpenFileW>
300284f8:	e1a03000 	mov	r3, r0
300284fc:	e3730001 	cmn	r3, #1
30028500:	1a000013 	bne	30028554 <_FileOpenRW+0x110>
        {
            FileInfo[Rt].Flags |=  (FILE_FLAGS_WRITE | FILE_FLAGS_READ);
30028504:	e59d200c 	ldr	r2, [sp, #12]
30028508:	e59d100c 	ldr	r1, [sp, #12]
3002850c:	e59f0080 	ldr	r0, [pc, #128]	; 30028594 <_FileOpenRW+0x150>
30028510:	e1a03001 	mov	r3, r1
30028514:	e1a03183 	lsl	r3, r3, #3
30028518:	e0833001 	add	r3, r3, r1
3002851c:	e1a03103 	lsl	r3, r3, #2
30028520:	e0833000 	add	r3, r3, r0
30028524:	e5d33000 	ldrb	r3, [r3]
30028528:	e3833003 	orr	r3, r3, #3
3002852c:	e20310ff 	and	r1, r3, #255	; 0xff
30028530:	e59f005c 	ldr	r0, [pc, #92]	; 30028594 <_FileOpenRW+0x150>
30028534:	e1a03002 	mov	r3, r2
30028538:	e1a03183 	lsl	r3, r3, #3
3002853c:	e0833002 	add	r3, r3, r2
30028540:	e1a03103 	lsl	r3, r3, #2
30028544:	e0833000 	add	r3, r3, r0
30028548:	e1a02001 	mov	r2, r1
3002854c:	e5c32000 	strb	r2, [r3]
30028550:	ea00000a 	b	30028580 <_FileOpenRW+0x13c>
        }
        else
        {
            FileInfo[Rt].Flags = 0;
30028554:	e59d200c 	ldr	r2, [sp, #12]
30028558:	e59f1034 	ldr	r1, [pc, #52]	; 30028594 <_FileOpenRW+0x150>
3002855c:	e1a03002 	mov	r3, r2
30028560:	e1a03183 	lsl	r3, r3, #3
30028564:	e0833002 	add	r3, r3, r2
30028568:	e1a03103 	lsl	r3, r3, #2
3002856c:	e0833001 	add	r3, r3, r1
30028570:	e3a02000 	mov	r2, #0
30028574:	e5c32000 	strb	r2, [r3]
            Rt = Not_Open_FILE;
30028578:	e3e03000 	mvn	r3, #0
3002857c:	e58d300c 	str	r3, [sp, #12]
        }
    }
    return Rt;
30028580:	e59d300c 	ldr	r3, [sp, #12]
}
30028584:	e1a00003 	mov	r0, r3
30028588:	e28dd014 	add	sp, sp, #20
3002858c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30028590:	e12fff1e 	bx	lr
30028594:	300e3ebc 	.word	0x300e3ebc

30028598 <FileOpen>:
**         
** ȫ�ֱ���: ��
** ����ģ��: _FileOpenR,_FileOpenW,_FileOpenRW
********************************************************************************************************/
        HANDLE FileOpen(acoral_char *DirFileName, acoral_char *Type)
{
30028598:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002859c:	e24dd014 	sub	sp, sp, #20
300285a0:	e58d0004 	str	r0, [sp, #4]
300285a4:	e58d1000 	str	r1, [sp]
    HANDLE Rt;

    Rt = Not_Open_FILE;    
300285a8:	e3e03000 	mvn	r3, #0
300285ac:	e58d300c 	str	r3, [sp, #12]
    strupr(Type);
300285b0:	e59d0000 	ldr	r0, [sp]
300285b4:	eb0006bf 	bl	3002a0b8 <strupr>
    strupr(DirFileName);
300285b8:	e59d0004 	ldr	r0, [sp, #4]
300285bc:	eb0006bd 	bl	3002a0b8 <strupr>
    if (Type[0] == 'R')
300285c0:	e59d3000 	ldr	r3, [sp]
300285c4:	e5d33000 	ldrb	r3, [r3]
300285c8:	e3530052 	cmp	r3, #82	; 0x52
300285cc:	1a00000f 	bne	30028610 <FileOpen+0x78>
    {
        if (Type[1] == 'W')
300285d0:	e59d3000 	ldr	r3, [sp]
300285d4:	e2833001 	add	r3, r3, #1
300285d8:	e5d33000 	ldrb	r3, [r3]
300285dc:	e3530057 	cmp	r3, #87	; 0x57
300285e0:	1a000004 	bne	300285f8 <FileOpen+0x60>
        {
            Rt = _FileOpenRW(DirFileName);
300285e4:	e59d0004 	ldr	r0, [sp, #4]
300285e8:	ebffff95 	bl	30028444 <_FileOpenRW>
300285ec:	e1a03000 	mov	r3, r0
300285f0:	e58d300c 	str	r3, [sp, #12]
300285f4:	ea000003 	b	30028608 <FileOpen+0x70>
        }
        else
        {
            Rt = _FileOpenR(DirFileName);
300285f8:	e59d0004 	ldr	r0, [sp, #4]
300285fc:	ebfffe86 	bl	3002801c <_FileOpenR>
30028600:	e1a03000 	mov	r3, r0
30028604:	e58d300c 	str	r3, [sp, #12]
        }
        return Rt;
30028608:	e59d300c 	ldr	r3, [sp, #12]
3002860c:	ea000012 	b	3002865c <FileOpen+0xc4>
    }
    if (Type[0] == 'W')
30028610:	e59d3000 	ldr	r3, [sp]
30028614:	e5d33000 	ldrb	r3, [r3]
30028618:	e3530057 	cmp	r3, #87	; 0x57
3002861c:	1a00000d 	bne	30028658 <FileOpen+0xc0>
    {
        if (Type[1] == 'R')
30028620:	e59d3000 	ldr	r3, [sp]
30028624:	e2833001 	add	r3, r3, #1
30028628:	e5d33000 	ldrb	r3, [r3]
3002862c:	e3530052 	cmp	r3, #82	; 0x52
30028630:	1a000004 	bne	30028648 <FileOpen+0xb0>
        {
            Rt = _FileOpenRW(DirFileName);
30028634:	e59d0004 	ldr	r0, [sp, #4]
30028638:	ebffff81 	bl	30028444 <_FileOpenRW>
3002863c:	e1a03000 	mov	r3, r0
30028640:	e58d300c 	str	r3, [sp, #12]
30028644:	ea000003 	b	30028658 <FileOpen+0xc0>
        }
        else
        {
            Rt = _FileOpenW(DirFileName);
30028648:	e59d0004 	ldr	r0, [sp, #4]
3002864c:	ebfffed3 	bl	300281a0 <_FileOpenW>
30028650:	e1a03000 	mov	r3, r0
30028654:	e58d300c 	str	r3, [sp, #12]
        }
    }
    return Rt;
30028658:	e59d300c 	ldr	r3, [sp, #12]
}
3002865c:	e1a00003 	mov	r0, r3
30028660:	e28dd014 	add	sp, sp, #20
30028664:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30028668:	e12fff1e 	bx	lr

3002866c <FileClose>:
**        ����ο�fat.h�й��ڷ���ֵ��˵�� 
** ȫ�ֱ���: ��
** ����ģ��: ��
********************************************************************************************************/
        acoral_u8 FileClose(HANDLE Handle)
{
3002866c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30028670:	e24dd034 	sub	sp, sp, #52	; 0x34
30028674:	e58d0004 	str	r0, [sp, #4]
    acoral_u8 Rt;
    FDT FileFDT;
    MY_FILE *fp;
    
    Rt = PARAMETER_ERR;
30028678:	e3e03000 	mvn	r3, #0
3002867c:	e5cd302b 	strb	r3, [sp, #43]	; 0x2b
    if (Handle >= 0 && Handle < MAX_OPEN_FILES)
30028680:	e59d3004 	ldr	r3, [sp, #4]
30028684:	e3530000 	cmp	r3, #0
30028688:	ba000044 	blt	300287a0 <FileClose+0x134>
3002868c:	e59d3004 	ldr	r3, [sp, #4]
30028690:	e3530009 	cmp	r3, #9
30028694:	ca000041 	bgt	300287a0 <FileClose+0x134>
    {
        Rt = RETURN_OK;
30028698:	e3a03000 	mov	r3, #0
3002869c:	e5cd302b 	strb	r3, [sp, #43]	; 0x2b
        fp = FileInfo + Handle;
300286a0:	e59d2004 	ldr	r2, [sp, #4]
300286a4:	e1a03002 	mov	r3, r2
300286a8:	e1a03183 	lsl	r3, r3, #3
300286ac:	e0833002 	add	r3, r3, r2
300286b0:	e1a03103 	lsl	r3, r3, #2
300286b4:	e1a02003 	mov	r2, r3
300286b8:	e59f30f4 	ldr	r3, [pc, #244]	; 300287b4 <FileClose+0x148>
300286bc:	e0823003 	add	r3, r2, r3
300286c0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
        if ((fp->Flags & FILE_FLAGS_WRITE) == FILE_FLAGS_WRITE)
300286c4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300286c8:	e5d33000 	ldrb	r3, [r3]
300286cc:	e2033002 	and	r3, r3, #2
300286d0:	e3530000 	cmp	r3, #0
300286d4:	0a00002e 	beq	30028794 <FileClose+0x128>
        {
            Rt = FindFDTInfo(&FileFDT, fp->Drive, fp->DirClus, fp->Name);
300286d8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300286dc:	e5d3100c 	ldrb	r1, [r3, #12]
300286e0:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300286e4:	e5932010 	ldr	r2, [r3, #16]
300286e8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300286ec:	e2833001 	add	r3, r3, #1
300286f0:	e28d0008 	add	r0, sp, #8
300286f4:	ebfffa2e 	bl	30026fb4 <FindFDTInfo>
300286f8:	e1a03000 	mov	r3, r0
300286fc:	e5cd302b 	strb	r3, [sp, #43]	; 0x2b
            if (Rt == RETURN_OK)
30028700:	e5dd302b 	ldrb	r3, [sp, #43]	; 0x2b
30028704:	e3530000 	cmp	r3, #0
30028708:	1a000021 	bne	30028794 <FileClose+0x128>
            if (FileFDT.FileSize < fp->FileSize)
3002870c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30028710:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30028714:	e5933014 	ldr	r3, [r3, #20]
30028718:	e1520003 	cmp	r2, r3
3002871c:	2a00001c 	bcs	30028794 <FileClose+0x128>
            {
                FileFDT.FileSize = fp->FileSize;
30028720:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30028724:	e5933014 	ldr	r3, [r3, #20]
30028728:	e58d3024 	str	r3, [sp, #36]	; 0x24
                if (FileFDT.FstClusLO == 0)
3002872c:	e1dd32b2 	ldrh	r3, [sp, #34]	; 0x22
30028730:	e3530000 	cmp	r3, #0
30028734:	1a00000d 	bne	30028770 <FileClose+0x104>
                if (FileFDT.FstClusHI == 0)
30028738:	e1dd31bc 	ldrh	r3, [sp, #28]
3002873c:	e3530000 	cmp	r3, #0
30028740:	1a00000a 	bne	30028770 <FileClose+0x104>
                {
                    FileFDT.FstClusLO = fp->FstClus & 0xffff;
30028744:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30028748:	e5933018 	ldr	r3, [r3, #24]
3002874c:	e1a03803 	lsl	r3, r3, #16
30028750:	e1a03823 	lsr	r3, r3, #16
30028754:	e1cd32b2 	strh	r3, [sp, #34]	; 0x22
                    FileFDT.FstClusHI = (fp->FstClus >> 16) & 0xffff;
30028758:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3002875c:	e5933018 	ldr	r3, [r3, #24]
30028760:	e1a03823 	lsr	r3, r3, #16
30028764:	e1a03803 	lsl	r3, r3, #16
30028768:	e1a03823 	lsr	r3, r3, #16
3002876c:	e1cd31bc 	strh	r3, [sp, #28]
                }
                ChangeFDT(fp->Drive, fp->DirClus, &FileFDT);
30028770:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30028774:	e5d3100c 	ldrb	r1, [r3, #12]
30028778:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3002877c:	e5932010 	ldr	r2, [r3, #16]
30028780:	e28d3008 	add	r3, sp, #8
30028784:	e1a00001 	mov	r0, r1
30028788:	e1a01002 	mov	r1, r2
3002878c:	e1a02003 	mov	r2, r3
30028790:	ebfffb96 	bl	300275f0 <ChangeFDT>
            }
        }
        fp->Flags = 0;
30028794:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30028798:	e3a02000 	mov	r2, #0
3002879c:	e5c32000 	strb	r2, [r3]
    }
    return Rt;
300287a0:	e5dd302b 	ldrb	r3, [sp, #43]	; 0x2b
}
300287a4:	e1a00003 	mov	r0, r3
300287a8:	e28dd034 	add	sp, sp, #52	; 0x34
300287ac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300287b0:	e12fff1e 	bx	lr
300287b4:	300e3ebc 	.word	0x300e3ebc

300287b8 <FileGetCh>:
**        ����ο�fat.h�й��ڷ���ֵ��˵�� 
** ȫ�ֱ���: ��
** ����ģ��: ��
********************************************************************************************************/
        acoral_u8 FileGetCh(acoral_u8 *Ch, HANDLE Handle)
{
300287b8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300287bc:	e24dd02c 	sub	sp, sp, #44	; 0x2c
300287c0:	e58d0004 	str	r0, [sp, #4]
300287c4:	e58d1000 	str	r1, [sp]
    MY_FILE *fp;
    Disk_Info * DiskInfo;
    acoral_u8 Rt;
    acoral_u8 *Buf;
    
    Rt = PARAMETER_ERR;
300287c8:	e3e03000 	mvn	r3, #0
300287cc:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
    fp = FileInfo + Handle;
300287d0:	e59d2000 	ldr	r2, [sp]
300287d4:	e1a03002 	mov	r3, r2
300287d8:	e1a03183 	lsl	r3, r3, #3
300287dc:	e0833002 	add	r3, r3, r2
300287e0:	e1a03103 	lsl	r3, r3, #2
300287e4:	e1a02003 	mov	r2, r3
300287e8:	e59f3328 	ldr	r3, [pc, #808]	; 30028b18 <FileGetCh+0x360>
300287ec:	e0823003 	add	r3, r2, r3
300287f0:	e58d3018 	str	r3, [sp, #24]
    if (Handle >= 0 && Handle < MAX_OPEN_FILES)     /* Handle�Ƿ���Ч */
300287f4:	e59d3000 	ldr	r3, [sp]
300287f8:	e3530000 	cmp	r3, #0
300287fc:	ba0000c0 	blt	30028b04 <FileGetCh+0x34c>
30028800:	e59d3000 	ldr	r3, [sp]
30028804:	e3530009 	cmp	r3, #9
30028808:	ca0000bd 	bgt	30028b04 <FileGetCh+0x34c>
    if (fp->Flags != 0)                             /* ��Ӧ�Ĵ��ļ���Ϣ���Ƿ���ʹ�� */
3002880c:	e59d3018 	ldr	r3, [sp, #24]
30028810:	e5d33000 	ldrb	r3, [r3]
30028814:	e3530000 	cmp	r3, #0
30028818:	0a0000b9 	beq	30028b04 <FileGetCh+0x34c>
    {
        Rt = FILE_EOF;
3002881c:	e3a03011 	mov	r3, #17
30028820:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
        if (fp->Offset >= fp->FileSize)
30028824:	e59d3018 	ldr	r3, [sp, #24]
30028828:	e5932020 	ldr	r2, [r3, #32]
3002882c:	e59d3018 	ldr	r3, [sp, #24]
30028830:	e5933014 	ldr	r3, [r3, #20]
30028834:	e1520003 	cmp	r2, r3
30028838:	3a000036 	bcc	30028918 <FileGetCh+0x160>
        {
            /* ������ݳ����ļ��ĳ��ȣ���һ��˭���б�ĳ�������д����ļ� */
            /* ����У�������ļ��ĳ����б仯������֮*/
            Handle = FindOpenFileW(fp->Drive, fp->DirClus, fp->Name);
3002883c:	e59d3018 	ldr	r3, [sp, #24]
30028840:	e5d3100c 	ldrb	r1, [r3, #12]
30028844:	e59d3018 	ldr	r3, [sp, #24]
30028848:	e5932010 	ldr	r2, [r3, #16]
3002884c:	e59d3018 	ldr	r3, [sp, #24]
30028850:	e2833001 	add	r3, r3, #1
30028854:	e1a00001 	mov	r0, r1
30028858:	e1a01002 	mov	r1, r2
3002885c:	e1a02003 	mov	r2, r3
30028860:	ebfffd73 	bl	30027e34 <FindOpenFileW>
30028864:	e1a03000 	mov	r3, r0
30028868:	e58d3000 	str	r3, [sp]
            if (Handle !=  Not_Open_FILE)
3002886c:	e59d3000 	ldr	r3, [sp]
30028870:	e3730001 	cmn	r3, #1
30028874:	0a000027 	beq	30028918 <FileGetCh+0x160>
            {
                fp->FileSize = FileInfo[Handle].FileSize;
30028878:	e59d2000 	ldr	r2, [sp]
3002887c:	e59f0294 	ldr	r0, [pc, #660]	; 30028b18 <FileGetCh+0x360>
30028880:	e3a01014 	mov	r1, #20
30028884:	e1a03002 	mov	r3, r2
30028888:	e1a03183 	lsl	r3, r3, #3
3002888c:	e0833002 	add	r3, r3, r2
30028890:	e1a03103 	lsl	r3, r3, #2
30028894:	e0833000 	add	r3, r3, r0
30028898:	e0833001 	add	r3, r3, r1
3002889c:	e5932000 	ldr	r2, [r3]
300288a0:	e59d3018 	ldr	r3, [sp, #24]
300288a4:	e5832014 	str	r2, [r3, #20]
                if (fp->Offset == 0)
300288a8:	e59d3018 	ldr	r3, [sp, #24]
300288ac:	e5933020 	ldr	r3, [r3, #32]
300288b0:	e3530000 	cmp	r3, #0
300288b4:	1a000017 	bne	30028918 <FileGetCh+0x160>
                {
                    fp->FstClus = FileInfo[Handle].FstClus;
300288b8:	e59d2000 	ldr	r2, [sp]
300288bc:	e59f0254 	ldr	r0, [pc, #596]	; 30028b18 <FileGetCh+0x360>
300288c0:	e3a01018 	mov	r1, #24
300288c4:	e1a03002 	mov	r3, r2
300288c8:	e1a03183 	lsl	r3, r3, #3
300288cc:	e0833002 	add	r3, r3, r2
300288d0:	e1a03103 	lsl	r3, r3, #2
300288d4:	e0833000 	add	r3, r3, r0
300288d8:	e0833001 	add	r3, r3, r1
300288dc:	e5932000 	ldr	r2, [r3]
300288e0:	e59d3018 	ldr	r3, [sp, #24]
300288e4:	e5832018 	str	r2, [r3, #24]
                    fp->Clus = FileInfo[Handle].Clus;
300288e8:	e59d2000 	ldr	r2, [sp]
300288ec:	e59f0224 	ldr	r0, [pc, #548]	; 30028b18 <FileGetCh+0x360>
300288f0:	e3a0101c 	mov	r1, #28
300288f4:	e1a03002 	mov	r3, r2
300288f8:	e1a03183 	lsl	r3, r3, #3
300288fc:	e0833002 	add	r3, r3, r2
30028900:	e1a03103 	lsl	r3, r3, #2
30028904:	e0833000 	add	r3, r3, r0
30028908:	e0833001 	add	r3, r3, r1
3002890c:	e5932000 	ldr	r2, [r3]
30028910:	e59d3018 	ldr	r3, [sp, #24]
30028914:	e583201c 	str	r2, [r3, #28]
                }
            }
        }
        Rt = FILE_EOF;
30028918:	e3a03011 	mov	r3, #17
3002891c:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
        if (fp->Offset < fp->FileSize)              /* �Ƿ��ļ����� */
30028920:	e59d3018 	ldr	r3, [sp, #24]
30028924:	e5932020 	ldr	r2, [r3, #32]
30028928:	e59d3018 	ldr	r3, [sp, #24]
3002892c:	e5933014 	ldr	r3, [r3, #20]
30028930:	e1520003 	cmp	r2, r3
30028934:	2a000072 	bcs	30028b04 <FileGetCh+0x34c>
        {
            Rt = NOT_FIND_DISK;
30028938:	e3a03001 	mov	r3, #1
3002893c:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
                /* ��ȡ�ļ������߼�����Ϣ */
            DiskInfo = GetDiskInfo(fp->Drive);
30028940:	e59d3018 	ldr	r3, [sp, #24]
30028944:	e5d3300c 	ldrb	r3, [r3, #12]
30028948:	e1a00003 	mov	r0, r3
3002894c:	ebffeeb3 	bl	30024420 <GetDiskInfo>
30028950:	e1a03000 	mov	r3, r0
30028954:	e58d301c 	str	r3, [sp, #28]
            if (DiskInfo != NULL)
30028958:	e59d301c 	ldr	r3, [sp, #28]
3002895c:	e3530000 	cmp	r3, #0
30028960:	0a000067 	beq	30028b04 <FileGetCh+0x34c>
            {
                /* ��������������� */
                j = fp->Offset % (DiskInfo->SecPerClus * DiskInfo->BytsPerSec);
30028964:	e59d3018 	ldr	r3, [sp, #24]
30028968:	e5932020 	ldr	r2, [r3, #32]
3002896c:	e59d301c 	ldr	r3, [sp, #28]
30028970:	e5d33002 	ldrb	r3, [r3, #2]
30028974:	e59d101c 	ldr	r1, [sp, #28]
30028978:	e591100c 	ldr	r1, [r1, #12]
3002897c:	e0030391 	mul	r3, r1, r3
30028980:	e1a00002 	mov	r0, r2
30028984:	e1a01003 	mov	r1, r3
30028988:	eb006d01 	bl	30043d94 <__aeabi_uidivmod>
3002898c:	e1a03001 	mov	r3, r1
30028990:	e58d3010 	str	r3, [sp, #16]
                i = j / DiskInfo->BytsPerSec;
30028994:	e59d301c 	ldr	r3, [sp, #28]
30028998:	e593300c 	ldr	r3, [r3, #12]
3002899c:	e59d0010 	ldr	r0, [sp, #16]
300289a0:	e1a01003 	mov	r1, r3
300289a4:	eb006cbd 	bl	30043ca0 <__aeabi_uidiv>
300289a8:	e1a03000 	mov	r3, r0
300289ac:	e58d300c 	str	r3, [sp, #12]
                j = j % DiskInfo->BytsPerSec;
300289b0:	e59d301c 	ldr	r3, [sp, #28]
300289b4:	e593300c 	ldr	r3, [r3, #12]
300289b8:	e59d2010 	ldr	r2, [sp, #16]
300289bc:	e1a00002 	mov	r0, r2
300289c0:	e1a01003 	mov	r1, r3
300289c4:	eb006cf2 	bl	30043d94 <__aeabi_uidivmod>
300289c8:	e1a03001 	mov	r3, r1
300289cc:	e58d3010 	str	r3, [sp, #16]
                SecIndex = (fp->Clus - 2) * DiskInfo->SecPerClus + 
300289d0:	e59d3018 	ldr	r3, [sp, #24]
300289d4:	e593301c 	ldr	r3, [r3, #28]
300289d8:	e2433002 	sub	r3, r3, #2
300289dc:	e59d201c 	ldr	r2, [sp, #28]
300289e0:	e5d22002 	ldrb	r2, [r2, #2]
300289e4:	e0020293 	mul	r2, r3, r2
                           DiskInfo->DataStartSec + i;
300289e8:	e59d301c 	ldr	r3, [sp, #28]
300289ec:	e5933020 	ldr	r3, [r3, #32]
300289f0:	e0822003 	add	r2, r2, r3
            {
                /* ��������������� */
                j = fp->Offset % (DiskInfo->SecPerClus * DiskInfo->BytsPerSec);
                i = j / DiskInfo->BytsPerSec;
                j = j % DiskInfo->BytsPerSec;
                SecIndex = (fp->Clus - 2) * DiskInfo->SecPerClus + 
300289f4:	e59d300c 	ldr	r3, [sp, #12]
300289f8:	e0823003 	add	r3, r2, r3
300289fc:	e58d3014 	str	r3, [sp, #20]
                           DiskInfo->DataStartSec + i;
                Rt = SECTOR_READ_ERR;
30028a00:	e3a03005 	mov	r3, #5
30028a04:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
                /* ������ */
                Buf = OpenSec(fp->Drive, SecIndex);
30028a08:	e59d3018 	ldr	r3, [sp, #24]
30028a0c:	e5d3300c 	ldrb	r3, [r3, #12]
30028a10:	e1a00003 	mov	r0, r3
30028a14:	e59d1014 	ldr	r1, [sp, #20]
30028a18:	eb000d02 	bl	3002be28 <OpenSec>
30028a1c:	e1a03000 	mov	r3, r0
30028a20:	e58d3024 	str	r3, [sp, #36]	; 0x24
                if (Buf != NULL)
30028a24:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30028a28:	e3530000 	cmp	r3, #0
30028a2c:	0a000034 	beq	30028b04 <FileGetCh+0x34c>
                {
                    /* ��ȡ������� */
                    if (ReadSec(fp->Drive, SecIndex) == RETURN_OK)
30028a30:	e59d3018 	ldr	r3, [sp, #24]
30028a34:	e5d3300c 	ldrb	r3, [r3, #12]
30028a38:	e1a00003 	mov	r0, r3
30028a3c:	e59d1014 	ldr	r1, [sp, #20]
30028a40:	eb000d9c 	bl	3002c0b8 <ReadSec>
30028a44:	e1a03000 	mov	r3, r0
30028a48:	e3530000 	cmp	r3, #0
30028a4c:	1a000027 	bne	30028af0 <FileGetCh+0x338>
                    {
                        /* ��ȡ��� */
                        *Ch = Buf[j];
30028a50:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30028a54:	e59d3010 	ldr	r3, [sp, #16]
30028a58:	e0823003 	add	r3, r2, r3
30028a5c:	e5d32000 	ldrb	r2, [r3]
30028a60:	e59d3004 	ldr	r3, [sp, #4]
30028a64:	e5c32000 	strb	r2, [r3]
                        /* �����ļ�ָ�� */
                        fp->Offset++;
30028a68:	e59d3018 	ldr	r3, [sp, #24]
30028a6c:	e5933020 	ldr	r3, [r3, #32]
30028a70:	e2832001 	add	r2, r3, #1
30028a74:	e59d3018 	ldr	r3, [sp, #24]
30028a78:	e5832020 	str	r2, [r3, #32]
                        j++;
30028a7c:	e59d3010 	ldr	r3, [sp, #16]
30028a80:	e2833001 	add	r3, r3, #1
30028a84:	e58d3010 	str	r3, [sp, #16]
                        if (j >= DiskInfo->BytsPerSec)
30028a88:	e59d301c 	ldr	r3, [sp, #28]
30028a8c:	e593200c 	ldr	r2, [r3, #12]
30028a90:	e59d3010 	ldr	r3, [sp, #16]
30028a94:	e1520003 	cmp	r2, r3
30028a98:	8a000012 	bhi	30028ae8 <FileGetCh+0x330>
                        {
                            i++;
30028a9c:	e59d300c 	ldr	r3, [sp, #12]
30028aa0:	e2833001 	add	r3, r3, #1
30028aa4:	e58d300c 	str	r3, [sp, #12]
                            if (i >= DiskInfo->SecPerClus)
30028aa8:	e59d301c 	ldr	r3, [sp, #28]
30028aac:	e5d33002 	ldrb	r3, [r3, #2]
30028ab0:	e1a02003 	mov	r2, r3
30028ab4:	e59d300c 	ldr	r3, [sp, #12]
30028ab8:	e1520003 	cmp	r2, r3
30028abc:	8a000009 	bhi	30028ae8 <FileGetCh+0x330>
                            {
                                fp->Clus = FATGetNextClus(fp->Drive, fp->Clus);
30028ac0:	e59d3018 	ldr	r3, [sp, #24]
30028ac4:	e5d3200c 	ldrb	r2, [r3, #12]
30028ac8:	e59d3018 	ldr	r3, [sp, #24]
30028acc:	e593301c 	ldr	r3, [r3, #28]
30028ad0:	e1a00002 	mov	r0, r2
30028ad4:	e1a01003 	mov	r1, r3
30028ad8:	ebfff1c6 	bl	300251f8 <FATGetNextClus>
30028adc:	e1a02000 	mov	r2, r0
30028ae0:	e59d3018 	ldr	r3, [sp, #24]
30028ae4:	e583201c 	str	r2, [r3, #28]
                            }
                        }
                        Rt = RETURN_OK;
30028ae8:	e3a03000 	mov	r3, #0
30028aec:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
                    }
                    /* �ر����� */
                    CloseSec(fp->Drive, SecIndex);
30028af0:	e59d3018 	ldr	r3, [sp, #24]
30028af4:	e5d3300c 	ldrb	r3, [r3, #12]
30028af8:	e1a00003 	mov	r0, r3
30028afc:	e59d1014 	ldr	r1, [sp, #20]
30028b00:	eb000bc0 	bl	3002ba08 <CloseSec>
                }
            }
        }
    }
    return Rt;
30028b04:	e5dd3023 	ldrb	r3, [sp, #35]	; 0x23
}
30028b08:	e1a00003 	mov	r0, r3
30028b0c:	e28dd02c 	add	sp, sp, #44	; 0x2c
30028b10:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30028b14:	e12fff1e 	bx	lr
30028b18:	300e3ebc 	.word	0x300e3ebc

30028b1c <FileRead>:
    }
    return i;
}*/
	/***************re-write by gaopan*******************/
	acoral_32 FileRead(void *Buf_out, acoral_u32 Size, HANDLE Handle)
{
30028b1c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30028b20:	e24dd04c 	sub	sp, sp, #76	; 0x4c
30028b24:	e58d000c 	str	r0, [sp, #12]
30028b28:	e58d1008 	str	r1, [sp, #8]
30028b2c:	e58d2004 	str	r2, [sp, #4]
	acoral_32 Rt;
	MY_FILE * fp;
	acoral_u32 i,j,k,SecIndex,RealSize,FirstSize;
	Disk_Info *DiskInfo;
	acoral_u8 *SecBuf;
	acoral_u8 *Buf=(acoral_u8 *)Buf_out;
30028b30:	e59d300c 	ldr	r3, [sp, #12]
30028b34:	e58d303c 	str	r3, [sp, #60]	; 0x3c

	Rt = -1;
30028b38:	e3e03000 	mvn	r3, #0
30028b3c:	e58d3014 	str	r3, [sp, #20]
	RealSize=Size;
30028b40:	e59d3008 	ldr	r3, [sp, #8]
30028b44:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	fp = FileInfo + Handle;
30028b48:	e59d2004 	ldr	r2, [sp, #4]
30028b4c:	e1a03002 	mov	r3, r2
30028b50:	e1a03183 	lsl	r3, r3, #3
30028b54:	e0833002 	add	r3, r3, r2
30028b58:	e1a03103 	lsl	r3, r3, #2
30028b5c:	e1a02003 	mov	r2, r3
30028b60:	e59f3718 	ldr	r3, [pc, #1816]	; 30029280 <FileRead+0x764>
30028b64:	e0823003 	add	r3, r2, r3
30028b68:	e58d3018 	str	r3, [sp, #24]
	if(Buf!=NULL)
30028b6c:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30028b70:	e3530000 	cmp	r3, #0
30028b74:	0a0001bc 	beq	3002926c <FileRead+0x750>
	if(Handle >= 0 && Handle < MAX_OPEN_FILES)
30028b78:	e59d3004 	ldr	r3, [sp, #4]
30028b7c:	e3530000 	cmp	r3, #0
30028b80:	ba0001b9 	blt	3002926c <FileRead+0x750>
30028b84:	e59d3004 	ldr	r3, [sp, #4]
30028b88:	e3530009 	cmp	r3, #9
30028b8c:	ca0001b6 	bgt	3002926c <FileRead+0x750>
	if(fp->Flags != 0 )
30028b90:	e59d3018 	ldr	r3, [sp, #24]
30028b94:	e5d33000 	ldrb	r3, [r3]
30028b98:	e3530000 	cmp	r3, #0
30028b9c:	0a0001b2 	beq	3002926c <FileRead+0x750>
	{
		Rt = 0;
30028ba0:	e3a03000 	mov	r3, #0
30028ba4:	e58d3014 	str	r3, [sp, #20]
		if(fp->Offset+Size >= fp->FileSize)
30028ba8:	e59d3018 	ldr	r3, [sp, #24]
30028bac:	e5932020 	ldr	r2, [r3, #32]
30028bb0:	e59d3008 	ldr	r3, [sp, #8]
30028bb4:	e0822003 	add	r2, r2, r3
30028bb8:	e59d3018 	ldr	r3, [sp, #24]
30028bbc:	e5933014 	ldr	r3, [r3, #20]
30028bc0:	e1520003 	cmp	r2, r3
30028bc4:	3a000036 	bcc	30028ca4 <FileRead+0x188>
		{
			Handle = FindOpenFileW(fp->Drive,fp->DirClus,fp->Name);
30028bc8:	e59d3018 	ldr	r3, [sp, #24]
30028bcc:	e5d3100c 	ldrb	r1, [r3, #12]
30028bd0:	e59d3018 	ldr	r3, [sp, #24]
30028bd4:	e5932010 	ldr	r2, [r3, #16]
30028bd8:	e59d3018 	ldr	r3, [sp, #24]
30028bdc:	e2833001 	add	r3, r3, #1
30028be0:	e1a00001 	mov	r0, r1
30028be4:	e1a01002 	mov	r1, r2
30028be8:	e1a02003 	mov	r2, r3
30028bec:	ebfffc90 	bl	30027e34 <FindOpenFileW>
30028bf0:	e1a03000 	mov	r3, r0
30028bf4:	e58d3004 	str	r3, [sp, #4]
			if(Handle !=  Not_Open_FILE)
30028bf8:	e59d3004 	ldr	r3, [sp, #4]
30028bfc:	e3730001 	cmn	r3, #1
30028c00:	0a000027 	beq	30028ca4 <FileRead+0x188>
			{
				fp->FileSize = FileInfo[Handle].FileSize;
30028c04:	e59d2004 	ldr	r2, [sp, #4]
30028c08:	e59f0670 	ldr	r0, [pc, #1648]	; 30029280 <FileRead+0x764>
30028c0c:	e3a01014 	mov	r1, #20
30028c10:	e1a03002 	mov	r3, r2
30028c14:	e1a03183 	lsl	r3, r3, #3
30028c18:	e0833002 	add	r3, r3, r2
30028c1c:	e1a03103 	lsl	r3, r3, #2
30028c20:	e0833000 	add	r3, r3, r0
30028c24:	e0833001 	add	r3, r3, r1
30028c28:	e5932000 	ldr	r2, [r3]
30028c2c:	e59d3018 	ldr	r3, [sp, #24]
30028c30:	e5832014 	str	r2, [r3, #20]
				if(fp->Offset == 0)
30028c34:	e59d3018 	ldr	r3, [sp, #24]
30028c38:	e5933020 	ldr	r3, [r3, #32]
30028c3c:	e3530000 	cmp	r3, #0
30028c40:	1a000017 	bne	30028ca4 <FileRead+0x188>
				{
					fp->FstClus = FileInfo[Handle].FstClus;
30028c44:	e59d2004 	ldr	r2, [sp, #4]
30028c48:	e59f0630 	ldr	r0, [pc, #1584]	; 30029280 <FileRead+0x764>
30028c4c:	e3a01018 	mov	r1, #24
30028c50:	e1a03002 	mov	r3, r2
30028c54:	e1a03183 	lsl	r3, r3, #3
30028c58:	e0833002 	add	r3, r3, r2
30028c5c:	e1a03103 	lsl	r3, r3, #2
30028c60:	e0833000 	add	r3, r3, r0
30028c64:	e0833001 	add	r3, r3, r1
30028c68:	e5932000 	ldr	r2, [r3]
30028c6c:	e59d3018 	ldr	r3, [sp, #24]
30028c70:	e5832018 	str	r2, [r3, #24]
					fp->Clus = FileInfo[Handle].FstClus;
30028c74:	e59d2004 	ldr	r2, [sp, #4]
30028c78:	e59f0600 	ldr	r0, [pc, #1536]	; 30029280 <FileRead+0x764>
30028c7c:	e3a01018 	mov	r1, #24
30028c80:	e1a03002 	mov	r3, r2
30028c84:	e1a03183 	lsl	r3, r3, #3
30028c88:	e0833002 	add	r3, r3, r2
30028c8c:	e1a03103 	lsl	r3, r3, #2
30028c90:	e0833000 	add	r3, r3, r0
30028c94:	e0833001 	add	r3, r3, r1
30028c98:	e5932000 	ldr	r2, [r3]
30028c9c:	e59d3018 	ldr	r3, [sp, #24]
30028ca0:	e583201c 	str	r2, [r3, #28]
				}
			}
		}
		if(fp->Offset < fp->FileSize)
30028ca4:	e59d3018 	ldr	r3, [sp, #24]
30028ca8:	e5932020 	ldr	r2, [r3, #32]
30028cac:	e59d3018 	ldr	r3, [sp, #24]
30028cb0:	e5933014 	ldr	r3, [r3, #20]
30028cb4:	e1520003 	cmp	r2, r3
30028cb8:	2a00016b 	bcs	3002926c <FileRead+0x750>
		{
			if(fp->Offset+Size >= fp->FileSize)
30028cbc:	e59d3018 	ldr	r3, [sp, #24]
30028cc0:	e5932020 	ldr	r2, [r3, #32]
30028cc4:	e59d3008 	ldr	r3, [sp, #8]
30028cc8:	e0822003 	add	r2, r2, r3
30028ccc:	e59d3018 	ldr	r3, [sp, #24]
30028cd0:	e5933014 	ldr	r3, [r3, #20]
30028cd4:	e1520003 	cmp	r2, r3
30028cd8:	3a000005 	bcc	30028cf4 <FileRead+0x1d8>
				RealSize=fp->FileSize - fp->Offset;
30028cdc:	e59d3018 	ldr	r3, [sp, #24]
30028ce0:	e5932014 	ldr	r2, [r3, #20]
30028ce4:	e59d3018 	ldr	r3, [sp, #24]
30028ce8:	e5933020 	ldr	r3, [r3, #32]
30028cec:	e0633002 	rsb	r3, r3, r2
30028cf0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
			Rt = RealSize;
30028cf4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30028cf8:	e58d3014 	str	r3, [sp, #20]
//			Rt=NOT_FIND_DISK;
			DiskInfo = GetDiskInfo(fp->Drive);
30028cfc:	e59d3018 	ldr	r3, [sp, #24]
30028d00:	e5d3300c 	ldrb	r3, [r3, #12]
30028d04:	e1a00003 	mov	r0, r3
30028d08:	ebffedc4 	bl	30024420 <GetDiskInfo>
30028d0c:	e1a03000 	mov	r3, r0
30028d10:	e58d3034 	str	r3, [sp, #52]	; 0x34
			if(DiskInfo != NULL)
30028d14:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30028d18:	e3530000 	cmp	r3, #0
30028d1c:	0a00014f 	beq	30029260 <FileRead+0x744>
			{
				j=fp->Offset % (DiskInfo->SecPerClus * DiskInfo->BytsPerSec);
30028d20:	e59d3018 	ldr	r3, [sp, #24]
30028d24:	e5932020 	ldr	r2, [r3, #32]
30028d28:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30028d2c:	e5d33002 	ldrb	r3, [r3, #2]
30028d30:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
30028d34:	e591100c 	ldr	r1, [r1, #12]
30028d38:	e0030391 	mul	r3, r1, r3
30028d3c:	e1a00002 	mov	r0, r2
30028d40:	e1a01003 	mov	r1, r3
30028d44:	eb006c12 	bl	30043d94 <__aeabi_uidivmod>
30028d48:	e1a03001 	mov	r3, r1
30028d4c:	e58d3020 	str	r3, [sp, #32]
				i=j / DiskInfo->BytsPerSec;
30028d50:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30028d54:	e593300c 	ldr	r3, [r3, #12]
30028d58:	e59d0020 	ldr	r0, [sp, #32]
30028d5c:	e1a01003 	mov	r1, r3
30028d60:	eb006bce 	bl	30043ca0 <__aeabi_uidiv>
30028d64:	e1a03000 	mov	r3, r0
30028d68:	e58d301c 	str	r3, [sp, #28]
				j=j % DiskInfo->BytsPerSec;
30028d6c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30028d70:	e593300c 	ldr	r3, [r3, #12]
30028d74:	e59d2020 	ldr	r2, [sp, #32]
30028d78:	e1a00002 	mov	r0, r2
30028d7c:	e1a01003 	mov	r1, r3
30028d80:	eb006c03 	bl	30043d94 <__aeabi_uidivmod>
30028d84:	e1a03001 	mov	r3, r1
30028d88:	e58d3020 	str	r3, [sp, #32]
				SecIndex = (fp->Clus-2) * DiskInfo->SecPerClus+DiskInfo->DataStartSec+i;
30028d8c:	e59d3018 	ldr	r3, [sp, #24]
30028d90:	e593301c 	ldr	r3, [r3, #28]
30028d94:	e2433002 	sub	r3, r3, #2
30028d98:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
30028d9c:	e5d22002 	ldrb	r2, [r2, #2]
30028da0:	e0020293 	mul	r2, r3, r2
30028da4:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30028da8:	e5933020 	ldr	r3, [r3, #32]
30028dac:	e0822003 	add	r2, r2, r3
30028db0:	e59d301c 	ldr	r3, [sp, #28]
30028db4:	e0823003 	add	r3, r2, r3
30028db8:	e58d3028 	str	r3, [sp, #40]	; 0x28
//				Rt = SECTOR_READ_ERR;
				//�����һ������
				SecBuf = OpenSec(fp->Drive,SecIndex);
30028dbc:	e59d3018 	ldr	r3, [sp, #24]
30028dc0:	e5d3300c 	ldrb	r3, [r3, #12]
30028dc4:	e1a00003 	mov	r0, r3
30028dc8:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
30028dcc:	eb000c15 	bl	3002be28 <OpenSec>
30028dd0:	e1a03000 	mov	r3, r0
30028dd4:	e58d3038 	str	r3, [sp, #56]	; 0x38
				if(SecBuf == NULL)
30028dd8:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30028ddc:	e3530000 	cmp	r3, #0
30028de0:	1a000001 	bne	30028dec <FileRead+0x2d0>
				{
					return -1;
30028de4:	e3e03000 	mvn	r3, #0
30028de8:	ea000120 	b	30029270 <FileRead+0x754>
				}
				
				if(ReadSec(fp->Drive,SecIndex) == RETURN_OK)
30028dec:	e59d3018 	ldr	r3, [sp, #24]
30028df0:	e5d3300c 	ldrb	r3, [r3, #12]
30028df4:	e1a00003 	mov	r0, r3
30028df8:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
30028dfc:	eb000cad 	bl	3002c0b8 <ReadSec>
30028e00:	e1a03000 	mov	r3, r0
30028e04:	e3530000 	cmp	r3, #0
30028e08:	1a000031 	bne	30028ed4 <FileRead+0x3b8>
				{
					FirstSize = ((DiskInfo->BytsPerSec-j)<RealSize) ? (DiskInfo->BytsPerSec-j):RealSize;
30028e0c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30028e10:	e593200c 	ldr	r2, [r3, #12]
30028e14:	e59d3020 	ldr	r3, [sp, #32]
30028e18:	e0632002 	rsb	r2, r3, r2
30028e1c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30028e20:	e1520003 	cmp	r2, r3
30028e24:	31a03002 	movcc	r3, r2
30028e28:	e58d3030 	str	r3, [sp, #48]	; 0x30
					for(k=FirstSize;k>0;k--)
30028e2c:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30028e30:	e58d3024 	str	r3, [sp, #36]	; 0x24
30028e34:	ea00000e 	b	30028e74 <FileRead+0x358>
					{
						*Buf++ = SecBuf[j];
30028e38:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
30028e3c:	e59d3020 	ldr	r3, [sp, #32]
30028e40:	e0823003 	add	r3, r2, r3
30028e44:	e5d32000 	ldrb	r2, [r3]
30028e48:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30028e4c:	e5c32000 	strb	r2, [r3]
30028e50:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30028e54:	e2833001 	add	r3, r3, #1
30028e58:	e58d303c 	str	r3, [sp, #60]	; 0x3c
						j++;
30028e5c:	e59d3020 	ldr	r3, [sp, #32]
30028e60:	e2833001 	add	r3, r3, #1
30028e64:	e58d3020 	str	r3, [sp, #32]
				}
				
				if(ReadSec(fp->Drive,SecIndex) == RETURN_OK)
				{
					FirstSize = ((DiskInfo->BytsPerSec-j)<RealSize) ? (DiskInfo->BytsPerSec-j):RealSize;
					for(k=FirstSize;k>0;k--)
30028e68:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30028e6c:	e2433001 	sub	r3, r3, #1
30028e70:	e58d3024 	str	r3, [sp, #36]	; 0x24
30028e74:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30028e78:	e3530000 	cmp	r3, #0
30028e7c:	1affffed 	bne	30028e38 <FileRead+0x31c>
					{
						*Buf++ = SecBuf[j];
						j++;
					}
					fp->Offset = fp->Offset + FirstSize;
30028e80:	e59d3018 	ldr	r3, [sp, #24]
30028e84:	e5932020 	ldr	r2, [r3, #32]
30028e88:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30028e8c:	e0822003 	add	r2, r2, r3
30028e90:	e59d3018 	ldr	r3, [sp, #24]
30028e94:	e5832020 	str	r2, [r3, #32]
					RealSize = RealSize - FirstSize;
30028e98:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30028e9c:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30028ea0:	e0633002 	rsb	r3, r3, r2
30028ea4:	e58d302c 	str	r3, [sp, #44]	; 0x2c
				}
				else
					return -1;
				
				CloseSec(fp->Drive,SecIndex);
30028ea8:	e59d3018 	ldr	r3, [sp, #24]
30028eac:	e5d3300c 	ldrb	r3, [r3, #12]
30028eb0:	e1a00003 	mov	r0, r3
30028eb4:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
30028eb8:	eb000ad2 	bl	3002ba08 <CloseSec>
				if(j>=DiskInfo->BytsPerSec)
30028ebc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30028ec0:	e593200c 	ldr	r2, [r3, #12]
30028ec4:	e59d3020 	ldr	r3, [sp, #32]
30028ec8:	e1520003 	cmp	r2, r3
30028ecc:	9a000002 	bls	30028edc <FileRead+0x3c0>
						//fp->Clus = FATGetNextClus(fp->Drive,fp->Clus); change serious logical wrong
					}
				}

				//�����м�����
				for(;RealSize >= DiskInfo->BytsPerSec;RealSize -= DiskInfo->BytsPerSec)
30028ed0:	ea000099 	b	3002913c <FileRead+0x620>
					}
					fp->Offset = fp->Offset + FirstSize;
					RealSize = RealSize - FirstSize;
				}
				else
					return -1;
30028ed4:	e3e03000 	mvn	r3, #0
30028ed8:	ea0000e4 	b	30029270 <FileRead+0x754>
				
				CloseSec(fp->Drive,SecIndex);
				if(j>=DiskInfo->BytsPerSec)
				{
					i++;
30028edc:	e59d301c 	ldr	r3, [sp, #28]
30028ee0:	e2833001 	add	r3, r3, #1
30028ee4:	e58d301c 	str	r3, [sp, #28]
					if(i>=DiskInfo->SecPerClus)
30028ee8:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30028eec:	e5d33002 	ldrb	r3, [r3, #2]
30028ef0:	e1a02003 	mov	r2, r3
30028ef4:	e59d301c 	ldr	r3, [sp, #28]
30028ef8:	e1520003 	cmp	r2, r3
30028efc:	8a00008b 	bhi	30029130 <FileRead+0x614>
					{
						i=0;
30028f00:	e3a03000 	mov	r3, #0
30028f04:	e58d301c 	str	r3, [sp, #28]
						acoral_32 tmp;
						tmp = FATGetNextClus(fp->Drive,fp->Clus);
30028f08:	e59d3018 	ldr	r3, [sp, #24]
30028f0c:	e5d3200c 	ldrb	r2, [r3, #12]
30028f10:	e59d3018 	ldr	r3, [sp, #24]
30028f14:	e593301c 	ldr	r3, [r3, #28]
30028f18:	e1a00002 	mov	r0, r2
30028f1c:	e1a01003 	mov	r1, r3
30028f20:	ebfff0b4 	bl	300251f8 <FATGetNextClus>
30028f24:	e1a03000 	mov	r3, r0
30028f28:	e58d3040 	str	r3, [sp, #64]	; 0x40
						if(tmp != 0xFFFFFFF)
30028f2c:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
30028f30:	e373021f 	cmn	r3, #-268435455	; 0xf0000001
30028f34:	0a00007f 	beq	30029138 <FileRead+0x61c>
							fp->Clus =tmp;
30028f38:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
30028f3c:	e59d3018 	ldr	r3, [sp, #24]
30028f40:	e583201c 	str	r2, [r3, #28]
						//fp->Clus = FATGetNextClus(fp->Drive,fp->Clus); change serious logical wrong
					}
				}

				//�����м�����
				for(;RealSize >= DiskInfo->BytsPerSec;RealSize -= DiskInfo->BytsPerSec)
30028f44:	ea00007c 	b	3002913c <FileRead+0x620>
				{
					SecIndex=(fp->Clus-2) * DiskInfo->SecPerClus+DiskInfo->DataStartSec+i;
30028f48:	e59d3018 	ldr	r3, [sp, #24]
30028f4c:	e593301c 	ldr	r3, [r3, #28]
30028f50:	e2433002 	sub	r3, r3, #2
30028f54:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
30028f58:	e5d22002 	ldrb	r2, [r2, #2]
30028f5c:	e0020293 	mul	r2, r3, r2
30028f60:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30028f64:	e5933020 	ldr	r3, [r3, #32]
30028f68:	e0822003 	add	r2, r2, r3
30028f6c:	e59d301c 	ldr	r3, [sp, #28]
30028f70:	e0823003 	add	r3, r2, r3
30028f74:	e58d3028 	str	r3, [sp, #40]	; 0x28
					if((SecBuf = OpenSec(fp->Drive,SecIndex))==NULL)
30028f78:	e59d3018 	ldr	r3, [sp, #24]
30028f7c:	e5d3300c 	ldrb	r3, [r3, #12]
30028f80:	e1a00003 	mov	r0, r3
30028f84:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
30028f88:	eb000ba6 	bl	3002be28 <OpenSec>
30028f8c:	e1a03000 	mov	r3, r0
30028f90:	e58d3038 	str	r3, [sp, #56]	; 0x38
30028f94:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30028f98:	e3530000 	cmp	r3, #0
30028f9c:	1a000001 	bne	30028fa8 <FileRead+0x48c>
						return -1;
30028fa0:	e3e03000 	mvn	r3, #0
30028fa4:	ea0000b1 	b	30029270 <FileRead+0x754>
					if(ReadSec(fp->Drive,SecIndex) != RETURN_OK)
30028fa8:	e59d3018 	ldr	r3, [sp, #24]
30028fac:	e5d3300c 	ldrb	r3, [r3, #12]
30028fb0:	e1a00003 	mov	r0, r3
30028fb4:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
30028fb8:	eb000c3e 	bl	3002c0b8 <ReadSec>
30028fbc:	e1a03000 	mov	r3, r0
30028fc0:	e3530000 	cmp	r3, #0
30028fc4:	0a000001 	beq	30028fd0 <FileRead+0x4b4>
						return -1;
30028fc8:	e3e03000 	mvn	r3, #0
30028fcc:	ea0000a7 	b	30029270 <FileRead+0x754>
					for(k=0;k<DiskInfo->BytsPerSec;k+=4)
30028fd0:	e3a03000 	mov	r3, #0
30028fd4:	e58d3024 	str	r3, [sp, #36]	; 0x24
30028fd8:	ea000023 	b	3002906c <FileRead+0x550>
					{
						Buf[0] = SecBuf[k];
30028fdc:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
30028fe0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30028fe4:	e0823003 	add	r3, r2, r3
30028fe8:	e5d32000 	ldrb	r2, [r3]
30028fec:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30028ff0:	e5c32000 	strb	r2, [r3]
						Buf[1] = SecBuf[k+1];
30028ff4:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30028ff8:	e2833001 	add	r3, r3, #1
30028ffc:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30029000:	e2821001 	add	r1, r2, #1
30029004:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
30029008:	e0812002 	add	r2, r1, r2
3002900c:	e5d22000 	ldrb	r2, [r2]
30029010:	e5c32000 	strb	r2, [r3]
						Buf[2] = SecBuf[k+2];
30029014:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30029018:	e2833002 	add	r3, r3, #2
3002901c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30029020:	e2821002 	add	r1, r2, #2
30029024:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
30029028:	e0812002 	add	r2, r1, r2
3002902c:	e5d22000 	ldrb	r2, [r2]
30029030:	e5c32000 	strb	r2, [r3]
						Buf[3] = SecBuf[k+3];
30029034:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30029038:	e2833003 	add	r3, r3, #3
3002903c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30029040:	e2821003 	add	r1, r2, #3
30029044:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
30029048:	e0812002 	add	r2, r1, r2
3002904c:	e5d22000 	ldrb	r2, [r2]
30029050:	e5c32000 	strb	r2, [r3]
						Buf += 4;
30029054:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30029058:	e2833004 	add	r3, r3, #4
3002905c:	e58d303c 	str	r3, [sp, #60]	; 0x3c
					SecIndex=(fp->Clus-2) * DiskInfo->SecPerClus+DiskInfo->DataStartSec+i;
					if((SecBuf = OpenSec(fp->Drive,SecIndex))==NULL)
						return -1;
					if(ReadSec(fp->Drive,SecIndex) != RETURN_OK)
						return -1;
					for(k=0;k<DiskInfo->BytsPerSec;k+=4)
30029060:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30029064:	e2833004 	add	r3, r3, #4
30029068:	e58d3024 	str	r3, [sp, #36]	; 0x24
3002906c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30029070:	e593200c 	ldr	r2, [r3, #12]
30029074:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30029078:	e1520003 	cmp	r2, r3
3002907c:	8affffd6 	bhi	30028fdc <FileRead+0x4c0>
						Buf[1] = SecBuf[k+1];
						Buf[2] = SecBuf[k+2];
						Buf[3] = SecBuf[k+3];
						Buf += 4;
					}
					CloseSec(fp->Drive,SecIndex);
30029080:	e59d3018 	ldr	r3, [sp, #24]
30029084:	e5d3300c 	ldrb	r3, [r3, #12]
30029088:	e1a00003 	mov	r0, r3
3002908c:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
30029090:	eb000a5c 	bl	3002ba08 <CloseSec>
					fp->Offset = fp->Offset+DiskInfo->BytsPerSec;
30029094:	e59d3018 	ldr	r3, [sp, #24]
30029098:	e5932020 	ldr	r2, [r3, #32]
3002909c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
300290a0:	e593300c 	ldr	r3, [r3, #12]
300290a4:	e0822003 	add	r2, r2, r3
300290a8:	e59d3018 	ldr	r3, [sp, #24]
300290ac:	e5832020 	str	r2, [r3, #32]
					i++;
300290b0:	e59d301c 	ldr	r3, [sp, #28]
300290b4:	e2833001 	add	r3, r3, #1
300290b8:	e58d301c 	str	r3, [sp, #28]
					if(i>=DiskInfo->SecPerClus)
300290bc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
300290c0:	e5d33002 	ldrb	r3, [r3, #2]
300290c4:	e1a02003 	mov	r2, r3
300290c8:	e59d301c 	ldr	r3, [sp, #28]
300290cc:	e1520003 	cmp	r2, r3
300290d0:	8a000010 	bhi	30029118 <FileRead+0x5fc>
					{
						i=0;
300290d4:	e3a03000 	mov	r3, #0
300290d8:	e58d301c 	str	r3, [sp, #28]
						acoral_32 tmp;
						tmp = FATGetNextClus(fp->Drive,fp->Clus);
300290dc:	e59d3018 	ldr	r3, [sp, #24]
300290e0:	e5d3200c 	ldrb	r2, [r3, #12]
300290e4:	e59d3018 	ldr	r3, [sp, #24]
300290e8:	e593301c 	ldr	r3, [r3, #28]
300290ec:	e1a00002 	mov	r0, r2
300290f0:	e1a01003 	mov	r1, r3
300290f4:	ebfff03f 	bl	300251f8 <FATGetNextClus>
300290f8:	e1a03000 	mov	r3, r0
300290fc:	e58d3044 	str	r3, [sp, #68]	; 0x44
						if(tmp != 0xFFFFFFF)
30029100:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30029104:	e373021f 	cmn	r3, #-268435455	; 0xf0000001
30029108:	0a000002 	beq	30029118 <FileRead+0x5fc>
							fp->Clus =tmp;
3002910c:	e59d2044 	ldr	r2, [sp, #68]	; 0x44
30029110:	e59d3018 	ldr	r3, [sp, #24]
30029114:	e583201c 	str	r2, [r3, #28]
						//fp->Clus = FATGetNextClus(fp->Drive,fp->Clus); change serious logical wrong
					}
				}

				//�����м�����
				for(;RealSize >= DiskInfo->BytsPerSec;RealSize -= DiskInfo->BytsPerSec)
30029118:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3002911c:	e593300c 	ldr	r3, [r3, #12]
30029120:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30029124:	e0633002 	rsb	r3, r3, r2
30029128:	e58d302c 	str	r3, [sp, #44]	; 0x2c
3002912c:	ea000002 	b	3002913c <FileRead+0x620>
30029130:	e1a00000 	nop			; (mov r0, r0)
30029134:	ea000000 	b	3002913c <FileRead+0x620>
30029138:	e1a00000 	nop			; (mov r0, r0)
3002913c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30029140:	e593200c 	ldr	r2, [r3, #12]
30029144:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30029148:	e1520003 	cmp	r2, r3
3002914c:	9affff7d 	bls	30028f48 <FileRead+0x42c>
					}
					
				}

				//�������һ������
				if(RealSize>0)
30029150:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30029154:	e3530000 	cmp	r3, #0
30029158:	0a000042 	beq	30029268 <FileRead+0x74c>
				{
					SecIndex=(fp->Clus-2) * DiskInfo->SecPerClus+DiskInfo->DataStartSec+i;
3002915c:	e59d3018 	ldr	r3, [sp, #24]
30029160:	e593301c 	ldr	r3, [r3, #28]
30029164:	e2433002 	sub	r3, r3, #2
30029168:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3002916c:	e5d22002 	ldrb	r2, [r2, #2]
30029170:	e0020293 	mul	r2, r3, r2
30029174:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30029178:	e5933020 	ldr	r3, [r3, #32]
3002917c:	e0822003 	add	r2, r2, r3
30029180:	e59d301c 	ldr	r3, [sp, #28]
30029184:	e0823003 	add	r3, r2, r3
30029188:	e58d3028 	str	r3, [sp, #40]	; 0x28
					if((SecBuf = OpenSec(fp->Drive,SecIndex))==NULL)
3002918c:	e59d3018 	ldr	r3, [sp, #24]
30029190:	e5d3300c 	ldrb	r3, [r3, #12]
30029194:	e1a00003 	mov	r0, r3
30029198:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3002919c:	eb000b21 	bl	3002be28 <OpenSec>
300291a0:	e1a03000 	mov	r3, r0
300291a4:	e58d3038 	str	r3, [sp, #56]	; 0x38
300291a8:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
300291ac:	e3530000 	cmp	r3, #0
300291b0:	1a000001 	bne	300291bc <FileRead+0x6a0>
						return -1;
300291b4:	e3e03000 	mvn	r3, #0
300291b8:	ea00002c 	b	30029270 <FileRead+0x754>
					if(ReadSec(fp->Drive,SecIndex) != RETURN_OK)
300291bc:	e59d3018 	ldr	r3, [sp, #24]
300291c0:	e5d3300c 	ldrb	r3, [r3, #12]
300291c4:	e1a00003 	mov	r0, r3
300291c8:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
300291cc:	eb000bb9 	bl	3002c0b8 <ReadSec>
300291d0:	e1a03000 	mov	r3, r0
300291d4:	e3530000 	cmp	r3, #0
300291d8:	0a000001 	beq	300291e4 <FileRead+0x6c8>
						return -1;
300291dc:	e3e03000 	mvn	r3, #0
300291e0:	ea000022 	b	30029270 <FileRead+0x754>
					for(k=0;k<RealSize;k++)
300291e4:	e3a03000 	mov	r3, #0
300291e8:	e58d3024 	str	r3, [sp, #36]	; 0x24
300291ec:	ea00000b 	b	30029220 <FileRead+0x704>
						*Buf++ = SecBuf[k];
300291f0:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
300291f4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300291f8:	e0823003 	add	r3, r2, r3
300291fc:	e5d32000 	ldrb	r2, [r3]
30029200:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30029204:	e5c32000 	strb	r2, [r3]
30029208:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3002920c:	e2833001 	add	r3, r3, #1
30029210:	e58d303c 	str	r3, [sp, #60]	; 0x3c
					SecIndex=(fp->Clus-2) * DiskInfo->SecPerClus+DiskInfo->DataStartSec+i;
					if((SecBuf = OpenSec(fp->Drive,SecIndex))==NULL)
						return -1;
					if(ReadSec(fp->Drive,SecIndex) != RETURN_OK)
						return -1;
					for(k=0;k<RealSize;k++)
30029214:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30029218:	e2833001 	add	r3, r3, #1
3002921c:	e58d3024 	str	r3, [sp, #36]	; 0x24
30029220:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30029224:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30029228:	e1520003 	cmp	r2, r3
3002922c:	3affffef 	bcc	300291f0 <FileRead+0x6d4>
						*Buf++ = SecBuf[k];
					CloseSec(fp->Drive,SecIndex);
30029230:	e59d3018 	ldr	r3, [sp, #24]
30029234:	e5d3300c 	ldrb	r3, [r3, #12]
30029238:	e1a00003 	mov	r0, r3
3002923c:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
30029240:	eb0009f0 	bl	3002ba08 <CloseSec>
					fp->Offset = fp->Offset+RealSize;					
30029244:	e59d3018 	ldr	r3, [sp, #24]
30029248:	e5932020 	ldr	r2, [r3, #32]
3002924c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30029250:	e0822003 	add	r2, r2, r3
30029254:	e59d3018 	ldr	r3, [sp, #24]
30029258:	e5832020 	str	r2, [r3, #32]
3002925c:	ea000002 	b	3002926c <FileRead+0x750>
				}
			}
			else
				return -1;
30029260:	e3e03000 	mvn	r3, #0
30029264:	ea000001 	b	30029270 <FileRead+0x754>
					if(ReadSec(fp->Drive,SecIndex) != RETURN_OK)
						return -1;
					for(k=0;k<RealSize;k++)
						*Buf++ = SecBuf[k];
					CloseSec(fp->Drive,SecIndex);
					fp->Offset = fp->Offset+RealSize;					
30029268:	e1a00000 	nop			; (mov r0, r0)
			}
			else
				return -1;
		}
	}
	return Rt;
3002926c:	e59d3014 	ldr	r3, [sp, #20]
}
30029270:	e1a00003 	mov	r0, r3
30029274:	e28dd04c 	add	sp, sp, #76	; 0x4c
30029278:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002927c:	e12fff1e 	bx	lr
30029280:	300e3ebc 	.word	0x300e3ebc

30029284 <FilePutCh>:
**        ����ο�fat.h�й��ڷ���ֵ��˵�� 
** ȫ�ֱ���: ��
** ����ģ��: ��
********************************************************************************************************/
        acoral_u8 FilePutCh(acoral_u8 Ch, HANDLE Handle)
{
30029284:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30029288:	e24dd02c 	sub	sp, sp, #44	; 0x2c
3002928c:	e1a03000 	mov	r3, r0
30029290:	e58d1000 	str	r1, [sp]
30029294:	e5cd3007 	strb	r3, [sp, #7]
    MY_FILE *fp;
    Disk_Info * DiskInfo;
    acoral_u8 Rt;
    acoral_u8 *Buf;

    Rt = PARAMETER_ERR;
30029298:	e3e03000 	mvn	r3, #0
3002929c:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
    fp = FileInfo + Handle;
300292a0:	e59d2000 	ldr	r2, [sp]
300292a4:	e1a03002 	mov	r3, r2
300292a8:	e1a03183 	lsl	r3, r3, #3
300292ac:	e0833002 	add	r3, r3, r2
300292b0:	e1a03103 	lsl	r3, r3, #2
300292b4:	e1a02003 	mov	r2, r3
300292b8:	e59f32ac 	ldr	r3, [pc, #684]	; 3002956c <FilePutCh+0x2e8>
300292bc:	e0823003 	add	r3, r2, r3
300292c0:	e58d3018 	str	r3, [sp, #24]
    if (Handle >= 0 && Handle < MAX_OPEN_FILES)      /* Handle�Ƿ���Ч */
300292c4:	e59d3000 	ldr	r3, [sp]
300292c8:	e3530000 	cmp	r3, #0
300292cc:	ba0000a1 	blt	30029558 <FilePutCh+0x2d4>
300292d0:	e59d3000 	ldr	r3, [sp]
300292d4:	e3530009 	cmp	r3, #9
300292d8:	ca00009e 	bgt	30029558 <FilePutCh+0x2d4>
    if (((fp->Flags) & FILE_FLAGS_WRITE) != 0)       /* ��Ӧ�Ĵ��ļ���Ϣ���Ƿ���ʹ�� */
300292dc:	e59d3018 	ldr	r3, [sp, #24]
300292e0:	e5d33000 	ldrb	r3, [r3]
300292e4:	e2033002 	and	r3, r3, #2
300292e8:	e3530000 	cmp	r3, #0
300292ec:	0a000099 	beq	30029558 <FilePutCh+0x2d4>
    {
        Rt = FILE_EOF;
300292f0:	e3a03011 	mov	r3, #17
300292f4:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
        if (fp->Offset <= fp->FileSize)
300292f8:	e59d3018 	ldr	r3, [sp, #24]
300292fc:	e5932020 	ldr	r2, [r3, #32]
30029300:	e59d3018 	ldr	r3, [sp, #24]
30029304:	e5933014 	ldr	r3, [r3, #20]
30029308:	e1520003 	cmp	r2, r3
3002930c:	8a000091 	bhi	30029558 <FilePutCh+0x2d4>
        {
            Rt = NOT_FIND_DISK;
30029310:	e3a03001 	mov	r3, #1
30029314:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
                /* ��ȡ�ļ������߼�����Ϣ */
            DiskInfo = GetDiskInfo(fp->Drive);
30029318:	e59d3018 	ldr	r3, [sp, #24]
3002931c:	e5d3300c 	ldrb	r3, [r3, #12]
30029320:	e1a00003 	mov	r0, r3
30029324:	ebffec3d 	bl	30024420 <GetDiskInfo>
30029328:	e1a03000 	mov	r3, r0
3002932c:	e58d301c 	str	r3, [sp, #28]
            if (DiskInfo != NULL)
30029330:	e59d301c 	ldr	r3, [sp, #28]
30029334:	e3530000 	cmp	r3, #0
30029338:	0a000086 	beq	30029558 <FilePutCh+0x2d4>
            {
                
                /* �����ļ�ָ�� */
                j = (fp->Offset) % (DiskInfo->SecPerClus * DiskInfo->BytsPerSec); 
3002933c:	e59d3018 	ldr	r3, [sp, #24]
30029340:	e5932020 	ldr	r2, [r3, #32]
30029344:	e59d301c 	ldr	r3, [sp, #28]
30029348:	e5d33002 	ldrb	r3, [r3, #2]
3002934c:	e59d101c 	ldr	r1, [sp, #28]
30029350:	e591100c 	ldr	r1, [r1, #12]
30029354:	e0030391 	mul	r3, r1, r3
30029358:	e1a00002 	mov	r0, r2
3002935c:	e1a01003 	mov	r1, r3
30029360:	eb006a8b 	bl	30043d94 <__aeabi_uidivmod>
30029364:	e1a03001 	mov	r3, r1
30029368:	e58d3010 	str	r3, [sp, #16]
                
                if (j == 0)
3002936c:	e59d3010 	ldr	r3, [sp, #16]
30029370:	e3530000 	cmp	r3, #0
30029374:	1a000028 	bne	3002941c <FilePutCh+0x198>
                {
                    if (fp->Offset < fp->FileSize)
30029378:	e59d3018 	ldr	r3, [sp, #24]
3002937c:	e5932020 	ldr	r2, [r3, #32]
30029380:	e59d3018 	ldr	r3, [sp, #24]
30029384:	e5933014 	ldr	r3, [r3, #20]
30029388:	e1520003 	cmp	r2, r3
3002938c:	2a00000a 	bcs	300293bc <FilePutCh+0x138>
                    {
                        fp->Clus = FATGetNextClus(fp->Drive, fp->Clus);
30029390:	e59d3018 	ldr	r3, [sp, #24]
30029394:	e5d3200c 	ldrb	r2, [r3, #12]
30029398:	e59d3018 	ldr	r3, [sp, #24]
3002939c:	e593301c 	ldr	r3, [r3, #28]
300293a0:	e1a00002 	mov	r0, r2
300293a4:	e1a01003 	mov	r1, r3
300293a8:	ebffef92 	bl	300251f8 <FATGetNextClus>
300293ac:	e1a02000 	mov	r2, r0
300293b0:	e59d3018 	ldr	r3, [sp, #24]
300293b4:	e583201c 	str	r2, [r3, #28]
300293b8:	ea000017 	b	3002941c <FilePutCh+0x198>
                    }
                    else
                    {
                        i = FATAddClus(fp->Drive, fp->Clus);
300293bc:	e59d3018 	ldr	r3, [sp, #24]
300293c0:	e5d3200c 	ldrb	r2, [r3, #12]
300293c4:	e59d3018 	ldr	r3, [sp, #24]
300293c8:	e593301c 	ldr	r3, [r3, #28]
300293cc:	e1a00002 	mov	r0, r2
300293d0:	e1a01003 	mov	r1, r3
300293d4:	ebfff236 	bl	30025cb4 <FATAddClus>
300293d8:	e1a03000 	mov	r3, r0
300293dc:	e58d300c 	str	r3, [sp, #12]
                        if (i >= BAD_CLUS)
300293e0:	e59d300c 	ldr	r3, [sp, #12]
300293e4:	e37302af 	cmn	r3, #-268435446	; 0xf000000a
300293e8:	9a000001 	bls	300293f4 <FilePutCh+0x170>
                        {
                            return DISK_FULL;
300293ec:	e3a03002 	mov	r3, #2
300293f0:	ea000059 	b	3002955c <FilePutCh+0x2d8>
                        }
                        fp->Clus = i;
300293f4:	e59d3018 	ldr	r3, [sp, #24]
300293f8:	e59d200c 	ldr	r2, [sp, #12]
300293fc:	e583201c 	str	r2, [r3, #28]
                        if (fp->FstClus == EMPTY_CLUS)
30029400:	e59d3018 	ldr	r3, [sp, #24]
30029404:	e5933018 	ldr	r3, [r3, #24]
30029408:	e3530000 	cmp	r3, #0
3002940c:	1a000002 	bne	3002941c <FilePutCh+0x198>
                        {
                            fp->FstClus = i;
30029410:	e59d3018 	ldr	r3, [sp, #24]
30029414:	e59d200c 	ldr	r2, [sp, #12]
30029418:	e5832018 	str	r2, [r3, #24]
                        }
                    }
                }
                
                /* ��������������� */
                i = j / DiskInfo->BytsPerSec;
3002941c:	e59d301c 	ldr	r3, [sp, #28]
30029420:	e593300c 	ldr	r3, [r3, #12]
30029424:	e59d0010 	ldr	r0, [sp, #16]
30029428:	e1a01003 	mov	r1, r3
3002942c:	eb006a1b 	bl	30043ca0 <__aeabi_uidiv>
30029430:	e1a03000 	mov	r3, r0
30029434:	e58d300c 	str	r3, [sp, #12]
                j = j % DiskInfo->BytsPerSec;
30029438:	e59d301c 	ldr	r3, [sp, #28]
3002943c:	e593300c 	ldr	r3, [r3, #12]
30029440:	e59d2010 	ldr	r2, [sp, #16]
30029444:	e1a00002 	mov	r0, r2
30029448:	e1a01003 	mov	r1, r3
3002944c:	eb006a50 	bl	30043d94 <__aeabi_uidivmod>
30029450:	e1a03001 	mov	r3, r1
30029454:	e58d3010 	str	r3, [sp, #16]
                SecIndex = (fp->Clus - 2) * DiskInfo->SecPerClus + DiskInfo->DataStartSec + i;
30029458:	e59d3018 	ldr	r3, [sp, #24]
3002945c:	e593301c 	ldr	r3, [r3, #28]
30029460:	e2433002 	sub	r3, r3, #2
30029464:	e59d201c 	ldr	r2, [sp, #28]
30029468:	e5d22002 	ldrb	r2, [r2, #2]
3002946c:	e0020293 	mul	r2, r3, r2
30029470:	e59d301c 	ldr	r3, [sp, #28]
30029474:	e5933020 	ldr	r3, [r3, #32]
30029478:	e0822003 	add	r2, r2, r3
3002947c:	e59d300c 	ldr	r3, [sp, #12]
30029480:	e0823003 	add	r3, r2, r3
30029484:	e58d3014 	str	r3, [sp, #20]
                Rt = SECTOR_READ_ERR;
30029488:	e3a03005 	mov	r3, #5
3002948c:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
                
                /* ������ļ���Ϣ�� */
                fp->Offset++;
30029490:	e59d3018 	ldr	r3, [sp, #24]
30029494:	e5933020 	ldr	r3, [r3, #32]
30029498:	e2832001 	add	r2, r3, #1
3002949c:	e59d3018 	ldr	r3, [sp, #24]
300294a0:	e5832020 	str	r2, [r3, #32]
                if (fp->Offset > fp->FileSize)
300294a4:	e59d3018 	ldr	r3, [sp, #24]
300294a8:	e5932020 	ldr	r2, [r3, #32]
300294ac:	e59d3018 	ldr	r3, [sp, #24]
300294b0:	e5933014 	ldr	r3, [r3, #20]
300294b4:	e1520003 	cmp	r2, r3
300294b8:	9a000003 	bls	300294cc <FilePutCh+0x248>
                {
                    fp->FileSize = fp->Offset;
300294bc:	e59d3018 	ldr	r3, [sp, #24]
300294c0:	e5932020 	ldr	r2, [r3, #32]
300294c4:	e59d3018 	ldr	r3, [sp, #24]
300294c8:	e5832014 	str	r2, [r3, #20]
                }

                /* ������ */
                Buf = OpenSec(fp->Drive, SecIndex);
300294cc:	e59d3018 	ldr	r3, [sp, #24]
300294d0:	e5d3300c 	ldrb	r3, [r3, #12]
300294d4:	e1a00003 	mov	r0, r3
300294d8:	e59d1014 	ldr	r1, [sp, #20]
300294dc:	eb000a51 	bl	3002be28 <OpenSec>
300294e0:	e1a03000 	mov	r3, r0
300294e4:	e58d3024 	str	r3, [sp, #36]	; 0x24
                if (Buf != NULL)
300294e8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300294ec:	e3530000 	cmp	r3, #0
300294f0:	0a000018 	beq	30029558 <FilePutCh+0x2d4>
                {
                    /* д������� */
                    if (ReadSec(fp->Drive, SecIndex) == RETURN_OK)
300294f4:	e59d3018 	ldr	r3, [sp, #24]
300294f8:	e5d3300c 	ldrb	r3, [r3, #12]
300294fc:	e1a00003 	mov	r0, r3
30029500:	e59d1014 	ldr	r1, [sp, #20]
30029504:	eb000aeb 	bl	3002c0b8 <ReadSec>
30029508:	e1a03000 	mov	r3, r0
3002950c:	e3530000 	cmp	r3, #0
30029510:	1a00000b 	bne	30029544 <FilePutCh+0x2c0>
                    {
                        /* �洢��� */
                        Buf[j] = Ch;
30029514:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30029518:	e59d3010 	ldr	r3, [sp, #16]
3002951c:	e0823003 	add	r3, r2, r3
30029520:	e5dd2007 	ldrb	r2, [sp, #7]
30029524:	e5c32000 	strb	r2, [r3]
                        WriteSec(fp->Drive, SecIndex);
30029528:	e59d3018 	ldr	r3, [sp, #24]
3002952c:	e5d3300c 	ldrb	r3, [r3, #12]
30029530:	e1a00003 	mov	r0, r3
30029534:	e59d1014 	ldr	r1, [sp, #20]
30029538:	eb000b41 	bl	3002c244 <WriteSec>
                        Rt = RETURN_OK;
3002953c:	e3a03000 	mov	r3, #0
30029540:	e5cd3023 	strb	r3, [sp, #35]	; 0x23
                    }
                    CloseSec(fp->Drive, SecIndex);
30029544:	e59d3018 	ldr	r3, [sp, #24]
30029548:	e5d3300c 	ldrb	r3, [r3, #12]
3002954c:	e1a00003 	mov	r0, r3
30029550:	e59d1014 	ldr	r1, [sp, #20]
30029554:	eb00092b 	bl	3002ba08 <CloseSec>
                }
            }
        }
    }
    return Rt;
30029558:	e5dd3023 	ldrb	r3, [sp, #35]	; 0x23
}
3002955c:	e1a00003 	mov	r0, r3
30029560:	e28dd02c 	add	sp, sp, #44	; 0x2c
30029564:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30029568:	e12fff1e 	bx	lr
3002956c:	300e3ebc 	.word	0x300e3ebc

30029570 <FileWrite>:
        temp++;
    }
    return i;
}*/
	acoral_32 FileWrite(const void *Buf_in,acoral_u32 Size,HANDLE Handle)
{
30029570:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30029574:	e24dd03c 	sub	sp, sp, #60	; 0x3c
30029578:	e58d000c 	str	r0, [sp, #12]
3002957c:	e58d1008 	str	r1, [sp, #8]
30029580:	e58d2004 	str	r2, [sp, #4]
	acoral_u8 *Buf=(acoral_u8 *)Buf_in;
30029584:	e59d300c 	ldr	r3, [sp, #12]
30029588:	e58d3010 	str	r3, [sp, #16]
	MY_FILE *fp;
	acoral_u8 *SecBuf=NULL;
3002958c:	e3a03000 	mov	r3, #0
30029590:	e58d3018 	str	r3, [sp, #24]
	Disk_Info *DiskInfo;
	acoral_u32 i,j,k,SecIndex,FirstSize,RealSize;

	fp=FileInfo+Handle;
30029594:	e59d2004 	ldr	r2, [sp, #4]
30029598:	e1a03002 	mov	r3, r2
3002959c:	e1a03183 	lsl	r3, r3, #3
300295a0:	e0833002 	add	r3, r3, r2
300295a4:	e1a03103 	lsl	r3, r3, #2
300295a8:	e1a02003 	mov	r2, r3
300295ac:	e59f381c 	ldr	r3, [pc, #2076]	; 30029dd0 <FileWrite+0x860>
300295b0:	e0823003 	add	r3, r2, r3
300295b4:	e58d3014 	str	r3, [sp, #20]
	RealSize=Size;
300295b8:	e59d3008 	ldr	r3, [sp, #8]
300295bc:	e58d3034 	str	r3, [sp, #52]	; 0x34

	if(Buf_in==NULL||Handle<0||Handle>=MAX_OPEN_FILES)
300295c0:	e59d300c 	ldr	r3, [sp, #12]
300295c4:	e3530000 	cmp	r3, #0
300295c8:	0a000005 	beq	300295e4 <FileWrite+0x74>
300295cc:	e59d3004 	ldr	r3, [sp, #4]
300295d0:	e3530000 	cmp	r3, #0
300295d4:	ba000002 	blt	300295e4 <FileWrite+0x74>
300295d8:	e59d3004 	ldr	r3, [sp, #4]
300295dc:	e3530009 	cmp	r3, #9
300295e0:	da000001 	ble	300295ec <FileWrite+0x7c>
		return -1;
300295e4:	e3e03000 	mvn	r3, #0
300295e8:	ea0001f4 	b	30029dc0 <FileWrite+0x850>
	if(fp->Offset>fp->FileSize || (((fp->Flags)&FILE_FLAGS_WRITE)==0))
300295ec:	e59d3014 	ldr	r3, [sp, #20]
300295f0:	e5932020 	ldr	r2, [r3, #32]
300295f4:	e59d3014 	ldr	r3, [sp, #20]
300295f8:	e5933014 	ldr	r3, [r3, #20]
300295fc:	e1520003 	cmp	r2, r3
30029600:	8a000004 	bhi	30029618 <FileWrite+0xa8>
30029604:	e59d3014 	ldr	r3, [sp, #20]
30029608:	e5d33000 	ldrb	r3, [r3]
3002960c:	e2033002 	and	r3, r3, #2
30029610:	e3530000 	cmp	r3, #0
30029614:	1a000001 	bne	30029620 <FileWrite+0xb0>
		return -1;
30029618:	e3e03000 	mvn	r3, #0
3002961c:	ea0001e7 	b	30029dc0 <FileWrite+0x850>
	if(Size==0)
30029620:	e59d3008 	ldr	r3, [sp, #8]
30029624:	e3530000 	cmp	r3, #0
30029628:	1a000001 	bne	30029634 <FileWrite+0xc4>
		return 0;
3002962c:	e3a03000 	mov	r3, #0
30029630:	ea0001e2 	b	30029dc0 <FileWrite+0x850>

	if((DiskInfo=GetDiskInfo(fp->Drive))==NULL)
30029634:	e59d3014 	ldr	r3, [sp, #20]
30029638:	e5d3300c 	ldrb	r3, [r3, #12]
3002963c:	e1a00003 	mov	r0, r3
30029640:	ebffeb76 	bl	30024420 <GetDiskInfo>
30029644:	e1a03000 	mov	r3, r0
30029648:	e58d301c 	str	r3, [sp, #28]
3002964c:	e59d301c 	ldr	r3, [sp, #28]
30029650:	e3530000 	cmp	r3, #0
30029654:	1a000001 	bne	30029660 <FileWrite+0xf0>
		return -1;
30029658:	e3e03000 	mvn	r3, #0
3002965c:	ea0001d7 	b	30029dc0 <FileWrite+0x850>
	j=fp->Offset%(DiskInfo->SecPerClus * DiskInfo->BytsPerSec);
30029660:	e59d3014 	ldr	r3, [sp, #20]
30029664:	e5932020 	ldr	r2, [r3, #32]
30029668:	e59d301c 	ldr	r3, [sp, #28]
3002966c:	e5d33002 	ldrb	r3, [r3, #2]
30029670:	e59d101c 	ldr	r1, [sp, #28]
30029674:	e591100c 	ldr	r1, [r1, #12]
30029678:	e0030391 	mul	r3, r1, r3
3002967c:	e1a00002 	mov	r0, r2
30029680:	e1a01003 	mov	r1, r3
30029684:	eb0069c2 	bl	30043d94 <__aeabi_uidivmod>
30029688:	e1a03001 	mov	r3, r1
3002968c:	e58d3024 	str	r3, [sp, #36]	; 0x24
	if(j==0)
30029690:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30029694:	e3530000 	cmp	r3, #0
30029698:	1a000028 	bne	30029740 <FileWrite+0x1d0>
	{
		if(fp->Offset<fp->FileSize)
3002969c:	e59d3014 	ldr	r3, [sp, #20]
300296a0:	e5932020 	ldr	r2, [r3, #32]
300296a4:	e59d3014 	ldr	r3, [sp, #20]
300296a8:	e5933014 	ldr	r3, [r3, #20]
300296ac:	e1520003 	cmp	r2, r3
300296b0:	2a00000a 	bcs	300296e0 <FileWrite+0x170>
			fp->Clus=FATGetNextClus(fp->Drive,fp->Clus);
300296b4:	e59d3014 	ldr	r3, [sp, #20]
300296b8:	e5d3200c 	ldrb	r2, [r3, #12]
300296bc:	e59d3014 	ldr	r3, [sp, #20]
300296c0:	e593301c 	ldr	r3, [r3, #28]
300296c4:	e1a00002 	mov	r0, r2
300296c8:	e1a01003 	mov	r1, r3
300296cc:	ebffeec9 	bl	300251f8 <FATGetNextClus>
300296d0:	e1a02000 	mov	r2, r0
300296d4:	e59d3014 	ldr	r3, [sp, #20]
300296d8:	e583201c 	str	r2, [r3, #28]
300296dc:	ea000017 	b	30029740 <FileWrite+0x1d0>
		else
		{
			i=FATAddClus(fp->Drive,fp->Clus);
300296e0:	e59d3014 	ldr	r3, [sp, #20]
300296e4:	e5d3200c 	ldrb	r2, [r3, #12]
300296e8:	e59d3014 	ldr	r3, [sp, #20]
300296ec:	e593301c 	ldr	r3, [r3, #28]
300296f0:	e1a00002 	mov	r0, r2
300296f4:	e1a01003 	mov	r1, r3
300296f8:	ebfff16d 	bl	30025cb4 <FATAddClus>
300296fc:	e1a03000 	mov	r3, r0
30029700:	e58d3020 	str	r3, [sp, #32]
			if(i>=BAD_CLUS)
30029704:	e59d3020 	ldr	r3, [sp, #32]
30029708:	e37302af 	cmn	r3, #-268435446	; 0xf000000a
3002970c:	9a000001 	bls	30029718 <FileWrite+0x1a8>
				return -1;
30029710:	e3e03000 	mvn	r3, #0
30029714:	ea0001a9 	b	30029dc0 <FileWrite+0x850>
			fp->Clus = i;
30029718:	e59d3014 	ldr	r3, [sp, #20]
3002971c:	e59d2020 	ldr	r2, [sp, #32]
30029720:	e583201c 	str	r2, [r3, #28]
			if(fp->FstClus==EMPTY_CLUS)
30029724:	e59d3014 	ldr	r3, [sp, #20]
30029728:	e5933018 	ldr	r3, [r3, #24]
3002972c:	e3530000 	cmp	r3, #0
30029730:	1a000002 	bne	30029740 <FileWrite+0x1d0>
				fp->FstClus=i;
30029734:	e59d3014 	ldr	r3, [sp, #20]
30029738:	e59d2020 	ldr	r2, [sp, #32]
3002973c:	e5832018 	str	r2, [r3, #24]
		}
	}
	i=j/DiskInfo->BytsPerSec;
30029740:	e59d301c 	ldr	r3, [sp, #28]
30029744:	e593300c 	ldr	r3, [r3, #12]
30029748:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3002974c:	e1a01003 	mov	r1, r3
30029750:	eb006952 	bl	30043ca0 <__aeabi_uidiv>
30029754:	e1a03000 	mov	r3, r0
30029758:	e58d3020 	str	r3, [sp, #32]
	j=j%DiskInfo->BytsPerSec;
3002975c:	e59d301c 	ldr	r3, [sp, #28]
30029760:	e593300c 	ldr	r3, [r3, #12]
30029764:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30029768:	e1a00002 	mov	r0, r2
3002976c:	e1a01003 	mov	r1, r3
30029770:	eb006987 	bl	30043d94 <__aeabi_uidivmod>
30029774:	e1a03001 	mov	r3, r1
30029778:	e58d3024 	str	r3, [sp, #36]	; 0x24
	SecIndex=(fp->Clus-2)*DiskInfo->SecPerClus+DiskInfo->DataStartSec+i;
3002977c:	e59d3014 	ldr	r3, [sp, #20]
30029780:	e593301c 	ldr	r3, [r3, #28]
30029784:	e2433002 	sub	r3, r3, #2
30029788:	e59d201c 	ldr	r2, [sp, #28]
3002978c:	e5d22002 	ldrb	r2, [r2, #2]
30029790:	e0020293 	mul	r2, r3, r2
30029794:	e59d301c 	ldr	r3, [sp, #28]
30029798:	e5933020 	ldr	r3, [r3, #32]
3002979c:	e0822003 	add	r2, r2, r3
300297a0:	e59d3020 	ldr	r3, [sp, #32]
300297a4:	e0823003 	add	r3, r2, r3
300297a8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	//�����һ������
	SecBuf = (acoral_u8 *)OpenSec(fp->Drive,SecIndex);
300297ac:	e59d3014 	ldr	r3, [sp, #20]
300297b0:	e5d3300c 	ldrb	r3, [r3, #12]
300297b4:	e1a00003 	mov	r0, r3
300297b8:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
300297bc:	eb000999 	bl	3002be28 <OpenSec>
300297c0:	e1a03000 	mov	r3, r0
300297c4:	e58d3018 	str	r3, [sp, #24]
	if(SecBuf == NULL)
300297c8:	e59d3018 	ldr	r3, [sp, #24]
300297cc:	e3530000 	cmp	r3, #0
300297d0:	1a000001 	bne	300297dc <FileWrite+0x26c>
		return -1;
300297d4:	e3e03000 	mvn	r3, #0
300297d8:	ea000178 	b	30029dc0 <FileWrite+0x850>
	if(ReadSec(fp->Drive,SecIndex) != RETURN_OK)
300297dc:	e59d3014 	ldr	r3, [sp, #20]
300297e0:	e5d3300c 	ldrb	r3, [r3, #12]
300297e4:	e1a00003 	mov	r0, r3
300297e8:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
300297ec:	eb000a31 	bl	3002c0b8 <ReadSec>
300297f0:	e1a03000 	mov	r3, r0
300297f4:	e3530000 	cmp	r3, #0
300297f8:	0a000001 	beq	30029804 <FileWrite+0x294>
		return -1;
300297fc:	e3e03000 	mvn	r3, #0
30029800:	ea00016e 	b	30029dc0 <FileWrite+0x850>
	FirstSize=(DiskInfo->BytsPerSec-j)<Size?(DiskInfo->BytsPerSec-j):Size;
30029804:	e59d301c 	ldr	r3, [sp, #28]
30029808:	e593200c 	ldr	r2, [r3, #12]
3002980c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30029810:	e0632002 	rsb	r2, r3, r2
30029814:	e59d3008 	ldr	r3, [sp, #8]
30029818:	e1520003 	cmp	r2, r3
3002981c:	31a03002 	movcc	r3, r2
30029820:	e58d3030 	str	r3, [sp, #48]	; 0x30
	for(k=0;k<FirstSize;k++)
30029824:	e3a03000 	mov	r3, #0
30029828:	e58d3028 	str	r3, [sp, #40]	; 0x28
3002982c:	ea00000e 	b	3002986c <FileWrite+0x2fc>
	{
		SecBuf[j]=*Buf++;
30029830:	e59d2018 	ldr	r2, [sp, #24]
30029834:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30029838:	e0823003 	add	r3, r2, r3
3002983c:	e59d2010 	ldr	r2, [sp, #16]
30029840:	e5d22000 	ldrb	r2, [r2]
30029844:	e5c32000 	strb	r2, [r3]
30029848:	e59d3010 	ldr	r3, [sp, #16]
3002984c:	e2833001 	add	r3, r3, #1
30029850:	e58d3010 	str	r3, [sp, #16]
		j++;
30029854:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30029858:	e2833001 	add	r3, r3, #1
3002985c:	e58d3024 	str	r3, [sp, #36]	; 0x24
	if(SecBuf == NULL)
		return -1;
	if(ReadSec(fp->Drive,SecIndex) != RETURN_OK)
		return -1;
	FirstSize=(DiskInfo->BytsPerSec-j)<Size?(DiskInfo->BytsPerSec-j):Size;
	for(k=0;k<FirstSize;k++)
30029860:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30029864:	e2833001 	add	r3, r3, #1
30029868:	e58d3028 	str	r3, [sp, #40]	; 0x28
3002986c:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30029870:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30029874:	e1520003 	cmp	r2, r3
30029878:	3affffec 	bcc	30029830 <FileWrite+0x2c0>
	{
		SecBuf[j]=*Buf++;
		j++;
	}
	WriteSec(fp->Drive,SecIndex);
3002987c:	e59d3014 	ldr	r3, [sp, #20]
30029880:	e5d3300c 	ldrb	r3, [r3, #12]
30029884:	e1a00003 	mov	r0, r3
30029888:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
3002988c:	eb000a6c 	bl	3002c244 <WriteSec>
	CloseSec(fp->Drive,SecIndex);
30029890:	e59d3014 	ldr	r3, [sp, #20]
30029894:	e5d3300c 	ldrb	r3, [r3, #12]
30029898:	e1a00003 	mov	r0, r3
3002989c:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
300298a0:	eb000858 	bl	3002ba08 <CloseSec>
	RealSize=RealSize-FirstSize;
300298a4:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
300298a8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
300298ac:	e0633002 	rsb	r3, r3, r2
300298b0:	e58d3034 	str	r3, [sp, #52]	; 0x34
	fp->Offset=fp->Offset+FirstSize;
300298b4:	e59d3014 	ldr	r3, [sp, #20]
300298b8:	e5932020 	ldr	r2, [r3, #32]
300298bc:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
300298c0:	e0822003 	add	r2, r2, r3
300298c4:	e59d3014 	ldr	r3, [sp, #20]
300298c8:	e5832020 	str	r2, [r3, #32]
	if(fp->Offset>fp->FileSize)
300298cc:	e59d3014 	ldr	r3, [sp, #20]
300298d0:	e5932020 	ldr	r2, [r3, #32]
300298d4:	e59d3014 	ldr	r3, [sp, #20]
300298d8:	e5933014 	ldr	r3, [r3, #20]
300298dc:	e1520003 	cmp	r2, r3
300298e0:	9a0000a6 	bls	30029b80 <FileWrite+0x610>
		fp->FileSize=fp->Offset;
300298e4:	e59d3014 	ldr	r3, [sp, #20]
300298e8:	e5932020 	ldr	r2, [r3, #32]
300298ec:	e59d3014 	ldr	r3, [sp, #20]
300298f0:	e5832014 	str	r2, [r3, #20]
	//�����м������
	for(;RealSize>=DiskInfo->BytsPerSec;RealSize-=DiskInfo->BytsPerSec)
300298f4:	ea0000a2 	b	30029b84 <FileWrite+0x614>
	{
		i++;
300298f8:	e59d3020 	ldr	r3, [sp, #32]
300298fc:	e2833001 	add	r3, r3, #1
30029900:	e58d3020 	str	r3, [sp, #32]
		if(i>=DiskInfo->SecPerClus)
30029904:	e59d301c 	ldr	r3, [sp, #28]
30029908:	e5d33002 	ldrb	r3, [r3, #2]
3002990c:	e1a02003 	mov	r2, r3
30029910:	e59d3020 	ldr	r3, [sp, #32]
30029914:	e1520003 	cmp	r2, r3
30029918:	8a000025 	bhi	300299b4 <FileWrite+0x444>
		{
			i=0;
3002991c:	e3a03000 	mov	r3, #0
30029920:	e58d3020 	str	r3, [sp, #32]
			if(fp->Offset<fp->FileSize)
30029924:	e59d3014 	ldr	r3, [sp, #20]
30029928:	e5932020 	ldr	r2, [r3, #32]
3002992c:	e59d3014 	ldr	r3, [sp, #20]
30029930:	e5933014 	ldr	r3, [r3, #20]
30029934:	e1520003 	cmp	r2, r3
30029938:	2a00000a 	bcs	30029968 <FileWrite+0x3f8>
				fp->Clus=FATGetNextClus(fp->Drive,fp->Clus);
3002993c:	e59d3014 	ldr	r3, [sp, #20]
30029940:	e5d3200c 	ldrb	r2, [r3, #12]
30029944:	e59d3014 	ldr	r3, [sp, #20]
30029948:	e593301c 	ldr	r3, [r3, #28]
3002994c:	e1a00002 	mov	r0, r2
30029950:	e1a01003 	mov	r1, r3
30029954:	ebffee27 	bl	300251f8 <FATGetNextClus>
30029958:	e1a02000 	mov	r2, r0
3002995c:	e59d3014 	ldr	r3, [sp, #20]
30029960:	e583201c 	str	r2, [r3, #28]
30029964:	ea000012 	b	300299b4 <FileWrite+0x444>
			else
			{
				k=FATAddClus(fp->Drive,fp->Clus);
30029968:	e59d3014 	ldr	r3, [sp, #20]
3002996c:	e5d3200c 	ldrb	r2, [r3, #12]
30029970:	e59d3014 	ldr	r3, [sp, #20]
30029974:	e593301c 	ldr	r3, [r3, #28]
30029978:	e1a00002 	mov	r0, r2
3002997c:	e1a01003 	mov	r1, r3
30029980:	ebfff0cb 	bl	30025cb4 <FATAddClus>
30029984:	e1a03000 	mov	r3, r0
30029988:	e58d3028 	str	r3, [sp, #40]	; 0x28
				if(k>=BAD_CLUS)
3002998c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30029990:	e37302af 	cmn	r3, #-268435446	; 0xf000000a
30029994:	9a000003 	bls	300299a8 <FileWrite+0x438>
					return (Size-RealSize);
30029998:	e59d2008 	ldr	r2, [sp, #8]
3002999c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
300299a0:	e0633002 	rsb	r3, r3, r2
300299a4:	ea000105 	b	30029dc0 <FileWrite+0x850>
				fp->Clus=k;
300299a8:	e59d3014 	ldr	r3, [sp, #20]
300299ac:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
300299b0:	e583201c 	str	r2, [r3, #28]
			}
		}		
		SecIndex=(fp->Clus-2)*DiskInfo->SecPerClus+DiskInfo->DataStartSec+i;
300299b4:	e59d3014 	ldr	r3, [sp, #20]
300299b8:	e593301c 	ldr	r3, [r3, #28]
300299bc:	e2433002 	sub	r3, r3, #2
300299c0:	e59d201c 	ldr	r2, [sp, #28]
300299c4:	e5d22002 	ldrb	r2, [r2, #2]
300299c8:	e0020293 	mul	r2, r3, r2
300299cc:	e59d301c 	ldr	r3, [sp, #28]
300299d0:	e5933020 	ldr	r3, [r3, #32]
300299d4:	e0822003 	add	r2, r2, r3
300299d8:	e59d3020 	ldr	r3, [sp, #32]
300299dc:	e0823003 	add	r3, r2, r3
300299e0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
		if((SecBuf=OpenSec(fp->Drive,SecIndex))==NULL)
300299e4:	e59d3014 	ldr	r3, [sp, #20]
300299e8:	e5d3300c 	ldrb	r3, [r3, #12]
300299ec:	e1a00003 	mov	r0, r3
300299f0:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
300299f4:	eb00090b 	bl	3002be28 <OpenSec>
300299f8:	e1a03000 	mov	r3, r0
300299fc:	e58d3018 	str	r3, [sp, #24]
30029a00:	e59d3018 	ldr	r3, [sp, #24]
30029a04:	e3530000 	cmp	r3, #0
30029a08:	1a000003 	bne	30029a1c <FileWrite+0x4ac>
			return (Size-RealSize);
30029a0c:	e59d2008 	ldr	r2, [sp, #8]
30029a10:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30029a14:	e0633002 	rsb	r3, r3, r2
30029a18:	ea0000e8 	b	30029dc0 <FileWrite+0x850>
		if((ReadSec(fp->Drive,SecIndex))!=RETURN_OK)
30029a1c:	e59d3014 	ldr	r3, [sp, #20]
30029a20:	e5d3300c 	ldrb	r3, [r3, #12]
30029a24:	e1a00003 	mov	r0, r3
30029a28:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
30029a2c:	eb0009a1 	bl	3002c0b8 <ReadSec>
30029a30:	e1a03000 	mov	r3, r0
30029a34:	e3530000 	cmp	r3, #0
30029a38:	0a000003 	beq	30029a4c <FileWrite+0x4dc>
			return (Size-RealSize);
30029a3c:	e59d2008 	ldr	r2, [sp, #8]
30029a40:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30029a44:	e0633002 	rsb	r3, r3, r2
30029a48:	ea0000dc 	b	30029dc0 <FileWrite+0x850>
		for(k=0;k<DiskInfo->BytsPerSec;k+=4)
30029a4c:	e3a03000 	mov	r3, #0
30029a50:	e58d3028 	str	r3, [sp, #40]	; 0x28
30029a54:	ea000023 	b	30029ae8 <FileWrite+0x578>
		{
			SecBuf[k]=Buf[0];
30029a58:	e59d2018 	ldr	r2, [sp, #24]
30029a5c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30029a60:	e0823003 	add	r3, r2, r3
30029a64:	e59d2010 	ldr	r2, [sp, #16]
30029a68:	e5d22000 	ldrb	r2, [r2]
30029a6c:	e5c32000 	strb	r2, [r3]
			SecBuf[k+1]=Buf[1];
30029a70:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30029a74:	e2832001 	add	r2, r3, #1
30029a78:	e59d3018 	ldr	r3, [sp, #24]
30029a7c:	e0823003 	add	r3, r2, r3
30029a80:	e59d2010 	ldr	r2, [sp, #16]
30029a84:	e2822001 	add	r2, r2, #1
30029a88:	e5d22000 	ldrb	r2, [r2]
30029a8c:	e5c32000 	strb	r2, [r3]
			SecBuf[k+2]=Buf[2];
30029a90:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30029a94:	e2832002 	add	r2, r3, #2
30029a98:	e59d3018 	ldr	r3, [sp, #24]
30029a9c:	e0823003 	add	r3, r2, r3
30029aa0:	e59d2010 	ldr	r2, [sp, #16]
30029aa4:	e2822002 	add	r2, r2, #2
30029aa8:	e5d22000 	ldrb	r2, [r2]
30029aac:	e5c32000 	strb	r2, [r3]
			SecBuf[k+3]=Buf[3];
30029ab0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30029ab4:	e2832003 	add	r2, r3, #3
30029ab8:	e59d3018 	ldr	r3, [sp, #24]
30029abc:	e0823003 	add	r3, r2, r3
30029ac0:	e59d2010 	ldr	r2, [sp, #16]
30029ac4:	e2822003 	add	r2, r2, #3
30029ac8:	e5d22000 	ldrb	r2, [r2]
30029acc:	e5c32000 	strb	r2, [r3]
			Buf+=4;
30029ad0:	e59d3010 	ldr	r3, [sp, #16]
30029ad4:	e2833004 	add	r3, r3, #4
30029ad8:	e58d3010 	str	r3, [sp, #16]
		SecIndex=(fp->Clus-2)*DiskInfo->SecPerClus+DiskInfo->DataStartSec+i;
		if((SecBuf=OpenSec(fp->Drive,SecIndex))==NULL)
			return (Size-RealSize);
		if((ReadSec(fp->Drive,SecIndex))!=RETURN_OK)
			return (Size-RealSize);
		for(k=0;k<DiskInfo->BytsPerSec;k+=4)
30029adc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30029ae0:	e2833004 	add	r3, r3, #4
30029ae4:	e58d3028 	str	r3, [sp, #40]	; 0x28
30029ae8:	e59d301c 	ldr	r3, [sp, #28]
30029aec:	e593200c 	ldr	r2, [r3, #12]
30029af0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30029af4:	e1520003 	cmp	r2, r3
30029af8:	8affffd6 	bhi	30029a58 <FileWrite+0x4e8>
			SecBuf[k+2]=Buf[2];
			SecBuf[k+3]=Buf[3];
			Buf+=4;
				
		}
		WriteSec(fp->Drive,SecIndex);
30029afc:	e59d3014 	ldr	r3, [sp, #20]
30029b00:	e5d3300c 	ldrb	r3, [r3, #12]
30029b04:	e1a00003 	mov	r0, r3
30029b08:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
30029b0c:	eb0009cc 	bl	3002c244 <WriteSec>
		CloseSec(fp->Drive,SecIndex);
30029b10:	e59d3014 	ldr	r3, [sp, #20]
30029b14:	e5d3300c 	ldrb	r3, [r3, #12]
30029b18:	e1a00003 	mov	r0, r3
30029b1c:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
30029b20:	eb0007b8 	bl	3002ba08 <CloseSec>
		fp->Offset=fp->Offset+DiskInfo->BytsPerSec;
30029b24:	e59d3014 	ldr	r3, [sp, #20]
30029b28:	e5932020 	ldr	r2, [r3, #32]
30029b2c:	e59d301c 	ldr	r3, [sp, #28]
30029b30:	e593300c 	ldr	r3, [r3, #12]
30029b34:	e0822003 	add	r2, r2, r3
30029b38:	e59d3014 	ldr	r3, [sp, #20]
30029b3c:	e5832020 	str	r2, [r3, #32]
		if(fp->Offset>fp->FileSize)
30029b40:	e59d3014 	ldr	r3, [sp, #20]
30029b44:	e5932020 	ldr	r2, [r3, #32]
30029b48:	e59d3014 	ldr	r3, [sp, #20]
30029b4c:	e5933014 	ldr	r3, [r3, #20]
30029b50:	e1520003 	cmp	r2, r3
30029b54:	9a000003 	bls	30029b68 <FileWrite+0x5f8>
			fp->FileSize=fp->Offset;
30029b58:	e59d3014 	ldr	r3, [sp, #20]
30029b5c:	e5932020 	ldr	r2, [r3, #32]
30029b60:	e59d3014 	ldr	r3, [sp, #20]
30029b64:	e5832014 	str	r2, [r3, #20]
	RealSize=RealSize-FirstSize;
	fp->Offset=fp->Offset+FirstSize;
	if(fp->Offset>fp->FileSize)
		fp->FileSize=fp->Offset;
	//�����м������
	for(;RealSize>=DiskInfo->BytsPerSec;RealSize-=DiskInfo->BytsPerSec)
30029b68:	e59d301c 	ldr	r3, [sp, #28]
30029b6c:	e593300c 	ldr	r3, [r3, #12]
30029b70:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
30029b74:	e0633002 	rsb	r3, r3, r2
30029b78:	e58d3034 	str	r3, [sp, #52]	; 0x34
30029b7c:	ea000000 	b	30029b84 <FileWrite+0x614>
30029b80:	e1a00000 	nop			; (mov r0, r0)
30029b84:	e59d301c 	ldr	r3, [sp, #28]
30029b88:	e593200c 	ldr	r2, [r3, #12]
30029b8c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30029b90:	e1520003 	cmp	r2, r3
30029b94:	9affff57 	bls	300298f8 <FileWrite+0x388>
		if(fp->Offset>fp->FileSize)
			fp->FileSize=fp->Offset;
	}

	//��������һ������
	if(RealSize>0)
30029b98:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30029b9c:	e3530000 	cmp	r3, #0
30029ba0:	0a000083 	beq	30029db4 <FileWrite+0x844>
	{
		i++;
30029ba4:	e59d3020 	ldr	r3, [sp, #32]
30029ba8:	e2833001 	add	r3, r3, #1
30029bac:	e58d3020 	str	r3, [sp, #32]
		if(i>=DiskInfo->SecPerClus)
30029bb0:	e59d301c 	ldr	r3, [sp, #28]
30029bb4:	e5d33002 	ldrb	r3, [r3, #2]
30029bb8:	e1a02003 	mov	r2, r3
30029bbc:	e59d3020 	ldr	r3, [sp, #32]
30029bc0:	e1520003 	cmp	r2, r3
30029bc4:	8a000025 	bhi	30029c60 <FileWrite+0x6f0>
		{
			i=0;
30029bc8:	e3a03000 	mov	r3, #0
30029bcc:	e58d3020 	str	r3, [sp, #32]
			if(fp->Offset<fp->FileSize)
30029bd0:	e59d3014 	ldr	r3, [sp, #20]
30029bd4:	e5932020 	ldr	r2, [r3, #32]
30029bd8:	e59d3014 	ldr	r3, [sp, #20]
30029bdc:	e5933014 	ldr	r3, [r3, #20]
30029be0:	e1520003 	cmp	r2, r3
30029be4:	2a00000a 	bcs	30029c14 <FileWrite+0x6a4>
				fp->Clus=FATGetNextClus(fp->Drive,fp->Clus);
30029be8:	e59d3014 	ldr	r3, [sp, #20]
30029bec:	e5d3200c 	ldrb	r2, [r3, #12]
30029bf0:	e59d3014 	ldr	r3, [sp, #20]
30029bf4:	e593301c 	ldr	r3, [r3, #28]
30029bf8:	e1a00002 	mov	r0, r2
30029bfc:	e1a01003 	mov	r1, r3
30029c00:	ebffed7c 	bl	300251f8 <FATGetNextClus>
30029c04:	e1a02000 	mov	r2, r0
30029c08:	e59d3014 	ldr	r3, [sp, #20]
30029c0c:	e583201c 	str	r2, [r3, #28]
30029c10:	ea000012 	b	30029c60 <FileWrite+0x6f0>
			else
			{
				k=FATAddClus(fp->Drive,fp->Clus);
30029c14:	e59d3014 	ldr	r3, [sp, #20]
30029c18:	e5d3200c 	ldrb	r2, [r3, #12]
30029c1c:	e59d3014 	ldr	r3, [sp, #20]
30029c20:	e593301c 	ldr	r3, [r3, #28]
30029c24:	e1a00002 	mov	r0, r2
30029c28:	e1a01003 	mov	r1, r3
30029c2c:	ebfff020 	bl	30025cb4 <FATAddClus>
30029c30:	e1a03000 	mov	r3, r0
30029c34:	e58d3028 	str	r3, [sp, #40]	; 0x28
				if(k>=BAD_CLUS)
30029c38:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30029c3c:	e37302af 	cmn	r3, #-268435446	; 0xf000000a
30029c40:	9a000003 	bls	30029c54 <FileWrite+0x6e4>
					return (Size-RealSize);
30029c44:	e59d2008 	ldr	r2, [sp, #8]
30029c48:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30029c4c:	e0633002 	rsb	r3, r3, r2
30029c50:	ea00005a 	b	30029dc0 <FileWrite+0x850>
				fp->Clus=k;
30029c54:	e59d3014 	ldr	r3, [sp, #20]
30029c58:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30029c5c:	e583201c 	str	r2, [r3, #28]
			}
		}		
		SecIndex=(fp->Clus-2)*DiskInfo->SecPerClus+DiskInfo->DataStartSec+i;
30029c60:	e59d3014 	ldr	r3, [sp, #20]
30029c64:	e593301c 	ldr	r3, [r3, #28]
30029c68:	e2433002 	sub	r3, r3, #2
30029c6c:	e59d201c 	ldr	r2, [sp, #28]
30029c70:	e5d22002 	ldrb	r2, [r2, #2]
30029c74:	e0020293 	mul	r2, r3, r2
30029c78:	e59d301c 	ldr	r3, [sp, #28]
30029c7c:	e5933020 	ldr	r3, [r3, #32]
30029c80:	e0822003 	add	r2, r2, r3
30029c84:	e59d3020 	ldr	r3, [sp, #32]
30029c88:	e0823003 	add	r3, r2, r3
30029c8c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
		if((SecBuf=OpenSec(fp->Drive,SecIndex))==NULL)
30029c90:	e59d3014 	ldr	r3, [sp, #20]
30029c94:	e5d3300c 	ldrb	r3, [r3, #12]
30029c98:	e1a00003 	mov	r0, r3
30029c9c:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
30029ca0:	eb000860 	bl	3002be28 <OpenSec>
30029ca4:	e1a03000 	mov	r3, r0
30029ca8:	e58d3018 	str	r3, [sp, #24]
30029cac:	e59d3018 	ldr	r3, [sp, #24]
30029cb0:	e3530000 	cmp	r3, #0
30029cb4:	1a000003 	bne	30029cc8 <FileWrite+0x758>
			return (Size-RealSize);
30029cb8:	e59d2008 	ldr	r2, [sp, #8]
30029cbc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30029cc0:	e0633002 	rsb	r3, r3, r2
30029cc4:	ea00003d 	b	30029dc0 <FileWrite+0x850>
		if((ReadSec(fp->Drive,SecIndex))!=RETURN_OK)
30029cc8:	e59d3014 	ldr	r3, [sp, #20]
30029ccc:	e5d3300c 	ldrb	r3, [r3, #12]
30029cd0:	e1a00003 	mov	r0, r3
30029cd4:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
30029cd8:	eb0008f6 	bl	3002c0b8 <ReadSec>
30029cdc:	e1a03000 	mov	r3, r0
30029ce0:	e3530000 	cmp	r3, #0
30029ce4:	0a000003 	beq	30029cf8 <FileWrite+0x788>
			return (Size-RealSize);
30029ce8:	e59d2008 	ldr	r2, [sp, #8]
30029cec:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30029cf0:	e0633002 	rsb	r3, r3, r2
30029cf4:	ea000031 	b	30029dc0 <FileWrite+0x850>
		for(k=0;k<RealSize;k++)
30029cf8:	e3a03000 	mov	r3, #0
30029cfc:	e58d3028 	str	r3, [sp, #40]	; 0x28
30029d00:	ea00000b 	b	30029d34 <FileWrite+0x7c4>
		{
			SecBuf[k]=*Buf++;
30029d04:	e59d2018 	ldr	r2, [sp, #24]
30029d08:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30029d0c:	e0823003 	add	r3, r2, r3
30029d10:	e59d2010 	ldr	r2, [sp, #16]
30029d14:	e5d22000 	ldrb	r2, [r2]
30029d18:	e5c32000 	strb	r2, [r3]
30029d1c:	e59d3010 	ldr	r3, [sp, #16]
30029d20:	e2833001 	add	r3, r3, #1
30029d24:	e58d3010 	str	r3, [sp, #16]
		SecIndex=(fp->Clus-2)*DiskInfo->SecPerClus+DiskInfo->DataStartSec+i;
		if((SecBuf=OpenSec(fp->Drive,SecIndex))==NULL)
			return (Size-RealSize);
		if((ReadSec(fp->Drive,SecIndex))!=RETURN_OK)
			return (Size-RealSize);
		for(k=0;k<RealSize;k++)
30029d28:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30029d2c:	e2833001 	add	r3, r3, #1
30029d30:	e58d3028 	str	r3, [sp, #40]	; 0x28
30029d34:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30029d38:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30029d3c:	e1520003 	cmp	r2, r3
30029d40:	3affffef 	bcc	30029d04 <FileWrite+0x794>
		{
			SecBuf[k]=*Buf++;
				
		}
		WriteSec(fp->Drive,SecIndex);
30029d44:	e59d3014 	ldr	r3, [sp, #20]
30029d48:	e5d3300c 	ldrb	r3, [r3, #12]
30029d4c:	e1a00003 	mov	r0, r3
30029d50:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
30029d54:	eb00093a 	bl	3002c244 <WriteSec>
		CloseSec(fp->Drive,SecIndex);
30029d58:	e59d3014 	ldr	r3, [sp, #20]
30029d5c:	e5d3300c 	ldrb	r3, [r3, #12]
30029d60:	e1a00003 	mov	r0, r3
30029d64:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
30029d68:	eb000726 	bl	3002ba08 <CloseSec>
		fp->Offset=fp->Offset+RealSize;
30029d6c:	e59d3014 	ldr	r3, [sp, #20]
30029d70:	e5932020 	ldr	r2, [r3, #32]
30029d74:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30029d78:	e0822003 	add	r2, r2, r3
30029d7c:	e59d3014 	ldr	r3, [sp, #20]
30029d80:	e5832020 	str	r2, [r3, #32]
		RealSize=0;
30029d84:	e3a03000 	mov	r3, #0
30029d88:	e58d3034 	str	r3, [sp, #52]	; 0x34
		if(fp->Offset>fp->FileSize)
30029d8c:	e59d3014 	ldr	r3, [sp, #20]
30029d90:	e5932020 	ldr	r2, [r3, #32]
30029d94:	e59d3014 	ldr	r3, [sp, #20]
30029d98:	e5933014 	ldr	r3, [r3, #20]
30029d9c:	e1520003 	cmp	r2, r3
30029da0:	9a000003 	bls	30029db4 <FileWrite+0x844>
			fp->FileSize=fp->Offset;		
30029da4:	e59d3014 	ldr	r3, [sp, #20]
30029da8:	e5932020 	ldr	r2, [r3, #32]
30029dac:	e59d3014 	ldr	r3, [sp, #20]
30029db0:	e5832014 	str	r2, [r3, #20]
	}
	return (Size-RealSize);
30029db4:	e59d2008 	ldr	r2, [sp, #8]
30029db8:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30029dbc:	e0633002 	rsb	r3, r3, r2
}
30029dc0:	e1a00003 	mov	r0, r3
30029dc4:	e28dd03c 	add	sp, sp, #60	; 0x3c
30029dc8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30029dcc:	e12fff1e 	bx	lr
30029dd0:	300e3ebc 	.word	0x300e3ebc

30029dd4 <FileCloseAll>:
**         
** ȫ�ֱ���: FileInfo
** ����ģ��: AllCacheWriteBack
********************************************************************************************************/
        void FileCloseAll(void)
{
30029dd4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30029dd8:	e24dd00c 	sub	sp, sp, #12
    acoral_u32 i;

    for (i = 0; i < MAX_OPEN_FILES; i++)
30029ddc:	e3a03000 	mov	r3, #0
30029de0:	e58d3004 	str	r3, [sp, #4]
30029de4:	ea000005 	b	30029e00 <FileCloseAll+0x2c>
    {
        FileClose(i);
30029de8:	e59d3004 	ldr	r3, [sp, #4]
30029dec:	e1a00003 	mov	r0, r3
30029df0:	ebfffa1d 	bl	3002866c <FileClose>
********************************************************************************************************/
        void FileCloseAll(void)
{
    acoral_u32 i;

    for (i = 0; i < MAX_OPEN_FILES; i++)
30029df4:	e59d3004 	ldr	r3, [sp, #4]
30029df8:	e2833001 	add	r3, r3, #1
30029dfc:	e58d3004 	str	r3, [sp, #4]
30029e00:	e59d3004 	ldr	r3, [sp, #4]
30029e04:	e3530009 	cmp	r3, #9
30029e08:	9afffff6 	bls	30029de8 <FileCloseAll+0x14>
    {
        FileClose(i);
    }
    AllCacheWriteBack();
30029e0c:	eb000763 	bl	3002bba0 <AllCacheWriteBack>
}
30029e10:	e28dd00c 	add	sp, sp, #12
30029e14:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30029e18:	e12fff1e 	bx	lr

30029e1c <FileEof>:
**        1:�� 
** ȫ�ֱ���: FileInfo
** ����ģ��: ��
********************************************************************************************************/
        acoral_u8 FileEof(HANDLE Handle)
{
30029e1c:	e24dd008 	sub	sp, sp, #8
30029e20:	e58d0004 	str	r0, [sp, #4]
    if (Handle < MAX_OPEN_FILES)
30029e24:	e59d3004 	ldr	r3, [sp, #4]
30029e28:	e3530009 	cmp	r3, #9
30029e2c:	ca000017 	bgt	30029e90 <FileEof+0x74>
    if (FileInfo[Handle].Offset < FileInfo[Handle].FileSize)
30029e30:	e59d2004 	ldr	r2, [sp, #4]
30029e34:	e59f0064 	ldr	r0, [pc, #100]	; 30029ea0 <FileEof+0x84>
30029e38:	e3a01020 	mov	r1, #32
30029e3c:	e1a03002 	mov	r3, r2
30029e40:	e1a03183 	lsl	r3, r3, #3
30029e44:	e0833002 	add	r3, r3, r2
30029e48:	e1a03103 	lsl	r3, r3, #2
30029e4c:	e0833000 	add	r3, r3, r0
30029e50:	e0833001 	add	r3, r3, r1
30029e54:	e5931000 	ldr	r1, [r3]
30029e58:	e59d2004 	ldr	r2, [sp, #4]
30029e5c:	e59fc03c 	ldr	ip, [pc, #60]	; 30029ea0 <FileEof+0x84>
30029e60:	e3a00014 	mov	r0, #20
30029e64:	e1a03002 	mov	r3, r2
30029e68:	e1a03183 	lsl	r3, r3, #3
30029e6c:	e0833002 	add	r3, r3, r2
30029e70:	e1a03103 	lsl	r3, r3, #2
30029e74:	e083300c 	add	r3, r3, ip
30029e78:	e0833000 	add	r3, r3, r0
30029e7c:	e5933000 	ldr	r3, [r3]
30029e80:	e1510003 	cmp	r1, r3
30029e84:	2a000001 	bcs	30029e90 <FileEof+0x74>
    {
        return FALSE;
30029e88:	e3a03000 	mov	r3, #0
30029e8c:	ea000000 	b	30029e94 <FileEof+0x78>
    }
    return TRUE;
30029e90:	e3a03001 	mov	r3, #1
}
30029e94:	e1a00003 	mov	r0, r3
30029e98:	e28dd008 	add	sp, sp, #8
30029e9c:	e12fff1e 	bx	lr
30029ea0:	300e3ebc 	.word	0x300e3ebc

30029ea4 <FileSeek>:
**         
** ȫ�ֱ���: ��
** ����ģ��: ��
********************************************************************************************************/
        acoral_u32 FileSeek(HANDLE Handle, acoral_32 offset, acoral_u8 Whence)
{
30029ea4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30029ea8:	e24dd02c 	sub	sp, sp, #44	; 0x2c
30029eac:	e58d000c 	str	r0, [sp, #12]
30029eb0:	e58d1008 	str	r1, [sp, #8]
30029eb4:	e1a03002 	mov	r3, r2
30029eb8:	e5cd3007 	strb	r3, [sp, #7]
    acoral_u32 Rt;
    acoral_u32 i, Clus;
    MY_FILE *fp;
    Disk_Info * DiskInfo;
    
    Rt = PARAMETER_ERR;
30029ebc:	e3a030ff 	mov	r3, #255	; 0xff
30029ec0:	e58d3014 	str	r3, [sp, #20]
    fp = FileInfo + Handle;
30029ec4:	e59d200c 	ldr	r2, [sp, #12]
30029ec8:	e1a03002 	mov	r3, r2
30029ecc:	e1a03183 	lsl	r3, r3, #3
30029ed0:	e0833002 	add	r3, r3, r2
30029ed4:	e1a03103 	lsl	r3, r3, #2
30029ed8:	e1a02003 	mov	r2, r3
30029edc:	e59f31d0 	ldr	r3, [pc, #464]	; 3002a0b4 <FileSeek+0x210>
30029ee0:	e0823003 	add	r3, r2, r3
30029ee4:	e58d3020 	str	r3, [sp, #32]
    if (Handle >= 0 && Handle < MAX_OPEN_FILES)     /* Handle�Ƿ���Ч */
30029ee8:	e59d300c 	ldr	r3, [sp, #12]
30029eec:	e3530000 	cmp	r3, #0
30029ef0:	ba000064 	blt	3002a088 <FileSeek+0x1e4>
30029ef4:	e59d300c 	ldr	r3, [sp, #12]
30029ef8:	e3530009 	cmp	r3, #9
30029efc:	ca000061 	bgt	3002a088 <FileSeek+0x1e4>
    if (fp->Flags  != 0)                            /* ��Ӧ�Ĵ��ļ���Ϣ���Ƿ���ʹ�� */
30029f00:	e59d3020 	ldr	r3, [sp, #32]
30029f04:	e5d33000 	ldrb	r3, [r3]
30029f08:	e3530000 	cmp	r3, #0
30029f0c:	0a00005d 	beq	3002a088 <FileSeek+0x1e4>
    {
        Rt = RETURN_OK;
30029f10:	e3a03000 	mov	r3, #0
30029f14:	e58d3014 	str	r3, [sp, #20]
        switch (Whence)
30029f18:	e5dd3007 	ldrb	r3, [sp, #7]
30029f1c:	e3530001 	cmp	r3, #1
30029f20:	0a00000f 	beq	30029f64 <FileSeek+0xc0>
30029f24:	e3530002 	cmp	r3, #2
30029f28:	0a000002 	beq	30029f38 <FileSeek+0x94>
30029f2c:	e3530000 	cmp	r3, #0
30029f30:	0a000007 	beq	30029f54 <FileSeek+0xb0>
30029f34:	ea000010 	b	30029f7c <FileSeek+0xd8>
        {
            case SEEK_END:                          /* ���ļ�β���� */
                fp->Offset = fp->FileSize + offset;
30029f38:	e59d3020 	ldr	r3, [sp, #32]
30029f3c:	e5932014 	ldr	r2, [r3, #20]
30029f40:	e59d3008 	ldr	r3, [sp, #8]
30029f44:	e0822003 	add	r2, r2, r3
30029f48:	e59d3020 	ldr	r3, [sp, #32]
30029f4c:	e5832020 	str	r2, [r3, #32]
//                offset = -offset;
                break;
30029f50:	ea00000b 	b	30029f84 <FileSeek+0xe0>
            case SEEK_SET:
                fp->Offset = offset;
30029f54:	e59d2008 	ldr	r2, [sp, #8]
30029f58:	e59d3020 	ldr	r3, [sp, #32]
30029f5c:	e5832020 	str	r2, [r3, #32]
                break;
30029f60:	ea000007 	b	30029f84 <FileSeek+0xe0>
            case SEEK_CUR:                          /* �ӵ�ǰλ�ü��� */
                i = fp->Offset + offset;
30029f64:	e59d3020 	ldr	r3, [sp, #32]
30029f68:	e5932020 	ldr	r2, [r3, #32]
30029f6c:	e59d3008 	ldr	r3, [sp, #8]
30029f70:	e0823003 	add	r3, r2, r3
30029f74:	e58d3018 	str	r3, [sp, #24]
                break;
30029f78:	ea000001 	b	30029f84 <FileSeek+0xe0>
            default:
                Rt = PARAMETER_ERR;
30029f7c:	e3a030ff 	mov	r3, #255	; 0xff
30029f80:	e58d3014 	str	r3, [sp, #20]
                break;
        }
        if (Rt == RETURN_OK)
30029f84:	e59d3014 	ldr	r3, [sp, #20]
30029f88:	e3530000 	cmp	r3, #0
30029f8c:	1a00003d 	bne	3002a088 <FileSeek+0x1e4>
        {
            if (fp->Offset > fp->FileSize)
30029f90:	e59d3020 	ldr	r3, [sp, #32]
30029f94:	e5932020 	ldr	r2, [r3, #32]
30029f98:	e59d3020 	ldr	r3, [sp, #32]
30029f9c:	e5933014 	ldr	r3, [r3, #20]
30029fa0:	e1520003 	cmp	r2, r3
30029fa4:	9a000003 	bls	30029fb8 <FileSeek+0x114>
	fp->Offset=fp->FileSize;
30029fa8:	e59d3020 	ldr	r3, [sp, #32]
30029fac:	e5932014 	ldr	r2, [r3, #20]
30029fb0:	e59d3020 	ldr	r3, [sp, #32]
30029fb4:	e5832020 	str	r2, [r3, #32]
           if(fp->Offset<0)
    	fp->Offset=0;
            /* �ı䵱ǰ�غ� */
            Rt = NOT_FIND_DISK;
30029fb8:	e3a03001 	mov	r3, #1
30029fbc:	e58d3014 	str	r3, [sp, #20]
            DiskInfo = GetDiskInfo(fp->Drive);
30029fc0:	e59d3020 	ldr	r3, [sp, #32]
30029fc4:	e5d3300c 	ldrb	r3, [r3, #12]
30029fc8:	e1a00003 	mov	r0, r3
30029fcc:	ebffe913 	bl	30024420 <GetDiskInfo>
30029fd0:	e1a03000 	mov	r3, r0
30029fd4:	e58d3024 	str	r3, [sp, #36]	; 0x24
            if (DiskInfo != NULL)
30029fd8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30029fdc:	e3530000 	cmp	r3, #0
30029fe0:	0a000028 	beq	3002a088 <FileSeek+0x1e4>
            {
                Rt = RETURN_OK;
30029fe4:	e3a03000 	mov	r3, #0
30029fe8:	e58d3014 	str	r3, [sp, #20]
                i = fp->Offset / (DiskInfo->BytsPerSec * DiskInfo->SecPerClus);
30029fec:	e59d3020 	ldr	r3, [sp, #32]
30029ff0:	e5932020 	ldr	r2, [r3, #32]
30029ff4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30029ff8:	e593300c 	ldr	r3, [r3, #12]
30029ffc:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
3002a000:	e5d11002 	ldrb	r1, [r1, #2]
3002a004:	e0030391 	mul	r3, r1, r3
3002a008:	e1a00002 	mov	r0, r2
3002a00c:	e1a01003 	mov	r1, r3
3002a010:	eb006722 	bl	30043ca0 <__aeabi_uidiv>
3002a014:	e1a03000 	mov	r3, r0
3002a018:	e58d3018 	str	r3, [sp, #24]
                Clus = fp->FstClus;
3002a01c:	e59d3020 	ldr	r3, [sp, #32]
3002a020:	e5933018 	ldr	r3, [r3, #24]
3002a024:	e58d301c 	str	r3, [sp, #28]
                for (; i != 0; i--)
3002a028:	ea000010 	b	3002a070 <FileSeek+0x1cc>
                {
                    Clus = FATGetNextClus(fp->Drive, Clus);
3002a02c:	e59d3020 	ldr	r3, [sp, #32]
3002a030:	e5d3300c 	ldrb	r3, [r3, #12]
3002a034:	e1a00003 	mov	r0, r3
3002a038:	e59d101c 	ldr	r1, [sp, #28]
3002a03c:	ebffec6d 	bl	300251f8 <FATGetNextClus>
3002a040:	e1a03000 	mov	r3, r0
3002a044:	e58d301c 	str	r3, [sp, #28]
                    if (Clus >= BAD_CLUS)
3002a048:	e59d301c 	ldr	r3, [sp, #28]
3002a04c:	e37302af 	cmn	r3, #-268435446	; 0xf000000a
3002a050:	9a000003 	bls	3002a064 <FileSeek+0x1c0>
                    {
                        Rt = FAT_ERR;
3002a054:	e3a0300f 	mov	r3, #15
3002a058:	e58d3014 	str	r3, [sp, #20]
                       // break;   change there is a big logical wrong. if seek, the clus is bad, so we can't write
                        return Rt;
3002a05c:	e59d3014 	ldr	r3, [sp, #20]
3002a060:	ea00000f 	b	3002a0a4 <FileSeek+0x200>
            if (DiskInfo != NULL)
            {
                Rt = RETURN_OK;
                i = fp->Offset / (DiskInfo->BytsPerSec * DiskInfo->SecPerClus);
                Clus = fp->FstClus;
                for (; i != 0; i--)
3002a064:	e59d3018 	ldr	r3, [sp, #24]
3002a068:	e2433001 	sub	r3, r3, #1
3002a06c:	e58d3018 	str	r3, [sp, #24]
3002a070:	e59d3018 	ldr	r3, [sp, #24]
3002a074:	e3530000 	cmp	r3, #0
3002a078:	1affffeb 	bne	3002a02c <FileSeek+0x188>
                        Rt = FAT_ERR;
                       // break;   change there is a big logical wrong. if seek, the clus is bad, so we can't write
                        return Rt;
                    }
                }
                fp->Clus = Clus;
3002a07c:	e59d3020 	ldr	r3, [sp, #32]
3002a080:	e59d201c 	ldr	r2, [sp, #28]
3002a084:	e583201c 	str	r2, [r3, #28]
            }
        }
    }
    if(Rt!=RETURN_OK)
3002a088:	e59d3014 	ldr	r3, [sp, #20]
3002a08c:	e3530000 	cmp	r3, #0
3002a090:	0a000001 	beq	3002a09c <FileSeek+0x1f8>
    	return -1;
3002a094:	e3e03000 	mvn	r3, #0
3002a098:	ea000001 	b	3002a0a4 <FileSeek+0x200>
    else
    	return fp->Offset;
3002a09c:	e59d3020 	ldr	r3, [sp, #32]
3002a0a0:	e5933020 	ldr	r3, [r3, #32]
}
3002a0a4:	e1a00003 	mov	r0, r3
3002a0a8:	e28dd02c 	add	sp, sp, #44	; 0x2c
3002a0ac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002a0b0:	e12fff1e 	bx	lr
3002a0b4:	300e3ebc 	.word	0x300e3ebc

3002a0b8 <strupr>:
/*********************************************************************************************************
**                            FS��ʹ�õĺ��� 
********************************************************************************************************/

 acoral_char  *strupr(acoral_char *Str)					
{    acoral_char *cp;
3002a0b8:	e24dd010 	sub	sp, sp, #16
3002a0bc:	e58d0004 	str	r0, [sp, #4]
     cp = Str;
3002a0c0:	e59d3004 	ldr	r3, [sp, #4]
3002a0c4:	e58d300c 	str	r3, [sp, #12]
    while (*cp != 0)
3002a0c8:	ea000010 	b	3002a110 <strupr+0x58>
    {   if (*cp >= 'a' && *cp <= 'z' )
3002a0cc:	e59d300c 	ldr	r3, [sp, #12]
3002a0d0:	e5d33000 	ldrb	r3, [r3]
3002a0d4:	e3530060 	cmp	r3, #96	; 0x60
3002a0d8:	9a000009 	bls	3002a104 <strupr+0x4c>
3002a0dc:	e59d300c 	ldr	r3, [sp, #12]
3002a0e0:	e5d33000 	ldrb	r3, [r3]
3002a0e4:	e353007a 	cmp	r3, #122	; 0x7a
3002a0e8:	8a000005 	bhi	3002a104 <strupr+0x4c>
            *cp -=  'a' - 'A';
3002a0ec:	e59d300c 	ldr	r3, [sp, #12]
3002a0f0:	e5d33000 	ldrb	r3, [r3]
3002a0f4:	e2433020 	sub	r3, r3, #32
3002a0f8:	e20320ff 	and	r2, r3, #255	; 0xff
3002a0fc:	e59d300c 	ldr	r3, [sp, #12]
3002a100:	e5c32000 	strb	r2, [r3]
       cp++;
3002a104:	e59d300c 	ldr	r3, [sp, #12]
3002a108:	e2833001 	add	r3, r3, #1
3002a10c:	e58d300c 	str	r3, [sp, #12]
********************************************************************************************************/

 acoral_char  *strupr(acoral_char *Str)					
{    acoral_char *cp;
     cp = Str;
    while (*cp != 0)
3002a110:	e59d300c 	ldr	r3, [sp, #12]
3002a114:	e5d33000 	ldrb	r3, [r3]
3002a118:	e3530000 	cmp	r3, #0
3002a11c:	1affffea 	bne	3002a0cc <strupr+0x14>
    {   if (*cp >= 'a' && *cp <= 'z' )
            *cp -=  'a' - 'A';
       cp++;
    }
    return Str;
3002a120:	e59d3004 	ldr	r3, [sp, #4]
}
3002a124:	e1a00003 	mov	r0, r3
3002a128:	e28dd010 	add	sp, sp, #16
3002a12c:	e12fff1e 	bx	lr

3002a130 <Format>:
**
** ȫֱ: Buf
** ģ: 
********************************************************************************************************/
        acoral_u8 Format(acoral_u8 Drive, acoral_u32 SecPerDisk, acoral_u16 BytsPerSec)
{
3002a130:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002a134:	e24dd044 	sub	sp, sp, #68	; 0x44
3002a138:	e58d1008 	str	r1, [sp, #8]
3002a13c:	e1a03002 	mov	r3, r2
3002a140:	e1a02000 	mov	r2, r0
3002a144:	e5cd200f 	strb	r2, [sp, #15]
3002a148:	e1cd30b6 	strh	r3, [sp, #6]
    acoral_u16 i, j, temp;
    acoral_u32 temp1, k;
    Disk_RW_Parameter parameter;
    Disk_Info *Disk;

    Disk = GetDiskInfo(Drive);
3002a14c:	e5dd300f 	ldrb	r3, [sp, #15]
3002a150:	e1a00003 	mov	r0, r3
3002a154:	ebffe8b1 	bl	30024420 <GetDiskInfo>
3002a158:	e1a03000 	mov	r3, r0
3002a15c:	e58d303c 	str	r3, [sp, #60]	; 0x3c
    if (Disk != NULL)
3002a160:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3002a164:	e3530000 	cmp	r3, #0
3002a168:	0a0002b5 	beq	3002ac44 <Format+0xb14>
    {
        cp2 = Buf;
3002a16c:	e59f3ae4 	ldr	r3, [pc, #2788]	; 3002ac58 <Format+0xb28>
3002a170:	e58d3028 	str	r3, [sp, #40]	; 0x28
        for (i = 0; i < BytsPerSec; i++)
3002a174:	e3a03000 	mov	r3, #0
3002a178:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
3002a17c:	ea000008 	b	3002a1a4 <Format+0x74>
        {
            *cp2++ = 0;
3002a180:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002a184:	e3a02000 	mov	r2, #0
3002a188:	e5c32000 	strb	r2, [r3]
3002a18c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002a190:	e2833001 	add	r3, r3, #1
3002a194:	e58d3028 	str	r3, [sp, #40]	; 0x28

    Disk = GetDiskInfo(Drive);
    if (Disk != NULL)
    {
        cp2 = Buf;
        for (i = 0; i < BytsPerSec; i++)
3002a198:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3002a19c:	e2833001 	add	r3, r3, #1
3002a1a0:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
3002a1a4:	e1dd22be 	ldrh	r2, [sp, #46]	; 0x2e
3002a1a8:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a1ac:	e1520003 	cmp	r2, r3
3002a1b0:	3afffff2 	bcc	3002a180 <Format+0x50>
        {
            *cp2++ = 0;
        }
        
        cp1 = Root;
3002a1b4:	e59f3aa0 	ldr	r3, [pc, #2720]	; 3002ac5c <Format+0xb2c>
3002a1b8:	e58d3024 	str	r3, [sp, #36]	; 0x24
        cp2 = Buf;
3002a1bc:	e59f3a94 	ldr	r3, [pc, #2708]	; 3002ac58 <Format+0xb28>
3002a1c0:	e58d3028 	str	r3, [sp, #40]	; 0x28
        for (i = 0; i < 512; i++)
3002a1c4:	e3a03000 	mov	r3, #0
3002a1c8:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
3002a1cc:	ea00000c 	b	3002a204 <Format+0xd4>
        {
            *cp2++ = *cp1++;
3002a1d0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3002a1d4:	e5d32000 	ldrb	r2, [r3]
3002a1d8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002a1dc:	e5c32000 	strb	r2, [r3]
3002a1e0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002a1e4:	e2833001 	add	r3, r3, #1
3002a1e8:	e58d3028 	str	r3, [sp, #40]	; 0x28
3002a1ec:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3002a1f0:	e2833001 	add	r3, r3, #1
3002a1f4:	e58d3024 	str	r3, [sp, #36]	; 0x24
            *cp2++ = 0;
        }
        
        cp1 = Root;
        cp2 = Buf;
        for (i = 0; i < 512; i++)
3002a1f8:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3002a1fc:	e2833001 	add	r3, r3, #1
3002a200:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
3002a204:	e1dd22be 	ldrh	r2, [sp, #46]	; 0x2e
3002a208:	e3a03f7f 	mov	r3, #508	; 0x1fc
3002a20c:	e2833003 	add	r3, r3, #3
3002a210:	e1520003 	cmp	r2, r3
3002a214:	9affffed 	bls	3002a1d0 <Format+0xa0>
        {
            *cp2++ = *cp1++;
        }
            /* ÿֽ */
        Buf[11] = BytsPerSec & 0xff;
3002a218:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a21c:	e20320ff 	and	r2, r3, #255	; 0xff
3002a220:	e59f3a30 	ldr	r3, [pc, #2608]	; 3002ac58 <Format+0xb28>
3002a224:	e5c3200b 	strb	r2, [r3, #11]
        Buf[12] = (BytsPerSec >> 8) & 0xff;
3002a228:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a22c:	e1a03423 	lsr	r3, r3, #8
3002a230:	e1a03803 	lsl	r3, r3, #16
3002a234:	e1a03823 	lsr	r3, r3, #16
3002a238:	e20320ff 	and	r2, r3, #255	; 0xff
3002a23c:	e59f3a14 	ldr	r3, [pc, #2580]	; 3002ac58 <Format+0xb28>
3002a240:	e5c3200c 	strb	r2, [r3, #12]
            /* ÿ */
        Buf[13] = 1;
3002a244:	e59f3a0c 	ldr	r3, [pc, #2572]	; 3002ac58 <Format+0xb28>
3002a248:	e3a02001 	mov	r2, #1
3002a24c:	e5c3200d 	strb	r2, [r3, #13]
            /*  */
        Buf[14] = 1;
3002a250:	e59f3a00 	ldr	r3, [pc, #2560]	; 3002ac58 <Format+0xb28>
3002a254:	e3a02001 	mov	r2, #1
3002a258:	e5c3200e 	strb	r2, [r3, #14]
        Buf[15] = 0;
3002a25c:	e59f39f4 	ldr	r3, [pc, #2548]	; 3002ac58 <Format+0xb28>
3002a260:	e3a02000 	mov	r2, #0
3002a264:	e5c3200f 	strb	r2, [r3, #15]
            /* FAT */
        Buf[16] = 1;
3002a268:	e59f39e8 	ldr	r3, [pc, #2536]	; 3002ac58 <Format+0xb28>
3002a26c:	e3a02001 	mov	r2, #1
3002a270:	e5c32010 	strb	r2, [r3, #16]

        Buf[19] = SecPerDisk & 0xff;
3002a274:	e59d3008 	ldr	r3, [sp, #8]
3002a278:	e20320ff 	and	r2, r3, #255	; 0xff
3002a27c:	e59f39d4 	ldr	r3, [pc, #2516]	; 3002ac58 <Format+0xb28>
3002a280:	e5c32013 	strb	r2, [r3, #19]
        Buf[20] = (SecPerDisk >> 8) & 0xff;
3002a284:	e59d3008 	ldr	r3, [sp, #8]
3002a288:	e1a03423 	lsr	r3, r3, #8
3002a28c:	e20320ff 	and	r2, r3, #255	; 0xff
3002a290:	e59f39c0 	ldr	r3, [pc, #2496]	; 3002ac58 <Format+0xb28>
3002a294:	e5c32014 	strb	r2, [r3, #20]
        if (SecPerDisk >= 0x10000)
3002a298:	e59d2008 	ldr	r2, [sp, #8]
3002a29c:	e3a03801 	mov	r3, #65536	; 0x10000
3002a2a0:	e2433001 	sub	r3, r3, #1
3002a2a4:	e1520003 	cmp	r2, r3
3002a2a8:	9a000018 	bls	3002a310 <Format+0x1e0>
        {
            Buf[19] = 0;
3002a2ac:	e59f39a4 	ldr	r3, [pc, #2468]	; 3002ac58 <Format+0xb28>
3002a2b0:	e3a02000 	mov	r2, #0
3002a2b4:	e5c32013 	strb	r2, [r3, #19]
            Buf[20] = 0;
3002a2b8:	e59f3998 	ldr	r3, [pc, #2456]	; 3002ac58 <Format+0xb28>
3002a2bc:	e3a02000 	mov	r2, #0
3002a2c0:	e5c32014 	strb	r2, [r3, #20]

            Buf[32] = SecPerDisk & 0xff;
3002a2c4:	e59d3008 	ldr	r3, [sp, #8]
3002a2c8:	e20320ff 	and	r2, r3, #255	; 0xff
3002a2cc:	e59f3984 	ldr	r3, [pc, #2436]	; 3002ac58 <Format+0xb28>
3002a2d0:	e5c32020 	strb	r2, [r3, #32]
            Buf[33] = (SecPerDisk >> 8) & 0xff;
3002a2d4:	e59d3008 	ldr	r3, [sp, #8]
3002a2d8:	e1a03423 	lsr	r3, r3, #8
3002a2dc:	e20320ff 	and	r2, r3, #255	; 0xff
3002a2e0:	e59f3970 	ldr	r3, [pc, #2416]	; 3002ac58 <Format+0xb28>
3002a2e4:	e5c32021 	strb	r2, [r3, #33]	; 0x21
            Buf[34] = (SecPerDisk >> 16) & 0xff;
3002a2e8:	e59d3008 	ldr	r3, [sp, #8]
3002a2ec:	e1a03823 	lsr	r3, r3, #16
3002a2f0:	e20320ff 	and	r2, r3, #255	; 0xff
3002a2f4:	e59f395c 	ldr	r3, [pc, #2396]	; 3002ac58 <Format+0xb28>
3002a2f8:	e5c32022 	strb	r2, [r3, #34]	; 0x22
            Buf[35] = (SecPerDisk >> 17) & 0xff;
3002a2fc:	e59d3008 	ldr	r3, [sp, #8]
3002a300:	e1a038a3 	lsr	r3, r3, #17
3002a304:	e20320ff 	and	r2, r3, #255	; 0xff
3002a308:	e59f3948 	ldr	r3, [pc, #2376]	; 3002ac58 <Format+0xb28>
3002a30c:	e5c32023 	strb	r2, [r3, #35]	; 0x23
        }

        temp = (4086 * 3 / 2 + BytsPerSec - 1) / BytsPerSec;
3002a310:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a314:	e2833d5f 	add	r3, r3, #6080	; 0x17c0
3002a318:	e2833030 	add	r3, r3, #48	; 0x30
3002a31c:	e1dd20b6 	ldrh	r2, [sp, #6]
3002a320:	e1a00003 	mov	r0, r3
3002a324:	e1a01002 	mov	r1, r2
3002a328:	eb0066a1 	bl	30043db4 <__aeabi_idiv>
3002a32c:	e1a03000 	mov	r3, r0
3002a330:	e1cd33b2 	strh	r3, [sp, #50]	; 0x32
        i = (0xe0 * 32 + BytsPerSec - 1) / BytsPerSec;
3002a334:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a338:	e2833d6f 	add	r3, r3, #7104	; 0x1bc0
3002a33c:	e283303f 	add	r3, r3, #63	; 0x3f
3002a340:	e1dd20b6 	ldrh	r2, [sp, #6]
3002a344:	e1a00003 	mov	r0, r3
3002a348:	e1a01002 	mov	r1, r2
3002a34c:	eb006698 	bl	30043db4 <__aeabi_idiv>
3002a350:	e1a03000 	mov	r3, r0
3002a354:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
        temp1 = SecPerDisk - temp - i;
3002a358:	e1dd33b2 	ldrh	r3, [sp, #50]	; 0x32
3002a35c:	e59d2008 	ldr	r2, [sp, #8]
3002a360:	e0632002 	rsb	r2, r3, r2
3002a364:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3002a368:	e0633002 	rsb	r3, r3, r2
3002a36c:	e58d3034 	str	r3, [sp, #52]	; 0x34
        if (temp1 < 4085)               /* FAT12 */
3002a370:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3002a374:	e3a03eff 	mov	r3, #4080	; 0xff0
3002a378:	e2833004 	add	r3, r3, #4
3002a37c:	e1520003 	cmp	r2, r3
3002a380:	8a000097 	bhi	3002a5e4 <Format+0x4b4>
        {
            temp = ((SecPerDisk - i - 1)  * 3 / 2 + BytsPerSec - 1) / BytsPerSec;
3002a384:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3002a388:	e59d2008 	ldr	r2, [sp, #8]
3002a38c:	e0632002 	rsb	r2, r3, r2
3002a390:	e1a03002 	mov	r3, r2
3002a394:	e1a03083 	lsl	r3, r3, #1
3002a398:	e0833002 	add	r3, r3, r2
3002a39c:	e2433003 	sub	r3, r3, #3
3002a3a0:	e1a020a3 	lsr	r2, r3, #1
3002a3a4:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a3a8:	e0823003 	add	r3, r2, r3
3002a3ac:	e2432001 	sub	r2, r3, #1
3002a3b0:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a3b4:	e1a00002 	mov	r0, r2
3002a3b8:	e1a01003 	mov	r1, r3
3002a3bc:	eb006637 	bl	30043ca0 <__aeabi_uidiv>
3002a3c0:	e1a03000 	mov	r3, r0
3002a3c4:	e1cd33b2 	strh	r3, [sp, #50]	; 0x32

            /* Ŀ¼FDT */
            i = (i * BytsPerSec) / 32;
3002a3c8:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3002a3cc:	e1dd20b6 	ldrh	r2, [sp, #6]
3002a3d0:	e0030392 	mul	r3, r2, r3
3002a3d4:	e283201f 	add	r2, r3, #31
3002a3d8:	e3530000 	cmp	r3, #0
3002a3dc:	b1a03002 	movlt	r3, r2
3002a3e0:	e1a032c3 	asr	r3, r3, #5
3002a3e4:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
            Buf[17] = i & 0xff;
3002a3e8:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3002a3ec:	e20320ff 	and	r2, r3, #255	; 0xff
3002a3f0:	e59f3860 	ldr	r3, [pc, #2144]	; 3002ac58 <Format+0xb28>
3002a3f4:	e5c32011 	strb	r2, [r3, #17]
            Buf[18] = (i >> 8) & 0xff;
3002a3f8:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3002a3fc:	e1a03423 	lsr	r3, r3, #8
3002a400:	e1a03803 	lsl	r3, r3, #16
3002a404:	e1a03823 	lsr	r3, r3, #16
3002a408:	e20320ff 	and	r2, r3, #255	; 0xff
3002a40c:	e59f3844 	ldr	r3, [pc, #2116]	; 3002ac58 <Format+0xb28>
3002a410:	e5c32012 	strb	r2, [r3, #18]

            /* FATռ */
            Buf[22] = temp & 0xff;
3002a414:	e1dd33b2 	ldrh	r3, [sp, #50]	; 0x32
3002a418:	e20320ff 	and	r2, r3, #255	; 0xff
3002a41c:	e59f3834 	ldr	r3, [pc, #2100]	; 3002ac58 <Format+0xb28>
3002a420:	e5c32016 	strb	r2, [r3, #22]
            Buf[23] = (temp >> 8) & 0xff;
3002a424:	e1dd33b2 	ldrh	r3, [sp, #50]	; 0x32
3002a428:	e1a03423 	lsr	r3, r3, #8
3002a42c:	e1a03803 	lsl	r3, r3, #16
3002a430:	e1a03823 	lsr	r3, r3, #16
3002a434:	e20320ff 	and	r2, r3, #255	; 0xff
3002a438:	e59f3818 	ldr	r3, [pc, #2072]	; 3002ac58 <Format+0xb28>
3002a43c:	e5c32017 	strb	r2, [r3, #23]

            parameter.Drive = Drive;
3002a440:	e5dd300f 	ldrb	r3, [sp, #15]
3002a444:	e5cd3014 	strb	r3, [sp, #20]
            parameter.SectorIndex = 0;
3002a448:	e3a03000 	mov	r3, #0
3002a44c:	e58d3018 	str	r3, [sp, #24]
            parameter.RsvdForLow = Disk->RsvdForLow;
3002a450:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3002a454:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
3002a458:	e58d301c 	str	r3, [sp, #28]
            parameter.Buf = Buf;
3002a45c:	e59f37f4 	ldr	r3, [pc, #2036]	; 3002ac58 <Format+0xb28>
3002a460:	e58d3020 	str	r3, [sp, #32]
            Disk->DiakCommand(DISK_WRITE_SECTOR, &parameter);
3002a464:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3002a468:	e5933030 	ldr	r3, [r3, #48]	; 0x30
3002a46c:	e28d2014 	add	r2, sp, #20
3002a470:	e3a00003 	mov	r0, #3
3002a474:	e1a01002 	mov	r1, r2
3002a478:	e1a0e00f 	mov	lr, pc
3002a47c:	e12fff13 	bx	r3

/* ʼ FAT͸Ŀ¼ */
            cp2 = Buf + 3;
3002a480:	e59f37d8 	ldr	r3, [pc, #2008]	; 3002ac60 <Format+0xb30>
3002a484:	e58d3028 	str	r3, [sp, #40]	; 0x28
            Buf[0] = 0xf0;
3002a488:	e59f37c8 	ldr	r3, [pc, #1992]	; 3002ac58 <Format+0xb28>
3002a48c:	e3e0200f 	mvn	r2, #15
3002a490:	e5c32000 	strb	r2, [r3]
            Buf[1] = 0xff;
3002a494:	e59f37bc 	ldr	r3, [pc, #1980]	; 3002ac58 <Format+0xb28>
3002a498:	e3e02000 	mvn	r2, #0
3002a49c:	e5c32001 	strb	r2, [r3, #1]
            Buf[2] = 0xff;
3002a4a0:	e59f37b0 	ldr	r3, [pc, #1968]	; 3002ac58 <Format+0xb28>
3002a4a4:	e3e02000 	mvn	r2, #0
3002a4a8:	e5c32002 	strb	r2, [r3, #2]
            for (j = 3; j < BytsPerSec; j++)
3002a4ac:	e3a03003 	mov	r3, #3
3002a4b0:	e1cd33b0 	strh	r3, [sp, #48]	; 0x30
3002a4b4:	ea000008 	b	3002a4dc <Format+0x3ac>
            {
                *cp2++ = 0;
3002a4b8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002a4bc:	e3a02000 	mov	r2, #0
3002a4c0:	e5c32000 	strb	r2, [r3]
3002a4c4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002a4c8:	e2833001 	add	r3, r3, #1
3002a4cc:	e58d3028 	str	r3, [sp, #40]	; 0x28
/* ʼ FAT͸Ŀ¼ */
            cp2 = Buf + 3;
            Buf[0] = 0xf0;
            Buf[1] = 0xff;
            Buf[2] = 0xff;
            for (j = 3; j < BytsPerSec; j++)
3002a4d0:	e1dd33b0 	ldrh	r3, [sp, #48]	; 0x30
3002a4d4:	e2833001 	add	r3, r3, #1
3002a4d8:	e1cd33b0 	strh	r3, [sp, #48]	; 0x30
3002a4dc:	e1dd23b0 	ldrh	r2, [sp, #48]	; 0x30
3002a4e0:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a4e4:	e1520003 	cmp	r2, r3
3002a4e8:	3afffff2 	bcc	3002a4b8 <Format+0x388>
            {
                *cp2++ = 0;
            }
            for (j = 0; j < temp; j++)
3002a4ec:	e3a03000 	mov	r3, #0
3002a4f0:	e1cd33b0 	strh	r3, [sp, #48]	; 0x30
3002a4f4:	ea000015 	b	3002a550 <Format+0x420>
            {
                parameter.SectorIndex = j + 1;
3002a4f8:	e1dd33b0 	ldrh	r3, [sp, #48]	; 0x30
3002a4fc:	e2833001 	add	r3, r3, #1
3002a500:	e58d3018 	str	r3, [sp, #24]
                Disk->DiakCommand(DISK_WRITE_SECTOR, &parameter);
3002a504:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3002a508:	e5933030 	ldr	r3, [r3, #48]	; 0x30
3002a50c:	e28d2014 	add	r2, sp, #20
3002a510:	e3a00003 	mov	r0, #3
3002a514:	e1a01002 	mov	r1, r2
3002a518:	e1a0e00f 	mov	lr, pc
3002a51c:	e12fff13 	bx	r3
                Buf[0] = 0;
3002a520:	e59f3730 	ldr	r3, [pc, #1840]	; 3002ac58 <Format+0xb28>
3002a524:	e3a02000 	mov	r2, #0
3002a528:	e5c32000 	strb	r2, [r3]
                Buf[1] = 0;
3002a52c:	e59f3724 	ldr	r3, [pc, #1828]	; 3002ac58 <Format+0xb28>
3002a530:	e3a02000 	mov	r2, #0
3002a534:	e5c32001 	strb	r2, [r3, #1]
                Buf[2] = 0;
3002a538:	e59f3718 	ldr	r3, [pc, #1816]	; 3002ac58 <Format+0xb28>
3002a53c:	e3a02000 	mov	r2, #0
3002a540:	e5c32002 	strb	r2, [r3, #2]
            Buf[2] = 0xff;
            for (j = 3; j < BytsPerSec; j++)
            {
                *cp2++ = 0;
            }
            for (j = 0; j < temp; j++)
3002a544:	e1dd33b0 	ldrh	r3, [sp, #48]	; 0x30
3002a548:	e2833001 	add	r3, r3, #1
3002a54c:	e1cd33b0 	strh	r3, [sp, #48]	; 0x30
3002a550:	e1dd23b0 	ldrh	r2, [sp, #48]	; 0x30
3002a554:	e1dd33b2 	ldrh	r3, [sp, #50]	; 0x32
3002a558:	e1520003 	cmp	r2, r3
3002a55c:	3affffe5 	bcc	3002a4f8 <Format+0x3c8>
                Disk->DiakCommand(DISK_WRITE_SECTOR, &parameter);
                Buf[0] = 0;
                Buf[1] = 0;
                Buf[2] = 0;
            }
            i = (i * 32) / BytsPerSec;
3002a560:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3002a564:	e1a02283 	lsl	r2, r3, #5
3002a568:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a56c:	e1a00002 	mov	r0, r2
3002a570:	e1a01003 	mov	r1, r3
3002a574:	eb00660e 	bl	30043db4 <__aeabi_idiv>
3002a578:	e1a03000 	mov	r3, r0
3002a57c:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
            temp++;
3002a580:	e1dd33b2 	ldrh	r3, [sp, #50]	; 0x32
3002a584:	e2833001 	add	r3, r3, #1
3002a588:	e1cd33b2 	strh	r3, [sp, #50]	; 0x32
            for (j = 0; j < i; j++)
3002a58c:	e3a03000 	mov	r3, #0
3002a590:	e1cd33b0 	strh	r3, [sp, #48]	; 0x30
3002a594:	ea00000d 	b	3002a5d0 <Format+0x4a0>
            {
                parameter.SectorIndex = j + temp;
3002a598:	e1dd23b0 	ldrh	r2, [sp, #48]	; 0x30
3002a59c:	e1dd33b2 	ldrh	r3, [sp, #50]	; 0x32
3002a5a0:	e0823003 	add	r3, r2, r3
3002a5a4:	e58d3018 	str	r3, [sp, #24]
                Disk->DiakCommand(DISK_WRITE_SECTOR, &parameter);
3002a5a8:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3002a5ac:	e5933030 	ldr	r3, [r3, #48]	; 0x30
3002a5b0:	e28d2014 	add	r2, sp, #20
3002a5b4:	e3a00003 	mov	r0, #3
3002a5b8:	e1a01002 	mov	r1, r2
3002a5bc:	e1a0e00f 	mov	lr, pc
3002a5c0:	e12fff13 	bx	r3
                Buf[1] = 0;
                Buf[2] = 0;
            }
            i = (i * 32) / BytsPerSec;
            temp++;
            for (j = 0; j < i; j++)
3002a5c4:	e1dd33b0 	ldrh	r3, [sp, #48]	; 0x30
3002a5c8:	e2833001 	add	r3, r3, #1
3002a5cc:	e1cd33b0 	strh	r3, [sp, #48]	; 0x30
3002a5d0:	e1dd23b0 	ldrh	r2, [sp, #48]	; 0x30
3002a5d4:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3002a5d8:	e1520003 	cmp	r2, r3
3002a5dc:	3affffed 	bcc	3002a598 <Format+0x468>
3002a5e0:	ea000195 	b	3002ac3c <Format+0xb0c>
                Disk->DiakCommand(DISK_WRITE_SECTOR, &parameter);
            }
        }
        else
        {
            temp = (4086 * 2 + BytsPerSec - 1) / BytsPerSec;
3002a5e4:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a5e8:	e2833d7f 	add	r3, r3, #8128	; 0x1fc0
3002a5ec:	e283302b 	add	r3, r3, #43	; 0x2b
3002a5f0:	e1dd20b6 	ldrh	r2, [sp, #6]
3002a5f4:	e1a00003 	mov	r0, r3
3002a5f8:	e1a01002 	mov	r1, r2
3002a5fc:	eb0065ec 	bl	30043db4 <__aeabi_idiv>
3002a600:	e1a03000 	mov	r3, r0
3002a604:	e1cd33b2 	strh	r3, [sp, #50]	; 0x32
            i = (512 * 32 + BytsPerSec - 1) / BytsPerSec;
3002a608:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a60c:	e2833dff 	add	r3, r3, #16320	; 0x3fc0
3002a610:	e283303f 	add	r3, r3, #63	; 0x3f
3002a614:	e1dd20b6 	ldrh	r2, [sp, #6]
3002a618:	e1a00003 	mov	r0, r3
3002a61c:	e1a01002 	mov	r1, r2
3002a620:	eb0065e3 	bl	30043db4 <__aeabi_idiv>
3002a624:	e1a03000 	mov	r3, r0
3002a628:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
            temp1 = SecPerDisk - temp - i;
3002a62c:	e1dd33b2 	ldrh	r3, [sp, #50]	; 0x32
3002a630:	e59d2008 	ldr	r2, [sp, #8]
3002a634:	e0632002 	rsb	r2, r3, r2
3002a638:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3002a63c:	e0633002 	rsb	r3, r3, r2
3002a640:	e58d3034 	str	r3, [sp, #52]	; 0x34
            if (temp1 < 65525)          /* FAT16 */
3002a644:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3002a648:	e3a03cff 	mov	r3, #65280	; 0xff00
3002a64c:	e28330f4 	add	r3, r3, #244	; 0xf4
3002a650:	e1520003 	cmp	r2, r3
3002a654:	8a00009a 	bhi	3002a8c4 <Format+0x794>
            {
                temp = ((SecPerDisk - i - 1) * 2 + BytsPerSec - 1) / BytsPerSec;
3002a658:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3002a65c:	e59d2008 	ldr	r2, [sp, #8]
3002a660:	e0633002 	rsb	r3, r3, r2
3002a664:	e2433106 	sub	r3, r3, #-2147483647	; 0x80000001
3002a668:	e1a02083 	lsl	r2, r3, #1
3002a66c:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a670:	e0823003 	add	r3, r2, r3
3002a674:	e2432001 	sub	r2, r3, #1
3002a678:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a67c:	e1a00002 	mov	r0, r2
3002a680:	e1a01003 	mov	r1, r3
3002a684:	eb006585 	bl	30043ca0 <__aeabi_uidiv>
3002a688:	e1a03000 	mov	r3, r0
3002a68c:	e1cd33b2 	strh	r3, [sp, #50]	; 0x32
                /* Ŀ¼FDT */
                i = (i * BytsPerSec) / 32;
3002a690:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3002a694:	e1dd20b6 	ldrh	r2, [sp, #6]
3002a698:	e0030392 	mul	r3, r2, r3
3002a69c:	e283201f 	add	r2, r3, #31
3002a6a0:	e3530000 	cmp	r3, #0
3002a6a4:	b1a03002 	movlt	r3, r2
3002a6a8:	e1a032c3 	asr	r3, r3, #5
3002a6ac:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
                Buf[17] = i & 0xff;
3002a6b0:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3002a6b4:	e20320ff 	and	r2, r3, #255	; 0xff
3002a6b8:	e59f3598 	ldr	r3, [pc, #1432]	; 3002ac58 <Format+0xb28>
3002a6bc:	e5c32011 	strb	r2, [r3, #17]
                Buf[18] = (i >> 8) & 0xff;
3002a6c0:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3002a6c4:	e1a03423 	lsr	r3, r3, #8
3002a6c8:	e1a03803 	lsl	r3, r3, #16
3002a6cc:	e1a03823 	lsr	r3, r3, #16
3002a6d0:	e20320ff 	and	r2, r3, #255	; 0xff
3002a6d4:	e59f357c 	ldr	r3, [pc, #1404]	; 3002ac58 <Format+0xb28>
3002a6d8:	e5c32012 	strb	r2, [r3, #18]

                /* FATռ */
                Buf[22] = temp & 0xff;
3002a6dc:	e1dd33b2 	ldrh	r3, [sp, #50]	; 0x32
3002a6e0:	e20320ff 	and	r2, r3, #255	; 0xff
3002a6e4:	e59f356c 	ldr	r3, [pc, #1388]	; 3002ac58 <Format+0xb28>
3002a6e8:	e5c32016 	strb	r2, [r3, #22]
                Buf[23] = (temp >> 8) & 0xff;
3002a6ec:	e1dd33b2 	ldrh	r3, [sp, #50]	; 0x32
3002a6f0:	e1a03423 	lsr	r3, r3, #8
3002a6f4:	e1a03803 	lsl	r3, r3, #16
3002a6f8:	e1a03823 	lsr	r3, r3, #16
3002a6fc:	e20320ff 	and	r2, r3, #255	; 0xff
3002a700:	e59f3550 	ldr	r3, [pc, #1360]	; 3002ac58 <Format+0xb28>
3002a704:	e5c32017 	strb	r2, [r3, #23]
                
                parameter.Drive = Drive;
3002a708:	e5dd300f 	ldrb	r3, [sp, #15]
3002a70c:	e5cd3014 	strb	r3, [sp, #20]
                parameter.SectorIndex = 0;
3002a710:	e3a03000 	mov	r3, #0
3002a714:	e58d3018 	str	r3, [sp, #24]
                parameter.RsvdForLow = Disk->RsvdForLow;
3002a718:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3002a71c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
3002a720:	e58d301c 	str	r3, [sp, #28]
                parameter.Buf = Buf;
3002a724:	e59f352c 	ldr	r3, [pc, #1324]	; 3002ac58 <Format+0xb28>
3002a728:	e58d3020 	str	r3, [sp, #32]
                Disk->DiakCommand(DISK_WRITE_SECTOR, &parameter);
3002a72c:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3002a730:	e5933030 	ldr	r3, [r3, #48]	; 0x30
3002a734:	e28d2014 	add	r2, sp, #20
3002a738:	e3a00003 	mov	r0, #3
3002a73c:	e1a01002 	mov	r1, r2
3002a740:	e1a0e00f 	mov	lr, pc
3002a744:	e12fff13 	bx	r3
                
/* ʼ FAT͸Ŀ¼ */
                cp2 = Buf + 4;
3002a748:	e59f3514 	ldr	r3, [pc, #1300]	; 3002ac64 <Format+0xb34>
3002a74c:	e58d3028 	str	r3, [sp, #40]	; 0x28
                Buf[0] = 0xf0;
3002a750:	e59f3500 	ldr	r3, [pc, #1280]	; 3002ac58 <Format+0xb28>
3002a754:	e3e0200f 	mvn	r2, #15
3002a758:	e5c32000 	strb	r2, [r3]
                Buf[1] = 0xff;
3002a75c:	e59f34f4 	ldr	r3, [pc, #1268]	; 3002ac58 <Format+0xb28>
3002a760:	e3e02000 	mvn	r2, #0
3002a764:	e5c32001 	strb	r2, [r3, #1]
                Buf[2] = 0xff;
3002a768:	e59f34e8 	ldr	r3, [pc, #1256]	; 3002ac58 <Format+0xb28>
3002a76c:	e3e02000 	mvn	r2, #0
3002a770:	e5c32002 	strb	r2, [r3, #2]
                Buf[3] = 0xff;
3002a774:	e59f34dc 	ldr	r3, [pc, #1244]	; 3002ac58 <Format+0xb28>
3002a778:	e3e02000 	mvn	r2, #0
3002a77c:	e5c32003 	strb	r2, [r3, #3]
                for (j = 4; j < BytsPerSec; j++)
3002a780:	e3a03004 	mov	r3, #4
3002a784:	e1cd33b0 	strh	r3, [sp, #48]	; 0x30
3002a788:	ea000008 	b	3002a7b0 <Format+0x680>
                {
                    *cp2++ = 0;
3002a78c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002a790:	e3a02000 	mov	r2, #0
3002a794:	e5c32000 	strb	r2, [r3]
3002a798:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002a79c:	e2833001 	add	r3, r3, #1
3002a7a0:	e58d3028 	str	r3, [sp, #40]	; 0x28
                cp2 = Buf + 4;
                Buf[0] = 0xf0;
                Buf[1] = 0xff;
                Buf[2] = 0xff;
                Buf[3] = 0xff;
                for (j = 4; j < BytsPerSec; j++)
3002a7a4:	e1dd33b0 	ldrh	r3, [sp, #48]	; 0x30
3002a7a8:	e2833001 	add	r3, r3, #1
3002a7ac:	e1cd33b0 	strh	r3, [sp, #48]	; 0x30
3002a7b0:	e1dd23b0 	ldrh	r2, [sp, #48]	; 0x30
3002a7b4:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a7b8:	e1520003 	cmp	r2, r3
3002a7bc:	3afffff2 	bcc	3002a78c <Format+0x65c>
                {
                    *cp2++ = 0;
                }
                for (j = 0; j < temp; j++)
3002a7c0:	e3a03000 	mov	r3, #0
3002a7c4:	e1cd33b0 	strh	r3, [sp, #48]	; 0x30
3002a7c8:	ea000018 	b	3002a830 <Format+0x700>
                {
                    parameter.SectorIndex = j + 1;
3002a7cc:	e1dd33b0 	ldrh	r3, [sp, #48]	; 0x30
3002a7d0:	e2833001 	add	r3, r3, #1
3002a7d4:	e58d3018 	str	r3, [sp, #24]
                    Disk->DiakCommand(DISK_WRITE_SECTOR, &parameter);
3002a7d8:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3002a7dc:	e5933030 	ldr	r3, [r3, #48]	; 0x30
3002a7e0:	e28d2014 	add	r2, sp, #20
3002a7e4:	e3a00003 	mov	r0, #3
3002a7e8:	e1a01002 	mov	r1, r2
3002a7ec:	e1a0e00f 	mov	lr, pc
3002a7f0:	e12fff13 	bx	r3
                    Buf[0] = 0;
3002a7f4:	e59f345c 	ldr	r3, [pc, #1116]	; 3002ac58 <Format+0xb28>
3002a7f8:	e3a02000 	mov	r2, #0
3002a7fc:	e5c32000 	strb	r2, [r3]
                    Buf[1] = 0;
3002a800:	e59f3450 	ldr	r3, [pc, #1104]	; 3002ac58 <Format+0xb28>
3002a804:	e3a02000 	mov	r2, #0
3002a808:	e5c32001 	strb	r2, [r3, #1]
                    Buf[2] = 0;
3002a80c:	e59f3444 	ldr	r3, [pc, #1092]	; 3002ac58 <Format+0xb28>
3002a810:	e3a02000 	mov	r2, #0
3002a814:	e5c32002 	strb	r2, [r3, #2]
                    Buf[3] = 0;
3002a818:	e59f3438 	ldr	r3, [pc, #1080]	; 3002ac58 <Format+0xb28>
3002a81c:	e3a02000 	mov	r2, #0
3002a820:	e5c32003 	strb	r2, [r3, #3]
                Buf[3] = 0xff;
                for (j = 4; j < BytsPerSec; j++)
                {
                    *cp2++ = 0;
                }
                for (j = 0; j < temp; j++)
3002a824:	e1dd33b0 	ldrh	r3, [sp, #48]	; 0x30
3002a828:	e2833001 	add	r3, r3, #1
3002a82c:	e1cd33b0 	strh	r3, [sp, #48]	; 0x30
3002a830:	e1dd23b0 	ldrh	r2, [sp, #48]	; 0x30
3002a834:	e1dd33b2 	ldrh	r3, [sp, #50]	; 0x32
3002a838:	e1520003 	cmp	r2, r3
3002a83c:	3affffe2 	bcc	3002a7cc <Format+0x69c>
                    Buf[0] = 0;
                    Buf[1] = 0;
                    Buf[2] = 0;
                    Buf[3] = 0;
                }
                i = (i * 32) / BytsPerSec;
3002a840:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3002a844:	e1a02283 	lsl	r2, r3, #5
3002a848:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a84c:	e1a00002 	mov	r0, r2
3002a850:	e1a01003 	mov	r1, r3
3002a854:	eb006556 	bl	30043db4 <__aeabi_idiv>
3002a858:	e1a03000 	mov	r3, r0
3002a85c:	e1cd32be 	strh	r3, [sp, #46]	; 0x2e
                temp++;
3002a860:	e1dd33b2 	ldrh	r3, [sp, #50]	; 0x32
3002a864:	e2833001 	add	r3, r3, #1
3002a868:	e1cd33b2 	strh	r3, [sp, #50]	; 0x32
                for (j = 0; j < i; j++)
3002a86c:	e3a03000 	mov	r3, #0
3002a870:	e1cd33b0 	strh	r3, [sp, #48]	; 0x30
3002a874:	ea00000d 	b	3002a8b0 <Format+0x780>
                {
                    parameter.SectorIndex = j + temp;
3002a878:	e1dd23b0 	ldrh	r2, [sp, #48]	; 0x30
3002a87c:	e1dd33b2 	ldrh	r3, [sp, #50]	; 0x32
3002a880:	e0823003 	add	r3, r2, r3
3002a884:	e58d3018 	str	r3, [sp, #24]
                    Disk->DiakCommand(DISK_WRITE_SECTOR, &parameter);
3002a888:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3002a88c:	e5933030 	ldr	r3, [r3, #48]	; 0x30
3002a890:	e28d2014 	add	r2, sp, #20
3002a894:	e3a00003 	mov	r0, #3
3002a898:	e1a01002 	mov	r1, r2
3002a89c:	e1a0e00f 	mov	lr, pc
3002a8a0:	e12fff13 	bx	r3
                    Buf[2] = 0;
                    Buf[3] = 0;
                }
                i = (i * 32) / BytsPerSec;
                temp++;
                for (j = 0; j < i; j++)
3002a8a4:	e1dd33b0 	ldrh	r3, [sp, #48]	; 0x30
3002a8a8:	e2833001 	add	r3, r3, #1
3002a8ac:	e1cd33b0 	strh	r3, [sp, #48]	; 0x30
3002a8b0:	e1dd23b0 	ldrh	r2, [sp, #48]	; 0x30
3002a8b4:	e1dd32be 	ldrh	r3, [sp, #46]	; 0x2e
3002a8b8:	e1520003 	cmp	r2, r3
3002a8bc:	3affffed 	bcc	3002a878 <Format+0x748>
3002a8c0:	ea0000dd 	b	3002ac3c <Format+0xb0c>
                    
            }
            else                        /* FAT32 */
            {
                /* Ŀ¼FDT */
                Buf[17] = 0;
3002a8c4:	e59f338c 	ldr	r3, [pc, #908]	; 3002ac58 <Format+0xb28>
3002a8c8:	e3a02000 	mov	r2, #0
3002a8cc:	e5c32011 	strb	r2, [r3, #17]
                Buf[18] = 0;
3002a8d0:	e59f3380 	ldr	r3, [pc, #896]	; 3002ac58 <Format+0xb28>
3002a8d4:	e3a02000 	mov	r2, #0
3002a8d8:	e5c32012 	strb	r2, [r3, #18]

                /* FATռ */
                Buf[22] = 0;
3002a8dc:	e59f3374 	ldr	r3, [pc, #884]	; 3002ac58 <Format+0xb28>
3002a8e0:	e3a02000 	mov	r2, #0
3002a8e4:	e5c32016 	strb	r2, [r3, #22]
                Buf[23] = 0;
3002a8e8:	e59f3368 	ldr	r3, [pc, #872]	; 3002ac58 <Format+0xb28>
3002a8ec:	e3a02000 	mov	r2, #0
3002a8f0:	e5c32017 	strb	r2, [r3, #23]
                    
                temp1 = (SecPerDisk * 4 + BytsPerSec - 1) / BytsPerSec;
3002a8f4:	e59d3008 	ldr	r3, [sp, #8]
3002a8f8:	e1a02103 	lsl	r2, r3, #2
3002a8fc:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a900:	e0823003 	add	r3, r2, r3
3002a904:	e2432001 	sub	r2, r3, #1
3002a908:	e1dd30b6 	ldrh	r3, [sp, #6]
3002a90c:	e1a00002 	mov	r0, r2
3002a910:	e1a01003 	mov	r1, r3
3002a914:	eb0064e1 	bl	30043ca0 <__aeabi_uidiv>
3002a918:	e1a03000 	mov	r3, r0
3002a91c:	e58d3034 	str	r3, [sp, #52]	; 0x34
                Buf[36] = temp1 & 0xff;
3002a920:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3002a924:	e20320ff 	and	r2, r3, #255	; 0xff
3002a928:	e59f3328 	ldr	r3, [pc, #808]	; 3002ac58 <Format+0xb28>
3002a92c:	e5c32024 	strb	r2, [r3, #36]	; 0x24
                Buf[37] = (temp1 >> 8) & 0xff;
3002a930:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3002a934:	e1a03423 	lsr	r3, r3, #8
3002a938:	e20320ff 	and	r2, r3, #255	; 0xff
3002a93c:	e59f3314 	ldr	r3, [pc, #788]	; 3002ac58 <Format+0xb28>
3002a940:	e5c32025 	strb	r2, [r3, #37]	; 0x25
                Buf[38] = (temp1 >> 16) & 0xff;
3002a944:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3002a948:	e1a03823 	lsr	r3, r3, #16
3002a94c:	e20320ff 	and	r2, r3, #255	; 0xff
3002a950:	e59f3300 	ldr	r3, [pc, #768]	; 3002ac58 <Format+0xb28>
3002a954:	e5c32026 	strb	r2, [r3, #38]	; 0x26
                Buf[39] = (temp1 >> 24) & 0xff;
3002a958:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3002a95c:	e1a03c23 	lsr	r3, r3, #24
3002a960:	e20320ff 	and	r2, r3, #255	; 0xff
3002a964:	e59f32ec 	ldr	r3, [pc, #748]	; 3002ac58 <Format+0xb28>
3002a968:	e5c32027 	strb	r2, [r3, #39]	; 0x27

                /* FAT32 RootDirTableΪʼغ */
                Buf[44] = 2;
3002a96c:	e59f32e4 	ldr	r3, [pc, #740]	; 3002ac58 <Format+0xb28>
3002a970:	e3a02002 	mov	r2, #2
3002a974:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
                Buf[45] = 0;
3002a978:	e59f32d8 	ldr	r3, [pc, #728]	; 3002ac58 <Format+0xb28>
3002a97c:	e3a02000 	mov	r2, #0
3002a980:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
                Buf[46] = 0;
3002a984:	e59f32cc 	ldr	r3, [pc, #716]	; 3002ac58 <Format+0xb28>
3002a988:	e3a02000 	mov	r2, #0
3002a98c:	e5c3202e 	strb	r2, [r3, #46]	; 0x2e
                Buf[47] = 0;
3002a990:	e59f32c0 	ldr	r3, [pc, #704]	; 3002ac58 <Format+0xb28>
3002a994:	e3a02000 	mov	r2, #0
3002a998:	e5c3202f 	strb	r2, [r3, #47]	; 0x2f


                Buf[40] = 0;
3002a99c:	e59f32b4 	ldr	r3, [pc, #692]	; 3002ac58 <Format+0xb28>
3002a9a0:	e3a02000 	mov	r2, #0
3002a9a4:	e5c32028 	strb	r2, [r3, #40]	; 0x28
                Buf[41] = 0;
3002a9a8:	e59f32a8 	ldr	r3, [pc, #680]	; 3002ac58 <Format+0xb28>
3002a9ac:	e3a02000 	mov	r2, #0
3002a9b0:	e5c32029 	strb	r2, [r3, #41]	; 0x29
                Buf[42] = 0;
3002a9b4:	e59f329c 	ldr	r3, [pc, #668]	; 3002ac58 <Format+0xb28>
3002a9b8:	e3a02000 	mov	r2, #0
3002a9bc:	e5c3202a 	strb	r2, [r3, #42]	; 0x2a
                Buf[43] = 0;
3002a9c0:	e59f3290 	ldr	r3, [pc, #656]	; 3002ac58 <Format+0xb28>
3002a9c4:	e3a02000 	mov	r2, #0
3002a9c8:	e5c3202b 	strb	r2, [r3, #43]	; 0x2b

                Buf[48] = 1;
3002a9cc:	e59f3284 	ldr	r3, [pc, #644]	; 3002ac58 <Format+0xb28>
3002a9d0:	e3a02001 	mov	r2, #1
3002a9d4:	e5c32030 	strb	r2, [r3, #48]	; 0x30
                Buf[49] = 0;
3002a9d8:	e59f3278 	ldr	r3, [pc, #632]	; 3002ac58 <Format+0xb28>
3002a9dc:	e3a02000 	mov	r2, #0
3002a9e0:	e5c32031 	strb	r2, [r3, #49]	; 0x31

                Buf[50] = 0;        /* 6? */
3002a9e4:	e59f326c 	ldr	r3, [pc, #620]	; 3002ac58 <Format+0xb28>
3002a9e8:	e3a02000 	mov	r2, #0
3002a9ec:	e5c32032 	strb	r2, [r3, #50]	; 0x32
                Buf[51] = 0;
3002a9f0:	e59f3260 	ldr	r3, [pc, #608]	; 3002ac58 <Format+0xb28>
3002a9f4:	e3a02000 	mov	r2, #0
3002a9f8:	e5c32033 	strb	r2, [r3, #51]	; 0x33

                Buf[52] = 0;
3002a9fc:	e59f3254 	ldr	r3, [pc, #596]	; 3002ac58 <Format+0xb28>
3002aa00:	e3a02000 	mov	r2, #0
3002aa04:	e5c32034 	strb	r2, [r3, #52]	; 0x34
                Buf[53] = 0;
3002aa08:	e59f3248 	ldr	r3, [pc, #584]	; 3002ac58 <Format+0xb28>
3002aa0c:	e3a02000 	mov	r2, #0
3002aa10:	e5c32035 	strb	r2, [r3, #53]	; 0x35

                Buf[82] = 'F';
3002aa14:	e59f323c 	ldr	r3, [pc, #572]	; 3002ac58 <Format+0xb28>
3002aa18:	e3a02046 	mov	r2, #70	; 0x46
3002aa1c:	e5c32052 	strb	r2, [r3, #82]	; 0x52
                Buf[83] = 'A';
3002aa20:	e59f3230 	ldr	r3, [pc, #560]	; 3002ac58 <Format+0xb28>
3002aa24:	e3a02041 	mov	r2, #65	; 0x41
3002aa28:	e5c32053 	strb	r2, [r3, #83]	; 0x53
                Buf[84] = 'T';
3002aa2c:	e59f3224 	ldr	r3, [pc, #548]	; 3002ac58 <Format+0xb28>
3002aa30:	e3a02054 	mov	r2, #84	; 0x54
3002aa34:	e5c32054 	strb	r2, [r3, #84]	; 0x54
                Buf[85] = '3';
3002aa38:	e59f3218 	ldr	r3, [pc, #536]	; 3002ac58 <Format+0xb28>
3002aa3c:	e3a02033 	mov	r2, #51	; 0x33
3002aa40:	e5c32055 	strb	r2, [r3, #85]	; 0x55
                Buf[86] = '2';
3002aa44:	e59f320c 	ldr	r3, [pc, #524]	; 3002ac58 <Format+0xb28>
3002aa48:	e3a02032 	mov	r2, #50	; 0x32
3002aa4c:	e5c32056 	strb	r2, [r3, #86]	; 0x56
                Buf[87] = ' ';
3002aa50:	e59f3200 	ldr	r3, [pc, #512]	; 3002ac58 <Format+0xb28>
3002aa54:	e3a02020 	mov	r2, #32
3002aa58:	e5c32057 	strb	r2, [r3, #87]	; 0x57
                Buf[88] = ' ';
3002aa5c:	e59f31f4 	ldr	r3, [pc, #500]	; 3002ac58 <Format+0xb28>
3002aa60:	e3a02020 	mov	r2, #32
3002aa64:	e5c32058 	strb	r2, [r3, #88]	; 0x58
                Buf[89] = ' ';
3002aa68:	e59f31e8 	ldr	r3, [pc, #488]	; 3002ac58 <Format+0xb28>
3002aa6c:	e3a02020 	mov	r2, #32
3002aa70:	e5c32059 	strb	r2, [r3, #89]	; 0x59

                parameter.Drive = Drive;
3002aa74:	e5dd300f 	ldrb	r3, [sp, #15]
3002aa78:	e5cd3014 	strb	r3, [sp, #20]
                parameter.SectorIndex = 0;
3002aa7c:	e3a03000 	mov	r3, #0
3002aa80:	e58d3018 	str	r3, [sp, #24]
                parameter.RsvdForLow = Disk->RsvdForLow;
3002aa84:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3002aa88:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
3002aa8c:	e58d301c 	str	r3, [sp, #28]
                parameter.Buf = Buf;
3002aa90:	e59f31c0 	ldr	r3, [pc, #448]	; 3002ac58 <Format+0xb28>
3002aa94:	e58d3020 	str	r3, [sp, #32]
                Disk->DiakCommand(DISK_WRITE_SECTOR, &parameter);
3002aa98:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3002aa9c:	e5933030 	ldr	r3, [r3, #48]	; 0x30
3002aaa0:	e28d2014 	add	r2, sp, #20
3002aaa4:	e3a00003 	mov	r0, #3
3002aaa8:	e1a01002 	mov	r1, r2
3002aaac:	e1a0e00f 	mov	lr, pc
3002aab0:	e12fff13 	bx	r3

/* ʼ FAT͸Ŀ¼T */
                cp2 = Buf + 8;
3002aab4:	e59f31ac 	ldr	r3, [pc, #428]	; 3002ac68 <Format+0xb38>
3002aab8:	e58d3028 	str	r3, [sp, #40]	; 0x28
                Buf[0] = 0xf0;
3002aabc:	e59f3194 	ldr	r3, [pc, #404]	; 3002ac58 <Format+0xb28>
3002aac0:	e3e0200f 	mvn	r2, #15
3002aac4:	e5c32000 	strb	r2, [r3]
                Buf[1] = 0xff;
3002aac8:	e59f3188 	ldr	r3, [pc, #392]	; 3002ac58 <Format+0xb28>
3002aacc:	e3e02000 	mvn	r2, #0
3002aad0:	e5c32001 	strb	r2, [r3, #1]
                Buf[2] = 0xff;
3002aad4:	e59f317c 	ldr	r3, [pc, #380]	; 3002ac58 <Format+0xb28>
3002aad8:	e3e02000 	mvn	r2, #0
3002aadc:	e5c32002 	strb	r2, [r3, #2]
                Buf[3] = 0xff;
3002aae0:	e59f3170 	ldr	r3, [pc, #368]	; 3002ac58 <Format+0xb28>
3002aae4:	e3e02000 	mvn	r2, #0
3002aae8:	e5c32003 	strb	r2, [r3, #3]
                Buf[4] = 0xff;
3002aaec:	e59f3164 	ldr	r3, [pc, #356]	; 3002ac58 <Format+0xb28>
3002aaf0:	e3e02000 	mvn	r2, #0
3002aaf4:	e5c32004 	strb	r2, [r3, #4]
                Buf[5] = 0xff;
3002aaf8:	e59f3158 	ldr	r3, [pc, #344]	; 3002ac58 <Format+0xb28>
3002aafc:	e3e02000 	mvn	r2, #0
3002ab00:	e5c32005 	strb	r2, [r3, #5]
                Buf[6] = 0xff;
3002ab04:	e59f314c 	ldr	r3, [pc, #332]	; 3002ac58 <Format+0xb28>
3002ab08:	e3e02000 	mvn	r2, #0
3002ab0c:	e5c32006 	strb	r2, [r3, #6]
                Buf[7] = 0xff;
3002ab10:	e59f3140 	ldr	r3, [pc, #320]	; 3002ac58 <Format+0xb28>
3002ab14:	e3e02000 	mvn	r2, #0
3002ab18:	e5c32007 	strb	r2, [r3, #7]
                for (j = 8; j < BytsPerSec; j++)
3002ab1c:	e3a03008 	mov	r3, #8
3002ab20:	e1cd33b0 	strh	r3, [sp, #48]	; 0x30
3002ab24:	ea000008 	b	3002ab4c <Format+0xa1c>
                {
                    *cp2++ = 0;
3002ab28:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002ab2c:	e3a02000 	mov	r2, #0
3002ab30:	e5c32000 	strb	r2, [r3]
3002ab34:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002ab38:	e2833001 	add	r3, r3, #1
3002ab3c:	e58d3028 	str	r3, [sp, #40]	; 0x28
                Buf[3] = 0xff;
                Buf[4] = 0xff;
                Buf[5] = 0xff;
                Buf[6] = 0xff;
                Buf[7] = 0xff;
                for (j = 8; j < BytsPerSec; j++)
3002ab40:	e1dd33b0 	ldrh	r3, [sp, #48]	; 0x30
3002ab44:	e2833001 	add	r3, r3, #1
3002ab48:	e1cd33b0 	strh	r3, [sp, #48]	; 0x30
3002ab4c:	e1dd23b0 	ldrh	r2, [sp, #48]	; 0x30
3002ab50:	e1dd30b6 	ldrh	r3, [sp, #6]
3002ab54:	e1520003 	cmp	r2, r3
3002ab58:	3afffff2 	bcc	3002ab28 <Format+0x9f8>
                {
                    *cp2++ = 0;
                }
                temp += 2;
3002ab5c:	e1dd33b2 	ldrh	r3, [sp, #50]	; 0x32
3002ab60:	e2833002 	add	r3, r3, #2
3002ab64:	e1cd33b2 	strh	r3, [sp, #50]	; 0x32
                parameter.SectorIndex = 1;
3002ab68:	e3a03001 	mov	r3, #1
3002ab6c:	e58d3018 	str	r3, [sp, #24]
                Disk->DiakCommand(DISK_WRITE_SECTOR, &parameter);
3002ab70:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3002ab74:	e5933030 	ldr	r3, [r3, #48]	; 0x30
3002ab78:	e28d2014 	add	r2, sp, #20
3002ab7c:	e3a00003 	mov	r0, #3
3002ab80:	e1a01002 	mov	r1, r2
3002ab84:	e1a0e00f 	mov	lr, pc
3002ab88:	e12fff13 	bx	r3
                Buf[0] = 0;
3002ab8c:	e59f30c4 	ldr	r3, [pc, #196]	; 3002ac58 <Format+0xb28>
3002ab90:	e3a02000 	mov	r2, #0
3002ab94:	e5c32000 	strb	r2, [r3]
                Buf[1] = 0;
3002ab98:	e59f30b8 	ldr	r3, [pc, #184]	; 3002ac58 <Format+0xb28>
3002ab9c:	e3a02000 	mov	r2, #0
3002aba0:	e5c32001 	strb	r2, [r3, #1]
                Buf[2] = 0;
3002aba4:	e59f30ac 	ldr	r3, [pc, #172]	; 3002ac58 <Format+0xb28>
3002aba8:	e3a02000 	mov	r2, #0
3002abac:	e5c32002 	strb	r2, [r3, #2]
                Buf[3] = 0;
3002abb0:	e59f30a0 	ldr	r3, [pc, #160]	; 3002ac58 <Format+0xb28>
3002abb4:	e3a02000 	mov	r2, #0
3002abb8:	e5c32003 	strb	r2, [r3, #3]
                Buf[4] = 0;
3002abbc:	e59f3094 	ldr	r3, [pc, #148]	; 3002ac58 <Format+0xb28>
3002abc0:	e3a02000 	mov	r2, #0
3002abc4:	e5c32004 	strb	r2, [r3, #4]
                Buf[5] = 0;
3002abc8:	e59f3088 	ldr	r3, [pc, #136]	; 3002ac58 <Format+0xb28>
3002abcc:	e3a02000 	mov	r2, #0
3002abd0:	e5c32005 	strb	r2, [r3, #5]
                Buf[6] = 0;
3002abd4:	e59f307c 	ldr	r3, [pc, #124]	; 3002ac58 <Format+0xb28>
3002abd8:	e3a02000 	mov	r2, #0
3002abdc:	e5c32006 	strb	r2, [r3, #6]
                Buf[7] = 0;
3002abe0:	e59f3070 	ldr	r3, [pc, #112]	; 3002ac58 <Format+0xb28>
3002abe4:	e3a02000 	mov	r2, #0
3002abe8:	e5c32007 	strb	r2, [r3, #7]
                for (k = 1; k < temp1; k++)
3002abec:	e3a03001 	mov	r3, #1
3002abf0:	e58d3038 	str	r3, [sp, #56]	; 0x38
3002abf4:	ea00000c 	b	3002ac2c <Format+0xafc>
                {
                    parameter.SectorIndex = k + 1;
3002abf8:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3002abfc:	e2833001 	add	r3, r3, #1
3002ac00:	e58d3018 	str	r3, [sp, #24]
                    Disk->DiakCommand(DISK_WRITE_SECTOR, &parameter);
3002ac04:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3002ac08:	e5933030 	ldr	r3, [r3, #48]	; 0x30
3002ac0c:	e28d2014 	add	r2, sp, #20
3002ac10:	e3a00003 	mov	r0, #3
3002ac14:	e1a01002 	mov	r1, r2
3002ac18:	e1a0e00f 	mov	lr, pc
3002ac1c:	e12fff13 	bx	r3
                Buf[3] = 0;
                Buf[4] = 0;
                Buf[5] = 0;
                Buf[6] = 0;
                Buf[7] = 0;
                for (k = 1; k < temp1; k++)
3002ac20:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3002ac24:	e2833001 	add	r3, r3, #1
3002ac28:	e58d3038 	str	r3, [sp, #56]	; 0x38
3002ac2c:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
3002ac30:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3002ac34:	e1520003 	cmp	r2, r3
3002ac38:	3affffee 	bcc	3002abf8 <Format+0xac8>
                    parameter.SectorIndex = k + 1;
                    Disk->DiakCommand(DISK_WRITE_SECTOR, &parameter);
                }
            }
        }
        return TRUE;
3002ac3c:	e3a03001 	mov	r3, #1
3002ac40:	ea000000 	b	3002ac48 <Format+0xb18>
    }
    return FALSE;
3002ac44:	e3a03000 	mov	r3, #0
}
3002ac48:	e1a00003 	mov	r0, r3
3002ac4c:	e28dd044 	add	sp, sp, #68	; 0x44
3002ac50:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002ac54:	e12fff1e 	bx	lr
3002ac58:	300e4024 	.word	0x300e4024
3002ac5c:	300457b4 	.word	0x300457b4
3002ac60:	300e4027 	.word	0x300e4027
3002ac64:	300e4028 	.word	0x300e4028
3002ac68:	300e402c 	.word	0x300e402c

3002ac6c <FsCommand>:
**        BAD_DISK_COMMANDЧ
** ȫֱ: 
** ģ: 
********************************************************************************************************/
        acoral_u16 FsCommand(acoral_u8 Cammand, void *Parameter)
{
3002ac6c:	e92d4030 	push	{r4, r5, lr}
3002ac70:	e24dd02c 	sub	sp, sp, #44	; 0x2c
3002ac74:	e1a03000 	mov	r3, r0
3002ac78:	e58d1008 	str	r1, [sp, #8]
3002ac7c:	e5cd300f 	strb	r3, [sp, #15]
    acoral_u8 drive;
    Disk_RW_Parameter * Dp;
    Disk_Info *DiskInfo1;
    
    
    Dp = (Disk_RW_Parameter *)Parameter;
3002ac80:	e59d3008 	ldr	r3, [sp, #8]
3002ac84:	e58d3020 	str	r3, [sp, #32]
    drive=Dp->Drive;
3002ac88:	e59d3020 	ldr	r3, [sp, #32]
3002ac8c:	e5d33000 	ldrb	r3, [r3]
3002ac90:	e5cd301f 	strb	r3, [sp, #31]
    switch (Cammand)
3002ac94:	e5dd300f 	ldrb	r3, [sp, #15]
3002ac98:	e3530004 	cmp	r3, #4
3002ac9c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3002aca0:	ea0000bc 	b	3002af98 <FsCommand+0x32c>
3002aca4:	3002acb8 	.word	0x3002acb8
3002aca8:	3002ad40 	.word	0x3002ad40
3002acac:	3002adf0 	.word	0x3002adf0
3002acb0:	3002aec4 	.word	0x3002aec4
3002acb4:	3002ad7c 	.word	0x3002ad7c
    {
        case DISK_INIT:										/*豸ʼ*/
            rt = DISK_INIT_NOT_OK;
3002acb8:	e3a03083 	mov	r3, #131	; 0x83
3002acbc:	e1cd31b6 	strh	r3, [sp, #22]
        	DiskInfo1 = &DiskInfo[drive];
3002acc0:	e5dd201f 	ldrb	r2, [sp, #31]
3002acc4:	e1a03002 	mov	r3, r2
3002acc8:	e1a03083 	lsl	r3, r3, #1
3002accc:	e0833002 	add	r3, r3, r2
3002acd0:	e1a03103 	lsl	r3, r3, #2
3002acd4:	e0833002 	add	r3, r3, r2
3002acd8:	e1a03103 	lsl	r3, r3, #2
3002acdc:	e1a02003 	mov	r2, r3
3002ace0:	e59f32f4 	ldr	r3, [pc, #756]	; 3002afdc <FsCommand+0x370>
3002ace4:	e0823003 	add	r3, r2, r3
3002ace8:	e58d3024 	str	r3, [sp, #36]	; 0x24
        	if (DiskInfo1 != NULL)
3002acec:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3002acf0:	e3530000 	cmp	r3, #0
3002acf4:	0a0000aa 	beq	3002afa4 <FsCommand+0x338>
        	{
				DiskInfo1->DiakCommand = FsCommand;
3002acf8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3002acfc:	e59f22dc 	ldr	r2, [pc, #732]	; 3002afe0 <FsCommand+0x374>
3002ad00:	e5832030 	str	r2, [r3, #48]	; 0x30
				dev_id=acoral_dev_open((acoral_char *)(Dp->Buf));
3002ad04:	e59d3020 	ldr	r3, [sp, #32]
3002ad08:	e593300c 	ldr	r3, [r3, #12]
3002ad0c:	e1a00003 	mov	r0, r3
3002ad10:	eb005633 	bl	300405e4 <acoral_dev_open>
3002ad14:	e1a03000 	mov	r3, r0
3002ad18:	e58d3018 	str	r3, [sp, #24]
				if(dev_id!=ACORAL_DEV_ERR_ID)
3002ad1c:	e59d3018 	ldr	r3, [sp, #24]
3002ad20:	e3730001 	cmn	r3, #1
3002ad24:	0a0000a0 	beq	3002afac <FsCommand+0x340>
				{
					DiskInfo1->DevId= dev_id;
3002ad28:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3002ad2c:	e59d2018 	ldr	r2, [sp, #24]
3002ad30:	e5832004 	str	r2, [r3, #4]
						if(SD_Initialize()==0);
							return DISK_INIT_OK;
					}
					else
						acoral_dev_close(dev_id);*/
					rt = DISK_INIT_OK;
3002ad34:	e3a03003 	mov	r3, #3
3002ad38:	e1cd31b6 	strh	r3, [sp, #22]
		/*	DiskInfo1->RsvdForLow = SDGetBlockSize();
			if(SD_Initialize()==SD_NO_ERR);*/
					
        	}
		
            break;
3002ad3c:	ea0000a1 	b	3002afc8 <FsCommand+0x35c>
        	 
        case DISK_CLOSE:
			acoral_dev_close(DiskInfo[drive].DevId);
3002ad40:	e5dd201f 	ldrb	r2, [sp, #31]
3002ad44:	e59f0290 	ldr	r0, [pc, #656]	; 3002afdc <FsCommand+0x370>
3002ad48:	e3a01004 	mov	r1, #4
3002ad4c:	e1a03002 	mov	r3, r2
3002ad50:	e1a03083 	lsl	r3, r3, #1
3002ad54:	e0833002 	add	r3, r3, r2
3002ad58:	e1a03103 	lsl	r3, r3, #2
3002ad5c:	e0833002 	add	r3, r3, r2
3002ad60:	e1a03103 	lsl	r3, r3, #2
3002ad64:	e0833000 	add	r3, r3, r0
3002ad68:	e0833001 	add	r3, r3, r1
3002ad6c:	e5933000 	ldr	r3, [r3]
3002ad70:	e1a00003 	mov	r0, r3
3002ad74:	eb0056b0 	bl	3004083c <acoral_dev_close>
            break;
3002ad78:	ea000092 	b	3002afc8 <FsCommand+0x35c>
        case DISK_READ_SUPER_SECTOR:								/**/
	    	rt = DISK_READ_OK;
3002ad7c:	e3a03001 	mov	r3, #1
3002ad80:	e1cd31b6 	strh	r3, [sp, #22]
            if(acoral_dev_read(DiskInfo[drive].DevId,(void *)Dp->Buf,512,0,0)!=0)
3002ad84:	e5dd201f 	ldrb	r2, [sp, #31]
3002ad88:	e59f024c 	ldr	r0, [pc, #588]	; 3002afdc <FsCommand+0x370>
3002ad8c:	e3a01004 	mov	r1, #4
3002ad90:	e1a03002 	mov	r3, r2
3002ad94:	e1a03083 	lsl	r3, r3, #1
3002ad98:	e0833002 	add	r3, r3, r2
3002ad9c:	e1a03103 	lsl	r3, r3, #2
3002ada0:	e0833002 	add	r3, r3, r2
3002ada4:	e1a03103 	lsl	r3, r3, #2
3002ada8:	e0833000 	add	r3, r3, r0
3002adac:	e0833001 	add	r3, r3, r1
3002adb0:	e5932000 	ldr	r2, [r3]
3002adb4:	e59d3020 	ldr	r3, [sp, #32]
3002adb8:	e593300c 	ldr	r3, [r3, #12]
3002adbc:	e3a01000 	mov	r1, #0
3002adc0:	e58d1000 	str	r1, [sp]
3002adc4:	e1a00002 	mov	r0, r2
3002adc8:	e1a01003 	mov	r1, r3
3002adcc:	e3a02c02 	mov	r2, #512	; 0x200
3002add0:	e3a03000 	mov	r3, #0
3002add4:	eb00564d 	bl	30040710 <acoral_dev_read>
3002add8:	e1a03000 	mov	r3, r0
3002addc:	e3530000 	cmp	r3, #0
3002ade0:	0a000073 	beq	3002afb4 <FsCommand+0x348>
            { 
                rt = DISK_READ_NOT_OK;
3002ade4:	e3a03080 	mov	r3, #128	; 0x80
3002ade8:	e1cd31b6 	strh	r3, [sp, #22]
            }
            break;
3002adec:	ea000075 	b	3002afc8 <FsCommand+0x35c>

        case DISK_READ_SECTOR:									/**/
            rt = DISK_READ_OK;
3002adf0:	e3a03001 	mov	r3, #1
3002adf4:	e1cd31b6 	strh	r3, [sp, #22]
            if(acoral_dev_read(
3002adf8:	e5dd201f 	ldrb	r2, [sp, #31]
3002adfc:	e59f01d8 	ldr	r0, [pc, #472]	; 3002afdc <FsCommand+0x370>
3002ae00:	e3a01004 	mov	r1, #4
3002ae04:	e1a03002 	mov	r3, r2
3002ae08:	e1a03083 	lsl	r3, r3, #1
3002ae0c:	e0833002 	add	r3, r3, r2
3002ae10:	e1a03103 	lsl	r3, r3, #2
3002ae14:	e0833002 	add	r3, r3, r2
3002ae18:	e1a03103 	lsl	r3, r3, #2
3002ae1c:	e0833000 	add	r3, r3, r0
3002ae20:	e0833001 	add	r3, r3, r1
3002ae24:	e5930000 	ldr	r0, [r3]
3002ae28:	e59d3020 	ldr	r3, [sp, #32]
3002ae2c:	e593100c 	ldr	r1, [r3, #12]
3002ae30:	e5dd201f 	ldrb	r2, [sp, #31]
3002ae34:	e59fe1a0 	ldr	lr, [pc, #416]	; 3002afdc <FsCommand+0x370>
3002ae38:	e3a0c00c 	mov	ip, #12
3002ae3c:	e1a03002 	mov	r3, r2
3002ae40:	e1a03083 	lsl	r3, r3, #1
3002ae44:	e0833002 	add	r3, r3, r2
3002ae48:	e1a03103 	lsl	r3, r3, #2
3002ae4c:	e0833002 	add	r3, r3, r2
3002ae50:	e1a03103 	lsl	r3, r3, #2
3002ae54:	e083300e 	add	r3, r3, lr
3002ae58:	e083300c 	add	r3, r3, ip
3002ae5c:	e593c000 	ldr	ip, [r3]
3002ae60:	e59d3020 	ldr	r3, [sp, #32]
3002ae64:	e593e004 	ldr	lr, [r3, #4]
3002ae68:	e5dd201f 	ldrb	r2, [sp, #31]
3002ae6c:	e59f5168 	ldr	r5, [pc, #360]	; 3002afdc <FsCommand+0x370>
3002ae70:	e3a0400c 	mov	r4, #12
3002ae74:	e1a03002 	mov	r3, r2
3002ae78:	e1a03083 	lsl	r3, r3, #1
3002ae7c:	e0833002 	add	r3, r3, r2
3002ae80:	e1a03103 	lsl	r3, r3, #2
3002ae84:	e0833002 	add	r3, r3, r2
3002ae88:	e1a03103 	lsl	r3, r3, #2
3002ae8c:	e0833005 	add	r3, r3, r5
3002ae90:	e0833004 	add	r3, r3, r4
3002ae94:	e5933000 	ldr	r3, [r3]
3002ae98:	e003039e 	mul	r3, lr, r3
3002ae9c:	e3a02000 	mov	r2, #0
3002aea0:	e58d2000 	str	r2, [sp]
3002aea4:	e1a0200c 	mov	r2, ip
3002aea8:	eb005618 	bl	30040710 <acoral_dev_read>
3002aeac:	e1a03000 	mov	r3, r0
3002aeb0:	e3530000 	cmp	r3, #0
3002aeb4:	0a000040 	beq	3002afbc <FsCommand+0x350>
            	(void *)Dp->Buf,
            	DiskInfo[drive].BytsPerSec,
            	Dp->SectorIndex*DiskInfo[drive].BytsPerSec,
            	0)!=0)
            { 
                rt = DISK_READ_NOT_OK;
3002aeb8:	e3a03080 	mov	r3, #128	; 0x80
3002aebc:	e1cd31b6 	strh	r3, [sp, #22]
            }
            break;
3002aec0:	ea000040 	b	3002afc8 <FsCommand+0x35c>
        case DISK_WRITE_SECTOR:									/*д*/
            rt = DISK_WRITE_OK;
3002aec4:	e3a03002 	mov	r3, #2
3002aec8:	e1cd31b6 	strh	r3, [sp, #22]
            if(acoral_dev_write(
3002aecc:	e5dd201f 	ldrb	r2, [sp, #31]
3002aed0:	e59f0104 	ldr	r0, [pc, #260]	; 3002afdc <FsCommand+0x370>
3002aed4:	e3a01004 	mov	r1, #4
3002aed8:	e1a03002 	mov	r3, r2
3002aedc:	e1a03083 	lsl	r3, r3, #1
3002aee0:	e0833002 	add	r3, r3, r2
3002aee4:	e1a03103 	lsl	r3, r3, #2
3002aee8:	e0833002 	add	r3, r3, r2
3002aeec:	e1a03103 	lsl	r3, r3, #2
3002aef0:	e0833000 	add	r3, r3, r0
3002aef4:	e0833001 	add	r3, r3, r1
3002aef8:	e5930000 	ldr	r0, [r3]
3002aefc:	e59d3020 	ldr	r3, [sp, #32]
3002af00:	e593100c 	ldr	r1, [r3, #12]
3002af04:	e5dd201f 	ldrb	r2, [sp, #31]
3002af08:	e59fe0cc 	ldr	lr, [pc, #204]	; 3002afdc <FsCommand+0x370>
3002af0c:	e3a0c00c 	mov	ip, #12
3002af10:	e1a03002 	mov	r3, r2
3002af14:	e1a03083 	lsl	r3, r3, #1
3002af18:	e0833002 	add	r3, r3, r2
3002af1c:	e1a03103 	lsl	r3, r3, #2
3002af20:	e0833002 	add	r3, r3, r2
3002af24:	e1a03103 	lsl	r3, r3, #2
3002af28:	e083300e 	add	r3, r3, lr
3002af2c:	e083300c 	add	r3, r3, ip
3002af30:	e593c000 	ldr	ip, [r3]
3002af34:	e59d3020 	ldr	r3, [sp, #32]
3002af38:	e593e004 	ldr	lr, [r3, #4]
3002af3c:	e5dd201f 	ldrb	r2, [sp, #31]
3002af40:	e59f5094 	ldr	r5, [pc, #148]	; 3002afdc <FsCommand+0x370>
3002af44:	e3a0400c 	mov	r4, #12
3002af48:	e1a03002 	mov	r3, r2
3002af4c:	e1a03083 	lsl	r3, r3, #1
3002af50:	e0833002 	add	r3, r3, r2
3002af54:	e1a03103 	lsl	r3, r3, #2
3002af58:	e0833002 	add	r3, r3, r2
3002af5c:	e1a03103 	lsl	r3, r3, #2
3002af60:	e0833005 	add	r3, r3, r5
3002af64:	e0833004 	add	r3, r3, r4
3002af68:	e5933000 	ldr	r3, [r3]
3002af6c:	e003039e 	mul	r3, lr, r3
3002af70:	e3a02000 	mov	r2, #0
3002af74:	e58d2000 	str	r2, [sp]
3002af78:	e1a0200c 	mov	r2, ip
3002af7c:	eb0055bd 	bl	30040678 <acoral_dev_write>
3002af80:	e1a03000 	mov	r3, r0
3002af84:	e3530000 	cmp	r3, #0
3002af88:	0a00000d 	beq	3002afc4 <FsCommand+0x358>
            	(void *)Dp->Buf,
            	DiskInfo[drive].BytsPerSec,
            	Dp->SectorIndex*DiskInfo[drive].BytsPerSec,
            	0)!=0)
            {
               rt = DISK_WRITE_NOT_OK;
3002af8c:	e3a03082 	mov	r3, #130	; 0x82
3002af90:	e1cd31b6 	strh	r3, [sp, #22]
            }

            break;
3002af94:	ea00000b 	b	3002afc8 <FsCommand+0x35c>
        default:
            rt = BAD_DISK_COMMAND;
3002af98:	e3e03000 	mvn	r3, #0
3002af9c:	e1cd31b6 	strh	r3, [sp, #22]
3002afa0:	ea000008 	b	3002afc8 <FsCommand+0x35c>
		/*	DiskInfo1->RsvdForLow = SDGetBlockSize();
			if(SD_Initialize()==SD_NO_ERR);*/
					
        	}
		
            break;
3002afa4:	e1a00000 	nop			; (mov r0, r0)
3002afa8:	ea000006 	b	3002afc8 <FsCommand+0x35c>
3002afac:	e1a00000 	nop			; (mov r0, r0)
3002afb0:	ea000004 	b	3002afc8 <FsCommand+0x35c>
	    	rt = DISK_READ_OK;
            if(acoral_dev_read(DiskInfo[drive].DevId,(void *)Dp->Buf,512,0,0)!=0)
            { 
                rt = DISK_READ_NOT_OK;
            }
            break;
3002afb4:	e1a00000 	nop			; (mov r0, r0)
3002afb8:	ea000002 	b	3002afc8 <FsCommand+0x35c>
            	Dp->SectorIndex*DiskInfo[drive].BytsPerSec,
            	0)!=0)
            { 
                rt = DISK_READ_NOT_OK;
            }
            break;
3002afbc:	e1a00000 	nop			; (mov r0, r0)
3002afc0:	ea000000 	b	3002afc8 <FsCommand+0x35c>
            	0)!=0)
            {
               rt = DISK_WRITE_NOT_OK;
            }

            break;
3002afc4:	e1a00000 	nop			; (mov r0, r0)
        default:
            rt = BAD_DISK_COMMAND;
            break;
    }
    return rt;
3002afc8:	e1dd31b6 	ldrh	r3, [sp, #22]
}
3002afcc:	e1a00003 	mov	r0, r3
3002afd0:	e28dd02c 	add	sp, sp, #44	; 0x2c
3002afd4:	e8bd4030 	pop	{r4, r5, lr}
3002afd8:	e12fff1e 	bx	lr
3002afdc:	300eab48 	.word	0x300eab48
3002afe0:	3002ac6c 	.word	0x3002ac6c

3002afe4 <acoral_unlink>:
#include <mutex.h>
#include <mem.h>
acoral_evt_t *fs_mutex;

acoral_32 acoral_unlink(const acoral_char *pathname)
{
3002afe4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002afe8:	e24dd01c 	sub	sp, sp, #28
3002afec:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 ret;
	acoral_u8  fs_ret,len;
	acoral_char *path;
	len=acoral_str_len(pathname);
3002aff0:	e59d0004 	ldr	r0, [sp, #4]
3002aff4:	ebff81cf 	bl	3000b738 <acoral_str_len>
3002aff8:	e1a03000 	mov	r3, r0
3002affc:	e5cd3013 	strb	r3, [sp, #19]
	if(path=(acoral_char *)acoral_malloc2(len+1))
3002b000:	e5dd3013 	ldrb	r3, [sp, #19]
3002b004:	e2833001 	add	r3, r3, #1
3002b008:	e1a00003 	mov	r0, r3
3002b00c:	ebff6f00 	bl	30006c14 <v_malloc>
3002b010:	e1a03000 	mov	r3, r0
3002b014:	e58d3014 	str	r3, [sp, #20]
3002b018:	e59d3014 	ldr	r3, [sp, #20]
3002b01c:	e3530000 	cmp	r3, #0
3002b020:	0a000012 	beq	3002b070 <acoral_unlink+0x8c>
	{
		acoral_str_cpy(path,pathname);
3002b024:	e59d0014 	ldr	r0, [sp, #20]
3002b028:	e59d1004 	ldr	r1, [sp, #4]
3002b02c:	ebff81da 	bl	3000b79c <acoral_str_cpy>
		path[len]=0;
3002b030:	e5dd2013 	ldrb	r2, [sp, #19]
3002b034:	e59d3014 	ldr	r3, [sp, #20]
3002b038:	e0823003 	add	r3, r2, r3
3002b03c:	e3a02000 	mov	r2, #0
3002b040:	e5c32000 	strb	r2, [r3]
	}
	else
		return -1;
	ret=acoral_mutex_pend(fs_mutex,0);
3002b044:	e59f308c 	ldr	r3, [pc, #140]	; 3002b0d8 <acoral_unlink+0xf4>
3002b048:	e5933000 	ldr	r3, [r3]
3002b04c:	e1a00003 	mov	r0, r3
3002b050:	e3a01000 	mov	r1, #0
3002b054:	ebff67ef 	bl	30005018 <acoral_mutex_pend>
3002b058:	e1a03000 	mov	r3, r0
3002b05c:	e58d300c 	str	r3, [sp, #12]
	if(ret!=MUTEX_SUCCED)
3002b060:	e59d300c 	ldr	r3, [sp, #12]
3002b064:	e3530000 	cmp	r3, #0
3002b068:	1a000002 	bne	3002b078 <acoral_unlink+0x94>
3002b06c:	ea000005 	b	3002b088 <acoral_unlink+0xa4>
	{
		acoral_str_cpy(path,pathname);
		path[len]=0;
	}
	else
		return -1;
3002b070:	e3e03000 	mvn	r3, #0
3002b074:	ea000013 	b	3002b0c8 <acoral_unlink+0xe4>
	ret=acoral_mutex_pend(fs_mutex,0);
	if(ret!=MUTEX_SUCCED)
	{
		acoral_free2(path);
3002b078:	e59d0014 	ldr	r0, [sp, #20]
3002b07c:	ebff6ef9 	bl	30006c68 <v_free>
		return -1;
3002b080:	e3e03000 	mvn	r3, #0
3002b084:	ea00000f 	b	3002b0c8 <acoral_unlink+0xe4>
	}
	fs_ret=RemoveFile(path);
3002b088:	e59d0014 	ldr	r0, [sp, #20]
3002b08c:	ebfff320 	bl	30027d14 <RemoveFile>
3002b090:	e1a03000 	mov	r3, r0
3002b094:	e5cd3012 	strb	r3, [sp, #18]
	acoral_mutex_post(fs_mutex);
3002b098:	e59f3038 	ldr	r3, [pc, #56]	; 3002b0d8 <acoral_unlink+0xf4>
3002b09c:	e5933000 	ldr	r3, [r3]
3002b0a0:	e1a00003 	mov	r0, r3
3002b0a4:	ebff686c 	bl	3000525c <acoral_mutex_post>
	acoral_free2(path);
3002b0a8:	e59d0014 	ldr	r0, [sp, #20]
3002b0ac:	ebff6eed 	bl	30006c68 <v_free>
	if(fs_ret!=RETURN_OK)
3002b0b0:	e5dd3012 	ldrb	r3, [sp, #18]
3002b0b4:	e3530000 	cmp	r3, #0
3002b0b8:	0a000001 	beq	3002b0c4 <acoral_unlink+0xe0>
		return -1;
3002b0bc:	e3e03000 	mvn	r3, #0
3002b0c0:	ea000000 	b	3002b0c8 <acoral_unlink+0xe4>
	return 0;
3002b0c4:	e3a03000 	mov	r3, #0
}
3002b0c8:	e1a00003 	mov	r0, r3
3002b0cc:	e28dd01c 	add	sp, sp, #28
3002b0d0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002b0d4:	e12fff1e 	bx	lr
3002b0d8:	3012a80c 	.word	0x3012a80c

3002b0dc <acoral_open>:


acoral_32 acoral_open(const acoral_char *pathname,acoral_32 oflag)
{
3002b0dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002b0e0:	e24dd024 	sub	sp, sp, #36	; 0x24
3002b0e4:	e58d0004 	str	r0, [sp, #4]
3002b0e8:	e58d1000 	str	r1, [sp]
	acoral_u32 ret;
	acoral_32 fd;
	acoral_u8 len;
	acoral_char flag[3];
	acoral_char *pflag=flag;
3002b0ec:	e28d3008 	add	r3, sp, #8
3002b0f0:	e58d3018 	str	r3, [sp, #24]
	acoral_char *path;
	len=acoral_str_len(pathname);
3002b0f4:	e59d0004 	ldr	r0, [sp, #4]
3002b0f8:	ebff818e 	bl	3000b738 <acoral_str_len>
3002b0fc:	e1a03000 	mov	r3, r0
3002b100:	e5cd3017 	strb	r3, [sp, #23]
	if(path=(acoral_char *)acoral_malloc2(len+1))
3002b104:	e5dd3017 	ldrb	r3, [sp, #23]
3002b108:	e2833001 	add	r3, r3, #1
3002b10c:	e1a00003 	mov	r0, r3
3002b110:	ebff6ebf 	bl	30006c14 <v_malloc>
3002b114:	e1a03000 	mov	r3, r0
3002b118:	e58d301c 	str	r3, [sp, #28]
3002b11c:	e59d301c 	ldr	r3, [sp, #28]
3002b120:	e3530000 	cmp	r3, #0
3002b124:	0a00000c 	beq	3002b15c <acoral_open+0x80>
	{
		acoral_str_cpy(path,pathname);
3002b128:	e59d001c 	ldr	r0, [sp, #28]
3002b12c:	e59d1004 	ldr	r1, [sp, #4]
3002b130:	ebff8199 	bl	3000b79c <acoral_str_cpy>
		path[len]=0;
3002b134:	e5dd2017 	ldrb	r2, [sp, #23]
3002b138:	e59d301c 	ldr	r3, [sp, #28]
3002b13c:	e0823003 	add	r3, r2, r3
3002b140:	e3a02000 	mov	r2, #0
3002b144:	e5c32000 	strb	r2, [r3]
	}
	else
		return -1;
		
	if(oflag&O_RDONLY)
3002b148:	e59d3000 	ldr	r3, [sp]
3002b14c:	e2033004 	and	r3, r3, #4
3002b150:	e3530000 	cmp	r3, #0
3002b154:	1a000002 	bne	3002b164 <acoral_open+0x88>
3002b158:	ea000007 	b	3002b17c <acoral_open+0xa0>
	{
		acoral_str_cpy(path,pathname);
		path[len]=0;
	}
	else
		return -1;
3002b15c:	e3e03000 	mvn	r3, #0
3002b160:	ea00002d 	b	3002b21c <acoral_open+0x140>
		
	if(oflag&O_RDONLY)
		*pflag++='r';
3002b164:	e59d3018 	ldr	r3, [sp, #24]
3002b168:	e3a02072 	mov	r2, #114	; 0x72
3002b16c:	e5c32000 	strb	r2, [r3]
3002b170:	e59d3018 	ldr	r3, [sp, #24]
3002b174:	e2833001 	add	r3, r3, #1
3002b178:	e58d3018 	str	r3, [sp, #24]
	if(oflag&O_WRONLY)
3002b17c:	e59d3000 	ldr	r3, [sp]
3002b180:	e2033002 	and	r3, r3, #2
3002b184:	e3530000 	cmp	r3, #0
3002b188:	0a000005 	beq	3002b1a4 <acoral_open+0xc8>
		*pflag++='w';
3002b18c:	e59d3018 	ldr	r3, [sp, #24]
3002b190:	e3a02077 	mov	r2, #119	; 0x77
3002b194:	e5c32000 	strb	r2, [r3]
3002b198:	e59d3018 	ldr	r3, [sp, #24]
3002b19c:	e2833001 	add	r3, r3, #1
3002b1a0:	e58d3018 	str	r3, [sp, #24]
	*pflag='\0';
3002b1a4:	e59d3018 	ldr	r3, [sp, #24]
3002b1a8:	e3a02000 	mov	r2, #0
3002b1ac:	e5c32000 	strb	r2, [r3]
	ret=acoral_mutex_pend(fs_mutex,0);
3002b1b0:	e59f3074 	ldr	r3, [pc, #116]	; 3002b22c <acoral_open+0x150>
3002b1b4:	e5933000 	ldr	r3, [r3]
3002b1b8:	e1a00003 	mov	r0, r3
3002b1bc:	e3a01000 	mov	r1, #0
3002b1c0:	ebff6794 	bl	30005018 <acoral_mutex_pend>
3002b1c4:	e1a03000 	mov	r3, r0
3002b1c8:	e58d300c 	str	r3, [sp, #12]
	if(ret!=MUTEX_SUCCED)
3002b1cc:	e59d300c 	ldr	r3, [sp, #12]
3002b1d0:	e3530000 	cmp	r3, #0
3002b1d4:	0a000003 	beq	3002b1e8 <acoral_open+0x10c>
	{
		acoral_free2(path);
3002b1d8:	e59d001c 	ldr	r0, [sp, #28]
3002b1dc:	ebff6ea1 	bl	30006c68 <v_free>
		return -1;
3002b1e0:	e3e03000 	mvn	r3, #0
3002b1e4:	ea00000c 	b	3002b21c <acoral_open+0x140>
	}
	fd=FileOpen(path,flag);
3002b1e8:	e28d3008 	add	r3, sp, #8
3002b1ec:	e59d001c 	ldr	r0, [sp, #28]
3002b1f0:	e1a01003 	mov	r1, r3
3002b1f4:	ebfff4e7 	bl	30028598 <FileOpen>
3002b1f8:	e1a03000 	mov	r3, r0
3002b1fc:	e58d3010 	str	r3, [sp, #16]
	acoral_mutex_post(fs_mutex);
3002b200:	e59f3024 	ldr	r3, [pc, #36]	; 3002b22c <acoral_open+0x150>
3002b204:	e5933000 	ldr	r3, [r3]
3002b208:	e1a00003 	mov	r0, r3
3002b20c:	ebff6812 	bl	3000525c <acoral_mutex_post>
	acoral_free2(path);
3002b210:	e59d001c 	ldr	r0, [sp, #28]
3002b214:	ebff6e93 	bl	30006c68 <v_free>
	return fd;
3002b218:	e59d3010 	ldr	r3, [sp, #16]
}
3002b21c:	e1a00003 	mov	r0, r3
3002b220:	e28dd024 	add	sp, sp, #36	; 0x24
3002b224:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002b228:	e12fff1e 	bx	lr
3002b22c:	3012a80c 	.word	0x3012a80c

3002b230 <acoral_close>:

acoral_32 acoral_close(acoral_32 fd)
{
3002b230:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002b234:	e24dd014 	sub	sp, sp, #20
3002b238:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 ret;
	acoral_u8 fs_ret;
	ret=acoral_mutex_pend(fs_mutex,0);
3002b23c:	e59f3074 	ldr	r3, [pc, #116]	; 3002b2b8 <acoral_close+0x88>
3002b240:	e5933000 	ldr	r3, [r3]
3002b244:	e1a00003 	mov	r0, r3
3002b248:	e3a01000 	mov	r1, #0
3002b24c:	ebff6771 	bl	30005018 <acoral_mutex_pend>
3002b250:	e1a03000 	mov	r3, r0
3002b254:	e58d3008 	str	r3, [sp, #8]
	if(ret!=MUTEX_SUCCED)
3002b258:	e59d3008 	ldr	r3, [sp, #8]
3002b25c:	e3530000 	cmp	r3, #0
3002b260:	0a000001 	beq	3002b26c <acoral_close+0x3c>
		return -1;
3002b264:	e3e03000 	mvn	r3, #0
3002b268:	ea00000e 	b	3002b2a8 <acoral_close+0x78>
	fs_ret=FileClose(fd);
3002b26c:	e59d0004 	ldr	r0, [sp, #4]
3002b270:	ebfff4fd 	bl	3002866c <FileClose>
3002b274:	e1a03000 	mov	r3, r0
3002b278:	e5cd300f 	strb	r3, [sp, #15]
	AllCacheWriteBack();
3002b27c:	eb000247 	bl	3002bba0 <AllCacheWriteBack>
	acoral_mutex_post(fs_mutex);
3002b280:	e59f3030 	ldr	r3, [pc, #48]	; 3002b2b8 <acoral_close+0x88>
3002b284:	e5933000 	ldr	r3, [r3]
3002b288:	e1a00003 	mov	r0, r3
3002b28c:	ebff67f2 	bl	3000525c <acoral_mutex_post>
	if(fs_ret!=RETURN_OK)
3002b290:	e5dd300f 	ldrb	r3, [sp, #15]
3002b294:	e3530000 	cmp	r3, #0
3002b298:	0a000001 	beq	3002b2a4 <acoral_close+0x74>
		return -1;
3002b29c:	e3e03000 	mvn	r3, #0
3002b2a0:	ea000000 	b	3002b2a8 <acoral_close+0x78>
	return 0;
3002b2a4:	e3a03000 	mov	r3, #0
}
3002b2a8:	e1a00003 	mov	r0, r3
3002b2ac:	e28dd014 	add	sp, sp, #20
3002b2b0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002b2b4:	e12fff1e 	bx	lr
3002b2b8:	3012a80c 	.word	0x3012a80c

3002b2bc <acoral_read>:

acoral_32 acoral_read(acoral_32 fd,void *buf,acoral_u32 nbytes)
{
3002b2bc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002b2c0:	e24dd01c 	sub	sp, sp, #28
3002b2c4:	e58d000c 	str	r0, [sp, #12]
3002b2c8:	e58d1008 	str	r1, [sp, #8]
3002b2cc:	e58d2004 	str	r2, [sp, #4]
	acoral_u32 ret;
	acoral_32  fs_ret;
	ret=acoral_mutex_pend(fs_mutex,0);
3002b2d0:	e59f3064 	ldr	r3, [pc, #100]	; 3002b33c <acoral_read+0x80>
3002b2d4:	e5933000 	ldr	r3, [r3]
3002b2d8:	e1a00003 	mov	r0, r3
3002b2dc:	e3a01000 	mov	r1, #0
3002b2e0:	ebff674c 	bl	30005018 <acoral_mutex_pend>
3002b2e4:	e1a03000 	mov	r3, r0
3002b2e8:	e58d3010 	str	r3, [sp, #16]
	if(ret!=MUTEX_SUCCED)
3002b2ec:	e59d3010 	ldr	r3, [sp, #16]
3002b2f0:	e3530000 	cmp	r3, #0
3002b2f4:	0a000001 	beq	3002b300 <acoral_read+0x44>
		return -1;
3002b2f8:	e3e03000 	mvn	r3, #0
3002b2fc:	ea00000a 	b	3002b32c <acoral_read+0x70>
	fs_ret=FileRead(buf,nbytes,fd);
3002b300:	e59d0008 	ldr	r0, [sp, #8]
3002b304:	e59d1004 	ldr	r1, [sp, #4]
3002b308:	e59d200c 	ldr	r2, [sp, #12]
3002b30c:	ebfff602 	bl	30028b1c <FileRead>
3002b310:	e1a03000 	mov	r3, r0
3002b314:	e58d3014 	str	r3, [sp, #20]
	acoral_mutex_post(fs_mutex);
3002b318:	e59f301c 	ldr	r3, [pc, #28]	; 3002b33c <acoral_read+0x80>
3002b31c:	e5933000 	ldr	r3, [r3]
3002b320:	e1a00003 	mov	r0, r3
3002b324:	ebff67cc 	bl	3000525c <acoral_mutex_post>
	return fs_ret;
3002b328:	e59d3014 	ldr	r3, [sp, #20]
}
3002b32c:	e1a00003 	mov	r0, r3
3002b330:	e28dd01c 	add	sp, sp, #28
3002b334:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002b338:	e12fff1e 	bx	lr
3002b33c:	3012a80c 	.word	0x3012a80c

3002b340 <acoral_write>:

acoral_32 acoral_write(acoral_32 fd,const void *buf,acoral_u32 nbytes)
{
3002b340:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002b344:	e24dd01c 	sub	sp, sp, #28
3002b348:	e58d000c 	str	r0, [sp, #12]
3002b34c:	e58d1008 	str	r1, [sp, #8]
3002b350:	e58d2004 	str	r2, [sp, #4]
	acoral_u32 ret,fs_ret;
	ret=acoral_mutex_pend(fs_mutex,0);
3002b354:	e59f3064 	ldr	r3, [pc, #100]	; 3002b3c0 <acoral_write+0x80>
3002b358:	e5933000 	ldr	r3, [r3]
3002b35c:	e1a00003 	mov	r0, r3
3002b360:	e3a01000 	mov	r1, #0
3002b364:	ebff672b 	bl	30005018 <acoral_mutex_pend>
3002b368:	e1a03000 	mov	r3, r0
3002b36c:	e58d3010 	str	r3, [sp, #16]
	if(ret!=MUTEX_SUCCED)
3002b370:	e59d3010 	ldr	r3, [sp, #16]
3002b374:	e3530000 	cmp	r3, #0
3002b378:	0a000001 	beq	3002b384 <acoral_write+0x44>
		return -1;
3002b37c:	e3e03000 	mvn	r3, #0
3002b380:	ea00000a 	b	3002b3b0 <acoral_write+0x70>
	fs_ret=FileWrite(buf,nbytes,fd);
3002b384:	e59d0008 	ldr	r0, [sp, #8]
3002b388:	e59d1004 	ldr	r1, [sp, #4]
3002b38c:	e59d200c 	ldr	r2, [sp, #12]
3002b390:	ebfff876 	bl	30029570 <FileWrite>
3002b394:	e1a03000 	mov	r3, r0
3002b398:	e58d3014 	str	r3, [sp, #20]
	acoral_mutex_post(fs_mutex);
3002b39c:	e59f301c 	ldr	r3, [pc, #28]	; 3002b3c0 <acoral_write+0x80>
3002b3a0:	e5933000 	ldr	r3, [r3]
3002b3a4:	e1a00003 	mov	r0, r3
3002b3a8:	ebff67ab 	bl	3000525c <acoral_mutex_post>
	return fs_ret;
3002b3ac:	e59d3014 	ldr	r3, [sp, #20]
}
3002b3b0:	e1a00003 	mov	r0, r3
3002b3b4:	e28dd01c 	add	sp, sp, #28
3002b3b8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002b3bc:	e12fff1e 	bx	lr
3002b3c0:	3012a80c 	.word	0x3012a80c

3002b3c4 <acoral_closeall>:

acoral_32 acoral_closeall(void)
{
3002b3c4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002b3c8:	e24dd00c 	sub	sp, sp, #12
	acoral_u32 ret;
	ret=acoral_mutex_pend(fs_mutex,0);
3002b3cc:	e59f3050 	ldr	r3, [pc, #80]	; 3002b424 <acoral_closeall+0x60>
3002b3d0:	e5933000 	ldr	r3, [r3]
3002b3d4:	e1a00003 	mov	r0, r3
3002b3d8:	e3a01000 	mov	r1, #0
3002b3dc:	ebff670d 	bl	30005018 <acoral_mutex_pend>
3002b3e0:	e1a03000 	mov	r3, r0
3002b3e4:	e58d3004 	str	r3, [sp, #4]
	if(ret!=MUTEX_SUCCED)
3002b3e8:	e59d3004 	ldr	r3, [sp, #4]
3002b3ec:	e3530000 	cmp	r3, #0
3002b3f0:	0a000001 	beq	3002b3fc <acoral_closeall+0x38>
		return -1;
3002b3f4:	e3e03000 	mvn	r3, #0
3002b3f8:	ea000005 	b	3002b414 <acoral_closeall+0x50>
	FileCloseAll();
3002b3fc:	ebfffa74 	bl	30029dd4 <FileCloseAll>
	acoral_mutex_post(fs_mutex);
3002b400:	e59f301c 	ldr	r3, [pc, #28]	; 3002b424 <acoral_closeall+0x60>
3002b404:	e5933000 	ldr	r3, [r3]
3002b408:	e1a00003 	mov	r0, r3
3002b40c:	ebff6792 	bl	3000525c <acoral_mutex_post>
	return 0;
3002b410:	e3a03000 	mov	r3, #0
}
3002b414:	e1a00003 	mov	r0, r3
3002b418:	e28dd00c 	add	sp, sp, #12
3002b41c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002b420:	e12fff1e 	bx	lr
3002b424:	3012a80c 	.word	0x3012a80c

3002b428 <acoral_lseek>:

acoral_u32 acoral_lseek(acoral_32 fd,acoral_32 offset,acoral_u8 whence)
{
3002b428:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002b42c:	e24dd01c 	sub	sp, sp, #28
3002b430:	e58d000c 	str	r0, [sp, #12]
3002b434:	e58d1008 	str	r1, [sp, #8]
3002b438:	e1a03002 	mov	r3, r2
3002b43c:	e5cd3007 	strb	r3, [sp, #7]
	acoral_u32 ret,fs_ret;
	ret=acoral_mutex_pend(fs_mutex,0);
3002b440:	e59f3068 	ldr	r3, [pc, #104]	; 3002b4b0 <acoral_lseek+0x88>
3002b444:	e5933000 	ldr	r3, [r3]
3002b448:	e1a00003 	mov	r0, r3
3002b44c:	e3a01000 	mov	r1, #0
3002b450:	ebff66f0 	bl	30005018 <acoral_mutex_pend>
3002b454:	e1a03000 	mov	r3, r0
3002b458:	e58d3010 	str	r3, [sp, #16]
	if(ret!=MUTEX_SUCCED)
3002b45c:	e59d3010 	ldr	r3, [sp, #16]
3002b460:	e3530000 	cmp	r3, #0
3002b464:	0a000001 	beq	3002b470 <acoral_lseek+0x48>
		return -1;
3002b468:	e3e03000 	mvn	r3, #0
3002b46c:	ea00000b 	b	3002b4a0 <acoral_lseek+0x78>
	fs_ret=FileSeek(fd,offset,whence);
3002b470:	e5dd3007 	ldrb	r3, [sp, #7]
3002b474:	e59d000c 	ldr	r0, [sp, #12]
3002b478:	e59d1008 	ldr	r1, [sp, #8]
3002b47c:	e1a02003 	mov	r2, r3
3002b480:	ebfffa87 	bl	30029ea4 <FileSeek>
3002b484:	e1a03000 	mov	r3, r0
3002b488:	e58d3014 	str	r3, [sp, #20]
	acoral_mutex_post(fs_mutex);
3002b48c:	e59f301c 	ldr	r3, [pc, #28]	; 3002b4b0 <acoral_lseek+0x88>
3002b490:	e5933000 	ldr	r3, [r3]
3002b494:	e1a00003 	mov	r0, r3
3002b498:	ebff676f 	bl	3000525c <acoral_mutex_post>
	return fs_ret;
3002b49c:	e59d3014 	ldr	r3, [sp, #20]
}
3002b4a0:	e1a00003 	mov	r0, r3
3002b4a4:	e28dd01c 	add	sp, sp, #28
3002b4a8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002b4ac:	e12fff1e 	bx	lr
3002b4b0:	3012a80c 	.word	0x3012a80c

3002b4b4 <acoral_mkdir>:

acoral_32 acoral_mkdir(const acoral_char *pathname,acoral_u8 mode)
{
3002b4b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002b4b8:	e24dd01c 	sub	sp, sp, #28
3002b4bc:	e58d0004 	str	r0, [sp, #4]
3002b4c0:	e1a03001 	mov	r3, r1
3002b4c4:	e5cd3003 	strb	r3, [sp, #3]
	acoral_u32 ret;
	acoral_u8 fs_ret,len;
	acoral_char *path;
	len=acoral_str_len(pathname);
3002b4c8:	e59d0004 	ldr	r0, [sp, #4]
3002b4cc:	ebff8099 	bl	3000b738 <acoral_str_len>
3002b4d0:	e1a03000 	mov	r3, r0
3002b4d4:	e5cd3013 	strb	r3, [sp, #19]
	if(path=(acoral_char *)acoral_malloc2(len+1))
3002b4d8:	e5dd3013 	ldrb	r3, [sp, #19]
3002b4dc:	e2833001 	add	r3, r3, #1
3002b4e0:	e1a00003 	mov	r0, r3
3002b4e4:	ebff6dca 	bl	30006c14 <v_malloc>
3002b4e8:	e1a03000 	mov	r3, r0
3002b4ec:	e58d3014 	str	r3, [sp, #20]
3002b4f0:	e59d3014 	ldr	r3, [sp, #20]
3002b4f4:	e3530000 	cmp	r3, #0
3002b4f8:	0a000012 	beq	3002b548 <acoral_mkdir+0x94>
	{
		acoral_str_cpy(path,pathname);
3002b4fc:	e59d0014 	ldr	r0, [sp, #20]
3002b500:	e59d1004 	ldr	r1, [sp, #4]
3002b504:	ebff80a4 	bl	3000b79c <acoral_str_cpy>
		path[len]=0;
3002b508:	e5dd2013 	ldrb	r2, [sp, #19]
3002b50c:	e59d3014 	ldr	r3, [sp, #20]
3002b510:	e0823003 	add	r3, r2, r3
3002b514:	e3a02000 	mov	r2, #0
3002b518:	e5c32000 	strb	r2, [r3]
	}
	else
		return -1;
	ret=acoral_mutex_pend(fs_mutex,0);
3002b51c:	e59f308c 	ldr	r3, [pc, #140]	; 3002b5b0 <acoral_mkdir+0xfc>
3002b520:	e5933000 	ldr	r3, [r3]
3002b524:	e1a00003 	mov	r0, r3
3002b528:	e3a01000 	mov	r1, #0
3002b52c:	ebff66b9 	bl	30005018 <acoral_mutex_pend>
3002b530:	e1a03000 	mov	r3, r0
3002b534:	e58d300c 	str	r3, [sp, #12]
	if(ret!=MUTEX_SUCCED)
3002b538:	e59d300c 	ldr	r3, [sp, #12]
3002b53c:	e3530000 	cmp	r3, #0
3002b540:	1a000002 	bne	3002b550 <acoral_mkdir+0x9c>
3002b544:	ea000005 	b	3002b560 <acoral_mkdir+0xac>
	{
		acoral_str_cpy(path,pathname);
		path[len]=0;
	}
	else
		return -1;
3002b548:	e3e03000 	mvn	r3, #0
3002b54c:	ea000013 	b	3002b5a0 <acoral_mkdir+0xec>
	ret=acoral_mutex_pend(fs_mutex,0);
	if(ret!=MUTEX_SUCCED)
	{
		acoral_free2(path);
3002b550:	e59d0014 	ldr	r0, [sp, #20]
3002b554:	ebff6dc3 	bl	30006c68 <v_free>
		return -1;
3002b558:	e3e03000 	mvn	r3, #0
3002b55c:	ea00000f 	b	3002b5a0 <acoral_mkdir+0xec>
	}
	fs_ret=MakeDir(path);
3002b560:	e59d0014 	ldr	r0, [sp, #20]
3002b564:	ebffe1f1 	bl	30023d30 <MakeDir>
3002b568:	e1a03000 	mov	r3, r0
3002b56c:	e5cd3012 	strb	r3, [sp, #18]
	acoral_mutex_post(fs_mutex);
3002b570:	e59f3038 	ldr	r3, [pc, #56]	; 3002b5b0 <acoral_mkdir+0xfc>
3002b574:	e5933000 	ldr	r3, [r3]
3002b578:	e1a00003 	mov	r0, r3
3002b57c:	ebff6736 	bl	3000525c <acoral_mutex_post>
	acoral_free2(path);
3002b580:	e59d0014 	ldr	r0, [sp, #20]
3002b584:	ebff6db7 	bl	30006c68 <v_free>
	if(fs_ret!=RETURN_OK)
3002b588:	e5dd3012 	ldrb	r3, [sp, #18]
3002b58c:	e3530000 	cmp	r3, #0
3002b590:	0a000001 	beq	3002b59c <acoral_mkdir+0xe8>
		return -1;
3002b594:	e3e03000 	mvn	r3, #0
3002b598:	ea000000 	b	3002b5a0 <acoral_mkdir+0xec>
	return 0;	
3002b59c:	e3a03000 	mov	r3, #0
}
3002b5a0:	e1a00003 	mov	r0, r3
3002b5a4:	e28dd01c 	add	sp, sp, #28
3002b5a8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002b5ac:	e12fff1e 	bx	lr
3002b5b0:	3012a80c 	.word	0x3012a80c

3002b5b4 <acoral_rmdir>:

acoral_32 acoral_rmdir(const acoral_char *pathname)
{
3002b5b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002b5b8:	e24dd01c 	sub	sp, sp, #28
3002b5bc:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 ret;
	acoral_u8 fs_ret,len;
	acoral_char *path;
	len=acoral_str_len(pathname);
3002b5c0:	e59d0004 	ldr	r0, [sp, #4]
3002b5c4:	ebff805b 	bl	3000b738 <acoral_str_len>
3002b5c8:	e1a03000 	mov	r3, r0
3002b5cc:	e5cd3013 	strb	r3, [sp, #19]
	if(path=(acoral_char *)acoral_malloc2(len+1))
3002b5d0:	e5dd3013 	ldrb	r3, [sp, #19]
3002b5d4:	e2833001 	add	r3, r3, #1
3002b5d8:	e1a00003 	mov	r0, r3
3002b5dc:	ebff6d8c 	bl	30006c14 <v_malloc>
3002b5e0:	e1a03000 	mov	r3, r0
3002b5e4:	e58d3014 	str	r3, [sp, #20]
3002b5e8:	e59d3014 	ldr	r3, [sp, #20]
3002b5ec:	e3530000 	cmp	r3, #0
3002b5f0:	0a000012 	beq	3002b640 <acoral_rmdir+0x8c>
	{
		acoral_str_cpy(path,pathname);
3002b5f4:	e59d0014 	ldr	r0, [sp, #20]
3002b5f8:	e59d1004 	ldr	r1, [sp, #4]
3002b5fc:	ebff8066 	bl	3000b79c <acoral_str_cpy>
		path[len]=0;
3002b600:	e5dd2013 	ldrb	r2, [sp, #19]
3002b604:	e59d3014 	ldr	r3, [sp, #20]
3002b608:	e0823003 	add	r3, r2, r3
3002b60c:	e3a02000 	mov	r2, #0
3002b610:	e5c32000 	strb	r2, [r3]
	}
	else
		return -1;
	ret=acoral_mutex_pend(fs_mutex,0);
3002b614:	e59f308c 	ldr	r3, [pc, #140]	; 3002b6a8 <acoral_rmdir+0xf4>
3002b618:	e5933000 	ldr	r3, [r3]
3002b61c:	e1a00003 	mov	r0, r3
3002b620:	e3a01000 	mov	r1, #0
3002b624:	ebff667b 	bl	30005018 <acoral_mutex_pend>
3002b628:	e1a03000 	mov	r3, r0
3002b62c:	e58d300c 	str	r3, [sp, #12]
	if(ret!=MUTEX_SUCCED)
3002b630:	e59d300c 	ldr	r3, [sp, #12]
3002b634:	e3530000 	cmp	r3, #0
3002b638:	1a000002 	bne	3002b648 <acoral_rmdir+0x94>
3002b63c:	ea000005 	b	3002b658 <acoral_rmdir+0xa4>
	{
		acoral_str_cpy(path,pathname);
		path[len]=0;
	}
	else
		return -1;
3002b640:	e3e03000 	mvn	r3, #0
3002b644:	ea000013 	b	3002b698 <acoral_rmdir+0xe4>
	ret=acoral_mutex_pend(fs_mutex,0);
	if(ret!=MUTEX_SUCCED)
	{
		acoral_free2(path);
3002b648:	e59d0014 	ldr	r0, [sp, #20]
3002b64c:	ebff6d85 	bl	30006c68 <v_free>
		return -1;
3002b650:	e3e03000 	mvn	r3, #0
3002b654:	ea00000f 	b	3002b698 <acoral_rmdir+0xe4>
	}
	fs_ret=RemoveDir(path);
3002b658:	e59d0014 	ldr	r0, [sp, #20]
3002b65c:	ebffe245 	bl	30023f78 <RemoveDir>
3002b660:	e1a03000 	mov	r3, r0
3002b664:	e5cd3012 	strb	r3, [sp, #18]
	acoral_mutex_post(fs_mutex);
3002b668:	e59f3038 	ldr	r3, [pc, #56]	; 3002b6a8 <acoral_rmdir+0xf4>
3002b66c:	e5933000 	ldr	r3, [r3]
3002b670:	e1a00003 	mov	r0, r3
3002b674:	ebff66f8 	bl	3000525c <acoral_mutex_post>
	acoral_free2(path);
3002b678:	e59d0014 	ldr	r0, [sp, #20]
3002b67c:	ebff6d79 	bl	30006c68 <v_free>
	if(fs_ret!=RETURN_OK)
3002b680:	e5dd3012 	ldrb	r3, [sp, #18]
3002b684:	e3530000 	cmp	r3, #0
3002b688:	0a000001 	beq	3002b694 <acoral_rmdir+0xe0>
		return -1;
3002b68c:	e3e03000 	mvn	r3, #0
3002b690:	ea000000 	b	3002b698 <acoral_rmdir+0xe4>
	return 0;
3002b694:	e3a03000 	mov	r3, #0
}
3002b698:	e1a00003 	mov	r0, r3
3002b69c:	e28dd01c 	add	sp, sp, #28
3002b6a0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002b6a4:	e12fff1e 	bx	lr
3002b6a8:	3012a80c 	.word	0x3012a80c

3002b6ac <acoral_chdir>:

acoral_32 acoral_chdir(const acoral_char *pathname)
{
3002b6ac:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002b6b0:	e24dd01c 	sub	sp, sp, #28
3002b6b4:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 ret;
	acoral_u8 fs_ret,len;
	acoral_char *path;
	len=acoral_str_len(pathname);
3002b6b8:	e59d0004 	ldr	r0, [sp, #4]
3002b6bc:	ebff801d 	bl	3000b738 <acoral_str_len>
3002b6c0:	e1a03000 	mov	r3, r0
3002b6c4:	e5cd3013 	strb	r3, [sp, #19]
	if(path=(acoral_char *)acoral_malloc2(len+1))
3002b6c8:	e5dd3013 	ldrb	r3, [sp, #19]
3002b6cc:	e2833001 	add	r3, r3, #1
3002b6d0:	e1a00003 	mov	r0, r3
3002b6d4:	ebff6d4e 	bl	30006c14 <v_malloc>
3002b6d8:	e1a03000 	mov	r3, r0
3002b6dc:	e58d3014 	str	r3, [sp, #20]
3002b6e0:	e59d3014 	ldr	r3, [sp, #20]
3002b6e4:	e3530000 	cmp	r3, #0
3002b6e8:	0a000012 	beq	3002b738 <acoral_chdir+0x8c>
	{
		acoral_str_cpy(path,pathname);
3002b6ec:	e59d0014 	ldr	r0, [sp, #20]
3002b6f0:	e59d1004 	ldr	r1, [sp, #4]
3002b6f4:	ebff8028 	bl	3000b79c <acoral_str_cpy>
		path[len]=0;
3002b6f8:	e5dd2013 	ldrb	r2, [sp, #19]
3002b6fc:	e59d3014 	ldr	r3, [sp, #20]
3002b700:	e0823003 	add	r3, r2, r3
3002b704:	e3a02000 	mov	r2, #0
3002b708:	e5c32000 	strb	r2, [r3]
	}
	else
		return -1;
	ret=acoral_mutex_pend(fs_mutex,0);
3002b70c:	e59f308c 	ldr	r3, [pc, #140]	; 3002b7a0 <acoral_chdir+0xf4>
3002b710:	e5933000 	ldr	r3, [r3]
3002b714:	e1a00003 	mov	r0, r3
3002b718:	e3a01000 	mov	r1, #0
3002b71c:	ebff663d 	bl	30005018 <acoral_mutex_pend>
3002b720:	e1a03000 	mov	r3, r0
3002b724:	e58d300c 	str	r3, [sp, #12]
	if(ret!=MUTEX_SUCCED)
3002b728:	e59d300c 	ldr	r3, [sp, #12]
3002b72c:	e3530000 	cmp	r3, #0
3002b730:	1a000002 	bne	3002b740 <acoral_chdir+0x94>
3002b734:	ea000005 	b	3002b750 <acoral_chdir+0xa4>
	{
		acoral_str_cpy(path,pathname);
		path[len]=0;
	}
	else
		return -1;
3002b738:	e3e03000 	mvn	r3, #0
3002b73c:	ea000013 	b	3002b790 <acoral_chdir+0xe4>
	ret=acoral_mutex_pend(fs_mutex,0);
	if(ret!=MUTEX_SUCCED)
	{
		acoral_free2(path);
3002b740:	e59d0014 	ldr	r0, [sp, #20]
3002b744:	ebff6d47 	bl	30006c68 <v_free>
		return -1;
3002b748:	e3e03000 	mvn	r3, #0
3002b74c:	ea00000f 	b	3002b790 <acoral_chdir+0xe4>
	}
	fs_ret=ChangeDir(path);
3002b750:	e59d0014 	ldr	r0, [sp, #20]
3002b754:	ebffe24f 	bl	30024098 <ChangeDir>
3002b758:	e1a03000 	mov	r3, r0
3002b75c:	e5cd3012 	strb	r3, [sp, #18]
	acoral_mutex_post(fs_mutex);
3002b760:	e59f3038 	ldr	r3, [pc, #56]	; 3002b7a0 <acoral_chdir+0xf4>
3002b764:	e5933000 	ldr	r3, [r3]
3002b768:	e1a00003 	mov	r0, r3
3002b76c:	ebff66ba 	bl	3000525c <acoral_mutex_post>
	acoral_free2(path);
3002b770:	e59d0014 	ldr	r0, [sp, #20]
3002b774:	ebff6d3b 	bl	30006c68 <v_free>
	if(fs_ret!=RETURN_OK)
3002b778:	e5dd3012 	ldrb	r3, [sp, #18]
3002b77c:	e3530000 	cmp	r3, #0
3002b780:	0a000001 	beq	3002b78c <acoral_chdir+0xe0>
		return -1;
3002b784:	e3e03000 	mvn	r3, #0
3002b788:	ea000000 	b	3002b790 <acoral_chdir+0xe4>
	return 0;
3002b78c:	e3a03000 	mov	r3, #0
}
3002b790:	e1a00003 	mov	r0, r3
3002b794:	e28dd01c 	add	sp, sp, #28
3002b798:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002b79c:	e12fff1e 	bx	lr
3002b7a0:	3012a80c 	.word	0x3012a80c

3002b7a4 <acoral_flush>:

void acoral_flush(void)
{
3002b7a4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002b7a8:	e24dd00c 	sub	sp, sp, #12
	acoral_u32 ret;
	ret=acoral_mutex_pend(fs_mutex,0);
3002b7ac:	e59f304c 	ldr	r3, [pc, #76]	; 3002b800 <acoral_flush+0x5c>
3002b7b0:	e5933000 	ldr	r3, [r3]
3002b7b4:	e1a00003 	mov	r0, r3
3002b7b8:	e3a01000 	mov	r1, #0
3002b7bc:	ebff6615 	bl	30005018 <acoral_mutex_pend>
3002b7c0:	e1a03000 	mov	r3, r0
3002b7c4:	e58d3004 	str	r3, [sp, #4]
	if(ret!=MUTEX_SUCCED)
3002b7c8:	e59d3004 	ldr	r3, [sp, #4]
3002b7cc:	e3530000 	cmp	r3, #0
3002b7d0:	1a000006 	bne	3002b7f0 <acoral_flush+0x4c>
		return;
	AllCacheWriteBack();
3002b7d4:	eb0000f1 	bl	3002bba0 <AllCacheWriteBack>
	acoral_mutex_post(fs_mutex);
3002b7d8:	e59f3020 	ldr	r3, [pc, #32]	; 3002b800 <acoral_flush+0x5c>
3002b7dc:	e5933000 	ldr	r3, [r3]
3002b7e0:	e1a00003 	mov	r0, r3
3002b7e4:	ebff669c 	bl	3000525c <acoral_mutex_post>
	return;
3002b7e8:	e1a00000 	nop			; (mov r0, r0)
3002b7ec:	ea000000 	b	3002b7f4 <acoral_flush+0x50>
void acoral_flush(void)
{
	acoral_u32 ret;
	ret=acoral_mutex_pend(fs_mutex,0);
	if(ret!=MUTEX_SUCCED)
		return;
3002b7f0:	e1a00000 	nop			; (mov r0, r0)
	AllCacheWriteBack();
	acoral_mutex_post(fs_mutex);
	return;
}
3002b7f4:	e28dd00c 	add	sp, sp, #12
3002b7f8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002b7fc:	e12fff1e 	bx	lr
3002b800:	3012a80c 	.word	0x3012a80c

3002b804 <acoral_mount>:

acoral_32 acoral_mount(acoral_char *source,const char *target,
					   const acoral_char *filesystemtype,acoral_u32 mountflags,
					   const void *data)
{
3002b804:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002b808:	e24dd01c 	sub	sp, sp, #28
3002b80c:	e58d000c 	str	r0, [sp, #12]
3002b810:	e58d1008 	str	r1, [sp, #8]
3002b814:	e58d2004 	str	r2, [sp, #4]
3002b818:	e58d3000 	str	r3, [sp]
	acoral_u32 ret;
	acoral_32 fs_ret;
	ret=acoral_mutex_pend(fs_mutex,0);
3002b81c:	e59f3094 	ldr	r3, [pc, #148]	; 3002b8b8 <acoral_mount+0xb4>
3002b820:	e5933000 	ldr	r3, [r3]
3002b824:	e1a00003 	mov	r0, r3
3002b828:	e3a01000 	mov	r1, #0
3002b82c:	ebff65f9 	bl	30005018 <acoral_mutex_pend>
3002b830:	e1a03000 	mov	r3, r0
3002b834:	e58d3010 	str	r3, [sp, #16]
	if(ret!=MUTEX_SUCCED)
3002b838:	e59d3010 	ldr	r3, [sp, #16]
3002b83c:	e3530000 	cmp	r3, #0
3002b840:	0a000001 	beq	3002b84c <acoral_mount+0x48>
		return -1;
3002b844:	e3e03000 	mvn	r3, #0
3002b848:	ea000016 	b	3002b8a8 <acoral_mount+0xa4>
	fs_ret=AddFileDriver(FsCommand,source,GetDrive(target));
3002b84c:	e59d0008 	ldr	r0, [sp, #8]
3002b850:	ebffe03f 	bl	30023954 <GetDrive>
3002b854:	e1a03000 	mov	r3, r0
3002b858:	e59f005c 	ldr	r0, [pc, #92]	; 3002b8bc <acoral_mount+0xb8>
3002b85c:	e59d100c 	ldr	r1, [sp, #12]
3002b860:	e1a02003 	mov	r2, r3
3002b864:	ebffe311 	bl	300244b0 <AddFileDriver>
3002b868:	e1a03000 	mov	r3, r0
3002b86c:	e58d3014 	str	r3, [sp, #20]
	if(fs_ret==-1)
3002b870:	e59d3014 	ldr	r3, [sp, #20]
3002b874:	e3730001 	cmn	r3, #1
3002b878:	1a000005 	bne	3002b894 <acoral_mount+0x90>
	{
		acoral_mutex_post(fs_mutex);
3002b87c:	e59f3034 	ldr	r3, [pc, #52]	; 3002b8b8 <acoral_mount+0xb4>
3002b880:	e5933000 	ldr	r3, [r3]
3002b884:	e1a00003 	mov	r0, r3
3002b888:	ebff6673 	bl	3000525c <acoral_mutex_post>
		return -1;
3002b88c:	e3e03000 	mvn	r3, #0
3002b890:	ea000004 	b	3002b8a8 <acoral_mount+0xa4>
	}
	acoral_mutex_post(fs_mutex);
3002b894:	e59f301c 	ldr	r3, [pc, #28]	; 3002b8b8 <acoral_mount+0xb4>
3002b898:	e5933000 	ldr	r3, [r3]
3002b89c:	e1a00003 	mov	r0, r3
3002b8a0:	ebff666d 	bl	3000525c <acoral_mutex_post>
	return 0;
3002b8a4:	e3a03000 	mov	r3, #0
}
3002b8a8:	e1a00003 	mov	r0, r3
3002b8ac:	e28dd01c 	add	sp, sp, #28
3002b8b0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002b8b4:	e12fff1e 	bx	lr
3002b8b8:	3012a80c 	.word	0x3012a80c
3002b8bc:	3002ac6c 	.word	0x3002ac6c

3002b8c0 <acoral_umount>:

acoral_32 acoral_umount(const char *target)
{
3002b8c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002b8c4:	e24dd014 	sub	sp, sp, #20
3002b8c8:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 ret;
	ret=acoral_mutex_pend(fs_mutex,0);
3002b8cc:	e59f3060 	ldr	r3, [pc, #96]	; 3002b934 <acoral_umount+0x74>
3002b8d0:	e5933000 	ldr	r3, [r3]
3002b8d4:	e1a00003 	mov	r0, r3
3002b8d8:	e3a01000 	mov	r1, #0
3002b8dc:	ebff65cd 	bl	30005018 <acoral_mutex_pend>
3002b8e0:	e1a03000 	mov	r3, r0
3002b8e4:	e58d300c 	str	r3, [sp, #12]
	if(ret!=MUTEX_SUCCED)
3002b8e8:	e59d300c 	ldr	r3, [sp, #12]
3002b8ec:	e3530000 	cmp	r3, #0
3002b8f0:	0a000001 	beq	3002b8fc <acoral_umount+0x3c>
		return -1;
3002b8f4:	e3e03000 	mvn	r3, #0
3002b8f8:	ea000009 	b	3002b924 <acoral_umount+0x64>
	RemoveFileDriver(GetDrive(target));
3002b8fc:	e59d0004 	ldr	r0, [sp, #4]
3002b900:	ebffe013 	bl	30023954 <GetDrive>
3002b904:	e1a03000 	mov	r3, r0
3002b908:	e1a00003 	mov	r0, r3
3002b90c:	ebffe553 	bl	30024e60 <RemoveFileDriver>
	acoral_mutex_post(fs_mutex);
3002b910:	e59f301c 	ldr	r3, [pc, #28]	; 3002b934 <acoral_umount+0x74>
3002b914:	e5933000 	ldr	r3, [r3]
3002b918:	e1a00003 	mov	r0, r3
3002b91c:	ebff664e 	bl	3000525c <acoral_mutex_post>
	return 0;
3002b920:	e3a03000 	mov	r3, #0
}
3002b924:	e1a00003 	mov	r0, r3
3002b928:	e28dd014 	add	sp, sp, #20
3002b92c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002b930:	e12fff1e 	bx	lr
3002b934:	3012a80c 	.word	0x3012a80c

3002b938 <acoral_fs_init>:

void acoral_fs_init(void)
{
3002b938:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002b93c:	e24dd00c 	sub	sp, sp, #12
    DiskInit();
3002b940:	ebffe1f8 	bl	30024128 <DiskInit>
    FileInit();	
3002b944:	ebfff063 	bl	30027ad8 <FileInit>

    fs_mutex=acoral_mutex_create(0,NULL);
3002b948:	e3a00000 	mov	r0, #0
3002b94c:	e3a01000 	mov	r1, #0
3002b950:	ebff6535 	bl	30004e2c <acoral_mutex_create>
3002b954:	e1a02000 	mov	r2, r0
3002b958:	e59f3028 	ldr	r3, [pc, #40]	; 3002b988 <acoral_fs_init+0x50>
3002b95c:	e5832000 	str	r2, [r3]
    acoral_mount("disk","A:",NULL,0,NULL);
3002b960:	e3a03000 	mov	r3, #0
3002b964:	e58d3000 	str	r3, [sp]
3002b968:	e59f001c 	ldr	r0, [pc, #28]	; 3002b98c <acoral_fs_init+0x54>
3002b96c:	e59f101c 	ldr	r1, [pc, #28]	; 3002b990 <acoral_fs_init+0x58>
3002b970:	e3a02000 	mov	r2, #0
3002b974:	e3a03000 	mov	r3, #0
3002b978:	ebffffa1 	bl	3002b804 <acoral_mount>
}
3002b97c:	e28dd00c 	add	sp, sp, #12
3002b980:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002b984:	e12fff1e 	bx	lr
3002b988:	3012a80c 	.word	0x3012a80c
3002b98c:	300459b4 	.word	0x300459b4
3002b990:	300459bc 	.word	0x300459bc

3002b994 <CacheInit>:
**         
** ȫֱ: DiskCache
** ģ: 
********************************************************************************************************/
        void CacheInit(void)
{
3002b994:	e24dd008 	sub	sp, sp, #8
    acoral_u16 i;
    for(i=0;i<CACHE_HASH_SIZE;i++)
3002b998:	e3a03000 	mov	r3, #0
3002b99c:	e1cd30b6 	strh	r3, [sp, #6]
3002b9a0:	ea000006 	b	3002b9c0 <CacheInit+0x2c>
    	HashTable[i]=NULL;
3002b9a4:	e1dd20b6 	ldrh	r2, [sp, #6]
3002b9a8:	e59f3048 	ldr	r3, [pc, #72]	; 3002b9f8 <CacheInit+0x64>
3002b9ac:	e3a01000 	mov	r1, #0
3002b9b0:	e7831102 	str	r1, [r3, r2, lsl #2]
** ģ: 
********************************************************************************************************/
        void CacheInit(void)
{
    acoral_u16 i;
    for(i=0;i<CACHE_HASH_SIZE;i++)
3002b9b4:	e1dd30b6 	ldrh	r3, [sp, #6]
3002b9b8:	e2833001 	add	r3, r3, #1
3002b9bc:	e1cd30b6 	strh	r3, [sp, #6]
3002b9c0:	e1dd30b6 	ldrh	r3, [sp, #6]
3002b9c4:	e3530009 	cmp	r3, #9
3002b9c8:	9afffff5 	bls	3002b9a4 <CacheInit+0x10>
    	HashTable[i]=NULL;
    FreeList=NULL;
3002b9cc:	e59f3028 	ldr	r3, [pc, #40]	; 3002b9fc <CacheInit+0x68>
3002b9d0:	e3a02000 	mov	r2, #0
3002b9d4:	e5832000 	str	r2, [r3]
    FreeListTail = NULL;
3002b9d8:	e59f3020 	ldr	r3, [pc, #32]	; 3002ba00 <CacheInit+0x6c>
3002b9dc:	e3a02000 	mov	r2, #0
3002b9e0:	e5832000 	str	r2, [r3]
    CacheNum = 0;
3002b9e4:	e59f3018 	ldr	r3, [pc, #24]	; 3002ba04 <CacheInit+0x70>
3002b9e8:	e3a02000 	mov	r2, #0
3002b9ec:	e5c32000 	strb	r2, [r3]
}
3002b9f0:	e28dd008 	add	sp, sp, #8
3002b9f4:	e12fff1e 	bx	lr
3002b9f8:	301f5910 	.word	0x301f5910
3002b9fc:	3012b63c 	.word	0x3012b63c
3002ba00:	3012d6dc 	.word	0x3012d6dc
3002ba04:	3012d688 	.word	0x3012d688

3002ba08 <CloseSec>:
**         
** ȫֱ: DiskCache
** ģ: 
********************************************************************************************************/
        void CloseSec(acoral_u8 Drive, acoral_u32 Index)
{
3002ba08:	e24dd008 	sub	sp, sp, #8
3002ba0c:	e1a03000 	mov	r3, r0
3002ba10:	e58d1000 	str	r1, [sp]
3002ba14:	e5cd3007 	strb	r3, [sp, #7]
    Drive = Drive;
    Index = Index;
}
3002ba18:	e28dd008 	add	sp, sp, #8
3002ba1c:	e12fff1e 	bx	lr

3002ba20 <CacheWriteBack2>:
**         
** ȫֱ: DiskCache
** ģ: GetDiskInfo
********************************************************************************************************/
        void CacheWriteBack2(Disk_cache* pcache)
{
3002ba20:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002ba24:	e24dd024 	sub	sp, sp, #36	; 0x24
3002ba28:	e58d0004 	str	r0, [sp, #4]
    Disk_RW_Parameter Pa;
    Disk_Info * Disk;

    Disk = GetDiskInfo(pcache->Drive);     // ȡ߼Ϣ
3002ba2c:	e59d3004 	ldr	r3, [sp, #4]
3002ba30:	e5d33000 	ldrb	r3, [r3]
3002ba34:	e1a00003 	mov	r0, r3
3002ba38:	ebffe278 	bl	30024420 <GetDiskInfo>
3002ba3c:	e1a03000 	mov	r3, r0
3002ba40:	e58d301c 	str	r3, [sp, #28]
    if (Disk != NULL)
3002ba44:	e59d301c 	ldr	r3, [sp, #28]
3002ba48:	e3530000 	cmp	r3, #0
3002ba4c:	0a00001b 	beq	3002bac0 <CacheWriteBack2+0xa0>
    if (Disk->DiakCommand != NULL)
3002ba50:	e59d301c 	ldr	r3, [sp, #28]
3002ba54:	e5933030 	ldr	r3, [r3, #48]	; 0x30
3002ba58:	e3530000 	cmp	r3, #0
3002ba5c:	0a000017 	beq	3002bac0 <CacheWriteBack2+0xa0>
    {
        pcache->Flag &= ~CACHE_WRITED;     // cache Ҫд
3002ba60:	e59d3004 	ldr	r3, [sp, #4]
3002ba64:	e5d33001 	ldrb	r3, [r3, #1]
3002ba68:	e20330fe 	and	r3, r3, #254	; 0xfe
3002ba6c:	e59d2004 	ldr	r2, [sp, #4]
3002ba70:	e5c23001 	strb	r3, [r2, #1]
        /* ݲ */
        Pa.Drive = pcache->Drive;               
3002ba74:	e59d3004 	ldr	r3, [sp, #4]
3002ba78:	e5d33000 	ldrb	r3, [r3]
3002ba7c:	e5cd300c 	strb	r3, [sp, #12]
        Pa.SectorIndex = pcache->SecIndex;
3002ba80:	e59d3004 	ldr	r3, [sp, #4]
3002ba84:	e5933004 	ldr	r3, [r3, #4]
3002ba88:	e58d3010 	str	r3, [sp, #16]
        Pa.RsvdForLow = Disk->RsvdForLow;
3002ba8c:	e59d301c 	ldr	r3, [sp, #28]
3002ba90:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
3002ba94:	e58d3014 	str	r3, [sp, #20]
        Pa.Buf = pcache->buf;
3002ba98:	e59d3004 	ldr	r3, [sp, #4]
3002ba9c:	e2833014 	add	r3, r3, #20
3002baa0:	e58d3018 	str	r3, [sp, #24]
        
        Disk->DiakCommand(DISK_WRITE_SECTOR, &Pa);  /* õײд */ 
3002baa4:	e59d301c 	ldr	r3, [sp, #28]
3002baa8:	e5933030 	ldr	r3, [r3, #48]	; 0x30
3002baac:	e28d200c 	add	r2, sp, #12
3002bab0:	e3a00003 	mov	r0, #3
3002bab4:	e1a01002 	mov	r1, r2
3002bab8:	e1a0e00f 	mov	lr, pc
3002babc:	e12fff13 	bx	r3
    }
}
3002bac0:	e28dd024 	add	sp, sp, #36	; 0x24
3002bac4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002bac8:	e12fff1e 	bx	lr

3002bacc <CacheWriteBack>:
**         
** ȫֱ: DiskCache
** ģ: CacheWriteBack2
********************************************************************************************************/
       void CacheWriteBack(acoral_u8 Drive, acoral_u32 Index)
{
3002bacc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002bad0:	e24dd014 	sub	sp, sp, #20
3002bad4:	e1a03000 	mov	r3, r0
3002bad8:	e58d1000 	str	r1, [sp]
3002badc:	e5cd3007 	strb	r3, [sp, #7]
    Disk_cache* pcache;
    acoral_u8  hashindex = Index % CACHE_HASH_SIZE;
3002bae0:	e59d1000 	ldr	r1, [sp]
3002bae4:	e59f30ac 	ldr	r3, [pc, #172]	; 3002bb98 <CacheWriteBack+0xcc>
3002bae8:	e0832391 	umull	r2, r3, r1, r3
3002baec:	e1a021a3 	lsr	r2, r3, #3
3002baf0:	e1a03002 	mov	r3, r2
3002baf4:	e1a03103 	lsl	r3, r3, #2
3002baf8:	e0833002 	add	r3, r3, r2
3002bafc:	e1a03083 	lsl	r3, r3, #1
3002bb00:	e0632001 	rsb	r2, r3, r1
3002bb04:	e1a03002 	mov	r3, r2
3002bb08:	e5cd300f 	strb	r3, [sp, #15]
    for(pcache = HashTable[hashindex]; pcache != NULL; pcache = pcache->NextHash)
3002bb0c:	e5dd200f 	ldrb	r2, [sp, #15]
3002bb10:	e59f3084 	ldr	r3, [pc, #132]	; 3002bb9c <CacheWriteBack+0xd0>
3002bb14:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3002bb18:	e58d3008 	str	r3, [sp, #8]
3002bb1c:	ea000015 	b	3002bb78 <CacheWriteBack+0xac>
    {
    	if(pcache->Drive == Drive)
3002bb20:	e59d3008 	ldr	r3, [sp, #8]
3002bb24:	e5d33000 	ldrb	r3, [r3]
3002bb28:	e5dd2007 	ldrb	r2, [sp, #7]
3002bb2c:	e1520003 	cmp	r2, r3
3002bb30:	1a00000d 	bne	3002bb6c <CacheWriteBack+0xa0>
    	if(pcache->SecIndex == Index)
3002bb34:	e59d3008 	ldr	r3, [sp, #8]
3002bb38:	e5932004 	ldr	r2, [r3, #4]
3002bb3c:	e59d3000 	ldr	r3, [sp]
3002bb40:	e1520003 	cmp	r2, r3
3002bb44:	1a000008 	bne	3002bb6c <CacheWriteBack+0xa0>
    	{
    		if((pcache->Flag & CACHE_WRITED) != 0)
3002bb48:	e59d3008 	ldr	r3, [sp, #8]
3002bb4c:	e5d33001 	ldrb	r3, [r3, #1]
3002bb50:	e2033001 	and	r3, r3, #1
3002bb54:	e20330ff 	and	r3, r3, #255	; 0xff
3002bb58:	e3530000 	cmp	r3, #0
3002bb5c:	0a000009 	beq	3002bb88 <CacheWriteBack+0xbc>
    		{
    			CacheWriteBack2(pcache);
3002bb60:	e59d0008 	ldr	r0, [sp, #8]
3002bb64:	ebffffad 	bl	3002ba20 <CacheWriteBack2>
    		}
    		break;
3002bb68:	ea000007 	b	3002bb8c <CacheWriteBack+0xc0>
********************************************************************************************************/
       void CacheWriteBack(acoral_u8 Drive, acoral_u32 Index)
{
    Disk_cache* pcache;
    acoral_u8  hashindex = Index % CACHE_HASH_SIZE;
    for(pcache = HashTable[hashindex]; pcache != NULL; pcache = pcache->NextHash)
3002bb6c:	e59d3008 	ldr	r3, [sp, #8]
3002bb70:	e5933008 	ldr	r3, [r3, #8]
3002bb74:	e58d3008 	str	r3, [sp, #8]
3002bb78:	e59d3008 	ldr	r3, [sp, #8]
3002bb7c:	e3530000 	cmp	r3, #0
3002bb80:	1affffe6 	bne	3002bb20 <CacheWriteBack+0x54>
3002bb84:	ea000000 	b	3002bb8c <CacheWriteBack+0xc0>
    	{
    		if((pcache->Flag & CACHE_WRITED) != 0)
    		{
    			CacheWriteBack2(pcache);
    		}
    		break;
3002bb88:	e1a00000 	nop			; (mov r0, r0)
    	}
    }
}
3002bb8c:	e28dd014 	add	sp, sp, #20
3002bb90:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002bb94:	e12fff1e 	bx	lr
3002bb98:	cccccccd 	.word	0xcccccccd
3002bb9c:	301f5910 	.word	0x301f5910

3002bba0 <AllCacheWriteBack>:
**         
** ȫֱ: DiskCache
** ģ: CacheWriteBack2
********************************************************************************************************/
       void AllCacheWriteBack(void)
{
3002bba0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002bba4:	e24dd00c 	sub	sp, sp, #12
    Disk_cache* pcache;

    for (pcache = FreeList; pcache != NULL; pcache = pcache->NextFreeList)
3002bba8:	e59f304c 	ldr	r3, [pc, #76]	; 3002bbfc <AllCacheWriteBack+0x5c>
3002bbac:	e5933000 	ldr	r3, [r3]
3002bbb0:	e58d3004 	str	r3, [sp, #4]
3002bbb4:	ea00000a 	b	3002bbe4 <AllCacheWriteBack+0x44>
    {
        if ((pcache->Flag & CACHE_WRITED) != 0)
3002bbb8:	e59d3004 	ldr	r3, [sp, #4]
3002bbbc:	e5d33001 	ldrb	r3, [r3, #1]
3002bbc0:	e2033001 	and	r3, r3, #1
3002bbc4:	e20330ff 	and	r3, r3, #255	; 0xff
3002bbc8:	e3530000 	cmp	r3, #0
3002bbcc:	0a000001 	beq	3002bbd8 <AllCacheWriteBack+0x38>
        {
            CacheWriteBack2(pcache);
3002bbd0:	e59d0004 	ldr	r0, [sp, #4]
3002bbd4:	ebffff91 	bl	3002ba20 <CacheWriteBack2>
********************************************************************************************************/
       void AllCacheWriteBack(void)
{
    Disk_cache* pcache;

    for (pcache = FreeList; pcache != NULL; pcache = pcache->NextFreeList)
3002bbd8:	e59d3004 	ldr	r3, [sp, #4]
3002bbdc:	e5933010 	ldr	r3, [r3, #16]
3002bbe0:	e58d3004 	str	r3, [sp, #4]
3002bbe4:	e59d3004 	ldr	r3, [sp, #4]
3002bbe8:	e3530000 	cmp	r3, #0
3002bbec:	1afffff1 	bne	3002bbb8 <AllCacheWriteBack+0x18>
        if ((pcache->Flag & CACHE_WRITED) != 0)
        {
            CacheWriteBack2(pcache);
        }
    }
}
3002bbf0:	e28dd00c 	add	sp, sp, #12
3002bbf4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002bbf8:	e12fff1e 	bx	lr
3002bbfc:	3012b63c 	.word	0x3012b63c

3002bc00 <GetCache>:
**         
** ȫֱ: DiskCache
** ģ: 
********************************************************************************************************/
        Disk_cache* GetCache(void)
{
3002bc00:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002bc04:	e24dd00c 	sub	sp, sp, #12
	Disk_cache* pcache;
	
	//С󻺳С»
	if(CacheNum < MAX_DISK_CACHES)
3002bc08:	e59f3204 	ldr	r3, [pc, #516]	; 3002be14 <GetCache+0x214>
3002bc0c:	e5d33000 	ldrb	r3, [r3]
3002bc10:	e3530063 	cmp	r3, #99	; 0x63
3002bc14:	8a00002b 	bhi	3002bcc8 <GetCache+0xc8>
	{
		pcache = (Disk_cache *)acoral_malloc(sizeof(Disk_cache));
3002bc18:	e3a00f85 	mov	r0, #532	; 0x214
3002bc1c:	ebff69e9 	bl	300063c8 <buddy_malloc>
3002bc20:	e1a03000 	mov	r3, r0
3002bc24:	e58d3004 	str	r3, [sp, #4]
		if(pcache == NULL)
3002bc28:	e59d3004 	ldr	r3, [sp, #4]
3002bc2c:	e3530000 	cmp	r3, #0
3002bc30:	1a000001 	bne	3002bc3c <GetCache+0x3c>
			return NULL;
3002bc34:	e3a03000 	mov	r3, #0
3002bc38:	ea000071 	b	3002be04 <GetCache+0x204>
		pcache->NextHash=NULL;
3002bc3c:	e59d3004 	ldr	r3, [sp, #4]
3002bc40:	e3a02000 	mov	r2, #0
3002bc44:	e5832008 	str	r2, [r3, #8]
		pcache->FrontHash=NULL;
3002bc48:	e59d3004 	ldr	r3, [sp, #4]
3002bc4c:	e3a02000 	mov	r2, #0
3002bc50:	e583200c 	str	r2, [r3, #12]
		pcache->NextFreeList=NULL;
3002bc54:	e59d3004 	ldr	r3, [sp, #4]
3002bc58:	e3a02000 	mov	r2, #0
3002bc5c:	e5832010 	str	r2, [r3, #16]
		CacheNum++;
3002bc60:	e59f31ac 	ldr	r3, [pc, #428]	; 3002be14 <GetCache+0x214>
3002bc64:	e5d33000 	ldrb	r3, [r3]
3002bc68:	e2833001 	add	r3, r3, #1
3002bc6c:	e20320ff 	and	r2, r3, #255	; 0xff
3002bc70:	e59f319c 	ldr	r3, [pc, #412]	; 3002be14 <GetCache+0x214>
3002bc74:	e5c32000 	strb	r2, [r3]
		if(FreeList == NULL)
3002bc78:	e59f3198 	ldr	r3, [pc, #408]	; 3002be18 <GetCache+0x218>
3002bc7c:	e5933000 	ldr	r3, [r3]
3002bc80:	e3530000 	cmp	r3, #0
3002bc84:	1a000007 	bne	3002bca8 <GetCache+0xa8>
		{
			FreeList = FreeListTail = pcache;
3002bc88:	e59f318c 	ldr	r3, [pc, #396]	; 3002be1c <GetCache+0x21c>
3002bc8c:	e59d2004 	ldr	r2, [sp, #4]
3002bc90:	e5832000 	str	r2, [r3]
3002bc94:	e59f3180 	ldr	r3, [pc, #384]	; 3002be1c <GetCache+0x21c>
3002bc98:	e5932000 	ldr	r2, [r3]
3002bc9c:	e59f3174 	ldr	r3, [pc, #372]	; 3002be18 <GetCache+0x218>
3002bca0:	e5832000 	str	r2, [r3]
		}
		else //·Ļĩβ
		{
			FreeListTail->NextFreeList=pcache;
			FreeListTail=pcache;
3002bca4:	ea000055 	b	3002be00 <GetCache+0x200>
		{
			FreeList = FreeListTail = pcache;
		}
		else //·Ļĩβ
		{
			FreeListTail->NextFreeList=pcache;
3002bca8:	e59f316c 	ldr	r3, [pc, #364]	; 3002be1c <GetCache+0x21c>
3002bcac:	e5933000 	ldr	r3, [r3]
3002bcb0:	e59d2004 	ldr	r2, [sp, #4]
3002bcb4:	e5832010 	str	r2, [r3, #16]
			FreeListTail=pcache;
3002bcb8:	e59f315c 	ldr	r3, [pc, #348]	; 3002be1c <GetCache+0x21c>
3002bcbc:	e59d2004 	ldr	r2, [sp, #4]
3002bcc0:	e5832000 	str	r2, [r3]
3002bcc4:	ea00004d 	b	3002be00 <GetCache+0x200>
		}
	}
	//ժлͷ㣬뵽βڵ㣬ӶӦhashɾ
	else
	{
		if(FreeList != FreeListTail)
3002bcc8:	e59f3148 	ldr	r3, [pc, #328]	; 3002be18 <GetCache+0x218>
3002bccc:	e5932000 	ldr	r2, [r3]
3002bcd0:	e59f3144 	ldr	r3, [pc, #324]	; 3002be1c <GetCache+0x21c>
3002bcd4:	e5933000 	ldr	r3, [r3]
3002bcd8:	e1520003 	cmp	r2, r3
3002bcdc:	0a000012 	beq	3002bd2c <GetCache+0x12c>
		{
			pcache=FreeList;
3002bce0:	e59f3130 	ldr	r3, [pc, #304]	; 3002be18 <GetCache+0x218>
3002bce4:	e5933000 	ldr	r3, [r3]
3002bce8:	e58d3004 	str	r3, [sp, #4]
			FreeList=FreeList->NextFreeList;
3002bcec:	e59f3124 	ldr	r3, [pc, #292]	; 3002be18 <GetCache+0x218>
3002bcf0:	e5933000 	ldr	r3, [r3]
3002bcf4:	e5932010 	ldr	r2, [r3, #16]
3002bcf8:	e59f3118 	ldr	r3, [pc, #280]	; 3002be18 <GetCache+0x218>
3002bcfc:	e5832000 	str	r2, [r3]
			FreeListTail->NextFreeList=pcache;
3002bd00:	e59f3114 	ldr	r3, [pc, #276]	; 3002be1c <GetCache+0x21c>
3002bd04:	e5933000 	ldr	r3, [r3]
3002bd08:	e59d2004 	ldr	r2, [sp, #4]
3002bd0c:	e5832010 	str	r2, [r3, #16]
			FreeListTail=pcache;
3002bd10:	e59f3104 	ldr	r3, [pc, #260]	; 3002be1c <GetCache+0x21c>
3002bd14:	e59d2004 	ldr	r2, [sp, #4]
3002bd18:	e5832000 	str	r2, [r3]
			FreeListTail->NextFreeList=NULL;
3002bd1c:	e59f30f8 	ldr	r3, [pc, #248]	; 3002be1c <GetCache+0x21c>
3002bd20:	e5933000 	ldr	r3, [r3]
3002bd24:	e3a02000 	mov	r2, #0
3002bd28:	e5832010 	str	r2, [r3, #16]
		}
		
		if(pcache->FrontHash == NULL)
3002bd2c:	e59d3004 	ldr	r3, [sp, #4]
3002bd30:	e593300c 	ldr	r3, [r3, #12]
3002bd34:	e3530000 	cmp	r3, #0
3002bd38:	1a000016 	bne	3002bd98 <GetCache+0x198>
		{
			if(pcache->NextHash != NULL)
3002bd3c:	e59d3004 	ldr	r3, [sp, #4]
3002bd40:	e5933008 	ldr	r3, [r3, #8]
3002bd44:	e3530000 	cmp	r3, #0
3002bd48:	0a000003 	beq	3002bd5c <GetCache+0x15c>
				pcache->NextHash->FrontHash=NULL;
3002bd4c:	e59d3004 	ldr	r3, [sp, #4]
3002bd50:	e5933008 	ldr	r3, [r3, #8]
3002bd54:	e3a02000 	mov	r2, #0
3002bd58:	e583200c 	str	r2, [r3, #12]
			HashTable[pcache->SecIndex % CACHE_HASH_SIZE] = pcache->NextHash;
3002bd5c:	e59d3004 	ldr	r3, [sp, #4]
3002bd60:	e5931004 	ldr	r1, [r3, #4]
3002bd64:	e59f30b4 	ldr	r3, [pc, #180]	; 3002be20 <GetCache+0x220>
3002bd68:	e0832391 	umull	r2, r3, r1, r3
3002bd6c:	e1a021a3 	lsr	r2, r3, #3
3002bd70:	e1a03002 	mov	r3, r2
3002bd74:	e1a03103 	lsl	r3, r3, #2
3002bd78:	e0833002 	add	r3, r3, r2
3002bd7c:	e1a03083 	lsl	r3, r3, #1
3002bd80:	e0632001 	rsb	r2, r3, r1
3002bd84:	e59d3004 	ldr	r3, [sp, #4]
3002bd88:	e5931008 	ldr	r1, [r3, #8]
3002bd8c:	e59f3090 	ldr	r3, [pc, #144]	; 3002be24 <GetCache+0x224>
3002bd90:	e7831102 	str	r1, [r3, r2, lsl #2]
3002bd94:	ea00000d 	b	3002bdd0 <GetCache+0x1d0>
		}
		else
		{
			if(pcache->NextHash != NULL)
3002bd98:	e59d3004 	ldr	r3, [sp, #4]
3002bd9c:	e5933008 	ldr	r3, [r3, #8]
3002bda0:	e3530000 	cmp	r3, #0
3002bda4:	0a000004 	beq	3002bdbc <GetCache+0x1bc>
				pcache->NextHash->FrontHash = pcache->FrontHash;
3002bda8:	e59d3004 	ldr	r3, [sp, #4]
3002bdac:	e5933008 	ldr	r3, [r3, #8]
3002bdb0:	e59d2004 	ldr	r2, [sp, #4]
3002bdb4:	e592200c 	ldr	r2, [r2, #12]
3002bdb8:	e583200c 	str	r2, [r3, #12]
			pcache->FrontHash->NextHash = pcache->NextHash;
3002bdbc:	e59d3004 	ldr	r3, [sp, #4]
3002bdc0:	e593300c 	ldr	r3, [r3, #12]
3002bdc4:	e59d2004 	ldr	r2, [sp, #4]
3002bdc8:	e5922008 	ldr	r2, [r2, #8]
3002bdcc:	e5832008 	str	r2, [r3, #8]
		}
		if(pcache->Drive != EMPTY_DRIVE)
3002bdd0:	e59d3004 	ldr	r3, [sp, #4]
3002bdd4:	e5d33000 	ldrb	r3, [r3]
3002bdd8:	e35300ff 	cmp	r3, #255	; 0xff
3002bddc:	0a000007 	beq	3002be00 <GetCache+0x200>
		if((pcache->Flag & CACHE_WRITED) != 0)
3002bde0:	e59d3004 	ldr	r3, [sp, #4]
3002bde4:	e5d33001 	ldrb	r3, [r3, #1]
3002bde8:	e2033001 	and	r3, r3, #1
3002bdec:	e20330ff 	and	r3, r3, #255	; 0xff
3002bdf0:	e3530000 	cmp	r3, #0
3002bdf4:	0a000001 	beq	3002be00 <GetCache+0x200>
		{
			CacheWriteBack2(pcache);
3002bdf8:	e59d0004 	ldr	r0, [sp, #4]
3002bdfc:	ebffff07 	bl	3002ba20 <CacheWriteBack2>
		}
	}
	return pcache;
3002be00:	e59d3004 	ldr	r3, [sp, #4]
}
3002be04:	e1a00003 	mov	r0, r3
3002be08:	e28dd00c 	add	sp, sp, #12
3002be0c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002be10:	e12fff1e 	bx	lr
3002be14:	3012d688 	.word	0x3012d688
3002be18:	3012b63c 	.word	0x3012b63c
3002be1c:	3012d6dc 	.word	0x3012d6dc
3002be20:	cccccccd 	.word	0xcccccccd
3002be24:	301f5910 	.word	0x301f5910

3002be28 <OpenSec>:
**         
** ȫֱ: DiskCache
** ģ: 
********************************************************************************************************/
        acoral_u8 *OpenSec(acoral_u8 Drive, acoral_u32 Index)
{
3002be28:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002be2c:	e24dd01c 	sub	sp, sp, #28
3002be30:	e1a03000 	mov	r3, r0
3002be34:	e58d1000 	str	r1, [sp]
3002be38:	e5cd3007 	strb	r3, [sp, #7]
    Disk_cache *pcache;
    acoral_u8 *Rt;
    Disk_Info *Disk;
   	acoral_u8 hashindex;
   	acoral_u16 i;
   	hashindex = Index % CACHE_HASH_SIZE;
3002be3c:	e59d1000 	ldr	r1, [sp]
3002be40:	e59f31ec 	ldr	r3, [pc, #492]	; 3002c034 <OpenSec+0x20c>
3002be44:	e0832391 	umull	r2, r3, r1, r3
3002be48:	e1a021a3 	lsr	r2, r3, #3
3002be4c:	e1a03002 	mov	r3, r2
3002be50:	e1a03103 	lsl	r3, r3, #2
3002be54:	e0833002 	add	r3, r3, r2
3002be58:	e1a03083 	lsl	r3, r3, #1
3002be5c:	e0632001 	rsb	r2, r3, r1
3002be60:	e1a03002 	mov	r3, r2
3002be64:	e5cd3015 	strb	r3, [sp, #21]

    /* ǷѾ */
    Rt = NULL;
3002be68:	e3a03000 	mov	r3, #0
3002be6c:	e58d300c 	str	r3, [sp, #12]
    for (pcache = HashTable[hashindex]; pcache != NULL; pcache = pcache->NextHash)
3002be70:	e5dd2015 	ldrb	r2, [sp, #21]
3002be74:	e59f31bc 	ldr	r3, [pc, #444]	; 3002c038 <OpenSec+0x210>
3002be78:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3002be7c:	e58d3008 	str	r3, [sp, #8]
3002be80:	ea000010 	b	3002bec8 <OpenSec+0xa0>
    {
        if (pcache->Drive == Drive )
3002be84:	e59d3008 	ldr	r3, [sp, #8]
3002be88:	e5d33000 	ldrb	r3, [r3]
3002be8c:	e5dd2007 	ldrb	r2, [sp, #7]
3002be90:	e1520003 	cmp	r2, r3
3002be94:	1a000008 	bne	3002bebc <OpenSec+0x94>
        if (pcache->SecIndex == Index)
3002be98:	e59d3008 	ldr	r3, [sp, #8]
3002be9c:	e5932004 	ldr	r2, [r3, #4]
3002bea0:	e59d3000 	ldr	r3, [sp]
3002bea4:	e1520003 	cmp	r2, r3
3002bea8:	1a000003 	bne	3002bebc <OpenSec+0x94>
        {
            Rt = pcache->buf;
3002beac:	e59d3008 	ldr	r3, [sp, #8]
3002beb0:	e2833014 	add	r3, r3, #20
3002beb4:	e58d300c 	str	r3, [sp, #12]
            break;
3002beb8:	ea000005 	b	3002bed4 <OpenSec+0xac>
   	acoral_u16 i;
   	hashindex = Index % CACHE_HASH_SIZE;

    /* ǷѾ */
    Rt = NULL;
    for (pcache = HashTable[hashindex]; pcache != NULL; pcache = pcache->NextHash)
3002bebc:	e59d3008 	ldr	r3, [sp, #8]
3002bec0:	e5933008 	ldr	r3, [r3, #8]
3002bec4:	e58d3008 	str	r3, [sp, #8]
3002bec8:	e59d3008 	ldr	r3, [sp, #8]
3002becc:	e3530000 	cmp	r3, #0
3002bed0:	1affffeb 	bne	3002be84 <OpenSec+0x5c>
            break;
        }
    }
    
    /* Rt == NULLδ */
    if (Rt == NULL)
3002bed4:	e59d300c 	ldr	r3, [sp, #12]
3002bed8:	e3530000 	cmp	r3, #0
3002bedc:	1a00004f 	bne	3002c020 <OpenSec+0x1f8>
    {
        Disk = GetDiskInfo(Drive);
3002bee0:	e5dd3007 	ldrb	r3, [sp, #7]
3002bee4:	e1a00003 	mov	r0, r3
3002bee8:	ebffe14c 	bl	30024420 <GetDiskInfo>
3002beec:	e1a03000 	mov	r3, r0
3002bef0:	e58d3010 	str	r3, [sp, #16]
        if (Disk != NULL)
3002bef4:	e59d3010 	ldr	r3, [sp, #16]
3002bef8:	e3530000 	cmp	r3, #0
3002befc:	0a000047 	beq	3002c020 <OpenSec+0x1f8>
        if (Disk->SecPerDisk > Index)
3002bf00:	e59d3010 	ldr	r3, [sp, #16]
3002bf04:	e5932008 	ldr	r2, [r3, #8]
3002bf08:	e59d3000 	ldr	r3, [sp]
3002bf0c:	e1520003 	cmp	r2, r3
3002bf10:	9a000042 	bls	3002c020 <OpenSec+0x1f8>
        {
            pcache = GetCache();                     /* ȡcache */
3002bf14:	ebffff39 	bl	3002bc00 <GetCache>
3002bf18:	e1a03000 	mov	r3, r0
3002bf1c:	e58d3008 	str	r3, [sp, #8]
            if (pcache != NULL)
3002bf20:	e59d3008 	ldr	r3, [sp, #8]
3002bf24:	e3530000 	cmp	r3, #0
3002bf28:	0a00003c 	beq	3002c020 <OpenSec+0x1f8>
            {
                /* ʼcache  */
                pcache->Drive = Drive;     
3002bf2c:	e59d3008 	ldr	r3, [sp, #8]
3002bf30:	e5dd2007 	ldrb	r2, [sp, #7]
3002bf34:	e5c32000 	strb	r2, [r3]
                pcache->Flag = 0;
3002bf38:	e59d3008 	ldr	r3, [sp, #8]
3002bf3c:	e3a02000 	mov	r2, #0
3002bf40:	e5c32001 	strb	r2, [r3, #1]
                pcache->SecIndex = Index;
3002bf44:	e59d3008 	ldr	r3, [sp, #8]
3002bf48:	e59d2000 	ldr	r2, [sp]
3002bf4c:	e5832004 	str	r2, [r3, #4]
                if(HashTable[hashindex] == NULL)
3002bf50:	e5dd2015 	ldrb	r2, [sp, #21]
3002bf54:	e59f30dc 	ldr	r3, [pc, #220]	; 3002c038 <OpenSec+0x210>
3002bf58:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3002bf5c:	e3530000 	cmp	r3, #0
3002bf60:	1a00000a 	bne	3002bf90 <OpenSec+0x168>
                {
                	pcache->FrontHash = NULL;
3002bf64:	e59d3008 	ldr	r3, [sp, #8]
3002bf68:	e3a02000 	mov	r2, #0
3002bf6c:	e583200c 	str	r2, [r3, #12]
                	pcache->NextHash = NULL;
3002bf70:	e59d3008 	ldr	r3, [sp, #8]
3002bf74:	e3a02000 	mov	r2, #0
3002bf78:	e5832008 	str	r2, [r3, #8]
                	HashTable[hashindex] = pcache;
3002bf7c:	e5dd2015 	ldrb	r2, [sp, #21]
3002bf80:	e59f30b0 	ldr	r3, [pc, #176]	; 3002c038 <OpenSec+0x210>
3002bf84:	e59d1008 	ldr	r1, [sp, #8]
3002bf88:	e7831102 	str	r1, [r3, r2, lsl #2]
3002bf8c:	ea000010 	b	3002bfd4 <OpenSec+0x1ac>
                }
                else
                {
                	pcache->FrontHash = NULL;
3002bf90:	e59d3008 	ldr	r3, [sp, #8]
3002bf94:	e3a02000 	mov	r2, #0
3002bf98:	e583200c 	str	r2, [r3, #12]
                	pcache->NextHash = HashTable[hashindex];
3002bf9c:	e5dd2015 	ldrb	r2, [sp, #21]
3002bfa0:	e59f3090 	ldr	r3, [pc, #144]	; 3002c038 <OpenSec+0x210>
3002bfa4:	e7932102 	ldr	r2, [r3, r2, lsl #2]
3002bfa8:	e59d3008 	ldr	r3, [sp, #8]
3002bfac:	e5832008 	str	r2, [r3, #8]
                	HashTable[hashindex]->FrontHash = pcache;
3002bfb0:	e5dd2015 	ldrb	r2, [sp, #21]
3002bfb4:	e59f307c 	ldr	r3, [pc, #124]	; 3002c038 <OpenSec+0x210>
3002bfb8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3002bfbc:	e59d2008 	ldr	r2, [sp, #8]
3002bfc0:	e583200c 	str	r2, [r3, #12]
                	HashTable[hashindex] = pcache;
3002bfc4:	e5dd2015 	ldrb	r2, [sp, #21]
3002bfc8:	e59f3068 	ldr	r3, [pc, #104]	; 3002c038 <OpenSec+0x210>
3002bfcc:	e59d1008 	ldr	r1, [sp, #8]
3002bfd0:	e7831102 	str	r1, [r3, r2, lsl #2]
                }
                Rt = pcache->buf;
3002bfd4:	e59d3008 	ldr	r3, [sp, #8]
3002bfd8:	e2833014 	add	r3, r3, #20
3002bfdc:	e58d300c 	str	r3, [sp, #12]
                for (i = 0; i < Disk->BytsPerSec; i++)
3002bfe0:	e3a03000 	mov	r3, #0
3002bfe4:	e1cd31b6 	strh	r3, [sp, #22]
3002bfe8:	ea000007 	b	3002c00c <OpenSec+0x1e4>
                {
                    Rt[i] = 0;
3002bfec:	e1dd21b6 	ldrh	r2, [sp, #22]
3002bff0:	e59d300c 	ldr	r3, [sp, #12]
3002bff4:	e0823003 	add	r3, r2, r3
3002bff8:	e3a02000 	mov	r2, #0
3002bffc:	e5c32000 	strb	r2, [r3]
                	pcache->NextHash = HashTable[hashindex];
                	HashTable[hashindex]->FrontHash = pcache;
                	HashTable[hashindex] = pcache;
                }
                Rt = pcache->buf;
                for (i = 0; i < Disk->BytsPerSec; i++)
3002c000:	e1dd31b6 	ldrh	r3, [sp, #22]
3002c004:	e2833001 	add	r3, r3, #1
3002c008:	e1cd31b6 	strh	r3, [sp, #22]
3002c00c:	e1dd21b6 	ldrh	r2, [sp, #22]
3002c010:	e59d3010 	ldr	r3, [sp, #16]
3002c014:	e593300c 	ldr	r3, [r3, #12]
3002c018:	e1520003 	cmp	r2, r3
3002c01c:	3afffff2 	bcc	3002bfec <OpenSec+0x1c4>
                    Rt[i] = 0;
                }
            }
        }
    }
    return Rt;
3002c020:	e59d300c 	ldr	r3, [sp, #12]
}
3002c024:	e1a00003 	mov	r0, r3
3002c028:	e28dd01c 	add	sp, sp, #28
3002c02c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002c030:	e12fff1e 	bx	lr
3002c034:	cccccccd 	.word	0xcccccccd
3002c038:	301f5910 	.word	0x301f5910

3002c03c <ReadSuperSec>:

acoral_u8 ReadSuperSec(acoral_u8 Drive,acoral_u8 *buf)
{
3002c03c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002c040:	e24dd024 	sub	sp, sp, #36	; 0x24
3002c044:	e1a03000 	mov	r3, r0
3002c048:	e58d1000 	str	r1, [sp]
3002c04c:	e5cd3007 	strb	r3, [sp, #7]
	Disk_RW_Parameter Pa;
	Disk_Info *Disk;
        Disk = GetDiskInfo(Drive);    
3002c050:	e5dd3007 	ldrb	r3, [sp, #7]
3002c054:	e1a00003 	mov	r0, r3
3002c058:	ebffe0f0 	bl	30024420 <GetDiskInfo>
3002c05c:	e1a03000 	mov	r3, r0
3002c060:	e58d301c 	str	r3, [sp, #28]
	Pa.Drive=Drive;
3002c064:	e5dd3007 	ldrb	r3, [sp, #7]
3002c068:	e5cd300c 	strb	r3, [sp, #12]
	Pa.Buf=buf;
3002c06c:	e59d3000 	ldr	r3, [sp]
3002c070:	e58d3018 	str	r3, [sp, #24]
        if(Disk->DiakCommand(DISK_READ_SUPER_SECTOR, &Pa) == DISK_READ_OK)
3002c074:	e59d301c 	ldr	r3, [sp, #28]
3002c078:	e5933030 	ldr	r3, [r3, #48]	; 0x30
3002c07c:	e28d200c 	add	r2, sp, #12
3002c080:	e3a00004 	mov	r0, #4
3002c084:	e1a01002 	mov	r1, r2
3002c088:	e1a0e00f 	mov	lr, pc
3002c08c:	e12fff13 	bx	r3
3002c090:	e1a03000 	mov	r3, r0
3002c094:	e3530001 	cmp	r3, #1
3002c098:	1a000001 	bne	3002c0a4 <ReadSuperSec+0x68>
        {
                return RETURN_OK;
3002c09c:	e3a03000 	mov	r3, #0
3002c0a0:	ea000000 	b	3002c0a8 <ReadSuperSec+0x6c>
	}
	return SECTOR_READ_ERR;
3002c0a4:	e3a03005 	mov	r3, #5
}
3002c0a8:	e1a00003 	mov	r0, r3
3002c0ac:	e28dd024 	add	sp, sp, #36	; 0x24
3002c0b0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002c0b4:	e12fff1e 	bx	lr

3002c0b8 <ReadSec>:
**         FALSE:ʧ
** ȫֱ: DiskCache
** ģ: GetDiskInfo
********************************************************************************************************/
        acoral_u8 ReadSec(acoral_u8 Drive, acoral_u32 Index)
{
3002c0b8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002c0bc:	e24dd02c 	sub	sp, sp, #44	; 0x2c
3002c0c0:	e1a03000 	mov	r3, r0
3002c0c4:	e58d1000 	str	r1, [sp]
3002c0c8:	e5cd3007 	strb	r3, [sp, #7]
    Disk_cache *pcache;
    Disk_RW_Parameter Pa;
    Disk_Info *Disk;
    acoral_u8 Rt;
    acoral_u8 hashindex = Index % CACHE_HASH_SIZE;
3002c0cc:	e59d1000 	ldr	r1, [sp]
3002c0d0:	e59f3164 	ldr	r3, [pc, #356]	; 3002c23c <ReadSec+0x184>
3002c0d4:	e0832391 	umull	r2, r3, r1, r3
3002c0d8:	e1a021a3 	lsr	r2, r3, #3
3002c0dc:	e1a03002 	mov	r3, r2
3002c0e0:	e1a03103 	lsl	r3, r3, #2
3002c0e4:	e0833002 	add	r3, r3, r2
3002c0e8:	e1a03083 	lsl	r3, r3, #1
3002c0ec:	e0632001 	rsb	r2, r3, r1
3002c0f0:	e1a03002 	mov	r3, r2
3002c0f4:	e5cd3027 	strb	r3, [sp, #39]	; 0x27
    
    for (pcache = HashTable[hashindex]; pcache != NULL; pcache = pcache->NextHash)
3002c0f8:	e5dd2027 	ldrb	r2, [sp, #39]	; 0x27
3002c0fc:	e59f313c 	ldr	r3, [pc, #316]	; 3002c240 <ReadSec+0x188>
3002c100:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3002c104:	e58d301c 	str	r3, [sp, #28]
3002c108:	ea000013 	b	3002c15c <ReadSec+0xa4>
    {
        if (pcache->Drive == Drive)
3002c10c:	e59d301c 	ldr	r3, [sp, #28]
3002c110:	e5d33000 	ldrb	r3, [r3]
3002c114:	e5dd2007 	ldrb	r2, [sp, #7]
3002c118:	e1520003 	cmp	r2, r3
3002c11c:	1a00000b 	bne	3002c150 <ReadSec+0x98>
        if (pcache->SecIndex == Index)
3002c120:	e59d301c 	ldr	r3, [sp, #28]
3002c124:	e5932004 	ldr	r2, [r3, #4]
3002c128:	e59d3000 	ldr	r3, [sp]
3002c12c:	e1520003 	cmp	r2, r3
3002c130:	1a000006 	bne	3002c150 <ReadSec+0x98>
        {
            if ((pcache->Flag & CACHE_READED) != 0)
3002c134:	e59d301c 	ldr	r3, [sp, #28]
3002c138:	e5d33001 	ldrb	r3, [r3, #1]
3002c13c:	e2033002 	and	r3, r3, #2
3002c140:	e3530000 	cmp	r3, #0
3002c144:	0a000008 	beq	3002c16c <ReadSec+0xb4>
            {
                return RETURN_OK;
3002c148:	e3a03000 	mov	r3, #0
3002c14c:	ea000036 	b	3002c22c <ReadSec+0x174>
    Disk_RW_Parameter Pa;
    Disk_Info *Disk;
    acoral_u8 Rt;
    acoral_u8 hashindex = Index % CACHE_HASH_SIZE;
    
    for (pcache = HashTable[hashindex]; pcache != NULL; pcache = pcache->NextHash)
3002c150:	e59d301c 	ldr	r3, [sp, #28]
3002c154:	e5933008 	ldr	r3, [r3, #8]
3002c158:	e58d301c 	str	r3, [sp, #28]
3002c15c:	e59d301c 	ldr	r3, [sp, #28]
3002c160:	e3530000 	cmp	r3, #0
3002c164:	1affffe8 	bne	3002c10c <ReadSec+0x54>
3002c168:	ea000000 	b	3002c170 <ReadSec+0xb8>
        {
            if ((pcache->Flag & CACHE_READED) != 0)
            {
                return RETURN_OK;
            }
            break;
3002c16c:	e1a00000 	nop			; (mov r0, r0)
        }
    }
    Rt = SECTOR_NOT_IN_CACHE;
3002c170:	e3a03003 	mov	r3, #3
3002c174:	e5cd3026 	strb	r3, [sp, #38]	; 0x26
    if (pcache != NULL)
3002c178:	e59d301c 	ldr	r3, [sp, #28]
3002c17c:	e3530000 	cmp	r3, #0
3002c180:	0a000028 	beq	3002c228 <ReadSec+0x170>
    {
        Disk = GetDiskInfo(Drive);    
3002c184:	e5dd3007 	ldrb	r3, [sp, #7]
3002c188:	e1a00003 	mov	r0, r3
3002c18c:	ebffe0a3 	bl	30024420 <GetDiskInfo>
3002c190:	e1a03000 	mov	r3, r0
3002c194:	e58d3020 	str	r3, [sp, #32]

        pcache->Flag |= CACHE_READED;
3002c198:	e59d301c 	ldr	r3, [sp, #28]
3002c19c:	e5d33001 	ldrb	r3, [r3, #1]
3002c1a0:	e3833002 	orr	r3, r3, #2
3002c1a4:	e20320ff 	and	r2, r3, #255	; 0xff
3002c1a8:	e59d301c 	ldr	r3, [sp, #28]
3002c1ac:	e5c32001 	strb	r2, [r3, #1]

        /* Ӵ̶ȡ */
        Pa.Drive = Drive;
3002c1b0:	e5dd3007 	ldrb	r3, [sp, #7]
3002c1b4:	e5cd300c 	strb	r3, [sp, #12]
        Pa.SectorIndex = Index;
3002c1b8:	e59d3000 	ldr	r3, [sp]
3002c1bc:	e58d3010 	str	r3, [sp, #16]
        Pa.RsvdForLow = Disk->RsvdForLow;
3002c1c0:	e59d3020 	ldr	r3, [sp, #32]
3002c1c4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
3002c1c8:	e58d3014 	str	r3, [sp, #20]
        Pa.Buf = pcache->buf;
3002c1cc:	e59d301c 	ldr	r3, [sp, #28]
3002c1d0:	e2833014 	add	r3, r3, #20
3002c1d4:	e58d3018 	str	r3, [sp, #24]
        Rt = NOT_FIND_DISK;
3002c1d8:	e3a03001 	mov	r3, #1
3002c1dc:	e5cd3026 	strb	r3, [sp, #38]	; 0x26
        if (Disk->DiakCommand != NULL)
3002c1e0:	e59d3020 	ldr	r3, [sp, #32]
3002c1e4:	e5933030 	ldr	r3, [r3, #48]	; 0x30
3002c1e8:	e3530000 	cmp	r3, #0
3002c1ec:	0a00000d 	beq	3002c228 <ReadSec+0x170>
        {

            Rt = SECTOR_READ_ERR;
3002c1f0:	e3a03005 	mov	r3, #5
3002c1f4:	e5cd3026 	strb	r3, [sp, #38]	; 0x26
            if (Disk->DiakCommand(DISK_READ_SECTOR, &Pa) == DISK_READ_OK)
3002c1f8:	e59d3020 	ldr	r3, [sp, #32]
3002c1fc:	e5933030 	ldr	r3, [r3, #48]	; 0x30
3002c200:	e28d200c 	add	r2, sp, #12
3002c204:	e3a00002 	mov	r0, #2
3002c208:	e1a01002 	mov	r1, r2
3002c20c:	e1a0e00f 	mov	lr, pc
3002c210:	e12fff13 	bx	r3
3002c214:	e1a03000 	mov	r3, r0
3002c218:	e3530001 	cmp	r3, #1
3002c21c:	1a000001 	bne	3002c228 <ReadSec+0x170>
            {
                return RETURN_OK;
3002c220:	e3a03000 	mov	r3, #0
3002c224:	ea000000 	b	3002c22c <ReadSec+0x174>
            }
        }
    }
    return Rt;
3002c228:	e5dd3026 	ldrb	r3, [sp, #38]	; 0x26
}
3002c22c:	e1a00003 	mov	r0, r3
3002c230:	e28dd02c 	add	sp, sp, #44	; 0x2c
3002c234:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002c238:	e12fff1e 	bx	lr
3002c23c:	cccccccd 	.word	0xcccccccd
3002c240:	301f5910 	.word	0x301f5910

3002c244 <WriteSec>:
**         
** ȫֱ: DiskCache
** ģ: 
********************************************************************************************************/
        void WriteSec(acoral_u8 Drive, acoral_u32 Index)
{
3002c244:	e24dd010 	sub	sp, sp, #16
3002c248:	e1a03000 	mov	r3, r0
3002c24c:	e58d1000 	str	r1, [sp]
3002c250:	e5cd3007 	strb	r3, [sp, #7]
    Disk_cache *pcache;
    acoral_u8 hashindex = Index % CACHE_HASH_SIZE;
3002c254:	e59d1000 	ldr	r1, [sp]
3002c258:	e59f3098 	ldr	r3, [pc, #152]	; 3002c2f8 <WriteSec+0xb4>
3002c25c:	e0832391 	umull	r2, r3, r1, r3
3002c260:	e1a021a3 	lsr	r2, r3, #3
3002c264:	e1a03002 	mov	r3, r2
3002c268:	e1a03103 	lsl	r3, r3, #2
3002c26c:	e0833002 	add	r3, r3, r2
3002c270:	e1a03083 	lsl	r3, r3, #1
3002c274:	e0632001 	rsb	r2, r3, r1
3002c278:	e1a03002 	mov	r3, r2
3002c27c:	e5cd300f 	strb	r3, [sp, #15]
    
    for (pcache = HashTable[hashindex]; pcache != NULL; pcache = pcache->NextHash)
3002c280:	e5dd200f 	ldrb	r2, [sp, #15]
3002c284:	e59f3070 	ldr	r3, [pc, #112]	; 3002c2fc <WriteSec+0xb8>
3002c288:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3002c28c:	e58d3008 	str	r3, [sp, #8]
3002c290:	ea000013 	b	3002c2e4 <WriteSec+0xa0>
    {
        if (pcache->Drive == Drive)
3002c294:	e59d3008 	ldr	r3, [sp, #8]
3002c298:	e5d33000 	ldrb	r3, [r3]
3002c29c:	e5dd2007 	ldrb	r2, [sp, #7]
3002c2a0:	e1520003 	cmp	r2, r3
3002c2a4:	1a00000b 	bne	3002c2d8 <WriteSec+0x94>
        if (pcache->SecIndex == Index)
3002c2a8:	e59d3008 	ldr	r3, [sp, #8]
3002c2ac:	e5932004 	ldr	r2, [r3, #4]
3002c2b0:	e59d3000 	ldr	r3, [sp]
3002c2b4:	e1520003 	cmp	r2, r3
3002c2b8:	1a000006 	bne	3002c2d8 <WriteSec+0x94>
        {
            pcache->Flag |= (CACHE_WRITED | CACHE_READED);
3002c2bc:	e59d3008 	ldr	r3, [sp, #8]
3002c2c0:	e5d33001 	ldrb	r3, [r3, #1]
3002c2c4:	e3833003 	orr	r3, r3, #3
3002c2c8:	e20320ff 	and	r2, r3, #255	; 0xff
3002c2cc:	e59d3008 	ldr	r3, [sp, #8]
3002c2d0:	e5c32001 	strb	r2, [r3, #1]
            break;
3002c2d4:	ea000005 	b	3002c2f0 <WriteSec+0xac>
        void WriteSec(acoral_u8 Drive, acoral_u32 Index)
{
    Disk_cache *pcache;
    acoral_u8 hashindex = Index % CACHE_HASH_SIZE;
    
    for (pcache = HashTable[hashindex]; pcache != NULL; pcache = pcache->NextHash)
3002c2d8:	e59d3008 	ldr	r3, [sp, #8]
3002c2dc:	e5933008 	ldr	r3, [r3, #8]
3002c2e0:	e58d3008 	str	r3, [sp, #8]
3002c2e4:	e59d3008 	ldr	r3, [sp, #8]
3002c2e8:	e3530000 	cmp	r3, #0
3002c2ec:	1affffe8 	bne	3002c294 <WriteSec+0x50>
        {
            pcache->Flag |= (CACHE_WRITED | CACHE_READED);
            break;
        }
    }
}
3002c2f0:	e28dd010 	add	sp, sp, #16
3002c2f4:	e12fff1e 	bx	lr
3002c2f8:	cccccccd 	.word	0xcccccccd
3002c2fc:	301f5910 	.word	0x301f5910

3002c300 <aocal_net_mp3>:





void aocal_net_mp3() {
3002c300:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002c304:	e24dd00c 	sub	sp, sp, #12

	acoral_create_thread(my_main_start,8192,NULL,"acoral_net_mp3",20,0);
3002c308:	e59f302c 	ldr	r3, [pc, #44]	; 3002c33c <aocal_net_mp3+0x3c>
3002c30c:	e3a02014 	mov	r2, #20
3002c310:	e58d2000 	str	r2, [sp]
3002c314:	e3a02000 	mov	r2, #0
3002c318:	e58d2004 	str	r2, [sp, #4]
3002c31c:	e1a00003 	mov	r0, r3
3002c320:	e3a01a02 	mov	r1, #8192	; 0x2000
3002c324:	e3a02000 	mov	r2, #0
3002c328:	e59f3010 	ldr	r3, [pc, #16]	; 3002c340 <aocal_net_mp3+0x40>
3002c32c:	ebff5b1c 	bl	30002fa4 <create_comm_thread>
}
3002c330:	e28dd00c 	add	sp, sp, #12
3002c334:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002c338:	e12fff1e 	bx	lr
3002c33c:	30030338 	.word	0x30030338
3002c340:	300459c0 	.word	0x300459c0

3002c344 <user_main>:

void user_main()
{
3002c344:	e92d4008 	push	{r3, lr}
#ifdef CFG_TELNET_SHELL
	user_telnetd();
3002c348:	eb0002f4 	bl	3002cf20 <user_telnetd>
#endif
#ifdef CFG_WEB_SERVER
	user_httpd();   //1  没有把函数所在的c文件生成.o目标文件
3002c34c:	eb0005d5 	bl	3002daa8 <user_httpd>
					//2  在函数所在的c文件中定义了，但是没有在与之相关联的.h文件中声明
#endif
//	acoral_create_thread(dummy,256,NULL,NULL,20,0);
	aocal_net_mp3();
3002c350:	ebffffea 	bl	3002c300 <aocal_net_mp3>
}
3002c354:	e8bd4008 	pop	{r3, lr}
3002c358:	e12fff1e 	bx	lr

3002c35c <parse_args>:
	PS_STRING,
	PS_ESCAPE
};

void parse_args(acoral_char *argstr, acoral_32 *argc_p, acoral_char **argv, acoral_char** resid,enum parse_state *stacked)
{
3002c35c:	e24dd018 	sub	sp, sp, #24
3002c360:	e58d000c 	str	r0, [sp, #12]
3002c364:	e58d1008 	str	r1, [sp, #8]
3002c368:	e58d2004 	str	r2, [sp, #4]
3002c36c:	e58d3000 	str	r3, [sp]
	acoral_32 argc = 0;
3002c370:	e3a03000 	mov	r3, #0
3002c374:	e58d3010 	str	r3, [sp, #16]
	acoral_char c;
	enum parse_state newState;
	enum parse_state stacked_state=*stacked;
3002c378:	e59d3018 	ldr	r3, [sp, #24]
3002c37c:	e5d33000 	ldrb	r3, [r3]
3002c380:	e5cd3016 	strb	r3, [sp, #22]
	enum parse_state lastState = PS_WHITESPACE;
3002c384:	e3a03000 	mov	r3, #0
3002c388:	e5cd3017 	strb	r3, [sp, #23]

	while ((c = *argstr) != 0&&argc<MAX_ARGS_NUM) {
3002c38c:	ea000059 	b	3002c4f8 <parse_args+0x19c>

		if (c == ';' && lastState != PS_STRING && lastState != PS_ESCAPE)
3002c390:	e5dd3014 	ldrb	r3, [sp, #20]
3002c394:	e353003b 	cmp	r3, #59	; 0x3b
3002c398:	1a000005 	bne	3002c3b4 <parse_args+0x58>
3002c39c:	e5dd3017 	ldrb	r3, [sp, #23]
3002c3a0:	e3530002 	cmp	r3, #2
3002c3a4:	0a000002 	beq	3002c3b4 <parse_args+0x58>
3002c3a8:	e5dd3017 	ldrb	r3, [sp, #23]
3002c3ac:	e3530003 	cmp	r3, #3
3002c3b0:	1a00005a 	bne	3002c520 <parse_args+0x1c4>
			break;

		if (lastState == PS_ESCAPE) {
3002c3b4:	e5dd3017 	ldrb	r3, [sp, #23]
3002c3b8:	e3530003 	cmp	r3, #3
3002c3bc:	1a000002 	bne	3002c3cc <parse_args+0x70>
			newState = stacked_state;
3002c3c0:	e5dd3016 	ldrb	r3, [sp, #22]
3002c3c4:	e5cd3015 	strb	r3, [sp, #21]
3002c3c8:	ea000045 	b	3002c4e4 <parse_args+0x188>
		} else if (lastState == PS_STRING) {
3002c3cc:	e5dd3017 	ldrb	r3, [sp, #23]
3002c3d0:	e3530002 	cmp	r3, #2
3002c3d4:	1a00000b 	bne	3002c408 <parse_args+0xac>
			if (c == '"') {
3002c3d8:	e5dd3014 	ldrb	r3, [sp, #20]
3002c3dc:	e3530022 	cmp	r3, #34	; 0x22
3002c3e0:	1a000005 	bne	3002c3fc <parse_args+0xa0>
				newState = PS_WHITESPACE;
3002c3e4:	e3a03000 	mov	r3, #0
3002c3e8:	e5cd3015 	strb	r3, [sp, #21]
				*argstr = 0;
3002c3ec:	e59d300c 	ldr	r3, [sp, #12]
3002c3f0:	e3a02000 	mov	r2, #0
3002c3f4:	e5c32000 	strb	r2, [r3]
			} else {
				newState = PS_STRING;
3002c3f8:	ea000039 	b	3002c4e4 <parse_args+0x188>
3002c3fc:	e3a03002 	mov	r3, #2
3002c400:	e5cd3015 	strb	r3, [sp, #21]
3002c404:	ea000036 	b	3002c4e4 <parse_args+0x188>
			}
		} else if ((c == ' ') || (c == '\t')) {
3002c408:	e5dd3014 	ldrb	r3, [sp, #20]
3002c40c:	e3530020 	cmp	r3, #32
3002c410:	0a000002 	beq	3002c420 <parse_args+0xc4>
3002c414:	e5dd3014 	ldrb	r3, [sp, #20]
3002c418:	e3530009 	cmp	r3, #9
3002c41c:	1a000005 	bne	3002c438 <parse_args+0xdc>
			*argstr = 0;
3002c420:	e59d300c 	ldr	r3, [sp, #12]
3002c424:	e3a02000 	mov	r2, #0
3002c428:	e5c32000 	strb	r2, [r3]
			newState = PS_WHITESPACE;
3002c42c:	e3a03000 	mov	r3, #0
3002c430:	e5cd3015 	strb	r3, [sp, #21]
				newState = PS_WHITESPACE;
				*argstr = 0;
			} else {
				newState = PS_STRING;
			}
		} else if ((c == ' ') || (c == '\t')) {
3002c434:	ea00002a 	b	3002c4e4 <parse_args+0x188>
			*argstr = 0;
			newState = PS_WHITESPACE;
		} else if (c == '"') {
3002c438:	e5dd3014 	ldrb	r3, [sp, #20]
3002c43c:	e3530022 	cmp	r3, #34	; 0x22
3002c440:	1a000011 	bne	3002c48c <parse_args+0x130>
			newState = PS_STRING;
3002c444:	e3a03002 	mov	r3, #2
3002c448:	e5cd3015 	strb	r3, [sp, #21]
			*argstr++ = 0;
3002c44c:	e59d300c 	ldr	r3, [sp, #12]
3002c450:	e3a02000 	mov	r2, #0
3002c454:	e5c32000 	strb	r2, [r3]
3002c458:	e59d300c 	ldr	r3, [sp, #12]
3002c45c:	e2833001 	add	r3, r3, #1
3002c460:	e58d300c 	str	r3, [sp, #12]
			argv[argc++] = argstr;
3002c464:	e59d3010 	ldr	r3, [sp, #16]
3002c468:	e1a02103 	lsl	r2, r3, #2
3002c46c:	e59d3004 	ldr	r3, [sp, #4]
3002c470:	e0823003 	add	r3, r2, r3
3002c474:	e59d200c 	ldr	r2, [sp, #12]
3002c478:	e5832000 	str	r2, [r3]
3002c47c:	e59d3010 	ldr	r3, [sp, #16]
3002c480:	e2833001 	add	r3, r3, #1
3002c484:	e58d3010 	str	r3, [sp, #16]
3002c488:	ea000015 	b	3002c4e4 <parse_args+0x188>
		} else if (c == '\\') {
3002c48c:	e5dd3014 	ldrb	r3, [sp, #20]
3002c490:	e353005c 	cmp	r3, #92	; 0x5c
3002c494:	1a000004 	bne	3002c4ac <parse_args+0x150>
			stacked_state = lastState;
3002c498:	e5dd3017 	ldrb	r3, [sp, #23]
3002c49c:	e5cd3016 	strb	r3, [sp, #22]
			newState = PS_ESCAPE;
3002c4a0:	e3a03003 	mov	r3, #3
3002c4a4:	e5cd3015 	strb	r3, [sp, #21]
3002c4a8:	ea00000d 	b	3002c4e4 <parse_args+0x188>
		} else {
			if (lastState == PS_WHITESPACE) {
3002c4ac:	e5dd3017 	ldrb	r3, [sp, #23]
3002c4b0:	e3530000 	cmp	r3, #0
3002c4b4:	1a000008 	bne	3002c4dc <parse_args+0x180>
				argv[argc++] = argstr;
3002c4b8:	e59d3010 	ldr	r3, [sp, #16]
3002c4bc:	e1a02103 	lsl	r2, r3, #2
3002c4c0:	e59d3004 	ldr	r3, [sp, #4]
3002c4c4:	e0823003 	add	r3, r2, r3
3002c4c8:	e59d200c 	ldr	r2, [sp, #12]
3002c4cc:	e5832000 	str	r2, [r3]
3002c4d0:	e59d3010 	ldr	r3, [sp, #16]
3002c4d4:	e2833001 	add	r3, r3, #1
3002c4d8:	e58d3010 	str	r3, [sp, #16]
			}
			newState = PS_TOKEN;
3002c4dc:	e3a03001 	mov	r3, #1
3002c4e0:	e5cd3015 	strb	r3, [sp, #21]
		}

		lastState = newState;
3002c4e4:	e5dd3015 	ldrb	r3, [sp, #21]
3002c4e8:	e5cd3017 	strb	r3, [sp, #23]
		argstr++;
3002c4ec:	e59d300c 	ldr	r3, [sp, #12]
3002c4f0:	e2833001 	add	r3, r3, #1
3002c4f4:	e58d300c 	str	r3, [sp, #12]
	acoral_char c;
	enum parse_state newState;
	enum parse_state stacked_state=*stacked;
	enum parse_state lastState = PS_WHITESPACE;

	while ((c = *argstr) != 0&&argc<MAX_ARGS_NUM) {
3002c4f8:	e59d300c 	ldr	r3, [sp, #12]
3002c4fc:	e5d33000 	ldrb	r3, [r3]
3002c500:	e5cd3014 	strb	r3, [sp, #20]
3002c504:	e5dd3014 	ldrb	r3, [sp, #20]
3002c508:	e3530000 	cmp	r3, #0
3002c50c:	0a000004 	beq	3002c524 <parse_args+0x1c8>
3002c510:	e59d3010 	ldr	r3, [sp, #16]
3002c514:	e3530007 	cmp	r3, #7
3002c518:	daffff9c 	ble	3002c390 <parse_args+0x34>
3002c51c:	ea000000 	b	3002c524 <parse_args+0x1c8>

		if (c == ';' && lastState != PS_STRING && lastState != PS_ESCAPE)
			break;
3002c520:	e1a00000 	nop			; (mov r0, r0)

		lastState = newState;
		argstr++;
	}

	argv[argc] = NULL;
3002c524:	e59d3010 	ldr	r3, [sp, #16]
3002c528:	e1a02103 	lsl	r2, r3, #2
3002c52c:	e59d3004 	ldr	r3, [sp, #4]
3002c530:	e0823003 	add	r3, r2, r3
3002c534:	e3a02000 	mov	r2, #0
3002c538:	e5832000 	str	r2, [r3]
	if (argc_p != NULL)
3002c53c:	e59d3008 	ldr	r3, [sp, #8]
3002c540:	e3530000 	cmp	r3, #0
3002c544:	0a000002 	beq	3002c554 <parse_args+0x1f8>
		*argc_p = argc;
3002c548:	e59d3008 	ldr	r3, [sp, #8]
3002c54c:	e59d2010 	ldr	r2, [sp, #16]
3002c550:	e5832000 	str	r2, [r3]

	if (*argstr == ';') {
3002c554:	e59d300c 	ldr	r3, [sp, #12]
3002c558:	e5d33000 	ldrb	r3, [r3]
3002c55c:	e353003b 	cmp	r3, #59	; 0x3b
3002c560:	1a000005 	bne	3002c57c <parse_args+0x220>
		*argstr++ = '\0';
3002c564:	e59d300c 	ldr	r3, [sp, #12]
3002c568:	e3a02000 	mov	r2, #0
3002c56c:	e5c32000 	strb	r2, [r3]
3002c570:	e59d300c 	ldr	r3, [sp, #12]
3002c574:	e2833001 	add	r3, r3, #1
3002c578:	e58d300c 	str	r3, [sp, #12]
	}
	*resid = argstr;
3002c57c:	e59d3000 	ldr	r3, [sp]
3002c580:	e59d200c 	ldr	r2, [sp, #12]
3002c584:	e5832000 	str	r2, [r3]
	*stacked=stacked_state;
3002c588:	e59d3018 	ldr	r3, [sp, #24]
3002c58c:	e5dd2016 	ldrb	r2, [sp, #22]
3002c590:	e5c32000 	strb	r2, [r3]
}
3002c594:	e28dd018 	add	sp, sp, #24
3002c598:	e12fff1e 	bx	lr

3002c59c <add_command>:

void add_command(acoral_shell_cmd_t *cmd)
{
3002c59c:	e24dd008 	sub	sp, sp, #8
3002c5a0:	e58d0004 	str	r0, [sp, #4]
	if (head_cmd == NULL) {
3002c5a4:	e59f304c 	ldr	r3, [pc, #76]	; 3002c5f8 <add_command+0x5c>
3002c5a8:	e5933000 	ldr	r3, [r3]
3002c5ac:	e3530000 	cmp	r3, #0
3002c5b0:	1a000007 	bne	3002c5d4 <add_command+0x38>
		head_cmd = tail_cmd = cmd;
3002c5b4:	e59f3040 	ldr	r3, [pc, #64]	; 3002c5fc <add_command+0x60>
3002c5b8:	e59d2004 	ldr	r2, [sp, #4]
3002c5bc:	e5832000 	str	r2, [r3]
3002c5c0:	e59f3034 	ldr	r3, [pc, #52]	; 3002c5fc <add_command+0x60>
3002c5c4:	e5932000 	ldr	r2, [r3]
3002c5c8:	e59f3028 	ldr	r3, [pc, #40]	; 3002c5f8 <add_command+0x5c>
3002c5cc:	e5832000 	str	r2, [r3]
3002c5d0:	ea000006 	b	3002c5f0 <add_command+0x54>
	} else {
		tail_cmd->next = cmd;
3002c5d4:	e59f3020 	ldr	r3, [pc, #32]	; 3002c5fc <add_command+0x60>
3002c5d8:	e5933000 	ldr	r3, [r3]
3002c5dc:	e59d2004 	ldr	r2, [sp, #4]
3002c5e0:	e583200c 	str	r2, [r3, #12]
		tail_cmd = cmd;
3002c5e4:	e59f3010 	ldr	r3, [pc, #16]	; 3002c5fc <add_command+0x60>
3002c5e8:	e59d2004 	ldr	r2, [sp, #4]
3002c5ec:	e5832000 	str	r2, [r3]
	}
}
3002c5f0:	e28dd008 	add	sp, sp, #8
3002c5f4:	e12fff1e 	bx	lr
3002c5f8:	3012ac9c 	.word	0x3012ac9c
3002c5fc:	302f7e44 	.word	0x302f7e44

3002c600 <find_cmd>:

acoral_shell_cmd_t *find_cmd(acoral_char *cmdname)
{
3002c600:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002c604:	e24dd014 	sub	sp, sp, #20
3002c608:	e58d0004 	str	r0, [sp, #4]
	acoral_shell_cmd_t *curr;
	curr =head_cmd;
3002c60c:	e59f305c 	ldr	r3, [pc, #92]	; 3002c670 <find_cmd+0x70>
3002c610:	e5933000 	ldr	r3, [r3]
3002c614:	e58d300c 	str	r3, [sp, #12]
	while(curr != NULL) {
3002c618:	ea00000c 	b	3002c650 <find_cmd+0x50>
		if (acoral_str_cmp(curr->name, cmdname) == 0)
3002c61c:	e59d300c 	ldr	r3, [sp, #12]
3002c620:	e5933000 	ldr	r3, [r3]
3002c624:	e1a00003 	mov	r0, r3
3002c628:	e59d1004 	ldr	r1, [sp, #4]
3002c62c:	ebff7c75 	bl	3000b808 <acoral_str_cmp>
3002c630:	e1a03000 	mov	r3, r0
3002c634:	e3530000 	cmp	r3, #0
3002c638:	1a000001 	bne	3002c644 <find_cmd+0x44>
			return curr;
3002c63c:	e59d300c 	ldr	r3, [sp, #12]
3002c640:	ea000006 	b	3002c660 <find_cmd+0x60>
		curr = curr->next;
3002c644:	e59d300c 	ldr	r3, [sp, #12]
3002c648:	e593300c 	ldr	r3, [r3, #12]
3002c64c:	e58d300c 	str	r3, [sp, #12]

acoral_shell_cmd_t *find_cmd(acoral_char *cmdname)
{
	acoral_shell_cmd_t *curr;
	curr =head_cmd;
	while(curr != NULL) {
3002c650:	e59d300c 	ldr	r3, [sp, #12]
3002c654:	e3530000 	cmp	r3, #0
3002c658:	1affffef 	bne	3002c61c <find_cmd+0x1c>
		if (acoral_str_cmp(curr->name, cmdname) == 0)
			return curr;
		curr = curr->next;
	}
	return NULL;
3002c65c:	e3a03000 	mov	r3, #0
}
3002c660:	e1a00003 	mov	r0, r3
3002c664:	e28dd014 	add	sp, sp, #20
3002c668:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002c66c:	e12fff1e 	bx	lr
3002c670:	3012ac9c 	.word	0x3012ac9c

3002c674 <execmd>:

void execmd(acoral_32 argc,acoral_char **argv)
{
3002c674:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002c678:	e24dd014 	sub	sp, sp, #20
3002c67c:	e58d0004 	str	r0, [sp, #4]
3002c680:	e58d1000 	str	r1, [sp]
	acoral_shell_cmd_t *cmd = find_cmd(argv[0]);
3002c684:	e59d3000 	ldr	r3, [sp]
3002c688:	e5933000 	ldr	r3, [r3]
3002c68c:	e1a00003 	mov	r0, r3
3002c690:	ebffffda 	bl	3002c600 <find_cmd>
3002c694:	e1a03000 	mov	r3, r0
3002c698:	e58d300c 	str	r3, [sp, #12]
	if (cmd == NULL) {
3002c69c:	e59d300c 	ldr	r3, [sp, #12]
3002c6a0:	e3530000 	cmp	r3, #0
3002c6a4:	1a000007 	bne	3002c6c8 <execmd+0x54>
		acoral_print("Could not found '%s' command\r\n", argv[0]);
3002c6a8:	e59d3000 	ldr	r3, [sp]
3002c6ac:	e5933000 	ldr	r3, [r3]
3002c6b0:	e59f0034 	ldr	r0, [pc, #52]	; 3002c6ec <execmd+0x78>
3002c6b4:	e1a01003 	mov	r1, r3
3002c6b8:	ebff7ae0 	bl	3000b240 <acoral_print>
		acoral_print("you can type 'help'\r\n"); 
3002c6bc:	e59f002c 	ldr	r0, [pc, #44]	; 3002c6f0 <execmd+0x7c>
3002c6c0:	ebff7ade 	bl	3000b240 <acoral_print>
		return;
3002c6c4:	ea000005 	b	3002c6e0 <execmd+0x6c>
	}
	cmd->exe(argc, argv);
3002c6c8:	e59d300c 	ldr	r3, [sp, #12]
3002c6cc:	e5933004 	ldr	r3, [r3, #4]
3002c6d0:	e59d0004 	ldr	r0, [sp, #4]
3002c6d4:	e59d1000 	ldr	r1, [sp]
3002c6d8:	e1a0e00f 	mov	lr, pc
3002c6dc:	e12fff13 	bx	r3
}
3002c6e0:	e28dd014 	add	sp, sp, #20
3002c6e4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002c6e8:	e12fff1e 	bx	lr
3002c6ec:	300459d0 	.word	0x300459d0
3002c6f0:	300459f0 	.word	0x300459f0

3002c6f4 <cmd_exe>:


void cmd_exe(acoral_char *buf){
3002c6f4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002c6f8:	e24dd044 	sub	sp, sp, #68	; 0x44
3002c6fc:	e58d000c 	str	r0, [sp, #12]
	acoral_32 argc;
	acoral_char *argv[MAX_ARGS_NUM];
	acoral_char *resid;
	enum parse_state stacked_state;
	while (*buf) {
3002c700:	ea000015 	b	3002c75c <cmd_exe+0x68>
		acoral_memset(argv, 0, sizeof(argv));
3002c704:	e28d301c 	add	r3, sp, #28
3002c708:	e1a00003 	mov	r0, r3
3002c70c:	e3a01000 	mov	r1, #0
3002c710:	e3a02020 	mov	r2, #32
3002c714:	ebff7ed4 	bl	3000c26c <acoral_memset>
		parse_args(buf, &argc, argv, &resid,&stacked_state);
3002c718:	e28d103c 	add	r1, sp, #60	; 0x3c
3002c71c:	e28d201c 	add	r2, sp, #28
3002c720:	e28d3018 	add	r3, sp, #24
3002c724:	e28d0017 	add	r0, sp, #23
3002c728:	e58d0000 	str	r0, [sp]
3002c72c:	e59d000c 	ldr	r0, [sp, #12]
3002c730:	ebffff09 	bl	3002c35c <parse_args>
		if (argc > 0)
3002c734:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3002c738:	e3530000 	cmp	r3, #0
3002c73c:	da000004 	ble	3002c754 <cmd_exe+0x60>
			execmd(argc, (const acoral_char **)argv);
3002c740:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3002c744:	e28d301c 	add	r3, sp, #28
3002c748:	e1a00002 	mov	r0, r2
3002c74c:	e1a01003 	mov	r1, r3
3002c750:	ebffffc7 	bl	3002c674 <execmd>
		buf = resid;
3002c754:	e59d3018 	ldr	r3, [sp, #24]
3002c758:	e58d300c 	str	r3, [sp, #12]
void cmd_exe(acoral_char *buf){
	acoral_32 argc;
	acoral_char *argv[MAX_ARGS_NUM];
	acoral_char *resid;
	enum parse_state stacked_state;
	while (*buf) {
3002c75c:	e59d300c 	ldr	r3, [sp, #12]
3002c760:	e5d33000 	ldrb	r3, [r3]
3002c764:	e3530000 	cmp	r3, #0
3002c768:	1affffe5 	bne	3002c704 <cmd_exe+0x10>
		parse_args(buf, &argc, argv, &resid,&stacked_state);
		if (argc > 0)
			execmd(argc, (const acoral_char **)argv);
		buf = resid;
	}	
}
3002c76c:	e28dd044 	add	sp, sp, #68	; 0x44
3002c770:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002c774:	e12fff1e 	bx	lr

3002c778 <echo>:

void echo(acoral_char c){
3002c778:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002c77c:	e24dd00c 	sub	sp, sp, #12
3002c780:	e1a03000 	mov	r3, r0
3002c784:	e5cd3007 	strb	r3, [sp, #7]
	acoral_putchar(c);
3002c788:	e5dd3007 	ldrb	r3, [sp, #7]
3002c78c:	e1a00003 	mov	r0, r3
3002c790:	ebff7af8 	bl	3000b378 <acoral_putchar>
}
3002c794:	e28dd00c 	add	sp, sp, #12
3002c798:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002c79c:	e12fff1e 	bx	lr

3002c7a0 <get_cmd>:

void get_cmd(acoral_char *cmd_buf){
3002c7a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002c7a4:	e24dd024 	sub	sp, sp, #36	; 0x24
3002c7a8:	e58d000c 	str	r0, [sp, #12]
	acoral_u32 cur_pos;
	acoral_char c;
	acoral_u8 IsEcho=0;
3002c7ac:	e3a03000 	mov	r3, #0
3002c7b0:	e5cd3016 	strb	r3, [sp, #22]
	acoral_id console_id;
	console_id=acoral_cur_thread->console_id;
3002c7b4:	e59f31a8 	ldr	r3, [pc, #424]	; 3002c964 <get_cmd+0x1c4>
3002c7b8:	e5933000 	ldr	r3, [r3]
3002c7bc:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
3002c7c0:	e58d301c 	str	r3, [sp, #28]
	acoral_dev_config(console_id,CONSOLE_ECHO,&IsEcho,0);
3002c7c4:	e28d3016 	add	r3, sp, #22
3002c7c8:	e59d001c 	ldr	r0, [sp, #28]
3002c7cc:	e3a01001 	mov	r1, #1
3002c7d0:	e1a02003 	mov	r2, r3
3002c7d4:	e3a03000 	mov	r3, #0
3002c7d8:	eb004ff2 	bl	300407a8 <acoral_dev_config>
	cur_pos=0;
3002c7dc:	e3a03000 	mov	r3, #0
3002c7e0:	e58d3018 	str	r3, [sp, #24]
3002c7e4:	ea000000 	b	3002c7ec <get_cmd+0x4c>
						echo(c);
					cur_pos++;
				}
				break;
		}
	}
3002c7e8:	e1a00000 	nop			; (mov r0, r0)
	acoral_id console_id;
	console_id=acoral_cur_thread->console_id;
	acoral_dev_config(console_id,CONSOLE_ECHO,&IsEcho,0);
	cur_pos=0;
	while(1){
		while(acoral_dev_read(console_id,&c,1,0,0)<1);
3002c7ec:	e28d3017 	add	r3, sp, #23
3002c7f0:	e3a02000 	mov	r2, #0
3002c7f4:	e58d2000 	str	r2, [sp]
3002c7f8:	e59d001c 	ldr	r0, [sp, #28]
3002c7fc:	e1a01003 	mov	r1, r3
3002c800:	e3a02001 	mov	r2, #1
3002c804:	e3a03000 	mov	r3, #0
3002c808:	eb004fc0 	bl	30040710 <acoral_dev_read>
3002c80c:	e1a03000 	mov	r3, r0
3002c810:	e3530000 	cmp	r3, #0
3002c814:	dafffff4 	ble	3002c7ec <get_cmd+0x4c>
		switch (c) {
3002c818:	e5dd3017 	ldrb	r3, [sp, #23]
3002c81c:	e353000a 	cmp	r3, #10
3002c820:	0a000028 	beq	3002c8c8 <get_cmd+0x128>
3002c824:	e353000a 	cmp	r3, #10
3002c828:	ca000007 	bgt	3002c84c <get_cmd+0xac>
3002c82c:	e3530000 	cmp	r3, #0
3002c830:	0a000024 	beq	3002c8c8 <get_cmd+0x128>
3002c834:	e3530000 	cmp	r3, #0
3002c838:	ba000036 	blt	3002c918 <get_cmd+0x178>
3002c83c:	e2433006 	sub	r3, r3, #6
3002c840:	e3530002 	cmp	r3, #2
3002c844:	8a000033 	bhi	3002c918 <get_cmd+0x178>
3002c848:	ea000009 	b	3002c874 <get_cmd+0xd4>
3002c84c:	e3530018 	cmp	r3, #24
3002c850:	0a00002d 	beq	3002c90c <get_cmd+0x16c>
3002c854:	e3530018 	cmp	r3, #24
3002c858:	ca000002 	bgt	3002c868 <get_cmd+0xc8>
3002c85c:	e353000d 	cmp	r3, #13
3002c860:	0a000018 	beq	3002c8c8 <get_cmd+0x128>
3002c864:	ea00002b 	b	3002c918 <get_cmd+0x178>
3002c868:	e243307e 	sub	r3, r3, #126	; 0x7e
3002c86c:	e3530001 	cmp	r3, #1
3002c870:	8a000028 	bhi	3002c918 <get_cmd+0x178>
			case 0x08:
			case 0x06:
			case 0x07:
			case 0x7E:
			case 0x7F:
				if (cur_pos) {
3002c874:	e59d3018 	ldr	r3, [sp, #24]
3002c878:	e3530000 	cmp	r3, #0
3002c87c:	0a00000b 	beq	3002c8b0 <get_cmd+0x110>
					cur_pos--;
3002c880:	e59d3018 	ldr	r3, [sp, #24]
3002c884:	e2433001 	sub	r3, r3, #1
3002c888:	e58d3018 	str	r3, [sp, #24]
					if(IsEcho){
3002c88c:	e5dd3016 	ldrb	r3, [sp, #22]
3002c890:	e3530000 	cmp	r3, #0
3002c894:	0a000005 	beq	3002c8b0 <get_cmd+0x110>
						echo(0x08);
3002c898:	e3a00008 	mov	r0, #8
3002c89c:	ebffffb5 	bl	3002c778 <echo>
						echo(' ');
3002c8a0:	e3a00020 	mov	r0, #32
3002c8a4:	ebffffb3 	bl	3002c778 <echo>
						echo(0x08);
3002c8a8:	e3a00008 	mov	r0, #8
3002c8ac:	ebffffb1 	bl	3002c778 <echo>
					}
				}
				cmd_buf[cur_pos] = '\0';
3002c8b0:	e59d200c 	ldr	r2, [sp, #12]
3002c8b4:	e59d3018 	ldr	r3, [sp, #24]
3002c8b8:	e0823003 	add	r3, r2, r3
3002c8bc:	e3a02000 	mov	r2, #0
3002c8c0:	e5c32000 	strb	r2, [r3]
				break;
3002c8c4:	ea000025 	b	3002c960 <get_cmd+0x1c0>
			case '\r':
			case '\n':
			case '\0':
				echo('\r');
3002c8c8:	e3a0000d 	mov	r0, #13
3002c8cc:	ebffffa9 	bl	3002c778 <echo>
				echo('\n');
3002c8d0:	e3a0000a 	mov	r0, #10
3002c8d4:	ebffffa7 	bl	3002c778 <echo>
				cmd_buf[cur_pos]='\0';
3002c8d8:	e59d200c 	ldr	r2, [sp, #12]
3002c8dc:	e59d3018 	ldr	r3, [sp, #24]
3002c8e0:	e0823003 	add	r3, r2, r3
3002c8e4:	e3a02000 	mov	r2, #0
3002c8e8:	e5c32000 	strb	r2, [r3]
				acoral_dev_config(console_id,CONSOLE_BUF_CLEAR,NULL,0);
3002c8ec:	e59d001c 	ldr	r0, [sp, #28]
3002c8f0:	e3a01004 	mov	r1, #4
3002c8f4:	e3a02000 	mov	r2, #0
3002c8f8:	e3a03000 	mov	r3, #0
3002c8fc:	eb004fa9 	bl	300407a8 <acoral_dev_config>
					cur_pos++;
				}
				break;
		}
	}
}
3002c900:	e28dd024 	add	sp, sp, #36	; 0x24
3002c904:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002c908:	e12fff1e 	bx	lr
				echo('\n');
				cmd_buf[cur_pos]='\0';
				acoral_dev_config(console_id,CONSOLE_BUF_CLEAR,NULL,0);
				return;
			case 'x'-'a'+1:
				cur_pos = 0;
3002c90c:	e3a03000 	mov	r3, #0
3002c910:	e58d3018 	str	r3, [sp, #24]
				break;
3002c914:	ea000011 	b	3002c960 <get_cmd+0x1c0>

			default:
				if (cur_pos < BUF_SIZE) {
3002c918:	e59d3018 	ldr	r3, [sp, #24]
3002c91c:	e353007f 	cmp	r3, #127	; 0x7f
3002c920:	8affffb0 	bhi	3002c7e8 <get_cmd+0x48>
					cmd_buf[cur_pos] = c;
3002c924:	e59d200c 	ldr	r2, [sp, #12]
3002c928:	e59d3018 	ldr	r3, [sp, #24]
3002c92c:	e0823003 	add	r3, r2, r3
3002c930:	e5dd2017 	ldrb	r2, [sp, #23]
3002c934:	e5c32000 	strb	r2, [r3]
					if(IsEcho)
3002c938:	e5dd3016 	ldrb	r3, [sp, #22]
3002c93c:	e3530000 	cmp	r3, #0
3002c940:	0a000002 	beq	3002c950 <get_cmd+0x1b0>
						echo(c);
3002c944:	e5dd3017 	ldrb	r3, [sp, #23]
3002c948:	e1a00003 	mov	r0, r3
3002c94c:	ebffff89 	bl	3002c778 <echo>
					cur_pos++;
3002c950:	e59d3018 	ldr	r3, [sp, #24]
3002c954:	e2833001 	add	r3, r3, #1
3002c958:	e58d3018 	str	r3, [sp, #24]
				}
				break;
		}
	}
3002c95c:	eaffffa2 	b	3002c7ec <get_cmd+0x4c>
3002c960:	eaffffa1 	b	3002c7ec <get_cmd+0x4c>
3002c964:	302be818 	.word	0x302be818

3002c968 <acoral_shell_init>:
}

#define SHELL_STACK_SIZE 1024
void acoral_shell_init(){
3002c968:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002c96c:	e24dd01c 	sub	sp, sp, #28
	acoral_comm_policy_data_t data;
	head_cmd=NULL;
3002c970:	e59f3070 	ldr	r3, [pc, #112]	; 3002c9e8 <acoral_shell_init+0x80>
3002c974:	e3a02000 	mov	r2, #0
3002c978:	e5832000 	str	r2, [r3]
	tail_cmd=NULL;
3002c97c:	e59f3068 	ldr	r3, [pc, #104]	; 3002c9ec <acoral_shell_init+0x84>
3002c980:	e3a02000 	mov	r2, #0
3002c984:	e5832000 	str	r2, [r3]
	cmd_init();
3002c988:	eb00008a 	bl	3002cbb8 <cmd_init>
#ifdef CFG_UART_SHELL
	data.cpu=acoral_current_cpu;
3002c98c:	e3a03000 	mov	r3, #0
3002c990:	e5cd3014 	strb	r3, [sp, #20]
	data.prio=ACORAL_TMP_PRIO;
3002c994:	e3e0307e 	mvn	r3, #126	; 0x7e
3002c998:	e5cd3015 	strb	r3, [sp, #21]
	data.prio_type=ACORAL_ABSOLUTE_PRIO;
3002c99c:	e3a03004 	mov	r3, #4
3002c9a0:	e5cd3016 	strb	r3, [sp, #22]
	acoral_create_thread_ext(acoral_shell_enter,SHELL_STACK_SIZE,(void *)acoral_cur_thread->console_id,"shell",NULL,ACORAL_SCHED_POLICY_COMM,&data);
3002c9a4:	e59f3044 	ldr	r3, [pc, #68]	; 3002c9f0 <acoral_shell_init+0x88>
3002c9a8:	e5933000 	ldr	r3, [r3]
3002c9ac:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
3002c9b0:	e3a02000 	mov	r2, #0
3002c9b4:	e58d2000 	str	r2, [sp]
3002c9b8:	e3a02015 	mov	r2, #21
3002c9bc:	e58d2004 	str	r2, [sp, #4]
3002c9c0:	e28d2014 	add	r2, sp, #20
3002c9c4:	e58d2008 	str	r2, [sp, #8]
3002c9c8:	e59f0024 	ldr	r0, [pc, #36]	; 3002c9f4 <acoral_shell_init+0x8c>
3002c9cc:	e3a01b01 	mov	r1, #1024	; 0x400
3002c9d0:	e1a02003 	mov	r2, r3
3002c9d4:	e59f301c 	ldr	r3, [pc, #28]	; 3002c9f8 <acoral_shell_init+0x90>
3002c9d8:	ebff5495 	bl	30001c34 <create_thread_ext>
#endif
}
3002c9dc:	e28dd01c 	add	sp, sp, #28
3002c9e0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002c9e4:	e12fff1e 	bx	lr
3002c9e8:	3012ac9c 	.word	0x3012ac9c
3002c9ec:	302f7e44 	.word	0x302f7e44
3002c9f0:	302be818 	.word	0x302be818
3002c9f4:	3002ca20 	.word	0x3002ca20
3002c9f8:	30045a08 	.word	0x30045a08

3002c9fc <acoral_shell_exit>:

void acoral_shell_exit(void *ptr){
3002c9fc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002ca00:	e24dd00c 	sub	sp, sp, #12
3002ca04:	e58d0004 	str	r0, [sp, #4]
	acoral_free(ptr);
3002ca08:	e59d0004 	ldr	r0, [sp, #4]
3002ca0c:	ebff66a5 	bl	300064a8 <buddy_free>
	acoral_thread_exit();
3002ca10:	ebff581a 	bl	30002a80 <acoral_thread_exit>
}
3002ca14:	e28dd00c 	add	sp, sp, #12
3002ca18:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002ca1c:	e12fff1e 	bx	lr

3002ca20 <acoral_shell_enter>:

void acoral_shell_enter(void *args){
3002ca20:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002ca24:	e24dd014 	sub	sp, sp, #20
3002ca28:	e58d0004 	str	r0, [sp, #4]
	acoral_char *cmd_buf;
	acoral_set_thread_console((acoral_id)args);
3002ca2c:	e59d3004 	ldr	r3, [sp, #4]
3002ca30:	e1a00003 	mov	r0, r3
3002ca34:	ebff5940 	bl	30002f3c <acoral_set_thread_console>
	if(acoral_cur_thread->console_id<0){
3002ca38:	e59f306c 	ldr	r3, [pc, #108]	; 3002caac <acoral_shell_enter+0x8c>
3002ca3c:	e5933000 	ldr	r3, [r3]
3002ca40:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
3002ca44:	e3530000 	cmp	r3, #0
3002ca48:	aa000004 	bge	3002ca60 <acoral_shell_enter+0x40>
		acoral_prints("The thread have no Console\n");
3002ca4c:	e59f005c 	ldr	r0, [pc, #92]	; 3002cab0 <acoral_shell_enter+0x90>
3002ca50:	ebff7a1d 	bl	3000b2cc <acoral_prints>
		acoral_prints("aCoral:>");
		get_cmd(cmd_buf);
		if(cmd_buf[0])
			cmd_exe(cmd_buf);
	}
}
3002ca54:	e28dd014 	add	sp, sp, #20
3002ca58:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002ca5c:	e12fff1e 	bx	lr
	acoral_set_thread_console((acoral_id)args);
	if(acoral_cur_thread->console_id<0){
		acoral_prints("The thread have no Console\n");
		return;
	}
	cmd_buf=acoral_malloc(sizeof(BUF_SIZE));
3002ca60:	e3a00004 	mov	r0, #4
3002ca64:	ebff6657 	bl	300063c8 <buddy_malloc>
3002ca68:	e1a03000 	mov	r3, r0
3002ca6c:	e58d300c 	str	r3, [sp, #12]
3002ca70:	ea000000 	b	3002ca78 <acoral_shell_enter+0x58>
		acoral_prints("\r\n");
		acoral_prints("aCoral:>");
		get_cmd(cmd_buf);
		if(cmd_buf[0])
			cmd_exe(cmd_buf);
	}
3002ca74:	e1a00000 	nop			; (mov r0, r0)
		acoral_prints("The thread have no Console\n");
		return;
	}
	cmd_buf=acoral_malloc(sizeof(BUF_SIZE));
	while(1){
		acoral_prints("\r\n");
3002ca78:	e59f0034 	ldr	r0, [pc, #52]	; 3002cab4 <acoral_shell_enter+0x94>
3002ca7c:	ebff7a12 	bl	3000b2cc <acoral_prints>
		acoral_prints("aCoral:>");
3002ca80:	e59f0030 	ldr	r0, [pc, #48]	; 3002cab8 <acoral_shell_enter+0x98>
3002ca84:	ebff7a10 	bl	3000b2cc <acoral_prints>
		get_cmd(cmd_buf);
3002ca88:	e59d000c 	ldr	r0, [sp, #12]
3002ca8c:	ebffff43 	bl	3002c7a0 <get_cmd>
		if(cmd_buf[0])
3002ca90:	e59d300c 	ldr	r3, [sp, #12]
3002ca94:	e5d33000 	ldrb	r3, [r3]
3002ca98:	e3530000 	cmp	r3, #0
3002ca9c:	0afffff4 	beq	3002ca74 <acoral_shell_enter+0x54>
			cmd_exe(cmd_buf);
3002caa0:	e59d000c 	ldr	r0, [sp, #12]
3002caa4:	ebffff12 	bl	3002c6f4 <cmd_exe>
	}
3002caa8:	eafffff2 	b	3002ca78 <acoral_shell_enter+0x58>
3002caac:	302be818 	.word	0x302be818
3002cab0:	30045a10 	.word	0x30045a10
3002cab4:	30045a2c 	.word	0x30045a2c
3002cab8:	30045a30 	.word	0x30045a30

3002cabc <malloc_scan>:
#include<kernel.h>
#include"../include/shell.h"
#include"console.h"
void malloc_scan(acoral_32 argc,acoral_char **argv){
3002cabc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002cac0:	e24dd00c 	sub	sp, sp, #12
3002cac4:	e58d0004 	str	r0, [sp, #4]
3002cac8:	e58d1000 	str	r1, [sp]
	acoral_mem_scan();
3002cacc:	ebff624c 	bl	30005404 <buddy_scan>
}
3002cad0:	e28dd00c 	add	sp, sp, #12
3002cad4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002cad8:	e12fff1e 	bx	lr

3002cadc <malloc_scan2>:
	"View the first Level Memory Managment Info",
	NULL
};

#ifdef CFG_MEM2
void malloc_scan2(acoral_32 argc,acoral_char **argv){
3002cadc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002cae0:	e24dd00c 	sub	sp, sp, #12
3002cae4:	e58d0004 	str	r0, [sp, #4]
3002cae8:	e58d1000 	str	r1, [sp]
	acoral_mem_scan2();
3002caec:	ebff6935 	bl	30006fc8 <v_mem_scan>
}
3002caf0:	e28dd00c 	add	sp, sp, #12
3002caf4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002caf8:	e12fff1e 	bx	lr

3002cafc <help>:
	NULL
};
#endif

extern acoral_shell_cmd_t *head_cmd;
void help(acoral_32 argc,acoral_char **argv){
3002cafc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002cb00:	e24dd014 	sub	sp, sp, #20
3002cb04:	e58d0004 	str	r0, [sp, #4]
3002cb08:	e58d1000 	str	r1, [sp]
	acoral_shell_cmd_t *curr;
	curr =head_cmd;
3002cb0c:	e59f304c 	ldr	r3, [pc, #76]	; 3002cb60 <help+0x64>
3002cb10:	e5933000 	ldr	r3, [r3]
3002cb14:	e58d300c 	str	r3, [sp, #12]
	while(curr != NULL) {
3002cb18:	ea00000a 	b	3002cb48 <help+0x4c>
		acoral_print("%s  %s\n",curr->name,curr->comment);
3002cb1c:	e59d300c 	ldr	r3, [sp, #12]
3002cb20:	e5932000 	ldr	r2, [r3]
3002cb24:	e59d300c 	ldr	r3, [sp, #12]
3002cb28:	e5933008 	ldr	r3, [r3, #8]
3002cb2c:	e59f0030 	ldr	r0, [pc, #48]	; 3002cb64 <help+0x68>
3002cb30:	e1a01002 	mov	r1, r2
3002cb34:	e1a02003 	mov	r2, r3
3002cb38:	ebff79c0 	bl	3000b240 <acoral_print>
		curr = curr->next;
3002cb3c:	e59d300c 	ldr	r3, [sp, #12]
3002cb40:	e593300c 	ldr	r3, [r3, #12]
3002cb44:	e58d300c 	str	r3, [sp, #12]

extern acoral_shell_cmd_t *head_cmd;
void help(acoral_32 argc,acoral_char **argv){
	acoral_shell_cmd_t *curr;
	curr =head_cmd;
	while(curr != NULL) {
3002cb48:	e59d300c 	ldr	r3, [sp, #12]
3002cb4c:	e3530000 	cmp	r3, #0
3002cb50:	1afffff1 	bne	3002cb1c <help+0x20>
		acoral_print("%s  %s\n",curr->name,curr->comment);
		curr = curr->next;
	}
}
3002cb54:	e28dd014 	add	sp, sp, #20
3002cb58:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002cb5c:	e12fff1e 	bx	lr
3002cb60:	3012ac9c 	.word	0x3012ac9c
3002cb64:	30045aac 	.word	0x30045aac

3002cb68 <exit>:
	help,
	"View all Shell Command info",
	NULL
};

void exit(acoral_32 argc,acoral_char **argv){
3002cb68:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002cb6c:	e24dd00c 	sub	sp, sp, #12
3002cb70:	e58d0004 	str	r0, [sp, #4]
3002cb74:	e58d1000 	str	r1, [sp]
	acoral_dev_config(acoral_cur_thread->console_id,CONSOLE_EXIT,NULL,0);
3002cb78:	e59f3034 	ldr	r3, [pc, #52]	; 3002cbb4 <exit+0x4c>
3002cb7c:	e5933000 	ldr	r3, [r3]
3002cb80:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
3002cb84:	e1a00003 	mov	r0, r3
3002cb88:	e3a01003 	mov	r1, #3
3002cb8c:	e3a02000 	mov	r2, #0
3002cb90:	e3a03000 	mov	r3, #0
3002cb94:	eb004f03 	bl	300407a8 <acoral_dev_config>
	acoral_shell_exit((void *)argv[0]);
3002cb98:	e59d3000 	ldr	r3, [sp]
3002cb9c:	e5933000 	ldr	r3, [r3]
3002cba0:	e1a00003 	mov	r0, r3
3002cba4:	ebffff94 	bl	3002c9fc <acoral_shell_exit>
}
3002cba8:	e28dd00c 	add	sp, sp, #12
3002cbac:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002cbb0:	e12fff1e 	bx	lr
3002cbb4:	302be818 	.word	0x302be818

3002cbb8 <cmd_init>:
};
#endif

extern acoral_shell_cmd_t dt_cmd;
extern fs_cmd_init();
void cmd_init(){
3002cbb8:	e92d4008 	push	{r3, lr}
	add_command(&mem_cmd);
3002cbbc:	e59f002c 	ldr	r0, [pc, #44]	; 3002cbf0 <cmd_init+0x38>
3002cbc0:	ebfffe75 	bl	3002c59c <add_command>
#ifdef CFG_MEM2
	add_command(&mem2_cmd);
3002cbc4:	e59f0028 	ldr	r0, [pc, #40]	; 3002cbf4 <cmd_init+0x3c>
3002cbc8:	ebfffe73 	bl	3002c59c <add_command>
#endif
	add_command(&dt_cmd);
3002cbcc:	e59f0024 	ldr	r0, [pc, #36]	; 3002cbf8 <cmd_init+0x40>
3002cbd0:	ebfffe71 	bl	3002c59c <add_command>
#ifdef CFG_PM
	add_command(&suspend_cmd);
#endif
	add_command(&exit_cmd);
3002cbd4:	e59f0020 	ldr	r0, [pc, #32]	; 3002cbfc <cmd_init+0x44>
3002cbd8:	ebfffe6f 	bl	3002c59c <add_command>
	add_command(&help_cmd);
3002cbdc:	e59f001c 	ldr	r0, [pc, #28]	; 3002cc00 <cmd_init+0x48>
3002cbe0:	ebfffe6d 	bl	3002c59c <add_command>
#ifdef CFG_SHELL_FS_CMD
	fs_cmd_init();
3002cbe4:	eb0002e6 	bl	3002d784 <fs_cmd_init>
#endif

}
3002cbe8:	e8bd4008 	pop	{r3, lr}
3002cbec:	e12fff1e 	bx	lr
3002cbf0:	300466d0 	.word	0x300466d0
3002cbf4:	300466e0 	.word	0x300466e0
3002cbf8:	30046710 	.word	0x30046710
3002cbfc:	30046700 	.word	0x30046700
3002cc00:	300466f0 	.word	0x300466f0

3002cc04 <display_thread>:
#include<thread.h>
#include<policy.h>
#include<hal.h>
#include"../include/shell.h"
void display_thread(acoral_32 argc,acoral_char **argv){
3002cc04:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002cc08:	e24dd01c 	sub	sp, sp, #28
3002cc0c:	e58d0004 	str	r0, [sp, #4]
3002cc10:	e58d1000 	str	r1, [sp]
	acoral_sr cpu_sr;	
	acoral_list_t *head,*tmp;
	acoral_thread_t * thread;
	head=&acoral_threads_queue.head;
3002cc14:	e59f31b4 	ldr	r3, [pc, #436]	; 3002cdd0 <display_thread+0x1cc>
3002cc18:	e58d300c 	str	r3, [sp, #12]
	acoral_prints("\t\tSystem Thread Information\r\n");
3002cc1c:	e59f01b0 	ldr	r0, [pc, #432]	; 3002cdd4 <display_thread+0x1d0>
3002cc20:	ebff79a9 	bl	3000b2cc <acoral_prints>
	acoral_prints("------------------------------------------------------\r\n");
3002cc24:	e59f01ac 	ldr	r0, [pc, #428]	; 3002cdd8 <display_thread+0x1d4>
3002cc28:	ebff79a7 	bl	3000b2cc <acoral_prints>
	acoral_prints("Name\t\tType\t\tConsole\t\tState\r\n");
3002cc2c:	e59f01a8 	ldr	r0, [pc, #424]	; 3002cddc <display_thread+0x1d8>
3002cc30:	ebff79a5 	bl	3000b2cc <acoral_prints>
	HAL_ENTER_CRITICAL();
3002cc34:	ebff52ae 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
3002cc38:	e1a03000 	mov	r3, r0
3002cc3c:	e58d3008 	str	r3, [sp, #8]
	acoral_spin_lock(&acoral_threads_queue.head.lock);
	for(tmp=head->next;tmp!=head;tmp=tmp->next){
3002cc40:	e59d300c 	ldr	r3, [sp, #12]
3002cc44:	e5933000 	ldr	r3, [r3]
3002cc48:	e58d3010 	str	r3, [sp, #16]
3002cc4c:	ea000054 	b	3002cda4 <display_thread+0x1a0>
		thread=list_entry(tmp,acoral_thread_t,global_list);
3002cc50:	e59d3010 	ldr	r3, [sp, #16]
3002cc54:	e2433028 	sub	r3, r3, #40	; 0x28
3002cc58:	e58d3014 	str	r3, [sp, #20]
		acoral_print("%s\t\t",thread->name);
3002cc5c:	e59d3014 	ldr	r3, [sp, #20]
3002cc60:	e5933048 	ldr	r3, [r3, #72]	; 0x48
3002cc64:	e59f0174 	ldr	r0, [pc, #372]	; 3002cde0 <display_thread+0x1dc>
3002cc68:	e1a01003 	mov	r1, r3
3002cc6c:	ebff7973 	bl	3000b240 <acoral_print>
		switch(thread->policy){
3002cc70:	e59d3014 	ldr	r3, [sp, #20]
3002cc74:	e5d3300c 	ldrb	r3, [r3, #12]
3002cc78:	e2433015 	sub	r3, r3, #21
3002cc7c:	e3530004 	cmp	r3, #4
3002cc80:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3002cc84:	ea000012 	b	3002ccd4 <display_thread+0xd0>
3002cc88:	3002cc9c 	.word	0x3002cc9c
3002cc8c:	3002ccb4 	.word	0x3002ccb4
3002cc90:	3002ccc0 	.word	0x3002ccc0
3002cc94:	3002cca8 	.word	0x3002cca8
3002cc98:	3002cccc 	.word	0x3002cccc
			case ACORAL_SCHED_POLICY_COMM:
				acoral_prints("Common\t\t");
3002cc9c:	e59f0140 	ldr	r0, [pc, #320]	; 3002cde4 <display_thread+0x1e0>
3002cca0:	ebff7989 	bl	3000b2cc <acoral_prints>
				break;
3002cca4:	ea00000a 	b	3002ccd4 <display_thread+0xd0>
			case ACORAL_SCHED_POLICY_SLICE:
				acoral_prints("Slice\t\t");
3002cca8:	e59f0138 	ldr	r0, [pc, #312]	; 3002cde8 <display_thread+0x1e4>
3002ccac:	ebff7986 	bl	3000b2cc <acoral_prints>
				break;
3002ccb0:	ea000007 	b	3002ccd4 <display_thread+0xd0>
			case ACORAL_SCHED_POLICY_PERIOD:
				acoral_prints("Period\t\t");
3002ccb4:	e59f0130 	ldr	r0, [pc, #304]	; 3002cdec <display_thread+0x1e8>
3002ccb8:	ebff7983 	bl	3000b2cc <acoral_prints>
				break;
3002ccbc:	ea000004 	b	3002ccd4 <display_thread+0xd0>
			case ACORAL_SCHED_POLICY_RM:
				acoral_prints("RM\t\t");
3002ccc0:	e59f0128 	ldr	r0, [pc, #296]	; 3002cdf0 <display_thread+0x1ec>
3002ccc4:	ebff7980 	bl	3000b2cc <acoral_prints>
				break;
3002ccc8:	ea000001 	b	3002ccd4 <display_thread+0xd0>
			case ACORAL_SCHED_POLICY_POSIX:
				acoral_prints("Posix\t\t");
3002cccc:	e59f0120 	ldr	r0, [pc, #288]	; 3002cdf4 <display_thread+0x1f0>
3002ccd0:	ebff797d 	bl	3000b2cc <acoral_prints>
			default:
				break;
		}
		acoral_print("%d\t\t",thread->console_id);
3002ccd4:	e59d3014 	ldr	r3, [sp, #20]
3002ccd8:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
3002ccdc:	e59f0114 	ldr	r0, [pc, #276]	; 3002cdf8 <display_thread+0x1f4>
3002cce0:	e1a01003 	mov	r1, r3
3002cce4:	ebff7955 	bl	3000b240 <acoral_print>
		if(thread->state&ACORAL_THREAD_STATE_RUNNING)
3002cce8:	e59d3014 	ldr	r3, [sp, #20]
3002ccec:	e5d33004 	ldrb	r3, [r3, #4]
3002ccf0:	e2033004 	and	r3, r3, #4
3002ccf4:	e3530000 	cmp	r3, #0
3002ccf8:	0a000002 	beq	3002cd08 <display_thread+0x104>
				acoral_prints("Running\t\t");
3002ccfc:	e59f00f8 	ldr	r0, [pc, #248]	; 3002cdfc <display_thread+0x1f8>
3002cd00:	ebff7971 	bl	3000b2cc <acoral_prints>
3002cd04:	ea000021 	b	3002cd90 <display_thread+0x18c>
		else if(thread->state&ACORAL_THREAD_STATE_READY)
3002cd08:	e59d3014 	ldr	r3, [sp, #20]
3002cd0c:	e5d33004 	ldrb	r3, [r3, #4]
3002cd10:	e2033001 	and	r3, r3, #1
3002cd14:	e20330ff 	and	r3, r3, #255	; 0xff
3002cd18:	e3530000 	cmp	r3, #0
3002cd1c:	0a000002 	beq	3002cd2c <display_thread+0x128>
				acoral_prints("Ready\t\t");
3002cd20:	e59f00d8 	ldr	r0, [pc, #216]	; 3002ce00 <display_thread+0x1fc>
3002cd24:	ebff7968 	bl	3000b2cc <acoral_prints>
3002cd28:	ea000018 	b	3002cd90 <display_thread+0x18c>
		else if(thread->state&ACORAL_THREAD_STATE_DELAY)
3002cd2c:	e59d3014 	ldr	r3, [sp, #20]
3002cd30:	e5d33004 	ldrb	r3, [r3, #4]
3002cd34:	e2033020 	and	r3, r3, #32
3002cd38:	e3530000 	cmp	r3, #0
3002cd3c:	0a000002 	beq	3002cd4c <display_thread+0x148>
				acoral_prints("Delay\t\t");
3002cd40:	e59f00bc 	ldr	r0, [pc, #188]	; 3002ce04 <display_thread+0x200>
3002cd44:	ebff7960 	bl	3000b2cc <acoral_prints>
3002cd48:	ea000010 	b	3002cd90 <display_thread+0x18c>
		else if(thread->state&ACORAL_THREAD_STATE_SUSPEND)
3002cd4c:	e59d3014 	ldr	r3, [sp, #20]
3002cd50:	e5d33004 	ldrb	r3, [r3, #4]
3002cd54:	e2033002 	and	r3, r3, #2
3002cd58:	e3530000 	cmp	r3, #0
3002cd5c:	0a000002 	beq	3002cd6c <display_thread+0x168>
				acoral_prints("Sleep\t\t");
3002cd60:	e59f00a0 	ldr	r0, [pc, #160]	; 3002ce08 <display_thread+0x204>
3002cd64:	ebff7958 	bl	3000b2cc <acoral_prints>
3002cd68:	ea000008 	b	3002cd90 <display_thread+0x18c>
		else if(thread->state==ACORAL_THREAD_STATE_EXIT)
3002cd6c:	e59d3014 	ldr	r3, [sp, #20]
3002cd70:	e5d33004 	ldrb	r3, [r3, #4]
3002cd74:	e3530008 	cmp	r3, #8
3002cd78:	1a000002 	bne	3002cd88 <display_thread+0x184>
				acoral_prints("Freeze\t\t");
3002cd7c:	e59f0088 	ldr	r0, [pc, #136]	; 3002ce0c <display_thread+0x208>
3002cd80:	ebff7951 	bl	3000b2cc <acoral_prints>
3002cd84:	ea000001 	b	3002cd90 <display_thread+0x18c>
		else
				acoral_prints("Error\t\t");
3002cd88:	e59f0080 	ldr	r0, [pc, #128]	; 3002ce10 <display_thread+0x20c>
3002cd8c:	ebff794e 	bl	3000b2cc <acoral_prints>
		acoral_prints("\r\n");
3002cd90:	e59f007c 	ldr	r0, [pc, #124]	; 3002ce14 <display_thread+0x210>
3002cd94:	ebff794c 	bl	3000b2cc <acoral_prints>
	acoral_prints("\t\tSystem Thread Information\r\n");
	acoral_prints("------------------------------------------------------\r\n");
	acoral_prints("Name\t\tType\t\tConsole\t\tState\r\n");
	HAL_ENTER_CRITICAL();
	acoral_spin_lock(&acoral_threads_queue.head.lock);
	for(tmp=head->next;tmp!=head;tmp=tmp->next){
3002cd98:	e59d3010 	ldr	r3, [sp, #16]
3002cd9c:	e5933000 	ldr	r3, [r3]
3002cda0:	e58d3010 	str	r3, [sp, #16]
3002cda4:	e59d2010 	ldr	r2, [sp, #16]
3002cda8:	e59d300c 	ldr	r3, [sp, #12]
3002cdac:	e1520003 	cmp	r2, r3
3002cdb0:	1affffa6 	bne	3002cc50 <display_thread+0x4c>
				acoral_prints("Freeze\t\t");
		else
				acoral_prints("Error\t\t");
		acoral_prints("\r\n");
	}
	acoral_prints("------------------------------------------------------\r\n");
3002cdb4:	e59f001c 	ldr	r0, [pc, #28]	; 3002cdd8 <display_thread+0x1d4>
3002cdb8:	ebff7943 	bl	3000b2cc <acoral_prints>
	acoral_spin_unlock(&acoral_threads_queue.head.lock);
	HAL_EXIT_CRITICAL();
3002cdbc:	e59d0008 	ldr	r0, [sp, #8]
3002cdc0:	ebff5249 	bl	300016ec <HAL_INTR_RESTORE>
}
3002cdc4:	e28dd01c 	add	sp, sp, #28
3002cdc8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002cdcc:	e12fff1e 	bx	lr
3002cdd0:	300eab34 	.word	0x300eab34
3002cdd4:	30045aec 	.word	0x30045aec
3002cdd8:	30045b0c 	.word	0x30045b0c
3002cddc:	30045b48 	.word	0x30045b48
3002cde0:	30045b68 	.word	0x30045b68
3002cde4:	30045b70 	.word	0x30045b70
3002cde8:	30045b7c 	.word	0x30045b7c
3002cdec:	30045b84 	.word	0x30045b84
3002cdf0:	30045b90 	.word	0x30045b90
3002cdf4:	30045b98 	.word	0x30045b98
3002cdf8:	30045ba0 	.word	0x30045ba0
3002cdfc:	30045ba8 	.word	0x30045ba8
3002ce00:	30045bb4 	.word	0x30045bb4
3002ce04:	30045bbc 	.word	0x30045bbc
3002ce08:	30045bc4 	.word	0x30045bc4
3002ce0c:	30045bcc 	.word	0x30045bcc
3002ce10:	30045bd8 	.word	0x30045bd8
3002ce14:	30045be0 	.word	0x30045be0

3002ce18 <server_client>:
;* 输　	 入 : arg: 线程参数
;*        
;* 输　	 出 : 无
;*****************************************************************************************************
;*/
void server_client(void *args){
3002ce18:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002ce1c:	e24dd014 	sub	sp, sp, #20
3002ce20:	e58d0004 	str	r0, [sp, #4]
	acoral_id telnet_id;
	struct netconn *newconn=(struct netconn *)args;	
3002ce24:	e59d3004 	ldr	r3, [sp, #4]
3002ce28:	e58d300c 	str	r3, [sp, #12]
	if(newconn != NULL)
3002ce2c:	e59d300c 	ldr	r3, [sp, #12]
3002ce30:	e3530000 	cmp	r3, #0
3002ce34:	0a000015 	beq	3002ce90 <server_client+0x78>
	{
		telnet_id=acoral_dev_open("con_telnet");
3002ce38:	e59f005c 	ldr	r0, [pc, #92]	; 3002ce9c <server_client+0x84>
3002ce3c:	eb004de8 	bl	300405e4 <acoral_dev_open>
3002ce40:	e1a03000 	mov	r3, r0
3002ce44:	e58d3008 	str	r3, [sp, #8]
		if(telnet_id<0){
3002ce48:	e59d3008 	ldr	r3, [sp, #8]
3002ce4c:	e3530000 	cmp	r3, #0
3002ce50:	aa000004 	bge	3002ce68 <server_client+0x50>
			acoral_prints("No shell Support,will Exit");
3002ce54:	e59f0044 	ldr	r0, [pc, #68]	; 3002cea0 <server_client+0x88>
3002ce58:	ebff791b 	bl	3000b2cc <acoral_prints>
			netconn_delete(newconn);
3002ce5c:	e59d000c 	ldr	r0, [sp, #12]
3002ce60:	ebff7fd7 	bl	3000cdc4 <netconn_delete>
			return;
3002ce64:	ea000009 	b	3002ce90 <server_client+0x78>
		}
		acoral_dev_config(telnet_id,CONSOLE_SET_PRIV_DATA,newconn,0);
3002ce68:	e59d0008 	ldr	r0, [sp, #8]
3002ce6c:	e3a01002 	mov	r1, #2
3002ce70:	e59d200c 	ldr	r2, [sp, #12]
3002ce74:	e3a03000 	mov	r3, #0
3002ce78:	eb004e4a 	bl	300407a8 <acoral_dev_config>
		acoral_posix_create(NULL,NULL,acoral_shell_enter,(void *)telnet_id);
3002ce7c:	e59d3008 	ldr	r3, [sp, #8]
3002ce80:	e3a00000 	mov	r0, #0
3002ce84:	e3a01000 	mov	r1, #0
3002ce88:	e59f2014 	ldr	r2, [pc, #20]	; 3002cea4 <server_client+0x8c>
3002ce8c:	ebff71c0 	bl	30009594 <acoral_posix_create>
	}
}
3002ce90:	e28dd014 	add	sp, sp, #20
3002ce94:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002ce98:	e12fff1e 	bx	lr
3002ce9c:	30045c00 	.word	0x30045c00
3002cea0:	30045c0c 	.word	0x30045c0c
3002cea4:	3002ca20 	.word	0x3002ca20

3002cea8 <telnet_thread>:

void telnet_thread(void *arg)
{
3002cea8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002ceac:	e24dd01c 	sub	sp, sp, #28
3002ceb0:	e58d0004 	str	r0, [sp, #4]
	struct netconn *conn, *newconn;
	struct ip_addr l_ip;
	IP4_ADDR(&l_ip, 192,168,1,2);
3002ceb4:	e3a00c01 	mov	r0, #256	; 0x100
3002ceb8:	e280010b 	add	r0, r0, #-1073741822	; 0xc0000002
3002cebc:	e280072a 	add	r0, r0, #11010048	; 0xa80000
3002cec0:	ebff99ed 	bl	3001367c <htonl>
3002cec4:	e1a03000 	mov	r3, r0
3002cec8:	e58d300c 	str	r3, [sp, #12]
  	/* Create a new connection identifier. */
	conn = netconn_new(NETCONN_TCP);
3002cecc:	e3a00010 	mov	r0, #16
3002ced0:	e3a01000 	mov	r1, #0
3002ced4:	e3a02000 	mov	r2, #0
3002ced8:	ebff7f89 	bl	3000cd04 <netconn_new_with_proto_and_callback>
3002cedc:	e1a03000 	mov	r3, r0
3002cee0:	e58d3010 	str	r3, [sp, #16]

	/* Bind connection to well known port number 7. */
	netconn_bind(conn, &l_ip, 23);
3002cee4:	e28d300c 	add	r3, sp, #12
3002cee8:	e59d0010 	ldr	r0, [sp, #16]
3002ceec:	e1a01003 	mov	r1, r3
3002cef0:	e3a02017 	mov	r2, #23
3002cef4:	ebff7ff1 	bl	3000cec0 <netconn_bind>

  	/* Tell connection to go into listening mode. */
	netconn_listen(conn);
3002cef8:	e59d0010 	ldr	r0, [sp, #16]
3002cefc:	e3a010ff 	mov	r1, #255	; 0xff
3002cf00:	ebff8035 	bl	3000cfdc <netconn_listen_with_backlog>

	while(1)
	{
		newconn = netconn_accept(conn);
3002cf04:	e59d0010 	ldr	r0, [sp, #16]
3002cf08:	ebff8048 	bl	3000d030 <netconn_accept>
3002cf0c:	e1a03000 	mov	r3, r0
3002cf10:	e58d3014 	str	r3, [sp, #20]
		server_client(newconn);
3002cf14:	e59d0014 	ldr	r0, [sp, #20]
3002cf18:	ebffffbe 	bl	3002ce18 <server_client>
	}
3002cf1c:	eafffff8 	b	3002cf04 <telnet_thread+0x5c>

3002cf20 <user_telnetd>:
}



void user_telnetd()
{
3002cf20:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002cf24:	e24dd00c 	sub	sp, sp, #12
     acoral_create_thread(telnet_thread,1024,"telnet",NULL,TELNET_TASK_PRIO,-1);
3002cf28:	e3a03017 	mov	r3, #23
3002cf2c:	e58d3000 	str	r3, [sp]
3002cf30:	e3e03000 	mvn	r3, #0
3002cf34:	e58d3004 	str	r3, [sp, #4]
3002cf38:	e59f0018 	ldr	r0, [pc, #24]	; 3002cf58 <user_telnetd+0x38>
3002cf3c:	e3a01b01 	mov	r1, #1024	; 0x400
3002cf40:	e59f2014 	ldr	r2, [pc, #20]	; 3002cf5c <user_telnetd+0x3c>
3002cf44:	e3a03000 	mov	r3, #0
3002cf48:	ebff5815 	bl	30002fa4 <create_comm_thread>
}
3002cf4c:	e28dd00c 	add	sp, sp, #12
3002cf50:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002cf54:	e12fff1e 	bx	lr
3002cf58:	3002cea8 	.word	0x3002cea8
3002cf5c:	30045c28 	.word	0x30045c28

3002cf60 <cd_dir>:
#include <mutex.h>
#include "../include/shell.h"
extern acoral_evt_t *fs_mutex;
acoral_char CurrentDirName[12];
void cd_dir(acoral_32 argc,acoral_char **argv)
{
3002cf60:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002cf64:	e24dd01c 	sub	sp, sp, #28
3002cf68:	e58d0004 	str	r0, [sp, #4]
3002cf6c:	e58d1000 	str	r1, [sp]
	acoral_u32 ret;
	acoral_u8 fs_ret;
	acoral_u32 len;
	acoral_char *path;
	if(argc!=2)
3002cf70:	e59d3004 	ldr	r3, [sp, #4]
3002cf74:	e3530002 	cmp	r3, #2
3002cf78:	0a000002 	beq	3002cf88 <cd_dir+0x28>
	{
		acoral_print("Usage ls <Pathname>\n");
3002cf7c:	e59f0128 	ldr	r0, [pc, #296]	; 3002d0ac <cd_dir+0x14c>
3002cf80:	ebff78ae 	bl	3000b240 <acoral_print>
		return ;
3002cf84:	ea000045 	b	3002d0a0 <cd_dir+0x140>
	}
	path=argv[1];
3002cf88:	e59d3000 	ldr	r3, [sp]
3002cf8c:	e2833004 	add	r3, r3, #4
3002cf90:	e5933000 	ldr	r3, [r3]
3002cf94:	e58d3014 	str	r3, [sp, #20]
	ret=acoral_mutex_pend(fs_mutex,0);
3002cf98:	e59f3110 	ldr	r3, [pc, #272]	; 3002d0b0 <cd_dir+0x150>
3002cf9c:	e5933000 	ldr	r3, [r3]
3002cfa0:	e1a00003 	mov	r0, r3
3002cfa4:	e3a01000 	mov	r1, #0
3002cfa8:	ebff601a 	bl	30005018 <acoral_mutex_pend>
3002cfac:	e1a03000 	mov	r3, r0
3002cfb0:	e58d3008 	str	r3, [sp, #8]
	if(ret!=MUTEX_SUCCED)
3002cfb4:	e59d3008 	ldr	r3, [sp, #8]
3002cfb8:	e3530000 	cmp	r3, #0
3002cfbc:	1a000034 	bne	3002d094 <cd_dir+0x134>
		return;
	fs_ret=ChangeDir(path);
3002cfc0:	e59d0014 	ldr	r0, [sp, #20]
3002cfc4:	ebffdc33 	bl	30024098 <ChangeDir>
3002cfc8:	e1a03000 	mov	r3, r0
3002cfcc:	e5cd300f 	strb	r3, [sp, #15]
	acoral_mutex_post(fs_mutex);
3002cfd0:	e59f30d8 	ldr	r3, [pc, #216]	; 3002d0b0 <cd_dir+0x150>
3002cfd4:	e5933000 	ldr	r3, [r3]
3002cfd8:	e1a00003 	mov	r0, r3
3002cfdc:	ebff609e 	bl	3000525c <acoral_mutex_post>
	if(fs_ret!=RETURN_OK)
3002cfe0:	e5dd300f 	ldrb	r3, [sp, #15]
3002cfe4:	e3530000 	cmp	r3, #0
3002cfe8:	1a00002b 	bne	3002d09c <cd_dir+0x13c>
		return ;
	len=acoral_str_len(path);
3002cfec:	e59d0014 	ldr	r0, [sp, #20]
3002cff0:	ebff79d0 	bl	3000b738 <acoral_str_len>
3002cff4:	e1a03000 	mov	r3, r0
3002cff8:	e58d3010 	str	r3, [sp, #16]
	path+=len;
3002cffc:	e59d2014 	ldr	r2, [sp, #20]
3002d000:	e59d3010 	ldr	r3, [sp, #16]
3002d004:	e0823003 	add	r3, r2, r3
3002d008:	e58d3014 	str	r3, [sp, #20]
	while((len--)!=0 && *path!='/' && *path!='\\')
3002d00c:	ea000002 	b	3002d01c <cd_dir+0xbc>
		path--;
3002d010:	e59d3014 	ldr	r3, [sp, #20]
3002d014:	e2433001 	sub	r3, r3, #1
3002d018:	e58d3014 	str	r3, [sp, #20]
	acoral_mutex_post(fs_mutex);
	if(fs_ret!=RETURN_OK)
		return ;
	len=acoral_str_len(path);
	path+=len;
	while((len--)!=0 && *path!='/' && *path!='\\')
3002d01c:	e59d3010 	ldr	r3, [sp, #16]
3002d020:	e3530000 	cmp	r3, #0
3002d024:	03a03000 	moveq	r3, #0
3002d028:	13a03001 	movne	r3, #1
3002d02c:	e20330ff 	and	r3, r3, #255	; 0xff
3002d030:	e59d2010 	ldr	r2, [sp, #16]
3002d034:	e2422001 	sub	r2, r2, #1
3002d038:	e58d2010 	str	r2, [sp, #16]
3002d03c:	e3530000 	cmp	r3, #0
3002d040:	0a000007 	beq	3002d064 <cd_dir+0x104>
3002d044:	e59d3014 	ldr	r3, [sp, #20]
3002d048:	e5d33000 	ldrb	r3, [r3]
3002d04c:	e353002f 	cmp	r3, #47	; 0x2f
3002d050:	0a000003 	beq	3002d064 <cd_dir+0x104>
3002d054:	e59d3014 	ldr	r3, [sp, #20]
3002d058:	e5d33000 	ldrb	r3, [r3]
3002d05c:	e353005c 	cmp	r3, #92	; 0x5c
3002d060:	1affffea 	bne	3002d010 <cd_dir+0xb0>
		path--;
	acoral_str_ncpy(CurrentDirName,path,11);
3002d064:	e59f0048 	ldr	r0, [pc, #72]	; 3002d0b4 <cd_dir+0x154>
3002d068:	e59d1014 	ldr	r1, [sp, #20]
3002d06c:	e3a0200b 	mov	r2, #11
3002d070:	ebff7a65 	bl	3000ba0c <acoral_str_ncpy>
	CurrentDirName[11]='\0';
3002d074:	e59f3038 	ldr	r3, [pc, #56]	; 3002d0b4 <cd_dir+0x154>
3002d078:	e3a02000 	mov	r2, #0
3002d07c:	e5c3200b 	strb	r2, [r3, #11]
	acoral_print("%s>",path);
3002d080:	e59f0030 	ldr	r0, [pc, #48]	; 3002d0b8 <cd_dir+0x158>
3002d084:	e59d1014 	ldr	r1, [sp, #20]
3002d088:	ebff786c 	bl	3000b240 <acoral_print>
	return ;	
3002d08c:	e1a00000 	nop			; (mov r0, r0)
3002d090:	ea000002 	b	3002d0a0 <cd_dir+0x140>
		return ;
	}
	path=argv[1];
	ret=acoral_mutex_pend(fs_mutex,0);
	if(ret!=MUTEX_SUCCED)
		return;
3002d094:	e1a00000 	nop			; (mov r0, r0)
3002d098:	ea000000 	b	3002d0a0 <cd_dir+0x140>
	fs_ret=ChangeDir(path);
	acoral_mutex_post(fs_mutex);
	if(fs_ret!=RETURN_OK)
		return ;
3002d09c:	e1a00000 	nop			; (mov r0, r0)
		path--;
	acoral_str_ncpy(CurrentDirName,path,11);
	CurrentDirName[11]='\0';
	acoral_print("%s>",path);
	return ;	
}
3002d0a0:	e28dd01c 	add	sp, sp, #28
3002d0a4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002d0a8:	e12fff1e 	bx	lr
3002d0ac:	30045c30 	.word	0x30045c30
3002d0b0:	3012a80c 	.word	0x3012a80c
3002d0b4:	3012a844 	.word	0x3012a844
3002d0b8:	30045c48 	.word	0x30045c48

3002d0bc <print>:
	"Change current dir",
	NULL
};

void print(FDT *Rt,acoral_u8 detail)
{
3002d0bc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002d0c0:	e24dd044 	sub	sp, sp, #68	; 0x44
3002d0c4:	e58d0004 	str	r0, [sp, #4]
3002d0c8:	e1a03001 	mov	r3, r1
3002d0cc:	e5cd3003 	strb	r3, [sp, #3]
	acoral_char *name,*pbuf;
	acoral_char buf[38];
	acoral_u8 i;
	static acoral_u8 j=0;
	for(i=0;i<37;i++)
3002d0d0:	e3a03000 	mov	r3, #0
3002d0d4:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
3002d0d8:	ea000009 	b	3002d104 <print+0x48>
		buf[i]=' ';
3002d0dc:	e5dd203f 	ldrb	r2, [sp, #63]	; 0x3f
3002d0e0:	e3e03033 	mvn	r3, #51	; 0x33
3002d0e4:	e28d1040 	add	r1, sp, #64	; 0x40
3002d0e8:	e0812002 	add	r2, r1, r2
3002d0ec:	e0823003 	add	r3, r2, r3
3002d0f0:	e3a02020 	mov	r2, #32
3002d0f4:	e5c32000 	strb	r2, [r3]
{
	acoral_char *name,*pbuf;
	acoral_char buf[38];
	acoral_u8 i;
	static acoral_u8 j=0;
	for(i=0;i<37;i++)
3002d0f8:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
3002d0fc:	e2833001 	add	r3, r3, #1
3002d100:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
3002d104:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
3002d108:	e3530024 	cmp	r3, #36	; 0x24
3002d10c:	9afffff2 	bls	3002d0dc <print+0x20>
		buf[i]=' ';
	buf[37]='\0';
3002d110:	e3a03000 	mov	r3, #0
3002d114:	e5cd3031 	strb	r3, [sp, #49]	; 0x31
	pbuf=buf;
3002d118:	e28d300c 	add	r3, sp, #12
3002d11c:	e58d3038 	str	r3, [sp, #56]	; 0x38

	name=Rt->Name;
3002d120:	e59d3004 	ldr	r3, [sp, #4]
3002d124:	e58d3034 	str	r3, [sp, #52]	; 0x34
	for(i=0;i<8;i++)
3002d128:	e3a03000 	mov	r3, #0
3002d12c:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
3002d130:	ea000010 	b	3002d178 <print+0xbc>
	{
		if(*name!=0x20)
3002d134:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3002d138:	e5d33000 	ldrb	r3, [r3]
3002d13c:	e3530020 	cmp	r3, #32
3002d140:	0a000010 	beq	3002d188 <print+0xcc>
			*pbuf++=*name++;
3002d144:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3002d148:	e5d32000 	ldrb	r2, [r3]
3002d14c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3002d150:	e5c32000 	strb	r2, [r3]
3002d154:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3002d158:	e2833001 	add	r3, r3, #1
3002d15c:	e58d3038 	str	r3, [sp, #56]	; 0x38
3002d160:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3002d164:	e2833001 	add	r3, r3, #1
3002d168:	e58d3034 	str	r3, [sp, #52]	; 0x34
		buf[i]=' ';
	buf[37]='\0';
	pbuf=buf;

	name=Rt->Name;
	for(i=0;i<8;i++)
3002d16c:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
3002d170:	e2833001 	add	r3, r3, #1
3002d174:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
3002d178:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
3002d17c:	e3530007 	cmp	r3, #7
3002d180:	9affffeb 	bls	3002d134 <print+0x78>
3002d184:	ea000000 	b	3002d18c <print+0xd0>
	{
		if(*name!=0x20)
			*pbuf++=*name++;
		else
			break;
3002d188:	e1a00000 	nop			; (mov r0, r0)
	}
	name=Rt->Name+8;
3002d18c:	e59d3004 	ldr	r3, [sp, #4]
3002d190:	e2833008 	add	r3, r3, #8
3002d194:	e58d3034 	str	r3, [sp, #52]	; 0x34
	if(*name!=0x20)
3002d198:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3002d19c:	e5d33000 	ldrb	r3, [r3]
3002d1a0:	e3530020 	cmp	r3, #32
3002d1a4:	0a00001e 	beq	3002d224 <print+0x168>
	{
		*pbuf++='.';
3002d1a8:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3002d1ac:	e3a0202e 	mov	r2, #46	; 0x2e
3002d1b0:	e5c32000 	strb	r2, [r3]
3002d1b4:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3002d1b8:	e2833001 	add	r3, r3, #1
3002d1bc:	e58d3038 	str	r3, [sp, #56]	; 0x38
		for(i=0;i<3;i++)
3002d1c0:	e3a03000 	mov	r3, #0
3002d1c4:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
3002d1c8:	ea000010 	b	3002d210 <print+0x154>
		{
			if(*name!=0x20)
3002d1cc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3002d1d0:	e5d33000 	ldrb	r3, [r3]
3002d1d4:	e3530020 	cmp	r3, #32
3002d1d8:	0a000010 	beq	3002d220 <print+0x164>
				*pbuf++=*name++;
3002d1dc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3002d1e0:	e5d32000 	ldrb	r2, [r3]
3002d1e4:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3002d1e8:	e5c32000 	strb	r2, [r3]
3002d1ec:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3002d1f0:	e2833001 	add	r3, r3, #1
3002d1f4:	e58d3038 	str	r3, [sp, #56]	; 0x38
3002d1f8:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3002d1fc:	e2833001 	add	r3, r3, #1
3002d200:	e58d3034 	str	r3, [sp, #52]	; 0x34
	}
	name=Rt->Name+8;
	if(*name!=0x20)
	{
		*pbuf++='.';
		for(i=0;i<3;i++)
3002d204:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
3002d208:	e2833001 	add	r3, r3, #1
3002d20c:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
3002d210:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
3002d214:	e3530002 	cmp	r3, #2
3002d218:	9affffeb 	bls	3002d1cc <print+0x110>
3002d21c:	ea000000 	b	3002d224 <print+0x168>
		{
			if(*name!=0x20)
				*pbuf++=*name++;
			else
				break;
3002d220:	e1a00000 	nop			; (mov r0, r0)
		}
	}
	if(detail)
3002d224:	e5dd3003 	ldrb	r3, [sp, #3]
3002d228:	e3530000 	cmp	r3, #0
3002d22c:	0a000022 	beq	3002d2bc <print+0x200>
	{
		pbuf=buf+13;
3002d230:	e28d300c 	add	r3, sp, #12
3002d234:	e283300d 	add	r3, r3, #13
3002d238:	e58d3038 	str	r3, [sp, #56]	; 0x38
		acoral_sprint(pbuf,16,"%10dBytes",Rt->FileSize);
3002d23c:	e59d3004 	ldr	r3, [sp, #4]
3002d240:	e593301c 	ldr	r3, [r3, #28]
3002d244:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
3002d248:	e3a01010 	mov	r1, #16
3002d24c:	e59f2084 	ldr	r2, [pc, #132]	; 3002d2d8 <print+0x21c>
3002d250:	ebff77e2 	bl	3000b1e0 <acoral_sprint>
		pbuf[15]=' ';
3002d254:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3002d258:	e283300f 	add	r3, r3, #15
3002d25c:	e3a02020 	mov	r2, #32
3002d260:	e5c32000 	strb	r2, [r3]
		pbuf+=18;
3002d264:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3002d268:	e2833012 	add	r3, r3, #18
3002d26c:	e58d3038 	str	r3, [sp, #56]	; 0x38
		name=(Rt->Attr&0x10)?"dir":"file";
3002d270:	e59d3004 	ldr	r3, [sp, #4]
3002d274:	e5d3300b 	ldrb	r3, [r3, #11]
3002d278:	e2033010 	and	r3, r3, #16
3002d27c:	e3530000 	cmp	r3, #0
3002d280:	0a000001 	beq	3002d28c <print+0x1d0>
3002d284:	e59f3050 	ldr	r3, [pc, #80]	; 3002d2dc <print+0x220>
3002d288:	ea000000 	b	3002d290 <print+0x1d4>
3002d28c:	e59f304c 	ldr	r3, [pc, #76]	; 3002d2e0 <print+0x224>
3002d290:	e58d3034 	str	r3, [sp, #52]	; 0x34
		acoral_sprint(pbuf,5,"%s",name);
3002d294:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
3002d298:	e3a01005 	mov	r1, #5
3002d29c:	e59f2040 	ldr	r2, [pc, #64]	; 3002d2e4 <print+0x228>
3002d2a0:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3002d2a4:	ebff77cd 	bl	3000b1e0 <acoral_sprint>
		acoral_print("%s\n",buf);
3002d2a8:	e28d300c 	add	r3, sp, #12
3002d2ac:	e59f0034 	ldr	r0, [pc, #52]	; 3002d2e8 <print+0x22c>
3002d2b0:	e1a01003 	mov	r1, r3
3002d2b4:	ebff77e1 	bl	3000b240 <acoral_print>
3002d2b8:	ea000003 	b	3002d2cc <print+0x210>
	}
	else
	{
		acoral_print("%s\n",buf);
3002d2bc:	e28d300c 	add	r3, sp, #12
3002d2c0:	e59f0020 	ldr	r0, [pc, #32]	; 3002d2e8 <print+0x22c>
3002d2c4:	e1a01003 	mov	r1, r3
3002d2c8:	ebff77dc 	bl	3000b240 <acoral_print>

	}
}
3002d2cc:	e28dd044 	add	sp, sp, #68	; 0x44
3002d2d0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002d2d4:	e12fff1e 	bx	lr
3002d2d8:	30045c64 	.word	0x30045c64
3002d2dc:	30045c70 	.word	0x30045c70
3002d2e0:	30045c74 	.word	0x30045c74
3002d2e4:	30045c7c 	.word	0x30045c7c
3002d2e8:	30045c80 	.word	0x30045c80

3002d2ec <ls_dir>:

void ls_dir(acoral_32 argc,acoral_char **argv)
{
3002d2ec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002d2f0:	e24dd04c 	sub	sp, sp, #76	; 0x4c
3002d2f4:	e58d0004 	str	r0, [sp, #4]
3002d2f8:	e58d1000 	str	r1, [sp]
	acoral_u32 i;
	FDT Rt;
	acoral_u8 Drive;
	acoral_u32 ClusIndex;
	acoral_u8 flag;
	Drive=CurrentDrive;
3002d2fc:	e59f3178 	ldr	r3, [pc, #376]	; 3002d47c <ls_dir+0x190>
3002d300:	e5d33000 	ldrb	r3, [r3]
3002d304:	e5cd303f 	strb	r3, [sp, #63]	; 0x3f
	ClusIndex=DiskInfo[Drive].PathClusIndex;
3002d308:	e5dd203f 	ldrb	r2, [sp, #63]	; 0x3f
3002d30c:	e59f016c 	ldr	r0, [pc, #364]	; 3002d480 <ls_dir+0x194>
3002d310:	e3a01028 	mov	r1, #40	; 0x28
3002d314:	e1a03002 	mov	r3, r2
3002d318:	e1a03083 	lsl	r3, r3, #1
3002d31c:	e0833002 	add	r3, r3, r2
3002d320:	e1a03103 	lsl	r3, r3, #2
3002d324:	e0833002 	add	r3, r3, r2
3002d328:	e1a03103 	lsl	r3, r3, #2
3002d32c:	e0833000 	add	r3, r3, r0
3002d330:	e0833001 	add	r3, r3, r1
3002d334:	e5933000 	ldr	r3, [r3]
3002d338:	e58d3040 	str	r3, [sp, #64]	; 0x40
	flag=0;
3002d33c:	e3a03000 	mov	r3, #0
3002d340:	e5cd3047 	strb	r3, [sp, #71]	; 0x47
	if(argc==2)
3002d344:	e59d3004 	ldr	r3, [sp, #4]
3002d348:	e3530002 	cmp	r3, #2
3002d34c:	1a00000e 	bne	3002d38c <ls_dir+0xa0>
	{
		if(argv[1][0]=='-' && argv[1][1]=='a')
3002d350:	e59d3000 	ldr	r3, [sp]
3002d354:	e2833004 	add	r3, r3, #4
3002d358:	e5933000 	ldr	r3, [r3]
3002d35c:	e5d33000 	ldrb	r3, [r3]
3002d360:	e353002d 	cmp	r3, #45	; 0x2d
3002d364:	1a000008 	bne	3002d38c <ls_dir+0xa0>
3002d368:	e59d3000 	ldr	r3, [sp]
3002d36c:	e2833004 	add	r3, r3, #4
3002d370:	e5933000 	ldr	r3, [r3]
3002d374:	e2833001 	add	r3, r3, #1
3002d378:	e5d33000 	ldrb	r3, [r3]
3002d37c:	e3530061 	cmp	r3, #97	; 0x61
3002d380:	1a000001 	bne	3002d38c <ls_dir+0xa0>
			flag=1;
3002d384:	e3a03001 	mov	r3, #1
3002d388:	e5cd3047 	strb	r3, [sp, #71]	; 0x47
	}

	ret=acoral_mutex_pend(fs_mutex,0);
3002d38c:	e59f30f0 	ldr	r3, [pc, #240]	; 3002d484 <ls_dir+0x198>
3002d390:	e5933000 	ldr	r3, [r3]
3002d394:	e1a00003 	mov	r0, r3
3002d398:	e3a01000 	mov	r1, #0
3002d39c:	ebff5f1d 	bl	30005018 <acoral_mutex_pend>
3002d3a0:	e1a03000 	mov	r3, r0
3002d3a4:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	if(ret!=MUTEX_SUCCED)
3002d3a8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3002d3ac:	e3530000 	cmp	r3, #0
3002d3b0:	1a00002d 	bne	3002d46c <ls_dir+0x180>
		return;
	
	i=0;
3002d3b4:	e3a03000 	mov	r3, #0
3002d3b8:	e58d3038 	str	r3, [sp, #56]	; 0x38
	while(1)
	{
		temp=GetFDTInfo(&Rt,Drive,ClusIndex,i);
3002d3bc:	e28d200c 	add	r2, sp, #12
3002d3c0:	e5dd303f 	ldrb	r3, [sp, #63]	; 0x3f
3002d3c4:	e1a00002 	mov	r0, r2
3002d3c8:	e1a01003 	mov	r1, r3
3002d3cc:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
3002d3d0:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3002d3d4:	ebffe5cb 	bl	30026b08 <GetFDTInfo>
3002d3d8:	e1a03000 	mov	r3, r0
3002d3dc:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
		if(temp!=RETURN_OK)
3002d3e0:	e5dd3037 	ldrb	r3, [sp, #55]	; 0x37
3002d3e4:	e3530000 	cmp	r3, #0
3002d3e8:	1a000013 	bne	3002d43c <ls_dir+0x150>
		{
			break;
		}
		if(Rt.Name[0]==EMPTY_FDT)
3002d3ec:	e5dd300c 	ldrb	r3, [sp, #12]
3002d3f0:	e3530000 	cmp	r3, #0
3002d3f4:	0a000012 	beq	3002d444 <ls_dir+0x158>
		{
			break;
		}
		if(Rt.Name[0]==DEL_FDT)
3002d3f8:	e5dd300c 	ldrb	r3, [sp, #12]
3002d3fc:	e35300e5 	cmp	r3, #229	; 0xe5
3002d400:	1a000004 	bne	3002d418 <ls_dir+0x12c>
		{
			i++;
3002d404:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3002d408:	e2833001 	add	r3, r3, #1
3002d40c:	e58d3038 	str	r3, [sp, #56]	; 0x38
			continue;
3002d410:	e1a00000 	nop			; (mov r0, r0)
		}
		print(&Rt,flag);
		i++;
	}
3002d414:	eaffffe8 	b	3002d3bc <ls_dir+0xd0>
		if(Rt.Name[0]==DEL_FDT)
		{
			i++;
			continue;
		}
		print(&Rt,flag);
3002d418:	e28d200c 	add	r2, sp, #12
3002d41c:	e5dd3047 	ldrb	r3, [sp, #71]	; 0x47
3002d420:	e1a00002 	mov	r0, r2
3002d424:	e1a01003 	mov	r1, r3
3002d428:	ebffff23 	bl	3002d0bc <print>
		i++;
3002d42c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3002d430:	e2833001 	add	r3, r3, #1
3002d434:	e58d3038 	str	r3, [sp, #56]	; 0x38
	}
3002d438:	eaffffdf 	b	3002d3bc <ls_dir+0xd0>
	while(1)
	{
		temp=GetFDTInfo(&Rt,Drive,ClusIndex,i);
		if(temp!=RETURN_OK)
		{
			break;
3002d43c:	e1a00000 	nop			; (mov r0, r0)
3002d440:	ea000000 	b	3002d448 <ls_dir+0x15c>
		}
		if(Rt.Name[0]==EMPTY_FDT)
		{
			break;
3002d444:	e1a00000 	nop			; (mov r0, r0)
		}
		print(&Rt,flag);
		i++;
	}
	
	acoral_mutex_post(fs_mutex);
3002d448:	e59f3034 	ldr	r3, [pc, #52]	; 3002d484 <ls_dir+0x198>
3002d44c:	e5933000 	ldr	r3, [r3]
3002d450:	e1a00003 	mov	r0, r3
3002d454:	ebff5f80 	bl	3000525c <acoral_mutex_post>
	acoral_print("\n%s>",CurrentDirName);
3002d458:	e59f0028 	ldr	r0, [pc, #40]	; 3002d488 <ls_dir+0x19c>
3002d45c:	e59f1028 	ldr	r1, [pc, #40]	; 3002d48c <ls_dir+0x1a0>
3002d460:	ebff7776 	bl	3000b240 <acoral_print>
	return ;	
3002d464:	e1a00000 	nop			; (mov r0, r0)
3002d468:	ea000000 	b	3002d470 <ls_dir+0x184>
			flag=1;
	}

	ret=acoral_mutex_pend(fs_mutex,0);
	if(ret!=MUTEX_SUCCED)
		return;
3002d46c:	e1a00000 	nop			; (mov r0, r0)
	}
	
	acoral_mutex_post(fs_mutex);
	acoral_print("\n%s>",CurrentDirName);
	return ;	
}
3002d470:	e28dd04c 	add	sp, sp, #76	; 0x4c
3002d474:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002d478:	e12fff1e 	bx	lr
3002d47c:	3012b640 	.word	0x3012b640
3002d480:	300eab48 	.word	0x300eab48
3002d484:	3012a80c 	.word	0x3012a80c
3002d488:	30045c84 	.word	0x30045c84
3002d48c:	3012a844 	.word	0x3012a844

3002d490 <mk_dir>:
	"List file/dir in current dir",
	NULL
};

void mk_dir(acoral_32 argc,acoral_char **argv)
{
3002d490:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002d494:	e24dd00c 	sub	sp, sp, #12
3002d498:	e58d0004 	str	r0, [sp, #4]
3002d49c:	e58d1000 	str	r1, [sp]
	if(argc!=2)
3002d4a0:	e59d3004 	ldr	r3, [sp, #4]
3002d4a4:	e3530002 	cmp	r3, #2
3002d4a8:	0a000002 	beq	3002d4b8 <mk_dir+0x28>
	{
		acoral_print("Usage mkdir <Pathname>!\n");
3002d4ac:	e59f002c 	ldr	r0, [pc, #44]	; 3002d4e0 <mk_dir+0x50>
3002d4b0:	ebff7762 	bl	3000b240 <acoral_print>
		return ;
3002d4b4:	ea000006 	b	3002d4d4 <mk_dir+0x44>
	}
	acoral_mkdir(argv[1],0);
3002d4b8:	e59d3000 	ldr	r3, [sp]
3002d4bc:	e2833004 	add	r3, r3, #4
3002d4c0:	e5933000 	ldr	r3, [r3]
3002d4c4:	e1a00003 	mov	r0, r3
3002d4c8:	e3a01000 	mov	r1, #0
3002d4cc:	ebfff7f8 	bl	3002b4b4 <acoral_mkdir>
	acoral_flush();
3002d4d0:	ebfff8b3 	bl	3002b7a4 <acoral_flush>
}
3002d4d4:	e28dd00c 	add	sp, sp, #12
3002d4d8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002d4dc:	e12fff1e 	bx	lr
3002d4e0:	30045cb0 	.word	0x30045cb0

3002d4e4 <rm_dir>:
	"make a dir in current dir",
	NULL
};

void rm_dir(acoral_32 argc,acoral_char **argv)
{
3002d4e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002d4e8:	e24dd014 	sub	sp, sp, #20
3002d4ec:	e58d0004 	str	r0, [sp, #4]
3002d4f0:	e58d1000 	str	r1, [sp]
	acoral_32 ret;
	if(argc!=2)
3002d4f4:	e59d3004 	ldr	r3, [sp, #4]
3002d4f8:	e3530002 	cmp	r3, #2
3002d4fc:	0a000002 	beq	3002d50c <rm_dir+0x28>
	{
		acoral_print("Usage rmdir <Pathname>!\n");
3002d500:	e59f0068 	ldr	r0, [pc, #104]	; 3002d570 <rm_dir+0x8c>
3002d504:	ebff774d 	bl	3000b240 <acoral_print>
		return ;
3002d508:	ea000015 	b	3002d564 <rm_dir+0x80>
	}
	ret=acoral_rmdir(argv[1]);
3002d50c:	e59d3000 	ldr	r3, [sp]
3002d510:	e2833004 	add	r3, r3, #4
3002d514:	e5933000 	ldr	r3, [r3]
3002d518:	e1a00003 	mov	r0, r3
3002d51c:	ebfff824 	bl	3002b5b4 <acoral_rmdir>
3002d520:	e1a03000 	mov	r3, r0
3002d524:	e58d300c 	str	r3, [sp, #12]
	if(ret==-1)
3002d528:	e59d300c 	ldr	r3, [sp, #12]
3002d52c:	e3730001 	cmn	r3, #1
3002d530:	1a00000a 	bne	3002d560 <rm_dir+0x7c>
	{
		acoral_print("delete dir:%s error!\n%s must be empty!\n",argv[1],argv[1]);
3002d534:	e59d3000 	ldr	r3, [sp]
3002d538:	e2833004 	add	r3, r3, #4
3002d53c:	e5932000 	ldr	r2, [r3]
3002d540:	e59d3000 	ldr	r3, [sp]
3002d544:	e2833004 	add	r3, r3, #4
3002d548:	e5933000 	ldr	r3, [r3]
3002d54c:	e59f0020 	ldr	r0, [pc, #32]	; 3002d574 <rm_dir+0x90>
3002d550:	e1a01002 	mov	r1, r2
3002d554:	e1a02003 	mov	r2, r3
3002d558:	ebff7738 	bl	3000b240 <acoral_print>
		return ;
3002d55c:	ea000000 	b	3002d564 <rm_dir+0x80>
	}
	acoral_flush();
3002d560:	ebfff88f 	bl	3002b7a4 <acoral_flush>
}
3002d564:	e28dd014 	add	sp, sp, #20
3002d568:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002d56c:	e12fff1e 	bx	lr
3002d570:	30045cf0 	.word	0x30045cf0
3002d574:	30045d0c 	.word	0x30045d0c

3002d578 <copy_file>:
	NULL
};

static acoral_char tmp[128];
void copy_file(acoral_32 argc,acoral_char **argv)
{
3002d578:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002d57c:	e24dd01c 	sub	sp, sp, #28
3002d580:	e58d0004 	str	r0, [sp, #4]
3002d584:	e58d1000 	str	r1, [sp]
	acoral_32 fd,fd1;
	int ret=0,i;
3002d588:	e3a03000 	mov	r3, #0
3002d58c:	e58d3010 	str	r3, [sp, #16]
	if(argc!=3)
3002d590:	e59d3004 	ldr	r3, [sp, #4]
3002d594:	e3530003 	cmp	r3, #3
3002d598:	0a000002 	beq	3002d5a8 <copy_file+0x30>
	{
		acoral_print("Usage create <srcname> <targetname>!\n");
3002d59c:	e59f00dc 	ldr	r0, [pc, #220]	; 3002d680 <copy_file+0x108>
3002d5a0:	ebff7726 	bl	3000b240 <acoral_print>
		return ;
3002d5a4:	ea000032 	b	3002d674 <copy_file+0xfc>
	}
	fd=acoral_open(argv[1],O_RDONLY);
3002d5a8:	e59d3000 	ldr	r3, [sp]
3002d5ac:	e2833004 	add	r3, r3, #4
3002d5b0:	e5933000 	ldr	r3, [r3]
3002d5b4:	e1a00003 	mov	r0, r3
3002d5b8:	e3a01004 	mov	r1, #4
3002d5bc:	ebfff6c6 	bl	3002b0dc <acoral_open>
3002d5c0:	e1a03000 	mov	r3, r0
3002d5c4:	e58d3008 	str	r3, [sp, #8]
	fd1=acoral_open(argv[2],O_RDWR);
3002d5c8:	e59d3000 	ldr	r3, [sp]
3002d5cc:	e2833008 	add	r3, r3, #8
3002d5d0:	e5933000 	ldr	r3, [r3]
3002d5d4:	e1a00003 	mov	r0, r3
3002d5d8:	e3a01006 	mov	r1, #6
3002d5dc:	ebfff6be 	bl	3002b0dc <acoral_open>
3002d5e0:	e1a03000 	mov	r3, r0
3002d5e4:	e58d300c 	str	r3, [sp, #12]
	if(fd==-1||fd1==-1)
3002d5e8:	e59d3008 	ldr	r3, [sp, #8]
3002d5ec:	e3730001 	cmn	r3, #1
3002d5f0:	0a000002 	beq	3002d600 <copy_file+0x88>
3002d5f4:	e59d300c 	ldr	r3, [sp, #12]
3002d5f8:	e3730001 	cmn	r3, #1
3002d5fc:	1a000006 	bne	3002d61c <copy_file+0xa4>
	{
		acoral_print("copy file:%s error!\n",argv[1]);
3002d600:	e59d3000 	ldr	r3, [sp]
3002d604:	e2833004 	add	r3, r3, #4
3002d608:	e5933000 	ldr	r3, [r3]
3002d60c:	e59f0070 	ldr	r0, [pc, #112]	; 3002d684 <copy_file+0x10c>
3002d610:	e1a01003 	mov	r1, r3
3002d614:	ebff7709 	bl	3000b240 <acoral_print>
		return ;
3002d618:	ea000015 	b	3002d674 <copy_file+0xfc>
	}
	
	do{
		i=acoral_read(fd,tmp,sizeof(tmp));
3002d61c:	e59d0008 	ldr	r0, [sp, #8]
3002d620:	e59f1060 	ldr	r1, [pc, #96]	; 3002d688 <copy_file+0x110>
3002d624:	e3a02080 	mov	r2, #128	; 0x80
3002d628:	ebfff723 	bl	3002b2bc <acoral_read>
3002d62c:	e1a03000 	mov	r3, r0
3002d630:	e58d3014 	str	r3, [sp, #20]
		acoral_write(fd1,tmp,i);
3002d634:	e59d3014 	ldr	r3, [sp, #20]
3002d638:	e59d000c 	ldr	r0, [sp, #12]
3002d63c:	e59f1044 	ldr	r1, [pc, #68]	; 3002d688 <copy_file+0x110>
3002d640:	e1a02003 	mov	r2, r3
3002d644:	ebfff73d 	bl	3002b340 <acoral_write>
		ret+=i;
3002d648:	e59d2010 	ldr	r2, [sp, #16]
3002d64c:	e59d3014 	ldr	r3, [sp, #20]
3002d650:	e0823003 	add	r3, r2, r3
3002d654:	e58d3010 	str	r3, [sp, #16]
	}while(i>0);
3002d658:	e59d3014 	ldr	r3, [sp, #20]
3002d65c:	e3530000 	cmp	r3, #0
3002d660:	caffffed 	bgt	3002d61c <copy_file+0xa4>
	acoral_close(fd);
3002d664:	e59d0008 	ldr	r0, [sp, #8]
3002d668:	ebfff6f0 	bl	3002b230 <acoral_close>
	acoral_close(fd1);
3002d66c:	e59d000c 	ldr	r0, [sp, #12]
3002d670:	ebfff6ee 	bl	3002b230 <acoral_close>
}
3002d674:	e28dd01c 	add	sp, sp, #28
3002d678:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002d67c:	e12fff1e 	bx	lr
3002d680:	30045d58 	.word	0x30045d58
3002d684:	30045d80 	.word	0x30045d80
3002d688:	300e5028 	.word	0x300e5028

3002d68c <create_file>:
	NULL
};


void create_file(acoral_32 argc,acoral_char **argv)
{
3002d68c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002d690:	e24dd014 	sub	sp, sp, #20
3002d694:	e58d0004 	str	r0, [sp, #4]
3002d698:	e58d1000 	str	r1, [sp]
	acoral_32 fd;
	if(argc!=2)
3002d69c:	e59d3004 	ldr	r3, [sp, #4]
3002d6a0:	e3530002 	cmp	r3, #2
3002d6a4:	0a000002 	beq	3002d6b4 <create_file+0x28>
	{
		acoral_print("Usage create <Filename>!\n");
3002d6a8:	e59f0074 	ldr	r0, [pc, #116]	; 3002d724 <create_file+0x98>
3002d6ac:	ebff76e3 	bl	3000b240 <acoral_print>
		return ;
3002d6b0:	ea000018 	b	3002d718 <create_file+0x8c>
	}
	fd=acoral_open(argv[1],O_RDWR);
3002d6b4:	e59d3000 	ldr	r3, [sp]
3002d6b8:	e2833004 	add	r3, r3, #4
3002d6bc:	e5933000 	ldr	r3, [r3]
3002d6c0:	e1a00003 	mov	r0, r3
3002d6c4:	e3a01006 	mov	r1, #6
3002d6c8:	ebfff683 	bl	3002b0dc <acoral_open>
3002d6cc:	e1a03000 	mov	r3, r0
3002d6d0:	e58d300c 	str	r3, [sp, #12]
	if(fd==-1)
3002d6d4:	e59d300c 	ldr	r3, [sp, #12]
3002d6d8:	e3730001 	cmn	r3, #1
3002d6dc:	1a000006 	bne	3002d6fc <create_file+0x70>
	{
		acoral_print("create file:%s error!\n",argv[1]);
3002d6e0:	e59d3000 	ldr	r3, [sp]
3002d6e4:	e2833004 	add	r3, r3, #4
3002d6e8:	e5933000 	ldr	r3, [r3]
3002d6ec:	e59f0034 	ldr	r0, [pc, #52]	; 3002d728 <create_file+0x9c>
3002d6f0:	e1a01003 	mov	r1, r3
3002d6f4:	ebff76d1 	bl	3000b240 <acoral_print>
		return ;
3002d6f8:	ea000006 	b	3002d718 <create_file+0x8c>
	}
	acoral_write(fd,tmp,sizeof(tmp));
3002d6fc:	e59d000c 	ldr	r0, [sp, #12]
3002d700:	e59f1024 	ldr	r1, [pc, #36]	; 3002d72c <create_file+0xa0>
3002d704:	e3a02080 	mov	r2, #128	; 0x80
3002d708:	ebfff70c 	bl	3002b340 <acoral_write>
	acoral_close(fd);
3002d70c:	e59d000c 	ldr	r0, [sp, #12]
3002d710:	ebfff6c6 	bl	3002b230 <acoral_close>
	acoral_flush();	
3002d714:	ebfff822 	bl	3002b7a4 <acoral_flush>
}
3002d718:	e28dd014 	add	sp, sp, #20
3002d71c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002d720:	e12fff1e 	bx	lr
3002d724:	30045db8 	.word	0x30045db8
3002d728:	30045dd4 	.word	0x30045dd4
3002d72c:	300e5028 	.word	0x300e5028

3002d730 <rm_file>:
	"create a file in current dir",
	NULL
};

void rm_file(acoral_32 argc,acoral_char **argv)
{
3002d730:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002d734:	e24dd00c 	sub	sp, sp, #12
3002d738:	e58d0004 	str	r0, [sp, #4]
3002d73c:	e58d1000 	str	r1, [sp]
	if(argc!=2)
3002d740:	e59d3004 	ldr	r3, [sp, #4]
3002d744:	e3530002 	cmp	r3, #2
3002d748:	0a000002 	beq	3002d758 <rm_file+0x28>
	{
		acoral_print("Usage rm <Filename>!\n");
3002d74c:	e59f002c 	ldr	r0, [pc, #44]	; 3002d780 <rm_file+0x50>
3002d750:	ebff76ba 	bl	3000b240 <acoral_print>
		return ;
3002d754:	ea000006 	b	3002d774 <rm_file+0x44>
	}
	acoral_unlink(argv[1]);
3002d758:	e59d3000 	ldr	r3, [sp]
3002d75c:	e2833004 	add	r3, r3, #4
3002d760:	e5933000 	ldr	r3, [r3]
3002d764:	e1a00003 	mov	r0, r3
3002d768:	ebfff61d 	bl	3002afe4 <acoral_unlink>
	acoral_flush();
3002d76c:	ebfff80c 	bl	3002b7a4 <acoral_flush>
	return;
3002d770:	e1a00000 	nop			; (mov r0, r0)
}
3002d774:	e28dd00c 	add	sp, sp, #12
3002d778:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002d77c:	e12fff1e 	bx	lr
3002d780:	30045e14 	.word	0x30045e14

3002d784 <fs_cmd_init>:
	rm_file,
	"delete a file in current dir",
	NULL
};

void fs_cmd_init(){
3002d784:	e92d4008 	push	{r3, lr}
	add_command(&cd_cmd);
3002d788:	e59f0038 	ldr	r0, [pc, #56]	; 3002d7c8 <fs_cmd_init+0x44>
3002d78c:	ebfffb82 	bl	3002c59c <add_command>
	add_command(&ls_cmd);
3002d790:	e59f0034 	ldr	r0, [pc, #52]	; 3002d7cc <fs_cmd_init+0x48>
3002d794:	ebfffb80 	bl	3002c59c <add_command>
	add_command(&mkdir_cmd);
3002d798:	e59f0030 	ldr	r0, [pc, #48]	; 3002d7d0 <fs_cmd_init+0x4c>
3002d79c:	ebfffb7e 	bl	3002c59c <add_command>
	add_command(&rmdir_cmd);
3002d7a0:	e59f002c 	ldr	r0, [pc, #44]	; 3002d7d4 <fs_cmd_init+0x50>
3002d7a4:	ebfffb7c 	bl	3002c59c <add_command>
	add_command(&create_cmd);
3002d7a8:	e59f0028 	ldr	r0, [pc, #40]	; 3002d7d8 <fs_cmd_init+0x54>
3002d7ac:	ebfffb7a 	bl	3002c59c <add_command>
	add_command(&rm_cmd);
3002d7b0:	e59f0024 	ldr	r0, [pc, #36]	; 3002d7dc <fs_cmd_init+0x58>
3002d7b4:	ebfffb78 	bl	3002c59c <add_command>
	add_command(&copy_cmd);
3002d7b8:	e59f0020 	ldr	r0, [pc, #32]	; 3002d7e0 <fs_cmd_init+0x5c>
3002d7bc:	ebfffb76 	bl	3002c59c <add_command>
}
3002d7c0:	e8bd4008 	pop	{r3, lr}
3002d7c4:	e12fff1e 	bx	lr
3002d7c8:	30046720 	.word	0x30046720
3002d7cc:	30046730 	.word	0x30046730
3002d7d0:	30046740 	.word	0x30046740
3002d7d4:	30046750 	.word	0x30046750
3002d7d8:	30046770 	.word	0x30046770
3002d7dc:	30046780 	.word	0x30046780
3002d7e0:	30046760 	.word	0x30046760

3002d7e4 <httpd_thread>:
acoral_u8 g_http_get_string[HTTP_GET_STRING_LEN];

static acoral_u8 httpd_buf[HTTP_GET_STRING_LEN];	
static acoral_char str[HTTP_GET_STRING_LEN];
void httpd_thread(void *arg)
{
3002d7e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002d7e8:	e24dd054 	sub	sp, sp, #84	; 0x54
3002d7ec:	e58d0004 	str	r0, [sp, #4]
	acoral_char *cmd[2]={"get", "post"};
3002d7f0:	e59f2298 	ldr	r2, [pc, #664]	; 3002da90 <httpd_thread+0x2ac>
3002d7f4:	e28d302c 	add	r3, sp, #44	; 0x2c
3002d7f8:	e8920003 	ldm	r2, {r0, r1}
3002d7fc:	e8830003 	stm	r3, {r0, r1}
	acoral_32  len;
	struct sockaddr_in serv, cli;
	acoral_u32 fd;
	acoral_u32 rootlen, pos1, pos2;
	
	rootlen = acoral_str_len(WwwRoot);
3002d800:	e59f328c 	ldr	r3, [pc, #652]	; 3002da94 <httpd_thread+0x2b0>
3002d804:	e5933000 	ldr	r3, [r3]
3002d808:	e1a00003 	mov	r0, r3
3002d80c:	ebff77c9 	bl	3000b738 <acoral_str_len>
3002d810:	e1a03000 	mov	r3, r0
3002d814:	e58d3044 	str	r3, [sp, #68]	; 0x44
	memset(&serv, 0, sizeof(struct sockaddr_in));
3002d818:	e28d3018 	add	r3, sp, #24
3002d81c:	e1a00003 	mov	r0, r3
3002d820:	e3a01000 	mov	r1, #0
3002d824:	e3a02010 	mov	r2, #16
3002d828:	ebff7a8f 	bl	3000c26c <acoral_memset>
	serv.sin_family = AF_INET;
3002d82c:	e3a03002 	mov	r3, #2
3002d830:	e5cd3019 	strb	r3, [sp, #25]
	serv.sin_port = htons(80);	
3002d834:	e3a00050 	mov	r0, #80	; 0x50
3002d838:	ebff9770 	bl	30013600 <htons>
3002d83c:	e1a03000 	mov	r3, r0
3002d840:	e1cd31ba 	strh	r3, [sp, #26]
	serv.sin_addr.s_addr = htons(INADDR_ANY);
3002d844:	e3a00000 	mov	r0, #0
3002d848:	ebff976c 	bl	30013600 <htons>
3002d84c:	e1a03000 	mov	r3, r0
3002d850:	e58d301c 	str	r3, [sp, #28]
	s = socket(AF_INET, SOCK_STREAM, 0);
3002d854:	e3a00002 	mov	r0, #2
3002d858:	e3a01001 	mov	r1, #1
3002d85c:	e3a02000 	mov	r2, #0
3002d860:	ebff8b89 	bl	3001068c <lwip_socket>
3002d864:	e1a03000 	mov	r3, r0
3002d868:	e58d3034 	str	r3, [sp, #52]	; 0x34
	ei = bind(s, (struct sockaddr*)&serv, sizeof(struct sockaddr_in));
3002d86c:	e28d3018 	add	r3, sp, #24
3002d870:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
3002d874:	e1a01003 	mov	r1, r3
3002d878:	e3a02010 	mov	r2, #16
3002d87c:	ebff88a1 	bl	3000fb08 <lwip_bind>
3002d880:	e1a03000 	mov	r3, r0
3002d884:	e58d3038 	str	r3, [sp, #56]	; 0x38
	ei = listen(s, 5);
3002d888:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
3002d88c:	e3a01005 	mov	r1, #5
3002d890:	ebff8952 	bl	3000fde0 <lwip_listen>
3002d894:	e1a03000 	mov	r3, r0
3002d898:	e58d3038 	str	r3, [sp, #56]	; 0x38
	while (1)
	{
		//发送响应报文
		temp = accept(s, (struct sockaddr*)&cli, &len);
3002d89c:	e28d2008 	add	r2, sp, #8
3002d8a0:	e28d3028 	add	r3, sp, #40	; 0x28
3002d8a4:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
3002d8a8:	e1a01002 	mov	r1, r2
3002d8ac:	e1a02003 	mov	r2, r3
3002d8b0:	ebff87ed 	bl	3000f86c <lwip_accept>
3002d8b4:	e1a03000 	mov	r3, r0
3002d8b8:	e58d303c 	str	r3, [sp, #60]	; 0x3c
		if (temp != -1)
3002d8bc:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3002d8c0:	e3730001 	cmn	r3, #1
3002d8c4:	0a00006d 	beq	3002da80 <httpd_thread+0x29c>
		{
			recv(temp, g_http_get_string, HTTP_GET_STRING_LEN-1, 0);
3002d8c8:	e59d003c 	ldr	r0, [sp, #60]	; 0x3c
3002d8cc:	e59f11c4 	ldr	r1, [pc, #452]	; 3002da98 <httpd_thread+0x2b4>
3002d8d0:	e3a02fff 	mov	r2, #1020	; 0x3fc
3002d8d4:	e2822003 	add	r2, r2, #3
3002d8d8:	e3a03000 	mov	r3, #0
3002d8dc:	ebff8aa0 	bl	30010364 <lwip_recv>
			g_http_get_string[HTTP_GET_STRING_LEN-1] = '\0';
3002d8e0:	e59f31b0 	ldr	r3, [pc, #432]	; 3002da98 <httpd_thread+0x2b4>
3002d8e4:	e3a02000 	mov	r2, #0
3002d8e8:	e5c323ff 	strb	r2, [r3, #1023]	; 0x3ff
			
			//分析http报头
			//非get命令
			if (acoral_str_nicmp(g_http_get_string, cmd[0], 3) != 0)
3002d8ec:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3002d8f0:	e59f01a0 	ldr	r0, [pc, #416]	; 3002da98 <httpd_thread+0x2b4>
3002d8f4:	e1a01003 	mov	r1, r3
3002d8f8:	e3a02003 	mov	r2, #3
3002d8fc:	ebff77fd 	bl	3000b8f8 <acoral_str_nicmp>
3002d900:	e1a03000 	mov	r3, r0
3002d904:	e3530000 	cmp	r3, #0
3002d908:	0a000000 	beq	3002d910 <httpd_thread+0x12c>
				continue;
3002d90c:	ea00005e 	b	3002da8c <httpd_thread+0x2a8>
			
			//没有空格分格,未知格式
			pos1 = acoral_str_chr(g_http_get_string, ' ');
3002d910:	e59f0180 	ldr	r0, [pc, #384]	; 3002da98 <httpd_thread+0x2b4>
3002d914:	e3a01020 	mov	r1, #32
3002d918:	ebff7935 	bl	3000bdf4 <acoral_str_chr>
3002d91c:	e1a03000 	mov	r3, r0
3002d920:	e58d3048 	str	r3, [sp, #72]	; 0x48
			if (pos1 == 0)
3002d924:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
3002d928:	e3530000 	cmp	r3, #0
3002d92c:	1a000000 	bne	3002d934 <httpd_thread+0x150>
				continue;
3002d930:	ea000055 	b	3002da8c <httpd_thread+0x2a8>
			
			pos2 = acoral_str_chr(g_http_get_string+pos1, ' ');
3002d934:	e59d2048 	ldr	r2, [sp, #72]	; 0x48
3002d938:	e59f3158 	ldr	r3, [pc, #344]	; 3002da98 <httpd_thread+0x2b4>
3002d93c:	e0823003 	add	r3, r2, r3
3002d940:	e1a00003 	mov	r0, r3
3002d944:	e3a01020 	mov	r1, #32
3002d948:	ebff7929 	bl	3000bdf4 <acoral_str_chr>
3002d94c:	e1a03000 	mov	r3, r0
3002d950:	e58d304c 	str	r3, [sp, #76]	; 0x4c
			if (pos2 == 0)
3002d954:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3002d958:	e3530000 	cmp	r3, #0
3002d95c:	1a000000 	bne	3002d964 <httpd_thread+0x180>
				continue;
3002d960:	ea000049 	b	3002da8c <httpd_thread+0x2a8>
				
			//pos1 与 pos2 之间为申请文件
			acoral_str_cpy(str, WwwRoot);
3002d964:	e59f3128 	ldr	r3, [pc, #296]	; 3002da94 <httpd_thread+0x2b0>
3002d968:	e5933000 	ldr	r3, [r3]
3002d96c:	e59f0128 	ldr	r0, [pc, #296]	; 3002da9c <httpd_thread+0x2b8>
3002d970:	e1a01003 	mov	r1, r3
3002d974:	ebff7788 	bl	3000b79c <acoral_str_cpy>
			//acoral_debugs(g_http_get_string);
			acoral_str_ncpy(&str[rootlen], &g_http_get_string[pos1], pos2-1);
3002d978:	e59d2044 	ldr	r2, [sp, #68]	; 0x44
3002d97c:	e59f3118 	ldr	r3, [pc, #280]	; 3002da9c <httpd_thread+0x2b8>
3002d980:	e0821003 	add	r1, r2, r3
3002d984:	e59d2048 	ldr	r2, [sp, #72]	; 0x48
3002d988:	e59f3108 	ldr	r3, [pc, #264]	; 3002da98 <httpd_thread+0x2b4>
3002d98c:	e0822003 	add	r2, r2, r3
3002d990:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3002d994:	e2433001 	sub	r3, r3, #1
3002d998:	e1a00001 	mov	r0, r1
3002d99c:	e1a01002 	mov	r1, r2
3002d9a0:	e1a02003 	mov	r2, r3
3002d9a4:	ebff7818 	bl	3000ba0c <acoral_str_ncpy>
			str[rootlen+pos2-1] = '\0';
3002d9a8:	e59d2044 	ldr	r2, [sp, #68]	; 0x44
3002d9ac:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3002d9b0:	e0823003 	add	r3, r2, r3
3002d9b4:	e2433001 	sub	r3, r3, #1
3002d9b8:	e59f20dc 	ldr	r2, [pc, #220]	; 3002da9c <httpd_thread+0x2b8>
3002d9bc:	e3a01000 	mov	r1, #0
3002d9c0:	e7c21003 	strb	r1, [r2, r3]
			//acoral_debugs(str);
			if (str[rootlen+pos2-2] == '/')
3002d9c4:	e59d2044 	ldr	r2, [sp, #68]	; 0x44
3002d9c8:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
3002d9cc:	e0823003 	add	r3, r2, r3
3002d9d0:	e2433002 	sub	r3, r3, #2
3002d9d4:	e59f20c0 	ldr	r2, [pc, #192]	; 3002da9c <httpd_thread+0x2b8>
3002d9d8:	e7d23003 	ldrb	r3, [r2, r3]
3002d9dc:	e353002f 	cmp	r3, #47	; 0x2f
3002d9e0:	1a000002 	bne	3002d9f0 <httpd_thread+0x20c>
				acoral_str_cat(str, "index.htm");
3002d9e4:	e59f00b0 	ldr	r0, [pc, #176]	; 3002da9c <httpd_thread+0x2b8>
3002d9e8:	e59f10b0 	ldr	r1, [pc, #176]	; 3002daa0 <httpd_thread+0x2bc>
3002d9ec:	ebff784d 	bl	3000bb28 <acoral_str_cat>
			if(str[rootlen]=='\0')
3002d9f0:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
3002d9f4:	e59f20a0 	ldr	r2, [pc, #160]	; 3002da9c <httpd_thread+0x2b8>
3002d9f8:	e7d23003 	ldrb	r3, [r2, r3]
3002d9fc:	e3530000 	cmp	r3, #0
3002da00:	1a000005 	bne	3002da1c <httpd_thread+0x238>
				acoral_str_cpy(&str[rootlen], "index.htm");
3002da04:	e59d2044 	ldr	r2, [sp, #68]	; 0x44
3002da08:	e59f308c 	ldr	r3, [pc, #140]	; 3002da9c <httpd_thread+0x2b8>
3002da0c:	e0823003 	add	r3, r2, r3
3002da10:	e1a00003 	mov	r0, r3
3002da14:	e59f1084 	ldr	r1, [pc, #132]	; 3002daa0 <httpd_thread+0x2bc>
3002da18:	ebff775f 	bl	3000b79c <acoral_str_cpy>
			fd=acoral_open(str,O_RDONLY); 	
3002da1c:	e59f0078 	ldr	r0, [pc, #120]	; 3002da9c <httpd_thread+0x2b8>
3002da20:	e3a01004 	mov	r1, #4
3002da24:	ebfff5ac 	bl	3002b0dc <acoral_open>
3002da28:	e1a03000 	mov	r3, r0
3002da2c:	e58d3040 	str	r3, [sp, #64]	; 0x40
			while((len=acoral_read(fd, httpd_buf,HTTP_GET_STRING_LEN))>0)
3002da30:	ea000005 	b	3002da4c <httpd_thread+0x268>
				send(temp,httpd_buf, len, 0);
3002da34:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002da38:	e59d003c 	ldr	r0, [sp, #60]	; 0x3c
3002da3c:	e59f1060 	ldr	r1, [pc, #96]	; 3002daa4 <httpd_thread+0x2c0>
3002da40:	e1a02003 	mov	r2, r3
3002da44:	e3a03000 	mov	r3, #0
3002da48:	ebff8a59 	bl	300103b4 <lwip_send>
			if (str[rootlen+pos2-2] == '/')
				acoral_str_cat(str, "index.htm");
			if(str[rootlen]=='\0')
				acoral_str_cpy(&str[rootlen], "index.htm");
			fd=acoral_open(str,O_RDONLY); 	
			while((len=acoral_read(fd, httpd_buf,HTTP_GET_STRING_LEN))>0)
3002da4c:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3002da50:	e1a00003 	mov	r0, r3
3002da54:	e59f1048 	ldr	r1, [pc, #72]	; 3002daa4 <httpd_thread+0x2c0>
3002da58:	e3a02b01 	mov	r2, #1024	; 0x400
3002da5c:	ebfff616 	bl	3002b2bc <acoral_read>
3002da60:	e1a03000 	mov	r3, r0
3002da64:	e58d3028 	str	r3, [sp, #40]	; 0x28
3002da68:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002da6c:	e3530000 	cmp	r3, #0
3002da70:	caffffef 	bgt	3002da34 <httpd_thread+0x250>
				send(temp,httpd_buf, len, 0);
			acoral_close(fd);
3002da74:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3002da78:	e1a00003 	mov	r0, r3
3002da7c:	ebfff5eb 	bl	3002b230 <acoral_close>
		}
		close(temp); 
3002da80:	e59d003c 	ldr	r0, [sp, #60]	; 0x3c
3002da84:	ebff885b 	bl	3000fbf8 <lwip_close>
	}
3002da88:	eaffff83 	b	3002d89c <httpd_thread+0xb8>
3002da8c:	eaffff82 	b	3002d89c <httpd_thread+0xb8>
3002da90:	30045e70 	.word	0x30045e70
3002da94:	30046790 	.word	0x30046790
3002da98:	3012a854 	.word	0x3012a854
3002da9c:	300e54ac 	.word	0x300e54ac
3002daa0:	30045e58 	.word	0x30045e58
3002daa4:	300e50ac 	.word	0x300e50ac

3002daa8 <user_httpd>:
 }

void user_httpd()
{
3002daa8:	e92d4008 	push	{r3, lr}
	acoral_posix_create(NULL,NULL,httpd_thread,0);
3002daac:	e3a00000 	mov	r0, #0
3002dab0:	e3a01000 	mov	r1, #0
3002dab4:	e59f200c 	ldr	r2, [pc, #12]	; 3002dac8 <user_httpd+0x20>
3002dab8:	e3a03000 	mov	r3, #0
3002dabc:	ebff6eb4 	bl	30009594 <acoral_posix_create>
}
3002dac0:	e8bd4008 	pop	{r3, lr}
3002dac4:	e12fff1e 	bx	lr
3002dac8:	3002d7e4 	.word	0x3002d7e4

3002dacc <key_init>:
#define IRQ_EINT4		4

int key_dir = 10;
acoral_evt_t key_eve;

void key_init(void) {
3002dacc:	e92d4008 	push	{r3, lr}
	rGPFCON = rGPFCON & (~((3<<4)|(3<<0)|(3<<8)|(3<<2))) | ((2<<4)|(2<<0)|(2<<8)|(2<<2)) ;		//GPF4,2,1,0 set EINT
3002dad0:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002dad4:	e2833050 	add	r3, r3, #80	; 0x50
3002dad8:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3002dadc:	e2822050 	add	r2, r2, #80	; 0x50
3002dae0:	e5922000 	ldr	r2, [r2]
3002dae4:	e3c22fcf 	bic	r2, r2, #828	; 0x33c
3002dae8:	e3c22003 	bic	r2, r2, #3
3002daec:	e3822f8a 	orr	r2, r2, #552	; 0x228
3002daf0:	e3822002 	orr	r2, r2, #2
3002daf4:	e5832000 	str	r2, [r3]
	rEXTINT0 &= ~(7|(7<<4)|(7<<8)|(7<<16));
3002daf8:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3002dafc:	e2822088 	add	r2, r2, #136	; 0x88
3002db00:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002db04:	e2833088 	add	r3, r3, #136	; 0x88
3002db08:	e5933000 	ldr	r3, [r3]
3002db0c:	e3c33807 	bic	r3, r3, #458752	; 0x70000
3002db10:	e3c33e77 	bic	r3, r3, #1904	; 0x770
3002db14:	e3c33007 	bic	r3, r3, #7
3002db18:	e5823000 	str	r3, [r2]
	rEXTINT0 |= (0|(0<<4)|(0<<8)|(0<<16));		//set eint0,1,2,4 falling edge int
3002db1c:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002db20:	e2833088 	add	r3, r3, #136	; 0x88
3002db24:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3002db28:	e2822088 	add	r2, r2, #136	; 0x88
3002db2c:	e5922000 	ldr	r2, [r2]
3002db30:	e5832000 	str	r2, [r3]

	rEINTPEND |= (1<<4);							//clear eint 4
3002db34:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002db38:	e28330a8 	add	r3, r3, #168	; 0xa8
3002db3c:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3002db40:	e28220a8 	add	r2, r2, #168	; 0xa8
3002db44:	e5922000 	ldr	r2, [r2]
3002db48:	e3822010 	orr	r2, r2, #16
3002db4c:	e5832000 	str	r2, [r3]
	rEINTMASK &= ~(1<<4);						//enable eint 4
3002db50:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002db54:	e28330a4 	add	r3, r3, #164	; 0xa4
3002db58:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3002db5c:	e28220a4 	add	r2, r2, #164	; 0xa4
3002db60:	e5922000 	ldr	r2, [r2]
3002db64:	e3c22010 	bic	r2, r2, #16
3002db68:	e5832000 	str	r2, [r3]
	//ClearPending(BIT_EINT0|BIT_EINT1|BIT_EINT2|BIT_EINT4_7);
	rSRCPND = BIT_EINT0|BIT_EINT1|BIT_EINT2|BIT_EINT4_7;
3002db6c:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002db70:	e3a02017 	mov	r2, #23
3002db74:	e5832000 	str	r2, [r3]
	rINTPND = BIT_EINT0|BIT_EINT1|BIT_EINT2|BIT_EINT4_7;
3002db78:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002db7c:	e2833010 	add	r3, r3, #16
3002db80:	e3a02017 	mov	r2, #23
3002db84:	e5832000 	str	r2, [r3]
	acoral_sem_init(&key_eve, 0);
3002db88:	e59f009c 	ldr	r0, [pc, #156]	; 3002dc2c <key_init+0x160>
3002db8c:	e3a01000 	mov	r1, #0
3002db90:	ebff6636 	bl	30007470 <acoral_sem_init>
	acoral_intr_set_type(IRQ_EINT0,ACORAL_EXPERT_INTR);
3002db94:	e3a00000 	mov	r0, #0
3002db98:	e3a01002 	mov	r1, #2
3002db9c:	ebff59f9 	bl	30004388 <acoral_intr_set_type>
	acoral_intr_attach(IRQ_EINT0,key_scan);
3002dba0:	e59f3088 	ldr	r3, [pc, #136]	; 3002dc30 <key_init+0x164>
3002dba4:	e3a00000 	mov	r0, #0
3002dba8:	e1a01003 	mov	r1, r3
3002dbac:	ebff5874 	bl	30003d84 <acoral_intr_attach>
	acoral_intr_set_type(IRQ_EINT1,ACORAL_EXPERT_INTR);
3002dbb0:	e3a00001 	mov	r0, #1
3002dbb4:	e3a01002 	mov	r1, #2
3002dbb8:	ebff59f2 	bl	30004388 <acoral_intr_set_type>
	acoral_intr_attach(IRQ_EINT1,key_scan);
3002dbbc:	e59f306c 	ldr	r3, [pc, #108]	; 3002dc30 <key_init+0x164>
3002dbc0:	e3a00001 	mov	r0, #1
3002dbc4:	e1a01003 	mov	r1, r3
3002dbc8:	ebff586d 	bl	30003d84 <acoral_intr_attach>
	acoral_intr_set_type(IRQ_EINT2,ACORAL_EXPERT_INTR);
3002dbcc:	e3a00002 	mov	r0, #2
3002dbd0:	e3a01002 	mov	r1, #2
3002dbd4:	ebff59eb 	bl	30004388 <acoral_intr_set_type>
	acoral_intr_attach(IRQ_EINT2,key_scan);
3002dbd8:	e59f3050 	ldr	r3, [pc, #80]	; 3002dc30 <key_init+0x164>
3002dbdc:	e3a00002 	mov	r0, #2
3002dbe0:	e1a01003 	mov	r1, r3
3002dbe4:	ebff5866 	bl	30003d84 <acoral_intr_attach>
	acoral_intr_set_type(IRQ_EINT4,ACORAL_EXPERT_INTR);
3002dbe8:	e3a00004 	mov	r0, #4
3002dbec:	e3a01002 	mov	r1, #2
3002dbf0:	ebff59e4 	bl	30004388 <acoral_intr_set_type>
    acoral_intr_attach(IRQ_EINT4,key_scan);
3002dbf4:	e59f3034 	ldr	r3, [pc, #52]	; 3002dc30 <key_init+0x164>
3002dbf8:	e3a00004 	mov	r0, #4
3002dbfc:	e1a01003 	mov	r1, r3
3002dc00:	ebff585f 	bl	30003d84 <acoral_intr_attach>

	EnableIrq(BIT_EINT0|BIT_EINT1|BIT_EINT2|BIT_EINT4_7);
3002dc04:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dc08:	e2833008 	add	r3, r3, #8
3002dc0c:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
3002dc10:	e2822008 	add	r2, r2, #8
3002dc14:	e5922000 	ldr	r2, [r2]
3002dc18:	e3c22017 	bic	r2, r2, #23
3002dc1c:	e5832000 	str	r2, [r3]
	while(1) {
		acoral_delay_self(200);
3002dc20:	e3a000c8 	mov	r0, #200	; 0xc8
3002dc24:	ebff5356 	bl	30002984 <acoral_delay_self>
				acoral_print("left\n");
			if(key_dir == right)
				acoral_print("right\n");
			key_dir = 10;
		}*/
	}
3002dc28:	eafffffc 	b	3002dc20 <key_init+0x154>
3002dc2c:	3012a820 	.word	0x3012a820
3002dc30:	3002dc34 	.word	0x3002dc34

3002dc34 <key_scan>:
}
void key_scan(void) {
3002dc34:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002dc38:	e24dd00c 	sub	sp, sp, #12
		int i, j;
		DisableIrq(BIT_EINT0|BIT_EINT1|BIT_EINT2|BIT_EINT4_7);
3002dc3c:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dc40:	e2833008 	add	r3, r3, #8
3002dc44:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
3002dc48:	e2822008 	add	r2, r2, #8
3002dc4c:	e5922000 	ldr	r2, [r2]
3002dc50:	e3822017 	orr	r2, r2, #23
3002dc54:	e5832000 	str	r2, [r3]
		if(rINTPND==BIT_EINT1)
3002dc58:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dc5c:	e2833010 	add	r3, r3, #16
3002dc60:	e5933000 	ldr	r3, [r3]
3002dc64:	e3530002 	cmp	r3, #2
3002dc68:	1a00000b 	bne	3002dc9c <key_scan+0x68>
		{
			//Uart_Printf("eint1\n");
			rSRCPND = BIT_EINT1;
3002dc6c:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dc70:	e3a02002 	mov	r2, #2
3002dc74:	e5832000 	str	r2, [r3]
			rINTPND = BIT_EINT1;
3002dc78:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dc7c:	e2833010 	add	r3, r3, #16
3002dc80:	e3a02002 	mov	r2, #2
3002dc84:	e5832000 	str	r2, [r3]
			i = rINTPND;
3002dc88:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dc8c:	e2833010 	add	r3, r3, #16
3002dc90:	e5933000 	ldr	r3, [r3]
3002dc94:	e58d3000 	str	r3, [sp]
3002dc98:	ea000036 	b	3002dd78 <key_scan+0x144>
			//acoral_print("down\n");
		}
		else if(rINTPND==BIT_EINT4_7)
3002dc9c:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dca0:	e2833010 	add	r3, r3, #16
3002dca4:	e5933000 	ldr	r3, [r3]
3002dca8:	e3530010 	cmp	r3, #16
3002dcac:	1a000018 	bne	3002dd14 <key_scan+0xe0>
		{
			 if(rEINTPEND&(1<<4)){
3002dcb0:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002dcb4:	e28330a8 	add	r3, r3, #168	; 0xa8
3002dcb8:	e5933000 	ldr	r3, [r3]
3002dcbc:	e2033010 	and	r3, r3, #16
3002dcc0:	e3530000 	cmp	r3, #0
3002dcc4:	0a000006 	beq	3002dce4 <key_scan+0xb0>
							//Uart_Printf("eint4\n");
				  rEINTPEND |= 1<< 4;
3002dcc8:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002dccc:	e28330a8 	add	r3, r3, #168	; 0xa8
3002dcd0:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3002dcd4:	e28220a8 	add	r2, r2, #168	; 0xa8
3002dcd8:	e5922000 	ldr	r2, [r2]
3002dcdc:	e3822010 	orr	r2, r2, #16
3002dce0:	e5832000 	str	r2, [r3]
				  //acoral_print("up\n");
			}
			rSRCPND = BIT_EINT4_7;
3002dce4:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dce8:	e3a02010 	mov	r2, #16
3002dcec:	e5832000 	str	r2, [r3]
		    rINTPND = BIT_EINT4_7;
3002dcf0:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dcf4:	e2833010 	add	r3, r3, #16
3002dcf8:	e3a02010 	mov	r2, #16
3002dcfc:	e5832000 	str	r2, [r3]
		    i = rINTPND;
3002dd00:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dd04:	e2833010 	add	r3, r3, #16
3002dd08:	e5933000 	ldr	r3, [r3]
3002dd0c:	e58d3000 	str	r3, [sp]
3002dd10:	ea000018 	b	3002dd78 <key_scan+0x144>
		}
		else if(rINTPND==BIT_EINT0)
3002dd14:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dd18:	e2833010 	add	r3, r3, #16
3002dd1c:	e5933000 	ldr	r3, [r3]
3002dd20:	e3530001 	cmp	r3, #1
3002dd24:	1a000007 	bne	3002dd48 <key_scan+0x114>
		{
			//Uart_Printf("eint0\n");
			rSRCPND = BIT_EINT0;
3002dd28:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dd2c:	e3a02001 	mov	r2, #1
3002dd30:	e5832000 	str	r2, [r3]
			rINTPND = BIT_EINT0;
3002dd34:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dd38:	e2833010 	add	r3, r3, #16
3002dd3c:	e3a02001 	mov	r2, #1
3002dd40:	e5832000 	str	r2, [r3]
3002dd44:	ea00000b 	b	3002dd78 <key_scan+0x144>
			//acoral_print("left\n");

		}
		else if(rINTPND==BIT_EINT2)
3002dd48:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dd4c:	e2833010 	add	r3, r3, #16
3002dd50:	e5933000 	ldr	r3, [r3]
3002dd54:	e3530004 	cmp	r3, #4
3002dd58:	1a000006 	bne	3002dd78 <key_scan+0x144>
		{
			//Uart_Printf("eint2\n");
			rSRCPND = BIT_EINT2;
3002dd5c:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dd60:	e3a02004 	mov	r2, #4
3002dd64:	e5832000 	str	r2, [r3]
			rINTPND = BIT_EINT2;
3002dd68:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dd6c:	e2833010 	add	r3, r3, #16
3002dd70:	e3a02004 	mov	r2, #4
3002dd74:	e5832000 	str	r2, [r3]
			//acoral_print("right\n");
		}

		for(i=0; i<1000; i++)
3002dd78:	e3a03000 	mov	r3, #0
3002dd7c:	e58d3000 	str	r3, [sp]
3002dd80:	ea00000d 	b	3002ddbc <key_scan+0x188>
			for(j=0; j<300; j++);
3002dd84:	e3a03000 	mov	r3, #0
3002dd88:	e58d3004 	str	r3, [sp, #4]
3002dd8c:	ea000002 	b	3002dd9c <key_scan+0x168>
3002dd90:	e59d3004 	ldr	r3, [sp, #4]
3002dd94:	e2833001 	add	r3, r3, #1
3002dd98:	e58d3004 	str	r3, [sp, #4]
3002dd9c:	e59d2004 	ldr	r2, [sp, #4]
3002dda0:	e3a03f4a 	mov	r3, #296	; 0x128
3002dda4:	e2833003 	add	r3, r3, #3
3002dda8:	e1520003 	cmp	r2, r3
3002ddac:	dafffff7 	ble	3002dd90 <key_scan+0x15c>
			rSRCPND = BIT_EINT2;
			rINTPND = BIT_EINT2;
			//acoral_print("right\n");
		}

		for(i=0; i<1000; i++)
3002ddb0:	e59d3000 	ldr	r3, [sp]
3002ddb4:	e2833001 	add	r3, r3, #1
3002ddb8:	e58d3000 	str	r3, [sp]
3002ddbc:	e59d2000 	ldr	r2, [sp]
3002ddc0:	e3a03ff9 	mov	r3, #996	; 0x3e4
3002ddc4:	e2833003 	add	r3, r3, #3
3002ddc8:	e1520003 	cmp	r2, r3
3002ddcc:	daffffec 	ble	3002dd84 <key_scan+0x150>
			for(j=0; j<300; j++);
		if((rGPFDAT&(1<< 0)) == 0){
3002ddd0:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002ddd4:	e2833054 	add	r3, r3, #84	; 0x54
3002ddd8:	e5933000 	ldr	r3, [r3]
3002dddc:	e2033001 	and	r3, r3, #1
3002dde0:	e3530000 	cmp	r3, #0
3002dde4:	1a000003 	bne	3002ddf8 <key_scan+0x1c4>
			key_dir = up;
3002dde8:	e59f30c8 	ldr	r3, [pc, #200]	; 3002deb8 <key_scan+0x284>
3002ddec:	e3a02004 	mov	r2, #4
3002ddf0:	e5832000 	str	r2, [r3]
3002ddf4:	ea00001c 	b	3002de6c <key_scan+0x238>
		}
		else if( (rGPFDAT&(1<< 2)) == 0 ){
3002ddf8:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002ddfc:	e2833054 	add	r3, r3, #84	; 0x54
3002de00:	e5933000 	ldr	r3, [r3]
3002de04:	e2033004 	and	r3, r3, #4
3002de08:	e3530000 	cmp	r3, #0
3002de0c:	1a000003 	bne	3002de20 <key_scan+0x1ec>
			key_dir = down;
3002de10:	e59f30a0 	ldr	r3, [pc, #160]	; 3002deb8 <key_scan+0x284>
3002de14:	e3a02001 	mov	r2, #1
3002de18:	e5832000 	str	r2, [r3]
3002de1c:	ea000012 	b	3002de6c <key_scan+0x238>
		}
		else if( (rGPFDAT&(1<<4)) == 0 ){
3002de20:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002de24:	e2833054 	add	r3, r3, #84	; 0x54
3002de28:	e5933000 	ldr	r3, [r3]
3002de2c:	e2033010 	and	r3, r3, #16
3002de30:	e3530000 	cmp	r3, #0
3002de34:	1a000003 	bne	3002de48 <key_scan+0x214>
			key_dir = left;
3002de38:	e59f3078 	ldr	r3, [pc, #120]	; 3002deb8 <key_scan+0x284>
3002de3c:	e3a02000 	mov	r2, #0
3002de40:	e5832000 	str	r2, [r3]
3002de44:	ea000008 	b	3002de6c <key_scan+0x238>
		}
		else if( (rGPFDAT&(1<< 1)) == 0 ){
3002de48:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002de4c:	e2833054 	add	r3, r3, #84	; 0x54
3002de50:	e5933000 	ldr	r3, [r3]
3002de54:	e2033002 	and	r3, r3, #2
3002de58:	e3530000 	cmp	r3, #0
3002de5c:	1a000002 	bne	3002de6c <key_scan+0x238>
			key_dir = right;
3002de60:	e59f3050 	ldr	r3, [pc, #80]	; 3002deb8 <key_scan+0x284>
3002de64:	e3a02002 	mov	r2, #2
3002de68:	e5832000 	str	r2, [r3]
		}
		if(key_dir != 10) {
3002de6c:	e59f3044 	ldr	r3, [pc, #68]	; 3002deb8 <key_scan+0x284>
3002de70:	e5933000 	ldr	r3, [r3]
3002de74:	e353000a 	cmp	r3, #10
3002de78:	0a000004 	beq	3002de90 <key_scan+0x25c>
			key_dir = 10;
3002de7c:	e59f3034 	ldr	r3, [pc, #52]	; 3002deb8 <key_scan+0x284>
3002de80:	e3a0200a 	mov	r2, #10
3002de84:	e5832000 	str	r2, [r3]
			acoral_sem_post(&key_eve);
3002de88:	e59f002c 	ldr	r0, [pc, #44]	; 3002debc <key_scan+0x288>
3002de8c:	ebff6676 	bl	3000786c <acoral_sem_post>
		}
		EnableIrq(BIT_EINT0|BIT_EINT1|BIT_EINT2|BIT_EINT4_7);
3002de90:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002de94:	e2833008 	add	r3, r3, #8
3002de98:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
3002de9c:	e2822008 	add	r2, r2, #8
3002dea0:	e5922000 	ldr	r2, [r2]
3002dea4:	e3c22017 	bic	r2, r2, #23
3002dea8:	e5832000 	str	r2, [r3]
}
3002deac:	e28dd00c 	add	sp, sp, #12
3002deb0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002deb4:	e12fff1e 	bx	lr
3002deb8:	30046794 	.word	0x30046794
3002debc:	3012a820 	.word	0x3012a820

3002dec0 <ClearPending>:
#define LOOP 1
int count=0;
int change = 0;
int xdata, ydata;
__inline void ClearPending(int bit)
{
3002dec0:	e24dd008 	sub	sp, sp, #8
3002dec4:	e58d0004 	str	r0, [sp, #4]
	register i;
	rSRCPND = bit;
3002dec8:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002decc:	e59d2004 	ldr	r2, [sp, #4]
3002ded0:	e5832000 	str	r2, [r3]
	rINTPND = bit;
3002ded4:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002ded8:	e2833010 	add	r3, r3, #16
3002dedc:	e59d2004 	ldr	r2, [sp, #4]
3002dee0:	e5832000 	str	r2, [r3]
	i = rINTPND;
3002dee4:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dee8:	e2833010 	add	r3, r3, #16
3002deec:	e5933000 	ldr	r3, [r3]
}
3002def0:	e28dd008 	add	sp, sp, #8
3002def4:	e12fff1e 	bx	lr

3002def8 <touch_pad_init>:
}*/

acoral_evt_t touch_eve;
void  ts_isr(acoral_vector vector);
void touch_pad_init(void)
{
3002def8:	e92d4008 	push	{r3, lr}
	rADCDLY = (50000);    // ADC Start or Interval Delay
3002defc:	e3a03316 	mov	r3, #1476395008	; 0x58000000
3002df00:	e2833008 	add	r3, r3, #8
3002df04:	e3a02cc3 	mov	r2, #49920	; 0xc300
3002df08:	e2822050 	add	r2, r2, #80	; 0x50
3002df0c:	e5832000 	str	r2, [r3]
	rADCCON = (1<<14)|(ADCPRS<<6)|(0<<3)|(0<<2)|(0<<1)|(0);
3002df10:	e3a02316 	mov	r2, #1476395008	; 0x58000000
3002df14:	e3a03c42 	mov	r3, #16896	; 0x4200
3002df18:	e2833040 	add	r3, r3, #64	; 0x40
3002df1c:	e5823000 	str	r3, [r2]
      // Enable Prescaler,Prescaler,AIN5/7 fix,Normal,Disable read start,No operation
	rADCTSC = (0<<8)|(1<<7)|(1<<6)|(0<<5)|(1<<4)|(0<<3)|(0<<2)|(3);//tark
3002df20:	e3a03316 	mov	r3, #1476395008	; 0x58000000
3002df24:	e2833004 	add	r3, r3, #4
3002df28:	e3a020d3 	mov	r2, #211	; 0xd3
3002df2c:	e5832000 	str	r2, [r3]
      // Down,YM:GND,YP:AIN5,XM:Hi-z,XP:AIN7,XP pullup En,Normal,Waiting for interrupt mode
	acoral_intr_set_type(IRQ_ADC,ACORAL_EXPERT_INTR);
3002df30:	e3a00031 	mov	r0, #49	; 0x31
3002df34:	e3a01002 	mov	r1, #2
3002df38:	ebff5912 	bl	30004388 <acoral_intr_set_type>
	acoral_intr_attach(IRQ_ADC,ts_isr);
3002df3c:	e3a00031 	mov	r0, #49	; 0x31
3002df40:	e59f104c 	ldr	r1, [pc, #76]	; 3002df94 <touch_pad_init+0x9c>
3002df44:	ebff578e 	bl	30003d84 <acoral_intr_attach>
	rINTMSK  &=~(BIT_ADC);
3002df48:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002df4c:	e2833008 	add	r3, r3, #8
3002df50:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
3002df54:	e2822008 	add	r2, r2, #8
3002df58:	e5922000 	ldr	r2, [r2]
3002df5c:	e3c22102 	bic	r2, r2, #-2147483648	; 0x80000000
3002df60:	e5832000 	str	r2, [r3]
	rINTSUBMSK  &=~(BIT_SUB_TC);
3002df64:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002df68:	e283301c 	add	r3, r3, #28
3002df6c:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
3002df70:	e282201c 	add	r2, r2, #28
3002df74:	e5922000 	ldr	r2, [r2]
3002df78:	e3c22c02 	bic	r2, r2, #512	; 0x200
3002df7c:	e5832000 	str	r2, [r3]
	acoral_sem_init(&touch_eve, 0);
3002df80:	e59f0010 	ldr	r0, [pc, #16]	; 3002df98 <touch_pad_init+0xa0>
3002df84:	e3a01000 	mov	r1, #0
3002df88:	ebff6538 	bl	30007470 <acoral_sem_init>
}
3002df8c:	e8bd4008 	pop	{r3, lr}
3002df90:	e12fff1e 	bx	lr
3002df94:	3002df9c 	.word	0x3002df9c
3002df98:	302f7e48 	.word	0x302f7e48

3002df9c <ts_isr>:

static acoral_u8 flag=1;
#define BIT_SUB_ADC		(0x1<<10)
acoral_32 num = 0;
void  ts_isr(acoral_vector vector)
{
3002df9c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002dfa0:	e24dd00c 	sub	sp, sp, #12
3002dfa4:	e58d0004 	str	r0, [sp, #4]

     rINTSUBMSK |= (BIT_SUB_ADC | BIT_SUB_TC);     //Mask sub interrupt (ADC and TC)
3002dfa8:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002dfac:	e283301c 	add	r3, r3, #28
3002dfb0:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
3002dfb4:	e282201c 	add	r2, r2, #28
3002dfb8:	e5922000 	ldr	r2, [r2]
3002dfbc:	e3822c06 	orr	r2, r2, #1536	; 0x600
3002dfc0:	e5832000 	str	r2, [r3]

     //等待中断模式是在触笔落下时产生一个中断，在这种模式下，A/D触摸屏控制寄存器ADCTSC的值应为0xD3，在系统响应中断后，XY坐标的测量模式必须为无操作模式，即寄存器ADCTSC的低两位必须清零
     //寄存器ADCTSC的第3位可以选择上拉电阻的使能，在等待中断模式下，上拉电阻要有效，在触发中断后，上拉电阻要无效
     //Auto X-Position and Y-Position Read
	rADCTSC=(1<<7)|(1<<6)|(0<<5)|(1<<4)|(1<<3)|(1<<2)|(0);
3002dfc4:	e3a03316 	mov	r3, #1476395008	; 0x58000000
3002dfc8:	e2833004 	add	r3, r3, #4
3002dfcc:	e3a020dc 	mov	r2, #220	; 0xdc
3002dfd0:	e5832000 	str	r2, [r3]
          //[7] YM=GND, [6] YP is connected with AIN[5], [5] XM=Hi-Z, [4] XP is connected with AIN[7]
          //[3] XP pull-up disable, [2] Auto(sequential) X/Y position conversion mode, [1:0] No operation mode
	rADCCON |= 0x1;             //Start Auto conversion
3002dfd4:	e3a03316 	mov	r3, #1476395008	; 0x58000000
3002dfd8:	e3a02316 	mov	r2, #1476395008	; 0x58000000
3002dfdc:	e5922000 	ldr	r2, [r2]
3002dfe0:	e3822001 	orr	r2, r2, #1
3002dfe4:	e5832000 	str	r2, [r3]
	while(rADCCON & 0x1);//      //Check if Enable_start is low
3002dfe8:	e3a03316 	mov	r3, #1476395008	; 0x58000000
3002dfec:	e5933000 	ldr	r3, [r3]
3002dff0:	e2033001 	and	r3, r3, #1
3002dff4:	e20330ff 	and	r3, r3, #255	; 0xff
3002dff8:	e3530000 	cmp	r3, #0
3002dffc:	1afffff9 	bne	3002dfe8 <ts_isr+0x4c>
	while(!(0x8000&rADCCON));//   //Check ECFLG
3002e000:	e3a03316 	mov	r3, #1476395008	; 0x58000000
3002e004:	e5933000 	ldr	r3, [r3]
3002e008:	e2033902 	and	r3, r3, #32768	; 0x8000
3002e00c:	e3530000 	cmp	r3, #0
3002e010:	0afffffa 	beq	3002e000 <ts_isr+0x64>

	xdata = (0x3ff&rADCDAT1);
3002e014:	e3a03316 	mov	r3, #1476395008	; 0x58000000
3002e018:	e2833010 	add	r3, r3, #16
3002e01c:	e5933000 	ldr	r3, [r3]
3002e020:	e1a03b03 	lsl	r3, r3, #22
3002e024:	e1a03b23 	lsr	r3, r3, #22
3002e028:	e59f2108 	ldr	r2, [pc, #264]	; 3002e138 <ts_isr+0x19c>
3002e02c:	e5823000 	str	r3, [r2]
	ydata = (0x3ff&rADCDAT0);
3002e030:	e3a03316 	mov	r3, #1476395008	; 0x58000000
3002e034:	e283300c 	add	r3, r3, #12
3002e038:	e5933000 	ldr	r3, [r3]
3002e03c:	e1a03b03 	lsl	r3, r3, #22
3002e040:	e1a03b23 	lsr	r3, r3, #22
3002e044:	e59f20f0 	ldr	r2, [pc, #240]	; 3002e13c <ts_isr+0x1a0>
3002e048:	e5823000 	str	r3, [r2]

    //放手不算一个中断，只有在已经进入中断的情况下，才判断是什么状态

    //当测量完了后，我们接着配置成等待中断模式
    //下面这两句是什么意思呢？就是说，如果这次是相应按下中断，那么下次就是响应弹起中断
	if(flag==2)
3002e04c:	e59f30ec 	ldr	r3, [pc, #236]	; 3002e140 <ts_isr+0x1a4>
3002e050:	e5d33000 	ldrb	r3, [r3]
3002e054:	e3530002 	cmp	r3, #2
3002e058:	1a000007 	bne	3002e07c <ts_isr+0xe0>
	{
		rADCTSC = (0<<8)|(1<<7)|(1<<6)|(0<<5)|(1<<4)|(0<<3)|(0<<2)|(3);
3002e05c:	e3a03316 	mov	r3, #1476395008	; 0x58000000
3002e060:	e2833004 	add	r3, r3, #4
3002e064:	e3a020d3 	mov	r2, #211	; 0xd3
3002e068:	e5832000 	str	r2, [r3]
	//[7] YM=GND, [6] YP is connected with AIN[5], [5] XM=Hi-Z, [4] XP is connected with AIN[7]
      //[3] XP pull-up enable, [2] Normal ADC conversion, [1:0] Waiting for interrupt mode
		flag =1;
3002e06c:	e59f30cc 	ldr	r3, [pc, #204]	; 3002e140 <ts_isr+0x1a4>
3002e070:	e3a02001 	mov	r2, #1
3002e074:	e5c32000 	strb	r2, [r3]
3002e078:	ea000007 	b	3002e09c <ts_isr+0x100>
	}
	else
	{
		rADCTSC = (1<<8)|(1<<7)|(1<<6)|(0<<5)|(1<<4)|(0<<3)|(0<<2)|(3);
3002e07c:	e3a03316 	mov	r3, #1476395008	; 0x58000000
3002e080:	e2833004 	add	r3, r3, #4
3002e084:	e3a02e1d 	mov	r2, #464	; 0x1d0
3002e088:	e2822003 	add	r2, r2, #3
3002e08c:	e5832000 	str	r2, [r3]
		flag =2;
3002e090:	e59f30a8 	ldr	r3, [pc, #168]	; 3002e140 <ts_isr+0x1a4>
3002e094:	e3a02002 	mov	r2, #2
3002e098:	e5c32000 	strb	r2, [r3]
	}

    //相应的位为1表示已经请求，清0表示没有请求，我们就是要它没有请求，这样就能接受新的请求了
    //怎么感觉这里错了啊，应该是清源啊，这里是或的话，就讲相应的位置1了啊，那不是接着又有请求了吗。
    //有大大的问题，调试看看.
	rSUBSRCPND |= BIT_SUB_TC;
3002e09c:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002e0a0:	e2833018 	add	r3, r3, #24
3002e0a4:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
3002e0a8:	e2822018 	add	r2, r2, #24
3002e0ac:	e5922000 	ldr	r2, [r2]
3002e0b0:	e3822c02 	orr	r2, r2, #512	; 0x200
3002e0b4:	e5832000 	str	r2, [r3]
	// rSUBSRCPND &=~(BIT_SUB_TC);
	//子屏蔽寄存器，置1表示屏蔽，清0表示接受中断，下面的语句表示打开触摸屏中断
	rINTSUBMSK  &=~(BIT_SUB_TC);   //Unmask sub interrupt (TC)
3002e0b8:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002e0bc:	e283301c 	add	r3, r3, #28
3002e0c0:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
3002e0c4:	e282201c 	add	r2, r2, #28
3002e0c8:	e5922000 	ldr	r2, [r2]
3002e0cc:	e3c22c02 	bic	r2, r2, #512	; 0x200
3002e0d0:	e5832000 	str	r2, [r3]
	//感觉这个函数也不是清除中断源，感觉刚好相反
	rSRCPND = BIT_ADC;
3002e0d4:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002e0d8:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
3002e0dc:	e5832000 	str	r2, [r3]
	rINTPND = BIT_ADC;
3002e0e0:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3002e0e4:	e2833010 	add	r3, r3, #16
3002e0e8:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
3002e0ec:	e5832000 	str	r2, [r3]
	//num ++;
	//if(num == 2) {
		//num = 0;
	//}
	//else
	if(xdata!=0 && ydata!=0) {
3002e0f0:	e59f3040 	ldr	r3, [pc, #64]	; 3002e138 <ts_isr+0x19c>
3002e0f4:	e5933000 	ldr	r3, [r3]
3002e0f8:	e3530000 	cmp	r3, #0
3002e0fc:	0a00000a 	beq	3002e12c <ts_isr+0x190>
3002e100:	e59f3034 	ldr	r3, [pc, #52]	; 3002e13c <ts_isr+0x1a0>
3002e104:	e5933000 	ldr	r3, [r3]
3002e108:	e3530000 	cmp	r3, #0
3002e10c:	0a000006 	beq	3002e12c <ts_isr+0x190>
		if(acoral_sem_getnum(&touch_eve) <= 0)
3002e110:	e59f002c 	ldr	r0, [pc, #44]	; 3002e144 <ts_isr+0x1a8>
3002e114:	ebff6616 	bl	30007974 <acoral_sem_getnum>
3002e118:	e1a03000 	mov	r3, r0
3002e11c:	e3530000 	cmp	r3, #0
3002e120:	0a000001 	beq	3002e12c <ts_isr+0x190>
			acoral_sem_post(&touch_eve);
3002e124:	e59f0018 	ldr	r0, [pc, #24]	; 3002e144 <ts_isr+0x1a8>
3002e128:	ebff65cf 	bl	3000786c <acoral_sem_post>
	}
}
3002e12c:	e28dd00c 	add	sp, sp, #12
3002e130:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002e134:	e12fff1e 	bx	lr
3002e138:	301f57a4 	.word	0x301f57a4
3002e13c:	301f5938 	.word	0x301f5938
3002e140:	30046798 	.word	0x30046798
3002e144:	302f7e48 	.word	0x302f7e48

3002e148 <Lcd_Init>:
TFT LCD功能模块初始化
**************************************************************/

void Lcd_Init(void)
{
	rGPCUP  = 0x00000000;
3002e148:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002e14c:	e2833028 	add	r3, r3, #40	; 0x28
3002e150:	e3a02000 	mov	r2, #0
3002e154:	e5832000 	str	r2, [r3]
	rGPCCON = 0xaaaa02a9;
3002e158:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002e15c:	e2833020 	add	r3, r3, #32
3002e160:	e59f2138 	ldr	r2, [pc, #312]	; 3002e2a0 <Lcd_Init+0x158>
3002e164:	e5832000 	str	r2, [r3]

	rGPDUP  = 0x00000000;
3002e168:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002e16c:	e2833038 	add	r3, r3, #56	; 0x38
3002e170:	e3a02000 	mov	r2, #0
3002e174:	e5832000 	str	r2, [r3]
	rGPDCON=0xaaaaaaaa; //Initialize VD[15:8]
3002e178:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3002e17c:	e2822030 	add	r2, r2, #48	; 0x30
3002e180:	e3a03caa 	mov	r3, #43520	; 0xaa00
3002e184:	e28330aa 	add	r3, r3, #170	; 0xaa
3002e188:	e1833803 	orr	r3, r3, r3, lsl #16
3002e18c:	e5823000 	str	r3, [r2]

	rLCDCON1=(CLKVAL_TFT<<8)|(MVAL_USED<<7)|(3<<5)|(12<<1)|0;
3002e190:	e3a0244d 	mov	r2, #1291845632	; 0x4d000000
3002e194:	e3a03e47 	mov	r3, #1136	; 0x470
3002e198:	e2833008 	add	r3, r3, #8
3002e19c:	e5823000 	str	r3, [r2]
    	// TFT LCD panel,12bpp TFT,ENVID=off
	rLCDCON2=(VBPD<<24)|(LINEVAL_TFT<<14)|(VFPD<<6)|(VSPW);
3002e1a0:	e3a0244d 	mov	r2, #1291845632	; 0x4d000000
3002e1a4:	e2822004 	add	r2, r2, #4
3002e1a8:	e3a03509 	mov	r3, #37748736	; 0x2400000
3002e1ac:	e283390f 	add	r3, r3, #245760	; 0x3c000
3002e1b0:	e2833f42 	add	r3, r3, #264	; 0x108
3002e1b4:	e5823000 	str	r3, [r2]
	rLCDCON3=(HBPD<<19)|(HOZVAL_TFT<<8)|(HFPD);
3002e1b8:	e3a0244d 	mov	r2, #1291845632	; 0x4d000000
3002e1bc:	e2822008 	add	r2, r2, #8
3002e1c0:	e3a03851 	mov	r3, #5308416	; 0x510000
3002e1c4:	e2833cdf 	add	r3, r3, #57088	; 0xdf00
3002e1c8:	e2833013 	add	r3, r3, #19
3002e1cc:	e5823000 	str	r3, [r2]
	rLCDCON4=(MVAL<<8)|(HSPW);
3002e1d0:	e3a0344d 	mov	r3, #1291845632	; 0x4d000000
3002e1d4:	e283300c 	add	r3, r3, #12
3002e1d8:	e3a02ed1 	mov	r2, #3344	; 0xd10
3002e1dc:	e282200e 	add	r2, r2, #14
3002e1e0:	e5832000 	str	r2, [r3]
	rLCDCON5 = (1<<11) | (0<<10) | (1<<9) | (1<<8) | (0<<7) | (0<<6) | (1<<3)  |(BSWP<<1) | (HWSWP);
3002e1e4:	e3a0344d 	mov	r3, #1291845632	; 0x4d000000
3002e1e8:	e2833010 	add	r3, r3, #16
3002e1ec:	e3a02c0b 	mov	r2, #2816	; 0xb00
3002e1f0:	e2822009 	add	r2, r2, #9
3002e1f4:	e5832000 	str	r2, [r3]

	rLCDSADDR1=(((unsigned int)LCD_BUFFER>>22)<<21)|M5D((unsigned int)LCD_BUFFER>>1);
3002e1f8:	e3a0344d 	mov	r3, #1291845632	; 0x4d000000
3002e1fc:	e2833014 	add	r3, r3, #20
3002e200:	e59f209c 	ldr	r2, [pc, #156]	; 3002e2a4 <Lcd_Init+0x15c>
3002e204:	e1a02b22 	lsr	r2, r2, #22
3002e208:	e1a01a82 	lsl	r1, r2, #21
3002e20c:	e59f2090 	ldr	r2, [pc, #144]	; 3002e2a4 <Lcd_Init+0x15c>
3002e210:	e1a020a2 	lsr	r2, r2, #1
3002e214:	e3c224ff 	bic	r2, r2, #-16777216	; 0xff000000
3002e218:	e3c2260e 	bic	r2, r2, #14680064	; 0xe00000
3002e21c:	e1812002 	orr	r2, r1, r2
3002e220:	e5832000 	str	r2, [r3]
	rLCDSADDR2=M5D( ((unsigned int)LCD_BUFFER+(SCR_XSIZE_TFT*LCD_YSIZE_TFT*2))>>1 );
3002e224:	e3a0344d 	mov	r3, #1291845632	; 0x4d000000
3002e228:	e2833018 	add	r3, r3, #24
3002e22c:	e59f2070 	ldr	r2, [pc, #112]	; 3002e2a4 <Lcd_Init+0x15c>
3002e230:	e2822bff 	add	r2, r2, #261120	; 0x3fc00
3002e234:	e1a020a2 	lsr	r2, r2, #1
3002e238:	e3c224ff 	bic	r2, r2, #-16777216	; 0xff000000
3002e23c:	e3c2260e 	bic	r2, r2, #14680064	; 0xe00000
3002e240:	e5832000 	str	r2, [r3]
	rLCDSADDR3=(((SCR_XSIZE_TFT-LCD_XSIZE_TFT)/1)<<11)|(LCD_XSIZE_TFT/1);
3002e244:	e3a0344d 	mov	r3, #1291845632	; 0x4d000000
3002e248:	e283301c 	add	r3, r3, #28
3002e24c:	e3a02e1e 	mov	r2, #480	; 0x1e0
3002e250:	e5832000 	str	r2, [r3]
	rLCDINTMSK|=(3); // MASK LCD Sub Interrupt
3002e254:	e3a0344d 	mov	r3, #1291845632	; 0x4d000000
3002e258:	e283305c 	add	r3, r3, #92	; 0x5c
3002e25c:	e3a0244d 	mov	r2, #1291845632	; 0x4d000000
3002e260:	e282205c 	add	r2, r2, #92	; 0x5c
3002e264:	e5922000 	ldr	r2, [r2]
3002e268:	e3822003 	orr	r2, r2, #3
3002e26c:	e5832000 	str	r2, [r3]
	rTCONSEL &= (~7) ;     // Disable LPC3480
3002e270:	e3a0344d 	mov	r3, #1291845632	; 0x4d000000
3002e274:	e2833060 	add	r3, r3, #96	; 0x60
3002e278:	e3a0244d 	mov	r2, #1291845632	; 0x4d000000
3002e27c:	e2822060 	add	r2, r2, #96	; 0x60
3002e280:	e5922000 	ldr	r2, [r2]
3002e284:	e3c22007 	bic	r2, r2, #7
3002e288:	e5832000 	str	r2, [r3]
	rTPAL=0; // Disable Temp Palette
3002e28c:	e3a0344d 	mov	r3, #1291845632	; 0x4d000000
3002e290:	e2833050 	add	r3, r3, #80	; 0x50
3002e294:	e3a02000 	mov	r2, #0
3002e298:	e5832000 	str	r2, [r3]
}
3002e29c:	e12fff1e 	bx	lr
3002e2a0:	aaaa02a9 	.word	0xaaaa02a9
3002e2a4:	300eabe4 	.word	0x300eabe4

3002e2a8 <Lcd_EnvidOnOff>:

/**************************************************************
LCD视频和控制信号输出或者停止，1开启视频输出
**************************************************************/
void Lcd_EnvidOnOff(int onoff)
{
3002e2a8:	e24dd008 	sub	sp, sp, #8
3002e2ac:	e58d0004 	str	r0, [sp, #4]
	if(onoff==1)
3002e2b0:	e59d3004 	ldr	r3, [sp, #4]
3002e2b4:	e3530001 	cmp	r3, #1
3002e2b8:	1a000005 	bne	3002e2d4 <Lcd_EnvidOnOff+0x2c>
		rLCDCON1|=1; // ENVID=ON
3002e2bc:	e3a0344d 	mov	r3, #1291845632	; 0x4d000000
3002e2c0:	e3a0244d 	mov	r2, #1291845632	; 0x4d000000
3002e2c4:	e5922000 	ldr	r2, [r2]
3002e2c8:	e3822001 	orr	r2, r2, #1
3002e2cc:	e5832000 	str	r2, [r3]
3002e2d0:	ea000005 	b	3002e2ec <Lcd_EnvidOnOff+0x44>
	else
		rLCDCON1 =rLCDCON1 & 0x3fffe; // ENVID Off
3002e2d4:	e3a0244d 	mov	r2, #1291845632	; 0x4d000000
3002e2d8:	e3a0344d 	mov	r3, #1291845632	; 0x4d000000
3002e2dc:	e5933000 	ldr	r3, [r3]
3002e2e0:	e3c3337f 	bic	r3, r3, #-67108863	; 0xfc000001
3002e2e4:	e3c337ff 	bic	r3, r3, #66846720	; 0x3fc0000
3002e2e8:	e5823000 	str	r3, [r2]
}
3002e2ec:	e28dd008 	add	sp, sp, #8
3002e2f0:	e12fff1e 	bx	lr

3002e2f4 <Lcd_PowerEnable>:

/**************************************************************
TFT LCD 电源控制引脚使能
**************************************************************/
void Lcd_PowerEnable(int invpwren,int pwren)
{
3002e2f4:	e24dd008 	sub	sp, sp, #8
3002e2f8:	e58d0004 	str	r0, [sp, #4]
3002e2fc:	e58d1000 	str	r1, [sp]
	//GPG4 is setted as LCD_PWREN
	rGPGUP=rGPGUP&(~(1<<4))|(1<<4); // Pull-up disable
3002e300:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002e304:	e2833068 	add	r3, r3, #104	; 0x68
3002e308:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3002e30c:	e2822068 	add	r2, r2, #104	; 0x68
3002e310:	e5922000 	ldr	r2, [r2]
3002e314:	e3822010 	orr	r2, r2, #16
3002e318:	e5832000 	str	r2, [r3]
	rGPGCON=rGPGCON&(~(3<<8))|(3<<8); //GPG4=LCD_PWREN
3002e31c:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002e320:	e2833060 	add	r3, r3, #96	; 0x60
3002e324:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3002e328:	e2822060 	add	r2, r2, #96	; 0x60
3002e32c:	e5922000 	ldr	r2, [r2]
3002e330:	e3822c03 	orr	r2, r2, #768	; 0x300
3002e334:	e5832000 	str	r2, [r3]
	rGPGDAT = rGPGDAT | (1<<4) ;
3002e338:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3002e33c:	e2833064 	add	r3, r3, #100	; 0x64
3002e340:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3002e344:	e2822064 	add	r2, r2, #100	; 0x64
3002e348:	e5922000 	ldr	r2, [r2]
3002e34c:	e3822010 	orr	r2, r2, #16
3002e350:	e5832000 	str	r2, [r3]
	//invpwren=pwren;
	//Enable LCD POWER ENABLE Function
	rLCDCON5=rLCDCON5&(~(1<<3))|(pwren<<3);   // PWREN
3002e354:	e3a0344d 	mov	r3, #1291845632	; 0x4d000000
3002e358:	e2833010 	add	r3, r3, #16
3002e35c:	e3a0244d 	mov	r2, #1291845632	; 0x4d000000
3002e360:	e2822010 	add	r2, r2, #16
3002e364:	e5922000 	ldr	r2, [r2]
3002e368:	e3c21008 	bic	r1, r2, #8
3002e36c:	e59d2000 	ldr	r2, [sp]
3002e370:	e1a02182 	lsl	r2, r2, #3
3002e374:	e1812002 	orr	r2, r1, r2
3002e378:	e5832000 	str	r2, [r3]
	rLCDCON5=rLCDCON5&(~(1<<5))|(invpwren<<5);   // INVPWREN
3002e37c:	e3a0344d 	mov	r3, #1291845632	; 0x4d000000
3002e380:	e2833010 	add	r3, r3, #16
3002e384:	e3a0244d 	mov	r2, #1291845632	; 0x4d000000
3002e388:	e2822010 	add	r2, r2, #16
3002e38c:	e5922000 	ldr	r2, [r2]
3002e390:	e3c21020 	bic	r1, r2, #32
3002e394:	e59d2004 	ldr	r2, [sp, #4]
3002e398:	e1a02282 	lsl	r2, r2, #5
3002e39c:	e1812002 	orr	r2, r1, r2
3002e3a0:	e5832000 	str	r2, [r3]
}
3002e3a4:	e28dd008 	add	sp, sp, #8
3002e3a8:	e12fff1e 	bx	lr

3002e3ac <Lcd_MoveViewPort>:

/**************************************************************
TFT LCD移动观察窗口
**************************************************************/
void Lcd_MoveViewPort(int vx,int vy)
{
3002e3ac:	e24dd008 	sub	sp, sp, #8
3002e3b0:	e58d0004 	str	r0, [sp, #4]
3002e3b4:	e58d1000 	str	r1, [sp]
	return;
}
3002e3b8:	e28dd008 	add	sp, sp, #8
3002e3bc:	e12fff1e 	bx	lr

3002e3c0 <MoveViewPort>:
TFT LCD移动观察窗口
**************************************************************/
void MoveViewPort(void)
{
	return;
}
3002e3c0:	e12fff1e 	bx	lr

3002e3c4 <PutPixel>:

/**************************************************************
TFT LCD单个象素的显示数据输出
**************************************************************/
void PutPixel(unsigned int x,unsigned int y, unsigned int c )
{
3002e3c4:	e24dd010 	sub	sp, sp, #16
3002e3c8:	e58d000c 	str	r0, [sp, #12]
3002e3cc:	e58d1008 	str	r1, [sp, #8]
3002e3d0:	e58d2004 	str	r2, [sp, #4]
	if ( (x < SCR_XSIZE_TFT) && (y < SCR_YSIZE_TFT) )
3002e3d4:	e59d200c 	ldr	r2, [sp, #12]
3002e3d8:	e3a03f77 	mov	r3, #476	; 0x1dc
3002e3dc:	e2833003 	add	r3, r3, #3
3002e3e0:	e1520003 	cmp	r2, r3
3002e3e4:	8a000012 	bhi	3002e434 <PutPixel+0x70>
3002e3e8:	e59d2008 	ldr	r2, [sp, #8]
3002e3ec:	e3a03f43 	mov	r3, #268	; 0x10c
3002e3f0:	e2833003 	add	r3, r3, #3
3002e3f4:	e1520003 	cmp	r2, r3
3002e3f8:	8a00000d 	bhi	3002e434 <PutPixel+0x70>
		LCD_BUFFER[(y)][(x)] = c;
3002e3fc:	e59d2008 	ldr	r2, [sp, #8]
3002e400:	e59dc00c 	ldr	ip, [sp, #12]
3002e404:	e59d3004 	ldr	r3, [sp, #4]
3002e408:	e1a03803 	lsl	r3, r3, #16
3002e40c:	e1a01823 	lsr	r1, r3, #16
3002e410:	e59f0024 	ldr	r0, [pc, #36]	; 3002e43c <PutPixel+0x78>
3002e414:	e1a03002 	mov	r3, r2
3002e418:	e1a03203 	lsl	r3, r3, #4
3002e41c:	e0623003 	rsb	r3, r2, r3
3002e420:	e1a03283 	lsl	r3, r3, #5
3002e424:	e083300c 	add	r3, r3, ip
3002e428:	e1a03083 	lsl	r3, r3, #1
3002e42c:	e0833000 	add	r3, r3, r0
3002e430:	e1c310b0 	strh	r1, [r3]
}
3002e434:	e28dd010 	add	sp, sp, #16
3002e438:	e12fff1e 	bx	lr
3002e43c:	300eabe4 	.word	0x300eabe4

3002e440 <Lcd_ClearScr>:

/**************************************************************
TFT LCD全屏填充特定颜色单元或清屏
**************************************************************/
void Lcd_ClearScr( unsigned int c)
{
3002e440:	e24dd010 	sub	sp, sp, #16
3002e444:	e58d0004 	str	r0, [sp, #4]
	unsigned int x,y ;

    for( y = 0 ; y < SCR_YSIZE_TFT ; y++ )
3002e448:	e3a03000 	mov	r3, #0
3002e44c:	e58d300c 	str	r3, [sp, #12]
3002e450:	ea00001b 	b	3002e4c4 <Lcd_ClearScr+0x84>
    {
    	for( x = 0 ; x < SCR_XSIZE_TFT ; x++ )
3002e454:	e3a03000 	mov	r3, #0
3002e458:	e58d3008 	str	r3, [sp, #8]
3002e45c:	ea000010 	b	3002e4a4 <Lcd_ClearScr+0x64>
    	{
			LCD_BUFFER[y][x] = c ;
3002e460:	e59d200c 	ldr	r2, [sp, #12]
3002e464:	e59dc008 	ldr	ip, [sp, #8]
3002e468:	e59d3004 	ldr	r3, [sp, #4]
3002e46c:	e1a03803 	lsl	r3, r3, #16
3002e470:	e1a01823 	lsr	r1, r3, #16
3002e474:	e59f0064 	ldr	r0, [pc, #100]	; 3002e4e0 <Lcd_ClearScr+0xa0>
3002e478:	e1a03002 	mov	r3, r2
3002e47c:	e1a03203 	lsl	r3, r3, #4
3002e480:	e0623003 	rsb	r3, r2, r3
3002e484:	e1a03283 	lsl	r3, r3, #5
3002e488:	e083300c 	add	r3, r3, ip
3002e48c:	e1a03083 	lsl	r3, r3, #1
3002e490:	e0833000 	add	r3, r3, r0
3002e494:	e1c310b0 	strh	r1, [r3]
{
	unsigned int x,y ;

    for( y = 0 ; y < SCR_YSIZE_TFT ; y++ )
    {
    	for( x = 0 ; x < SCR_XSIZE_TFT ; x++ )
3002e498:	e59d3008 	ldr	r3, [sp, #8]
3002e49c:	e2833001 	add	r3, r3, #1
3002e4a0:	e58d3008 	str	r3, [sp, #8]
3002e4a4:	e59d2008 	ldr	r2, [sp, #8]
3002e4a8:	e3a03f77 	mov	r3, #476	; 0x1dc
3002e4ac:	e2833003 	add	r3, r3, #3
3002e4b0:	e1520003 	cmp	r2, r3
3002e4b4:	9affffe9 	bls	3002e460 <Lcd_ClearScr+0x20>
**************************************************************/
void Lcd_ClearScr( unsigned int c)
{
	unsigned int x,y ;

    for( y = 0 ; y < SCR_YSIZE_TFT ; y++ )
3002e4b8:	e59d300c 	ldr	r3, [sp, #12]
3002e4bc:	e2833001 	add	r3, r3, #1
3002e4c0:	e58d300c 	str	r3, [sp, #12]
3002e4c4:	e59d200c 	ldr	r2, [sp, #12]
3002e4c8:	e3a03f43 	mov	r3, #268	; 0x10c
3002e4cc:	e2833003 	add	r3, r3, #3
3002e4d0:	e1520003 	cmp	r2, r3
3002e4d4:	9affffde 	bls	3002e454 <Lcd_ClearScr+0x14>
    	for( x = 0 ; x < SCR_XSIZE_TFT ; x++ )
    	{
			LCD_BUFFER[y][x] = c ;
    	}
    }
}
3002e4d8:	e28dd010 	add	sp, sp, #16
3002e4dc:	e12fff1e 	bx	lr
3002e4e0:	300eabe4 	.word	0x300eabe4

3002e4e4 <Glib_Line>:
//  --+--   <-8 octants  mathematical cordinate
//   5 I 8
//   6I7
**************************************************************/
void Glib_Line(int x1,int y1,int x2,int y2,int color)
{
3002e4e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002e4e8:	e24dd024 	sub	sp, sp, #36	; 0x24
3002e4ec:	e58d000c 	str	r0, [sp, #12]
3002e4f0:	e58d1008 	str	r1, [sp, #8]
3002e4f4:	e58d2004 	str	r2, [sp, #4]
3002e4f8:	e58d3000 	str	r3, [sp]
	int dx,dy,e;
	dx=x2-x1;
3002e4fc:	e59d2004 	ldr	r2, [sp, #4]
3002e500:	e59d300c 	ldr	r3, [sp, #12]
3002e504:	e0633002 	rsb	r3, r3, r2
3002e508:	e58d3014 	str	r3, [sp, #20]
	dy=y2-y1;
3002e50c:	e59d2000 	ldr	r2, [sp]
3002e510:	e59d3008 	ldr	r3, [sp, #8]
3002e514:	e0633002 	rsb	r3, r3, r2
3002e518:	e58d3018 	str	r3, [sp, #24]

	if(dx>=0)
3002e51c:	e59d3014 	ldr	r3, [sp, #20]
3002e520:	e3530000 	cmp	r3, #0
3002e524:	ba0000a1 	blt	3002e7b0 <Glib_Line+0x2cc>
	{
		if(dy >= 0) // dy>=0
3002e528:	e59d3018 	ldr	r3, [sp, #24]
3002e52c:	e3530000 	cmp	r3, #0
3002e530:	ba00004d 	blt	3002e66c <Glib_Line+0x188>
		{
			if(dx>=dy) // 1/8 octant
3002e534:	e59d2014 	ldr	r2, [sp, #20]
3002e538:	e59d3018 	ldr	r3, [sp, #24]
3002e53c:	e1520003 	cmp	r2, r3
3002e540:	ba000024 	blt	3002e5d8 <Glib_Line+0xf4>
			{
				e=dy-dx/2;
3002e544:	e59d3014 	ldr	r3, [sp, #20]
3002e548:	e1a02fa3 	lsr	r2, r3, #31
3002e54c:	e0823003 	add	r3, r2, r3
3002e550:	e1a030c3 	asr	r3, r3, #1
3002e554:	e59d2018 	ldr	r2, [sp, #24]
3002e558:	e0633002 	rsb	r3, r3, r2
3002e55c:	e58d301c 	str	r3, [sp, #28]
				while(x1<=x2)
3002e560:	ea000017 	b	3002e5c4 <Glib_Line+0xe0>
				{
					PutPixel(x1,y1,color);
3002e564:	e59d100c 	ldr	r1, [sp, #12]
3002e568:	e59d2008 	ldr	r2, [sp, #8]
3002e56c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002e570:	e1a00001 	mov	r0, r1
3002e574:	e1a01002 	mov	r1, r2
3002e578:	e1a02003 	mov	r2, r3
3002e57c:	ebffff90 	bl	3002e3c4 <PutPixel>
					if(e>0){y1+=1;e-=dx;}
3002e580:	e59d301c 	ldr	r3, [sp, #28]
3002e584:	e3530000 	cmp	r3, #0
3002e588:	da000006 	ble	3002e5a8 <Glib_Line+0xc4>
3002e58c:	e59d3008 	ldr	r3, [sp, #8]
3002e590:	e2833001 	add	r3, r3, #1
3002e594:	e58d3008 	str	r3, [sp, #8]
3002e598:	e59d201c 	ldr	r2, [sp, #28]
3002e59c:	e59d3014 	ldr	r3, [sp, #20]
3002e5a0:	e0633002 	rsb	r3, r3, r2
3002e5a4:	e58d301c 	str	r3, [sp, #28]
					x1+=1;
3002e5a8:	e59d300c 	ldr	r3, [sp, #12]
3002e5ac:	e2833001 	add	r3, r3, #1
3002e5b0:	e58d300c 	str	r3, [sp, #12]
					e+=dy;
3002e5b4:	e59d201c 	ldr	r2, [sp, #28]
3002e5b8:	e59d3018 	ldr	r3, [sp, #24]
3002e5bc:	e0823003 	add	r3, r2, r3
3002e5c0:	e58d301c 	str	r3, [sp, #28]
		if(dy >= 0) // dy>=0
		{
			if(dx>=dy) // 1/8 octant
			{
				e=dy-dx/2;
				while(x1<=x2)
3002e5c4:	e59d200c 	ldr	r2, [sp, #12]
3002e5c8:	e59d3004 	ldr	r3, [sp, #4]
3002e5cc:	e1520003 	cmp	r2, r3
3002e5d0:	daffffe3 	ble	3002e564 <Glib_Line+0x80>
				}
			}
			else		// 7/8 octant
			{
				e=dx-dy/2;
				while(y1>=y2)
3002e5d4:	ea000119 	b	3002ea40 <Glib_Line+0x55c>
					e+=dy;
				}
			}
			else		// 2/8 octant
			{
				e=dx-dy/2;
3002e5d8:	e59d3018 	ldr	r3, [sp, #24]
3002e5dc:	e1a02fa3 	lsr	r2, r3, #31
3002e5e0:	e0823003 	add	r3, r2, r3
3002e5e4:	e1a030c3 	asr	r3, r3, #1
3002e5e8:	e59d2014 	ldr	r2, [sp, #20]
3002e5ec:	e0633002 	rsb	r3, r3, r2
3002e5f0:	e58d301c 	str	r3, [sp, #28]
				while(y1<=y2)
3002e5f4:	ea000017 	b	3002e658 <Glib_Line+0x174>
				{
					PutPixel(x1,y1,color);
3002e5f8:	e59d100c 	ldr	r1, [sp, #12]
3002e5fc:	e59d2008 	ldr	r2, [sp, #8]
3002e600:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002e604:	e1a00001 	mov	r0, r1
3002e608:	e1a01002 	mov	r1, r2
3002e60c:	e1a02003 	mov	r2, r3
3002e610:	ebffff6b 	bl	3002e3c4 <PutPixel>
					if(e>0){x1+=1;e-=dy;}
3002e614:	e59d301c 	ldr	r3, [sp, #28]
3002e618:	e3530000 	cmp	r3, #0
3002e61c:	da000006 	ble	3002e63c <Glib_Line+0x158>
3002e620:	e59d300c 	ldr	r3, [sp, #12]
3002e624:	e2833001 	add	r3, r3, #1
3002e628:	e58d300c 	str	r3, [sp, #12]
3002e62c:	e59d201c 	ldr	r2, [sp, #28]
3002e630:	e59d3018 	ldr	r3, [sp, #24]
3002e634:	e0633002 	rsb	r3, r3, r2
3002e638:	e58d301c 	str	r3, [sp, #28]
					y1+=1;
3002e63c:	e59d3008 	ldr	r3, [sp, #8]
3002e640:	e2833001 	add	r3, r3, #1
3002e644:	e58d3008 	str	r3, [sp, #8]
					e+=dx;
3002e648:	e59d201c 	ldr	r2, [sp, #28]
3002e64c:	e59d3014 	ldr	r3, [sp, #20]
3002e650:	e0823003 	add	r3, r2, r3
3002e654:	e58d301c 	str	r3, [sp, #28]
				}
			}
			else		// 2/8 octant
			{
				e=dx-dy/2;
				while(y1<=y2)
3002e658:	e59d2008 	ldr	r2, [sp, #8]
3002e65c:	e59d3000 	ldr	r3, [sp]
3002e660:	e1520003 	cmp	r2, r3
3002e664:	daffffe3 	ble	3002e5f8 <Glib_Line+0x114>
				}
			}
			else		// 7/8 octant
			{
				e=dx-dy/2;
				while(y1>=y2)
3002e668:	ea0000f4 	b	3002ea40 <Glib_Line+0x55c>
				}
			}
		}
		else		   // dy<0
		{
			dy=-dy;   // dy=abs(dy)
3002e66c:	e59d3018 	ldr	r3, [sp, #24]
3002e670:	e2633000 	rsb	r3, r3, #0
3002e674:	e58d3018 	str	r3, [sp, #24]

			if(dx>=dy) // 8/8 octant
3002e678:	e59d2014 	ldr	r2, [sp, #20]
3002e67c:	e59d3018 	ldr	r3, [sp, #24]
3002e680:	e1520003 	cmp	r2, r3
3002e684:	ba000024 	blt	3002e71c <Glib_Line+0x238>
			{
				e=dy-dx/2;
3002e688:	e59d3014 	ldr	r3, [sp, #20]
3002e68c:	e1a02fa3 	lsr	r2, r3, #31
3002e690:	e0823003 	add	r3, r2, r3
3002e694:	e1a030c3 	asr	r3, r3, #1
3002e698:	e59d2018 	ldr	r2, [sp, #24]
3002e69c:	e0633002 	rsb	r3, r3, r2
3002e6a0:	e58d301c 	str	r3, [sp, #28]
				while(x1<=x2)
3002e6a4:	ea000017 	b	3002e708 <Glib_Line+0x224>
				{
					PutPixel(x1,y1,color);
3002e6a8:	e59d100c 	ldr	r1, [sp, #12]
3002e6ac:	e59d2008 	ldr	r2, [sp, #8]
3002e6b0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002e6b4:	e1a00001 	mov	r0, r1
3002e6b8:	e1a01002 	mov	r1, r2
3002e6bc:	e1a02003 	mov	r2, r3
3002e6c0:	ebffff3f 	bl	3002e3c4 <PutPixel>
					if(e>0){y1-=1;e-=dx;}
3002e6c4:	e59d301c 	ldr	r3, [sp, #28]
3002e6c8:	e3530000 	cmp	r3, #0
3002e6cc:	da000006 	ble	3002e6ec <Glib_Line+0x208>
3002e6d0:	e59d3008 	ldr	r3, [sp, #8]
3002e6d4:	e2433001 	sub	r3, r3, #1
3002e6d8:	e58d3008 	str	r3, [sp, #8]
3002e6dc:	e59d201c 	ldr	r2, [sp, #28]
3002e6e0:	e59d3014 	ldr	r3, [sp, #20]
3002e6e4:	e0633002 	rsb	r3, r3, r2
3002e6e8:	e58d301c 	str	r3, [sp, #28]
					x1+=1;
3002e6ec:	e59d300c 	ldr	r3, [sp, #12]
3002e6f0:	e2833001 	add	r3, r3, #1
3002e6f4:	e58d300c 	str	r3, [sp, #12]
					e+=dy;
3002e6f8:	e59d201c 	ldr	r2, [sp, #28]
3002e6fc:	e59d3018 	ldr	r3, [sp, #24]
3002e700:	e0823003 	add	r3, r2, r3
3002e704:	e58d301c 	str	r3, [sp, #28]
			dy=-dy;   // dy=abs(dy)

			if(dx>=dy) // 8/8 octant
			{
				e=dy-dx/2;
				while(x1<=x2)
3002e708:	e59d200c 	ldr	r2, [sp, #12]
3002e70c:	e59d3004 	ldr	r3, [sp, #4]
3002e710:	e1520003 	cmp	r2, r3
3002e714:	daffffe3 	ble	3002e6a8 <Glib_Line+0x1c4>
				}
			}
			else		// 7/8 octant
			{
				e=dx-dy/2;
				while(y1>=y2)
3002e718:	ea0000c8 	b	3002ea40 <Glib_Line+0x55c>
					e+=dy;
				}
			}
			else		// 7/8 octant
			{
				e=dx-dy/2;
3002e71c:	e59d3018 	ldr	r3, [sp, #24]
3002e720:	e1a02fa3 	lsr	r2, r3, #31
3002e724:	e0823003 	add	r3, r2, r3
3002e728:	e1a030c3 	asr	r3, r3, #1
3002e72c:	e59d2014 	ldr	r2, [sp, #20]
3002e730:	e0633002 	rsb	r3, r3, r2
3002e734:	e58d301c 	str	r3, [sp, #28]
				while(y1>=y2)
3002e738:	ea000017 	b	3002e79c <Glib_Line+0x2b8>
				{
					PutPixel(x1,y1,color);
3002e73c:	e59d100c 	ldr	r1, [sp, #12]
3002e740:	e59d2008 	ldr	r2, [sp, #8]
3002e744:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002e748:	e1a00001 	mov	r0, r1
3002e74c:	e1a01002 	mov	r1, r2
3002e750:	e1a02003 	mov	r2, r3
3002e754:	ebffff1a 	bl	3002e3c4 <PutPixel>
					if(e>0){x1+=1;e-=dy;}
3002e758:	e59d301c 	ldr	r3, [sp, #28]
3002e75c:	e3530000 	cmp	r3, #0
3002e760:	da000006 	ble	3002e780 <Glib_Line+0x29c>
3002e764:	e59d300c 	ldr	r3, [sp, #12]
3002e768:	e2833001 	add	r3, r3, #1
3002e76c:	e58d300c 	str	r3, [sp, #12]
3002e770:	e59d201c 	ldr	r2, [sp, #28]
3002e774:	e59d3018 	ldr	r3, [sp, #24]
3002e778:	e0633002 	rsb	r3, r3, r2
3002e77c:	e58d301c 	str	r3, [sp, #28]
					y1-=1;
3002e780:	e59d3008 	ldr	r3, [sp, #8]
3002e784:	e2433001 	sub	r3, r3, #1
3002e788:	e58d3008 	str	r3, [sp, #8]
					e+=dx;
3002e78c:	e59d201c 	ldr	r2, [sp, #28]
3002e790:	e59d3014 	ldr	r3, [sp, #20]
3002e794:	e0823003 	add	r3, r2, r3
3002e798:	e58d301c 	str	r3, [sp, #28]
				}
			}
			else		// 7/8 octant
			{
				e=dx-dy/2;
				while(y1>=y2)
3002e79c:	e59d2008 	ldr	r2, [sp, #8]
3002e7a0:	e59d3000 	ldr	r3, [sp]
3002e7a4:	e1520003 	cmp	r2, r3
3002e7a8:	aaffffe3 	bge	3002e73c <Glib_Line+0x258>
3002e7ac:	ea0000a3 	b	3002ea40 <Glib_Line+0x55c>
			}
		}
	}
	else //dx<0
	{
		dx=-dx;		//dx=abs(dx)
3002e7b0:	e59d3014 	ldr	r3, [sp, #20]
3002e7b4:	e2633000 	rsb	r3, r3, #0
3002e7b8:	e58d3014 	str	r3, [sp, #20]
		if(dy >= 0) // dy>=0
3002e7bc:	e59d3018 	ldr	r3, [sp, #24]
3002e7c0:	e3530000 	cmp	r3, #0
3002e7c4:	ba00004d 	blt	3002e900 <Glib_Line+0x41c>
		{
			if(dx>=dy) // 4/8 octant
3002e7c8:	e59d2014 	ldr	r2, [sp, #20]
3002e7cc:	e59d3018 	ldr	r3, [sp, #24]
3002e7d0:	e1520003 	cmp	r2, r3
3002e7d4:	ba000024 	blt	3002e86c <Glib_Line+0x388>
			{
				e=dy-dx/2;
3002e7d8:	e59d3014 	ldr	r3, [sp, #20]
3002e7dc:	e1a02fa3 	lsr	r2, r3, #31
3002e7e0:	e0823003 	add	r3, r2, r3
3002e7e4:	e1a030c3 	asr	r3, r3, #1
3002e7e8:	e59d2018 	ldr	r2, [sp, #24]
3002e7ec:	e0633002 	rsb	r3, r3, r2
3002e7f0:	e58d301c 	str	r3, [sp, #28]
				while(x1>=x2)
3002e7f4:	ea000017 	b	3002e858 <Glib_Line+0x374>
				{
					PutPixel(x1,y1,color);
3002e7f8:	e59d100c 	ldr	r1, [sp, #12]
3002e7fc:	e59d2008 	ldr	r2, [sp, #8]
3002e800:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002e804:	e1a00001 	mov	r0, r1
3002e808:	e1a01002 	mov	r1, r2
3002e80c:	e1a02003 	mov	r2, r3
3002e810:	ebfffeeb 	bl	3002e3c4 <PutPixel>
					if(e>0){y1+=1;e-=dx;}
3002e814:	e59d301c 	ldr	r3, [sp, #28]
3002e818:	e3530000 	cmp	r3, #0
3002e81c:	da000006 	ble	3002e83c <Glib_Line+0x358>
3002e820:	e59d3008 	ldr	r3, [sp, #8]
3002e824:	e2833001 	add	r3, r3, #1
3002e828:	e58d3008 	str	r3, [sp, #8]
3002e82c:	e59d201c 	ldr	r2, [sp, #28]
3002e830:	e59d3014 	ldr	r3, [sp, #20]
3002e834:	e0633002 	rsb	r3, r3, r2
3002e838:	e58d301c 	str	r3, [sp, #28]
					x1-=1;
3002e83c:	e59d300c 	ldr	r3, [sp, #12]
3002e840:	e2433001 	sub	r3, r3, #1
3002e844:	e58d300c 	str	r3, [sp, #12]
					e+=dy;
3002e848:	e59d201c 	ldr	r2, [sp, #28]
3002e84c:	e59d3018 	ldr	r3, [sp, #24]
3002e850:	e0823003 	add	r3, r2, r3
3002e854:	e58d301c 	str	r3, [sp, #28]
		if(dy >= 0) // dy>=0
		{
			if(dx>=dy) // 4/8 octant
			{
				e=dy-dx/2;
				while(x1>=x2)
3002e858:	e59d200c 	ldr	r2, [sp, #12]
3002e85c:	e59d3004 	ldr	r3, [sp, #4]
3002e860:	e1520003 	cmp	r2, r3
3002e864:	aaffffe3 	bge	3002e7f8 <Glib_Line+0x314>
				}
			}
			else		// 3/8 octant
			{
				e=dx-dy/2;
				while(y1<=y2)
3002e868:	ea000074 	b	3002ea40 <Glib_Line+0x55c>
					e+=dy;
				}
			}
			else		// 3/8 octant
			{
				e=dx-dy/2;
3002e86c:	e59d3018 	ldr	r3, [sp, #24]
3002e870:	e1a02fa3 	lsr	r2, r3, #31
3002e874:	e0823003 	add	r3, r2, r3
3002e878:	e1a030c3 	asr	r3, r3, #1
3002e87c:	e59d2014 	ldr	r2, [sp, #20]
3002e880:	e0633002 	rsb	r3, r3, r2
3002e884:	e58d301c 	str	r3, [sp, #28]
				while(y1<=y2)
3002e888:	ea000017 	b	3002e8ec <Glib_Line+0x408>
				{
					PutPixel(x1,y1,color);
3002e88c:	e59d100c 	ldr	r1, [sp, #12]
3002e890:	e59d2008 	ldr	r2, [sp, #8]
3002e894:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002e898:	e1a00001 	mov	r0, r1
3002e89c:	e1a01002 	mov	r1, r2
3002e8a0:	e1a02003 	mov	r2, r3
3002e8a4:	ebfffec6 	bl	3002e3c4 <PutPixel>
					if(e>0){x1-=1;e-=dy;}
3002e8a8:	e59d301c 	ldr	r3, [sp, #28]
3002e8ac:	e3530000 	cmp	r3, #0
3002e8b0:	da000006 	ble	3002e8d0 <Glib_Line+0x3ec>
3002e8b4:	e59d300c 	ldr	r3, [sp, #12]
3002e8b8:	e2433001 	sub	r3, r3, #1
3002e8bc:	e58d300c 	str	r3, [sp, #12]
3002e8c0:	e59d201c 	ldr	r2, [sp, #28]
3002e8c4:	e59d3018 	ldr	r3, [sp, #24]
3002e8c8:	e0633002 	rsb	r3, r3, r2
3002e8cc:	e58d301c 	str	r3, [sp, #28]
					y1+=1;
3002e8d0:	e59d3008 	ldr	r3, [sp, #8]
3002e8d4:	e2833001 	add	r3, r3, #1
3002e8d8:	e58d3008 	str	r3, [sp, #8]
					e+=dx;
3002e8dc:	e59d201c 	ldr	r2, [sp, #28]
3002e8e0:	e59d3014 	ldr	r3, [sp, #20]
3002e8e4:	e0823003 	add	r3, r2, r3
3002e8e8:	e58d301c 	str	r3, [sp, #28]
				}
			}
			else		// 3/8 octant
			{
				e=dx-dy/2;
				while(y1<=y2)
3002e8ec:	e59d2008 	ldr	r2, [sp, #8]
3002e8f0:	e59d3000 	ldr	r3, [sp]
3002e8f4:	e1520003 	cmp	r2, r3
3002e8f8:	daffffe3 	ble	3002e88c <Glib_Line+0x3a8>
3002e8fc:	ea00004f 	b	3002ea40 <Glib_Line+0x55c>
				}
			}
		}
		else		   // dy<0
		{
			dy=-dy;   // dy=abs(dy)
3002e900:	e59d3018 	ldr	r3, [sp, #24]
3002e904:	e2633000 	rsb	r3, r3, #0
3002e908:	e58d3018 	str	r3, [sp, #24]

			if(dx>=dy) // 5/8 octant
3002e90c:	e59d2014 	ldr	r2, [sp, #20]
3002e910:	e59d3018 	ldr	r3, [sp, #24]
3002e914:	e1520003 	cmp	r2, r3
3002e918:	ba000024 	blt	3002e9b0 <Glib_Line+0x4cc>
			{
				e=dy-dx/2;
3002e91c:	e59d3014 	ldr	r3, [sp, #20]
3002e920:	e1a02fa3 	lsr	r2, r3, #31
3002e924:	e0823003 	add	r3, r2, r3
3002e928:	e1a030c3 	asr	r3, r3, #1
3002e92c:	e59d2018 	ldr	r2, [sp, #24]
3002e930:	e0633002 	rsb	r3, r3, r2
3002e934:	e58d301c 	str	r3, [sp, #28]
				while(x1>=x2)
3002e938:	ea000017 	b	3002e99c <Glib_Line+0x4b8>
				{
					PutPixel(x1,y1,color);
3002e93c:	e59d100c 	ldr	r1, [sp, #12]
3002e940:	e59d2008 	ldr	r2, [sp, #8]
3002e944:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002e948:	e1a00001 	mov	r0, r1
3002e94c:	e1a01002 	mov	r1, r2
3002e950:	e1a02003 	mov	r2, r3
3002e954:	ebfffe9a 	bl	3002e3c4 <PutPixel>
					if(e>0){y1-=1;e-=dx;}
3002e958:	e59d301c 	ldr	r3, [sp, #28]
3002e95c:	e3530000 	cmp	r3, #0
3002e960:	da000006 	ble	3002e980 <Glib_Line+0x49c>
3002e964:	e59d3008 	ldr	r3, [sp, #8]
3002e968:	e2433001 	sub	r3, r3, #1
3002e96c:	e58d3008 	str	r3, [sp, #8]
3002e970:	e59d201c 	ldr	r2, [sp, #28]
3002e974:	e59d3014 	ldr	r3, [sp, #20]
3002e978:	e0633002 	rsb	r3, r3, r2
3002e97c:	e58d301c 	str	r3, [sp, #28]
					x1-=1;
3002e980:	e59d300c 	ldr	r3, [sp, #12]
3002e984:	e2433001 	sub	r3, r3, #1
3002e988:	e58d300c 	str	r3, [sp, #12]
					e+=dy;
3002e98c:	e59d201c 	ldr	r2, [sp, #28]
3002e990:	e59d3018 	ldr	r3, [sp, #24]
3002e994:	e0823003 	add	r3, r2, r3
3002e998:	e58d301c 	str	r3, [sp, #28]
			dy=-dy;   // dy=abs(dy)

			if(dx>=dy) // 5/8 octant
			{
				e=dy-dx/2;
				while(x1>=x2)
3002e99c:	e59d200c 	ldr	r2, [sp, #12]
3002e9a0:	e59d3004 	ldr	r3, [sp, #4]
3002e9a4:	e1520003 	cmp	r2, r3
3002e9a8:	aaffffe3 	bge	3002e93c <Glib_Line+0x458>
3002e9ac:	ea000023 	b	3002ea40 <Glib_Line+0x55c>
					e+=dy;
				}
			}
			else		// 6/8 octant
			{
				e=dx-dy/2;
3002e9b0:	e59d3018 	ldr	r3, [sp, #24]
3002e9b4:	e1a02fa3 	lsr	r2, r3, #31
3002e9b8:	e0823003 	add	r3, r2, r3
3002e9bc:	e1a030c3 	asr	r3, r3, #1
3002e9c0:	e59d2014 	ldr	r2, [sp, #20]
3002e9c4:	e0633002 	rsb	r3, r3, r2
3002e9c8:	e58d301c 	str	r3, [sp, #28]
				while(y1>=y2)
3002e9cc:	ea000017 	b	3002ea30 <Glib_Line+0x54c>
				{
					PutPixel(x1,y1,color);
3002e9d0:	e59d100c 	ldr	r1, [sp, #12]
3002e9d4:	e59d2008 	ldr	r2, [sp, #8]
3002e9d8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002e9dc:	e1a00001 	mov	r0, r1
3002e9e0:	e1a01002 	mov	r1, r2
3002e9e4:	e1a02003 	mov	r2, r3
3002e9e8:	ebfffe75 	bl	3002e3c4 <PutPixel>
					if(e>0){x1-=1;e-=dy;}
3002e9ec:	e59d301c 	ldr	r3, [sp, #28]
3002e9f0:	e3530000 	cmp	r3, #0
3002e9f4:	da000006 	ble	3002ea14 <Glib_Line+0x530>
3002e9f8:	e59d300c 	ldr	r3, [sp, #12]
3002e9fc:	e2433001 	sub	r3, r3, #1
3002ea00:	e58d300c 	str	r3, [sp, #12]
3002ea04:	e59d201c 	ldr	r2, [sp, #28]
3002ea08:	e59d3018 	ldr	r3, [sp, #24]
3002ea0c:	e0633002 	rsb	r3, r3, r2
3002ea10:	e58d301c 	str	r3, [sp, #28]
					y1-=1;
3002ea14:	e59d3008 	ldr	r3, [sp, #8]
3002ea18:	e2433001 	sub	r3, r3, #1
3002ea1c:	e58d3008 	str	r3, [sp, #8]
					e+=dx;
3002ea20:	e59d201c 	ldr	r2, [sp, #28]
3002ea24:	e59d3014 	ldr	r3, [sp, #20]
3002ea28:	e0823003 	add	r3, r2, r3
3002ea2c:	e58d301c 	str	r3, [sp, #28]
				}
			}
			else		// 6/8 octant
			{
				e=dx-dy/2;
				while(y1>=y2)
3002ea30:	e59d2008 	ldr	r2, [sp, #8]
3002ea34:	e59d3000 	ldr	r3, [sp]
3002ea38:	e1520003 	cmp	r2, r3
3002ea3c:	aaffffe3 	bge	3002e9d0 <Glib_Line+0x4ec>
					e+=dx;
				}
			}
		}
	}
}
3002ea40:	e28dd024 	add	sp, sp, #36	; 0x24
3002ea44:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002ea48:	e12fff1e 	bx	lr

3002ea4c <Glib_Rectangle>:

/**************************************************************
在LCD屏幕上画一个矩形
**************************************************************/
void Glib_Rectangle(int x1,int y1,int x2,int y2,int color)
{
3002ea4c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002ea50:	e24dd01c 	sub	sp, sp, #28
3002ea54:	e58d0014 	str	r0, [sp, #20]
3002ea58:	e58d1010 	str	r1, [sp, #16]
3002ea5c:	e58d200c 	str	r2, [sp, #12]
3002ea60:	e58d3008 	str	r3, [sp, #8]
    Glib_Line(x1,y1,x2,y1,color);
3002ea64:	e59d3020 	ldr	r3, [sp, #32]
3002ea68:	e58d3000 	str	r3, [sp]
3002ea6c:	e59d0014 	ldr	r0, [sp, #20]
3002ea70:	e59d1010 	ldr	r1, [sp, #16]
3002ea74:	e59d200c 	ldr	r2, [sp, #12]
3002ea78:	e59d3010 	ldr	r3, [sp, #16]
3002ea7c:	ebfffe98 	bl	3002e4e4 <Glib_Line>
    Glib_Line(x2,y1,x2,y2,color);
3002ea80:	e59d3020 	ldr	r3, [sp, #32]
3002ea84:	e58d3000 	str	r3, [sp]
3002ea88:	e59d000c 	ldr	r0, [sp, #12]
3002ea8c:	e59d1010 	ldr	r1, [sp, #16]
3002ea90:	e59d200c 	ldr	r2, [sp, #12]
3002ea94:	e59d3008 	ldr	r3, [sp, #8]
3002ea98:	ebfffe91 	bl	3002e4e4 <Glib_Line>
    Glib_Line(x1,y2,x2,y2,color);
3002ea9c:	e59d3020 	ldr	r3, [sp, #32]
3002eaa0:	e58d3000 	str	r3, [sp]
3002eaa4:	e59d0014 	ldr	r0, [sp, #20]
3002eaa8:	e59d1008 	ldr	r1, [sp, #8]
3002eaac:	e59d200c 	ldr	r2, [sp, #12]
3002eab0:	e59d3008 	ldr	r3, [sp, #8]
3002eab4:	ebfffe8a 	bl	3002e4e4 <Glib_Line>
    Glib_Line(x1,y1,x1,y2,color);
3002eab8:	e59d3020 	ldr	r3, [sp, #32]
3002eabc:	e58d3000 	str	r3, [sp]
3002eac0:	e59d0014 	ldr	r0, [sp, #20]
3002eac4:	e59d1010 	ldr	r1, [sp, #16]
3002eac8:	e59d2014 	ldr	r2, [sp, #20]
3002eacc:	e59d3008 	ldr	r3, [sp, #8]
3002ead0:	ebfffe83 	bl	3002e4e4 <Glib_Line>
}
3002ead4:	e28dd01c 	add	sp, sp, #28
3002ead8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002eadc:	e12fff1e 	bx	lr

3002eae0 <Glib_FilledRectangle>:

/**************************************************************
在LCD屏幕上用颜色填充一个矩形
**************************************************************/
void Glib_FilledRectangle(int x1,int y1,int x2,int y2,int color)
{
3002eae0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002eae4:	e24dd024 	sub	sp, sp, #36	; 0x24
3002eae8:	e58d0014 	str	r0, [sp, #20]
3002eaec:	e58d1010 	str	r1, [sp, #16]
3002eaf0:	e58d200c 	str	r2, [sp, #12]
3002eaf4:	e58d3008 	str	r3, [sp, #8]
    int i;

    for(i=y1;i<=y2;i++)
3002eaf8:	e59d3010 	ldr	r3, [sp, #16]
3002eafc:	e58d301c 	str	r3, [sp, #28]
3002eb00:	ea000009 	b	3002eb2c <Glib_FilledRectangle+0x4c>
	Glib_Line(x1,i,x2,i,color);
3002eb04:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002eb08:	e58d3000 	str	r3, [sp]
3002eb0c:	e59d0014 	ldr	r0, [sp, #20]
3002eb10:	e59d101c 	ldr	r1, [sp, #28]
3002eb14:	e59d200c 	ldr	r2, [sp, #12]
3002eb18:	e59d301c 	ldr	r3, [sp, #28]
3002eb1c:	ebfffe70 	bl	3002e4e4 <Glib_Line>
**************************************************************/
void Glib_FilledRectangle(int x1,int y1,int x2,int y2,int color)
{
    int i;

    for(i=y1;i<=y2;i++)
3002eb20:	e59d301c 	ldr	r3, [sp, #28]
3002eb24:	e2833001 	add	r3, r3, #1
3002eb28:	e58d301c 	str	r3, [sp, #28]
3002eb2c:	e59d201c 	ldr	r2, [sp, #28]
3002eb30:	e59d3008 	ldr	r3, [sp, #8]
3002eb34:	e1520003 	cmp	r2, r3
3002eb38:	dafffff1 	ble	3002eb04 <Glib_FilledRectangle+0x24>
	Glib_Line(x1,i,x2,i,color);
}
3002eb3c:	e28dd024 	add	sp, sp, #36	; 0x24
3002eb40:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002eb44:	e12fff1e 	bx	lr

3002eb48 <Paint_Bmp>:

/**************************************************************
在LCD屏幕上指定坐标点画一个指定大小的图片
**************************************************************/
void Paint_Bmp(int x0,int y0,int h,int l,unsigned char bmp[])
{
3002eb48:	e24dd020 	sub	sp, sp, #32
3002eb4c:	e58d000c 	str	r0, [sp, #12]
3002eb50:	e58d1008 	str	r1, [sp, #8]
3002eb54:	e58d2004 	str	r2, [sp, #4]
3002eb58:	e58d3000 	str	r3, [sp]
	int x,y;
	unsigned int c;
	int p = 0;
3002eb5c:	e3a03000 	mov	r3, #0
3002eb60:	e58d301c 	str	r3, [sp, #28]

    for( y = y0 ; y < l ; y++ )
3002eb64:	e59d3008 	ldr	r3, [sp, #8]
3002eb68:	e58d3014 	str	r3, [sp, #20]
3002eb6c:	ea00003c 	b	3002ec64 <Paint_Bmp+0x11c>
    {
    	for( x = x0 ; x < h ; x++ )
3002eb70:	e59d300c 	ldr	r3, [sp, #12]
3002eb74:	e58d3010 	str	r3, [sp, #16]
3002eb78:	ea000032 	b	3002ec48 <Paint_Bmp+0x100>
    	{
    		c = bmp[p+1] | (bmp[p]<<8) ;
3002eb7c:	e59d301c 	ldr	r3, [sp, #28]
3002eb80:	e2832001 	add	r2, r3, #1
3002eb84:	e59d3020 	ldr	r3, [sp, #32]
3002eb88:	e0823003 	add	r3, r2, r3
3002eb8c:	e5d33000 	ldrb	r3, [r3]
3002eb90:	e1a02003 	mov	r2, r3
3002eb94:	e59d101c 	ldr	r1, [sp, #28]
3002eb98:	e59d3020 	ldr	r3, [sp, #32]
3002eb9c:	e0813003 	add	r3, r1, r3
3002eba0:	e5d33000 	ldrb	r3, [r3]
3002eba4:	e1a03403 	lsl	r3, r3, #8
3002eba8:	e1823003 	orr	r3, r2, r3
3002ebac:	e58d3018 	str	r3, [sp, #24]

			if ( ( (x0+x) < SCR_XSIZE_TFT) && ( (y0+y) < SCR_YSIZE_TFT) )
3002ebb0:	e59d200c 	ldr	r2, [sp, #12]
3002ebb4:	e59d3010 	ldr	r3, [sp, #16]
3002ebb8:	e0822003 	add	r2, r2, r3
3002ebbc:	e3a03f77 	mov	r3, #476	; 0x1dc
3002ebc0:	e2833003 	add	r3, r3, #3
3002ebc4:	e1520003 	cmp	r2, r3
3002ebc8:	ca000018 	bgt	3002ec30 <Paint_Bmp+0xe8>
3002ebcc:	e59d2008 	ldr	r2, [sp, #8]
3002ebd0:	e59d3014 	ldr	r3, [sp, #20]
3002ebd4:	e0822003 	add	r2, r2, r3
3002ebd8:	e3a03f43 	mov	r3, #268	; 0x10c
3002ebdc:	e2833003 	add	r3, r3, #3
3002ebe0:	e1520003 	cmp	r2, r3
3002ebe4:	ca000011 	bgt	3002ec30 <Paint_Bmp+0xe8>
				LCD_BUFFER[y0+y][x0+x] = c ;
3002ebe8:	e59d2008 	ldr	r2, [sp, #8]
3002ebec:	e59d3014 	ldr	r3, [sp, #20]
3002ebf0:	e0822003 	add	r2, r2, r3
3002ebf4:	e59d100c 	ldr	r1, [sp, #12]
3002ebf8:	e59d3010 	ldr	r3, [sp, #16]
3002ebfc:	e081c003 	add	ip, r1, r3
3002ec00:	e59d3018 	ldr	r3, [sp, #24]
3002ec04:	e1a03803 	lsl	r3, r3, #16
3002ec08:	e1a01823 	lsr	r1, r3, #16
3002ec0c:	e59f0068 	ldr	r0, [pc, #104]	; 3002ec7c <Paint_Bmp+0x134>
3002ec10:	e1a03002 	mov	r3, r2
3002ec14:	e1a03203 	lsl	r3, r3, #4
3002ec18:	e0623003 	rsb	r3, r2, r3
3002ec1c:	e1a03283 	lsl	r3, r3, #5
3002ec20:	e083300c 	add	r3, r3, ip
3002ec24:	e1a03083 	lsl	r3, r3, #1
3002ec28:	e0833000 	add	r3, r3, r0
3002ec2c:	e1c310b0 	strh	r1, [r3]

    		p = p + 2 ;
3002ec30:	e59d301c 	ldr	r3, [sp, #28]
3002ec34:	e2833002 	add	r3, r3, #2
3002ec38:	e58d301c 	str	r3, [sp, #28]
	unsigned int c;
	int p = 0;

    for( y = y0 ; y < l ; y++ )
    {
    	for( x = x0 ; x < h ; x++ )
3002ec3c:	e59d3010 	ldr	r3, [sp, #16]
3002ec40:	e2833001 	add	r3, r3, #1
3002ec44:	e58d3010 	str	r3, [sp, #16]
3002ec48:	e59d2010 	ldr	r2, [sp, #16]
3002ec4c:	e59d3004 	ldr	r3, [sp, #4]
3002ec50:	e1520003 	cmp	r2, r3
3002ec54:	baffffc8 	blt	3002eb7c <Paint_Bmp+0x34>
{
	int x,y;
	unsigned int c;
	int p = 0;

    for( y = y0 ; y < l ; y++ )
3002ec58:	e59d3014 	ldr	r3, [sp, #20]
3002ec5c:	e2833001 	add	r3, r3, #1
3002ec60:	e58d3014 	str	r3, [sp, #20]
3002ec64:	e59d2014 	ldr	r2, [sp, #20]
3002ec68:	e59d3000 	ldr	r3, [sp]
3002ec6c:	e1520003 	cmp	r2, r3
3002ec70:	baffffbe 	blt	3002eb70 <Paint_Bmp+0x28>
				LCD_BUFFER[y0+y][x0+x] = c ;

    		p = p + 2 ;
    	}
    }
}
3002ec74:	e28dd020 	add	sp, sp, #32
3002ec78:	e12fff1e 	bx	lr
3002ec7c:	300eabe4 	.word	0x300eabe4

3002ec80 <Lcd_TFT_Init>:

/**************************************************************
**************************************************************/
void Lcd_TFT_Init(void)
{
3002ec80:	e92d4008 	push	{r3, lr}
	Lcd_Init();
3002ec84:	ebfffd2f 	bl	3002e148 <Lcd_Init>
	Lcd_PowerEnable(0, 1);
3002ec88:	e3a00000 	mov	r0, #0
3002ec8c:	e3a01001 	mov	r1, #1
3002ec90:	ebfffd97 	bl	3002e2f4 <Lcd_PowerEnable>
	Lcd_EnvidOnOff(1);		//turn on vedio
3002ec94:	e3a00001 	mov	r0, #1
3002ec98:	ebfffd82 	bl	3002e2a8 <Lcd_EnvidOnOff>
	Lcd_ClearScr( (0x00<<11) | (0x00<<5) | (0x00) );
3002ec9c:	e3a00000 	mov	r0, #0
3002eca0:	ebfffde6 	bl	3002e440 <Lcd_ClearScr>

	Glib_Line( LCD_BLANK,LCD_BLANK, (LCD_XSIZE_TFT-LCD_BLANK), (LCD_YSIZE_TFT-LCD_BLANK), 0x0000 ) ;
	Glib_Line( LCD_BLANK,(LCD_YSIZE_TFT-LCD_BLANK), (LCD_XSIZE_TFT-LCD_BLANK), LCD_BLANK, 0x0000 ) ;
	Glib_Line( (LCD_XSIZE_TFT/2),(LCD_BLANK*2 + V_BLACK*0), (LCD_XSIZE_TFT/2), (LCD_BLANK*2 + V_BLACK*6), 0x0000 ) ;
	*/
}
3002eca4:	e8bd4008 	pop	{r3, lr}
3002eca8:	e12fff1e 	bx	lr

3002ecac <ts_command>:
int end_of_song = 0;
acoral_id id;

acoral_slice_policy_data_t data;

void ts_command(void) {
3002ecac:	e92d4008 	push	{r3, lr}
	//while(1) {
		acoral_sem_pend(&touch_eve, 0);
3002ecb0:	e59f0344 	ldr	r0, [pc, #836]	; 3002effc <ts_command+0x350>
3002ecb4:	e3a01000 	mov	r1, #0
3002ecb8:	ebff6280 	bl	300076c0 <acoral_sem_pend>
		acoral_print("x: %d y: %d\n", xdata, ydata);
3002ecbc:	e59f333c 	ldr	r3, [pc, #828]	; 3002f000 <ts_command+0x354>
3002ecc0:	e5932000 	ldr	r2, [r3]
3002ecc4:	e59f3338 	ldr	r3, [pc, #824]	; 3002f004 <ts_command+0x358>
3002ecc8:	e5933000 	ldr	r3, [r3]
3002eccc:	e59f0334 	ldr	r0, [pc, #820]	; 3002f008 <ts_command+0x35c>
3002ecd0:	e1a01002 	mov	r1, r2
3002ecd4:	e1a02003 	mov	r2, r3
3002ecd8:	ebff7158 	bl	3000b240 <acoral_print>
		status_changed = 1;
3002ecdc:	e59f3328 	ldr	r3, [pc, #808]	; 3002f00c <ts_command+0x360>
3002ece0:	e3a02001 	mov	r2, #1
3002ece4:	e5832000 	str	r2, [r3]

		if(xdata>620 && xdata<720 && ydata>300 && ydata<400) {
3002ece8:	e59f3310 	ldr	r3, [pc, #784]	; 3002f000 <ts_command+0x354>
3002ecec:	e5933000 	ldr	r3, [r3]
3002ecf0:	e3530f9b 	cmp	r3, #620	; 0x26c
3002ecf4:	da000015 	ble	3002ed50 <ts_command+0xa4>
3002ecf8:	e59f3300 	ldr	r3, [pc, #768]	; 3002f000 <ts_command+0x354>
3002ecfc:	e5932000 	ldr	r2, [r3]
3002ed00:	e3a03fb3 	mov	r3, #716	; 0x2cc
3002ed04:	e2833003 	add	r3, r3, #3
3002ed08:	e1520003 	cmp	r2, r3
3002ed0c:	ca00000f 	bgt	3002ed50 <ts_command+0xa4>
3002ed10:	e59f32ec 	ldr	r3, [pc, #748]	; 3002f004 <ts_command+0x358>
3002ed14:	e5933000 	ldr	r3, [r3]
3002ed18:	e3530f4b 	cmp	r3, #300	; 0x12c
3002ed1c:	da00000b 	ble	3002ed50 <ts_command+0xa4>
3002ed20:	e59f32dc 	ldr	r3, [pc, #732]	; 3002f004 <ts_command+0x358>
3002ed24:	e5932000 	ldr	r2, [r3]
3002ed28:	e3a03f63 	mov	r3, #396	; 0x18c
3002ed2c:	e2833003 	add	r3, r3, #3
3002ed30:	e1520003 	cmp	r2, r3
3002ed34:	ca000005 	bgt	3002ed50 <ts_command+0xa4>
			play_command = Inc_Vol;
3002ed38:	e59f32d0 	ldr	r3, [pc, #720]	; 3002f010 <ts_command+0x364>
3002ed3c:	e3a02002 	mov	r2, #2
3002ed40:	e5832000 	str	r2, [r3]
			acoral_print("vol_inc\n");
3002ed44:	e59f02c8 	ldr	r0, [pc, #712]	; 3002f014 <ts_command+0x368>
3002ed48:	ebff713c 	bl	3000b240 <acoral_print>
	//while(1) {
		acoral_sem_pend(&touch_eve, 0);
		acoral_print("x: %d y: %d\n", xdata, ydata);
		status_changed = 1;

		if(xdata>620 && xdata<720 && ydata>300 && ydata<400) {
3002ed4c:	ea0000a8 	b	3002eff4 <ts_command+0x348>
			play_command = Inc_Vol;
			acoral_print("vol_inc\n");
		}
		else if(xdata>600 && xdata<700 && ydata>730 && ydata<830) {
3002ed50:	e59f32a8 	ldr	r3, [pc, #680]	; 3002f000 <ts_command+0x354>
3002ed54:	e5933000 	ldr	r3, [r3]
3002ed58:	e3530f96 	cmp	r3, #600	; 0x258
3002ed5c:	da000017 	ble	3002edc0 <ts_command+0x114>
3002ed60:	e59f3298 	ldr	r3, [pc, #664]	; 3002f000 <ts_command+0x354>
3002ed64:	e5932000 	ldr	r2, [r3]
3002ed68:	e3a03fae 	mov	r3, #696	; 0x2b8
3002ed6c:	e2833003 	add	r3, r3, #3
3002ed70:	e1520003 	cmp	r2, r3
3002ed74:	ca000011 	bgt	3002edc0 <ts_command+0x114>
3002ed78:	e59f3284 	ldr	r3, [pc, #644]	; 3002f004 <ts_command+0x358>
3002ed7c:	e5932000 	ldr	r2, [r3]
3002ed80:	e3a03fb6 	mov	r3, #728	; 0x2d8
3002ed84:	e2833002 	add	r3, r3, #2
3002ed88:	e1520003 	cmp	r2, r3
3002ed8c:	da00000b 	ble	3002edc0 <ts_command+0x114>
3002ed90:	e59f326c 	ldr	r3, [pc, #620]	; 3002f004 <ts_command+0x358>
3002ed94:	e5932000 	ldr	r2, [r3]
3002ed98:	e3a03fcf 	mov	r3, #828	; 0x33c
3002ed9c:	e2833001 	add	r3, r3, #1
3002eda0:	e1520003 	cmp	r2, r3
3002eda4:	ca000005 	bgt	3002edc0 <ts_command+0x114>
			play_command = Dec_Vol;
3002eda8:	e59f3260 	ldr	r3, [pc, #608]	; 3002f010 <ts_command+0x364>
3002edac:	e3a02003 	mov	r2, #3
3002edb0:	e5832000 	str	r2, [r3]
			acoral_print("vol_dec\n");
3002edb4:	e59f025c 	ldr	r0, [pc, #604]	; 3002f018 <ts_command+0x36c>
3002edb8:	ebff7120 	bl	3000b240 <acoral_print>

		if(xdata>620 && xdata<720 && ydata>300 && ydata<400) {
			play_command = Inc_Vol;
			acoral_print("vol_inc\n");
		}
		else if(xdata>600 && xdata<700 && ydata>730 && ydata<830) {
3002edbc:	ea00008c 	b	3002eff4 <ts_command+0x348>
			play_command = Dec_Vol;
			acoral_print("vol_dec\n");
		}
		else if(xdata>450 && xdata<550 && ydata>500 && ydata<600) {
3002edc0:	e59f3238 	ldr	r3, [pc, #568]	; 3002f000 <ts_command+0x354>
3002edc4:	e5932000 	ldr	r2, [r3]
3002edc8:	e3a03d07 	mov	r3, #448	; 0x1c0
3002edcc:	e2833002 	add	r3, r3, #2
3002edd0:	e1520003 	cmp	r2, r3
3002edd4:	da000015 	ble	3002ee30 <ts_command+0x184>
3002edd8:	e59f3220 	ldr	r3, [pc, #544]	; 3002f000 <ts_command+0x354>
3002eddc:	e5932000 	ldr	r2, [r3]
3002ede0:	e3a03f89 	mov	r3, #548	; 0x224
3002ede4:	e2833001 	add	r3, r3, #1
3002ede8:	e1520003 	cmp	r2, r3
3002edec:	ca00000f 	bgt	3002ee30 <ts_command+0x184>
3002edf0:	e59f320c 	ldr	r3, [pc, #524]	; 3002f004 <ts_command+0x358>
3002edf4:	e5933000 	ldr	r3, [r3]
3002edf8:	e3530f7d 	cmp	r3, #500	; 0x1f4
3002edfc:	da00000b 	ble	3002ee30 <ts_command+0x184>
3002ee00:	e59f31fc 	ldr	r3, [pc, #508]	; 3002f004 <ts_command+0x358>
3002ee04:	e5932000 	ldr	r2, [r3]
3002ee08:	e3a03f95 	mov	r3, #596	; 0x254
3002ee0c:	e2833003 	add	r3, r3, #3
3002ee10:	e1520003 	cmp	r2, r3
3002ee14:	ca000005 	bgt	3002ee30 <ts_command+0x184>
			play_command = Next_Song;
3002ee18:	e59f31f0 	ldr	r3, [pc, #496]	; 3002f010 <ts_command+0x364>
3002ee1c:	e3a02004 	mov	r2, #4
3002ee20:	e5832000 	str	r2, [r3]
			acoral_print("next\n");
3002ee24:	e59f01f0 	ldr	r0, [pc, #496]	; 3002f01c <ts_command+0x370>
3002ee28:	ebff7104 	bl	3000b240 <acoral_print>
		}
		else if(xdata>600 && xdata<700 && ydata>730 && ydata<830) {
			play_command = Dec_Vol;
			acoral_print("vol_dec\n");
		}
		else if(xdata>450 && xdata<550 && ydata>500 && ydata<600) {
3002ee2c:	ea000070 	b	3002eff4 <ts_command+0x348>
			play_command = Next_Song;
			acoral_print("next\n");
		}
		else if(xdata>750 && xdata<850 && ydata>500 && ydata<600) {
3002ee30:	e59f31c8 	ldr	r3, [pc, #456]	; 3002f000 <ts_command+0x354>
3002ee34:	e5932000 	ldr	r2, [r3]
3002ee38:	e3a03fbb 	mov	r3, #748	; 0x2ec
3002ee3c:	e2833002 	add	r3, r3, #2
3002ee40:	e1520003 	cmp	r2, r3
3002ee44:	da000015 	ble	3002eea0 <ts_command+0x1f4>
3002ee48:	e59f31b0 	ldr	r3, [pc, #432]	; 3002f000 <ts_command+0x354>
3002ee4c:	e5932000 	ldr	r2, [r3]
3002ee50:	e3a03e35 	mov	r3, #848	; 0x350
3002ee54:	e2833001 	add	r3, r3, #1
3002ee58:	e1520003 	cmp	r2, r3
3002ee5c:	ca00000f 	bgt	3002eea0 <ts_command+0x1f4>
3002ee60:	e59f319c 	ldr	r3, [pc, #412]	; 3002f004 <ts_command+0x358>
3002ee64:	e5933000 	ldr	r3, [r3]
3002ee68:	e3530f7d 	cmp	r3, #500	; 0x1f4
3002ee6c:	da00000b 	ble	3002eea0 <ts_command+0x1f4>
3002ee70:	e59f318c 	ldr	r3, [pc, #396]	; 3002f004 <ts_command+0x358>
3002ee74:	e5932000 	ldr	r2, [r3]
3002ee78:	e3a03f95 	mov	r3, #596	; 0x254
3002ee7c:	e2833003 	add	r3, r3, #3
3002ee80:	e1520003 	cmp	r2, r3
3002ee84:	ca000005 	bgt	3002eea0 <ts_command+0x1f4>
			play_command = Pre_Song;
3002ee88:	e59f3180 	ldr	r3, [pc, #384]	; 3002f010 <ts_command+0x364>
3002ee8c:	e3a02005 	mov	r2, #5
3002ee90:	e5832000 	str	r2, [r3]
			acoral_print("pre\n");
3002ee94:	e59f0184 	ldr	r0, [pc, #388]	; 3002f020 <ts_command+0x374>
3002ee98:	ebff70e8 	bl	3000b240 <acoral_print>
		}
		else if(xdata>450 && xdata<550 && ydata>500 && ydata<600) {
			play_command = Next_Song;
			acoral_print("next\n");
		}
		else if(xdata>750 && xdata<850 && ydata>500 && ydata<600) {
3002ee9c:	ea000054 	b	3002eff4 <ts_command+0x348>
			play_command = Pre_Song;
			acoral_print("pre\n");
		}
		else if(xdata>600 && xdata<700 && ydata>530 && ydata<630) {
3002eea0:	e59f3158 	ldr	r3, [pc, #344]	; 3002f000 <ts_command+0x354>
3002eea4:	e5933000 	ldr	r3, [r3]
3002eea8:	e3530f96 	cmp	r3, #600	; 0x258
3002eeac:	da000017 	ble	3002ef10 <ts_command+0x264>
3002eeb0:	e59f3148 	ldr	r3, [pc, #328]	; 3002f000 <ts_command+0x354>
3002eeb4:	e5932000 	ldr	r2, [r3]
3002eeb8:	e3a03fae 	mov	r3, #696	; 0x2b8
3002eebc:	e2833003 	add	r3, r3, #3
3002eec0:	e1520003 	cmp	r2, r3
3002eec4:	ca000011 	bgt	3002ef10 <ts_command+0x264>
3002eec8:	e59f3134 	ldr	r3, [pc, #308]	; 3002f004 <ts_command+0x358>
3002eecc:	e5932000 	ldr	r2, [r3]
3002eed0:	e3a03e21 	mov	r3, #528	; 0x210
3002eed4:	e2833002 	add	r3, r3, #2
3002eed8:	e1520003 	cmp	r2, r3
3002eedc:	da00000b 	ble	3002ef10 <ts_command+0x264>
3002eee0:	e59f311c 	ldr	r3, [pc, #284]	; 3002f004 <ts_command+0x358>
3002eee4:	e5932000 	ldr	r2, [r3]
3002eee8:	e3a03f9d 	mov	r3, #628	; 0x274
3002eeec:	e2833001 	add	r3, r3, #1
3002eef0:	e1520003 	cmp	r2, r3
3002eef4:	ca000005 	bgt	3002ef10 <ts_command+0x264>
			play_command = Start_Stop;
3002eef8:	e59f3110 	ldr	r3, [pc, #272]	; 3002f010 <ts_command+0x364>
3002eefc:	e3a02001 	mov	r2, #1
3002ef00:	e5832000 	str	r2, [r3]
			acoral_print("stop_start\n");
3002ef04:	e59f0118 	ldr	r0, [pc, #280]	; 3002f024 <ts_command+0x378>
3002ef08:	ebff70cc 	bl	3000b240 <acoral_print>
		}
		else if(xdata>750 && xdata<850 && ydata>500 && ydata<600) {
			play_command = Pre_Song;
			acoral_print("pre\n");
		}
		else if(xdata>600 && xdata<700 && ydata>530 && ydata<630) {
3002ef0c:	ea000038 	b	3002eff4 <ts_command+0x348>
			play_command = Start_Stop;
			acoral_print("stop_start\n");
		}
		else if(xdata>230 && xdata<330 && ydata>400 && ydata<500) {
3002ef10:	e59f30e8 	ldr	r3, [pc, #232]	; 3002f000 <ts_command+0x354>
3002ef14:	e5933000 	ldr	r3, [r3]
3002ef18:	e35300e6 	cmp	r3, #230	; 0xe6
3002ef1c:	da000015 	ble	3002ef78 <ts_command+0x2cc>
3002ef20:	e59f30d8 	ldr	r3, [pc, #216]	; 3002f000 <ts_command+0x354>
3002ef24:	e5932000 	ldr	r2, [r3]
3002ef28:	e3a03f52 	mov	r3, #328	; 0x148
3002ef2c:	e2833001 	add	r3, r3, #1
3002ef30:	e1520003 	cmp	r2, r3
3002ef34:	ca00000f 	bgt	3002ef78 <ts_command+0x2cc>
3002ef38:	e59f30c4 	ldr	r3, [pc, #196]	; 3002f004 <ts_command+0x358>
3002ef3c:	e5933000 	ldr	r3, [r3]
3002ef40:	e3530e19 	cmp	r3, #400	; 0x190
3002ef44:	da00000b 	ble	3002ef78 <ts_command+0x2cc>
3002ef48:	e59f30b4 	ldr	r3, [pc, #180]	; 3002f004 <ts_command+0x358>
3002ef4c:	e5932000 	ldr	r2, [r3]
3002ef50:	e3a03e1f 	mov	r3, #496	; 0x1f0
3002ef54:	e2833003 	add	r3, r3, #3
3002ef58:	e1520003 	cmp	r2, r3
3002ef5c:	ca000005 	bgt	3002ef78 <ts_command+0x2cc>
			play_command = Local;
3002ef60:	e59f30a8 	ldr	r3, [pc, #168]	; 3002f010 <ts_command+0x364>
3002ef64:	e3a02015 	mov	r2, #21
3002ef68:	e5832000 	str	r2, [r3]
			acoral_print("local\n");
3002ef6c:	e59f00b4 	ldr	r0, [pc, #180]	; 3002f028 <ts_command+0x37c>
3002ef70:	ebff70b2 	bl	3000b240 <acoral_print>
		}
		else if(xdata>600 && xdata<700 && ydata>530 && ydata<630) {
			play_command = Start_Stop;
			acoral_print("stop_start\n");
		}
		else if(xdata>230 && xdata<330 && ydata>400 && ydata<500) {
3002ef74:	ea00001e 	b	3002eff4 <ts_command+0x348>
			play_command = Local;
			acoral_print("local\n");
		}
		else if(xdata>230 && xdata<330 && ydata>650 && ydata<750) {
3002ef78:	e59f3080 	ldr	r3, [pc, #128]	; 3002f000 <ts_command+0x354>
3002ef7c:	e5933000 	ldr	r3, [r3]
3002ef80:	e35300e6 	cmp	r3, #230	; 0xe6
3002ef84:	da000017 	ble	3002efe8 <ts_command+0x33c>
3002ef88:	e59f3070 	ldr	r3, [pc, #112]	; 3002f000 <ts_command+0x354>
3002ef8c:	e5932000 	ldr	r2, [r3]
3002ef90:	e3a03f52 	mov	r3, #328	; 0x148
3002ef94:	e2833001 	add	r3, r3, #1
3002ef98:	e1520003 	cmp	r2, r3
3002ef9c:	ca000011 	bgt	3002efe8 <ts_command+0x33c>
3002efa0:	e59f305c 	ldr	r3, [pc, #92]	; 3002f004 <ts_command+0x358>
3002efa4:	e5932000 	ldr	r2, [r3]
3002efa8:	e3a03fa2 	mov	r3, #648	; 0x288
3002efac:	e2833002 	add	r3, r3, #2
3002efb0:	e1520003 	cmp	r2, r3
3002efb4:	da00000b 	ble	3002efe8 <ts_command+0x33c>
3002efb8:	e59f3044 	ldr	r3, [pc, #68]	; 3002f004 <ts_command+0x358>
3002efbc:	e5932000 	ldr	r2, [r3]
3002efc0:	e3a03fbb 	mov	r3, #748	; 0x2ec
3002efc4:	e2833001 	add	r3, r3, #1
3002efc8:	e1520003 	cmp	r2, r3
3002efcc:	ca000005 	bgt	3002efe8 <ts_command+0x33c>
			play_command = Online;
3002efd0:	e59f3038 	ldr	r3, [pc, #56]	; 3002f010 <ts_command+0x364>
3002efd4:	e3a02016 	mov	r2, #22
3002efd8:	e5832000 	str	r2, [r3]
			acoral_print("online\n");
3002efdc:	e59f0048 	ldr	r0, [pc, #72]	; 3002f02c <ts_command+0x380>
3002efe0:	ebff7096 	bl	3000b240 <acoral_print>
		}
		else if(xdata>230 && xdata<330 && ydata>400 && ydata<500) {
			play_command = Local;
			acoral_print("local\n");
		}
		else if(xdata>230 && xdata<330 && ydata>650 && ydata<750) {
3002efe4:	ea000002 	b	3002eff4 <ts_command+0x348>
			play_command = Online;
			acoral_print("online\n");
		}
		else
			play_command = No_Command;
3002efe8:	e59f3020 	ldr	r3, [pc, #32]	; 3002f010 <ts_command+0x364>
3002efec:	e3a02000 	mov	r2, #0
3002eff0:	e5832000 	str	r2, [r3]
	//}
}
3002eff4:	e8bd4008 	pop	{r3, lr}
3002eff8:	e12fff1e 	bx	lr
3002effc:	302f7e48 	.word	0x302f7e48
3002f000:	301f57a4 	.word	0x301f57a4
3002f004:	301f5938 	.word	0x301f5938
3002f008:	30045e78 	.word	0x30045e78
3002f00c:	300e58b8 	.word	0x300e58b8
3002f010:	300e58bc 	.word	0x300e58bc
3002f014:	30045e88 	.word	0x30045e88
3002f018:	30045e94 	.word	0x30045e94
3002f01c:	30045ea0 	.word	0x30045ea0
3002f020:	30045ea8 	.word	0x30045ea8
3002f024:	30045eb0 	.word	0x30045eb0
3002f028:	30045ebc 	.word	0x30045ebc
3002f02c:	30045ec4 	.word	0x30045ec4

3002f030 <get_local_file_dir>:
#define RETURN_OK                   0x00

char local_file_dir[Max_Song_Num][20];
int  song_num;

void get_local_file_dir(void) {
3002f030:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002f034:	e24dd03c 	sub	sp, sp, #60	; 0x3c
	acoral_u32 i, j;
	FDT Rt;
	acoral_u8 Drive;
	acoral_u32 ClusIndex;
	acoral_u8 flag;
	song_num = 0;
3002f038:	e59f3170 	ldr	r3, [pc, #368]	; 3002f1b0 <get_local_file_dir+0x180>
3002f03c:	e3a02000 	mov	r2, #0
3002f040:	e5832000 	str	r2, [r3]
	Drive=CurrentDrive;
3002f044:	e59f3168 	ldr	r3, [pc, #360]	; 3002f1b4 <get_local_file_dir+0x184>
3002f048:	e5d33000 	ldrb	r3, [r3]
3002f04c:	e5cd302f 	strb	r3, [sp, #47]	; 0x2f
	ClusIndex=DiskInfo[Drive].PathClusIndex;
3002f050:	e5dd202f 	ldrb	r2, [sp, #47]	; 0x2f
3002f054:	e59f015c 	ldr	r0, [pc, #348]	; 3002f1b8 <get_local_file_dir+0x188>
3002f058:	e3a01028 	mov	r1, #40	; 0x28
3002f05c:	e1a03002 	mov	r3, r2
3002f060:	e1a03083 	lsl	r3, r3, #1
3002f064:	e0833002 	add	r3, r3, r2
3002f068:	e1a03103 	lsl	r3, r3, #2
3002f06c:	e0833002 	add	r3, r3, r2
3002f070:	e1a03103 	lsl	r3, r3, #2
3002f074:	e0833000 	add	r3, r3, r0
3002f078:	e0833001 	add	r3, r3, r1
3002f07c:	e5933000 	ldr	r3, [r3]
3002f080:	e58d3030 	str	r3, [sp, #48]	; 0x30
	flag=0;
3002f084:	e3a03000 	mov	r3, #0
3002f088:	e5cd3037 	strb	r3, [sp, #55]	; 0x37
	i=0;
3002f08c:	e3a03000 	mov	r3, #0
3002f090:	e58d3024 	str	r3, [sp, #36]	; 0x24
	while(1)
	{
		temp=GetFDTInfo(&Rt,Drive,ClusIndex,i);
3002f094:	e1a0200d 	mov	r2, sp
3002f098:	e5dd302f 	ldrb	r3, [sp, #47]	; 0x2f
3002f09c:	e1a00002 	mov	r0, r2
3002f0a0:	e1a01003 	mov	r1, r3
3002f0a4:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
3002f0a8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3002f0ac:	ebffde95 	bl	30026b08 <GetFDTInfo>
3002f0b0:	e1a03000 	mov	r3, r0
3002f0b4:	e5cd3023 	strb	r3, [sp, #35]	; 0x23

		if(temp!=RETURN_OK)
3002f0b8:	e5dd3023 	ldrb	r3, [sp, #35]	; 0x23
3002f0bc:	e3530000 	cmp	r3, #0
3002f0c0:	1a000034 	bne	3002f198 <get_local_file_dir+0x168>
		{
			break;
		}
		if(Rt.Name[0]==EMPTY_FDT)
3002f0c4:	e5dd3000 	ldrb	r3, [sp]
3002f0c8:	e3530000 	cmp	r3, #0
3002f0cc:	0a000033 	beq	3002f1a0 <get_local_file_dir+0x170>
		{
			break;
		}
		if(Rt.Name[0]==DEL_FDT)
3002f0d0:	e5dd3000 	ldrb	r3, [sp]
3002f0d4:	e35300e5 	cmp	r3, #229	; 0xe5
3002f0d8:	1a000004 	bne	3002f0f0 <get_local_file_dir+0xc0>
		{
			i++;
3002f0dc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3002f0e0:	e2833001 	add	r3, r3, #1
3002f0e4:	e58d3024 	str	r3, [sp, #36]	; 0x24
			continue;
3002f0e8:	e1a00000 	nop			; (mov r0, r0)
			for(j=0; j<sizeof(Rt.Name); j++)
				local_file_dir[song_num][j] = Rt.Name[j];
			song_num ++;
		}
		i++;
	}
3002f0ec:	eaffffe8 	b	3002f094 <get_local_file_dir+0x64>
		if(Rt.Name[0]==DEL_FDT)
		{
			i++;
			continue;
		}
		if(Rt.Name[8]=='M' || Rt.Name[8]=='W') {
3002f0f0:	e5dd3008 	ldrb	r3, [sp, #8]
3002f0f4:	e353004d 	cmp	r3, #77	; 0x4d
3002f0f8:	0a000002 	beq	3002f108 <get_local_file_dir+0xd8>
3002f0fc:	e5dd3008 	ldrb	r3, [sp, #8]
3002f100:	e3530057 	cmp	r3, #87	; 0x57
3002f104:	1a00001f 	bne	3002f188 <get_local_file_dir+0x158>
			for(j=0; j<sizeof(Rt.Name); j++)
3002f108:	e3a03000 	mov	r3, #0
3002f10c:	e58d3028 	str	r3, [sp, #40]	; 0x28
3002f110:	ea000014 	b	3002f168 <get_local_file_dir+0x138>
				local_file_dir[song_num][j] = Rt.Name[j];
3002f114:	e59f3094 	ldr	r3, [pc, #148]	; 3002f1b0 <get_local_file_dir+0x180>
3002f118:	e5932000 	ldr	r2, [r3]
3002f11c:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
3002f120:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3002f124:	e3e03037 	mvn	r3, #55	; 0x37
3002f128:	e28d0038 	add	r0, sp, #56	; 0x38
3002f12c:	e0801001 	add	r1, r0, r1
3002f130:	e0813003 	add	r3, r1, r3
3002f134:	e5d31000 	ldrb	r1, [r3]
3002f138:	e59f007c 	ldr	r0, [pc, #124]	; 3002f1bc <get_local_file_dir+0x18c>
3002f13c:	e1a03002 	mov	r3, r2
3002f140:	e1a03103 	lsl	r3, r3, #2
3002f144:	e0833002 	add	r3, r3, r2
3002f148:	e1a03103 	lsl	r3, r3, #2
3002f14c:	e083300c 	add	r3, r3, ip
3002f150:	e0833000 	add	r3, r3, r0
3002f154:	e1a02001 	mov	r2, r1
3002f158:	e5c32000 	strb	r2, [r3]
		{
			i++;
			continue;
		}
		if(Rt.Name[8]=='M' || Rt.Name[8]=='W') {
			for(j=0; j<sizeof(Rt.Name); j++)
3002f15c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002f160:	e2833001 	add	r3, r3, #1
3002f164:	e58d3028 	str	r3, [sp, #40]	; 0x28
3002f168:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3002f16c:	e353000a 	cmp	r3, #10
3002f170:	9affffe7 	bls	3002f114 <get_local_file_dir+0xe4>
				local_file_dir[song_num][j] = Rt.Name[j];
			song_num ++;
3002f174:	e59f3034 	ldr	r3, [pc, #52]	; 3002f1b0 <get_local_file_dir+0x180>
3002f178:	e5933000 	ldr	r3, [r3]
3002f17c:	e2832001 	add	r2, r3, #1
3002f180:	e59f3028 	ldr	r3, [pc, #40]	; 3002f1b0 <get_local_file_dir+0x180>
3002f184:	e5832000 	str	r2, [r3]
		}
		i++;
3002f188:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3002f18c:	e2833001 	add	r3, r3, #1
3002f190:	e58d3024 	str	r3, [sp, #36]	; 0x24
	}
3002f194:	eaffffbe 	b	3002f094 <get_local_file_dir+0x64>
	{
		temp=GetFDTInfo(&Rt,Drive,ClusIndex,i);

		if(temp!=RETURN_OK)
		{
			break;
3002f198:	e1a00000 	nop			; (mov r0, r0)
3002f19c:	ea000000 	b	3002f1a4 <get_local_file_dir+0x174>
		}
		if(Rt.Name[0]==EMPTY_FDT)
		{
			break;
3002f1a0:	e1a00000 	nop			; (mov r0, r0)
		}
		i++;
	}

	return ;
}
3002f1a4:	e28dd03c 	add	sp, sp, #60	; 0x3c
3002f1a8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3002f1ac:	e12fff1e 	bx	lr
3002f1b0:	3012b680 	.word	0x3012b680
3002f1b4:	3012b640 	.word	0x3012b640
3002f1b8:	300eab48 	.word	0x300eab48
3002f1bc:	302be3dc 	.word	0x302be3dc

3002f1c0 <suspector_thread>:

void suspector_thread(void) {
3002f1c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002f1c4:	e24dd01c 	sub	sp, sp, #28
	int i, j;
	end_of_song = 0;
3002f1c8:	e59f32c8 	ldr	r3, [pc, #712]	; 3002f498 <suspector_thread+0x2d8>
3002f1cc:	e3a02000 	mov	r2, #0
3002f1d0:	e5832000 	str	r2, [r3]
	while(1) {
		if(end_of_song) {
3002f1d4:	e59f32bc 	ldr	r3, [pc, #700]	; 3002f498 <suspector_thread+0x2d8>
3002f1d8:	e5933000 	ldr	r3, [r3]
3002f1dc:	e3530000 	cmp	r3, #0
3002f1e0:	0a0000a9 	beq	3002f48c <suspector_thread+0x2cc>
			if(play_model == Online) {
3002f1e4:	e59f32b0 	ldr	r3, [pc, #688]	; 3002f49c <suspector_thread+0x2dc>
3002f1e8:	e5933000 	ldr	r3, [r3]
3002f1ec:	e3530016 	cmp	r3, #22
3002f1f0:	1a000004 	bne	3002f208 <suspector_thread+0x48>
				waveOutPause(0);
3002f1f4:	e3a00000 	mov	r0, #0
3002f1f8:	eb000932 	bl	300316c8 <waveOutPause>
				acoral_delay_self(3000);
3002f1fc:	e3a00ebb 	mov	r0, #2992	; 0xbb0
3002f200:	e2800008 	add	r0, r0, #8
3002f204:	ebff4dde 	bl	30002984 <acoral_delay_self>
			}
			waveOutClose(0);
3002f208:	e3a00000 	mov	r0, #0
3002f20c:	eb000856 	bl	3003136c <waveOutClose>
			play_status = Play;
3002f210:	e59f3288 	ldr	r3, [pc, #648]	; 3002f4a0 <suspector_thread+0x2e0>
3002f214:	e3a02001 	mov	r2, #1
3002f218:	e5832000 	str	r2, [r3]
			cur_song = (cur_song+1)%song_num;
3002f21c:	e59f3280 	ldr	r3, [pc, #640]	; 3002f4a4 <suspector_thread+0x2e4>
3002f220:	e5933000 	ldr	r3, [r3]
3002f224:	e2832001 	add	r2, r3, #1
3002f228:	e59f3278 	ldr	r3, [pc, #632]	; 3002f4a8 <suspector_thread+0x2e8>
3002f22c:	e5933000 	ldr	r3, [r3]
3002f230:	e1a00002 	mov	r0, r2
3002f234:	e1a01003 	mov	r1, r3
3002f238:	eb005327 	bl	30043edc <__aeabi_idivmod>
3002f23c:	e1a03001 	mov	r3, r1
3002f240:	e1a02003 	mov	r2, r3
3002f244:	e59f3258 	ldr	r3, [pc, #600]	; 3002f4a4 <suspector_thread+0x2e4>
3002f248:	e5832000 	str	r2, [r3]
			acoral_close(cur_file_ptr);
3002f24c:	e59f3258 	ldr	r3, [pc, #600]	; 3002f4ac <suspector_thread+0x2ec>
3002f250:	e5933000 	ldr	r3, [r3]
3002f254:	e1a00003 	mov	r0, r3
3002f258:	ebffeff4 	bl	3002b230 <acoral_close>
			acoral_kill_thread_by_id(pcm_player_id);
3002f25c:	e59f324c 	ldr	r3, [pc, #588]	; 3002f4b0 <suspector_thread+0x2f0>
3002f260:	e5933000 	ldr	r3, [r3]
3002f264:	e1a00003 	mov	r0, r3
3002f268:	ebff4df8 	bl	30002a50 <acoral_kill_thread_by_id>
			acoral_kill_thread_by_id(mp3_decoder_id);
3002f26c:	e59f3240 	ldr	r3, [pc, #576]	; 3002f4b4 <suspector_thread+0x2f4>
3002f270:	e5933000 	ldr	r3, [r3]
3002f274:	e1a00003 	mov	r0, r3
3002f278:	ebff4df4 	bl	30002a50 <acoral_kill_thread_by_id>
			client_close();
3002f27c:	eb0013f4 	bl	30034254 <client_close>
			acoral_kill_thread_by_id(id);
3002f280:	e59f3230 	ldr	r3, [pc, #560]	; 3002f4b8 <suspector_thread+0x2f8>
3002f284:	e5933000 	ldr	r3, [r3]
3002f288:	e1a00003 	mov	r0, r3
3002f28c:	ebff4def 	bl	30002a50 <acoral_kill_thread_by_id>
			if(play_model == Local) {
3002f290:	e59f3204 	ldr	r3, [pc, #516]	; 3002f49c <suspector_thread+0x2dc>
3002f294:	e5933000 	ldr	r3, [r3]
3002f298:	e3530015 	cmp	r3, #21
3002f29c:	1a000064 	bne	3002f434 <suspector_thread+0x274>
				j = 0;
3002f2a0:	e3a03000 	mov	r3, #0
3002f2a4:	e58d3014 	str	r3, [sp, #20]
				for(i=0; i<20; i++) {
3002f2a8:	e3a03000 	mov	r3, #0
3002f2ac:	e58d3010 	str	r3, [sp, #16]
3002f2b0:	ea00002a 	b	3002f360 <suspector_thread+0x1a0>
					if(local_file_dir[cur_song][i] != 32) {
3002f2b4:	e59f31e8 	ldr	r3, [pc, #488]	; 3002f4a4 <suspector_thread+0x2e4>
3002f2b8:	e5932000 	ldr	r2, [r3]
3002f2bc:	e59d0010 	ldr	r0, [sp, #16]
3002f2c0:	e59f11f4 	ldr	r1, [pc, #500]	; 3002f4bc <suspector_thread+0x2fc>
3002f2c4:	e1a03002 	mov	r3, r2
3002f2c8:	e1a03103 	lsl	r3, r3, #2
3002f2cc:	e0833002 	add	r3, r3, r2
3002f2d0:	e1a03103 	lsl	r3, r3, #2
3002f2d4:	e0833000 	add	r3, r3, r0
3002f2d8:	e0833001 	add	r3, r3, r1
3002f2dc:	e5d33000 	ldrb	r3, [r3]
3002f2e0:	e3530020 	cmp	r3, #32
3002f2e4:	0a00001a 	beq	3002f354 <suspector_thread+0x194>
						cur_file_name[j] = local_file_dir[cur_song][i];
3002f2e8:	e59d1014 	ldr	r1, [sp, #20]
3002f2ec:	e59f31b0 	ldr	r3, [pc, #432]	; 3002f4a4 <suspector_thread+0x2e4>
3002f2f0:	e5932000 	ldr	r2, [r3]
3002f2f4:	e59dc010 	ldr	ip, [sp, #16]
3002f2f8:	e59f01bc 	ldr	r0, [pc, #444]	; 3002f4bc <suspector_thread+0x2fc>
3002f2fc:	e1a03002 	mov	r3, r2
3002f300:	e1a03103 	lsl	r3, r3, #2
3002f304:	e0833002 	add	r3, r3, r2
3002f308:	e1a03103 	lsl	r3, r3, #2
3002f30c:	e083300c 	add	r3, r3, ip
3002f310:	e0833000 	add	r3, r3, r0
3002f314:	e5d32000 	ldrb	r2, [r3]
3002f318:	e59f31a0 	ldr	r3, [pc, #416]	; 3002f4c0 <suspector_thread+0x300>
3002f31c:	e7c32001 	strb	r2, [r3, r1]
						j ++;
3002f320:	e59d3014 	ldr	r3, [sp, #20]
3002f324:	e2833001 	add	r3, r3, #1
3002f328:	e58d3014 	str	r3, [sp, #20]
						if(j == 1)
3002f32c:	e59d3014 	ldr	r3, [sp, #20]
3002f330:	e3530001 	cmp	r3, #1
3002f334:	1a000006 	bne	3002f354 <suspector_thread+0x194>
							cur_file_name[j++] = '.';
3002f338:	e59d3014 	ldr	r3, [sp, #20]
3002f33c:	e59f217c 	ldr	r2, [pc, #380]	; 3002f4c0 <suspector_thread+0x300>
3002f340:	e3a0102e 	mov	r1, #46	; 0x2e
3002f344:	e7c21003 	strb	r1, [r2, r3]
3002f348:	e59d3014 	ldr	r3, [sp, #20]
3002f34c:	e2833001 	add	r3, r3, #1
3002f350:	e58d3014 	str	r3, [sp, #20]
			acoral_kill_thread_by_id(mp3_decoder_id);
			client_close();
			acoral_kill_thread_by_id(id);
			if(play_model == Local) {
				j = 0;
				for(i=0; i<20; i++) {
3002f354:	e59d3010 	ldr	r3, [sp, #16]
3002f358:	e2833001 	add	r3, r3, #1
3002f35c:	e58d3010 	str	r3, [sp, #16]
3002f360:	e59d3010 	ldr	r3, [sp, #16]
3002f364:	e3530013 	cmp	r3, #19
3002f368:	daffffd1 	ble	3002f2b4 <suspector_thread+0xf4>
						if(j == 1)
							cur_file_name[j++] = '.';
					}
				}
			//acoral_print("not support yet! \n");
				play_status = Play;
3002f36c:	e59f312c 	ldr	r3, [pc, #300]	; 3002f4a0 <suspector_thread+0x2e0>
3002f370:	e3a02001 	mov	r2, #1
3002f374:	e5832000 	str	r2, [r3]
				if((cur_file_name[2]=='m') || (cur_file_name[2]=='M'))
3002f378:	e59f3140 	ldr	r3, [pc, #320]	; 3002f4c0 <suspector_thread+0x300>
3002f37c:	e5d33002 	ldrb	r3, [r3, #2]
3002f380:	e353006d 	cmp	r3, #109	; 0x6d
3002f384:	0a000003 	beq	3002f398 <suspector_thread+0x1d8>
3002f388:	e59f3130 	ldr	r3, [pc, #304]	; 3002f4c0 <suspector_thread+0x300>
3002f38c:	e5d33002 	ldrb	r3, [r3, #2]
3002f390:	e353004d 	cmp	r3, #77	; 0x4d
3002f394:	1a00000e 	bne	3002f3d4 <suspector_thread+0x214>
					id = acoral_create_thread_ext(local_mp3_file_read, 8192*16, 0, "local_mp3_file_read", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
3002f398:	e59f3124 	ldr	r3, [pc, #292]	; 3002f4c4 <suspector_thread+0x304>
3002f39c:	e3a02000 	mov	r2, #0
3002f3a0:	e58d2000 	str	r2, [sp]
3002f3a4:	e3a02018 	mov	r2, #24
3002f3a8:	e58d2004 	str	r2, [sp, #4]
3002f3ac:	e59f2114 	ldr	r2, [pc, #276]	; 3002f4c8 <suspector_thread+0x308>
3002f3b0:	e58d2008 	str	r2, [sp, #8]
3002f3b4:	e1a00003 	mov	r0, r3
3002f3b8:	e3a01802 	mov	r1, #131072	; 0x20000
3002f3bc:	e3a02000 	mov	r2, #0
3002f3c0:	e59f3104 	ldr	r3, [pc, #260]	; 3002f4cc <suspector_thread+0x30c>
3002f3c4:	ebff4a1a 	bl	30001c34 <create_thread_ext>
3002f3c8:	e1a02000 	mov	r2, r0
3002f3cc:	e59f30e4 	ldr	r3, [pc, #228]	; 3002f4b8 <suspector_thread+0x2f8>
3002f3d0:	e5832000 	str	r2, [r3]
				if((cur_file_name[2]=='w') || (cur_file_name[2]=='W'))
3002f3d4:	e59f30e4 	ldr	r3, [pc, #228]	; 3002f4c0 <suspector_thread+0x300>
3002f3d8:	e5d33002 	ldrb	r3, [r3, #2]
3002f3dc:	e3530077 	cmp	r3, #119	; 0x77
3002f3e0:	0a000003 	beq	3002f3f4 <suspector_thread+0x234>
3002f3e4:	e59f30d4 	ldr	r3, [pc, #212]	; 3002f4c0 <suspector_thread+0x300>
3002f3e8:	e5d33002 	ldrb	r3, [r3, #2]
3002f3ec:	e3530057 	cmp	r3, #87	; 0x57
3002f3f0:	1a000021 	bne	3002f47c <suspector_thread+0x2bc>
					id = acoral_create_thread_ext(local_wav_file_read, 8192*16, 0, "local_wav_file_read", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
3002f3f4:	e59f30d4 	ldr	r3, [pc, #212]	; 3002f4d0 <suspector_thread+0x310>
3002f3f8:	e3a02000 	mov	r2, #0
3002f3fc:	e58d2000 	str	r2, [sp]
3002f400:	e3a02018 	mov	r2, #24
3002f404:	e58d2004 	str	r2, [sp, #4]
3002f408:	e59f20b8 	ldr	r2, [pc, #184]	; 3002f4c8 <suspector_thread+0x308>
3002f40c:	e58d2008 	str	r2, [sp, #8]
3002f410:	e1a00003 	mov	r0, r3
3002f414:	e3a01802 	mov	r1, #131072	; 0x20000
3002f418:	e3a02000 	mov	r2, #0
3002f41c:	e59f30b0 	ldr	r3, [pc, #176]	; 3002f4d4 <suspector_thread+0x314>
3002f420:	ebff4a03 	bl	30001c34 <create_thread_ext>
3002f424:	e1a02000 	mov	r2, r0
3002f428:	e59f3088 	ldr	r3, [pc, #136]	; 3002f4b8 <suspector_thread+0x2f8>
3002f42c:	e5832000 	str	r2, [r3]
3002f430:	ea000012 	b	3002f480 <suspector_thread+0x2c0>
			}
			else if(play_model == Online) {
3002f434:	e59f3060 	ldr	r3, [pc, #96]	; 3002f49c <suspector_thread+0x2dc>
3002f438:	e5933000 	ldr	r3, [r3]
3002f43c:	e3530016 	cmp	r3, #22
3002f440:	1a00000e 	bne	3002f480 <suspector_thread+0x2c0>
				id = acoral_create_thread(client_init,8192,NULL,"client",13,0);
3002f444:	e59f308c 	ldr	r3, [pc, #140]	; 3002f4d8 <suspector_thread+0x318>
3002f448:	e3a0200d 	mov	r2, #13
3002f44c:	e58d2000 	str	r2, [sp]
3002f450:	e3a02000 	mov	r2, #0
3002f454:	e58d2004 	str	r2, [sp, #4]
3002f458:	e1a00003 	mov	r0, r3
3002f45c:	e3a01a02 	mov	r1, #8192	; 0x2000
3002f460:	e3a02000 	mov	r2, #0
3002f464:	e59f3070 	ldr	r3, [pc, #112]	; 3002f4dc <suspector_thread+0x31c>
3002f468:	ebff4ecd 	bl	30002fa4 <create_comm_thread>
3002f46c:	e1a02000 	mov	r2, r0
3002f470:	e59f3040 	ldr	r3, [pc, #64]	; 3002f4b8 <suspector_thread+0x2f8>
3002f474:	e5832000 	str	r2, [r3]
3002f478:	ea000000 	b	3002f480 <suspector_thread+0x2c0>
			//acoral_print("not support yet! \n");
				play_status = Play;
				if((cur_file_name[2]=='m') || (cur_file_name[2]=='M'))
					id = acoral_create_thread_ext(local_mp3_file_read, 8192*16, 0, "local_mp3_file_read", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
				if((cur_file_name[2]=='w') || (cur_file_name[2]=='W'))
					id = acoral_create_thread_ext(local_wav_file_read, 8192*16, 0, "local_wav_file_read", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
3002f47c:	e1a00000 	nop			; (mov r0, r0)
			}
			else if(play_model == Online) {
				id = acoral_create_thread(client_init,8192,NULL,"client",13,0);
			}
		    end_of_song = 0;
3002f480:	e59f3010 	ldr	r3, [pc, #16]	; 3002f498 <suspector_thread+0x2d8>
3002f484:	e3a02000 	mov	r2, #0
3002f488:	e5832000 	str	r2, [r3]
		}
		acoral_delay_self(200);
3002f48c:	e3a000c8 	mov	r0, #200	; 0xc8
3002f490:	ebff4d3b 	bl	30002984 <acoral_delay_self>
	}
3002f494:	eaffff4e 	b	3002f1d4 <suspector_thread+0x14>
3002f498:	300e58c4 	.word	0x300e58c4
3002f49c:	300c5fa0 	.word	0x300c5fa0
3002f4a0:	300c5f9c 	.word	0x300c5f9c
3002f4a4:	300e58c0 	.word	0x300e58c0
3002f4a8:	3012b680 	.word	0x3012b680
3002f4ac:	302be6ac 	.word	0x302be6ac
3002f4b0:	300eaab0 	.word	0x300eaab0
3002f4b4:	302bf844 	.word	0x302bf844
3002f4b8:	3012a81c 	.word	0x3012a81c
3002f4bc:	302be3dc 	.word	0x302be3dc
3002f4c0:	300eaa24 	.word	0x300eaa24
3002f4c4:	30033464 	.word	0x30033464
3002f4c8:	3012d6e0 	.word	0x3012d6e0
3002f4cc:	30045ecc 	.word	0x30045ecc
3002f4d0:	300338ec 	.word	0x300338ec
3002f4d4:	30045ee0 	.word	0x30045ee0
3002f4d8:	3003405c 	.word	0x3003405c
3002f4dc:	30045ef4 	.word	0x30045ef4

3002f4e0 <main_thread>:
}


void main_thread(void)
{
3002f4e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3002f4e4:	e24dd01c 	sub	sp, sp, #28
	int i, j;
	data.cpu = 0;
3002f4e8:	e59f3ba8 	ldr	r3, [pc, #2984]	; 30030098 <main_thread+0xbb8>
3002f4ec:	e3a02000 	mov	r2, #0
3002f4f0:	e5c32000 	strb	r2, [r3]
	data.prio = 20;
3002f4f4:	e59f3b9c 	ldr	r3, [pc, #2972]	; 30030098 <main_thread+0xbb8>
3002f4f8:	e3a02014 	mov	r2, #20
3002f4fc:	e5c32001 	strb	r2, [r3, #1]
	data.slice = 100;
3002f500:	e59f3b90 	ldr	r3, [pc, #2960]	; 30030098 <main_thread+0xbb8>
3002f504:	e3a02064 	mov	r2, #100	; 0x64
3002f508:	e5832004 	str	r2, [r3, #4]
	Lcd_TFT_Init();
3002f50c:	ebfffddb 	bl	3002ec80 <Lcd_TFT_Init>
	Paint_Bmp(0, 0, 480, 272, bg1);
3002f510:	e59f3b84 	ldr	r3, [pc, #2948]	; 3003009c <main_thread+0xbbc>
3002f514:	e58d3000 	str	r3, [sp]
3002f518:	e3a00000 	mov	r0, #0
3002f51c:	e3a01000 	mov	r1, #0
3002f520:	e3a02e1e 	mov	r2, #480	; 0x1e0
3002f524:	e3a03e11 	mov	r3, #272	; 0x110
3002f528:	ebfffd86 	bl	3002eb48 <Paint_Bmp>
	acoral_create_thread(suspector_thread,8192,NULL,"suspector_thread",13,0);
3002f52c:	e59f3b6c 	ldr	r3, [pc, #2924]	; 300300a0 <main_thread+0xbc0>
3002f530:	e3a0200d 	mov	r2, #13
3002f534:	e58d2000 	str	r2, [sp]
3002f538:	e3a02000 	mov	r2, #0
3002f53c:	e58d2004 	str	r2, [sp, #4]
3002f540:	e1a00003 	mov	r0, r3
3002f544:	e3a01a02 	mov	r1, #8192	; 0x2000
3002f548:	e3a02000 	mov	r2, #0
3002f54c:	e59f3b50 	ldr	r3, [pc, #2896]	; 300300a4 <main_thread+0xbc4>
3002f550:	ebff4e93 	bl	30002fa4 <create_comm_thread>
	end_of_song = 0;
3002f554:	e59f3b4c 	ldr	r3, [pc, #2892]	; 300300a8 <main_thread+0xbc8>
3002f558:	e3a02000 	mov	r2, #0
3002f55c:	e5832000 	str	r2, [r3]
	play_model = Local;
3002f560:	e59f3b44 	ldr	r3, [pc, #2884]	; 300300ac <main_thread+0xbcc>
3002f564:	e3a02015 	mov	r2, #21
3002f568:	e5832000 	str	r2, [r3]
3002f56c:	ea000002 	b	3002f57c <main_thread+0x9c>
					break;
			}
		}

		//acoral_delay_self(100);
   	}
3002f570:	e1a00000 	nop			; (mov r0, r0)
3002f574:	ea000000 	b	3002f57c <main_thread+0x9c>
3002f578:	e1a00000 	nop			; (mov r0, r0)
	cur_file_name[3] = 'a';
	cur_file_name[4] = 'v';*/
	//id = acoral_create_thread_ext(local_wav_file_read, 8192*16, 0, "local_wav_file_read", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
	//get_local_file_dir();
	while(1){
		ts_command();
3002f57c:	ebfffdca 	bl	3002ecac <ts_command>

		if(status_changed) {
3002f580:	e59f3b28 	ldr	r3, [pc, #2856]	; 300300b0 <main_thread+0xbd0>
3002f584:	e5933000 	ldr	r3, [r3]
3002f588:	e3530000 	cmp	r3, #0
3002f58c:	0afffff7 	beq	3002f570 <main_thread+0x90>
			acoral_print("changed ! \n");
3002f590:	e59f0b1c 	ldr	r0, [pc, #2844]	; 300300b4 <main_thread+0xbd4>
3002f594:	ebff6f29 	bl	3000b240 <acoral_print>
			status_changed = 0;
3002f598:	e59f3b10 	ldr	r3, [pc, #2832]	; 300300b0 <main_thread+0xbd0>
3002f59c:	e3a02000 	mov	r2, #0
3002f5a0:	e5832000 	str	r2, [r3]
			switch(play_command) {
3002f5a4:	e59f3b0c 	ldr	r3, [pc, #2828]	; 300300b8 <main_thread+0xbd8>
3002f5a8:	e5933000 	ldr	r3, [r3]
3002f5ac:	e2433001 	sub	r3, r3, #1
3002f5b0:	e3530015 	cmp	r3, #21
3002f5b4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3002f5b8:	eaffffee 	b	3002f578 <main_thread+0x98>
3002f5bc:	3002f614 	.word	0x3002f614
3002f5c0:	3002f87c 	.word	0x3002f87c
3002f5c4:	3002f8bc 	.word	0x3002f8bc
3002f5c8:	3002f8fc 	.word	0x3002f8fc
3002f5cc:	3002fc08 	.word	0x3002fc08
3002f5d0:	3002f578 	.word	0x3002f578
3002f5d4:	3002f578 	.word	0x3002f578
3002f5d8:	3002f578 	.word	0x3002f578
3002f5dc:	3002f578 	.word	0x3002f578
3002f5e0:	3002f578 	.word	0x3002f578
3002f5e4:	3002f578 	.word	0x3002f578
3002f5e8:	3002f578 	.word	0x3002f578
3002f5ec:	3002f578 	.word	0x3002f578
3002f5f0:	3002f578 	.word	0x3002f578
3002f5f4:	3002f578 	.word	0x3002f578
3002f5f8:	3002f578 	.word	0x3002f578
3002f5fc:	3002f578 	.word	0x3002f578
3002f600:	3002f578 	.word	0x3002f578
3002f604:	3002f578 	.word	0x3002f578
3002f608:	3002f578 	.word	0x3002f578
3002f60c:	3002ff34 	.word	0x3002ff34
3002f610:	3002ffe8 	.word	0x3002ffe8
				case Start_Stop:
					if(play_status == First_Song) {
3002f614:	e59f3aa0 	ldr	r3, [pc, #2720]	; 300300bc <main_thread+0xbdc>
3002f618:	e5933000 	ldr	r3, [r3]
3002f61c:	e3530002 	cmp	r3, #2
3002f620:	1a000081 	bne	3002f82c <main_thread+0x34c>
							cur_song = 0;
3002f624:	e59f3a94 	ldr	r3, [pc, #2708]	; 300300c0 <main_thread+0xbe0>
3002f628:	e3a02000 	mov	r2, #0
3002f62c:	e5832000 	str	r2, [r3]
						  if(play_model == Local) {
3002f630:	e59f3a74 	ldr	r3, [pc, #2676]	; 300300ac <main_thread+0xbcc>
3002f634:	e5933000 	ldr	r3, [r3]
3002f638:	e3530015 	cmp	r3, #21
3002f63c:	1a000065 	bne	3002f7d8 <main_thread+0x2f8>
							    get_local_file_dir();
3002f640:	ebfffe7a 	bl	3002f030 <get_local_file_dir>
								j = 0;
3002f644:	e3a03000 	mov	r3, #0
3002f648:	e58d3014 	str	r3, [sp, #20]
								for(i=0; i<20; i++) {
3002f64c:	e3a03000 	mov	r3, #0
3002f650:	e58d3010 	str	r3, [sp, #16]
3002f654:	ea00002a 	b	3002f704 <main_thread+0x224>
									if(local_file_dir[cur_song][i] != 32) {
3002f658:	e59f3a60 	ldr	r3, [pc, #2656]	; 300300c0 <main_thread+0xbe0>
3002f65c:	e5932000 	ldr	r2, [r3]
3002f660:	e59d0010 	ldr	r0, [sp, #16]
3002f664:	e59f1a58 	ldr	r1, [pc, #2648]	; 300300c4 <main_thread+0xbe4>
3002f668:	e1a03002 	mov	r3, r2
3002f66c:	e1a03103 	lsl	r3, r3, #2
3002f670:	e0833002 	add	r3, r3, r2
3002f674:	e1a03103 	lsl	r3, r3, #2
3002f678:	e0833000 	add	r3, r3, r0
3002f67c:	e0833001 	add	r3, r3, r1
3002f680:	e5d33000 	ldrb	r3, [r3]
3002f684:	e3530020 	cmp	r3, #32
3002f688:	0a00001a 	beq	3002f6f8 <main_thread+0x218>
										cur_file_name[j] = local_file_dir[cur_song][i];
3002f68c:	e59d1014 	ldr	r1, [sp, #20]
3002f690:	e59f3a28 	ldr	r3, [pc, #2600]	; 300300c0 <main_thread+0xbe0>
3002f694:	e5932000 	ldr	r2, [r3]
3002f698:	e59dc010 	ldr	ip, [sp, #16]
3002f69c:	e59f0a20 	ldr	r0, [pc, #2592]	; 300300c4 <main_thread+0xbe4>
3002f6a0:	e1a03002 	mov	r3, r2
3002f6a4:	e1a03103 	lsl	r3, r3, #2
3002f6a8:	e0833002 	add	r3, r3, r2
3002f6ac:	e1a03103 	lsl	r3, r3, #2
3002f6b0:	e083300c 	add	r3, r3, ip
3002f6b4:	e0833000 	add	r3, r3, r0
3002f6b8:	e5d32000 	ldrb	r2, [r3]
3002f6bc:	e59f3a04 	ldr	r3, [pc, #2564]	; 300300c8 <main_thread+0xbe8>
3002f6c0:	e7c32001 	strb	r2, [r3, r1]
										j ++;
3002f6c4:	e59d3014 	ldr	r3, [sp, #20]
3002f6c8:	e2833001 	add	r3, r3, #1
3002f6cc:	e58d3014 	str	r3, [sp, #20]
										if(j == 1)
3002f6d0:	e59d3014 	ldr	r3, [sp, #20]
3002f6d4:	e3530001 	cmp	r3, #1
3002f6d8:	1a000006 	bne	3002f6f8 <main_thread+0x218>
											cur_file_name[j++] = '.';
3002f6dc:	e59d3014 	ldr	r3, [sp, #20]
3002f6e0:	e59f29e0 	ldr	r2, [pc, #2528]	; 300300c8 <main_thread+0xbe8>
3002f6e4:	e3a0102e 	mov	r1, #46	; 0x2e
3002f6e8:	e7c21003 	strb	r1, [r2, r3]
3002f6ec:	e59d3014 	ldr	r3, [sp, #20]
3002f6f0:	e2833001 	add	r3, r3, #1
3002f6f4:	e58d3014 	str	r3, [sp, #20]
					if(play_status == First_Song) {
							cur_song = 0;
						  if(play_model == Local) {
							    get_local_file_dir();
								j = 0;
								for(i=0; i<20; i++) {
3002f6f8:	e59d3010 	ldr	r3, [sp, #16]
3002f6fc:	e2833001 	add	r3, r3, #1
3002f700:	e58d3010 	str	r3, [sp, #16]
3002f704:	e59d3010 	ldr	r3, [sp, #16]
3002f708:	e3530013 	cmp	r3, #19
3002f70c:	daffffd1 	ble	3002f658 <main_thread+0x178>
										if(j == 1)
											cur_file_name[j++] = '.';
									}
								}
							//acoral_print("not support yet! \n");
								play_status = Play;
3002f710:	e59f39a4 	ldr	r3, [pc, #2468]	; 300300bc <main_thread+0xbdc>
3002f714:	e3a02001 	mov	r2, #1
3002f718:	e5832000 	str	r2, [r3]
								if((cur_file_name[2]=='m') || (cur_file_name[2]=='M'))
3002f71c:	e59f39a4 	ldr	r3, [pc, #2468]	; 300300c8 <main_thread+0xbe8>
3002f720:	e5d33002 	ldrb	r3, [r3, #2]
3002f724:	e353006d 	cmp	r3, #109	; 0x6d
3002f728:	0a000003 	beq	3002f73c <main_thread+0x25c>
3002f72c:	e59f3994 	ldr	r3, [pc, #2452]	; 300300c8 <main_thread+0xbe8>
3002f730:	e5d33002 	ldrb	r3, [r3, #2]
3002f734:	e353004d 	cmp	r3, #77	; 0x4d
3002f738:	1a00000e 	bne	3002f778 <main_thread+0x298>
									id = acoral_create_thread_ext(local_mp3_file_read, 8192*16, 0, "local_mp3_file_read", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
3002f73c:	e59f3988 	ldr	r3, [pc, #2440]	; 300300cc <main_thread+0xbec>
3002f740:	e3a02000 	mov	r2, #0
3002f744:	e58d2000 	str	r2, [sp]
3002f748:	e3a02018 	mov	r2, #24
3002f74c:	e58d2004 	str	r2, [sp, #4]
3002f750:	e59f2940 	ldr	r2, [pc, #2368]	; 30030098 <main_thread+0xbb8>
3002f754:	e58d2008 	str	r2, [sp, #8]
3002f758:	e1a00003 	mov	r0, r3
3002f75c:	e3a01802 	mov	r1, #131072	; 0x20000
3002f760:	e3a02000 	mov	r2, #0
3002f764:	e59f3964 	ldr	r3, [pc, #2404]	; 300300d0 <main_thread+0xbf0>
3002f768:	ebff4931 	bl	30001c34 <create_thread_ext>
3002f76c:	e1a02000 	mov	r2, r0
3002f770:	e59f395c 	ldr	r3, [pc, #2396]	; 300300d4 <main_thread+0xbf4>
3002f774:	e5832000 	str	r2, [r3]
								if((cur_file_name[2]=='w') || (cur_file_name[2]=='W'))
3002f778:	e59f3948 	ldr	r3, [pc, #2376]	; 300300c8 <main_thread+0xbe8>
3002f77c:	e5d33002 	ldrb	r3, [r3, #2]
3002f780:	e3530077 	cmp	r3, #119	; 0x77
3002f784:	0a000003 	beq	3002f798 <main_thread+0x2b8>
3002f788:	e59f3938 	ldr	r3, [pc, #2360]	; 300300c8 <main_thread+0xbe8>
3002f78c:	e5d33002 	ldrb	r3, [r3, #2]
3002f790:	e3530057 	cmp	r3, #87	; 0x57
3002f794:	1a00000e 	bne	3002f7d4 <main_thread+0x2f4>
									id = acoral_create_thread_ext(local_wav_file_read, 8192*16, 0, "local_wav_file_read", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
3002f798:	e59f3938 	ldr	r3, [pc, #2360]	; 300300d8 <main_thread+0xbf8>
3002f79c:	e3a02000 	mov	r2, #0
3002f7a0:	e58d2000 	str	r2, [sp]
3002f7a4:	e3a02018 	mov	r2, #24
3002f7a8:	e58d2004 	str	r2, [sp, #4]
3002f7ac:	e59f28e4 	ldr	r2, [pc, #2276]	; 30030098 <main_thread+0xbb8>
3002f7b0:	e58d2008 	str	r2, [sp, #8]
3002f7b4:	e1a00003 	mov	r0, r3
3002f7b8:	e3a01802 	mov	r1, #131072	; 0x20000
3002f7bc:	e3a02000 	mov	r2, #0
3002f7c0:	e59f3914 	ldr	r3, [pc, #2324]	; 300300dc <main_thread+0xbfc>
3002f7c4:	ebff491a 	bl	30001c34 <create_thread_ext>
3002f7c8:	e1a02000 	mov	r2, r0
3002f7cc:	e59f3900 	ldr	r3, [pc, #2304]	; 300300d4 <main_thread+0xbf4>
3002f7d0:	e5832000 	str	r2, [r3]
3002f7d4:	ea000013 	b	3002f828 <main_thread+0x348>
							}
							else if(play_model == Online) {
3002f7d8:	e59f38cc 	ldr	r3, [pc, #2252]	; 300300ac <main_thread+0xbcc>
3002f7dc:	e5933000 	ldr	r3, [r3]
3002f7e0:	e3530016 	cmp	r3, #22
3002f7e4:	1a00000f 	bne	3002f828 <main_thread+0x348>
								//id = acoral_create_thread_ext(client_init, 8192*16, 0, "client_init", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
								play_status = Play;
3002f7e8:	e59f38cc 	ldr	r3, [pc, #2252]	; 300300bc <main_thread+0xbdc>
3002f7ec:	e3a02001 	mov	r2, #1
3002f7f0:	e5832000 	str	r2, [r3]
								id = acoral_create_thread(client_init,8192,NULL,"client",13,0);
3002f7f4:	e59f38e4 	ldr	r3, [pc, #2276]	; 300300e0 <main_thread+0xc00>
3002f7f8:	e3a0200d 	mov	r2, #13
3002f7fc:	e58d2000 	str	r2, [sp]
3002f800:	e3a02000 	mov	r2, #0
3002f804:	e58d2004 	str	r2, [sp, #4]
3002f808:	e1a00003 	mov	r0, r3
3002f80c:	e3a01a02 	mov	r1, #8192	; 0x2000
3002f810:	e3a02000 	mov	r2, #0
3002f814:	e59f38c8 	ldr	r3, [pc, #2248]	; 300300e4 <main_thread+0xc04>
3002f818:	ebff4de1 	bl	30002fa4 <create_comm_thread>
3002f81c:	e1a02000 	mov	r2, r0
3002f820:	e59f38ac 	ldr	r3, [pc, #2220]	; 300300d4 <main_thread+0xbf4>
3002f824:	e5832000 	str	r2, [r3]
3002f828:	ea000012 	b	3002f878 <main_thread+0x398>
							}
					}
					else if(play_status == Pause) {
3002f82c:	e59f3888 	ldr	r3, [pc, #2184]	; 300300bc <main_thread+0xbdc>
3002f830:	e5933000 	ldr	r3, [r3]
3002f834:	e3530000 	cmp	r3, #0
3002f838:	1a000005 	bne	3002f854 <main_thread+0x374>
						// play the music
						//if(play_model == Local) {
							waveOutRestart(0);
3002f83c:	e3a00000 	mov	r0, #0
3002f840:	eb0007b6 	bl	30031720 <waveOutRestart>
							play_status = Play;
3002f844:	e59f3870 	ldr	r3, [pc, #2160]	; 300300bc <main_thread+0xbdc>
3002f848:	e3a02001 	mov	r2, #1
3002f84c:	e5832000 	str	r2, [r3]
3002f850:	ea000008 	b	3002f878 <main_thread+0x398>
						//}
						//else
							//acoral_print("not support!!!!!");
					}
					else if(play_status == Play) {
3002f854:	e59f3860 	ldr	r3, [pc, #2144]	; 300300bc <main_thread+0xbdc>
3002f858:	e5933000 	ldr	r3, [r3]
3002f85c:	e3530001 	cmp	r3, #1
3002f860:	1a000004 	bne	3002f878 <main_thread+0x398>
						//if(play_model == Local) {
							waveOutPause(0);
3002f864:	e3a00000 	mov	r0, #0
3002f868:	eb000796 	bl	300316c8 <waveOutPause>
							play_status = Pause;
3002f86c:	e59f3848 	ldr	r3, [pc, #2120]	; 300300bc <main_thread+0xbdc>
3002f870:	e3a02000 	mov	r2, #0
3002f874:	e5832000 	str	r2, [r3]
						//}
						//else
							//acoral_print("not support!!!!!");
					}
					break;
3002f878:	ea000205 	b	30030094 <main_thread+0xbb4>
				case Inc_Vol:
					waveOutGetVolume(0,	&play_volume);
3002f87c:	e59f3864 	ldr	r3, [pc, #2148]	; 300300e8 <main_thread+0xc08>
3002f880:	e3a00000 	mov	r0, #0
3002f884:	e1a01003 	mov	r1, r3
3002f888:	eb000775 	bl	30031664 <waveOutGetVolume>
					play_volume += 5000;
3002f88c:	e59f3854 	ldr	r3, [pc, #2132]	; 300300e8 <main_thread+0xc08>
3002f890:	e5933000 	ldr	r3, [r3]
3002f894:	e2833d4e 	add	r3, r3, #4992	; 0x1380
3002f898:	e2833008 	add	r3, r3, #8
3002f89c:	e59f2844 	ldr	r2, [pc, #2116]	; 300300e8 <main_thread+0xc08>
3002f8a0:	e5823000 	str	r3, [r2]
					waveOutSetVolume(0, play_volume);
3002f8a4:	e59f383c 	ldr	r3, [pc, #2108]	; 300300e8 <main_thread+0xc08>
3002f8a8:	e5933000 	ldr	r3, [r3]
3002f8ac:	e3a00000 	mov	r0, #0
3002f8b0:	e1a01003 	mov	r1, r3
3002f8b4:	eb00074b 	bl	300315e8 <waveOutSetVolume>
					break;
3002f8b8:	ea0001f5 	b	30030094 <main_thread+0xbb4>
				case Dec_Vol:
					waveOutGetVolume(0,	&play_volume);
3002f8bc:	e59f3824 	ldr	r3, [pc, #2084]	; 300300e8 <main_thread+0xc08>
3002f8c0:	e3a00000 	mov	r0, #0
3002f8c4:	e1a01003 	mov	r1, r3
3002f8c8:	eb000765 	bl	30031664 <waveOutGetVolume>
					play_volume -= 5000;
3002f8cc:	e59f3814 	ldr	r3, [pc, #2068]	; 300300e8 <main_thread+0xc08>
3002f8d0:	e5933000 	ldr	r3, [r3]
3002f8d4:	e2433d4e 	sub	r3, r3, #4992	; 0x1380
3002f8d8:	e2433008 	sub	r3, r3, #8
3002f8dc:	e59f2804 	ldr	r2, [pc, #2052]	; 300300e8 <main_thread+0xc08>
3002f8e0:	e5823000 	str	r3, [r2]
					waveOutSetVolume(0, play_volume);
3002f8e4:	e59f37fc 	ldr	r3, [pc, #2044]	; 300300e8 <main_thread+0xc08>
3002f8e8:	e5933000 	ldr	r3, [r3]
3002f8ec:	e3a00000 	mov	r0, #0
3002f8f0:	e1a01003 	mov	r1, r3
3002f8f4:	eb00073b 	bl	300315e8 <waveOutSetVolume>
					break;
3002f8f8:	ea0001e5 	b	30030094 <main_thread+0xbb4>
				case Next_Song:
					if(play_model == Local) {
3002f8fc:	e59f37a8 	ldr	r3, [pc, #1960]	; 300300ac <main_thread+0xbcc>
3002f900:	e5933000 	ldr	r3, [r3]
3002f904:	e3530015 	cmp	r3, #21
3002f908:	1a000085 	bne	3002fb24 <main_thread+0x644>
						waveOutClose(0);
3002f90c:	e3a00000 	mov	r0, #0
3002f910:	eb000695 	bl	3003136c <waveOutClose>
						play_status = Play;
3002f914:	e59f37a0 	ldr	r3, [pc, #1952]	; 300300bc <main_thread+0xbdc>
3002f918:	e3a02001 	mov	r2, #1
3002f91c:	e5832000 	str	r2, [r3]
						cur_song = (cur_song+1)%song_num;
3002f920:	e59f3798 	ldr	r3, [pc, #1944]	; 300300c0 <main_thread+0xbe0>
3002f924:	e5933000 	ldr	r3, [r3]
3002f928:	e2832001 	add	r2, r3, #1
3002f92c:	e59f37b8 	ldr	r3, [pc, #1976]	; 300300ec <main_thread+0xc0c>
3002f930:	e5933000 	ldr	r3, [r3]
3002f934:	e1a00002 	mov	r0, r2
3002f938:	e1a01003 	mov	r1, r3
3002f93c:	eb005166 	bl	30043edc <__aeabi_idivmod>
3002f940:	e1a03001 	mov	r3, r1
3002f944:	e1a02003 	mov	r2, r3
3002f948:	e59f3770 	ldr	r3, [pc, #1904]	; 300300c0 <main_thread+0xbe0>
3002f94c:	e5832000 	str	r2, [r3]
						acoral_close(cur_file_ptr);
3002f950:	e59f3798 	ldr	r3, [pc, #1944]	; 300300f0 <main_thread+0xc10>
3002f954:	e5933000 	ldr	r3, [r3]
3002f958:	e1a00003 	mov	r0, r3
3002f95c:	ebffee33 	bl	3002b230 <acoral_close>
						acoral_kill_thread_by_id(pcm_player_id);
3002f960:	e59f378c 	ldr	r3, [pc, #1932]	; 300300f4 <main_thread+0xc14>
3002f964:	e5933000 	ldr	r3, [r3]
3002f968:	e1a00003 	mov	r0, r3
3002f96c:	ebff4c37 	bl	30002a50 <acoral_kill_thread_by_id>
						acoral_kill_thread_by_id(mp3_decoder_id);
3002f970:	e59f3780 	ldr	r3, [pc, #1920]	; 300300f8 <main_thread+0xc18>
3002f974:	e5933000 	ldr	r3, [r3]
3002f978:	e1a00003 	mov	r0, r3
3002f97c:	ebff4c33 	bl	30002a50 <acoral_kill_thread_by_id>
						acoral_kill_thread_by_id(id);
3002f980:	e59f374c 	ldr	r3, [pc, #1868]	; 300300d4 <main_thread+0xbf4>
3002f984:	e5933000 	ldr	r3, [r3]
3002f988:	e1a00003 	mov	r0, r3
3002f98c:	ebff4c2f 	bl	30002a50 <acoral_kill_thread_by_id>
						j = 0;
3002f990:	e3a03000 	mov	r3, #0
3002f994:	e58d3014 	str	r3, [sp, #20]
						for(i=0; i<20; i++) {
3002f998:	e3a03000 	mov	r3, #0
3002f99c:	e58d3010 	str	r3, [sp, #16]
3002f9a0:	ea00002a 	b	3002fa50 <main_thread+0x570>
							if(local_file_dir[cur_song][i] != 32) {
3002f9a4:	e59f3714 	ldr	r3, [pc, #1812]	; 300300c0 <main_thread+0xbe0>
3002f9a8:	e5932000 	ldr	r2, [r3]
3002f9ac:	e59d0010 	ldr	r0, [sp, #16]
3002f9b0:	e59f170c 	ldr	r1, [pc, #1804]	; 300300c4 <main_thread+0xbe4>
3002f9b4:	e1a03002 	mov	r3, r2
3002f9b8:	e1a03103 	lsl	r3, r3, #2
3002f9bc:	e0833002 	add	r3, r3, r2
3002f9c0:	e1a03103 	lsl	r3, r3, #2
3002f9c4:	e0833000 	add	r3, r3, r0
3002f9c8:	e0833001 	add	r3, r3, r1
3002f9cc:	e5d33000 	ldrb	r3, [r3]
3002f9d0:	e3530020 	cmp	r3, #32
3002f9d4:	0a00001a 	beq	3002fa44 <main_thread+0x564>
								cur_file_name[j] = local_file_dir[cur_song][i];
3002f9d8:	e59d1014 	ldr	r1, [sp, #20]
3002f9dc:	e59f36dc 	ldr	r3, [pc, #1756]	; 300300c0 <main_thread+0xbe0>
3002f9e0:	e5932000 	ldr	r2, [r3]
3002f9e4:	e59dc010 	ldr	ip, [sp, #16]
3002f9e8:	e59f06d4 	ldr	r0, [pc, #1748]	; 300300c4 <main_thread+0xbe4>
3002f9ec:	e1a03002 	mov	r3, r2
3002f9f0:	e1a03103 	lsl	r3, r3, #2
3002f9f4:	e0833002 	add	r3, r3, r2
3002f9f8:	e1a03103 	lsl	r3, r3, #2
3002f9fc:	e083300c 	add	r3, r3, ip
3002fa00:	e0833000 	add	r3, r3, r0
3002fa04:	e5d32000 	ldrb	r2, [r3]
3002fa08:	e59f36b8 	ldr	r3, [pc, #1720]	; 300300c8 <main_thread+0xbe8>
3002fa0c:	e7c32001 	strb	r2, [r3, r1]
								j ++;
3002fa10:	e59d3014 	ldr	r3, [sp, #20]
3002fa14:	e2833001 	add	r3, r3, #1
3002fa18:	e58d3014 	str	r3, [sp, #20]
								if(j == 1)
3002fa1c:	e59d3014 	ldr	r3, [sp, #20]
3002fa20:	e3530001 	cmp	r3, #1
3002fa24:	1a000006 	bne	3002fa44 <main_thread+0x564>
									cur_file_name[j++] = '.';
3002fa28:	e59d3014 	ldr	r3, [sp, #20]
3002fa2c:	e59f2694 	ldr	r2, [pc, #1684]	; 300300c8 <main_thread+0xbe8>
3002fa30:	e3a0102e 	mov	r1, #46	; 0x2e
3002fa34:	e7c21003 	strb	r1, [r2, r3]
3002fa38:	e59d3014 	ldr	r3, [sp, #20]
3002fa3c:	e2833001 	add	r3, r3, #1
3002fa40:	e58d3014 	str	r3, [sp, #20]
						acoral_close(cur_file_ptr);
						acoral_kill_thread_by_id(pcm_player_id);
						acoral_kill_thread_by_id(mp3_decoder_id);
						acoral_kill_thread_by_id(id);
						j = 0;
						for(i=0; i<20; i++) {
3002fa44:	e59d3010 	ldr	r3, [sp, #16]
3002fa48:	e2833001 	add	r3, r3, #1
3002fa4c:	e58d3010 	str	r3, [sp, #16]
3002fa50:	e59d3010 	ldr	r3, [sp, #16]
3002fa54:	e3530013 	cmp	r3, #19
3002fa58:	daffffd1 	ble	3002f9a4 <main_thread+0x4c4>
								if(j == 1)
									cur_file_name[j++] = '.';
								}
						}
					//acoral_print("not support yet! \n");
						play_status = Play;
3002fa5c:	e59f3658 	ldr	r3, [pc, #1624]	; 300300bc <main_thread+0xbdc>
3002fa60:	e3a02001 	mov	r2, #1
3002fa64:	e5832000 	str	r2, [r3]
						if((cur_file_name[2]=='m') || (cur_file_name[2]=='M'))
3002fa68:	e59f3658 	ldr	r3, [pc, #1624]	; 300300c8 <main_thread+0xbe8>
3002fa6c:	e5d33002 	ldrb	r3, [r3, #2]
3002fa70:	e353006d 	cmp	r3, #109	; 0x6d
3002fa74:	0a000003 	beq	3002fa88 <main_thread+0x5a8>
3002fa78:	e59f3648 	ldr	r3, [pc, #1608]	; 300300c8 <main_thread+0xbe8>
3002fa7c:	e5d33002 	ldrb	r3, [r3, #2]
3002fa80:	e353004d 	cmp	r3, #77	; 0x4d
3002fa84:	1a00000e 	bne	3002fac4 <main_thread+0x5e4>
							id = acoral_create_thread_ext(local_mp3_file_read, 8192*16, 0, "local_mp3_file_read", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
3002fa88:	e59f363c 	ldr	r3, [pc, #1596]	; 300300cc <main_thread+0xbec>
3002fa8c:	e3a02000 	mov	r2, #0
3002fa90:	e58d2000 	str	r2, [sp]
3002fa94:	e3a02018 	mov	r2, #24
3002fa98:	e58d2004 	str	r2, [sp, #4]
3002fa9c:	e59f25f4 	ldr	r2, [pc, #1524]	; 30030098 <main_thread+0xbb8>
3002faa0:	e58d2008 	str	r2, [sp, #8]
3002faa4:	e1a00003 	mov	r0, r3
3002faa8:	e3a01802 	mov	r1, #131072	; 0x20000
3002faac:	e3a02000 	mov	r2, #0
3002fab0:	e59f3618 	ldr	r3, [pc, #1560]	; 300300d0 <main_thread+0xbf0>
3002fab4:	ebff485e 	bl	30001c34 <create_thread_ext>
3002fab8:	e1a02000 	mov	r2, r0
3002fabc:	e59f3610 	ldr	r3, [pc, #1552]	; 300300d4 <main_thread+0xbf4>
3002fac0:	e5832000 	str	r2, [r3]
				    	if((cur_file_name[2]=='w') || (cur_file_name[2]=='W'))
3002fac4:	e59f35fc 	ldr	r3, [pc, #1532]	; 300300c8 <main_thread+0xbe8>
3002fac8:	e5d33002 	ldrb	r3, [r3, #2]
3002facc:	e3530077 	cmp	r3, #119	; 0x77
3002fad0:	0a000003 	beq	3002fae4 <main_thread+0x604>
3002fad4:	e59f35ec 	ldr	r3, [pc, #1516]	; 300300c8 <main_thread+0xbe8>
3002fad8:	e5d33002 	ldrb	r3, [r3, #2]
3002fadc:	e3530057 	cmp	r3, #87	; 0x57
3002fae0:	1a00000e 	bne	3002fb20 <main_thread+0x640>
							id = acoral_create_thread_ext(local_wav_file_read, 8192*16, 0, "local_wav_file_read", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
3002fae4:	e59f35ec 	ldr	r3, [pc, #1516]	; 300300d8 <main_thread+0xbf8>
3002fae8:	e3a02000 	mov	r2, #0
3002faec:	e58d2000 	str	r2, [sp]
3002faf0:	e3a02018 	mov	r2, #24
3002faf4:	e58d2004 	str	r2, [sp, #4]
3002faf8:	e59f2598 	ldr	r2, [pc, #1432]	; 30030098 <main_thread+0xbb8>
3002fafc:	e58d2008 	str	r2, [sp, #8]
3002fb00:	e1a00003 	mov	r0, r3
3002fb04:	e3a01802 	mov	r1, #131072	; 0x20000
3002fb08:	e3a02000 	mov	r2, #0
3002fb0c:	e59f35c8 	ldr	r3, [pc, #1480]	; 300300dc <main_thread+0xbfc>
3002fb10:	ebff4847 	bl	30001c34 <create_thread_ext>
3002fb14:	e1a02000 	mov	r2, r0
3002fb18:	e59f35b4 	ldr	r3, [pc, #1460]	; 300300d4 <main_thread+0xbf4>
3002fb1c:	e5832000 	str	r2, [r3]
3002fb20:	ea000037 	b	3002fc04 <main_thread+0x724>
					}
					else if(play_model == Online) {
3002fb24:	e59f3580 	ldr	r3, [pc, #1408]	; 300300ac <main_thread+0xbcc>
3002fb28:	e5933000 	ldr	r3, [r3]
3002fb2c:	e3530016 	cmp	r3, #22
3002fb30:	1a000033 	bne	3002fc04 <main_thread+0x724>
						waveOutPause(0);
3002fb34:	e3a00000 	mov	r0, #0
3002fb38:	eb0006e2 	bl	300316c8 <waveOutPause>
						acoral_delay_self(3000);
3002fb3c:	e3a00ebb 	mov	r0, #2992	; 0xbb0
3002fb40:	e2800008 	add	r0, r0, #8
3002fb44:	ebff4b8e 	bl	30002984 <acoral_delay_self>
						waveOutClose(0);
3002fb48:	e3a00000 	mov	r0, #0
3002fb4c:	eb000606 	bl	3003136c <waveOutClose>
						play_status = Play;
3002fb50:	e59f3564 	ldr	r3, [pc, #1380]	; 300300bc <main_thread+0xbdc>
3002fb54:	e3a02001 	mov	r2, #1
3002fb58:	e5832000 	str	r2, [r3]
						cur_song = (cur_song+1)%song_num;
3002fb5c:	e59f355c 	ldr	r3, [pc, #1372]	; 300300c0 <main_thread+0xbe0>
3002fb60:	e5933000 	ldr	r3, [r3]
3002fb64:	e2832001 	add	r2, r3, #1
3002fb68:	e59f357c 	ldr	r3, [pc, #1404]	; 300300ec <main_thread+0xc0c>
3002fb6c:	e5933000 	ldr	r3, [r3]
3002fb70:	e1a00002 	mov	r0, r2
3002fb74:	e1a01003 	mov	r1, r3
3002fb78:	eb0050d7 	bl	30043edc <__aeabi_idivmod>
3002fb7c:	e1a03001 	mov	r3, r1
3002fb80:	e1a02003 	mov	r2, r3
3002fb84:	e59f3534 	ldr	r3, [pc, #1332]	; 300300c0 <main_thread+0xbe0>
3002fb88:	e5832000 	str	r2, [r3]
						acoral_close(cur_file_ptr);
3002fb8c:	e59f355c 	ldr	r3, [pc, #1372]	; 300300f0 <main_thread+0xc10>
3002fb90:	e5933000 	ldr	r3, [r3]
3002fb94:	e1a00003 	mov	r0, r3
3002fb98:	ebffeda4 	bl	3002b230 <acoral_close>
						acoral_kill_thread_by_id(pcm_player_id);
3002fb9c:	e59f3550 	ldr	r3, [pc, #1360]	; 300300f4 <main_thread+0xc14>
3002fba0:	e5933000 	ldr	r3, [r3]
3002fba4:	e1a00003 	mov	r0, r3
3002fba8:	ebff4ba8 	bl	30002a50 <acoral_kill_thread_by_id>
						acoral_kill_thread_by_id(mp3_decoder_id);
3002fbac:	e59f3544 	ldr	r3, [pc, #1348]	; 300300f8 <main_thread+0xc18>
3002fbb0:	e5933000 	ldr	r3, [r3]
3002fbb4:	e1a00003 	mov	r0, r3
3002fbb8:	ebff4ba4 	bl	30002a50 <acoral_kill_thread_by_id>
						client_close();
3002fbbc:	eb0011a4 	bl	30034254 <client_close>
						acoral_kill_thread_by_id(id);
3002fbc0:	e59f350c 	ldr	r3, [pc, #1292]	; 300300d4 <main_thread+0xbf4>
3002fbc4:	e5933000 	ldr	r3, [r3]
3002fbc8:	e1a00003 	mov	r0, r3
3002fbcc:	ebff4b9f 	bl	30002a50 <acoral_kill_thread_by_id>
						//sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, 81920, 24);
						id = acoral_create_thread(client_init,8192,NULL,"client",13,0);
3002fbd0:	e59f3508 	ldr	r3, [pc, #1288]	; 300300e0 <main_thread+0xc00>
3002fbd4:	e3a0200d 	mov	r2, #13
3002fbd8:	e58d2000 	str	r2, [sp]
3002fbdc:	e3a02000 	mov	r2, #0
3002fbe0:	e58d2004 	str	r2, [sp, #4]
3002fbe4:	e1a00003 	mov	r0, r3
3002fbe8:	e3a01a02 	mov	r1, #8192	; 0x2000
3002fbec:	e3a02000 	mov	r2, #0
3002fbf0:	e59f34ec 	ldr	r3, [pc, #1260]	; 300300e4 <main_thread+0xc04>
3002fbf4:	ebff4cea 	bl	30002fa4 <create_comm_thread>
3002fbf8:	e1a02000 	mov	r2, r0
3002fbfc:	e59f34d0 	ldr	r3, [pc, #1232]	; 300300d4 <main_thread+0xbf4>
3002fc00:	e5832000 	str	r2, [r3]
					}

					break;
3002fc04:	ea000122 	b	30030094 <main_thread+0xbb4>
				case Pre_Song:
					if(play_model == Local) {
3002fc08:	e59f349c 	ldr	r3, [pc, #1180]	; 300300ac <main_thread+0xbcc>
3002fc0c:	e5933000 	ldr	r3, [r3]
3002fc10:	e3530015 	cmp	r3, #21
3002fc14:	1a000089 	bne	3002fe40 <main_thread+0x960>
						waveOutClose(0);
3002fc18:	e3a00000 	mov	r0, #0
3002fc1c:	eb0005d2 	bl	3003136c <waveOutClose>
						play_status = Play;
3002fc20:	e59f3494 	ldr	r3, [pc, #1172]	; 300300bc <main_thread+0xbdc>
3002fc24:	e3a02001 	mov	r2, #1
3002fc28:	e5832000 	str	r2, [r3]
						if(cur_song-1 < 0)
3002fc2c:	e59f348c 	ldr	r3, [pc, #1164]	; 300300c0 <main_thread+0xbe0>
3002fc30:	e5933000 	ldr	r3, [r3]
3002fc34:	e2433001 	sub	r3, r3, #1
3002fc38:	e3530000 	cmp	r3, #0
3002fc3c:	aa000005 	bge	3002fc58 <main_thread+0x778>
							cur_song = song_num-1;
3002fc40:	e59f34a4 	ldr	r3, [pc, #1188]	; 300300ec <main_thread+0xc0c>
3002fc44:	e5933000 	ldr	r3, [r3]
3002fc48:	e2432001 	sub	r2, r3, #1
3002fc4c:	e59f346c 	ldr	r3, [pc, #1132]	; 300300c0 <main_thread+0xbe0>
3002fc50:	e5832000 	str	r2, [r3]
3002fc54:	ea000004 	b	3002fc6c <main_thread+0x78c>
						else
							cur_song --;
3002fc58:	e59f3460 	ldr	r3, [pc, #1120]	; 300300c0 <main_thread+0xbe0>
3002fc5c:	e5933000 	ldr	r3, [r3]
3002fc60:	e2432001 	sub	r2, r3, #1
3002fc64:	e59f3454 	ldr	r3, [pc, #1108]	; 300300c0 <main_thread+0xbe0>
3002fc68:	e5832000 	str	r2, [r3]
						acoral_close(cur_file_ptr);
3002fc6c:	e59f347c 	ldr	r3, [pc, #1148]	; 300300f0 <main_thread+0xc10>
3002fc70:	e5933000 	ldr	r3, [r3]
3002fc74:	e1a00003 	mov	r0, r3
3002fc78:	ebffed6c 	bl	3002b230 <acoral_close>
						acoral_kill_thread_by_id(pcm_player_id);
3002fc7c:	e59f3470 	ldr	r3, [pc, #1136]	; 300300f4 <main_thread+0xc14>
3002fc80:	e5933000 	ldr	r3, [r3]
3002fc84:	e1a00003 	mov	r0, r3
3002fc88:	ebff4b70 	bl	30002a50 <acoral_kill_thread_by_id>
						acoral_kill_thread_by_id(mp3_decoder_id);
3002fc8c:	e59f3464 	ldr	r3, [pc, #1124]	; 300300f8 <main_thread+0xc18>
3002fc90:	e5933000 	ldr	r3, [r3]
3002fc94:	e1a00003 	mov	r0, r3
3002fc98:	ebff4b6c 	bl	30002a50 <acoral_kill_thread_by_id>
						acoral_kill_thread_by_id(id);
3002fc9c:	e59f3430 	ldr	r3, [pc, #1072]	; 300300d4 <main_thread+0xbf4>
3002fca0:	e5933000 	ldr	r3, [r3]
3002fca4:	e1a00003 	mov	r0, r3
3002fca8:	ebff4b68 	bl	30002a50 <acoral_kill_thread_by_id>
						j = 0;
3002fcac:	e3a03000 	mov	r3, #0
3002fcb0:	e58d3014 	str	r3, [sp, #20]
						for(i=0; i<20; i++) {
3002fcb4:	e3a03000 	mov	r3, #0
3002fcb8:	e58d3010 	str	r3, [sp, #16]
3002fcbc:	ea00002a 	b	3002fd6c <main_thread+0x88c>
							if(local_file_dir[cur_song][i] != 32) {
3002fcc0:	e59f33f8 	ldr	r3, [pc, #1016]	; 300300c0 <main_thread+0xbe0>
3002fcc4:	e5932000 	ldr	r2, [r3]
3002fcc8:	e59d0010 	ldr	r0, [sp, #16]
3002fccc:	e59f13f0 	ldr	r1, [pc, #1008]	; 300300c4 <main_thread+0xbe4>
3002fcd0:	e1a03002 	mov	r3, r2
3002fcd4:	e1a03103 	lsl	r3, r3, #2
3002fcd8:	e0833002 	add	r3, r3, r2
3002fcdc:	e1a03103 	lsl	r3, r3, #2
3002fce0:	e0833000 	add	r3, r3, r0
3002fce4:	e0833001 	add	r3, r3, r1
3002fce8:	e5d33000 	ldrb	r3, [r3]
3002fcec:	e3530020 	cmp	r3, #32
3002fcf0:	0a00001a 	beq	3002fd60 <main_thread+0x880>
								cur_file_name[j] = local_file_dir[cur_song][i];
3002fcf4:	e59d1014 	ldr	r1, [sp, #20]
3002fcf8:	e59f33c0 	ldr	r3, [pc, #960]	; 300300c0 <main_thread+0xbe0>
3002fcfc:	e5932000 	ldr	r2, [r3]
3002fd00:	e59dc010 	ldr	ip, [sp, #16]
3002fd04:	e59f03b8 	ldr	r0, [pc, #952]	; 300300c4 <main_thread+0xbe4>
3002fd08:	e1a03002 	mov	r3, r2
3002fd0c:	e1a03103 	lsl	r3, r3, #2
3002fd10:	e0833002 	add	r3, r3, r2
3002fd14:	e1a03103 	lsl	r3, r3, #2
3002fd18:	e083300c 	add	r3, r3, ip
3002fd1c:	e0833000 	add	r3, r3, r0
3002fd20:	e5d32000 	ldrb	r2, [r3]
3002fd24:	e59f339c 	ldr	r3, [pc, #924]	; 300300c8 <main_thread+0xbe8>
3002fd28:	e7c32001 	strb	r2, [r3, r1]
								j ++;
3002fd2c:	e59d3014 	ldr	r3, [sp, #20]
3002fd30:	e2833001 	add	r3, r3, #1
3002fd34:	e58d3014 	str	r3, [sp, #20]
								if(j == 1)
3002fd38:	e59d3014 	ldr	r3, [sp, #20]
3002fd3c:	e3530001 	cmp	r3, #1
3002fd40:	1a000006 	bne	3002fd60 <main_thread+0x880>
									cur_file_name[j++] = '.';
3002fd44:	e59d3014 	ldr	r3, [sp, #20]
3002fd48:	e59f2378 	ldr	r2, [pc, #888]	; 300300c8 <main_thread+0xbe8>
3002fd4c:	e3a0102e 	mov	r1, #46	; 0x2e
3002fd50:	e7c21003 	strb	r1, [r2, r3]
3002fd54:	e59d3014 	ldr	r3, [sp, #20]
3002fd58:	e2833001 	add	r3, r3, #1
3002fd5c:	e58d3014 	str	r3, [sp, #20]
						acoral_close(cur_file_ptr);
						acoral_kill_thread_by_id(pcm_player_id);
						acoral_kill_thread_by_id(mp3_decoder_id);
						acoral_kill_thread_by_id(id);
						j = 0;
						for(i=0; i<20; i++) {
3002fd60:	e59d3010 	ldr	r3, [sp, #16]
3002fd64:	e2833001 	add	r3, r3, #1
3002fd68:	e58d3010 	str	r3, [sp, #16]
3002fd6c:	e59d3010 	ldr	r3, [sp, #16]
3002fd70:	e3530013 	cmp	r3, #19
3002fd74:	daffffd1 	ble	3002fcc0 <main_thread+0x7e0>
								if(j == 1)
									cur_file_name[j++] = '.';
							}
						}
						//acoral_print("not support yet! \n");
						play_status = Play;
3002fd78:	e59f333c 	ldr	r3, [pc, #828]	; 300300bc <main_thread+0xbdc>
3002fd7c:	e3a02001 	mov	r2, #1
3002fd80:	e5832000 	str	r2, [r3]
						if((cur_file_name[2]=='m') || (cur_file_name[2]=='M'))
3002fd84:	e59f333c 	ldr	r3, [pc, #828]	; 300300c8 <main_thread+0xbe8>
3002fd88:	e5d33002 	ldrb	r3, [r3, #2]
3002fd8c:	e353006d 	cmp	r3, #109	; 0x6d
3002fd90:	0a000003 	beq	3002fda4 <main_thread+0x8c4>
3002fd94:	e59f332c 	ldr	r3, [pc, #812]	; 300300c8 <main_thread+0xbe8>
3002fd98:	e5d33002 	ldrb	r3, [r3, #2]
3002fd9c:	e353004d 	cmp	r3, #77	; 0x4d
3002fda0:	1a00000e 	bne	3002fde0 <main_thread+0x900>
							id = acoral_create_thread_ext(local_mp3_file_read, 8192*16, 0, "local_mp3_file_read", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
3002fda4:	e59f3320 	ldr	r3, [pc, #800]	; 300300cc <main_thread+0xbec>
3002fda8:	e3a02000 	mov	r2, #0
3002fdac:	e58d2000 	str	r2, [sp]
3002fdb0:	e3a02018 	mov	r2, #24
3002fdb4:	e58d2004 	str	r2, [sp, #4]
3002fdb8:	e59f22d8 	ldr	r2, [pc, #728]	; 30030098 <main_thread+0xbb8>
3002fdbc:	e58d2008 	str	r2, [sp, #8]
3002fdc0:	e1a00003 	mov	r0, r3
3002fdc4:	e3a01802 	mov	r1, #131072	; 0x20000
3002fdc8:	e3a02000 	mov	r2, #0
3002fdcc:	e59f32fc 	ldr	r3, [pc, #764]	; 300300d0 <main_thread+0xbf0>
3002fdd0:	ebff4797 	bl	30001c34 <create_thread_ext>
3002fdd4:	e1a02000 	mov	r2, r0
3002fdd8:	e59f32f4 	ldr	r3, [pc, #756]	; 300300d4 <main_thread+0xbf4>
3002fddc:	e5832000 	str	r2, [r3]
						if((cur_file_name[2]=='w') || (cur_file_name[2]=='W'))
3002fde0:	e59f32e0 	ldr	r3, [pc, #736]	; 300300c8 <main_thread+0xbe8>
3002fde4:	e5d33002 	ldrb	r3, [r3, #2]
3002fde8:	e3530077 	cmp	r3, #119	; 0x77
3002fdec:	0a000003 	beq	3002fe00 <main_thread+0x920>
3002fdf0:	e59f32d0 	ldr	r3, [pc, #720]	; 300300c8 <main_thread+0xbe8>
3002fdf4:	e5d33002 	ldrb	r3, [r3, #2]
3002fdf8:	e3530057 	cmp	r3, #87	; 0x57
3002fdfc:	1a00000e 	bne	3002fe3c <main_thread+0x95c>
							id = acoral_create_thread_ext(local_wav_file_read, 8192*16, 0, "local_wav_file_read", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
3002fe00:	e59f32d0 	ldr	r3, [pc, #720]	; 300300d8 <main_thread+0xbf8>
3002fe04:	e3a02000 	mov	r2, #0
3002fe08:	e58d2000 	str	r2, [sp]
3002fe0c:	e3a02018 	mov	r2, #24
3002fe10:	e58d2004 	str	r2, [sp, #4]
3002fe14:	e59f227c 	ldr	r2, [pc, #636]	; 30030098 <main_thread+0xbb8>
3002fe18:	e58d2008 	str	r2, [sp, #8]
3002fe1c:	e1a00003 	mov	r0, r3
3002fe20:	e3a01802 	mov	r1, #131072	; 0x20000
3002fe24:	e3a02000 	mov	r2, #0
3002fe28:	e59f32ac 	ldr	r3, [pc, #684]	; 300300dc <main_thread+0xbfc>
3002fe2c:	ebff4780 	bl	30001c34 <create_thread_ext>
3002fe30:	e1a02000 	mov	r2, r0
3002fe34:	e59f3298 	ldr	r3, [pc, #664]	; 300300d4 <main_thread+0xbf4>
3002fe38:	e5832000 	str	r2, [r3]
3002fe3c:	ea00003b 	b	3002ff30 <main_thread+0xa50>
					}
					else if(play_model == Online) {
3002fe40:	e59f3264 	ldr	r3, [pc, #612]	; 300300ac <main_thread+0xbcc>
3002fe44:	e5933000 	ldr	r3, [r3]
3002fe48:	e3530016 	cmp	r3, #22
3002fe4c:	1a000037 	bne	3002ff30 <main_thread+0xa50>
						waveOutPause(0);
3002fe50:	e3a00000 	mov	r0, #0
3002fe54:	eb00061b 	bl	300316c8 <waveOutPause>
						acoral_delay_self(3000);
3002fe58:	e3a00ebb 	mov	r0, #2992	; 0xbb0
3002fe5c:	e2800008 	add	r0, r0, #8
3002fe60:	ebff4ac7 	bl	30002984 <acoral_delay_self>
						waveOutClose(0);
3002fe64:	e3a00000 	mov	r0, #0
3002fe68:	eb00053f 	bl	3003136c <waveOutClose>
						play_status = Play;
3002fe6c:	e59f3248 	ldr	r3, [pc, #584]	; 300300bc <main_thread+0xbdc>
3002fe70:	e3a02001 	mov	r2, #1
3002fe74:	e5832000 	str	r2, [r3]
						if(cur_song-1 < 0)
3002fe78:	e59f3240 	ldr	r3, [pc, #576]	; 300300c0 <main_thread+0xbe0>
3002fe7c:	e5933000 	ldr	r3, [r3]
3002fe80:	e2433001 	sub	r3, r3, #1
3002fe84:	e3530000 	cmp	r3, #0
3002fe88:	aa000005 	bge	3002fea4 <main_thread+0x9c4>
							cur_song = song_num-1;
3002fe8c:	e59f3258 	ldr	r3, [pc, #600]	; 300300ec <main_thread+0xc0c>
3002fe90:	e5933000 	ldr	r3, [r3]
3002fe94:	e2432001 	sub	r2, r3, #1
3002fe98:	e59f3220 	ldr	r3, [pc, #544]	; 300300c0 <main_thread+0xbe0>
3002fe9c:	e5832000 	str	r2, [r3]
3002fea0:	ea000004 	b	3002feb8 <main_thread+0x9d8>
						else
							cur_song --;
3002fea4:	e59f3214 	ldr	r3, [pc, #532]	; 300300c0 <main_thread+0xbe0>
3002fea8:	e5933000 	ldr	r3, [r3]
3002feac:	e2432001 	sub	r2, r3, #1
3002feb0:	e59f3208 	ldr	r3, [pc, #520]	; 300300c0 <main_thread+0xbe0>
3002feb4:	e5832000 	str	r2, [r3]
						acoral_close(cur_file_ptr);
3002feb8:	e59f3230 	ldr	r3, [pc, #560]	; 300300f0 <main_thread+0xc10>
3002febc:	e5933000 	ldr	r3, [r3]
3002fec0:	e1a00003 	mov	r0, r3
3002fec4:	ebffecd9 	bl	3002b230 <acoral_close>
						acoral_kill_thread_by_id(pcm_player_id);
3002fec8:	e59f3224 	ldr	r3, [pc, #548]	; 300300f4 <main_thread+0xc14>
3002fecc:	e5933000 	ldr	r3, [r3]
3002fed0:	e1a00003 	mov	r0, r3
3002fed4:	ebff4add 	bl	30002a50 <acoral_kill_thread_by_id>
						acoral_kill_thread_by_id(mp3_decoder_id);
3002fed8:	e59f3218 	ldr	r3, [pc, #536]	; 300300f8 <main_thread+0xc18>
3002fedc:	e5933000 	ldr	r3, [r3]
3002fee0:	e1a00003 	mov	r0, r3
3002fee4:	ebff4ad9 	bl	30002a50 <acoral_kill_thread_by_id>
						client_close();
3002fee8:	eb0010d9 	bl	30034254 <client_close>
						acoral_kill_thread_by_id(id);
3002feec:	e59f31e0 	ldr	r3, [pc, #480]	; 300300d4 <main_thread+0xbf4>
3002fef0:	e5933000 	ldr	r3, [r3]
3002fef4:	e1a00003 	mov	r0, r3
3002fef8:	ebff4ad4 	bl	30002a50 <acoral_kill_thread_by_id>
						id = acoral_create_thread(client_init,8192,NULL,"client",13,0);
3002fefc:	e59f31dc 	ldr	r3, [pc, #476]	; 300300e0 <main_thread+0xc00>
3002ff00:	e3a0200d 	mov	r2, #13
3002ff04:	e58d2000 	str	r2, [sp]
3002ff08:	e3a02000 	mov	r2, #0
3002ff0c:	e58d2004 	str	r2, [sp, #4]
3002ff10:	e1a00003 	mov	r0, r3
3002ff14:	e3a01a02 	mov	r1, #8192	; 0x2000
3002ff18:	e3a02000 	mov	r2, #0
3002ff1c:	e59f31c0 	ldr	r3, [pc, #448]	; 300300e4 <main_thread+0xc04>
3002ff20:	ebff4c1f 	bl	30002fa4 <create_comm_thread>
3002ff24:	e1a02000 	mov	r2, r0
3002ff28:	e59f31a4 	ldr	r3, [pc, #420]	; 300300d4 <main_thread+0xbf4>
3002ff2c:	e5832000 	str	r2, [r3]
					}
					break;
3002ff30:	ea000057 	b	30030094 <main_thread+0xbb4>
				case Local:
					if(play_model != Local) {
3002ff34:	e59f3170 	ldr	r3, [pc, #368]	; 300300ac <main_thread+0xbcc>
3002ff38:	e5933000 	ldr	r3, [r3]
3002ff3c:	e3530015 	cmp	r3, #21
3002ff40:	0a000025 	beq	3002ffdc <main_thread+0xafc>
						waveOutPause(0);
3002ff44:	e3a00000 	mov	r0, #0
3002ff48:	eb0005de 	bl	300316c8 <waveOutPause>
						acoral_delay_self(5000);
3002ff4c:	e3a00d4e 	mov	r0, #4992	; 0x1380
3002ff50:	e2800008 	add	r0, r0, #8
3002ff54:	ebff4a8a 	bl	30002984 <acoral_delay_self>
						waveOutClose(0);
3002ff58:	e3a00000 	mov	r0, #0
3002ff5c:	eb000502 	bl	3003136c <waveOutClose>
						play_status = First_Song;
3002ff60:	e59f3154 	ldr	r3, [pc, #340]	; 300300bc <main_thread+0xbdc>
3002ff64:	e3a02002 	mov	r2, #2
3002ff68:	e5832000 	str	r2, [r3]
						play_model = Local;
3002ff6c:	e59f3138 	ldr	r3, [pc, #312]	; 300300ac <main_thread+0xbcc>
3002ff70:	e3a02015 	mov	r2, #21
3002ff74:	e5832000 	str	r2, [r3]
						acoral_close(cur_file_ptr);
3002ff78:	e59f3170 	ldr	r3, [pc, #368]	; 300300f0 <main_thread+0xc10>
3002ff7c:	e5933000 	ldr	r3, [r3]
3002ff80:	e1a00003 	mov	r0, r3
3002ff84:	ebffeca9 	bl	3002b230 <acoral_close>
						acoral_kill_thread_by_id(pcm_player_id);
3002ff88:	e59f3164 	ldr	r3, [pc, #356]	; 300300f4 <main_thread+0xc14>
3002ff8c:	e5933000 	ldr	r3, [r3]
3002ff90:	e1a00003 	mov	r0, r3
3002ff94:	ebff4aad 	bl	30002a50 <acoral_kill_thread_by_id>
						acoral_kill_thread_by_id(mp3_decoder_id);
3002ff98:	e59f3158 	ldr	r3, [pc, #344]	; 300300f8 <main_thread+0xc18>
3002ff9c:	e5933000 	ldr	r3, [r3]
3002ffa0:	e1a00003 	mov	r0, r3
3002ffa4:	ebff4aa9 	bl	30002a50 <acoral_kill_thread_by_id>
						client_close();
3002ffa8:	eb0010a9 	bl	30034254 <client_close>
						acoral_kill_thread_by_id(id);
3002ffac:	e59f3120 	ldr	r3, [pc, #288]	; 300300d4 <main_thread+0xbf4>
3002ffb0:	e5933000 	ldr	r3, [r3]
3002ffb4:	e1a00003 	mov	r0, r3
3002ffb8:	ebff4aa4 	bl	30002a50 <acoral_kill_thread_by_id>
						Paint_Bmp(0, 0, 480, 272, bg1);
3002ffbc:	e59f30d8 	ldr	r3, [pc, #216]	; 3003009c <main_thread+0xbbc>
3002ffc0:	e58d3000 	str	r3, [sp]
3002ffc4:	e3a00000 	mov	r0, #0
3002ffc8:	e3a01000 	mov	r1, #0
3002ffcc:	e3a02e1e 	mov	r2, #480	; 0x1e0
3002ffd0:	e3a03e11 	mov	r3, #272	; 0x110
3002ffd4:	ebfffadb 	bl	3002eb48 <Paint_Bmp>
3002ffd8:	ea000001 	b	3002ffe4 <main_thread+0xb04>
					}
					else
						acoral_print("it's already Local!\n");
3002ffdc:	e59f0118 	ldr	r0, [pc, #280]	; 300300fc <main_thread+0xc1c>
3002ffe0:	ebff6c96 	bl	3000b240 <acoral_print>
					break;
3002ffe4:	ea00002a 	b	30030094 <main_thread+0xbb4>
				case Online:
					if(play_model != Online) {
3002ffe8:	e59f30bc 	ldr	r3, [pc, #188]	; 300300ac <main_thread+0xbcc>
3002ffec:	e5933000 	ldr	r3, [r3]
3002fff0:	e3530016 	cmp	r3, #22
3002fff4:	0a000023 	beq	30030088 <main_thread+0xba8>
						waveOutPause(0);
3002fff8:	e3a00000 	mov	r0, #0
3002fffc:	eb0005b1 	bl	300316c8 <waveOutPause>
						acoral_delay_self(1000);
30030000:	e3a00ffa 	mov	r0, #1000	; 0x3e8
30030004:	ebff4a5e 	bl	30002984 <acoral_delay_self>
						waveOutClose(0);
30030008:	e3a00000 	mov	r0, #0
3003000c:	eb0004d6 	bl	3003136c <waveOutClose>
						play_status = First_Song;
30030010:	e59f30a4 	ldr	r3, [pc, #164]	; 300300bc <main_thread+0xbdc>
30030014:	e3a02002 	mov	r2, #2
30030018:	e5832000 	str	r2, [r3]
						play_model = Online;
3003001c:	e59f3088 	ldr	r3, [pc, #136]	; 300300ac <main_thread+0xbcc>
30030020:	e3a02016 	mov	r2, #22
30030024:	e5832000 	str	r2, [r3]
						acoral_close(cur_file_ptr);
30030028:	e59f30c0 	ldr	r3, [pc, #192]	; 300300f0 <main_thread+0xc10>
3003002c:	e5933000 	ldr	r3, [r3]
30030030:	e1a00003 	mov	r0, r3
30030034:	ebffec7d 	bl	3002b230 <acoral_close>
						acoral_kill_thread_by_id(pcm_player_id);
30030038:	e59f30b4 	ldr	r3, [pc, #180]	; 300300f4 <main_thread+0xc14>
3003003c:	e5933000 	ldr	r3, [r3]
30030040:	e1a00003 	mov	r0, r3
30030044:	ebff4a81 	bl	30002a50 <acoral_kill_thread_by_id>
						acoral_kill_thread_by_id(mp3_decoder_id);
30030048:	e59f30a8 	ldr	r3, [pc, #168]	; 300300f8 <main_thread+0xc18>
3003004c:	e5933000 	ldr	r3, [r3]
30030050:	e1a00003 	mov	r0, r3
30030054:	ebff4a7d 	bl	30002a50 <acoral_kill_thread_by_id>
						acoral_kill_thread_by_id(id);
30030058:	e59f3074 	ldr	r3, [pc, #116]	; 300300d4 <main_thread+0xbf4>
3003005c:	e5933000 	ldr	r3, [r3]
30030060:	e1a00003 	mov	r0, r3
30030064:	ebff4a79 	bl	30002a50 <acoral_kill_thread_by_id>
						//acoral_delay_self(2000);
						Paint_Bmp(0, 0, 480, 272, bg2);
30030068:	e59f3090 	ldr	r3, [pc, #144]	; 30030100 <main_thread+0xc20>
3003006c:	e58d3000 	str	r3, [sp]
30030070:	e3a00000 	mov	r0, #0
30030074:	e3a01000 	mov	r1, #0
30030078:	e3a02e1e 	mov	r2, #480	; 0x1e0
3003007c:	e3a03e11 	mov	r3, #272	; 0x110
30030080:	ebfffab0 	bl	3002eb48 <Paint_Bmp>
					break;
			}
		}

		//acoral_delay_self(100);
   	}
30030084:	eafffd3c 	b	3002f57c <main_thread+0x9c>
						acoral_kill_thread_by_id(id);
						//acoral_delay_self(2000);
						Paint_Bmp(0, 0, 480, 272, bg2);
					}
					else
						acoral_print("it's already online !!!!\n");
30030088:	e59f0074 	ldr	r0, [pc, #116]	; 30030104 <main_thread+0xc24>
3003008c:	ebff6c6b 	bl	3000b240 <acoral_print>
					break;
			}
		}

		//acoral_delay_self(100);
   	}
30030090:	eafffd39 	b	3002f57c <main_thread+0x9c>
30030094:	eafffd38 	b	3002f57c <main_thread+0x9c>
30030098:	3012d6e0 	.word	0x3012d6e0
3003009c:	3004679c 	.word	0x3004679c
300300a0:	3002f1c0 	.word	0x3002f1c0
300300a4:	30045efc 	.word	0x30045efc
300300a8:	300e58c4 	.word	0x300e58c4
300300ac:	300c5fa0 	.word	0x300c5fa0
300300b0:	300e58b8 	.word	0x300e58b8
300300b4:	30045f10 	.word	0x30045f10
300300b8:	300e58bc 	.word	0x300e58bc
300300bc:	300c5f9c 	.word	0x300c5f9c
300300c0:	300e58c0 	.word	0x300e58c0
300300c4:	302be3dc 	.word	0x302be3dc
300300c8:	300eaa24 	.word	0x300eaa24
300300cc:	30033464 	.word	0x30033464
300300d0:	30045ecc 	.word	0x30045ecc
300300d4:	3012a81c 	.word	0x3012a81c
300300d8:	300338ec 	.word	0x300338ec
300300dc:	30045ee0 	.word	0x30045ee0
300300e0:	3003405c 	.word	0x3003405c
300300e4:	30045ef4 	.word	0x30045ef4
300300e8:	300c5fa4 	.word	0x300c5fa4
300300ec:	3012b680 	.word	0x3012b680
300300f0:	302be6ac 	.word	0x302be6ac
300300f4:	300eaab0 	.word	0x300eaab0
300300f8:	302bf844 	.word	0x302bf844
300300fc:	30045f1c 	.word	0x30045f1c
30030100:	3008639c 	.word	0x3008639c
30030104:	30045f34 	.word	0x30045f34

30030108 <Lcd_TFT_Test>:
}



void Lcd_TFT_Test( void )
{
30030108:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3003010c:	e24dd024 	sub	sp, sp, #36	; 0x24
	acoral_id id;
	acoral_slice_policy_data_t data;
	data.cpu = 0;
30030110:	e3a03000 	mov	r3, #0
30030114:	e5cd3014 	strb	r3, [sp, #20]
	data.prio = 20;
30030118:	e3a03014 	mov	r3, #20
3003011c:	e5cd3015 	strb	r3, [sp, #21]
	data.slice = 100;
30030120:	e3a03064 	mov	r3, #100	; 0x64
30030124:	e58d3018 	str	r3, [sp, #24]
	Lcd_TFT_Init();
30030128:	ebfffad4 	bl	3002ec80 <Lcd_TFT_Init>
   	acoral_print("\nTest TFT LCD!\n");
3003012c:	e59f01dc 	ldr	r0, [pc, #476]	; 30030310 <Lcd_TFT_Test+0x208>
30030130:	ebff6c42 	bl	3000b240 <acoral_print>
   	Paint_Bmp(0, 0, 480, 272, bg1);
30030134:	e59f31d8 	ldr	r3, [pc, #472]	; 30030314 <Lcd_TFT_Test+0x20c>
30030138:	e58d3000 	str	r3, [sp]
3003013c:	e3a00000 	mov	r0, #0
30030140:	e3a01000 	mov	r1, #0
30030144:	e3a02e1e 	mov	r2, #480	; 0x1e0
30030148:	e3a03e11 	mov	r3, #272	; 0x110
3003014c:	ebfffa7d 	bl	3002eb48 <Paint_Bmp>
   	cur_file_name[0] = '1';
30030150:	e59f31c0 	ldr	r3, [pc, #448]	; 30030318 <Lcd_TFT_Test+0x210>
30030154:	e3a02031 	mov	r2, #49	; 0x31
30030158:	e5c32000 	strb	r2, [r3]
   		cur_file_name[1] = '.';
3003015c:	e59f31b4 	ldr	r3, [pc, #436]	; 30030318 <Lcd_TFT_Test+0x210>
30030160:	e3a0202e 	mov	r2, #46	; 0x2e
30030164:	e5c32001 	strb	r2, [r3, #1]
   		cur_file_name[2] = 'w';
30030168:	e59f31a8 	ldr	r3, [pc, #424]	; 30030318 <Lcd_TFT_Test+0x210>
3003016c:	e3a02077 	mov	r2, #119	; 0x77
30030170:	e5c32002 	strb	r2, [r3, #2]
   		cur_file_name[3] = 'a';
30030174:	e59f319c 	ldr	r3, [pc, #412]	; 30030318 <Lcd_TFT_Test+0x210>
30030178:	e3a02061 	mov	r2, #97	; 0x61
3003017c:	e5c32003 	strb	r2, [r3, #3]
   		cur_file_name[4] = 'v';
30030180:	e59f3190 	ldr	r3, [pc, #400]	; 30030318 <Lcd_TFT_Test+0x210>
30030184:	e3a02076 	mov	r2, #118	; 0x76
30030188:	e5c32004 	strb	r2, [r3, #4]
   		//id = acoral_create_thread_ext(local_wav_file_read, 8192*16, 0, "local_wav_file_read", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
   	while(1){
   	acoral_sem_pend(&touch_eve, 0);
3003018c:	e59f0188 	ldr	r0, [pc, #392]	; 3003031c <Lcd_TFT_Test+0x214>
30030190:	e3a01000 	mov	r1, #0
30030194:	ebff5d49 	bl	300076c0 <acoral_sem_pend>
	//acoral_print( "\nDisplay Black! Press any key to continue!\n" );
	//acoral_print("x: %d y: %d\n", xdata, ydata);
	//Uart_Getch() ;		//wait uart input


   	acoral_kill_thread_by_id(pcm_player_id);
30030198:	e59f3180 	ldr	r3, [pc, #384]	; 30030320 <Lcd_TFT_Test+0x218>
3003019c:	e5933000 	ldr	r3, [r3]
300301a0:	e1a00003 	mov	r0, r3
300301a4:	ebff4a29 	bl	30002a50 <acoral_kill_thread_by_id>
	acoral_kill_thread_by_id(mp3_decoder_id);
300301a8:	e59f3174 	ldr	r3, [pc, #372]	; 30030324 <Lcd_TFT_Test+0x21c>
300301ac:	e5933000 	ldr	r3, [r3]
300301b0:	e1a00003 	mov	r0, r3
300301b4:	ebff4a25 	bl	30002a50 <acoral_kill_thread_by_id>
	acoral_kill_thread_by_id(id);
300301b8:	e59d001c 	ldr	r0, [sp, #28]
300301bc:	ebff4a23 	bl	30002a50 <acoral_kill_thread_by_id>
	waveOutClose(0);
300301c0:	e3a00000 	mov	r0, #0
300301c4:	eb000468 	bl	3003136c <waveOutClose>
	acoral_close(cur_file_ptr);
300301c8:	e59f3158 	ldr	r3, [pc, #344]	; 30030328 <Lcd_TFT_Test+0x220>
300301cc:	e5933000 	ldr	r3, [r3]
300301d0:	e1a00003 	mov	r0, r3
300301d4:	ebffec15 	bl	3002b230 <acoral_close>
	cur_file_name[0] = '1';
300301d8:	e59f3138 	ldr	r3, [pc, #312]	; 30030318 <Lcd_TFT_Test+0x210>
300301dc:	e3a02031 	mov	r2, #49	; 0x31
300301e0:	e5c32000 	strb	r2, [r3]
	cur_file_name[1] = '.';
300301e4:	e59f312c 	ldr	r3, [pc, #300]	; 30030318 <Lcd_TFT_Test+0x210>
300301e8:	e3a0202e 	mov	r2, #46	; 0x2e
300301ec:	e5c32001 	strb	r2, [r3, #1]
	cur_file_name[2] = 'w';
300301f0:	e59f3120 	ldr	r3, [pc, #288]	; 30030318 <Lcd_TFT_Test+0x210>
300301f4:	e3a02077 	mov	r2, #119	; 0x77
300301f8:	e5c32002 	strb	r2, [r3, #2]
	cur_file_name[3] = 'a';
300301fc:	e59f3114 	ldr	r3, [pc, #276]	; 30030318 <Lcd_TFT_Test+0x210>
30030200:	e3a02061 	mov	r2, #97	; 0x61
30030204:	e5c32003 	strb	r2, [r3, #3]
	cur_file_name[4] = 'v';
30030208:	e59f3108 	ldr	r3, [pc, #264]	; 30030318 <Lcd_TFT_Test+0x210>
3003020c:	e3a02076 	mov	r2, #118	; 0x76
30030210:	e5c32004 	strb	r2, [r3, #4]
	id = acoral_create_thread_ext(local_wav_file_read, 8192*16, 0, "local_wav_file_read", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
30030214:	e59f3110 	ldr	r3, [pc, #272]	; 3003032c <Lcd_TFT_Test+0x224>
30030218:	e3a02000 	mov	r2, #0
3003021c:	e58d2000 	str	r2, [sp]
30030220:	e3a02018 	mov	r2, #24
30030224:	e58d2004 	str	r2, [sp, #4]
30030228:	e28d2014 	add	r2, sp, #20
3003022c:	e58d2008 	str	r2, [sp, #8]
30030230:	e1a00003 	mov	r0, r3
30030234:	e3a01802 	mov	r1, #131072	; 0x20000
30030238:	e3a02000 	mov	r2, #0
3003023c:	e59f30ec 	ldr	r3, [pc, #236]	; 30030330 <Lcd_TFT_Test+0x228>
30030240:	ebff467b 	bl	30001c34 <create_thread_ext>
30030244:	e1a03000 	mov	r3, r0
30030248:	e58d301c 	str	r3, [sp, #28]
	//id = acoral_create_thread(local_mp3_file_read,8192*16,NULL,"local_mp3_file_read",13,0);
	//Paint_Bmp(0, 0, 480, 272, bg2);
	acoral_sem_pend(&touch_eve, 0);
3003024c:	e59f00c8 	ldr	r0, [pc, #200]	; 3003031c <Lcd_TFT_Test+0x214>
30030250:	e3a01000 	mov	r1, #0
30030254:	ebff5d19 	bl	300076c0 <acoral_sem_pend>
	//Lcd_ClearScr( (0x1f<<11) | (0x3f<<5) | (0x1f)  )  ;		//clear screen
	//acoral_print( "Display White! Press any key to continue!\n" );
	//acoral_print("x: %d y: %d\n", xdata, ydata);
	//Uart_Getch() ;		//wait uart input
	acoral_kill_thread_by_id(pcm_player_id);
30030258:	e59f30c0 	ldr	r3, [pc, #192]	; 30030320 <Lcd_TFT_Test+0x218>
3003025c:	e5933000 	ldr	r3, [r3]
30030260:	e1a00003 	mov	r0, r3
30030264:	ebff49f9 	bl	30002a50 <acoral_kill_thread_by_id>
	acoral_kill_thread_by_id(mp3_decoder_id);
30030268:	e59f30b4 	ldr	r3, [pc, #180]	; 30030324 <Lcd_TFT_Test+0x21c>
3003026c:	e5933000 	ldr	r3, [r3]
30030270:	e1a00003 	mov	r0, r3
30030274:	ebff49f5 	bl	30002a50 <acoral_kill_thread_by_id>
	acoral_kill_thread_by_id(id);
30030278:	e59d001c 	ldr	r0, [sp, #28]
3003027c:	ebff49f3 	bl	30002a50 <acoral_kill_thread_by_id>
	waveOutClose(0);
30030280:	e3a00000 	mov	r0, #0
30030284:	eb000438 	bl	3003136c <waveOutClose>
	acoral_close(cur_file_ptr);
30030288:	e59f3098 	ldr	r3, [pc, #152]	; 30030328 <Lcd_TFT_Test+0x220>
3003028c:	e5933000 	ldr	r3, [r3]
30030290:	e1a00003 	mov	r0, r3
30030294:	ebffebe5 	bl	3002b230 <acoral_close>
	cur_file_name[0] = '2';
30030298:	e59f3078 	ldr	r3, [pc, #120]	; 30030318 <Lcd_TFT_Test+0x210>
3003029c:	e3a02032 	mov	r2, #50	; 0x32
300302a0:	e5c32000 	strb	r2, [r3]
	cur_file_name[1] = '.';
300302a4:	e59f306c 	ldr	r3, [pc, #108]	; 30030318 <Lcd_TFT_Test+0x210>
300302a8:	e3a0202e 	mov	r2, #46	; 0x2e
300302ac:	e5c32001 	strb	r2, [r3, #1]
	cur_file_name[2] = 'w';
300302b0:	e59f3060 	ldr	r3, [pc, #96]	; 30030318 <Lcd_TFT_Test+0x210>
300302b4:	e3a02077 	mov	r2, #119	; 0x77
300302b8:	e5c32002 	strb	r2, [r3, #2]
	cur_file_name[3] = 'a';
300302bc:	e59f3054 	ldr	r3, [pc, #84]	; 30030318 <Lcd_TFT_Test+0x210>
300302c0:	e3a02061 	mov	r2, #97	; 0x61
300302c4:	e5c32003 	strb	r2, [r3, #3]
	cur_file_name[4] = 'v';
300302c8:	e59f3048 	ldr	r3, [pc, #72]	; 30030318 <Lcd_TFT_Test+0x210>
300302cc:	e3a02076 	mov	r2, #118	; 0x76
300302d0:	e5c32004 	strb	r2, [r3, #4]
	id = acoral_create_thread_ext(local_wav_file_read, 8192*16, 0, "local_mp3_file_read", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
300302d4:	e59f3050 	ldr	r3, [pc, #80]	; 3003032c <Lcd_TFT_Test+0x224>
300302d8:	e3a02000 	mov	r2, #0
300302dc:	e58d2000 	str	r2, [sp]
300302e0:	e3a02018 	mov	r2, #24
300302e4:	e58d2004 	str	r2, [sp, #4]
300302e8:	e28d2014 	add	r2, sp, #20
300302ec:	e58d2008 	str	r2, [sp, #8]
300302f0:	e1a00003 	mov	r0, r3
300302f4:	e3a01802 	mov	r1, #131072	; 0x20000
300302f8:	e3a02000 	mov	r2, #0
300302fc:	e59f3030 	ldr	r3, [pc, #48]	; 30030334 <Lcd_TFT_Test+0x22c>
30030300:	ebff464b 	bl	30001c34 <create_thread_ext>
30030304:	e1a03000 	mov	r3, r0
30030308:	e58d301c 	str	r3, [sp, #28]
	//id = acoral_create_thread(local_mp3_file_read,8192*16,NULL,"local_mp3_file_read",13,0);
	//Paint_Bmp(0, 0, 480, 272, bg1);

   	}
3003030c:	eaffff9e 	b	3003018c <Lcd_TFT_Test+0x84>
30030310:	30045f50 	.word	0x30045f50
30030314:	3004679c 	.word	0x3004679c
30030318:	300eaa24 	.word	0x300eaa24
3003031c:	302f7e48 	.word	0x302f7e48
30030320:	300eaab0 	.word	0x300eaab0
30030324:	302bf844 	.word	0x302bf844
30030328:	302be6ac 	.word	0x302be6ac
3003032c:	300338ec 	.word	0x300338ec
30030330:	30045ee0 	.word	0x30045ee0
30030334:	30045ecc 	.word	0x30045ecc

30030338 <my_main_start>:

#include "../include/global.h"
#include <os_file.h>


void my_main_start(void) {
30030338:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3003033c:	e24dd00c 	sub	sp, sp, #12



	acoral_create_thread(touch_pad_init,8192,NULL,"touch_pad_test",14,0);
30030340:	e59f307c 	ldr	r3, [pc, #124]	; 300303c4 <my_main_start+0x8c>
30030344:	e3a0200e 	mov	r2, #14
30030348:	e58d2000 	str	r2, [sp]
3003034c:	e3a02000 	mov	r2, #0
30030350:	e58d2004 	str	r2, [sp, #4]
30030354:	e1a00003 	mov	r0, r3
30030358:	e3a01a02 	mov	r1, #8192	; 0x2000
3003035c:	e3a02000 	mov	r2, #0
30030360:	e59f3060 	ldr	r3, [pc, #96]	; 300303c8 <my_main_start+0x90>
30030364:	ebff4b0e 	bl	30002fa4 <create_comm_thread>
	acoral_create_thread(key_init,8192,NULL,"key_test",14,0);
30030368:	e59f305c 	ldr	r3, [pc, #92]	; 300303cc <my_main_start+0x94>
3003036c:	e3a0200e 	mov	r2, #14
30030370:	e58d2000 	str	r2, [sp]
30030374:	e3a02000 	mov	r2, #0
30030378:	e58d2004 	str	r2, [sp, #4]
3003037c:	e1a00003 	mov	r0, r3
30030380:	e3a01a02 	mov	r1, #8192	; 0x2000
30030384:	e3a02000 	mov	r2, #0
30030388:	e59f3040 	ldr	r3, [pc, #64]	; 300303d0 <my_main_start+0x98>
3003038c:	ebff4b04 	bl	30002fa4 <create_comm_thread>
	acoral_create_thread(main_thread,8192*8,NULL,"main_thread",15,0);
30030390:	e59f303c 	ldr	r3, [pc, #60]	; 300303d4 <my_main_start+0x9c>
30030394:	e3a0200f 	mov	r2, #15
30030398:	e58d2000 	str	r2, [sp]
3003039c:	e3a02000 	mov	r2, #0
300303a0:	e58d2004 	str	r2, [sp, #4]
300303a4:	e1a00003 	mov	r0, r3
300303a8:	e3a01801 	mov	r1, #65536	; 0x10000
300303ac:	e3a02000 	mov	r2, #0
300303b0:	e59f3020 	ldr	r3, [pc, #32]	; 300303d8 <my_main_start+0xa0>
300303b4:	ebff4afa 	bl	30002fa4 <create_comm_thread>
		acoral_read(localFile, tmp, sizeof(tmp));
		acoral_print("%2x\n", tmp[0]);
	}
	acoral_close(localFile);
	*/
}
300303b8:	e28dd00c 	add	sp, sp, #12
300303bc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300303c0:	e12fff1e 	bx	lr
300303c4:	3002def8 	.word	0x3002def8
300303c8:	30045f60 	.word	0x30045f60
300303cc:	3002dacc 	.word	0x3002dacc
300303d0:	30045f70 	.word	0x30045f70
300303d4:	3002f4e0 	.word	0x3002f4e0
300303d8:	30045f7c 	.word	0x30045f7c

300303dc <RequestDMASW>:

/********************************************************/
//attr��16λΪ�豸ID,��16λ�ĸ�8λΪDMA����Դ,Ŀ������(AHP/APB,INCREASE/FIX)
//��8λΪ����Դ,����ֵʧ��ΪREQUEST_DMA_FAIL,�ɹ���16λΪ�豸ID,��8λΪ���뵽��ͨ��
acoral_u32 RequestDMASW(acoral_u32 attr, acoral_u32 mode)
{
300303dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300303e0:	e24dd014 	sub	sp, sp, #20
300303e4:	e58d0004 	str	r0, [sp, #4]
300303e8:	e58d1000 	str	r1, [sp]
	acoral_u16 channel;
	acoral_u32 ret;
	
	attr &= ~0xff;
300303ec:	e59d3004 	ldr	r3, [sp, #4]
300303f0:	e3c330ff 	bic	r3, r3, #255	; 0xff
300303f4:	e58d3004 	str	r3, [sp, #4]
	mode &= ~HW_TRIG;
300303f8:	e59d3000 	ldr	r3, [sp]
300303fc:	e3c33502 	bic	r3, r3, #8388608	; 0x800000
30030400:	e58d3000 	str	r3, [sp]
	
	for(channel=0; channel<(MAX_DMA_CHANNEL*0x10); channel+=0x10)
30030404:	e3a03000 	mov	r3, #0
30030408:	e1cd30ba 	strh	r3, [sp, #10]
3003040c:	ea00000d 	b	30030448 <RequestDMASW+0x6c>
	{
		ret = RequestDMA(attr|channel, mode);
30030410:	e1dd20ba 	ldrh	r2, [sp, #10]
30030414:	e59d3004 	ldr	r3, [sp, #4]
30030418:	e1823003 	orr	r3, r2, r3
3003041c:	e1a00003 	mov	r0, r3
30030420:	e59d1000 	ldr	r1, [sp]
30030424:	eb000011 	bl	30030470 <RequestDMA>
30030428:	e1a03000 	mov	r3, r0
3003042c:	e58d300c 	str	r3, [sp, #12]
		if(ret!=REQUEST_DMA_FAIL)
30030430:	e59d300c 	ldr	r3, [sp, #12]
30030434:	e3530a01 	cmp	r3, #4096	; 0x1000
30030438:	1a000006 	bne	30030458 <RequestDMASW+0x7c>
	acoral_u32 ret;
	
	attr &= ~0xff;
	mode &= ~HW_TRIG;
	
	for(channel=0; channel<(MAX_DMA_CHANNEL*0x10); channel+=0x10)
3003043c:	e1dd30ba 	ldrh	r3, [sp, #10]
30030440:	e2833010 	add	r3, r3, #16
30030444:	e1cd30ba 	strh	r3, [sp, #10]
30030448:	e1dd30ba 	ldrh	r3, [sp, #10]
3003044c:	e353003f 	cmp	r3, #63	; 0x3f
30030450:	9affffee 	bls	30030410 <RequestDMASW+0x34>
30030454:	ea000000 	b	3003045c <RequestDMASW+0x80>
	{
		ret = RequestDMA(attr|channel, mode);
		if(ret!=REQUEST_DMA_FAIL)
			break;
30030458:	e1a00000 	nop			; (mov r0, r0)
	}
	return ret;			
3003045c:	e59d300c 	ldr	r3, [sp, #12]
}
30030460:	e1a00003 	mov	r0, r3
30030464:	e28dd014 	add	sp, sp, #20
30030468:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3003046c:	e12fff1e 	bx	lr

30030470 <RequestDMA>:


acoral_u32 RequestDMA(acoral_u32 attr, acoral_u32 mode)
{
30030470:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30030474:	e24dd024 	sub	sp, sp, #36	; 0x24
30030478:	e58d0004 	str	r0, [sp, #4]
3003047c:	e58d1000 	str	r1, [sp]
	acoral_u16 DevID, ReqSrc, ch;
	acoral_u32 ret=REQUEST_DMA_FAIL, r;
30030480:	e3a03a01 	mov	r3, #4096	; 0x1000
30030484:	e58d3010 	str	r3, [sp, #16]
	acoral_sr cpu_sr;
	
	DevID   = attr>>16;	
30030488:	e59d3004 	ldr	r3, [sp, #4]
3003048c:	e1a03823 	lsr	r3, r3, #16
30030490:	e1cd30ba 	strh	r3, [sp, #10]
	ReqSrc  = attr&0xff;	
30030494:	e59d3004 	ldr	r3, [sp, #4]
30030498:	e1a03803 	lsl	r3, r3, #16
3003049c:	e1a03823 	lsr	r3, r3, #16
300304a0:	e20330ff 	and	r3, r3, #255	; 0xff
300304a4:	e1cd30bc 	strh	r3, [sp, #12]
	
	if(((ReqSrc>>4)>=MAX_DMA_CHANNEL)||((ReqSrc&0xf)>4))
300304a8:	e1dd30bc 	ldrh	r3, [sp, #12]
300304ac:	e1a03223 	lsr	r3, r3, #4
300304b0:	e1a03803 	lsl	r3, r3, #16
300304b4:	e1a03823 	lsr	r3, r3, #16
300304b8:	e3530003 	cmp	r3, #3
300304bc:	8a000003 	bhi	300304d0 <RequestDMA+0x60>
300304c0:	e1dd30bc 	ldrh	r3, [sp, #12]
300304c4:	e203300f 	and	r3, r3, #15
300304c8:	e3530004 	cmp	r3, #4
300304cc:	da000001 	ble	300304d8 <RequestDMA+0x68>
		return ret;
300304d0:	e59d3010 	ldr	r3, [sp, #16]
300304d4:	ea0000ae 	b	30030794 <RequestDMA+0x324>
		

	//EnterCritical(&r);
	HAL_ENTER_CRITICAL();
300304d8:	ebff4485 	bl	300016f4 <HAL_INTR_DISABLE_SAVE>
300304dc:	e1a03000 	mov	r3, r0
300304e0:	e58d3018 	str	r3, [sp, #24]
	if(DMAChannel[ReqSrc>>4].used!=DMA_IS_FREE)
300304e4:	e1dd30bc 	ldrh	r3, [sp, #12]
300304e8:	e1a03223 	lsr	r3, r3, #4
300304ec:	e1a03803 	lsl	r3, r3, #16
300304f0:	e1a03823 	lsr	r3, r3, #16
300304f4:	e1a02003 	mov	r2, r3
300304f8:	e59f32a4 	ldr	r3, [pc, #676]	; 300307a4 <RequestDMA+0x334>
300304fc:	e1a02182 	lsl	r2, r2, #3
30030500:	e0823003 	add	r3, r2, r3
30030504:	e1d330b0 	ldrh	r3, [r3]
30030508:	e3530000 	cmp	r3, #0
3003050c:	0a000036 	beq	300305ec <RequestDMA+0x17c>
	{
		acoral_u8 src = ReqSrc;
30030510:	e1dd30bc 	ldrh	r3, [sp, #12]
30030514:	e5cd301f 	strb	r3, [sp, #31]
		
		if(src==REQ_IISDI)
30030518:	e5dd301f 	ldrb	r3, [sp, #31]
3003051c:	e3530021 	cmp	r3, #33	; 0x21
30030520:	1a000006 	bne	30030540 <RequestDMA+0xd0>
		{		
			if(DMAChannel[2].used!=DMA_IS_FREE)
30030524:	e59f3278 	ldr	r3, [pc, #632]	; 300307a4 <RequestDMA+0x334>
30030528:	e1d331b0 	ldrh	r3, [r3, #16]
3003052c:	e3530000 	cmp	r3, #0
30030530:	1a00008b 	bne	30030764 <RequestDMA+0x2f4>
				goto RequestDmaExit;
			else							
				ReqSrc = 0x21;											
30030534:	e3a03021 	mov	r3, #33	; 0x21
30030538:	e1cd30bc 	strh	r3, [sp, #12]
3003053c:	ea00002a 	b	300305ec <RequestDMA+0x17c>
		}
		else if(src==REQ_SDI)
30030540:	e5dd301f 	ldrb	r3, [sp, #31]
30030544:	e3530002 	cmp	r3, #2
30030548:	1a00000d 	bne	30030584 <RequestDMA+0x114>
		{
			if(DMAChannel[2].used!=DMA_IS_FREE)
3003054c:	e59f3250 	ldr	r3, [pc, #592]	; 300307a4 <RequestDMA+0x334>
30030550:	e1d331b0 	ldrh	r3, [r3, #16]
30030554:	e3530000 	cmp	r3, #0
30030558:	0a000006 	beq	30030578 <RequestDMA+0x108>
			{
				if(DMAChannel[3].used!=DMA_IS_FREE)
3003055c:	e59f3240 	ldr	r3, [pc, #576]	; 300307a4 <RequestDMA+0x334>
30030560:	e1d331b8 	ldrh	r3, [r3, #24]
30030564:	e3530000 	cmp	r3, #0
30030568:	1a00007f 	bne	3003076c <RequestDMA+0x2fc>
					goto RequestDmaExit;
				else
					ReqSrc = 0x31;				
3003056c:	e3a03031 	mov	r3, #49	; 0x31
30030570:	e1cd30bc 	strh	r3, [sp, #12]
			}
			else
				ReqSrc = 0x22;					
30030574:	ea00001c 	b	300305ec <RequestDMA+0x17c>
30030578:	e3a03022 	mov	r3, #34	; 0x22
3003057c:	e1cd30bc 	strh	r3, [sp, #12]
30030580:	ea000019 	b	300305ec <RequestDMA+0x17c>
		}
		else if(src==REQ_SPI)
30030584:	e5dd301f 	ldrb	r3, [sp, #31]
30030588:	e3530013 	cmp	r3, #19
3003058c:	1a000006 	bne	300305ac <RequestDMA+0x13c>
		{
			if(DMAChannel[3].used!=DMA_IS_FREE)
30030590:	e59f320c 	ldr	r3, [pc, #524]	; 300307a4 <RequestDMA+0x334>
30030594:	e1d331b8 	ldrh	r3, [r3, #24]
30030598:	e3530000 	cmp	r3, #0
3003059c:	1a000074 	bne	30030774 <RequestDMA+0x304>
				goto RequestDmaExit;
			else				
				ReqSrc = 0x32;				
300305a0:	e3a03032 	mov	r3, #50	; 0x32
300305a4:	e1cd30bc 	strh	r3, [sp, #12]
300305a8:	ea00000f 	b	300305ec <RequestDMA+0x17c>
		}
		else if(src==REQ_TIMER)
300305ac:	e5dd301f 	ldrb	r3, [sp, #31]
300305b0:	e3530003 	cmp	r3, #3
300305b4:	1a000070 	bne	3003077c <RequestDMA+0x30c>
		{
			if(DMAChannel[2].used!=DMA_IS_FREE)
300305b8:	e59f31e4 	ldr	r3, [pc, #484]	; 300307a4 <RequestDMA+0x334>
300305bc:	e1d331b0 	ldrh	r3, [r3, #16]
300305c0:	e3530000 	cmp	r3, #0
300305c4:	0a000006 	beq	300305e4 <RequestDMA+0x174>
			{
				if(DMAChannel[3].used!=DMA_IS_FREE)
300305c8:	e59f31d4 	ldr	r3, [pc, #468]	; 300307a4 <RequestDMA+0x334>
300305cc:	e1d331b8 	ldrh	r3, [r3, #24]
300305d0:	e3530000 	cmp	r3, #0
300305d4:	1a00006a 	bne	30030784 <RequestDMA+0x314>
					goto RequestDmaExit;
				else				
					ReqSrc = 0x33;				
300305d8:	e3a03033 	mov	r3, #51	; 0x33
300305dc:	e1cd30bc 	strh	r3, [sp, #12]
			}
			else				
				ReqSrc = 0x23;					
300305e0:	ea000001 	b	300305ec <RequestDMA+0x17c>
300305e4:	e3a03023 	mov	r3, #35	; 0x23
300305e8:	e1cd30bc 	strh	r3, [sp, #12]
		}
		else
			goto RequestDmaExit;		
	}	
			
	ch = ReqSrc>>4;
300305ec:	e1dd30bc 	ldrh	r3, [sp, #12]
300305f0:	e1a03223 	lsr	r3, r3, #4
300305f4:	e1cd30be 	strh	r3, [sp, #14]
	if(mode&HW_TRIG)
300305f8:	e59d3000 	ldr	r3, [sp]
300305fc:	e2033502 	and	r3, r3, #8388608	; 0x800000
30030600:	e3530000 	cmp	r3, #0
30030604:	0a000006 	beq	30030624 <RequestDMA+0x1b4>
		DMAChannel[ch].used  = DMA_IS_HWTRIG;
30030608:	e1dd20be 	ldrh	r2, [sp, #14]
3003060c:	e59f3190 	ldr	r3, [pc, #400]	; 300307a4 <RequestDMA+0x334>
30030610:	e1a02182 	lsl	r2, r2, #3
30030614:	e0823003 	add	r3, r2, r3
30030618:	e3a02002 	mov	r2, #2
3003061c:	e1c320b0 	strh	r2, [r3]
30030620:	ea000005 	b	3003063c <RequestDMA+0x1cc>
	else
		DMAChannel[ch].used  = DMA_IS_SWTRIG;	
30030624:	e1dd20be 	ldrh	r2, [sp, #14]
30030628:	e59f3174 	ldr	r3, [pc, #372]	; 300307a4 <RequestDMA+0x334>
3003062c:	e1a02182 	lsl	r2, r2, #3
30030630:	e0823003 	add	r3, r2, r3
30030634:	e3a02001 	mov	r2, #1
30030638:	e1c320b0 	strh	r2, [r3]
	DMAChannel[ch].DevID = DevID;
3003063c:	e1dd10be 	ldrh	r1, [sp, #14]
30030640:	e59f215c 	ldr	r2, [pc, #348]	; 300307a4 <RequestDMA+0x334>
30030644:	e3a03002 	mov	r3, #2
30030648:	e1a01181 	lsl	r1, r1, #3
3003064c:	e0812002 	add	r2, r1, r2
30030650:	e0823003 	add	r3, r2, r3
30030654:	e1dd20ba 	ldrh	r2, [sp, #10]
30030658:	e1c320b0 	strh	r2, [r3]
	DMAChannel[ch].pDMA  = (DMAReg *)(0x4b000000+(ch)*0x40);	
3003065c:	e1dd00be 	ldrh	r0, [sp, #14]
30030660:	e1dd30be 	ldrh	r3, [sp, #14]
30030664:	e283374b 	add	r3, r3, #19660800	; 0x12c0000
30030668:	e1a03303 	lsl	r3, r3, #6
3003066c:	e1a02003 	mov	r2, r3
30030670:	e59f112c 	ldr	r1, [pc, #300]	; 300307a4 <RequestDMA+0x334>
30030674:	e3a03004 	mov	r3, #4
30030678:	e1a00180 	lsl	r0, r0, #3
3003067c:	e0801001 	add	r1, r0, r1
30030680:	e0813003 	add	r3, r1, r3
30030684:	e5832000 	str	r2, [r3]
	DMAChannel[ch].pDMA->DMASKTRIG = 1<<2;	//stop dma
30030688:	e1dd10be 	ldrh	r1, [sp, #14]
3003068c:	e59f2110 	ldr	r2, [pc, #272]	; 300307a4 <RequestDMA+0x334>
30030690:	e3a03004 	mov	r3, #4
30030694:	e1a01181 	lsl	r1, r1, #3
30030698:	e0812002 	add	r2, r1, r2
3003069c:	e0823003 	add	r3, r2, r3
300306a0:	e5933000 	ldr	r3, [r3]
300306a4:	e3a02004 	mov	r2, #4
300306a8:	e5832020 	str	r2, [r3, #32]
	DMAChannel[ch].pDMA->DISRCC = (attr>>8)&3;	
300306ac:	e1dd10be 	ldrh	r1, [sp, #14]
300306b0:	e59f20ec 	ldr	r2, [pc, #236]	; 300307a4 <RequestDMA+0x334>
300306b4:	e3a03004 	mov	r3, #4
300306b8:	e1a01181 	lsl	r1, r1, #3
300306bc:	e0812002 	add	r2, r1, r2
300306c0:	e0823003 	add	r3, r2, r3
300306c4:	e5933000 	ldr	r3, [r3]
300306c8:	e59d2004 	ldr	r2, [sp, #4]
300306cc:	e1a02422 	lsr	r2, r2, #8
300306d0:	e2022003 	and	r2, r2, #3
300306d4:	e5832004 	str	r2, [r3, #4]
	DMAChannel[ch].pDMA->DIDSTC = (attr>>12)&3;	
300306d8:	e1dd10be 	ldrh	r1, [sp, #14]
300306dc:	e59f20c0 	ldr	r2, [pc, #192]	; 300307a4 <RequestDMA+0x334>
300306e0:	e3a03004 	mov	r3, #4
300306e4:	e1a01181 	lsl	r1, r1, #3
300306e8:	e0812002 	add	r2, r1, r2
300306ec:	e0823003 	add	r3, r2, r3
300306f0:	e5933000 	ldr	r3, [r3]
300306f4:	e59d2004 	ldr	r2, [sp, #4]
300306f8:	e1a02622 	lsr	r2, r2, #12
300306fc:	e2022003 	and	r2, r2, #3
30030700:	e583200c 	str	r2, [r3, #12]
	mode &= ~0x07000000;
30030704:	e59d3000 	ldr	r3, [sp]
30030708:	e3c33407 	bic	r3, r3, #117440512	; 0x7000000
3003070c:	e58d3000 	str	r3, [sp]
	mode |= (ReqSrc&0x7)<<24;
30030710:	e1dd30bc 	ldrh	r3, [sp, #12]
30030714:	e2033007 	and	r3, r3, #7
30030718:	e1a03c03 	lsl	r3, r3, #24
3003071c:	e59d2000 	ldr	r2, [sp]
30030720:	e1823003 	orr	r3, r2, r3
30030724:	e58d3000 	str	r3, [sp]
	DMAChannel[ch].pDMA->DCON	= mode;	
30030728:	e1dd10be 	ldrh	r1, [sp, #14]
3003072c:	e59f2070 	ldr	r2, [pc, #112]	; 300307a4 <RequestDMA+0x334>
30030730:	e3a03004 	mov	r3, #4
30030734:	e1a01181 	lsl	r1, r1, #3
30030738:	e0812002 	add	r2, r1, r2
3003073c:	e0823003 	add	r3, r2, r3
30030740:	e5933000 	ldr	r3, [r3]
30030744:	e59d2000 	ldr	r2, [sp]
30030748:	e5832010 	str	r2, [r3, #16]

//	DbgOut("Request DMA %x success\n", ReqSrc);
	ret = (DevID<<16)|ReqSrc;
3003074c:	e1dd30ba 	ldrh	r3, [sp, #10]
30030750:	e1a02803 	lsl	r2, r3, #16
30030754:	e1dd30bc 	ldrh	r3, [sp, #12]
30030758:	e1823003 	orr	r3, r2, r3
3003075c:	e58d3010 	str	r3, [sp, #16]
30030760:	ea000008 	b	30030788 <RequestDMA+0x318>
		acoral_u8 src = ReqSrc;
		
		if(src==REQ_IISDI)
		{		
			if(DMAChannel[2].used!=DMA_IS_FREE)
				goto RequestDmaExit;
30030764:	e1a00000 	nop			; (mov r0, r0)
30030768:	ea000006 	b	30030788 <RequestDMA+0x318>
		else if(src==REQ_SDI)
		{
			if(DMAChannel[2].used!=DMA_IS_FREE)
			{
				if(DMAChannel[3].used!=DMA_IS_FREE)
					goto RequestDmaExit;
3003076c:	e1a00000 	nop			; (mov r0, r0)
30030770:	ea000004 	b	30030788 <RequestDMA+0x318>
				ReqSrc = 0x22;					
		}
		else if(src==REQ_SPI)
		{
			if(DMAChannel[3].used!=DMA_IS_FREE)
				goto RequestDmaExit;
30030774:	e1a00000 	nop			; (mov r0, r0)
30030778:	ea000002 	b	30030788 <RequestDMA+0x318>
			}
			else				
				ReqSrc = 0x23;					
		}
		else
			goto RequestDmaExit;		
3003077c:	e1a00000 	nop			; (mov r0, r0)
30030780:	ea000000 	b	30030788 <RequestDMA+0x318>
		else if(src==REQ_TIMER)
		{
			if(DMAChannel[2].used!=DMA_IS_FREE)
			{
				if(DMAChannel[3].used!=DMA_IS_FREE)
					goto RequestDmaExit;
30030784:	e1a00000 	nop			; (mov r0, r0)
//	DbgOut("Request DMA %x success\n", ReqSrc);
	ret = (DevID<<16)|ReqSrc;
	
RequestDmaExit:
	//ExitCritical(&r);
	HAL_EXIT_CRITICAL();
30030788:	e59d0018 	ldr	r0, [sp, #24]
3003078c:	ebff43d6 	bl	300016ec <HAL_INTR_RESTORE>
	return ret;			
30030790:	e59d3010 	ldr	r3, [sp, #16]
}
30030794:	e1a00003 	mov	r0, r3
30030798:	e28dd024 	add	sp, sp, #36	; 0x24
3003079c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300307a0:	e12fff1e 	bx	lr
300307a4:	300e58c8 	.word	0x300e58c8

300307a8 <ReleaseDMA>:

acoral_u16 ReleaseDMA(acoral_u32 attr)
{
300307a8:	e24dd010 	sub	sp, sp, #16
300307ac:	e58d0004 	str	r0, [sp, #4]
	acoral_u16 DevID, ReqSrc, ch;
	
	DevID  = attr>>16;
300307b0:	e59d3004 	ldr	r3, [sp, #4]
300307b4:	e1a03823 	lsr	r3, r3, #16
300307b8:	e1cd30ba 	strh	r3, [sp, #10]
	ReqSrc = attr&0xf;
300307bc:	e59d3004 	ldr	r3, [sp, #4]
300307c0:	e1a03803 	lsl	r3, r3, #16
300307c4:	e1a03823 	lsr	r3, r3, #16
300307c8:	e203300f 	and	r3, r3, #15
300307cc:	e1cd30bc 	strh	r3, [sp, #12]
	ch     = (attr&0xf0)>>4;
300307d0:	e59d3004 	ldr	r3, [sp, #4]
300307d4:	e20330f0 	and	r3, r3, #240	; 0xf0
300307d8:	e1a03223 	lsr	r3, r3, #4
300307dc:	e1cd30be 	strh	r3, [sp, #14]
	
#if	DMA_CHECK_ATTR					
	if((ch>=MAX_DMA_CHANNEL)||(ReqSrc>4))
300307e0:	e1dd30be 	ldrh	r3, [sp, #14]
300307e4:	e3530003 	cmp	r3, #3
300307e8:	8a000002 	bhi	300307f8 <ReleaseDMA+0x50>
300307ec:	e1dd30bc 	ldrh	r3, [sp, #12]
300307f0:	e3530004 	cmp	r3, #4
300307f4:	9a000001 	bls	30030800 <ReleaseDMA+0x58>
		return 1;
300307f8:	e3a03001 	mov	r3, #1
300307fc:	ea000022 	b	3003088c <ReleaseDMA+0xe4>
	if((DMAChannel[ch].used==DMA_IS_FREE)||(DMAChannel[ch].DevID!=DevID))
30030800:	e1dd20be 	ldrh	r2, [sp, #14]
30030804:	e59f308c 	ldr	r3, [pc, #140]	; 30030898 <ReleaseDMA+0xf0>
30030808:	e1a02182 	lsl	r2, r2, #3
3003080c:	e0823003 	add	r3, r2, r3
30030810:	e1d330b0 	ldrh	r3, [r3]
30030814:	e3530000 	cmp	r3, #0
30030818:	0a000009 	beq	30030844 <ReleaseDMA+0x9c>
3003081c:	e1dd10be 	ldrh	r1, [sp, #14]
30030820:	e59f2070 	ldr	r2, [pc, #112]	; 30030898 <ReleaseDMA+0xf0>
30030824:	e3a03002 	mov	r3, #2
30030828:	e1a01181 	lsl	r1, r1, #3
3003082c:	e0812002 	add	r2, r1, r2
30030830:	e0823003 	add	r3, r2, r3
30030834:	e1d330b0 	ldrh	r3, [r3]
30030838:	e1dd20ba 	ldrh	r2, [sp, #10]
3003083c:	e1520003 	cmp	r2, r3
30030840:	0a000001 	beq	3003084c <ReleaseDMA+0xa4>
		return 1;
30030844:	e3a03001 	mov	r3, #1
30030848:	ea00000f 	b	3003088c <ReleaseDMA+0xe4>
#endif	
		
	DMAChannel[ch].pDMA->DMASKTRIG = 0;//4;	//stop dma and channel off 
3003084c:	e1dd10be 	ldrh	r1, [sp, #14]
30030850:	e59f2040 	ldr	r2, [pc, #64]	; 30030898 <ReleaseDMA+0xf0>
30030854:	e3a03004 	mov	r3, #4
30030858:	e1a01181 	lsl	r1, r1, #3
3003085c:	e0812002 	add	r2, r1, r2
30030860:	e0823003 	add	r3, r2, r3
30030864:	e5933000 	ldr	r3, [r3]
30030868:	e3a02000 	mov	r2, #0
3003086c:	e5832020 	str	r2, [r3, #32]
	DMAChannel[ch].used = DMA_IS_FREE;
30030870:	e1dd20be 	ldrh	r2, [sp, #14]
30030874:	e59f301c 	ldr	r3, [pc, #28]	; 30030898 <ReleaseDMA+0xf0>
30030878:	e1a02182 	lsl	r2, r2, #3
3003087c:	e0823003 	add	r3, r2, r3
30030880:	e3a02000 	mov	r2, #0
30030884:	e1c320b0 	strh	r2, [r3]
	
	return 0;					
30030888:	e3a03000 	mov	r3, #0
}
3003088c:	e1a00003 	mov	r0, r3
30030890:	e28dd010 	add	sp, sp, #16
30030894:	e12fff1e 	bx	lr
30030898:	300e58c8 	.word	0x300e58c8

3003089c <StartDMA>:

acoral_u16 StartDMA(acoral_u32 attr)
{
3003089c:	e24dd010 	sub	sp, sp, #16
300308a0:	e58d0004 	str	r0, [sp, #4]
	acoral_u16 DevID, ReqSrc, ch;
	
	DevID  = attr>>16;
300308a4:	e59d3004 	ldr	r3, [sp, #4]
300308a8:	e1a03823 	lsr	r3, r3, #16
300308ac:	e1cd30ba 	strh	r3, [sp, #10]
	ReqSrc = attr&0xf;
300308b0:	e59d3004 	ldr	r3, [sp, #4]
300308b4:	e1a03803 	lsl	r3, r3, #16
300308b8:	e1a03823 	lsr	r3, r3, #16
300308bc:	e203300f 	and	r3, r3, #15
300308c0:	e1cd30bc 	strh	r3, [sp, #12]
	ch     = (attr&0xf0)>>4;		
300308c4:	e59d3004 	ldr	r3, [sp, #4]
300308c8:	e20330f0 	and	r3, r3, #240	; 0xf0
300308cc:	e1a03223 	lsr	r3, r3, #4
300308d0:	e1cd30be 	strh	r3, [sp, #14]
#if	DMA_CHECK_ATTR		
	if((ch>=MAX_DMA_CHANNEL)||(ReqSrc>4))
300308d4:	e1dd30be 	ldrh	r3, [sp, #14]
300308d8:	e3530003 	cmp	r3, #3
300308dc:	8a000002 	bhi	300308ec <StartDMA+0x50>
300308e0:	e1dd30bc 	ldrh	r3, [sp, #12]
300308e4:	e3530004 	cmp	r3, #4
300308e8:	9a000001 	bls	300308f4 <StartDMA+0x58>
		return 1;
300308ec:	e3a03001 	mov	r3, #1
300308f0:	ea000033 	b	300309c4 <StartDMA+0x128>
	if((DMAChannel[ch].used==DMA_IS_FREE)||(DMAChannel[ch].DevID!=DevID))
300308f4:	e1dd20be 	ldrh	r2, [sp, #14]
300308f8:	e59f30d0 	ldr	r3, [pc, #208]	; 300309d0 <StartDMA+0x134>
300308fc:	e1a02182 	lsl	r2, r2, #3
30030900:	e0823003 	add	r3, r2, r3
30030904:	e1d330b0 	ldrh	r3, [r3]
30030908:	e3530000 	cmp	r3, #0
3003090c:	0a000009 	beq	30030938 <StartDMA+0x9c>
30030910:	e1dd10be 	ldrh	r1, [sp, #14]
30030914:	e59f20b4 	ldr	r2, [pc, #180]	; 300309d0 <StartDMA+0x134>
30030918:	e3a03002 	mov	r3, #2
3003091c:	e1a01181 	lsl	r1, r1, #3
30030920:	e0812002 	add	r2, r1, r2
30030924:	e0823003 	add	r3, r2, r3
30030928:	e1d330b0 	ldrh	r3, [r3]
3003092c:	e1dd20ba 	ldrh	r2, [sp, #10]
30030930:	e1520003 	cmp	r2, r3
30030934:	0a000001 	beq	30030940 <StartDMA+0xa4>
		return 1;
30030938:	e3a03001 	mov	r3, #1
3003093c:	ea000020 	b	300309c4 <StartDMA+0x128>
#endif
	
	if(DMAChannel[ch].used==DMA_IS_HWTRIG)
30030940:	e1dd20be 	ldrh	r2, [sp, #14]
30030944:	e59f3084 	ldr	r3, [pc, #132]	; 300309d0 <StartDMA+0x134>
30030948:	e1a02182 	lsl	r2, r2, #3
3003094c:	e0823003 	add	r3, r2, r3
30030950:	e1d330b0 	ldrh	r3, [r3]
30030954:	e3530002 	cmp	r3, #2
30030958:	1a000008 	bne	30030980 <StartDMA+0xe4>
		DMAChannel[ch].pDMA->DMASKTRIG = 2;		//channel on
3003095c:	e1dd10be 	ldrh	r1, [sp, #14]
30030960:	e59f2068 	ldr	r2, [pc, #104]	; 300309d0 <StartDMA+0x134>
30030964:	e3a03004 	mov	r3, #4
30030968:	e1a01181 	lsl	r1, r1, #3
3003096c:	e0812002 	add	r2, r1, r2
30030970:	e0823003 	add	r3, r2, r3
30030974:	e5933000 	ldr	r3, [r3]
30030978:	e3a02002 	mov	r2, #2
3003097c:	e5832020 	str	r2, [r3, #32]
	if(DMAChannel[ch].used==DMA_IS_SWTRIG)
30030980:	e1dd20be 	ldrh	r2, [sp, #14]
30030984:	e59f3044 	ldr	r3, [pc, #68]	; 300309d0 <StartDMA+0x134>
30030988:	e1a02182 	lsl	r2, r2, #3
3003098c:	e0823003 	add	r3, r2, r3
30030990:	e1d330b0 	ldrh	r3, [r3]
30030994:	e3530001 	cmp	r3, #1
30030998:	1a000008 	bne	300309c0 <StartDMA+0x124>
		DMAChannel[ch].pDMA->DMASKTRIG = 3;		//sw_trig
3003099c:	e1dd10be 	ldrh	r1, [sp, #14]
300309a0:	e59f2028 	ldr	r2, [pc, #40]	; 300309d0 <StartDMA+0x134>
300309a4:	e3a03004 	mov	r3, #4
300309a8:	e1a01181 	lsl	r1, r1, #3
300309ac:	e0812002 	add	r2, r1, r2
300309b0:	e0823003 	add	r3, r2, r3
300309b4:	e5933000 	ldr	r3, [r3]
300309b8:	e3a02003 	mov	r2, #3
300309bc:	e5832020 	str	r2, [r3, #32]
		
	return 0;	
300309c0:	e3a03000 	mov	r3, #0
}
300309c4:	e1a00003 	mov	r0, r3
300309c8:	e28dd010 	add	sp, sp, #16
300309cc:	e12fff1e 	bx	lr
300309d0:	300e58c8 	.word	0x300e58c8

300309d4 <StopDMA>:

acoral_u16 StopDMA(acoral_u32 attr)
{
300309d4:	e24dd010 	sub	sp, sp, #16
300309d8:	e58d0004 	str	r0, [sp, #4]
	acoral_u16 DevID, ReqSrc, ch;
	
	DevID  = attr>>16;
300309dc:	e59d3004 	ldr	r3, [sp, #4]
300309e0:	e1a03823 	lsr	r3, r3, #16
300309e4:	e1cd30ba 	strh	r3, [sp, #10]
	ReqSrc = attr&0xf;
300309e8:	e59d3004 	ldr	r3, [sp, #4]
300309ec:	e1a03803 	lsl	r3, r3, #16
300309f0:	e1a03823 	lsr	r3, r3, #16
300309f4:	e203300f 	and	r3, r3, #15
300309f8:	e1cd30bc 	strh	r3, [sp, #12]
	ch     = (attr&0xf0)>>4;		
300309fc:	e59d3004 	ldr	r3, [sp, #4]
30030a00:	e20330f0 	and	r3, r3, #240	; 0xf0
30030a04:	e1a03223 	lsr	r3, r3, #4
30030a08:	e1cd30be 	strh	r3, [sp, #14]
#if	DMA_CHECK_ATTR		
	if((ch>=MAX_DMA_CHANNEL)||(ReqSrc>4))
30030a0c:	e1dd30be 	ldrh	r3, [sp, #14]
30030a10:	e3530003 	cmp	r3, #3
30030a14:	8a000002 	bhi	30030a24 <StopDMA+0x50>
30030a18:	e1dd30bc 	ldrh	r3, [sp, #12]
30030a1c:	e3530004 	cmp	r3, #4
30030a20:	9a000001 	bls	30030a2c <StopDMA+0x58>
		return 1;
30030a24:	e3a03001 	mov	r3, #1
30030a28:	ea00001c 	b	30030aa0 <StopDMA+0xcc>
	if((DMAChannel[ch].used==DMA_IS_FREE)||(DMAChannel[ch].DevID!=DevID))
30030a2c:	e1dd20be 	ldrh	r2, [sp, #14]
30030a30:	e59f3074 	ldr	r3, [pc, #116]	; 30030aac <StopDMA+0xd8>
30030a34:	e1a02182 	lsl	r2, r2, #3
30030a38:	e0823003 	add	r3, r2, r3
30030a3c:	e1d330b0 	ldrh	r3, [r3]
30030a40:	e3530000 	cmp	r3, #0
30030a44:	0a000009 	beq	30030a70 <StopDMA+0x9c>
30030a48:	e1dd10be 	ldrh	r1, [sp, #14]
30030a4c:	e59f2058 	ldr	r2, [pc, #88]	; 30030aac <StopDMA+0xd8>
30030a50:	e3a03002 	mov	r3, #2
30030a54:	e1a01181 	lsl	r1, r1, #3
30030a58:	e0812002 	add	r2, r1, r2
30030a5c:	e0823003 	add	r3, r2, r3
30030a60:	e1d330b0 	ldrh	r3, [r3]
30030a64:	e1dd20ba 	ldrh	r2, [sp, #10]
30030a68:	e1520003 	cmp	r2, r3
30030a6c:	0a000001 	beq	30030a78 <StopDMA+0xa4>
		return 1;
30030a70:	e3a03001 	mov	r3, #1
30030a74:	ea000009 	b	30030aa0 <StopDMA+0xcc>
#endif	

	DMAChannel[ch].pDMA->DMASKTRIG = 1<<2;	//channel off	
30030a78:	e1dd10be 	ldrh	r1, [sp, #14]
30030a7c:	e59f2028 	ldr	r2, [pc, #40]	; 30030aac <StopDMA+0xd8>
30030a80:	e3a03004 	mov	r3, #4
30030a84:	e1a01181 	lsl	r1, r1, #3
30030a88:	e0812002 	add	r2, r1, r2
30030a8c:	e0823003 	add	r3, r2, r3
30030a90:	e5933000 	ldr	r3, [r3]
30030a94:	e3a02004 	mov	r2, #4
30030a98:	e5832020 	str	r2, [r3, #32]
		
	return 0;
30030a9c:	e3a03000 	mov	r3, #0
}
30030aa0:	e1a00003 	mov	r0, r3
30030aa4:	e28dd010 	add	sp, sp, #16
30030aa8:	e12fff1e 	bx	lr
30030aac:	300e58c8 	.word	0x300e58c8

30030ab0 <SetDMARun>:

acoral_u16 SetDMARun(acoral_u32 attr, acoral_u32 src_addr, acoral_u32 dst_addr, acoral_u32 len)
{
30030ab0:	e24dd018 	sub	sp, sp, #24
30030ab4:	e58d000c 	str	r0, [sp, #12]
30030ab8:	e58d1008 	str	r1, [sp, #8]
30030abc:	e58d2004 	str	r2, [sp, #4]
30030ac0:	e58d3000 	str	r3, [sp]
	acoral_u16 DevID, ReqSrc, ch;
	
	DevID  = attr>>16;
30030ac4:	e59d300c 	ldr	r3, [sp, #12]
30030ac8:	e1a03823 	lsr	r3, r3, #16
30030acc:	e1cd31b2 	strh	r3, [sp, #18]
	ReqSrc = attr&0xf;
30030ad0:	e59d300c 	ldr	r3, [sp, #12]
30030ad4:	e1a03803 	lsl	r3, r3, #16
30030ad8:	e1a03823 	lsr	r3, r3, #16
30030adc:	e203300f 	and	r3, r3, #15
30030ae0:	e1cd31b4 	strh	r3, [sp, #20]
	ch     = (attr&0xf0)>>4;		
30030ae4:	e59d300c 	ldr	r3, [sp, #12]
30030ae8:	e20330f0 	and	r3, r3, #240	; 0xf0
30030aec:	e1a03223 	lsr	r3, r3, #4
30030af0:	e1cd31b6 	strh	r3, [sp, #22]
#if	DMA_CHECK_ATTR		
	if((ch>=MAX_DMA_CHANNEL)||(ReqSrc>4))
30030af4:	e1dd31b6 	ldrh	r3, [sp, #22]
30030af8:	e3530003 	cmp	r3, #3
30030afc:	8a000002 	bhi	30030b0c <SetDMARun+0x5c>
30030b00:	e1dd31b4 	ldrh	r3, [sp, #20]
30030b04:	e3530004 	cmp	r3, #4
30030b08:	9a000001 	bls	30030b14 <SetDMARun+0x64>
		return 1;
30030b0c:	e3a03001 	mov	r3, #1
30030b10:	ea00006f 	b	30030cd4 <SetDMARun+0x224>
	if((DMAChannel[ch].used==DMA_IS_FREE)||(DMAChannel[ch].DevID!=DevID))
30030b14:	e1dd21b6 	ldrh	r2, [sp, #22]
30030b18:	e59f31c0 	ldr	r3, [pc, #448]	; 30030ce0 <SetDMARun+0x230>
30030b1c:	e1a02182 	lsl	r2, r2, #3
30030b20:	e0823003 	add	r3, r2, r3
30030b24:	e1d330b0 	ldrh	r3, [r3]
30030b28:	e3530000 	cmp	r3, #0
30030b2c:	0a000009 	beq	30030b58 <SetDMARun+0xa8>
30030b30:	e1dd11b6 	ldrh	r1, [sp, #22]
30030b34:	e59f21a4 	ldr	r2, [pc, #420]	; 30030ce0 <SetDMARun+0x230>
30030b38:	e3a03002 	mov	r3, #2
30030b3c:	e1a01181 	lsl	r1, r1, #3
30030b40:	e0812002 	add	r2, r1, r2
30030b44:	e0823003 	add	r3, r2, r3
30030b48:	e1d330b0 	ldrh	r3, [r3]
30030b4c:	e1dd21b2 	ldrh	r2, [sp, #18]
30030b50:	e1520003 	cmp	r2, r3
30030b54:	0a000001 	beq	30030b60 <SetDMARun+0xb0>
		return 1;
30030b58:	e3a03001 	mov	r3, #1
30030b5c:	ea00005c 	b	30030cd4 <SetDMARun+0x224>
#endif
	DMAChannel[ch].pDMA->DISRC = src_addr;
30030b60:	e1dd11b6 	ldrh	r1, [sp, #22]
30030b64:	e59f2174 	ldr	r2, [pc, #372]	; 30030ce0 <SetDMARun+0x230>
30030b68:	e3a03004 	mov	r3, #4
30030b6c:	e1a01181 	lsl	r1, r1, #3
30030b70:	e0812002 	add	r2, r1, r2
30030b74:	e0823003 	add	r3, r2, r3
30030b78:	e5933000 	ldr	r3, [r3]
30030b7c:	e59d2008 	ldr	r2, [sp, #8]
30030b80:	e5832000 	str	r2, [r3]
	DMAChannel[ch].pDMA->DIDST = dst_addr;
30030b84:	e1dd11b6 	ldrh	r1, [sp, #22]
30030b88:	e59f2150 	ldr	r2, [pc, #336]	; 30030ce0 <SetDMARun+0x230>
30030b8c:	e3a03004 	mov	r3, #4
30030b90:	e1a01181 	lsl	r1, r1, #3
30030b94:	e0812002 	add	r2, r1, r2
30030b98:	e0823003 	add	r3, r2, r3
30030b9c:	e5933000 	ldr	r3, [r3]
30030ba0:	e59d2004 	ldr	r2, [sp, #4]
30030ba4:	e5832008 	str	r2, [r3, #8]
	DMAChannel[ch].pDMA->DCON &= ~0xfffff;
30030ba8:	e1dd11b6 	ldrh	r1, [sp, #22]
30030bac:	e59f212c 	ldr	r2, [pc, #300]	; 30030ce0 <SetDMARun+0x230>
30030bb0:	e3a03004 	mov	r3, #4
30030bb4:	e1a01181 	lsl	r1, r1, #3
30030bb8:	e0812002 	add	r2, r1, r2
30030bbc:	e0823003 	add	r3, r2, r3
30030bc0:	e5932000 	ldr	r2, [r3]
30030bc4:	e1dd01b6 	ldrh	r0, [sp, #22]
30030bc8:	e59f1110 	ldr	r1, [pc, #272]	; 30030ce0 <SetDMARun+0x230>
30030bcc:	e3a03004 	mov	r3, #4
30030bd0:	e1a00180 	lsl	r0, r0, #3
30030bd4:	e0801001 	add	r1, r0, r1
30030bd8:	e0813003 	add	r3, r1, r3
30030bdc:	e5933000 	ldr	r3, [r3]
30030be0:	e5933010 	ldr	r3, [r3, #16]
30030be4:	e1a03a23 	lsr	r3, r3, #20
30030be8:	e1a03a03 	lsl	r3, r3, #20
30030bec:	e5823010 	str	r3, [r2, #16]
	DMAChannel[ch].pDMA->DCON |= len&0xfffff;
30030bf0:	e1dd11b6 	ldrh	r1, [sp, #22]
30030bf4:	e59f20e4 	ldr	r2, [pc, #228]	; 30030ce0 <SetDMARun+0x230>
30030bf8:	e3a03004 	mov	r3, #4
30030bfc:	e1a01181 	lsl	r1, r1, #3
30030c00:	e0812002 	add	r2, r1, r2
30030c04:	e0823003 	add	r3, r2, r3
30030c08:	e5932000 	ldr	r2, [r3]
30030c0c:	e1dd01b6 	ldrh	r0, [sp, #22]
30030c10:	e59f10c8 	ldr	r1, [pc, #200]	; 30030ce0 <SetDMARun+0x230>
30030c14:	e3a03004 	mov	r3, #4
30030c18:	e1a00180 	lsl	r0, r0, #3
30030c1c:	e0801001 	add	r1, r0, r1
30030c20:	e0813003 	add	r3, r1, r3
30030c24:	e5933000 	ldr	r3, [r3]
30030c28:	e5931010 	ldr	r1, [r3, #16]
30030c2c:	e59d3000 	ldr	r3, [sp]
30030c30:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
30030c34:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
30030c38:	e1813003 	orr	r3, r1, r3
30030c3c:	e5823010 	str	r3, [r2, #16]
	
	if(attr&DMA_START)
30030c40:	e59d300c 	ldr	r3, [sp, #12]
30030c44:	e2033902 	and	r3, r3, #32768	; 0x8000
30030c48:	e3530000 	cmp	r3, #0
30030c4c:	0a00001f 	beq	30030cd0 <SetDMARun+0x220>
	{
		if(DMAChannel[ch].used==DMA_IS_HWTRIG)
30030c50:	e1dd21b6 	ldrh	r2, [sp, #22]
30030c54:	e59f3084 	ldr	r3, [pc, #132]	; 30030ce0 <SetDMARun+0x230>
30030c58:	e1a02182 	lsl	r2, r2, #3
30030c5c:	e0823003 	add	r3, r2, r3
30030c60:	e1d330b0 	ldrh	r3, [r3]
30030c64:	e3530002 	cmp	r3, #2
30030c68:	1a000008 	bne	30030c90 <SetDMARun+0x1e0>
			DMAChannel[ch].pDMA->DMASKTRIG = 2;		//channel on
30030c6c:	e1dd11b6 	ldrh	r1, [sp, #22]
30030c70:	e59f2068 	ldr	r2, [pc, #104]	; 30030ce0 <SetDMARun+0x230>
30030c74:	e3a03004 	mov	r3, #4
30030c78:	e1a01181 	lsl	r1, r1, #3
30030c7c:	e0812002 	add	r2, r1, r2
30030c80:	e0823003 	add	r3, r2, r3
30030c84:	e5933000 	ldr	r3, [r3]
30030c88:	e3a02002 	mov	r2, #2
30030c8c:	e5832020 	str	r2, [r3, #32]
		if(DMAChannel[ch].used==DMA_IS_SWTRIG)
30030c90:	e1dd21b6 	ldrh	r2, [sp, #22]
30030c94:	e59f3044 	ldr	r3, [pc, #68]	; 30030ce0 <SetDMARun+0x230>
30030c98:	e1a02182 	lsl	r2, r2, #3
30030c9c:	e0823003 	add	r3, r2, r3
30030ca0:	e1d330b0 	ldrh	r3, [r3]
30030ca4:	e3530001 	cmp	r3, #1
30030ca8:	1a000008 	bne	30030cd0 <SetDMARun+0x220>
			DMAChannel[ch].pDMA->DMASKTRIG = 3;		//sw_trig
30030cac:	e1dd11b6 	ldrh	r1, [sp, #22]
30030cb0:	e59f2028 	ldr	r2, [pc, #40]	; 30030ce0 <SetDMARun+0x230>
30030cb4:	e3a03004 	mov	r3, #4
30030cb8:	e1a01181 	lsl	r1, r1, #3
30030cbc:	e0812002 	add	r2, r1, r2
30030cc0:	e0823003 	add	r3, r2, r3
30030cc4:	e5933000 	ldr	r3, [r3]
30030cc8:	e3a02003 	mov	r2, #3
30030ccc:	e5832020 	str	r2, [r3, #32]
	}
	
	return 0;
30030cd0:	e3a03000 	mov	r3, #0
}
30030cd4:	e1a00003 	mov	r0, r3
30030cd8:	e28dd018 	add	sp, sp, #24
30030cdc:	e12fff1e 	bx	lr
30030ce0:	300e58c8 	.word	0x300e58c8

30030ce4 <QueryDMAStat>:

acoral_u32 QueryDMAStat(acoral_u32 attr)
{
30030ce4:	e24dd010 	sub	sp, sp, #16
30030ce8:	e58d0004 	str	r0, [sp, #4]
	acoral_u16 DevID, ReqSrc, ch;
	
	DevID  = attr>>16;
30030cec:	e59d3004 	ldr	r3, [sp, #4]
30030cf0:	e1a03823 	lsr	r3, r3, #16
30030cf4:	e1cd30ba 	strh	r3, [sp, #10]
	ReqSrc = attr&0xf;
30030cf8:	e59d3004 	ldr	r3, [sp, #4]
30030cfc:	e1a03803 	lsl	r3, r3, #16
30030d00:	e1a03823 	lsr	r3, r3, #16
30030d04:	e203300f 	and	r3, r3, #15
30030d08:	e1cd30bc 	strh	r3, [sp, #12]
	ch     = (attr&0xf0)>>4;		
30030d0c:	e59d3004 	ldr	r3, [sp, #4]
30030d10:	e20330f0 	and	r3, r3, #240	; 0xf0
30030d14:	e1a03223 	lsr	r3, r3, #4
30030d18:	e1cd30be 	strh	r3, [sp, #14]
#if	DMA_CHECK_ATTR		
	if((ch>=MAX_DMA_CHANNEL)||(ReqSrc>4))
30030d1c:	e1dd30be 	ldrh	r3, [sp, #14]
30030d20:	e3530003 	cmp	r3, #3
30030d24:	8a000002 	bhi	30030d34 <QueryDMAStat+0x50>
30030d28:	e1dd30bc 	ldrh	r3, [sp, #12]
30030d2c:	e3530004 	cmp	r3, #4
30030d30:	9a000001 	bls	30030d3c <QueryDMAStat+0x58>
		return -1;
30030d34:	e3e03000 	mvn	r3, #0
30030d38:	ea00001a 	b	30030da8 <QueryDMAStat+0xc4>
	if((DMAChannel[ch].used==DMA_IS_FREE)||(DMAChannel[ch].DevID!=DevID))
30030d3c:	e1dd20be 	ldrh	r2, [sp, #14]
30030d40:	e59f306c 	ldr	r3, [pc, #108]	; 30030db4 <QueryDMAStat+0xd0>
30030d44:	e1a02182 	lsl	r2, r2, #3
30030d48:	e0823003 	add	r3, r2, r3
30030d4c:	e1d330b0 	ldrh	r3, [r3]
30030d50:	e3530000 	cmp	r3, #0
30030d54:	0a000009 	beq	30030d80 <QueryDMAStat+0x9c>
30030d58:	e1dd10be 	ldrh	r1, [sp, #14]
30030d5c:	e59f2050 	ldr	r2, [pc, #80]	; 30030db4 <QueryDMAStat+0xd0>
30030d60:	e3a03002 	mov	r3, #2
30030d64:	e1a01181 	lsl	r1, r1, #3
30030d68:	e0812002 	add	r2, r1, r2
30030d6c:	e0823003 	add	r3, r2, r3
30030d70:	e1d330b0 	ldrh	r3, [r3]
30030d74:	e1dd20ba 	ldrh	r2, [sp, #10]
30030d78:	e1520003 	cmp	r2, r3
30030d7c:	0a000001 	beq	30030d88 <QueryDMAStat+0xa4>
		return -1;
30030d80:	e3e03000 	mvn	r3, #0
30030d84:	ea000007 	b	30030da8 <QueryDMAStat+0xc4>
#endif	

	return DMAChannel[ch].pDMA->DSTAT;	//STAT[21:20], CURR_TC[19:0] 
30030d88:	e1dd10be 	ldrh	r1, [sp, #14]
30030d8c:	e59f2020 	ldr	r2, [pc, #32]	; 30030db4 <QueryDMAStat+0xd0>
30030d90:	e3a03004 	mov	r3, #4
30030d94:	e1a01181 	lsl	r1, r1, #3
30030d98:	e0812002 	add	r2, r1, r2
30030d9c:	e0823003 	add	r3, r2, r3
30030da0:	e5933000 	ldr	r3, [r3]
30030da4:	e5933014 	ldr	r3, [r3, #20]
}
30030da8:	e1a00003 	mov	r0, r3
30030dac:	e28dd010 	add	sp, sp, #16
30030db0:	e12fff1e 	bx	lr
30030db4:	300e58c8 	.word	0x300e58c8

30030db8 <QueryDMASrc>:

acoral_u32 QueryDMASrc(acoral_u32 attr)
{
30030db8:	e24dd010 	sub	sp, sp, #16
30030dbc:	e58d0004 	str	r0, [sp, #4]
	acoral_u16 DevID, ReqSrc, ch;
	
	DevID  = attr>>16;
30030dc0:	e59d3004 	ldr	r3, [sp, #4]
30030dc4:	e1a03823 	lsr	r3, r3, #16
30030dc8:	e1cd30ba 	strh	r3, [sp, #10]
	ReqSrc = attr&0xf;
30030dcc:	e59d3004 	ldr	r3, [sp, #4]
30030dd0:	e1a03803 	lsl	r3, r3, #16
30030dd4:	e1a03823 	lsr	r3, r3, #16
30030dd8:	e203300f 	and	r3, r3, #15
30030ddc:	e1cd30bc 	strh	r3, [sp, #12]
	ch     = (attr&0xf0)>>4;		
30030de0:	e59d3004 	ldr	r3, [sp, #4]
30030de4:	e20330f0 	and	r3, r3, #240	; 0xf0
30030de8:	e1a03223 	lsr	r3, r3, #4
30030dec:	e1cd30be 	strh	r3, [sp, #14]
#if	DMA_CHECK_ATTR		
	if((ch>=MAX_DMA_CHANNEL)||(ReqSrc>4))
30030df0:	e1dd30be 	ldrh	r3, [sp, #14]
30030df4:	e3530003 	cmp	r3, #3
30030df8:	8a000002 	bhi	30030e08 <QueryDMASrc+0x50>
30030dfc:	e1dd30bc 	ldrh	r3, [sp, #12]
30030e00:	e3530004 	cmp	r3, #4
30030e04:	9a000001 	bls	30030e10 <QueryDMASrc+0x58>
		return -1;
30030e08:	e3e03000 	mvn	r3, #0
30030e0c:	ea00001a 	b	30030e7c <QueryDMASrc+0xc4>
	if((DMAChannel[ch].used==DMA_IS_FREE)||(DMAChannel[ch].DevID!=DevID))
30030e10:	e1dd20be 	ldrh	r2, [sp, #14]
30030e14:	e59f306c 	ldr	r3, [pc, #108]	; 30030e88 <QueryDMASrc+0xd0>
30030e18:	e1a02182 	lsl	r2, r2, #3
30030e1c:	e0823003 	add	r3, r2, r3
30030e20:	e1d330b0 	ldrh	r3, [r3]
30030e24:	e3530000 	cmp	r3, #0
30030e28:	0a000009 	beq	30030e54 <QueryDMASrc+0x9c>
30030e2c:	e1dd10be 	ldrh	r1, [sp, #14]
30030e30:	e59f2050 	ldr	r2, [pc, #80]	; 30030e88 <QueryDMASrc+0xd0>
30030e34:	e3a03002 	mov	r3, #2
30030e38:	e1a01181 	lsl	r1, r1, #3
30030e3c:	e0812002 	add	r2, r1, r2
30030e40:	e0823003 	add	r3, r2, r3
30030e44:	e1d330b0 	ldrh	r3, [r3]
30030e48:	e1dd20ba 	ldrh	r2, [sp, #10]
30030e4c:	e1520003 	cmp	r2, r3
30030e50:	0a000001 	beq	30030e5c <QueryDMASrc+0xa4>
		return -1;
30030e54:	e3e03000 	mvn	r3, #0
30030e58:	ea000007 	b	30030e7c <QueryDMASrc+0xc4>
#endif	

	return DMAChannel[ch].pDMA->DCSRC;
30030e5c:	e1dd10be 	ldrh	r1, [sp, #14]
30030e60:	e59f2020 	ldr	r2, [pc, #32]	; 30030e88 <QueryDMASrc+0xd0>
30030e64:	e3a03004 	mov	r3, #4
30030e68:	e1a01181 	lsl	r1, r1, #3
30030e6c:	e0812002 	add	r2, r1, r2
30030e70:	e0823003 	add	r3, r2, r3
30030e74:	e5933000 	ldr	r3, [r3]
30030e78:	e5933018 	ldr	r3, [r3, #24]
}
30030e7c:	e1a00003 	mov	r0, r3
30030e80:	e28dd010 	add	sp, sp, #16
30030e84:	e12fff1e 	bx	lr
30030e88:	300e58c8 	.word	0x300e58c8

30030e8c <QueryDMADst>:

acoral_u32 QueryDMADst(acoral_u32 attr)
{
30030e8c:	e24dd010 	sub	sp, sp, #16
30030e90:	e58d0004 	str	r0, [sp, #4]
	acoral_u16 DevID, ReqSrc, ch;
	
	DevID  = attr>>16;
30030e94:	e59d3004 	ldr	r3, [sp, #4]
30030e98:	e1a03823 	lsr	r3, r3, #16
30030e9c:	e1cd30ba 	strh	r3, [sp, #10]
	ReqSrc = attr&0xf;
30030ea0:	e59d3004 	ldr	r3, [sp, #4]
30030ea4:	e1a03803 	lsl	r3, r3, #16
30030ea8:	e1a03823 	lsr	r3, r3, #16
30030eac:	e203300f 	and	r3, r3, #15
30030eb0:	e1cd30bc 	strh	r3, [sp, #12]
	ch     = (attr&0xf0)>>4;		
30030eb4:	e59d3004 	ldr	r3, [sp, #4]
30030eb8:	e20330f0 	and	r3, r3, #240	; 0xf0
30030ebc:	e1a03223 	lsr	r3, r3, #4
30030ec0:	e1cd30be 	strh	r3, [sp, #14]
#if	DMA_CHECK_ATTR		
	if((ch>=MAX_DMA_CHANNEL)||(ReqSrc>4))
30030ec4:	e1dd30be 	ldrh	r3, [sp, #14]
30030ec8:	e3530003 	cmp	r3, #3
30030ecc:	8a000002 	bhi	30030edc <QueryDMADst+0x50>
30030ed0:	e1dd30bc 	ldrh	r3, [sp, #12]
30030ed4:	e3530004 	cmp	r3, #4
30030ed8:	9a000001 	bls	30030ee4 <QueryDMADst+0x58>
		return -1;
30030edc:	e3e03000 	mvn	r3, #0
30030ee0:	ea00001a 	b	30030f50 <QueryDMADst+0xc4>
	if((DMAChannel[ch].used==DMA_IS_FREE)||(DMAChannel[ch].DevID!=DevID))
30030ee4:	e1dd20be 	ldrh	r2, [sp, #14]
30030ee8:	e59f306c 	ldr	r3, [pc, #108]	; 30030f5c <QueryDMADst+0xd0>
30030eec:	e1a02182 	lsl	r2, r2, #3
30030ef0:	e0823003 	add	r3, r2, r3
30030ef4:	e1d330b0 	ldrh	r3, [r3]
30030ef8:	e3530000 	cmp	r3, #0
30030efc:	0a000009 	beq	30030f28 <QueryDMADst+0x9c>
30030f00:	e1dd10be 	ldrh	r1, [sp, #14]
30030f04:	e59f2050 	ldr	r2, [pc, #80]	; 30030f5c <QueryDMADst+0xd0>
30030f08:	e3a03002 	mov	r3, #2
30030f0c:	e1a01181 	lsl	r1, r1, #3
30030f10:	e0812002 	add	r2, r1, r2
30030f14:	e0823003 	add	r3, r2, r3
30030f18:	e1d330b0 	ldrh	r3, [r3]
30030f1c:	e1dd20ba 	ldrh	r2, [sp, #10]
30030f20:	e1520003 	cmp	r2, r3
30030f24:	0a000001 	beq	30030f30 <QueryDMADst+0xa4>
		return -1;
30030f28:	e3e03000 	mvn	r3, #0
30030f2c:	ea000007 	b	30030f50 <QueryDMADst+0xc4>
#endif	

	return DMAChannel[ch].pDMA->DCDST;
30030f30:	e1dd10be 	ldrh	r1, [sp, #14]
30030f34:	e59f2020 	ldr	r2, [pc, #32]	; 30030f5c <QueryDMADst+0xd0>
30030f38:	e3a03004 	mov	r3, #4
30030f3c:	e1a01181 	lsl	r1, r1, #3
30030f40:	e0812002 	add	r2, r1, r2
30030f44:	e0823003 	add	r3, r2, r3
30030f48:	e5933000 	ldr	r3, [r3]
30030f4c:	e593301c 	ldr	r3, [r3, #28]
}
30030f50:	e1a00003 	mov	r0, r3
30030f54:	e28dd010 	add	sp, sp, #16
30030f58:	e12fff1e 	bx	lr
30030f5c:	300e58c8 	.word	0x300e58c8

30030f60 <DbgChgUartDiv>:
static acoral_u16 PlayVolume = 0xffff;

void DbgChgUartDiv(void)
{
	//Uart_Init(0, 115200);
}
30030f60:	e12fff1e 	bx	lr

30030f64 <SetSysFclk>:

static void SetSysFclk( acoral_u32 MPLL )
{
30030f64:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30030f68:	e24dd024 	sub	sp, sp, #36	; 0x24
30030f6c:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 mdiv, pdiv, sdiv, val;
	acoral_u32 mclk;

    mdiv = (MPLL>>12)&0xff;
30030f70:	e59d3004 	ldr	r3, [sp, #4]
30030f74:	e1a03623 	lsr	r3, r3, #12
30030f78:	e20330ff 	and	r3, r3, #255	; 0xff
30030f7c:	e58d300c 	str	r3, [sp, #12]
    pdiv = (MPLL>>4)&0xff;
30030f80:	e59d3004 	ldr	r3, [sp, #4]
30030f84:	e1a03223 	lsr	r3, r3, #4
30030f88:	e20330ff 	and	r3, r3, #255	; 0xff
30030f8c:	e58d3010 	str	r3, [sp, #16]
    sdiv = MPLL&0xf;
30030f90:	e59d3004 	ldr	r3, [sp, #4]
30030f94:	e203300f 	and	r3, r3, #15
30030f98:	e58d3014 	str	r3, [sp, #20]
    
    val = 1;
30030f9c:	e3a03001 	mov	r3, #1
30030fa0:	e58d3018 	str	r3, [sp, #24]
    while(sdiv--)
30030fa4:	ea000002 	b	30030fb4 <SetSysFclk+0x50>
    {
    	val *= 2;
30030fa8:	e59d3018 	ldr	r3, [sp, #24]
30030fac:	e1a03083 	lsl	r3, r3, #1
30030fb0:	e58d3018 	str	r3, [sp, #24]
    mdiv = (MPLL>>12)&0xff;
    pdiv = (MPLL>>4)&0xff;
    sdiv = MPLL&0xf;
    
    val = 1;
    while(sdiv--)
30030fb4:	e59d3014 	ldr	r3, [sp, #20]
30030fb8:	e3530000 	cmp	r3, #0
30030fbc:	03a03000 	moveq	r3, #0
30030fc0:	13a03001 	movne	r3, #1
30030fc4:	e20330ff 	and	r3, r3, #255	; 0xff
30030fc8:	e59d2014 	ldr	r2, [sp, #20]
30030fcc:	e2422001 	sub	r2, r2, #1
30030fd0:	e58d2014 	str	r2, [sp, #20]
30030fd4:	e3530000 	cmp	r3, #0
30030fd8:	1afffff2 	bne	30030fa8 <SetSysFclk+0x44>
    {
    	val *= 2;
    }
    		
    mclk = ((mdiv+8)*12000000)/((pdiv+2)*val) ;	    	
30030fdc:	e59d200c 	ldr	r2, [sp, #12]
30030fe0:	e1a03002 	mov	r3, r2
30030fe4:	e1a03283 	lsl	r3, r3, #5
30030fe8:	e0623003 	rsb	r3, r2, r3
30030fec:	e1a03103 	lsl	r3, r3, #2
30030ff0:	e0833002 	add	r3, r3, r2
30030ff4:	e1a02103 	lsl	r2, r3, #2
30030ff8:	e0833002 	add	r3, r3, r2
30030ffc:	e1a02103 	lsl	r2, r3, #2
30031000:	e0833002 	add	r3, r3, r2
30031004:	e1a02203 	lsl	r2, r3, #4
30031008:	e0632002 	rsb	r2, r3, r2
3003100c:	e1a03402 	lsl	r3, r2, #8
30031010:	e283365b 	add	r3, r3, #95420416	; 0x5b00000
30031014:	e2833a8d 	add	r3, r3, #577536	; 0x8d000
30031018:	e2833b02 	add	r3, r3, #2048	; 0x800
3003101c:	e59d2010 	ldr	r2, [sp, #16]
30031020:	e2822002 	add	r2, r2, #2
30031024:	e59d1018 	ldr	r1, [sp, #24]
30031028:	e0020291 	mul	r2, r1, r2
3003102c:	e1a00003 	mov	r0, r3
30031030:	e1a01002 	mov	r1, r2
30031034:	eb004b19 	bl	30043ca0 <__aeabi_uidiv>
30031038:	e1a03000 	mov	r3, r0
3003103c:	e58d301c 	str	r3, [sp, #28]
    //Uart_Init(mclk>>2, 115200) ;
}
30031040:	e28dd024 	add	sp, sp, #36	; 0x24
30031044:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30031048:	e12fff1e 	bx	lr

3003104c <waveOutOpen>:
	LPWAVEFORMATEX pwfx,
	DWORD dwCallback,
	DWORD dwCallbackInstance,
	DWORD fdwOpen
)
{
3003104c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30031050:	e24dd01c 	sub	sp, sp, #28
30031054:	e58d000c 	str	r0, [sp, #12]
30031058:	e58d1008 	str	r1, [sp, #8]
3003105c:	e58d2004 	str	r2, [sp, #4]
30031060:	e58d3000 	str	r3, [sp]
	acoral_u8 i;
	acoral_u8 err = 0;
30031064:	e3a03000 	mov	r3, #0
30031068:	e5cd3017 	strb	r3, [sp, #23]
	//PlayStatus.Status		  = DEVICE_FREE;
	if(pwfx->wFormatTag!=WAVE_FORMAT_PCM)	//only support PCM
3003106c:	e59d3004 	ldr	r3, [sp, #4]
30031070:	e1d330b0 	ldrh	r3, [r3]
30031074:	e3530001 	cmp	r3, #1
30031078:	0a000001 	beq	30031084 <waveOutOpen+0x38>
		err = 1;
3003107c:	e3a03001 	mov	r3, #1
30031080:	e5cd3017 	strb	r3, [sp, #23]
	if(pwfx->nChannels!=2)					//must be stero
30031084:	e59d3004 	ldr	r3, [sp, #4]
30031088:	e1d330b2 	ldrh	r3, [r3, #2]
3003108c:	e3530002 	cmp	r3, #2
30031090:	0a000001 	beq	3003109c <waveOutOpen+0x50>
		err = 1;
30031094:	e3a03001 	mov	r3, #1
30031098:	e5cd3017 	strb	r3, [sp, #23]
	if(pwfx->wBitsPerSample%8)				//8 or 16 bits
3003109c:	e59d3004 	ldr	r3, [sp, #4]
300310a0:	e1d330be 	ldrh	r3, [r3, #14]
300310a4:	e2033007 	and	r3, r3, #7
300310a8:	e3530000 	cmp	r3, #0
300310ac:	0a000001 	beq	300310b8 <waveOutOpen+0x6c>
		err = 1;
300310b0:	e3a03001 	mov	r3, #1
300310b4:	e5cd3017 	strb	r3, [sp, #23]
	for(i=0; i<7; i++)
300310b8:	e3a03000 	mov	r3, #0
300310bc:	e5cd3016 	strb	r3, [sp, #22]
300310c0:	ea00000e 	b	30031100 <waveOutOpen+0xb4>
		if(pwfx->nSamplesPerSec==CodecPara[i].Freq)
300310c4:	e59d3004 	ldr	r3, [sp, #4]
300310c8:	e5931004 	ldr	r1, [r3, #4]
300310cc:	e5dd2016 	ldrb	r2, [sp, #22]
300310d0:	e59f027c 	ldr	r0, [pc, #636]	; 30031354 <waveOutOpen+0x308>
300310d4:	e1a03002 	mov	r3, r2
300310d8:	e1a03083 	lsl	r3, r3, #1
300310dc:	e0833002 	add	r3, r3, r2
300310e0:	e1a03103 	lsl	r3, r3, #2
300310e4:	e0833000 	add	r3, r3, r0
300310e8:	e1d330b0 	ldrh	r3, [r3]
300310ec:	e1510003 	cmp	r1, r3
300310f0:	0a000006 	beq	30031110 <waveOutOpen+0xc4>
		err = 1;
	if(pwfx->nChannels!=2)					//must be stero
		err = 1;
	if(pwfx->wBitsPerSample%8)				//8 or 16 bits
		err = 1;
	for(i=0; i<7; i++)
300310f4:	e5dd3016 	ldrb	r3, [sp, #22]
300310f8:	e2833001 	add	r3, r3, #1
300310fc:	e5cd3016 	strb	r3, [sp, #22]
30031100:	e5dd3016 	ldrb	r3, [sp, #22]
30031104:	e3530006 	cmp	r3, #6
30031108:	9affffed 	bls	300310c4 <waveOutOpen+0x78>
3003110c:	ea000000 	b	30031114 <waveOutOpen+0xc8>
		if(pwfx->nSamplesPerSec==CodecPara[i].Freq)
			break;
30031110:	e1a00000 	nop			; (mov r0, r0)
	if(i==7)
30031114:	e5dd3016 	ldrb	r3, [sp, #22]
30031118:	e3530007 	cmp	r3, #7
3003111c:	1a000001 	bne	30031128 <waveOutOpen+0xdc>
		err = 1;		
30031120:	e3a03001 	mov	r3, #1
30031124:	e5cd3017 	strb	r3, [sp, #23]
	if((pwfx->nChannels*pwfx->wBitsPerSample)/8!=pwfx->nBlockAlign)
30031128:	e59d3004 	ldr	r3, [sp, #4]
3003112c:	e1d330b2 	ldrh	r3, [r3, #2]
30031130:	e59d2004 	ldr	r2, [sp, #4]
30031134:	e1d220be 	ldrh	r2, [r2, #14]
30031138:	e0030392 	mul	r3, r2, r3
3003113c:	e2832007 	add	r2, r3, #7
30031140:	e3530000 	cmp	r3, #0
30031144:	b1a03002 	movlt	r3, r2
30031148:	e1a031c3 	asr	r3, r3, #3
3003114c:	e1a02003 	mov	r2, r3
30031150:	e59d3004 	ldr	r3, [sp, #4]
30031154:	e1d330bc 	ldrh	r3, [r3, #12]
30031158:	e1520003 	cmp	r2, r3
3003115c:	0a000001 	beq	30031168 <waveOutOpen+0x11c>
		err = 1;
30031160:	e3a03001 	mov	r3, #1
30031164:	e5cd3017 	strb	r3, [sp, #23]
	if(pwfx->nAvgBytesPerSec!=pwfx->nSamplesPerSec*pwfx->nBlockAlign)
30031168:	e59d3004 	ldr	r3, [sp, #4]
3003116c:	e5932008 	ldr	r2, [r3, #8]
30031170:	e59d3004 	ldr	r3, [sp, #4]
30031174:	e5933004 	ldr	r3, [r3, #4]
30031178:	e59d1004 	ldr	r1, [sp, #4]
3003117c:	e1d110bc 	ldrh	r1, [r1, #12]
30031180:	e0030391 	mul	r3, r1, r3
30031184:	e1520003 	cmp	r2, r3
30031188:	0a000001 	beq	30031194 <waveOutOpen+0x148>
		err = 1;		
3003118c:	e3a03001 	mov	r3, #1
30031190:	e5cd3017 	strb	r3, [sp, #23]
	if(err)											
30031194:	e5dd3017 	ldrb	r3, [sp, #23]
30031198:	e3530000 	cmp	r3, #0
3003119c:	0a000001 	beq	300311a8 <waveOutOpen+0x15c>
		return WAVERR_BADFORMAT;			//check format parameters
300311a0:	e3a03020 	mov	r3, #32
300311a4:	ea000066 	b	30031344 <waveOutOpen+0x2f8>
	
	if(PlayStatus.Status!=DEVICE_FREE)
300311a8:	e59f31a8 	ldr	r3, [pc, #424]	; 30031358 <waveOutOpen+0x30c>
300311ac:	e5d3301c 	ldrb	r3, [r3, #28]
300311b0:	e3530000 	cmp	r3, #0
300311b4:	0a000001 	beq	300311c0 <waveOutOpen+0x174>
		return MMSYSERR_BADDEVICEID;
300311b8:	e3a03002 	mov	r3, #2
300311bc:	ea000060 	b	30031344 <waveOutOpen+0x2f8>
	PlayStatus.DevReq = RequestDMA(PLAY_DMA_ATTR, PLAY_DMA_MODE);				
300311c0:	e3a00401 	mov	r0, #16777216	; 0x1000000
300311c4:	e2800a03 	add	r0, r0, #12288	; 0x3000
300311c8:	e2800020 	add	r0, r0, #32
300311cc:	e3a0120a 	mov	r1, #-1610612736	; 0xa0000000
300311d0:	e281160d 	add	r1, r1, #13631488	; 0xd00000
300311d4:	ebfffca5 	bl	30030470 <RequestDMA>
300311d8:	e1a02000 	mov	r2, r0
300311dc:	e59f3174 	ldr	r3, [pc, #372]	; 30031358 <waveOutOpen+0x30c>
300311e0:	e5832018 	str	r2, [r3, #24]
	if(PlayStatus.DevReq==REQUEST_DMA_FAIL)
300311e4:	e59f316c 	ldr	r3, [pc, #364]	; 30031358 <waveOutOpen+0x30c>
300311e8:	e5933018 	ldr	r3, [r3, #24]
300311ec:	e3530a01 	cmp	r3, #4096	; 0x1000
300311f0:	1a000001 	bne	300311fc <waveOutOpen+0x1b0>
		return MMSYSERR_BADDEVICEID;
300311f4:	e3a03002 	mov	r3, #2
300311f8:	ea000051 	b	30031344 <waveOutOpen+0x2f8>
	
	PlayStatus.handle		  =	*phwo; 
300311fc:	e59d300c 	ldr	r3, [sp, #12]
30031200:	e5932000 	ldr	r2, [r3]
30031204:	e59f314c 	ldr	r3, [pc, #332]	; 30031358 <waveOutOpen+0x30c>
30031208:	e5832000 	str	r2, [r3]
	PlayStatus.wFormatTag     = pwfx->wFormatTag;
3003120c:	e59d3004 	ldr	r3, [sp, #4]
30031210:	e1d320b0 	ldrh	r2, [r3]
30031214:	e59f313c 	ldr	r3, [pc, #316]	; 30031358 <waveOutOpen+0x30c>
30031218:	e1c320b4 	strh	r2, [r3, #4]
	PlayStatus.nChannels      = pwfx->nChannels;	
3003121c:	e59d3004 	ldr	r3, [sp, #4]
30031220:	e1d320b2 	ldrh	r2, [r3, #2]
30031224:	e59f312c 	ldr	r3, [pc, #300]	; 30031358 <waveOutOpen+0x30c>
30031228:	e1c320b6 	strh	r2, [r3, #6]
	PlayStatus.wBitsPerSample = pwfx->wBitsPerSample;
3003122c:	e59d3004 	ldr	r3, [sp, #4]
30031230:	e1d320be 	ldrh	r2, [r3, #14]
30031234:	e59f311c 	ldr	r3, [pc, #284]	; 30031358 <waveOutOpen+0x30c>
30031238:	e1c320b8 	strh	r2, [r3, #8]
	PlayStatus.FsIdx          = i;
3003123c:	e59f3114 	ldr	r3, [pc, #276]	; 30031358 <waveOutOpen+0x30c>
30031240:	e5dd2016 	ldrb	r2, [sp, #22]
30031244:	e5c32014 	strb	r2, [r3, #20]
	PlayStatus.CallBack		  = (CallBackProc)dwCallback;
30031248:	e59d2000 	ldr	r2, [sp]
3003124c:	e59f3104 	ldr	r3, [pc, #260]	; 30031358 <waveOutOpen+0x30c>
30031250:	e583200c 	str	r2, [r3, #12]
	PlayStatus.CallBackInst	  = dwCallbackInstance;
30031254:	e59f30fc 	ldr	r3, [pc, #252]	; 30031358 <waveOutOpen+0x30c>
30031258:	e59d2020 	ldr	r2, [sp, #32]
3003125c:	e5832010 	str	r2, [r3, #16]
	PlayStatus.Status		  = DEVICE_PLAY;
30031260:	e59f30f0 	ldr	r3, [pc, #240]	; 30031358 <waveOutOpen+0x30c>
30031264:	e3a02001 	mov	r2, #1
30031268:	e5c3201c 	strb	r2, [r3, #28]
			
	save_MPLLCON = rMPLLCON;				//save MPLLCON value
3003126c:	e3a03313 	mov	r3, #1275068416	; 0x4c000000
30031270:	e2833004 	add	r3, r3, #4
30031274:	e5932000 	ldr	r2, [r3]
30031278:	e59f30dc 	ldr	r3, [pc, #220]	; 3003135c <waveOutOpen+0x310>
3003127c:	e5832000 	str	r2, [r3]
	SetSysFclk(CodecPara[PlayStatus.FsIdx].MPLL);
30031280:	e59f30d0 	ldr	r3, [pc, #208]	; 30031358 <waveOutOpen+0x30c>
30031284:	e5d33014 	ldrb	r3, [r3, #20]
30031288:	e1a02003 	mov	r2, r3
3003128c:	e59f00c0 	ldr	r0, [pc, #192]	; 30031354 <waveOutOpen+0x308>
30031290:	e3a01004 	mov	r1, #4
30031294:	e1a03002 	mov	r3, r2
30031298:	e1a03083 	lsl	r3, r3, #1
3003129c:	e0833002 	add	r3, r3, r2
300312a0:	e1a03103 	lsl	r3, r3, #2
300312a4:	e0833000 	add	r3, r3, r0
300312a8:	e0833001 	add	r3, r3, r1
300312ac:	e5933000 	ldr	r3, [r3]
300312b0:	e1a00003 	mov	r0, r3
300312b4:	ebffff2a 	bl	30030f64 <SetSysFclk>
	rCLKCON |= 0x20000;						//enable IIS clock	
300312b8:	e3a03313 	mov	r3, #1275068416	; 0x4c000000
300312bc:	e283300c 	add	r3, r3, #12
300312c0:	e3a02313 	mov	r2, #1275068416	; 0x4c000000
300312c4:	e282200c 	add	r2, r2, #12
300312c8:	e5922000 	ldr	r2, [r2]
300312cc:	e3822802 	orr	r2, r2, #131072	; 0x20000
300312d0:	e5832000 	str	r2, [r3]
	
	//DbgChgUartDiv();
	
	IIS_PortSetting();	    
300312d4:	eb000429 	bl	30032380 <IIS_PortSetting>
	//pISR_DMA2 = (acoral_u32)PlayDMA2Done;

	acoral_intr_set_type(IRQ_DMA2,ACORAL_EXPERT_INTR);
300312d8:	e3a00025 	mov	r0, #37	; 0x25
300312dc:	e3a01002 	mov	r1, #2
300312e0:	ebff4c28 	bl	30004388 <acoral_intr_set_type>
    acoral_intr_attach(IRQ_DMA2,PlayDMA2Done);
300312e4:	e59f3074 	ldr	r3, [pc, #116]	; 30031360 <waveOutOpen+0x314>
300312e8:	e3a00025 	mov	r0, #37	; 0x25
300312ec:	e1a01003 	mov	r1, r3
300312f0:	ebff4aa3 	bl	30003d84 <acoral_intr_attach>

	EnableIrq(BIT_DMA2);
300312f4:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
300312f8:	e2833008 	add	r3, r3, #8
300312fc:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
30031300:	e2822008 	add	r2, r2, #8
30031304:	e5922000 	ldr	r2, [r2]
30031308:	e3c22702 	bic	r2, r2, #524288	; 0x80000
3003130c:	e5832000 	str	r2, [r3]
	PlayTotBlks = 0;
30031310:	e59f304c 	ldr	r3, [pc, #76]	; 30031364 <waveOutOpen+0x318>
30031314:	e3a02000 	mov	r2, #0
30031318:	e5832000 	str	r2, [r3]
	Init1341(PLAY);
3003131c:	e3a00000 	mov	r0, #0
30031320:	eb00055d 	bl	3003289c <Init1341>
	waveOutSetVolume(PlayStatus.handle, PlayVolume);
30031324:	e59f302c 	ldr	r3, [pc, #44]	; 30031358 <waveOutOpen+0x30c>
30031328:	e5932000 	ldr	r2, [r3]
3003132c:	e59f3034 	ldr	r3, [pc, #52]	; 30031368 <waveOutOpen+0x31c>
30031330:	e1d330b0 	ldrh	r3, [r3]
30031334:	e1a00002 	mov	r0, r2
30031338:	e1a01003 	mov	r1, r3
3003133c:	eb0000a9 	bl	300315e8 <waveOutSetVolume>
	
	return MMSYSERR_NOERROR;
30031340:	e3a03000 	mov	r3, #0
}
30031344:	e1a00003 	mov	r0, r3
30031348:	e28dd01c 	add	sp, sp, #28
3003134c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30031350:	e12fff1e 	bx	lr
30031354:	300c5fa8 	.word	0x300c5fa8
30031358:	300e5904 	.word	0x300e5904
3003135c:	300e5900 	.word	0x300e5900
30031360:	300318fc 	.word	0x300318fc
30031364:	300e58f8 	.word	0x300e58f8
30031368:	300c5ffc 	.word	0x300c5ffc

3003136c <waveOutClose>:

MMRESULT waveOutClose(HWAVEOUT hwo)
{
3003136c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30031370:	e24dd00c 	sub	sp, sp, #12
30031374:	e58d0004 	str	r0, [sp, #4]
	if((PlayStatus.handle!=hwo)||(PlayStatus.Status!=DEVICE_PLAY))
30031378:	e59f30b8 	ldr	r3, [pc, #184]	; 30031438 <waveOutClose+0xcc>
3003137c:	e5932000 	ldr	r2, [r3]
30031380:	e59d3004 	ldr	r3, [sp, #4]
30031384:	e1520003 	cmp	r2, r3
30031388:	1a000003 	bne	3003139c <waveOutClose+0x30>
3003138c:	e59f30a4 	ldr	r3, [pc, #164]	; 30031438 <waveOutClose+0xcc>
30031390:	e5d3301c 	ldrb	r3, [r3, #28]
30031394:	e3530001 	cmp	r3, #1
30031398:	0a000001 	beq	300313a4 <waveOutClose+0x38>
		return MMSYSERR_INVALHANDLE;		
3003139c:	e3a03005 	mov	r3, #5
300313a0:	ea000020 	b	30031428 <waveOutClose+0xbc>
		
	rIISCON      = 0x0;						//IIS Interface stop    
300313a4:	e3a03455 	mov	r3, #1426063360	; 0x55000000
300313a8:	e3a02000 	mov	r2, #0
300313ac:	e5832000 	str	r2, [r3]
	rIISFCON     = 0x0; 						//For FIFO flush
300313b0:	e3a03455 	mov	r3, #1426063360	; 0x55000000
300313b4:	e283300c 	add	r3, r3, #12
300313b8:	e3a02000 	mov	r2, #0
300313bc:	e5832000 	str	r2, [r3]
	rCLKCON		&= ~0x20000;				//disable IIS colock
300313c0:	e3a03313 	mov	r3, #1275068416	; 0x4c000000
300313c4:	e283300c 	add	r3, r3, #12
300313c8:	e3a02313 	mov	r2, #1275068416	; 0x4c000000
300313cc:	e282200c 	add	r2, r2, #12
300313d0:	e5922000 	ldr	r2, [r2]
300313d4:	e3c22802 	bic	r2, r2, #131072	; 0x20000
300313d8:	e5832000 	str	r2, [r3]
	SetSysFclk(save_MPLLCON);
300313dc:	e59f3058 	ldr	r3, [pc, #88]	; 3003143c <waveOutClose+0xd0>
300313e0:	e5933000 	ldr	r3, [r3]
300313e4:	e1a00003 	mov	r0, r3
300313e8:	ebfffedd 	bl	30030f64 <SetSysFclk>
	PlayStatus.Status = DEVICE_FREE;    
300313ec:	e59f3044 	ldr	r3, [pc, #68]	; 30031438 <waveOutClose+0xcc>
300313f0:	e3a02000 	mov	r2, #0
300313f4:	e5c3201c 	strb	r2, [r3, #28]
	ReleaseDMA(PlayStatus.DevReq);		
300313f8:	e59f3038 	ldr	r3, [pc, #56]	; 30031438 <waveOutClose+0xcc>
300313fc:	e5933018 	ldr	r3, [r3, #24]
30031400:	e1a00003 	mov	r0, r3
30031404:	ebfffce7 	bl	300307a8 <ReleaseDMA>
	DisableIrq(BIT_DMA2);
30031408:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3003140c:	e2833008 	add	r3, r3, #8
30031410:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
30031414:	e2822008 	add	r2, r2, #8
30031418:	e5922000 	ldr	r2, [r2]
3003141c:	e3822702 	orr	r2, r2, #524288	; 0x80000
30031420:	e5832000 	str	r2, [r3]
			
	return MMSYSERR_NOERROR;
30031424:	e3a03000 	mov	r3, #0
}
30031428:	e1a00003 	mov	r0, r3
3003142c:	e28dd00c 	add	sp, sp, #12
30031430:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30031434:	e12fff1e 	bx	lr
30031438:	300e5904 	.word	0x300e5904
3003143c:	300e5900 	.word	0x300e5900

30031440 <waveOutPrepareHeader>:

MMRESULT waveOutPrepareHeader(HWAVEOUT hwo,	LPWAVEHDR pwh, UINT cbwh)
{
30031440:	e24dd010 	sub	sp, sp, #16
30031444:	e58d000c 	str	r0, [sp, #12]
30031448:	e58d1008 	str	r1, [sp, #8]
3003144c:	e58d2004 	str	r2, [sp, #4]
	if((PlayStatus.handle!=hwo)||(PlayStatus.Status!=DEVICE_PLAY))
30031450:	e59f3064 	ldr	r3, [pc, #100]	; 300314bc <waveOutPrepareHeader+0x7c>
30031454:	e5932000 	ldr	r2, [r3]
30031458:	e59d300c 	ldr	r3, [sp, #12]
3003145c:	e1520003 	cmp	r2, r3
30031460:	1a000003 	bne	30031474 <waveOutPrepareHeader+0x34>
30031464:	e59f3050 	ldr	r3, [pc, #80]	; 300314bc <waveOutPrepareHeader+0x7c>
30031468:	e5d3301c 	ldrb	r3, [r3, #28]
3003146c:	e3530001 	cmp	r3, #1
30031470:	0a000001 	beq	3003147c <waveOutPrepareHeader+0x3c>
		return MMSYSERR_INVALHANDLE;
30031474:	e3a03005 	mov	r3, #5
30031478:	ea00000c 	b	300314b0 <waveOutPrepareHeader+0x70>
	
	pwh->lpNext = 0;
3003147c:	e59d3008 	ldr	r3, [sp, #8]
30031480:	e3a02000 	mov	r2, #0
30031484:	e5832018 	str	r2, [r3, #24]
	pwh->dwBytesRecorded = 0;
30031488:	e59d3008 	ldr	r3, [sp, #8]
3003148c:	e3a02000 	mov	r2, #0
30031490:	e5832008 	str	r2, [r3, #8]
	pwh->dwUser  = 0;
30031494:	e59d3008 	ldr	r3, [sp, #8]
30031498:	e3a02000 	mov	r2, #0
3003149c:	e583200c 	str	r2, [r3, #12]
	pwh->dwFlags = 0;	
300314a0:	e59d3008 	ldr	r3, [sp, #8]
300314a4:	e3a02000 	mov	r2, #0
300314a8:	e5832010 	str	r2, [r3, #16]
	return MMSYSERR_NOERROR;
300314ac:	e3a03000 	mov	r3, #0
}
300314b0:	e1a00003 	mov	r0, r3
300314b4:	e28dd010 	add	sp, sp, #16
300314b8:	e12fff1e 	bx	lr
300314bc:	300e5904 	.word	0x300e5904

300314c0 <waveOutUnprepareHeader>:
	
MMRESULT waveOutUnprepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh)
{
300314c0:	e24dd010 	sub	sp, sp, #16
300314c4:	e58d000c 	str	r0, [sp, #12]
300314c8:	e58d1008 	str	r1, [sp, #8]
300314cc:	e58d2004 	str	r2, [sp, #4]
	if((PlayStatus.handle!=hwo)||(PlayStatus.Status!=DEVICE_PLAY))
300314d0:	e59f3034 	ldr	r3, [pc, #52]	; 3003150c <waveOutUnprepareHeader+0x4c>
300314d4:	e5932000 	ldr	r2, [r3]
300314d8:	e59d300c 	ldr	r3, [sp, #12]
300314dc:	e1520003 	cmp	r2, r3
300314e0:	1a000003 	bne	300314f4 <waveOutUnprepareHeader+0x34>
300314e4:	e59f3020 	ldr	r3, [pc, #32]	; 3003150c <waveOutUnprepareHeader+0x4c>
300314e8:	e5d3301c 	ldrb	r3, [r3, #28]
300314ec:	e3530001 	cmp	r3, #1
300314f0:	0a000001 	beq	300314fc <waveOutUnprepareHeader+0x3c>
		return MMSYSERR_INVALHANDLE;
300314f4:	e3a03005 	mov	r3, #5
300314f8:	ea000000 	b	30031500 <waveOutUnprepareHeader+0x40>
		
	return MMSYSERR_NOERROR;
300314fc:	e3a03000 	mov	r3, #0
}
30031500:	e1a00003 	mov	r0, r3
30031504:	e28dd010 	add	sp, sp, #16
30031508:	e12fff1e 	bx	lr
3003150c:	300e5904 	.word	0x300e5904

30031510 <waveOutWrite>:

MMRESULT waveOutWrite(HWAVEOUT hwo,	LPWAVEHDR pwh, UINT cbwh)
{
30031510:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30031514:	e24dd014 	sub	sp, sp, #20
30031518:	e58d000c 	str	r0, [sp, #12]
3003151c:	e58d1008 	str	r1, [sp, #8]
30031520:	e58d2004 	str	r2, [sp, #4]
	if((PlayStatus.handle!=hwo)||(PlayStatus.Status!=DEVICE_PLAY))
30031524:	e59f30a8 	ldr	r3, [pc, #168]	; 300315d4 <waveOutWrite+0xc4>
30031528:	e5932000 	ldr	r2, [r3]
3003152c:	e59d300c 	ldr	r3, [sp, #12]
30031530:	e1520003 	cmp	r2, r3
30031534:	1a000003 	bne	30031548 <waveOutWrite+0x38>
30031538:	e59f3094 	ldr	r3, [pc, #148]	; 300315d4 <waveOutWrite+0xc4>
3003153c:	e5d3301c 	ldrb	r3, [r3, #28]
30031540:	e3530001 	cmp	r3, #1
30031544:	0a000001 	beq	30031550 <waveOutWrite+0x40>
		return MMSYSERR_INVALHANDLE;
30031548:	e3a03005 	mov	r3, #5
3003154c:	ea00001c 	b	300315c4 <waveOutWrite+0xb4>
	
	if(!PlayTotBlks)
30031550:	e59f3080 	ldr	r3, [pc, #128]	; 300315d8 <waveOutWrite+0xc8>
30031554:	e5933000 	ldr	r3, [r3]
30031558:	e3530000 	cmp	r3, #0
3003155c:	1a000008 	bne	30031584 <waveOutWrite+0x74>
	{
		lpPlayFstBlk = pwh;
30031560:	e59f3074 	ldr	r3, [pc, #116]	; 300315dc <waveOutWrite+0xcc>
30031564:	e59d2008 	ldr	r2, [sp, #8]
30031568:	e5832000 	str	r2, [r3]
		lpPlayCurBlk = lpPlayFstBlk;
3003156c:	e59f3068 	ldr	r3, [pc, #104]	; 300315dc <waveOutWrite+0xcc>
30031570:	e5932000 	ldr	r2, [r3]
30031574:	e59f3064 	ldr	r3, [pc, #100]	; 300315e0 <waveOutWrite+0xd0>
30031578:	e5832000 	str	r2, [r3]
		StartPlay();					
3003157c:	eb0000a4 	bl	30031814 <StartPlay>
30031580:	ea000003 	b	30031594 <waveOutWrite+0x84>
	}
	else
	{
		lpPlayLstBlk -> lpNext = pwh ;
30031584:	e59f3058 	ldr	r3, [pc, #88]	; 300315e4 <waveOutWrite+0xd4>
30031588:	e5933000 	ldr	r3, [r3]
3003158c:	e59d2008 	ldr	r2, [sp, #8]
30031590:	e5832018 	str	r2, [r3, #24]
	}
	lpPlayLstBlk = pwh;
30031594:	e59f3048 	ldr	r3, [pc, #72]	; 300315e4 <waveOutWrite+0xd4>
30031598:	e59d2008 	ldr	r2, [sp, #8]
3003159c:	e5832000 	str	r2, [r3]
	pwh->lpNext = 0;
300315a0:	e59d3008 	ldr	r3, [sp, #8]
300315a4:	e3a02000 	mov	r2, #0
300315a8:	e5832018 	str	r2, [r3, #24]
	PlayTotBlks++;		
300315ac:	e59f3024 	ldr	r3, [pc, #36]	; 300315d8 <waveOutWrite+0xc8>
300315b0:	e5933000 	ldr	r3, [r3]
300315b4:	e2832001 	add	r2, r3, #1
300315b8:	e59f3018 	ldr	r3, [pc, #24]	; 300315d8 <waveOutWrite+0xc8>
300315bc:	e5832000 	str	r2, [r3]

	return MMSYSERR_NOERROR;
300315c0:	e3a03000 	mov	r3, #0
}
300315c4:	e1a00003 	mov	r0, r3
300315c8:	e28dd014 	add	sp, sp, #20
300315cc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300315d0:	e12fff1e 	bx	lr
300315d4:	300e5904 	.word	0x300e5904
300315d8:	300e58f8 	.word	0x300e58f8
300315dc:	300e58e8 	.word	0x300e58e8
300315e0:	300eab40 	.word	0x300eab40
300315e4:	300e58f0 	.word	0x300e58f0

300315e8 <waveOutSetVolume>:

MMRESULT waveOutSetVolume(HWAVEOUT hwo,	DWORD dwVolume)
{
300315e8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300315ec:	e24dd00c 	sub	sp, sp, #12
300315f0:	e58d0004 	str	r0, [sp, #4]
300315f4:	e58d1000 	str	r1, [sp]
	if((PlayStatus.handle!=hwo)||(PlayStatus.Status!=DEVICE_PLAY))
300315f8:	e59f305c 	ldr	r3, [pc, #92]	; 3003165c <waveOutSetVolume+0x74>
300315fc:	e5932000 	ldr	r2, [r3]
30031600:	e59d3004 	ldr	r3, [sp, #4]
30031604:	e1520003 	cmp	r2, r3
30031608:	1a000003 	bne	3003161c <waveOutSetVolume+0x34>
3003160c:	e59f3048 	ldr	r3, [pc, #72]	; 3003165c <waveOutSetVolume+0x74>
30031610:	e5d3301c 	ldrb	r3, [r3, #28]
30031614:	e3530001 	cmp	r3, #1
30031618:	0a000001 	beq	30031624 <waveOutSetVolume+0x3c>
		return MMSYSERR_INVALHANDLE;
3003161c:	e3a03005 	mov	r3, #5
30031620:	ea000009 	b	3003164c <waveOutSetVolume+0x64>
		
	PlayVolume = dwVolume&0xffff;
30031624:	e59d3000 	ldr	r3, [sp]
30031628:	e1a03803 	lsl	r3, r3, #16
3003162c:	e1a02823 	lsr	r2, r3, #16
30031630:	e59f3028 	ldr	r3, [pc, #40]	; 30031660 <waveOutSetVolume+0x78>
30031634:	e1c320b0 	strh	r2, [r3]
	AdjVolume(PlayVolume);			
30031638:	e59f3020 	ldr	r3, [pc, #32]	; 30031660 <waveOutSetVolume+0x78>
3003163c:	e1d330b0 	ldrh	r3, [r3]
30031640:	e1a00003 	mov	r0, r3
30031644:	eb000515 	bl	30032aa0 <AdjVolume>
		
	return MMSYSERR_NOERROR;
30031648:	e3a03000 	mov	r3, #0
}	
3003164c:	e1a00003 	mov	r0, r3
30031650:	e28dd00c 	add	sp, sp, #12
30031654:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30031658:	e12fff1e 	bx	lr
3003165c:	300e5904 	.word	0x300e5904
30031660:	300c5ffc 	.word	0x300c5ffc

30031664 <waveOutGetVolume>:

MMRESULT waveOutGetVolume(HWAVEOUT hwo,	LPDWORD pdwVolume)
{
30031664:	e24dd008 	sub	sp, sp, #8
30031668:	e58d0004 	str	r0, [sp, #4]
3003166c:	e58d1000 	str	r1, [sp]
	if((PlayStatus.handle!=hwo)||(PlayStatus.Status!=DEVICE_PLAY))
30031670:	e59f3048 	ldr	r3, [pc, #72]	; 300316c0 <waveOutGetVolume+0x5c>
30031674:	e5932000 	ldr	r2, [r3]
30031678:	e59d3004 	ldr	r3, [sp, #4]
3003167c:	e1520003 	cmp	r2, r3
30031680:	1a000003 	bne	30031694 <waveOutGetVolume+0x30>
30031684:	e59f3034 	ldr	r3, [pc, #52]	; 300316c0 <waveOutGetVolume+0x5c>
30031688:	e5d3301c 	ldrb	r3, [r3, #28]
3003168c:	e3530001 	cmp	r3, #1
30031690:	0a000001 	beq	3003169c <waveOutGetVolume+0x38>
		return MMSYSERR_INVALHANDLE;
30031694:	e3a03005 	mov	r3, #5
30031698:	ea000005 	b	300316b4 <waveOutGetVolume+0x50>
		
	*pdwVolume = PlayVolume; 
3003169c:	e59f3020 	ldr	r3, [pc, #32]	; 300316c4 <waveOutGetVolume+0x60>
300316a0:	e1d330b0 	ldrh	r3, [r3]
300316a4:	e1a02003 	mov	r2, r3
300316a8:	e59d3000 	ldr	r3, [sp]
300316ac:	e5832000 	str	r2, [r3]
	return MMSYSERR_NOERROR;
300316b0:	e3a03000 	mov	r3, #0
}
300316b4:	e1a00003 	mov	r0, r3
300316b8:	e28dd008 	add	sp, sp, #8
300316bc:	e12fff1e 	bx	lr
300316c0:	300e5904 	.word	0x300e5904
300316c4:	300c5ffc 	.word	0x300c5ffc

300316c8 <waveOutPause>:

MMRESULT waveOutPause (HWAVEOUT hwo)
{
300316c8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300316cc:	e24dd00c 	sub	sp, sp, #12
300316d0:	e58d0004 	str	r0, [sp, #4]
	if((PlayStatus.handle!=hwo)||(PlayStatus.Status!=DEVICE_PLAY))
300316d4:	e59f3040 	ldr	r3, [pc, #64]	; 3003171c <waveOutPause+0x54>
300316d8:	e5932000 	ldr	r2, [r3]
300316dc:	e59d3004 	ldr	r3, [sp, #4]
300316e0:	e1520003 	cmp	r2, r3
300316e4:	1a000003 	bne	300316f8 <waveOutPause+0x30>
300316e8:	e59f302c 	ldr	r3, [pc, #44]	; 3003171c <waveOutPause+0x54>
300316ec:	e5d3301c 	ldrb	r3, [r3, #28]
300316f0:	e3530001 	cmp	r3, #1
300316f4:	0a000001 	beq	30031700 <waveOutPause+0x38>
		return MMSYSERR_INVALHANDLE;
300316f8:	e3a03005 	mov	r3, #5
300316fc:	ea000002 	b	3003170c <waveOutPause+0x44>

	PlayPause(1);
30031700:	e3a00001 	mov	r0, #1
30031704:	eb0004d2 	bl	30032a54 <PlayPause>
	return MMSYSERR_NOERROR;
30031708:	e3a03000 	mov	r3, #0
}
3003170c:	e1a00003 	mov	r0, r3
30031710:	e28dd00c 	add	sp, sp, #12
30031714:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30031718:	e12fff1e 	bx	lr
3003171c:	300e5904 	.word	0x300e5904

30031720 <waveOutRestart>:

MMRESULT waveOutRestart(HWAVEOUT hwo)
{
30031720:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30031724:	e24dd00c 	sub	sp, sp, #12
30031728:	e58d0004 	str	r0, [sp, #4]
	if((PlayStatus.handle!=hwo)||(PlayStatus.Status!=DEVICE_PLAY))
3003172c:	e59f3040 	ldr	r3, [pc, #64]	; 30031774 <waveOutRestart+0x54>
30031730:	e5932000 	ldr	r2, [r3]
30031734:	e59d3004 	ldr	r3, [sp, #4]
30031738:	e1520003 	cmp	r2, r3
3003173c:	1a000003 	bne	30031750 <waveOutRestart+0x30>
30031740:	e59f302c 	ldr	r3, [pc, #44]	; 30031774 <waveOutRestart+0x54>
30031744:	e5d3301c 	ldrb	r3, [r3, #28]
30031748:	e3530001 	cmp	r3, #1
3003174c:	0a000001 	beq	30031758 <waveOutRestart+0x38>
		return MMSYSERR_INVALHANDLE;
30031750:	e3a03005 	mov	r3, #5
30031754:	ea000002 	b	30031764 <waveOutRestart+0x44>
		
	PlayPause(0);
30031758:	e3a00000 	mov	r0, #0
3003175c:	eb0004bc 	bl	30032a54 <PlayPause>
	return MMSYSERR_NOERROR;
30031760:	e3a03000 	mov	r3, #0
}
30031764:	e1a00003 	mov	r0, r3
30031768:	e28dd00c 	add	sp, sp, #12
3003176c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30031770:	e12fff1e 	bx	lr
30031774:	300e5904 	.word	0x300e5904

30031778 <waveOutReset>:

MMRESULT waveOutReset (HWAVEOUT hwo)
{
30031778:	e24dd008 	sub	sp, sp, #8
3003177c:	e58d0004 	str	r0, [sp, #4]
	if((PlayStatus.handle!=hwo)||(PlayStatus.Status!=DEVICE_PLAY))
30031780:	e59f3034 	ldr	r3, [pc, #52]	; 300317bc <waveOutReset+0x44>
30031784:	e5932000 	ldr	r2, [r3]
30031788:	e59d3004 	ldr	r3, [sp, #4]
3003178c:	e1520003 	cmp	r2, r3
30031790:	1a000003 	bne	300317a4 <waveOutReset+0x2c>
30031794:	e59f3020 	ldr	r3, [pc, #32]	; 300317bc <waveOutReset+0x44>
30031798:	e5d3301c 	ldrb	r3, [r3, #28]
3003179c:	e3530001 	cmp	r3, #1
300317a0:	0a000001 	beq	300317ac <waveOutReset+0x34>
		return MMSYSERR_INVALHANDLE;
300317a4:	e3a03005 	mov	r3, #5
300317a8:	ea000000 	b	300317b0 <waveOutReset+0x38>
		
	return MMSYSERR_NOERROR;
300317ac:	e3a03000 	mov	r3, #0
}
300317b0:	e1a00003 	mov	r0, r3
300317b4:	e28dd008 	add	sp, sp, #8
300317b8:	e12fff1e 	bx	lr
300317bc:	300e5904 	.word	0x300e5904

300317c0 <SetPlayDma>:

//==========================================================
//static __inline void SetPlayDma(void)
__inline void SetPlayDma(void)
{
300317c0:	e92d4008 	push	{r3, lr}
	SetDMARun(PlayStatus.DevReq|DMA_START, (acoral_u32)lpPlayCurBlk->lpData, (acoral_u32)IISFIFO, lpPlayCurBlk->dwBufferLength/2);
300317c4:	e59f3040 	ldr	r3, [pc, #64]	; 3003180c <SetPlayDma+0x4c>
300317c8:	e5933018 	ldr	r3, [r3, #24]
300317cc:	e3831902 	orr	r1, r3, #32768	; 0x8000
300317d0:	e59f3038 	ldr	r3, [pc, #56]	; 30031810 <SetPlayDma+0x50>
300317d4:	e5933000 	ldr	r3, [r3]
300317d8:	e5933000 	ldr	r3, [r3]
300317dc:	e1a02003 	mov	r2, r3
300317e0:	e59f3028 	ldr	r3, [pc, #40]	; 30031810 <SetPlayDma+0x50>
300317e4:	e5933000 	ldr	r3, [r3]
300317e8:	e5933004 	ldr	r3, [r3, #4]
300317ec:	e1a030a3 	lsr	r3, r3, #1
300317f0:	e1a00001 	mov	r0, r1
300317f4:	e1a01002 	mov	r1, r2
300317f8:	e3a02455 	mov	r2, #1426063360	; 0x55000000
300317fc:	e2822010 	add	r2, r2, #16
30031800:	ebfffcaa 	bl	30030ab0 <SetDMARun>
}
30031804:	e8bd4008 	pop	{r3, lr}
30031808:	e12fff1e 	bx	lr
3003180c:	300e5904 	.word	0x300e5904
30031810:	300eab40 	.word	0x300eab40

30031814 <StartPlay>:

static void StartPlay(void)
{
30031814:	e92d4010 	push	{r4, lr}
	SetPlayDma();	   	    	
30031818:	ebffffe8 	bl	300317c0 <SetPlayDma>

	rIISPSR  = CodecPara[PlayStatus.FsIdx].PreScaler;
3003181c:	e3a02455 	mov	r2, #1426063360	; 0x55000000
30031820:	e2822008 	add	r2, r2, #8
30031824:	e59f30c8 	ldr	r3, [pc, #200]	; 300318f4 <StartPlay+0xe0>
30031828:	e5d33014 	ldrb	r3, [r3, #20]
3003182c:	e1a01003 	mov	r1, r3
30031830:	e59fc0c0 	ldr	ip, [pc, #192]	; 300318f8 <StartPlay+0xe4>
30031834:	e3a00008 	mov	r0, #8
30031838:	e1a03001 	mov	r3, r1
3003183c:	e1a03083 	lsl	r3, r3, #1
30031840:	e0833001 	add	r3, r3, r1
30031844:	e1a03103 	lsl	r3, r3, #2
30031848:	e083300c 	add	r3, r3, ip
3003184c:	e0833000 	add	r3, r3, r0
30031850:	e1d330b0 	ldrh	r3, [r3]
30031854:	e5823000 	str	r3, [r2]
	rIISCON  = (1<<5)+(0<<4)+(0<<3)+(1<<2)+(1<<1);	//Tx DMA enable[5], Rx idle[2], Prescaler enable[1]	
30031858:	e3a03455 	mov	r3, #1426063360	; 0x55000000
3003185c:	e3a02026 	mov	r2, #38	; 0x26
30031860:	e5832000 	str	r2, [r3]
	rIISMOD  = (0<<8)+(2<<6)+(0<<5)+(1<<4)+((PlayStatus.wBitsPerSample>>4)<<3)+(CodecPara[PlayStatus.FsIdx].ofs<<2)+(1<<0);	
30031864:	e3a02455 	mov	r2, #1426063360	; 0x55000000
30031868:	e2822004 	add	r2, r2, #4
3003186c:	e59f3080 	ldr	r3, [pc, #128]	; 300318f4 <StartPlay+0xe0>
30031870:	e1d330b8 	ldrh	r3, [r3, #8]
30031874:	e1a03223 	lsr	r3, r3, #4
30031878:	e1a03803 	lsl	r3, r3, #16
3003187c:	e1a03823 	lsr	r3, r3, #16
30031880:	e1a03183 	lsl	r3, r3, #3
30031884:	e2830090 	add	r0, r3, #144	; 0x90
30031888:	e59f3064 	ldr	r3, [pc, #100]	; 300318f4 <StartPlay+0xe0>
3003188c:	e5d33014 	ldrb	r3, [r3, #20]
30031890:	e1a01003 	mov	r1, r3
30031894:	e59f405c 	ldr	r4, [pc, #92]	; 300318f8 <StartPlay+0xe4>
30031898:	e3a0c008 	mov	ip, #8
3003189c:	e1a03001 	mov	r3, r1
300318a0:	e1a03083 	lsl	r3, r3, #1
300318a4:	e0833001 	add	r3, r3, r1
300318a8:	e1a03103 	lsl	r3, r3, #2
300318ac:	e0833004 	add	r3, r3, r4
300318b0:	e083300c 	add	r3, r3, ip
300318b4:	e5d33002 	ldrb	r3, [r3, #2]
300318b8:	e1a03103 	lsl	r3, r3, #2
300318bc:	e0803003 	add	r3, r0, r3
300318c0:	e2833001 	add	r3, r3, #1
300318c4:	e5823000 	str	r3, [r2]
	rIISFCON = (1<<15) + (1<<13);    
300318c8:	e3a03455 	mov	r3, #1426063360	; 0x55000000
300318cc:	e283300c 	add	r3, r3, #12
300318d0:	e3a02a0a 	mov	r2, #40960	; 0xa000
300318d4:	e5832000 	str	r2, [r3]
	rIISCON |= 0x1;    		      
300318d8:	e3a03455 	mov	r3, #1426063360	; 0x55000000
300318dc:	e3a02455 	mov	r2, #1426063360	; 0x55000000
300318e0:	e5922000 	ldr	r2, [r2]
300318e4:	e3822001 	orr	r2, r2, #1
300318e8:	e5832000 	str	r2, [r3]
}
300318ec:	e8bd4010 	pop	{r4, lr}
300318f0:	e12fff1e 	bx	lr
300318f4:	300e5904 	.word	0x300e5904
300318f8:	300c5fa8 	.word	0x300c5fa8

300318fc <PlayDMA2Done>:
			rINTPND = bit;\
			rINTPND;\
		}

void PlayDMA2Done(void)
{
300318fc:	e92d4008 	push	{r3, lr}
	ClearPending(BIT_DMA2);							//Clear pending bit
30031900:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30031904:	e3a02702 	mov	r2, #524288	; 0x80000
30031908:	e5832000 	str	r2, [r3]
3003190c:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30031910:	e2833010 	add	r3, r3, #16
30031914:	e3a02702 	mov	r2, #524288	; 0x80000
30031918:	e5832000 	str	r2, [r3]
3003191c:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30031920:	e2833010 	add	r3, r3, #16
30031924:	e5933000 	ldr	r3, [r3]
    
	lpPlayCurBlk->dwLoops--;
30031928:	e59f3118 	ldr	r3, [pc, #280]	; 30031a48 <PlayDMA2Done+0x14c>
3003192c:	e5933000 	ldr	r3, [r3]
30031930:	e5932014 	ldr	r2, [r3, #20]
30031934:	e2422001 	sub	r2, r2, #1
30031938:	e5832014 	str	r2, [r3, #20]
	/*if(lpPlayCurBlk->lpNext->pcm_dma_buf_cur == end_of_file) {
		end_of_file = -1;
		end_of_song = 1;
		return;
	}*/
	if(lpPlayCurBlk->used) {
3003193c:	e59f3104 	ldr	r3, [pc, #260]	; 30031a48 <PlayDMA2Done+0x14c>
30031940:	e5933000 	ldr	r3, [r3]
30031944:	e5933024 	ldr	r3, [r3, #36]	; 0x24
30031948:	e3530000 	cmp	r3, #0
3003194c:	0a000020 	beq	300319d4 <PlayDMA2Done+0xd8>
		lpPlayCurBlk->used = 0;
30031950:	e59f30f0 	ldr	r3, [pc, #240]	; 30031a48 <PlayDMA2Done+0x14c>
30031954:	e5933000 	ldr	r3, [r3]
30031958:	e3a02000 	mov	r2, #0
3003195c:	e5832024 	str	r2, [r3, #36]	; 0x24
		if(acoral_sem_getnum(pcm_dma_buf_playdone_eve+lpPlayCurBlk->pcm_dma_buf_cur))
30031960:	e59f30e0 	ldr	r3, [pc, #224]	; 30031a48 <PlayDMA2Done+0x14c>
30031964:	e5933000 	ldr	r3, [r3]
30031968:	e5933020 	ldr	r3, [r3, #32]
3003196c:	e1a02003 	mov	r2, r3
30031970:	e1a03002 	mov	r3, r2
30031974:	e1a03183 	lsl	r3, r3, #3
30031978:	e0833002 	add	r3, r3, r2
3003197c:	e1a03103 	lsl	r3, r3, #2
30031980:	e1a02003 	mov	r2, r3
30031984:	e59f30c0 	ldr	r3, [pc, #192]	; 30031a4c <PlayDMA2Done+0x150>
30031988:	e0823003 	add	r3, r2, r3
3003198c:	e1a00003 	mov	r0, r3
30031990:	ebff57f7 	bl	30007974 <acoral_sem_getnum>
30031994:	e1a03000 	mov	r3, r0
30031998:	e3530000 	cmp	r3, #0
3003199c:	0a00000c 	beq	300319d4 <PlayDMA2Done+0xd8>
			acoral_sem_post(pcm_dma_buf_playdone_eve+lpPlayCurBlk->pcm_dma_buf_cur);
300319a0:	e59f30a0 	ldr	r3, [pc, #160]	; 30031a48 <PlayDMA2Done+0x14c>
300319a4:	e5933000 	ldr	r3, [r3]
300319a8:	e5933020 	ldr	r3, [r3, #32]
300319ac:	e1a02003 	mov	r2, r3
300319b0:	e1a03002 	mov	r3, r2
300319b4:	e1a03183 	lsl	r3, r3, #3
300319b8:	e0833002 	add	r3, r3, r2
300319bc:	e1a03103 	lsl	r3, r3, #2
300319c0:	e1a02003 	mov	r2, r3
300319c4:	e59f3080 	ldr	r3, [pc, #128]	; 30031a4c <PlayDMA2Done+0x150>
300319c8:	e0823003 	add	r3, r2, r3
300319cc:	e1a00003 	mov	r0, r3
300319d0:	ebff57a5 	bl	3000786c <acoral_sem_post>
	}

	if(lpPlayCurBlk->lpNext)
300319d4:	e59f306c 	ldr	r3, [pc, #108]	; 30031a48 <PlayDMA2Done+0x14c>
300319d8:	e5933000 	ldr	r3, [r3]
300319dc:	e5933018 	ldr	r3, [r3, #24]
300319e0:	e3530000 	cmp	r3, #0
300319e4:	0a000005 	beq	30031a00 <PlayDMA2Done+0x104>
	{
		lpPlayCurBlk = lpPlayCurBlk->lpNext;
300319e8:	e59f3058 	ldr	r3, [pc, #88]	; 30031a48 <PlayDMA2Done+0x14c>
300319ec:	e5933000 	ldr	r3, [r3]
300319f0:	e5932018 	ldr	r2, [r3, #24]
300319f4:	e59f304c 	ldr	r3, [pc, #76]	; 30031a48 <PlayDMA2Done+0x14c>
300319f8:	e5832000 	str	r2, [r3]
300319fc:	ea00000e 	b	30031a3c <PlayDMA2Done+0x140>
	}
	else
	{
		lpPlayCurBlk = lpPlayFstBlk;
30031a00:	e59f3048 	ldr	r3, [pc, #72]	; 30031a50 <PlayDMA2Done+0x154>
30031a04:	e5932000 	ldr	r2, [r3]
30031a08:	e59f3038 	ldr	r3, [pc, #56]	; 30031a48 <PlayDMA2Done+0x14c>
30031a0c:	e5832000 	str	r2, [r3]
		if(end_of_file != -1){
30031a10:	e59f303c 	ldr	r3, [pc, #60]	; 30031a54 <PlayDMA2Done+0x158>
30031a14:	e5933000 	ldr	r3, [r3]
30031a18:	e3730001 	cmn	r3, #1
30031a1c:	0a000006 	beq	30031a3c <PlayDMA2Done+0x140>
			end_of_file = -1;
30031a20:	e59f302c 	ldr	r3, [pc, #44]	; 30031a54 <PlayDMA2Done+0x158>
30031a24:	e3e02000 	mvn	r2, #0
30031a28:	e5832000 	str	r2, [r3]
			end_of_song = 1;
30031a2c:	e59f3024 	ldr	r3, [pc, #36]	; 30031a58 <PlayDMA2Done+0x15c>
30031a30:	e3a02001 	mov	r2, #1
30031a34:	e5832000 	str	r2, [r3]
			return;
30031a38:	ea000000 	b	30031a40 <PlayDMA2Done+0x144>
		}
	}    
	//lpPlayCurBlk->used = 1;
	SetPlayDma();
30031a3c:	ebffff5f 	bl	300317c0 <SetPlayDma>
}
30031a40:	e8bd4008 	pop	{r3, lr}
30031a44:	e12fff1e 	bx	lr
30031a48:	300eab40 	.word	0x300eab40
30031a4c:	301f57a8 	.word	0x301f57a8
30031a50:	300e58e8 	.word	0x300e58e8
30031a54:	300c6000 	.word	0x300c6000
30031a58:	300e58c4 	.word	0x300e58c4

30031a5c <SetRecDma>:

/************************* Record Function *********************/
static __inline void SetRecDma(void)
{
30031a5c:	e92d4008 	push	{r3, lr}
	SetDMARun(RecStatus.DevReq|DMA_START, (acoral_u32)IISFIFO, (acoral_u32)lpRecCurBlk->lpData, lpRecCurBlk->dwBufferLength/2);
30031a60:	e59f303c 	ldr	r3, [pc, #60]	; 30031aa4 <SetRecDma+0x48>
30031a64:	e5933018 	ldr	r3, [r3, #24]
30031a68:	e3831902 	orr	r1, r3, #32768	; 0x8000
30031a6c:	e59f3034 	ldr	r3, [pc, #52]	; 30031aa8 <SetRecDma+0x4c>
30031a70:	e5933000 	ldr	r3, [r3]
30031a74:	e5933000 	ldr	r3, [r3]
30031a78:	e1a02003 	mov	r2, r3
30031a7c:	e59f3024 	ldr	r3, [pc, #36]	; 30031aa8 <SetRecDma+0x4c>
30031a80:	e5933000 	ldr	r3, [r3]
30031a84:	e5933004 	ldr	r3, [r3, #4]
30031a88:	e1a030a3 	lsr	r3, r3, #1
30031a8c:	e1a00001 	mov	r0, r1
30031a90:	e3a01455 	mov	r1, #1426063360	; 0x55000000
30031a94:	e2811010 	add	r1, r1, #16
30031a98:	ebfffc04 	bl	30030ab0 <SetDMARun>
}
30031a9c:	e8bd4008 	pop	{r3, lr}
30031aa0:	e12fff1e 	bx	lr
30031aa4:	300e5924 	.word	0x300e5924
30031aa8:	3012ac54 	.word	0x3012ac54

30031aac <RecDMADone>:

static void  RecDMADone(void)
{	
30031aac:	e92d4008 	push	{r3, lr}
	if((RecStatus.DevReq&0xff)==0x12)
30031ab0:	e59f30d0 	ldr	r3, [pc, #208]	; 30031b88 <RecDMADone+0xdc>
30031ab4:	e5933018 	ldr	r3, [r3, #24]
30031ab8:	e20330ff 	and	r3, r3, #255	; 0xff
30031abc:	e3530012 	cmp	r3, #18
30031ac0:	1a000009 	bne	30031aec <RecDMADone+0x40>
		ClearPending(BIT_DMA1);						//Clear pending bit
30031ac4:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30031ac8:	e3a02701 	mov	r2, #262144	; 0x40000
30031acc:	e5832000 	str	r2, [r3]
30031ad0:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30031ad4:	e2833010 	add	r3, r3, #16
30031ad8:	e3a02701 	mov	r2, #262144	; 0x40000
30031adc:	e5832000 	str	r2, [r3]
30031ae0:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30031ae4:	e2833010 	add	r3, r3, #16
30031ae8:	e5933000 	ldr	r3, [r3]
	if((RecStatus.DevReq&0xff)==0x21)
30031aec:	e59f3094 	ldr	r3, [pc, #148]	; 30031b88 <RecDMADone+0xdc>
30031af0:	e5933018 	ldr	r3, [r3, #24]
30031af4:	e20330ff 	and	r3, r3, #255	; 0xff
30031af8:	e3530021 	cmp	r3, #33	; 0x21
30031afc:	1a000009 	bne	30031b28 <RecDMADone+0x7c>
		ClearPending(BIT_DMA2);	    
30031b00:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30031b04:	e3a02702 	mov	r2, #524288	; 0x80000
30031b08:	e5832000 	str	r2, [r3]
30031b0c:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30031b10:	e2833010 	add	r3, r3, #16
30031b14:	e3a02702 	mov	r2, #524288	; 0x80000
30031b18:	e5832000 	str	r2, [r3]
30031b1c:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30031b20:	e2833010 	add	r3, r3, #16
30031b24:	e5933000 	ldr	r3, [r3]
    
    lpRecCurBlk->dwBytesRecorded = lpRecCurBlk->dwBufferLength;
30031b28:	e59f305c 	ldr	r3, [pc, #92]	; 30031b8c <RecDMADone+0xe0>
30031b2c:	e5933000 	ldr	r3, [r3]
30031b30:	e59f2054 	ldr	r2, [pc, #84]	; 30031b8c <RecDMADone+0xe0>
30031b34:	e5922000 	ldr	r2, [r2]
30031b38:	e5922004 	ldr	r2, [r2, #4]
30031b3c:	e5832008 	str	r2, [r3, #8]
    
    if(lpRecCurBlk->lpNext)
30031b40:	e59f3044 	ldr	r3, [pc, #68]	; 30031b8c <RecDMADone+0xe0>
30031b44:	e5933000 	ldr	r3, [r3]
30031b48:	e5933018 	ldr	r3, [r3, #24]
30031b4c:	e3530000 	cmp	r3, #0
30031b50:	0a000005 	beq	30031b6c <RecDMADone+0xc0>
    {
    	lpRecCurBlk = lpRecCurBlk->lpNext;    	   	
30031b54:	e59f3030 	ldr	r3, [pc, #48]	; 30031b8c <RecDMADone+0xe0>
30031b58:	e5933000 	ldr	r3, [r3]
30031b5c:	e5932018 	ldr	r2, [r3, #24]
30031b60:	e59f3024 	ldr	r3, [pc, #36]	; 30031b8c <RecDMADone+0xe0>
30031b64:	e5832000 	str	r2, [r3]
30031b68:	ea000003 	b	30031b7c <RecDMADone+0xd0>
    }
    else
    {
       	lpRecCurBlk = lpRecFstBlk;    	    	
30031b6c:	e59f301c 	ldr	r3, [pc, #28]	; 30031b90 <RecDMADone+0xe4>
30031b70:	e5932000 	ldr	r2, [r3]
30031b74:	e59f3010 	ldr	r3, [pc, #16]	; 30031b8c <RecDMADone+0xe0>
30031b78:	e5832000 	str	r2, [r3]
    }
    SetRecDma();
30031b7c:	ebffffb6 	bl	30031a5c <SetRecDma>
}
30031b80:	e8bd4008 	pop	{r3, lr}
30031b84:	e12fff1e 	bx	lr
30031b88:	300e5924 	.word	0x300e5924
30031b8c:	3012ac54 	.word	0x3012ac54
30031b90:	300e58ec 	.word	0x300e58ec

30031b94 <waveInOpen>:
	LPWAVEFORMATEX pwfx,
	DWORD dwCallback,
	DWORD dwCallbackInstance,
	DWORD fdwOpen
)
{
30031b94:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30031b98:	e24dd01c 	sub	sp, sp, #28
30031b9c:	e58d000c 	str	r0, [sp, #12]
30031ba0:	e58d1008 	str	r1, [sp, #8]
30031ba4:	e58d2004 	str	r2, [sp, #4]
30031ba8:	e58d3000 	str	r3, [sp]
	acoral_u8 i;
	acoral_u8 err = 0;
30031bac:	e3a03000 	mov	r3, #0
30031bb0:	e5cd3017 	strb	r3, [sp, #23]
	
	if(pwfx->wFormatTag!=WAVE_FORMAT_PCM)			//only support PCM
30031bb4:	e59d3004 	ldr	r3, [sp, #4]
30031bb8:	e1d330b0 	ldrh	r3, [r3]
30031bbc:	e3530001 	cmp	r3, #1
30031bc0:	0a000001 	beq	30031bcc <waveInOpen+0x38>
		err = 1;
30031bc4:	e3a03001 	mov	r3, #1
30031bc8:	e5cd3017 	strb	r3, [sp, #23]
	if(pwfx->nChannels!=2)							//must be stero
30031bcc:	e59d3004 	ldr	r3, [sp, #4]
30031bd0:	e1d330b2 	ldrh	r3, [r3, #2]
30031bd4:	e3530002 	cmp	r3, #2
30031bd8:	0a000001 	beq	30031be4 <waveInOpen+0x50>
		err = 2;
30031bdc:	e3a03002 	mov	r3, #2
30031be0:	e5cd3017 	strb	r3, [sp, #23]
	if(pwfx->wBitsPerSample%8)						//8 or 16 bits
30031be4:	e59d3004 	ldr	r3, [sp, #4]
30031be8:	e1d330be 	ldrh	r3, [r3, #14]
30031bec:	e2033007 	and	r3, r3, #7
30031bf0:	e3530000 	cmp	r3, #0
30031bf4:	0a000001 	beq	30031c00 <waveInOpen+0x6c>
		err = 3;
30031bf8:	e3a03003 	mov	r3, #3
30031bfc:	e5cd3017 	strb	r3, [sp, #23]
	for(i=0; i<7; i++)
30031c00:	e3a03000 	mov	r3, #0
30031c04:	e5cd3016 	strb	r3, [sp, #22]
30031c08:	ea00000e 	b	30031c48 <waveInOpen+0xb4>
		if(pwfx->nSamplesPerSec==CodecPara[i].Freq)
30031c0c:	e59d3004 	ldr	r3, [sp, #4]
30031c10:	e5931004 	ldr	r1, [r3, #4]
30031c14:	e5dd2016 	ldrb	r2, [sp, #22]
30031c18:	e59f02bc 	ldr	r0, [pc, #700]	; 30031edc <waveInOpen+0x348>
30031c1c:	e1a03002 	mov	r3, r2
30031c20:	e1a03083 	lsl	r3, r3, #1
30031c24:	e0833002 	add	r3, r3, r2
30031c28:	e1a03103 	lsl	r3, r3, #2
30031c2c:	e0833000 	add	r3, r3, r0
30031c30:	e1d330b0 	ldrh	r3, [r3]
30031c34:	e1510003 	cmp	r1, r3
30031c38:	0a000006 	beq	30031c58 <waveInOpen+0xc4>
		err = 1;
	if(pwfx->nChannels!=2)							//must be stero
		err = 2;
	if(pwfx->wBitsPerSample%8)						//8 or 16 bits
		err = 3;
	for(i=0; i<7; i++)
30031c3c:	e5dd3016 	ldrb	r3, [sp, #22]
30031c40:	e2833001 	add	r3, r3, #1
30031c44:	e5cd3016 	strb	r3, [sp, #22]
30031c48:	e5dd3016 	ldrb	r3, [sp, #22]
30031c4c:	e3530006 	cmp	r3, #6
30031c50:	9affffed 	bls	30031c0c <waveInOpen+0x78>
30031c54:	ea000000 	b	30031c5c <waveInOpen+0xc8>
		if(pwfx->nSamplesPerSec==CodecPara[i].Freq)
			break;
30031c58:	e1a00000 	nop			; (mov r0, r0)
	if(i==7)
30031c5c:	e5dd3016 	ldrb	r3, [sp, #22]
30031c60:	e3530007 	cmp	r3, #7
30031c64:	1a000001 	bne	30031c70 <waveInOpen+0xdc>
		err = 4;		
30031c68:	e3a03004 	mov	r3, #4
30031c6c:	e5cd3017 	strb	r3, [sp, #23]
	if((pwfx->nChannels*pwfx->wBitsPerSample)/8!=pwfx->nBlockAlign)
30031c70:	e59d3004 	ldr	r3, [sp, #4]
30031c74:	e1d330b2 	ldrh	r3, [r3, #2]
30031c78:	e59d2004 	ldr	r2, [sp, #4]
30031c7c:	e1d220be 	ldrh	r2, [r2, #14]
30031c80:	e0030392 	mul	r3, r2, r3
30031c84:	e2832007 	add	r2, r3, #7
30031c88:	e3530000 	cmp	r3, #0
30031c8c:	b1a03002 	movlt	r3, r2
30031c90:	e1a031c3 	asr	r3, r3, #3
30031c94:	e1a02003 	mov	r2, r3
30031c98:	e59d3004 	ldr	r3, [sp, #4]
30031c9c:	e1d330bc 	ldrh	r3, [r3, #12]
30031ca0:	e1520003 	cmp	r2, r3
30031ca4:	0a000001 	beq	30031cb0 <waveInOpen+0x11c>
		err = 5;
30031ca8:	e3a03005 	mov	r3, #5
30031cac:	e5cd3017 	strb	r3, [sp, #23]
	if(pwfx->nAvgBytesPerSec!=pwfx->nSamplesPerSec*pwfx->nBlockAlign)
30031cb0:	e59d3004 	ldr	r3, [sp, #4]
30031cb4:	e5932008 	ldr	r2, [r3, #8]
30031cb8:	e59d3004 	ldr	r3, [sp, #4]
30031cbc:	e5933004 	ldr	r3, [r3, #4]
30031cc0:	e59d1004 	ldr	r1, [sp, #4]
30031cc4:	e1d110bc 	ldrh	r1, [r1, #12]
30031cc8:	e0030391 	mul	r3, r1, r3
30031ccc:	e1520003 	cmp	r2, r3
30031cd0:	0a000001 	beq	30031cdc <waveInOpen+0x148>
		err = 6;		
30031cd4:	e3a03006 	mov	r3, #6
30031cd8:	e5cd3017 	strb	r3, [sp, #23]
	if(err)
30031cdc:	e5dd3017 	ldrb	r3, [sp, #23]
30031ce0:	e3530000 	cmp	r3, #0
30031ce4:	0a000001 	beq	30031cf0 <waveInOpen+0x15c>
	{
		//printf("check err = %d\n", err);											
		return WAVERR_BADFORMAT;					//check format parameters
30031ce8:	e3a03020 	mov	r3, #32
30031cec:	ea000076 	b	30031ecc <waveInOpen+0x338>
	}
	
	if(RecStatus.Status!=DEVICE_FREE)
30031cf0:	e59f31e8 	ldr	r3, [pc, #488]	; 30031ee0 <waveInOpen+0x34c>
30031cf4:	e5d3301c 	ldrb	r3, [r3, #28]
30031cf8:	e3530000 	cmp	r3, #0
30031cfc:	0a000001 	beq	30031d08 <waveInOpen+0x174>
		return MMSYSERR_BADDEVICEID;
30031d00:	e3a03002 	mov	r3, #2
30031d04:	ea000070 	b	30031ecc <waveInOpen+0x338>
	RecStatus.DevReq = RequestDMA(REC_DMA_ATTR, REC_DMA_MODE);			
30031d08:	e59f01d4 	ldr	r0, [pc, #468]	; 30031ee4 <waveInOpen+0x350>
30031d0c:	e3a0120a 	mov	r1, #-1610612736	; 0xa0000000
30031d10:	e281160d 	add	r1, r1, #13631488	; 0xd00000
30031d14:	ebfff9d5 	bl	30030470 <RequestDMA>
30031d18:	e1a02000 	mov	r2, r0
30031d1c:	e59f31bc 	ldr	r3, [pc, #444]	; 30031ee0 <waveInOpen+0x34c>
30031d20:	e5832018 	str	r2, [r3, #24]
	if(RecStatus.DevReq==REQUEST_DMA_FAIL)		
30031d24:	e59f31b4 	ldr	r3, [pc, #436]	; 30031ee0 <waveInOpen+0x34c>
30031d28:	e5933018 	ldr	r3, [r3, #24]
30031d2c:	e3530a01 	cmp	r3, #4096	; 0x1000
30031d30:	1a000001 	bne	30031d3c <waveInOpen+0x1a8>
		return MMSYSERR_BADDEVICEID;											
30031d34:	e3a03002 	mov	r3, #2
30031d38:	ea000063 	b	30031ecc <waveInOpen+0x338>
	
	RecStatus.handle 		 =	*phwi; 
30031d3c:	e59d300c 	ldr	r3, [sp, #12]
30031d40:	e5932000 	ldr	r2, [r3]
30031d44:	e59f3194 	ldr	r3, [pc, #404]	; 30031ee0 <waveInOpen+0x34c>
30031d48:	e5832000 	str	r2, [r3]
	RecStatus.wFormatTag     = pwfx->wFormatTag;
30031d4c:	e59d3004 	ldr	r3, [sp, #4]
30031d50:	e1d320b0 	ldrh	r2, [r3]
30031d54:	e59f3184 	ldr	r3, [pc, #388]	; 30031ee0 <waveInOpen+0x34c>
30031d58:	e1c320b4 	strh	r2, [r3, #4]
	RecStatus.nChannels      = pwfx->nChannels;	
30031d5c:	e59d3004 	ldr	r3, [sp, #4]
30031d60:	e1d320b2 	ldrh	r2, [r3, #2]
30031d64:	e59f3174 	ldr	r3, [pc, #372]	; 30031ee0 <waveInOpen+0x34c>
30031d68:	e1c320b6 	strh	r2, [r3, #6]
	RecStatus.wBitsPerSample = pwfx->wBitsPerSample;
30031d6c:	e59d3004 	ldr	r3, [sp, #4]
30031d70:	e1d320be 	ldrh	r2, [r3, #14]
30031d74:	e59f3164 	ldr	r3, [pc, #356]	; 30031ee0 <waveInOpen+0x34c>
30031d78:	e1c320b8 	strh	r2, [r3, #8]
	RecStatus.FsIdx          = i;
30031d7c:	e59f315c 	ldr	r3, [pc, #348]	; 30031ee0 <waveInOpen+0x34c>
30031d80:	e5dd2016 	ldrb	r2, [sp, #22]
30031d84:	e5c32014 	strb	r2, [r3, #20]
	RecStatus.CallBack		 = (CallBackProc)dwCallback;
30031d88:	e59d2000 	ldr	r2, [sp]
30031d8c:	e59f314c 	ldr	r3, [pc, #332]	; 30031ee0 <waveInOpen+0x34c>
30031d90:	e583200c 	str	r2, [r3, #12]
	RecStatus.CallBackInst	 = dwCallbackInstance;
30031d94:	e59f3144 	ldr	r3, [pc, #324]	; 30031ee0 <waveInOpen+0x34c>
30031d98:	e59d2020 	ldr	r2, [sp, #32]
30031d9c:	e5832010 	str	r2, [r3, #16]
	RecStatus.Status		 = DEVICE_REC;
30031da0:	e59f3138 	ldr	r3, [pc, #312]	; 30031ee0 <waveInOpen+0x34c>
30031da4:	e3a02002 	mov	r2, #2
30031da8:	e5c3201c 	strb	r2, [r3, #28]
	
	save_MPLLCON = rMPLLCON;						//save MPLLCON value
30031dac:	e3a03313 	mov	r3, #1275068416	; 0x4c000000
30031db0:	e2833004 	add	r3, r3, #4
30031db4:	e5932000 	ldr	r2, [r3]
30031db8:	e59f3128 	ldr	r3, [pc, #296]	; 30031ee8 <waveInOpen+0x354>
30031dbc:	e5832000 	str	r2, [r3]
	//rMPLLCON = CodecPara[RecStatus.FsIdx].MPLL;
	SetSysFclk(CodecPara[RecStatus.FsIdx].MPLL);
30031dc0:	e59f3118 	ldr	r3, [pc, #280]	; 30031ee0 <waveInOpen+0x34c>
30031dc4:	e5d33014 	ldrb	r3, [r3, #20]
30031dc8:	e1a02003 	mov	r2, r3
30031dcc:	e59f0108 	ldr	r0, [pc, #264]	; 30031edc <waveInOpen+0x348>
30031dd0:	e3a01004 	mov	r1, #4
30031dd4:	e1a03002 	mov	r3, r2
30031dd8:	e1a03083 	lsl	r3, r3, #1
30031ddc:	e0833002 	add	r3, r3, r2
30031de0:	e1a03103 	lsl	r3, r3, #2
30031de4:	e0833000 	add	r3, r3, r0
30031de8:	e0833001 	add	r3, r3, r1
30031dec:	e5933000 	ldr	r3, [r3]
30031df0:	e1a00003 	mov	r0, r3
30031df4:	ebfffc5a 	bl	30030f64 <SetSysFclk>
	rCLKCON |= 0x20000;								//enable IIS clock	
30031df8:	e3a03313 	mov	r3, #1275068416	; 0x4c000000
30031dfc:	e283300c 	add	r3, r3, #12
30031e00:	e3a02313 	mov	r2, #1275068416	; 0x4c000000
30031e04:	e282200c 	add	r2, r2, #12
30031e08:	e5922000 	ldr	r2, [r2]
30031e0c:	e3822802 	orr	r2, r2, #131072	; 0x20000
30031e10:	e5832000 	str	r2, [r3]
	
		DbgChgUartDiv();		
30031e14:	ebfffc51 	bl	30030f60 <DbgChgUartDiv>
			
	IIS_PortSetting();		
30031e18:	eb000158 	bl	30032380 <IIS_PortSetting>
	if((RecStatus.DevReq&0xff)==0x12)
30031e1c:	e59f30bc 	ldr	r3, [pc, #188]	; 30031ee0 <waveInOpen+0x34c>
30031e20:	e5933018 	ldr	r3, [r3, #24]
30031e24:	e20330ff 	and	r3, r3, #255	; 0xff
30031e28:	e3530012 	cmp	r3, #18
30031e2c:	1a00000d 	bne	30031e68 <waveInOpen+0x2d4>
	{
		//pISR_DMA1 = (acoral_u32)RecDMADone;

		acoral_intr_set_type(IRQ_DMA1,ACORAL_EXPERT_INTR);
30031e30:	e3a00024 	mov	r0, #36	; 0x24
30031e34:	e3a01002 	mov	r1, #2
30031e38:	ebff4952 	bl	30004388 <acoral_intr_set_type>
	    acoral_intr_attach(IRQ_DMA1,RecDMADone);
30031e3c:	e59f30a8 	ldr	r3, [pc, #168]	; 30031eec <waveInOpen+0x358>
30031e40:	e3a00024 	mov	r0, #36	; 0x24
30031e44:	e1a01003 	mov	r1, r3
30031e48:	ebff47cd 	bl	30003d84 <acoral_intr_attach>

	    EnableIrq(BIT_DMA1);
30031e4c:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30031e50:	e2833008 	add	r3, r3, #8
30031e54:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
30031e58:	e2822008 	add	r2, r2, #8
30031e5c:	e5922000 	ldr	r2, [r2]
30031e60:	e3c22701 	bic	r2, r2, #262144	; 0x40000
30031e64:	e5832000 	str	r2, [r3]
	}
	if((RecStatus.DevReq&0xff)==0x21)		    
30031e68:	e59f3070 	ldr	r3, [pc, #112]	; 30031ee0 <waveInOpen+0x34c>
30031e6c:	e5933018 	ldr	r3, [r3, #24]
30031e70:	e20330ff 	and	r3, r3, #255	; 0xff
30031e74:	e3530021 	cmp	r3, #33	; 0x21
30031e78:	1a00000d 	bne	30031eb4 <waveInOpen+0x320>
	{

		//pISR_DMA2 = (acoral_u32)RecDMADone;
		acoral_intr_set_type(IRQ_DMA2,ACORAL_EXPERT_INTR);
30031e7c:	e3a00025 	mov	r0, #37	; 0x25
30031e80:	e3a01002 	mov	r1, #2
30031e84:	ebff493f 	bl	30004388 <acoral_intr_set_type>
	    acoral_intr_attach(IRQ_DMA2,RecDMADone);
30031e88:	e59f305c 	ldr	r3, [pc, #92]	; 30031eec <waveInOpen+0x358>
30031e8c:	e3a00025 	mov	r0, #37	; 0x25
30031e90:	e1a01003 	mov	r1, r3
30031e94:	ebff47ba 	bl	30003d84 <acoral_intr_attach>
		EnableIrq(BIT_DMA2);
30031e98:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30031e9c:	e2833008 	add	r3, r3, #8
30031ea0:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
30031ea4:	e2822008 	add	r2, r2, #8
30031ea8:	e5922000 	ldr	r2, [r2]
30031eac:	e3c22702 	bic	r2, r2, #524288	; 0x80000
30031eb0:	e5832000 	str	r2, [r3]
	}
		
	RecTotBlks = 0;
30031eb4:	e59f3034 	ldr	r3, [pc, #52]	; 30031ef0 <waveInOpen+0x35c>
30031eb8:	e3a02000 	mov	r2, #0
30031ebc:	e5832000 	str	r2, [r3]
	Init1341(RECORD);		
30031ec0:	e3a00001 	mov	r0, #1
30031ec4:	eb000274 	bl	3003289c <Init1341>
	
	return MMSYSERR_NOERROR;
30031ec8:	e3a03000 	mov	r3, #0
}
30031ecc:	e1a00003 	mov	r0, r3
30031ed0:	e28dd01c 	add	sp, sp, #28
30031ed4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30031ed8:	e12fff1e 	bx	lr
30031edc:	300c5fa8 	.word	0x300c5fa8
30031ee0:	300e5924 	.word	0x300e5924
30031ee4:	01010321 	.word	0x01010321
30031ee8:	300e5900 	.word	0x300e5900
30031eec:	30031aac 	.word	0x30031aac
30031ef0:	300e58fc 	.word	0x300e58fc

30031ef4 <waveInClose>:

MMRESULT waveInClose(HWAVEOUT hwi)
{
30031ef4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30031ef8:	e24dd00c 	sub	sp, sp, #12
30031efc:	e58d0004 	str	r0, [sp, #4]
	if((RecStatus.handle!=hwi)||(RecStatus.Status!=DEVICE_REC))
30031f00:	e59f30fc 	ldr	r3, [pc, #252]	; 30032004 <waveInClose+0x110>
30031f04:	e5932000 	ldr	r2, [r3]
30031f08:	e59d3004 	ldr	r3, [sp, #4]
30031f0c:	e1520003 	cmp	r2, r3
30031f10:	1a000003 	bne	30031f24 <waveInClose+0x30>
30031f14:	e59f30e8 	ldr	r3, [pc, #232]	; 30032004 <waveInClose+0x110>
30031f18:	e5d3301c 	ldrb	r3, [r3, #28]
30031f1c:	e3530002 	cmp	r3, #2
30031f20:	0a000001 	beq	30031f2c <waveInClose+0x38>
		return MMSYSERR_INVALHANDLE;		
30031f24:	e3a03005 	mov	r3, #5
30031f28:	ea000031 	b	30031ff4 <waveInClose+0x100>

	rIISCON      = 0x0;				//IIS Interface stop    
30031f2c:	e3a03455 	mov	r3, #1426063360	; 0x55000000
30031f30:	e3a02000 	mov	r2, #0
30031f34:	e5832000 	str	r2, [r3]
	rIISFCON     = 0x0;     		//For FIFO flush
30031f38:	e3a03455 	mov	r3, #1426063360	; 0x55000000
30031f3c:	e283300c 	add	r3, r3, #12
30031f40:	e3a02000 	mov	r2, #0
30031f44:	e5832000 	str	r2, [r3]
	rCLKCON		&= ~0x20000;		//disable IIS colock
30031f48:	e3a03313 	mov	r3, #1275068416	; 0x4c000000
30031f4c:	e283300c 	add	r3, r3, #12
30031f50:	e3a02313 	mov	r2, #1275068416	; 0x4c000000
30031f54:	e282200c 	add	r2, r2, #12
30031f58:	e5922000 	ldr	r2, [r2]
30031f5c:	e3c22802 	bic	r2, r2, #131072	; 0x20000
30031f60:	e5832000 	str	r2, [r3]
	//rMPLLCON	 = save_MPLLCON;	//restore MPLLCON value
	SetSysFclk(save_MPLLCON);
30031f64:	e59f309c 	ldr	r3, [pc, #156]	; 30032008 <waveInClose+0x114>
30031f68:	e5933000 	ldr	r3, [r3]
30031f6c:	e1a00003 	mov	r0, r3
30031f70:	ebfffbfb 	bl	30030f64 <SetSysFclk>
    
	RecStatus.Status = DEVICE_FREE;    
30031f74:	e59f3088 	ldr	r3, [pc, #136]	; 30032004 <waveInClose+0x110>
30031f78:	e3a02000 	mov	r2, #0
30031f7c:	e5c3201c 	strb	r2, [r3, #28]
	ReleaseDMA(RecStatus.DevReq);
30031f80:	e59f307c 	ldr	r3, [pc, #124]	; 30032004 <waveInClose+0x110>
30031f84:	e5933018 	ldr	r3, [r3, #24]
30031f88:	e1a00003 	mov	r0, r3
30031f8c:	ebfffa05 	bl	300307a8 <ReleaseDMA>
	if((RecStatus.DevReq&0xff)==0x12)		
30031f90:	e59f306c 	ldr	r3, [pc, #108]	; 30032004 <waveInClose+0x110>
30031f94:	e5933018 	ldr	r3, [r3, #24]
30031f98:	e20330ff 	and	r3, r3, #255	; 0xff
30031f9c:	e3530012 	cmp	r3, #18
30031fa0:	1a000006 	bne	30031fc0 <waveInClose+0xcc>
		DisableIrq(BIT_DMA1);
30031fa4:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30031fa8:	e2833008 	add	r3, r3, #8
30031fac:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
30031fb0:	e2822008 	add	r2, r2, #8
30031fb4:	e5922000 	ldr	r2, [r2]
30031fb8:	e3822701 	orr	r2, r2, #262144	; 0x40000
30031fbc:	e5832000 	str	r2, [r3]
	if((RecStatus.DevReq&0xff)==0x21)
30031fc0:	e59f303c 	ldr	r3, [pc, #60]	; 30032004 <waveInClose+0x110>
30031fc4:	e5933018 	ldr	r3, [r3, #24]
30031fc8:	e20330ff 	and	r3, r3, #255	; 0xff
30031fcc:	e3530021 	cmp	r3, #33	; 0x21
30031fd0:	1a000006 	bne	30031ff0 <waveInClose+0xfc>
		DisableIrq(BIT_DMA2);
30031fd4:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30031fd8:	e2833008 	add	r3, r3, #8
30031fdc:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
30031fe0:	e2822008 	add	r2, r2, #8
30031fe4:	e5922000 	ldr	r2, [r2]
30031fe8:	e3822702 	orr	r2, r2, #524288	; 0x80000
30031fec:	e5832000 	str	r2, [r3]
			
	return MMSYSERR_NOERROR;	
30031ff0:	e3a03000 	mov	r3, #0
}
30031ff4:	e1a00003 	mov	r0, r3
30031ff8:	e28dd00c 	add	sp, sp, #12
30031ffc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30032000:	e12fff1e 	bx	lr
30032004:	300e5924 	.word	0x300e5924
30032008:	300e5900 	.word	0x300e5900

3003200c <waveInStart>:

MMRESULT waveInStart(HWAVEIN hwi)
{
3003200c:	e92d4010 	push	{r4, lr}
30032010:	e24dd008 	sub	sp, sp, #8
30032014:	e58d0004 	str	r0, [sp, #4]
	if((RecStatus.handle!=hwi)||(RecStatus.Status!=DEVICE_REC))
30032018:	e59f3124 	ldr	r3, [pc, #292]	; 30032144 <waveInStart+0x138>
3003201c:	e5932000 	ldr	r2, [r3]
30032020:	e59d3004 	ldr	r3, [sp, #4]
30032024:	e1520003 	cmp	r2, r3
30032028:	1a000003 	bne	3003203c <waveInStart+0x30>
3003202c:	e59f3110 	ldr	r3, [pc, #272]	; 30032144 <waveInStart+0x138>
30032030:	e5d3301c 	ldrb	r3, [r3, #28]
30032034:	e3530002 	cmp	r3, #2
30032038:	0a000001 	beq	30032044 <waveInStart+0x38>
		return MMSYSERR_INVALHANDLE;
3003203c:	e3a03005 	mov	r3, #5
30032040:	ea00003b 	b	30032134 <waveInStart+0x128>
	
	if(!RecTotBlks)
30032044:	e59f30fc 	ldr	r3, [pc, #252]	; 30032148 <waveInStart+0x13c>
30032048:	e5933000 	ldr	r3, [r3]
3003204c:	e3530000 	cmp	r3, #0
30032050:	1a000001 	bne	3003205c <waveInStart+0x50>
		return MMSYSERR_NOMEM;
30032054:	e3a03007 	mov	r3, #7
30032058:	ea000035 	b	30032134 <waveInStart+0x128>
	
	SetRecDma();	
3003205c:	ebfffe7e 	bl	30031a5c <SetRecDma>
	
	rIISPSR  = CodecPara[RecStatus.FsIdx].PreScaler;
30032060:	e3a02455 	mov	r2, #1426063360	; 0x55000000
30032064:	e2822008 	add	r2, r2, #8
30032068:	e59f30d4 	ldr	r3, [pc, #212]	; 30032144 <waveInStart+0x138>
3003206c:	e5d33014 	ldrb	r3, [r3, #20]
30032070:	e1a01003 	mov	r1, r3
30032074:	e59fc0d0 	ldr	ip, [pc, #208]	; 3003214c <waveInStart+0x140>
30032078:	e3a00008 	mov	r0, #8
3003207c:	e1a03001 	mov	r3, r1
30032080:	e1a03083 	lsl	r3, r3, #1
30032084:	e0833001 	add	r3, r3, r1
30032088:	e1a03103 	lsl	r3, r3, #2
3003208c:	e083300c 	add	r3, r3, ip
30032090:	e0833000 	add	r3, r3, r0
30032094:	e1d330b0 	ldrh	r3, [r3]
30032098:	e5823000 	str	r3, [r2]
	rIISCON  = (0<<5)+(1<<4)+(1<<3)+(0<<2)+(1<<1);	//Tx DMA disable,Rx DMA enable,Tx idle,Rx not idle,prescaler enable,stop		
3003209c:	e3a03455 	mov	r3, #1426063360	; 0x55000000
300320a0:	e3a0201a 	mov	r2, #26
300320a4:	e5832000 	str	r2, [r3]
	rIISMOD  = (0<<8)+(1<<6)+(0<<5)+(1<<4)+((RecStatus.wBitsPerSample>>4)<<3)+(CodecPara[RecStatus.FsIdx].ofs<<2)+(1<<0);	
300320a8:	e3a02455 	mov	r2, #1426063360	; 0x55000000
300320ac:	e2822004 	add	r2, r2, #4
300320b0:	e59f308c 	ldr	r3, [pc, #140]	; 30032144 <waveInStart+0x138>
300320b4:	e1d330b8 	ldrh	r3, [r3, #8]
300320b8:	e1a03223 	lsr	r3, r3, #4
300320bc:	e1a03803 	lsl	r3, r3, #16
300320c0:	e1a03823 	lsr	r3, r3, #16
300320c4:	e1a03183 	lsl	r3, r3, #3
300320c8:	e2830050 	add	r0, r3, #80	; 0x50
300320cc:	e59f3070 	ldr	r3, [pc, #112]	; 30032144 <waveInStart+0x138>
300320d0:	e5d33014 	ldrb	r3, [r3, #20]
300320d4:	e1a01003 	mov	r1, r3
300320d8:	e59f406c 	ldr	r4, [pc, #108]	; 3003214c <waveInStart+0x140>
300320dc:	e3a0c008 	mov	ip, #8
300320e0:	e1a03001 	mov	r3, r1
300320e4:	e1a03083 	lsl	r3, r3, #1
300320e8:	e0833001 	add	r3, r3, r1
300320ec:	e1a03103 	lsl	r3, r3, #2
300320f0:	e0833004 	add	r3, r3, r4
300320f4:	e083300c 	add	r3, r3, ip
300320f8:	e5d33002 	ldrb	r3, [r3, #2]
300320fc:	e1a03103 	lsl	r3, r3, #2
30032100:	e0803003 	add	r3, r0, r3
30032104:	e2833001 	add	r3, r3, #1
30032108:	e5823000 	str	r3, [r2]
		//Master mode[8],Rx mode[7:6],Low for Left Channel[5],IIS format[4],16/8bit [3],256/384fs [2],IISCLK 32fs[1:0]	    	
	rIISFCON = (1<<14)+(1<<12);		//Rx DMA,Rx FIFO --> start piling....    
3003210c:	e3a03455 	mov	r3, #1426063360	; 0x55000000
30032110:	e283300c 	add	r3, r3, #12
30032114:	e3a02a05 	mov	r2, #20480	; 0x5000
30032118:	e5832000 	str	r2, [r3]
	rIISCON |= 0x1;    				//start IIS 
3003211c:	e3a03455 	mov	r3, #1426063360	; 0x55000000
30032120:	e3a02455 	mov	r2, #1426063360	; 0x55000000
30032124:	e5922000 	ldr	r2, [r2]
30032128:	e3822001 	orr	r2, r2, #1
3003212c:	e5832000 	str	r2, [r3]
	
	return MMSYSERR_NOERROR;
30032130:	e3a03000 	mov	r3, #0
}
30032134:	e1a00003 	mov	r0, r3
30032138:	e28dd008 	add	sp, sp, #8
3003213c:	e8bd4010 	pop	{r4, lr}
30032140:	e12fff1e 	bx	lr
30032144:	300e5924 	.word	0x300e5924
30032148:	300e58fc 	.word	0x300e58fc
3003214c:	300c5fa8 	.word	0x300c5fa8

30032150 <waveInStop>:

MMRESULT waveInStop(HWAVEIN hwi)
{
30032150:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30032154:	e24dd00c 	sub	sp, sp, #12
30032158:	e58d0004 	str	r0, [sp, #4]
	if((RecStatus.handle!=hwi)||(RecStatus.Status!=DEVICE_REC))
3003215c:	e59f3064 	ldr	r3, [pc, #100]	; 300321c8 <waveInStop+0x78>
30032160:	e5932000 	ldr	r2, [r3]
30032164:	e59d3004 	ldr	r3, [sp, #4]
30032168:	e1520003 	cmp	r2, r3
3003216c:	1a000003 	bne	30032180 <waveInStop+0x30>
30032170:	e59f3050 	ldr	r3, [pc, #80]	; 300321c8 <waveInStop+0x78>
30032174:	e5d3301c 	ldrb	r3, [r3, #28]
30032178:	e3530002 	cmp	r3, #2
3003217c:	0a000001 	beq	30032188 <waveInStop+0x38>
		return MMSYSERR_INVALHANDLE;
30032180:	e3a03005 	mov	r3, #5
30032184:	ea00000b 	b	300321b8 <waveInStop+0x68>
	
	rIISCON     = 0x0;			//IIS Interface stop    
30032188:	e3a03455 	mov	r3, #1426063360	; 0x55000000
3003218c:	e3a02000 	mov	r2, #0
30032190:	e5832000 	str	r2, [r3]
    rIISFCON    = 0x0;     		//For FIFO flush
30032194:	e3a03455 	mov	r3, #1426063360	; 0x55000000
30032198:	e283300c 	add	r3, r3, #12
3003219c:	e3a02000 	mov	r2, #0
300321a0:	e5832000 	str	r2, [r3]
    StopDMA(RecStatus.DevReq);    
300321a4:	e59f301c 	ldr	r3, [pc, #28]	; 300321c8 <waveInStop+0x78>
300321a8:	e5933018 	ldr	r3, [r3, #24]
300321ac:	e1a00003 	mov	r0, r3
300321b0:	ebfffa07 	bl	300309d4 <StopDMA>
		
	return MMSYSERR_NOERROR;
300321b4:	e3a03000 	mov	r3, #0
}
300321b8:	e1a00003 	mov	r0, r3
300321bc:	e28dd00c 	add	sp, sp, #12
300321c0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300321c4:	e12fff1e 	bx	lr
300321c8:	300e5924 	.word	0x300e5924

300321cc <waveInPrepareHeader>:

MMRESULT waveInPrepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh)
{
300321cc:	e24dd010 	sub	sp, sp, #16
300321d0:	e58d000c 	str	r0, [sp, #12]
300321d4:	e58d1008 	str	r1, [sp, #8]
300321d8:	e58d2004 	str	r2, [sp, #4]
	if((RecStatus.handle!=hwi)||(RecStatus.Status!=DEVICE_REC))
300321dc:	e59f3064 	ldr	r3, [pc, #100]	; 30032248 <waveInPrepareHeader+0x7c>
300321e0:	e5932000 	ldr	r2, [r3]
300321e4:	e59d300c 	ldr	r3, [sp, #12]
300321e8:	e1520003 	cmp	r2, r3
300321ec:	1a000003 	bne	30032200 <waveInPrepareHeader+0x34>
300321f0:	e59f3050 	ldr	r3, [pc, #80]	; 30032248 <waveInPrepareHeader+0x7c>
300321f4:	e5d3301c 	ldrb	r3, [r3, #28]
300321f8:	e3530002 	cmp	r3, #2
300321fc:	0a000001 	beq	30032208 <waveInPrepareHeader+0x3c>
		return MMSYSERR_INVALHANDLE;
30032200:	e3a03005 	mov	r3, #5
30032204:	ea00000c 	b	3003223c <waveInPrepareHeader+0x70>
	
	pwh->lpNext = 0;
30032208:	e59d3008 	ldr	r3, [sp, #8]
3003220c:	e3a02000 	mov	r2, #0
30032210:	e5832018 	str	r2, [r3, #24]
	pwh->dwBytesRecorded = 0;
30032214:	e59d3008 	ldr	r3, [sp, #8]
30032218:	e3a02000 	mov	r2, #0
3003221c:	e5832008 	str	r2, [r3, #8]
	pwh->dwUser  = 0;
30032220:	e59d3008 	ldr	r3, [sp, #8]
30032224:	e3a02000 	mov	r2, #0
30032228:	e583200c 	str	r2, [r3, #12]
	pwh->dwFlags = 0;	
3003222c:	e59d3008 	ldr	r3, [sp, #8]
30032230:	e3a02000 	mov	r2, #0
30032234:	e5832010 	str	r2, [r3, #16]
	return MMSYSERR_NOERROR;
30032238:	e3a03000 	mov	r3, #0
}
3003223c:	e1a00003 	mov	r0, r3
30032240:	e28dd010 	add	sp, sp, #16
30032244:	e12fff1e 	bx	lr
30032248:	300e5924 	.word	0x300e5924

3003224c <waveInUnprepareHeader>:

MMRESULT waveInUnprepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh)
{
3003224c:	e24dd010 	sub	sp, sp, #16
30032250:	e58d000c 	str	r0, [sp, #12]
30032254:	e58d1008 	str	r1, [sp, #8]
30032258:	e58d2004 	str	r2, [sp, #4]
	if((RecStatus.handle!=hwi)||(RecStatus.Status!=DEVICE_REC))
3003225c:	e59f3034 	ldr	r3, [pc, #52]	; 30032298 <waveInUnprepareHeader+0x4c>
30032260:	e5932000 	ldr	r2, [r3]
30032264:	e59d300c 	ldr	r3, [sp, #12]
30032268:	e1520003 	cmp	r2, r3
3003226c:	1a000003 	bne	30032280 <waveInUnprepareHeader+0x34>
30032270:	e59f3020 	ldr	r3, [pc, #32]	; 30032298 <waveInUnprepareHeader+0x4c>
30032274:	e5d3301c 	ldrb	r3, [r3, #28]
30032278:	e3530002 	cmp	r3, #2
3003227c:	0a000001 	beq	30032288 <waveInUnprepareHeader+0x3c>
		return MMSYSERR_INVALHANDLE;
30032280:	e3a03005 	mov	r3, #5
30032284:	ea000000 	b	3003228c <waveInUnprepareHeader+0x40>
		
	return MMSYSERR_NOERROR;
30032288:	e3a03000 	mov	r3, #0
}
3003228c:	e1a00003 	mov	r0, r3
30032290:	e28dd010 	add	sp, sp, #16
30032294:	e12fff1e 	bx	lr
30032298:	300e5924 	.word	0x300e5924

3003229c <waveInAddBuffer>:

MMRESULT waveInAddBuffer(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh)
{
3003229c:	e24dd010 	sub	sp, sp, #16
300322a0:	e58d000c 	str	r0, [sp, #12]
300322a4:	e58d1008 	str	r1, [sp, #8]
300322a8:	e58d2004 	str	r2, [sp, #4]
	if((RecStatus.handle!=hwi)||(RecStatus.Status!=DEVICE_REC))
300322ac:	e59f30a0 	ldr	r3, [pc, #160]	; 30032354 <waveInAddBuffer+0xb8>
300322b0:	e5932000 	ldr	r2, [r3]
300322b4:	e59d300c 	ldr	r3, [sp, #12]
300322b8:	e1520003 	cmp	r2, r3
300322bc:	1a000003 	bne	300322d0 <waveInAddBuffer+0x34>
300322c0:	e59f308c 	ldr	r3, [pc, #140]	; 30032354 <waveInAddBuffer+0xb8>
300322c4:	e5d3301c 	ldrb	r3, [r3, #28]
300322c8:	e3530002 	cmp	r3, #2
300322cc:	0a000001 	beq	300322d8 <waveInAddBuffer+0x3c>
		return MMSYSERR_INVALHANDLE;
300322d0:	e3a03005 	mov	r3, #5
300322d4:	ea00001b 	b	30032348 <waveInAddBuffer+0xac>
	
	if(!RecTotBlks)
300322d8:	e59f3078 	ldr	r3, [pc, #120]	; 30032358 <waveInAddBuffer+0xbc>
300322dc:	e5933000 	ldr	r3, [r3]
300322e0:	e3530000 	cmp	r3, #0
300322e4:	1a000007 	bne	30032308 <waveInAddBuffer+0x6c>
	{
		lpRecFstBlk = pwh;
300322e8:	e59f306c 	ldr	r3, [pc, #108]	; 3003235c <waveInAddBuffer+0xc0>
300322ec:	e59d2008 	ldr	r2, [sp, #8]
300322f0:	e5832000 	str	r2, [r3]
		lpRecCurBlk = lpRecFstBlk;							
300322f4:	e59f3060 	ldr	r3, [pc, #96]	; 3003235c <waveInAddBuffer+0xc0>
300322f8:	e5932000 	ldr	r2, [r3]
300322fc:	e59f305c 	ldr	r3, [pc, #92]	; 30032360 <waveInAddBuffer+0xc4>
30032300:	e5832000 	str	r2, [r3]
30032304:	ea000003 	b	30032318 <waveInAddBuffer+0x7c>
	}
	else
	{
		lpRecLstBlk->lpNext = pwh;		
30032308:	e59f3054 	ldr	r3, [pc, #84]	; 30032364 <waveInAddBuffer+0xc8>
3003230c:	e5933000 	ldr	r3, [r3]
30032310:	e59d2008 	ldr	r2, [sp, #8]
30032314:	e5832018 	str	r2, [r3, #24]
	}
	lpRecLstBlk = pwh;
30032318:	e59f3044 	ldr	r3, [pc, #68]	; 30032364 <waveInAddBuffer+0xc8>
3003231c:	e59d2008 	ldr	r2, [sp, #8]
30032320:	e5832000 	str	r2, [r3]
	pwh->lpNext = 0;
30032324:	e59d3008 	ldr	r3, [sp, #8]
30032328:	e3a02000 	mov	r2, #0
3003232c:	e5832018 	str	r2, [r3, #24]
	RecTotBlks++;		
30032330:	e59f3020 	ldr	r3, [pc, #32]	; 30032358 <waveInAddBuffer+0xbc>
30032334:	e5933000 	ldr	r3, [r3]
30032338:	e2832001 	add	r2, r3, #1
3003233c:	e59f3014 	ldr	r3, [pc, #20]	; 30032358 <waveInAddBuffer+0xbc>
30032340:	e5832000 	str	r2, [r3]

	return MMSYSERR_NOERROR;
30032344:	e3a03000 	mov	r3, #0
}
30032348:	e1a00003 	mov	r0, r3
3003234c:	e28dd010 	add	sp, sp, #16
30032350:	e12fff1e 	bx	lr
30032354:	300e5924 	.word	0x300e5924
30032358:	300e58fc 	.word	0x300e58fc
3003235c:	300e58ec 	.word	0x300e58ec
30032360:	3012ac54 	.word	0x3012ac54
30032364:	300e58f4 	.word	0x300e58f4

30032368 <waveInReset>:

MMRESULT waveInReset(HWAVEOUT hwi)
{
30032368:	e24dd008 	sub	sp, sp, #8
3003236c:	e58d0004 	str	r0, [sp, #4]
	return MMSYSERR_NOERROR;
30032370:	e3a03000 	mov	r3, #0
}
30032374:	e1a00003 	mov	r0, r3
30032378:	e28dd008 	add	sp, sp, #8
3003237c:	e12fff1e 	bx	lr

30032380 <IIS_PortSetting>:
//Signal :  L3CLOCK L3DATA L3MODE
//Setting:   OUTPUT OUTPUT OUTPUT 
//           [9:8]   [7:6}  [5:4]
//Binary :     01  ,   01    01 
//----------------------------------------------------------    
	rGPBUP  = rGPBUP  & ~(0x7<<2) | (0x7<<2);   //The pull up function is disabled GPB[4:2] 1 1100    
30032380:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032384:	e2833018 	add	r3, r3, #24
30032388:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3003238c:	e2822018 	add	r2, r2, #24
30032390:	e5922000 	ldr	r2, [r2]
30032394:	e382201c 	orr	r2, r2, #28
30032398:	e5832000 	str	r2, [r3]
	rGPBCON = rGPBCON & ~(0x3f<<4) | (0x15<<4); //GPB[4:2]=Output(L3CLOCK):Output(L3DATA):Output(L3MODE)
3003239c:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300323a0:	e2833010 	add	r3, r3, #16
300323a4:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300323a8:	e2822010 	add	r2, r2, #16
300323ac:	e5922000 	ldr	r2, [r2]
300323b0:	e3c22e3f 	bic	r2, r2, #1008	; 0x3f0
300323b4:	e3822e15 	orr	r2, r2, #336	; 0x150
300323b8:	e5832000 	str	r2, [r3]
//   PORT E GROUP
//Ports  :  GPE4    GPE3   GPE2  GPE1    GPE0 
//Signal : I2SSDO  I2SSDI CDCLK I2SSCLK I2SLRCK 
//Binary :   10  ,   10     10 ,  10      10    
//----------------------------------------------------------
	rGPEUP  = rGPEUP  & ~(0x1f)  | 0x1f;    //The pull up function is disabled GPE[4:0] 1 1111
300323bc:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300323c0:	e2833048 	add	r3, r3, #72	; 0x48
300323c4:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300323c8:	e2822048 	add	r2, r2, #72	; 0x48
300323cc:	e5922000 	ldr	r2, [r2]
300323d0:	e382201f 	orr	r2, r2, #31
300323d4:	e5832000 	str	r2, [r3]
	rGPECON = rGPECON & ~(0x3ff) | 0x2aa;   //GPE[4:0]=I2SSDO:I2SSDI:CDCLK:I2SSCLK:I2SLRCK
300323d8:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300323dc:	e2833040 	add	r3, r3, #64	; 0x40
300323e0:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300323e4:	e2822040 	add	r2, r2, #64	; 0x40
300323e8:	e5922000 	ldr	r2, [r2]
300323ec:	e3c22fff 	bic	r2, r2, #1020	; 0x3fc
300323f0:	e3c22003 	bic	r2, r2, #3
300323f4:	e3822faa 	orr	r2, r2, #680	; 0x2a8
300323f8:	e3822002 	orr	r2, r2, #2
300323fc:	e5832000 	str	r2, [r3]
}    
30032400:	e12fff1e 	bx	lr

30032404 <_WrL3Addr>:
#define L3C (1<<4)              //GPB4 = L3CLOCK
#define L3D (1<<3)              //GPB3 = L3DATA
#define L3M (1<<2)              //GPB2 = L3MODE

static void _WrL3Addr(acoral_u8 data)
{       
30032404:	e24dd010 	sub	sp, sp, #16
30032408:	e1a03000 	mov	r3, r0
3003240c:	e5cd3007 	strb	r3, [sp, #7]
	int i,j;

	rGPBDAT  = rGPBDAT & ~(L3D | L3M | L3C) | L3C;      //L3D=L, L3M=L(in address mode), L3C=H
30032410:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032414:	e2833014 	add	r3, r3, #20
30032418:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3003241c:	e2822014 	add	r2, r2, #20
30032420:	e5922000 	ldr	r2, [r2]
30032424:	e3c2201c 	bic	r2, r2, #28
30032428:	e3822010 	orr	r2, r2, #16
3003242c:	e5832000 	str	r2, [r3]

	for(j=0;j<4;j++);                   //tsu(L3) > 190ns
30032430:	e3a03000 	mov	r3, #0
30032434:	e58d300c 	str	r3, [sp, #12]
30032438:	ea000002 	b	30032448 <_WrL3Addr+0x44>
3003243c:	e59d300c 	ldr	r3, [sp, #12]
30032440:	e2833001 	add	r3, r3, #1
30032444:	e58d300c 	str	r3, [sp, #12]
30032448:	e59d300c 	ldr	r3, [sp, #12]
3003244c:	e3530003 	cmp	r3, #3
30032450:	dafffff9 	ble	3003243c <_WrL3Addr+0x38>

      //GPB[4:2]=L3C:L3D:L3M
	for(i=0;i<8;i++)                    //LSB first
30032454:	e3a03000 	mov	r3, #0
30032458:	e58d3008 	str	r3, [sp, #8]
3003245c:	ea000067 	b	30032600 <_WrL3Addr+0x1fc>
	{
		if(data & 0x1)                  //If data's LSB is 'H'
30032460:	e5dd3007 	ldrb	r3, [sp, #7]
30032464:	e2033001 	and	r3, r3, #1
30032468:	e20330ff 	and	r3, r3, #255	; 0xff
3003246c:	e3530000 	cmp	r3, #0
30032470:	0a00002e 	beq	30032530 <_WrL3Addr+0x12c>
		{
			rGPBDAT &= ~L3C;            //L3C=L
30032474:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032478:	e2833014 	add	r3, r3, #20
3003247c:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30032480:	e2822014 	add	r2, r2, #20
30032484:	e5922000 	ldr	r2, [r2]
30032488:	e3c22010 	bic	r2, r2, #16
3003248c:	e5832000 	str	r2, [r3]
			rGPBDAT |= L3D;             //L3D=H             
30032490:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032494:	e2833014 	add	r3, r3, #20
30032498:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3003249c:	e2822014 	add	r2, r2, #20
300324a0:	e5922000 	ldr	r2, [r2]
300324a4:	e3822008 	orr	r2, r2, #8
300324a8:	e5832000 	str	r2, [r3]
			for(j=0;j<4;j++);           //tcy(L3) > 500ns
300324ac:	e3a03000 	mov	r3, #0
300324b0:	e58d300c 	str	r3, [sp, #12]
300324b4:	ea000002 	b	300324c4 <_WrL3Addr+0xc0>
300324b8:	e59d300c 	ldr	r3, [sp, #12]
300324bc:	e2833001 	add	r3, r3, #1
300324c0:	e58d300c 	str	r3, [sp, #12]
300324c4:	e59d300c 	ldr	r3, [sp, #12]
300324c8:	e3530003 	cmp	r3, #3
300324cc:	dafffff9 	ble	300324b8 <_WrL3Addr+0xb4>
			rGPBDAT |= L3C;             //L3C=H
300324d0:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300324d4:	e2833014 	add	r3, r3, #20
300324d8:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300324dc:	e2822014 	add	r2, r2, #20
300324e0:	e5922000 	ldr	r2, [r2]
300324e4:	e3822010 	orr	r2, r2, #16
300324e8:	e5832000 	str	r2, [r3]
			rGPBDAT |= L3D;             //L3D=H
300324ec:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300324f0:	e2833014 	add	r3, r3, #20
300324f4:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300324f8:	e2822014 	add	r2, r2, #20
300324fc:	e5922000 	ldr	r2, [r2]
30032500:	e3822008 	orr	r2, r2, #8
30032504:	e5832000 	str	r2, [r3]
			for(j=0;j<4;j++);           //tcy(L3) > 500ns
30032508:	e3a03000 	mov	r3, #0
3003250c:	e58d300c 	str	r3, [sp, #12]
30032510:	ea000002 	b	30032520 <_WrL3Addr+0x11c>
30032514:	e59d300c 	ldr	r3, [sp, #12]
30032518:	e2833001 	add	r3, r3, #1
3003251c:	e58d300c 	str	r3, [sp, #12]
30032520:	e59d300c 	ldr	r3, [sp, #12]
30032524:	e3530003 	cmp	r3, #3
30032528:	dafffff9 	ble	30032514 <_WrL3Addr+0x110>
3003252c:	ea00002d 	b	300325e8 <_WrL3Addr+0x1e4>
        	}
		else                            //If data's LSB is 'L'
		{
			rGPBDAT &= ~L3C;            //L3C=L
30032530:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032534:	e2833014 	add	r3, r3, #20
30032538:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3003253c:	e2822014 	add	r2, r2, #20
30032540:	e5922000 	ldr	r2, [r2]
30032544:	e3c22010 	bic	r2, r2, #16
30032548:	e5832000 	str	r2, [r3]
			rGPBDAT &= ~L3D;            //L3D=L
3003254c:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032550:	e2833014 	add	r3, r3, #20
30032554:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30032558:	e2822014 	add	r2, r2, #20
3003255c:	e5922000 	ldr	r2, [r2]
30032560:	e3c22008 	bic	r2, r2, #8
30032564:	e5832000 	str	r2, [r3]
			for(j=0;j<4;j++);           //tcy(L3) > 500ns
30032568:	e3a03000 	mov	r3, #0
3003256c:	e58d300c 	str	r3, [sp, #12]
30032570:	ea000002 	b	30032580 <_WrL3Addr+0x17c>
30032574:	e59d300c 	ldr	r3, [sp, #12]
30032578:	e2833001 	add	r3, r3, #1
3003257c:	e58d300c 	str	r3, [sp, #12]
30032580:	e59d300c 	ldr	r3, [sp, #12]
30032584:	e3530003 	cmp	r3, #3
30032588:	dafffff9 	ble	30032574 <_WrL3Addr+0x170>
			rGPBDAT |= L3C;             //L3C=H
3003258c:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032590:	e2833014 	add	r3, r3, #20
30032594:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30032598:	e2822014 	add	r2, r2, #20
3003259c:	e5922000 	ldr	r2, [r2]
300325a0:	e3822010 	orr	r2, r2, #16
300325a4:	e5832000 	str	r2, [r3]
			rGPBDAT &= ~L3D;            //L3D=L
300325a8:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300325ac:	e2833014 	add	r3, r3, #20
300325b0:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300325b4:	e2822014 	add	r2, r2, #20
300325b8:	e5922000 	ldr	r2, [r2]
300325bc:	e3c22008 	bic	r2, r2, #8
300325c0:	e5832000 	str	r2, [r3]
			for(j=0;j<4;j++);           //tcy(L3) > 500ns            
300325c4:	e3a03000 	mov	r3, #0
300325c8:	e58d300c 	str	r3, [sp, #12]
300325cc:	ea000002 	b	300325dc <_WrL3Addr+0x1d8>
300325d0:	e59d300c 	ldr	r3, [sp, #12]
300325d4:	e2833001 	add	r3, r3, #1
300325d8:	e58d300c 	str	r3, [sp, #12]
300325dc:	e59d300c 	ldr	r3, [sp, #12]
300325e0:	e3530003 	cmp	r3, #3
300325e4:	dafffff9 	ble	300325d0 <_WrL3Addr+0x1cc>
		}
		data >>= 1;
300325e8:	e5dd3007 	ldrb	r3, [sp, #7]
300325ec:	e1a030a3 	lsr	r3, r3, #1
300325f0:	e5cd3007 	strb	r3, [sp, #7]
	rGPBDAT  = rGPBDAT & ~(L3D | L3M | L3C) | L3C;      //L3D=L, L3M=L(in address mode), L3C=H

	for(j=0;j<4;j++);                   //tsu(L3) > 190ns

      //GPB[4:2]=L3C:L3D:L3M
	for(i=0;i<8;i++)                    //LSB first
300325f4:	e59d3008 	ldr	r3, [sp, #8]
300325f8:	e2833001 	add	r3, r3, #1
300325fc:	e58d3008 	str	r3, [sp, #8]
30032600:	e59d3008 	ldr	r3, [sp, #8]
30032604:	e3530007 	cmp	r3, #7
30032608:	daffff94 	ble	30032460 <_WrL3Addr+0x5c>
			rGPBDAT &= ~L3D;            //L3D=L
			for(j=0;j<4;j++);           //tcy(L3) > 500ns            
		}
		data >>= 1;
	}
	rGPBDAT  = rGPBDAT & ~(L3D | L3M | L3C) | (L3C | L3M);       //L3M=H,L3C=H   
3003260c:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032610:	e2833014 	add	r3, r3, #20
30032614:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30032618:	e2822014 	add	r2, r2, #20
3003261c:	e5922000 	ldr	r2, [r2]
30032620:	e3c2201c 	bic	r2, r2, #28
30032624:	e3822014 	orr	r2, r2, #20
30032628:	e5832000 	str	r2, [r3]
}
3003262c:	e28dd010 	add	sp, sp, #16
30032630:	e12fff1e 	bx	lr

30032634 <_WrL3Data>:

//==========================================================
static void _WrL3Data(acoral_u8 data,int halt)
{
30032634:	e24dd010 	sub	sp, sp, #16
30032638:	e1a03000 	mov	r3, r0
3003263c:	e58d1000 	str	r1, [sp]
30032640:	e5cd3007 	strb	r3, [sp, #7]
	int i,j;

	if(halt)
30032644:	e59d3000 	ldr	r3, [sp]
30032648:	e3530000 	cmp	r3, #0
3003264c:	0a000010 	beq	30032694 <_WrL3Data+0x60>
	{
		rGPBDAT  = rGPBDAT & ~(L3D | L3M | L3C) | L3C;   //L3C=H(while tstp, L3 interface halt condition)        
30032650:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032654:	e2833014 	add	r3, r3, #20
30032658:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3003265c:	e2822014 	add	r2, r2, #20
30032660:	e5922000 	ldr	r2, [r2]
30032664:	e3c2201c 	bic	r2, r2, #28
30032668:	e3822010 	orr	r2, r2, #16
3003266c:	e5832000 	str	r2, [r3]
		for(j=0;j<4;j++);                                //tstp(L3) > 190ns
30032670:	e3a03000 	mov	r3, #0
30032674:	e58d300c 	str	r3, [sp, #12]
30032678:	ea000002 	b	30032688 <_WrL3Data+0x54>
3003267c:	e59d300c 	ldr	r3, [sp, #12]
30032680:	e2833001 	add	r3, r3, #1
30032684:	e58d300c 	str	r3, [sp, #12]
30032688:	e59d300c 	ldr	r3, [sp, #12]
3003268c:	e3530003 	cmp	r3, #3
30032690:	dafffff9 	ble	3003267c <_WrL3Data+0x48>
	}

	rGPBDAT  = rGPBDAT & ~(L3D | L3M | L3C) | (L3C | L3M);   //L3M=H(in data transfer mode)        
30032694:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032698:	e2833014 	add	r3, r3, #20
3003269c:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300326a0:	e2822014 	add	r2, r2, #20
300326a4:	e5922000 	ldr	r2, [r2]
300326a8:	e3c2201c 	bic	r2, r2, #28
300326ac:	e3822014 	orr	r2, r2, #20
300326b0:	e5832000 	str	r2, [r3]
	for(j=0;j<4;j++);                                        //tsu(L3)D > 190ns
300326b4:	e3a03000 	mov	r3, #0
300326b8:	e58d300c 	str	r3, [sp, #12]
300326bc:	ea000002 	b	300326cc <_WrL3Data+0x98>
300326c0:	e59d300c 	ldr	r3, [sp, #12]
300326c4:	e2833001 	add	r3, r3, #1
300326c8:	e58d300c 	str	r3, [sp, #12]
300326cc:	e59d300c 	ldr	r3, [sp, #12]
300326d0:	e3530003 	cmp	r3, #3
300326d4:	dafffff9 	ble	300326c0 <_WrL3Data+0x8c>

	//GPB[4:2]=L3C:L3D:L3M
	for(i=0;i<8;i++)
300326d8:	e3a03000 	mov	r3, #0
300326dc:	e58d3008 	str	r3, [sp, #8]
300326e0:	ea000060 	b	30032868 <_WrL3Data+0x234>
	{
		if(data & 0x1)                   //if data's LSB is 'H'
300326e4:	e5dd3007 	ldrb	r3, [sp, #7]
300326e8:	e2033001 	and	r3, r3, #1
300326ec:	e20330ff 	and	r3, r3, #255	; 0xff
300326f0:	e3530000 	cmp	r3, #0
300326f4:	0a000027 	beq	30032798 <_WrL3Data+0x164>
		{
			rGPBDAT &= ~L3C;              //L3C=L
300326f8:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300326fc:	e2833014 	add	r3, r3, #20
30032700:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30032704:	e2822014 	add	r2, r2, #20
30032708:	e5922000 	ldr	r2, [r2]
3003270c:	e3c22010 	bic	r2, r2, #16
30032710:	e5832000 	str	r2, [r3]
			rGPBDAT |= L3D;               //L3D=H
30032714:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032718:	e2833014 	add	r3, r3, #20
3003271c:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30032720:	e2822014 	add	r2, r2, #20
30032724:	e5922000 	ldr	r2, [r2]
30032728:	e3822008 	orr	r2, r2, #8
3003272c:	e5832000 	str	r2, [r3]
			for(j=0;j<4;j++);             //tcy(L3) > 500ns
30032730:	e3a03000 	mov	r3, #0
30032734:	e58d300c 	str	r3, [sp, #12]
30032738:	ea000002 	b	30032748 <_WrL3Data+0x114>
3003273c:	e59d300c 	ldr	r3, [sp, #12]
30032740:	e2833001 	add	r3, r3, #1
30032744:	e58d300c 	str	r3, [sp, #12]
30032748:	e59d300c 	ldr	r3, [sp, #12]
3003274c:	e3530003 	cmp	r3, #3
30032750:	dafffff9 	ble	3003273c <_WrL3Data+0x108>
			rGPBDAT |= (L3C | L3D);       //L3C=H,L3D=H
30032754:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032758:	e2833014 	add	r3, r3, #20
3003275c:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30032760:	e2822014 	add	r2, r2, #20
30032764:	e5922000 	ldr	r2, [r2]
30032768:	e3822018 	orr	r2, r2, #24
3003276c:	e5832000 	str	r2, [r3]
			for(j=0;j<4;j++);             //tcy(L3) > 500ns
30032770:	e3a03000 	mov	r3, #0
30032774:	e58d300c 	str	r3, [sp, #12]
30032778:	ea000002 	b	30032788 <_WrL3Data+0x154>
3003277c:	e59d300c 	ldr	r3, [sp, #12]
30032780:	e2833001 	add	r3, r3, #1
30032784:	e58d300c 	str	r3, [sp, #12]
30032788:	e59d300c 	ldr	r3, [sp, #12]
3003278c:	e3530003 	cmp	r3, #3
30032790:	dafffff9 	ble	3003277c <_WrL3Data+0x148>
30032794:	ea00002d 	b	30032850 <_WrL3Data+0x21c>
		}
		else                             //If data's LSB is 'L'
		{
			rGPBDAT &= ~L3C;              //L3C=L
30032798:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3003279c:	e2833014 	add	r3, r3, #20
300327a0:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300327a4:	e2822014 	add	r2, r2, #20
300327a8:	e5922000 	ldr	r2, [r2]
300327ac:	e3c22010 	bic	r2, r2, #16
300327b0:	e5832000 	str	r2, [r3]
			rGPBDAT &= ~L3D;              //L3D=L
300327b4:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300327b8:	e2833014 	add	r3, r3, #20
300327bc:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300327c0:	e2822014 	add	r2, r2, #20
300327c4:	e5922000 	ldr	r2, [r2]
300327c8:	e3c22008 	bic	r2, r2, #8
300327cc:	e5832000 	str	r2, [r3]
			for(j=0;j<4;j++);             //tcy(L3) > 500ns
300327d0:	e3a03000 	mov	r3, #0
300327d4:	e58d300c 	str	r3, [sp, #12]
300327d8:	ea000002 	b	300327e8 <_WrL3Data+0x1b4>
300327dc:	e59d300c 	ldr	r3, [sp, #12]
300327e0:	e2833001 	add	r3, r3, #1
300327e4:	e58d300c 	str	r3, [sp, #12]
300327e8:	e59d300c 	ldr	r3, [sp, #12]
300327ec:	e3530003 	cmp	r3, #3
300327f0:	dafffff9 	ble	300327dc <_WrL3Data+0x1a8>
			rGPBDAT |= L3C;               //L3C=H
300327f4:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300327f8:	e2833014 	add	r3, r3, #20
300327fc:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30032800:	e2822014 	add	r2, r2, #20
30032804:	e5922000 	ldr	r2, [r2]
30032808:	e3822010 	orr	r2, r2, #16
3003280c:	e5832000 	str	r2, [r3]
			rGPBDAT &= ~L3D;              //L3D=L
30032810:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032814:	e2833014 	add	r3, r3, #20
30032818:	e3a02456 	mov	r2, #1442840576	; 0x56000000
3003281c:	e2822014 	add	r2, r2, #20
30032820:	e5922000 	ldr	r2, [r2]
30032824:	e3c22008 	bic	r2, r2, #8
30032828:	e5832000 	str	r2, [r3]
			for(j=0;j<4;j++);             //tcy(L3) > 500ns
3003282c:	e3a03000 	mov	r3, #0
30032830:	e58d300c 	str	r3, [sp, #12]
30032834:	ea000002 	b	30032844 <_WrL3Data+0x210>
30032838:	e59d300c 	ldr	r3, [sp, #12]
3003283c:	e2833001 	add	r3, r3, #1
30032840:	e58d300c 	str	r3, [sp, #12]
30032844:	e59d300c 	ldr	r3, [sp, #12]
30032848:	e3530003 	cmp	r3, #3
3003284c:	dafffff9 	ble	30032838 <_WrL3Data+0x204>
		}
		data >>= 1;                      //For check next bit
30032850:	e5dd3007 	ldrb	r3, [sp, #7]
30032854:	e1a030a3 	lsr	r3, r3, #1
30032858:	e5cd3007 	strb	r3, [sp, #7]

	rGPBDAT  = rGPBDAT & ~(L3D | L3M | L3C) | (L3C | L3M);   //L3M=H(in data transfer mode)        
	for(j=0;j<4;j++);                                        //tsu(L3)D > 190ns

	//GPB[4:2]=L3C:L3D:L3M
	for(i=0;i<8;i++)
3003285c:	e59d3008 	ldr	r3, [sp, #8]
30032860:	e2833001 	add	r3, r3, #1
30032864:	e58d3008 	str	r3, [sp, #8]
30032868:	e59d3008 	ldr	r3, [sp, #8]
3003286c:	e3530007 	cmp	r3, #7
30032870:	daffff9b 	ble	300326e4 <_WrL3Data+0xb0>
			rGPBDAT &= ~L3D;              //L3D=L
			for(j=0;j<4;j++);             //tcy(L3) > 500ns
		}
		data >>= 1;                      //For check next bit
	}
    rGPBDAT  = rGPBDAT & ~(L3D | L3M | L3C) | (L3C | L3M);    //L3M=H,L3C=H
30032874:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032878:	e2833014 	add	r3, r3, #20
3003287c:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30032880:	e2822014 	add	r2, r2, #20
30032884:	e5922000 	ldr	r2, [r2]
30032888:	e3c2201c 	bic	r2, r2, #28
3003288c:	e3822014 	orr	r2, r2, #20
30032890:	e5832000 	str	r2, [r3]
}
30032894:	e28dd010 	add	sp, sp, #16
30032898:	e12fff1e 	bx	lr

3003289c <Init1341>:

//==========================================================
static void Init1341(char mode)
{
3003289c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300328a0:	e24dd014 	sub	sp, sp, #20
300328a4:	e1a03000 	mov	r3, r0
300328a8:	e5cd3007 	strb	r3, [sp, #7]
//Signal :  L3CLOCK L3DATA L3MODE
//Setting:   OUTPUT OUTPUT OUTPUT 
//           [9:8]   [7:6}  [5:4]
//Binary :     01  ,   01    01 
//----------------------------------------------------------    
	rGPBDAT = rGPBDAT & ~(L3M|L3C|L3D) |(L3M|L3C); //Start condition : L3M=H, L3C=H
300328ac:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300328b0:	e2833014 	add	r3, r3, #20
300328b4:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300328b8:	e2822014 	add	r2, r2, #20
300328bc:	e5922000 	ldr	r2, [r2]
300328c0:	e3c2201c 	bic	r2, r2, #28
300328c4:	e3822014 	orr	r2, r2, #20
300328c8:	e5832000 	str	r2, [r3]
	rGPBUP  = rGPBUP  & ~(0x7<<2) |(0x7<<2);       //The pull up function is disabled GPB[4:2] 1 1100    
300328cc:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300328d0:	e2833018 	add	r3, r3, #24
300328d4:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300328d8:	e2822018 	add	r2, r2, #24
300328dc:	e5922000 	ldr	r2, [r2]
300328e0:	e382201c 	orr	r2, r2, #28
300328e4:	e5832000 	str	r2, [r3]
	rGPBCON = rGPBCON & ~(0x3f<<4) |(0x15<<4);     //GPB[4:2]=Output(L3CLOCK):Output(L3DATA):Output(L3MODE)
300328e8:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300328ec:	e2833010 	add	r3, r3, #16
300328f0:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300328f4:	e2822010 	add	r2, r2, #16
300328f8:	e5922000 	ldr	r2, [r2]
300328fc:	e3c22e3f 	bic	r2, r2, #1008	; 0x3f0
30032900:	e3822e15 	orr	r2, r2, #336	; 0x150
30032904:	e5832000 	str	r2, [r3]
	
	//L3 Interface
	_WrL3Addr(0x14 + 2);	//STATUS (000101xx+10)
30032908:	e3a00016 	mov	r0, #22
3003290c:	ebfffebc 	bl	30032404 <_WrL3Addr>
	_WrL3Data(0x60,0);		//0,1,10, 000,0 : Status 0,Reset,256fs,IIS-bus,no DC-filtering
30032910:	e3a00060 	mov	r0, #96	; 0x60
30032914:	e3a01000 	mov	r1, #0
30032918:	ebffff45 	bl	30032634 <_WrL3Data>
	
	_WrL3Addr(0x14 + 2);	//STATUS (000101xx+10)
3003291c:	e3a00016 	mov	r0, #22
30032920:	ebfffeb7 	bl	30032404 <_WrL3Addr>
	
	FsIdx = mode?RecStatus.FsIdx:PlayStatus.FsIdx;        
30032924:	e5dd3007 	ldrb	r3, [sp, #7]
30032928:	e3530000 	cmp	r3, #0
3003292c:	0a000002 	beq	3003293c <Init1341+0xa0>
30032930:	e59f3110 	ldr	r3, [pc, #272]	; 30032a48 <Init1341+0x1ac>
30032934:	e5d33014 	ldrb	r3, [r3, #20]
30032938:	ea000001 	b	30032944 <Init1341+0xa8>
3003293c:	e59f3108 	ldr	r3, [pc, #264]	; 30032a4c <Init1341+0x1b0>
30032940:	e5d33014 	ldrb	r3, [r3, #20]
30032944:	e1cd30be 	strh	r3, [sp, #14]
	if(CodecPara[FsIdx].ofs)
30032948:	e1dd20be 	ldrh	r2, [sp, #14]
3003294c:	e59f00fc 	ldr	r0, [pc, #252]	; 30032a50 <Init1341+0x1b4>
30032950:	e3a01008 	mov	r1, #8
30032954:	e1a03002 	mov	r3, r2
30032958:	e1a03083 	lsl	r3, r3, #1
3003295c:	e0833002 	add	r3, r3, r2
30032960:	e1a03103 	lsl	r3, r3, #2
30032964:	e0833000 	add	r3, r3, r0
30032968:	e0833001 	add	r3, r3, r1
3003296c:	e5d33002 	ldrb	r3, [r3, #2]
30032970:	e3530000 	cmp	r3, #0
30032974:	0a000003 	beq	30032988 <Init1341+0xec>
		_WrL3Data(0x18,0);	//0,0,01, 000,0 : Status 0,No reset,384fs,IIS-bus,no DC-filtering
30032978:	e3a00018 	mov	r0, #24
3003297c:	e3a01000 	mov	r1, #0
30032980:	ebffff2b 	bl	30032634 <_WrL3Data>
30032984:	ea000002 	b	30032994 <Init1341+0xf8>
	else
	 _WrL3Data(0x28,0);	//0,0,10, 000,0 : Status 0,No reset,256fs,IIS-bus,no DC-filtering
30032988:	e3a00028 	mov	r0, #40	; 0x28
3003298c:	e3a01000 	mov	r1, #0
30032990:	ebffff27 	bl	30032634 <_WrL3Data>
	
	_WrL3Addr(0x14 + 2);	//STATUS (000101xx+10)
30032994:	e3a00016 	mov	r0, #22
30032998:	ebfffe99 	bl	30032404 <_WrL3Addr>
	_WrL3Data(0xc1,0);		//1,0,0,0, 0,0,01 
3003299c:	e3a000c1 	mov	r0, #193	; 0xc1
300329a0:	e3a01000 	mov	r1, #0
300329a4:	ebffff22 	bl	30032634 <_WrL3Data>
							//Status 1,Gain of DAC 6 dB,Gain of ADC 0dB,ADC non-inverting,DAC non-inverting
							//,Single speed playback,ADC-Off DAC-On
    
	//Record
	if(mode)
300329a8:	e5dd3007 	ldrb	r3, [sp, #7]
300329ac:	e3530000 	cmp	r3, #0
300329b0:	0a000021 	beq	30032a3c <Init1341+0x1a0>
	{
		_WrL3Addr(0x14 + 2);	//STATUS (000101xx+10)
300329b4:	e3a00016 	mov	r0, #22
300329b8:	ebfffe91 	bl	30032404 <_WrL3Addr>
//		_WrL3Data(0xa2,0);		//1,0,1,0, 0,0,10 
								//Status 1,Gain of DAC 0 dB,Gain of ADC 6dB,ADC non-inverting,DAC non-inverting
								//,Single speed playback,ADC-On DAC-Off       

		_WrL3Data(0xe3,0);		//1,1,1,0, 0,0,11 
300329bc:	e3a000e3 	mov	r0, #227	; 0xe3
300329c0:	e3a01000 	mov	r1, #0
300329c4:	ebffff1a 	bl	30032634 <_WrL3Data>

//		_WrL3Addr(0x14 + 0);	//DATA0 (000101xx+00)
//		_WrL3Data(0x3f,0);		//00,11 1111  : Volume control (6 bits)  
//		_WrL3Data(0x00,0);		//00,00 0000  : Volume control (6 bits) 0dB    

		_WrL3Addr(0x14 + 0);	//DATA0 (000101xx+00)
300329c8:	e3a00014 	mov	r0, #20
300329cc:	ebfffe8c 	bl	30032404 <_WrL3Addr>
		_WrL3Data(0x7b,0);		//01,11 10,11 : Data0, Bass Boost 18~24dB, Treble 6dB
300329d0:	e3a0007b 	mov	r0, #123	; 0x7b
300329d4:	e3a01000 	mov	r1, #0
300329d8:	ebffff15 	bl	30032634 <_WrL3Data>
		
//		_WrL3Addr(0x14 + 0);	//DATA0 (000101xx+00)
		_WrL3Data(0xc4,0);		//1100 0,100  : Extended addr(3bits), 100
300329dc:	e3a000c4 	mov	r0, #196	; 0xc4
300329e0:	e3a01000 	mov	r1, #0
300329e4:	ebffff12 	bl	30032634 <_WrL3Data>
//		_WrL3Data(0x90,0);		//100,1 00,00 : DATA0, Enable AGC, 00, input amplifier gain channel 2 (2bits)
		_WrL3Data(0xf0,0);		//111,1 00,00 : DATA0, Enable AGC, 00, input amplifier gain channel 2 (2bits)
300329e8:	e3a000f0 	mov	r0, #240	; 0xf0
300329ec:	e3a01000 	mov	r1, #0
300329f0:	ebffff0f 	bl	30032634 <_WrL3Data>

//		_WrL3Addr(0x14 + 0);	//DATA0 (000101xx+00)
		_WrL3Data(0xc0,0);		//1100 0,000  : Extended addr(3bits), 000		
300329f4:	e3a000c0 	mov	r0, #192	; 0xc0
300329f8:	e3a01000 	mov	r1, #0
300329fc:	ebffff0c 	bl	30032634 <_WrL3Data>
		_WrL3Data(0xe4,0);		//111, 00000  : MA = 0dB
30032a00:	e3a000e4 	mov	r0, #228	; 0xe4
30032a04:	e3a01000 	mov	r1, #0
30032a08:	ebffff09 	bl	30032634 <_WrL3Data>
		_WrL3Data(0xc1,0);		//1100 0,001  : Extended addr(3bits), 001 
30032a0c:	e3a000c1 	mov	r0, #193	; 0xc1
30032a10:	e3a01000 	mov	r1, #0
30032a14:	ebffff06 	bl	30032634 <_WrL3Data>
		_WrL3Data(0xe4,0);		//111, 00000  : MB = 0dB
30032a18:	e3a000e4 	mov	r0, #228	; 0xe4
30032a1c:	e3a01000 	mov	r1, #0
30032a20:	ebffff03 	bl	30032634 <_WrL3Data>
		
//		_WrL3Addr(0x14 + 0);	//DATA0 (000101xx+00)
		_WrL3Data(0xc2,0);		//1100 0,010  : Extended addr(3bits), 010
30032a24:	e3a000c2 	mov	r0, #194	; 0xc2
30032a28:	e3a01000 	mov	r1, #0
30032a2c:	ebffff00 	bl	30032634 <_WrL3Data>
//		_WrL3Data(0x59,0);		//010,1 10,01 : DATA0, MIC Amplifier Gain 27dB, input channel 1 select(input channel 2 off)
		_WrL3Data(0xf9,0);		//111,1 10,11 : DATA0, MIC Amplifier Gain 27dB, input 1 X MA + input 2 X MB
30032a30:	e3a000f9 	mov	r0, #249	; 0xf9
30032a34:	e3a01000 	mov	r1, #0
30032a38:	ebfffefd 	bl	30032634 <_WrL3Data>
	}
}
30032a3c:	e28dd014 	add	sp, sp, #20
30032a40:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30032a44:	e12fff1e 	bx	lr
30032a48:	300e5924 	.word	0x300e5924
30032a4c:	300e5904 	.word	0x300e5904
30032a50:	300c5fa8 	.word	0x300c5fa8

30032a54 <PlayPause>:

//==========================================================
static void PlayPause(acoral_u8 mode)
{
30032a54:	e24dd008 	sub	sp, sp, #8
30032a58:	e1a03000 	mov	r3, r0
30032a5c:	e5cd3007 	strb	r3, [sp, #7]
	if(mode) 
30032a60:	e5dd3007 	ldrb	r3, [sp, #7]
30032a64:	e3530000 	cmp	r3, #0
30032a68:	0a000005 	beq	30032a84 <PlayPause+0x30>
		rIISCON &= ~1;		//stop iis
30032a6c:	e3a03455 	mov	r3, #1426063360	; 0x55000000
30032a70:	e3a02455 	mov	r2, #1426063360	; 0x55000000
30032a74:	e5922000 	ldr	r2, [r2]
30032a78:	e3c22001 	bic	r2, r2, #1
30032a7c:	e5832000 	str	r2, [r3]
30032a80:	ea000004 	b	30032a98 <PlayPause+0x44>
	else
		rIISCON |= 1;		//start iis
30032a84:	e3a03455 	mov	r3, #1426063360	; 0x55000000
30032a88:	e3a02455 	mov	r2, #1426063360	; 0x55000000
30032a8c:	e5922000 	ldr	r2, [r2]
30032a90:	e3822001 	orr	r2, r2, #1
30032a94:	e5832000 	str	r2, [r3]
}
30032a98:	e28dd008 	add	sp, sp, #8
30032a9c:	e12fff1e 	bx	lr

30032aa0 <AdjVolume>:

#define	MAX_VOLUME	61
static void AdjVolume(acoral_u16 volume)
{	
30032aa0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30032aa4:	e24dd00c 	sub	sp, sp, #12
30032aa8:	e1a03000 	mov	r3, r0
30032aac:	e1cd30b6 	strh	r3, [sp, #6]
	rGPBDAT = rGPBDAT & ~(L3M|L3C|L3D) |(L3M|L3C); //Start condition : L3M=H, L3C=H
30032ab0:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032ab4:	e2833014 	add	r3, r3, #20
30032ab8:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30032abc:	e2822014 	add	r2, r2, #20
30032ac0:	e5922000 	ldr	r2, [r2]
30032ac4:	e3c2201c 	bic	r2, r2, #28
30032ac8:	e3822014 	orr	r2, r2, #20
30032acc:	e5832000 	str	r2, [r3]
	rGPBUP  = rGPBUP  & ~(0x7<<2) |(0x7<<2);       //The pull up function is disabled GPB[4:2] 1 1100    
30032ad0:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032ad4:	e2833018 	add	r3, r3, #24
30032ad8:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30032adc:	e2822018 	add	r2, r2, #24
30032ae0:	e5922000 	ldr	r2, [r2]
30032ae4:	e382201c 	orr	r2, r2, #28
30032ae8:	e5832000 	str	r2, [r3]
   	rGPBCON = rGPBCON & ~(0x3f<<4) |(0x15<<4);     //GPB[4:2]=Output(L3CLOCK):Output(L3DATA):Output(L3MODE)
30032aec:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30032af0:	e2833010 	add	r3, r3, #16
30032af4:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30032af8:	e2822010 	add	r2, r2, #16
30032afc:	e5922000 	ldr	r2, [r2]
30032b00:	e3c22e3f 	bic	r2, r2, #1008	; 0x3f0
30032b04:	e3822e15 	orr	r2, r2, #336	; 0x150
30032b08:	e5832000 	str	r2, [r3]
	
	volume = (volume*MAX_VOLUME)/0xffff;		    
30032b0c:	e1dd20b6 	ldrh	r2, [sp, #6]
30032b10:	e1a03002 	mov	r3, r2
30032b14:	e1a03203 	lsl	r3, r3, #4
30032b18:	e0623003 	rsb	r3, r2, r3
30032b1c:	e1a03103 	lsl	r3, r3, #2
30032b20:	e0833002 	add	r3, r3, r2
30032b24:	e3a02902 	mov	r2, #32768	; 0x8000
30032b28:	e2822106 	add	r2, r2, #-2147483647	; 0x80000001
30032b2c:	e0c21293 	smull	r1, r2, r3, r2
30032b30:	e0822003 	add	r2, r2, r3
30032b34:	e1a027c2 	asr	r2, r2, #15
30032b38:	e1a03fc3 	asr	r3, r3, #31
30032b3c:	e0633002 	rsb	r3, r3, r2
30032b40:	e1cd30b6 	strh	r3, [sp, #6]
	    
	_WrL3Addr(0x14 + 0);				//DATA0 (000101xx+00)
30032b44:	e3a00014 	mov	r0, #20
30032b48:	ebfffe2d 	bl	30032404 <_WrL3Addr>
   	_WrL3Data(MAX_VOLUME-volume, 0);
30032b4c:	e1dd30b6 	ldrh	r3, [sp, #6]
30032b50:	e20330ff 	and	r3, r3, #255	; 0xff
30032b54:	e263303d 	rsb	r3, r3, #61	; 0x3d
30032b58:	e20330ff 	and	r3, r3, #255	; 0xff
30032b5c:	e1a00003 	mov	r0, r3
30032b60:	e3a01000 	mov	r1, #0
30032b64:	ebfffeb2 	bl	30032634 <_WrL3Data>
}
30032b68:	e28dd00c 	add	sp, sp, #12
30032b6c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30032b70:	e12fff1e 	bx	lr

30032b74 <PlayMusicTest>:


#define _NONCACHE_STARTADDRESS			0x32000000   //FileInfo

void PlayMusicTest(void)
{
30032b74:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30032b78:	e24dd801 	sub	sp, sp, #65536	; 0x10000
30032b7c:	e24dd054 	sub	sp, sp, #84	; 0x54
	//acoral_u8 mute = 0;
	acoral_u32 volume;
	unsigned char *buf;

	acoral_u32 downloadAddress;
	acoral_u32 downloadFileSize = 0;
30032b80:	e3a03000 	mov	r3, #0
30032b84:	e28d0801 	add	r0, sp, #65536	; 0x10000
30032b88:	e5803044 	str	r3, [r0, #68]	; 0x44

	char fileName[] = "1.wav";
30032b8c:	e3e03801 	mvn	r3, #65536	; 0x10000
30032b90:	e2433047 	sub	r3, r3, #71	; 0x47
30032b94:	e59f2390 	ldr	r2, [pc, #912]	; 30032f2c <PlayMusicTest+0x3b8>
30032b98:	e28d1801 	add	r1, sp, #65536	; 0x10000
30032b9c:	e2811050 	add	r1, r1, #80	; 0x50
30032ba0:	e0813003 	add	r3, r1, r3
30032ba4:	e8920003 	ldm	r2, {r0, r1}
30032ba8:	e5830000 	str	r0, [r3]
30032bac:	e2833004 	add	r3, r3, #4
30032bb0:	e1c310b0 	strh	r1, [r3]
	acoral_32 f = acoral_open(fileName, O_RDWR);
30032bb4:	e28d3050 	add	r3, sp, #80	; 0x50
30032bb8:	e2433048 	sub	r3, r3, #72	; 0x48
30032bbc:	e1a00003 	mov	r0, r3
30032bc0:	e3a01006 	mov	r1, #6
30032bc4:	ebffe144 	bl	3002b0dc <acoral_open>
30032bc8:	e1a03000 	mov	r3, r0
30032bcc:	e28d2801 	add	r2, sp, #65536	; 0x10000
30032bd0:	e5823048 	str	r3, [r2, #72]	; 0x48
	downloadAddress = _NONCACHE_STARTADDRESS;
30032bd4:	e3a03432 	mov	r3, #838860800	; 0x32000000
30032bd8:	e28dc801 	add	ip, sp, #65536	; 0x10000
30032bdc:	e58c3040 	str	r3, [ip, #64]	; 0x40
	buf = (unsigned char *)downloadAddress ;
30032be0:	e28d0801 	add	r0, sp, #65536	; 0x10000
30032be4:	e5903040 	ldr	r3, [r0, #64]	; 0x40
30032be8:	e28d1801 	add	r1, sp, #65536	; 0x10000
30032bec:	e581303c 	str	r3, [r1, #60]	; 0x3c
	//for( i = 0; i < 243552; i++ )  buf[i] = WindowsXP_Wav[i] ;
	i = 0;
30032bf0:	e3a03000 	mov	r3, #0
30032bf4:	e28d2801 	add	r2, sp, #65536	; 0x10000
30032bf8:	e5823030 	str	r3, [r2, #48]	; 0x30
	while(1) {
		downloadFileSize = acoral_read(f, buf+i*1024, 1024);
30032bfc:	e28dc801 	add	ip, sp, #65536	; 0x10000
30032c00:	e59c3030 	ldr	r3, [ip, #48]	; 0x30
30032c04:	e1a03503 	lsl	r3, r3, #10
30032c08:	e1a02003 	mov	r2, r3
30032c0c:	e28d0801 	add	r0, sp, #65536	; 0x10000
30032c10:	e590303c 	ldr	r3, [r0, #60]	; 0x3c
30032c14:	e0823003 	add	r3, r2, r3
30032c18:	e28d1801 	add	r1, sp, #65536	; 0x10000
30032c1c:	e5910048 	ldr	r0, [r1, #72]	; 0x48
30032c20:	e1a01003 	mov	r1, r3
30032c24:	e3a02b01 	mov	r2, #1024	; 0x400
30032c28:	ebffe1a3 	bl	3002b2bc <acoral_read>
30032c2c:	e1a03000 	mov	r3, r0
30032c30:	e28d2801 	add	r2, sp, #65536	; 0x10000
30032c34:	e5823044 	str	r3, [r2, #68]	; 0x44
		if(downloadFileSize == 1024)
30032c38:	e28dc801 	add	ip, sp, #65536	; 0x10000
30032c3c:	e59c3044 	ldr	r3, [ip, #68]	; 0x44
30032c40:	e3530b01 	cmp	r3, #1024	; 0x400
30032c44:	1a000005 	bne	30032c60 <PlayMusicTest+0xec>
			i ++;
30032c48:	e28d0801 	add	r0, sp, #65536	; 0x10000
30032c4c:	e5903030 	ldr	r3, [r0, #48]	; 0x30
30032c50:	e2833001 	add	r3, r3, #1
30032c54:	e28d1801 	add	r1, sp, #65536	; 0x10000
30032c58:	e5813030 	str	r3, [r1, #48]	; 0x30
		else
			break;
	}
30032c5c:	eaffffe6 	b	30032bfc <PlayMusicTest+0x88>
	acoral_close(f);
30032c60:	e28d2801 	add	r2, sp, #65536	; 0x10000
30032c64:	e5920048 	ldr	r0, [r2, #72]	; 0x48
30032c68:	ebffe170 	bl	3002b230 <acoral_close>
	downloadFileSize = downloadFileSize + i*1024 ;
30032c6c:	e28dc801 	add	ip, sp, #65536	; 0x10000
30032c70:	e59c3030 	ldr	r3, [ip, #48]	; 0x30
30032c74:	e1a03503 	lsl	r3, r3, #10
30032c78:	e28d0801 	add	r0, sp, #65536	; 0x10000
30032c7c:	e5902044 	ldr	r2, [r0, #68]	; 0x44
30032c80:	e0823003 	add	r3, r2, r3
30032c84:	e28d1801 	add	r1, sp, #65536	; 0x10000
30032c88:	e5813044 	str	r3, [r1, #68]	; 0x44

	size = *(acoral_u32 *)(downloadAddress+0x28);
30032c8c:	e28d2801 	add	r2, sp, #65536	; 0x10000
30032c90:	e5923040 	ldr	r3, [r2, #64]	; 0x40
30032c94:	e2833028 	add	r3, r3, #40	; 0x28
30032c98:	e5933000 	ldr	r3, [r3]
30032c9c:	e28dc801 	add	ip, sp, #65536	; 0x10000
30032ca0:	e58c302c 	str	r3, [ip, #44]	; 0x2c
	i = 0;							
30032ca4:	e3a03000 	mov	r3, #0
30032ca8:	e28d0801 	add	r0, sp, #65536	; 0x10000
30032cac:	e5803030 	str	r3, [r0, #48]	; 0x30
	
	while(size>0)
30032cb0:	ea00002b 	b	30032d64 <PlayMusicTest+0x1f0>
	{
		hdr[i].lpData = (LPSTR)(downloadAddress+0x2c+i*BUF_SIZE);
30032cb4:	e28d2801 	add	r2, sp, #65536	; 0x10000
30032cb8:	e5921030 	ldr	r1, [r2, #48]	; 0x30
30032cbc:	e28dc801 	add	ip, sp, #65536	; 0x10000
30032cc0:	e59c3030 	ldr	r3, [ip, #48]	; 0x30
30032cc4:	e1a03703 	lsl	r3, r3, #14
30032cc8:	e1a02003 	mov	r2, r3
30032ccc:	e28d0801 	add	r0, sp, #65536	; 0x10000
30032cd0:	e5903040 	ldr	r3, [r0, #64]	; 0x40
30032cd4:	e0823003 	add	r3, r2, r3
30032cd8:	e283302c 	add	r3, r3, #44	; 0x2c
30032cdc:	e1a02003 	mov	r2, r3
30032ce0:	e3e03801 	mvn	r3, #65536	; 0x10000
30032ce4:	e2433037 	sub	r3, r3, #55	; 0x37
30032ce8:	e1a01281 	lsl	r1, r1, #5
30032cec:	e28dc801 	add	ip, sp, #65536	; 0x10000
30032cf0:	e28cc050 	add	ip, ip, #80	; 0x50
30032cf4:	e081100c 	add	r1, r1, ip
30032cf8:	e0813003 	add	r3, r1, r3
30032cfc:	e5832000 	str	r2, [r3]
		hdr[i].dwBufferLength = (size>BUF_SIZE)?BUF_SIZE:size;	
30032d00:	e28d0801 	add	r0, sp, #65536	; 0x10000
30032d04:	e5901030 	ldr	r1, [r0, #48]	; 0x30
30032d08:	e28d2801 	add	r2, sp, #65536	; 0x10000
30032d0c:	e592302c 	ldr	r3, [r2, #44]	; 0x2c
30032d10:	e3530901 	cmp	r3, #16384	; 0x4000
30032d14:	a3a03901 	movge	r3, #16384	; 0x4000
30032d18:	e1a02003 	mov	r2, r3
30032d1c:	e3e03801 	mvn	r3, #65536	; 0x10000
30032d20:	e2433037 	sub	r3, r3, #55	; 0x37
30032d24:	e1a01281 	lsl	r1, r1, #5
30032d28:	e28dc801 	add	ip, sp, #65536	; 0x10000
30032d2c:	e28cc050 	add	ip, ip, #80	; 0x50
30032d30:	e081100c 	add	r1, r1, ip
30032d34:	e0813003 	add	r3, r1, r3
30032d38:	e5832004 	str	r2, [r3, #4]
		size -= BUF_SIZE;
30032d3c:	e28d0801 	add	r0, sp, #65536	; 0x10000
30032d40:	e590302c 	ldr	r3, [r0, #44]	; 0x2c
30032d44:	e2433901 	sub	r3, r3, #16384	; 0x4000
30032d48:	e28d1801 	add	r1, sp, #65536	; 0x10000
30032d4c:	e581302c 	str	r3, [r1, #44]	; 0x2c
		i++;
30032d50:	e28d2801 	add	r2, sp, #65536	; 0x10000
30032d54:	e5923030 	ldr	r3, [r2, #48]	; 0x30
30032d58:	e2833001 	add	r3, r3, #1
30032d5c:	e28dc801 	add	ip, sp, #65536	; 0x10000
30032d60:	e58c3030 	str	r3, [ip, #48]	; 0x30
	downloadFileSize = downloadFileSize + i*1024 ;

	size = *(acoral_u32 *)(downloadAddress+0x28);
	i = 0;							
	
	while(size>0)
30032d64:	e28d0801 	add	r0, sp, #65536	; 0x10000
30032d68:	e590302c 	ldr	r3, [r0, #44]	; 0x2c
30032d6c:	e3530000 	cmp	r3, #0
30032d70:	caffffcf 	bgt	30032cb4 <PlayMusicTest+0x140>
		hdr[i].dwBufferLength = (size>BUF_SIZE)?BUF_SIZE:size;	
		size -= BUF_SIZE;
		i++;
	}
	
	fmt.wFormatTag		= WAVE_FORMAT_PCM;
30032d74:	e3a03001 	mov	r3, #1
30032d78:	e28d1801 	add	r1, sp, #65536	; 0x10000
30032d7c:	e1c131b8 	strh	r3, [r1, #24]
	fmt.nChannels		= *(acoral_u16 *)(downloadAddress+0x16);
30032d80:	e28d2801 	add	r2, sp, #65536	; 0x10000
30032d84:	e5923040 	ldr	r3, [r2, #64]	; 0x40
30032d88:	e2833016 	add	r3, r3, #22
30032d8c:	e1d330b0 	ldrh	r3, [r3]
30032d90:	e28dc801 	add	ip, sp, #65536	; 0x10000
30032d94:	e1cc31ba 	strh	r3, [ip, #26]
	fmt.nSamplesPerSec	= *(acoral_u32 *)(downloadAddress+0x18);
30032d98:	e28d0801 	add	r0, sp, #65536	; 0x10000
30032d9c:	e5903040 	ldr	r3, [r0, #64]	; 0x40
30032da0:	e2833018 	add	r3, r3, #24
30032da4:	e5933000 	ldr	r3, [r3]
30032da8:	e28d1801 	add	r1, sp, #65536	; 0x10000
30032dac:	e581301c 	str	r3, [r1, #28]
	fmt.nAvgBytesPerSec	= *(acoral_u32 *)(downloadAddress+0x1c);
30032db0:	e28d2801 	add	r2, sp, #65536	; 0x10000
30032db4:	e5923040 	ldr	r3, [r2, #64]	; 0x40
30032db8:	e283301c 	add	r3, r3, #28
30032dbc:	e5933000 	ldr	r3, [r3]
30032dc0:	e28dc801 	add	ip, sp, #65536	; 0x10000
30032dc4:	e58c3020 	str	r3, [ip, #32]
	fmt.nBlockAlign		= *(acoral_u16 *)(downloadAddress+0x20);
30032dc8:	e28d0801 	add	r0, sp, #65536	; 0x10000
30032dcc:	e5903040 	ldr	r3, [r0, #64]	; 0x40
30032dd0:	e2833020 	add	r3, r3, #32
30032dd4:	e1d330b0 	ldrh	r3, [r3]
30032dd8:	e28d1801 	add	r1, sp, #65536	; 0x10000
30032ddc:	e1c132b4 	strh	r3, [r1, #36]	; 0x24
	fmt.wBitsPerSample	= *(acoral_u16 *)(downloadAddress+0x22);
30032de0:	e28d2801 	add	r2, sp, #65536	; 0x10000
30032de4:	e5923040 	ldr	r3, [r2, #64]	; 0x40
30032de8:	e2833022 	add	r3, r3, #34	; 0x22
30032dec:	e1d330b0 	ldrh	r3, [r3]
30032df0:	e28dc801 	add	ip, sp, #65536	; 0x10000
30032df4:	e1cc32b6 	strh	r3, [ip, #38]	; 0x26
	acoral_print("\nSample Rate = %d, Channels = %d, %dBitsPerSample, size = %d\n",
30032df8:	e28d0801 	add	r0, sp, #65536	; 0x10000
30032dfc:	e590101c 	ldr	r1, [r0, #28]
			fmt.nSamplesPerSec, fmt.nChannels, fmt.wBitsPerSample, *(acoral_u32 *)(downloadAddress+0x28));
30032e00:	e28d2801 	add	r2, sp, #65536	; 0x10000
30032e04:	e1d231ba 	ldrh	r3, [r2, #26]
	fmt.nChannels		= *(acoral_u16 *)(downloadAddress+0x16);
	fmt.nSamplesPerSec	= *(acoral_u32 *)(downloadAddress+0x18);
	fmt.nAvgBytesPerSec	= *(acoral_u32 *)(downloadAddress+0x1c);
	fmt.nBlockAlign		= *(acoral_u16 *)(downloadAddress+0x20);
	fmt.wBitsPerSample	= *(acoral_u16 *)(downloadAddress+0x22);
	acoral_print("\nSample Rate = %d, Channels = %d, %dBitsPerSample, size = %d\n",
30032e08:	e1a02003 	mov	r2, r3
			fmt.nSamplesPerSec, fmt.nChannels, fmt.wBitsPerSample, *(acoral_u32 *)(downloadAddress+0x28));
30032e0c:	e28dc801 	add	ip, sp, #65536	; 0x10000
30032e10:	e1dc32b6 	ldrh	r3, [ip, #38]	; 0x26
30032e14:	e28dc801 	add	ip, sp, #65536	; 0x10000
30032e18:	e59c0040 	ldr	r0, [ip, #64]	; 0x40
30032e1c:	e2800028 	add	r0, r0, #40	; 0x28
	fmt.nChannels		= *(acoral_u16 *)(downloadAddress+0x16);
	fmt.nSamplesPerSec	= *(acoral_u32 *)(downloadAddress+0x18);
	fmt.nAvgBytesPerSec	= *(acoral_u32 *)(downloadAddress+0x1c);
	fmt.nBlockAlign		= *(acoral_u16 *)(downloadAddress+0x20);
	fmt.wBitsPerSample	= *(acoral_u16 *)(downloadAddress+0x22);
	acoral_print("\nSample Rate = %d, Channels = %d, %dBitsPerSample, size = %d\n",
30032e20:	e5900000 	ldr	r0, [r0]
30032e24:	e58d0000 	str	r0, [sp]
30032e28:	e59f0100 	ldr	r0, [pc, #256]	; 30032f30 <PlayMusicTest+0x3bc>
30032e2c:	ebff6103 	bl	3000b240 <acoral_print>
			fmt.nSamplesPerSec, fmt.nChannels, fmt.wBitsPerSample, *(acoral_u32 *)(downloadAddress+0x28));
	
	hwo = 0;
30032e30:	e3e03801 	mvn	r3, #65536	; 0x10000
30032e34:	e243303b 	sub	r3, r3, #59	; 0x3b
30032e38:	e3a02000 	mov	r2, #0
30032e3c:	e28d0801 	add	r0, sp, #65536	; 0x10000
30032e40:	e2800050 	add	r0, r0, #80	; 0x50
30032e44:	e7802003 	str	r2, [r0, r3]
	err = waveOutOpen(&hwo,
30032e48:	e28d3050 	add	r3, sp, #80	; 0x50
30032e4c:	e243303c 	sub	r3, r3, #60	; 0x3c
30032e50:	e28d2801 	add	r2, sp, #65536	; 0x10000
30032e54:	e2822018 	add	r2, r2, #24
30032e58:	e3a01000 	mov	r1, #0
30032e5c:	e58d1000 	str	r1, [sp]
30032e60:	e3a01000 	mov	r1, #0
30032e64:	e58d1004 	str	r1, [sp, #4]
30032e68:	e1a00003 	mov	r0, r3
30032e6c:	e3a01000 	mov	r1, #0
30032e70:	e3a03000 	mov	r3, #0
30032e74:	ebfff874 	bl	3003104c <waveOutOpen>
30032e78:	e1a03000 	mov	r3, r0
30032e7c:	e28d1801 	add	r1, sp, #65536	; 0x10000
30032e80:	e5813038 	str	r3, [r1, #56]	; 0x38
				0,
				&fmt,
				0,
				0,
				0);
	acoral_print("\nerr = %x\n", err);
30032e84:	e59f00a8 	ldr	r0, [pc, #168]	; 30032f34 <PlayMusicTest+0x3c0>
30032e88:	e28d2801 	add	r2, sp, #65536	; 0x10000
30032e8c:	e5921038 	ldr	r1, [r2, #56]	; 0x38
30032e90:	ebff60ea 	bl	3000b240 <acoral_print>
	for(j=0;j<i;j++)
30032e94:	e3a03000 	mov	r3, #0
30032e98:	e28dc801 	add	ip, sp, #65536	; 0x10000
30032e9c:	e58c3034 	str	r3, [ip, #52]	; 0x34
30032ea0:	ea00000e 	b	30032ee0 <PlayMusicTest+0x36c>
		waveOutWrite(0,	&hdr[j], 0);
30032ea4:	e28d0801 	add	r0, sp, #65536	; 0x10000
30032ea8:	e5903034 	ldr	r3, [r0, #52]	; 0x34
30032eac:	e1a02283 	lsl	r2, r3, #5
30032eb0:	e28d3050 	add	r3, sp, #80	; 0x50
30032eb4:	e2433038 	sub	r3, r3, #56	; 0x38
30032eb8:	e0833002 	add	r3, r3, r2
30032ebc:	e3a00000 	mov	r0, #0
30032ec0:	e1a01003 	mov	r1, r3
30032ec4:	e3a02000 	mov	r2, #0
30032ec8:	ebfff990 	bl	30031510 <waveOutWrite>
				&fmt,
				0,
				0,
				0);
	acoral_print("\nerr = %x\n", err);
	for(j=0;j<i;j++)
30032ecc:	e28d1801 	add	r1, sp, #65536	; 0x10000
30032ed0:	e5913034 	ldr	r3, [r1, #52]	; 0x34
30032ed4:	e2833001 	add	r3, r3, #1
30032ed8:	e28d2801 	add	r2, sp, #65536	; 0x10000
30032edc:	e5823034 	str	r3, [r2, #52]	; 0x34
30032ee0:	e28d3801 	add	r3, sp, #65536	; 0x10000
30032ee4:	e5932034 	ldr	r2, [r3, #52]	; 0x34
30032ee8:	e28dc801 	add	ip, sp, #65536	; 0x10000
30032eec:	e59c3030 	ldr	r3, [ip, #48]	; 0x30
30032ef0:	e1520003 	cmp	r2, r3
30032ef4:	baffffea 	blt	30032ea4 <PlayMusicTest+0x330>
		waveOutWrite(0,	&hdr[j], 0);
		
	acoral_print("Now playing the file\n");
30032ef8:	e59f0038 	ldr	r0, [pc, #56]	; 30032f38 <PlayMusicTest+0x3c4>
30032efc:	ebff60cf 	bl	3000b240 <acoral_print>
	acoral_print("Press 'ESC' to quit, '+' to inc volume, '-' to dec volume, 'm' to mute, 'p' to pause\n");
30032f00:	e59f0034 	ldr	r0, [pc, #52]	; 30032f3c <PlayMusicTest+0x3c8>
30032f04:	ebff60cd 	bl	3000b240 <acoral_print>
	
	waveOutGetVolume(0,	&volume);
30032f08:	e28d3050 	add	r3, sp, #80	; 0x50
30032f0c:	e2433040 	sub	r3, r3, #64	; 0x40
30032f10:	e3a00000 	mov	r0, #0
30032f14:	e1a01003 	mov	r1, r3
30032f18:	ebfff9d1 	bl	30031664 <waveOutGetVolume>

	int a = 1;
30032f1c:	e3a03001 	mov	r3, #1
30032f20:	e28d0801 	add	r0, sp, #65536	; 0x10000
30032f24:	e580304c 	str	r3, [r0, #76]	; 0x4c
		/*if(a) {
			a = 0;
			acoral_print("start playing the wav~\n");
			waveOutRestart(0);
		}*/
	}
30032f28:	eafffffe 	b	30032f28 <PlayMusicTest+0x3b4>
30032f2c:	30046044 	.word	0x30046044
30032f30:	30045f88 	.word	0x30045f88
30032f34:	30045fc8 	.word	0x30045fc8
30032f38:	30045fd4 	.word	0x30045fd4
30032f3c:	30045fec 	.word	0x30045fec

30032f40 <mp3_pcm_player>:
#include "../include/global.h"
#include "../include/AudioDrv.h"

WAVEHDR hdr[pcm_dma_buf_size];
WAVEFORMATEX fmt;
void mp3_pcm_player(void) {
30032f40:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30032f44:	e24dd024 	sub	sp, sp, #36	; 0x24

	int i, tmp_count;

	HWAVEOUT hwo;
	acoral_u32 volume;
	int cur = 0;
30032f48:	e3a03000 	mov	r3, #0
30032f4c:	e58d301c 	str	r3, [sp, #28]

	fmt.wFormatTag = WAVE_FORMAT_PCM;
30032f50:	e59f32b0 	ldr	r3, [pc, #688]	; 30033208 <mp3_pcm_player+0x2c8>
30032f54:	e3a02001 	mov	r2, #1
30032f58:	e1c320b0 	strh	r2, [r3]
    fmt.nChannels		= 2;
30032f5c:	e59f32a4 	ldr	r3, [pc, #676]	; 30033208 <mp3_pcm_player+0x2c8>
30032f60:	e3a02002 	mov	r2, #2
30032f64:	e1c320b2 	strh	r2, [r3, #2]
	fmt.nSamplesPerSec	= mp3_freq;
30032f68:	e59f329c 	ldr	r3, [pc, #668]	; 3003320c <mp3_pcm_player+0x2cc>
30032f6c:	e5933000 	ldr	r3, [r3]
30032f70:	e1a02003 	mov	r2, r3
30032f74:	e59f328c 	ldr	r3, [pc, #652]	; 30033208 <mp3_pcm_player+0x2c8>
30032f78:	e5832004 	str	r2, [r3, #4]
	fmt.nAvgBytesPerSec	= mp3_freq*4;
30032f7c:	e59f3288 	ldr	r3, [pc, #648]	; 3003320c <mp3_pcm_player+0x2cc>
30032f80:	e5933000 	ldr	r3, [r3]
30032f84:	e1a03103 	lsl	r3, r3, #2
30032f88:	e1a02003 	mov	r2, r3
30032f8c:	e59f3274 	ldr	r3, [pc, #628]	; 30033208 <mp3_pcm_player+0x2c8>
30032f90:	e5832008 	str	r2, [r3, #8]
	fmt.nBlockAlign		= 4;
30032f94:	e59f326c 	ldr	r3, [pc, #620]	; 30033208 <mp3_pcm_player+0x2c8>
30032f98:	e3a02004 	mov	r2, #4
30032f9c:	e1c320bc 	strh	r2, [r3, #12]
	fmt.wBitsPerSample	= 16;
30032fa0:	e59f3260 	ldr	r3, [pc, #608]	; 30033208 <mp3_pcm_player+0x2c8>
30032fa4:	e3a02010 	mov	r2, #16
30032fa8:	e1c320be 	strh	r2, [r3, #14]
	acoral_print("\nSample Rate = %d, Channels = %d, %dBitsPerSample, size = %d\n",
30032fac:	e59f3254 	ldr	r3, [pc, #596]	; 30033208 <mp3_pcm_player+0x2c8>
30032fb0:	e5931004 	ldr	r1, [r3, #4]
	fmt.nSamplesPerSec, fmt.nChannels, fmt.wBitsPerSample, fmt.nChannels);
30032fb4:	e59f324c 	ldr	r3, [pc, #588]	; 30033208 <mp3_pcm_player+0x2c8>
30032fb8:	e1d330b2 	ldrh	r3, [r3, #2]
    fmt.nChannels		= 2;
	fmt.nSamplesPerSec	= mp3_freq;
	fmt.nAvgBytesPerSec	= mp3_freq*4;
	fmt.nBlockAlign		= 4;
	fmt.wBitsPerSample	= 16;
	acoral_print("\nSample Rate = %d, Channels = %d, %dBitsPerSample, size = %d\n",
30032fbc:	e1a02003 	mov	r2, r3
	fmt.nSamplesPerSec, fmt.nChannels, fmt.wBitsPerSample, fmt.nChannels);
30032fc0:	e59f3240 	ldr	r3, [pc, #576]	; 30033208 <mp3_pcm_player+0x2c8>
30032fc4:	e1d330be 	ldrh	r3, [r3, #14]
30032fc8:	e59f0238 	ldr	r0, [pc, #568]	; 30033208 <mp3_pcm_player+0x2c8>
30032fcc:	e1d000b2 	ldrh	r0, [r0, #2]
    fmt.nChannels		= 2;
	fmt.nSamplesPerSec	= mp3_freq;
	fmt.nAvgBytesPerSec	= mp3_freq*4;
	fmt.nBlockAlign		= 4;
	fmt.wBitsPerSample	= 16;
	acoral_print("\nSample Rate = %d, Channels = %d, %dBitsPerSample, size = %d\n",
30032fd0:	e58d0000 	str	r0, [sp]
30032fd4:	e59f0234 	ldr	r0, [pc, #564]	; 30033210 <mp3_pcm_player+0x2d0>
30032fd8:	ebff6098 	bl	3000b240 <acoral_print>
	fmt.nSamplesPerSec, fmt.nChannels, fmt.wBitsPerSample, fmt.nChannels);
	hwo = 0;
30032fdc:	e3a03000 	mov	r3, #0
30032fe0:	e58d300c 	str	r3, [sp, #12]
	waveOutOpen(&hwo, 0,&fmt,0,0,0);
30032fe4:	e28d300c 	add	r3, sp, #12
30032fe8:	e3a02000 	mov	r2, #0
30032fec:	e58d2000 	str	r2, [sp]
30032ff0:	e3a02000 	mov	r2, #0
30032ff4:	e58d2004 	str	r2, [sp, #4]
30032ff8:	e1a00003 	mov	r0, r3
30032ffc:	e3a01000 	mov	r1, #0
30033000:	e59f2200 	ldr	r2, [pc, #512]	; 30033208 <mp3_pcm_player+0x2c8>
30033004:	e3a03000 	mov	r3, #0
30033008:	ebfff80f 	bl	3003104c <waveOutOpen>
	volume = 50000;
3003300c:	e3a03cc3 	mov	r3, #49920	; 0xc300
30033010:	e2833050 	add	r3, r3, #80	; 0x50
30033014:	e58d3018 	str	r3, [sp, #24]
	waveOutSetVolume(0, volume);
30033018:	e3a00000 	mov	r0, #0
3003301c:	e59d1018 	ldr	r1, [sp, #24]
30033020:	ebfff970 	bl	300315e8 <waveOutSetVolume>
30033024:	ea000000 	b	3003302c <mp3_pcm_player+0xec>
		hdr[cur].update = 0;

		cur ++;
		if(cur == pcm_dma_buf_size)
			cur = 0;
	}
30033028:	e1a00000 	nop			; (mov r0, r0)
		acoral_sem_init(pcm_dma_buf_update_eve+i, 0);
		acoral_sem_init(pcm_dma_buf_playdone_eve+i, 0);
	}*/

	while(1) {
		if(hdr[cur].update == 0)
3003302c:	e59d201c 	ldr	r2, [sp, #28]
30033030:	e59f01dc 	ldr	r0, [pc, #476]	; 30033214 <mp3_pcm_player+0x2d4>
30033034:	e3a01028 	mov	r1, #40	; 0x28
30033038:	e1a03002 	mov	r3, r2
3003303c:	e1a03103 	lsl	r3, r3, #2
30033040:	e0833002 	add	r3, r3, r2
30033044:	e1a03083 	lsl	r3, r3, #1
30033048:	e0833002 	add	r3, r3, r2
3003304c:	e1a03103 	lsl	r3, r3, #2
30033050:	e0833000 	add	r3, r3, r0
30033054:	e0833001 	add	r3, r3, r1
30033058:	e5933000 	ldr	r3, [r3]
3003305c:	e3530000 	cmp	r3, #0
30033060:	1a00000a 	bne	30033090 <mp3_pcm_player+0x150>
			acoral_sem_pend(pcm_dma_buf_update_eve+cur, 0);
30033064:	e59d201c 	ldr	r2, [sp, #28]
30033068:	e1a03002 	mov	r3, r2
3003306c:	e1a03183 	lsl	r3, r3, #3
30033070:	e0833002 	add	r3, r3, r2
30033074:	e1a03103 	lsl	r3, r3, #2
30033078:	e1a02003 	mov	r2, r3
3003307c:	e59f3194 	ldr	r3, [pc, #404]	; 30033218 <mp3_pcm_player+0x2d8>
30033080:	e0823003 	add	r3, r2, r3
30033084:	e1a00003 	mov	r0, r3
30033088:	e3a01000 	mov	r1, #0
3003308c:	ebff518b 	bl	300076c0 <acoral_sem_pend>
		hdr[cur].lpData = (LPSTR)(pcm_dma_buf+cur*2*10);
30033090:	e59d201c 	ldr	r2, [sp, #28]
30033094:	e59f0180 	ldr	r0, [pc, #384]	; 3003321c <mp3_pcm_player+0x2dc>
30033098:	e59d101c 	ldr	r1, [sp, #28]
3003309c:	e1a03001 	mov	r3, r1
300330a0:	e1a03083 	lsl	r3, r3, #1
300330a4:	e0833001 	add	r3, r3, r1
300330a8:	e1a01203 	lsl	r1, r3, #4
300330ac:	e0631001 	rsb	r1, r3, r1
300330b0:	e1a03481 	lsl	r3, r1, #9
300330b4:	e0801003 	add	r1, r0, r3
300330b8:	e59f0154 	ldr	r0, [pc, #340]	; 30033214 <mp3_pcm_player+0x2d4>
300330bc:	e1a03002 	mov	r3, r2
300330c0:	e1a03103 	lsl	r3, r3, #2
300330c4:	e0833002 	add	r3, r3, r2
300330c8:	e1a03083 	lsl	r3, r3, #1
300330cc:	e0833002 	add	r3, r3, r2
300330d0:	e1a03103 	lsl	r3, r3, #2
300330d4:	e0833000 	add	r3, r3, r0
300330d8:	e5831000 	str	r1, [r3]
		hdr[cur].dwBufferLength = 2*18*32*2*10;
300330dc:	e59d201c 	ldr	r2, [sp, #28]
300330e0:	e59f012c 	ldr	r0, [pc, #300]	; 30033214 <mp3_pcm_player+0x2d4>
300330e4:	e3a01004 	mov	r1, #4
300330e8:	e1a03002 	mov	r3, r2
300330ec:	e1a03103 	lsl	r3, r3, #2
300330f0:	e0833002 	add	r3, r3, r2
300330f4:	e1a03083 	lsl	r3, r3, #1
300330f8:	e0833002 	add	r3, r3, r2
300330fc:	e1a03103 	lsl	r3, r3, #2
30033100:	e0833000 	add	r3, r3, r0
30033104:	e0833001 	add	r3, r3, r1
30033108:	e3a02c5a 	mov	r2, #23040	; 0x5a00
3003310c:	e5832000 	str	r2, [r3]
		hdr[cur].pcm_dma_buf_cur = cur;
30033110:	e59d201c 	ldr	r2, [sp, #28]
30033114:	e59f00f8 	ldr	r0, [pc, #248]	; 30033214 <mp3_pcm_player+0x2d4>
30033118:	e3a01020 	mov	r1, #32
3003311c:	e1a03002 	mov	r3, r2
30033120:	e1a03103 	lsl	r3, r3, #2
30033124:	e0833002 	add	r3, r3, r2
30033128:	e1a03083 	lsl	r3, r3, #1
3003312c:	e0833002 	add	r3, r3, r2
30033130:	e1a03103 	lsl	r3, r3, #2
30033134:	e0833000 	add	r3, r3, r0
30033138:	e0833001 	add	r3, r3, r1
3003313c:	e59d201c 	ldr	r2, [sp, #28]
30033140:	e5832000 	str	r2, [r3]
		hdr[cur].used = 1;
30033144:	e59d201c 	ldr	r2, [sp, #28]
30033148:	e59f00c4 	ldr	r0, [pc, #196]	; 30033214 <mp3_pcm_player+0x2d4>
3003314c:	e3a01024 	mov	r1, #36	; 0x24
30033150:	e1a03002 	mov	r3, r2
30033154:	e1a03103 	lsl	r3, r3, #2
30033158:	e0833002 	add	r3, r3, r2
3003315c:	e1a03083 	lsl	r3, r3, #1
30033160:	e0833002 	add	r3, r3, r2
30033164:	e1a03103 	lsl	r3, r3, #2
30033168:	e0833000 	add	r3, r3, r0
3003316c:	e0833001 	add	r3, r3, r1
30033170:	e3a02001 	mov	r2, #1
30033174:	e5832000 	str	r2, [r3]
		waveOutWrite(0,&hdr[cur], 0);
30033178:	e59d201c 	ldr	r2, [sp, #28]
3003317c:	e1a03002 	mov	r3, r2
30033180:	e1a03103 	lsl	r3, r3, #2
30033184:	e0833002 	add	r3, r3, r2
30033188:	e1a03083 	lsl	r3, r3, #1
3003318c:	e0833002 	add	r3, r3, r2
30033190:	e1a03103 	lsl	r3, r3, #2
30033194:	e1a02003 	mov	r2, r3
30033198:	e59f3074 	ldr	r3, [pc, #116]	; 30033214 <mp3_pcm_player+0x2d4>
3003319c:	e0823003 	add	r3, r2, r3
300331a0:	e3a00000 	mov	r0, #0
300331a4:	e1a01003 	mov	r1, r3
300331a8:	e3a02000 	mov	r2, #0
300331ac:	ebfff8d7 	bl	30031510 <waveOutWrite>
		hdr[cur].update = 0;
300331b0:	e59d201c 	ldr	r2, [sp, #28]
300331b4:	e59f0058 	ldr	r0, [pc, #88]	; 30033214 <mp3_pcm_player+0x2d4>
300331b8:	e3a01028 	mov	r1, #40	; 0x28
300331bc:	e1a03002 	mov	r3, r2
300331c0:	e1a03103 	lsl	r3, r3, #2
300331c4:	e0833002 	add	r3, r3, r2
300331c8:	e1a03083 	lsl	r3, r3, #1
300331cc:	e0833002 	add	r3, r3, r2
300331d0:	e1a03103 	lsl	r3, r3, #2
300331d4:	e0833000 	add	r3, r3, r0
300331d8:	e0833001 	add	r3, r3, r1
300331dc:	e3a02000 	mov	r2, #0
300331e0:	e5832000 	str	r2, [r3]

		cur ++;
300331e4:	e59d301c 	ldr	r3, [sp, #28]
300331e8:	e2833001 	add	r3, r3, #1
300331ec:	e58d301c 	str	r3, [sp, #28]
		if(cur == pcm_dma_buf_size)
300331f0:	e59d301c 	ldr	r3, [sp, #28]
300331f4:	e353000a 	cmp	r3, #10
300331f8:	1affff8a 	bne	30033028 <mp3_pcm_player+0xe8>
			cur = 0;
300331fc:	e3a03000 	mov	r3, #0
30033200:	e58d301c 	str	r3, [sp, #28]
	}
30033204:	eaffff88 	b	3003302c <mp3_pcm_player+0xec>
30033208:	302be50c 	.word	0x302be50c
3003320c:	300c9a94 	.word	0x300c9a94
30033210:	3004604c 	.word	0x3004604c
30033214:	302bf84c 	.word	0x302bf84c
30033218:	302be6b0 	.word	0x302be6b0
3003321c:	302bfa04 	.word	0x302bfa04

30033220 <file_pcm_player>:
	}

}


void file_pcm_player(void) {
30033220:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30033224:	e24dd024 	sub	sp, sp, #36	; 0x24
	int i, tmp_count;


	HWAVEOUT hwo;
	acoral_u32 volume;
	int cur = 0;
30033228:	e3a03000 	mov	r3, #0
3003322c:	e58d301c 	str	r3, [sp, #28]

	hwo = 0;
30033230:	e3a03000 	mov	r3, #0
30033234:	e58d300c 	str	r3, [sp, #12]
	waveOutOpen(&hwo, 0,&fmt,0,0,0);
30033238:	e28d300c 	add	r3, sp, #12
3003323c:	e3a02000 	mov	r2, #0
30033240:	e58d2000 	str	r2, [sp]
30033244:	e3a02000 	mov	r2, #0
30033248:	e58d2004 	str	r2, [sp, #4]
3003324c:	e1a00003 	mov	r0, r3
30033250:	e3a01000 	mov	r1, #0
30033254:	e59f21f8 	ldr	r2, [pc, #504]	; 30033454 <file_pcm_player+0x234>
30033258:	e3a03000 	mov	r3, #0
3003325c:	ebfff77a 	bl	3003104c <waveOutOpen>
	//waveOutGetVolume(0,	&volume);
	volume = 50000;
30033260:	e3a03cc3 	mov	r3, #49920	; 0xc300
30033264:	e2833050 	add	r3, r3, #80	; 0x50
30033268:	e58d3018 	str	r3, [sp, #24]
	waveOutSetVolume(0, volume);
3003326c:	e3a00000 	mov	r0, #0
30033270:	e59d1018 	ldr	r1, [sp, #24]
30033274:	ebfff8db 	bl	300315e8 <waveOutSetVolume>
30033278:	ea000000 	b	30033280 <file_pcm_player+0x60>

		}*/
		cur ++;
		if(cur == pcm_dma_buf_size)
			cur = 0;
	}
3003327c:	e1a00000 	nop			; (mov r0, r0)
	volume = 50000;
	waveOutSetVolume(0, volume);

	while(1) {

		if(hdr[cur].update == 0)
30033280:	e59d201c 	ldr	r2, [sp, #28]
30033284:	e59f01cc 	ldr	r0, [pc, #460]	; 30033458 <file_pcm_player+0x238>
30033288:	e3a01028 	mov	r1, #40	; 0x28
3003328c:	e1a03002 	mov	r3, r2
30033290:	e1a03103 	lsl	r3, r3, #2
30033294:	e0833002 	add	r3, r3, r2
30033298:	e1a03083 	lsl	r3, r3, #1
3003329c:	e0833002 	add	r3, r3, r2
300332a0:	e1a03103 	lsl	r3, r3, #2
300332a4:	e0833000 	add	r3, r3, r0
300332a8:	e0833001 	add	r3, r3, r1
300332ac:	e5933000 	ldr	r3, [r3]
300332b0:	e3530000 	cmp	r3, #0
300332b4:	1a00000a 	bne	300332e4 <file_pcm_player+0xc4>
			acoral_sem_pend(pcm_dma_buf_update_eve+cur, 0);
300332b8:	e59d201c 	ldr	r2, [sp, #28]
300332bc:	e1a03002 	mov	r3, r2
300332c0:	e1a03183 	lsl	r3, r3, #3
300332c4:	e0833002 	add	r3, r3, r2
300332c8:	e1a03103 	lsl	r3, r3, #2
300332cc:	e1a02003 	mov	r2, r3
300332d0:	e59f3184 	ldr	r3, [pc, #388]	; 3003345c <file_pcm_player+0x23c>
300332d4:	e0823003 	add	r3, r2, r3
300332d8:	e1a00003 	mov	r0, r3
300332dc:	e3a01000 	mov	r1, #0
300332e0:	ebff50f6 	bl	300076c0 <acoral_sem_pend>
		hdr[cur].lpData = (LPSTR)(file_wav_buf+cur);
300332e4:	e59d201c 	ldr	r2, [sp, #28]
300332e8:	e59f0170 	ldr	r0, [pc, #368]	; 30033460 <file_pcm_player+0x240>
300332ec:	e59d101c 	ldr	r1, [sp, #28]
300332f0:	e1a03001 	mov	r3, r1
300332f4:	e1a03103 	lsl	r3, r3, #2
300332f8:	e0833001 	add	r3, r3, r1
300332fc:	e1a03703 	lsl	r3, r3, #14
30033300:	e0801003 	add	r1, r0, r3
30033304:	e59f014c 	ldr	r0, [pc, #332]	; 30033458 <file_pcm_player+0x238>
30033308:	e1a03002 	mov	r3, r2
3003330c:	e1a03103 	lsl	r3, r3, #2
30033310:	e0833002 	add	r3, r3, r2
30033314:	e1a03083 	lsl	r3, r3, #1
30033318:	e0833002 	add	r3, r3, r2
3003331c:	e1a03103 	lsl	r3, r3, #2
30033320:	e0833000 	add	r3, r3, r0
30033324:	e5831000 	str	r1, [r3]
		hdr[cur].dwBufferLength = file_buf_block_size;
30033328:	e59d201c 	ldr	r2, [sp, #28]
3003332c:	e59f0124 	ldr	r0, [pc, #292]	; 30033458 <file_pcm_player+0x238>
30033330:	e3a01004 	mov	r1, #4
30033334:	e1a03002 	mov	r3, r2
30033338:	e1a03103 	lsl	r3, r3, #2
3003333c:	e0833002 	add	r3, r3, r2
30033340:	e1a03083 	lsl	r3, r3, #1
30033344:	e0833002 	add	r3, r3, r2
30033348:	e1a03103 	lsl	r3, r3, #2
3003334c:	e0833000 	add	r3, r3, r0
30033350:	e0833001 	add	r3, r3, r1
30033354:	e3a02905 	mov	r2, #81920	; 0x14000
30033358:	e5832000 	str	r2, [r3]
		hdr[cur].pcm_dma_buf_cur = cur;
3003335c:	e59d201c 	ldr	r2, [sp, #28]
30033360:	e59f00f0 	ldr	r0, [pc, #240]	; 30033458 <file_pcm_player+0x238>
30033364:	e3a01020 	mov	r1, #32
30033368:	e1a03002 	mov	r3, r2
3003336c:	e1a03103 	lsl	r3, r3, #2
30033370:	e0833002 	add	r3, r3, r2
30033374:	e1a03083 	lsl	r3, r3, #1
30033378:	e0833002 	add	r3, r3, r2
3003337c:	e1a03103 	lsl	r3, r3, #2
30033380:	e0833000 	add	r3, r3, r0
30033384:	e0833001 	add	r3, r3, r1
30033388:	e59d201c 	ldr	r2, [sp, #28]
3003338c:	e5832000 	str	r2, [r3]
		hdr[cur].used = 1;
30033390:	e59d201c 	ldr	r2, [sp, #28]
30033394:	e59f00bc 	ldr	r0, [pc, #188]	; 30033458 <file_pcm_player+0x238>
30033398:	e3a01024 	mov	r1, #36	; 0x24
3003339c:	e1a03002 	mov	r3, r2
300333a0:	e1a03103 	lsl	r3, r3, #2
300333a4:	e0833002 	add	r3, r3, r2
300333a8:	e1a03083 	lsl	r3, r3, #1
300333ac:	e0833002 	add	r3, r3, r2
300333b0:	e1a03103 	lsl	r3, r3, #2
300333b4:	e0833000 	add	r3, r3, r0
300333b8:	e0833001 	add	r3, r3, r1
300333bc:	e3a02001 	mov	r2, #1
300333c0:	e5832000 	str	r2, [r3]
		waveOutWrite(0,&hdr[cur], 0);
300333c4:	e59d201c 	ldr	r2, [sp, #28]
300333c8:	e1a03002 	mov	r3, r2
300333cc:	e1a03103 	lsl	r3, r3, #2
300333d0:	e0833002 	add	r3, r3, r2
300333d4:	e1a03083 	lsl	r3, r3, #1
300333d8:	e0833002 	add	r3, r3, r2
300333dc:	e1a03103 	lsl	r3, r3, #2
300333e0:	e1a02003 	mov	r2, r3
300333e4:	e59f306c 	ldr	r3, [pc, #108]	; 30033458 <file_pcm_player+0x238>
300333e8:	e0823003 	add	r3, r2, r3
300333ec:	e3a00000 	mov	r0, #0
300333f0:	e1a01003 	mov	r1, r3
300333f4:	e3a02000 	mov	r2, #0
300333f8:	ebfff844 	bl	30031510 <waveOutWrite>
		hdr[cur].update = 0;   //put here may happen dead lock!!!!!!
300333fc:	e59d201c 	ldr	r2, [sp, #28]
30033400:	e59f0050 	ldr	r0, [pc, #80]	; 30033458 <file_pcm_player+0x238>
30033404:	e3a01028 	mov	r1, #40	; 0x28
30033408:	e1a03002 	mov	r3, r2
3003340c:	e1a03103 	lsl	r3, r3, #2
30033410:	e0833002 	add	r3, r3, r2
30033414:	e1a03083 	lsl	r3, r3, #1
30033418:	e0833002 	add	r3, r3, r2
3003341c:	e1a03103 	lsl	r3, r3, #2
30033420:	e0833000 	add	r3, r3, r0
30033424:	e0833001 	add	r3, r3, r1
30033428:	e3a02000 	mov	r2, #0
3003342c:	e5832000 	str	r2, [r3]
					if(cur > (lpPlayCurBlk->pcm_dma_buf_cur))
						break;
			}

		}*/
		cur ++;
30033430:	e59d301c 	ldr	r3, [sp, #28]
30033434:	e2833001 	add	r3, r3, #1
30033438:	e58d301c 	str	r3, [sp, #28]
		if(cur == pcm_dma_buf_size)
3003343c:	e59d301c 	ldr	r3, [sp, #28]
30033440:	e353000a 	cmp	r3, #10
30033444:	1affff8c 	bne	3003327c <file_pcm_player+0x5c>
			cur = 0;
30033448:	e3a03000 	mov	r3, #0
3003344c:	e58d301c 	str	r3, [sp, #28]
	}
30033450:	eaffff8a 	b	30033280 <file_pcm_player+0x60>
30033454:	302be50c 	.word	0x302be50c
30033458:	302bf84c 	.word	0x302bf84c
3003345c:	302be6b0 	.word	0x302be6b0
30033460:	3012d730 	.word	0x3012d730

30033464 <local_mp3_file_read>:
acoral_32 cur_file_ptr;
acoral_id mp3_decoder_id;
acoral_id pcm_player_id;
int end_of_file = -1;

void local_mp3_file_read(void) {
30033464:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30033468:	e24dd034 	sub	sp, sp, #52	; 0x34

	int i;
	int cur = 0;
3003346c:	e3a03000 	mov	r3, #0
30033470:	e58d3020 	str	r3, [sp, #32]
	int first = 1;
30033474:	e3a03001 	mov	r3, #1
30033478:	e58d3024 	str	r3, [sp, #36]	; 0x24
	//acoral_32 mp3_file = acoral_open("2.mp3", O_RDWR);
	acoral_32 mp3_file;
	acoral_slice_policy_data_t data;
	play_song = Mp3;
3003347c:	e59f341c 	ldr	r3, [pc, #1052]	; 300338a0 <local_mp3_file_read+0x43c>
30033480:	e3a02002 	mov	r2, #2
30033484:	e5832000 	str	r2, [r3]
	data.cpu = 0;
30033488:	e3a03000 	mov	r3, #0
3003348c:	e5cd3014 	strb	r3, [sp, #20]
	data.prio = 21;
30033490:	e3a03015 	mov	r3, #21
30033494:	e5cd3015 	strb	r3, [sp, #21]
	data.slice = 100;
30033498:	e3a03064 	mov	r3, #100	; 0x64
3003349c:	e58d3018 	str	r3, [sp, #24]
	cur_file_ptr = acoral_open(cur_file_name, O_RDWR);
300334a0:	e59f03fc 	ldr	r0, [pc, #1020]	; 300338a4 <local_mp3_file_read+0x440>
300334a4:	e3a01006 	mov	r1, #6
300334a8:	ebffdf0b 	bl	3002b0dc <acoral_open>
300334ac:	e1a02000 	mov	r2, r0
300334b0:	e59f33f0 	ldr	r3, [pc, #1008]	; 300338a8 <local_mp3_file_read+0x444>
300334b4:	e5832000 	str	r2, [r3]
	mp3_file = cur_file_ptr;
300334b8:	e59f33e8 	ldr	r3, [pc, #1000]	; 300338a8 <local_mp3_file_read+0x444>
300334bc:	e5933000 	ldr	r3, [r3]
300334c0:	e58d3028 	str	r3, [sp, #40]	; 0x28
	int tmp;
	for(i=0; i<file_mp3_buf_size; i++) {
300334c4:	e3a03000 	mov	r3, #0
300334c8:	e58d301c 	str	r3, [sp, #28]
300334cc:	ea000026 	b	3003356c <local_mp3_file_read+0x108>
		file_mp3_buf_hdr[i].update = 0;
300334d0:	e59d201c 	ldr	r2, [sp, #28]
300334d4:	e59f33d0 	ldr	r3, [pc, #976]	; 300338ac <local_mp3_file_read+0x448>
300334d8:	e1a02082 	lsl	r2, r2, #1
300334dc:	e2822001 	add	r2, r2, #1
300334e0:	e3a01000 	mov	r1, #0
300334e4:	e7831182 	str	r1, [r3, r2, lsl #3]
		file_mp3_buf_hdr[i].used = 0;
300334e8:	e59d101c 	ldr	r1, [sp, #28]
300334ec:	e59f23b8 	ldr	r2, [pc, #952]	; 300338ac <local_mp3_file_read+0x448>
300334f0:	e3a03004 	mov	r3, #4
300334f4:	e1a01201 	lsl	r1, r1, #4
300334f8:	e0812002 	add	r2, r1, r2
300334fc:	e0823003 	add	r3, r2, r3
30033500:	e3a02000 	mov	r2, #0
30033504:	e5832000 	str	r2, [r3]
		acoral_sem_init(file_mp3_buf_usedone_eve+i, 0);
30033508:	e59d201c 	ldr	r2, [sp, #28]
3003350c:	e1a03002 	mov	r3, r2
30033510:	e1a03183 	lsl	r3, r3, #3
30033514:	e0833002 	add	r3, r3, r2
30033518:	e1a03103 	lsl	r3, r3, #2
3003351c:	e1a02003 	mov	r2, r3
30033520:	e59f3388 	ldr	r3, [pc, #904]	; 300338b0 <local_mp3_file_read+0x44c>
30033524:	e0823003 	add	r3, r2, r3
30033528:	e1a00003 	mov	r0, r3
3003352c:	e3a01000 	mov	r1, #0
30033530:	ebff4fce 	bl	30007470 <acoral_sem_init>
		acoral_sem_init(file_mp3_buf_update_eve+i, 0);
30033534:	e59d201c 	ldr	r2, [sp, #28]
30033538:	e1a03002 	mov	r3, r2
3003353c:	e1a03183 	lsl	r3, r3, #3
30033540:	e0833002 	add	r3, r3, r2
30033544:	e1a03103 	lsl	r3, r3, #2
30033548:	e1a02003 	mov	r2, r3
3003354c:	e59f3360 	ldr	r3, [pc, #864]	; 300338b4 <local_mp3_file_read+0x450>
30033550:	e0823003 	add	r3, r2, r3
30033554:	e1a00003 	mov	r0, r3
30033558:	e3a01000 	mov	r1, #0
3003355c:	ebff4fc3 	bl	30007470 <acoral_sem_init>
	data.prio = 21;
	data.slice = 100;
	cur_file_ptr = acoral_open(cur_file_name, O_RDWR);
	mp3_file = cur_file_ptr;
	int tmp;
	for(i=0; i<file_mp3_buf_size; i++) {
30033560:	e59d301c 	ldr	r3, [sp, #28]
30033564:	e2833001 	add	r3, r3, #1
30033568:	e58d301c 	str	r3, [sp, #28]
3003356c:	e59d301c 	ldr	r3, [sp, #28]
30033570:	e3530009 	cmp	r3, #9
30033574:	daffffd5 	ble	300334d0 <local_mp3_file_read+0x6c>
		file_mp3_buf_hdr[i].update = 0;
		file_mp3_buf_hdr[i].used = 0;
		acoral_sem_init(file_mp3_buf_usedone_eve+i, 0);
		acoral_sem_init(file_mp3_buf_update_eve+i, 0);
	}
	for(i=0; i<pcm_dma_buf_size; i++) {
30033578:	e3a03000 	mov	r3, #0
3003357c:	e58d301c 	str	r3, [sp, #28]
30033580:	ea000032 	b	30033650 <local_mp3_file_read+0x1ec>
			hdr[i].used = 0;
30033584:	e59d201c 	ldr	r2, [sp, #28]
30033588:	e59f0328 	ldr	r0, [pc, #808]	; 300338b8 <local_mp3_file_read+0x454>
3003358c:	e3a01024 	mov	r1, #36	; 0x24
30033590:	e1a03002 	mov	r3, r2
30033594:	e1a03103 	lsl	r3, r3, #2
30033598:	e0833002 	add	r3, r3, r2
3003359c:	e1a03083 	lsl	r3, r3, #1
300335a0:	e0833002 	add	r3, r3, r2
300335a4:	e1a03103 	lsl	r3, r3, #2
300335a8:	e0833000 	add	r3, r3, r0
300335ac:	e0833001 	add	r3, r3, r1
300335b0:	e3a02000 	mov	r2, #0
300335b4:	e5832000 	str	r2, [r3]
			hdr[i].update = 0;
300335b8:	e59d201c 	ldr	r2, [sp, #28]
300335bc:	e59f02f4 	ldr	r0, [pc, #756]	; 300338b8 <local_mp3_file_read+0x454>
300335c0:	e3a01028 	mov	r1, #40	; 0x28
300335c4:	e1a03002 	mov	r3, r2
300335c8:	e1a03103 	lsl	r3, r3, #2
300335cc:	e0833002 	add	r3, r3, r2
300335d0:	e1a03083 	lsl	r3, r3, #1
300335d4:	e0833002 	add	r3, r3, r2
300335d8:	e1a03103 	lsl	r3, r3, #2
300335dc:	e0833000 	add	r3, r3, r0
300335e0:	e0833001 	add	r3, r3, r1
300335e4:	e3a02000 	mov	r2, #0
300335e8:	e5832000 	str	r2, [r3]
			acoral_sem_init(pcm_dma_buf_update_eve+i, 0);
300335ec:	e59d201c 	ldr	r2, [sp, #28]
300335f0:	e1a03002 	mov	r3, r2
300335f4:	e1a03183 	lsl	r3, r3, #3
300335f8:	e0833002 	add	r3, r3, r2
300335fc:	e1a03103 	lsl	r3, r3, #2
30033600:	e1a02003 	mov	r2, r3
30033604:	e59f32b0 	ldr	r3, [pc, #688]	; 300338bc <local_mp3_file_read+0x458>
30033608:	e0823003 	add	r3, r2, r3
3003360c:	e1a00003 	mov	r0, r3
30033610:	e3a01000 	mov	r1, #0
30033614:	ebff4f95 	bl	30007470 <acoral_sem_init>
			acoral_sem_init(pcm_dma_buf_playdone_eve+i, 0);
30033618:	e59d201c 	ldr	r2, [sp, #28]
3003361c:	e1a03002 	mov	r3, r2
30033620:	e1a03183 	lsl	r3, r3, #3
30033624:	e0833002 	add	r3, r3, r2
30033628:	e1a03103 	lsl	r3, r3, #2
3003362c:	e1a02003 	mov	r2, r3
30033630:	e59f3288 	ldr	r3, [pc, #648]	; 300338c0 <local_mp3_file_read+0x45c>
30033634:	e0823003 	add	r3, r2, r3
30033638:	e1a00003 	mov	r0, r3
3003363c:	e3a01000 	mov	r1, #0
30033640:	ebff4f8a 	bl	30007470 <acoral_sem_init>
		file_mp3_buf_hdr[i].update = 0;
		file_mp3_buf_hdr[i].used = 0;
		acoral_sem_init(file_mp3_buf_usedone_eve+i, 0);
		acoral_sem_init(file_mp3_buf_update_eve+i, 0);
	}
	for(i=0; i<pcm_dma_buf_size; i++) {
30033644:	e59d301c 	ldr	r3, [sp, #28]
30033648:	e2833001 	add	r3, r3, #1
3003364c:	e58d301c 	str	r3, [sp, #28]
30033650:	e59d301c 	ldr	r3, [sp, #28]
30033654:	e3530009 	cmp	r3, #9
30033658:	daffffc9 	ble	30033584 <local_mp3_file_read+0x120>
			hdr[i].used = 0;
			hdr[i].update = 0;
			acoral_sem_init(pcm_dma_buf_update_eve+i, 0);
			acoral_sem_init(pcm_dma_buf_playdone_eve+i, 0);
	}
	end_of_file = -1;
3003365c:	e59f3260 	ldr	r3, [pc, #608]	; 300338c4 <local_mp3_file_read+0x460>
30033660:	e3e02000 	mvn	r2, #0
30033664:	e5832000 	str	r2, [r3]
30033668:	ea000000 	b	30033670 <local_mp3_file_read+0x20c>
			first = 0;
			mp3_decoder_id = acoral_create_thread_ext(mp3_decoder, 8192*16, 0, "mp3_decoder", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
		}
		if(cur == file_mp3_buf_size)
			cur = 0;
	}
3003366c:	e1a00000 	nop			; (mov r0, r0)
	}
	end_of_file = -1;
	//mp3_decoder_id = acoral_create_thread(mp3_decoder,8192*16,NULL,"mp3_decoder",16,0);
	//mp3_decoder_id = acoral_create_thread_ext(mp3_decoder, 8192*16, 0, "mp3_decoder", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
	while(1) {
		if(file_mp3_buf_hdr[cur].used)
30033670:	e59d1020 	ldr	r1, [sp, #32]
30033674:	e59f2230 	ldr	r2, [pc, #560]	; 300338ac <local_mp3_file_read+0x448>
30033678:	e3a03004 	mov	r3, #4
3003367c:	e1a01201 	lsl	r1, r1, #4
30033680:	e0812002 	add	r2, r1, r2
30033684:	e0823003 	add	r3, r2, r3
30033688:	e5933000 	ldr	r3, [r3]
3003368c:	e3530000 	cmp	r3, #0
30033690:	0a00000a 	beq	300336c0 <local_mp3_file_read+0x25c>
			acoral_sem_pend(file_mp3_buf_usedone_eve+cur, 0);
30033694:	e59d2020 	ldr	r2, [sp, #32]
30033698:	e1a03002 	mov	r3, r2
3003369c:	e1a03183 	lsl	r3, r3, #3
300336a0:	e0833002 	add	r3, r3, r2
300336a4:	e1a03103 	lsl	r3, r3, #2
300336a8:	e1a02003 	mov	r2, r3
300336ac:	e59f31fc 	ldr	r3, [pc, #508]	; 300338b0 <local_mp3_file_read+0x44c>
300336b0:	e0823003 	add	r3, r2, r3
300336b4:	e1a00003 	mov	r0, r3
300336b8:	e3a01000 	mov	r1, #0
300336bc:	ebff4fff 	bl	300076c0 <acoral_sem_pend>
		for(i=0; i<file_buf_block_size; i++)
300336c0:	e3a03000 	mov	r3, #0
300336c4:	e58d301c 	str	r3, [sp, #28]
300336c8:	ea00000d 	b	30033704 <local_mp3_file_read+0x2a0>
			file_mp3_buf[cur][i] = 0;
300336cc:	e59d2020 	ldr	r2, [sp, #32]
300336d0:	e59d001c 	ldr	r0, [sp, #28]
300336d4:	e59f11ec 	ldr	r1, [pc, #492]	; 300338c8 <local_mp3_file_read+0x464>
300336d8:	e1a03002 	mov	r3, r2
300336dc:	e1a03103 	lsl	r3, r3, #2
300336e0:	e0833002 	add	r3, r3, r2
300336e4:	e1a03703 	lsl	r3, r3, #14
300336e8:	e0833000 	add	r3, r3, r0
300336ec:	e0833001 	add	r3, r3, r1
300336f0:	e3a02000 	mov	r2, #0
300336f4:	e5c32000 	strb	r2, [r3]
	//mp3_decoder_id = acoral_create_thread(mp3_decoder,8192*16,NULL,"mp3_decoder",16,0);
	//mp3_decoder_id = acoral_create_thread_ext(mp3_decoder, 8192*16, 0, "mp3_decoder", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
	while(1) {
		if(file_mp3_buf_hdr[cur].used)
			acoral_sem_pend(file_mp3_buf_usedone_eve+cur, 0);
		for(i=0; i<file_buf_block_size; i++)
300336f8:	e59d301c 	ldr	r3, [sp, #28]
300336fc:	e2833001 	add	r3, r3, #1
30033700:	e58d301c 	str	r3, [sp, #28]
30033704:	e59d201c 	ldr	r2, [sp, #28]
30033708:	e3a03905 	mov	r3, #81920	; 0x14000
3003370c:	e2433001 	sub	r3, r3, #1
30033710:	e1520003 	cmp	r2, r3
30033714:	daffffec 	ble	300336cc <local_mp3_file_read+0x268>
			file_mp3_buf[cur][i] = 0;
		tmp = acoral_read(mp3_file, file_mp3_buf[cur], file_buf_block_size);
30033718:	e59d2020 	ldr	r2, [sp, #32]
3003371c:	e1a03002 	mov	r3, r2
30033720:	e1a03103 	lsl	r3, r3, #2
30033724:	e0833002 	add	r3, r3, r2
30033728:	e1a03703 	lsl	r3, r3, #14
3003372c:	e1a02003 	mov	r2, r3
30033730:	e59f3190 	ldr	r3, [pc, #400]	; 300338c8 <local_mp3_file_read+0x464>
30033734:	e0823003 	add	r3, r2, r3
30033738:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
3003373c:	e1a01003 	mov	r1, r3
30033740:	e3a02905 	mov	r2, #81920	; 0x14000
30033744:	ebffdedc 	bl	3002b2bc <acoral_read>
30033748:	e1a03000 	mov	r3, r0
3003374c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
		file_mp3_buf_hdr[cur].update = 1;
30033750:	e59d2020 	ldr	r2, [sp, #32]
30033754:	e59f3150 	ldr	r3, [pc, #336]	; 300338ac <local_mp3_file_read+0x448>
30033758:	e1a02082 	lsl	r2, r2, #1
3003375c:	e2822001 	add	r2, r2, #1
30033760:	e3a01001 	mov	r1, #1
30033764:	e7831182 	str	r1, [r3, r2, lsl #3]
		file_mp3_buf_hdr[cur].used = 1;
30033768:	e59d1020 	ldr	r1, [sp, #32]
3003376c:	e59f2138 	ldr	r2, [pc, #312]	; 300338ac <local_mp3_file_read+0x448>
30033770:	e3a03004 	mov	r3, #4
30033774:	e1a01201 	lsl	r1, r1, #4
30033778:	e0812002 	add	r2, r1, r2
3003377c:	e0823003 	add	r3, r2, r3
30033780:	e3a02001 	mov	r2, #1
30033784:	e5832000 	str	r2, [r3]
		if(acoral_sem_getnum(file_mp3_buf_update_eve+cur))
30033788:	e59d2020 	ldr	r2, [sp, #32]
3003378c:	e1a03002 	mov	r3, r2
30033790:	e1a03183 	lsl	r3, r3, #3
30033794:	e0833002 	add	r3, r3, r2
30033798:	e1a03103 	lsl	r3, r3, #2
3003379c:	e1a02003 	mov	r2, r3
300337a0:	e59f310c 	ldr	r3, [pc, #268]	; 300338b4 <local_mp3_file_read+0x450>
300337a4:	e0823003 	add	r3, r2, r3
300337a8:	e1a00003 	mov	r0, r3
300337ac:	ebff5070 	bl	30007974 <acoral_sem_getnum>
300337b0:	e1a03000 	mov	r3, r0
300337b4:	e3530000 	cmp	r3, #0
300337b8:	0a000009 	beq	300337e4 <local_mp3_file_read+0x380>
			acoral_sem_post(file_mp3_buf_update_eve+cur);
300337bc:	e59d2020 	ldr	r2, [sp, #32]
300337c0:	e1a03002 	mov	r3, r2
300337c4:	e1a03183 	lsl	r3, r3, #3
300337c8:	e0833002 	add	r3, r3, r2
300337cc:	e1a03103 	lsl	r3, r3, #2
300337d0:	e1a02003 	mov	r2, r3
300337d4:	e59f30d8 	ldr	r3, [pc, #216]	; 300338b4 <local_mp3_file_read+0x450>
300337d8:	e0823003 	add	r3, r2, r3
300337dc:	e1a00003 	mov	r0, r3
300337e0:	ebff5021 	bl	3000786c <acoral_sem_post>
		if(tmp != file_buf_block_size)
300337e4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300337e8:	e3530905 	cmp	r3, #81920	; 0x14000
300337ec:	0a000007 	beq	30033810 <local_mp3_file_read+0x3ac>
			mp3_decoder_id = acoral_create_thread_ext(mp3_decoder, 8192*16, 0, "mp3_decoder", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
		}
		if(cur == file_mp3_buf_size)
			cur = 0;
	}
	acoral_close(cur_file_ptr);
300337f0:	e59f30b0 	ldr	r3, [pc, #176]	; 300338a8 <local_mp3_file_read+0x444>
300337f4:	e5933000 	ldr	r3, [r3]
300337f8:	e1a00003 	mov	r0, r3
300337fc:	ebffde8b 	bl	3002b230 <acoral_close>
	end_of_file = cur;
30033800:	e59f30bc 	ldr	r3, [pc, #188]	; 300338c4 <local_mp3_file_read+0x460>
30033804:	e59d2020 	ldr	r2, [sp, #32]
30033808:	e5832000 	str	r2, [r3]
3003380c:	ea00001f 	b	30033890 <local_mp3_file_read+0x42c>
		file_mp3_buf_hdr[cur].used = 1;
		if(acoral_sem_getnum(file_mp3_buf_update_eve+cur))
			acoral_sem_post(file_mp3_buf_update_eve+cur);
		if(tmp != file_buf_block_size)
					break;
		cur ++;
30033810:	e59d3020 	ldr	r3, [sp, #32]
30033814:	e2833001 	add	r3, r3, #1
30033818:	e58d3020 	str	r3, [sp, #32]
		if(first && cur == 3) {
3003381c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30033820:	e3530000 	cmp	r3, #0
30033824:	0a000013 	beq	30033878 <local_mp3_file_read+0x414>
30033828:	e59d3020 	ldr	r3, [sp, #32]
3003382c:	e3530003 	cmp	r3, #3
30033830:	1a000010 	bne	30033878 <local_mp3_file_read+0x414>
			first = 0;
30033834:	e3a03000 	mov	r3, #0
30033838:	e58d3024 	str	r3, [sp, #36]	; 0x24
			mp3_decoder_id = acoral_create_thread_ext(mp3_decoder, 8192*16, 0, "mp3_decoder", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
3003383c:	e59f3088 	ldr	r3, [pc, #136]	; 300338cc <local_mp3_file_read+0x468>
30033840:	e3a02000 	mov	r2, #0
30033844:	e58d2000 	str	r2, [sp]
30033848:	e3a02018 	mov	r2, #24
3003384c:	e58d2004 	str	r2, [sp, #4]
30033850:	e28d2014 	add	r2, sp, #20
30033854:	e58d2008 	str	r2, [sp, #8]
30033858:	e1a00003 	mov	r0, r3
3003385c:	e3a01802 	mov	r1, #131072	; 0x20000
30033860:	e3a02000 	mov	r2, #0
30033864:	e59f3064 	ldr	r3, [pc, #100]	; 300338d0 <local_mp3_file_read+0x46c>
30033868:	ebff38f1 	bl	30001c34 <create_thread_ext>
3003386c:	e1a02000 	mov	r2, r0
30033870:	e59f305c 	ldr	r3, [pc, #92]	; 300338d4 <local_mp3_file_read+0x470>
30033874:	e5832000 	str	r2, [r3]
		}
		if(cur == file_mp3_buf_size)
30033878:	e59d3020 	ldr	r3, [sp, #32]
3003387c:	e353000a 	cmp	r3, #10
30033880:	1affff79 	bne	3003366c <local_mp3_file_read+0x208>
			cur = 0;
30033884:	e3a03000 	mov	r3, #0
30033888:	e58d3020 	str	r3, [sp, #32]
	}
3003388c:	eaffff77 	b	30033670 <local_mp3_file_read+0x20c>
	acoral_close(cur_file_ptr);
	end_of_file = cur;
	while(1) {
			acoral_delay_self(5000);
30033890:	e3a00d4e 	mov	r0, #4992	; 0x1380
30033894:	e2800008 	add	r0, r0, #8
30033898:	ebff3c39 	bl	30002984 <acoral_delay_self>
	}
3003389c:	eafffffb 	b	30033890 <local_mp3_file_read+0x42c>
300338a0:	3012b644 	.word	0x3012b644
300338a4:	300eaa24 	.word	0x300eaa24
300338a8:	302be6ac 	.word	0x302be6ac
300338ac:	300ea3bc 	.word	0x300ea3bc
300338b0:	3012acac 	.word	0x3012acac
300338b4:	302be270 	.word	0x302be270
300338b8:	302bf84c 	.word	0x302bf84c
300338bc:	302be6b0 	.word	0x302be6b0
300338c0:	301f57a8 	.word	0x301f57a8
300338c4:	300c6000 	.word	0x300c6000
300338c8:	301f5948 	.word	0x301f5948
300338cc:	3003f950 	.word	0x3003f950
300338d0:	3004608c 	.word	0x3004608c
300338d4:	302bf844 	.word	0x302bf844

300338d8 <mp3_mask>:

}

void mp3_mask(void) {
300338d8:	e92d4008 	push	{r3, lr}
	while(1) {
			acoral_delay_self(10000);
300338dc:	e3a00c27 	mov	r0, #9984	; 0x2700
300338e0:	e2800010 	add	r0, r0, #16
300338e4:	ebff3c26 	bl	30002984 <acoral_delay_self>
	}
300338e8:	eafffffb 	b	300338dc <mp3_mask+0x4>

300338ec <local_wav_file_read>:
}

void local_wav_file_read(void) {
300338ec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300338f0:	e24dd034 	sub	sp, sp, #52	; 0x34

	int i;
	int cur = 0;
300338f4:	e3a03000 	mov	r3, #0
300338f8:	e58d3020 	str	r3, [sp, #32]
	end_of_file = -1;
300338fc:	e59f34a0 	ldr	r3, [pc, #1184]	; 30033da4 <local_wav_file_read+0x4b8>
30033900:	e3e02000 	mvn	r2, #0
30033904:	e5832000 	str	r2, [r3]
	play_song = Mp3;
30033908:	e59f3498 	ldr	r3, [pc, #1176]	; 30033da8 <local_wav_file_read+0x4bc>
3003390c:	e3a02002 	mov	r2, #2
30033910:	e5832000 	str	r2, [r3]
	//acoral_32 wav_file = acoral_open("2.wav", O_RDWR);
	acoral_32 wav_file;
	acoral_slice_policy_data_t data;
	data.cpu = 0;
30033914:	e3a03000 	mov	r3, #0
30033918:	e5cd3014 	strb	r3, [sp, #20]
	data.prio = 20;
3003391c:	e3a03014 	mov	r3, #20
30033920:	e5cd3015 	strb	r3, [sp, #21]
	data.slice = 100;
30033924:	e3a03064 	mov	r3, #100	; 0x64
30033928:	e58d3018 	str	r3, [sp, #24]
	cur_file_ptr = acoral_open(cur_file_name, O_RDWR);
3003392c:	e59f0478 	ldr	r0, [pc, #1144]	; 30033dac <local_wav_file_read+0x4c0>
30033930:	e3a01006 	mov	r1, #6
30033934:	ebffdde8 	bl	3002b0dc <acoral_open>
30033938:	e1a02000 	mov	r2, r0
3003393c:	e59f346c 	ldr	r3, [pc, #1132]	; 30033db0 <local_wav_file_read+0x4c4>
30033940:	e5832000 	str	r2, [r3]
	wav_file = cur_file_ptr;
30033944:	e59f3464 	ldr	r3, [pc, #1124]	; 30033db0 <local_wav_file_read+0x4c4>
30033948:	e5933000 	ldr	r3, [r3]
3003394c:	e58d3024 	str	r3, [sp, #36]	; 0x24
	int tmp;
	for(i=0; i<pcm_dma_buf_size; i++) {
30033950:	e3a03000 	mov	r3, #0
30033954:	e58d301c 	str	r3, [sp, #28]
30033958:	ea000032 	b	30033a28 <local_wav_file_read+0x13c>
			hdr[i].used = 0;
3003395c:	e59d201c 	ldr	r2, [sp, #28]
30033960:	e59f044c 	ldr	r0, [pc, #1100]	; 30033db4 <local_wav_file_read+0x4c8>
30033964:	e3a01024 	mov	r1, #36	; 0x24
30033968:	e1a03002 	mov	r3, r2
3003396c:	e1a03103 	lsl	r3, r3, #2
30033970:	e0833002 	add	r3, r3, r2
30033974:	e1a03083 	lsl	r3, r3, #1
30033978:	e0833002 	add	r3, r3, r2
3003397c:	e1a03103 	lsl	r3, r3, #2
30033980:	e0833000 	add	r3, r3, r0
30033984:	e0833001 	add	r3, r3, r1
30033988:	e3a02000 	mov	r2, #0
3003398c:	e5832000 	str	r2, [r3]
			hdr[i].update = 0;
30033990:	e59d201c 	ldr	r2, [sp, #28]
30033994:	e59f0418 	ldr	r0, [pc, #1048]	; 30033db4 <local_wav_file_read+0x4c8>
30033998:	e3a01028 	mov	r1, #40	; 0x28
3003399c:	e1a03002 	mov	r3, r2
300339a0:	e1a03103 	lsl	r3, r3, #2
300339a4:	e0833002 	add	r3, r3, r2
300339a8:	e1a03083 	lsl	r3, r3, #1
300339ac:	e0833002 	add	r3, r3, r2
300339b0:	e1a03103 	lsl	r3, r3, #2
300339b4:	e0833000 	add	r3, r3, r0
300339b8:	e0833001 	add	r3, r3, r1
300339bc:	e3a02000 	mov	r2, #0
300339c0:	e5832000 	str	r2, [r3]
			acoral_sem_init(pcm_dma_buf_update_eve+i, 0);
300339c4:	e59d201c 	ldr	r2, [sp, #28]
300339c8:	e1a03002 	mov	r3, r2
300339cc:	e1a03183 	lsl	r3, r3, #3
300339d0:	e0833002 	add	r3, r3, r2
300339d4:	e1a03103 	lsl	r3, r3, #2
300339d8:	e1a02003 	mov	r2, r3
300339dc:	e59f33d4 	ldr	r3, [pc, #980]	; 30033db8 <local_wav_file_read+0x4cc>
300339e0:	e0823003 	add	r3, r2, r3
300339e4:	e1a00003 	mov	r0, r3
300339e8:	e3a01000 	mov	r1, #0
300339ec:	ebff4e9f 	bl	30007470 <acoral_sem_init>
			acoral_sem_init(pcm_dma_buf_playdone_eve+i, 0);
300339f0:	e59d201c 	ldr	r2, [sp, #28]
300339f4:	e1a03002 	mov	r3, r2
300339f8:	e1a03183 	lsl	r3, r3, #3
300339fc:	e0833002 	add	r3, r3, r2
30033a00:	e1a03103 	lsl	r3, r3, #2
30033a04:	e1a02003 	mov	r2, r3
30033a08:	e59f33ac 	ldr	r3, [pc, #940]	; 30033dbc <local_wav_file_read+0x4d0>
30033a0c:	e0823003 	add	r3, r2, r3
30033a10:	e1a00003 	mov	r0, r3
30033a14:	e3a01000 	mov	r1, #0
30033a18:	ebff4e94 	bl	30007470 <acoral_sem_init>
	data.prio = 20;
	data.slice = 100;
	cur_file_ptr = acoral_open(cur_file_name, O_RDWR);
	wav_file = cur_file_ptr;
	int tmp;
	for(i=0; i<pcm_dma_buf_size; i++) {
30033a1c:	e59d301c 	ldr	r3, [sp, #28]
30033a20:	e2833001 	add	r3, r3, #1
30033a24:	e58d301c 	str	r3, [sp, #28]
30033a28:	e59d301c 	ldr	r3, [sp, #28]
30033a2c:	e3530009 	cmp	r3, #9
30033a30:	daffffc9 	ble	3003395c <local_wav_file_read+0x70>
			hdr[i].update = 0;
			acoral_sem_init(pcm_dma_buf_update_eve+i, 0);
			acoral_sem_init(pcm_dma_buf_playdone_eve+i, 0);
	}
	unsigned char* ptr;
	acoral_read(wav_file, file_wav_buf+0, 50);
30033a34:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
30033a38:	e59f1380 	ldr	r1, [pc, #896]	; 30033dc0 <local_wav_file_read+0x4d4>
30033a3c:	e3a02032 	mov	r2, #50	; 0x32
30033a40:	ebffde1d 	bl	3002b2bc <acoral_read>
	ptr = file_wav_buf[cur];
30033a44:	e59f1374 	ldr	r1, [pc, #884]	; 30033dc0 <local_wav_file_read+0x4d4>
30033a48:	e59d2020 	ldr	r2, [sp, #32]
30033a4c:	e1a03002 	mov	r3, r2
30033a50:	e1a03103 	lsl	r3, r3, #2
30033a54:	e0833002 	add	r3, r3, r2
30033a58:	e1a03703 	lsl	r3, r3, #14
30033a5c:	e0813003 	add	r3, r1, r3
30033a60:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	fmt.wFormatTag = WAVE_FORMAT_PCM;
30033a64:	e59f3358 	ldr	r3, [pc, #856]	; 30033dc4 <local_wav_file_read+0x4d8>
30033a68:	e3a02001 	mov	r2, #1
30033a6c:	e1c320b0 	strh	r2, [r3]
	fmt.nChannels		= *(acoral_u16 *)(ptr+0x16);
30033a70:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30033a74:	e2833016 	add	r3, r3, #22
30033a78:	e1d320b0 	ldrh	r2, [r3]
30033a7c:	e59f3340 	ldr	r3, [pc, #832]	; 30033dc4 <local_wav_file_read+0x4d8>
30033a80:	e1c320b2 	strh	r2, [r3, #2]
	fmt.nSamplesPerSec	= *(acoral_u32 *)(ptr+0x18);
30033a84:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30033a88:	e2833018 	add	r3, r3, #24
30033a8c:	e5932000 	ldr	r2, [r3]
30033a90:	e59f332c 	ldr	r3, [pc, #812]	; 30033dc4 <local_wav_file_read+0x4d8>
30033a94:	e5832004 	str	r2, [r3, #4]
	fmt.nAvgBytesPerSec	= *(acoral_u32 *)(ptr+0x1c);
30033a98:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30033a9c:	e283301c 	add	r3, r3, #28
30033aa0:	e5932000 	ldr	r2, [r3]
30033aa4:	e59f3318 	ldr	r3, [pc, #792]	; 30033dc4 <local_wav_file_read+0x4d8>
30033aa8:	e5832008 	str	r2, [r3, #8]
	fmt.nBlockAlign		= *(acoral_u16 *)(ptr+0x20);
30033aac:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30033ab0:	e2833020 	add	r3, r3, #32
30033ab4:	e1d320b0 	ldrh	r2, [r3]
30033ab8:	e59f3304 	ldr	r3, [pc, #772]	; 30033dc4 <local_wav_file_read+0x4d8>
30033abc:	e1c320bc 	strh	r2, [r3, #12]
	fmt.wBitsPerSample	= *(acoral_u16 *)(ptr+0x22);
30033ac0:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30033ac4:	e2833022 	add	r3, r3, #34	; 0x22
30033ac8:	e1d320b0 	ldrh	r2, [r3]
30033acc:	e59f32f0 	ldr	r3, [pc, #752]	; 30033dc4 <local_wav_file_read+0x4d8>
30033ad0:	e1c320be 	strh	r2, [r3, #14]
	acoral_print("\nSample Rate = %d, Channels = %d, %dBitsPerSample, size = %d\n",
30033ad4:	e59f32e8 	ldr	r3, [pc, #744]	; 30033dc4 <local_wav_file_read+0x4d8>
30033ad8:	e5931004 	ldr	r1, [r3, #4]
				fmt.nSamplesPerSec, fmt.nChannels, fmt.wBitsPerSample, fmt.nChannels);
30033adc:	e59f32e0 	ldr	r3, [pc, #736]	; 30033dc4 <local_wav_file_read+0x4d8>
30033ae0:	e1d330b2 	ldrh	r3, [r3, #2]
	fmt.nChannels		= *(acoral_u16 *)(ptr+0x16);
	fmt.nSamplesPerSec	= *(acoral_u32 *)(ptr+0x18);
	fmt.nAvgBytesPerSec	= *(acoral_u32 *)(ptr+0x1c);
	fmt.nBlockAlign		= *(acoral_u16 *)(ptr+0x20);
	fmt.wBitsPerSample	= *(acoral_u16 *)(ptr+0x22);
	acoral_print("\nSample Rate = %d, Channels = %d, %dBitsPerSample, size = %d\n",
30033ae4:	e1a02003 	mov	r2, r3
				fmt.nSamplesPerSec, fmt.nChannels, fmt.wBitsPerSample, fmt.nChannels);
30033ae8:	e59f32d4 	ldr	r3, [pc, #724]	; 30033dc4 <local_wav_file_read+0x4d8>
30033aec:	e1d330be 	ldrh	r3, [r3, #14]
30033af0:	e59f02cc 	ldr	r0, [pc, #716]	; 30033dc4 <local_wav_file_read+0x4d8>
30033af4:	e1d000b2 	ldrh	r0, [r0, #2]
	fmt.nChannels		= *(acoral_u16 *)(ptr+0x16);
	fmt.nSamplesPerSec	= *(acoral_u32 *)(ptr+0x18);
	fmt.nAvgBytesPerSec	= *(acoral_u32 *)(ptr+0x1c);
	fmt.nBlockAlign		= *(acoral_u16 *)(ptr+0x20);
	fmt.wBitsPerSample	= *(acoral_u16 *)(ptr+0x22);
	acoral_print("\nSample Rate = %d, Channels = %d, %dBitsPerSample, size = %d\n",
30033af8:	e58d0000 	str	r0, [sp]
30033afc:	e59f02c4 	ldr	r0, [pc, #708]	; 30033dc8 <local_wav_file_read+0x4dc>
30033b00:	ebff5dce 	bl	3000b240 <acoral_print>
				fmt.nSamplesPerSec, fmt.nChannels, fmt.wBitsPerSample, fmt.nChannels);
	mp3_decoder_id = acoral_create_thread(mp3_mask,8192*16,NULL,"mp3_decoder",16,0);
30033b04:	e59f32c0 	ldr	r3, [pc, #704]	; 30033dcc <local_wav_file_read+0x4e0>
30033b08:	e3a02010 	mov	r2, #16
30033b0c:	e58d2000 	str	r2, [sp]
30033b10:	e3a02000 	mov	r2, #0
30033b14:	e58d2004 	str	r2, [sp, #4]
30033b18:	e1a00003 	mov	r0, r3
30033b1c:	e3a01802 	mov	r1, #131072	; 0x20000
30033b20:	e3a02000 	mov	r2, #0
30033b24:	e59f32a4 	ldr	r3, [pc, #676]	; 30033dd0 <local_wav_file_read+0x4e4>
30033b28:	ebff3d1d 	bl	30002fa4 <create_comm_thread>
30033b2c:	e1a02000 	mov	r2, r0
30033b30:	e59f329c 	ldr	r3, [pc, #668]	; 30033dd4 <local_wav_file_read+0x4e8>
30033b34:	e5832000 	str	r2, [r3]
	//pcm_player_id = acoral_create_thread(file_pcm_player,8192*16,NULL,"file_pcm_player",20,0);
	pcm_player_id = acoral_create_thread_ext(file_pcm_player, 8192*16, 0, "file_pcm_player", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
30033b38:	e59f3298 	ldr	r3, [pc, #664]	; 30033dd8 <local_wav_file_read+0x4ec>
30033b3c:	e3a02000 	mov	r2, #0
30033b40:	e58d2000 	str	r2, [sp]
30033b44:	e3a02018 	mov	r2, #24
30033b48:	e58d2004 	str	r2, [sp, #4]
30033b4c:	e28d2014 	add	r2, sp, #20
30033b50:	e58d2008 	str	r2, [sp, #8]
30033b54:	e1a00003 	mov	r0, r3
30033b58:	e3a01802 	mov	r1, #131072	; 0x20000
30033b5c:	e3a02000 	mov	r2, #0
30033b60:	e59f3274 	ldr	r3, [pc, #628]	; 30033ddc <local_wav_file_read+0x4f0>
30033b64:	ebff3832 	bl	30001c34 <create_thread_ext>
30033b68:	e1a02000 	mov	r2, r0
30033b6c:	e59f326c 	ldr	r3, [pc, #620]	; 30033de0 <local_wav_file_read+0x4f4>
30033b70:	e5832000 	str	r2, [r3]
	while(1) {

		if(hdr[cur].used)
30033b74:	e59d2020 	ldr	r2, [sp, #32]
30033b78:	e59f0234 	ldr	r0, [pc, #564]	; 30033db4 <local_wav_file_read+0x4c8>
30033b7c:	e3a01024 	mov	r1, #36	; 0x24
30033b80:	e1a03002 	mov	r3, r2
30033b84:	e1a03103 	lsl	r3, r3, #2
30033b88:	e0833002 	add	r3, r3, r2
30033b8c:	e1a03083 	lsl	r3, r3, #1
30033b90:	e0833002 	add	r3, r3, r2
30033b94:	e1a03103 	lsl	r3, r3, #2
30033b98:	e0833000 	add	r3, r3, r0
30033b9c:	e0833001 	add	r3, r3, r1
30033ba0:	e5933000 	ldr	r3, [r3]
30033ba4:	e3530000 	cmp	r3, #0
30033ba8:	0a00000a 	beq	30033bd8 <local_wav_file_read+0x2ec>
			acoral_sem_pend(pcm_dma_buf_playdone_eve+cur, 0);
30033bac:	e59d2020 	ldr	r2, [sp, #32]
30033bb0:	e1a03002 	mov	r3, r2
30033bb4:	e1a03183 	lsl	r3, r3, #3
30033bb8:	e0833002 	add	r3, r3, r2
30033bbc:	e1a03103 	lsl	r3, r3, #2
30033bc0:	e1a02003 	mov	r2, r3
30033bc4:	e59f31f0 	ldr	r3, [pc, #496]	; 30033dbc <local_wav_file_read+0x4d0>
30033bc8:	e0823003 	add	r3, r2, r3
30033bcc:	e1a00003 	mov	r0, r3
30033bd0:	e3a01000 	mov	r1, #0
30033bd4:	ebff4eb9 	bl	300076c0 <acoral_sem_pend>
		for(i=0; i<file_buf_block_size; i++)
30033bd8:	e3a03000 	mov	r3, #0
30033bdc:	e58d301c 	str	r3, [sp, #28]
30033be0:	ea00000d 	b	30033c1c <local_wav_file_read+0x330>
			file_wav_buf[cur][i] = 0;
30033be4:	e59d2020 	ldr	r2, [sp, #32]
30033be8:	e59d001c 	ldr	r0, [sp, #28]
30033bec:	e59f11cc 	ldr	r1, [pc, #460]	; 30033dc0 <local_wav_file_read+0x4d4>
30033bf0:	e1a03002 	mov	r3, r2
30033bf4:	e1a03103 	lsl	r3, r3, #2
30033bf8:	e0833002 	add	r3, r3, r2
30033bfc:	e1a03703 	lsl	r3, r3, #14
30033c00:	e0833000 	add	r3, r3, r0
30033c04:	e0833001 	add	r3, r3, r1
30033c08:	e3a02000 	mov	r2, #0
30033c0c:	e5c32000 	strb	r2, [r3]
	pcm_player_id = acoral_create_thread_ext(file_pcm_player, 8192*16, 0, "file_pcm_player", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
	while(1) {

		if(hdr[cur].used)
			acoral_sem_pend(pcm_dma_buf_playdone_eve+cur, 0);
		for(i=0; i<file_buf_block_size; i++)
30033c10:	e59d301c 	ldr	r3, [sp, #28]
30033c14:	e2833001 	add	r3, r3, #1
30033c18:	e58d301c 	str	r3, [sp, #28]
30033c1c:	e59d201c 	ldr	r2, [sp, #28]
30033c20:	e3a03905 	mov	r3, #81920	; 0x14000
30033c24:	e2433001 	sub	r3, r3, #1
30033c28:	e1520003 	cmp	r2, r3
30033c2c:	daffffec 	ble	30033be4 <local_wav_file_read+0x2f8>
			file_wav_buf[cur][i] = 0;
		tmp = acoral_read(wav_file, file_wav_buf+cur, file_buf_block_size);
30033c30:	e59d2020 	ldr	r2, [sp, #32]
30033c34:	e1a03002 	mov	r3, r2
30033c38:	e1a03103 	lsl	r3, r3, #2
30033c3c:	e0833002 	add	r3, r3, r2
30033c40:	e1a03703 	lsl	r3, r3, #14
30033c44:	e1a02003 	mov	r2, r3
30033c48:	e59f3170 	ldr	r3, [pc, #368]	; 30033dc0 <local_wav_file_read+0x4d4>
30033c4c:	e0823003 	add	r3, r2, r3
30033c50:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
30033c54:	e1a01003 	mov	r1, r3
30033c58:	e3a02905 	mov	r2, #81920	; 0x14000
30033c5c:	ebffdd96 	bl	3002b2bc <acoral_read>
30033c60:	e1a03000 	mov	r3, r0
30033c64:	e58d3028 	str	r3, [sp, #40]	; 0x28
		hdr[cur].update = 1;
30033c68:	e59d2020 	ldr	r2, [sp, #32]
30033c6c:	e59f0140 	ldr	r0, [pc, #320]	; 30033db4 <local_wav_file_read+0x4c8>
30033c70:	e3a01028 	mov	r1, #40	; 0x28
30033c74:	e1a03002 	mov	r3, r2
30033c78:	e1a03103 	lsl	r3, r3, #2
30033c7c:	e0833002 	add	r3, r3, r2
30033c80:	e1a03083 	lsl	r3, r3, #1
30033c84:	e0833002 	add	r3, r3, r2
30033c88:	e1a03103 	lsl	r3, r3, #2
30033c8c:	e0833000 	add	r3, r3, r0
30033c90:	e0833001 	add	r3, r3, r1
30033c94:	e3a02001 	mov	r2, #1
30033c98:	e5832000 	str	r2, [r3]
		hdr[cur].used = 1;
30033c9c:	e59d2020 	ldr	r2, [sp, #32]
30033ca0:	e59f010c 	ldr	r0, [pc, #268]	; 30033db4 <local_wav_file_read+0x4c8>
30033ca4:	e3a01024 	mov	r1, #36	; 0x24
30033ca8:	e1a03002 	mov	r3, r2
30033cac:	e1a03103 	lsl	r3, r3, #2
30033cb0:	e0833002 	add	r3, r3, r2
30033cb4:	e1a03083 	lsl	r3, r3, #1
30033cb8:	e0833002 	add	r3, r3, r2
30033cbc:	e1a03103 	lsl	r3, r3, #2
30033cc0:	e0833000 	add	r3, r3, r0
30033cc4:	e0833001 	add	r3, r3, r1
30033cc8:	e3a02001 	mov	r2, #1
30033ccc:	e5832000 	str	r2, [r3]
		if(acoral_sem_getnum(pcm_dma_buf_update_eve+cur))
30033cd0:	e59d2020 	ldr	r2, [sp, #32]
30033cd4:	e1a03002 	mov	r3, r2
30033cd8:	e1a03183 	lsl	r3, r3, #3
30033cdc:	e0833002 	add	r3, r3, r2
30033ce0:	e1a03103 	lsl	r3, r3, #2
30033ce4:	e1a02003 	mov	r2, r3
30033ce8:	e59f30c8 	ldr	r3, [pc, #200]	; 30033db8 <local_wav_file_read+0x4cc>
30033cec:	e0823003 	add	r3, r2, r3
30033cf0:	e1a00003 	mov	r0, r3
30033cf4:	ebff4f1e 	bl	30007974 <acoral_sem_getnum>
30033cf8:	e1a03000 	mov	r3, r0
30033cfc:	e3530000 	cmp	r3, #0
30033d00:	0a000009 	beq	30033d2c <local_wav_file_read+0x440>
			acoral_sem_post(pcm_dma_buf_update_eve+cur);
30033d04:	e59d2020 	ldr	r2, [sp, #32]
30033d08:	e1a03002 	mov	r3, r2
30033d0c:	e1a03183 	lsl	r3, r3, #3
30033d10:	e0833002 	add	r3, r3, r2
30033d14:	e1a03103 	lsl	r3, r3, #2
30033d18:	e1a02003 	mov	r2, r3
30033d1c:	e59f3094 	ldr	r3, [pc, #148]	; 30033db8 <local_wav_file_read+0x4cc>
30033d20:	e0823003 	add	r3, r2, r3
30033d24:	e1a00003 	mov	r0, r3
30033d28:	ebff4ecf 	bl	3000786c <acoral_sem_post>
		if(tmp != file_buf_block_size)
30033d2c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30033d30:	e3530905 	cmp	r3, #81920	; 0x14000
30033d34:	0a000007 	beq	30033d58 <local_wav_file_read+0x46c>
		if(cur == pcm_dma_buf_size)
			cur = 0;

		acoral_print("%d\n", i);
	}
	acoral_close(cur_file_ptr);
30033d38:	e59f3070 	ldr	r3, [pc, #112]	; 30033db0 <local_wav_file_read+0x4c4>
30033d3c:	e5933000 	ldr	r3, [r3]
30033d40:	e1a00003 	mov	r0, r3
30033d44:	ebffdd39 	bl	3002b230 <acoral_close>
	end_of_file = cur;
30033d48:	e59f3054 	ldr	r3, [pc, #84]	; 30033da4 <local_wav_file_read+0x4b8>
30033d4c:	e59d2020 	ldr	r2, [sp, #32]
30033d50:	e5832000 	str	r2, [r3]
30033d54:	ea00000e 	b	30033d94 <local_wav_file_read+0x4a8>
		hdr[cur].used = 1;
		if(acoral_sem_getnum(pcm_dma_buf_update_eve+cur))
			acoral_sem_post(pcm_dma_buf_update_eve+cur);
		if(tmp != file_buf_block_size)
			break;
		cur ++;
30033d58:	e59d3020 	ldr	r3, [sp, #32]
30033d5c:	e2833001 	add	r3, r3, #1
30033d60:	e58d3020 	str	r3, [sp, #32]
		i ++;
30033d64:	e59d301c 	ldr	r3, [sp, #28]
30033d68:	e2833001 	add	r3, r3, #1
30033d6c:	e58d301c 	str	r3, [sp, #28]
		if(cur == pcm_dma_buf_size)
30033d70:	e59d3020 	ldr	r3, [sp, #32]
30033d74:	e353000a 	cmp	r3, #10
30033d78:	1a000001 	bne	30033d84 <local_wav_file_read+0x498>
			cur = 0;
30033d7c:	e3a03000 	mov	r3, #0
30033d80:	e58d3020 	str	r3, [sp, #32]

		acoral_print("%d\n", i);
30033d84:	e59f0058 	ldr	r0, [pc, #88]	; 30033de4 <local_wav_file_read+0x4f8>
30033d88:	e59d101c 	ldr	r1, [sp, #28]
30033d8c:	ebff5d2b 	bl	3000b240 <acoral_print>
	}
30033d90:	eaffff77 	b	30033b74 <local_wav_file_read+0x288>
	acoral_close(cur_file_ptr);
	end_of_file = cur;
	while(1) {
			acoral_delay_self(5000);
30033d94:	e3a00d4e 	mov	r0, #4992	; 0x1380
30033d98:	e2800008 	add	r0, r0, #8
30033d9c:	ebff3af8 	bl	30002984 <acoral_delay_self>
	}
30033da0:	eafffffb 	b	30033d94 <local_wav_file_read+0x4a8>
30033da4:	300c6000 	.word	0x300c6000
30033da8:	3012b644 	.word	0x3012b644
30033dac:	300eaa24 	.word	0x300eaa24
30033db0:	302be6ac 	.word	0x302be6ac
30033db4:	302bf84c 	.word	0x302bf84c
30033db8:	302be6b0 	.word	0x302be6b0
30033dbc:	301f57a8 	.word	0x301f57a8
30033dc0:	3012d730 	.word	0x3012d730
30033dc4:	302be50c 	.word	0x302be50c
30033dc8:	30046098 	.word	0x30046098
30033dcc:	300338d8 	.word	0x300338d8
30033dd0:	3004608c 	.word	0x3004608c
30033dd4:	302bf844 	.word	0x302bf844
30033dd8:	30033220 	.word	0x30033220
30033ddc:	300460d8 	.word	0x300460d8
30033de0:	300eaab0 	.word	0x300eaab0
30033de4:	300460e8 	.word	0x300460e8

30033de8 <online_sel>:
acoral_u8 send_cmd[2];
acoral_u8 rec_cmd = 0;
char fileName[50];   //存放文件名
acoral_32 localFile = 0;   //本地文件

void online_sel(void) {
30033de8:	e92d4010 	push	{r4, lr}
30033dec:	e24dd018 	sub	sp, sp, #24
	void* tmp_trans;
	acoral_u8* trans;
	acoral_u8 tmp[8];
	int i;

	recv(sock_fd, (acoral_u64 *)&totalBytes, sizeof(acoral_u64), 0);
30033df0:	e59f324c 	ldr	r3, [pc, #588]	; 30034044 <online_sel+0x25c>
30033df4:	e5933000 	ldr	r3, [r3]
30033df8:	e1a00003 	mov	r0, r3
30033dfc:	e59f1244 	ldr	r1, [pc, #580]	; 30034048 <online_sel+0x260>
30033e00:	e3a02008 	mov	r2, #8
30033e04:	e3a03000 	mov	r3, #0
30033e08:	ebff7155 	bl	30010364 <lwip_recv>
	tmp_trans = &totalBytes;
30033e0c:	e59f3234 	ldr	r3, [pc, #564]	; 30034048 <online_sel+0x260>
30033e10:	e58d300c 	str	r3, [sp, #12]
	trans = tmp_trans;
30033e14:	e59d300c 	ldr	r3, [sp, #12]
30033e18:	e58d3010 	str	r3, [sp, #16]
	for(i=0; i<8; i++)
30033e1c:	e3a03000 	mov	r3, #0
30033e20:	e58d3014 	str	r3, [sp, #20]
30033e24:	ea00000d 	b	30033e60 <online_sel+0x78>
	   tmp[7-i] = trans[i];
30033e28:	e59d3014 	ldr	r3, [sp, #20]
30033e2c:	e2631007 	rsb	r1, r3, #7
30033e30:	e59d2014 	ldr	r2, [sp, #20]
30033e34:	e59d3010 	ldr	r3, [sp, #16]
30033e38:	e0823003 	add	r3, r2, r3
30033e3c:	e5d32000 	ldrb	r2, [r3]
30033e40:	e3e03013 	mvn	r3, #19
30033e44:	e28d0018 	add	r0, sp, #24
30033e48:	e0801001 	add	r1, r0, r1
30033e4c:	e0813003 	add	r3, r1, r3
30033e50:	e5c32000 	strb	r2, [r3]
	int i;

	recv(sock_fd, (acoral_u64 *)&totalBytes, sizeof(acoral_u64), 0);
	tmp_trans = &totalBytes;
	trans = tmp_trans;
	for(i=0; i<8; i++)
30033e54:	e59d3014 	ldr	r3, [sp, #20]
30033e58:	e2833001 	add	r3, r3, #1
30033e5c:	e58d3014 	str	r3, [sp, #20]
30033e60:	e59d3014 	ldr	r3, [sp, #20]
30033e64:	e3530007 	cmp	r3, #7
30033e68:	daffffee 	ble	30033e28 <online_sel+0x40>
	   tmp[7-i] = trans[i];
	for(i=0; i<8; i++)
30033e6c:	e3a03000 	mov	r3, #0
30033e70:	e58d3014 	str	r3, [sp, #20]
30033e74:	ea00000c 	b	30033eac <online_sel+0xc4>
	   trans[i] = tmp[i];
30033e78:	e59d2014 	ldr	r2, [sp, #20]
30033e7c:	e59d3010 	ldr	r3, [sp, #16]
30033e80:	e0823003 	add	r3, r2, r3
30033e84:	e59d1014 	ldr	r1, [sp, #20]
30033e88:	e3e02013 	mvn	r2, #19
30033e8c:	e28d0018 	add	r0, sp, #24
30033e90:	e0801001 	add	r1, r0, r1
30033e94:	e0812002 	add	r2, r1, r2
30033e98:	e5d22000 	ldrb	r2, [r2]
30033e9c:	e5c32000 	strb	r2, [r3]
	recv(sock_fd, (acoral_u64 *)&totalBytes, sizeof(acoral_u64), 0);
	tmp_trans = &totalBytes;
	trans = tmp_trans;
	for(i=0; i<8; i++)
	   tmp[7-i] = trans[i];
	for(i=0; i<8; i++)
30033ea0:	e59d3014 	ldr	r3, [sp, #20]
30033ea4:	e2833001 	add	r3, r3, #1
30033ea8:	e58d3014 	str	r3, [sp, #20]
30033eac:	e59d3014 	ldr	r3, [sp, #20]
30033eb0:	e3530007 	cmp	r3, #7
30033eb4:	daffffef 	ble	30033e78 <online_sel+0x90>
	   trans[i] = tmp[i];

    recv(sock_fd, (acoral_u64 *)&fileNameSize, sizeof(acoral_u64), 0);
30033eb8:	e59f3184 	ldr	r3, [pc, #388]	; 30034044 <online_sel+0x25c>
30033ebc:	e5933000 	ldr	r3, [r3]
30033ec0:	e1a00003 	mov	r0, r3
30033ec4:	e59f1180 	ldr	r1, [pc, #384]	; 3003404c <online_sel+0x264>
30033ec8:	e3a02008 	mov	r2, #8
30033ecc:	e3a03000 	mov	r3, #0
30033ed0:	ebff7123 	bl	30010364 <lwip_recv>
    tmp_trans = &fileNameSize;
30033ed4:	e59f3170 	ldr	r3, [pc, #368]	; 3003404c <online_sel+0x264>
30033ed8:	e58d300c 	str	r3, [sp, #12]
    trans = tmp_trans;
30033edc:	e59d300c 	ldr	r3, [sp, #12]
30033ee0:	e58d3010 	str	r3, [sp, #16]
    for(i=0; i<8; i++)
30033ee4:	e3a03000 	mov	r3, #0
30033ee8:	e58d3014 	str	r3, [sp, #20]
30033eec:	ea00000d 	b	30033f28 <online_sel+0x140>
    	 tmp[7-i] = trans[i];
30033ef0:	e59d3014 	ldr	r3, [sp, #20]
30033ef4:	e2631007 	rsb	r1, r3, #7
30033ef8:	e59d2014 	ldr	r2, [sp, #20]
30033efc:	e59d3010 	ldr	r3, [sp, #16]
30033f00:	e0823003 	add	r3, r2, r3
30033f04:	e5d32000 	ldrb	r2, [r3]
30033f08:	e3e03013 	mvn	r3, #19
30033f0c:	e28d0018 	add	r0, sp, #24
30033f10:	e0801001 	add	r1, r0, r1
30033f14:	e0813003 	add	r3, r1, r3
30033f18:	e5c32000 	strb	r2, [r3]
	   trans[i] = tmp[i];

    recv(sock_fd, (acoral_u64 *)&fileNameSize, sizeof(acoral_u64), 0);
    tmp_trans = &fileNameSize;
    trans = tmp_trans;
    for(i=0; i<8; i++)
30033f1c:	e59d3014 	ldr	r3, [sp, #20]
30033f20:	e2833001 	add	r3, r3, #1
30033f24:	e58d3014 	str	r3, [sp, #20]
30033f28:	e59d3014 	ldr	r3, [sp, #20]
30033f2c:	e3530007 	cmp	r3, #7
30033f30:	daffffee 	ble	30033ef0 <online_sel+0x108>
    	 tmp[7-i] = trans[i];
    for(i=0; i<8; i++)
30033f34:	e3a03000 	mov	r3, #0
30033f38:	e58d3014 	str	r3, [sp, #20]
30033f3c:	ea00000c 	b	30033f74 <online_sel+0x18c>
        trans[i] = tmp[i];
30033f40:	e59d2014 	ldr	r2, [sp, #20]
30033f44:	e59d3010 	ldr	r3, [sp, #16]
30033f48:	e0823003 	add	r3, r2, r3
30033f4c:	e59d1014 	ldr	r1, [sp, #20]
30033f50:	e3e02013 	mvn	r2, #19
30033f54:	e28d0018 	add	r0, sp, #24
30033f58:	e0801001 	add	r1, r0, r1
30033f5c:	e0812002 	add	r2, r1, r2
30033f60:	e5d22000 	ldrb	r2, [r2]
30033f64:	e5c32000 	strb	r2, [r3]
    recv(sock_fd, (acoral_u64 *)&fileNameSize, sizeof(acoral_u64), 0);
    tmp_trans = &fileNameSize;
    trans = tmp_trans;
    for(i=0; i<8; i++)
    	 tmp[7-i] = trans[i];
    for(i=0; i<8; i++)
30033f68:	e59d3014 	ldr	r3, [sp, #20]
30033f6c:	e2833001 	add	r3, r3, #1
30033f70:	e58d3014 	str	r3, [sp, #20]
30033f74:	e59d3014 	ldr	r3, [sp, #20]
30033f78:	e3530007 	cmp	r3, #7
30033f7c:	daffffef 	ble	30033f40 <online_sel+0x158>
        trans[i] = tmp[i];

	bytesReceived += 2*sizeof(acoral_u64);
30033f80:	e59f30c8 	ldr	r3, [pc, #200]	; 30034050 <online_sel+0x268>
30033f84:	e8930006 	ldm	r3, {r1, r2}
30033f88:	e3a03010 	mov	r3, #16
30033f8c:	e3a04000 	mov	r4, #0
30033f90:	e0933001 	adds	r3, r3, r1
30033f94:	e0a44002 	adc	r4, r4, r2
30033f98:	e59f20b0 	ldr	r2, [pc, #176]	; 30034050 <online_sel+0x268>
30033f9c:	e8820018 	stm	r2, {r3, r4}
	       //接收文件名，并建立文件
	recv(sock_fd, (char *)fileName, fileNameSize, 0);
30033fa0:	e59f309c 	ldr	r3, [pc, #156]	; 30034044 <online_sel+0x25c>
30033fa4:	e5932000 	ldr	r2, [r3]
30033fa8:	e59f309c 	ldr	r3, [pc, #156]	; 3003404c <online_sel+0x264>
30033fac:	e8930018 	ldm	r3, {r3, r4}
30033fb0:	e1a00002 	mov	r0, r2
30033fb4:	e59f1098 	ldr	r1, [pc, #152]	; 30034054 <online_sel+0x26c>
30033fb8:	e1a02003 	mov	r2, r3
30033fbc:	e3a03000 	mov	r3, #0
30033fc0:	ebff70e7 	bl	30010364 <lwip_recv>
	bytesReceived += fileNameSize;
30033fc4:	e59f3084 	ldr	r3, [pc, #132]	; 30034050 <online_sel+0x268>
30033fc8:	e8930006 	ldm	r3, {r1, r2}
30033fcc:	e59f3078 	ldr	r3, [pc, #120]	; 3003404c <online_sel+0x264>
30033fd0:	e8930018 	ldm	r3, {r3, r4}
30033fd4:	e0933001 	adds	r3, r3, r1
30033fd8:	e0a44002 	adc	r4, r4, r2
30033fdc:	e59f206c 	ldr	r2, [pc, #108]	; 30034050 <online_sel+0x268>
30033fe0:	e8820018 	stm	r2, {r3, r4}
	//localFile = acoral_open(fileName, O_RDWR);
	acoral_print("filename: %s\n", fileName);
30033fe4:	e59f006c 	ldr	r0, [pc, #108]	; 30034058 <online_sel+0x270>
30033fe8:	e59f1064 	ldr	r1, [pc, #100]	; 30034054 <online_sel+0x26c>
30033fec:	ebff5c93 	bl	3000b240 <acoral_print>
	if((fileName[2]=='m') || (fileName[2]=='M'))
30033ff0:	e59f305c 	ldr	r3, [pc, #92]	; 30034054 <online_sel+0x26c>
30033ff4:	e5d33002 	ldrb	r3, [r3, #2]
30033ff8:	e353006d 	cmp	r3, #109	; 0x6d
30033ffc:	0a000003 	beq	30034010 <online_sel+0x228>
30034000:	e59f304c 	ldr	r3, [pc, #76]	; 30034054 <online_sel+0x26c>
30034004:	e5d33002 	ldrb	r3, [r3, #2]
30034008:	e353004d 	cmp	r3, #77	; 0x4d
3003400c:	1a000000 	bne	30034014 <online_sel+0x22c>
		online_mp3_file_read();
30034010:	eb000212 	bl	30034860 <online_mp3_file_read>
	if((fileName[2]=='w') || (fileName[2]=='W'))
30034014:	e59f3038 	ldr	r3, [pc, #56]	; 30034054 <online_sel+0x26c>
30034018:	e5d33002 	ldrb	r3, [r3, #2]
3003401c:	e3530077 	cmp	r3, #119	; 0x77
30034020:	0a000003 	beq	30034034 <online_sel+0x24c>
30034024:	e59f3028 	ldr	r3, [pc, #40]	; 30034054 <online_sel+0x26c>
30034028:	e5d33002 	ldrb	r3, [r3, #2]
3003402c:	e3530057 	cmp	r3, #87	; 0x57
30034030:	1a000000 	bne	30034038 <online_sel+0x250>
		online_wav_file_read();
30034034:	eb0000a9 	bl	300342e0 <online_wav_file_read>

}
30034038:	e28dd018 	add	sp, sp, #24
3003403c:	e8bd4010 	pop	{r4, lr}
30034040:	e12fff1e 	bx	lr
30034044:	300e5968 	.word	0x300e5968
30034048:	300e5948 	.word	0x300e5948
3003404c:	300e5958 	.word	0x300e5958
30034050:	300e5950 	.word	0x300e5950
30034054:	300eaa7c 	.word	0x300eaa7c
30034058:	300460ec 	.word	0x300460ec

3003405c <client_init>:

int sock_fd = 0;
void client_init(void) {
3003405c:	e92d4010 	push	{r4, lr}

	totalBytes = 0;  //存放总大小信息  .....................remember to initialize it when reading a new file
30034060:	e59f21bc 	ldr	r2, [pc, #444]	; 30034224 <client_init+0x1c8>
30034064:	e3a03000 	mov	r3, #0
30034068:	e3a04000 	mov	r4, #0
3003406c:	e8820018 	stm	r2, {r3, r4}
	bytesReceived = 0;  //已收到数据的大小
30034070:	e59f21b0 	ldr	r2, [pc, #432]	; 30034228 <client_init+0x1cc>
30034074:	e3a03000 	mov	r3, #0
30034078:	e3a04000 	mov	r4, #0
3003407c:	e8820018 	stm	r2, {r3, r4}
	fileNameSize = 0;  //文件名的大小信息
30034080:	e59f21a4 	ldr	r2, [pc, #420]	; 3003422c <client_init+0x1d0>
30034084:	e3a03000 	mov	r3, #0
30034088:	e3a04000 	mov	r4, #0
3003408c:	e8820018 	stm	r2, {r3, r4}
	//send_cmd = 0;
	rec_cmd = 0;
30034090:	e59f3198 	ldr	r3, [pc, #408]	; 30034230 <client_init+0x1d4>
30034094:	e3a02000 	mov	r2, #0
30034098:	e5c32000 	strb	r2, [r3]
	sock_fd = 0;
3003409c:	e59f3190 	ldr	r3, [pc, #400]	; 30034234 <client_init+0x1d8>
300340a0:	e3a02000 	mov	r2, #0
300340a4:	e5832000 	str	r2, [r3]
	sock_fd = socket(AF_INET, SOCK_STREAM, 0);
300340a8:	e3a00002 	mov	r0, #2
300340ac:	e3a01001 	mov	r1, #1
300340b0:	e3a02000 	mov	r2, #0
300340b4:	ebff7174 	bl	3001068c <lwip_socket>
300340b8:	e1a02000 	mov	r2, r0
300340bc:	e59f3170 	ldr	r3, [pc, #368]	; 30034234 <client_init+0x1d8>
300340c0:	e5832000 	str	r2, [r3]
	if (sock_fd == -1) {
300340c4:	e59f3168 	ldr	r3, [pc, #360]	; 30034234 <client_init+0x1d8>
300340c8:	e5933000 	ldr	r3, [r3]
300340cc:	e3730001 	cmn	r3, #1
300340d0:	1a000002 	bne	300340e0 <client_init+0x84>
			acoral_print("failed to create sock_fd!\n");
300340d4:	e59f015c 	ldr	r0, [pc, #348]	; 30034238 <client_init+0x1dc>
300340d8:	ebff5c58 	bl	3000b240 <acoral_print>
			return ;
300340dc:	ea00004e 	b	3003421c <client_init+0x1c0>
	}
	memset(&server_addr, 0, sizeof(server_addr));
300340e0:	e59f0154 	ldr	r0, [pc, #340]	; 3003423c <client_init+0x1e0>
300340e4:	e3a01000 	mov	r1, #0
300340e8:	e3a02010 	mov	r2, #16
300340ec:	ebff605e 	bl	3000c26c <acoral_memset>
	server_addr.sin_family = AF_INET;
300340f0:	e59f3144 	ldr	r3, [pc, #324]	; 3003423c <client_init+0x1e0>
300340f4:	e3a02002 	mov	r2, #2
300340f8:	e5c32001 	strb	r2, [r3, #1]
	server_addr.sin_addr.s_addr = inet_addr("192.168.1.1");
300340fc:	e59f013c 	ldr	r0, [pc, #316]	; 30034240 <client_init+0x1e4>
30034100:	ebff7bce 	bl	30013040 <inet_addr>
30034104:	e1a02000 	mov	r2, r0
30034108:	e59f312c 	ldr	r3, [pc, #300]	; 3003423c <client_init+0x1e0>
3003410c:	e5832004 	str	r2, [r3, #4]
	server_addr.sin_port = htons(PORT);
30034110:	e3a00cc3 	mov	r0, #49920	; 0xc300
30034114:	e2800050 	add	r0, r0, #80	; 0x50
30034118:	ebff7d38 	bl	30013600 <htons>
3003411c:	e1a03000 	mov	r3, r0
30034120:	e1a02003 	mov	r2, r3
30034124:	e59f3110 	ldr	r3, [pc, #272]	; 3003423c <client_init+0x1e0>
30034128:	e1c320b2 	strh	r2, [r3, #2]

	while(1) {
		if(connect(sock_fd, (struct sockaddr *)&server_addr, sizeof(struct sockaddr)) != -1)
3003412c:	e59f3100 	ldr	r3, [pc, #256]	; 30034234 <client_init+0x1d8>
30034130:	e5932000 	ldr	r2, [r3]
30034134:	e59f3100 	ldr	r3, [pc, #256]	; 3003423c <client_init+0x1e0>
30034138:	e1a00002 	mov	r0, r2
3003413c:	e1a01003 	mov	r1, r3
30034140:	e3a02010 	mov	r2, #16
30034144:	ebff6edd 	bl	3000fcc0 <lwip_connect>
30034148:	e1a03000 	mov	r3, r0
3003414c:	e3730001 	cmn	r3, #1
30034150:	0a000011 	beq	3003419c <client_init+0x140>
			   break;
		acoral_delay_self(100);  // reconnect each 5s
	}

	acoral_print("connect !!\n");
30034154:	e59f00e8 	ldr	r0, [pc, #232]	; 30034244 <client_init+0x1e8>
30034158:	ebff5c38 	bl	3000b240 <acoral_print>
	send_cmd[0] = 0xff;
3003415c:	e59f30e4 	ldr	r3, [pc, #228]	; 30034248 <client_init+0x1ec>
30034160:	e3e02000 	mvn	r2, #0
30034164:	e5c32000 	strb	r2, [r3]
	send_cmd[1] = cur_song;
30034168:	e59f30dc 	ldr	r3, [pc, #220]	; 3003424c <client_init+0x1f0>
3003416c:	e5933000 	ldr	r3, [r3]
30034170:	e20320ff 	and	r2, r3, #255	; 0xff
30034174:	e59f30cc 	ldr	r3, [pc, #204]	; 30034248 <client_init+0x1ec>
30034178:	e5c32001 	strb	r2, [r3, #1]
	send(sock_fd, (acoral_u8 *)&send_cmd, sizeof(send_cmd), 0);
3003417c:	e59f30b0 	ldr	r3, [pc, #176]	; 30034234 <client_init+0x1d8>
30034180:	e5933000 	ldr	r3, [r3]
30034184:	e1a00003 	mov	r0, r3
30034188:	e59f10b8 	ldr	r1, [pc, #184]	; 30034248 <client_init+0x1ec>
3003418c:	e3a02002 	mov	r2, #2
30034190:	e3a03000 	mov	r3, #0
30034194:	ebff7086 	bl	300103b4 <lwip_send>
30034198:	ea000002 	b	300341a8 <client_init+0x14c>
	server_addr.sin_port = htons(PORT);

	while(1) {
		if(connect(sock_fd, (struct sockaddr *)&server_addr, sizeof(struct sockaddr)) != -1)
			   break;
		acoral_delay_self(100);  // reconnect each 5s
3003419c:	e3a00064 	mov	r0, #100	; 0x64
300341a0:	ebff39f7 	bl	30002984 <acoral_delay_self>
	}
300341a4:	eaffffe0 	b	3003412c <client_init+0xd0>
	send_cmd[1] = cur_song;
	send(sock_fd, (acoral_u8 *)&send_cmd, sizeof(send_cmd), 0);
	//send_cmd = cur_song;
	//send(sock_fd, (acoral_u8 *)&send_cmd, sizeof(send_cmd), 0);
	while(1) {
		 recv(sock_fd, (acoral_u8 *)&rec_cmd, sizeof(acoral_u8), 0);
300341a8:	e59f3084 	ldr	r3, [pc, #132]	; 30034234 <client_init+0x1d8>
300341ac:	e5933000 	ldr	r3, [r3]
300341b0:	e1a00003 	mov	r0, r3
300341b4:	e59f1074 	ldr	r1, [pc, #116]	; 30034230 <client_init+0x1d4>
300341b8:	e3a02001 	mov	r2, #1
300341bc:	e3a03000 	mov	r3, #0
300341c0:	ebff7067 	bl	30010364 <lwip_recv>
		 if(rec_cmd == 0xee) {
300341c4:	e59f3064 	ldr	r3, [pc, #100]	; 30034230 <client_init+0x1d4>
300341c8:	e5d33000 	ldrb	r3, [r3]
300341cc:	e35300ee 	cmp	r3, #238	; 0xee
300341d0:	1a00000e 	bne	30034210 <client_init+0x1b4>
			 //online_mp3_file_read();
			 recv(sock_fd, (acoral_u8 *)&rec_cmd, sizeof(acoral_u8), 0);
300341d4:	e59f3058 	ldr	r3, [pc, #88]	; 30034234 <client_init+0x1d8>
300341d8:	e5933000 	ldr	r3, [r3]
300341dc:	e1a00003 	mov	r0, r3
300341e0:	e59f1048 	ldr	r1, [pc, #72]	; 30034230 <client_init+0x1d4>
300341e4:	e3a02001 	mov	r2, #1
300341e8:	e3a03000 	mov	r3, #0
300341ec:	ebff705c 	bl	30010364 <lwip_recv>
			 song_num = (int)rec_cmd;
300341f0:	e59f3038 	ldr	r3, [pc, #56]	; 30034230 <client_init+0x1d4>
300341f4:	e5d33000 	ldrb	r3, [r3]
300341f8:	e1a02003 	mov	r2, r3
300341fc:	e59f304c 	ldr	r3, [pc, #76]	; 30034250 <client_init+0x1f4>
30034200:	e5832000 	str	r2, [r3]
			 online_sel();
30034204:	ebfffef7 	bl	30033de8 <online_sel>
			 break;
30034208:	e1a00000 	nop			; (mov r0, r0)
3003420c:	ea000002 	b	3003421c <client_init+0x1c0>
		 }
		 else
			 acoral_delay_self(200);
30034210:	e3a000c8 	mov	r0, #200	; 0xc8
30034214:	ebff39da 	bl	30002984 <acoral_delay_self>
	}
30034218:	eaffffe2 	b	300341a8 <client_init+0x14c>

}
3003421c:	e8bd4010 	pop	{r4, lr}
30034220:	e12fff1e 	bx	lr
30034224:	300e5948 	.word	0x300e5948
30034228:	300e5950 	.word	0x300e5950
3003422c:	300e5958 	.word	0x300e5958
30034230:	300e5960 	.word	0x300e5960
30034234:	300e5968 	.word	0x300e5968
30034238:	300460fc 	.word	0x300460fc
3003423c:	300ea478 	.word	0x300ea478
30034240:	30046118 	.word	0x30046118
30034244:	30046124 	.word	0x30046124
30034248:	302be3d8 	.word	0x302be3d8
3003424c:	300e58c0 	.word	0x300e58c0
30034250:	3012b680 	.word	0x3012b680

30034254 <client_close>:

void client_close(void) {
30034254:	e92d4008 	push	{r3, lr}
	if(sock_fd) {
30034258:	e59f302c 	ldr	r3, [pc, #44]	; 3003428c <client_close+0x38>
3003425c:	e5933000 	ldr	r3, [r3]
30034260:	e3530000 	cmp	r3, #0
30034264:	0a000006 	beq	30034284 <client_close+0x30>
		closesocket(sock_fd);
30034268:	e59f301c 	ldr	r3, [pc, #28]	; 3003428c <client_close+0x38>
3003426c:	e5933000 	ldr	r3, [r3]
30034270:	e1a00003 	mov	r0, r3
30034274:	ebff6e5f 	bl	3000fbf8 <lwip_close>
		sock_fd = 0;
30034278:	e59f300c 	ldr	r3, [pc, #12]	; 3003428c <client_close+0x38>
3003427c:	e3a02000 	mov	r2, #0
30034280:	e5832000 	str	r2, [r3]
	}
}
30034284:	e8bd4008 	pop	{r3, lr}
30034288:	e12fff1e 	bx	lr
3003428c:	300e5968 	.word	0x300e5968

30034290 <min>:


acoral_u64 min(acoral_u64 a, acoral_u64 b) {
30034290:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
30034294:	e24dd014 	sub	sp, sp, #20
30034298:	e58d0008 	str	r0, [sp, #8]
3003429c:	e58d100c 	str	r1, [sp, #12]
300342a0:	e88d000c 	stm	sp, {r2, r3}
	if(a > b)
300342a4:	e28d2008 	add	r2, sp, #8
300342a8:	e8920006 	ldm	r2, {r1, r2}
300342ac:	e89d0018 	ldm	sp, {r3, r4}
300342b0:	e1520004 	cmp	r2, r4
300342b4:	01510003 	cmpeq	r1, r3
300342b8:	9a000001 	bls	300342c4 <min+0x34>
		return b;
300342bc:	e89d0018 	ldm	sp, {r3, r4}
300342c0:	ea000001 	b	300342cc <min+0x3c>
	else
		return a;
300342c4:	e28d4008 	add	r4, sp, #8
300342c8:	e8940018 	ldm	r4, {r3, r4}
}
300342cc:	e1a00003 	mov	r0, r3
300342d0:	e1a01004 	mov	r1, r4
300342d4:	e28dd014 	add	sp, sp, #20
300342d8:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
300342dc:	e12fff1e 	bx	lr

300342e0 <online_wav_file_read>:

void online_wav_file_read(void) {
300342e0:	e92d4010 	push	{r4, lr}
300342e4:	e24dd030 	sub	sp, sp, #48	; 0x30

	int i;
	int count = 0;
300342e8:	e3a03000 	mov	r3, #0
300342ec:	e58d3014 	str	r3, [sp, #20]
	int cur = 0;
300342f0:	e3a03000 	mov	r3, #0
300342f4:	e58d3018 	str	r3, [sp, #24]
	int first = 1;
300342f8:	e3a03001 	mov	r3, #1
300342fc:	e58d301c 	str	r3, [sp, #28]
	acoral_slice_policy_data_t data;
	end_of_file = -1;
30034300:	e59f3508 	ldr	r3, [pc, #1288]	; 30034810 <online_wav_file_read+0x530>
30034304:	e3e02000 	mvn	r2, #0
30034308:	e5832000 	str	r2, [r3]
	data.cpu = 0;
3003430c:	e3a03000 	mov	r3, #0
30034310:	e5cd3008 	strb	r3, [sp, #8]
	data.prio = 18;
30034314:	e3a03012 	mov	r3, #18
30034318:	e5cd3009 	strb	r3, [sp, #9]
	data.slice = 100;
3003431c:	e3a03064 	mov	r3, #100	; 0x64
30034320:	e58d300c 	str	r3, [sp, #12]

	for(i=0; i<pcm_dma_buf_size; i++) {
30034324:	e3a03000 	mov	r3, #0
30034328:	e58d3010 	str	r3, [sp, #16]
3003432c:	ea000032 	b	300343fc <online_wav_file_read+0x11c>
			hdr[i].used = 0;
30034330:	e59d2010 	ldr	r2, [sp, #16]
30034334:	e59f04d8 	ldr	r0, [pc, #1240]	; 30034814 <online_wav_file_read+0x534>
30034338:	e3a01024 	mov	r1, #36	; 0x24
3003433c:	e1a03002 	mov	r3, r2
30034340:	e1a03103 	lsl	r3, r3, #2
30034344:	e0833002 	add	r3, r3, r2
30034348:	e1a03083 	lsl	r3, r3, #1
3003434c:	e0833002 	add	r3, r3, r2
30034350:	e1a03103 	lsl	r3, r3, #2
30034354:	e0833000 	add	r3, r3, r0
30034358:	e0833001 	add	r3, r3, r1
3003435c:	e3a02000 	mov	r2, #0
30034360:	e5832000 	str	r2, [r3]
			hdr[i].update = 0;
30034364:	e59d2010 	ldr	r2, [sp, #16]
30034368:	e59f04a4 	ldr	r0, [pc, #1188]	; 30034814 <online_wav_file_read+0x534>
3003436c:	e3a01028 	mov	r1, #40	; 0x28
30034370:	e1a03002 	mov	r3, r2
30034374:	e1a03103 	lsl	r3, r3, #2
30034378:	e0833002 	add	r3, r3, r2
3003437c:	e1a03083 	lsl	r3, r3, #1
30034380:	e0833002 	add	r3, r3, r2
30034384:	e1a03103 	lsl	r3, r3, #2
30034388:	e0833000 	add	r3, r3, r0
3003438c:	e0833001 	add	r3, r3, r1
30034390:	e3a02000 	mov	r2, #0
30034394:	e5832000 	str	r2, [r3]
			acoral_sem_init(pcm_dma_buf_update_eve+i, 0);
30034398:	e59d2010 	ldr	r2, [sp, #16]
3003439c:	e1a03002 	mov	r3, r2
300343a0:	e1a03183 	lsl	r3, r3, #3
300343a4:	e0833002 	add	r3, r3, r2
300343a8:	e1a03103 	lsl	r3, r3, #2
300343ac:	e1a02003 	mov	r2, r3
300343b0:	e59f3460 	ldr	r3, [pc, #1120]	; 30034818 <online_wav_file_read+0x538>
300343b4:	e0823003 	add	r3, r2, r3
300343b8:	e1a00003 	mov	r0, r3
300343bc:	e3a01000 	mov	r1, #0
300343c0:	ebff4c2a 	bl	30007470 <acoral_sem_init>
			acoral_sem_init(pcm_dma_buf_playdone_eve+i, 0);
300343c4:	e59d2010 	ldr	r2, [sp, #16]
300343c8:	e1a03002 	mov	r3, r2
300343cc:	e1a03183 	lsl	r3, r3, #3
300343d0:	e0833002 	add	r3, r3, r2
300343d4:	e1a03103 	lsl	r3, r3, #2
300343d8:	e1a02003 	mov	r2, r3
300343dc:	e59f3438 	ldr	r3, [pc, #1080]	; 3003481c <online_wav_file_read+0x53c>
300343e0:	e0823003 	add	r3, r2, r3
300343e4:	e1a00003 	mov	r0, r3
300343e8:	e3a01000 	mov	r1, #0
300343ec:	ebff4c1f 	bl	30007470 <acoral_sem_init>
	end_of_file = -1;
	data.cpu = 0;
	data.prio = 18;
	data.slice = 100;

	for(i=0; i<pcm_dma_buf_size; i++) {
300343f0:	e59d3010 	ldr	r3, [sp, #16]
300343f4:	e2833001 	add	r3, r3, #1
300343f8:	e58d3010 	str	r3, [sp, #16]
300343fc:	e59d3010 	ldr	r3, [sp, #16]
30034400:	e3530009 	cmp	r3, #9
30034404:	daffffc9 	ble	30034330 <online_wav_file_read+0x50>
			acoral_sem_init(pcm_dma_buf_playdone_eve+i, 0);
	}

	//acoral_create_thread(file_pcm_player,8192*16,NULL,"file_pcm_player",20,0);

	i = 0;
30034408:	e3a03000 	mov	r3, #0
3003440c:	e58d3010 	str	r3, [sp, #16]
    while(bytesReceived < totalBytes) {
30034410:	ea0000ee 	b	300347d0 <online_wav_file_read+0x4f0>
	       //如果接收的数据小于总数据，那么写入文件
    	 if(hdr[cur].used)
30034414:	e59d2018 	ldr	r2, [sp, #24]
30034418:	e59f03f4 	ldr	r0, [pc, #1012]	; 30034814 <online_wav_file_read+0x534>
3003441c:	e3a01024 	mov	r1, #36	; 0x24
30034420:	e1a03002 	mov	r3, r2
30034424:	e1a03103 	lsl	r3, r3, #2
30034428:	e0833002 	add	r3, r3, r2
3003442c:	e1a03083 	lsl	r3, r3, #1
30034430:	e0833002 	add	r3, r3, r2
30034434:	e1a03103 	lsl	r3, r3, #2
30034438:	e0833000 	add	r3, r3, r0
3003443c:	e0833001 	add	r3, r3, r1
30034440:	e5933000 	ldr	r3, [r3]
30034444:	e3530000 	cmp	r3, #0
30034448:	0a00000a 	beq	30034478 <online_wav_file_read+0x198>
    		acoral_sem_pend(pcm_dma_buf_playdone_eve+cur, 0);
3003444c:	e59d2018 	ldr	r2, [sp, #24]
30034450:	e1a03002 	mov	r3, r2
30034454:	e1a03183 	lsl	r3, r3, #3
30034458:	e0833002 	add	r3, r3, r2
3003445c:	e1a03103 	lsl	r3, r3, #2
30034460:	e1a02003 	mov	r2, r3
30034464:	e59f33b0 	ldr	r3, [pc, #944]	; 3003481c <online_wav_file_read+0x53c>
30034468:	e0823003 	add	r3, r2, r3
3003446c:	e1a00003 	mov	r0, r3
30034470:	e3a01000 	mov	r1, #0
30034474:	ebff4c91 	bl	300076c0 <acoral_sem_pend>
    	 acoral_u64 tmp_size = min(8192, (totalBytes-bytesReceived));
30034478:	e59f33a0 	ldr	r3, [pc, #928]	; 30034820 <online_wav_file_read+0x540>
3003447c:	e8930006 	ldm	r3, {r1, r2}
30034480:	e59f339c 	ldr	r3, [pc, #924]	; 30034824 <online_wav_file_read+0x544>
30034484:	e8930018 	ldm	r3, {r3, r4}
30034488:	e0513003 	subs	r3, r1, r3
3003448c:	e0c24004 	sbc	r4, r2, r4
30034490:	e3a00a02 	mov	r0, #8192	; 0x2000
30034494:	e3a01000 	mov	r1, #0
30034498:	e1a02003 	mov	r2, r3
3003449c:	e1a03004 	mov	r3, r4
300344a0:	ebffff7a 	bl	30034290 <min>
300344a4:	e1a03000 	mov	r3, r0
300344a8:	e1a04001 	mov	r4, r1
300344ac:	e58d3020 	str	r3, [sp, #32]
300344b0:	e58d4024 	str	r4, [sp, #36]	; 0x24
		 //send_cmd = 0xfe;
		 send_cmd[0] = 0xfe;
300344b4:	e59f336c 	ldr	r3, [pc, #876]	; 30034828 <online_wav_file_read+0x548>
300344b8:	e3e02001 	mvn	r2, #1
300344bc:	e5c32000 	strb	r2, [r3]
		 send_cmd[1] = 0xff;
300344c0:	e59f3360 	ldr	r3, [pc, #864]	; 30034828 <online_wav_file_read+0x548>
300344c4:	e3e02000 	mvn	r2, #0
300344c8:	e5c32001 	strb	r2, [r3, #1]
    	 send(sock_fd, (acoral_u8 *)&send_cmd, sizeof(send_cmd), 0);
300344cc:	e59f3358 	ldr	r3, [pc, #856]	; 3003482c <online_wav_file_read+0x54c>
300344d0:	e5933000 	ldr	r3, [r3]
300344d4:	e1a00003 	mov	r0, r3
300344d8:	e59f1348 	ldr	r1, [pc, #840]	; 30034828 <online_wav_file_read+0x548>
300344dc:	e3a02002 	mov	r2, #2
300344e0:	e3a03000 	mov	r3, #0
300344e4:	ebff6fb2 	bl	300103b4 <lwip_send>
		 //Delay(75);
		 recv(sock_fd, (unsigned char *)(&file_wav_buf[cur][i*8192]), tmp_size, 0);
300344e8:	e59f333c 	ldr	r3, [pc, #828]	; 3003482c <online_wav_file_read+0x54c>
300344ec:	e5931000 	ldr	r1, [r3]
300344f0:	e59d2018 	ldr	r2, [sp, #24]
300344f4:	e1a03002 	mov	r3, r2
300344f8:	e1a03103 	lsl	r3, r3, #2
300344fc:	e0833002 	add	r3, r3, r2
30034500:	e1a03083 	lsl	r3, r3, #1
30034504:	e1a02003 	mov	r2, r3
30034508:	e59d3010 	ldr	r3, [sp, #16]
3003450c:	e0823003 	add	r3, r2, r3
30034510:	e1a02683 	lsl	r2, r3, #13
30034514:	e59f3314 	ldr	r3, [pc, #788]	; 30034830 <online_wav_file_read+0x550>
30034518:	e0822003 	add	r2, r2, r3
3003451c:	e59d3020 	ldr	r3, [sp, #32]
30034520:	e1a00001 	mov	r0, r1
30034524:	e1a01002 	mov	r1, r2
30034528:	e1a02003 	mov	r2, r3
3003452c:	e3a03000 	mov	r3, #0
30034530:	ebff6f8b 	bl	30010364 <lwip_recv>

		 bytesReceived = bytesReceived + tmp_size;
30034534:	e59f32e8 	ldr	r3, [pc, #744]	; 30034824 <online_wav_file_read+0x544>
30034538:	e8930006 	ldm	r3, {r1, r2}
3003453c:	e28d4020 	add	r4, sp, #32
30034540:	e8940018 	ldm	r4, {r3, r4}
30034544:	e0933001 	adds	r3, r3, r1
30034548:	e0a44002 	adc	r4, r4, r2
3003454c:	e59f22d0 	ldr	r2, [pc, #720]	; 30034824 <online_wav_file_read+0x544>
30034550:	e8820018 	stm	r2, {r3, r4}
	//	 acoral_write(localFile, rec, tmp_size);
		// acoral_flush();
		 if(count == 0) {
30034554:	e59d3014 	ldr	r3, [sp, #20]
30034558:	e3530000 	cmp	r3, #0
3003455c:	1a00002f 	bne	30034620 <online_wav_file_read+0x340>
				unsigned char* ptr;
				ptr = file_wav_buf[cur];
30034560:	e59f12c8 	ldr	r1, [pc, #712]	; 30034830 <online_wav_file_read+0x550>
30034564:	e59d2018 	ldr	r2, [sp, #24]
30034568:	e1a03002 	mov	r3, r2
3003456c:	e1a03103 	lsl	r3, r3, #2
30034570:	e0833002 	add	r3, r3, r2
30034574:	e1a03703 	lsl	r3, r3, #14
30034578:	e0813003 	add	r3, r1, r3
3003457c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
				fmt.wFormatTag = WAVE_FORMAT_PCM;
30034580:	e59f32ac 	ldr	r3, [pc, #684]	; 30034834 <online_wav_file_read+0x554>
30034584:	e3a02001 	mov	r2, #1
30034588:	e1c320b0 	strh	r2, [r3]
				fmt.nChannels		= *(acoral_u16 *)(ptr+0x16);
3003458c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30034590:	e2833016 	add	r3, r3, #22
30034594:	e1d320b0 	ldrh	r2, [r3]
30034598:	e59f3294 	ldr	r3, [pc, #660]	; 30034834 <online_wav_file_read+0x554>
3003459c:	e1c320b2 	strh	r2, [r3, #2]
				fmt.nSamplesPerSec	= *(acoral_u32 *)(ptr+0x18);
300345a0:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300345a4:	e2833018 	add	r3, r3, #24
300345a8:	e5932000 	ldr	r2, [r3]
300345ac:	e59f3280 	ldr	r3, [pc, #640]	; 30034834 <online_wav_file_read+0x554>
300345b0:	e5832004 	str	r2, [r3, #4]
				fmt.nAvgBytesPerSec	= *(acoral_u32 *)(ptr+0x1c);
300345b4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300345b8:	e283301c 	add	r3, r3, #28
300345bc:	e5932000 	ldr	r2, [r3]
300345c0:	e59f326c 	ldr	r3, [pc, #620]	; 30034834 <online_wav_file_read+0x554>
300345c4:	e5832008 	str	r2, [r3, #8]
				fmt.nBlockAlign		= *(acoral_u16 *)(ptr+0x20);
300345c8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300345cc:	e2833020 	add	r3, r3, #32
300345d0:	e1d320b0 	ldrh	r2, [r3]
300345d4:	e59f3258 	ldr	r3, [pc, #600]	; 30034834 <online_wav_file_read+0x554>
300345d8:	e1c320bc 	strh	r2, [r3, #12]
				fmt.wBitsPerSample	= *(acoral_u16 *)(ptr+0x22);
300345dc:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300345e0:	e2833022 	add	r3, r3, #34	; 0x22
300345e4:	e1d320b0 	ldrh	r2, [r3]
300345e8:	e59f3244 	ldr	r3, [pc, #580]	; 30034834 <online_wav_file_read+0x554>
300345ec:	e1c320be 	strh	r2, [r3, #14]
				acoral_print("\nSample Rate = %d, Channels = %d, %dBitsPerSample, size = %d\n",
300345f0:	e59f323c 	ldr	r3, [pc, #572]	; 30034834 <online_wav_file_read+0x554>
300345f4:	e5931004 	ldr	r1, [r3, #4]
							fmt.nSamplesPerSec, fmt.nChannels, fmt.wBitsPerSample, fmt.nChannels);
300345f8:	e59f3234 	ldr	r3, [pc, #564]	; 30034834 <online_wav_file_read+0x554>
300345fc:	e1d330b2 	ldrh	r3, [r3, #2]
				fmt.nChannels		= *(acoral_u16 *)(ptr+0x16);
				fmt.nSamplesPerSec	= *(acoral_u32 *)(ptr+0x18);
				fmt.nAvgBytesPerSec	= *(acoral_u32 *)(ptr+0x1c);
				fmt.nBlockAlign		= *(acoral_u16 *)(ptr+0x20);
				fmt.wBitsPerSample	= *(acoral_u16 *)(ptr+0x22);
				acoral_print("\nSample Rate = %d, Channels = %d, %dBitsPerSample, size = %d\n",
30034600:	e1a02003 	mov	r2, r3
							fmt.nSamplesPerSec, fmt.nChannels, fmt.wBitsPerSample, fmt.nChannels);
30034604:	e59f3228 	ldr	r3, [pc, #552]	; 30034834 <online_wav_file_read+0x554>
30034608:	e1d330be 	ldrh	r3, [r3, #14]
3003460c:	e59f0220 	ldr	r0, [pc, #544]	; 30034834 <online_wav_file_read+0x554>
30034610:	e1d000b2 	ldrh	r0, [r0, #2]
				fmt.nChannels		= *(acoral_u16 *)(ptr+0x16);
				fmt.nSamplesPerSec	= *(acoral_u32 *)(ptr+0x18);
				fmt.nAvgBytesPerSec	= *(acoral_u32 *)(ptr+0x1c);
				fmt.nBlockAlign		= *(acoral_u16 *)(ptr+0x20);
				fmt.wBitsPerSample	= *(acoral_u16 *)(ptr+0x22);
				acoral_print("\nSample Rate = %d, Channels = %d, %dBitsPerSample, size = %d\n",
30034614:	e58d0000 	str	r0, [sp]
30034618:	e59f0218 	ldr	r0, [pc, #536]	; 30034838 <online_wav_file_read+0x558>
3003461c:	ebff5b07 	bl	3000b240 <acoral_print>
				waveOutOpen(&hwo, 0,&fmt,0,0,0);
				//waveOutGetVolume(0,	&volume);
				volume = 50000;
				waveOutSetVolume(0, volume);*/
		 }
		 count ++;
30034620:	e59d3014 	ldr	r3, [sp, #20]
30034624:	e2833001 	add	r3, r3, #1
30034628:	e58d3014 	str	r3, [sp, #20]
		 i ++;
3003462c:	e59d3010 	ldr	r3, [sp, #16]
30034630:	e2833001 	add	r3, r3, #1
30034634:	e58d3010 	str	r3, [sp, #16]

		 if(i == 10) {
30034638:	e59d3010 	ldr	r3, [sp, #16]
3003463c:	e353000a 	cmp	r3, #10
30034640:	1a000035 	bne	3003471c <online_wav_file_read+0x43c>
			 hdr[cur].update = 1;
30034644:	e59d2018 	ldr	r2, [sp, #24]
30034648:	e59f01c4 	ldr	r0, [pc, #452]	; 30034814 <online_wav_file_read+0x534>
3003464c:	e3a01028 	mov	r1, #40	; 0x28
30034650:	e1a03002 	mov	r3, r2
30034654:	e1a03103 	lsl	r3, r3, #2
30034658:	e0833002 	add	r3, r3, r2
3003465c:	e1a03083 	lsl	r3, r3, #1
30034660:	e0833002 	add	r3, r3, r2
30034664:	e1a03103 	lsl	r3, r3, #2
30034668:	e0833000 	add	r3, r3, r0
3003466c:	e0833001 	add	r3, r3, r1
30034670:	e3a02001 	mov	r2, #1
30034674:	e5832000 	str	r2, [r3]
			 hdr[cur].used = 1;
30034678:	e59d2018 	ldr	r2, [sp, #24]
3003467c:	e59f0190 	ldr	r0, [pc, #400]	; 30034814 <online_wav_file_read+0x534>
30034680:	e3a01024 	mov	r1, #36	; 0x24
30034684:	e1a03002 	mov	r3, r2
30034688:	e1a03103 	lsl	r3, r3, #2
3003468c:	e0833002 	add	r3, r3, r2
30034690:	e1a03083 	lsl	r3, r3, #1
30034694:	e0833002 	add	r3, r3, r2
30034698:	e1a03103 	lsl	r3, r3, #2
3003469c:	e0833000 	add	r3, r3, r0
300346a0:	e0833001 	add	r3, r3, r1
300346a4:	e3a02001 	mov	r2, #1
300346a8:	e5832000 	str	r2, [r3]
			 if(acoral_sem_getnum(pcm_dma_buf_update_eve+cur))
300346ac:	e59d2018 	ldr	r2, [sp, #24]
300346b0:	e1a03002 	mov	r3, r2
300346b4:	e1a03183 	lsl	r3, r3, #3
300346b8:	e0833002 	add	r3, r3, r2
300346bc:	e1a03103 	lsl	r3, r3, #2
300346c0:	e1a02003 	mov	r2, r3
300346c4:	e59f314c 	ldr	r3, [pc, #332]	; 30034818 <online_wav_file_read+0x538>
300346c8:	e0823003 	add	r3, r2, r3
300346cc:	e1a00003 	mov	r0, r3
300346d0:	ebff4ca7 	bl	30007974 <acoral_sem_getnum>
300346d4:	e1a03000 	mov	r3, r0
300346d8:	e3530000 	cmp	r3, #0
300346dc:	0a000009 	beq	30034708 <online_wav_file_read+0x428>
				acoral_sem_post(pcm_dma_buf_update_eve+cur);
300346e0:	e59d2018 	ldr	r2, [sp, #24]
300346e4:	e1a03002 	mov	r3, r2
300346e8:	e1a03183 	lsl	r3, r3, #3
300346ec:	e0833002 	add	r3, r3, r2
300346f0:	e1a03103 	lsl	r3, r3, #2
300346f4:	e1a02003 	mov	r2, r3
300346f8:	e59f3118 	ldr	r3, [pc, #280]	; 30034818 <online_wav_file_read+0x538>
300346fc:	e0823003 	add	r3, r2, r3
30034700:	e1a00003 	mov	r0, r3
30034704:	ebff4c58 	bl	3000786c <acoral_sem_post>
			 hdr[cur].dwBufferLength = file_buf_block_size;
			 hdr[cur].pcm_dma_buf_cur = cur;
			 hdr[cur].used = 1;
			 waveOutWrite(0,&hdr[cur], 0);
		*/
			i = 0;
30034708:	e3a03000 	mov	r3, #0
3003470c:	e58d3010 	str	r3, [sp, #16]
			cur ++;
30034710:	e59d3018 	ldr	r3, [sp, #24]
30034714:	e2833001 	add	r3, r3, #1
30034718:	e58d3018 	str	r3, [sp, #24]
		 }

		 if(first && (cur == 3)) {
3003471c:	e59d301c 	ldr	r3, [sp, #28]
30034720:	e3530000 	cmp	r3, #0
30034724:	0a00001e 	beq	300347a4 <online_wav_file_read+0x4c4>
30034728:	e59d3018 	ldr	r3, [sp, #24]
3003472c:	e3530003 	cmp	r3, #3
30034730:	1a00001b 	bne	300347a4 <online_wav_file_read+0x4c4>
			 first = 0;
30034734:	e3a03000 	mov	r3, #0
30034738:	e58d301c 	str	r3, [sp, #28]
			 //pcm_player_id = acoral_create_thread_ext(file_pcm_player, 8192*16, 0, "file_pcm_player", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
			 pcm_player_id = acoral_create_thread(file_pcm_player,8192*16,NULL,"file_pcm_player",21,0);
3003473c:	e59f30f8 	ldr	r3, [pc, #248]	; 3003483c <online_wav_file_read+0x55c>
30034740:	e3a02015 	mov	r2, #21
30034744:	e58d2000 	str	r2, [sp]
30034748:	e3a02000 	mov	r2, #0
3003474c:	e58d2004 	str	r2, [sp, #4]
30034750:	e1a00003 	mov	r0, r3
30034754:	e3a01802 	mov	r1, #131072	; 0x20000
30034758:	e3a02000 	mov	r2, #0
3003475c:	e59f30dc 	ldr	r3, [pc, #220]	; 30034840 <online_wav_file_read+0x560>
30034760:	ebff3a0f 	bl	30002fa4 <create_comm_thread>
30034764:	e1a02000 	mov	r2, r0
30034768:	e59f30d4 	ldr	r3, [pc, #212]	; 30034844 <online_wav_file_read+0x564>
3003476c:	e5832000 	str	r2, [r3]
			 mp3_decoder_id = acoral_create_thread(mp3_mask,8192*16,NULL,"mp3_decoder",25,0);
30034770:	e59f30d0 	ldr	r3, [pc, #208]	; 30034848 <online_wav_file_read+0x568>
30034774:	e3a02019 	mov	r2, #25
30034778:	e58d2000 	str	r2, [sp]
3003477c:	e3a02000 	mov	r2, #0
30034780:	e58d2004 	str	r2, [sp, #4]
30034784:	e1a00003 	mov	r0, r3
30034788:	e3a01802 	mov	r1, #131072	; 0x20000
3003478c:	e3a02000 	mov	r2, #0
30034790:	e59f30b4 	ldr	r3, [pc, #180]	; 3003484c <online_wav_file_read+0x56c>
30034794:	ebff3a02 	bl	30002fa4 <create_comm_thread>
30034798:	e1a02000 	mov	r2, r0
3003479c:	e59f30ac 	ldr	r3, [pc, #172]	; 30034850 <online_wav_file_read+0x570>
300347a0:	e5832000 	str	r2, [r3]
		 }

		 if(cur == pcm_dma_buf_size)
300347a4:	e59d3018 	ldr	r3, [sp, #24]
300347a8:	e353000a 	cmp	r3, #10
300347ac:	1a000001 	bne	300347b8 <online_wav_file_read+0x4d8>
			 cur = 0;
300347b0:	e3a03000 	mov	r3, #0
300347b4:	e58d3018 	str	r3, [sp, #24]
		 acoral_print("recive96 : %d  info: %2x\n", count, rec[23]);
300347b8:	e59f3094 	ldr	r3, [pc, #148]	; 30034854 <online_wav_file_read+0x574>
300347bc:	e5d33017 	ldrb	r3, [r3, #23]
300347c0:	e59f0090 	ldr	r0, [pc, #144]	; 30034858 <online_wav_file_read+0x578>
300347c4:	e59d1014 	ldr	r1, [sp, #20]
300347c8:	e1a02003 	mov	r2, r3
300347cc:	ebff5a9b 	bl	3000b240 <acoral_print>
	}

	//acoral_create_thread(file_pcm_player,8192*16,NULL,"file_pcm_player",20,0);

	i = 0;
    while(bytesReceived < totalBytes) {
300347d0:	e59f304c 	ldr	r3, [pc, #76]	; 30034824 <online_wav_file_read+0x544>
300347d4:	e8930006 	ldm	r3, {r1, r2}
300347d8:	e59f3040 	ldr	r3, [pc, #64]	; 30034820 <online_wav_file_read+0x540>
300347dc:	e8930018 	ldm	r3, {r3, r4}
300347e0:	e1520004 	cmp	r2, r4
300347e4:	01510003 	cmpeq	r1, r3
300347e8:	3affff09 	bcc	30034414 <online_wav_file_read+0x134>
	 }

	 //acoral_flush();
	 //acoral_close(localFile);
	// acoral_flush();
	 acoral_print("wait for next song~");
300347ec:	e59f0068 	ldr	r0, [pc, #104]	; 3003485c <online_wav_file_read+0x57c>
300347f0:	ebff5a92 	bl	3000b240 <acoral_print>
	end_of_file = cur;
300347f4:	e59f3014 	ldr	r3, [pc, #20]	; 30034810 <online_wav_file_read+0x530>
300347f8:	e59d2018 	ldr	r2, [sp, #24]
300347fc:	e5832000 	str	r2, [r3]
	while(1) {
				acoral_delay_self(5000);
30034800:	e3a00d4e 	mov	r0, #4992	; 0x1380
30034804:	e2800008 	add	r0, r0, #8
30034808:	ebff385d 	bl	30002984 <acoral_delay_self>
	}
3003480c:	eafffffb 	b	30034800 <online_wav_file_read+0x520>
30034810:	300c6000 	.word	0x300c6000
30034814:	302bf84c 	.word	0x302bf84c
30034818:	302be6b0 	.word	0x302be6b0
3003481c:	301f57a8 	.word	0x301f57a8
30034820:	300e5948 	.word	0x300e5948
30034824:	300e5950 	.word	0x300e5950
30034828:	302be3d8 	.word	0x302be3d8
3003482c:	300e5968 	.word	0x300e5968
30034830:	3012d730 	.word	0x3012d730
30034834:	302be50c 	.word	0x302be50c
30034838:	30046098 	.word	0x30046098
3003483c:	30033220 	.word	0x30033220
30034840:	300460d8 	.word	0x300460d8
30034844:	300eaab0 	.word	0x300eaab0
30034848:	300338d8 	.word	0x300338d8
3003484c:	3004608c 	.word	0x3004608c
30034850:	302bf844 	.word	0x302bf844
30034854:	302be830 	.word	0x302be830
30034858:	30046130 	.word	0x30046130
3003485c:	3004614c 	.word	0x3004614c

30034860 <online_mp3_file_read>:
}


void online_mp3_file_read(void) {
30034860:	e92d4010 	push	{r4, lr}
30034864:	e24dd028 	sub	sp, sp, #40	; 0x28
	int i;
	int cur = 0;
30034868:	e3a03000 	mov	r3, #0
3003486c:	e58d3014 	str	r3, [sp, #20]
	int count = 0;
30034870:	e3a03000 	mov	r3, #0
30034874:	e58d3018 	str	r3, [sp, #24]
	int first = 1;
30034878:	e3a03001 	mov	r3, #1
3003487c:	e58d301c 	str	r3, [sp, #28]
	end_of_file = -1;
30034880:	e59f3478 	ldr	r3, [pc, #1144]	; 30034d00 <online_mp3_file_read+0x4a0>
30034884:	e3e02000 	mvn	r2, #0
30034888:	e5832000 	str	r2, [r3]
	acoral_slice_policy_data_t data;
	data.cpu = 0;
3003488c:	e3a03000 	mov	r3, #0
30034890:	e5cd3008 	strb	r3, [sp, #8]
	data.prio = 19;
30034894:	e3a03013 	mov	r3, #19
30034898:	e5cd3009 	strb	r3, [sp, #9]
	data.slice = 100;
3003489c:	e3a03064 	mov	r3, #100	; 0x64
300348a0:	e58d300c 	str	r3, [sp, #12]

	for(i=0; i<file_mp3_buf_size; i++) {
300348a4:	e3a03000 	mov	r3, #0
300348a8:	e58d3010 	str	r3, [sp, #16]
300348ac:	ea000026 	b	3003494c <online_mp3_file_read+0xec>
		file_mp3_buf_hdr[i].update = 0;
300348b0:	e59d2010 	ldr	r2, [sp, #16]
300348b4:	e59f3448 	ldr	r3, [pc, #1096]	; 30034d04 <online_mp3_file_read+0x4a4>
300348b8:	e1a02082 	lsl	r2, r2, #1
300348bc:	e2822001 	add	r2, r2, #1
300348c0:	e3a01000 	mov	r1, #0
300348c4:	e7831182 	str	r1, [r3, r2, lsl #3]
		file_mp3_buf_hdr[i].used = 0;
300348c8:	e59d1010 	ldr	r1, [sp, #16]
300348cc:	e59f2430 	ldr	r2, [pc, #1072]	; 30034d04 <online_mp3_file_read+0x4a4>
300348d0:	e3a03004 	mov	r3, #4
300348d4:	e1a01201 	lsl	r1, r1, #4
300348d8:	e0812002 	add	r2, r1, r2
300348dc:	e0823003 	add	r3, r2, r3
300348e0:	e3a02000 	mov	r2, #0
300348e4:	e5832000 	str	r2, [r3]
		acoral_sem_init(file_mp3_buf_usedone_eve+i, 0);
300348e8:	e59d2010 	ldr	r2, [sp, #16]
300348ec:	e1a03002 	mov	r3, r2
300348f0:	e1a03183 	lsl	r3, r3, #3
300348f4:	e0833002 	add	r3, r3, r2
300348f8:	e1a03103 	lsl	r3, r3, #2
300348fc:	e1a02003 	mov	r2, r3
30034900:	e59f3400 	ldr	r3, [pc, #1024]	; 30034d08 <online_mp3_file_read+0x4a8>
30034904:	e0823003 	add	r3, r2, r3
30034908:	e1a00003 	mov	r0, r3
3003490c:	e3a01000 	mov	r1, #0
30034910:	ebff4ad6 	bl	30007470 <acoral_sem_init>
		acoral_sem_init(file_mp3_buf_update_eve+i, 0);
30034914:	e59d2010 	ldr	r2, [sp, #16]
30034918:	e1a03002 	mov	r3, r2
3003491c:	e1a03183 	lsl	r3, r3, #3
30034920:	e0833002 	add	r3, r3, r2
30034924:	e1a03103 	lsl	r3, r3, #2
30034928:	e1a02003 	mov	r2, r3
3003492c:	e59f33d8 	ldr	r3, [pc, #984]	; 30034d0c <online_mp3_file_read+0x4ac>
30034930:	e0823003 	add	r3, r2, r3
30034934:	e1a00003 	mov	r0, r3
30034938:	e3a01000 	mov	r1, #0
3003493c:	ebff4acb 	bl	30007470 <acoral_sem_init>
	acoral_slice_policy_data_t data;
	data.cpu = 0;
	data.prio = 19;
	data.slice = 100;

	for(i=0; i<file_mp3_buf_size; i++) {
30034940:	e59d3010 	ldr	r3, [sp, #16]
30034944:	e2833001 	add	r3, r3, #1
30034948:	e58d3010 	str	r3, [sp, #16]
3003494c:	e59d3010 	ldr	r3, [sp, #16]
30034950:	e3530009 	cmp	r3, #9
30034954:	daffffd5 	ble	300348b0 <online_mp3_file_read+0x50>
		file_mp3_buf_hdr[i].update = 0;
		file_mp3_buf_hdr[i].used = 0;
		acoral_sem_init(file_mp3_buf_usedone_eve+i, 0);
		acoral_sem_init(file_mp3_buf_update_eve+i, 0);
	}
	for(i=0; i<pcm_dma_buf_size; i++) {
30034958:	e3a03000 	mov	r3, #0
3003495c:	e58d3010 	str	r3, [sp, #16]
30034960:	ea000032 	b	30034a30 <online_mp3_file_read+0x1d0>
			hdr[i].used = 0;
30034964:	e59d2010 	ldr	r2, [sp, #16]
30034968:	e59f03a0 	ldr	r0, [pc, #928]	; 30034d10 <online_mp3_file_read+0x4b0>
3003496c:	e3a01024 	mov	r1, #36	; 0x24
30034970:	e1a03002 	mov	r3, r2
30034974:	e1a03103 	lsl	r3, r3, #2
30034978:	e0833002 	add	r3, r3, r2
3003497c:	e1a03083 	lsl	r3, r3, #1
30034980:	e0833002 	add	r3, r3, r2
30034984:	e1a03103 	lsl	r3, r3, #2
30034988:	e0833000 	add	r3, r3, r0
3003498c:	e0833001 	add	r3, r3, r1
30034990:	e3a02000 	mov	r2, #0
30034994:	e5832000 	str	r2, [r3]
			hdr[i].update = 0;
30034998:	e59d2010 	ldr	r2, [sp, #16]
3003499c:	e59f036c 	ldr	r0, [pc, #876]	; 30034d10 <online_mp3_file_read+0x4b0>
300349a0:	e3a01028 	mov	r1, #40	; 0x28
300349a4:	e1a03002 	mov	r3, r2
300349a8:	e1a03103 	lsl	r3, r3, #2
300349ac:	e0833002 	add	r3, r3, r2
300349b0:	e1a03083 	lsl	r3, r3, #1
300349b4:	e0833002 	add	r3, r3, r2
300349b8:	e1a03103 	lsl	r3, r3, #2
300349bc:	e0833000 	add	r3, r3, r0
300349c0:	e0833001 	add	r3, r3, r1
300349c4:	e3a02000 	mov	r2, #0
300349c8:	e5832000 	str	r2, [r3]
			acoral_sem_init(pcm_dma_buf_update_eve+i, 0);
300349cc:	e59d2010 	ldr	r2, [sp, #16]
300349d0:	e1a03002 	mov	r3, r2
300349d4:	e1a03183 	lsl	r3, r3, #3
300349d8:	e0833002 	add	r3, r3, r2
300349dc:	e1a03103 	lsl	r3, r3, #2
300349e0:	e1a02003 	mov	r2, r3
300349e4:	e59f3328 	ldr	r3, [pc, #808]	; 30034d14 <online_mp3_file_read+0x4b4>
300349e8:	e0823003 	add	r3, r2, r3
300349ec:	e1a00003 	mov	r0, r3
300349f0:	e3a01000 	mov	r1, #0
300349f4:	ebff4a9d 	bl	30007470 <acoral_sem_init>
			acoral_sem_init(pcm_dma_buf_playdone_eve+i, 0);
300349f8:	e59d2010 	ldr	r2, [sp, #16]
300349fc:	e1a03002 	mov	r3, r2
30034a00:	e1a03183 	lsl	r3, r3, #3
30034a04:	e0833002 	add	r3, r3, r2
30034a08:	e1a03103 	lsl	r3, r3, #2
30034a0c:	e1a02003 	mov	r2, r3
30034a10:	e59f3300 	ldr	r3, [pc, #768]	; 30034d18 <online_mp3_file_read+0x4b8>
30034a14:	e0823003 	add	r3, r2, r3
30034a18:	e1a00003 	mov	r0, r3
30034a1c:	e3a01000 	mov	r1, #0
30034a20:	ebff4a92 	bl	30007470 <acoral_sem_init>
		file_mp3_buf_hdr[i].update = 0;
		file_mp3_buf_hdr[i].used = 0;
		acoral_sem_init(file_mp3_buf_usedone_eve+i, 0);
		acoral_sem_init(file_mp3_buf_update_eve+i, 0);
	}
	for(i=0; i<pcm_dma_buf_size; i++) {
30034a24:	e59d3010 	ldr	r3, [sp, #16]
30034a28:	e2833001 	add	r3, r3, #1
30034a2c:	e58d3010 	str	r3, [sp, #16]
30034a30:	e59d3010 	ldr	r3, [sp, #16]
30034a34:	e3530009 	cmp	r3, #9
30034a38:	daffffc9 	ble	30034964 <online_mp3_file_read+0x104>
			acoral_sem_init(pcm_dma_buf_update_eve+i, 0);
			acoral_sem_init(pcm_dma_buf_playdone_eve+i, 0);
	}
	//mp3_decoder_id = acoral_create_thread(mp3_decoder,8192*16,NULL,"mp3_decoder",16,0);
	//mp3_decoder_id = acoral_create_thread_ext(mp3_decoder, 8192*16, 0, "mp3_decoder", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
	i = 0;
30034a3c:	e3a03000 	mov	r3, #0
30034a40:	e58d3010 	str	r3, [sp, #16]
    while(bytesReceived < totalBytes) {
30034a44:	ea00009d 	b	30034cc0 <online_mp3_file_read+0x460>
	       //如果接收的数据小于总数据，那么写入文件
    	if(file_mp3_buf_hdr[cur].used)
30034a48:	e59d1014 	ldr	r1, [sp, #20]
30034a4c:	e59f22b0 	ldr	r2, [pc, #688]	; 30034d04 <online_mp3_file_read+0x4a4>
30034a50:	e3a03004 	mov	r3, #4
30034a54:	e1a01201 	lsl	r1, r1, #4
30034a58:	e0812002 	add	r2, r1, r2
30034a5c:	e0823003 	add	r3, r2, r3
30034a60:	e5933000 	ldr	r3, [r3]
30034a64:	e3530000 	cmp	r3, #0
30034a68:	0a00000a 	beq	30034a98 <online_mp3_file_read+0x238>
    		acoral_sem_pend(file_mp3_buf_usedone_eve+cur, 0);
30034a6c:	e59d2014 	ldr	r2, [sp, #20]
30034a70:	e1a03002 	mov	r3, r2
30034a74:	e1a03183 	lsl	r3, r3, #3
30034a78:	e0833002 	add	r3, r3, r2
30034a7c:	e1a03103 	lsl	r3, r3, #2
30034a80:	e1a02003 	mov	r2, r3
30034a84:	e59f327c 	ldr	r3, [pc, #636]	; 30034d08 <online_mp3_file_read+0x4a8>
30034a88:	e0823003 	add	r3, r2, r3
30034a8c:	e1a00003 	mov	r0, r3
30034a90:	e3a01000 	mov	r1, #0
30034a94:	ebff4b09 	bl	300076c0 <acoral_sem_pend>
    	 acoral_u64 tmp_size = min(8192, (totalBytes-bytesReceived));
30034a98:	e59f327c 	ldr	r3, [pc, #636]	; 30034d1c <online_mp3_file_read+0x4bc>
30034a9c:	e8930006 	ldm	r3, {r1, r2}
30034aa0:	e59f3278 	ldr	r3, [pc, #632]	; 30034d20 <online_mp3_file_read+0x4c0>
30034aa4:	e8930018 	ldm	r3, {r3, r4}
30034aa8:	e0513003 	subs	r3, r1, r3
30034aac:	e0c24004 	sbc	r4, r2, r4
30034ab0:	e3a00a02 	mov	r0, #8192	; 0x2000
30034ab4:	e3a01000 	mov	r1, #0
30034ab8:	e1a02003 	mov	r2, r3
30034abc:	e1a03004 	mov	r3, r4
30034ac0:	ebfffdf2 	bl	30034290 <min>
30034ac4:	e1a03000 	mov	r3, r0
30034ac8:	e1a04001 	mov	r4, r1
30034acc:	e58d3020 	str	r3, [sp, #32]
30034ad0:	e58d4024 	str	r4, [sp, #36]	; 0x24
		 send_cmd[0] = 0xfe;
30034ad4:	e59f3248 	ldr	r3, [pc, #584]	; 30034d24 <online_mp3_file_read+0x4c4>
30034ad8:	e3e02001 	mvn	r2, #1
30034adc:	e5c32000 	strb	r2, [r3]
		 send_cmd[1] = 0xff;
30034ae0:	e59f323c 	ldr	r3, [pc, #572]	; 30034d24 <online_mp3_file_read+0x4c4>
30034ae4:	e3e02000 	mvn	r2, #0
30034ae8:	e5c32001 	strb	r2, [r3, #1]
		 send(sock_fd, (acoral_u8 *)&send_cmd, sizeof(send_cmd), 0);
30034aec:	e59f3234 	ldr	r3, [pc, #564]	; 30034d28 <online_mp3_file_read+0x4c8>
30034af0:	e5933000 	ldr	r3, [r3]
30034af4:	e1a00003 	mov	r0, r3
30034af8:	e59f1224 	ldr	r1, [pc, #548]	; 30034d24 <online_mp3_file_read+0x4c4>
30034afc:	e3a02002 	mov	r2, #2
30034b00:	e3a03000 	mov	r3, #0
30034b04:	ebff6e2a 	bl	300103b4 <lwip_send>
		 //Delay(75);
		 recv(sock_fd, (unsigned char *)(&file_mp3_buf[cur][i*8192]), tmp_size, 0);
30034b08:	e59f3218 	ldr	r3, [pc, #536]	; 30034d28 <online_mp3_file_read+0x4c8>
30034b0c:	e5931000 	ldr	r1, [r3]
30034b10:	e59d2014 	ldr	r2, [sp, #20]
30034b14:	e1a03002 	mov	r3, r2
30034b18:	e1a03103 	lsl	r3, r3, #2
30034b1c:	e0833002 	add	r3, r3, r2
30034b20:	e1a03083 	lsl	r3, r3, #1
30034b24:	e1a02003 	mov	r2, r3
30034b28:	e59d3010 	ldr	r3, [sp, #16]
30034b2c:	e0823003 	add	r3, r2, r3
30034b30:	e1a02683 	lsl	r2, r3, #13
30034b34:	e59f31f0 	ldr	r3, [pc, #496]	; 30034d2c <online_mp3_file_read+0x4cc>
30034b38:	e0822003 	add	r2, r2, r3
30034b3c:	e59d3020 	ldr	r3, [sp, #32]
30034b40:	e1a00001 	mov	r0, r1
30034b44:	e1a01002 	mov	r1, r2
30034b48:	e1a02003 	mov	r2, r3
30034b4c:	e3a03000 	mov	r3, #0
30034b50:	ebff6e03 	bl	30010364 <lwip_recv>
		 //recv(sock_fd, (unsigned char *)(&file_mp3_buf[cur][0]), tmp_size, 0);
		 bytesReceived = bytesReceived + tmp_size;
30034b54:	e59f31c4 	ldr	r3, [pc, #452]	; 30034d20 <online_mp3_file_read+0x4c0>
30034b58:	e8930006 	ldm	r3, {r1, r2}
30034b5c:	e28d4020 	add	r4, sp, #32
30034b60:	e8940018 	ldm	r4, {r3, r4}
30034b64:	e0933001 	adds	r3, r3, r1
30034b68:	e0a44002 	adc	r4, r4, r2
30034b6c:	e59f21ac 	ldr	r2, [pc, #428]	; 30034d20 <online_mp3_file_read+0x4c0>
30034b70:	e8820018 	stm	r2, {r3, r4}
		// acoral_write(localFile, (unsigned char *)(&file_mp3_buf[cur][i*4096]), tmp_size);
		 //acoral_flush();
		 count ++;
30034b74:	e59d3018 	ldr	r3, [sp, #24]
30034b78:	e2833001 	add	r3, r3, #1
30034b7c:	e58d3018 	str	r3, [sp, #24]
		 i ++;
30034b80:	e59d3010 	ldr	r3, [sp, #16]
30034b84:	e2833001 	add	r3, r3, #1
30034b88:	e58d3010 	str	r3, [sp, #16]
		 if(i == 10) {
30034b8c:	e59d3010 	ldr	r3, [sp, #16]
30034b90:	e353000a 	cmp	r3, #10
30034b94:	1a000029 	bne	30034c40 <online_mp3_file_read+0x3e0>
			 file_mp3_buf_hdr[cur].update = 1;
30034b98:	e59d2014 	ldr	r2, [sp, #20]
30034b9c:	e59f3160 	ldr	r3, [pc, #352]	; 30034d04 <online_mp3_file_read+0x4a4>
30034ba0:	e1a02082 	lsl	r2, r2, #1
30034ba4:	e2822001 	add	r2, r2, #1
30034ba8:	e3a01001 	mov	r1, #1
30034bac:	e7831182 	str	r1, [r3, r2, lsl #3]
			 file_mp3_buf_hdr[cur].used = 1;
30034bb0:	e59d1014 	ldr	r1, [sp, #20]
30034bb4:	e59f2148 	ldr	r2, [pc, #328]	; 30034d04 <online_mp3_file_read+0x4a4>
30034bb8:	e3a03004 	mov	r3, #4
30034bbc:	e1a01201 	lsl	r1, r1, #4
30034bc0:	e0812002 	add	r2, r1, r2
30034bc4:	e0823003 	add	r3, r2, r3
30034bc8:	e3a02001 	mov	r2, #1
30034bcc:	e5832000 	str	r2, [r3]
			 if(acoral_sem_getnum(file_mp3_buf_update_eve+cur))
30034bd0:	e59d2014 	ldr	r2, [sp, #20]
30034bd4:	e1a03002 	mov	r3, r2
30034bd8:	e1a03183 	lsl	r3, r3, #3
30034bdc:	e0833002 	add	r3, r3, r2
30034be0:	e1a03103 	lsl	r3, r3, #2
30034be4:	e1a02003 	mov	r2, r3
30034be8:	e59f311c 	ldr	r3, [pc, #284]	; 30034d0c <online_mp3_file_read+0x4ac>
30034bec:	e0823003 	add	r3, r2, r3
30034bf0:	e1a00003 	mov	r0, r3
30034bf4:	ebff4b5e 	bl	30007974 <acoral_sem_getnum>
30034bf8:	e1a03000 	mov	r3, r0
30034bfc:	e3530000 	cmp	r3, #0
30034c00:	0a000009 	beq	30034c2c <online_mp3_file_read+0x3cc>
				acoral_sem_post(file_mp3_buf_update_eve+cur);
30034c04:	e59d2014 	ldr	r2, [sp, #20]
30034c08:	e1a03002 	mov	r3, r2
30034c0c:	e1a03183 	lsl	r3, r3, #3
30034c10:	e0833002 	add	r3, r3, r2
30034c14:	e1a03103 	lsl	r3, r3, #2
30034c18:	e1a02003 	mov	r2, r3
30034c1c:	e59f30e8 	ldr	r3, [pc, #232]	; 30034d0c <online_mp3_file_read+0x4ac>
30034c20:	e0823003 	add	r3, r2, r3
30034c24:	e1a00003 	mov	r0, r3
30034c28:	ebff4b0f 	bl	3000786c <acoral_sem_post>
			 i = 0;
30034c2c:	e3a03000 	mov	r3, #0
30034c30:	e58d3010 	str	r3, [sp, #16]
			 cur ++;
30034c34:	e59d3014 	ldr	r3, [sp, #20]
30034c38:	e2833001 	add	r3, r3, #1
30034c3c:	e58d3014 	str	r3, [sp, #20]
		 }
		 if(first && (cur==file_mp3_buf_size)) {
30034c40:	e59d301c 	ldr	r3, [sp, #28]
30034c44:	e3530000 	cmp	r3, #0
30034c48:	0a000011 	beq	30034c94 <online_mp3_file_read+0x434>
30034c4c:	e59d3014 	ldr	r3, [sp, #20]
30034c50:	e353000a 	cmp	r3, #10
30034c54:	1a00000e 	bne	30034c94 <online_mp3_file_read+0x434>
			first = 0;
30034c58:	e3a03000 	mov	r3, #0
30034c5c:	e58d301c 	str	r3, [sp, #28]
			mp3_decoder_id = acoral_create_thread(mp3_decoder,8192*16,NULL,"mp3_decoder",16,0);
30034c60:	e59f30c8 	ldr	r3, [pc, #200]	; 30034d30 <online_mp3_file_read+0x4d0>
30034c64:	e3a02010 	mov	r2, #16
30034c68:	e58d2000 	str	r2, [sp]
30034c6c:	e3a02000 	mov	r2, #0
30034c70:	e58d2004 	str	r2, [sp, #4]
30034c74:	e1a00003 	mov	r0, r3
30034c78:	e3a01802 	mov	r1, #131072	; 0x20000
30034c7c:	e3a02000 	mov	r2, #0
30034c80:	e59f30ac 	ldr	r3, [pc, #172]	; 30034d34 <online_mp3_file_read+0x4d4>
30034c84:	ebff38c6 	bl	30002fa4 <create_comm_thread>
30034c88:	e1a02000 	mov	r2, r0
30034c8c:	e59f30a4 	ldr	r3, [pc, #164]	; 30034d38 <online_mp3_file_read+0x4d8>
30034c90:	e5832000 	str	r2, [r3]
		 }

		 if(cur == file_mp3_buf_size)
30034c94:	e59d3014 	ldr	r3, [sp, #20]
30034c98:	e353000a 	cmp	r3, #10
30034c9c:	1a000001 	bne	30034ca8 <online_mp3_file_read+0x448>
			 cur = 0;
30034ca0:	e3a03000 	mov	r3, #0
30034ca4:	e58d3014 	str	r3, [sp, #20]
		 acoral_print("recive96 : %d  info: %2x\n", count, rec[23]);
30034ca8:	e59f308c 	ldr	r3, [pc, #140]	; 30034d3c <online_mp3_file_read+0x4dc>
30034cac:	e5d33017 	ldrb	r3, [r3, #23]
30034cb0:	e59f0088 	ldr	r0, [pc, #136]	; 30034d40 <online_mp3_file_read+0x4e0>
30034cb4:	e59d1018 	ldr	r1, [sp, #24]
30034cb8:	e1a02003 	mov	r2, r3
30034cbc:	ebff595f 	bl	3000b240 <acoral_print>
			acoral_sem_init(pcm_dma_buf_playdone_eve+i, 0);
	}
	//mp3_decoder_id = acoral_create_thread(mp3_decoder,8192*16,NULL,"mp3_decoder",16,0);
	//mp3_decoder_id = acoral_create_thread_ext(mp3_decoder, 8192*16, 0, "mp3_decoder", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
	i = 0;
    while(bytesReceived < totalBytes) {
30034cc0:	e59f3058 	ldr	r3, [pc, #88]	; 30034d20 <online_mp3_file_read+0x4c0>
30034cc4:	e8930006 	ldm	r3, {r1, r2}
30034cc8:	e59f304c 	ldr	r3, [pc, #76]	; 30034d1c <online_mp3_file_read+0x4bc>
30034ccc:	e8930018 	ldm	r3, {r3, r4}
30034cd0:	e1520004 	cmp	r2, r4
30034cd4:	01510003 	cmpeq	r1, r3
30034cd8:	3affff5a 	bcc	30034a48 <online_mp3_file_read+0x1e8>
			// for(k=0; k<1300; k++);
	 }
	 //acoral_flush();
	//	acoral_close(localFile);
	// acoral_flush();
	 acoral_print("wait for next song~");
30034cdc:	e59f0060 	ldr	r0, [pc, #96]	; 30034d44 <online_mp3_file_read+0x4e4>
30034ce0:	ebff5956 	bl	3000b240 <acoral_print>
	 end_of_file = cur;
30034ce4:	e59f3014 	ldr	r3, [pc, #20]	; 30034d00 <online_mp3_file_read+0x4a0>
30034ce8:	e59d2014 	ldr	r2, [sp, #20]
30034cec:	e5832000 	str	r2, [r3]
	 while(1) {
			acoral_delay_self(5000);
30034cf0:	e3a00d4e 	mov	r0, #4992	; 0x1380
30034cf4:	e2800008 	add	r0, r0, #8
30034cf8:	ebff3721 	bl	30002984 <acoral_delay_self>
	 }
30034cfc:	eafffffb 	b	30034cf0 <online_mp3_file_read+0x490>
30034d00:	300c6000 	.word	0x300c6000
30034d04:	300ea3bc 	.word	0x300ea3bc
30034d08:	3012acac 	.word	0x3012acac
30034d0c:	302be270 	.word	0x302be270
30034d10:	302bf84c 	.word	0x302bf84c
30034d14:	302be6b0 	.word	0x302be6b0
30034d18:	301f57a8 	.word	0x301f57a8
30034d1c:	300e5948 	.word	0x300e5948
30034d20:	300e5950 	.word	0x300e5950
30034d24:	302be3d8 	.word	0x302be3d8
30034d28:	300e5968 	.word	0x300e5968
30034d2c:	301f5948 	.word	0x301f5948
30034d30:	3003f950 	.word	0x3003f950
30034d34:	3004608c 	.word	0x3004608c
30034d38:	302bf844 	.word	0x302bf844
30034d3c:	302be830 	.word	0x302be830
30034d40:	30046130 	.word	0x30046130
30034d44:	3004614c 	.word	0x3004614c

30034d48 <talor_factorial>:
,355687428096000
,6402373705728000
,121645100408832000
,2432902008176640000
};
double talor_factorial(double n) {
30034d48:	e92d4030 	push	{r4, r5, lr}
30034d4c:	e24dd024 	sub	sp, sp, #36	; 0x24
30034d50:	e88d0003 	stm	sp, {r0, r1}
	double mul = useful_fact[20];
30034d54:	e59f314c 	ldr	r3, [pc, #332]	; 30034ea8 <talor_factorial+0x160>
30034d58:	e28340a0 	add	r4, r3, #160	; 0xa0
30034d5c:	e8940018 	ldm	r4, {r3, r4}
30034d60:	e58d3008 	str	r3, [sp, #8]
30034d64:	e58d400c 	str	r4, [sp, #12]
	double num = 21;
30034d68:	e3a03000 	mov	r3, #0
30034d6c:	e3a04101 	mov	r4, #1073741824	; 0x40000000
30034d70:	e2844835 	add	r4, r4, #3473408	; 0x350000
30034d74:	e58d3010 	str	r3, [sp, #16]
30034d78:	e58d4014 	str	r4, [sp, #20]
	int i = n;
30034d7c:	e89d0003 	ldm	sp, {r0, r1}
30034d80:	eb003edd 	bl	300448fc <__aeabi_d2iz>
30034d84:	e1a03000 	mov	r3, r0
30034d88:	e58d301c 	str	r3, [sp, #28]
	if(n <= 20)
30034d8c:	e3a03000 	mov	r3, #0
30034d90:	e1a04003 	mov	r4, r3
30034d94:	e89d0003 	ldm	sp, {r0, r1}
30034d98:	e3a02000 	mov	r2, #0
30034d9c:	e3a03101 	mov	r3, #1073741824	; 0x40000000
30034da0:	e283370d 	add	r3, r3, #3407872	; 0x340000
30034da4:	eb003ec2 	bl	300448b4 <__aeabi_dcmple>
30034da8:	e1a03000 	mov	r3, r0
30034dac:	e3530000 	cmp	r3, #0
30034db0:	0a000001 	beq	30034dbc <talor_factorial+0x74>
30034db4:	e3a03001 	mov	r3, #1
30034db8:	e1a04003 	mov	r4, r3
30034dbc:	e20430ff 	and	r3, r4, #255	; 0xff
30034dc0:	e3530000 	cmp	r3, #0
30034dc4:	0a000005 	beq	30034de0 <talor_factorial+0x98>
		return useful_fact[i];
30034dc8:	e59d201c 	ldr	r2, [sp, #28]
30034dcc:	e59f30d4 	ldr	r3, [pc, #212]	; 30034ea8 <talor_factorial+0x160>
30034dd0:	e1a02182 	lsl	r2, r2, #3
30034dd4:	e0823003 	add	r3, r2, r3
30034dd8:	e8930018 	ldm	r3, {r3, r4}
30034ddc:	ea00002c 	b	30034e94 <talor_factorial+0x14c>
	for(i=21; i<=n; i++) {
30034de0:	e3a03015 	mov	r3, #21
30034de4:	e58d301c 	str	r3, [sp, #28]
30034de8:	ea000015 	b	30034e44 <talor_factorial+0xfc>
		mul *= num;
30034dec:	e28d1008 	add	r1, sp, #8
30034df0:	e8910003 	ldm	r1, {r0, r1}
30034df4:	e28d3010 	add	r3, sp, #16
30034df8:	e893000c 	ldm	r3, {r2, r3}
30034dfc:	eb003d46 	bl	3004431c <__aeabi_dmul>
30034e00:	e1a03000 	mov	r3, r0
30034e04:	e1a04001 	mov	r4, r1
30034e08:	e58d3008 	str	r3, [sp, #8]
30034e0c:	e58d400c 	str	r4, [sp, #12]
		num ++;
30034e10:	e28d1010 	add	r1, sp, #16
30034e14:	e8910003 	ldm	r1, {r0, r1}
30034e18:	e3a02000 	mov	r2, #0
30034e1c:	e3a035ff 	mov	r3, #1069547520	; 0x3fc00000
30034e20:	e2833603 	add	r3, r3, #3145728	; 0x300000
30034e24:	eb003c38 	bl	30043f0c <__adddf3>
30034e28:	e1a03000 	mov	r3, r0
30034e2c:	e1a04001 	mov	r4, r1
30034e30:	e58d3010 	str	r3, [sp, #16]
30034e34:	e58d4014 	str	r4, [sp, #20]
	double mul = useful_fact[20];
	double num = 21;
	int i = n;
	if(n <= 20)
		return useful_fact[i];
	for(i=21; i<=n; i++) {
30034e38:	e59d301c 	ldr	r3, [sp, #28]
30034e3c:	e2833001 	add	r3, r3, #1
30034e40:	e58d301c 	str	r3, [sp, #28]
30034e44:	e59d001c 	ldr	r0, [sp, #28]
30034e48:	eb003cfc 	bl	30044240 <__aeabi_i2d>
30034e4c:	e1a03000 	mov	r3, r0
30034e50:	e1a04001 	mov	r4, r1
30034e54:	e3a02000 	mov	r2, #0
30034e58:	e1a05002 	mov	r5, r2
30034e5c:	e1a00003 	mov	r0, r3
30034e60:	e1a01004 	mov	r1, r4
30034e64:	e89d000c 	ldm	sp, {r2, r3}
30034e68:	eb003e91 	bl	300448b4 <__aeabi_dcmple>
30034e6c:	e1a03000 	mov	r3, r0
30034e70:	e3530000 	cmp	r3, #0
30034e74:	0a000001 	beq	30034e80 <talor_factorial+0x138>
30034e78:	e3a03001 	mov	r3, #1
30034e7c:	e1a05003 	mov	r5, r3
30034e80:	e20530ff 	and	r3, r5, #255	; 0xff
30034e84:	e3530000 	cmp	r3, #0
30034e88:	1affffd7 	bne	30034dec <talor_factorial+0xa4>
		mul *= num;
		num ++;
	}
	return mul;
30034e8c:	e28d4008 	add	r4, sp, #8
30034e90:	e8940018 	ldm	r4, {r3, r4}
}
30034e94:	e1a00003 	mov	r0, r3
30034e98:	e1a01004 	mov	r1, r4
30034e9c:	e28dd024 	add	sp, sp, #36	; 0x24
30034ea0:	e8bd4030 	pop	{r4, r5, lr}
30034ea4:	e12fff1e 	bx	lr
30034ea8:	300c6008 	.word	0x300c6008

30034eac <talor_pow>:
double talor_pow(double x, int n) {
30034eac:	e92d4010 	push	{r4, lr}
30034eb0:	e24dd020 	sub	sp, sp, #32
30034eb4:	e58d0008 	str	r0, [sp, #8]
30034eb8:	e58d100c 	str	r1, [sp, #12]
30034ebc:	e58d2004 	str	r2, [sp, #4]
/*	int i;
	double num = 1;
	for(i=0; i<n; i++)
		num *= x;
	return num;*/
	double ret=1,pow=x;
30034ec0:	e3a03000 	mov	r3, #0
30034ec4:	e3a045ff 	mov	r4, #1069547520	; 0x3fc00000
30034ec8:	e2844603 	add	r4, r4, #3145728	; 0x300000
30034ecc:	e58d3010 	str	r3, [sp, #16]
30034ed0:	e58d4014 	str	r4, [sp, #20]
30034ed4:	e28d4008 	add	r4, sp, #8
30034ed8:	e8940018 	ldm	r4, {r3, r4}
30034edc:	e58d3018 	str	r3, [sp, #24]
30034ee0:	e58d401c 	str	r4, [sp, #28]
	while(n!=0){
30034ee4:	ea000019 	b	30034f50 <talor_pow+0xa4>
		if(n&1) 
30034ee8:	e59d3004 	ldr	r3, [sp, #4]
30034eec:	e2033001 	and	r3, r3, #1
30034ef0:	e20330ff 	and	r3, r3, #255	; 0xff
30034ef4:	e3530000 	cmp	r3, #0
30034ef8:	0a000008 	beq	30034f20 <talor_pow+0x74>
			ret=(ret*pow); 
30034efc:	e28d1010 	add	r1, sp, #16
30034f00:	e8910003 	ldm	r1, {r0, r1}
30034f04:	e28d3018 	add	r3, sp, #24
30034f08:	e893000c 	ldm	r3, {r2, r3}
30034f0c:	eb003d02 	bl	3004431c <__aeabi_dmul>
30034f10:	e1a03000 	mov	r3, r0
30034f14:	e1a04001 	mov	r4, r1
30034f18:	e58d3010 	str	r3, [sp, #16]
30034f1c:	e58d4014 	str	r4, [sp, #20]
		pow=(pow*pow);
30034f20:	e28d1018 	add	r1, sp, #24
30034f24:	e8910003 	ldm	r1, {r0, r1}
30034f28:	e28d3018 	add	r3, sp, #24
30034f2c:	e893000c 	ldm	r3, {r2, r3}
30034f30:	eb003cf9 	bl	3004431c <__aeabi_dmul>
30034f34:	e1a03000 	mov	r3, r0
30034f38:	e1a04001 	mov	r4, r1
30034f3c:	e58d3018 	str	r3, [sp, #24]
30034f40:	e58d401c 	str	r4, [sp, #28]
		n = n>>1;//相当于b>>1
30034f44:	e59d3004 	ldr	r3, [sp, #4]
30034f48:	e1a030c3 	asr	r3, r3, #1
30034f4c:	e58d3004 	str	r3, [sp, #4]
	double num = 1;
	for(i=0; i<n; i++)
		num *= x;
	return num;*/
	double ret=1,pow=x;
	while(n!=0){
30034f50:	e59d3004 	ldr	r3, [sp, #4]
30034f54:	e3530000 	cmp	r3, #0
30034f58:	1affffe2 	bne	30034ee8 <talor_pow+0x3c>
		if(n&1) 
			ret=(ret*pow); 
		pow=(pow*pow);
		n = n>>1;//相当于b>>1
    }
	return ret;
30034f5c:	e28d4010 	add	r4, sp, #16
30034f60:	e8940018 	ldm	r4, {r3, r4}
}
30034f64:	e1a00003 	mov	r0, r3
30034f68:	e1a01004 	mov	r1, r4
30034f6c:	e28dd020 	add	sp, sp, #32
30034f70:	e8bd4010 	pop	{r4, lr}
30034f74:	e12fff1e 	bx	lr

30034f78 <talor_sin_cal>:

double talor_sin_cal(double x, int k) {
30034f78:	e92d4070 	push	{r4, r5, r6, lr}
30034f7c:	e24dd010 	sub	sp, sp, #16
30034f80:	e58d0008 	str	r0, [sp, #8]
30034f84:	e58d100c 	str	r1, [sp, #12]
30034f88:	e58d2004 	str	r2, [sp, #4]
	if((k-1)%2 == 0)
30034f8c:	e59d3004 	ldr	r3, [sp, #4]
30034f90:	e2433001 	sub	r3, r3, #1
30034f94:	e2033001 	and	r3, r3, #1
30034f98:	e3530000 	cmp	r3, #0
30034f9c:	1a00001c 	bne	30035014 <talor_sin_cal+0x9c>
		return talor_pow(x, 2*k-1)/talor_factorial(2*k-1);
30034fa0:	e59d3004 	ldr	r3, [sp, #4]
30034fa4:	e1a03083 	lsl	r3, r3, #1
30034fa8:	e2433001 	sub	r3, r3, #1
30034fac:	e28d1008 	add	r1, sp, #8
30034fb0:	e8910003 	ldm	r1, {r0, r1}
30034fb4:	e1a02003 	mov	r2, r3
30034fb8:	ebffffbb 	bl	30034eac <talor_pow>
30034fbc:	e1a05000 	mov	r5, r0
30034fc0:	e1a06001 	mov	r6, r1
30034fc4:	e59d3004 	ldr	r3, [sp, #4]
30034fc8:	e1a03083 	lsl	r3, r3, #1
30034fcc:	e2433001 	sub	r3, r3, #1
30034fd0:	e1a00003 	mov	r0, r3
30034fd4:	eb003c99 	bl	30044240 <__aeabi_i2d>
30034fd8:	e1a03000 	mov	r3, r0
30034fdc:	e1a04001 	mov	r4, r1
30034fe0:	e1a00003 	mov	r0, r3
30034fe4:	e1a01004 	mov	r1, r4
30034fe8:	ebffff56 	bl	30034d48 <talor_factorial>
30034fec:	e1a03000 	mov	r3, r0
30034ff0:	e1a04001 	mov	r4, r1
30034ff4:	e1a00005 	mov	r0, r5
30034ff8:	e1a01006 	mov	r1, r6
30034ffc:	e1a02003 	mov	r2, r3
30035000:	e1a03004 	mov	r3, r4
30035004:	eb003d68 	bl	300445ac <__aeabi_ddiv>
30035008:	e1a03000 	mov	r3, r0
3003500c:	e1a04001 	mov	r4, r1
30035010:	ea00001b 	b	30035084 <talor_sin_cal+0x10c>
	else
		return -1*talor_pow(x, 2*k-1)/talor_factorial(2*k-1);
30035014:	e59d3004 	ldr	r3, [sp, #4]
30035018:	e1a03083 	lsl	r3, r3, #1
3003501c:	e2433001 	sub	r3, r3, #1
30035020:	e28d1008 	add	r1, sp, #8
30035024:	e8910003 	ldm	r1, {r0, r1}
30035028:	e1a02003 	mov	r2, r3
3003502c:	ebffff9e 	bl	30034eac <talor_pow>
30035030:	e1a02000 	mov	r2, r0
30035034:	e1a03001 	mov	r3, r1
30035038:	e1a04002 	mov	r4, r2
3003503c:	e2235102 	eor	r5, r3, #-2147483648	; 0x80000000
30035040:	e59d3004 	ldr	r3, [sp, #4]
30035044:	e1a03083 	lsl	r3, r3, #1
30035048:	e2433001 	sub	r3, r3, #1
3003504c:	e1a00003 	mov	r0, r3
30035050:	eb003c7a 	bl	30044240 <__aeabi_i2d>
30035054:	e1a02000 	mov	r2, r0
30035058:	e1a03001 	mov	r3, r1
3003505c:	e1a00002 	mov	r0, r2
30035060:	e1a01003 	mov	r1, r3
30035064:	ebffff37 	bl	30034d48 <talor_factorial>
30035068:	e1a02000 	mov	r2, r0
3003506c:	e1a03001 	mov	r3, r1
30035070:	e1a00004 	mov	r0, r4
30035074:	e1a01005 	mov	r1, r5
30035078:	eb003d4b 	bl	300445ac <__aeabi_ddiv>
3003507c:	e1a03000 	mov	r3, r0
30035080:	e1a04001 	mov	r4, r1
}
30035084:	e1a00003 	mov	r0, r3
30035088:	e1a01004 	mov	r1, r4
3003508c:	e28dd010 	add	sp, sp, #16
30035090:	e8bd4070 	pop	{r4, r5, r6, lr}
30035094:	e12fff1e 	bx	lr

30035098 <talor_cos_cal>:

double talor_cos_cal(double x, int k) {
30035098:	e92d4070 	push	{r4, r5, r6, lr}
3003509c:	e24dd010 	sub	sp, sp, #16
300350a0:	e58d0008 	str	r0, [sp, #8]
300350a4:	e58d100c 	str	r1, [sp, #12]
300350a8:	e58d2004 	str	r2, [sp, #4]
	if(k%2 == 0)
300350ac:	e59d3004 	ldr	r3, [sp, #4]
300350b0:	e2033001 	and	r3, r3, #1
300350b4:	e3530000 	cmp	r3, #0
300350b8:	1a00001a 	bne	30035128 <talor_cos_cal+0x90>
		return talor_pow(x, 2*k)/talor_factorial(2*k);
300350bc:	e59d3004 	ldr	r3, [sp, #4]
300350c0:	e1a03083 	lsl	r3, r3, #1
300350c4:	e28d1008 	add	r1, sp, #8
300350c8:	e8910003 	ldm	r1, {r0, r1}
300350cc:	e1a02003 	mov	r2, r3
300350d0:	ebffff75 	bl	30034eac <talor_pow>
300350d4:	e1a05000 	mov	r5, r0
300350d8:	e1a06001 	mov	r6, r1
300350dc:	e59d3004 	ldr	r3, [sp, #4]
300350e0:	e1a03083 	lsl	r3, r3, #1
300350e4:	e1a00003 	mov	r0, r3
300350e8:	eb003c54 	bl	30044240 <__aeabi_i2d>
300350ec:	e1a03000 	mov	r3, r0
300350f0:	e1a04001 	mov	r4, r1
300350f4:	e1a00003 	mov	r0, r3
300350f8:	e1a01004 	mov	r1, r4
300350fc:	ebffff11 	bl	30034d48 <talor_factorial>
30035100:	e1a03000 	mov	r3, r0
30035104:	e1a04001 	mov	r4, r1
30035108:	e1a00005 	mov	r0, r5
3003510c:	e1a01006 	mov	r1, r6
30035110:	e1a02003 	mov	r2, r3
30035114:	e1a03004 	mov	r3, r4
30035118:	eb003d23 	bl	300445ac <__aeabi_ddiv>
3003511c:	e1a03000 	mov	r3, r0
30035120:	e1a04001 	mov	r4, r1
30035124:	ea000019 	b	30035190 <talor_cos_cal+0xf8>
	else
		return -1*talor_pow(x, 2*k)/talor_factorial(2*k);
30035128:	e59d3004 	ldr	r3, [sp, #4]
3003512c:	e1a03083 	lsl	r3, r3, #1
30035130:	e28d1008 	add	r1, sp, #8
30035134:	e8910003 	ldm	r1, {r0, r1}
30035138:	e1a02003 	mov	r2, r3
3003513c:	ebffff5a 	bl	30034eac <talor_pow>
30035140:	e1a02000 	mov	r2, r0
30035144:	e1a03001 	mov	r3, r1
30035148:	e1a04002 	mov	r4, r2
3003514c:	e2235102 	eor	r5, r3, #-2147483648	; 0x80000000
30035150:	e59d3004 	ldr	r3, [sp, #4]
30035154:	e1a03083 	lsl	r3, r3, #1
30035158:	e1a00003 	mov	r0, r3
3003515c:	eb003c37 	bl	30044240 <__aeabi_i2d>
30035160:	e1a02000 	mov	r2, r0
30035164:	e1a03001 	mov	r3, r1
30035168:	e1a00002 	mov	r0, r2
3003516c:	e1a01003 	mov	r1, r3
30035170:	ebfffef4 	bl	30034d48 <talor_factorial>
30035174:	e1a02000 	mov	r2, r0
30035178:	e1a03001 	mov	r3, r1
3003517c:	e1a00004 	mov	r0, r4
30035180:	e1a01005 	mov	r1, r5
30035184:	eb003d08 	bl	300445ac <__aeabi_ddiv>
30035188:	e1a03000 	mov	r3, r0
3003518c:	e1a04001 	mov	r4, r1
}
30035190:	e1a00003 	mov	r0, r3
30035194:	e1a01004 	mov	r1, r4
30035198:	e28dd010 	add	sp, sp, #16
3003519c:	e8bd4070 	pop	{r4, r5, r6, lr}
300351a0:	e12fff1e 	bx	lr

300351a4 <sin>:

double sin(double x) {
	int i;
	double sum = 0;
300351a4:	e92d4010 	push	{r4, lr}
300351a8:	e24dd018 	sub	sp, sp, #24
300351ac:	e88d0003 	stm	sp, {r0, r1}
300351b0:	e3a03000 	mov	r3, #0
300351b4:	e3a04000 	mov	r4, #0
300351b8:	e58d3010 	str	r3, [sp, #16]
300351bc:	e58d4014 	str	r4, [sp, #20]
	if(x >= 2*talor_pi) {
300351c0:	e3a03000 	mov	r3, #0
300351c4:	e1a04003 	mov	r4, r3
300351c8:	e89d0003 	ldm	sp, {r0, r1}
300351cc:	e28f3f61 	add	r3, pc, #388	; 0x184
300351d0:	e893000c 	ldm	r3, {r2, r3}
300351d4:	eb003dbc 	bl	300448cc <__aeabi_dcmpge>
300351d8:	e1a03000 	mov	r3, r0
300351dc:	e3530000 	cmp	r3, #0
300351e0:	0a000001 	beq	300351ec <sin+0x48>
300351e4:	e3a03001 	mov	r3, #1
300351e8:	e1a04003 	mov	r4, r3
300351ec:	e20430ff 	and	r3, r4, #255	; 0xff
300351f0:	e3530000 	cmp	r3, #0
300351f4:	0a000015 	beq	30035250 <sin+0xac>
		do{
			x -= 2*talor_pi;
300351f8:	e89d0003 	ldm	sp, {r0, r1}
300351fc:	e28f3f55 	add	r3, pc, #340	; 0x154
30035200:	e893000c 	ldm	r3, {r2, r3}
30035204:	eb003b3f 	bl	30043f08 <__aeabi_dsub>
30035208:	e1a03000 	mov	r3, r0
3003520c:	e1a04001 	mov	r4, r1
30035210:	e88d0018 	stm	sp, {r3, r4}
		}while(x >= 2*talor_pi);
30035214:	e3a03000 	mov	r3, #0
30035218:	e1a04003 	mov	r4, r3
3003521c:	e89d0003 	ldm	sp, {r0, r1}
30035220:	e28f3e13 	add	r3, pc, #304	; 0x130
30035224:	e893000c 	ldm	r3, {r2, r3}
30035228:	eb003da7 	bl	300448cc <__aeabi_dcmpge>
3003522c:	e1a03000 	mov	r3, r0
30035230:	e3530000 	cmp	r3, #0
30035234:	0a000001 	beq	30035240 <sin+0x9c>
30035238:	e3a03001 	mov	r3, #1
3003523c:	e1a04003 	mov	r4, r3
30035240:	e20430ff 	and	r3, r4, #255	; 0xff
30035244:	e3530000 	cmp	r3, #0
30035248:	1affffea 	bne	300351f8 <sin+0x54>
3003524c:	ea000022 	b	300352dc <sin+0x138>
	}
	else if(x < 0) {
30035250:	e3a03000 	mov	r3, #0
30035254:	e1a04003 	mov	r4, r3
30035258:	e89d0003 	ldm	sp, {r0, r1}
3003525c:	e3a02000 	mov	r2, #0
30035260:	e3a03000 	mov	r3, #0
30035264:	eb003d8c 	bl	3004489c <__aeabi_dcmplt>
30035268:	e1a03000 	mov	r3, r0
3003526c:	e3530000 	cmp	r3, #0
30035270:	0a000001 	beq	3003527c <sin+0xd8>
30035274:	e3a03001 	mov	r3, #1
30035278:	e1a04003 	mov	r4, r3
3003527c:	e20430ff 	and	r3, r4, #255	; 0xff
30035280:	e3530000 	cmp	r3, #0
30035284:	0a000014 	beq	300352dc <sin+0x138>
		do{
			x += 2*talor_pi;
30035288:	e89d0003 	ldm	sp, {r0, r1}
3003528c:	e28f30c4 	add	r3, pc, #196	; 0xc4
30035290:	e893000c 	ldm	r3, {r2, r3}
30035294:	eb003b1c 	bl	30043f0c <__adddf3>
30035298:	e1a03000 	mov	r3, r0
3003529c:	e1a04001 	mov	r4, r1
300352a0:	e88d0018 	stm	sp, {r3, r4}
		}while(x < 0);
300352a4:	e3a03000 	mov	r3, #0
300352a8:	e1a04003 	mov	r4, r3
300352ac:	e89d0003 	ldm	sp, {r0, r1}
300352b0:	e3a02000 	mov	r2, #0
300352b4:	e3a03000 	mov	r3, #0
300352b8:	eb003d77 	bl	3004489c <__aeabi_dcmplt>
300352bc:	e1a03000 	mov	r3, r0
300352c0:	e3530000 	cmp	r3, #0
300352c4:	0a000001 	beq	300352d0 <sin+0x12c>
300352c8:	e3a03001 	mov	r3, #1
300352cc:	e1a04003 	mov	r4, r3
300352d0:	e20430ff 	and	r3, r4, #255	; 0xff
300352d4:	e3530000 	cmp	r3, #0
300352d8:	1affffea 	bne	30035288 <sin+0xe4>
	}
	for(i=1; i<=talor_lev; i++)
300352dc:	e3a03001 	mov	r3, #1
300352e0:	e58d300c 	str	r3, [sp, #12]
300352e4:	ea000010 	b	3003532c <sin+0x188>
		sum += talor_sin_cal(x, i);
300352e8:	e89d0003 	ldm	sp, {r0, r1}
300352ec:	e59d200c 	ldr	r2, [sp, #12]
300352f0:	ebffff20 	bl	30034f78 <talor_sin_cal>
300352f4:	e1a03000 	mov	r3, r0
300352f8:	e1a04001 	mov	r4, r1
300352fc:	e28d1010 	add	r1, sp, #16
30035300:	e8910003 	ldm	r1, {r0, r1}
30035304:	e1a02003 	mov	r2, r3
30035308:	e1a03004 	mov	r3, r4
3003530c:	eb003afe 	bl	30043f0c <__adddf3>
30035310:	e1a03000 	mov	r3, r0
30035314:	e1a04001 	mov	r4, r1
30035318:	e58d3010 	str	r3, [sp, #16]
3003531c:	e58d4014 	str	r4, [sp, #20]
	else if(x < 0) {
		do{
			x += 2*talor_pi;
		}while(x < 0);
	}
	for(i=1; i<=talor_lev; i++)
30035320:	e59d300c 	ldr	r3, [sp, #12]
30035324:	e2833001 	add	r3, r3, #1
30035328:	e58d300c 	str	r3, [sp, #12]
3003532c:	e59d300c 	ldr	r3, [sp, #12]
30035330:	e3530008 	cmp	r3, #8
30035334:	daffffeb 	ble	300352e8 <sin+0x144>
		sum += talor_sin_cal(x, i);
	return sum;
30035338:	e28d4010 	add	r4, sp, #16
3003533c:	e8940018 	ldm	r4, {r3, r4}
}
30035340:	e1a00003 	mov	r0, r3
30035344:	e1a01004 	mov	r1, r4
30035348:	e28dd018 	add	sp, sp, #24
3003534c:	e8bd4010 	pop	{r4, lr}
30035350:	e12fff1e 	bx	lr
30035354:	e1a00000 	nop			; (mov r0, r0)
30035358:	544486e0 	.word	0x544486e0
3003535c:	401921fb 	.word	0x401921fb

30035360 <cos>:
		}while(x < 0);
	}
	for(i=1; i<=talor_lev; i++)
		sum += talor_cos_cal(x, i);
	return sum;*/
	return sin(x+talor_pi/2);
30035360:	e92d4010 	push	{r4, lr}
30035364:	e24dd010 	sub	sp, sp, #16
30035368:	e88d0003 	stm	sp, {r0, r1}
3003536c:	e89d0003 	ldm	sp, {r0, r1}
30035370:	e28f3038 	add	r3, pc, #56	; 0x38
30035374:	e893000c 	ldm	r3, {r2, r3}
30035378:	eb003ae3 	bl	30043f0c <__adddf3>
3003537c:	e1a03000 	mov	r3, r0
30035380:	e1a04001 	mov	r4, r1
30035384:	e1a00003 	mov	r0, r3
30035388:	e1a01004 	mov	r1, r4
3003538c:	ebffff84 	bl	300351a4 <sin>
30035390:	e1a03000 	mov	r3, r0
30035394:	e1a04001 	mov	r4, r1
}
30035398:	e1a00003 	mov	r0, r3
3003539c:	e1a01004 	mov	r1, r4
300353a0:	e28dd010 	add	sp, sp, #16
300353a4:	e8bd4010 	pop	{r4, lr}
300353a8:	e12fff1e 	bx	lr
300353ac:	e1a00000 	nop			; (mov r0, r0)
300353b0:	544486e0 	.word	0x544486e0
300353b4:	3ff921fb 	.word	0x3ff921fb

300353b8 <tan>:

double tan(double x) {
	return sin(x)/cos(x);
300353b8:	e92d4070 	push	{r4, r5, r6, lr}
300353bc:	e24dd008 	sub	sp, sp, #8
300353c0:	e88d0003 	stm	sp, {r0, r1}
300353c4:	e89d0003 	ldm	sp, {r0, r1}
300353c8:	ebffff75 	bl	300351a4 <sin>
300353cc:	e1a05000 	mov	r5, r0
300353d0:	e1a06001 	mov	r6, r1
300353d4:	e89d0003 	ldm	sp, {r0, r1}
300353d8:	ebffffe0 	bl	30035360 <cos>
300353dc:	e1a03000 	mov	r3, r0
300353e0:	e1a04001 	mov	r4, r1
300353e4:	e1a00005 	mov	r0, r5
300353e8:	e1a01006 	mov	r1, r6
300353ec:	e1a02003 	mov	r2, r3
300353f0:	e1a03004 	mov	r3, r4
300353f4:	eb003c6c 	bl	300445ac <__aeabi_ddiv>
300353f8:	e1a03000 	mov	r3, r0
300353fc:	e1a04001 	mov	r4, r1
}
30035400:	e1a00003 	mov	r0, r3
30035404:	e1a01004 	mov	r1, r4
30035408:	e28dd008 	add	sp, sp, #8
3003540c:	e8bd4070 	pop	{r4, r5, r6, lr}
30035410:	e12fff1e 	bx	lr

30035414 <talor_exp_cal>:



double talor_exp_cal(double x, int k) {
30035414:	e92d4070 	push	{r4, r5, r6, lr}
30035418:	e24dd010 	sub	sp, sp, #16
3003541c:	e58d0008 	str	r0, [sp, #8]
30035420:	e58d100c 	str	r1, [sp, #12]
30035424:	e58d2004 	str	r2, [sp, #4]
	return talor_pow(x, k)/talor_factorial(k);
30035428:	e28d1008 	add	r1, sp, #8
3003542c:	e8910003 	ldm	r1, {r0, r1}
30035430:	e59d2004 	ldr	r2, [sp, #4]
30035434:	ebfffe9c 	bl	30034eac <talor_pow>
30035438:	e1a05000 	mov	r5, r0
3003543c:	e1a06001 	mov	r6, r1
30035440:	e59d0004 	ldr	r0, [sp, #4]
30035444:	eb003b7d 	bl	30044240 <__aeabi_i2d>
30035448:	e1a03000 	mov	r3, r0
3003544c:	e1a04001 	mov	r4, r1
30035450:	e1a00003 	mov	r0, r3
30035454:	e1a01004 	mov	r1, r4
30035458:	ebfffe3a 	bl	30034d48 <talor_factorial>
3003545c:	e1a03000 	mov	r3, r0
30035460:	e1a04001 	mov	r4, r1
30035464:	e1a00005 	mov	r0, r5
30035468:	e1a01006 	mov	r1, r6
3003546c:	e1a02003 	mov	r2, r3
30035470:	e1a03004 	mov	r3, r4
30035474:	eb003c4c 	bl	300445ac <__aeabi_ddiv>
30035478:	e1a03000 	mov	r3, r0
3003547c:	e1a04001 	mov	r4, r1
}
30035480:	e1a00003 	mov	r0, r3
30035484:	e1a01004 	mov	r1, r4
30035488:	e28dd010 	add	sp, sp, #16
3003548c:	e8bd4070 	pop	{r4, r5, r6, lr}
30035490:	e12fff1e 	bx	lr

30035494 <exp>:
            2, 1
};


int exp(int x)
{
30035494:	e24dd010 	sub	sp, sp, #16
30035498:	e58d0004 	str	r0, [sp, #4]
      int y = 1024;
3003549c:	e3a03b01 	mov	r3, #1024	; 0x400
300354a0:	e58d3008 	str	r3, [sp, #8]
      int i;
	  //if(x < 0)
		//  return 1/exp(-x);
	  for (i=0; i<8; i++) {
300354a4:	e3a03000 	mov	r3, #0
300354a8:	e58d300c 	str	r3, [sp, #12]
300354ac:	ea000015 	b	30035508 <exp+0x74>
            if (x >= C1[i]) {
300354b0:	e59d200c 	ldr	r2, [sp, #12]
300354b4:	e59f30d8 	ldr	r3, [pc, #216]	; 30035594 <exp+0x100>
300354b8:	e7932102 	ldr	r2, [r3, r2, lsl #2]
300354bc:	e59d3004 	ldr	r3, [sp, #4]
300354c0:	e1520003 	cmp	r2, r3
300354c4:	ca00000c 	bgt	300354fc <exp+0x68>
                  x -= C1[i];
300354c8:	e59d200c 	ldr	r2, [sp, #12]
300354cc:	e59f30c0 	ldr	r3, [pc, #192]	; 30035594 <exp+0x100>
300354d0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300354d4:	e59d2004 	ldr	r2, [sp, #4]
300354d8:	e0633002 	rsb	r3, r3, r2
300354dc:	e58d3004 	str	r3, [sp, #4]
                  y *= 1L <<(1<<(7-i));
300354e0:	e59d300c 	ldr	r3, [sp, #12]
300354e4:	e2633007 	rsb	r3, r3, #7
300354e8:	e3a02001 	mov	r2, #1
300354ec:	e1a03312 	lsl	r3, r2, r3
300354f0:	e59d2008 	ldr	r2, [sp, #8]
300354f4:	e1a03312 	lsl	r3, r2, r3
300354f8:	e58d3008 	str	r3, [sp, #8]
{
      int y = 1024;
      int i;
	  //if(x < 0)
		//  return 1/exp(-x);
	  for (i=0; i<8; i++) {
300354fc:	e59d300c 	ldr	r3, [sp, #12]
30035500:	e2833001 	add	r3, r3, #1
30035504:	e58d300c 	str	r3, [sp, #12]
30035508:	e59d300c 	ldr	r3, [sp, #12]
3003550c:	e3530007 	cmp	r3, #7
30035510:	daffffe6 	ble	300354b0 <exp+0x1c>
            if (x >= C1[i]) {
                  x -= C1[i];
                  y *= 1L <<(1<<(7-i));
            }
      }
      for (i=0; i<10; i++) {
30035514:	e3a03000 	mov	r3, #0
30035518:	e58d300c 	str	r3, [sp, #12]
3003551c:	ea000015 	b	30035578 <exp+0xe4>
            if (x >= C2[i]) {
30035520:	e59d200c 	ldr	r2, [sp, #12]
30035524:	e59f306c 	ldr	r3, [pc, #108]	; 30035598 <exp+0x104>
30035528:	e7932102 	ldr	r2, [r3, r2, lsl #2]
3003552c:	e59d3004 	ldr	r3, [sp, #4]
30035530:	e1520003 	cmp	r2, r3
30035534:	ca00000c 	bgt	3003556c <exp+0xd8>
                  x -= C2[i];
30035538:	e59d200c 	ldr	r2, [sp, #12]
3003553c:	e59f3054 	ldr	r3, [pc, #84]	; 30035598 <exp+0x104>
30035540:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30035544:	e59d2004 	ldr	r2, [sp, #4]
30035548:	e0633002 	rsb	r3, r3, r2
3003554c:	e58d3004 	str	r3, [sp, #4]
                  //y += y / (1<<(i+1));
				  y += y>>(i+1);
30035550:	e59d300c 	ldr	r3, [sp, #12]
30035554:	e2833001 	add	r3, r3, #1
30035558:	e59d2008 	ldr	r2, [sp, #8]
3003555c:	e1a03352 	asr	r3, r2, r3
30035560:	e59d2008 	ldr	r2, [sp, #8]
30035564:	e0823003 	add	r3, r2, r3
30035568:	e58d3008 	str	r3, [sp, #8]
            if (x >= C1[i]) {
                  x -= C1[i];
                  y *= 1L <<(1<<(7-i));
            }
      }
      for (i=0; i<10; i++) {
3003556c:	e59d300c 	ldr	r3, [sp, #12]
30035570:	e2833001 	add	r3, r3, #1
30035574:	e58d300c 	str	r3, [sp, #12]
30035578:	e59d300c 	ldr	r3, [sp, #12]
3003557c:	e3530009 	cmp	r3, #9
30035580:	daffffe6 	ble	30035520 <exp+0x8c>
                  x -= C2[i];
                  //y += y / (1<<(i+1));
				  y += y>>(i+1);
			}
      }
      return y;
30035584:	e59d3008 	ldr	r3, [sp, #8]
}
30035588:	e1a00003 	mov	r0, r3
3003558c:	e28dd010 	add	sp, sp, #16
30035590:	e12fff1e 	bx	lr
30035594:	300c63d0 	.word	0x300c63d0
30035598:	300c63f0 	.word	0x300c63f0

3003559c <log>:



double log(double a) {
   int N = 10;//我们取了前15+1项来估算
3003559c:	e92d4070 	push	{r4, r5, r6, lr}
300355a0:	e24dd030 	sub	sp, sp, #48	; 0x30
300355a4:	e88d0003 	stm	sp, {r0, r1}
300355a8:	e3a0300a 	mov	r3, #10
300355ac:	e58d300c 	str	r3, [sp, #12]
   int k,nk;
   double x,xx,y;
   x = (a-1)/(a+1);
300355b0:	e89d0003 	ldm	sp, {r0, r1}
300355b4:	e3a02000 	mov	r2, #0
300355b8:	e3a035ff 	mov	r3, #1069547520	; 0x3fc00000
300355bc:	e2833603 	add	r3, r3, #3145728	; 0x300000
300355c0:	eb003a50 	bl	30043f08 <__aeabi_dsub>
300355c4:	e1a03000 	mov	r3, r0
300355c8:	e1a04001 	mov	r4, r1
300355cc:	e1a05003 	mov	r5, r3
300355d0:	e1a06004 	mov	r6, r4
300355d4:	e89d0003 	ldm	sp, {r0, r1}
300355d8:	e3a02000 	mov	r2, #0
300355dc:	e3a035ff 	mov	r3, #1069547520	; 0x3fc00000
300355e0:	e2833603 	add	r3, r3, #3145728	; 0x300000
300355e4:	eb003a48 	bl	30043f0c <__adddf3>
300355e8:	e1a03000 	mov	r3, r0
300355ec:	e1a04001 	mov	r4, r1
300355f0:	e1a00005 	mov	r0, r5
300355f4:	e1a01006 	mov	r1, r6
300355f8:	e1a02003 	mov	r2, r3
300355fc:	e1a03004 	mov	r3, r4
30035600:	eb003be9 	bl	300445ac <__aeabi_ddiv>
30035604:	e1a03000 	mov	r3, r0
30035608:	e1a04001 	mov	r4, r1
3003560c:	e58d3018 	str	r3, [sp, #24]
30035610:	e58d401c 	str	r4, [sp, #28]
   xx = x*x;
30035614:	e28d1018 	add	r1, sp, #24
30035618:	e8910003 	ldm	r1, {r0, r1}
3003561c:	e28d3018 	add	r3, sp, #24
30035620:	e893000c 	ldm	r3, {r2, r3}
30035624:	eb003b3c 	bl	3004431c <__aeabi_dmul>
30035628:	e1a03000 	mov	r3, r0
3003562c:	e1a04001 	mov	r4, r1
30035630:	e58d3020 	str	r3, [sp, #32]
30035634:	e58d4024 	str	r4, [sp, #36]	; 0x24
   nk = 2*N+1;
30035638:	e59d300c 	ldr	r3, [sp, #12]
3003563c:	e1a03083 	lsl	r3, r3, #1
30035640:	e2833001 	add	r3, r3, #1
30035644:	e58d3014 	str	r3, [sp, #20]
   y = 1.0/nk;
30035648:	e59d0014 	ldr	r0, [sp, #20]
3003564c:	eb003afb 	bl	30044240 <__aeabi_i2d>
30035650:	e1a03000 	mov	r3, r0
30035654:	e1a04001 	mov	r4, r1
30035658:	e3a00000 	mov	r0, #0
3003565c:	e3a015ff 	mov	r1, #1069547520	; 0x3fc00000
30035660:	e2811603 	add	r1, r1, #3145728	; 0x300000
30035664:	e1a02003 	mov	r2, r3
30035668:	e1a03004 	mov	r3, r4
3003566c:	eb003bce 	bl	300445ac <__aeabi_ddiv>
30035670:	e1a03000 	mov	r3, r0
30035674:	e1a04001 	mov	r4, r1
30035678:	e58d3028 	str	r3, [sp, #40]	; 0x28
3003567c:	e58d402c 	str	r4, [sp, #44]	; 0x2c
   for(k=N;k>0;k--)
30035680:	e59d300c 	ldr	r3, [sp, #12]
30035684:	e58d3010 	str	r3, [sp, #16]
30035688:	ea000023 	b	3003571c <log+0x180>
   {
     nk = nk - 2;
3003568c:	e59d3014 	ldr	r3, [sp, #20]
30035690:	e2433002 	sub	r3, r3, #2
30035694:	e58d3014 	str	r3, [sp, #20]
     y = 1.0/nk+xx*y;
30035698:	e59d0014 	ldr	r0, [sp, #20]
3003569c:	eb003ae7 	bl	30044240 <__aeabi_i2d>
300356a0:	e1a03000 	mov	r3, r0
300356a4:	e1a04001 	mov	r4, r1
300356a8:	e3a00000 	mov	r0, #0
300356ac:	e3a015ff 	mov	r1, #1069547520	; 0x3fc00000
300356b0:	e2811603 	add	r1, r1, #3145728	; 0x300000
300356b4:	e1a02003 	mov	r2, r3
300356b8:	e1a03004 	mov	r3, r4
300356bc:	eb003bba 	bl	300445ac <__aeabi_ddiv>
300356c0:	e1a03000 	mov	r3, r0
300356c4:	e1a04001 	mov	r4, r1
300356c8:	e1a05003 	mov	r5, r3
300356cc:	e1a06004 	mov	r6, r4
300356d0:	e28d1020 	add	r1, sp, #32
300356d4:	e8910003 	ldm	r1, {r0, r1}
300356d8:	e28d3028 	add	r3, sp, #40	; 0x28
300356dc:	e893000c 	ldm	r3, {r2, r3}
300356e0:	eb003b0d 	bl	3004431c <__aeabi_dmul>
300356e4:	e1a03000 	mov	r3, r0
300356e8:	e1a04001 	mov	r4, r1
300356ec:	e1a00005 	mov	r0, r5
300356f0:	e1a01006 	mov	r1, r6
300356f4:	e1a02003 	mov	r2, r3
300356f8:	e1a03004 	mov	r3, r4
300356fc:	eb003a02 	bl	30043f0c <__adddf3>
30035700:	e1a03000 	mov	r3, r0
30035704:	e1a04001 	mov	r4, r1
30035708:	e58d3028 	str	r3, [sp, #40]	; 0x28
3003570c:	e58d402c 	str	r4, [sp, #44]	; 0x2c
   double x,xx,y;
   x = (a-1)/(a+1);
   xx = x*x;
   nk = 2*N+1;
   y = 1.0/nk;
   for(k=N;k>0;k--)
30035710:	e59d3010 	ldr	r3, [sp, #16]
30035714:	e2433001 	sub	r3, r3, #1
30035718:	e58d3010 	str	r3, [sp, #16]
3003571c:	e59d3010 	ldr	r3, [sp, #16]
30035720:	e3530000 	cmp	r3, #0
30035724:	caffffd8 	bgt	3003568c <log+0xf0>
   {
     nk = nk - 2;
     y = 1.0/nk+xx*y;
     
   }
   return 2.0*x*y;
30035728:	e28d4018 	add	r4, sp, #24
3003572c:	e8940018 	ldm	r4, {r3, r4}
30035730:	e1a00003 	mov	r0, r3
30035734:	e1a01004 	mov	r1, r4
30035738:	e1a02003 	mov	r2, r3
3003573c:	e1a03004 	mov	r3, r4
30035740:	eb0039f1 	bl	30043f0c <__adddf3>
30035744:	e1a03000 	mov	r3, r0
30035748:	e1a04001 	mov	r4, r1
3003574c:	e1a00003 	mov	r0, r3
30035750:	e1a01004 	mov	r1, r4
30035754:	e28d3028 	add	r3, sp, #40	; 0x28
30035758:	e893000c 	ldm	r3, {r2, r3}
3003575c:	eb003aee 	bl	3004431c <__aeabi_dmul>
30035760:	e1a03000 	mov	r3, r0
30035764:	e1a04001 	mov	r4, r1
	
}
30035768:	e1a00003 	mov	r0, r3
3003576c:	e1a01004 	mov	r1, r4
30035770:	e28dd030 	add	sp, sp, #48	; 0x30
30035774:	e8bd4070 	pop	{r4, r5, r6, lr}
30035778:	e12fff1e 	bx	lr

3003577c <pow>:
double pow(double x,double y)//计算x^y
{
	 double powint=1;
3003577c:	e92d4070 	push	{r4, r5, r6, lr}
30035780:	e24dd020 	sub	sp, sp, #32
30035784:	e58d0008 	str	r0, [sp, #8]
30035788:	e58d100c 	str	r1, [sp, #12]
3003578c:	e88d000c 	stm	sp, {r2, r3}
30035790:	e3a02000 	mov	r2, #0
30035794:	e3a035ff 	mov	r3, #1069547520	; 0x3fc00000
30035798:	e2833603 	add	r3, r3, #3145728	; 0x300000
3003579c:	e58d2010 	str	r2, [sp, #16]
300357a0:	e58d3014 	str	r3, [sp, #20]
     int i;
     if(x==0 && y!=0) 
300357a4:	e28d1008 	add	r1, sp, #8
300357a8:	e8910003 	ldm	r1, {r0, r1}
300357ac:	e3a02000 	mov	r2, #0
300357b0:	e3a03000 	mov	r3, #0
300357b4:	eb003c32 	bl	30044884 <__aeabi_dcmpeq>
300357b8:	e1a03000 	mov	r3, r0
300357bc:	e3530000 	cmp	r3, #0
300357c0:	0a000009 	beq	300357ec <pow+0x70>
300357c4:	e89d0003 	ldm	sp, {r0, r1}
300357c8:	e3a02000 	mov	r2, #0
300357cc:	e3a03000 	mov	r3, #0
300357d0:	eb003c2b 	bl	30044884 <__aeabi_dcmpeq>
300357d4:	e1a03000 	mov	r3, r0
300357d8:	e3530000 	cmp	r3, #0
300357dc:	1a000002 	bne	300357ec <pow+0x70>
		 return 0;
300357e0:	e3a03000 	mov	r3, #0
300357e4:	e3a04000 	mov	r4, #0
300357e8:	ea0000b8 	b	30035ad0 <pow+0x354>
     if(x==0 && y==0) 
300357ec:	e28d1008 	add	r1, sp, #8
300357f0:	e8910003 	ldm	r1, {r0, r1}
300357f4:	e3a02000 	mov	r2, #0
300357f8:	e3a03000 	mov	r3, #0
300357fc:	eb003c20 	bl	30044884 <__aeabi_dcmpeq>
30035800:	e1a03000 	mov	r3, r0
30035804:	e3530000 	cmp	r3, #0
30035808:	0a00000a 	beq	30035838 <pow+0xbc>
3003580c:	e89d0003 	ldm	sp, {r0, r1}
30035810:	e3a02000 	mov	r2, #0
30035814:	e3a03000 	mov	r3, #0
30035818:	eb003c19 	bl	30044884 <__aeabi_dcmpeq>
3003581c:	e1a03000 	mov	r3, r0
30035820:	e3530000 	cmp	r3, #0
30035824:	0a000003 	beq	30035838 <pow+0xbc>
		 return 1;
30035828:	e3a03000 	mov	r3, #0
3003582c:	e3a045ff 	mov	r4, #1069547520	; 0x3fc00000
30035830:	e2844603 	add	r4, r4, #3145728	; 0x300000
30035834:	ea0000a5 	b	30035ad0 <pow+0x354>
     if(y<0) 
30035838:	e3a03000 	mov	r3, #0
3003583c:	e1a06003 	mov	r6, r3
30035840:	e89d0003 	ldm	sp, {r0, r1}
30035844:	e3a02000 	mov	r2, #0
30035848:	e3a03000 	mov	r3, #0
3003584c:	eb003c12 	bl	3004489c <__aeabi_dcmplt>
30035850:	e1a03000 	mov	r3, r0
30035854:	e3530000 	cmp	r3, #0
30035858:	0a000001 	beq	30035864 <pow+0xe8>
3003585c:	e3a03001 	mov	r3, #1
30035860:	e1a06003 	mov	r6, r3
30035864:	e20630ff 	and	r3, r6, #255	; 0xff
30035868:	e3530000 	cmp	r3, #0
3003586c:	0a000012 	beq	300358bc <pow+0x140>
		 return 1/pow(x,-y);//把指数小于0的情况转为1/x^-y计算
30035870:	e59d4000 	ldr	r4, [sp]
30035874:	e59d3004 	ldr	r3, [sp, #4]
30035878:	e2235102 	eor	r5, r3, #-2147483648	; 0x80000000
3003587c:	e28d1008 	add	r1, sp, #8
30035880:	e8910003 	ldm	r1, {r0, r1}
30035884:	e1a02004 	mov	r2, r4
30035888:	e1a03005 	mov	r3, r5
3003588c:	ebffffba 	bl	3003577c <pow>
30035890:	e1a03000 	mov	r3, r0
30035894:	e1a04001 	mov	r4, r1
30035898:	e3a00000 	mov	r0, #0
3003589c:	e3a015ff 	mov	r1, #1069547520	; 0x3fc00000
300358a0:	e2811603 	add	r1, r1, #3145728	; 0x300000
300358a4:	e1a02003 	mov	r2, r3
300358a8:	e1a03004 	mov	r3, r4
300358ac:	eb003b3e 	bl	300445ac <__aeabi_ddiv>
300358b0:	e1a03000 	mov	r3, r0
300358b4:	e1a04001 	mov	r4, r1
300358b8:	ea000084 	b	30035ad0 <pow+0x354>
	 if(x<0 && (y-(int)y!=0)) 
300358bc:	e3a03000 	mov	r3, #0
300358c0:	e1a04003 	mov	r4, r3
300358c4:	e28d1008 	add	r1, sp, #8
300358c8:	e8910003 	ldm	r1, {r0, r1}
300358cc:	e3a02000 	mov	r2, #0
300358d0:	e3a03000 	mov	r3, #0
300358d4:	eb003bf0 	bl	3004489c <__aeabi_dcmplt>
300358d8:	e1a03000 	mov	r3, r0
300358dc:	e3530000 	cmp	r3, #0
300358e0:	0a000001 	beq	300358ec <pow+0x170>
300358e4:	e3a03001 	mov	r3, #1
300358e8:	e1a04003 	mov	r4, r3
300358ec:	e20430ff 	and	r3, r4, #255	; 0xff
300358f0:	e3530000 	cmp	r3, #0
300358f4:	0a000017 	beq	30035958 <pow+0x1dc>
300358f8:	e89d0003 	ldm	sp, {r0, r1}
300358fc:	eb003bfe 	bl	300448fc <__aeabi_d2iz>
30035900:	e1a03000 	mov	r3, r0
30035904:	e1a00003 	mov	r0, r3
30035908:	eb003a4c 	bl	30044240 <__aeabi_i2d>
3003590c:	e1a03000 	mov	r3, r0
30035910:	e1a04001 	mov	r4, r1
30035914:	e89d0003 	ldm	sp, {r0, r1}
30035918:	e1a02003 	mov	r2, r3
3003591c:	e1a03004 	mov	r3, r4
30035920:	eb003978 	bl	30043f08 <__aeabi_dsub>
30035924:	e1a03000 	mov	r3, r0
30035928:	e1a04001 	mov	r4, r1
3003592c:	e1a00003 	mov	r0, r3
30035930:	e1a01004 	mov	r1, r4
30035934:	e3a02000 	mov	r2, #0
30035938:	e3a03000 	mov	r3, #0
3003593c:	eb003bd0 	bl	30044884 <__aeabi_dcmpeq>
30035940:	e1a03000 	mov	r3, r0
30035944:	e3530000 	cmp	r3, #0
30035948:	1a000002 	bne	30035958 <pow+0x1dc>
		 return 0;//若x为负，且y不为整数数，则出错，返回0
3003594c:	e3a03000 	mov	r3, #0
30035950:	e3a04000 	mov	r4, #0
30035954:	ea00005d 	b	30035ad0 <pow+0x354>
     if(x<0 && (y-(int)y==0))//若x为负，且y为整数数，则用循环计算
30035958:	e3a03000 	mov	r3, #0
3003595c:	e1a04003 	mov	r4, r3
30035960:	e28d1008 	add	r1, sp, #8
30035964:	e8910003 	ldm	r1, {r0, r1}
30035968:	e3a02000 	mov	r2, #0
3003596c:	e3a03000 	mov	r3, #0
30035970:	eb003bc9 	bl	3004489c <__aeabi_dcmplt>
30035974:	e1a03000 	mov	r3, r0
30035978:	e3530000 	cmp	r3, #0
3003597c:	0a000001 	beq	30035988 <pow+0x20c>
30035980:	e3a03001 	mov	r3, #1
30035984:	e1a04003 	mov	r4, r3
30035988:	e20430ff 	and	r3, r4, #255	; 0xff
3003598c:	e3530000 	cmp	r3, #0
30035990:	0a000038 	beq	30035a78 <pow+0x2fc>
30035994:	e89d0003 	ldm	sp, {r0, r1}
30035998:	eb003bd7 	bl	300448fc <__aeabi_d2iz>
3003599c:	e1a03000 	mov	r3, r0
300359a0:	e1a00003 	mov	r0, r3
300359a4:	eb003a25 	bl	30044240 <__aeabi_i2d>
300359a8:	e1a03000 	mov	r3, r0
300359ac:	e1a04001 	mov	r4, r1
300359b0:	e89d0003 	ldm	sp, {r0, r1}
300359b4:	e1a02003 	mov	r2, r3
300359b8:	e1a03004 	mov	r3, r4
300359bc:	eb003951 	bl	30043f08 <__aeabi_dsub>
300359c0:	e1a03000 	mov	r3, r0
300359c4:	e1a04001 	mov	r4, r1
300359c8:	e1a00003 	mov	r0, r3
300359cc:	e1a01004 	mov	r1, r4
300359d0:	e3a02000 	mov	r2, #0
300359d4:	e3a03000 	mov	r3, #0
300359d8:	eb003ba9 	bl	30044884 <__aeabi_dcmpeq>
300359dc:	e1a03000 	mov	r3, r0
300359e0:	e3530000 	cmp	r3, #0
300359e4:	0a000023 	beq	30035a78 <pow+0x2fc>
        {
           for(i=1;i<=y;i++) 
300359e8:	e3a03001 	mov	r3, #1
300359ec:	e58d301c 	str	r3, [sp, #28]
300359f0:	ea00000b 	b	30035a24 <pow+0x2a8>
			   powint*=x;
300359f4:	e28d1010 	add	r1, sp, #16
300359f8:	e8910003 	ldm	r1, {r0, r1}
300359fc:	e28d3008 	add	r3, sp, #8
30035a00:	e893000c 	ldm	r3, {r2, r3}
30035a04:	eb003a44 	bl	3004431c <__aeabi_dmul>
30035a08:	e1a03000 	mov	r3, r0
30035a0c:	e1a04001 	mov	r4, r1
30035a10:	e58d3010 	str	r3, [sp, #16]
30035a14:	e58d4014 	str	r4, [sp, #20]
		 return 1/pow(x,-y);//把指数小于0的情况转为1/x^-y计算
	 if(x<0 && (y-(int)y!=0)) 
		 return 0;//若x为负，且y不为整数数，则出错，返回0
     if(x<0 && (y-(int)y==0))//若x为负，且y为整数数，则用循环计算
        {
           for(i=1;i<=y;i++) 
30035a18:	e59d301c 	ldr	r3, [sp, #28]
30035a1c:	e2833001 	add	r3, r3, #1
30035a20:	e58d301c 	str	r3, [sp, #28]
30035a24:	e59d001c 	ldr	r0, [sp, #28]
30035a28:	eb003a04 	bl	30044240 <__aeabi_i2d>
30035a2c:	e1a03000 	mov	r3, r0
30035a30:	e1a04001 	mov	r4, r1
30035a34:	e3a02000 	mov	r2, #0
30035a38:	e1a05002 	mov	r5, r2
30035a3c:	e1a00003 	mov	r0, r3
30035a40:	e1a01004 	mov	r1, r4
30035a44:	e89d000c 	ldm	sp, {r2, r3}
30035a48:	eb003b99 	bl	300448b4 <__aeabi_dcmple>
30035a4c:	e1a03000 	mov	r3, r0
30035a50:	e3530000 	cmp	r3, #0
30035a54:	0a000001 	beq	30035a60 <pow+0x2e4>
30035a58:	e3a03001 	mov	r3, #1
30035a5c:	e1a05003 	mov	r5, r3
30035a60:	e20530ff 	and	r3, r5, #255	; 0xff
30035a64:	e3530000 	cmp	r3, #0
30035a68:	1affffe1 	bne	300359f4 <pow+0x278>
			   powint*=x;
			return powint;
30035a6c:	e28d4010 	add	r4, sp, #16
30035a70:	e8940018 	ldm	r4, {r3, r4}
30035a74:	ea000015 	b	30035ad0 <pow+0x354>
       }
     //return expP(y*lnP(x));
	  //return exp((int)(y*log(x)));
		return exp(y*log(x));
30035a78:	e28d1008 	add	r1, sp, #8
30035a7c:	e8910003 	ldm	r1, {r0, r1}
30035a80:	ebfffec5 	bl	3003559c <log>
30035a84:	e1a03000 	mov	r3, r0
30035a88:	e1a04001 	mov	r4, r1
30035a8c:	e1a00003 	mov	r0, r3
30035a90:	e1a01004 	mov	r1, r4
30035a94:	e89d000c 	ldm	sp, {r2, r3}
30035a98:	eb003a1f 	bl	3004431c <__aeabi_dmul>
30035a9c:	e1a03000 	mov	r3, r0
30035aa0:	e1a04001 	mov	r4, r1
30035aa4:	e1a00003 	mov	r0, r3
30035aa8:	e1a01004 	mov	r1, r4
30035aac:	eb003b92 	bl	300448fc <__aeabi_d2iz>
30035ab0:	e1a03000 	mov	r3, r0
30035ab4:	e1a00003 	mov	r0, r3
30035ab8:	ebfffe75 	bl	30035494 <exp>
30035abc:	e1a03000 	mov	r3, r0
30035ac0:	e1a00003 	mov	r0, r3
30035ac4:	eb0039dd 	bl	30044240 <__aeabi_i2d>
30035ac8:	e1a03000 	mov	r3, r0
30035acc:	e1a04001 	mov	r4, r1
	 	
}	
30035ad0:	e1a00003 	mov	r0, r3
30035ad4:	e1a01004 	mov	r1, r4
30035ad8:	e28dd020 	add	sp, sp, #32
30035adc:	e8bd4070 	pop	{r4, r5, r6, lr}
30035ae0:	e12fff1e 	bx	lr

30035ae4 <sqrt>:
}*/
#define my_abs(x) ((x)>0?(x):(-x))

double sqrt(double x)
{
	double val = x;//最终
30035ae4:	e92d4070 	push	{r4, r5, r6, lr}
30035ae8:	e24dd018 	sub	sp, sp, #24
30035aec:	e88d0003 	stm	sp, {r0, r1}
30035af0:	e89d000c 	ldm	sp, {r2, r3}
30035af4:	e58d2008 	str	r2, [sp, #8]
30035af8:	e58d300c 	str	r3, [sp, #12]
	double last;//保存上一个计算的值
	do
	{
		last = val;
30035afc:	e28d3008 	add	r3, sp, #8
30035b00:	e893000c 	ldm	r3, {r2, r3}
30035b04:	e58d2010 	str	r2, [sp, #16]
30035b08:	e58d3014 	str	r3, [sp, #20]
		val =(val + x/val) / 2;
30035b0c:	e89d0003 	ldm	sp, {r0, r1}
30035b10:	e28d3008 	add	r3, sp, #8
30035b14:	e893000c 	ldm	r3, {r2, r3}
30035b18:	eb003aa3 	bl	300445ac <__aeabi_ddiv>
30035b1c:	e1a02000 	mov	r2, r0
30035b20:	e1a03001 	mov	r3, r1
30035b24:	e1a00002 	mov	r0, r2
30035b28:	e1a01003 	mov	r1, r3
30035b2c:	e28d3008 	add	r3, sp, #8
30035b30:	e893000c 	ldm	r3, {r2, r3}
30035b34:	eb0038f4 	bl	30043f0c <__adddf3>
30035b38:	e1a02000 	mov	r2, r0
30035b3c:	e1a03001 	mov	r3, r1
30035b40:	e1a00002 	mov	r0, r2
30035b44:	e1a01003 	mov	r1, r3
30035b48:	e3a02000 	mov	r2, #0
30035b4c:	e3a03101 	mov	r3, #1073741824	; 0x40000000
30035b50:	eb003a95 	bl	300445ac <__aeabi_ddiv>
30035b54:	e1a02000 	mov	r2, r0
30035b58:	e1a03001 	mov	r3, r1
30035b5c:	e58d2008 	str	r2, [sp, #8]
30035b60:	e58d300c 	str	r3, [sp, #12]
	}while(my_abs(val-last) > 0.0001);
30035b64:	e28d1008 	add	r1, sp, #8
30035b68:	e8910003 	ldm	r1, {r0, r1}
30035b6c:	e28d3010 	add	r3, sp, #16
30035b70:	e893000c 	ldm	r3, {r2, r3}
30035b74:	eb0038e3 	bl	30043f08 <__aeabi_dsub>
30035b78:	e1a02000 	mov	r2, r0
30035b7c:	e1a03001 	mov	r3, r1
30035b80:	e3a01000 	mov	r1, #0
30035b84:	e1a06001 	mov	r6, r1
30035b88:	e1a00002 	mov	r0, r2
30035b8c:	e1a01003 	mov	r1, r3
30035b90:	e3a02000 	mov	r2, #0
30035b94:	e3a03000 	mov	r3, #0
30035b98:	eb003b51 	bl	300448e4 <__aeabi_dcmpgt>
30035b9c:	e1a03000 	mov	r3, r0
30035ba0:	e3530000 	cmp	r3, #0
30035ba4:	0a000001 	beq	30035bb0 <sqrt+0xcc>
30035ba8:	e3a03001 	mov	r3, #1
30035bac:	e1a06003 	mov	r6, r3
30035bb0:	e20630ff 	and	r3, r6, #255	; 0xff
30035bb4:	e3530000 	cmp	r3, #0
30035bb8:	0a000014 	beq	30035c10 <sqrt+0x12c>
30035bbc:	e28d1008 	add	r1, sp, #8
30035bc0:	e8910003 	ldm	r1, {r0, r1}
30035bc4:	e28d3010 	add	r3, sp, #16
30035bc8:	e893000c 	ldm	r3, {r2, r3}
30035bcc:	eb0038cd 	bl	30043f08 <__aeabi_dsub>
30035bd0:	e1a02000 	mov	r2, r0
30035bd4:	e1a03001 	mov	r3, r1
30035bd8:	e3a01000 	mov	r1, #0
30035bdc:	e1a06001 	mov	r6, r1
30035be0:	e1a00002 	mov	r0, r2
30035be4:	e1a01003 	mov	r1, r3
30035be8:	e28f30a0 	add	r3, pc, #160	; 0xa0
30035bec:	e893000c 	ldm	r3, {r2, r3}
30035bf0:	eb003b3b 	bl	300448e4 <__aeabi_dcmpgt>
30035bf4:	e1a03000 	mov	r3, r0
30035bf8:	e3530000 	cmp	r3, #0
30035bfc:	0a000001 	beq	30035c08 <sqrt+0x124>
30035c00:	e3a03001 	mov	r3, #1
30035c04:	e1a06003 	mov	r6, r3
30035c08:	e20630ff 	and	r3, r6, #255	; 0xff
30035c0c:	ea000016 	b	30035c6c <sqrt+0x188>
30035c10:	e59d4008 	ldr	r4, [sp, #8]
30035c14:	e59d300c 	ldr	r3, [sp, #12]
30035c18:	e2235102 	eor	r5, r3, #-2147483648	; 0x80000000
30035c1c:	e1a00004 	mov	r0, r4
30035c20:	e1a01005 	mov	r1, r5
30035c24:	e28d3010 	add	r3, sp, #16
30035c28:	e893000c 	ldm	r3, {r2, r3}
30035c2c:	eb0038b5 	bl	30043f08 <__aeabi_dsub>
30035c30:	e1a02000 	mov	r2, r0
30035c34:	e1a03001 	mov	r3, r1
30035c38:	e3a01000 	mov	r1, #0
30035c3c:	e1a06001 	mov	r6, r1
30035c40:	e1a00002 	mov	r0, r2
30035c44:	e1a01003 	mov	r1, r3
30035c48:	e28f3040 	add	r3, pc, #64	; 0x40
30035c4c:	e893000c 	ldm	r3, {r2, r3}
30035c50:	eb003b23 	bl	300448e4 <__aeabi_dcmpgt>
30035c54:	e1a03000 	mov	r3, r0
30035c58:	e3530000 	cmp	r3, #0
30035c5c:	0a000001 	beq	30035c68 <sqrt+0x184>
30035c60:	e3a03001 	mov	r3, #1
30035c64:	e1a06003 	mov	r6, r3
30035c68:	e20630ff 	and	r3, r6, #255	; 0xff
30035c6c:	e3530000 	cmp	r3, #0
30035c70:	1affffa1 	bne	30035afc <sqrt+0x18>
	//while(abs(val-last) > 0.000001)
	return val;
30035c74:	e28d4008 	add	r4, sp, #8
30035c78:	e8940018 	ldm	r4, {r3, r4}
}	
30035c7c:	e1a00003 	mov	r0, r3
30035c80:	e1a01004 	mov	r1, r4
30035c84:	e28dd018 	add	sp, sp, #24
30035c88:	e8bd4070 	pop	{r4, r5, r6, lr}
30035c8c:	e12fff1e 	bx	lr
30035c90:	eb1c432d 	.word	0xeb1c432d
30035c94:	3f1a36e2 	.word	0x3f1a36e2

30035c98 <modf>:



double modf(double x, double *ipart) {
	int a = (int)x;
30035c98:	e92d4010 	push	{r4, lr}
30035c9c:	e24dd018 	sub	sp, sp, #24
30035ca0:	e58d0008 	str	r0, [sp, #8]
30035ca4:	e58d100c 	str	r1, [sp, #12]
30035ca8:	e58d2004 	str	r2, [sp, #4]
30035cac:	e28d1008 	add	r1, sp, #8
30035cb0:	e8910003 	ldm	r1, {r0, r1}
30035cb4:	eb003b10 	bl	300448fc <__aeabi_d2iz>
30035cb8:	e1a03000 	mov	r3, r0
30035cbc:	e58d3014 	str	r3, [sp, #20]
	*ipart = a;
30035cc0:	e59d0014 	ldr	r0, [sp, #20]
30035cc4:	eb00395d 	bl	30044240 <__aeabi_i2d>
30035cc8:	e1a03000 	mov	r3, r0
30035ccc:	e1a04001 	mov	r4, r1
30035cd0:	e59d2004 	ldr	r2, [sp, #4]
30035cd4:	e8820018 	stm	r2, {r3, r4}
	return x-a;
30035cd8:	e59d0014 	ldr	r0, [sp, #20]
30035cdc:	eb003957 	bl	30044240 <__aeabi_i2d>
30035ce0:	e1a03000 	mov	r3, r0
30035ce4:	e1a04001 	mov	r4, r1
30035ce8:	e28d1008 	add	r1, sp, #8
30035cec:	e8910003 	ldm	r1, {r0, r1}
30035cf0:	e1a02003 	mov	r2, r3
30035cf4:	e1a03004 	mov	r3, r4
30035cf8:	eb003882 	bl	30043f08 <__aeabi_dsub>
30035cfc:	e1a03000 	mov	r3, r0
30035d00:	e1a04001 	mov	r4, r1
}
30035d04:	e1a00003 	mov	r0, r3
30035d08:	e1a01004 	mov	r1, r4
30035d0c:	e28dd018 	add	sp, sp, #24
30035d10:	e8bd4010 	pop	{r4, lr}
30035d14:	e12fff1e 	bx	lr

30035d18 <open_bit_stream_r>:
unsigned short buffer[BUFFER_SIZE];


/* open the device to read the bit stream from it */
void open_bit_stream_r()
{
30035d18:	e92d4008 	push	{r3, lr}
	bs.buf=buffer;
30035d1c:	e59f305c 	ldr	r3, [pc, #92]	; 30035d80 <open_bit_stream_r+0x68>
30035d20:	e59f205c 	ldr	r2, [pc, #92]	; 30035d84 <open_bit_stream_r+0x6c>
30035d24:	e5832000 	str	r2, [r3]
	bs.read_ptr=0;
30035d28:	e59f3050 	ldr	r3, [pc, #80]	; 30035d80 <open_bit_stream_r+0x68>
30035d2c:	e3a02000 	mov	r2, #0
30035d30:	e5832008 	str	r2, [r3, #8]
	bs.write_ptr=0;
30035d34:	e59f3044 	ldr	r3, [pc, #68]	; 30035d80 <open_bit_stream_r+0x68>
30035d38:	e3a02000 	mov	r2, #0
30035d3c:	e5832010 	str	r2, [r3, #16]
	bs.bit_len=16;
30035d40:	e59f3038 	ldr	r3, [pc, #56]	; 30035d80 <open_bit_stream_r+0x68>
30035d44:	e3a02010 	mov	r2, #16
30035d48:	e583200c 	str	r2, [r3, #12]
	bs.totbit=0;
30035d4c:	e59f302c 	ldr	r3, [pc, #44]	; 30035d80 <open_bit_stream_r+0x68>
30035d50:	e3a02000 	mov	r2, #0
30035d54:	e5832004 	str	r2, [r3, #4]
	bs.eof = FALSE;
30035d58:	e59f3020 	ldr	r3, [pc, #32]	; 30035d80 <open_bit_stream_r+0x68>
30035d5c:	e3a02000 	mov	r2, #0
30035d60:	e5832014 	str	r2, [r3, #20]
	bs.eobs = FALSE;
30035d64:	e59f3014 	ldr	r3, [pc, #20]	; 30035d80 <open_bit_stream_r+0x68>
30035d68:	e3a02000 	mov	r2, #0
30035d6c:	e5832018 	str	r2, [r3, #24]
	quest_stream(&bs.write_ptr);
30035d70:	e59f0010 	ldr	r0, [pc, #16]	; 30035d88 <open_bit_stream_r+0x70>
30035d74:	eb0000f2 	bl	30036144 <quest_stream>
}
30035d78:	e8bd4008 	pop	{r3, lr}
30035d7c:	e12fff1e 	bx	lr
30035d80:	302f7e28 	.word	0x302f7e28
30035d84:	3012b684 	.word	0x3012b684
30035d88:	302f7e38 	.word	0x302f7e38

30035d8c <seek_sync>:
/* returns 0 if end of bit stream was not reached */

int mask[8]={0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};

int seek_sync(unsigned int sync)
{
30035d8c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30035d90:	e24dd014 	sub	sp, sp, #20
30035d94:	e58d0004 	str	r0, [sp, #4]
	unsigned int aligning;
	unsigned int val;

    aligning = bs.totbit%ALIGNING;
30035d98:	e59f30b0 	ldr	r3, [pc, #176]	; 30035e50 <seek_sync+0xc4>
30035d9c:	e5933004 	ldr	r3, [r3, #4]
30035da0:	e2033007 	and	r3, r3, #7
30035da4:	e58d3008 	str	r3, [sp, #8]
    if (aligning)
30035da8:	e59d3008 	ldr	r3, [sp, #8]
30035dac:	e3530000 	cmp	r3, #0
30035db0:	0a000003 	beq	30035dc4 <seek_sync+0x38>
		getbit((int)(ALIGNING-aligning));   //�ֽڶ���
30035db4:	e59d3008 	ldr	r3, [sp, #8]
30035db8:	e2633008 	rsb	r3, r3, #8
30035dbc:	e1a00003 	mov	r0, r3
30035dc0:	eb00005d 	bl	30035f3c <getbit>

    val = getbit(12);
30035dc4:	e3a0000c 	mov	r0, #12
30035dc8:	eb00005b 	bl	30035f3c <getbit>
30035dcc:	e1a03000 	mov	r3, r0
30035dd0:	e58d300c 	str	r3, [sp, #12]
	while( ((val&0xfff)!= sync) && (!bs.eobs))
30035dd4:	ea000008 	b	30035dfc <seek_sync+0x70>
	{
		val<<=ALIGNING;
30035dd8:	e59d300c 	ldr	r3, [sp, #12]
30035ddc:	e1a03403 	lsl	r3, r3, #8
30035de0:	e58d300c 	str	r3, [sp, #12]
		val|=getbit(ALIGNING);
30035de4:	e3a00008 	mov	r0, #8
30035de8:	eb000053 	bl	30035f3c <getbit>
30035dec:	e1a03000 	mov	r3, r0
30035df0:	e59d200c 	ldr	r2, [sp, #12]
30035df4:	e1823003 	orr	r3, r2, r3
30035df8:	e58d300c 	str	r3, [sp, #12]
    aligning = bs.totbit%ALIGNING;
    if (aligning)
		getbit((int)(ALIGNING-aligning));   //�ֽڶ���

    val = getbit(12);
	while( ((val&0xfff)!= sync) && (!bs.eobs))
30035dfc:	e59d300c 	ldr	r3, [sp, #12]
30035e00:	e1a03a03 	lsl	r3, r3, #20
30035e04:	e1a03a23 	lsr	r3, r3, #20
30035e08:	e59d2004 	ldr	r2, [sp, #4]
30035e0c:	e1530002 	cmp	r3, r2
30035e10:	0a000003 	beq	30035e24 <seek_sync+0x98>
30035e14:	e59f3034 	ldr	r3, [pc, #52]	; 30035e50 <seek_sync+0xc4>
30035e18:	e5933018 	ldr	r3, [r3, #24]
30035e1c:	e3530000 	cmp	r3, #0
30035e20:	0affffec 	beq	30035dd8 <seek_sync+0x4c>
	{
		val<<=ALIGNING;
		val|=getbit(ALIGNING);
	}

	if (bs.eobs)
30035e24:	e59f3024 	ldr	r3, [pc, #36]	; 30035e50 <seek_sync+0xc4>
30035e28:	e5933018 	ldr	r3, [r3, #24]
30035e2c:	e3530000 	cmp	r3, #0
30035e30:	0a000001 	beq	30035e3c <seek_sync+0xb0>
		return(0);
30035e34:	e3a03000 	mov	r3, #0
30035e38:	ea000000 	b	30035e40 <seek_sync+0xb4>
	else
		return(1);
30035e3c:	e3a03001 	mov	r3, #1
}
30035e40:	e1a00003 	mov	r0, r3
30035e44:	e28dd014 	add	sp, sp, #20
30035e48:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30035e4c:	e12fff1e 	bx	lr
30035e50:	302f7e28 	.word	0x302f7e28

30035e54 <js_bound>:

int js_bound(int lay, int m_ext)
{
30035e54:	e24dd008 	sub	sp, sp, #8
30035e58:	e58d0004 	str	r0, [sp, #4]
30035e5c:	e58d1000 	str	r1, [sp]

 //   if(lay<1 || lay >3 || m_ext<0 || m_ext>3) {
 //       fprintf(stderr, "js_bound bad layer/modext (%d/%d)\n", lay, m_ext);
 //       exit(1);
//    }
	return(jsb_table[lay-1][m_ext]);
30035e60:	e59d3004 	ldr	r3, [sp, #4]
30035e64:	e2431001 	sub	r1, r3, #1
30035e68:	e59d2000 	ldr	r2, [sp]
30035e6c:	e59f3014 	ldr	r3, [pc, #20]	; 30035e88 <js_bound+0x34>
30035e70:	e1a01101 	lsl	r1, r1, #2
30035e74:	e0812002 	add	r2, r1, r2
30035e78:	e7933102 	ldr	r3, [r3, r2, lsl #2]
}
30035e7c:	e1a00003 	mov	r0, r3
30035e80:	e28dd008 	add	sp, sp, #8
30035e84:	e12fff1e 	bx	lr
30035e88:	300c654c 	.word	0x300c654c

30035e8c <hdr_to_frps>:

/* interpret data in hdr str to fields in fr_ps */
void hdr_to_frps() 
{
30035e8c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30035e90:	e24dd00c 	sub	sp, sp, #12
	layer *hdr = fr_ps.header;     /* (or pass in as arg?) */
30035e94:	e59f309c 	ldr	r3, [pc, #156]	; 30035f38 <hdr_to_frps+0xac>
30035e98:	e5933000 	ldr	r3, [r3]
30035e9c:	e58d3004 	str	r3, [sp, #4]

	fr_ps.actual_mode = hdr->mode;
30035ea0:	e59d3004 	ldr	r3, [sp, #4]
30035ea4:	e593201c 	ldr	r2, [r3, #28]
30035ea8:	e59f3088 	ldr	r3, [pc, #136]	; 30035f38 <hdr_to_frps+0xac>
30035eac:	e5832004 	str	r2, [r3, #4]
	fr_ps.stereo = (hdr->mode == MPG_MD_MONO) ? 1 : 2;
30035eb0:	e59d3004 	ldr	r3, [sp, #4]
30035eb4:	e593301c 	ldr	r3, [r3, #28]
30035eb8:	e3530003 	cmp	r3, #3
30035ebc:	1a000001 	bne	30035ec8 <hdr_to_frps+0x3c>
30035ec0:	e3a03001 	mov	r3, #1
30035ec4:	ea000000 	b	30035ecc <hdr_to_frps+0x40>
30035ec8:	e3a03002 	mov	r3, #2
30035ecc:	e59f2064 	ldr	r2, [pc, #100]	; 30035f38 <hdr_to_frps+0xac>
30035ed0:	e5823008 	str	r3, [r2, #8]
	fr_ps.sblimit = SBLIMIT;
30035ed4:	e59f305c 	ldr	r3, [pc, #92]	; 30035f38 <hdr_to_frps+0xac>
30035ed8:	e3a02020 	mov	r2, #32
30035edc:	e5832010 	str	r2, [r3, #16]
	if(hdr->mode == MPG_MD_JOINT_STEREO)
30035ee0:	e59d3004 	ldr	r3, [sp, #4]
30035ee4:	e593301c 	ldr	r3, [r3, #28]
30035ee8:	e3530001 	cmp	r3, #1
30035eec:	1a00000a 	bne	30035f1c <hdr_to_frps+0x90>
		fr_ps.jsbound = js_bound(hdr->lay, hdr->mode_ext);
30035ef0:	e59d3004 	ldr	r3, [sp, #4]
30035ef4:	e5932004 	ldr	r2, [r3, #4]
30035ef8:	e59d3004 	ldr	r3, [sp, #4]
30035efc:	e5933020 	ldr	r3, [r3, #32]
30035f00:	e1a00002 	mov	r0, r2
30035f04:	e1a01003 	mov	r1, r3
30035f08:	ebffffd1 	bl	30035e54 <js_bound>
30035f0c:	e1a02000 	mov	r2, r0
30035f10:	e59f3020 	ldr	r3, [pc, #32]	; 30035f38 <hdr_to_frps+0xac>
30035f14:	e583200c 	str	r2, [r3, #12]
30035f18:	ea000003 	b	30035f2c <hdr_to_frps+0xa0>
	else
		fr_ps.jsbound = fr_ps.sblimit;
30035f1c:	e59f3014 	ldr	r3, [pc, #20]	; 30035f38 <hdr_to_frps+0xac>
30035f20:	e5932010 	ldr	r2, [r3, #16]
30035f24:	e59f300c 	ldr	r3, [pc, #12]	; 30035f38 <hdr_to_frps+0xac>
30035f28:	e583200c 	str	r2, [r3, #12]
}
30035f2c:	e28dd00c 	add	sp, sp, #12
30035f30:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30035f34:	e12fff1e 	bx	lr
30035f38:	302be81c 	.word	0x302be81c

30035f3c <getbit>:
int putmask[9]={0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff};


/*read N bit from the bit stream */
unsigned int getbit(int N)
{
30035f3c:	e92d4010 	push	{r4, lr}
30035f40:	e24dd018 	sub	sp, sp, #24
30035f44:	e58d0004 	str	r0, [sp, #4]
	unsigned short val=0;
30035f48:	e3a03000 	mov	r3, #0
30035f4c:	e1cd30be 	strh	r3, [sp, #14]
	unsigned long  word;
	register unsigned int n = N;
30035f50:	e59d4004 	ldr	r4, [sp, #4]
    unsigned short x1,x2;

	bs.totbit += n;
30035f54:	e59f31e0 	ldr	r3, [pc, #480]	; 3003613c <getbit+0x200>
30035f58:	e5933004 	ldr	r3, [r3, #4]
30035f5c:	e0832004 	add	r2, r3, r4
30035f60:	e59f31d4 	ldr	r3, [pc, #468]	; 3003613c <getbit+0x200>
30035f64:	e5832004 	str	r2, [r3, #4]
    if (bs.bit_len<=n)
30035f68:	e59f31cc 	ldr	r3, [pc, #460]	; 3003613c <getbit+0x200>
30035f6c:	e593300c 	ldr	r3, [r3, #12]
30035f70:	e1530004 	cmp	r3, r4
30035f74:	8a000039 	bhi	30036060 <getbit+0x124>
	{
		x1=bs.buf[bs.read_ptr];
30035f78:	e59f31bc 	ldr	r3, [pc, #444]	; 3003613c <getbit+0x200>
30035f7c:	e5932000 	ldr	r2, [r3]
30035f80:	e59f31b4 	ldr	r3, [pc, #436]	; 3003613c <getbit+0x200>
30035f84:	e5933008 	ldr	r3, [r3, #8]
30035f88:	e1a03083 	lsl	r3, r3, #1
30035f8c:	e0823003 	add	r3, r2, r3
30035f90:	e1d330b0 	ldrh	r3, [r3]
30035f94:	e1cd31b4 	strh	r3, [sp, #20]
		x2=bs.buf[(++bs.read_ptr)%BUFFER_SIZE];    
30035f98:	e59f319c 	ldr	r3, [pc, #412]	; 3003613c <getbit+0x200>
30035f9c:	e5932000 	ldr	r2, [r3]
30035fa0:	e59f3194 	ldr	r3, [pc, #404]	; 3003613c <getbit+0x200>
30035fa4:	e5933008 	ldr	r3, [r3, #8]
30035fa8:	e2831001 	add	r1, r3, #1
30035fac:	e59f3188 	ldr	r3, [pc, #392]	; 3003613c <getbit+0x200>
30035fb0:	e5831008 	str	r1, [r3, #8]
30035fb4:	e59f3180 	ldr	r3, [pc, #384]	; 3003613c <getbit+0x200>
30035fb8:	e5933008 	ldr	r3, [r3, #8]
30035fbc:	e1a03a03 	lsl	r3, r3, #20
30035fc0:	e1a03a23 	lsr	r3, r3, #20
30035fc4:	e1a03083 	lsl	r3, r3, #1
30035fc8:	e0823003 	add	r3, r2, r3
30035fcc:	e1d330b0 	ldrh	r3, [r3]
30035fd0:	e1cd31b6 	strh	r3, [sp, #22]
		word=(x1<<16)|x2;
30035fd4:	e1dd31b4 	ldrh	r3, [sp, #20]
30035fd8:	e1a02803 	lsl	r2, r3, #16
30035fdc:	e1dd31b6 	ldrh	r3, [sp, #22]
30035fe0:	e1823003 	orr	r3, r2, r3
30035fe4:	e58d3010 	str	r3, [sp, #16]
//  	    word=bs.buf[bs.read_ptr]<<16|bs.buf[(++bs.read_ptr)%BUFFER_SIZE];  //???  !!!!
		word=word<<(16-bs.bit_len);
30035fe8:	e59f314c 	ldr	r3, [pc, #332]	; 3003613c <getbit+0x200>
30035fec:	e593300c 	ldr	r3, [r3, #12]
30035ff0:	e2633010 	rsb	r3, r3, #16
30035ff4:	e59d2010 	ldr	r2, [sp, #16]
30035ff8:	e1a03312 	lsl	r3, r2, r3
30035ffc:	e58d3010 	str	r3, [sp, #16]
		val=(short)(word>>(32-n));  
30036000:	e2643020 	rsb	r3, r4, #32
30036004:	e59d2010 	ldr	r2, [sp, #16]
30036008:	e1a03332 	lsr	r3, r2, r3
3003600c:	e1cd30be 	strh	r3, [sp, #14]
		bs.bit_len =16+bs.bit_len-n ;
30036010:	e59f3124 	ldr	r3, [pc, #292]	; 3003613c <getbit+0x200>
30036014:	e593300c 	ldr	r3, [r3, #12]
30036018:	e0643003 	rsb	r3, r4, r3
3003601c:	e2832010 	add	r2, r3, #16
30036020:	e59f3114 	ldr	r3, [pc, #276]	; 3003613c <getbit+0x200>
30036024:	e583200c 	str	r2, [r3, #12]
		if(bs.bit_len==0)
30036028:	e59f310c 	ldr	r3, [pc, #268]	; 3003613c <getbit+0x200>
3003602c:	e593300c 	ldr	r3, [r3, #12]
30036030:	e3530000 	cmp	r3, #0
30036034:	1a000002 	bne	30036044 <getbit+0x108>
			bs.bit_len=16;
30036038:	e59f30fc 	ldr	r3, [pc, #252]	; 3003613c <getbit+0x200>
3003603c:	e3a02010 	mov	r2, #16
30036040:	e583200c 	str	r2, [r3, #12]
	    bs.read_ptr%=BUFFER_SIZE;
30036044:	e59f30f0 	ldr	r3, [pc, #240]	; 3003613c <getbit+0x200>
30036048:	e5933008 	ldr	r3, [r3, #8]
3003604c:	e1a03a03 	lsl	r3, r3, #20
30036050:	e1a03a23 	lsr	r3, r3, #20
30036054:	e59f20e0 	ldr	r2, [pc, #224]	; 3003613c <getbit+0x200>
30036058:	e5823008 	str	r3, [r2, #8]
3003605c:	ea000015 	b	300360b8 <getbit+0x17c>
	}
    else
	{
		val=bs.buf[bs.read_ptr]<<(16-bs.bit_len);
30036060:	e59f30d4 	ldr	r3, [pc, #212]	; 3003613c <getbit+0x200>
30036064:	e5932000 	ldr	r2, [r3]
30036068:	e59f30cc 	ldr	r3, [pc, #204]	; 3003613c <getbit+0x200>
3003606c:	e5933008 	ldr	r3, [r3, #8]
30036070:	e1a03083 	lsl	r3, r3, #1
30036074:	e0823003 	add	r3, r2, r3
30036078:	e1d330b0 	ldrh	r3, [r3]
3003607c:	e1a02003 	mov	r2, r3
30036080:	e59f30b4 	ldr	r3, [pc, #180]	; 3003613c <getbit+0x200>
30036084:	e593300c 	ldr	r3, [r3, #12]
30036088:	e2633010 	rsb	r3, r3, #16
3003608c:	e1a03312 	lsl	r3, r2, r3
30036090:	e1cd30be 	strh	r3, [sp, #14]
		val=val>>(16-n);
30036094:	e1dd20be 	ldrh	r2, [sp, #14]
30036098:	e2643010 	rsb	r3, r4, #16
3003609c:	e1a03352 	asr	r3, r2, r3
300360a0:	e1cd30be 	strh	r3, [sp, #14]
		bs.bit_len -=n ;
300360a4:	e59f3090 	ldr	r3, [pc, #144]	; 3003613c <getbit+0x200>
300360a8:	e593300c 	ldr	r3, [r3, #12]
300360ac:	e0642003 	rsb	r2, r4, r3
300360b0:	e59f3084 	ldr	r3, [pc, #132]	; 3003613c <getbit+0x200>
300360b4:	e583200c 	str	r2, [r3, #12]
	}
	if(bs.read_ptr>bs.write_ptr)
300360b8:	e59f307c 	ldr	r3, [pc, #124]	; 3003613c <getbit+0x200>
300360bc:	e5932008 	ldr	r2, [r3, #8]
300360c0:	e59f3074 	ldr	r3, [pc, #116]	; 3003613c <getbit+0x200>
300360c4:	e5933010 	ldr	r3, [r3, #16]
300360c8:	e1520003 	cmp	r2, r3
300360cc:	9a000009 	bls	300360f8 <getbit+0x1bc>
	{
	  if(bs.read_ptr-bs.write_ptr>ETHER_SIZE)
300360d0:	e59f3064 	ldr	r3, [pc, #100]	; 3003613c <getbit+0x200>
300360d4:	e5932008 	ldr	r2, [r3, #8]
300360d8:	e59f305c 	ldr	r3, [pc, #92]	; 3003613c <getbit+0x200>
300360dc:	e5933010 	ldr	r3, [r3, #16]
300360e0:	e0633002 	rsb	r3, r3, r2
300360e4:	e3530c02 	cmp	r3, #512	; 0x200
300360e8:	9a00000d 	bls	30036124 <getbit+0x1e8>
		 quest_stream(&bs.write_ptr);
300360ec:	e59f004c 	ldr	r0, [pc, #76]	; 30036140 <getbit+0x204>
300360f0:	eb000013 	bl	30036144 <quest_stream>
300360f4:	ea00000b 	b	30036128 <getbit+0x1ec>
	}
	else
	{
	  if(BUFFER_SIZE-(bs.write_ptr-bs.read_ptr)>ETHER_SIZE)
300360f8:	e59f303c 	ldr	r3, [pc, #60]	; 3003613c <getbit+0x200>
300360fc:	e5932008 	ldr	r2, [r3, #8]
30036100:	e59f3034 	ldr	r3, [pc, #52]	; 3003613c <getbit+0x200>
30036104:	e5933010 	ldr	r3, [r3, #16]
30036108:	e0633002 	rsb	r3, r3, r2
3003610c:	e2833a01 	add	r3, r3, #4096	; 0x1000
30036110:	e3530c02 	cmp	r3, #512	; 0x200
30036114:	9a000003 	bls	30036128 <getbit+0x1ec>
		 quest_stream(&bs.write_ptr);
30036118:	e59f0020 	ldr	r0, [pc, #32]	; 30036140 <getbit+0x204>
3003611c:	eb000008 	bl	30036144 <quest_stream>
30036120:	ea000000 	b	30036128 <getbit+0x1ec>
		bs.bit_len -=n ;
	}
	if(bs.read_ptr>bs.write_ptr)
	{
	  if(bs.read_ptr-bs.write_ptr>ETHER_SIZE)
		 quest_stream(&bs.write_ptr);
30036124:	e1a00000 	nop			; (mov r0, r0)
	else
	{
	  if(BUFFER_SIZE-(bs.write_ptr-bs.read_ptr)>ETHER_SIZE)
		 quest_stream(&bs.write_ptr);
	}
	return val;
30036128:	e1dd30be 	ldrh	r3, [sp, #14]
}
3003612c:	e1a00003 	mov	r0, r3
30036130:	e28dd018 	add	sp, sp, #24
30036134:	e8bd4010 	pop	{r4, lr}
30036138:	e12fff1e 	bx	lr
3003613c:	302f7e28 	.word	0x302f7e28
30036140:	302f7e38 	.word	0x302f7e38

30036144 <quest_stream>:




void quest_stream(unsigned int *ptr)
{
30036144:	e92d4010 	push	{r4, lr}
30036148:	e24dd010 	sub	sp, sp, #16
3003614c:	e58d0004 	str	r0, [sp, #4]
	register int i;
	unsigned char tmp[2];
	int j;
	static int read_count = 0;
	static int cur_file_buf = 0;
	if(mp3_first) {
30036150:	e59f3338 	ldr	r3, [pc, #824]	; 30036490 <quest_stream+0x34c>
30036154:	e5933000 	ldr	r3, [r3]
30036158:	e3530000 	cmp	r3, #0
3003615c:	0a000008 	beq	30036184 <quest_stream+0x40>
		mp3_first = 0;
30036160:	e59f3328 	ldr	r3, [pc, #808]	; 30036490 <quest_stream+0x34c>
30036164:	e3a02000 	mov	r2, #0
30036168:	e5832000 	str	r2, [r3]
		read_count = 0;
3003616c:	e59f3320 	ldr	r3, [pc, #800]	; 30036494 <quest_stream+0x350>
30036170:	e3a02000 	mov	r2, #0
30036174:	e5832000 	str	r2, [r3]
		cur_file_buf = 0;
30036178:	e59f3318 	ldr	r3, [pc, #792]	; 30036498 <quest_stream+0x354>
3003617c:	e3a02000 	mov	r2, #0
30036180:	e5832000 	str	r2, [r3]
	}
	if(file_mp3_buf_hdr[cur_file_buf].update == 0)
30036184:	e59f330c 	ldr	r3, [pc, #780]	; 30036498 <quest_stream+0x354>
30036188:	e5932000 	ldr	r2, [r3]
3003618c:	e59f3308 	ldr	r3, [pc, #776]	; 3003649c <quest_stream+0x358>
30036190:	e1a02082 	lsl	r2, r2, #1
30036194:	e2822001 	add	r2, r2, #1
30036198:	e7933182 	ldr	r3, [r3, r2, lsl #3]
3003619c:	e3530000 	cmp	r3, #0
300361a0:	1a00000c 	bne	300361d8 <quest_stream+0x94>
		acoral_sem_pend(file_mp3_buf_update_eve+cur_file_buf, 0);
300361a4:	e59f32ec 	ldr	r3, [pc, #748]	; 30036498 <quest_stream+0x354>
300361a8:	e5933000 	ldr	r3, [r3]
300361ac:	e1a02003 	mov	r2, r3
300361b0:	e1a03002 	mov	r3, r2
300361b4:	e1a03183 	lsl	r3, r3, #3
300361b8:	e0833002 	add	r3, r3, r2
300361bc:	e1a03103 	lsl	r3, r3, #2
300361c0:	e1a02003 	mov	r2, r3
300361c4:	e59f32d4 	ldr	r3, [pc, #724]	; 300364a0 <quest_stream+0x35c>
300361c8:	e0823003 	add	r3, r2, r3
300361cc:	e1a00003 	mov	r0, r3
300361d0:	e3a01000 	mov	r1, #0
300361d4:	ebff4539 	bl	300076c0 <acoral_sem_pend>
	file_mp3_buf_hdr[cur_file_buf].used = 1;
300361d8:	e59f32b8 	ldr	r3, [pc, #696]	; 30036498 <quest_stream+0x354>
300361dc:	e5931000 	ldr	r1, [r3]
300361e0:	e59f22b4 	ldr	r2, [pc, #692]	; 3003649c <quest_stream+0x358>
300361e4:	e3a03004 	mov	r3, #4
300361e8:	e1a01201 	lsl	r1, r1, #4
300361ec:	e0812002 	add	r2, r1, r2
300361f0:	e0823003 	add	r3, r2, r3
300361f4:	e3a02001 	mov	r2, #1
300361f8:	e5832000 	str	r2, [r3]
	for (i=0;i<ETHER_SIZE;i++)
300361fc:	e3a04000 	mov	r4, #0
30036200:	ea00009b 	b	30036474 <quest_stream+0x330>
	{
 	      bs.eof=0;
30036204:	e59f3298 	ldr	r3, [pc, #664]	; 300364a4 <quest_stream+0x360>
30036208:	e3a02000 	mov	r2, #0
3003620c:	e5832014 	str	r2, [r3, #20]
 	      //bs.buf[*ptr]=((*(file_buf+cur_file_buf+read_count))<<8)|(*(file_buf+cur_file_buf+read_count+1));
		  tmp[0] = file_mp3_buf[cur_file_buf][read_count];
30036210:	e59f3280 	ldr	r3, [pc, #640]	; 30036498 <quest_stream+0x354>
30036214:	e5932000 	ldr	r2, [r3]
30036218:	e59f3274 	ldr	r3, [pc, #628]	; 30036494 <quest_stream+0x350>
3003621c:	e5930000 	ldr	r0, [r3]
30036220:	e59f1280 	ldr	r1, [pc, #640]	; 300364a8 <quest_stream+0x364>
30036224:	e1a03002 	mov	r3, r2
30036228:	e1a03103 	lsl	r3, r3, #2
3003622c:	e0833002 	add	r3, r3, r2
30036230:	e1a03703 	lsl	r3, r3, #14
30036234:	e0833000 	add	r3, r3, r0
30036238:	e0833001 	add	r3, r3, r1
3003623c:	e5d33000 	ldrb	r3, [r3]
30036240:	e5cd3008 	strb	r3, [sp, #8]
		  tmp[1] = file_mp3_buf[cur_file_buf][read_count+1];
30036244:	e59f324c 	ldr	r3, [pc, #588]	; 30036498 <quest_stream+0x354>
30036248:	e5932000 	ldr	r2, [r3]
3003624c:	e59f3240 	ldr	r3, [pc, #576]	; 30036494 <quest_stream+0x350>
30036250:	e5933000 	ldr	r3, [r3]
30036254:	e2830001 	add	r0, r3, #1
30036258:	e59f1248 	ldr	r1, [pc, #584]	; 300364a8 <quest_stream+0x364>
3003625c:	e1a03002 	mov	r3, r2
30036260:	e1a03103 	lsl	r3, r3, #2
30036264:	e0833002 	add	r3, r3, r2
30036268:	e1a03703 	lsl	r3, r3, #14
3003626c:	e0833000 	add	r3, r3, r0
30036270:	e0833001 	add	r3, r3, r1
30036274:	e5d33000 	ldrb	r3, [r3]
30036278:	e5cd3009 	strb	r3, [sp, #9]
		  bs.buf[*ptr]=tmp[0]<<8|tmp[1];
3003627c:	e59f3220 	ldr	r3, [pc, #544]	; 300364a4 <quest_stream+0x360>
30036280:	e5932000 	ldr	r2, [r3]
30036284:	e59d3004 	ldr	r3, [sp, #4]
30036288:	e5933000 	ldr	r3, [r3]
3003628c:	e1a03083 	lsl	r3, r3, #1
30036290:	e0823003 	add	r3, r2, r3
30036294:	e5dd2008 	ldrb	r2, [sp, #8]
30036298:	e1a02402 	lsl	r2, r2, #8
3003629c:	e1a02802 	lsl	r2, r2, #16
300362a0:	e1a01822 	lsr	r1, r2, #16
300362a4:	e5dd2009 	ldrb	r2, [sp, #9]
300362a8:	e1812002 	orr	r2, r1, r2
300362ac:	e1a02802 	lsl	r2, r2, #16
300362b0:	e1a02822 	lsr	r2, r2, #16
300362b4:	e1a02802 	lsl	r2, r2, #16
300362b8:	e1a02822 	lsr	r2, r2, #16
300362bc:	e1c320b0 	strh	r2, [r3]
 	      (*ptr)++;
300362c0:	e59d3004 	ldr	r3, [sp, #4]
300362c4:	e5933000 	ldr	r3, [r3]
300362c8:	e2832001 	add	r2, r3, #1
300362cc:	e59d3004 	ldr	r3, [sp, #4]
300362d0:	e5832000 	str	r2, [r3]
		  (*ptr)%=BUFFER_SIZE;
300362d4:	e59d3004 	ldr	r3, [sp, #4]
300362d8:	e5933000 	ldr	r3, [r3]
300362dc:	e1a03a03 	lsl	r3, r3, #20
300362e0:	e1a03a23 	lsr	r3, r3, #20
300362e4:	e59d2004 	ldr	r2, [sp, #4]
300362e8:	e5823000 	str	r3, [r2]
		  read_count += 2;
300362ec:	e59f31a0 	ldr	r3, [pc, #416]	; 30036494 <quest_stream+0x350>
300362f0:	e5933000 	ldr	r3, [r3]
300362f4:	e2832002 	add	r2, r3, #2
300362f8:	e59f3194 	ldr	r3, [pc, #404]	; 30036494 <quest_stream+0x350>
300362fc:	e5832000 	str	r2, [r3]
		  if(read_count == file_buf_block_size) {
30036300:	e59f318c 	ldr	r3, [pc, #396]	; 30036494 <quest_stream+0x350>
30036304:	e5933000 	ldr	r3, [r3]
30036308:	e3530905 	cmp	r3, #81920	; 0x14000
3003630c:	1a000050 	bne	30036454 <quest_stream+0x310>
			  read_count = 0;
30036310:	e59f317c 	ldr	r3, [pc, #380]	; 30036494 <quest_stream+0x350>
30036314:	e3a02000 	mov	r2, #0
30036318:	e5832000 	str	r2, [r3]
			  file_mp3_buf_hdr[cur_file_buf].used = 0;
3003631c:	e59f3174 	ldr	r3, [pc, #372]	; 30036498 <quest_stream+0x354>
30036320:	e5931000 	ldr	r1, [r3]
30036324:	e59f2170 	ldr	r2, [pc, #368]	; 3003649c <quest_stream+0x358>
30036328:	e3a03004 	mov	r3, #4
3003632c:	e1a01201 	lsl	r1, r1, #4
30036330:	e0812002 	add	r2, r1, r2
30036334:	e0823003 	add	r3, r2, r3
30036338:	e3a02000 	mov	r2, #0
3003633c:	e5832000 	str	r2, [r3]
			  file_mp3_buf_hdr[cur_file_buf].update = 0;
30036340:	e59f3150 	ldr	r3, [pc, #336]	; 30036498 <quest_stream+0x354>
30036344:	e5932000 	ldr	r2, [r3]
30036348:	e59f314c 	ldr	r3, [pc, #332]	; 3003649c <quest_stream+0x358>
3003634c:	e1a02082 	lsl	r2, r2, #1
30036350:	e2822001 	add	r2, r2, #1
30036354:	e3a01000 	mov	r1, #0
30036358:	e7831182 	str	r1, [r3, r2, lsl #3]
			  if(acoral_sem_getnum(file_mp3_buf_usedone_eve+cur_file_buf) <= 0)
3003635c:	e59f3134 	ldr	r3, [pc, #308]	; 30036498 <quest_stream+0x354>
30036360:	e5933000 	ldr	r3, [r3]
30036364:	e1a02003 	mov	r2, r3
30036368:	e1a03002 	mov	r3, r2
3003636c:	e1a03183 	lsl	r3, r3, #3
30036370:	e0833002 	add	r3, r3, r2
30036374:	e1a03103 	lsl	r3, r3, #2
30036378:	e1a02003 	mov	r2, r3
3003637c:	e59f3128 	ldr	r3, [pc, #296]	; 300364ac <quest_stream+0x368>
30036380:	e0823003 	add	r3, r2, r3
30036384:	e1a00003 	mov	r0, r3
30036388:	ebff4579 	bl	30007974 <acoral_sem_getnum>
3003638c:	e1a03000 	mov	r3, r0
30036390:	e3530000 	cmp	r3, #0
30036394:	0a00000b 	beq	300363c8 <quest_stream+0x284>
				  acoral_sem_post(file_mp3_buf_usedone_eve+cur_file_buf);
30036398:	e59f30f8 	ldr	r3, [pc, #248]	; 30036498 <quest_stream+0x354>
3003639c:	e5933000 	ldr	r3, [r3]
300363a0:	e1a02003 	mov	r2, r3
300363a4:	e1a03002 	mov	r3, r2
300363a8:	e1a03183 	lsl	r3, r3, #3
300363ac:	e0833002 	add	r3, r3, r2
300363b0:	e1a03103 	lsl	r3, r3, #2
300363b4:	e1a02003 	mov	r2, r3
300363b8:	e59f30ec 	ldr	r3, [pc, #236]	; 300364ac <quest_stream+0x368>
300363bc:	e0823003 	add	r3, r2, r3
300363c0:	e1a00003 	mov	r0, r3
300363c4:	ebff4528 	bl	3000786c <acoral_sem_post>
			  cur_file_buf ++;
300363c8:	e59f30c8 	ldr	r3, [pc, #200]	; 30036498 <quest_stream+0x354>
300363cc:	e5933000 	ldr	r3, [r3]
300363d0:	e2832001 	add	r2, r3, #1
300363d4:	e59f30bc 	ldr	r3, [pc, #188]	; 30036498 <quest_stream+0x354>
300363d8:	e5832000 	str	r2, [r3]
			  if(file_mp3_buf_hdr[cur_file_buf].update == 0)
300363dc:	e59f30b4 	ldr	r3, [pc, #180]	; 30036498 <quest_stream+0x354>
300363e0:	e5932000 	ldr	r2, [r3]
300363e4:	e59f30b0 	ldr	r3, [pc, #176]	; 3003649c <quest_stream+0x358>
300363e8:	e1a02082 	lsl	r2, r2, #1
300363ec:	e2822001 	add	r2, r2, #1
300363f0:	e7933182 	ldr	r3, [r3, r2, lsl #3]
300363f4:	e3530000 	cmp	r3, #0
300363f8:	1a00000c 	bne	30036430 <quest_stream+0x2ec>
				acoral_sem_pend(file_mp3_buf_update_eve+cur_file_buf, 0);
300363fc:	e59f3094 	ldr	r3, [pc, #148]	; 30036498 <quest_stream+0x354>
30036400:	e5933000 	ldr	r3, [r3]
30036404:	e1a02003 	mov	r2, r3
30036408:	e1a03002 	mov	r3, r2
3003640c:	e1a03183 	lsl	r3, r3, #3
30036410:	e0833002 	add	r3, r3, r2
30036414:	e1a03103 	lsl	r3, r3, #2
30036418:	e1a02003 	mov	r2, r3
3003641c:	e59f307c 	ldr	r3, [pc, #124]	; 300364a0 <quest_stream+0x35c>
30036420:	e0823003 	add	r3, r2, r3
30036424:	e1a00003 	mov	r0, r3
30036428:	e3a01000 	mov	r1, #0
3003642c:	ebff44a3 	bl	300076c0 <acoral_sem_pend>
			  file_mp3_buf_hdr[cur_file_buf].used = 1;
30036430:	e59f3060 	ldr	r3, [pc, #96]	; 30036498 <quest_stream+0x354>
30036434:	e5931000 	ldr	r1, [r3]
30036438:	e59f205c 	ldr	r2, [pc, #92]	; 3003649c <quest_stream+0x358>
3003643c:	e3a03004 	mov	r3, #4
30036440:	e1a01201 	lsl	r1, r1, #4
30036444:	e0812002 	add	r2, r1, r2
30036448:	e0823003 	add	r3, r2, r3
3003644c:	e3a02001 	mov	r2, #1
30036450:	e5832000 	str	r2, [r3]
			 			  		}
			 		  }
				  }
			  }*/
		  }
		  if(cur_file_buf == file_mp3_buf_size)
30036454:	e59f303c 	ldr	r3, [pc, #60]	; 30036498 <quest_stream+0x354>
30036458:	e5933000 	ldr	r3, [r3]
3003645c:	e353000a 	cmp	r3, #10
30036460:	1a000002 	bne	30036470 <quest_stream+0x32c>
			  cur_file_buf = 0;
30036464:	e59f302c 	ldr	r3, [pc, #44]	; 30036498 <quest_stream+0x354>
30036468:	e3a02000 	mov	r2, #0
3003646c:	e5832000 	str	r2, [r3]
		cur_file_buf = 0;
	}
	if(file_mp3_buf_hdr[cur_file_buf].update == 0)
		acoral_sem_pend(file_mp3_buf_update_eve+cur_file_buf, 0);
	file_mp3_buf_hdr[cur_file_buf].used = 1;
	for (i=0;i<ETHER_SIZE;i++)
30036470:	e2844001 	add	r4, r4, #1
30036474:	e3a03f7f 	mov	r3, #508	; 0x1fc
30036478:	e2833003 	add	r3, r3, #3
3003647c:	e1540003 	cmp	r4, r3
30036480:	daffff5f 	ble	30036204 <quest_stream+0xc0>


		//else
			//bs.eobs=1;
	}
}
30036484:	e28dd010 	add	sp, sp, #16
30036488:	e8bd4010 	pop	{r4, lr}
3003648c:	e12fff1e 	bx	lr
30036490:	300c9a88 	.word	0x300c9a88
30036494:	300e5970 	.word	0x300e5970
30036498:	300e5974 	.word	0x300e5974
3003649c:	300ea3bc 	.word	0x300ea3bc
300364a0:	302be270 	.word	0x302be270
300364a4:	302f7e28 	.word	0x302f7e28
300364a8:	301f5948 	.word	0x301f5948
300364ac:	3012acac 	.word	0x3012acac

300364b0 <III_hufman_decode>:
		    int *x, int *y, int *v, int *w);


void III_hufman_decode(struct Granule *gr,int part2_start,
		       	 int freqline[SBLIMIT][SSLIMIT])
{
300364b0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300364b4:	e24dd064 	sub	sp, sp, #100	; 0x64
300364b8:	e58d0014 	str	r0, [sp, #20]
300364bc:	e58d1010 	str	r1, [sp, #16]
300364c0:	e58d200c 	str	r2, [sp, #12]
    unsigned int reg1, reg2,i; 

	unsigned int part3_length = part2_start + gr->part2_3_length;
300364c4:	e59d3014 	ldr	r3, [sp, #20]
300364c8:	e5932000 	ldr	r2, [r3]
300364cc:	e59d3010 	ldr	r3, [sp, #16]
300364d0:	e0823003 	add	r3, r2, r3
300364d4:	e58d3028 	str	r3, [sp, #40]	; 0x28
	unsigned used;
    int h,*f=&freqline[0][0];
300364d8:	e59d300c 	ldr	r3, [sp, #12]
300364dc:	e58d3034 	str	r3, [sp, #52]	; 0x34

    if(gr->window_switching_flag &&
300364e0:	e59d3014 	ldr	r3, [sp, #20]
300364e4:	e5933010 	ldr	r3, [r3, #16]
300364e8:	e3530000 	cmp	r3, #0
300364ec:	0a000008 	beq	30036514 <III_hufman_decode+0x64>
       gr->block_type == 2)
300364f0:	e59d3014 	ldr	r3, [sp, #20]
300364f4:	e5933014 	ldr	r3, [r3, #20]

	unsigned int part3_length = part2_start + gr->part2_3_length;
	unsigned used;
    int h,*f=&freqline[0][0];

    if(gr->window_switching_flag &&
300364f8:	e3530002 	cmp	r3, #2
300364fc:	1a000004 	bne	30036514 <III_hufman_decode+0x64>
       gr->block_type == 2)
	{
	
	/* short block regions */
	
	  reg1 = 36;  
30036500:	e3a03024 	mov	r3, #36	; 0x24
30036504:	e58d301c 	str	r3, [sp, #28]
	  reg2 = 576;
30036508:	e3a03d09 	mov	r3, #576	; 0x240
3003650c:	e58d3020 	str	r3, [sp, #32]

	unsigned int part3_length = part2_start + gr->part2_3_length;
	unsigned used;
    int h,*f=&freqline[0][0];

    if(gr->window_switching_flag &&
30036510:	ea000020 	b	30036598 <III_hufman_decode+0xe8>
    }
	else
	{
	/* long block regions */

	  reg1 = sfBandIndex[fr_ps.header->sampling_frequency].l[gr->region0_count + 1];
30036514:	e59f3b30 	ldr	r3, [pc, #2864]	; 3003704c <III_hufman_decode+0xb9c>
30036518:	e5933000 	ldr	r3, [r3]
3003651c:	e5932010 	ldr	r2, [r3, #16]
30036520:	e59d3014 	ldr	r3, [sp, #20]
30036524:	e5933034 	ldr	r3, [r3, #52]	; 0x34
30036528:	e2830001 	add	r0, r3, #1
3003652c:	e59f1b1c 	ldr	r1, [pc, #2844]	; 30037050 <III_hufman_decode+0xba0>
30036530:	e1a03002 	mov	r3, r2
30036534:	e1a03183 	lsl	r3, r3, #3
30036538:	e0833002 	add	r3, r3, r2
3003653c:	e1a03103 	lsl	r3, r3, #2
30036540:	e0833002 	add	r3, r3, r2
30036544:	e0833000 	add	r3, r3, r0
30036548:	e7913103 	ldr	r3, [r1, r3, lsl #2]
3003654c:	e58d301c 	str	r3, [sp, #28]
	  reg2 = sfBandIndex[fr_ps.header->sampling_frequency].l[gr->region0_count + gr->region1_count + 2];
30036550:	e59f3af4 	ldr	r3, [pc, #2804]	; 3003704c <III_hufman_decode+0xb9c>
30036554:	e5933000 	ldr	r3, [r3]
30036558:	e5932010 	ldr	r2, [r3, #16]
3003655c:	e59d3014 	ldr	r3, [sp, #20]
30036560:	e5931034 	ldr	r1, [r3, #52]	; 0x34
30036564:	e59d3014 	ldr	r3, [sp, #20]
30036568:	e5933038 	ldr	r3, [r3, #56]	; 0x38
3003656c:	e0813003 	add	r3, r1, r3
30036570:	e2830002 	add	r0, r3, #2
30036574:	e59f1ad4 	ldr	r1, [pc, #2772]	; 30037050 <III_hufman_decode+0xba0>
30036578:	e1a03002 	mov	r3, r2
3003657c:	e1a03183 	lsl	r3, r3, #3
30036580:	e0833002 	add	r3, r3, r2
30036584:	e1a03103 	lsl	r3, r3, #2
30036588:	e0833002 	add	r3, r3, r2
3003658c:	e0833000 	add	r3, r3, r0
30036590:	e7913103 	ldr	r3, [r1, r3, lsl #2]
30036594:	e58d3020 	str	r3, [sp, #32]
    }


    /* fill up dataword, end at a bytealign in the buffer */
    {
	int bitpos = totpos & 7;    //ȡ8������
30036598:	e59f3ab4 	ldr	r3, [pc, #2740]	; 30037054 <III_hufman_decode+0xba4>
3003659c:	e5933000 	ldr	r3, [r3]
300365a0:	e2033007 	and	r3, r3, #7
300365a4:	e58d3038 	str	r3, [sp, #56]	; 0x38
	datapos = (totpos>> 3) & (BITSTREAM_BUFSIZE - 1);
300365a8:	e59f3aa4 	ldr	r3, [pc, #2724]	; 30037054 <III_hufman_decode+0xba4>
300365ac:	e5933000 	ldr	r3, [r3]
300365b0:	e1a031a3 	lsr	r3, r3, #3
300365b4:	e1a03a83 	lsl	r3, r3, #21
300365b8:	e1a03aa3 	lsr	r3, r3, #21
300365bc:	e59f2a94 	ldr	r2, [pc, #2708]	; 30037058 <III_hufman_decode+0xba8>
300365c0:	e5823000 	str	r3, [r2]
	/* the first read might not be bytealigned so shift it in place */
	/* we have duplicated the last 4 bytes in the stream so it doesnt
	   matter that datapos+2 etc dont pass through modulo */
	dataword = buf[datapos++] << 24   ;                     //����3���ֽ�
300365c4:	e59f3a8c 	ldr	r3, [pc, #2700]	; 30037058 <III_hufman_decode+0xba8>
300365c8:	e5933000 	ldr	r3, [r3]
300365cc:	e59f2a88 	ldr	r2, [pc, #2696]	; 3003705c <III_hufman_decode+0xbac>
300365d0:	e7d22003 	ldrb	r2, [r2, r3]
300365d4:	e1a02c02 	lsl	r2, r2, #24
300365d8:	e1a01002 	mov	r1, r2
300365dc:	e59f2a7c 	ldr	r2, [pc, #2684]	; 30037060 <III_hufman_decode+0xbb0>
300365e0:	e5821000 	str	r1, [r2]
300365e4:	e2832001 	add	r2, r3, #1
300365e8:	e59f3a68 	ldr	r3, [pc, #2664]	; 30037058 <III_hufman_decode+0xba8>
300365ec:	e5832000 	str	r2, [r3]
	datapos  %=  BITSTREAM_BUFSIZE;
300365f0:	e59f3a60 	ldr	r3, [pc, #2656]	; 30037058 <III_hufman_decode+0xba8>
300365f4:	e5933000 	ldr	r3, [r3]
300365f8:	e1a02fc3 	asr	r2, r3, #31
300365fc:	e1a02aa2 	lsr	r2, r2, #21
30036600:	e0833002 	add	r3, r3, r2
30036604:	e1a03a83 	lsl	r3, r3, #21
30036608:	e1a03aa3 	lsr	r3, r3, #21
3003660c:	e0623003 	rsb	r3, r2, r3
30036610:	e1a02003 	mov	r2, r3
30036614:	e59f3a3c 	ldr	r3, [pc, #2620]	; 30037058 <III_hufman_decode+0xba8>
30036618:	e5832000 	str	r2, [r3]
	dataword|= buf[datapos++] << 16 ;
3003661c:	e59f3a34 	ldr	r3, [pc, #2612]	; 30037058 <III_hufman_decode+0xba8>
30036620:	e5933000 	ldr	r3, [r3]
30036624:	e59f2a30 	ldr	r2, [pc, #2608]	; 3003705c <III_hufman_decode+0xbac>
30036628:	e7d22003 	ldrb	r2, [r2, r3]
3003662c:	e1a02802 	lsl	r2, r2, #16
30036630:	e1a01002 	mov	r1, r2
30036634:	e59f2a24 	ldr	r2, [pc, #2596]	; 30037060 <III_hufman_decode+0xbb0>
30036638:	e5922000 	ldr	r2, [r2]
3003663c:	e1811002 	orr	r1, r1, r2
30036640:	e59f2a18 	ldr	r2, [pc, #2584]	; 30037060 <III_hufman_decode+0xbb0>
30036644:	e5821000 	str	r1, [r2]
30036648:	e2832001 	add	r2, r3, #1
3003664c:	e59f3a04 	ldr	r3, [pc, #2564]	; 30037058 <III_hufman_decode+0xba8>
30036650:	e5832000 	str	r2, [r3]
	datapos  %=  BITSTREAM_BUFSIZE;
30036654:	e59f39fc 	ldr	r3, [pc, #2556]	; 30037058 <III_hufman_decode+0xba8>
30036658:	e5933000 	ldr	r3, [r3]
3003665c:	e1a02fc3 	asr	r2, r3, #31
30036660:	e1a02aa2 	lsr	r2, r2, #21
30036664:	e0833002 	add	r3, r3, r2
30036668:	e1a03a83 	lsl	r3, r3, #21
3003666c:	e1a03aa3 	lsr	r3, r3, #21
30036670:	e0623003 	rsb	r3, r2, r3
30036674:	e1a02003 	mov	r2, r3
30036678:	e59f39d8 	ldr	r3, [pc, #2520]	; 30037058 <III_hufman_decode+0xba8>
3003667c:	e5832000 	str	r2, [r3]
	dataword|= buf[datapos++] << 8  ;
30036680:	e59f39d0 	ldr	r3, [pc, #2512]	; 30037058 <III_hufman_decode+0xba8>
30036684:	e5933000 	ldr	r3, [r3]
30036688:	e59f29cc 	ldr	r2, [pc, #2508]	; 3003705c <III_hufman_decode+0xbac>
3003668c:	e7d22003 	ldrb	r2, [r2, r3]
30036690:	e1a02402 	lsl	r2, r2, #8
30036694:	e1a01002 	mov	r1, r2
30036698:	e59f29c0 	ldr	r2, [pc, #2496]	; 30037060 <III_hufman_decode+0xbb0>
3003669c:	e5922000 	ldr	r2, [r2]
300366a0:	e1811002 	orr	r1, r1, r2
300366a4:	e59f29b4 	ldr	r2, [pc, #2484]	; 30037060 <III_hufman_decode+0xbb0>
300366a8:	e5821000 	str	r1, [r2]
300366ac:	e2832001 	add	r2, r3, #1
300366b0:	e59f39a0 	ldr	r3, [pc, #2464]	; 30037058 <III_hufman_decode+0xba8>
300366b4:	e5832000 	str	r2, [r3]
	datapos  %= BITSTREAM_BUFSIZE;
300366b8:	e59f3998 	ldr	r3, [pc, #2456]	; 30037058 <III_hufman_decode+0xba8>
300366bc:	e5933000 	ldr	r3, [r3]
300366c0:	e1a02fc3 	asr	r2, r3, #31
300366c4:	e1a02aa2 	lsr	r2, r2, #21
300366c8:	e0833002 	add	r3, r3, r2
300366cc:	e1a03a83 	lsl	r3, r3, #21
300366d0:	e1a03aa3 	lsr	r3, r3, #21
300366d4:	e0623003 	rsb	r3, r2, r3
300366d8:	e1a02003 	mov	r2, r3
300366dc:	e59f3974 	ldr	r3, [pc, #2420]	; 30037058 <III_hufman_decode+0xba8>
300366e0:	e5832000 	str	r2, [r3]
	dataword|= buf[datapos++]       ;
300366e4:	e59f396c 	ldr	r3, [pc, #2412]	; 30037058 <III_hufman_decode+0xba8>
300366e8:	e5933000 	ldr	r3, [r3]
300366ec:	e59f2968 	ldr	r2, [pc, #2408]	; 3003705c <III_hufman_decode+0xbac>
300366f0:	e7d22003 	ldrb	r2, [r2, r3]
300366f4:	e1a01002 	mov	r1, r2
300366f8:	e59f2960 	ldr	r2, [pc, #2400]	; 30037060 <III_hufman_decode+0xbb0>
300366fc:	e5922000 	ldr	r2, [r2]
30036700:	e1811002 	orr	r1, r1, r2
30036704:	e59f2954 	ldr	r2, [pc, #2388]	; 30037060 <III_hufman_decode+0xbb0>
30036708:	e5821000 	str	r1, [r2]
3003670c:	e2832001 	add	r2, r3, #1
30036710:	e59f3940 	ldr	r3, [pc, #2368]	; 30037058 <III_hufman_decode+0xba8>
30036714:	e5832000 	str	r2, [r3]
	datapos  %= BITSTREAM_BUFSIZE;
30036718:	e59f3938 	ldr	r3, [pc, #2360]	; 30037058 <III_hufman_decode+0xba8>
3003671c:	e5933000 	ldr	r3, [r3]
30036720:	e1a02fc3 	asr	r2, r3, #31
30036724:	e1a02aa2 	lsr	r2, r2, #21
30036728:	e0833002 	add	r3, r3, r2
3003672c:	e1a03a83 	lsl	r3, r3, #21
30036730:	e1a03aa3 	lsr	r3, r3, #21
30036734:	e0623003 	rsb	r3, r2, r3
30036738:	e1a02003 	mov	r2, r3
3003673c:	e59f3914 	ldr	r3, [pc, #2324]	; 30037058 <III_hufman_decode+0xba8>
30036740:	e5832000 	str	r2, [r3]

	dataword <<= bitpos;  /* strip the misaligned leading bits  ������bitposλ*/
30036744:	e59f3914 	ldr	r3, [pc, #2324]	; 30037060 <III_hufman_decode+0xbb0>
30036748:	e5932000 	ldr	r2, [r3]
3003674c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30036750:	e1a02312 	lsl	r2, r2, r3
30036754:	e59f3904 	ldr	r3, [pc, #2308]	; 30037060 <III_hufman_decode+0xbb0>
30036758:	e5832000 	str	r2, [r3]
	dataword_len = 32 - bitpos;  /* number of valid bits in dataword  ��Чλ�ĳ���*/
3003675c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
30036760:	e2632020 	rsb	r2, r3, #32
30036764:	e59f38f8 	ldr	r3, [pc, #2296]	; 30037064 <III_hufman_decode+0xbb4>
30036768:	e5832000 	str	r2, [r3]
	/* now dataword is loaded with at least 24 bits of data */
    }

    part3_length -= totpos;    //���㲿��2�Ľ���λ��
3003676c:	e59f38e0 	ldr	r3, [pc, #2272]	; 30037054 <III_hufman_decode+0xba4>
30036770:	e5933000 	ldr	r3, [r3]
30036774:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30036778:	e0633002 	rsb	r3, r3, r2
3003677c:	e58d3028 	str	r3, [sp, #40]	; 0x28

    /* read the big values, they come in pairs */

    h = gr->table_select[0];  /* start with the first table */
30036780:	e59d3014 	ldr	r3, [sp, #20]
30036784:	e593301c 	ldr	r3, [r3, #28]
30036788:	e58d3030 	str	r3, [sp, #48]	; 0x30
    for(i = 0; i < gr->big_values * 2; i += 2)
3003678c:	e3a03000 	mov	r3, #0
30036790:	e58d3024 	str	r3, [sp, #36]	; 0x24
30036794:	ea00019f 	b	30036e18 <III_hufman_decode+0x968>
	{
	unsigned long *h_tab;
	unsigned int lead;
	int l, len, x, y;

	if(i == reg1)
30036798:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
3003679c:	e59d301c 	ldr	r3, [sp, #28]
300367a0:	e1520003 	cmp	r2, r3
300367a4:	1a000003 	bne	300367b8 <III_hufman_decode+0x308>
	    h = gr->table_select[1];
300367a8:	e59d3014 	ldr	r3, [sp, #20]
300367ac:	e5933020 	ldr	r3, [r3, #32]
300367b0:	e58d3030 	str	r3, [sp, #48]	; 0x30
300367b4:	ea000006 	b	300367d4 <III_hufman_decode+0x324>
	else if(i == reg2)
300367b8:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
300367bc:	e59d3020 	ldr	r3, [sp, #32]
300367c0:	e1520003 	cmp	r2, r3
300367c4:	1a000002 	bne	300367d4 <III_hufman_decode+0x324>
	    h = gr->table_select[2];
300367c8:	e59d3014 	ldr	r3, [sp, #20]
300367cc:	e5933024 	ldr	r3, [r3, #36]	; 0x24
300367d0:	e58d3030 	str	r3, [sp, #48]	; 0x30
    h_tab = h_tables[h];
300367d4:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
300367d8:	e59f3888 	ldr	r3, [pc, #2184]	; 30037068 <III_hufman_decode+0xbb8>
300367dc:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300367e0:	e58d303c 	str	r3, [sp, #60]	; 0x3c

	/* dataword is always leftaligned, not rightaligned */

	lead = dataword >> (32 - NC_O); /* 19 - nc_o */
300367e4:	e59f3874 	ldr	r3, [pc, #2164]	; 30037060 <III_hufman_decode+0xbb0>
300367e8:	e5933000 	ldr	r3, [r3]
300367ec:	e1a03e23 	lsr	r3, r3, #28
300367f0:	e58d3040 	str	r3, [sp, #64]	; 0x40
	h_tab += h_cue[h][lead];  
300367f4:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
300367f8:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
300367fc:	e59f3868 	ldr	r3, [pc, #2152]	; 3003706c <III_hufman_decode+0xbbc>
30036800:	e1a01201 	lsl	r1, r1, #4
30036804:	e0812002 	add	r2, r1, r2
30036808:	e0823003 	add	r3, r2, r3
3003680c:	e5d33000 	ldrb	r3, [r3]
30036810:	e1a03103 	lsl	r3, r3, #2
30036814:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
30036818:	e0823003 	add	r3, r2, r3
3003681c:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	
	len = (*h_tab >> 8) & 0x1f;
30036820:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30036824:	e5933000 	ldr	r3, [r3]
30036828:	e1a03423 	lsr	r3, r3, #8
3003682c:	e203301f 	and	r3, r3, #31
30036830:	e58d3048 	str	r3, [sp, #72]	; 0x48
	
	/* check for an immediate hit, so we can decode short codes very fast
	 */

	if (((*h_tab>>(32-len))!=(dataword>>(32-len)))&&(len))
30036834:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30036838:	e5932000 	ldr	r2, [r3]
3003683c:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
30036840:	e2633020 	rsb	r3, r3, #32
30036844:	e1a02332 	lsr	r2, r2, r3
30036848:	e59f3810 	ldr	r3, [pc, #2064]	; 30037060 <III_hufman_decode+0xbb0>
3003684c:	e5931000 	ldr	r1, [r3]
30036850:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
30036854:	e2633020 	rsb	r3, r3, #32
30036858:	e1a03331 	lsr	r3, r1, r3
3003685c:	e1520003 	cmp	r2, r3
30036860:	0a000073 	beq	30036a34 <III_hufman_decode+0x584>
30036864:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
30036868:	e3530000 	cmp	r3, #0
3003686c:	0a000070 	beq	30036a34 <III_hufman_decode+0x584>
	{
	  int dir_flag;
	  int lag;
	  unsigned int chunk = (dataword & 0xffffe000) | 0x1ff; /* WHY */
30036870:	e59f37e8 	ldr	r3, [pc, #2024]	; 30037060 <III_hufman_decode+0xbb0>
30036874:	e5933000 	ldr	r3, [r3]
30036878:	e3c33d7f 	bic	r3, r3, #8128	; 0x1fc0
3003687c:	e3c3303f 	bic	r3, r3, #63	; 0x3f
30036880:	e1e034a3 	mvn	r3, r3, lsr #9
30036884:	e1e03483 	mvn	r3, r3, lsl #9
30036888:	e58d305c 	str	r3, [sp, #92]	; 0x5c
	  lag = h_cue[h][lead + 1] - h_cue[h][lead];
3003688c:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
30036890:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
30036894:	e2832001 	add	r2, r3, #1
30036898:	e59f37cc 	ldr	r3, [pc, #1996]	; 3003706c <III_hufman_decode+0xbbc>
3003689c:	e1a01201 	lsl	r1, r1, #4
300368a0:	e0812002 	add	r2, r1, r2
300368a4:	e0823003 	add	r3, r2, r3
300368a8:	e5d33000 	ldrb	r3, [r3]
300368ac:	e1a02003 	mov	r2, r3
300368b0:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
300368b4:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
300368b8:	e59f37ac 	ldr	r3, [pc, #1964]	; 3003706c <III_hufman_decode+0xbbc>
300368bc:	e1a00200 	lsl	r0, r0, #4
300368c0:	e0801001 	add	r1, r0, r1
300368c4:	e0813003 	add	r3, r1, r3
300368c8:	e5d33000 	ldrb	r3, [r3]
300368cc:	e0633002 	rsb	r3, r3, r2
300368d0:	e58d3058 	str	r3, [sp, #88]	; 0x58
	  dir_flag = 0;
300368d4:	e3a03000 	mov	r3, #0
300368d8:	e58d3054 	str	r3, [sp, #84]	; 0x54
	  while(lag > 1)
300368dc:	ea000032 	b	300369ac <III_hufman_decode+0x4fc>
	  {
	    if (!dir_flag)
300368e0:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
300368e4:	e3530000 	cmp	r3, #0
300368e8:	1a000006 	bne	30036908 <III_hufman_decode+0x458>
	      h_tab += lag >> 1;
300368ec:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
300368f0:	e1a030c3 	asr	r3, r3, #1
300368f4:	e1a03103 	lsl	r3, r3, #2
300368f8:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
300368fc:	e0823003 	add	r3, r2, r3
30036900:	e58d303c 	str	r3, [sp, #60]	; 0x3c
30036904:	ea000006 	b	30036924 <III_hufman_decode+0x474>
	    else
	      h_tab -= lag >> 1;
30036908:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3003690c:	e1a030c3 	asr	r3, r3, #1
30036910:	e1a03103 	lsl	r3, r3, #2
30036914:	e2633000 	rsb	r3, r3, #0
30036918:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3003691c:	e0823003 	add	r3, r2, r3
30036920:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	    if(*h_tab > chunk)
30036924:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30036928:	e5932000 	ldr	r2, [r3]
3003692c:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
30036930:	e1520003 	cmp	r2, r3
30036934:	9a00000e 	bls	30036974 <III_hufman_decode+0x4c4>
		{
		    if(!dir_flag)
30036938:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
3003693c:	e3530000 	cmp	r3, #0
30036940:	1a000003 	bne	30036954 <III_hufman_decode+0x4a4>
			    lag >>= 1;
30036944:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
30036948:	e1a030c3 	asr	r3, r3, #1
3003694c:	e58d3058 	str	r3, [sp, #88]	; 0x58
30036950:	ea000004 	b	30036968 <III_hufman_decode+0x4b8>
		    else
			    lag -= lag >> 1;
30036954:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
30036958:	e1a030c3 	asr	r3, r3, #1
3003695c:	e59d2058 	ldr	r2, [sp, #88]	; 0x58
30036960:	e0633002 	rsb	r3, r3, r2
30036964:	e58d3058 	str	r3, [sp, #88]	; 0x58
		    dir_flag =- 1;
30036968:	e3e03000 	mvn	r3, #0
3003696c:	e58d3054 	str	r3, [sp, #84]	; 0x54
30036970:	ea00000d 	b	300369ac <III_hufman_decode+0x4fc>
		}
		else
		{
		    if (!dir_flag)
30036974:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
30036978:	e3530000 	cmp	r3, #0
3003697c:	1a000005 	bne	30036998 <III_hufman_decode+0x4e8>
			   lag -= lag >> 1;
30036980:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
30036984:	e1a030c3 	asr	r3, r3, #1
30036988:	e59d2058 	ldr	r2, [sp, #88]	; 0x58
3003698c:	e0633002 	rsb	r3, r3, r2
30036990:	e58d3058 	str	r3, [sp, #88]	; 0x58
30036994:	ea000002 	b	300369a4 <III_hufman_decode+0x4f4>
		    else
			   lag >>= 1;
30036998:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
3003699c:	e1a030c3 	asr	r3, r3, #1
300369a0:	e58d3058 	str	r3, [sp, #88]	; 0x58
		    dir_flag = 0;
300369a4:	e3a03000 	mov	r3, #0
300369a8:	e58d3054 	str	r3, [sp, #84]	; 0x54
	  int dir_flag;
	  int lag;
	  unsigned int chunk = (dataword & 0xffffe000) | 0x1ff; /* WHY */
	  lag = h_cue[h][lead + 1] - h_cue[h][lead];
	  dir_flag = 0;
	  while(lag > 1)
300369ac:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
300369b0:	e3530001 	cmp	r3, #1
300369b4:	caffffc9 	bgt	300368e0 <III_hufman_decode+0x430>
			   lag >>= 1;
		    dir_flag = 0;
		}
	  }

      len = (*h_tab >> 8) & 0x1f;
300369b8:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
300369bc:	e5933000 	ldr	r3, [r3]
300369c0:	e1a03423 	lsr	r3, r3, #8
300369c4:	e203301f 	and	r3, r3, #31
300369c8:	e58d3048 	str	r3, [sp, #72]	; 0x48
      if((*h_tab >> (32 - len)) != (chunk >> (32 - len)))
300369cc:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
300369d0:	e5932000 	ldr	r2, [r3]
300369d4:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
300369d8:	e2633020 	rsb	r3, r3, #32
300369dc:	e1a02332 	lsr	r2, r2, r3
300369e0:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
300369e4:	e2633020 	rsb	r3, r3, #32
300369e8:	e59d105c 	ldr	r1, [sp, #92]	; 0x5c
300369ec:	e1a03331 	lsr	r3, r1, r3
300369f0:	e1520003 	cmp	r2, r3
300369f4:	0a00000e 	beq	30036a34 <III_hufman_decode+0x584>
	  {
		  if (!dir_flag)
300369f8:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
300369fc:	e3530000 	cmp	r3, #0
30036a00:	1a000003 	bne	30036a14 <III_hufman_decode+0x564>
		    h_tab++;
30036a04:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30036a08:	e2833004 	add	r3, r3, #4
30036a0c:	e58d303c 	str	r3, [sp, #60]	; 0x3c
30036a10:	ea000002 	b	30036a20 <III_hufman_decode+0x570>
		  else
		    h_tab--;
30036a14:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30036a18:	e2433004 	sub	r3, r3, #4
30036a1c:	e58d303c 	str	r3, [sp, #60]	; 0x3c
		  len = (*h_tab >> 8) & 0x1f;
30036a20:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30036a24:	e5933000 	ldr	r3, [r3]
30036a28:	e1a03423 	lsr	r3, r3, #8
30036a2c:	e203301f 	and	r3, r3, #31
30036a30:	e58d3048 	str	r3, [sp, #72]	; 0x48
	  }
	}
	
	dataword_len -= len;
30036a34:	e59f3628 	ldr	r3, [pc, #1576]	; 30037064 <III_hufman_decode+0xbb4>
30036a38:	e5932000 	ldr	r2, [r3]
30036a3c:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
30036a40:	e0632002 	rsb	r2, r3, r2
30036a44:	e59f3618 	ldr	r3, [pc, #1560]	; 30037064 <III_hufman_decode+0xbb4>
30036a48:	e5832000 	str	r2, [r3]
	dataword <<= len;  /* flush away the used bits */
30036a4c:	e59f360c 	ldr	r3, [pc, #1548]	; 30037060 <III_hufman_decode+0xbb0>
30036a50:	e5932000 	ldr	r2, [r3]
30036a54:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
30036a58:	e1a02312 	lsl	r2, r2, r3
30036a5c:	e59f35fc 	ldr	r3, [pc, #1532]	; 30037060 <III_hufman_decode+0xbb0>
30036a60:	e5832000 	str	r2, [r3]
	
	/* fill up dataword */
	while(dataword_len <= 24) {
30036a64:	ea000021 	b	30036af0 <III_hufman_decode+0x640>
	    dataword |= buf[datapos++] << (24 - dataword_len);
30036a68:	e59f35e8 	ldr	r3, [pc, #1512]	; 30037058 <III_hufman_decode+0xba8>
30036a6c:	e5933000 	ldr	r3, [r3]
30036a70:	e59f25e4 	ldr	r2, [pc, #1508]	; 3003705c <III_hufman_decode+0xbac>
30036a74:	e7d22003 	ldrb	r2, [r2, r3]
30036a78:	e1a01002 	mov	r1, r2
30036a7c:	e59f25e0 	ldr	r2, [pc, #1504]	; 30037064 <III_hufman_decode+0xbb4>
30036a80:	e5922000 	ldr	r2, [r2]
30036a84:	e2622018 	rsb	r2, r2, #24
30036a88:	e1a02211 	lsl	r2, r1, r2
30036a8c:	e1a01002 	mov	r1, r2
30036a90:	e59f25c8 	ldr	r2, [pc, #1480]	; 30037060 <III_hufman_decode+0xbb0>
30036a94:	e5922000 	ldr	r2, [r2]
30036a98:	e1811002 	orr	r1, r1, r2
30036a9c:	e59f25bc 	ldr	r2, [pc, #1468]	; 30037060 <III_hufman_decode+0xbb0>
30036aa0:	e5821000 	str	r1, [r2]
30036aa4:	e2832001 	add	r2, r3, #1
30036aa8:	e59f35a8 	ldr	r3, [pc, #1448]	; 30037058 <III_hufman_decode+0xba8>
30036aac:	e5832000 	str	r2, [r3]
	    dataword_len += 8;
30036ab0:	e59f35ac 	ldr	r3, [pc, #1452]	; 30037064 <III_hufman_decode+0xbb4>
30036ab4:	e5933000 	ldr	r3, [r3]
30036ab8:	e2832008 	add	r2, r3, #8
30036abc:	e59f35a0 	ldr	r3, [pc, #1440]	; 30037064 <III_hufman_decode+0xbb4>
30036ac0:	e5832000 	str	r2, [r3]
 	    datapos  %= BITSTREAM_BUFSIZE;    //��֤ȡ��ݵ�λ��,��ֹ���
30036ac4:	e59f358c 	ldr	r3, [pc, #1420]	; 30037058 <III_hufman_decode+0xba8>
30036ac8:	e5933000 	ldr	r3, [r3]
30036acc:	e1a02fc3 	asr	r2, r3, #31
30036ad0:	e1a02aa2 	lsr	r2, r2, #21
30036ad4:	e0833002 	add	r3, r3, r2
30036ad8:	e1a03a83 	lsl	r3, r3, #21
30036adc:	e1a03aa3 	lsr	r3, r3, #21
30036ae0:	e0623003 	rsb	r3, r2, r3
30036ae4:	e1a02003 	mov	r2, r3
30036ae8:	e59f3568 	ldr	r3, [pc, #1384]	; 30037058 <III_hufman_decode+0xba8>
30036aec:	e5832000 	str	r2, [r3]
	
	dataword_len -= len;
	dataword <<= len;  /* flush away the used bits */
	
	/* fill up dataword */
	while(dataword_len <= 24) {
30036af0:	e59f356c 	ldr	r3, [pc, #1388]	; 30037064 <III_hufman_decode+0xbb4>
30036af4:	e5933000 	ldr	r3, [r3]
30036af8:	e3530018 	cmp	r3, #24
30036afc:	daffffd9 	ble	30036a68 <III_hufman_decode+0x5b8>
 	    datapos  %= BITSTREAM_BUFSIZE;    //��֤ȡ��ݵ�λ��,��ֹ���
	}
	
	/* dataword now contains at least 24 bits */
	
	x = (*h_tab >> 4) & 0xf;
30036b00:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30036b04:	e5933000 	ldr	r3, [r3]
30036b08:	e1a03223 	lsr	r3, r3, #4
30036b0c:	e203300f 	and	r3, r3, #15
30036b10:	e58d304c 	str	r3, [sp, #76]	; 0x4c
	y = *h_tab & 0xf;
30036b14:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
30036b18:	e5933000 	ldr	r3, [r3]
30036b1c:	e203300f 	and	r3, r3, #15
30036b20:	e58d3050 	str	r3, [sp, #80]	; 0x50

	l = t_linbits[h];
30036b24:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
30036b28:	e59f3540 	ldr	r3, [pc, #1344]	; 30037070 <III_hufman_decode+0xbc0>
30036b2c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30036b30:	e58d3044 	str	r3, [sp, #68]	; 0x44
	/* linbits are used when values larger than 15 has to be encoded */

	/* l is 13 or less, and we know we have at least 24 bits of data
	   in the dataword, so use that directly */
	
	if(x == 15 && l > 0) {
30036b34:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
30036b38:	e353000f 	cmp	r3, #15
30036b3c:	1a00003d 	bne	30036c38 <III_hufman_decode+0x788>
30036b40:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30036b44:	e3530000 	cmp	r3, #0
30036b48:	da00003a 	ble	30036c38 <III_hufman_decode+0x788>
	    x += dataword >> (32 - l);
30036b4c:	e59f350c 	ldr	r3, [pc, #1292]	; 30037060 <III_hufman_decode+0xbb0>
30036b50:	e5932000 	ldr	r2, [r3]
30036b54:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30036b58:	e2633020 	rsb	r3, r3, #32
30036b5c:	e1a02332 	lsr	r2, r2, r3
30036b60:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
30036b64:	e0823003 	add	r3, r2, r3
30036b68:	e58d304c 	str	r3, [sp, #76]	; 0x4c
	    dataword <<= l;
30036b6c:	e59f34ec 	ldr	r3, [pc, #1260]	; 30037060 <III_hufman_decode+0xbb0>
30036b70:	e5932000 	ldr	r2, [r3]
30036b74:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30036b78:	e1a02312 	lsl	r2, r2, r3
30036b7c:	e59f34dc 	ldr	r3, [pc, #1244]	; 30037060 <III_hufman_decode+0xbb0>
30036b80:	e5832000 	str	r2, [r3]
	    dataword_len -= l;
30036b84:	e59f34d8 	ldr	r3, [pc, #1240]	; 30037064 <III_hufman_decode+0xbb4>
30036b88:	e5932000 	ldr	r2, [r3]
30036b8c:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30036b90:	e0632002 	rsb	r2, r3, r2
30036b94:	e59f34c8 	ldr	r3, [pc, #1224]	; 30037064 <III_hufman_decode+0xbb4>
30036b98:	e5832000 	str	r2, [r3]
	    /* better refill since we might have used 13 bits */
	    while(dataword_len <= 24) {
30036b9c:	ea000021 	b	30036c28 <III_hufman_decode+0x778>
		  dataword |= buf[datapos++] << (24 - dataword_len);
30036ba0:	e59f34b0 	ldr	r3, [pc, #1200]	; 30037058 <III_hufman_decode+0xba8>
30036ba4:	e5933000 	ldr	r3, [r3]
30036ba8:	e59f24ac 	ldr	r2, [pc, #1196]	; 3003705c <III_hufman_decode+0xbac>
30036bac:	e7d22003 	ldrb	r2, [r2, r3]
30036bb0:	e1a01002 	mov	r1, r2
30036bb4:	e59f24a8 	ldr	r2, [pc, #1192]	; 30037064 <III_hufman_decode+0xbb4>
30036bb8:	e5922000 	ldr	r2, [r2]
30036bbc:	e2622018 	rsb	r2, r2, #24
30036bc0:	e1a02211 	lsl	r2, r1, r2
30036bc4:	e1a01002 	mov	r1, r2
30036bc8:	e59f2490 	ldr	r2, [pc, #1168]	; 30037060 <III_hufman_decode+0xbb0>
30036bcc:	e5922000 	ldr	r2, [r2]
30036bd0:	e1811002 	orr	r1, r1, r2
30036bd4:	e59f2484 	ldr	r2, [pc, #1156]	; 30037060 <III_hufman_decode+0xbb0>
30036bd8:	e5821000 	str	r1, [r2]
30036bdc:	e2832001 	add	r2, r3, #1
30036be0:	e59f3470 	ldr	r3, [pc, #1136]	; 30037058 <III_hufman_decode+0xba8>
30036be4:	e5832000 	str	r2, [r3]
		  dataword_len += 8;
30036be8:	e59f3474 	ldr	r3, [pc, #1140]	; 30037064 <III_hufman_decode+0xbb4>
30036bec:	e5933000 	ldr	r3, [r3]
30036bf0:	e2832008 	add	r2, r3, #8
30036bf4:	e59f3468 	ldr	r3, [pc, #1128]	; 30037064 <III_hufman_decode+0xbb4>
30036bf8:	e5832000 	str	r2, [r3]
	      datapos = datapos % BITSTREAM_BUFSIZE;//��֤ȡ��ݵ�λ��,��ֹ���
30036bfc:	e59f3454 	ldr	r3, [pc, #1108]	; 30037058 <III_hufman_decode+0xba8>
30036c00:	e5933000 	ldr	r3, [r3]
30036c04:	e1a02fc3 	asr	r2, r3, #31
30036c08:	e1a02aa2 	lsr	r2, r2, #21
30036c0c:	e0833002 	add	r3, r3, r2
30036c10:	e1a03a83 	lsl	r3, r3, #21
30036c14:	e1a03aa3 	lsr	r3, r3, #21
30036c18:	e0623003 	rsb	r3, r2, r3
30036c1c:	e1a02003 	mov	r2, r3
30036c20:	e59f3430 	ldr	r3, [pc, #1072]	; 30037058 <III_hufman_decode+0xba8>
30036c24:	e5832000 	str	r2, [r3]
	if(x == 15 && l > 0) {
	    x += dataword >> (32 - l);
	    dataword <<= l;
	    dataword_len -= l;
	    /* better refill since we might have used 13 bits */
	    while(dataword_len <= 24) {
30036c28:	e59f3434 	ldr	r3, [pc, #1076]	; 30037064 <III_hufman_decode+0xbb4>
30036c2c:	e5933000 	ldr	r3, [r3]
30036c30:	e3530018 	cmp	r3, #24
30036c34:	daffffd9 	ble	30036ba0 <III_hufman_decode+0x6f0>
	      datapos = datapos % BITSTREAM_BUFSIZE;//��֤ȡ��ݵ�λ��,��ֹ���
	    }
	}

	/* read sign-bit for x */
	if(x) {
30036c38:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
30036c3c:	e3530000 	cmp	r3, #0
30036c40:	0a000010 	beq	30036c88 <III_hufman_decode+0x7d8>
	    if(dataword & 0x80000000)
30036c44:	e59f3414 	ldr	r3, [pc, #1044]	; 30037060 <III_hufman_decode+0xbb0>
30036c48:	e5933000 	ldr	r3, [r3]
30036c4c:	e3530000 	cmp	r3, #0
30036c50:	aa000002 	bge	30036c60 <III_hufman_decode+0x7b0>
	    	x = - x;
30036c54:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
30036c58:	e2633000 	rsb	r3, r3, #0
30036c5c:	e58d304c 	str	r3, [sp, #76]	; 0x4c
	    dataword <<= 1;
30036c60:	e59f33f8 	ldr	r3, [pc, #1016]	; 30037060 <III_hufman_decode+0xbb0>
30036c64:	e5933000 	ldr	r3, [r3]
30036c68:	e1a02083 	lsl	r2, r3, #1
30036c6c:	e59f33ec 	ldr	r3, [pc, #1004]	; 30037060 <III_hufman_decode+0xbb0>
30036c70:	e5832000 	str	r2, [r3]
	    dataword_len--;
30036c74:	e59f33e8 	ldr	r3, [pc, #1000]	; 30037064 <III_hufman_decode+0xbb4>
30036c78:	e5933000 	ldr	r3, [r3]
30036c7c:	e2432001 	sub	r2, r3, #1
30036c80:	e59f33dc 	ldr	r3, [pc, #988]	; 30037064 <III_hufman_decode+0xbb4>
30036c84:	e5832000 	str	r2, [r3]
	}

	if(y == 15 && l > 0) {
30036c88:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
30036c8c:	e353000f 	cmp	r3, #15
30036c90:	1a00003d 	bne	30036d8c <III_hufman_decode+0x8dc>
30036c94:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30036c98:	e3530000 	cmp	r3, #0
30036c9c:	da00003a 	ble	30036d8c <III_hufman_decode+0x8dc>
	    y += dataword >> (32 - l);
30036ca0:	e59f33b8 	ldr	r3, [pc, #952]	; 30037060 <III_hufman_decode+0xbb0>
30036ca4:	e5932000 	ldr	r2, [r3]
30036ca8:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30036cac:	e2633020 	rsb	r3, r3, #32
30036cb0:	e1a02332 	lsr	r2, r2, r3
30036cb4:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
30036cb8:	e0823003 	add	r3, r2, r3
30036cbc:	e58d3050 	str	r3, [sp, #80]	; 0x50
	    dataword <<= l; 
30036cc0:	e59f3398 	ldr	r3, [pc, #920]	; 30037060 <III_hufman_decode+0xbb0>
30036cc4:	e5932000 	ldr	r2, [r3]
30036cc8:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30036ccc:	e1a02312 	lsl	r2, r2, r3
30036cd0:	e59f3388 	ldr	r3, [pc, #904]	; 30037060 <III_hufman_decode+0xbb0>
30036cd4:	e5832000 	str	r2, [r3]
	    dataword_len -= l;
30036cd8:	e59f3384 	ldr	r3, [pc, #900]	; 30037064 <III_hufman_decode+0xbb4>
30036cdc:	e5932000 	ldr	r2, [r3]
30036ce0:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
30036ce4:	e0632002 	rsb	r2, r3, r2
30036ce8:	e59f3374 	ldr	r3, [pc, #884]	; 30037064 <III_hufman_decode+0xbb4>
30036cec:	e5832000 	str	r2, [r3]
	    /* better refill since we might have used 13 bits */
	    while(dataword_len <= 24) {
30036cf0:	ea000021 	b	30036d7c <III_hufman_decode+0x8cc>
 		  dataword |= buf[datapos++] << (24 - dataword_len);
30036cf4:	e59f335c 	ldr	r3, [pc, #860]	; 30037058 <III_hufman_decode+0xba8>
30036cf8:	e5933000 	ldr	r3, [r3]
30036cfc:	e59f2358 	ldr	r2, [pc, #856]	; 3003705c <III_hufman_decode+0xbac>
30036d00:	e7d22003 	ldrb	r2, [r2, r3]
30036d04:	e1a01002 	mov	r1, r2
30036d08:	e59f2354 	ldr	r2, [pc, #852]	; 30037064 <III_hufman_decode+0xbb4>
30036d0c:	e5922000 	ldr	r2, [r2]
30036d10:	e2622018 	rsb	r2, r2, #24
30036d14:	e1a02211 	lsl	r2, r1, r2
30036d18:	e1a01002 	mov	r1, r2
30036d1c:	e59f233c 	ldr	r2, [pc, #828]	; 30037060 <III_hufman_decode+0xbb0>
30036d20:	e5922000 	ldr	r2, [r2]
30036d24:	e1811002 	orr	r1, r1, r2
30036d28:	e59f2330 	ldr	r2, [pc, #816]	; 30037060 <III_hufman_decode+0xbb0>
30036d2c:	e5821000 	str	r1, [r2]
30036d30:	e2832001 	add	r2, r3, #1
30036d34:	e59f331c 	ldr	r3, [pc, #796]	; 30037058 <III_hufman_decode+0xba8>
30036d38:	e5832000 	str	r2, [r3]
		  dataword_len += 8;
30036d3c:	e59f3320 	ldr	r3, [pc, #800]	; 30037064 <III_hufman_decode+0xbb4>
30036d40:	e5933000 	ldr	r3, [r3]
30036d44:	e2832008 	add	r2, r3, #8
30036d48:	e59f3314 	ldr	r3, [pc, #788]	; 30037064 <III_hufman_decode+0xbb4>
30036d4c:	e5832000 	str	r2, [r3]
	      datapos %=  BITSTREAM_BUFSIZE;//��֤ȡ��ݵ�λ��,��ֹ���
30036d50:	e59f3300 	ldr	r3, [pc, #768]	; 30037058 <III_hufman_decode+0xba8>
30036d54:	e5933000 	ldr	r3, [r3]
30036d58:	e1a02fc3 	asr	r2, r3, #31
30036d5c:	e1a02aa2 	lsr	r2, r2, #21
30036d60:	e0833002 	add	r3, r3, r2
30036d64:	e1a03a83 	lsl	r3, r3, #21
30036d68:	e1a03aa3 	lsr	r3, r3, #21
30036d6c:	e0623003 	rsb	r3, r2, r3
30036d70:	e1a02003 	mov	r2, r3
30036d74:	e59f32dc 	ldr	r3, [pc, #732]	; 30037058 <III_hufman_decode+0xba8>
30036d78:	e5832000 	str	r2, [r3]
	if(y == 15 && l > 0) {
	    y += dataword >> (32 - l);
	    dataword <<= l; 
	    dataword_len -= l;
	    /* better refill since we might have used 13 bits */
	    while(dataword_len <= 24) {
30036d7c:	e59f32e0 	ldr	r3, [pc, #736]	; 30037064 <III_hufman_decode+0xbb4>
30036d80:	e5933000 	ldr	r3, [r3]
30036d84:	e3530018 	cmp	r3, #24
30036d88:	daffffd9 	ble	30036cf4 <III_hufman_decode+0x844>
	      datapos %=  BITSTREAM_BUFSIZE;//��֤ȡ��ݵ�λ��,��ֹ���
	    }
	}

	/* read sign-bit for y */
	if(y) {
30036d8c:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
30036d90:	e3530000 	cmp	r3, #0
30036d94:	0a000010 	beq	30036ddc <III_hufman_decode+0x92c>
	    if(dataword & 0x80000000)
30036d98:	e59f32c0 	ldr	r3, [pc, #704]	; 30037060 <III_hufman_decode+0xbb0>
30036d9c:	e5933000 	ldr	r3, [r3]
30036da0:	e3530000 	cmp	r3, #0
30036da4:	aa000002 	bge	30036db4 <III_hufman_decode+0x904>
	    	y = - y;
30036da8:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
30036dac:	e2633000 	rsb	r3, r3, #0
30036db0:	e58d3050 	str	r3, [sp, #80]	; 0x50
	    dataword <<= 1;
30036db4:	e59f32a4 	ldr	r3, [pc, #676]	; 30037060 <III_hufman_decode+0xbb0>
30036db8:	e5933000 	ldr	r3, [r3]
30036dbc:	e1a02083 	lsl	r2, r3, #1
30036dc0:	e59f3298 	ldr	r3, [pc, #664]	; 30037060 <III_hufman_decode+0xbb0>
30036dc4:	e5832000 	str	r2, [r3]
	    dataword_len--;
30036dc8:	e59f3294 	ldr	r3, [pc, #660]	; 30037064 <III_hufman_decode+0xbb4>
30036dcc:	e5933000 	ldr	r3, [r3]
30036dd0:	e2432001 	sub	r2, r3, #1
30036dd4:	e59f3288 	ldr	r3, [pc, #648]	; 30037064 <III_hufman_decode+0xbb4>
30036dd8:	e5832000 	str	r2, [r3]
	}

	*f++=x;
30036ddc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30036de0:	e59d204c 	ldr	r2, [sp, #76]	; 0x4c
30036de4:	e5832000 	str	r2, [r3]
30036de8:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30036dec:	e2833004 	add	r3, r3, #4
30036df0:	e58d3034 	str	r3, [sp, #52]	; 0x34
	*f++=y;
30036df4:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30036df8:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
30036dfc:	e5832000 	str	r2, [r3]
30036e00:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30036e04:	e2833004 	add	r3, r3, #4
30036e08:	e58d3034 	str	r3, [sp, #52]	; 0x34
    part3_length -= totpos;    //���㲿��2�Ľ���λ��

    /* read the big values, they come in pairs */

    h = gr->table_select[0];  /* start with the first table */
    for(i = 0; i < gr->big_values * 2; i += 2)
30036e0c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30036e10:	e2833002 	add	r3, r3, #2
30036e14:	e58d3024 	str	r3, [sp, #36]	; 0x24
30036e18:	e59d3014 	ldr	r3, [sp, #20]
30036e1c:	e5933004 	ldr	r3, [r3, #4]
30036e20:	e1a02083 	lsl	r2, r3, #1
30036e24:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30036e28:	e1520003 	cmp	r2, r3
30036e2c:	8afffe59 	bhi	30036798 <III_hufman_decode+0x2e8>
       keep decoding until all huffman bits have been decoded or until
       all frequency lines have been assigned (i == 576). 
    */
            
	  /* choose count1 table */
	  used=BITS_USED;
30036e30:	e59f3220 	ldr	r3, [pc, #544]	; 30037058 <III_hufman_decode+0xba8>
30036e34:	e5933000 	ldr	r3, [r3]
30036e38:	e1a02003 	mov	r2, r3
30036e3c:	e59f3210 	ldr	r3, [pc, #528]	; 30037054 <III_hufman_decode+0xba4>
30036e40:	e5933000 	ldr	r3, [r3]
30036e44:	e1a031a3 	lsr	r3, r3, #3
30036e48:	e0633002 	rsb	r3, r3, r2
30036e4c:	e1a03183 	lsl	r3, r3, #3
30036e50:	e1a03a83 	lsl	r3, r3, #21
30036e54:	e1a03aa3 	lsr	r3, r3, #21
30036e58:	e59f2204 	ldr	r2, [pc, #516]	; 30037064 <III_hufman_decode+0xbb4>
30036e5c:	e5922000 	ldr	r2, [r2]
30036e60:	e0622003 	rsb	r2, r2, r3
30036e64:	e59f31e8 	ldr	r3, [pc, #488]	; 30037054 <III_hufman_decode+0xba4>
30036e68:	e5933000 	ldr	r3, [r3]
30036e6c:	e2033007 	and	r3, r3, #7
30036e70:	e0633002 	rsb	r3, r3, r2
30036e74:	e58d302c 	str	r3, [sp, #44]	; 0x2c

      h = gr->count1table_select + 32;  
30036e78:	e59d3014 	ldr	r3, [sp, #20]
30036e7c:	e5933044 	ldr	r3, [r3, #68]	; 0x44
30036e80:	e2833020 	add	r3, r3, #32
30036e84:	e58d3030 	str	r3, [sp, #48]	; 0x30

      while(BITS_USED < part3_length && i < 576)
30036e88:	ea000011 	b	30036ed4 <III_hufman_decode+0xa24>
	  {

	    HuffmanTable_decode(h,f + 2, f + 3, f, f + 1);
30036e8c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30036e90:	e2832008 	add	r2, r3, #8
30036e94:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30036e98:	e283300c 	add	r3, r3, #12
30036e9c:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
30036ea0:	e2811004 	add	r1, r1, #4
30036ea4:	e58d1000 	str	r1, [sp]
30036ea8:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
30036eac:	e1a01002 	mov	r1, r2
30036eb0:	e1a02003 	mov	r2, r3
30036eb4:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30036eb8:	eb00006d 	bl	30037074 <HuffmanTable_decode>
	    f += 4;
30036ebc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30036ec0:	e2833010 	add	r3, r3, #16
30036ec4:	e58d3034 	str	r3, [sp, #52]	; 0x34
	    i += 4;
30036ec8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30036ecc:	e2833004 	add	r3, r3, #4
30036ed0:	e58d3024 	str	r3, [sp, #36]	; 0x24
	  /* choose count1 table */
	  used=BITS_USED;

      h = gr->count1table_select + 32;  

      while(BITS_USED < part3_length && i < 576)
30036ed4:	e59f317c 	ldr	r3, [pc, #380]	; 30037058 <III_hufman_decode+0xba8>
30036ed8:	e5933000 	ldr	r3, [r3]
30036edc:	e1a02003 	mov	r2, r3
30036ee0:	e59f316c 	ldr	r3, [pc, #364]	; 30037054 <III_hufman_decode+0xba4>
30036ee4:	e5933000 	ldr	r3, [r3]
30036ee8:	e1a031a3 	lsr	r3, r3, #3
30036eec:	e0633002 	rsb	r3, r3, r2
30036ef0:	e1a03183 	lsl	r3, r3, #3
30036ef4:	e1a03a83 	lsl	r3, r3, #21
30036ef8:	e1a03aa3 	lsr	r3, r3, #21
30036efc:	e59f2160 	ldr	r2, [pc, #352]	; 30037064 <III_hufman_decode+0xbb4>
30036f00:	e5922000 	ldr	r2, [r2]
30036f04:	e0622003 	rsb	r2, r2, r3
30036f08:	e59f3144 	ldr	r3, [pc, #324]	; 30037054 <III_hufman_decode+0xba4>
30036f0c:	e5933000 	ldr	r3, [r3]
30036f10:	e2033007 	and	r3, r3, #7
30036f14:	e0632002 	rsb	r2, r3, r2
30036f18:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30036f1c:	e1520003 	cmp	r2, r3
30036f20:	2a000004 	bcs	30036f38 <III_hufman_decode+0xa88>
30036f24:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30036f28:	e3a03f8f 	mov	r3, #572	; 0x23c
30036f2c:	e2833003 	add	r3, r3, #3
30036f30:	e1520003 	cmp	r2, r3
30036f34:	9affffd4 	bls	30036e8c <III_hufman_decode+0x9dc>
	    HuffmanTable_decode(h,f + 2, f + 3, f, f + 1);
	    f += 4;
	    i += 4;
	  }

      used = BITS_USED;
30036f38:	e59f3118 	ldr	r3, [pc, #280]	; 30037058 <III_hufman_decode+0xba8>
30036f3c:	e5933000 	ldr	r3, [r3]
30036f40:	e1a02003 	mov	r2, r3
30036f44:	e59f3108 	ldr	r3, [pc, #264]	; 30037054 <III_hufman_decode+0xba4>
30036f48:	e5933000 	ldr	r3, [r3]
30036f4c:	e1a031a3 	lsr	r3, r3, #3
30036f50:	e0633002 	rsb	r3, r3, r2
30036f54:	e1a03183 	lsl	r3, r3, #3
30036f58:	e1a03a83 	lsl	r3, r3, #21
30036f5c:	e1a03aa3 	lsr	r3, r3, #21
30036f60:	e59f20fc 	ldr	r2, [pc, #252]	; 30037064 <III_hufman_decode+0xbb4>
30036f64:	e5922000 	ldr	r2, [r2]
30036f68:	e0622003 	rsb	r2, r2, r3
30036f6c:	e59f30e0 	ldr	r3, [pc, #224]	; 30037054 <III_hufman_decode+0xba4>
30036f70:	e5933000 	ldr	r3, [r3]
30036f74:	e2033007 	and	r3, r3, #7
30036f78:	e0633002 	rsb	r3, r3, r2
30036f7c:	e58d302c 	str	r3, [sp, #44]	; 0x2c

	  hgetbits(used);
30036f80:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30036f84:	e1a00003 	mov	r0, r3
30036f88:	eb00019f 	bl	3003760c <hgetbits>


	  /* rewind if we got a bit too far, and discard if we got too short  */
	  if(used>10000000 || used<0)
30036f8c:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30036f90:	e3a03726 	mov	r3, #9961472	; 0x980000
30036f94:	e2833c96 	add	r3, r3, #38400	; 0x9600
30036f98:	e2833080 	add	r3, r3, #128	; 0x80
30036f9c:	e1520003 	cmp	r2, r3
30036fa0:	8a000025 	bhi	3003703c <III_hufman_decode+0xb8c>
		  return;
      if(used>part3_length)                    //��֤totpos��part3_length���ȵ��ۼ�
30036fa4:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30036fa8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30036fac:	e1520003 	cmp	r2, r3
30036fb0:	9a000008 	bls	30036fd8 <III_hufman_decode+0xb28>
	  {
	     i -= 4;
30036fb4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30036fb8:	e2433004 	sub	r3, r3, #4
30036fbc:	e58d3024 	str	r3, [sp, #36]	; 0x24
	     rewindNbits(used - part3_length);
30036fc0:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30036fc4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30036fc8:	e0633002 	rsb	r3, r3, r2
30036fcc:	e1a00003 	mov	r0, r3
30036fd0:	eb0001e3 	bl	30037764 <rewindNbits>
	  else if(used<part3_length)
		 hgetbits(part3_length-used);    //�����

	  /* the rest of the frequency lines are zero */

      for(; i < 576; i++)
30036fd4:	ea000012 	b	30037024 <III_hufman_decode+0xb74>
	  {
	     i -= 4;
	     rewindNbits(used - part3_length);
	  }
   /*   ���  totpos ����  */
	  else if(used<part3_length)
30036fd8:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
30036fdc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30036fe0:	e1520003 	cmp	r2, r3
30036fe4:	2a00000e 	bcs	30037024 <III_hufman_decode+0xb74>
		 hgetbits(part3_length-used);    //�����
30036fe8:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30036fec:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30036ff0:	e0633002 	rsb	r3, r3, r2
30036ff4:	e1a00003 	mov	r0, r3
30036ff8:	eb000183 	bl	3003760c <hgetbits>

	  /* the rest of the frequency lines are zero */

      for(; i < 576; i++)
30036ffc:	ea000008 	b	30037024 <III_hufman_decode+0xb74>
  	   *f++=0;
30037000:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30037004:	e3a02000 	mov	r2, #0
30037008:	e5832000 	str	r2, [r3]
3003700c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30037010:	e2833004 	add	r3, r3, #4
30037014:	e58d3034 	str	r3, [sp, #52]	; 0x34
	  else if(used<part3_length)
		 hgetbits(part3_length-used);    //�����

	  /* the rest of the frequency lines are zero */

      for(; i < 576; i++)
30037018:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3003701c:	e2833001 	add	r3, r3, #1
30037020:	e58d3024 	str	r3, [sp, #36]	; 0x24
30037024:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
30037028:	e3a03f8f 	mov	r3, #572	; 0x23c
3003702c:	e2833003 	add	r3, r3, #3
30037030:	e1520003 	cmp	r2, r3
30037034:	9afffff1 	bls	30037000 <III_hufman_decode+0xb50>
30037038:	ea000000 	b	30037040 <III_hufman_decode+0xb90>
	  hgetbits(used);


	  /* rewind if we got a bit too far, and discard if we got too short  */
	  if(used>10000000 || used<0)
		  return;
3003703c:	e1a00000 	nop			; (mov r0, r0)
	  /* the rest of the frequency lines are zero */

      for(; i < 576; i++)
  	   *f++=0;

}
30037040:	e28dd064 	add	sp, sp, #100	; 0x64
30037044:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30037048:	e12fff1e 	bx	lr
3003704c:	302be81c 	.word	0x302be81c
30037050:	300c7eb4 	.word	0x300c7eb4
30037054:	300ea2e0 	.word	0x300ea2e0
30037058:	3012d6a8 	.word	0x3012d6a8
3003705c:	302bda68 	.word	0x302bda68
30037060:	300e597c 	.word	0x300e597c
30037064:	302be56c 	.word	0x302be56c
30037068:	300c7da8 	.word	0x300c7da8
3003706c:	300c7b88 	.word	0x300c7b88
30037070:	300c7e30 	.word	0x300c7e30

30037074 <HuffmanTable_decode>:



int HuffmanTable_decode(int tbl, 
		    int *x, int *y, int *v, int *w)
{
30037074:	e24dd030 	sub	sp, sp, #48	; 0x30
30037078:	e58d000c 	str	r0, [sp, #12]
3003707c:	e58d1008 	str	r1, [sp, #8]
30037080:	e58d2004 	str	r2, [sp, #4]
30037084:	e58d3000 	str	r3, [sp]
    unsigned long *h_tab;
    unsigned int lead;
    int len,code;
  
    h_tab = h_tables[tbl];
30037088:	e59d200c 	ldr	r2, [sp, #12]
3003708c:	e59f3514 	ldr	r3, [pc, #1300]	; 300375a8 <HuffmanTable_decode+0x534>
30037090:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30037094:	e58d3014 	str	r3, [sp, #20]

    /* dataword is always leftaligned, not rightaligned */

    lead = dataword >> (32 - NC_O); /* 19 - NC_O */
30037098:	e59f350c 	ldr	r3, [pc, #1292]	; 300375ac <HuffmanTable_decode+0x538>
3003709c:	e5933000 	ldr	r3, [r3]
300370a0:	e1a03e23 	lsr	r3, r3, #28
300370a4:	e58d3018 	str	r3, [sp, #24]
    h_tab += h_cue[tbl][lead];  
300370a8:	e59d100c 	ldr	r1, [sp, #12]
300370ac:	e59d2018 	ldr	r2, [sp, #24]
300370b0:	e59f34f8 	ldr	r3, [pc, #1272]	; 300375b0 <HuffmanTable_decode+0x53c>
300370b4:	e1a01201 	lsl	r1, r1, #4
300370b8:	e0812002 	add	r2, r1, r2
300370bc:	e0823003 	add	r3, r2, r3
300370c0:	e5d33000 	ldrb	r3, [r3]
300370c4:	e1a03103 	lsl	r3, r3, #2
300370c8:	e59d2014 	ldr	r2, [sp, #20]
300370cc:	e0823003 	add	r3, r2, r3
300370d0:	e58d3014 	str	r3, [sp, #20]
    
    len = (*h_tab >> 8) & 0x1f;
300370d4:	e59d3014 	ldr	r3, [sp, #20]
300370d8:	e5933000 	ldr	r3, [r3]
300370dc:	e1a03423 	lsr	r3, r3, #8
300370e0:	e203301f 	and	r3, r3, #31
300370e4:	e58d301c 	str	r3, [sp, #28]
    
    /* check for an immediate hit, so we can decode short codes very fast
     */
    if ((*h_tab >> (32 - len)) != dataword >> (32 - len)) 
300370e8:	e59d3014 	ldr	r3, [sp, #20]
300370ec:	e5932000 	ldr	r2, [r3]
300370f0:	e59d301c 	ldr	r3, [sp, #28]
300370f4:	e2633020 	rsb	r3, r3, #32
300370f8:	e1a02332 	lsr	r2, r2, r3
300370fc:	e59f34a8 	ldr	r3, [pc, #1192]	; 300375ac <HuffmanTable_decode+0x538>
30037100:	e5931000 	ldr	r1, [r3]
30037104:	e59d301c 	ldr	r3, [sp, #28]
30037108:	e2633020 	rsb	r3, r3, #32
3003710c:	e1a03331 	lsr	r3, r1, r3
30037110:	e1520003 	cmp	r2, r3
30037114:	0a000070 	beq	300372dc <HuffmanTable_decode+0x268>
	{
	int dir_flag;
	int lag;
	unsigned int chunk = (dataword & 0xffffe000) | 0x1ff; /* WHY */
30037118:	e59f348c 	ldr	r3, [pc, #1164]	; 300375ac <HuffmanTable_decode+0x538>
3003711c:	e5933000 	ldr	r3, [r3]
30037120:	e3c33d7f 	bic	r3, r3, #8128	; 0x1fc0
30037124:	e3c3303f 	bic	r3, r3, #63	; 0x3f
30037128:	e1e034a3 	mvn	r3, r3, lsr #9
3003712c:	e1e03483 	mvn	r3, r3, lsl #9
30037130:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	lag = h_cue[tbl][lead + 1] - h_cue[tbl][lead];
30037134:	e59d100c 	ldr	r1, [sp, #12]
30037138:	e59d3018 	ldr	r3, [sp, #24]
3003713c:	e2832001 	add	r2, r3, #1
30037140:	e59f3468 	ldr	r3, [pc, #1128]	; 300375b0 <HuffmanTable_decode+0x53c>
30037144:	e1a01201 	lsl	r1, r1, #4
30037148:	e0812002 	add	r2, r1, r2
3003714c:	e0823003 	add	r3, r2, r3
30037150:	e5d33000 	ldrb	r3, [r3]
30037154:	e1a02003 	mov	r2, r3
30037158:	e59d000c 	ldr	r0, [sp, #12]
3003715c:	e59d1018 	ldr	r1, [sp, #24]
30037160:	e59f3448 	ldr	r3, [pc, #1096]	; 300375b0 <HuffmanTable_decode+0x53c>
30037164:	e1a00200 	lsl	r0, r0, #4
30037168:	e0801001 	add	r1, r0, r1
3003716c:	e0813003 	add	r3, r1, r3
30037170:	e5d33000 	ldrb	r3, [r3]
30037174:	e0633002 	rsb	r3, r3, r2
30037178:	e58d3028 	str	r3, [sp, #40]	; 0x28
	dir_flag = 0;
3003717c:	e3a03000 	mov	r3, #0
30037180:	e58d3024 	str	r3, [sp, #36]	; 0x24
	while(lag > 1)
30037184:	ea000032 	b	30037254 <HuffmanTable_decode+0x1e0>
	{
	  if (!dir_flag)
30037188:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3003718c:	e3530000 	cmp	r3, #0
30037190:	1a000006 	bne	300371b0 <HuffmanTable_decode+0x13c>
		h_tab += lag >> 1;
30037194:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30037198:	e1a030c3 	asr	r3, r3, #1
3003719c:	e1a03103 	lsl	r3, r3, #2
300371a0:	e59d2014 	ldr	r2, [sp, #20]
300371a4:	e0823003 	add	r3, r2, r3
300371a8:	e58d3014 	str	r3, [sp, #20]
300371ac:	ea000006 	b	300371cc <HuffmanTable_decode+0x158>
	  else
		h_tab -= lag >> 1;
300371b0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300371b4:	e1a030c3 	asr	r3, r3, #1
300371b8:	e1a03103 	lsl	r3, r3, #2
300371bc:	e2633000 	rsb	r3, r3, #0
300371c0:	e59d2014 	ldr	r2, [sp, #20]
300371c4:	e0823003 	add	r3, r2, r3
300371c8:	e58d3014 	str	r3, [sp, #20]
	  if(*h_tab > chunk)
300371cc:	e59d3014 	ldr	r3, [sp, #20]
300371d0:	e5932000 	ldr	r2, [r3]
300371d4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300371d8:	e1520003 	cmp	r2, r3
300371dc:	9a00000e 	bls	3003721c <HuffmanTable_decode+0x1a8>
	  {
		if(!dir_flag)
300371e0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300371e4:	e3530000 	cmp	r3, #0
300371e8:	1a000003 	bne	300371fc <HuffmanTable_decode+0x188>
		    lag >>= 1;
300371ec:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300371f0:	e1a030c3 	asr	r3, r3, #1
300371f4:	e58d3028 	str	r3, [sp, #40]	; 0x28
300371f8:	ea000004 	b	30037210 <HuffmanTable_decode+0x19c>
		else
		    lag -= lag >> 1;
300371fc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30037200:	e1a030c3 	asr	r3, r3, #1
30037204:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30037208:	e0633002 	rsb	r3, r3, r2
3003720c:	e58d3028 	str	r3, [sp, #40]	; 0x28
		dir_flag =- 1;
30037210:	e3e03000 	mvn	r3, #0
30037214:	e58d3024 	str	r3, [sp, #36]	; 0x24
30037218:	ea00000d 	b	30037254 <HuffmanTable_decode+0x1e0>
	  }
	  else
	  {
		if (!dir_flag)
3003721c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30037220:	e3530000 	cmp	r3, #0
30037224:	1a000005 	bne	30037240 <HuffmanTable_decode+0x1cc>
		    lag -= lag >> 1;
30037228:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3003722c:	e1a030c3 	asr	r3, r3, #1
30037230:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30037234:	e0633002 	rsb	r3, r3, r2
30037238:	e58d3028 	str	r3, [sp, #40]	; 0x28
3003723c:	ea000002 	b	3003724c <HuffmanTable_decode+0x1d8>
		else
		    lag >>= 1;
30037240:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30037244:	e1a030c3 	asr	r3, r3, #1
30037248:	e58d3028 	str	r3, [sp, #40]	; 0x28
		dir_flag = 0;
3003724c:	e3a03000 	mov	r3, #0
30037250:	e58d3024 	str	r3, [sp, #36]	; 0x24
	int dir_flag;
	int lag;
	unsigned int chunk = (dataword & 0xffffe000) | 0x1ff; /* WHY */
	lag = h_cue[tbl][lead + 1] - h_cue[tbl][lead];
	dir_flag = 0;
	while(lag > 1)
30037254:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30037258:	e3530001 	cmp	r3, #1
3003725c:	caffffc9 	bgt	30037188 <HuffmanTable_decode+0x114>
		else
		    lag >>= 1;
		dir_flag = 0;
	  }
	}
	len = (*h_tab >> 8) & 0x1f;
30037260:	e59d3014 	ldr	r3, [sp, #20]
30037264:	e5933000 	ldr	r3, [r3]
30037268:	e1a03423 	lsr	r3, r3, #8
3003726c:	e203301f 	and	r3, r3, #31
30037270:	e58d301c 	str	r3, [sp, #28]
	if((*h_tab >> (32 - len)) != (chunk >> (32 - len)))
30037274:	e59d3014 	ldr	r3, [sp, #20]
30037278:	e5932000 	ldr	r2, [r3]
3003727c:	e59d301c 	ldr	r3, [sp, #28]
30037280:	e2633020 	rsb	r3, r3, #32
30037284:	e1a02332 	lsr	r2, r2, r3
30037288:	e59d301c 	ldr	r3, [sp, #28]
3003728c:	e2633020 	rsb	r3, r3, #32
30037290:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
30037294:	e1a03331 	lsr	r3, r1, r3
30037298:	e1520003 	cmp	r2, r3
3003729c:	0a00000e 	beq	300372dc <HuffmanTable_decode+0x268>
	{
	    if (!dir_flag)
300372a0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300372a4:	e3530000 	cmp	r3, #0
300372a8:	1a000003 	bne	300372bc <HuffmanTable_decode+0x248>
		h_tab++;
300372ac:	e59d3014 	ldr	r3, [sp, #20]
300372b0:	e2833004 	add	r3, r3, #4
300372b4:	e58d3014 	str	r3, [sp, #20]
300372b8:	ea000002 	b	300372c8 <HuffmanTable_decode+0x254>
	    else
		h_tab--;
300372bc:	e59d3014 	ldr	r3, [sp, #20]
300372c0:	e2433004 	sub	r3, r3, #4
300372c4:	e58d3014 	str	r3, [sp, #20]
	    len = (*h_tab >> 8) & 0x1f;
300372c8:	e59d3014 	ldr	r3, [sp, #20]
300372cc:	e5933000 	ldr	r3, [r3]
300372d0:	e1a03423 	lsr	r3, r3, #8
300372d4:	e203301f 	and	r3, r3, #31
300372d8:	e58d301c 	str	r3, [sp, #28]
	}
    }

    dataword_len -= len;
300372dc:	e59f32d0 	ldr	r3, [pc, #720]	; 300375b4 <HuffmanTable_decode+0x540>
300372e0:	e5932000 	ldr	r2, [r3]
300372e4:	e59d301c 	ldr	r3, [sp, #28]
300372e8:	e0632002 	rsb	r2, r3, r2
300372ec:	e59f32c0 	ldr	r3, [pc, #704]	; 300375b4 <HuffmanTable_decode+0x540>
300372f0:	e5832000 	str	r2, [r3]
    dataword <<= len;  /* flush away the used bits */
300372f4:	e59f32b0 	ldr	r3, [pc, #688]	; 300375ac <HuffmanTable_decode+0x538>
300372f8:	e5932000 	ldr	r2, [r3]
300372fc:	e59d301c 	ldr	r3, [sp, #28]
30037300:	e1a02312 	lsl	r2, r2, r3
30037304:	e59f32a0 	ldr	r3, [pc, #672]	; 300375ac <HuffmanTable_decode+0x538>
30037308:	e5832000 	str	r2, [r3]

    /* fill up dataword */
    while(dataword_len <= 24)
3003730c:	ea000021 	b	30037398 <HuffmanTable_decode+0x324>
	{
	  dataword |= buf[datapos++] << (24 - dataword_len);
30037310:	e59f32a0 	ldr	r3, [pc, #672]	; 300375b8 <HuffmanTable_decode+0x544>
30037314:	e5933000 	ldr	r3, [r3]
30037318:	e59f229c 	ldr	r2, [pc, #668]	; 300375bc <HuffmanTable_decode+0x548>
3003731c:	e7d22003 	ldrb	r2, [r2, r3]
30037320:	e1a01002 	mov	r1, r2
30037324:	e59f2288 	ldr	r2, [pc, #648]	; 300375b4 <HuffmanTable_decode+0x540>
30037328:	e5922000 	ldr	r2, [r2]
3003732c:	e2622018 	rsb	r2, r2, #24
30037330:	e1a02211 	lsl	r2, r1, r2
30037334:	e1a01002 	mov	r1, r2
30037338:	e59f226c 	ldr	r2, [pc, #620]	; 300375ac <HuffmanTable_decode+0x538>
3003733c:	e5922000 	ldr	r2, [r2]
30037340:	e1811002 	orr	r1, r1, r2
30037344:	e59f2260 	ldr	r2, [pc, #608]	; 300375ac <HuffmanTable_decode+0x538>
30037348:	e5821000 	str	r1, [r2]
3003734c:	e2832001 	add	r2, r3, #1
30037350:	e59f3260 	ldr	r3, [pc, #608]	; 300375b8 <HuffmanTable_decode+0x544>
30037354:	e5832000 	str	r2, [r3]
	  dataword_len += 8;
30037358:	e59f3254 	ldr	r3, [pc, #596]	; 300375b4 <HuffmanTable_decode+0x540>
3003735c:	e5933000 	ldr	r3, [r3]
30037360:	e2832008 	add	r2, r3, #8
30037364:	e59f3248 	ldr	r3, [pc, #584]	; 300375b4 <HuffmanTable_decode+0x540>
30037368:	e5832000 	str	r2, [r3]
      datapos %=  BITSTREAM_BUFSIZE;
3003736c:	e59f3244 	ldr	r3, [pc, #580]	; 300375b8 <HuffmanTable_decode+0x544>
30037370:	e5933000 	ldr	r3, [r3]
30037374:	e1a02fc3 	asr	r2, r3, #31
30037378:	e1a02aa2 	lsr	r2, r2, #21
3003737c:	e0833002 	add	r3, r3, r2
30037380:	e1a03a83 	lsl	r3, r3, #21
30037384:	e1a03aa3 	lsr	r3, r3, #21
30037388:	e0623003 	rsb	r3, r2, r3
3003738c:	e1a02003 	mov	r2, r3
30037390:	e59f3220 	ldr	r3, [pc, #544]	; 300375b8 <HuffmanTable_decode+0x544>
30037394:	e5832000 	str	r2, [r3]

    dataword_len -= len;
    dataword <<= len;  /* flush away the used bits */

    /* fill up dataword */
    while(dataword_len <= 24)
30037398:	e59f3214 	ldr	r3, [pc, #532]	; 300375b4 <HuffmanTable_decode+0x540>
3003739c:	e5933000 	ldr	r3, [r3]
300373a0:	e3530018 	cmp	r3, #24
300373a4:	daffffd9 	ble	30037310 <HuffmanTable_decode+0x29c>
      datapos %=  BITSTREAM_BUFSIZE;
    }

    /* dataword now contains at least 24 bits */

    *x = (*h_tab >> 4) & 0xf;
300373a8:	e59d3014 	ldr	r3, [sp, #20]
300373ac:	e5933000 	ldr	r3, [r3]
300373b0:	e1a03223 	lsr	r3, r3, #4
300373b4:	e203200f 	and	r2, r3, #15
300373b8:	e59d3008 	ldr	r3, [sp, #8]
300373bc:	e5832000 	str	r2, [r3]
	code=*x;
300373c0:	e59d3008 	ldr	r3, [sp, #8]
300373c4:	e5933000 	ldr	r3, [r3]
300373c8:	e58d3020 	str	r3, [sp, #32]
//	*y = *h_tab & 0xf;
  	
    *v = (*x >> 3) & 1;
300373cc:	e59d3008 	ldr	r3, [sp, #8]
300373d0:	e5933000 	ldr	r3, [r3]
300373d4:	e1a031c3 	asr	r3, r3, #3
300373d8:	e2032001 	and	r2, r3, #1
300373dc:	e59d3000 	ldr	r3, [sp]
300373e0:	e5832000 	str	r2, [r3]
    *w = (*x >> 2) & 1;
300373e4:	e59d3008 	ldr	r3, [sp, #8]
300373e8:	e5933000 	ldr	r3, [r3]
300373ec:	e1a03143 	asr	r3, r3, #2
300373f0:	e2032001 	and	r2, r3, #1
300373f4:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
300373f8:	e5832000 	str	r2, [r3]
    *y = *x & 1;                     //  ����X��ֵ!!!!!!!
300373fc:	e59d3008 	ldr	r3, [sp, #8]
30037400:	e5933000 	ldr	r3, [r3]
30037404:	e2032001 	and	r2, r3, #1
30037408:	e59d3004 	ldr	r3, [sp, #4]
3003740c:	e5832000 	str	r2, [r3]
    *x = (*x >> 1) & 1;
30037410:	e59d3008 	ldr	r3, [sp, #8]
30037414:	e5933000 	ldr	r3, [r3]
30037418:	e1a030c3 	asr	r3, r3, #1
3003741c:	e2032001 	and	r2, r3, #1
30037420:	e59d3008 	ldr	r3, [sp, #8]
30037424:	e5832000 	str	r2, [r3]
    
    /* read and process the sign bits */
    
    if(*v)
30037428:	e59d3000 	ldr	r3, [sp]
3003742c:	e5933000 	ldr	r3, [r3]
30037430:	e3530000 	cmp	r3, #0
30037434:	0a000012 	beq	30037484 <HuffmanTable_decode+0x410>
	{
	   if(dataword & 0x80000000)
30037438:	e59f316c 	ldr	r3, [pc, #364]	; 300375ac <HuffmanTable_decode+0x538>
3003743c:	e5933000 	ldr	r3, [r3]
30037440:	e3530000 	cmp	r3, #0
30037444:	aa000004 	bge	3003745c <HuffmanTable_decode+0x3e8>
	    *v = - *v;
30037448:	e59d3000 	ldr	r3, [sp]
3003744c:	e5933000 	ldr	r3, [r3]
30037450:	e2632000 	rsb	r2, r3, #0
30037454:	e59d3000 	ldr	r3, [sp]
30037458:	e5832000 	str	r2, [r3]
	   dataword <<= 1;
3003745c:	e59f3148 	ldr	r3, [pc, #328]	; 300375ac <HuffmanTable_decode+0x538>
30037460:	e5933000 	ldr	r3, [r3]
30037464:	e1a02083 	lsl	r2, r3, #1
30037468:	e59f313c 	ldr	r3, [pc, #316]	; 300375ac <HuffmanTable_decode+0x538>
3003746c:	e5832000 	str	r2, [r3]
	   dataword_len--;
30037470:	e59f313c 	ldr	r3, [pc, #316]	; 300375b4 <HuffmanTable_decode+0x540>
30037474:	e5933000 	ldr	r3, [r3]
30037478:	e2432001 	sub	r2, r3, #1
3003747c:	e59f3130 	ldr	r3, [pc, #304]	; 300375b4 <HuffmanTable_decode+0x540>
30037480:	e5832000 	str	r2, [r3]
    }
    if(*w) {
30037484:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
30037488:	e5933000 	ldr	r3, [r3]
3003748c:	e3530000 	cmp	r3, #0
30037490:	0a000012 	beq	300374e0 <HuffmanTable_decode+0x46c>
	if(dataword & 0x80000000)
30037494:	e59f3110 	ldr	r3, [pc, #272]	; 300375ac <HuffmanTable_decode+0x538>
30037498:	e5933000 	ldr	r3, [r3]
3003749c:	e3530000 	cmp	r3, #0
300374a0:	aa000004 	bge	300374b8 <HuffmanTable_decode+0x444>
	    *w = - *w;
300374a4:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
300374a8:	e5933000 	ldr	r3, [r3]
300374ac:	e2632000 	rsb	r2, r3, #0
300374b0:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
300374b4:	e5832000 	str	r2, [r3]
	dataword <<= 1;
300374b8:	e59f30ec 	ldr	r3, [pc, #236]	; 300375ac <HuffmanTable_decode+0x538>
300374bc:	e5933000 	ldr	r3, [r3]
300374c0:	e1a02083 	lsl	r2, r3, #1
300374c4:	e59f30e0 	ldr	r3, [pc, #224]	; 300375ac <HuffmanTable_decode+0x538>
300374c8:	e5832000 	str	r2, [r3]
	dataword_len--;
300374cc:	e59f30e0 	ldr	r3, [pc, #224]	; 300375b4 <HuffmanTable_decode+0x540>
300374d0:	e5933000 	ldr	r3, [r3]
300374d4:	e2432001 	sub	r2, r3, #1
300374d8:	e59f30d4 	ldr	r3, [pc, #212]	; 300375b4 <HuffmanTable_decode+0x540>
300374dc:	e5832000 	str	r2, [r3]
    }
    if(*x) {
300374e0:	e59d3008 	ldr	r3, [sp, #8]
300374e4:	e5933000 	ldr	r3, [r3]
300374e8:	e3530000 	cmp	r3, #0
300374ec:	0a000012 	beq	3003753c <HuffmanTable_decode+0x4c8>
	if(dataword & 0x80000000)
300374f0:	e59f30b4 	ldr	r3, [pc, #180]	; 300375ac <HuffmanTable_decode+0x538>
300374f4:	e5933000 	ldr	r3, [r3]
300374f8:	e3530000 	cmp	r3, #0
300374fc:	aa000004 	bge	30037514 <HuffmanTable_decode+0x4a0>
	    *x = - *x;
30037500:	e59d3008 	ldr	r3, [sp, #8]
30037504:	e5933000 	ldr	r3, [r3]
30037508:	e2632000 	rsb	r2, r3, #0
3003750c:	e59d3008 	ldr	r3, [sp, #8]
30037510:	e5832000 	str	r2, [r3]
	dataword <<= 1;
30037514:	e59f3090 	ldr	r3, [pc, #144]	; 300375ac <HuffmanTable_decode+0x538>
30037518:	e5933000 	ldr	r3, [r3]
3003751c:	e1a02083 	lsl	r2, r3, #1
30037520:	e59f3084 	ldr	r3, [pc, #132]	; 300375ac <HuffmanTable_decode+0x538>
30037524:	e5832000 	str	r2, [r3]
	dataword_len--;
30037528:	e59f3084 	ldr	r3, [pc, #132]	; 300375b4 <HuffmanTable_decode+0x540>
3003752c:	e5933000 	ldr	r3, [r3]
30037530:	e2432001 	sub	r2, r3, #1
30037534:	e59f3078 	ldr	r3, [pc, #120]	; 300375b4 <HuffmanTable_decode+0x540>
30037538:	e5832000 	str	r2, [r3]
    }
    if(*y) {
3003753c:	e59d3004 	ldr	r3, [sp, #4]
30037540:	e5933000 	ldr	r3, [r3]
30037544:	e3530000 	cmp	r3, #0
30037548:	0a000012 	beq	30037598 <HuffmanTable_decode+0x524>
	if(dataword & 0x80000000)
3003754c:	e59f3058 	ldr	r3, [pc, #88]	; 300375ac <HuffmanTable_decode+0x538>
30037550:	e5933000 	ldr	r3, [r3]
30037554:	e3530000 	cmp	r3, #0
30037558:	aa000004 	bge	30037570 <HuffmanTable_decode+0x4fc>
	    *y = - *y;
3003755c:	e59d3004 	ldr	r3, [sp, #4]
30037560:	e5933000 	ldr	r3, [r3]
30037564:	e2632000 	rsb	r2, r3, #0
30037568:	e59d3004 	ldr	r3, [sp, #4]
3003756c:	e5832000 	str	r2, [r3]
	dataword <<= 1;
30037570:	e59f3034 	ldr	r3, [pc, #52]	; 300375ac <HuffmanTable_decode+0x538>
30037574:	e5933000 	ldr	r3, [r3]
30037578:	e1a02083 	lsl	r2, r3, #1
3003757c:	e59f3028 	ldr	r3, [pc, #40]	; 300375ac <HuffmanTable_decode+0x538>
30037580:	e5832000 	str	r2, [r3]
	dataword_len--;
30037584:	e59f3028 	ldr	r3, [pc, #40]	; 300375b4 <HuffmanTable_decode+0x540>
30037588:	e5933000 	ldr	r3, [r3]
3003758c:	e2432001 	sub	r2, r3, #1
30037590:	e59f301c 	ldr	r3, [pc, #28]	; 300375b4 <HuffmanTable_decode+0x540>
30037594:	e5832000 	str	r2, [r3]
    }
    
    /* we have used up to 4 bits, so there are at least 20 bits
       left in dataword, which is enough for the next run */
    
    return code;
30037598:	e59d3020 	ldr	r3, [sp, #32]

}
3003759c:	e1a00003 	mov	r0, r3
300375a0:	e28dd030 	add	sp, sp, #48	; 0x30
300375a4:	e12fff1e 	bx	lr
300375a8:	300c7da8 	.word	0x300c7da8
300375ac:	300e597c 	.word	0x300e597c
300375b0:	300c7b88 	.word	0x300c7b88
300375b4:	302be56c 	.word	0x302be56c
300375b8:	3012d6a8 	.word	0x3012d6a8
300375bc:	302bda68 	.word	0x302bda68

300375c0 <hputbuf>:


void hputbuf(unsigned int val)
{
300375c0:	e24dd008 	sub	sp, sp, #8
300375c4:	e58d0004 	str	r0, [sp, #4]
	buf[offset % BITSTREAM_BUFSIZE] = val;
300375c8:	e59f3034 	ldr	r3, [pc, #52]	; 30037604 <hputbuf+0x44>
300375cc:	e5933000 	ldr	r3, [r3]
300375d0:	e1a03a83 	lsl	r3, r3, #21
300375d4:	e1a03aa3 	lsr	r3, r3, #21
300375d8:	e59d2004 	ldr	r2, [sp, #4]
300375dc:	e20210ff 	and	r1, r2, #255	; 0xff
300375e0:	e59f2020 	ldr	r2, [pc, #32]	; 30037608 <hputbuf+0x48>
300375e4:	e7c21003 	strb	r1, [r2, r3]
	offset++;
300375e8:	e59f3014 	ldr	r3, [pc, #20]	; 30037604 <hputbuf+0x44>
300375ec:	e5933000 	ldr	r3, [r3]
300375f0:	e2832001 	add	r2, r3, #1
300375f4:	e59f3008 	ldr	r3, [pc, #8]	; 30037604 <hputbuf+0x44>
300375f8:	e5832000 	str	r2, [r3]
}
300375fc:	e28dd008 	add	sp, sp, #8
30037600:	e12fff1e 	bx	lr
30037604:	302be268 	.word	0x302be268
30037608:	302bda68 	.word	0x302bda68

3003760c <hgetbits>:



/*read N bit from the bit stream */
unsigned int hgetbits(int N)
{
3003760c:	e92d0030 	push	{r4, r5}
30037610:	e24dd038 	sub	sp, sp, #56	; 0x38
30037614:	e58d0004 	str	r0, [sp, #4]
	unsigned int  val=0;
30037618:	e3a03000 	mov	r3, #0
3003761c:	e58d3030 	str	r3, [sp, #48]	; 0x30
	register int j = N;
30037620:	e59d5004 	ldr	r5, [sp, #4]
	register int tmp;
	int k;
    int putmask1[9]={0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff};
30037624:	e59f3124 	ldr	r3, [pc, #292]	; 30037750 <hgetbits+0x144>
30037628:	e28dc00c 	add	ip, sp, #12
3003762c:	e1a04003 	mov	r4, r3
30037630:	e8b4000f 	ldm	r4!, {r0, r1, r2, r3}
30037634:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
30037638:	e8b4000f 	ldm	r4!, {r0, r1, r2, r3}
3003763c:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
30037640:	e5943000 	ldr	r3, [r4]
30037644:	e58c3000 	str	r3, [ip]

/*
	 if (N > MAX_LENGTH)
		 printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
*/
	totpos += N;
30037648:	e59f3104 	ldr	r3, [pc, #260]	; 30037754 <hgetbits+0x148>
3003764c:	e5932000 	ldr	r2, [r3]
30037650:	e59d3004 	ldr	r3, [sp, #4]
30037654:	e0822003 	add	r2, r2, r3
30037658:	e59f30f4 	ldr	r3, [pc, #244]	; 30037754 <hgetbits+0x148>
3003765c:	e5832000 	str	r2, [r3]
	while (j > 0) {
30037660:	ea000033 	b	30037734 <hgetbits+0x128>
		if (!buf_bit_idx)
30037664:	e59f30ec 	ldr	r3, [pc, #236]	; 30037758 <hgetbits+0x14c>
30037668:	e5933000 	ldr	r3, [r3]
3003766c:	e3530000 	cmp	r3, #0
30037670:	1a000007 	bne	30037694 <hgetbits+0x88>
		{
			buf_bit_idx = 8;
30037674:	e59f30dc 	ldr	r3, [pc, #220]	; 30037758 <hgetbits+0x14c>
30037678:	e3a02008 	mov	r2, #8
3003767c:	e5832000 	str	r2, [r3]
			buf_byte_idx++;
30037680:	e59f30d4 	ldr	r3, [pc, #212]	; 3003775c <hgetbits+0x150>
30037684:	e5933000 	ldr	r3, [r3]
30037688:	e2832001 	add	r2, r3, #1
3003768c:	e59f30c8 	ldr	r3, [pc, #200]	; 3003775c <hgetbits+0x150>
30037690:	e5832000 	str	r2, [r3]
		}
		k = MIN(j, (int)buf_bit_idx);
30037694:	e59f30bc 	ldr	r3, [pc, #188]	; 30037758 <hgetbits+0x14c>
30037698:	e5933000 	ldr	r3, [r3]
3003769c:	e1530005 	cmp	r3, r5
300376a0:	a1a03005 	movge	r3, r5
300376a4:	e58d3034 	str	r3, [sp, #52]	; 0x34
		tmp = buf[buf_byte_idx%BITSTREAM_BUFSIZE]&putmask1[buf_bit_idx];
300376a8:	e59f30ac 	ldr	r3, [pc, #172]	; 3003775c <hgetbits+0x150>
300376ac:	e5933000 	ldr	r3, [r3]
300376b0:	e1a03a83 	lsl	r3, r3, #21
300376b4:	e1a03aa3 	lsr	r3, r3, #21
300376b8:	e59f20a0 	ldr	r2, [pc, #160]	; 30037760 <hgetbits+0x154>
300376bc:	e7d23003 	ldrb	r3, [r2, r3]
300376c0:	e1a02003 	mov	r2, r3
300376c4:	e59f308c 	ldr	r3, [pc, #140]	; 30037758 <hgetbits+0x14c>
300376c8:	e5931000 	ldr	r1, [r3]
300376cc:	e3e0302b 	mvn	r3, #43	; 0x2b
300376d0:	e1a01101 	lsl	r1, r1, #2
300376d4:	e28d0038 	add	r0, sp, #56	; 0x38
300376d8:	e0811000 	add	r1, r1, r0
300376dc:	e0813003 	add	r3, r1, r3
300376e0:	e5933000 	ldr	r3, [r3]
300376e4:	e0024003 	and	r4, r2, r3
		tmp = tmp >> (buf_bit_idx-k);
300376e8:	e59f3068 	ldr	r3, [pc, #104]	; 30037758 <hgetbits+0x14c>
300376ec:	e5932000 	ldr	r2, [r3]
300376f0:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
300376f4:	e0633002 	rsb	r3, r3, r2
300376f8:	e1a04354 	asr	r4, r4, r3
		val |= tmp << (j-k);
300376fc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30037700:	e0633005 	rsb	r3, r3, r5
30037704:	e1a03314 	lsl	r3, r4, r3
30037708:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
3003770c:	e1823003 	orr	r3, r2, r3
30037710:	e58d3030 	str	r3, [sp, #48]	; 0x30
		buf_bit_idx -= k;
30037714:	e59f303c 	ldr	r3, [pc, #60]	; 30037758 <hgetbits+0x14c>
30037718:	e5932000 	ldr	r2, [r3]
3003771c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30037720:	e0632002 	rsb	r2, r3, r2
30037724:	e59f302c 	ldr	r3, [pc, #44]	; 30037758 <hgetbits+0x14c>
30037728:	e5832000 	str	r2, [r3]
		j -= k;
3003772c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
30037730:	e0635005 	rsb	r5, r3, r5
/*
	 if (N > MAX_LENGTH)
		 printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
*/
	totpos += N;
	while (j > 0) {
30037734:	e3550000 	cmp	r5, #0
30037738:	caffffc9 	bgt	30037664 <hgetbits+0x58>
		tmp = tmp >> (buf_bit_idx-k);
		val |= tmp << (j-k);
		buf_bit_idx -= k;
		j -= k;
	}
	return(val);
3003773c:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
}
30037740:	e1a00003 	mov	r0, r3
30037744:	e28dd038 	add	sp, sp, #56	; 0x38
30037748:	e8bd0030 	pop	{r4, r5}
3003774c:	e12fff1e 	bx	lr
30037750:	30046194 	.word	0x30046194
30037754:	300ea2e0 	.word	0x300ea2e0
30037758:	300c7eb0 	.word	0x300c7eb0
3003775c:	3012b634 	.word	0x3012b634
30037760:	302bda68 	.word	0x302bda68

30037764 <rewindNbits>:


void rewindNbits(int N)
{
30037764:	e24dd008 	sub	sp, sp, #8
30037768:	e58d0004 	str	r0, [sp, #4]
	totpos -= N;
3003776c:	e59f306c 	ldr	r3, [pc, #108]	; 300377e0 <rewindNbits+0x7c>
30037770:	e5932000 	ldr	r2, [r3]
30037774:	e59d3004 	ldr	r3, [sp, #4]
30037778:	e0632002 	rsb	r2, r3, r2
3003777c:	e59f305c 	ldr	r3, [pc, #92]	; 300377e0 <rewindNbits+0x7c>
30037780:	e5832000 	str	r2, [r3]
	buf_bit_idx += N;
30037784:	e59f3058 	ldr	r3, [pc, #88]	; 300377e4 <rewindNbits+0x80>
30037788:	e5932000 	ldr	r2, [r3]
3003778c:	e59d3004 	ldr	r3, [sp, #4]
30037790:	e0822003 	add	r2, r2, r3
30037794:	e59f3048 	ldr	r3, [pc, #72]	; 300377e4 <rewindNbits+0x80>
30037798:	e5832000 	str	r2, [r3]
	while( buf_bit_idx >= 8 )
3003779c:	ea000009 	b	300377c8 <rewindNbits+0x64>
	{
		buf_bit_idx -= 8;
300377a0:	e59f303c 	ldr	r3, [pc, #60]	; 300377e4 <rewindNbits+0x80>
300377a4:	e5933000 	ldr	r3, [r3]
300377a8:	e2432008 	sub	r2, r3, #8
300377ac:	e59f3030 	ldr	r3, [pc, #48]	; 300377e4 <rewindNbits+0x80>
300377b0:	e5832000 	str	r2, [r3]
		buf_byte_idx--;
300377b4:	e59f302c 	ldr	r3, [pc, #44]	; 300377e8 <rewindNbits+0x84>
300377b8:	e5933000 	ldr	r3, [r3]
300377bc:	e2432001 	sub	r2, r3, #1
300377c0:	e59f3020 	ldr	r3, [pc, #32]	; 300377e8 <rewindNbits+0x84>
300377c4:	e5832000 	str	r2, [r3]

void rewindNbits(int N)
{
	totpos -= N;
	buf_bit_idx += N;
	while( buf_bit_idx >= 8 )
300377c8:	e59f3014 	ldr	r3, [pc, #20]	; 300377e4 <rewindNbits+0x80>
300377cc:	e5933000 	ldr	r3, [r3]
300377d0:	e3530007 	cmp	r3, #7
300377d4:	8afffff1 	bhi	300377a0 <rewindNbits+0x3c>
	{
		buf_bit_idx -= 8;
		buf_byte_idx--;
	}
}
300377d8:	e28dd008 	add	sp, sp, #8
300377dc:	e12fff1e 	bx	lr
300377e0:	300ea2e0 	.word	0x300ea2e0
300377e4:	300c7eb0 	.word	0x300c7eb0
300377e8:	3012b634 	.word	0x3012b634

300377ec <rewindNbytes>:


void rewindNbytes(int N)
{
300377ec:	e24dd008 	sub	sp, sp, #8
300377f0:	e58d0004 	str	r0, [sp, #4]
	totpos -= N*8;
300377f4:	e59d2004 	ldr	r2, [sp, #4]
300377f8:	e1a03002 	mov	r3, r2
300377fc:	e1a03e83 	lsl	r3, r3, #29
30037800:	e0623003 	rsb	r3, r2, r3
30037804:	e1a03183 	lsl	r3, r3, #3
30037808:	e1a02003 	mov	r2, r3
3003780c:	e59f302c 	ldr	r3, [pc, #44]	; 30037840 <rewindNbytes+0x54>
30037810:	e5933000 	ldr	r3, [r3]
30037814:	e0822003 	add	r2, r2, r3
30037818:	e59f3020 	ldr	r3, [pc, #32]	; 30037840 <rewindNbytes+0x54>
3003781c:	e5832000 	str	r2, [r3]
	buf_byte_idx -= N;
30037820:	e59f301c 	ldr	r3, [pc, #28]	; 30037844 <rewindNbytes+0x58>
30037824:	e5932000 	ldr	r2, [r3]
30037828:	e59d3004 	ldr	r3, [sp, #4]
3003782c:	e0632002 	rsb	r2, r3, r2
30037830:	e59f300c 	ldr	r3, [pc, #12]	; 30037844 <rewindNbytes+0x58>
30037834:	e5832000 	str	r2, [r3]
}
30037838:	e28dd008 	add	sp, sp, #8
3003783c:	e12fff1e 	bx	lr
30037840:	300ea2e0 	.word	0x300ea2e0
30037844:	3012b634 	.word	0x3012b634

30037848 <decode_info>:
		{0,4,8,12,16,22,30,42,58,78,104,138,180,192}}
};


void decode_info()
{
30037848:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3003784c:	e24dd00c 	sub	sp, sp, #12
    layer *hdr = fr_ps.header;
30037850:	e59f313c 	ldr	r3, [pc, #316]	; 30037994 <decode_info+0x14c>
30037854:	e5933000 	ldr	r3, [r3]
30037858:	e58d3000 	str	r3, [sp]
    int x;

    hdr->version = getbit(1);
3003785c:	e3a00001 	mov	r0, #1
30037860:	ebfff9b5 	bl	30035f3c <getbit>
30037864:	e1a03000 	mov	r3, r0
30037868:	e1a02003 	mov	r2, r3
3003786c:	e59d3000 	ldr	r3, [sp]
30037870:	e5832000 	str	r2, [r3]
    hdr->lay = 4-getbit(2);
30037874:	e3a00002 	mov	r0, #2
30037878:	ebfff9af 	bl	30035f3c <getbit>
3003787c:	e1a03000 	mov	r3, r0
30037880:	e2633004 	rsb	r3, r3, #4
30037884:	e1a02003 	mov	r2, r3
30037888:	e59d3000 	ldr	r3, [sp]
3003788c:	e5832004 	str	r2, [r3, #4]
    hdr->error_protection = !getbit(1); /* error protect. TRUE/FALSE */
30037890:	e3a00001 	mov	r0, #1
30037894:	ebfff9a8 	bl	30035f3c <getbit>
30037898:	e1a03000 	mov	r3, r0
3003789c:	e3530000 	cmp	r3, #0
300378a0:	13a02000 	movne	r2, #0
300378a4:	03a02001 	moveq	r2, #1
300378a8:	e59d3000 	ldr	r3, [sp]
300378ac:	e5832008 	str	r2, [r3, #8]
    hdr->bitrate_index = getbit(4);
300378b0:	e3a00004 	mov	r0, #4
300378b4:	ebfff9a0 	bl	30035f3c <getbit>
300378b8:	e1a03000 	mov	r3, r0
300378bc:	e1a02003 	mov	r2, r3
300378c0:	e59d3000 	ldr	r3, [sp]
300378c4:	e583200c 	str	r2, [r3, #12]
    hdr->sampling_frequency = getbit(2);
300378c8:	e3a00002 	mov	r0, #2
300378cc:	ebfff99a 	bl	30035f3c <getbit>
300378d0:	e1a03000 	mov	r3, r0
300378d4:	e1a02003 	mov	r2, r3
300378d8:	e59d3000 	ldr	r3, [sp]
300378dc:	e5832010 	str	r2, [r3, #16]
    hdr->padding = getbit(1);
300378e0:	e3a00001 	mov	r0, #1
300378e4:	ebfff994 	bl	30035f3c <getbit>
300378e8:	e1a03000 	mov	r3, r0
300378ec:	e1a02003 	mov	r2, r3
300378f0:	e59d3000 	ldr	r3, [sp]
300378f4:	e5832014 	str	r2, [r3, #20]
    hdr->extension = getbit(1);
300378f8:	e3a00001 	mov	r0, #1
300378fc:	ebfff98e 	bl	30035f3c <getbit>
30037900:	e1a03000 	mov	r3, r0
30037904:	e1a02003 	mov	r2, r3
30037908:	e59d3000 	ldr	r3, [sp]
3003790c:	e5832018 	str	r2, [r3, #24]
    hdr->mode = getbit(2);
30037910:	e3a00002 	mov	r0, #2
30037914:	ebfff988 	bl	30035f3c <getbit>
30037918:	e1a03000 	mov	r3, r0
3003791c:	e1a02003 	mov	r2, r3
30037920:	e59d3000 	ldr	r3, [sp]
30037924:	e583201c 	str	r2, [r3, #28]
    hdr->mode_ext = getbit(2);
30037928:	e3a00002 	mov	r0, #2
3003792c:	ebfff982 	bl	30035f3c <getbit>
30037930:	e1a03000 	mov	r3, r0
30037934:	e1a02003 	mov	r2, r3
30037938:	e59d3000 	ldr	r3, [sp]
3003793c:	e5832020 	str	r2, [r3, #32]
    hdr->copyright = getbit(1);
30037940:	e3a00001 	mov	r0, #1
30037944:	ebfff97c 	bl	30035f3c <getbit>
30037948:	e1a03000 	mov	r3, r0
3003794c:	e1a02003 	mov	r2, r3
30037950:	e59d3000 	ldr	r3, [sp]
30037954:	e5832024 	str	r2, [r3, #36]	; 0x24
    hdr->original = getbit(1);
30037958:	e3a00001 	mov	r0, #1
3003795c:	ebfff976 	bl	30035f3c <getbit>
30037960:	e1a03000 	mov	r3, r0
30037964:	e1a02003 	mov	r2, r3
30037968:	e59d3000 	ldr	r3, [sp]
3003796c:	e5832028 	str	r2, [r3, #40]	; 0x28
    hdr->emphasis = getbit(2);
30037970:	e3a00002 	mov	r0, #2
30037974:	ebfff970 	bl	30035f3c <getbit>
30037978:	e1a03000 	mov	r3, r0
3003797c:	e1a02003 	mov	r2, r3
30037980:	e59d3000 	ldr	r3, [sp]
30037984:	e583202c 	str	r2, [r3, #44]	; 0x2c
}
30037988:	e28dd00c 	add	sp, sp, #12
3003798c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30037990:	e12fff1e 	bx	lr
30037994:	302be81c 	.word	0x302be81c

30037998 <III_get_side_info>:

void III_get_side_info(III_side_info_t *si)
{
30037998:	e92d4070 	push	{r4, r5, r6, lr}
3003799c:	e24dd018 	sub	sp, sp, #24
300379a0:	e58d0004 	str	r0, [sp, #4]
	int ch, gr, i;
	int stereo = fr_ps.stereo;
300379a4:	e59f388c 	ldr	r3, [pc, #2188]	; 30038238 <III_get_side_info+0x8a0>
300379a8:	e5933008 	ldr	r3, [r3, #8]
300379ac:	e58d3014 	str	r3, [sp, #20]

	si->main_data_begin = getbit(9);  //SI ����Ϣ�ṹ
300379b0:	e3a00009 	mov	r0, #9
300379b4:	ebfff960 	bl	30035f3c <getbit>
300379b8:	e1a02000 	mov	r2, r0
300379bc:	e59d3004 	ldr	r3, [sp, #4]
300379c0:	e5832000 	str	r2, [r3]
	if (stereo == 1)
300379c4:	e59d3014 	ldr	r3, [sp, #20]
300379c8:	e3530001 	cmp	r3, #1
300379cc:	1a000005 	bne	300379e8 <III_get_side_info+0x50>
		si->private_bits = getbit(5);
300379d0:	e3a00005 	mov	r0, #5
300379d4:	ebfff958 	bl	30035f3c <getbit>
300379d8:	e1a02000 	mov	r2, r0
300379dc:	e59d3004 	ldr	r3, [sp, #4]
300379e0:	e5832004 	str	r2, [r3, #4]
300379e4:	ea000004 	b	300379fc <III_get_side_info+0x64>
	else
		si->private_bits = getbit(3);
300379e8:	e3a00003 	mov	r0, #3
300379ec:	ebfff952 	bl	30035f3c <getbit>
300379f0:	e1a02000 	mov	r2, r0
300379f4:	e59d3004 	ldr	r3, [sp, #4]
300379f8:	e5832004 	str	r2, [r3, #4]

	for (ch=0; ch<stereo; ch++)         //�ڶ������Ƿ�����Ϣ
300379fc:	e3a03000 	mov	r3, #0
30037a00:	e58d3008 	str	r3, [sp, #8]
30037a04:	ea000015 	b	30037a60 <III_get_side_info+0xc8>
		for (i=0; i<4; i++)
30037a08:	e3a03000 	mov	r3, #0
30037a0c:	e58d3010 	str	r3, [sp, #16]
30037a10:	ea00000c 	b	30037a48 <III_get_side_info+0xb0>
			si->scfsi[ch][i] = getbit(1);
30037a14:	e59d5008 	ldr	r5, [sp, #8]
30037a18:	e59d4010 	ldr	r4, [sp, #16]
30037a1c:	e3a00001 	mov	r0, #1
30037a20:	ebfff945 	bl	30035f3c <getbit>
30037a24:	e1a01000 	mov	r1, r0
30037a28:	e59d3004 	ldr	r3, [sp, #4]
30037a2c:	e1a02105 	lsl	r2, r5, #2
30037a30:	e0822004 	add	r2, r2, r4
30037a34:	e2822002 	add	r2, r2, #2
30037a38:	e7831102 	str	r1, [r3, r2, lsl #2]
		si->private_bits = getbit(5);
	else
		si->private_bits = getbit(3);

	for (ch=0; ch<stereo; ch++)         //�ڶ������Ƿ�����Ϣ
		for (i=0; i<4; i++)
30037a3c:	e59d3010 	ldr	r3, [sp, #16]
30037a40:	e2833001 	add	r3, r3, #1
30037a44:	e58d3010 	str	r3, [sp, #16]
30037a48:	e59d3010 	ldr	r3, [sp, #16]
30037a4c:	e3530003 	cmp	r3, #3
30037a50:	daffffef 	ble	30037a14 <III_get_side_info+0x7c>
	if (stereo == 1)
		si->private_bits = getbit(5);
	else
		si->private_bits = getbit(3);

	for (ch=0; ch<stereo; ch++)         //�ڶ������Ƿ�����Ϣ
30037a54:	e59d3008 	ldr	r3, [sp, #8]
30037a58:	e2833001 	add	r3, r3, #1
30037a5c:	e58d3008 	str	r3, [sp, #8]
30037a60:	e59d2008 	ldr	r2, [sp, #8]
30037a64:	e59d3014 	ldr	r3, [sp, #20]
30037a68:	e1520003 	cmp	r2, r3
30037a6c:	baffffe5 	blt	30037a08 <III_get_side_info+0x70>
		for (i=0; i<4; i++)
			si->scfsi[ch][i] = getbit(1);

	for (gr=0; gr<2; gr++) {
30037a70:	e3a03000 	mov	r3, #0
30037a74:	e58d300c 	str	r3, [sp, #12]
30037a78:	ea0001e8 	b	30038220 <III_get_side_info+0x888>
		for (ch=0; ch<stereo; ch++) {
30037a7c:	e3a03000 	mov	r3, #0
30037a80:	e58d3008 	str	r3, [sp, #8]
30037a84:	ea0001de 	b	30038204 <III_get_side_info+0x86c>
			grle[ch][gr].part2_3_length = getbit(12);
30037a88:	e59d4008 	ldr	r4, [sp, #8]
30037a8c:	e59d500c 	ldr	r5, [sp, #12]
30037a90:	e3a0000c 	mov	r0, #12
30037a94:	ebfff928 	bl	30035f3c <getbit>
30037a98:	e1a02000 	mov	r2, r0
30037a9c:	e59f1798 	ldr	r1, [pc, #1944]	; 3003823c <III_get_side_info+0x8a4>
30037aa0:	e1a03005 	mov	r3, r5
30037aa4:	e1a03183 	lsl	r3, r3, #3
30037aa8:	e0833005 	add	r3, r3, r5
30037aac:	e1a00183 	lsl	r0, r3, #3
30037ab0:	e1a03004 	mov	r3, r4
30037ab4:	e1a03183 	lsl	r3, r3, #3
30037ab8:	e0833004 	add	r3, r3, r4
30037abc:	e1a03203 	lsl	r3, r3, #4
30037ac0:	e0803003 	add	r3, r0, r3
30037ac4:	e0833001 	add	r3, r3, r1
30037ac8:	e5832000 	str	r2, [r3]
			grle[ch][gr].big_values = getbit(9);
30037acc:	e59d4008 	ldr	r4, [sp, #8]
30037ad0:	e59d500c 	ldr	r5, [sp, #12]
30037ad4:	e3a00009 	mov	r0, #9
30037ad8:	ebfff917 	bl	30035f3c <getbit>
30037adc:	e1a02000 	mov	r2, r0
30037ae0:	e59f0754 	ldr	r0, [pc, #1876]	; 3003823c <III_get_side_info+0x8a4>
30037ae4:	e3a01004 	mov	r1, #4
30037ae8:	e1a03005 	mov	r3, r5
30037aec:	e1a03183 	lsl	r3, r3, #3
30037af0:	e0833005 	add	r3, r3, r5
30037af4:	e1a0c183 	lsl	ip, r3, #3
30037af8:	e1a03004 	mov	r3, r4
30037afc:	e1a03183 	lsl	r3, r3, #3
30037b00:	e0833004 	add	r3, r3, r4
30037b04:	e1a03203 	lsl	r3, r3, #4
30037b08:	e08c3003 	add	r3, ip, r3
30037b0c:	e0833000 	add	r3, r3, r0
30037b10:	e0833001 	add	r3, r3, r1
30037b14:	e5832000 	str	r2, [r3]
			grle[ch][gr].global_gain = getbit(8);
30037b18:	e59d4008 	ldr	r4, [sp, #8]
30037b1c:	e59d500c 	ldr	r5, [sp, #12]
30037b20:	e3a00008 	mov	r0, #8
30037b24:	ebfff904 	bl	30035f3c <getbit>
30037b28:	e1a02000 	mov	r2, r0
30037b2c:	e59f0708 	ldr	r0, [pc, #1800]	; 3003823c <III_get_side_info+0x8a4>
30037b30:	e3a01008 	mov	r1, #8
30037b34:	e1a03005 	mov	r3, r5
30037b38:	e1a03183 	lsl	r3, r3, #3
30037b3c:	e0833005 	add	r3, r3, r5
30037b40:	e1a0c183 	lsl	ip, r3, #3
30037b44:	e1a03004 	mov	r3, r4
30037b48:	e1a03183 	lsl	r3, r3, #3
30037b4c:	e0833004 	add	r3, r3, r4
30037b50:	e1a03203 	lsl	r3, r3, #4
30037b54:	e08c3003 	add	r3, ip, r3
30037b58:	e0833000 	add	r3, r3, r0
30037b5c:	e0833001 	add	r3, r3, r1
30037b60:	e5832000 	str	r2, [r3]
			grle[ch][gr].scalefac_compress = getbit(4);
30037b64:	e59d4008 	ldr	r4, [sp, #8]
30037b68:	e59d500c 	ldr	r5, [sp, #12]
30037b6c:	e3a00004 	mov	r0, #4
30037b70:	ebfff8f1 	bl	30035f3c <getbit>
30037b74:	e1a02000 	mov	r2, r0
30037b78:	e59f06bc 	ldr	r0, [pc, #1724]	; 3003823c <III_get_side_info+0x8a4>
30037b7c:	e3a0100c 	mov	r1, #12
30037b80:	e1a03005 	mov	r3, r5
30037b84:	e1a03183 	lsl	r3, r3, #3
30037b88:	e0833005 	add	r3, r3, r5
30037b8c:	e1a0c183 	lsl	ip, r3, #3
30037b90:	e1a03004 	mov	r3, r4
30037b94:	e1a03183 	lsl	r3, r3, #3
30037b98:	e0833004 	add	r3, r3, r4
30037b9c:	e1a03203 	lsl	r3, r3, #4
30037ba0:	e08c3003 	add	r3, ip, r3
30037ba4:	e0833000 	add	r3, r3, r0
30037ba8:	e0833001 	add	r3, r3, r1
30037bac:	e5832000 	str	r2, [r3]
			grle[ch][gr].window_switching_flag = getbit(1);
30037bb0:	e59d4008 	ldr	r4, [sp, #8]
30037bb4:	e59d500c 	ldr	r5, [sp, #12]
30037bb8:	e3a00001 	mov	r0, #1
30037bbc:	ebfff8de 	bl	30035f3c <getbit>
30037bc0:	e1a02000 	mov	r2, r0
30037bc4:	e59f0670 	ldr	r0, [pc, #1648]	; 3003823c <III_get_side_info+0x8a4>
30037bc8:	e3a01010 	mov	r1, #16
30037bcc:	e1a03005 	mov	r3, r5
30037bd0:	e1a03183 	lsl	r3, r3, #3
30037bd4:	e0833005 	add	r3, r3, r5
30037bd8:	e1a0c183 	lsl	ip, r3, #3
30037bdc:	e1a03004 	mov	r3, r4
30037be0:	e1a03183 	lsl	r3, r3, #3
30037be4:	e0833004 	add	r3, r3, r4
30037be8:	e1a03203 	lsl	r3, r3, #4
30037bec:	e08c3003 	add	r3, ip, r3
30037bf0:	e0833000 	add	r3, r3, r0
30037bf4:	e0833001 	add	r3, r3, r1
30037bf8:	e5832000 	str	r2, [r3]
			if (grle[ch][gr].window_switching_flag) {            //������Ϊ1
30037bfc:	e59d2008 	ldr	r2, [sp, #8]
30037c00:	e59d100c 	ldr	r1, [sp, #12]
30037c04:	e59fc630 	ldr	ip, [pc, #1584]	; 3003823c <III_get_side_info+0x8a4>
30037c08:	e3a00010 	mov	r0, #16
30037c0c:	e1a03001 	mov	r3, r1
30037c10:	e1a03183 	lsl	r3, r3, #3
30037c14:	e0833001 	add	r3, r3, r1
30037c18:	e1a01183 	lsl	r1, r3, #3
30037c1c:	e1a03002 	mov	r3, r2
30037c20:	e1a03183 	lsl	r3, r3, #3
30037c24:	e0833002 	add	r3, r3, r2
30037c28:	e1a03203 	lsl	r3, r3, #4
30037c2c:	e0813003 	add	r3, r1, r3
30037c30:	e083300c 	add	r3, r3, ip
30037c34:	e0833000 	add	r3, r3, r0
30037c38:	e5933000 	ldr	r3, [r3]
30037c3c:	e3530000 	cmp	r3, #0
30037c40:	0a0000dc 	beq	30037fb8 <III_get_side_info+0x620>
				grle[ch][gr].block_type = getbit(2);
30037c44:	e59d4008 	ldr	r4, [sp, #8]
30037c48:	e59d500c 	ldr	r5, [sp, #12]
30037c4c:	e3a00002 	mov	r0, #2
30037c50:	ebfff8b9 	bl	30035f3c <getbit>
30037c54:	e1a02000 	mov	r2, r0
30037c58:	e59f05dc 	ldr	r0, [pc, #1500]	; 3003823c <III_get_side_info+0x8a4>
30037c5c:	e3a01014 	mov	r1, #20
30037c60:	e1a03005 	mov	r3, r5
30037c64:	e1a03183 	lsl	r3, r3, #3
30037c68:	e0833005 	add	r3, r3, r5
30037c6c:	e1a0c183 	lsl	ip, r3, #3
30037c70:	e1a03004 	mov	r3, r4
30037c74:	e1a03183 	lsl	r3, r3, #3
30037c78:	e0833004 	add	r3, r3, r4
30037c7c:	e1a03203 	lsl	r3, r3, #4
30037c80:	e08c3003 	add	r3, ip, r3
30037c84:	e0833000 	add	r3, r3, r0
30037c88:	e0833001 	add	r3, r3, r1
30037c8c:	e5832000 	str	r2, [r3]
				grle[ch][gr].mixed_block_flag = getbit(1);
30037c90:	e59d4008 	ldr	r4, [sp, #8]
30037c94:	e59d500c 	ldr	r5, [sp, #12]
30037c98:	e3a00001 	mov	r0, #1
30037c9c:	ebfff8a6 	bl	30035f3c <getbit>
30037ca0:	e1a02000 	mov	r2, r0
30037ca4:	e59f0590 	ldr	r0, [pc, #1424]	; 3003823c <III_get_side_info+0x8a4>
30037ca8:	e3a01018 	mov	r1, #24
30037cac:	e1a03005 	mov	r3, r5
30037cb0:	e1a03183 	lsl	r3, r3, #3
30037cb4:	e0833005 	add	r3, r3, r5
30037cb8:	e1a0c183 	lsl	ip, r3, #3
30037cbc:	e1a03004 	mov	r3, r4
30037cc0:	e1a03183 	lsl	r3, r3, #3
30037cc4:	e0833004 	add	r3, r3, r4
30037cc8:	e1a03203 	lsl	r3, r3, #4
30037ccc:	e08c3003 	add	r3, ip, r3
30037cd0:	e0833000 	add	r3, r3, r0
30037cd4:	e0833001 	add	r3, r3, r1
30037cd8:	e5832000 	str	r2, [r3]
				for (i=0; i<2; i++)
30037cdc:	e3a03000 	mov	r3, #0
30037ce0:	e58d3010 	str	r3, [sp, #16]
30037ce4:	ea000019 	b	30037d50 <III_get_side_info+0x3b8>
					grle[ch][gr].table_select[i] = getbit(5);
30037ce8:	e59d4008 	ldr	r4, [sp, #8]
30037cec:	e59d500c 	ldr	r5, [sp, #12]
30037cf0:	e59d6010 	ldr	r6, [sp, #16]
30037cf4:	e3a00005 	mov	r0, #5
30037cf8:	ebfff88f 	bl	30035f3c <getbit>
30037cfc:	e1a02000 	mov	r2, r0
30037d00:	e59f1534 	ldr	r1, [pc, #1332]	; 3003823c <III_get_side_info+0x8a4>
30037d04:	e1a03005 	mov	r3, r5
30037d08:	e1a03183 	lsl	r3, r3, #3
30037d0c:	e0833005 	add	r3, r3, r5
30037d10:	e1a00083 	lsl	r0, r3, #1
30037d14:	e1a03004 	mov	r3, r4
30037d18:	e1a03183 	lsl	r3, r3, #3
30037d1c:	e0833004 	add	r3, r3, r4
30037d20:	e1a03103 	lsl	r3, r3, #2
30037d24:	e0803003 	add	r3, r0, r3
30037d28:	e0833006 	add	r3, r3, r6
30037d2c:	e2830006 	add	r0, r3, #6
30037d30:	e3a03004 	mov	r3, #4
30037d34:	e1a00100 	lsl	r0, r0, #2
30037d38:	e0801001 	add	r1, r0, r1
30037d3c:	e0813003 	add	r3, r1, r3
30037d40:	e5832000 	str	r2, [r3]
			grle[ch][gr].scalefac_compress = getbit(4);
			grle[ch][gr].window_switching_flag = getbit(1);
			if (grle[ch][gr].window_switching_flag) {            //������Ϊ1
				grle[ch][gr].block_type = getbit(2);
				grle[ch][gr].mixed_block_flag = getbit(1);
				for (i=0; i<2; i++)
30037d44:	e59d3010 	ldr	r3, [sp, #16]
30037d48:	e2833001 	add	r3, r3, #1
30037d4c:	e58d3010 	str	r3, [sp, #16]
30037d50:	e59d3010 	ldr	r3, [sp, #16]
30037d54:	e3530001 	cmp	r3, #1
30037d58:	daffffe2 	ble	30037ce8 <III_get_side_info+0x350>
					grle[ch][gr].table_select[i] = getbit(5);
				for (i=0; i<3; i++)
30037d5c:	e3a03000 	mov	r3, #0
30037d60:	e58d3010 	str	r3, [sp, #16]
30037d64:	ea000015 	b	30037dc0 <III_get_side_info+0x428>
					grle[ch][gr].subblock_gain[i] = getbit(3);
30037d68:	e59d4008 	ldr	r4, [sp, #8]
30037d6c:	e59d500c 	ldr	r5, [sp, #12]
30037d70:	e59d6010 	ldr	r6, [sp, #16]
30037d74:	e3a00003 	mov	r0, #3
30037d78:	ebfff86f 	bl	30035f3c <getbit>
30037d7c:	e1a01000 	mov	r1, r0
30037d80:	e59f24b4 	ldr	r2, [pc, #1204]	; 3003823c <III_get_side_info+0x8a4>
30037d84:	e1a03005 	mov	r3, r5
30037d88:	e1a03183 	lsl	r3, r3, #3
30037d8c:	e0833005 	add	r3, r3, r5
30037d90:	e1a00083 	lsl	r0, r3, #1
30037d94:	e1a03004 	mov	r3, r4
30037d98:	e1a03183 	lsl	r3, r3, #3
30037d9c:	e0833004 	add	r3, r3, r4
30037da0:	e1a03103 	lsl	r3, r3, #2
30037da4:	e0803003 	add	r3, r0, r3
30037da8:	e0833006 	add	r3, r3, r6
30037dac:	e283300a 	add	r3, r3, #10
30037db0:	e7821103 	str	r1, [r2, r3, lsl #2]
			if (grle[ch][gr].window_switching_flag) {            //������Ϊ1
				grle[ch][gr].block_type = getbit(2);
				grle[ch][gr].mixed_block_flag = getbit(1);
				for (i=0; i<2; i++)
					grle[ch][gr].table_select[i] = getbit(5);
				for (i=0; i<3; i++)
30037db4:	e59d3010 	ldr	r3, [sp, #16]
30037db8:	e2833001 	add	r3, r3, #1
30037dbc:	e58d3010 	str	r3, [sp, #16]
30037dc0:	e59d3010 	ldr	r3, [sp, #16]
30037dc4:	e3530002 	cmp	r3, #2
30037dc8:	daffffe6 	ble	30037d68 <III_get_side_info+0x3d0>
					grle[ch][gr].subblock_gain[i] = getbit(3);

				/* Set region_count parameters since they are implicit in this case. */

				if (grle[ch][gr].block_type == 0) {
30037dcc:	e59d2008 	ldr	r2, [sp, #8]
30037dd0:	e59d100c 	ldr	r1, [sp, #12]
30037dd4:	e59fc460 	ldr	ip, [pc, #1120]	; 3003823c <III_get_side_info+0x8a4>
30037dd8:	e3a00014 	mov	r0, #20
30037ddc:	e1a03001 	mov	r3, r1
30037de0:	e1a03183 	lsl	r3, r3, #3
30037de4:	e0833001 	add	r3, r3, r1
30037de8:	e1a01183 	lsl	r1, r3, #3
30037dec:	e1a03002 	mov	r3, r2
30037df0:	e1a03183 	lsl	r3, r3, #3
30037df4:	e0833002 	add	r3, r3, r2
30037df8:	e1a03203 	lsl	r3, r3, #4
30037dfc:	e0813003 	add	r3, r1, r3
30037e00:	e083300c 	add	r3, r3, ip
30037e04:	e0833000 	add	r3, r3, r0
30037e08:	e5933000 	ldr	r3, [r3]
30037e0c:	e3530000 	cmp	r3, #0
30037e10:	0a000046 	beq	30037f30 <III_get_side_info+0x598>
//					printf("Side info bad: block_type == 0 in split block.\n");
//					exit(0);
				}
				else if (grle[ch][gr].block_type == 2
						&& grle[ch][gr].mixed_block_flag == 0)
30037e14:	e59d2008 	ldr	r2, [sp, #8]
30037e18:	e59d100c 	ldr	r1, [sp, #12]
30037e1c:	e59fc418 	ldr	ip, [pc, #1048]	; 3003823c <III_get_side_info+0x8a4>
30037e20:	e3a00014 	mov	r0, #20
30037e24:	e1a03001 	mov	r3, r1
30037e28:	e1a03183 	lsl	r3, r3, #3
30037e2c:	e0833001 	add	r3, r3, r1
30037e30:	e1a01183 	lsl	r1, r3, #3
30037e34:	e1a03002 	mov	r3, r2
30037e38:	e1a03183 	lsl	r3, r3, #3
30037e3c:	e0833002 	add	r3, r3, r2
30037e40:	e1a03203 	lsl	r3, r3, #4
30037e44:	e0813003 	add	r3, r1, r3
30037e48:	e083300c 	add	r3, r3, ip
30037e4c:	e0833000 	add	r3, r3, r0
30037e50:	e5933000 	ldr	r3, [r3]

				if (grle[ch][gr].block_type == 0) {
//					printf("Side info bad: block_type == 0 in split block.\n");
//					exit(0);
				}
				else if (grle[ch][gr].block_type == 2
30037e54:	e3530002 	cmp	r3, #2
30037e58:	1a000023 	bne	30037eec <III_get_side_info+0x554>
						&& grle[ch][gr].mixed_block_flag == 0)
30037e5c:	e59d2008 	ldr	r2, [sp, #8]
30037e60:	e59d100c 	ldr	r1, [sp, #12]
30037e64:	e59fc3d0 	ldr	ip, [pc, #976]	; 3003823c <III_get_side_info+0x8a4>
30037e68:	e3a00018 	mov	r0, #24
30037e6c:	e1a03001 	mov	r3, r1
30037e70:	e1a03183 	lsl	r3, r3, #3
30037e74:	e0833001 	add	r3, r3, r1
30037e78:	e1a01183 	lsl	r1, r3, #3
30037e7c:	e1a03002 	mov	r3, r2
30037e80:	e1a03183 	lsl	r3, r3, #3
30037e84:	e0833002 	add	r3, r3, r2
30037e88:	e1a03203 	lsl	r3, r3, #4
30037e8c:	e0813003 	add	r3, r1, r3
30037e90:	e083300c 	add	r3, r3, ip
30037e94:	e0833000 	add	r3, r3, r0
30037e98:	e5933000 	ldr	r3, [r3]

				if (grle[ch][gr].block_type == 0) {
//					printf("Side info bad: block_type == 0 in split block.\n");
//					exit(0);
				}
				else if (grle[ch][gr].block_type == 2
30037e9c:	e3530000 	cmp	r3, #0
30037ea0:	1a000011 	bne	30037eec <III_get_side_info+0x554>
						&& grle[ch][gr].mixed_block_flag == 0)
					grle[ch][gr].region0_count = 8; /* MI 9; */     //region0��1��ȱʡ����
30037ea4:	e59d2008 	ldr	r2, [sp, #8]
30037ea8:	e59d100c 	ldr	r1, [sp, #12]
30037eac:	e59fc388 	ldr	ip, [pc, #904]	; 3003823c <III_get_side_info+0x8a4>
30037eb0:	e3a00034 	mov	r0, #52	; 0x34
30037eb4:	e1a03001 	mov	r3, r1
30037eb8:	e1a03183 	lsl	r3, r3, #3
30037ebc:	e0833001 	add	r3, r3, r1
30037ec0:	e1a01183 	lsl	r1, r3, #3
30037ec4:	e1a03002 	mov	r3, r2
30037ec8:	e1a03183 	lsl	r3, r3, #3
30037ecc:	e0833002 	add	r3, r3, r2
30037ed0:	e1a03203 	lsl	r3, r3, #4
30037ed4:	e0813003 	add	r3, r1, r3
30037ed8:	e083300c 	add	r3, r3, ip
30037edc:	e0833000 	add	r3, r3, r0
30037ee0:	e3a02008 	mov	r2, #8
30037ee4:	e5832000 	str	r2, [r3]

				if (grle[ch][gr].block_type == 0) {
//					printf("Side info bad: block_type == 0 in split block.\n");
//					exit(0);
				}
				else if (grle[ch][gr].block_type == 2
30037ee8:	ea000010 	b	30037f30 <III_get_side_info+0x598>
						&& grle[ch][gr].mixed_block_flag == 0)
					grle[ch][gr].region0_count = 8; /* MI 9; */     //region0��1��ȱʡ����
				else grle[ch][gr].region0_count = 7; /* MI 8; */
30037eec:	e59d2008 	ldr	r2, [sp, #8]
30037ef0:	e59d100c 	ldr	r1, [sp, #12]
30037ef4:	e59fc340 	ldr	ip, [pc, #832]	; 3003823c <III_get_side_info+0x8a4>
30037ef8:	e3a00034 	mov	r0, #52	; 0x34
30037efc:	e1a03001 	mov	r3, r1
30037f00:	e1a03183 	lsl	r3, r3, #3
30037f04:	e0833001 	add	r3, r3, r1
30037f08:	e1a01183 	lsl	r1, r3, #3
30037f0c:	e1a03002 	mov	r3, r2
30037f10:	e1a03183 	lsl	r3, r3, #3
30037f14:	e0833002 	add	r3, r3, r2
30037f18:	e1a03203 	lsl	r3, r3, #4
30037f1c:	e0813003 	add	r3, r1, r3
30037f20:	e083300c 	add	r3, r3, ip
30037f24:	e0833000 	add	r3, r3, r0
30037f28:	e3a02007 	mov	r2, #7
30037f2c:	e5832000 	str	r2, [r3]
					grle[ch][gr].region1_count = 20 - grle[ch][gr].region0_count;
30037f30:	e59d2008 	ldr	r2, [sp, #8]
30037f34:	e59d100c 	ldr	r1, [sp, #12]
30037f38:	e59d0008 	ldr	r0, [sp, #8]
30037f3c:	e59dc00c 	ldr	ip, [sp, #12]
30037f40:	e59f42f4 	ldr	r4, [pc, #756]	; 3003823c <III_get_side_info+0x8a4>
30037f44:	e3a0e034 	mov	lr, #52	; 0x34
30037f48:	e1a0300c 	mov	r3, ip
30037f4c:	e1a03183 	lsl	r3, r3, #3
30037f50:	e083300c 	add	r3, r3, ip
30037f54:	e1a0c183 	lsl	ip, r3, #3
30037f58:	e1a03000 	mov	r3, r0
30037f5c:	e1a03183 	lsl	r3, r3, #3
30037f60:	e0833000 	add	r3, r3, r0
30037f64:	e1a03203 	lsl	r3, r3, #4
30037f68:	e08c3003 	add	r3, ip, r3
30037f6c:	e0833004 	add	r3, r3, r4
30037f70:	e083300e 	add	r3, r3, lr
30037f74:	e5933000 	ldr	r3, [r3]
30037f78:	e2630014 	rsb	r0, r3, #20
30037f7c:	e59fe2b8 	ldr	lr, [pc, #696]	; 3003823c <III_get_side_info+0x8a4>
30037f80:	e3a0c038 	mov	ip, #56	; 0x38
30037f84:	e1a03001 	mov	r3, r1
30037f88:	e1a03183 	lsl	r3, r3, #3
30037f8c:	e0833001 	add	r3, r3, r1
30037f90:	e1a01183 	lsl	r1, r3, #3
30037f94:	e1a03002 	mov	r3, r2
30037f98:	e1a03183 	lsl	r3, r3, #3
30037f9c:	e0833002 	add	r3, r3, r2
30037fa0:	e1a03203 	lsl	r3, r3, #4
30037fa4:	e0813003 	add	r3, r1, r3
30037fa8:	e083300e 	add	r3, r3, lr
30037fac:	e083300c 	add	r3, r3, ip
30037fb0:	e5830000 	str	r0, [r3]
30037fb4:	ea000056 	b	30038114 <III_get_side_info+0x77c>
			}
			else {                                                       //������Ϊ0
				for (i=0; i<3; i++)
30037fb8:	e3a03000 	mov	r3, #0
30037fbc:	e58d3010 	str	r3, [sp, #16]
30037fc0:	ea000019 	b	3003802c <III_get_side_info+0x694>
					grle[ch][gr].table_select[i] = getbit(5);
30037fc4:	e59d4008 	ldr	r4, [sp, #8]
30037fc8:	e59d500c 	ldr	r5, [sp, #12]
30037fcc:	e59d6010 	ldr	r6, [sp, #16]
30037fd0:	e3a00005 	mov	r0, #5
30037fd4:	ebfff7d8 	bl	30035f3c <getbit>
30037fd8:	e1a02000 	mov	r2, r0
30037fdc:	e59f1258 	ldr	r1, [pc, #600]	; 3003823c <III_get_side_info+0x8a4>
30037fe0:	e1a03005 	mov	r3, r5
30037fe4:	e1a03183 	lsl	r3, r3, #3
30037fe8:	e0833005 	add	r3, r3, r5
30037fec:	e1a00083 	lsl	r0, r3, #1
30037ff0:	e1a03004 	mov	r3, r4
30037ff4:	e1a03183 	lsl	r3, r3, #3
30037ff8:	e0833004 	add	r3, r3, r4
30037ffc:	e1a03103 	lsl	r3, r3, #2
30038000:	e0803003 	add	r3, r0, r3
30038004:	e0833006 	add	r3, r3, r6
30038008:	e2830006 	add	r0, r3, #6
3003800c:	e3a03004 	mov	r3, #4
30038010:	e1a00100 	lsl	r0, r0, #2
30038014:	e0801001 	add	r1, r0, r1
30038018:	e0813003 	add	r3, r1, r3
3003801c:	e5832000 	str	r2, [r3]
					grle[ch][gr].region0_count = 8; /* MI 9; */     //region0��1��ȱʡ����
				else grle[ch][gr].region0_count = 7; /* MI 8; */
					grle[ch][gr].region1_count = 20 - grle[ch][gr].region0_count;
			}
			else {                                                       //������Ϊ0
				for (i=0; i<3; i++)
30038020:	e59d3010 	ldr	r3, [sp, #16]
30038024:	e2833001 	add	r3, r3, #1
30038028:	e58d3010 	str	r3, [sp, #16]
3003802c:	e59d3010 	ldr	r3, [sp, #16]
30038030:	e3530002 	cmp	r3, #2
30038034:	daffffe2 	ble	30037fc4 <III_get_side_info+0x62c>
					grle[ch][gr].table_select[i] = getbit(5);
				grle[ch][gr].region0_count = getbit(4);
30038038:	e59d4008 	ldr	r4, [sp, #8]
3003803c:	e59d500c 	ldr	r5, [sp, #12]
30038040:	e3a00004 	mov	r0, #4
30038044:	ebfff7bc 	bl	30035f3c <getbit>
30038048:	e1a02000 	mov	r2, r0
3003804c:	e59f01e8 	ldr	r0, [pc, #488]	; 3003823c <III_get_side_info+0x8a4>
30038050:	e3a01034 	mov	r1, #52	; 0x34
30038054:	e1a03005 	mov	r3, r5
30038058:	e1a03183 	lsl	r3, r3, #3
3003805c:	e0833005 	add	r3, r3, r5
30038060:	e1a0c183 	lsl	ip, r3, #3
30038064:	e1a03004 	mov	r3, r4
30038068:	e1a03183 	lsl	r3, r3, #3
3003806c:	e0833004 	add	r3, r3, r4
30038070:	e1a03203 	lsl	r3, r3, #4
30038074:	e08c3003 	add	r3, ip, r3
30038078:	e0833000 	add	r3, r3, r0
3003807c:	e0833001 	add	r3, r3, r1
30038080:	e5832000 	str	r2, [r3]
				grle[ch][gr].region1_count = getbit(3);
30038084:	e59d4008 	ldr	r4, [sp, #8]
30038088:	e59d500c 	ldr	r5, [sp, #12]
3003808c:	e3a00003 	mov	r0, #3
30038090:	ebfff7a9 	bl	30035f3c <getbit>
30038094:	e1a02000 	mov	r2, r0
30038098:	e59f019c 	ldr	r0, [pc, #412]	; 3003823c <III_get_side_info+0x8a4>
3003809c:	e3a01038 	mov	r1, #56	; 0x38
300380a0:	e1a03005 	mov	r3, r5
300380a4:	e1a03183 	lsl	r3, r3, #3
300380a8:	e0833005 	add	r3, r3, r5
300380ac:	e1a0c183 	lsl	ip, r3, #3
300380b0:	e1a03004 	mov	r3, r4
300380b4:	e1a03183 	lsl	r3, r3, #3
300380b8:	e0833004 	add	r3, r3, r4
300380bc:	e1a03203 	lsl	r3, r3, #4
300380c0:	e08c3003 	add	r3, ip, r3
300380c4:	e0833000 	add	r3, r3, r0
300380c8:	e0833001 	add	r3, r3, r1
300380cc:	e5832000 	str	r2, [r3]
				grle[ch][gr].block_type = 0;
300380d0:	e59d2008 	ldr	r2, [sp, #8]
300380d4:	e59d100c 	ldr	r1, [sp, #12]
300380d8:	e59fc15c 	ldr	ip, [pc, #348]	; 3003823c <III_get_side_info+0x8a4>
300380dc:	e3a00014 	mov	r0, #20
300380e0:	e1a03001 	mov	r3, r1
300380e4:	e1a03183 	lsl	r3, r3, #3
300380e8:	e0833001 	add	r3, r3, r1
300380ec:	e1a01183 	lsl	r1, r3, #3
300380f0:	e1a03002 	mov	r3, r2
300380f4:	e1a03183 	lsl	r3, r3, #3
300380f8:	e0833002 	add	r3, r3, r2
300380fc:	e1a03203 	lsl	r3, r3, #4
30038100:	e0813003 	add	r3, r1, r3
30038104:	e083300c 	add	r3, r3, ip
30038108:	e0833000 	add	r3, r3, r0
3003810c:	e3a02000 	mov	r2, #0
30038110:	e5832000 	str	r2, [r3]
			}
			grle[ch][gr].preflag = getbit(1);
30038114:	e59d4008 	ldr	r4, [sp, #8]
30038118:	e59d500c 	ldr	r5, [sp, #12]
3003811c:	e3a00001 	mov	r0, #1
30038120:	ebfff785 	bl	30035f3c <getbit>
30038124:	e1a02000 	mov	r2, r0
30038128:	e59f010c 	ldr	r0, [pc, #268]	; 3003823c <III_get_side_info+0x8a4>
3003812c:	e3a0103c 	mov	r1, #60	; 0x3c
30038130:	e1a03005 	mov	r3, r5
30038134:	e1a03183 	lsl	r3, r3, #3
30038138:	e0833005 	add	r3, r3, r5
3003813c:	e1a0c183 	lsl	ip, r3, #3
30038140:	e1a03004 	mov	r3, r4
30038144:	e1a03183 	lsl	r3, r3, #3
30038148:	e0833004 	add	r3, r3, r4
3003814c:	e1a03203 	lsl	r3, r3, #4
30038150:	e08c3003 	add	r3, ip, r3
30038154:	e0833000 	add	r3, r3, r0
30038158:	e0833001 	add	r3, r3, r1
3003815c:	e5832000 	str	r2, [r3]
			grle[ch][gr].scalefac_scale = getbit(1);
30038160:	e59d4008 	ldr	r4, [sp, #8]
30038164:	e59d500c 	ldr	r5, [sp, #12]
30038168:	e3a00001 	mov	r0, #1
3003816c:	ebfff772 	bl	30035f3c <getbit>
30038170:	e1a02000 	mov	r2, r0
30038174:	e59f00c0 	ldr	r0, [pc, #192]	; 3003823c <III_get_side_info+0x8a4>
30038178:	e3a01040 	mov	r1, #64	; 0x40
3003817c:	e1a03005 	mov	r3, r5
30038180:	e1a03183 	lsl	r3, r3, #3
30038184:	e0833005 	add	r3, r3, r5
30038188:	e1a0c183 	lsl	ip, r3, #3
3003818c:	e1a03004 	mov	r3, r4
30038190:	e1a03183 	lsl	r3, r3, #3
30038194:	e0833004 	add	r3, r3, r4
30038198:	e1a03203 	lsl	r3, r3, #4
3003819c:	e08c3003 	add	r3, ip, r3
300381a0:	e0833000 	add	r3, r3, r0
300381a4:	e0833001 	add	r3, r3, r1
300381a8:	e5832000 	str	r2, [r3]
			grle[ch][gr].count1table_select = getbit(1);
300381ac:	e59d4008 	ldr	r4, [sp, #8]
300381b0:	e59d500c 	ldr	r5, [sp, #12]
300381b4:	e3a00001 	mov	r0, #1
300381b8:	ebfff75f 	bl	30035f3c <getbit>
300381bc:	e1a02000 	mov	r2, r0
300381c0:	e59f0074 	ldr	r0, [pc, #116]	; 3003823c <III_get_side_info+0x8a4>
300381c4:	e3a01044 	mov	r1, #68	; 0x44
300381c8:	e1a03005 	mov	r3, r5
300381cc:	e1a03183 	lsl	r3, r3, #3
300381d0:	e0833005 	add	r3, r3, r5
300381d4:	e1a0c183 	lsl	ip, r3, #3
300381d8:	e1a03004 	mov	r3, r4
300381dc:	e1a03183 	lsl	r3, r3, #3
300381e0:	e0833004 	add	r3, r3, r4
300381e4:	e1a03203 	lsl	r3, r3, #4
300381e8:	e08c3003 	add	r3, ip, r3
300381ec:	e0833000 	add	r3, r3, r0
300381f0:	e0833001 	add	r3, r3, r1
300381f4:	e5832000 	str	r2, [r3]
	for (ch=0; ch<stereo; ch++)         //�ڶ������Ƿ�����Ϣ
		for (i=0; i<4; i++)
			si->scfsi[ch][i] = getbit(1);

	for (gr=0; gr<2; gr++) {
		for (ch=0; ch<stereo; ch++) {
300381f8:	e59d3008 	ldr	r3, [sp, #8]
300381fc:	e2833001 	add	r3, r3, #1
30038200:	e58d3008 	str	r3, [sp, #8]
30038204:	e59d2008 	ldr	r2, [sp, #8]
30038208:	e59d3014 	ldr	r3, [sp, #20]
3003820c:	e1520003 	cmp	r2, r3
30038210:	bafffe1c 	blt	30037a88 <III_get_side_info+0xf0>

	for (ch=0; ch<stereo; ch++)         //�ڶ������Ƿ�����Ϣ
		for (i=0; i<4; i++)
			si->scfsi[ch][i] = getbit(1);

	for (gr=0; gr<2; gr++) {
30038214:	e59d300c 	ldr	r3, [sp, #12]
30038218:	e2833001 	add	r3, r3, #1
3003821c:	e58d300c 	str	r3, [sp, #12]
30038220:	e59d300c 	ldr	r3, [sp, #12]
30038224:	e3530001 	cmp	r3, #1
30038228:	dafffe13 	ble	30037a7c <III_get_side_info+0xe4>
			grle[ch][gr].preflag = getbit(1);
			grle[ch][gr].scalefac_scale = getbit(1);
			grle[ch][gr].count1table_select = getbit(1);
         }
	}
}
3003822c:	e28dd018 	add	sp, sp, #24
30038230:	e8bd4070 	pop	{r4, r5, r6, lr}
30038234:	e12fff1e 	bx	lr
30038238:	302be81c 	.word	0x302be81c
3003823c:	302bd948 	.word	0x302bd948

30038240 <III_get_scale_factors>:
	{0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4},
	{0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3}
};

void III_get_scale_factors(III_scalefac_t *scalefac, III_side_info_t *si, int gr, int ch)
{
30038240:	e92d4070 	push	{r4, r5, r6, lr}
30038244:	e24dd020 	sub	sp, sp, #32
30038248:	e58d000c 	str	r0, [sp, #12]
3003824c:	e58d1008 	str	r1, [sp, #8]
30038250:	e58d2004 	str	r2, [sp, #4]
30038254:	e58d3000 	str	r3, [sp]
	int sfb, i, window;
	struct Granule *gr_info = &(grle[ch][gr]);
30038258:	e59f15a8 	ldr	r1, [pc, #1448]	; 30038808 <III_get_scale_factors+0x5c8>
3003825c:	e59d2000 	ldr	r2, [sp]
30038260:	e1a03002 	mov	r3, r2
30038264:	e1a03183 	lsl	r3, r3, #3
30038268:	e0833002 	add	r3, r3, r2
3003826c:	e1a03203 	lsl	r3, r3, #4
30038270:	e1a00003 	mov	r0, r3
30038274:	e59d2004 	ldr	r2, [sp, #4]
30038278:	e1a03002 	mov	r3, r2
3003827c:	e1a03183 	lsl	r3, r3, #3
30038280:	e0833002 	add	r3, r3, r2
30038284:	e1a03183 	lsl	r3, r3, #3
30038288:	e0803003 	add	r3, r0, r3
3003828c:	e0813003 	add	r3, r1, r3
30038290:	e58d301c 	str	r3, [sp, #28]

	if (gr_info->window_switching_flag && (gr_info->block_type == 2)) {
30038294:	e59d301c 	ldr	r3, [sp, #28]
30038298:	e5933010 	ldr	r3, [r3, #16]
3003829c:	e3530000 	cmp	r3, #0
300382a0:	0a00010f 	beq	300386e4 <III_get_scale_factors+0x4a4>
300382a4:	e59d301c 	ldr	r3, [sp, #28]
300382a8:	e5933014 	ldr	r3, [r3, #20]
300382ac:	e3530002 	cmp	r3, #2
300382b0:	1a00010b 	bne	300386e4 <III_get_scale_factors+0x4a4>
		if (gr_info->mixed_block_flag) { /* MIXED */ /* NEW - ag 11/25 */
300382b4:	e59d301c 	ldr	r3, [sp, #28]
300382b8:	e5933018 	ldr	r3, [r3, #24]
300382bc:	e3530000 	cmp	r3, #0
300382c0:	0a00009a 	beq	30038530 <III_get_scale_factors+0x2f0>
			for (sfb = 0; sfb < 8; sfb++)
300382c4:	e3a03000 	mov	r3, #0
300382c8:	e58d3010 	str	r3, [sp, #16]
300382cc:	ea000013 	b	30038320 <III_get_scale_factors+0xe0>
				(*scalefac)[ch].l[sfb] = hgetbits(
300382d0:	e59d4000 	ldr	r4, [sp]
300382d4:	e59d5010 	ldr	r5, [sp, #16]
					slen[0][gr_info->scalefac_compress]);       //�� slen[0]
300382d8:	e59d301c 	ldr	r3, [sp, #28]
300382dc:	e593200c 	ldr	r2, [r3, #12]
	struct Granule *gr_info = &(grle[ch][gr]);

	if (gr_info->window_switching_flag && (gr_info->block_type == 2)) {
		if (gr_info->mixed_block_flag) { /* MIXED */ /* NEW - ag 11/25 */
			for (sfb = 0; sfb < 8; sfb++)
				(*scalefac)[ch].l[sfb] = hgetbits(
300382e0:	e59f3524 	ldr	r3, [pc, #1316]	; 3003880c <III_get_scale_factors+0x5cc>
300382e4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300382e8:	e1a00003 	mov	r0, r3
300382ec:	ebfffcc6 	bl	3003760c <hgetbits>
300382f0:	e1a03000 	mov	r3, r0
300382f4:	e1a01003 	mov	r1, r3
300382f8:	e59d200c 	ldr	r2, [sp, #12]
300382fc:	e1a03004 	mov	r3, r4
30038300:	e1a03283 	lsl	r3, r3, #5
30038304:	e0643003 	rsb	r3, r4, r3
30038308:	e1a03083 	lsl	r3, r3, #1
3003830c:	e0833005 	add	r3, r3, r5
30038310:	e7821103 	str	r1, [r2, r3, lsl #2]
	int sfb, i, window;
	struct Granule *gr_info = &(grle[ch][gr]);

	if (gr_info->window_switching_flag && (gr_info->block_type == 2)) {
		if (gr_info->mixed_block_flag) { /* MIXED */ /* NEW - ag 11/25 */
			for (sfb = 0; sfb < 8; sfb++)
30038314:	e59d3010 	ldr	r3, [sp, #16]
30038318:	e2833001 	add	r3, r3, #1
3003831c:	e58d3010 	str	r3, [sp, #16]
30038320:	e59d3010 	ldr	r3, [sp, #16]
30038324:	e3530007 	cmp	r3, #7
30038328:	daffffe8 	ble	300382d0 <III_get_scale_factors+0x90>
				(*scalefac)[ch].l[sfb] = hgetbits(
					slen[0][gr_info->scalefac_compress]);       //�� slen[0]
			for (sfb = 3; sfb < 6; sfb++)
3003832c:	e3a03003 	mov	r3, #3
30038330:	e58d3010 	str	r3, [sp, #16]
30038334:	ea000028 	b	300383dc <III_get_scale_factors+0x19c>
				for (window=0; window<3; window++)
30038338:	e3a03000 	mov	r3, #0
3003833c:	e58d3018 	str	r3, [sp, #24]
30038340:	ea00001f 	b	300383c4 <III_get_scale_factors+0x184>
					(*scalefac)[ch].s[window][sfb] = hgetbits(
30038344:	e59d5000 	ldr	r5, [sp]
30038348:	e59d4018 	ldr	r4, [sp, #24]
3003834c:	e59d6010 	ldr	r6, [sp, #16]
						slen[0][gr_info->scalefac_compress]);   //�� slen[0]
30038350:	e59d301c 	ldr	r3, [sp, #28]
30038354:	e593200c 	ldr	r2, [r3, #12]
			for (sfb = 0; sfb < 8; sfb++)
				(*scalefac)[ch].l[sfb] = hgetbits(
					slen[0][gr_info->scalefac_compress]);       //�� slen[0]
			for (sfb = 3; sfb < 6; sfb++)
				for (window=0; window<3; window++)
					(*scalefac)[ch].s[window][sfb] = hgetbits(
30038358:	e59f34ac 	ldr	r3, [pc, #1196]	; 3003880c <III_get_scale_factors+0x5cc>
3003835c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30038360:	e1a00003 	mov	r0, r3
30038364:	ebfffca8 	bl	3003760c <hgetbits>
30038368:	e1a03000 	mov	r3, r0
3003836c:	e1a01003 	mov	r1, r3
30038370:	e59d000c 	ldr	r0, [sp, #12]
30038374:	e1a03004 	mov	r3, r4
30038378:	e1a03083 	lsl	r3, r3, #1
3003837c:	e0833004 	add	r3, r3, r4
30038380:	e1a03103 	lsl	r3, r3, #2
30038384:	e0833004 	add	r3, r3, r4
30038388:	e1a02005 	mov	r2, r5
3003838c:	e1a02282 	lsl	r2, r2, #5
30038390:	e0652002 	rsb	r2, r5, r2
30038394:	e1a02082 	lsl	r2, r2, #1
30038398:	e0833002 	add	r3, r3, r2
3003839c:	e0833006 	add	r3, r3, r6
300383a0:	e2832016 	add	r2, r3, #22
300383a4:	e3a03004 	mov	r3, #4
300383a8:	e1a02102 	lsl	r2, r2, #2
300383ac:	e0822000 	add	r2, r2, r0
300383b0:	e0823003 	add	r3, r2, r3
300383b4:	e5831000 	str	r1, [r3]
		if (gr_info->mixed_block_flag) { /* MIXED */ /* NEW - ag 11/25 */
			for (sfb = 0; sfb < 8; sfb++)
				(*scalefac)[ch].l[sfb] = hgetbits(
					slen[0][gr_info->scalefac_compress]);       //�� slen[0]
			for (sfb = 3; sfb < 6; sfb++)
				for (window=0; window<3; window++)
300383b8:	e59d3018 	ldr	r3, [sp, #24]
300383bc:	e2833001 	add	r3, r3, #1
300383c0:	e58d3018 	str	r3, [sp, #24]
300383c4:	e59d3018 	ldr	r3, [sp, #24]
300383c8:	e3530002 	cmp	r3, #2
300383cc:	daffffdc 	ble	30038344 <III_get_scale_factors+0x104>
	if (gr_info->window_switching_flag && (gr_info->block_type == 2)) {
		if (gr_info->mixed_block_flag) { /* MIXED */ /* NEW - ag 11/25 */
			for (sfb = 0; sfb < 8; sfb++)
				(*scalefac)[ch].l[sfb] = hgetbits(
					slen[0][gr_info->scalefac_compress]);       //�� slen[0]
			for (sfb = 3; sfb < 6; sfb++)
300383d0:	e59d3010 	ldr	r3, [sp, #16]
300383d4:	e2833001 	add	r3, r3, #1
300383d8:	e58d3010 	str	r3, [sp, #16]
300383dc:	e59d3010 	ldr	r3, [sp, #16]
300383e0:	e3530005 	cmp	r3, #5
300383e4:	daffffd3 	ble	30038338 <III_get_scale_factors+0xf8>
				for (window=0; window<3; window++)
					(*scalefac)[ch].s[window][sfb] = hgetbits(
						slen[0][gr_info->scalefac_compress]);   //�� slen[0]
			for (sfb = 6; sfb < 12; sfb++)
300383e8:	e3a03006 	mov	r3, #6
300383ec:	e58d3010 	str	r3, [sp, #16]
300383f0:	ea000029 	b	3003849c <III_get_scale_factors+0x25c>
				for (window=0; window<3; window++)
300383f4:	e3a03000 	mov	r3, #0
300383f8:	e58d3018 	str	r3, [sp, #24]
300383fc:	ea000020 	b	30038484 <III_get_scale_factors+0x244>
					(*scalefac)[ch].s[window][sfb] = hgetbits(
30038400:	e59d5000 	ldr	r5, [sp]
30038404:	e59d4018 	ldr	r4, [sp, #24]
30038408:	e59d6010 	ldr	r6, [sp, #16]
						slen[1][gr_info->scalefac_compress]);   //6-11�� slen[1]
3003840c:	e59d301c 	ldr	r3, [sp, #28]
30038410:	e593200c 	ldr	r2, [r3, #12]
				for (window=0; window<3; window++)
					(*scalefac)[ch].s[window][sfb] = hgetbits(
						slen[0][gr_info->scalefac_compress]);   //�� slen[0]
			for (sfb = 6; sfb < 12; sfb++)
				for (window=0; window<3; window++)
					(*scalefac)[ch].s[window][sfb] = hgetbits(
30038414:	e59f33f0 	ldr	r3, [pc, #1008]	; 3003880c <III_get_scale_factors+0x5cc>
30038418:	e2822010 	add	r2, r2, #16
3003841c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30038420:	e1a00003 	mov	r0, r3
30038424:	ebfffc78 	bl	3003760c <hgetbits>
30038428:	e1a03000 	mov	r3, r0
3003842c:	e1a01003 	mov	r1, r3
30038430:	e59d000c 	ldr	r0, [sp, #12]
30038434:	e1a03004 	mov	r3, r4
30038438:	e1a03083 	lsl	r3, r3, #1
3003843c:	e0833004 	add	r3, r3, r4
30038440:	e1a03103 	lsl	r3, r3, #2
30038444:	e0833004 	add	r3, r3, r4
30038448:	e1a02005 	mov	r2, r5
3003844c:	e1a02282 	lsl	r2, r2, #5
30038450:	e0652002 	rsb	r2, r5, r2
30038454:	e1a02082 	lsl	r2, r2, #1
30038458:	e0833002 	add	r3, r3, r2
3003845c:	e0833006 	add	r3, r3, r6
30038460:	e2832016 	add	r2, r3, #22
30038464:	e3a03004 	mov	r3, #4
30038468:	e1a02102 	lsl	r2, r2, #2
3003846c:	e0822000 	add	r2, r2, r0
30038470:	e0823003 	add	r3, r2, r3
30038474:	e5831000 	str	r1, [r3]
			for (sfb = 3; sfb < 6; sfb++)
				for (window=0; window<3; window++)
					(*scalefac)[ch].s[window][sfb] = hgetbits(
						slen[0][gr_info->scalefac_compress]);   //�� slen[0]
			for (sfb = 6; sfb < 12; sfb++)
				for (window=0; window<3; window++)
30038478:	e59d3018 	ldr	r3, [sp, #24]
3003847c:	e2833001 	add	r3, r3, #1
30038480:	e58d3018 	str	r3, [sp, #24]
30038484:	e59d3018 	ldr	r3, [sp, #24]
30038488:	e3530002 	cmp	r3, #2
3003848c:	daffffdb 	ble	30038400 <III_get_scale_factors+0x1c0>
					slen[0][gr_info->scalefac_compress]);       //�� slen[0]
			for (sfb = 3; sfb < 6; sfb++)
				for (window=0; window<3; window++)
					(*scalefac)[ch].s[window][sfb] = hgetbits(
						slen[0][gr_info->scalefac_compress]);   //�� slen[0]
			for (sfb = 6; sfb < 12; sfb++)
30038490:	e59d3010 	ldr	r3, [sp, #16]
30038494:	e2833001 	add	r3, r3, #1
30038498:	e58d3010 	str	r3, [sp, #16]
3003849c:	e59d3010 	ldr	r3, [sp, #16]
300384a0:	e353000b 	cmp	r3, #11
300384a4:	daffffd2 	ble	300383f4 <III_get_scale_factors+0x1b4>
				for (window=0; window<3; window++)
					(*scalefac)[ch].s[window][sfb] = hgetbits(
						slen[1][gr_info->scalefac_compress]);   //6-11�� slen[1]

			for (sfb=12,window=0; window<3; window++)
300384a8:	e3a0300c 	mov	r3, #12
300384ac:	e58d3010 	str	r3, [sp, #16]
300384b0:	e3a03000 	mov	r3, #0
300384b4:	e58d3018 	str	r3, [sp, #24]
300384b8:	ea000018 	b	30038520 <III_get_scale_factors+0x2e0>
				(*scalefac)[ch].s[window][sfb] = 0;
300384bc:	e59d1000 	ldr	r1, [sp]
300384c0:	e59d2018 	ldr	r2, [sp, #24]
300384c4:	e59dc010 	ldr	ip, [sp, #16]
300384c8:	e59d000c 	ldr	r0, [sp, #12]
300384cc:	e1a03002 	mov	r3, r2
300384d0:	e1a03083 	lsl	r3, r3, #1
300384d4:	e0833002 	add	r3, r3, r2
300384d8:	e1a03103 	lsl	r3, r3, #2
300384dc:	e0833002 	add	r3, r3, r2
300384e0:	e1a02001 	mov	r2, r1
300384e4:	e1a02282 	lsl	r2, r2, #5
300384e8:	e0612002 	rsb	r2, r1, r2
300384ec:	e1a02082 	lsl	r2, r2, #1
300384f0:	e0833002 	add	r3, r3, r2
300384f4:	e083300c 	add	r3, r3, ip
300384f8:	e2832016 	add	r2, r3, #22
300384fc:	e3a03004 	mov	r3, #4
30038500:	e1a02102 	lsl	r2, r2, #2
30038504:	e0822000 	add	r2, r2, r0
30038508:	e0823003 	add	r3, r2, r3
3003850c:	e3a02000 	mov	r2, #0
30038510:	e5832000 	str	r2, [r3]
			for (sfb = 6; sfb < 12; sfb++)
				for (window=0; window<3; window++)
					(*scalefac)[ch].s[window][sfb] = hgetbits(
						slen[1][gr_info->scalefac_compress]);   //6-11�� slen[1]

			for (sfb=12,window=0; window<3; window++)
30038514:	e59d3018 	ldr	r3, [sp, #24]
30038518:	e2833001 	add	r3, r3, #1
3003851c:	e58d3018 	str	r3, [sp, #24]
30038520:	e59d3018 	ldr	r3, [sp, #24]
30038524:	e3530002 	cmp	r3, #2
30038528:	daffffe3 	ble	300384bc <III_get_scale_factors+0x27c>
void III_get_scale_factors(III_scalefac_t *scalefac, III_side_info_t *si, int gr, int ch)
{
	int sfb, i, window;
	struct Granule *gr_info = &(grle[ch][gr]);

	if (gr_info->window_switching_flag && (gr_info->block_type == 2)) {
3003852c:	ea0000b2 	b	300387fc <III_get_scale_factors+0x5bc>

			for (sfb=12,window=0; window<3; window++)
				(*scalefac)[ch].s[window][sfb] = 0;
		}
		else {  /* SHORT*/
			for (i=0; i<2; i++)
30038530:	e3a03000 	mov	r3, #0
30038534:	e58d3014 	str	r3, [sp, #20]
30038538:	ea000044 	b	30038650 <III_get_scale_factors+0x410>
				for (sfb = sfbtable.s[i]; sfb < sfbtable.s[i+1]; sfb++)
3003853c:	e59d3014 	ldr	r3, [sp, #20]
30038540:	e59f22c8 	ldr	r2, [pc, #712]	; 30038810 <III_get_scale_factors+0x5d0>
30038544:	e2831004 	add	r1, r3, #4
30038548:	e3a03004 	mov	r3, #4
3003854c:	e1a01101 	lsl	r1, r1, #2
30038550:	e0812002 	add	r2, r1, r2
30038554:	e0823003 	add	r3, r2, r3
30038558:	e5933000 	ldr	r3, [r3]
3003855c:	e58d3010 	str	r3, [sp, #16]
30038560:	ea00002b 	b	30038614 <III_get_scale_factors+0x3d4>
					for (window=0; window<3; window++)
30038564:	e3a03000 	mov	r3, #0
30038568:	e58d3018 	str	r3, [sp, #24]
3003856c:	ea000022 	b	300385fc <III_get_scale_factors+0x3bc>
						(*scalefac)[ch].s[window][sfb] = hgetbits(
30038570:	e59d5000 	ldr	r5, [sp]
30038574:	e59d4018 	ldr	r4, [sp, #24]
30038578:	e59d6010 	ldr	r6, [sp, #16]
3003857c:	e59d1014 	ldr	r1, [sp, #20]
							slen[i][gr_info->scalefac_compress]);
30038580:	e59d301c 	ldr	r3, [sp, #28]
30038584:	e593200c 	ldr	r2, [r3, #12]
		}
		else {  /* SHORT*/
			for (i=0; i<2; i++)
				for (sfb = sfbtable.s[i]; sfb < sfbtable.s[i+1]; sfb++)
					for (window=0; window<3; window++)
						(*scalefac)[ch].s[window][sfb] = hgetbits(
30038588:	e59f327c 	ldr	r3, [pc, #636]	; 3003880c <III_get_scale_factors+0x5cc>
3003858c:	e1a01201 	lsl	r1, r1, #4
30038590:	e0812002 	add	r2, r1, r2
30038594:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30038598:	e1a00003 	mov	r0, r3
3003859c:	ebfffc1a 	bl	3003760c <hgetbits>
300385a0:	e1a03000 	mov	r3, r0
300385a4:	e1a01003 	mov	r1, r3
300385a8:	e59d000c 	ldr	r0, [sp, #12]
300385ac:	e1a03004 	mov	r3, r4
300385b0:	e1a03083 	lsl	r3, r3, #1
300385b4:	e0833004 	add	r3, r3, r4
300385b8:	e1a03103 	lsl	r3, r3, #2
300385bc:	e0833004 	add	r3, r3, r4
300385c0:	e1a02005 	mov	r2, r5
300385c4:	e1a02282 	lsl	r2, r2, #5
300385c8:	e0652002 	rsb	r2, r5, r2
300385cc:	e1a02082 	lsl	r2, r2, #1
300385d0:	e0833002 	add	r3, r3, r2
300385d4:	e0833006 	add	r3, r3, r6
300385d8:	e2832016 	add	r2, r3, #22
300385dc:	e3a03004 	mov	r3, #4
300385e0:	e1a02102 	lsl	r2, r2, #2
300385e4:	e0822000 	add	r2, r2, r0
300385e8:	e0823003 	add	r3, r2, r3
300385ec:	e5831000 	str	r1, [r3]
				(*scalefac)[ch].s[window][sfb] = 0;
		}
		else {  /* SHORT*/
			for (i=0; i<2; i++)
				for (sfb = sfbtable.s[i]; sfb < sfbtable.s[i+1]; sfb++)
					for (window=0; window<3; window++)
300385f0:	e59d3018 	ldr	r3, [sp, #24]
300385f4:	e2833001 	add	r3, r3, #1
300385f8:	e58d3018 	str	r3, [sp, #24]
300385fc:	e59d3018 	ldr	r3, [sp, #24]
30038600:	e3530002 	cmp	r3, #2
30038604:	daffffd9 	ble	30038570 <III_get_scale_factors+0x330>
			for (sfb=12,window=0; window<3; window++)
				(*scalefac)[ch].s[window][sfb] = 0;
		}
		else {  /* SHORT*/
			for (i=0; i<2; i++)
				for (sfb = sfbtable.s[i]; sfb < sfbtable.s[i+1]; sfb++)
30038608:	e59d3010 	ldr	r3, [sp, #16]
3003860c:	e2833001 	add	r3, r3, #1
30038610:	e58d3010 	str	r3, [sp, #16]
30038614:	e59d3014 	ldr	r3, [sp, #20]
30038618:	e2833001 	add	r3, r3, #1
3003861c:	e59f21ec 	ldr	r2, [pc, #492]	; 30038810 <III_get_scale_factors+0x5d0>
30038620:	e2831004 	add	r1, r3, #4
30038624:	e3a03004 	mov	r3, #4
30038628:	e1a01101 	lsl	r1, r1, #2
3003862c:	e0812002 	add	r2, r1, r2
30038630:	e0823003 	add	r3, r2, r3
30038634:	e5932000 	ldr	r2, [r3]
30038638:	e59d3010 	ldr	r3, [sp, #16]
3003863c:	e1520003 	cmp	r2, r3
30038640:	caffffc7 	bgt	30038564 <III_get_scale_factors+0x324>

			for (sfb=12,window=0; window<3; window++)
				(*scalefac)[ch].s[window][sfb] = 0;
		}
		else {  /* SHORT*/
			for (i=0; i<2; i++)
30038644:	e59d3014 	ldr	r3, [sp, #20]
30038648:	e2833001 	add	r3, r3, #1
3003864c:	e58d3014 	str	r3, [sp, #20]
30038650:	e59d3014 	ldr	r3, [sp, #20]
30038654:	e3530001 	cmp	r3, #1
30038658:	daffffb7 	ble	3003853c <III_get_scale_factors+0x2fc>
				for (sfb = sfbtable.s[i]; sfb < sfbtable.s[i+1]; sfb++)
					for (window=0; window<3; window++)
						(*scalefac)[ch].s[window][sfb] = hgetbits(
							slen[i][gr_info->scalefac_compress]);
				for (sfb=12,window=0; window<3; window++)
3003865c:	e3a0300c 	mov	r3, #12
30038660:	e58d3010 	str	r3, [sp, #16]
30038664:	e3a03000 	mov	r3, #0
30038668:	e58d3018 	str	r3, [sp, #24]
3003866c:	ea000018 	b	300386d4 <III_get_scale_factors+0x494>
					(*scalefac)[ch].s[window][sfb] = 0;
30038670:	e59d1000 	ldr	r1, [sp]
30038674:	e59d2018 	ldr	r2, [sp, #24]
30038678:	e59dc010 	ldr	ip, [sp, #16]
3003867c:	e59d000c 	ldr	r0, [sp, #12]
30038680:	e1a03002 	mov	r3, r2
30038684:	e1a03083 	lsl	r3, r3, #1
30038688:	e0833002 	add	r3, r3, r2
3003868c:	e1a03103 	lsl	r3, r3, #2
30038690:	e0833002 	add	r3, r3, r2
30038694:	e1a02001 	mov	r2, r1
30038698:	e1a02282 	lsl	r2, r2, #5
3003869c:	e0612002 	rsb	r2, r1, r2
300386a0:	e1a02082 	lsl	r2, r2, #1
300386a4:	e0833002 	add	r3, r3, r2
300386a8:	e083300c 	add	r3, r3, ip
300386ac:	e2832016 	add	r2, r3, #22
300386b0:	e3a03004 	mov	r3, #4
300386b4:	e1a02102 	lsl	r2, r2, #2
300386b8:	e0822000 	add	r2, r2, r0
300386bc:	e0823003 	add	r3, r2, r3
300386c0:	e3a02000 	mov	r2, #0
300386c4:	e5832000 	str	r2, [r3]
			for (i=0; i<2; i++)
				for (sfb = sfbtable.s[i]; sfb < sfbtable.s[i+1]; sfb++)
					for (window=0; window<3; window++)
						(*scalefac)[ch].s[window][sfb] = hgetbits(
							slen[i][gr_info->scalefac_compress]);
				for (sfb=12,window=0; window<3; window++)
300386c8:	e59d3018 	ldr	r3, [sp, #24]
300386cc:	e2833001 	add	r3, r3, #1
300386d0:	e58d3018 	str	r3, [sp, #24]
300386d4:	e59d3018 	ldr	r3, [sp, #24]
300386d8:	e3530002 	cmp	r3, #2
300386dc:	daffffe3 	ble	30038670 <III_get_scale_factors+0x430>
void III_get_scale_factors(III_scalefac_t *scalefac, III_side_info_t *si, int gr, int ch)
{
	int sfb, i, window;
	struct Granule *gr_info = &(grle[ch][gr]);

	if (gr_info->window_switching_flag && (gr_info->block_type == 2)) {
300386e0:	ea000045 	b	300387fc <III_get_scale_factors+0x5bc>
				for (sfb=12,window=0; window<3; window++)
					(*scalefac)[ch].s[window][sfb] = 0;
		}
	}
	else {   /* LONG types 0,1,3 */
		for (i=0; i<4; i++) {
300386e4:	e3a03000 	mov	r3, #0
300386e8:	e58d3014 	str	r3, [sp, #20]
300386ec:	ea000034 	b	300387c4 <III_get_scale_factors+0x584>
			if ((si->scfsi[ch][i] == 0) || (gr == 0))
300386f0:	e59d1000 	ldr	r1, [sp]
300386f4:	e59d2014 	ldr	r2, [sp, #20]
300386f8:	e59d3008 	ldr	r3, [sp, #8]
300386fc:	e1a01101 	lsl	r1, r1, #2
30038700:	e0812002 	add	r2, r1, r2
30038704:	e2822002 	add	r2, r2, #2
30038708:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3003870c:	e3530000 	cmp	r3, #0
30038710:	0a000002 	beq	30038720 <III_get_scale_factors+0x4e0>
30038714:	e59d3004 	ldr	r3, [sp, #4]
30038718:	e3530000 	cmp	r3, #0
3003871c:	1a000025 	bne	300387b8 <III_get_scale_factors+0x578>
				for (sfb = sfbtable.l[i]; sfb < sfbtable.l[i+1]; sfb++)
30038720:	e59d2014 	ldr	r2, [sp, #20]
30038724:	e59f30e4 	ldr	r3, [pc, #228]	; 30038810 <III_get_scale_factors+0x5d0>
30038728:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3003872c:	e58d3010 	str	r3, [sp, #16]
30038730:	ea000019 	b	3003879c <III_get_scale_factors+0x55c>
					(*scalefac)[ch].l[sfb] = hgetbits(
30038734:	e59d4000 	ldr	r4, [sp]
30038738:	e59d5010 	ldr	r5, [sp, #16]
3003873c:	e59d3014 	ldr	r3, [sp, #20]
30038740:	e3530001 	cmp	r3, #1
30038744:	d3a01000 	movle	r1, #0
30038748:	c3a01001 	movgt	r1, #1
						slen[(i<2)?0:1][gr_info->scalefac_compress]);
3003874c:	e59d301c 	ldr	r3, [sp, #28]
30038750:	e593200c 	ldr	r2, [r3, #12]
	}
	else {   /* LONG types 0,1,3 */
		for (i=0; i<4; i++) {
			if ((si->scfsi[ch][i] == 0) || (gr == 0))
				for (sfb = sfbtable.l[i]; sfb < sfbtable.l[i+1]; sfb++)
					(*scalefac)[ch].l[sfb] = hgetbits(
30038754:	e59f30b0 	ldr	r3, [pc, #176]	; 3003880c <III_get_scale_factors+0x5cc>
30038758:	e1a01201 	lsl	r1, r1, #4
3003875c:	e0812002 	add	r2, r1, r2
30038760:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30038764:	e1a00003 	mov	r0, r3
30038768:	ebfffba7 	bl	3003760c <hgetbits>
3003876c:	e1a03000 	mov	r3, r0
30038770:	e1a01003 	mov	r1, r3
30038774:	e59d200c 	ldr	r2, [sp, #12]
30038778:	e1a03004 	mov	r3, r4
3003877c:	e1a03283 	lsl	r3, r3, #5
30038780:	e0643003 	rsb	r3, r4, r3
30038784:	e1a03083 	lsl	r3, r3, #1
30038788:	e0833005 	add	r3, r3, r5
3003878c:	e7821103 	str	r1, [r2, r3, lsl #2]
		}
	}
	else {   /* LONG types 0,1,3 */
		for (i=0; i<4; i++) {
			if ((si->scfsi[ch][i] == 0) || (gr == 0))
				for (sfb = sfbtable.l[i]; sfb < sfbtable.l[i+1]; sfb++)
30038790:	e59d3010 	ldr	r3, [sp, #16]
30038794:	e2833001 	add	r3, r3, #1
30038798:	e58d3010 	str	r3, [sp, #16]
3003879c:	e59d3014 	ldr	r3, [sp, #20]
300387a0:	e2832001 	add	r2, r3, #1
300387a4:	e59f3064 	ldr	r3, [pc, #100]	; 30038810 <III_get_scale_factors+0x5d0>
300387a8:	e7932102 	ldr	r2, [r3, r2, lsl #2]
300387ac:	e59d3010 	ldr	r3, [sp, #16]
300387b0:	e1520003 	cmp	r2, r3
300387b4:	caffffde 	bgt	30038734 <III_get_scale_factors+0x4f4>
				for (sfb=12,window=0; window<3; window++)
					(*scalefac)[ch].s[window][sfb] = 0;
		}
	}
	else {   /* LONG types 0,1,3 */
		for (i=0; i<4; i++) {
300387b8:	e59d3014 	ldr	r3, [sp, #20]
300387bc:	e2833001 	add	r3, r3, #1
300387c0:	e58d3014 	str	r3, [sp, #20]
300387c4:	e59d3014 	ldr	r3, [sp, #20]
300387c8:	e3530003 	cmp	r3, #3
300387cc:	daffffc7 	ble	300386f0 <III_get_scale_factors+0x4b0>
			if ((si->scfsi[ch][i] == 0) || (gr == 0))
				for (sfb = sfbtable.l[i]; sfb < sfbtable.l[i+1]; sfb++)
					(*scalefac)[ch].l[sfb] = hgetbits(
						slen[(i<2)?0:1][gr_info->scalefac_compress]);
		}
		(*scalefac)[ch].l[22] = 0;
300387d0:	e59d2000 	ldr	r2, [sp]
300387d4:	e59d000c 	ldr	r0, [sp, #12]
300387d8:	e3a01058 	mov	r1, #88	; 0x58
300387dc:	e1a03002 	mov	r3, r2
300387e0:	e1a03283 	lsl	r3, r3, #5
300387e4:	e0623003 	rsb	r3, r2, r3
300387e8:	e1a03183 	lsl	r3, r3, #3
300387ec:	e0833000 	add	r3, r3, r0
300387f0:	e0833001 	add	r3, r3, r1
300387f4:	e3a02000 	mov	r2, #0
300387f8:	e5832000 	str	r2, [r3]
	}
}
300387fc:	e28dd020 	add	sp, sp, #32
30038800:	e8bd4070 	pop	{r4, r5, r6, lr}
30038804:	e12fff1e 	bx	lr
30038808:	302bd948 	.word	0x302bd948
3003880c:	300c8090 	.word	0x300c8090
30038810:	300c8070 	.word	0x300c8070

30038814 <III_dequantize_sample>:

}; //mul 1024

//double is43_table[1024];
void III_dequantize_sample(int is[SBLIMIT][SSLIMIT], int xr[SBLIMIT][SSLIMIT], III_scalefac_t *scalefac, struct Granule *gr_info, int ch)
{
30038814:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
30038818:	e24dd038 	sub	sp, sp, #56	; 0x38
3003881c:	e58d000c 	str	r0, [sp, #12]
30038820:	e58d1008 	str	r1, [sp, #8]
30038824:	e58d2004 	str	r2, [sp, #4]
30038828:	e58d3000 	str	r3, [sp]
	int ss,sb,cb=0,sfreq=fr_ps.header->sampling_frequency;
3003882c:	e3a03000 	mov	r3, #0
30038830:	e58d3018 	str	r3, [sp, #24]
30038834:	e59f3e04 	ldr	r3, [pc, #3588]	; 30039640 <III_dequantize_sample+0xe2c>
30038838:	e5933000 	ldr	r3, [r3]
3003883c:	e5933010 	ldr	r3, [r3, #16]
30038840:	e58d301c 	str	r3, [sp, #28]
	int next_cb_boundary, cb_begin, cb_width, sign;
	int temp;
	static int init=1;
	int tmp;

	if(init)
30038844:	e59f3df8 	ldr	r3, [pc, #3576]	; 30039644 <III_dequantize_sample+0xe30>
30038848:	e5933000 	ldr	r3, [r3]
3003884c:	e3530000 	cmp	r3, #0
30038850:	0a000002 	beq	30038860 <III_dequantize_sample+0x4c>
	{
		//for(init=0;init<1024;init++)
		  //is43_table[init]=1333*(int)log(init);
		init=0;
30038854:	e59f3de8 	ldr	r3, [pc, #3560]	; 30039644 <III_dequantize_sample+0xe30>
30038858:	e3a02000 	mov	r2, #0
3003885c:	e5832000 	str	r2, [r3]
	}

	/* choose correct scalefactor band per block type, initalize boundary */

	if (gr_info->window_switching_flag && (gr_info->block_type == 2) )
30038860:	e59d3000 	ldr	r3, [sp]
30038864:	e5933010 	ldr	r3, [r3, #16]
30038868:	e3530000 	cmp	r3, #0
3003886c:	0a000032 	beq	3003893c <III_dequantize_sample+0x128>
30038870:	e59d3000 	ldr	r3, [sp]
30038874:	e5933014 	ldr	r3, [r3, #20]
30038878:	e3530002 	cmp	r3, #2
3003887c:	1a00002e 	bne	3003893c <III_dequantize_sample+0x128>
		if (gr_info->mixed_block_flag)
30038880:	e59d3000 	ldr	r3, [sp]
30038884:	e5933018 	ldr	r3, [r3, #24]
30038888:	e3530000 	cmp	r3, #0
3003888c:	0a00000a 	beq	300388bc <III_dequantize_sample+0xa8>
			next_cb_boundary=sfBandIndex[sfreq].l[1];  /* LONG blocks: 0,1,3 */
30038890:	e59d201c 	ldr	r2, [sp, #28]
30038894:	e59f1dac 	ldr	r1, [pc, #3500]	; 30039648 <III_dequantize_sample+0xe34>
30038898:	e1a03002 	mov	r3, r2
3003889c:	e1a03183 	lsl	r3, r3, #3
300388a0:	e0833002 	add	r3, r3, r2
300388a4:	e1a03103 	lsl	r3, r3, #2
300388a8:	e0833002 	add	r3, r3, r2
300388ac:	e2833001 	add	r3, r3, #1
300388b0:	e7913103 	ldr	r3, [r1, r3, lsl #2]
300388b4:	e58d3020 	str	r3, [sp, #32]
		init=0;
	}

	/* choose correct scalefactor band per block type, initalize boundary */

	if (gr_info->window_switching_flag && (gr_info->block_type == 2) )
300388b8:	ea000029 	b	30038964 <III_dequantize_sample+0x150>
		if (gr_info->mixed_block_flag)
			next_cb_boundary=sfBandIndex[sfreq].l[1];  /* LONG blocks: 0,1,3 */
		else
		{
			next_cb_boundary=sfBandIndex[sfreq].s[1]*3; /* pure SHORT block */
300388bc:	e59d201c 	ldr	r2, [sp, #28]
300388c0:	e59f0d80 	ldr	r0, [pc, #3456]	; 30039648 <III_dequantize_sample+0xe34>
300388c4:	e3a01060 	mov	r1, #96	; 0x60
300388c8:	e1a03002 	mov	r3, r2
300388cc:	e1a03183 	lsl	r3, r3, #3
300388d0:	e0833002 	add	r3, r3, r2
300388d4:	e1a03103 	lsl	r3, r3, #2
300388d8:	e0833002 	add	r3, r3, r2
300388dc:	e1a03103 	lsl	r3, r3, #2
300388e0:	e0833000 	add	r3, r3, r0
300388e4:	e0833001 	add	r3, r3, r1
300388e8:	e5932000 	ldr	r2, [r3]
300388ec:	e1a03002 	mov	r3, r2
300388f0:	e1a03083 	lsl	r3, r3, #1
300388f4:	e0833002 	add	r3, r3, r2
300388f8:	e58d3020 	str	r3, [sp, #32]
			cb_width = sfBandIndex[sfreq].s[1];
300388fc:	e59d201c 	ldr	r2, [sp, #28]
30038900:	e59f0d40 	ldr	r0, [pc, #3392]	; 30039648 <III_dequantize_sample+0xe34>
30038904:	e3a01060 	mov	r1, #96	; 0x60
30038908:	e1a03002 	mov	r3, r2
3003890c:	e1a03183 	lsl	r3, r3, #3
30038910:	e0833002 	add	r3, r3, r2
30038914:	e1a03103 	lsl	r3, r3, #2
30038918:	e0833002 	add	r3, r3, r2
3003891c:	e1a03103 	lsl	r3, r3, #2
30038920:	e0833000 	add	r3, r3, r0
30038924:	e0833001 	add	r3, r3, r1
30038928:	e5933000 	ldr	r3, [r3]
3003892c:	e58d3028 	str	r3, [sp, #40]	; 0x28
			cb_begin = 0;
30038930:	e3a03000 	mov	r3, #0
30038934:	e58d3024 	str	r3, [sp, #36]	; 0x24
		init=0;
	}

	/* choose correct scalefactor band per block type, initalize boundary */

	if (gr_info->window_switching_flag && (gr_info->block_type == 2) )
30038938:	ea000009 	b	30038964 <III_dequantize_sample+0x150>
			next_cb_boundary=sfBandIndex[sfreq].s[1]*3; /* pure SHORT block */
			cb_width = sfBandIndex[sfreq].s[1];
			cb_begin = 0;
		}
	else
		next_cb_boundary=sfBandIndex[sfreq].l[1];  /* LONG blocks: 0,1,3 */
3003893c:	e59d201c 	ldr	r2, [sp, #28]
30038940:	e59f1d00 	ldr	r1, [pc, #3328]	; 30039648 <III_dequantize_sample+0xe34>
30038944:	e1a03002 	mov	r3, r2
30038948:	e1a03183 	lsl	r3, r3, #3
3003894c:	e0833002 	add	r3, r3, r2
30038950:	e1a03103 	lsl	r3, r3, #2
30038954:	e0833002 	add	r3, r3, r2
30038958:	e2833001 	add	r3, r3, #1
3003895c:	e7913103 	ldr	r3, [r1, r3, lsl #2]
30038960:	e58d3020 	str	r3, [sp, #32]

	/* apply formula per block type */
	for (sb=0 ; sb < SBLIMIT ; sb++) {        //0-31
30038964:	e3a03000 	mov	r3, #0
30038968:	e58d3014 	str	r3, [sp, #20]
3003896c:	ea00032d 	b	30039628 <III_dequantize_sample+0xe14>
		for (ss=0 ; ss < SSLIMIT ; ss++) {    //0-17
30038970:	e3a03000 	mov	r3, #0
30038974:	e58d3010 	str	r3, [sp, #16]
30038978:	ea000324 	b	30039610 <III_dequantize_sample+0xdfc>

/*********              由sb和ss计算cb(比例因子带)和cb_width(比例因子带宽)   **************/
			if ( (sb*18)+ss == next_cb_boundary)
3003897c:	e59d2014 	ldr	r2, [sp, #20]
30038980:	e1a03002 	mov	r3, r2
30038984:	e1a03183 	lsl	r3, r3, #3
30038988:	e0833002 	add	r3, r3, r2
3003898c:	e1a03083 	lsl	r3, r3, #1
30038990:	e1a02003 	mov	r2, r3
30038994:	e59d3010 	ldr	r3, [sp, #16]
30038998:	e0822003 	add	r2, r2, r3
3003899c:	e59d3020 	ldr	r3, [sp, #32]
300389a0:	e1520003 	cmp	r2, r3
300389a4:	1a000135 	bne	30038e80 <III_dequantize_sample+0x66c>
			{ /* Adjust critical band boundary */
				if (gr_info->window_switching_flag && (gr_info->block_type == 2))
300389a8:	e59d3000 	ldr	r3, [sp]
300389ac:	e5933010 	ldr	r3, [r3, #16]
300389b0:	e3530000 	cmp	r3, #0
300389b4:	0a000122 	beq	30038e44 <III_dequantize_sample+0x630>
300389b8:	e59d3000 	ldr	r3, [sp]
300389bc:	e5933014 	ldr	r3, [r3, #20]
300389c0:	e3530002 	cmp	r3, #2
300389c4:	1a00011e 	bne	30038e44 <III_dequantize_sample+0x630>
				{
					if (gr_info->mixed_block_flag)
300389c8:	e59d3000 	ldr	r3, [sp]
300389cc:	e5933018 	ldr	r3, [r3, #24]
300389d0:	e3530000 	cmp	r3, #0
300389d4:	0a0000ce 	beq	30038d14 <III_dequantize_sample+0x500>
					{
						if (((sb*18)+ss) == sfBandIndex[sfreq].l[8])
300389d8:	e59d2014 	ldr	r2, [sp, #20]
300389dc:	e1a03002 	mov	r3, r2
300389e0:	e1a03183 	lsl	r3, r3, #3
300389e4:	e0833002 	add	r3, r3, r2
300389e8:	e1a03083 	lsl	r3, r3, #1
300389ec:	e1a02003 	mov	r2, r3
300389f0:	e59d3010 	ldr	r3, [sp, #16]
300389f4:	e0821003 	add	r1, r2, r3
300389f8:	e59d201c 	ldr	r2, [sp, #28]
300389fc:	e59fcc44 	ldr	ip, [pc, #3140]	; 30039648 <III_dequantize_sample+0xe34>
30038a00:	e3a00020 	mov	r0, #32
30038a04:	e1a03002 	mov	r3, r2
30038a08:	e1a03183 	lsl	r3, r3, #3
30038a0c:	e0833002 	add	r3, r3, r2
30038a10:	e1a03103 	lsl	r3, r3, #2
30038a14:	e0833002 	add	r3, r3, r2
30038a18:	e1a03103 	lsl	r3, r3, #2
30038a1c:	e083300c 	add	r3, r3, ip
30038a20:	e0833000 	add	r3, r3, r0
30038a24:	e5933000 	ldr	r3, [r3]
30038a28:	e1510003 	cmp	r1, r3
30038a2c:	1a000046 	bne	30038b4c <III_dequantize_sample+0x338>
						{
							next_cb_boundary=sfBandIndex[sfreq].s[4]*3;
30038a30:	e59d201c 	ldr	r2, [sp, #28]
30038a34:	e59f0c0c 	ldr	r0, [pc, #3084]	; 30039648 <III_dequantize_sample+0xe34>
30038a38:	e3a0106c 	mov	r1, #108	; 0x6c
30038a3c:	e1a03002 	mov	r3, r2
30038a40:	e1a03183 	lsl	r3, r3, #3
30038a44:	e0833002 	add	r3, r3, r2
30038a48:	e1a03103 	lsl	r3, r3, #2
30038a4c:	e0833002 	add	r3, r3, r2
30038a50:	e1a03103 	lsl	r3, r3, #2
30038a54:	e0833000 	add	r3, r3, r0
30038a58:	e0833001 	add	r3, r3, r1
30038a5c:	e5932000 	ldr	r2, [r3]
30038a60:	e1a03002 	mov	r3, r2
30038a64:	e1a03083 	lsl	r3, r3, #1
30038a68:	e0833002 	add	r3, r3, r2
30038a6c:	e58d3020 	str	r3, [sp, #32]
							cb = 3;
30038a70:	e3a03003 	mov	r3, #3
30038a74:	e58d3018 	str	r3, [sp, #24]
							cb_width = sfBandIndex[sfreq].s[cb+1] -
30038a78:	e59d201c 	ldr	r2, [sp, #28]
30038a7c:	e59d3018 	ldr	r3, [sp, #24]
30038a80:	e2830001 	add	r0, r3, #1
30038a84:	e59f1bbc 	ldr	r1, [pc, #3004]	; 30039648 <III_dequantize_sample+0xe34>
30038a88:	e1a03002 	mov	r3, r2
30038a8c:	e1a03183 	lsl	r3, r3, #3
30038a90:	e0833002 	add	r3, r3, r2
30038a94:	e1a03103 	lsl	r3, r3, #2
30038a98:	e0833002 	add	r3, r3, r2
30038a9c:	e0833000 	add	r3, r3, r0
30038aa0:	e2832016 	add	r2, r3, #22
30038aa4:	e3a03004 	mov	r3, #4
30038aa8:	e1a02102 	lsl	r2, r2, #2
30038aac:	e0822001 	add	r2, r2, r1
30038ab0:	e0823003 	add	r3, r2, r3
30038ab4:	e5931000 	ldr	r1, [r3]
										sfBandIndex[sfreq].s[cb];
30038ab8:	e59d201c 	ldr	r2, [sp, #28]
30038abc:	e59dc018 	ldr	ip, [sp, #24]
30038ac0:	e59f0b80 	ldr	r0, [pc, #2944]	; 30039648 <III_dequantize_sample+0xe34>
30038ac4:	e1a03002 	mov	r3, r2
30038ac8:	e1a03183 	lsl	r3, r3, #3
30038acc:	e0833002 	add	r3, r3, r2
30038ad0:	e1a03103 	lsl	r3, r3, #2
30038ad4:	e0833002 	add	r3, r3, r2
30038ad8:	e083300c 	add	r3, r3, ip
30038adc:	e2832016 	add	r2, r3, #22
30038ae0:	e3a03004 	mov	r3, #4
30038ae4:	e1a02102 	lsl	r2, r2, #2
30038ae8:	e0822000 	add	r2, r2, r0
30038aec:	e0823003 	add	r3, r2, r3
30038af0:	e5933000 	ldr	r3, [r3]
					{
						if (((sb*18)+ss) == sfBandIndex[sfreq].l[8])
						{
							next_cb_boundary=sfBandIndex[sfreq].s[4]*3;
							cb = 3;
							cb_width = sfBandIndex[sfreq].s[cb+1] -
30038af4:	e0633001 	rsb	r3, r3, r1
30038af8:	e58d3028 	str	r3, [sp, #40]	; 0x28
										sfBandIndex[sfreq].s[cb];
							cb_begin = sfBandIndex[sfreq].s[cb]*3;
30038afc:	e59d201c 	ldr	r2, [sp, #28]
30038b00:	e59d0018 	ldr	r0, [sp, #24]
30038b04:	e59f1b3c 	ldr	r1, [pc, #2876]	; 30039648 <III_dequantize_sample+0xe34>
30038b08:	e1a03002 	mov	r3, r2
30038b0c:	e1a03183 	lsl	r3, r3, #3
30038b10:	e0833002 	add	r3, r3, r2
30038b14:	e1a03103 	lsl	r3, r3, #2
30038b18:	e0833002 	add	r3, r3, r2
30038b1c:	e0833000 	add	r3, r3, r0
30038b20:	e2832016 	add	r2, r3, #22
30038b24:	e3a03004 	mov	r3, #4
30038b28:	e1a02102 	lsl	r2, r2, #2
30038b2c:	e0822001 	add	r2, r2, r1
30038b30:	e0823003 	add	r3, r2, r3
30038b34:	e5932000 	ldr	r2, [r3]
30038b38:	e1a03002 	mov	r3, r2
30038b3c:	e1a03083 	lsl	r3, r3, #1
30038b40:	e0833002 	add	r3, r3, r2
30038b44:	e58d3024 	str	r3, [sp, #36]	; 0x24
		for (ss=0 ; ss < SSLIMIT ; ss++) {    //0-17

/*********              由sb和ss计算cb(比例因子带)和cb_width(比例因子带宽)   **************/
			if ( (sb*18)+ss == next_cb_boundary)
			{ /* Adjust critical band boundary */
				if (gr_info->window_switching_flag && (gr_info->block_type == 2))
30038b48:	ea0000cc 	b	30038e80 <III_dequantize_sample+0x66c>
							cb = 3;
							cb_width = sfBandIndex[sfreq].s[cb+1] -
										sfBandIndex[sfreq].s[cb];
							cb_begin = sfBandIndex[sfreq].s[cb]*3;
						}
						else if (((sb*18)+ss) < sfBandIndex[sfreq].l[8])
30038b4c:	e59d2014 	ldr	r2, [sp, #20]
30038b50:	e1a03002 	mov	r3, r2
30038b54:	e1a03183 	lsl	r3, r3, #3
30038b58:	e0833002 	add	r3, r3, r2
30038b5c:	e1a03083 	lsl	r3, r3, #1
30038b60:	e1a02003 	mov	r2, r3
30038b64:	e59d3010 	ldr	r3, [sp, #16]
30038b68:	e0821003 	add	r1, r2, r3
30038b6c:	e59d201c 	ldr	r2, [sp, #28]
30038b70:	e59fcad0 	ldr	ip, [pc, #2768]	; 30039648 <III_dequantize_sample+0xe34>
30038b74:	e3a00020 	mov	r0, #32
30038b78:	e1a03002 	mov	r3, r2
30038b7c:	e1a03183 	lsl	r3, r3, #3
30038b80:	e0833002 	add	r3, r3, r2
30038b84:	e1a03103 	lsl	r3, r3, #2
30038b88:	e0833002 	add	r3, r3, r2
30038b8c:	e1a03103 	lsl	r3, r3, #2
30038b90:	e083300c 	add	r3, r3, ip
30038b94:	e0833000 	add	r3, r3, r0
30038b98:	e5933000 	ldr	r3, [r3]
30038b9c:	e1510003 	cmp	r1, r3
30038ba0:	aa00000f 	bge	30038be4 <III_dequantize_sample+0x3d0>
							next_cb_boundary = sfBandIndex[sfreq].l[(++cb)+1];
30038ba4:	e59d201c 	ldr	r2, [sp, #28]
30038ba8:	e59d3018 	ldr	r3, [sp, #24]
30038bac:	e2833001 	add	r3, r3, #1
30038bb0:	e58d3018 	str	r3, [sp, #24]
30038bb4:	e59d3018 	ldr	r3, [sp, #24]
30038bb8:	e2830001 	add	r0, r3, #1
30038bbc:	e59f1a84 	ldr	r1, [pc, #2692]	; 30039648 <III_dequantize_sample+0xe34>
30038bc0:	e1a03002 	mov	r3, r2
30038bc4:	e1a03183 	lsl	r3, r3, #3
30038bc8:	e0833002 	add	r3, r3, r2
30038bcc:	e1a03103 	lsl	r3, r3, #2
30038bd0:	e0833002 	add	r3, r3, r2
30038bd4:	e0833000 	add	r3, r3, r0
30038bd8:	e7913103 	ldr	r3, [r1, r3, lsl #2]
30038bdc:	e58d3020 	str	r3, [sp, #32]
		for (ss=0 ; ss < SSLIMIT ; ss++) {    //0-17

/*********              由sb和ss计算cb(比例因子带)和cb_width(比例因子带宽)   **************/
			if ( (sb*18)+ss == next_cb_boundary)
			{ /* Adjust critical band boundary */
				if (gr_info->window_switching_flag && (gr_info->block_type == 2))
30038be0:	ea0000a6 	b	30038e80 <III_dequantize_sample+0x66c>
							cb_begin = sfBandIndex[sfreq].s[cb]*3;
						}
						else if (((sb*18)+ss) < sfBandIndex[sfreq].l[8])
							next_cb_boundary = sfBandIndex[sfreq].l[(++cb)+1];
						else {
							next_cb_boundary = sfBandIndex[sfreq].s[(++cb)+1]*3;
30038be4:	e59d201c 	ldr	r2, [sp, #28]
30038be8:	e59d3018 	ldr	r3, [sp, #24]
30038bec:	e2833001 	add	r3, r3, #1
30038bf0:	e58d3018 	str	r3, [sp, #24]
30038bf4:	e59d3018 	ldr	r3, [sp, #24]
30038bf8:	e2830001 	add	r0, r3, #1
30038bfc:	e59f1a44 	ldr	r1, [pc, #2628]	; 30039648 <III_dequantize_sample+0xe34>
30038c00:	e1a03002 	mov	r3, r2
30038c04:	e1a03183 	lsl	r3, r3, #3
30038c08:	e0833002 	add	r3, r3, r2
30038c0c:	e1a03103 	lsl	r3, r3, #2
30038c10:	e0833002 	add	r3, r3, r2
30038c14:	e0833000 	add	r3, r3, r0
30038c18:	e2832016 	add	r2, r3, #22
30038c1c:	e3a03004 	mov	r3, #4
30038c20:	e1a02102 	lsl	r2, r2, #2
30038c24:	e0822001 	add	r2, r2, r1
30038c28:	e0823003 	add	r3, r2, r3
30038c2c:	e5932000 	ldr	r2, [r3]
30038c30:	e1a03002 	mov	r3, r2
30038c34:	e1a03083 	lsl	r3, r3, #1
30038c38:	e0833002 	add	r3, r3, r2
30038c3c:	e58d3020 	str	r3, [sp, #32]
							cb_width = sfBandIndex[sfreq].s[cb+1] -
30038c40:	e59d201c 	ldr	r2, [sp, #28]
30038c44:	e59d3018 	ldr	r3, [sp, #24]
30038c48:	e2830001 	add	r0, r3, #1
30038c4c:	e59f19f4 	ldr	r1, [pc, #2548]	; 30039648 <III_dequantize_sample+0xe34>
30038c50:	e1a03002 	mov	r3, r2
30038c54:	e1a03183 	lsl	r3, r3, #3
30038c58:	e0833002 	add	r3, r3, r2
30038c5c:	e1a03103 	lsl	r3, r3, #2
30038c60:	e0833002 	add	r3, r3, r2
30038c64:	e0833000 	add	r3, r3, r0
30038c68:	e2832016 	add	r2, r3, #22
30038c6c:	e3a03004 	mov	r3, #4
30038c70:	e1a02102 	lsl	r2, r2, #2
30038c74:	e0822001 	add	r2, r2, r1
30038c78:	e0823003 	add	r3, r2, r3
30038c7c:	e5931000 	ldr	r1, [r3]
										sfBandIndex[sfreq].s[cb];
30038c80:	e59d201c 	ldr	r2, [sp, #28]
30038c84:	e59dc018 	ldr	ip, [sp, #24]
30038c88:	e59f09b8 	ldr	r0, [pc, #2488]	; 30039648 <III_dequantize_sample+0xe34>
30038c8c:	e1a03002 	mov	r3, r2
30038c90:	e1a03183 	lsl	r3, r3, #3
30038c94:	e0833002 	add	r3, r3, r2
30038c98:	e1a03103 	lsl	r3, r3, #2
30038c9c:	e0833002 	add	r3, r3, r2
30038ca0:	e083300c 	add	r3, r3, ip
30038ca4:	e2832016 	add	r2, r3, #22
30038ca8:	e3a03004 	mov	r3, #4
30038cac:	e1a02102 	lsl	r2, r2, #2
30038cb0:	e0822000 	add	r2, r2, r0
30038cb4:	e0823003 	add	r3, r2, r3
30038cb8:	e5933000 	ldr	r3, [r3]
						}
						else if (((sb*18)+ss) < sfBandIndex[sfreq].l[8])
							next_cb_boundary = sfBandIndex[sfreq].l[(++cb)+1];
						else {
							next_cb_boundary = sfBandIndex[sfreq].s[(++cb)+1]*3;
							cb_width = sfBandIndex[sfreq].s[cb+1] -
30038cbc:	e0633001 	rsb	r3, r3, r1
30038cc0:	e58d3028 	str	r3, [sp, #40]	; 0x28
										sfBandIndex[sfreq].s[cb];
							cb_begin = sfBandIndex[sfreq].s[cb]*3;
30038cc4:	e59d201c 	ldr	r2, [sp, #28]
30038cc8:	e59d0018 	ldr	r0, [sp, #24]
30038ccc:	e59f1974 	ldr	r1, [pc, #2420]	; 30039648 <III_dequantize_sample+0xe34>
30038cd0:	e1a03002 	mov	r3, r2
30038cd4:	e1a03183 	lsl	r3, r3, #3
30038cd8:	e0833002 	add	r3, r3, r2
30038cdc:	e1a03103 	lsl	r3, r3, #2
30038ce0:	e0833002 	add	r3, r3, r2
30038ce4:	e0833000 	add	r3, r3, r0
30038ce8:	e2832016 	add	r2, r3, #22
30038cec:	e3a03004 	mov	r3, #4
30038cf0:	e1a02102 	lsl	r2, r2, #2
30038cf4:	e0822001 	add	r2, r2, r1
30038cf8:	e0823003 	add	r3, r2, r3
30038cfc:	e5932000 	ldr	r2, [r3]
30038d00:	e1a03002 	mov	r3, r2
30038d04:	e1a03083 	lsl	r3, r3, #1
30038d08:	e0833002 	add	r3, r3, r2
30038d0c:	e58d3024 	str	r3, [sp, #36]	; 0x24
		for (ss=0 ; ss < SSLIMIT ; ss++) {    //0-17

/*********              由sb和ss计算cb(比例因子带)和cb_width(比例因子带宽)   **************/
			if ( (sb*18)+ss == next_cb_boundary)
			{ /* Adjust critical band boundary */
				if (gr_info->window_switching_flag && (gr_info->block_type == 2))
30038d10:	ea00005a 	b	30038e80 <III_dequantize_sample+0x66c>
							cb_begin = sfBandIndex[sfreq].s[cb]*3;
						}
					}
					else
					{
						next_cb_boundary = sfBandIndex[sfreq].s[(++cb)+1]*3;
30038d14:	e59d201c 	ldr	r2, [sp, #28]
30038d18:	e59d3018 	ldr	r3, [sp, #24]
30038d1c:	e2833001 	add	r3, r3, #1
30038d20:	e58d3018 	str	r3, [sp, #24]
30038d24:	e59d3018 	ldr	r3, [sp, #24]
30038d28:	e2830001 	add	r0, r3, #1
30038d2c:	e59f1914 	ldr	r1, [pc, #2324]	; 30039648 <III_dequantize_sample+0xe34>
30038d30:	e1a03002 	mov	r3, r2
30038d34:	e1a03183 	lsl	r3, r3, #3
30038d38:	e0833002 	add	r3, r3, r2
30038d3c:	e1a03103 	lsl	r3, r3, #2
30038d40:	e0833002 	add	r3, r3, r2
30038d44:	e0833000 	add	r3, r3, r0
30038d48:	e2832016 	add	r2, r3, #22
30038d4c:	e3a03004 	mov	r3, #4
30038d50:	e1a02102 	lsl	r2, r2, #2
30038d54:	e0822001 	add	r2, r2, r1
30038d58:	e0823003 	add	r3, r2, r3
30038d5c:	e5932000 	ldr	r2, [r3]
30038d60:	e1a03002 	mov	r3, r2
30038d64:	e1a03083 	lsl	r3, r3, #1
30038d68:	e0833002 	add	r3, r3, r2
30038d6c:	e58d3020 	str	r3, [sp, #32]
						cb_width = sfBandIndex[sfreq].s[cb+1] -
30038d70:	e59d201c 	ldr	r2, [sp, #28]
30038d74:	e59d3018 	ldr	r3, [sp, #24]
30038d78:	e2830001 	add	r0, r3, #1
30038d7c:	e59f18c4 	ldr	r1, [pc, #2244]	; 30039648 <III_dequantize_sample+0xe34>
30038d80:	e1a03002 	mov	r3, r2
30038d84:	e1a03183 	lsl	r3, r3, #3
30038d88:	e0833002 	add	r3, r3, r2
30038d8c:	e1a03103 	lsl	r3, r3, #2
30038d90:	e0833002 	add	r3, r3, r2
30038d94:	e0833000 	add	r3, r3, r0
30038d98:	e2832016 	add	r2, r3, #22
30038d9c:	e3a03004 	mov	r3, #4
30038da0:	e1a02102 	lsl	r2, r2, #2
30038da4:	e0822001 	add	r2, r2, r1
30038da8:	e0823003 	add	r3, r2, r3
30038dac:	e5931000 	ldr	r1, [r3]
									sfBandIndex[sfreq].s[cb];
30038db0:	e59d201c 	ldr	r2, [sp, #28]
30038db4:	e59dc018 	ldr	ip, [sp, #24]
30038db8:	e59f0888 	ldr	r0, [pc, #2184]	; 30039648 <III_dequantize_sample+0xe34>
30038dbc:	e1a03002 	mov	r3, r2
30038dc0:	e1a03183 	lsl	r3, r3, #3
30038dc4:	e0833002 	add	r3, r3, r2
30038dc8:	e1a03103 	lsl	r3, r3, #2
30038dcc:	e0833002 	add	r3, r3, r2
30038dd0:	e083300c 	add	r3, r3, ip
30038dd4:	e2832016 	add	r2, r3, #22
30038dd8:	e3a03004 	mov	r3, #4
30038ddc:	e1a02102 	lsl	r2, r2, #2
30038de0:	e0822000 	add	r2, r2, r0
30038de4:	e0823003 	add	r3, r2, r3
30038de8:	e5933000 	ldr	r3, [r3]
						}
					}
					else
					{
						next_cb_boundary = sfBandIndex[sfreq].s[(++cb)+1]*3;
						cb_width = sfBandIndex[sfreq].s[cb+1] -
30038dec:	e0633001 	rsb	r3, r3, r1
30038df0:	e58d3028 	str	r3, [sp, #40]	; 0x28
									sfBandIndex[sfreq].s[cb];
						cb_begin = sfBandIndex[sfreq].s[cb]*3;
30038df4:	e59d201c 	ldr	r2, [sp, #28]
30038df8:	e59d0018 	ldr	r0, [sp, #24]
30038dfc:	e59f1844 	ldr	r1, [pc, #2116]	; 30039648 <III_dequantize_sample+0xe34>
30038e00:	e1a03002 	mov	r3, r2
30038e04:	e1a03183 	lsl	r3, r3, #3
30038e08:	e0833002 	add	r3, r3, r2
30038e0c:	e1a03103 	lsl	r3, r3, #2
30038e10:	e0833002 	add	r3, r3, r2
30038e14:	e0833000 	add	r3, r3, r0
30038e18:	e2832016 	add	r2, r3, #22
30038e1c:	e3a03004 	mov	r3, #4
30038e20:	e1a02102 	lsl	r2, r2, #2
30038e24:	e0822001 	add	r2, r2, r1
30038e28:	e0823003 	add	r3, r2, r3
30038e2c:	e5932000 	ldr	r2, [r3]
30038e30:	e1a03002 	mov	r3, r2
30038e34:	e1a03083 	lsl	r3, r3, #1
30038e38:	e0833002 	add	r3, r3, r2
30038e3c:	e58d3024 	str	r3, [sp, #36]	; 0x24
		for (ss=0 ; ss < SSLIMIT ; ss++) {    //0-17

/*********              由sb和ss计算cb(比例因子带)和cb_width(比例因子带宽)   **************/
			if ( (sb*18)+ss == next_cb_boundary)
			{ /* Adjust critical band boundary */
				if (gr_info->window_switching_flag && (gr_info->block_type == 2))
30038e40:	ea00000e 	b	30038e80 <III_dequantize_sample+0x66c>
									sfBandIndex[sfreq].s[cb];
						cb_begin = sfBandIndex[sfreq].s[cb]*3;
					}
				}
	            else /* long blocks */
		           next_cb_boundary = sfBandIndex[sfreq].l[(++cb)+1];
30038e44:	e59d201c 	ldr	r2, [sp, #28]
30038e48:	e59d3018 	ldr	r3, [sp, #24]
30038e4c:	e2833001 	add	r3, r3, #1
30038e50:	e58d3018 	str	r3, [sp, #24]
30038e54:	e59d3018 	ldr	r3, [sp, #24]
30038e58:	e2830001 	add	r0, r3, #1
30038e5c:	e59f17e4 	ldr	r1, [pc, #2020]	; 30039648 <III_dequantize_sample+0xe34>
30038e60:	e1a03002 	mov	r3, r2
30038e64:	e1a03183 	lsl	r3, r3, #3
30038e68:	e0833002 	add	r3, r3, r2
30038e6c:	e1a03103 	lsl	r3, r3, #2
30038e70:	e0833002 	add	r3, r3, r2
30038e74:	e0833000 	add	r3, r3, r0
30038e78:	e7913103 	ldr	r3, [r1, r3, lsl #2]
30038e7c:	e58d3020 	str	r3, [sp, #32]
			}
/***************************************************************************************/
		  if(is[sb][ss]!=0)
30038e80:	e59d2014 	ldr	r2, [sp, #20]
30038e84:	e1a03002 	mov	r3, r2
30038e88:	e1a03183 	lsl	r3, r3, #3
30038e8c:	e0833002 	add	r3, r3, r2
30038e90:	e1a03183 	lsl	r3, r3, #3
30038e94:	e1a02003 	mov	r2, r3
30038e98:	e59d300c 	ldr	r3, [sp, #12]
30038e9c:	e0823003 	add	r3, r2, r3
30038ea0:	e59d2010 	ldr	r2, [sp, #16]
30038ea4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30038ea8:	e3530000 	cmp	r3, #0
30038eac:	0a0001c7 	beq	300395d0 <III_dequantize_sample+0xdbc>
		  {
			/* Compute overall (global) scaling. */
			//xr[sb][ss] = (0.25 * (gr_info->global_gain - 210.0));   //difference!!!!
			  xr[sb][ss] = (256 * (gr_info->global_gain - 210));
30038eb0:	e59d2014 	ldr	r2, [sp, #20]
30038eb4:	e1a03002 	mov	r3, r2
30038eb8:	e1a03183 	lsl	r3, r3, #3
30038ebc:	e0833002 	add	r3, r3, r2
30038ec0:	e1a03183 	lsl	r3, r3, #3
30038ec4:	e1a02003 	mov	r2, r3
30038ec8:	e59d3008 	ldr	r3, [sp, #8]
30038ecc:	e0822003 	add	r2, r2, r3
30038ed0:	e59d1010 	ldr	r1, [sp, #16]
30038ed4:	e59d3000 	ldr	r3, [sp]
30038ed8:	e5933008 	ldr	r3, [r3, #8]
30038edc:	e2833401 	add	r3, r3, #16777216	; 0x1000000
30038ee0:	e24330d2 	sub	r3, r3, #210	; 0xd2
30038ee4:	e1a03403 	lsl	r3, r3, #8
30038ee8:	e7823101 	str	r3, [r2, r1, lsl #2]
			  //xr[sb][ss] = ((gr_info->global_gain - 210))<<8;
			/* Do long/short dependent scaling operations. */

			if (gr_info->window_switching_flag && (
30038eec:	e59d3000 	ldr	r3, [sp]
30038ef0:	e5933010 	ldr	r3, [r3, #16]
30038ef4:	e3530000 	cmp	r3, #0
30038ef8:	0a000080 	beq	30039100 <III_dequantize_sample+0x8ec>
				((gr_info->block_type == 2) && (gr_info->mixed_block_flag == 0)) ||
30038efc:	e59d3000 	ldr	r3, [sp]
30038f00:	e5933014 	ldr	r3, [r3, #20]
			//xr[sb][ss] = (0.25 * (gr_info->global_gain - 210.0));   //difference!!!!
			  xr[sb][ss] = (256 * (gr_info->global_gain - 210));
			  //xr[sb][ss] = ((gr_info->global_gain - 210))<<8;
			/* Do long/short dependent scaling operations. */

			if (gr_info->window_switching_flag && (
30038f04:	e3530002 	cmp	r3, #2
30038f08:	1a000003 	bne	30038f1c <III_dequantize_sample+0x708>
				((gr_info->block_type == 2) && (gr_info->mixed_block_flag == 0)) ||
30038f0c:	e59d3000 	ldr	r3, [sp]
30038f10:	e5933018 	ldr	r3, [r3, #24]
			//xr[sb][ss] = (0.25 * (gr_info->global_gain - 210.0));   //difference!!!!
			  xr[sb][ss] = (256 * (gr_info->global_gain - 210));
			  //xr[sb][ss] = ((gr_info->global_gain - 210))<<8;
			/* Do long/short dependent scaling operations. */

			if (gr_info->window_switching_flag && (
30038f14:	e3530000 	cmp	r3, #0
30038f18:	0a00000a 	beq	30038f48 <III_dequantize_sample+0x734>
				((gr_info->block_type == 2) && (gr_info->mixed_block_flag == 0)) ||
				((gr_info->block_type == 2) && gr_info->mixed_block_flag && (sb >= 2)) ))
30038f1c:	e59d3000 	ldr	r3, [sp]
30038f20:	e5933014 	ldr	r3, [r3, #20]
			//xr[sb][ss] = (0.25 * (gr_info->global_gain - 210.0));   //difference!!!!
			  xr[sb][ss] = (256 * (gr_info->global_gain - 210));
			  //xr[sb][ss] = ((gr_info->global_gain - 210))<<8;
			/* Do long/short dependent scaling operations. */

			if (gr_info->window_switching_flag && (
30038f24:	e3530002 	cmp	r3, #2
30038f28:	1a000074 	bne	30039100 <III_dequantize_sample+0x8ec>
				((gr_info->block_type == 2) && (gr_info->mixed_block_flag == 0)) ||
				((gr_info->block_type == 2) && gr_info->mixed_block_flag && (sb >= 2)) ))
30038f2c:	e59d3000 	ldr	r3, [sp]
30038f30:	e5933018 	ldr	r3, [r3, #24]
			//xr[sb][ss] = (0.25 * (gr_info->global_gain - 210.0));   //difference!!!!
			  xr[sb][ss] = (256 * (gr_info->global_gain - 210));
			  //xr[sb][ss] = ((gr_info->global_gain - 210))<<8;
			/* Do long/short dependent scaling operations. */

			if (gr_info->window_switching_flag && (
30038f34:	e3530000 	cmp	r3, #0
30038f38:	0a000070 	beq	30039100 <III_dequantize_sample+0x8ec>
30038f3c:	e59d3014 	ldr	r3, [sp, #20]
30038f40:	e3530001 	cmp	r3, #1
30038f44:	da00006d 	ble	30039100 <III_dequantize_sample+0x8ec>
				((gr_info->block_type == 2) && (gr_info->mixed_block_flag == 0)) ||
				((gr_info->block_type == 2) && gr_info->mixed_block_flag && (sb >= 2)) ))
			{

				//xr[sb][ss] += (0.25 * -8.0 *gr_info->subblock_gain[(((sb*18)+ss) - cb_begin)/cb_width]);
				xr[sb][ss] += (-2048 *gr_info->subblock_gain[(((sb*18)+ss) - cb_begin)/cb_width]);
30038f48:	e59d2014 	ldr	r2, [sp, #20]
30038f4c:	e1a03002 	mov	r3, r2
30038f50:	e1a03183 	lsl	r3, r3, #3
30038f54:	e0833002 	add	r3, r3, r2
30038f58:	e1a03183 	lsl	r3, r3, #3
30038f5c:	e1a02003 	mov	r2, r3
30038f60:	e59d3008 	ldr	r3, [sp, #8]
30038f64:	e0824003 	add	r4, r2, r3
30038f68:	e59d5010 	ldr	r5, [sp, #16]
30038f6c:	e59d2014 	ldr	r2, [sp, #20]
30038f70:	e1a03002 	mov	r3, r2
30038f74:	e1a03183 	lsl	r3, r3, #3
30038f78:	e0833002 	add	r3, r3, r2
30038f7c:	e1a03183 	lsl	r3, r3, #3
30038f80:	e1a02003 	mov	r2, r3
30038f84:	e59d3008 	ldr	r3, [sp, #8]
30038f88:	e0823003 	add	r3, r2, r3
30038f8c:	e59d2010 	ldr	r2, [sp, #16]
30038f90:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30038f94:	e1a06003 	mov	r6, r3
30038f98:	e59d2014 	ldr	r2, [sp, #20]
30038f9c:	e1a03002 	mov	r3, r2
30038fa0:	e1a03183 	lsl	r3, r3, #3
30038fa4:	e0833002 	add	r3, r3, r2
30038fa8:	e1a03083 	lsl	r3, r3, #1
30038fac:	e1a02003 	mov	r2, r3
30038fb0:	e59d3010 	ldr	r3, [sp, #16]
30038fb4:	e0822003 	add	r2, r2, r3
30038fb8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30038fbc:	e0633002 	rsb	r3, r3, r2
30038fc0:	e1a00003 	mov	r0, r3
30038fc4:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
30038fc8:	eb002b79 	bl	30043db4 <__aeabi_idiv>
30038fcc:	e1a03000 	mov	r3, r0
30038fd0:	e1a02003 	mov	r2, r3
30038fd4:	e59d3000 	ldr	r3, [sp]
30038fd8:	e282200a 	add	r2, r2, #10
30038fdc:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30038fe0:	e1a03002 	mov	r3, r2
30038fe4:	e1a03a83 	lsl	r3, r3, #21
30038fe8:	e0623003 	rsb	r3, r2, r3
30038fec:	e1a03583 	lsl	r3, r3, #11
30038ff0:	e0863003 	add	r3, r6, r3
30038ff4:	e7843105 	str	r3, [r4, r5, lsl #2]
				//xr[sb][ss] += (-gr_info->subblock_gain[(((sb*18)+ss) - cb_begin)/cb_width])<<11;
				//xr[sb][ss] += (0.25 * -2.0 * (1.0+gr_info->scalefac_scale)
					//	* (*scalefac)[ch].s[(((sb*18)+ss) - cb_begin)/cb_width][cb]);
				xr[sb][ss] += (-512 * (1+gr_info->scalefac_scale)
30038ff8:	e59d2014 	ldr	r2, [sp, #20]
30038ffc:	e1a03002 	mov	r3, r2
30039000:	e1a03183 	lsl	r3, r3, #3
30039004:	e0833002 	add	r3, r3, r2
30039008:	e1a03183 	lsl	r3, r3, #3
3003900c:	e1a02003 	mov	r2, r3
30039010:	e59d3008 	ldr	r3, [sp, #8]
30039014:	e0825003 	add	r5, r2, r3
30039018:	e59d6010 	ldr	r6, [sp, #16]
3003901c:	e59d2014 	ldr	r2, [sp, #20]
30039020:	e1a03002 	mov	r3, r2
30039024:	e1a03183 	lsl	r3, r3, #3
30039028:	e0833002 	add	r3, r3, r2
3003902c:	e1a03183 	lsl	r3, r3, #3
30039030:	e1a02003 	mov	r2, r3
30039034:	e59d3008 	ldr	r3, [sp, #8]
30039038:	e0823003 	add	r3, r2, r3
3003903c:	e59d2010 	ldr	r2, [sp, #16]
30039040:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30039044:	e1a07003 	mov	r7, r3
30039048:	e59d3000 	ldr	r3, [sp]
3003904c:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30039050:	e2838001 	add	r8, r3, #1
						* (*scalefac)[ch].s[(((sb*18)+ss) - cb_begin)/cb_width][cb]);
30039054:	e59d4050 	ldr	r4, [sp, #80]	; 0x50
30039058:	e59d2014 	ldr	r2, [sp, #20]
3003905c:	e1a03002 	mov	r3, r2
30039060:	e1a03183 	lsl	r3, r3, #3
30039064:	e0833002 	add	r3, r3, r2
30039068:	e1a03083 	lsl	r3, r3, #1
3003906c:	e1a02003 	mov	r2, r3
30039070:	e59d3010 	ldr	r3, [sp, #16]
30039074:	e0822003 	add	r2, r2, r3
30039078:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3003907c:	e0633002 	rsb	r3, r3, r2
30039080:	e1a00003 	mov	r0, r3
30039084:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
30039088:	eb002b49 	bl	30043db4 <__aeabi_idiv>
3003908c:	e1a03000 	mov	r3, r0
30039090:	e1a02003 	mov	r2, r3
30039094:	e59d0018 	ldr	r0, [sp, #24]
30039098:	e59d1004 	ldr	r1, [sp, #4]
3003909c:	e1a03002 	mov	r3, r2
300390a0:	e1a03083 	lsl	r3, r3, #1
300390a4:	e0833002 	add	r3, r3, r2
300390a8:	e1a03103 	lsl	r3, r3, #2
300390ac:	e0833002 	add	r3, r3, r2
300390b0:	e1a02004 	mov	r2, r4
300390b4:	e1a02282 	lsl	r2, r2, #5
300390b8:	e0642002 	rsb	r2, r4, r2
300390bc:	e1a02082 	lsl	r2, r2, #1
300390c0:	e0833002 	add	r3, r3, r2
300390c4:	e0833000 	add	r3, r3, r0
300390c8:	e2832016 	add	r2, r3, #22
300390cc:	e3a03004 	mov	r3, #4
300390d0:	e1a02102 	lsl	r2, r2, #2
300390d4:	e0822001 	add	r2, r2, r1
300390d8:	e0823003 	add	r3, r2, r3
300390dc:	e5933000 	ldr	r3, [r3]
				//xr[sb][ss] += (0.25 * -8.0 *gr_info->subblock_gain[(((sb*18)+ss) - cb_begin)/cb_width]);
				xr[sb][ss] += (-2048 *gr_info->subblock_gain[(((sb*18)+ss) - cb_begin)/cb_width]);
				//xr[sb][ss] += (-gr_info->subblock_gain[(((sb*18)+ss) - cb_begin)/cb_width])<<11;
				//xr[sb][ss] += (0.25 * -2.0 * (1.0+gr_info->scalefac_scale)
					//	* (*scalefac)[ch].s[(((sb*18)+ss) - cb_begin)/cb_width][cb]);
				xr[sb][ss] += (-512 * (1+gr_info->scalefac_scale)
300390e0:	e0020893 	mul	r2, r3, r8
300390e4:	e1a03002 	mov	r3, r2
300390e8:	e1a03b83 	lsl	r3, r3, #23
300390ec:	e0623003 	rsb	r3, r2, r3
300390f0:	e1a03483 	lsl	r3, r3, #9
300390f4:	e0873003 	add	r3, r7, r3
300390f8:	e7853106 	str	r3, [r5, r6, lsl #2]
			//xr[sb][ss] = (0.25 * (gr_info->global_gain - 210.0));   //difference!!!!
			  xr[sb][ss] = (256 * (gr_info->global_gain - 210));
			  //xr[sb][ss] = ((gr_info->global_gain - 210))<<8;
			/* Do long/short dependent scaling operations. */

			if (gr_info->window_switching_flag && (
300390fc:	ea00002e 	b	300391bc <III_dequantize_sample+0x9a8>
			else    /* LONG block types 0,1,3 & 1st 2 subbands of switched blocks */
			{
				/*(xr[sb][ss] +=  (-0.5 * (1.0+gr_info->scalefac_scale)
								* ((*scalefac)[ch].l[cb]
								+ gr_info->preflag * pretab[cb]));*/
				xr[sb][ss] +=  (-512 * (1+gr_info->scalefac_scale)
30039100:	e59d2014 	ldr	r2, [sp, #20]
30039104:	e1a03002 	mov	r3, r2
30039108:	e1a03183 	lsl	r3, r3, #3
3003910c:	e0833002 	add	r3, r3, r2
30039110:	e1a03183 	lsl	r3, r3, #3
30039114:	e1a02003 	mov	r2, r3
30039118:	e59d3008 	ldr	r3, [sp, #8]
3003911c:	e0821003 	add	r1, r2, r3
30039120:	e59d0010 	ldr	r0, [sp, #16]
30039124:	e59d2014 	ldr	r2, [sp, #20]
30039128:	e1a03002 	mov	r3, r2
3003912c:	e1a03183 	lsl	r3, r3, #3
30039130:	e0833002 	add	r3, r3, r2
30039134:	e1a03183 	lsl	r3, r3, #3
30039138:	e1a02003 	mov	r2, r3
3003913c:	e59d3008 	ldr	r3, [sp, #8]
30039140:	e0823003 	add	r3, r2, r3
30039144:	e59d2010 	ldr	r2, [sp, #16]
30039148:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3003914c:	e1a0c003 	mov	ip, r3
30039150:	e59d3000 	ldr	r3, [sp]
30039154:	e5933040 	ldr	r3, [r3, #64]	; 0x40
30039158:	e283e001 	add	lr, r3, #1
								* ((*scalefac)[ch].l[cb]
3003915c:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
30039160:	e59d5018 	ldr	r5, [sp, #24]
30039164:	e59d4004 	ldr	r4, [sp, #4]
30039168:	e1a03002 	mov	r3, r2
3003916c:	e1a03283 	lsl	r3, r3, #5
30039170:	e0623003 	rsb	r3, r2, r3
30039174:	e1a03083 	lsl	r3, r3, #1
30039178:	e0833005 	add	r3, r3, r5
3003917c:	e7943103 	ldr	r3, [r4, r3, lsl #2]
30039180:	e1a02003 	mov	r2, r3
								+ gr_info->preflag * pretab[cb]));
30039184:	e59d3000 	ldr	r3, [sp]
30039188:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
3003918c:	e59d5018 	ldr	r5, [sp, #24]
30039190:	e59f44b4 	ldr	r4, [pc, #1204]	; 3003964c <III_dequantize_sample+0xe38>
30039194:	e7944105 	ldr	r4, [r4, r5, lsl #2]
30039198:	e0030394 	mul	r3, r4, r3
			{
				/*(xr[sb][ss] +=  (-0.5 * (1.0+gr_info->scalefac_scale)
								* ((*scalefac)[ch].l[cb]
								+ gr_info->preflag * pretab[cb]));*/
				xr[sb][ss] +=  (-512 * (1+gr_info->scalefac_scale)
								* ((*scalefac)[ch].l[cb]
3003919c:	e0823003 	add	r3, r2, r3
			else    /* LONG block types 0,1,3 & 1st 2 subbands of switched blocks */
			{
				/*(xr[sb][ss] +=  (-0.5 * (1.0+gr_info->scalefac_scale)
								* ((*scalefac)[ch].l[cb]
								+ gr_info->preflag * pretab[cb]));*/
				xr[sb][ss] +=  (-512 * (1+gr_info->scalefac_scale)
300391a0:	e0020e93 	mul	r2, r3, lr
300391a4:	e1a03002 	mov	r3, r2
300391a8:	e1a03b83 	lsl	r3, r3, #23
300391ac:	e0623003 	rsb	r3, r2, r3
300391b0:	e1a03483 	lsl	r3, r3, #9
300391b4:	e08c3003 	add	r3, ip, r3
300391b8:	e7813100 	str	r3, [r1, r0, lsl #2]
					//			+ gr_info->preflag * pretab[cb]))<<9;
			}

			/* Scale quantized value. */
            //求出符号
			sign=0;
300391bc:	e3a03000 	mov	r3, #0
300391c0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
			if(is[sb][ss]<0)
300391c4:	e59d2014 	ldr	r2, [sp, #20]
300391c8:	e1a03002 	mov	r3, r2
300391cc:	e1a03183 	lsl	r3, r3, #3
300391d0:	e0833002 	add	r3, r3, r2
300391d4:	e1a03183 	lsl	r3, r3, #3
300391d8:	e1a02003 	mov	r2, r3
300391dc:	e59d300c 	ldr	r3, [sp, #12]
300391e0:	e0823003 	add	r3, r2, r3
300391e4:	e59d2010 	ldr	r2, [sp, #16]
300391e8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300391ec:	e3530000 	cmp	r3, #0
300391f0:	aa000016 	bge	30039250 <III_dequantize_sample+0xa3c>
			{
				sign=1;
300391f4:	e3a03001 	mov	r3, #1
300391f8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
			    is[sb][ss]=-is[sb][ss];
300391fc:	e59d2014 	ldr	r2, [sp, #20]
30039200:	e1a03002 	mov	r3, r2
30039204:	e1a03183 	lsl	r3, r3, #3
30039208:	e0833002 	add	r3, r3, r2
3003920c:	e1a03183 	lsl	r3, r3, #3
30039210:	e1a02003 	mov	r2, r3
30039214:	e59d300c 	ldr	r3, [sp, #12]
30039218:	e0821003 	add	r1, r2, r3
3003921c:	e59d0010 	ldr	r0, [sp, #16]
30039220:	e59d2014 	ldr	r2, [sp, #20]
30039224:	e1a03002 	mov	r3, r2
30039228:	e1a03183 	lsl	r3, r3, #3
3003922c:	e0833002 	add	r3, r3, r2
30039230:	e1a03183 	lsl	r3, r3, #3
30039234:	e1a02003 	mov	r2, r3
30039238:	e59d300c 	ldr	r3, [sp, #12]
3003923c:	e0823003 	add	r3, r2, r3
30039240:	e59d2010 	ldr	r2, [sp, #16]
30039244:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30039248:	e2633000 	rsb	r3, r3, #0
3003924c:	e7813100 	str	r3, [r1, r0, lsl #2]
			}

			if(is[sb][ss]>1023)
30039250:	e59d2014 	ldr	r2, [sp, #20]
30039254:	e1a03002 	mov	r3, r2
30039258:	e1a03183 	lsl	r3, r3, #3
3003925c:	e0833002 	add	r3, r3, r2
30039260:	e1a03183 	lsl	r3, r3, #3
30039264:	e1a02003 	mov	r2, r3
30039268:	e59d300c 	ldr	r3, [sp, #12]
3003926c:	e0823003 	add	r3, r2, r3
30039270:	e59d2010 	ldr	r2, [sp, #16]
30039274:	e7932102 	ldr	r2, [r3, r2, lsl #2]
30039278:	e3a03fff 	mov	r3, #1020	; 0x3fc
3003927c:	e2833003 	add	r3, r3, #3
30039280:	e1520003 	cmp	r2, r3
30039284:	da000010 	ble	300392cc <III_dequantize_sample+0xab8>
				//temp=is43_table[(unsigned)is[sb][ss]>>3]+2.7725887;// 4/3*ln8
				temp=(int)((is43_table[(unsigned)is[sb][ss]>>3]+2772));// 4/3*ln8
30039288:	e59d2014 	ldr	r2, [sp, #20]
3003928c:	e1a03002 	mov	r3, r2
30039290:	e1a03183 	lsl	r3, r3, #3
30039294:	e0833002 	add	r3, r3, r2
30039298:	e1a03183 	lsl	r3, r3, #3
3003929c:	e1a02003 	mov	r2, r3
300392a0:	e59d300c 	ldr	r3, [sp, #12]
300392a4:	e0823003 	add	r3, r2, r3
300392a8:	e59d2010 	ldr	r2, [sp, #16]
300392ac:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300392b0:	e1a021a3 	lsr	r2, r3, #3
300392b4:	e59f3394 	ldr	r3, [pc, #916]	; 30039650 <III_dequantize_sample+0xe3c>
300392b8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300392bc:	e2833ead 	add	r3, r3, #2768	; 0xad0
300392c0:	e2833004 	add	r3, r3, #4
300392c4:	e58d3030 	str	r3, [sp, #48]	; 0x30
300392c8:	ea00000c 	b	30039300 <III_dequantize_sample+0xaec>
			else
				temp=(int)(is43_table[is[sb][ss]]);
300392cc:	e59d2014 	ldr	r2, [sp, #20]
300392d0:	e1a03002 	mov	r3, r2
300392d4:	e1a03183 	lsl	r3, r3, #3
300392d8:	e0833002 	add	r3, r3, r2
300392dc:	e1a03183 	lsl	r3, r3, #3
300392e0:	e1a02003 	mov	r2, r3
300392e4:	e59d300c 	ldr	r3, [sp, #12]
300392e8:	e0823003 	add	r3, r2, r3
300392ec:	e59d2010 	ldr	r2, [sp, #16]
300392f0:	e7932102 	ldr	r2, [r3, r2, lsl #2]
300392f4:	e59f3354 	ldr	r3, [pc, #852]	; 30039650 <III_dequantize_sample+0xe3c>
300392f8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300392fc:	e58d3030 	str	r3, [sp, #48]	; 0x30

			//xr[sb][ss] *=0.69314318;        //log(2);
			xr[sb][ss] = xr[sb][ss]*710/1024;        //log(2);
30039300:	e59d2014 	ldr	r2, [sp, #20]
30039304:	e1a03002 	mov	r3, r2
30039308:	e1a03183 	lsl	r3, r3, #3
3003930c:	e0833002 	add	r3, r3, r2
30039310:	e1a03183 	lsl	r3, r3, #3
30039314:	e1a02003 	mov	r2, r3
30039318:	e59d3008 	ldr	r3, [sp, #8]
3003931c:	e0821003 	add	r1, r2, r3
30039320:	e59d0010 	ldr	r0, [sp, #16]
30039324:	e59d2014 	ldr	r2, [sp, #20]
30039328:	e1a03002 	mov	r3, r2
3003932c:	e1a03183 	lsl	r3, r3, #3
30039330:	e0833002 	add	r3, r3, r2
30039334:	e1a03183 	lsl	r3, r3, #3
30039338:	e1a02003 	mov	r2, r3
3003933c:	e59d3008 	ldr	r3, [sp, #8]
30039340:	e0823003 	add	r3, r2, r3
30039344:	e59d2010 	ldr	r2, [sp, #16]
30039348:	e7932102 	ldr	r2, [r3, r2, lsl #2]
3003934c:	e1a03002 	mov	r3, r2
30039350:	e1a03183 	lsl	r3, r3, #3
30039354:	e0833002 	add	r3, r3, r2
30039358:	e1a03183 	lsl	r3, r3, #3
3003935c:	e0623003 	rsb	r3, r2, r3
30039360:	e1a02103 	lsl	r2, r3, #2
30039364:	e0833002 	add	r3, r3, r2
30039368:	e1a03083 	lsl	r3, r3, #1
3003936c:	e2832fff 	add	r2, r3, #1020	; 0x3fc
30039370:	e2822003 	add	r2, r2, #3
30039374:	e3530000 	cmp	r3, #0
30039378:	b1a03002 	movlt	r3, r2
3003937c:	e1a03543 	asr	r3, r3, #10
30039380:	e7813100 	str	r3, [r1, r0, lsl #2]
			//xr[sb][ss] = (xr[sb][ss]*710)>>10;        //log(2);
			xr[sb][ss] +=temp;
30039384:	e59d2014 	ldr	r2, [sp, #20]
30039388:	e1a03002 	mov	r3, r2
3003938c:	e1a03183 	lsl	r3, r3, #3
30039390:	e0833002 	add	r3, r3, r2
30039394:	e1a03183 	lsl	r3, r3, #3
30039398:	e1a02003 	mov	r2, r3
3003939c:	e59d3008 	ldr	r3, [sp, #8]
300393a0:	e0821003 	add	r1, r2, r3
300393a4:	e59d0010 	ldr	r0, [sp, #16]
300393a8:	e59d2014 	ldr	r2, [sp, #20]
300393ac:	e1a03002 	mov	r3, r2
300393b0:	e1a03183 	lsl	r3, r3, #3
300393b4:	e0833002 	add	r3, r3, r2
300393b8:	e1a03183 	lsl	r3, r3, #3
300393bc:	e1a02003 	mov	r2, r3
300393c0:	e59d3008 	ldr	r3, [sp, #8]
300393c4:	e0823003 	add	r3, r2, r3
300393c8:	e59d2010 	ldr	r2, [sp, #16]
300393cc:	e7932102 	ldr	r2, [r3, r2, lsl #2]
300393d0:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
300393d4:	e0823003 	add	r3, r2, r3
300393d8:	e7813100 	str	r3, [r1, r0, lsl #2]
			//xr[sb][ss] =(int)(exp(xr[sb][ss]/1024)*1024);
			if(xr[sb][ss] >= 0)
300393dc:	e59d2014 	ldr	r2, [sp, #20]
300393e0:	e1a03002 	mov	r3, r2
300393e4:	e1a03183 	lsl	r3, r3, #3
300393e8:	e0833002 	add	r3, r3, r2
300393ec:	e1a03183 	lsl	r3, r3, #3
300393f0:	e1a02003 	mov	r2, r3
300393f4:	e59d3008 	ldr	r3, [sp, #8]
300393f8:	e0823003 	add	r3, r2, r3
300393fc:	e59d2010 	ldr	r2, [sp, #16]
30039400:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30039404:	e3530000 	cmp	r3, #0
30039408:	ba000017 	blt	3003946c <III_dequantize_sample+0xc58>
				xr[sb][ss] = exp(xr[sb][ss]);
3003940c:	e59d2014 	ldr	r2, [sp, #20]
30039410:	e1a03002 	mov	r3, r2
30039414:	e1a03183 	lsl	r3, r3, #3
30039418:	e0833002 	add	r3, r3, r2
3003941c:	e1a03183 	lsl	r3, r3, #3
30039420:	e1a02003 	mov	r2, r3
30039424:	e59d3008 	ldr	r3, [sp, #8]
30039428:	e0824003 	add	r4, r2, r3
3003942c:	e59d5010 	ldr	r5, [sp, #16]
30039430:	e59d2014 	ldr	r2, [sp, #20]
30039434:	e1a03002 	mov	r3, r2
30039438:	e1a03183 	lsl	r3, r3, #3
3003943c:	e0833002 	add	r3, r3, r2
30039440:	e1a03183 	lsl	r3, r3, #3
30039444:	e1a02003 	mov	r2, r3
30039448:	e59d3008 	ldr	r3, [sp, #8]
3003944c:	e0823003 	add	r3, r2, r3
30039450:	e59d2010 	ldr	r2, [sp, #16]
30039454:	e7933102 	ldr	r3, [r3, r2, lsl #2]
30039458:	e1a00003 	mov	r0, r3
3003945c:	ebfff00c 	bl	30035494 <exp>
30039460:	e1a03000 	mov	r3, r0
30039464:	e7843105 	str	r3, [r4, r5, lsl #2]
30039468:	ea00003f 	b	3003956c <III_dequantize_sample+0xd58>
			else {
				xr[sb][ss] = -xr[sb][ss];
3003946c:	e59d2014 	ldr	r2, [sp, #20]
30039470:	e1a03002 	mov	r3, r2
30039474:	e1a03183 	lsl	r3, r3, #3
30039478:	e0833002 	add	r3, r3, r2
3003947c:	e1a03183 	lsl	r3, r3, #3
30039480:	e1a02003 	mov	r2, r3
30039484:	e59d3008 	ldr	r3, [sp, #8]
30039488:	e0821003 	add	r1, r2, r3
3003948c:	e59d0010 	ldr	r0, [sp, #16]
30039490:	e59d2014 	ldr	r2, [sp, #20]
30039494:	e1a03002 	mov	r3, r2
30039498:	e1a03183 	lsl	r3, r3, #3
3003949c:	e0833002 	add	r3, r3, r2
300394a0:	e1a03183 	lsl	r3, r3, #3
300394a4:	e1a02003 	mov	r2, r3
300394a8:	e59d3008 	ldr	r3, [sp, #8]
300394ac:	e0823003 	add	r3, r2, r3
300394b0:	e59d2010 	ldr	r2, [sp, #16]
300394b4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300394b8:	e2633000 	rsb	r3, r3, #0
300394bc:	e7813100 	str	r3, [r1, r0, lsl #2]
				//xr[sb][ss] = 1024*1024/(exp(xr[sb][ss]));
				tmp = exp(xr[sb][ss]);
300394c0:	e59d2014 	ldr	r2, [sp, #20]
300394c4:	e1a03002 	mov	r3, r2
300394c8:	e1a03183 	lsl	r3, r3, #3
300394cc:	e0833002 	add	r3, r3, r2
300394d0:	e1a03183 	lsl	r3, r3, #3
300394d4:	e1a02003 	mov	r2, r3
300394d8:	e59d3008 	ldr	r3, [sp, #8]
300394dc:	e0823003 	add	r3, r2, r3
300394e0:	e59d2010 	ldr	r2, [sp, #16]
300394e4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300394e8:	e1a00003 	mov	r0, r3
300394ec:	ebffefe8 	bl	30035494 <exp>
300394f0:	e1a03000 	mov	r3, r0
300394f4:	e58d3034 	str	r3, [sp, #52]	; 0x34
			    if(tmp == 0)
300394f8:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
300394fc:	e3530000 	cmp	r3, #0
30039500:	1a00000b 	bne	30039534 <III_dequantize_sample+0xd20>
					xr[sb][ss] = (1024*1024)*10000;
30039504:	e59d2014 	ldr	r2, [sp, #20]
30039508:	e1a03002 	mov	r3, r2
3003950c:	e1a03183 	lsl	r3, r3, #3
30039510:	e0833002 	add	r3, r3, r2
30039514:	e1a03183 	lsl	r3, r3, #3
30039518:	e1a02003 	mov	r2, r3
3003951c:	e59d3008 	ldr	r3, [sp, #8]
30039520:	e0823003 	add	r3, r2, r3
30039524:	e59d2010 	ldr	r2, [sp, #16]
30039528:	e3a01471 	mov	r1, #1895825408	; 0x71000000
3003952c:	e7831102 	str	r1, [r3, r2, lsl #2]
30039530:	ea00000d 	b	3003956c <III_dequantize_sample+0xd58>
				else
					xr[sb][ss] = (1024*1024)/tmp;
30039534:	e59d2014 	ldr	r2, [sp, #20]
30039538:	e1a03002 	mov	r3, r2
3003953c:	e1a03183 	lsl	r3, r3, #3
30039540:	e0833002 	add	r3, r3, r2
30039544:	e1a03183 	lsl	r3, r3, #3
30039548:	e1a02003 	mov	r2, r3
3003954c:	e59d3008 	ldr	r3, [sp, #8]
30039550:	e0824003 	add	r4, r2, r3
30039554:	e59d5010 	ldr	r5, [sp, #16]
30039558:	e3a00601 	mov	r0, #1048576	; 0x100000
3003955c:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
30039560:	eb002a13 	bl	30043db4 <__aeabi_idiv>
30039564:	e1a03000 	mov	r3, r0
30039568:	e7843105 	str	r3, [r4, r5, lsl #2]
			}

			if (sign) xr[sb][ss] = -xr[sb][ss];
3003956c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30039570:	e3530000 	cmp	r3, #0
30039574:	0a000021 	beq	30039600 <III_dequantize_sample+0xdec>
30039578:	e59d2014 	ldr	r2, [sp, #20]
3003957c:	e1a03002 	mov	r3, r2
30039580:	e1a03183 	lsl	r3, r3, #3
30039584:	e0833002 	add	r3, r3, r2
30039588:	e1a03183 	lsl	r3, r3, #3
3003958c:	e1a02003 	mov	r2, r3
30039590:	e59d3008 	ldr	r3, [sp, #8]
30039594:	e0821003 	add	r1, r2, r3
30039598:	e59d0010 	ldr	r0, [sp, #16]
3003959c:	e59d2014 	ldr	r2, [sp, #20]
300395a0:	e1a03002 	mov	r3, r2
300395a4:	e1a03183 	lsl	r3, r3, #3
300395a8:	e0833002 	add	r3, r3, r2
300395ac:	e1a03183 	lsl	r3, r3, #3
300395b0:	e1a02003 	mov	r2, r3
300395b4:	e59d3008 	ldr	r3, [sp, #8]
300395b8:	e0823003 	add	r3, r2, r3
300395bc:	e59d2010 	ldr	r2, [sp, #16]
300395c0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300395c4:	e2633000 	rsb	r3, r3, #0
300395c8:	e7813100 	str	r3, [r1, r0, lsl #2]
300395cc:	ea00000c 	b	30039604 <III_dequantize_sample+0xdf0>
		  }
		  else
			xr[sb][ss] =0;
300395d0:	e59d2014 	ldr	r2, [sp, #20]
300395d4:	e1a03002 	mov	r3, r2
300395d8:	e1a03183 	lsl	r3, r3, #3
300395dc:	e0833002 	add	r3, r3, r2
300395e0:	e1a03183 	lsl	r3, r3, #3
300395e4:	e1a02003 	mov	r2, r3
300395e8:	e59d3008 	ldr	r3, [sp, #8]
300395ec:	e0823003 	add	r3, r2, r3
300395f0:	e59d2010 	ldr	r2, [sp, #16]
300395f4:	e3a01000 	mov	r1, #0
300395f8:	e7831102 	str	r1, [r3, r2, lsl #2]
300395fc:	ea000000 	b	30039604 <III_dequantize_sample+0xdf0>
					xr[sb][ss] = (1024*1024)*10000;
				else
					xr[sb][ss] = (1024*1024)/tmp;
			}

			if (sign) xr[sb][ss] = -xr[sb][ss];
30039600:	e1a00000 	nop			; (mov r0, r0)
	else
		next_cb_boundary=sfBandIndex[sfreq].l[1];  /* LONG blocks: 0,1,3 */

	/* apply formula per block type */
	for (sb=0 ; sb < SBLIMIT ; sb++) {        //0-31
		for (ss=0 ; ss < SSLIMIT ; ss++) {    //0-17
30039604:	e59d3010 	ldr	r3, [sp, #16]
30039608:	e2833001 	add	r3, r3, #1
3003960c:	e58d3010 	str	r3, [sp, #16]
30039610:	e59d3010 	ldr	r3, [sp, #16]
30039614:	e3530011 	cmp	r3, #17
30039618:	dafffcd7 	ble	3003897c <III_dequantize_sample+0x168>
		}
	else
		next_cb_boundary=sfBandIndex[sfreq].l[1];  /* LONG blocks: 0,1,3 */

	/* apply formula per block type */
	for (sb=0 ; sb < SBLIMIT ; sb++) {        //0-31
3003961c:	e59d3014 	ldr	r3, [sp, #20]
30039620:	e2833001 	add	r3, r3, #1
30039624:	e58d3014 	str	r3, [sp, #20]
30039628:	e59d3014 	ldr	r3, [sp, #20]
3003962c:	e353001f 	cmp	r3, #31
30039630:	dafffcce 	ble	30038970 <III_dequantize_sample+0x15c>
		  else
			xr[sb][ss] =0;

		}
	}
}
30039634:	e28dd038 	add	sp, sp, #56	; 0x38
30039638:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
3003963c:	e12fff1e 	bx	lr
30039640:	302be81c 	.word	0x302be81c
30039644:	300c91ac 	.word	0x300c91ac
30039648:	300c7eb4 	.word	0x300c7eb4
3003964c:	300c8110 	.word	0x300c8110
30039650:	300c8168 	.word	0x300c8168

30039654 <III_reorder>:

 

void III_reorder(int xr[SBLIMIT][SSLIMIT] ,  struct Granule *gr_info)
{
30039654:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
30039658:	e24dde93 	sub	sp, sp, #2352	; 0x930
3003965c:	e24dd004 	sub	sp, sp, #4
30039660:	e58d0004 	str	r0, [sp, #4]
30039664:	e58d1000 	str	r1, [sp]
   int sfreq=fr_ps.header->sampling_frequency;
30039668:	e59f3698 	ldr	r3, [pc, #1688]	; 30039d08 <III_reorder+0x6b4>
3003966c:	e5933000 	ldr	r3, [r3]
30039670:	e5933010 	ldr	r3, [r3, #16]
30039674:	e58d3908 	str	r3, [sp, #2312]	; 0x908
   int sfb, sfb_start, sfb_lines;
   int sb, ss, window, freq, src_line, des_line;
   int ro[SBLIMIT][SSLIMIT] ;

   if (gr_info->window_switching_flag && (gr_info->block_type == 2)) 
30039678:	e59d3000 	ldr	r3, [sp]
3003967c:	e5933010 	ldr	r3, [r3, #16]
30039680:	e3530000 	cmp	r3, #0
30039684:	0a00019b 	beq	30039cf8 <III_reorder+0x6a4>
30039688:	e59d3000 	ldr	r3, [sp]
3003968c:	e5933014 	ldr	r3, [r3, #20]
30039690:	e3530002 	cmp	r3, #2
30039694:	1a000197 	bne	30039cf8 <III_reorder+0x6a4>
   {
      if (gr_info->mixed_block_flag) 
30039698:	e59d3000 	ldr	r3, [sp]
3003969c:	e5933018 	ldr	r3, [r3, #24]
300396a0:	e3530000 	cmp	r3, #0
300396a4:	0a0000d0 	beq	300399ec <III_reorder+0x398>
	  {
         /* NO REORDER FOR LOW 2 SUBBANDS */
         for (sb=0 ; sb < 2 ; sb++)
300396a8:	e3a03000 	mov	r3, #0
300396ac:	e58d3918 	str	r3, [sp, #2328]	; 0x918
300396b0:	ea000023 	b	30039744 <III_reorder+0xf0>
            for (ss=0 ; ss < SSLIMIT ; ss++) 
300396b4:	e3a03000 	mov	r3, #0
300396b8:	e58d391c 	str	r3, [sp, #2332]	; 0x91c
300396bc:	ea00001a 	b	3003972c <III_reorder+0xd8>
               ro[sb][ss] = xr[sb][ss];
300396c0:	e59d2918 	ldr	r2, [sp, #2328]	; 0x918
300396c4:	e59d091c 	ldr	r0, [sp, #2332]	; 0x91c
300396c8:	e59d1918 	ldr	r1, [sp, #2328]	; 0x918
300396cc:	e1a03001 	mov	r3, r1
300396d0:	e1a03183 	lsl	r3, r3, #3
300396d4:	e0833001 	add	r3, r3, r1
300396d8:	e1a03183 	lsl	r3, r3, #3
300396dc:	e1a01003 	mov	r1, r3
300396e0:	e59d3004 	ldr	r3, [sp, #4]
300396e4:	e0813003 	add	r3, r1, r3
300396e8:	e59d191c 	ldr	r1, [sp, #2332]	; 0x91c
300396ec:	e7931101 	ldr	r1, [r3, r1, lsl #2]
300396f0:	e1a03002 	mov	r3, r2
300396f4:	e1a03183 	lsl	r3, r3, #3
300396f8:	e0833002 	add	r3, r3, r2
300396fc:	e1a03083 	lsl	r3, r3, #1
30039700:	e0832000 	add	r2, r3, r0
30039704:	e3e03e92 	mvn	r3, #2336	; 0x920
30039708:	e2433007 	sub	r3, r3, #7
3003970c:	e1a02102 	lsl	r2, r2, #2
30039710:	e28d0e93 	add	r0, sp, #2352	; 0x930
30039714:	e0822000 	add	r2, r2, r0
30039718:	e0823003 	add	r3, r2, r3
3003971c:	e5831000 	str	r1, [r3]
   {
      if (gr_info->mixed_block_flag) 
	  {
         /* NO REORDER FOR LOW 2 SUBBANDS */
         for (sb=0 ; sb < 2 ; sb++)
            for (ss=0 ; ss < SSLIMIT ; ss++) 
30039720:	e59d391c 	ldr	r3, [sp, #2332]	; 0x91c
30039724:	e2833001 	add	r3, r3, #1
30039728:	e58d391c 	str	r3, [sp, #2332]	; 0x91c
3003972c:	e59d391c 	ldr	r3, [sp, #2332]	; 0x91c
30039730:	e3530011 	cmp	r3, #17
30039734:	daffffe1 	ble	300396c0 <III_reorder+0x6c>
   if (gr_info->window_switching_flag && (gr_info->block_type == 2)) 
   {
      if (gr_info->mixed_block_flag) 
	  {
         /* NO REORDER FOR LOW 2 SUBBANDS */
         for (sb=0 ; sb < 2 ; sb++)
30039738:	e59d3918 	ldr	r3, [sp, #2328]	; 0x918
3003973c:	e2833001 	add	r3, r3, #1
30039740:	e58d3918 	str	r3, [sp, #2328]	; 0x918
30039744:	e59d3918 	ldr	r3, [sp, #2328]	; 0x918
30039748:	e3530001 	cmp	r3, #1
3003974c:	daffffd8 	ble	300396b4 <III_reorder+0x60>
            for (ss=0 ; ss < SSLIMIT ; ss++) 
               ro[sb][ss] = xr[sb][ss];
            
         /* REORDERING FOR REST SWITCHED SHORT */
         for(sfb=3,sfb_start=sfBandIndex[sfreq].s[3],
30039750:	e3a03003 	mov	r3, #3
30039754:	e58d390c 	str	r3, [sp, #2316]	; 0x90c
30039758:	e59d2908 	ldr	r2, [sp, #2312]	; 0x908
3003975c:	e59f05a8 	ldr	r0, [pc, #1448]	; 30039d0c <III_reorder+0x6b8>
30039760:	e3a01068 	mov	r1, #104	; 0x68
30039764:	e1a03002 	mov	r3, r2
30039768:	e1a03183 	lsl	r3, r3, #3
3003976c:	e0833002 	add	r3, r3, r2
30039770:	e1a03103 	lsl	r3, r3, #2
30039774:	e0833002 	add	r3, r3, r2
30039778:	e1a03103 	lsl	r3, r3, #2
3003977c:	e0833000 	add	r3, r3, r0
30039780:	e0833001 	add	r3, r3, r1
30039784:	e5933000 	ldr	r3, [r3]
30039788:	e58d3910 	str	r3, [sp, #2320]	; 0x910
            sfb_lines=sfBandIndex[sfreq].s[4] - sfb_start;
3003978c:	e59d2908 	ldr	r2, [sp, #2312]	; 0x908
30039790:	e59f0574 	ldr	r0, [pc, #1396]	; 30039d0c <III_reorder+0x6b8>
30039794:	e3a0106c 	mov	r1, #108	; 0x6c
30039798:	e1a03002 	mov	r3, r2
3003979c:	e1a03183 	lsl	r3, r3, #3
300397a0:	e0833002 	add	r3, r3, r2
300397a4:	e1a03103 	lsl	r3, r3, #2
300397a8:	e0833002 	add	r3, r3, r2
300397ac:	e1a03103 	lsl	r3, r3, #2
300397b0:	e0833000 	add	r3, r3, r0
300397b4:	e0833001 	add	r3, r3, r1
300397b8:	e5932000 	ldr	r2, [r3]
300397bc:	e59d3910 	ldr	r3, [sp, #2320]	; 0x910
300397c0:	e0633002 	rsb	r3, r3, r2
300397c4:	e58d3914 	str	r3, [sp, #2324]	; 0x914
         for (sb=0 ; sb < 2 ; sb++)
            for (ss=0 ; ss < SSLIMIT ; ss++) 
               ro[sb][ss] = xr[sb][ss];
            
         /* REORDERING FOR REST SWITCHED SHORT */
         for(sfb=3,sfb_start=sfBandIndex[sfreq].s[3],
300397c8:	ea000083 	b	300399dc <III_reorder+0x388>
            sfb_lines=sfBandIndex[sfreq].s[4] - sfb_start;
            sfb < 13; sfb++,sfb_start=sfBandIndex[sfreq].s[sfb],
            (sfb_lines=sfBandIndex[sfreq].s[sfb+1] - sfb_start))
               for(window=0; window<3; window++)
300397cc:	e3a03000 	mov	r3, #0
300397d0:	e58d3920 	str	r3, [sp, #2336]	; 0x920
300397d4:	ea000057 	b	30039938 <III_reorder+0x2e4>
                  for(freq=0;freq<sfb_lines;freq++) {
300397d8:	e3a03000 	mov	r3, #0
300397dc:	e58d3924 	str	r3, [sp, #2340]	; 0x924
300397e0:	ea00004d 	b	3003991c <III_reorder+0x2c8>
                     src_line = sfb_start*3 + window*sfb_lines + freq;
300397e4:	e59d2910 	ldr	r2, [sp, #2320]	; 0x910
300397e8:	e1a03002 	mov	r3, r2
300397ec:	e1a03083 	lsl	r3, r3, #1
300397f0:	e0832002 	add	r2, r3, r2
300397f4:	e59d3920 	ldr	r3, [sp, #2336]	; 0x920
300397f8:	e59d1914 	ldr	r1, [sp, #2324]	; 0x914
300397fc:	e0030391 	mul	r3, r1, r3
30039800:	e0822003 	add	r2, r2, r3
30039804:	e59d3924 	ldr	r3, [sp, #2340]	; 0x924
30039808:	e0823003 	add	r3, r2, r3
3003980c:	e58d3928 	str	r3, [sp, #2344]	; 0x928
                     des_line = (sfb_start*3) + window + (freq*3);
30039810:	e59d2910 	ldr	r2, [sp, #2320]	; 0x910
30039814:	e59d3924 	ldr	r3, [sp, #2340]	; 0x924
30039818:	e0822003 	add	r2, r2, r3
3003981c:	e1a03002 	mov	r3, r2
30039820:	e1a03083 	lsl	r3, r3, #1
30039824:	e0832002 	add	r2, r3, r2
30039828:	e59d3920 	ldr	r3, [sp, #2336]	; 0x920
3003982c:	e0823003 	add	r3, r2, r3
30039830:	e58d392c 	str	r3, [sp, #2348]	; 0x92c
                     ro[des_line/SSLIMIT][des_line%SSLIMIT] =
30039834:	e59d392c 	ldr	r3, [sp, #2348]	; 0x92c
30039838:	e59f24d0 	ldr	r2, [pc, #1232]	; 30039d10 <III_reorder+0x6bc>
3003983c:	e0c21293 	smull	r1, r2, r3, r2
30039840:	e1a02142 	asr	r2, r2, #2
30039844:	e1a03fc3 	asr	r3, r3, #31
30039848:	e063c002 	rsb	ip, r3, r2
3003984c:	e59d192c 	ldr	r1, [sp, #2348]	; 0x92c
30039850:	e59f34b8 	ldr	r3, [pc, #1208]	; 30039d10 <III_reorder+0x6bc>
30039854:	e0c32391 	smull	r2, r3, r1, r3
30039858:	e1a02143 	asr	r2, r3, #2
3003985c:	e1a03fc1 	asr	r3, r1, #31
30039860:	e0632002 	rsb	r2, r3, r2
30039864:	e1a03002 	mov	r3, r2
30039868:	e1a03183 	lsl	r3, r3, #3
3003986c:	e0833002 	add	r3, r3, r2
30039870:	e1a03083 	lsl	r3, r3, #1
30039874:	e0632001 	rsb	r2, r3, r1
                                    xr[src_line/SSLIMIT][src_line%SSLIMIT];
30039878:	e59d3928 	ldr	r3, [sp, #2344]	; 0x928
3003987c:	e59f148c 	ldr	r1, [pc, #1164]	; 30039d10 <III_reorder+0x6bc>
30039880:	e0c10193 	smull	r0, r1, r3, r1
30039884:	e1a01141 	asr	r1, r1, #2
30039888:	e1a03fc3 	asr	r3, r3, #31
3003988c:	e0633001 	rsb	r3, r3, r1
30039890:	e1a01003 	mov	r1, r3
30039894:	e1a03001 	mov	r3, r1
30039898:	e1a03183 	lsl	r3, r3, #3
3003989c:	e0833001 	add	r3, r3, r1
300398a0:	e1a03183 	lsl	r3, r3, #3
300398a4:	e1a01003 	mov	r1, r3
300398a8:	e59d3004 	ldr	r3, [sp, #4]
300398ac:	e0814003 	add	r4, r1, r3
300398b0:	e59d0928 	ldr	r0, [sp, #2344]	; 0x928
300398b4:	e59f3454 	ldr	r3, [pc, #1108]	; 30039d10 <III_reorder+0x6bc>
300398b8:	e0c31390 	smull	r1, r3, r0, r3
300398bc:	e1a01143 	asr	r1, r3, #2
300398c0:	e1a03fc0 	asr	r3, r0, #31
300398c4:	e0631001 	rsb	r1, r3, r1
300398c8:	e1a03001 	mov	r3, r1
300398cc:	e1a03183 	lsl	r3, r3, #3
300398d0:	e0833001 	add	r3, r3, r1
300398d4:	e1a03083 	lsl	r3, r3, #1
300398d8:	e0631000 	rsb	r1, r3, r0
300398dc:	e7941101 	ldr	r1, [r4, r1, lsl #2]
            (sfb_lines=sfBandIndex[sfreq].s[sfb+1] - sfb_start))
               for(window=0; window<3; window++)
                  for(freq=0;freq<sfb_lines;freq++) {
                     src_line = sfb_start*3 + window*sfb_lines + freq;
                     des_line = (sfb_start*3) + window + (freq*3);
                     ro[des_line/SSLIMIT][des_line%SSLIMIT] =
300398e0:	e1a0300c 	mov	r3, ip
300398e4:	e1a03183 	lsl	r3, r3, #3
300398e8:	e083300c 	add	r3, r3, ip
300398ec:	e1a03083 	lsl	r3, r3, #1
300398f0:	e0832002 	add	r2, r3, r2
300398f4:	e3e03e92 	mvn	r3, #2336	; 0x920
300398f8:	e2433007 	sub	r3, r3, #7
300398fc:	e1a02102 	lsl	r2, r2, #2
30039900:	e28dce93 	add	ip, sp, #2352	; 0x930
30039904:	e082200c 	add	r2, r2, ip
30039908:	e0823003 	add	r3, r2, r3
3003990c:	e5831000 	str	r1, [r3]
         for(sfb=3,sfb_start=sfBandIndex[sfreq].s[3],
            sfb_lines=sfBandIndex[sfreq].s[4] - sfb_start;
            sfb < 13; sfb++,sfb_start=sfBandIndex[sfreq].s[sfb],
            (sfb_lines=sfBandIndex[sfreq].s[sfb+1] - sfb_start))
               for(window=0; window<3; window++)
                  for(freq=0;freq<sfb_lines;freq++) {
30039910:	e59d3924 	ldr	r3, [sp, #2340]	; 0x924
30039914:	e2833001 	add	r3, r3, #1
30039918:	e58d3924 	str	r3, [sp, #2340]	; 0x924
3003991c:	e59d2924 	ldr	r2, [sp, #2340]	; 0x924
30039920:	e59d3914 	ldr	r3, [sp, #2324]	; 0x914
30039924:	e1520003 	cmp	r2, r3
30039928:	baffffad 	blt	300397e4 <III_reorder+0x190>
         /* REORDERING FOR REST SWITCHED SHORT */
         for(sfb=3,sfb_start=sfBandIndex[sfreq].s[3],
            sfb_lines=sfBandIndex[sfreq].s[4] - sfb_start;
            sfb < 13; sfb++,sfb_start=sfBandIndex[sfreq].s[sfb],
            (sfb_lines=sfBandIndex[sfreq].s[sfb+1] - sfb_start))
               for(window=0; window<3; window++)
3003992c:	e59d3920 	ldr	r3, [sp, #2336]	; 0x920
30039930:	e2833001 	add	r3, r3, #1
30039934:	e58d3920 	str	r3, [sp, #2336]	; 0x920
30039938:	e59d3920 	ldr	r3, [sp, #2336]	; 0x920
3003993c:	e3530002 	cmp	r3, #2
30039940:	daffffa4 	ble	300397d8 <III_reorder+0x184>
               ro[sb][ss] = xr[sb][ss];
            
         /* REORDERING FOR REST SWITCHED SHORT */
         for(sfb=3,sfb_start=sfBandIndex[sfreq].s[3],
            sfb_lines=sfBandIndex[sfreq].s[4] - sfb_start;
            sfb < 13; sfb++,sfb_start=sfBandIndex[sfreq].s[sfb],
30039944:	e59d390c 	ldr	r3, [sp, #2316]	; 0x90c
30039948:	e2833001 	add	r3, r3, #1
3003994c:	e58d390c 	str	r3, [sp, #2316]	; 0x90c
30039950:	e59d2908 	ldr	r2, [sp, #2312]	; 0x908
30039954:	e59d090c 	ldr	r0, [sp, #2316]	; 0x90c
30039958:	e59f13ac 	ldr	r1, [pc, #940]	; 30039d0c <III_reorder+0x6b8>
3003995c:	e1a03002 	mov	r3, r2
30039960:	e1a03183 	lsl	r3, r3, #3
30039964:	e0833002 	add	r3, r3, r2
30039968:	e1a03103 	lsl	r3, r3, #2
3003996c:	e0833002 	add	r3, r3, r2
30039970:	e0833000 	add	r3, r3, r0
30039974:	e2832016 	add	r2, r3, #22
30039978:	e3a03004 	mov	r3, #4
3003997c:	e1a02102 	lsl	r2, r2, #2
30039980:	e0822001 	add	r2, r2, r1
30039984:	e0823003 	add	r3, r2, r3
30039988:	e5933000 	ldr	r3, [r3]
3003998c:	e58d3910 	str	r3, [sp, #2320]	; 0x910
            (sfb_lines=sfBandIndex[sfreq].s[sfb+1] - sfb_start))
30039990:	e59d2908 	ldr	r2, [sp, #2312]	; 0x908
30039994:	e59d390c 	ldr	r3, [sp, #2316]	; 0x90c
30039998:	e2830001 	add	r0, r3, #1
3003999c:	e59f1368 	ldr	r1, [pc, #872]	; 30039d0c <III_reorder+0x6b8>
300399a0:	e1a03002 	mov	r3, r2
300399a4:	e1a03183 	lsl	r3, r3, #3
300399a8:	e0833002 	add	r3, r3, r2
300399ac:	e1a03103 	lsl	r3, r3, #2
300399b0:	e0833002 	add	r3, r3, r2
300399b4:	e0833000 	add	r3, r3, r0
300399b8:	e2832016 	add	r2, r3, #22
300399bc:	e3a03004 	mov	r3, #4
300399c0:	e1a02102 	lsl	r2, r2, #2
300399c4:	e0822001 	add	r2, r2, r1
300399c8:	e0823003 	add	r3, r2, r3
300399cc:	e5932000 	ldr	r2, [r3]
300399d0:	e59d3910 	ldr	r3, [sp, #2320]	; 0x910
300399d4:	e0633002 	rsb	r3, r3, r2
300399d8:	e58d3914 	str	r3, [sp, #2324]	; 0x914
         for (sb=0 ; sb < 2 ; sb++)
            for (ss=0 ; ss < SSLIMIT ; ss++) 
               ro[sb][ss] = xr[sb][ss];
            
         /* REORDERING FOR REST SWITCHED SHORT */
         for(sfb=3,sfb_start=sfBandIndex[sfreq].s[3],
300399dc:	e59d390c 	ldr	r3, [sp, #2316]	; 0x90c
300399e0:	e353000c 	cmp	r3, #12
300399e4:	daffff78 	ble	300397cc <III_reorder+0x178>
300399e8:	ea000098 	b	30039c50 <III_reorder+0x5fc>
                     ro[des_line/SSLIMIT][des_line%SSLIMIT] =
                                    xr[src_line/SSLIMIT][src_line%SSLIMIT];
               }
      }
      else {  /* pure short */
         for(sfb=0,sfb_start=0,sfb_lines=sfBandIndex[sfreq].s[1];
300399ec:	e3a03000 	mov	r3, #0
300399f0:	e58d390c 	str	r3, [sp, #2316]	; 0x90c
300399f4:	e3a03000 	mov	r3, #0
300399f8:	e58d3910 	str	r3, [sp, #2320]	; 0x910
300399fc:	e59d2908 	ldr	r2, [sp, #2312]	; 0x908
30039a00:	e59f0304 	ldr	r0, [pc, #772]	; 30039d0c <III_reorder+0x6b8>
30039a04:	e3a01060 	mov	r1, #96	; 0x60
30039a08:	e1a03002 	mov	r3, r2
30039a0c:	e1a03183 	lsl	r3, r3, #3
30039a10:	e0833002 	add	r3, r3, r2
30039a14:	e1a03103 	lsl	r3, r3, #2
30039a18:	e0833002 	add	r3, r3, r2
30039a1c:	e1a03103 	lsl	r3, r3, #2
30039a20:	e0833000 	add	r3, r3, r0
30039a24:	e0833001 	add	r3, r3, r1
30039a28:	e5933000 	ldr	r3, [r3]
30039a2c:	e58d3914 	str	r3, [sp, #2324]	; 0x914
30039a30:	ea000083 	b	30039c44 <III_reorder+0x5f0>
            sfb < 13; sfb++,sfb_start=sfBandIndex[sfreq].s[sfb],
            (sfb_lines=sfBandIndex[sfreq].s[sfb+1] - sfb_start))
               for(window=0; window<3; window++)
30039a34:	e3a03000 	mov	r3, #0
30039a38:	e58d3920 	str	r3, [sp, #2336]	; 0x920
30039a3c:	ea000057 	b	30039ba0 <III_reorder+0x54c>
                  for(freq=0;freq<sfb_lines;freq++) 
30039a40:	e3a03000 	mov	r3, #0
30039a44:	e58d3924 	str	r3, [sp, #2340]	; 0x924
30039a48:	ea00004d 	b	30039b84 <III_reorder+0x530>
				  {
                     src_line = sfb_start*3 + window*sfb_lines + freq;
30039a4c:	e59d2910 	ldr	r2, [sp, #2320]	; 0x910
30039a50:	e1a03002 	mov	r3, r2
30039a54:	e1a03083 	lsl	r3, r3, #1
30039a58:	e0832002 	add	r2, r3, r2
30039a5c:	e59d3920 	ldr	r3, [sp, #2336]	; 0x920
30039a60:	e59d1914 	ldr	r1, [sp, #2324]	; 0x914
30039a64:	e0030391 	mul	r3, r1, r3
30039a68:	e0822003 	add	r2, r2, r3
30039a6c:	e59d3924 	ldr	r3, [sp, #2340]	; 0x924
30039a70:	e0823003 	add	r3, r2, r3
30039a74:	e58d3928 	str	r3, [sp, #2344]	; 0x928
                     des_line = sfb_start*3 + window + (freq*3);
30039a78:	e59d2910 	ldr	r2, [sp, #2320]	; 0x910
30039a7c:	e59d3924 	ldr	r3, [sp, #2340]	; 0x924
30039a80:	e0822003 	add	r2, r2, r3
30039a84:	e1a03002 	mov	r3, r2
30039a88:	e1a03083 	lsl	r3, r3, #1
30039a8c:	e0832002 	add	r2, r3, r2
30039a90:	e59d3920 	ldr	r3, [sp, #2336]	; 0x920
30039a94:	e0823003 	add	r3, r2, r3
30039a98:	e58d392c 	str	r3, [sp, #2348]	; 0x92c
                     ro[des_line/SSLIMIT][des_line%SSLIMIT] =
30039a9c:	e59d392c 	ldr	r3, [sp, #2348]	; 0x92c
30039aa0:	e59f2268 	ldr	r2, [pc, #616]	; 30039d10 <III_reorder+0x6bc>
30039aa4:	e0c20293 	smull	r0, r2, r3, r2
30039aa8:	e1a02142 	asr	r2, r2, #2
30039aac:	e1a03fc3 	asr	r3, r3, #31
30039ab0:	e063c002 	rsb	ip, r3, r2
30039ab4:	e59d192c 	ldr	r1, [sp, #2348]	; 0x92c
30039ab8:	e59f3250 	ldr	r3, [pc, #592]	; 30039d10 <III_reorder+0x6bc>
30039abc:	e0c32391 	smull	r2, r3, r1, r3
30039ac0:	e1a02143 	asr	r2, r3, #2
30039ac4:	e1a03fc1 	asr	r3, r1, #31
30039ac8:	e0632002 	rsb	r2, r3, r2
30039acc:	e1a03002 	mov	r3, r2
30039ad0:	e1a03183 	lsl	r3, r3, #3
30039ad4:	e0833002 	add	r3, r3, r2
30039ad8:	e1a03083 	lsl	r3, r3, #1
30039adc:	e0632001 	rsb	r2, r3, r1
                                    xr[src_line/SSLIMIT][src_line%SSLIMIT];
30039ae0:	e59d3928 	ldr	r3, [sp, #2344]	; 0x928
30039ae4:	e59f1224 	ldr	r1, [pc, #548]	; 30039d10 <III_reorder+0x6bc>
30039ae8:	e0c10193 	smull	r0, r1, r3, r1
30039aec:	e1a01141 	asr	r1, r1, #2
30039af0:	e1a03fc3 	asr	r3, r3, #31
30039af4:	e0633001 	rsb	r3, r3, r1
30039af8:	e1a01003 	mov	r1, r3
30039afc:	e1a03001 	mov	r3, r1
30039b00:	e1a03183 	lsl	r3, r3, #3
30039b04:	e0833001 	add	r3, r3, r1
30039b08:	e1a03183 	lsl	r3, r3, #3
30039b0c:	e1a01003 	mov	r1, r3
30039b10:	e59d3004 	ldr	r3, [sp, #4]
30039b14:	e0814003 	add	r4, r1, r3
30039b18:	e59d0928 	ldr	r0, [sp, #2344]	; 0x928
30039b1c:	e59f31ec 	ldr	r3, [pc, #492]	; 30039d10 <III_reorder+0x6bc>
30039b20:	e0c31390 	smull	r1, r3, r0, r3
30039b24:	e1a01143 	asr	r1, r3, #2
30039b28:	e1a03fc0 	asr	r3, r0, #31
30039b2c:	e0631001 	rsb	r1, r3, r1
30039b30:	e1a03001 	mov	r3, r1
30039b34:	e1a03183 	lsl	r3, r3, #3
30039b38:	e0833001 	add	r3, r3, r1
30039b3c:	e1a03083 	lsl	r3, r3, #1
30039b40:	e0631000 	rsb	r1, r3, r0
30039b44:	e7941101 	ldr	r1, [r4, r1, lsl #2]
               for(window=0; window<3; window++)
                  for(freq=0;freq<sfb_lines;freq++) 
				  {
                     src_line = sfb_start*3 + window*sfb_lines + freq;
                     des_line = sfb_start*3 + window + (freq*3);
                     ro[des_line/SSLIMIT][des_line%SSLIMIT] =
30039b48:	e1a0300c 	mov	r3, ip
30039b4c:	e1a03183 	lsl	r3, r3, #3
30039b50:	e083300c 	add	r3, r3, ip
30039b54:	e1a03083 	lsl	r3, r3, #1
30039b58:	e0832002 	add	r2, r3, r2
30039b5c:	e3e03e92 	mvn	r3, #2336	; 0x920
30039b60:	e2433007 	sub	r3, r3, #7
30039b64:	e1a02102 	lsl	r2, r2, #2
30039b68:	e28dce93 	add	ip, sp, #2352	; 0x930
30039b6c:	e082200c 	add	r2, r2, ip
30039b70:	e0823003 	add	r3, r2, r3
30039b74:	e5831000 	str	r1, [r3]
      else {  /* pure short */
         for(sfb=0,sfb_start=0,sfb_lines=sfBandIndex[sfreq].s[1];
            sfb < 13; sfb++,sfb_start=sfBandIndex[sfreq].s[sfb],
            (sfb_lines=sfBandIndex[sfreq].s[sfb+1] - sfb_start))
               for(window=0; window<3; window++)
                  for(freq=0;freq<sfb_lines;freq++) 
30039b78:	e59d3924 	ldr	r3, [sp, #2340]	; 0x924
30039b7c:	e2833001 	add	r3, r3, #1
30039b80:	e58d3924 	str	r3, [sp, #2340]	; 0x924
30039b84:	e59d2924 	ldr	r2, [sp, #2340]	; 0x924
30039b88:	e59d3914 	ldr	r3, [sp, #2324]	; 0x914
30039b8c:	e1520003 	cmp	r2, r3
30039b90:	baffffad 	blt	30039a4c <III_reorder+0x3f8>
      }
      else {  /* pure short */
         for(sfb=0,sfb_start=0,sfb_lines=sfBandIndex[sfreq].s[1];
            sfb < 13; sfb++,sfb_start=sfBandIndex[sfreq].s[sfb],
            (sfb_lines=sfBandIndex[sfreq].s[sfb+1] - sfb_start))
               for(window=0; window<3; window++)
30039b94:	e59d3920 	ldr	r3, [sp, #2336]	; 0x920
30039b98:	e2833001 	add	r3, r3, #1
30039b9c:	e58d3920 	str	r3, [sp, #2336]	; 0x920
30039ba0:	e59d3920 	ldr	r3, [sp, #2336]	; 0x920
30039ba4:	e3530002 	cmp	r3, #2
30039ba8:	daffffa4 	ble	30039a40 <III_reorder+0x3ec>
                                    xr[src_line/SSLIMIT][src_line%SSLIMIT];
               }
      }
      else {  /* pure short */
         for(sfb=0,sfb_start=0,sfb_lines=sfBandIndex[sfreq].s[1];
            sfb < 13; sfb++,sfb_start=sfBandIndex[sfreq].s[sfb],
30039bac:	e59d390c 	ldr	r3, [sp, #2316]	; 0x90c
30039bb0:	e2833001 	add	r3, r3, #1
30039bb4:	e58d390c 	str	r3, [sp, #2316]	; 0x90c
30039bb8:	e59d2908 	ldr	r2, [sp, #2312]	; 0x908
30039bbc:	e59d090c 	ldr	r0, [sp, #2316]	; 0x90c
30039bc0:	e59f1144 	ldr	r1, [pc, #324]	; 30039d0c <III_reorder+0x6b8>
30039bc4:	e1a03002 	mov	r3, r2
30039bc8:	e1a03183 	lsl	r3, r3, #3
30039bcc:	e0833002 	add	r3, r3, r2
30039bd0:	e1a03103 	lsl	r3, r3, #2
30039bd4:	e0833002 	add	r3, r3, r2
30039bd8:	e0833000 	add	r3, r3, r0
30039bdc:	e2832016 	add	r2, r3, #22
30039be0:	e3a03004 	mov	r3, #4
30039be4:	e1a02102 	lsl	r2, r2, #2
30039be8:	e0822001 	add	r2, r2, r1
30039bec:	e0823003 	add	r3, r2, r3
30039bf0:	e5933000 	ldr	r3, [r3]
30039bf4:	e58d3910 	str	r3, [sp, #2320]	; 0x910
            (sfb_lines=sfBandIndex[sfreq].s[sfb+1] - sfb_start))
30039bf8:	e59d2908 	ldr	r2, [sp, #2312]	; 0x908
30039bfc:	e59d390c 	ldr	r3, [sp, #2316]	; 0x90c
30039c00:	e2830001 	add	r0, r3, #1
30039c04:	e59f1100 	ldr	r1, [pc, #256]	; 30039d0c <III_reorder+0x6b8>
30039c08:	e1a03002 	mov	r3, r2
30039c0c:	e1a03183 	lsl	r3, r3, #3
30039c10:	e0833002 	add	r3, r3, r2
30039c14:	e1a03103 	lsl	r3, r3, #2
30039c18:	e0833002 	add	r3, r3, r2
30039c1c:	e0833000 	add	r3, r3, r0
30039c20:	e2832016 	add	r2, r3, #22
30039c24:	e3a03004 	mov	r3, #4
30039c28:	e1a02102 	lsl	r2, r2, #2
30039c2c:	e0822001 	add	r2, r2, r1
30039c30:	e0823003 	add	r3, r2, r3
30039c34:	e5932000 	ldr	r2, [r3]
30039c38:	e59d3910 	ldr	r3, [sp, #2320]	; 0x910
30039c3c:	e0633002 	rsb	r3, r3, r2
30039c40:	e58d3914 	str	r3, [sp, #2324]	; 0x914
                     ro[des_line/SSLIMIT][des_line%SSLIMIT] =
                                    xr[src_line/SSLIMIT][src_line%SSLIMIT];
               }
      }
      else {  /* pure short */
         for(sfb=0,sfb_start=0,sfb_lines=sfBandIndex[sfreq].s[1];
30039c44:	e59d390c 	ldr	r3, [sp, #2316]	; 0x90c
30039c48:	e353000c 	cmp	r3, #12
30039c4c:	daffff78 	ble	30039a34 <III_reorder+0x3e0>
                     des_line = sfb_start*3 + window + (freq*3);
                     ro[des_line/SSLIMIT][des_line%SSLIMIT] =
                                    xr[src_line/SSLIMIT][src_line%SSLIMIT];
				  }
      }
      for (sb=0 ; sb < SBLIMIT ; sb++)
30039c50:	e3a03000 	mov	r3, #0
30039c54:	e58d3918 	str	r3, [sp, #2328]	; 0x918
30039c58:	ea000023 	b	30039cec <III_reorder+0x698>
         for (ss=0 ; ss < SSLIMIT ; ss++)
30039c5c:	e3a03000 	mov	r3, #0
30039c60:	e58d391c 	str	r3, [sp, #2332]	; 0x91c
30039c64:	ea00001a 	b	30039cd4 <III_reorder+0x680>
            xr[sb][ss] = ro[sb][ss];
30039c68:	e59d2918 	ldr	r2, [sp, #2328]	; 0x918
30039c6c:	e1a03002 	mov	r3, r2
30039c70:	e1a03183 	lsl	r3, r3, #3
30039c74:	e0833002 	add	r3, r3, r2
30039c78:	e1a03183 	lsl	r3, r3, #3
30039c7c:	e1a02003 	mov	r2, r3
30039c80:	e59d3004 	ldr	r3, [sp, #4]
30039c84:	e0821003 	add	r1, r2, r3
30039c88:	e59d091c 	ldr	r0, [sp, #2332]	; 0x91c
30039c8c:	e59d2918 	ldr	r2, [sp, #2328]	; 0x918
30039c90:	e59dc91c 	ldr	ip, [sp, #2332]	; 0x91c
30039c94:	e1a03002 	mov	r3, r2
30039c98:	e1a03183 	lsl	r3, r3, #3
30039c9c:	e0833002 	add	r3, r3, r2
30039ca0:	e1a03083 	lsl	r3, r3, #1
30039ca4:	e083200c 	add	r2, r3, ip
30039ca8:	e3e03e92 	mvn	r3, #2336	; 0x920
30039cac:	e2433007 	sub	r3, r3, #7
30039cb0:	e1a02102 	lsl	r2, r2, #2
30039cb4:	e28dce93 	add	ip, sp, #2352	; 0x930
30039cb8:	e082200c 	add	r2, r2, ip
30039cbc:	e0823003 	add	r3, r2, r3
30039cc0:	e5933000 	ldr	r3, [r3]
30039cc4:	e7813100 	str	r3, [r1, r0, lsl #2]
                     ro[des_line/SSLIMIT][des_line%SSLIMIT] =
                                    xr[src_line/SSLIMIT][src_line%SSLIMIT];
				  }
      }
      for (sb=0 ; sb < SBLIMIT ; sb++)
         for (ss=0 ; ss < SSLIMIT ; ss++)
30039cc8:	e59d391c 	ldr	r3, [sp, #2332]	; 0x91c
30039ccc:	e2833001 	add	r3, r3, #1
30039cd0:	e58d391c 	str	r3, [sp, #2332]	; 0x91c
30039cd4:	e59d391c 	ldr	r3, [sp, #2332]	; 0x91c
30039cd8:	e3530011 	cmp	r3, #17
30039cdc:	daffffe1 	ble	30039c68 <III_reorder+0x614>
                     des_line = sfb_start*3 + window + (freq*3);
                     ro[des_line/SSLIMIT][des_line%SSLIMIT] =
                                    xr[src_line/SSLIMIT][src_line%SSLIMIT];
				  }
      }
      for (sb=0 ; sb < SBLIMIT ; sb++)
30039ce0:	e59d3918 	ldr	r3, [sp, #2328]	; 0x918
30039ce4:	e2833001 	add	r3, r3, #1
30039ce8:	e58d3918 	str	r3, [sp, #2328]	; 0x918
30039cec:	e59d3918 	ldr	r3, [sp, #2328]	; 0x918
30039cf0:	e353001f 	cmp	r3, #31
30039cf4:	daffffd8 	ble	30039c5c <III_reorder+0x608>
         for (ss=0 ; ss < SSLIMIT ; ss++)
            xr[sb][ss] = ro[sb][ss];

   }
}
30039cf8:	e28ddf4d 	add	sp, sp, #308	; 0x134
30039cfc:	e28ddb02 	add	sp, sp, #2048	; 0x800
30039d00:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
30039d04:	e12fff1e 	bx	lr
30039d08:	302be81c 	.word	0x302be81c
30039d0c:	300c7eb4 	.word	0x300c7eb4
30039d10:	38e38e39 	.word	0x38e38e39

30039d14 <III_stereo>:
 


void III_stereo(int xr[2][SBLIMIT][SSLIMIT],III_scalefac_t *scalefac, struct Granule *gr_info)  //change here ！
{
30039d14:	e92d40f0 	push	{r4, r5, r6, r7, lr}
30039d18:	e24ddd49 	sub	sp, sp, #4672	; 0x1240
30039d1c:	e24dd01c 	sub	sp, sp, #28
30039d20:	e3e03d49 	mvn	r3, #4672	; 0x1240
30039d24:	e243300b 	sub	r3, r3, #11
30039d28:	e28d4d49 	add	r4, sp, #4672	; 0x1240
30039d2c:	e2844018 	add	r4, r4, #24
30039d30:	e7840003 	str	r0, [r4, r3]
30039d34:	e3e03d49 	mvn	r3, #4672	; 0x1240
30039d38:	e243300f 	sub	r3, r3, #15
30039d3c:	e28dcd49 	add	ip, sp, #4672	; 0x1240
30039d40:	e28cc018 	add	ip, ip, #24
30039d44:	e78c1003 	str	r1, [ip, r3]
30039d48:	e3e03d49 	mvn	r3, #4672	; 0x1240
30039d4c:	e2433013 	sub	r3, r3, #19
30039d50:	e28d0d49 	add	r0, sp, #4672	; 0x1240
30039d54:	e2800018 	add	r0, r0, #24
30039d58:	e7802003 	str	r2, [r0, r3]
   int sfreq = fr_ps.header->sampling_frequency;
30039d5c:	e59f39dc 	ldr	r3, [pc, #2524]	; 3003a740 <III_stereo+0xa2c>
30039d60:	e5933000 	ldr	r3, [r3]
30039d64:	e5933010 	ldr	r3, [r3, #16]
30039d68:	e28d1a01 	add	r1, sp, #4096	; 0x1000
30039d6c:	e5813210 	str	r3, [r1, #528]	; 0x210
   int stereo = fr_ps.stereo;
30039d70:	e59f39c8 	ldr	r3, [pc, #2504]	; 3003a740 <III_stereo+0xa2c>
30039d74:	e5933008 	ldr	r3, [r3, #8]
30039d78:	e28d2a01 	add	r2, sp, #4096	; 0x1000
30039d7c:	e5823214 	str	r3, [r2, #532]	; 0x214
   int ms_stereo = (fr_ps.header->mode == MPG_MD_JOINT_STEREO) &&
30039d80:	e59f39b8 	ldr	r3, [pc, #2488]	; 3003a740 <III_stereo+0xa2c>
30039d84:	e5933000 	ldr	r3, [r3]
30039d88:	e593301c 	ldr	r3, [r3, #28]
30039d8c:	e3530001 	cmp	r3, #1
30039d90:	1a000007 	bne	30039db4 <III_stereo+0xa0>
                   (fr_ps.header->mode_ext & 0x2);
30039d94:	e59f39a4 	ldr	r3, [pc, #2468]	; 3003a740 <III_stereo+0xa2c>
30039d98:	e5933000 	ldr	r3, [r3]
30039d9c:	e5933020 	ldr	r3, [r3, #32]
30039da0:	e2033002 	and	r3, r3, #2

void III_stereo(int xr[2][SBLIMIT][SSLIMIT],III_scalefac_t *scalefac, struct Granule *gr_info)  //change here ！
{
   int sfreq = fr_ps.header->sampling_frequency;
   int stereo = fr_ps.stereo;
   int ms_stereo = (fr_ps.header->mode == MPG_MD_JOINT_STEREO) &&
30039da4:	e3530000 	cmp	r3, #0
30039da8:	0a000001 	beq	30039db4 <III_stereo+0xa0>
30039dac:	e3a03001 	mov	r3, #1
30039db0:	ea000000 	b	30039db8 <III_stereo+0xa4>
30039db4:	e3a03000 	mov	r3, #0
                   (fr_ps.header->mode_ext & 0x2);
30039db8:	e28d4a01 	add	r4, sp, #4096	; 0x1000
30039dbc:	e5843218 	str	r3, [r4, #536]	; 0x218
   int i_stereo = (fr_ps.header->mode == MPG_MD_JOINT_STEREO) &&
30039dc0:	e59f3978 	ldr	r3, [pc, #2424]	; 3003a740 <III_stereo+0xa2c>
30039dc4:	e5933000 	ldr	r3, [r3]
30039dc8:	e593301c 	ldr	r3, [r3, #28]
30039dcc:	e3530001 	cmp	r3, #1
30039dd0:	1a000008 	bne	30039df8 <III_stereo+0xe4>
                  (fr_ps.header->mode_ext & 0x1);
30039dd4:	e59f3964 	ldr	r3, [pc, #2404]	; 3003a740 <III_stereo+0xa2c>
30039dd8:	e5933000 	ldr	r3, [r3]
30039ddc:	e5933020 	ldr	r3, [r3, #32]
30039de0:	e2033001 	and	r3, r3, #1
{
   int sfreq = fr_ps.header->sampling_frequency;
   int stereo = fr_ps.stereo;
   int ms_stereo = (fr_ps.header->mode == MPG_MD_JOINT_STEREO) &&
                   (fr_ps.header->mode_ext & 0x2);
   int i_stereo = (fr_ps.header->mode == MPG_MD_JOINT_STEREO) &&
30039de4:	e20330ff 	and	r3, r3, #255	; 0xff
30039de8:	e3530000 	cmp	r3, #0
30039dec:	0a000001 	beq	30039df8 <III_stereo+0xe4>
30039df0:	e3a03001 	mov	r3, #1
30039df4:	ea000000 	b	30039dfc <III_stereo+0xe8>
30039df8:	e3a03000 	mov	r3, #0
                  (fr_ps.header->mode_ext & 0x1);
30039dfc:	e28dca01 	add	ip, sp, #4096	; 0x1000
30039e00:	e58c321c 	str	r3, [ip, #540]	; 0x21c
   int sfb;
   int i,j,sb,ss,is_pos[576];
   int is_ratio[576];

   /* intialization */
   for ( i=0; i<576; i++ )
30039e04:	e3a03000 	mov	r3, #0
30039e08:	e28d0a01 	add	r0, sp, #4096	; 0x1000
30039e0c:	e5803224 	str	r3, [r0, #548]	; 0x224
30039e10:	ea00000f 	b	30039e54 <III_stereo+0x140>
      is_pos[i] = 7;
30039e14:	e28d1a01 	add	r1, sp, #4096	; 0x1000
30039e18:	e5912224 	ldr	r2, [r1, #548]	; 0x224
30039e1c:	e3e03d25 	mvn	r3, #2368	; 0x940
30039e20:	e2433007 	sub	r3, r3, #7
30039e24:	e1a02102 	lsl	r2, r2, #2
30039e28:	e28d4d49 	add	r4, sp, #4672	; 0x1240
30039e2c:	e2844018 	add	r4, r4, #24
30039e30:	e0822004 	add	r2, r2, r4
30039e34:	e0823003 	add	r3, r2, r3
30039e38:	e3a02007 	mov	r2, #7
30039e3c:	e5832000 	str	r2, [r3]
   int sfb;
   int i,j,sb,ss,is_pos[576];
   int is_ratio[576];

   /* intialization */
   for ( i=0; i<576; i++ )
30039e40:	e28dca01 	add	ip, sp, #4096	; 0x1000
30039e44:	e59c3224 	ldr	r3, [ip, #548]	; 0x224
30039e48:	e2833001 	add	r3, r3, #1
30039e4c:	e28d0a01 	add	r0, sp, #4096	; 0x1000
30039e50:	e5803224 	str	r3, [r0, #548]	; 0x224
30039e54:	e28d1a01 	add	r1, sp, #4096	; 0x1000
30039e58:	e5912224 	ldr	r2, [r1, #548]	; 0x224
30039e5c:	e3a03f8f 	mov	r3, #572	; 0x23c
30039e60:	e2833003 	add	r3, r3, #3
30039e64:	e1520003 	cmp	r2, r3
30039e68:	daffffe9 	ble	30039e14 <III_stereo+0x100>
      is_pos[i] = 7;

   if ((stereo == 2) && i_stereo )
30039e6c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
30039e70:	e5923214 	ldr	r3, [r2, #532]	; 0x214
30039e74:	e3530002 	cmp	r3, #2
30039e78:	1a000661 	bne	3003b804 <III_stereo+0x1af0>
30039e7c:	e28d4a01 	add	r4, sp, #4096	; 0x1000
30039e80:	e594321c 	ldr	r3, [r4, #540]	; 0x21c
30039e84:	e3530000 	cmp	r3, #0
30039e88:	0a00065d 	beq	3003b804 <III_stereo+0x1af0>
   {  if (gr_info->window_switching_flag && (gr_info->block_type == 2))
30039e8c:	e3e03d49 	mvn	r3, #4672	; 0x1240
30039e90:	e2433013 	sub	r3, r3, #19
30039e94:	e28dcd49 	add	ip, sp, #4672	; 0x1240
30039e98:	e28cc018 	add	ip, ip, #24
30039e9c:	e79c3003 	ldr	r3, [ip, r3]
30039ea0:	e5933010 	ldr	r3, [r3, #16]
30039ea4:	e3530000 	cmp	r3, #0
30039ea8:	0a00050a 	beq	3003b2d8 <III_stereo+0x15c4>
30039eac:	e3e03d49 	mvn	r3, #4672	; 0x1240
30039eb0:	e2433013 	sub	r3, r3, #19
30039eb4:	e28d0d49 	add	r0, sp, #4672	; 0x1240
30039eb8:	e2800018 	add	r0, r0, #24
30039ebc:	e7903003 	ldr	r3, [r0, r3]
30039ec0:	e5933014 	ldr	r3, [r3, #20]
30039ec4:	e3530002 	cmp	r3, #2
30039ec8:	1a000502 	bne	3003b2d8 <III_stereo+0x15c4>
      {  if( gr_info->mixed_block_flag )
30039ecc:	e3e03d49 	mvn	r3, #4672	; 0x1240
30039ed0:	e2433013 	sub	r3, r3, #19
30039ed4:	e28d1d49 	add	r1, sp, #4672	; 0x1240
30039ed8:	e2811018 	add	r1, r1, #24
30039edc:	e7913003 	ldr	r3, [r1, r3]
30039ee0:	e5933018 	ldr	r3, [r3, #24]
30039ee4:	e3530000 	cmp	r3, #0
30039ee8:	0a0002fe 	beq	3003aae8 <III_stereo+0xdd4>
         {  int max_sfb = 0;
30039eec:	e3a03000 	mov	r3, #0
30039ef0:	e28d2a01 	add	r2, sp, #4096	; 0x1000
30039ef4:	e5823234 	str	r3, [r2, #564]	; 0x234

            for ( j=0; j<3; j++ )
30039ef8:	e3a03000 	mov	r3, #0
30039efc:	e28d4a01 	add	r4, sp, #4096	; 0x1000
30039f00:	e5843228 	str	r3, [r4, #552]	; 0x228
30039f04:	ea0001f8 	b	3003a6ec <III_stereo+0x9d8>
            {  int sfbcnt;
               sfbcnt = 2;
30039f08:	e3a03002 	mov	r3, #2
30039f0c:	e28dca01 	add	ip, sp, #4096	; 0x1000
30039f10:	e58c3238 	str	r3, [ip, #568]	; 0x238
               for( sfb=12; sfb >=3; sfb-- )
30039f14:	e3a0300c 	mov	r3, #12
30039f18:	e28d0a01 	add	r0, sp, #4096	; 0x1000
30039f1c:	e5803220 	str	r3, [r0, #544]	; 0x220
30039f20:	ea000082 	b	3003a130 <III_stereo+0x41c>
               {  int lines;
                  lines = sfBandIndex[sfreq].s[sfb+1]-sfBandIndex[sfreq].s[sfb];
30039f24:	e28d1a01 	add	r1, sp, #4096	; 0x1000
30039f28:	e5912210 	ldr	r2, [r1, #528]	; 0x210
30039f2c:	e28d4a01 	add	r4, sp, #4096	; 0x1000
30039f30:	e5943220 	ldr	r3, [r4, #544]	; 0x220
30039f34:	e2830001 	add	r0, r3, #1
30039f38:	e59f1808 	ldr	r1, [pc, #2056]	; 3003a748 <III_stereo+0xa34>
30039f3c:	e1a03002 	mov	r3, r2
30039f40:	e1a03183 	lsl	r3, r3, #3
30039f44:	e0833002 	add	r3, r3, r2
30039f48:	e1a03103 	lsl	r3, r3, #2
30039f4c:	e0833002 	add	r3, r3, r2
30039f50:	e0833000 	add	r3, r3, r0
30039f54:	e2832016 	add	r2, r3, #22
30039f58:	e3a03004 	mov	r3, #4
30039f5c:	e1a02102 	lsl	r2, r2, #2
30039f60:	e0822001 	add	r2, r2, r1
30039f64:	e0823003 	add	r3, r2, r3
30039f68:	e5931000 	ldr	r1, [r3]
30039f6c:	e28dca01 	add	ip, sp, #4096	; 0x1000
30039f70:	e59c2210 	ldr	r2, [ip, #528]	; 0x210
30039f74:	e28d0a01 	add	r0, sp, #4096	; 0x1000
30039f78:	e590c220 	ldr	ip, [r0, #544]	; 0x220
30039f7c:	e59f07c4 	ldr	r0, [pc, #1988]	; 3003a748 <III_stereo+0xa34>
30039f80:	e1a03002 	mov	r3, r2
30039f84:	e1a03183 	lsl	r3, r3, #3
30039f88:	e0833002 	add	r3, r3, r2
30039f8c:	e1a03103 	lsl	r3, r3, #2
30039f90:	e0833002 	add	r3, r3, r2
30039f94:	e083300c 	add	r3, r3, ip
30039f98:	e2832016 	add	r2, r3, #22
30039f9c:	e3a03004 	mov	r3, #4
30039fa0:	e1a02102 	lsl	r2, r2, #2
30039fa4:	e0822000 	add	r2, r2, r0
30039fa8:	e0823003 	add	r3, r2, r3
30039fac:	e5933000 	ldr	r3, [r3]
30039fb0:	e0633001 	rsb	r3, r3, r1
30039fb4:	e28d1a01 	add	r1, sp, #4096	; 0x1000
30039fb8:	e581323c 	str	r3, [r1, #572]	; 0x23c
                  i = 3*sfBandIndex[sfreq].s[sfb] + (j+1) * lines - 1;
30039fbc:	e28d3a01 	add	r3, sp, #4096	; 0x1000
30039fc0:	e5932210 	ldr	r2, [r3, #528]	; 0x210
30039fc4:	e28d4a01 	add	r4, sp, #4096	; 0x1000
30039fc8:	e5940220 	ldr	r0, [r4, #544]	; 0x220
30039fcc:	e59f1774 	ldr	r1, [pc, #1908]	; 3003a748 <III_stereo+0xa34>
30039fd0:	e1a03002 	mov	r3, r2
30039fd4:	e1a03183 	lsl	r3, r3, #3
30039fd8:	e0833002 	add	r3, r3, r2
30039fdc:	e1a03103 	lsl	r3, r3, #2
30039fe0:	e0833002 	add	r3, r3, r2
30039fe4:	e0833000 	add	r3, r3, r0
30039fe8:	e2832016 	add	r2, r3, #22
30039fec:	e3a03004 	mov	r3, #4
30039ff0:	e1a02102 	lsl	r2, r2, #2
30039ff4:	e0822001 	add	r2, r2, r1
30039ff8:	e0823003 	add	r3, r2, r3
30039ffc:	e5932000 	ldr	r2, [r3]
3003a000:	e1a03002 	mov	r3, r2
3003a004:	e1a03083 	lsl	r3, r3, #1
3003a008:	e0832002 	add	r2, r3, r2
3003a00c:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a010:	e59c3228 	ldr	r3, [ip, #552]	; 0x228
3003a014:	e2833001 	add	r3, r3, #1
3003a018:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a01c:	e590123c 	ldr	r1, [r0, #572]	; 0x23c
3003a020:	e0030391 	mul	r3, r1, r3
3003a024:	e0823003 	add	r3, r2, r3
3003a028:	e2433001 	sub	r3, r3, #1
3003a02c:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a030:	e5813224 	str	r3, [r1, #548]	; 0x224
                  while ( lines > 0 )
3003a034:	ea000034 	b	3003a10c <III_stereo+0x3f8>
                  {  if ( xr[1][i/SSLIMIT][i%SSLIMIT] != 0)
3003a038:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003a03c:	e243300b 	sub	r3, r3, #11
3003a040:	e28d2d49 	add	r2, sp, #4672	; 0x1240
3003a044:	e2822018 	add	r2, r2, #24
3003a048:	e7923003 	ldr	r3, [r2, r3]
3003a04c:	e283cc09 	add	ip, r3, #2304	; 0x900
3003a050:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a054:	e5943224 	ldr	r3, [r4, #548]	; 0x224
3003a058:	e59f26e4 	ldr	r2, [pc, #1764]	; 3003a744 <III_stereo+0xa30>
3003a05c:	e0c20293 	smull	r0, r2, r3, r2
3003a060:	e1a02142 	asr	r2, r2, #2
3003a064:	e1a03fc3 	asr	r3, r3, #31
3003a068:	e0630002 	rsb	r0, r3, r2
3003a06c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003a070:	e5921224 	ldr	r1, [r2, #548]	; 0x224
3003a074:	e59f36c8 	ldr	r3, [pc, #1736]	; 3003a744 <III_stereo+0xa30>
3003a078:	e0c34391 	smull	r4, r3, r1, r3
3003a07c:	e1a02143 	asr	r2, r3, #2
3003a080:	e1a03fc1 	asr	r3, r1, #31
3003a084:	e0632002 	rsb	r2, r3, r2
3003a088:	e1a03002 	mov	r3, r2
3003a08c:	e1a03183 	lsl	r3, r3, #3
3003a090:	e0833002 	add	r3, r3, r2
3003a094:	e1a03083 	lsl	r3, r3, #1
3003a098:	e0632001 	rsb	r2, r3, r1
3003a09c:	e1a03000 	mov	r3, r0
3003a0a0:	e1a03183 	lsl	r3, r3, #3
3003a0a4:	e0833000 	add	r3, r3, r0
3003a0a8:	e1a03083 	lsl	r3, r3, #1
3003a0ac:	e0833002 	add	r3, r3, r2
3003a0b0:	e79c3103 	ldr	r3, [ip, r3, lsl #2]
3003a0b4:	e3530000 	cmp	r3, #0
3003a0b8:	0a000009 	beq	3003a0e4 <III_stereo+0x3d0>
                     {  sfbcnt = sfb;
3003a0bc:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a0c0:	e59c3220 	ldr	r3, [ip, #544]	; 0x220
3003a0c4:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a0c8:	e5803238 	str	r3, [r0, #568]	; 0x238
                        sfb = -10;
3003a0cc:	e3e03009 	mvn	r3, #9
3003a0d0:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a0d4:	e5813220 	str	r3, [r1, #544]	; 0x220
                        lines = -10;
3003a0d8:	e3e03009 	mvn	r3, #9
3003a0dc:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003a0e0:	e582323c 	str	r3, [r2, #572]	; 0x23c
                     }
                     lines--;
3003a0e4:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a0e8:	e594323c 	ldr	r3, [r4, #572]	; 0x23c
3003a0ec:	e2433001 	sub	r3, r3, #1
3003a0f0:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a0f4:	e58c323c 	str	r3, [ip, #572]	; 0x23c
                     i--;
3003a0f8:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a0fc:	e5903224 	ldr	r3, [r0, #548]	; 0x224
3003a100:	e2433001 	sub	r3, r3, #1
3003a104:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a108:	e5813224 	str	r3, [r1, #548]	; 0x224
               sfbcnt = 2;
               for( sfb=12; sfb >=3; sfb-- )
               {  int lines;
                  lines = sfBandIndex[sfreq].s[sfb+1]-sfBandIndex[sfreq].s[sfb];
                  i = 3*sfBandIndex[sfreq].s[sfb] + (j+1) * lines - 1;
                  while ( lines > 0 )
3003a10c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003a110:	e592323c 	ldr	r3, [r2, #572]	; 0x23c
3003a114:	e3530000 	cmp	r3, #0
3003a118:	caffffc6 	bgt	3003a038 <III_stereo+0x324>
         {  int max_sfb = 0;

            for ( j=0; j<3; j++ )
            {  int sfbcnt;
               sfbcnt = 2;
               for( sfb=12; sfb >=3; sfb-- )
3003a11c:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a120:	e5943220 	ldr	r3, [r4, #544]	; 0x220
3003a124:	e2433001 	sub	r3, r3, #1
3003a128:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a12c:	e58c3220 	str	r3, [ip, #544]	; 0x220
3003a130:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a134:	e5903220 	ldr	r3, [r0, #544]	; 0x220
3003a138:	e3530002 	cmp	r3, #2
3003a13c:	caffff78 	bgt	30039f24 <III_stereo+0x210>
                     }
                     lines--;
                     i--;
                  }
               }
               sfb = sfbcnt + 1;
3003a140:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a144:	e5913238 	ldr	r3, [r1, #568]	; 0x238
3003a148:	e2833001 	add	r3, r3, #1
3003a14c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003a150:	e5823220 	str	r3, [r2, #544]	; 0x220

               if ( sfb > max_sfb )
3003a154:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003a158:	e5932220 	ldr	r2, [r3, #544]	; 0x220
3003a15c:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a160:	e5943234 	ldr	r3, [r4, #564]	; 0x234
3003a164:	e1520003 	cmp	r2, r3
3003a168:	da0000b5 	ble	3003a444 <III_stereo+0x730>
                  max_sfb = sfb;
3003a16c:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a170:	e59c3220 	ldr	r3, [ip, #544]	; 0x220
3003a174:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a178:	e5803234 	str	r3, [r0, #564]	; 0x234

               while( sfb<12 )
3003a17c:	ea0000b0 	b	3003a444 <III_stereo+0x730>
               {  sb = sfBandIndex[sfreq].s[sfb+1]-sfBandIndex[sfreq].s[sfb];
3003a180:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a184:	e5912210 	ldr	r2, [r1, #528]	; 0x210
3003a188:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a18c:	e5943220 	ldr	r3, [r4, #544]	; 0x220
3003a190:	e2830001 	add	r0, r3, #1
3003a194:	e59f15ac 	ldr	r1, [pc, #1452]	; 3003a748 <III_stereo+0xa34>
3003a198:	e1a03002 	mov	r3, r2
3003a19c:	e1a03183 	lsl	r3, r3, #3
3003a1a0:	e0833002 	add	r3, r3, r2
3003a1a4:	e1a03103 	lsl	r3, r3, #2
3003a1a8:	e0833002 	add	r3, r3, r2
3003a1ac:	e0833000 	add	r3, r3, r0
3003a1b0:	e2832016 	add	r2, r3, #22
3003a1b4:	e3a03004 	mov	r3, #4
3003a1b8:	e1a02102 	lsl	r2, r2, #2
3003a1bc:	e0822001 	add	r2, r2, r1
3003a1c0:	e0823003 	add	r3, r2, r3
3003a1c4:	e5931000 	ldr	r1, [r3]
3003a1c8:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a1cc:	e59c2210 	ldr	r2, [ip, #528]	; 0x210
3003a1d0:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a1d4:	e590c220 	ldr	ip, [r0, #544]	; 0x220
3003a1d8:	e59f0568 	ldr	r0, [pc, #1384]	; 3003a748 <III_stereo+0xa34>
3003a1dc:	e1a03002 	mov	r3, r2
3003a1e0:	e1a03183 	lsl	r3, r3, #3
3003a1e4:	e0833002 	add	r3, r3, r2
3003a1e8:	e1a03103 	lsl	r3, r3, #2
3003a1ec:	e0833002 	add	r3, r3, r2
3003a1f0:	e083300c 	add	r3, r3, ip
3003a1f4:	e2832016 	add	r2, r3, #22
3003a1f8:	e3a03004 	mov	r3, #4
3003a1fc:	e1a02102 	lsl	r2, r2, #2
3003a200:	e0822000 	add	r2, r2, r0
3003a204:	e0823003 	add	r3, r2, r3
3003a208:	e5933000 	ldr	r3, [r3]
3003a20c:	e0633001 	rsb	r3, r3, r1
3003a210:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a214:	e581322c 	str	r3, [r1, #556]	; 0x22c
                  i = 3*sfBandIndex[sfreq].s[sfb] + j * sb;
3003a218:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003a21c:	e5932210 	ldr	r2, [r3, #528]	; 0x210
3003a220:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a224:	e5940220 	ldr	r0, [r4, #544]	; 0x220
3003a228:	e59f1518 	ldr	r1, [pc, #1304]	; 3003a748 <III_stereo+0xa34>
3003a22c:	e1a03002 	mov	r3, r2
3003a230:	e1a03183 	lsl	r3, r3, #3
3003a234:	e0833002 	add	r3, r3, r2
3003a238:	e1a03103 	lsl	r3, r3, #2
3003a23c:	e0833002 	add	r3, r3, r2
3003a240:	e0833000 	add	r3, r3, r0
3003a244:	e2832016 	add	r2, r3, #22
3003a248:	e3a03004 	mov	r3, #4
3003a24c:	e1a02102 	lsl	r2, r2, #2
3003a250:	e0822001 	add	r2, r2, r1
3003a254:	e0823003 	add	r3, r2, r3
3003a258:	e5932000 	ldr	r2, [r3]
3003a25c:	e1a03002 	mov	r3, r2
3003a260:	e1a03083 	lsl	r3, r3, #1
3003a264:	e0832002 	add	r2, r3, r2
3003a268:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a26c:	e59c3228 	ldr	r3, [ip, #552]	; 0x228
3003a270:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a274:	e590122c 	ldr	r1, [r0, #556]	; 0x22c
3003a278:	e0030391 	mul	r3, r1, r3
3003a27c:	e0823003 	add	r3, r2, r3
3003a280:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a284:	e5813224 	str	r3, [r1, #548]	; 0x224
                  for ( ; sb > 0; sb--)
3003a288:	ea000064 	b	3003a420 <III_stereo+0x70c>
                  {  is_pos[i] = (*scalefac)[1].s[j][sfb];
3003a28c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003a290:	e5921224 	ldr	r1, [r2, #548]	; 0x224
3003a294:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003a298:	e5932228 	ldr	r2, [r3, #552]	; 0x228
3003a29c:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a2a0:	e594c220 	ldr	ip, [r4, #544]	; 0x220
3003a2a4:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003a2a8:	e243300f 	sub	r3, r3, #15
3003a2ac:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003a2b0:	e2844018 	add	r4, r4, #24
3003a2b4:	e7940003 	ldr	r0, [r4, r3]
3003a2b8:	e1a03002 	mov	r3, r2
3003a2bc:	e1a03083 	lsl	r3, r3, #1
3003a2c0:	e0833002 	add	r3, r3, r2
3003a2c4:	e1a03103 	lsl	r3, r3, #2
3003a2c8:	e0833002 	add	r3, r3, r2
3003a2cc:	e083300c 	add	r3, r3, ip
3003a2d0:	e2832054 	add	r2, r3, #84	; 0x54
3003a2d4:	e3a03004 	mov	r3, #4
3003a2d8:	e1a02102 	lsl	r2, r2, #2
3003a2dc:	e0822000 	add	r2, r2, r0
3003a2e0:	e0823003 	add	r3, r2, r3
3003a2e4:	e5932000 	ldr	r2, [r3]
3003a2e8:	e3e03d25 	mvn	r3, #2368	; 0x940
3003a2ec:	e2433007 	sub	r3, r3, #7
3003a2f0:	e1a01101 	lsl	r1, r1, #2
3003a2f4:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003a2f8:	e28cc018 	add	ip, ip, #24
3003a2fc:	e081100c 	add	r1, r1, ip
3003a300:	e0813003 	add	r3, r1, r3
3003a304:	e5832000 	str	r2, [r3]
                     if ( is_pos[i] != 7 )
3003a308:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a30c:	e5902224 	ldr	r2, [r0, #548]	; 0x224
3003a310:	e3e03d25 	mvn	r3, #2368	; 0x940
3003a314:	e2433007 	sub	r3, r3, #7
3003a318:	e1a02102 	lsl	r2, r2, #2
3003a31c:	e28d1d49 	add	r1, sp, #4672	; 0x1240
3003a320:	e2811018 	add	r1, r1, #24
3003a324:	e0822001 	add	r2, r2, r1
3003a328:	e0823003 	add	r3, r2, r3
3003a32c:	e5933000 	ldr	r3, [r3]
3003a330:	e3530007 	cmp	r3, #7
3003a334:	0a00002f 	beq	3003a3f8 <III_stereo+0x6e4>
                        is_ratio[i] = (int)(1024*tan( is_pos[i] * (PI / 12)));
3003a338:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003a33c:	e5925224 	ldr	r5, [r2, #548]	; 0x224
3003a340:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003a344:	e5932224 	ldr	r2, [r3, #548]	; 0x224
3003a348:	e3e03d25 	mvn	r3, #2368	; 0x940
3003a34c:	e2433007 	sub	r3, r3, #7
3003a350:	e1a02102 	lsl	r2, r2, #2
3003a354:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003a358:	e2844018 	add	r4, r4, #24
3003a35c:	e0822004 	add	r2, r2, r4
3003a360:	e0823003 	add	r3, r2, r3
3003a364:	e5933000 	ldr	r3, [r3]
3003a368:	e1a00003 	mov	r0, r3
3003a36c:	eb0027b3 	bl	30044240 <__aeabi_i2d>
3003a370:	e1a03000 	mov	r3, r0
3003a374:	e1a04001 	mov	r4, r1
3003a378:	e1a00003 	mov	r0, r3
3003a37c:	e1a01004 	mov	r1, r4
3003a380:	e28f3e3b 	add	r3, pc, #944	; 0x3b0
3003a384:	e893000c 	ldm	r3, {r2, r3}
3003a388:	eb0027e3 	bl	3004431c <__aeabi_dmul>
3003a38c:	e1a03000 	mov	r3, r0
3003a390:	e1a04001 	mov	r4, r1
3003a394:	e1a00003 	mov	r0, r3
3003a398:	e1a01004 	mov	r1, r4
3003a39c:	ebffec05 	bl	300353b8 <tan>
3003a3a0:	e1a03000 	mov	r3, r0
3003a3a4:	e1a04001 	mov	r4, r1
3003a3a8:	e1a00003 	mov	r0, r3
3003a3ac:	e1a01004 	mov	r1, r4
3003a3b0:	e3a02000 	mov	r2, #0
3003a3b4:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003a3b8:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003a3bc:	eb0027d6 	bl	3004431c <__aeabi_dmul>
3003a3c0:	e1a03000 	mov	r3, r0
3003a3c4:	e1a04001 	mov	r4, r1
3003a3c8:	e1a00003 	mov	r0, r3
3003a3cc:	e1a01004 	mov	r1, r4
3003a3d0:	eb002949 	bl	300448fc <__aeabi_d2iz>
3003a3d4:	e1a02000 	mov	r2, r0
3003a3d8:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003a3dc:	e2433007 	sub	r3, r3, #7
3003a3e0:	e1a01105 	lsl	r1, r5, #2
3003a3e4:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003a3e8:	e28cc018 	add	ip, ip, #24
3003a3ec:	e081100c 	add	r1, r1, ip
3003a3f0:	e0813003 	add	r3, r1, r3
3003a3f4:	e5832000 	str	r2, [r3]
                     i++;
3003a3f8:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a3fc:	e5903224 	ldr	r3, [r0, #548]	; 0x224
3003a400:	e2833001 	add	r3, r3, #1
3003a404:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a408:	e5813224 	str	r3, [r1, #548]	; 0x224
                  max_sfb = sfb;

               while( sfb<12 )
               {  sb = sfBandIndex[sfreq].s[sfb+1]-sfBandIndex[sfreq].s[sfb];
                  i = 3*sfBandIndex[sfreq].s[sfb] + j * sb;
                  for ( ; sb > 0; sb--)
3003a40c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003a410:	e592322c 	ldr	r3, [r2, #556]	; 0x22c
3003a414:	e2433001 	sub	r3, r3, #1
3003a418:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a41c:	e584322c 	str	r3, [r4, #556]	; 0x22c
3003a420:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a424:	e59c322c 	ldr	r3, [ip, #556]	; 0x22c
3003a428:	e3530000 	cmp	r3, #0
3003a42c:	caffff96 	bgt	3003a28c <III_stereo+0x578>
                  {  is_pos[i] = (*scalefac)[1].s[j][sfb];
                     if ( is_pos[i] != 7 )
                        is_ratio[i] = (int)(1024*tan( is_pos[i] * (PI / 12)));
                     i++;
                  }
                  sfb++;
3003a430:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a434:	e5903220 	ldr	r3, [r0, #544]	; 0x220
3003a438:	e2833001 	add	r3, r3, #1
3003a43c:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a440:	e5813220 	str	r3, [r1, #544]	; 0x220
               sfb = sfbcnt + 1;

               if ( sfb > max_sfb )
                  max_sfb = sfb;

               while( sfb<12 )
3003a444:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003a448:	e5923220 	ldr	r3, [r2, #544]	; 0x220
3003a44c:	e353000b 	cmp	r3, #11
3003a450:	daffff4a 	ble	3003a180 <III_stereo+0x46c>
                        is_ratio[i] = (int)(1024*tan( is_pos[i] * (PI / 12)));
                     i++;
                  }
                  sfb++;
               }
               sb = sfBandIndex[sfreq].s[11]-sfBandIndex[sfreq].s[10];
3003a454:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003a458:	e5932210 	ldr	r2, [r3, #528]	; 0x210
3003a45c:	e59f02e4 	ldr	r0, [pc, #740]	; 3003a748 <III_stereo+0xa34>
3003a460:	e3a01088 	mov	r1, #136	; 0x88
3003a464:	e1a03002 	mov	r3, r2
3003a468:	e1a03183 	lsl	r3, r3, #3
3003a46c:	e0833002 	add	r3, r3, r2
3003a470:	e1a03103 	lsl	r3, r3, #2
3003a474:	e0833002 	add	r3, r3, r2
3003a478:	e1a03103 	lsl	r3, r3, #2
3003a47c:	e0833000 	add	r3, r3, r0
3003a480:	e0833001 	add	r3, r3, r1
3003a484:	e5931000 	ldr	r1, [r3]
3003a488:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a48c:	e5942210 	ldr	r2, [r4, #528]	; 0x210
3003a490:	e59fc2b0 	ldr	ip, [pc, #688]	; 3003a748 <III_stereo+0xa34>
3003a494:	e3a00084 	mov	r0, #132	; 0x84
3003a498:	e1a03002 	mov	r3, r2
3003a49c:	e1a03183 	lsl	r3, r3, #3
3003a4a0:	e0833002 	add	r3, r3, r2
3003a4a4:	e1a03103 	lsl	r3, r3, #2
3003a4a8:	e0833002 	add	r3, r3, r2
3003a4ac:	e1a03103 	lsl	r3, r3, #2
3003a4b0:	e083300c 	add	r3, r3, ip
3003a4b4:	e0833000 	add	r3, r3, r0
3003a4b8:	e5933000 	ldr	r3, [r3]
3003a4bc:	e0633001 	rsb	r3, r3, r1
3003a4c0:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a4c4:	e58c322c 	str	r3, [ip, #556]	; 0x22c
               sfb = 3*sfBandIndex[sfreq].s[10] + j * sb;
3003a4c8:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a4cc:	e5902210 	ldr	r2, [r0, #528]	; 0x210
3003a4d0:	e59f0270 	ldr	r0, [pc, #624]	; 3003a748 <III_stereo+0xa34>
3003a4d4:	e3a01084 	mov	r1, #132	; 0x84
3003a4d8:	e1a03002 	mov	r3, r2
3003a4dc:	e1a03183 	lsl	r3, r3, #3
3003a4e0:	e0833002 	add	r3, r3, r2
3003a4e4:	e1a03103 	lsl	r3, r3, #2
3003a4e8:	e0833002 	add	r3, r3, r2
3003a4ec:	e1a03103 	lsl	r3, r3, #2
3003a4f0:	e0833000 	add	r3, r3, r0
3003a4f4:	e0833001 	add	r3, r3, r1
3003a4f8:	e5932000 	ldr	r2, [r3]
3003a4fc:	e1a03002 	mov	r3, r2
3003a500:	e1a03083 	lsl	r3, r3, #1
3003a504:	e0832002 	add	r2, r3, r2
3003a508:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a50c:	e5913228 	ldr	r3, [r1, #552]	; 0x228
3003a510:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a514:	e594122c 	ldr	r1, [r4, #556]	; 0x22c
3003a518:	e0030391 	mul	r3, r1, r3
3003a51c:	e0823003 	add	r3, r2, r3
3003a520:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a524:	e58c3220 	str	r3, [ip, #544]	; 0x220
               sb = sfBandIndex[sfreq].s[12]-sfBandIndex[sfreq].s[11];
3003a528:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a52c:	e5902210 	ldr	r2, [r0, #528]	; 0x210
3003a530:	e59f0210 	ldr	r0, [pc, #528]	; 3003a748 <III_stereo+0xa34>
3003a534:	e3a0108c 	mov	r1, #140	; 0x8c
3003a538:	e1a03002 	mov	r3, r2
3003a53c:	e1a03183 	lsl	r3, r3, #3
3003a540:	e0833002 	add	r3, r3, r2
3003a544:	e1a03103 	lsl	r3, r3, #2
3003a548:	e0833002 	add	r3, r3, r2
3003a54c:	e1a03103 	lsl	r3, r3, #2
3003a550:	e0833000 	add	r3, r3, r0
3003a554:	e0833001 	add	r3, r3, r1
3003a558:	e5931000 	ldr	r1, [r3]
3003a55c:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003a560:	e5932210 	ldr	r2, [r3, #528]	; 0x210
3003a564:	e59fc1dc 	ldr	ip, [pc, #476]	; 3003a748 <III_stereo+0xa34>
3003a568:	e3a00088 	mov	r0, #136	; 0x88
3003a56c:	e1a03002 	mov	r3, r2
3003a570:	e1a03183 	lsl	r3, r3, #3
3003a574:	e0833002 	add	r3, r3, r2
3003a578:	e1a03103 	lsl	r3, r3, #2
3003a57c:	e0833002 	add	r3, r3, r2
3003a580:	e1a03103 	lsl	r3, r3, #2
3003a584:	e083300c 	add	r3, r3, ip
3003a588:	e0833000 	add	r3, r3, r0
3003a58c:	e5933000 	ldr	r3, [r3]
3003a590:	e0633001 	rsb	r3, r3, r1
3003a594:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a598:	e584322c 	str	r3, [r4, #556]	; 0x22c
               i = 3*sfBandIndex[sfreq].s[11] + j * sb;
3003a59c:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a5a0:	e59c2210 	ldr	r2, [ip, #528]	; 0x210
3003a5a4:	e59f019c 	ldr	r0, [pc, #412]	; 3003a748 <III_stereo+0xa34>
3003a5a8:	e3a01088 	mov	r1, #136	; 0x88
3003a5ac:	e1a03002 	mov	r3, r2
3003a5b0:	e1a03183 	lsl	r3, r3, #3
3003a5b4:	e0833002 	add	r3, r3, r2
3003a5b8:	e1a03103 	lsl	r3, r3, #2
3003a5bc:	e0833002 	add	r3, r3, r2
3003a5c0:	e1a03103 	lsl	r3, r3, #2
3003a5c4:	e0833000 	add	r3, r3, r0
3003a5c8:	e0833001 	add	r3, r3, r1
3003a5cc:	e5932000 	ldr	r2, [r3]
3003a5d0:	e1a03002 	mov	r3, r2
3003a5d4:	e1a03083 	lsl	r3, r3, #1
3003a5d8:	e0832002 	add	r2, r3, r2
3003a5dc:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a5e0:	e5903228 	ldr	r3, [r0, #552]	; 0x228
3003a5e4:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a5e8:	e594122c 	ldr	r1, [r4, #556]	; 0x22c
3003a5ec:	e0030391 	mul	r3, r1, r3
3003a5f0:	e0823003 	add	r3, r2, r3
3003a5f4:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a5f8:	e58c3224 	str	r3, [ip, #548]	; 0x224
               for ( ; sb > 0; sb-- )
3003a5fc:	ea000031 	b	3003a6c8 <III_stereo+0x9b4>
               {  is_pos[i] = is_pos[sfb];
3003a600:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a604:	e5901224 	ldr	r1, [r0, #548]	; 0x224
3003a608:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003a60c:	e5932220 	ldr	r2, [r3, #544]	; 0x220
3003a610:	e3e03d25 	mvn	r3, #2368	; 0x940
3003a614:	e2433007 	sub	r3, r3, #7
3003a618:	e1a02102 	lsl	r2, r2, #2
3003a61c:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003a620:	e2844018 	add	r4, r4, #24
3003a624:	e0822004 	add	r2, r2, r4
3003a628:	e0823003 	add	r3, r2, r3
3003a62c:	e5932000 	ldr	r2, [r3]
3003a630:	e3e03d25 	mvn	r3, #2368	; 0x940
3003a634:	e2433007 	sub	r3, r3, #7
3003a638:	e1a01101 	lsl	r1, r1, #2
3003a63c:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003a640:	e28cc018 	add	ip, ip, #24
3003a644:	e081100c 	add	r1, r1, ip
3003a648:	e0813003 	add	r3, r1, r3
3003a64c:	e5832000 	str	r2, [r3]
                  is_ratio[i] = is_ratio[sfb];
3003a650:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a654:	e5901224 	ldr	r1, [r0, #548]	; 0x224
3003a658:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003a65c:	e5932220 	ldr	r2, [r3, #544]	; 0x220
3003a660:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003a664:	e2433007 	sub	r3, r3, #7
3003a668:	e1a02102 	lsl	r2, r2, #2
3003a66c:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003a670:	e2844018 	add	r4, r4, #24
3003a674:	e0822004 	add	r2, r2, r4
3003a678:	e0823003 	add	r3, r2, r3
3003a67c:	e5932000 	ldr	r2, [r3]
3003a680:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003a684:	e2433007 	sub	r3, r3, #7
3003a688:	e1a01101 	lsl	r1, r1, #2
3003a68c:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003a690:	e28cc018 	add	ip, ip, #24
3003a694:	e081100c 	add	r1, r1, ip
3003a698:	e0813003 	add	r3, r1, r3
3003a69c:	e5832000 	str	r2, [r3]
                  i++;
3003a6a0:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a6a4:	e5903224 	ldr	r3, [r0, #548]	; 0x224
3003a6a8:	e2833001 	add	r3, r3, #1
3003a6ac:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a6b0:	e5813224 	str	r3, [r1, #548]	; 0x224
               }
               sb = sfBandIndex[sfreq].s[11]-sfBandIndex[sfreq].s[10];
               sfb = 3*sfBandIndex[sfreq].s[10] + j * sb;
               sb = sfBandIndex[sfreq].s[12]-sfBandIndex[sfreq].s[11];
               i = 3*sfBandIndex[sfreq].s[11] + j * sb;
               for ( ; sb > 0; sb-- )
3003a6b4:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003a6b8:	e592322c 	ldr	r3, [r2, #556]	; 0x22c
3003a6bc:	e2433001 	sub	r3, r3, #1
3003a6c0:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a6c4:	e584322c 	str	r3, [r4, #556]	; 0x22c
3003a6c8:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a6cc:	e59c322c 	ldr	r3, [ip, #556]	; 0x22c
3003a6d0:	e3530000 	cmp	r3, #0
3003a6d4:	caffffc9 	bgt	3003a600 <III_stereo+0x8ec>
   if ((stereo == 2) && i_stereo )
   {  if (gr_info->window_switching_flag && (gr_info->block_type == 2))
      {  if( gr_info->mixed_block_flag )
         {  int max_sfb = 0;

            for ( j=0; j<3; j++ )
3003a6d8:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a6dc:	e5903228 	ldr	r3, [r0, #552]	; 0x228
3003a6e0:	e2833001 	add	r3, r3, #1
3003a6e4:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a6e8:	e5813228 	str	r3, [r1, #552]	; 0x228
3003a6ec:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003a6f0:	e5923228 	ldr	r3, [r2, #552]	; 0x228
3003a6f4:	e3530002 	cmp	r3, #2
3003a6f8:	dafffe02 	ble	30039f08 <III_stereo+0x1f4>
               {  is_pos[i] = is_pos[sfb];
                  is_ratio[i] = is_ratio[sfb];
                  i++;
               }
             }
             if ( max_sfb <= 3 )
3003a6fc:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a700:	e5943234 	ldr	r3, [r4, #564]	; 0x234
3003a704:	e3530003 	cmp	r3, #3
3003a708:	ca00043c 	bgt	3003b800 <III_stereo+0x1aec>
             {  i = 2;
3003a70c:	e3a03002 	mov	r3, #2
3003a710:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a714:	e58c3224 	str	r3, [ip, #548]	; 0x224
                ss = 17;
3003a718:	e3a03011 	mov	r3, #17
3003a71c:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a720:	e5803230 	str	r3, [r0, #560]	; 0x230
                sb = -1;
3003a724:	e3e03000 	mvn	r3, #0
3003a728:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a72c:	e581322c 	str	r3, [r1, #556]	; 0x22c
                while ( i >= 0 )
3003a730:	ea000038 	b	3003a818 <III_stereo+0xb04>
3003a734:	e1a00000 	nop			; (mov r0, r0)
3003a738:	382d7361 	.word	0x382d7361
3003a73c:	3fd0c152 	.word	0x3fd0c152
3003a740:	302be81c 	.word	0x302be81c
3003a744:	38e38e39 	.word	0x38e38e39
3003a748:	300c7eb4 	.word	0x300c7eb4
                {  if ( xr[1][i][ss] != 0 )
3003a74c:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003a750:	e243300b 	sub	r3, r3, #11
3003a754:	e28d2d49 	add	r2, sp, #4672	; 0x1240
3003a758:	e2822018 	add	r2, r2, #24
3003a75c:	e7923003 	ldr	r3, [r2, r3]
3003a760:	e2831c09 	add	r1, r3, #2304	; 0x900
3003a764:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003a768:	e5932224 	ldr	r2, [r3, #548]	; 0x224
3003a76c:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a770:	e5940230 	ldr	r0, [r4, #560]	; 0x230
3003a774:	e1a03002 	mov	r3, r2
3003a778:	e1a03183 	lsl	r3, r3, #3
3003a77c:	e0833002 	add	r3, r3, r2
3003a780:	e1a03083 	lsl	r3, r3, #1
3003a784:	e0833000 	add	r3, r3, r0
3003a788:	e7913103 	ldr	r3, [r1, r3, lsl #2]
3003a78c:	e3530000 	cmp	r3, #0
3003a790:	0a00000f 	beq	3003a7d4 <III_stereo+0xac0>
                   {  sb = i*18+ss;
3003a794:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a798:	e59c2224 	ldr	r2, [ip, #548]	; 0x224
3003a79c:	e1a03002 	mov	r3, r2
3003a7a0:	e1a03183 	lsl	r3, r3, #3
3003a7a4:	e0833002 	add	r3, r3, r2
3003a7a8:	e1a03083 	lsl	r3, r3, #1
3003a7ac:	e1a02003 	mov	r2, r3
3003a7b0:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a7b4:	e5903230 	ldr	r3, [r0, #560]	; 0x230
3003a7b8:	e0823003 	add	r3, r2, r3
3003a7bc:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a7c0:	e581322c 	str	r3, [r1, #556]	; 0x22c
                      i = -1;
3003a7c4:	e3e03000 	mvn	r3, #0
3003a7c8:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003a7cc:	e5823224 	str	r3, [r2, #548]	; 0x224
3003a7d0:	ea000010 	b	3003a818 <III_stereo+0xb04>
                   } else
                   {  ss--;
3003a7d4:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a7d8:	e5943230 	ldr	r3, [r4, #560]	; 0x230
3003a7dc:	e2433001 	sub	r3, r3, #1
3003a7e0:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a7e4:	e58c3230 	str	r3, [ip, #560]	; 0x230
                      if ( ss < 0 )
3003a7e8:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a7ec:	e5903230 	ldr	r3, [r0, #560]	; 0x230
3003a7f0:	e3530000 	cmp	r3, #0
3003a7f4:	aa000007 	bge	3003a818 <III_stereo+0xb04>
                      {  i--;
3003a7f8:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a7fc:	e5913224 	ldr	r3, [r1, #548]	; 0x224
3003a800:	e2433001 	sub	r3, r3, #1
3003a804:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003a808:	e5823224 	str	r3, [r2, #548]	; 0x224
                         ss = 17;
3003a80c:	e3a03011 	mov	r3, #17
3003a810:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a814:	e5843230 	str	r3, [r4, #560]	; 0x230
             }
             if ( max_sfb <= 3 )
             {  i = 2;
                ss = 17;
                sb = -1;
                while ( i >= 0 )
3003a818:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a81c:	e59c3224 	ldr	r3, [ip, #548]	; 0x224
3003a820:	e3530000 	cmp	r3, #0
3003a824:	aaffffc8 	bge	3003a74c <III_stereo+0xa38>
                      {  i--;
                         ss = 17;
                      }
                   }
                }
                i = 0;
3003a828:	e3a03000 	mov	r3, #0
3003a82c:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a830:	e5803224 	str	r3, [r0, #548]	; 0x224
                while ( sfBandIndex[sfreq].l[i] <= sb )
3003a834:	ea000004 	b	3003a84c <III_stereo+0xb38>
                   i++;
3003a838:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a83c:	e5913224 	ldr	r3, [r1, #548]	; 0x224
3003a840:	e2833001 	add	r3, r3, #1
3003a844:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003a848:	e5823224 	str	r3, [r2, #548]	; 0x224
                         ss = 17;
                      }
                   }
                }
                i = 0;
                while ( sfBandIndex[sfreq].l[i] <= sb )
3003a84c:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003a850:	e5932210 	ldr	r2, [r3, #528]	; 0x210
3003a854:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a858:	e5940224 	ldr	r0, [r4, #548]	; 0x224
3003a85c:	e51f111c 	ldr	r1, [pc, #-284]	; 3003a748 <III_stereo+0xa34>
3003a860:	e1a03002 	mov	r3, r2
3003a864:	e1a03183 	lsl	r3, r3, #3
3003a868:	e0833002 	add	r3, r3, r2
3003a86c:	e1a03103 	lsl	r3, r3, #2
3003a870:	e0833002 	add	r3, r3, r2
3003a874:	e0833000 	add	r3, r3, r0
3003a878:	e7912103 	ldr	r2, [r1, r3, lsl #2]
3003a87c:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a880:	e59c322c 	ldr	r3, [ip, #556]	; 0x22c
3003a884:	e1520003 	cmp	r2, r3
3003a888:	daffffea 	ble	3003a838 <III_stereo+0xb24>
                   i++;
                sfb = i;
3003a88c:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a890:	e5903224 	ldr	r3, [r0, #548]	; 0x224
3003a894:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a898:	e5813220 	str	r3, [r1, #544]	; 0x220
                i = sfBandIndex[sfreq].l[i];
3003a89c:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003a8a0:	e5932210 	ldr	r2, [r3, #528]	; 0x210
3003a8a4:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a8a8:	e5940224 	ldr	r0, [r4, #548]	; 0x224
3003a8ac:	e51f116c 	ldr	r1, [pc, #-364]	; 3003a748 <III_stereo+0xa34>
3003a8b0:	e1a03002 	mov	r3, r2
3003a8b4:	e1a03183 	lsl	r3, r3, #3
3003a8b8:	e0833002 	add	r3, r3, r2
3003a8bc:	e1a03103 	lsl	r3, r3, #2
3003a8c0:	e0833002 	add	r3, r3, r2
3003a8c4:	e0833000 	add	r3, r3, r0
3003a8c8:	e7913103 	ldr	r3, [r1, r3, lsl #2]
3003a8cc:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a8d0:	e58c3224 	str	r3, [ip, #548]	; 0x224
                for ( ; sfb<8; sfb++ )
3003a8d4:	ea00007e 	b	3003aad4 <III_stereo+0xdc0>
                {  sb = sfBandIndex[sfreq].l[sfb+1]-sfBandIndex[sfreq].l[sfb];
3003a8d8:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a8dc:	e5902210 	ldr	r2, [r0, #528]	; 0x210
3003a8e0:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003a8e4:	e5913220 	ldr	r3, [r1, #544]	; 0x220
3003a8e8:	e2830001 	add	r0, r3, #1
3003a8ec:	e51f11ac 	ldr	r1, [pc, #-428]	; 3003a748 <III_stereo+0xa34>
3003a8f0:	e1a03002 	mov	r3, r2
3003a8f4:	e1a03183 	lsl	r3, r3, #3
3003a8f8:	e0833002 	add	r3, r3, r2
3003a8fc:	e1a03103 	lsl	r3, r3, #2
3003a900:	e0833002 	add	r3, r3, r2
3003a904:	e0833000 	add	r3, r3, r0
3003a908:	e7911103 	ldr	r1, [r1, r3, lsl #2]
3003a90c:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003a910:	e5932210 	ldr	r2, [r3, #528]	; 0x210
3003a914:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003a918:	e594c220 	ldr	ip, [r4, #544]	; 0x220
3003a91c:	e51f01dc 	ldr	r0, [pc, #-476]	; 3003a748 <III_stereo+0xa34>
3003a920:	e1a03002 	mov	r3, r2
3003a924:	e1a03183 	lsl	r3, r3, #3
3003a928:	e0833002 	add	r3, r3, r2
3003a92c:	e1a03103 	lsl	r3, r3, #2
3003a930:	e0833002 	add	r3, r3, r2
3003a934:	e083300c 	add	r3, r3, ip
3003a938:	e7903103 	ldr	r3, [r0, r3, lsl #2]
3003a93c:	e0633001 	rsb	r3, r3, r1
3003a940:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003a944:	e58c322c 	str	r3, [ip, #556]	; 0x22c
                   for ( ; sb > 0; sb--)
3003a948:	ea000058 	b	3003aab0 <III_stereo+0xd9c>
                   {  is_pos[i] = (*scalefac)[1].l[sfb];
3003a94c:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a950:	e5901224 	ldr	r1, [r0, #548]	; 0x224
3003a954:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003a958:	e5932220 	ldr	r2, [r3, #544]	; 0x220
3003a95c:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003a960:	e243300f 	sub	r3, r3, #15
3003a964:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003a968:	e2844018 	add	r4, r4, #24
3003a96c:	e7943003 	ldr	r3, [r4, r3]
3003a970:	e282203e 	add	r2, r2, #62	; 0x3e
3003a974:	e7932102 	ldr	r2, [r3, r2, lsl #2]
3003a978:	e3e03d25 	mvn	r3, #2368	; 0x940
3003a97c:	e2433007 	sub	r3, r3, #7
3003a980:	e1a01101 	lsl	r1, r1, #2
3003a984:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003a988:	e28cc018 	add	ip, ip, #24
3003a98c:	e081100c 	add	r1, r1, ip
3003a990:	e0813003 	add	r3, r1, r3
3003a994:	e5832000 	str	r2, [r3]
                      if ( is_pos[i] != 7 )
3003a998:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003a99c:	e5902224 	ldr	r2, [r0, #548]	; 0x224
3003a9a0:	e3e03d25 	mvn	r3, #2368	; 0x940
3003a9a4:	e2433007 	sub	r3, r3, #7
3003a9a8:	e1a02102 	lsl	r2, r2, #2
3003a9ac:	e28d1d49 	add	r1, sp, #4672	; 0x1240
3003a9b0:	e2811018 	add	r1, r1, #24
3003a9b4:	e0822001 	add	r2, r2, r1
3003a9b8:	e0823003 	add	r3, r2, r3
3003a9bc:	e5933000 	ldr	r3, [r3]
3003a9c0:	e3530007 	cmp	r3, #7
3003a9c4:	0a00002f 	beq	3003aa88 <III_stereo+0xd74>
                         is_ratio[i] = (int)(1024*tan( is_pos[i] * (PI / 12)));
3003a9c8:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003a9cc:	e5925224 	ldr	r5, [r2, #548]	; 0x224
3003a9d0:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003a9d4:	e5932224 	ldr	r2, [r3, #548]	; 0x224
3003a9d8:	e3e03d25 	mvn	r3, #2368	; 0x940
3003a9dc:	e2433007 	sub	r3, r3, #7
3003a9e0:	e1a02102 	lsl	r2, r2, #2
3003a9e4:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003a9e8:	e2844018 	add	r4, r4, #24
3003a9ec:	e0822004 	add	r2, r2, r4
3003a9f0:	e0823003 	add	r3, r2, r3
3003a9f4:	e5933000 	ldr	r3, [r3]
3003a9f8:	e1a00003 	mov	r0, r3
3003a9fc:	eb00260f 	bl	30044240 <__aeabi_i2d>
3003aa00:	e1a03000 	mov	r3, r0
3003aa04:	e1a04001 	mov	r4, r1
3003aa08:	e1a00003 	mov	r0, r3
3003aa0c:	e1a01004 	mov	r1, r4
3003aa10:	e28f3e33 	add	r3, pc, #816	; 0x330
3003aa14:	e893000c 	ldm	r3, {r2, r3}
3003aa18:	eb00263f 	bl	3004431c <__aeabi_dmul>
3003aa1c:	e1a03000 	mov	r3, r0
3003aa20:	e1a04001 	mov	r4, r1
3003aa24:	e1a00003 	mov	r0, r3
3003aa28:	e1a01004 	mov	r1, r4
3003aa2c:	ebffea61 	bl	300353b8 <tan>
3003aa30:	e1a03000 	mov	r3, r0
3003aa34:	e1a04001 	mov	r4, r1
3003aa38:	e1a00003 	mov	r0, r3
3003aa3c:	e1a01004 	mov	r1, r4
3003aa40:	e3a02000 	mov	r2, #0
3003aa44:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003aa48:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003aa4c:	eb002632 	bl	3004431c <__aeabi_dmul>
3003aa50:	e1a03000 	mov	r3, r0
3003aa54:	e1a04001 	mov	r4, r1
3003aa58:	e1a00003 	mov	r0, r3
3003aa5c:	e1a01004 	mov	r1, r4
3003aa60:	eb0027a5 	bl	300448fc <__aeabi_d2iz>
3003aa64:	e1a02000 	mov	r2, r0
3003aa68:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003aa6c:	e2433007 	sub	r3, r3, #7
3003aa70:	e1a01105 	lsl	r1, r5, #2
3003aa74:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003aa78:	e28cc018 	add	ip, ip, #24
3003aa7c:	e081100c 	add	r1, r1, ip
3003aa80:	e0813003 	add	r3, r1, r3
3003aa84:	e5832000 	str	r2, [r3]
                      i++;
3003aa88:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003aa8c:	e5903224 	ldr	r3, [r0, #548]	; 0x224
3003aa90:	e2833001 	add	r3, r3, #1
3003aa94:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003aa98:	e5813224 	str	r3, [r1, #548]	; 0x224
                   i++;
                sfb = i;
                i = sfBandIndex[sfreq].l[i];
                for ( ; sfb<8; sfb++ )
                {  sb = sfBandIndex[sfreq].l[sfb+1]-sfBandIndex[sfreq].l[sfb];
                   for ( ; sb > 0; sb--)
3003aa9c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003aaa0:	e592322c 	ldr	r3, [r2, #556]	; 0x22c
3003aaa4:	e2433001 	sub	r3, r3, #1
3003aaa8:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003aaac:	e584322c 	str	r3, [r4, #556]	; 0x22c
3003aab0:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003aab4:	e59c322c 	ldr	r3, [ip, #556]	; 0x22c
3003aab8:	e3530000 	cmp	r3, #0
3003aabc:	caffffa2 	bgt	3003a94c <III_stereo+0xc38>
                i = 0;
                while ( sfBandIndex[sfreq].l[i] <= sb )
                   i++;
                sfb = i;
                i = sfBandIndex[sfreq].l[i];
                for ( ; sfb<8; sfb++ )
3003aac0:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003aac4:	e5903220 	ldr	r3, [r0, #544]	; 0x220
3003aac8:	e2833001 	add	r3, r3, #1
3003aacc:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003aad0:	e5813220 	str	r3, [r1, #544]	; 0x220
3003aad4:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003aad8:	e5923220 	ldr	r3, [r2, #544]	; 0x220
3003aadc:	e3530007 	cmp	r3, #7
3003aae0:	daffff7c 	ble	3003a8d8 <III_stereo+0xbc4>
   /* intialization */
   for ( i=0; i<576; i++ )
      is_pos[i] = 7;

   if ((stereo == 2) && i_stereo )
   {  if (gr_info->window_switching_flag && (gr_info->block_type == 2))
3003aae4:	ea000346 	b	3003b804 <III_stereo+0x1af0>
                   }
                }
            }
         }
	  else{
		for ( j=0; j<3; j++ )
3003aae8:	e3a03000 	mov	r3, #0
3003aaec:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003aaf0:	e5843228 	str	r3, [r4, #552]	; 0x228
3003aaf4:	ea0001f2 	b	3003b2c4 <III_stereo+0x15b0>
            {  int sfbcnt;
               sfbcnt = -1;
3003aaf8:	e3e03000 	mvn	r3, #0
3003aafc:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003ab00:	e58c3240 	str	r3, [ip, #576]	; 0x240
               for( sfb=12; sfb >=0; sfb-- )
3003ab04:	e3a0300c 	mov	r3, #12
3003ab08:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003ab0c:	e5803220 	str	r3, [r0, #544]	; 0x220
3003ab10:	ea000082 	b	3003ad20 <III_stereo+0x100c>
               {  int lines;
                  lines = sfBandIndex[sfreq].s[sfb+1]-sfBandIndex[sfreq].s[sfb];
3003ab14:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003ab18:	e5912210 	ldr	r2, [r1, #528]	; 0x210
3003ab1c:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003ab20:	e5943220 	ldr	r3, [r4, #544]	; 0x220
3003ab24:	e2830001 	add	r0, r3, #1
3003ab28:	e59f1224 	ldr	r1, [pc, #548]	; 3003ad54 <III_stereo+0x1040>
3003ab2c:	e1a03002 	mov	r3, r2
3003ab30:	e1a03183 	lsl	r3, r3, #3
3003ab34:	e0833002 	add	r3, r3, r2
3003ab38:	e1a03103 	lsl	r3, r3, #2
3003ab3c:	e0833002 	add	r3, r3, r2
3003ab40:	e0833000 	add	r3, r3, r0
3003ab44:	e2832016 	add	r2, r3, #22
3003ab48:	e3a03004 	mov	r3, #4
3003ab4c:	e1a02102 	lsl	r2, r2, #2
3003ab50:	e0822001 	add	r2, r2, r1
3003ab54:	e0823003 	add	r3, r2, r3
3003ab58:	e5931000 	ldr	r1, [r3]
3003ab5c:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003ab60:	e59c2210 	ldr	r2, [ip, #528]	; 0x210
3003ab64:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003ab68:	e590c220 	ldr	ip, [r0, #544]	; 0x220
3003ab6c:	e59f01e0 	ldr	r0, [pc, #480]	; 3003ad54 <III_stereo+0x1040>
3003ab70:	e1a03002 	mov	r3, r2
3003ab74:	e1a03183 	lsl	r3, r3, #3
3003ab78:	e0833002 	add	r3, r3, r2
3003ab7c:	e1a03103 	lsl	r3, r3, #2
3003ab80:	e0833002 	add	r3, r3, r2
3003ab84:	e083300c 	add	r3, r3, ip
3003ab88:	e2832016 	add	r2, r3, #22
3003ab8c:	e3a03004 	mov	r3, #4
3003ab90:	e1a02102 	lsl	r2, r2, #2
3003ab94:	e0822000 	add	r2, r2, r0
3003ab98:	e0823003 	add	r3, r2, r3
3003ab9c:	e5933000 	ldr	r3, [r3]
3003aba0:	e0633001 	rsb	r3, r3, r1
3003aba4:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003aba8:	e5813244 	str	r3, [r1, #580]	; 0x244
                  i = 3*sfBandIndex[sfreq].s[sfb] + (j+1) * lines - 1;
3003abac:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003abb0:	e5932210 	ldr	r2, [r3, #528]	; 0x210
3003abb4:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003abb8:	e5940220 	ldr	r0, [r4, #544]	; 0x220
3003abbc:	e59f1190 	ldr	r1, [pc, #400]	; 3003ad54 <III_stereo+0x1040>
3003abc0:	e1a03002 	mov	r3, r2
3003abc4:	e1a03183 	lsl	r3, r3, #3
3003abc8:	e0833002 	add	r3, r3, r2
3003abcc:	e1a03103 	lsl	r3, r3, #2
3003abd0:	e0833002 	add	r3, r3, r2
3003abd4:	e0833000 	add	r3, r3, r0
3003abd8:	e2832016 	add	r2, r3, #22
3003abdc:	e3a03004 	mov	r3, #4
3003abe0:	e1a02102 	lsl	r2, r2, #2
3003abe4:	e0822001 	add	r2, r2, r1
3003abe8:	e0823003 	add	r3, r2, r3
3003abec:	e5932000 	ldr	r2, [r3]
3003abf0:	e1a03002 	mov	r3, r2
3003abf4:	e1a03083 	lsl	r3, r3, #1
3003abf8:	e0832002 	add	r2, r3, r2
3003abfc:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003ac00:	e59c3228 	ldr	r3, [ip, #552]	; 0x228
3003ac04:	e2833001 	add	r3, r3, #1
3003ac08:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003ac0c:	e5901244 	ldr	r1, [r0, #580]	; 0x244
3003ac10:	e0030391 	mul	r3, r1, r3
3003ac14:	e0823003 	add	r3, r2, r3
3003ac18:	e2433001 	sub	r3, r3, #1
3003ac1c:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003ac20:	e5813224 	str	r3, [r1, #548]	; 0x224
                  while ( lines > 0 )
3003ac24:	ea000034 	b	3003acfc <III_stereo+0xfe8>
                  {  if ( xr[1][i/SSLIMIT][i%SSLIMIT] != 0)
3003ac28:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003ac2c:	e243300b 	sub	r3, r3, #11
3003ac30:	e28d2d49 	add	r2, sp, #4672	; 0x1240
3003ac34:	e2822018 	add	r2, r2, #24
3003ac38:	e7923003 	ldr	r3, [r2, r3]
3003ac3c:	e283cc09 	add	ip, r3, #2304	; 0x900
3003ac40:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003ac44:	e5943224 	ldr	r3, [r4, #548]	; 0x224
3003ac48:	e59f2100 	ldr	r2, [pc, #256]	; 3003ad50 <III_stereo+0x103c>
3003ac4c:	e0c20293 	smull	r0, r2, r3, r2
3003ac50:	e1a02142 	asr	r2, r2, #2
3003ac54:	e1a03fc3 	asr	r3, r3, #31
3003ac58:	e0630002 	rsb	r0, r3, r2
3003ac5c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003ac60:	e5921224 	ldr	r1, [r2, #548]	; 0x224
3003ac64:	e59f30e4 	ldr	r3, [pc, #228]	; 3003ad50 <III_stereo+0x103c>
3003ac68:	e0c34391 	smull	r4, r3, r1, r3
3003ac6c:	e1a02143 	asr	r2, r3, #2
3003ac70:	e1a03fc1 	asr	r3, r1, #31
3003ac74:	e0632002 	rsb	r2, r3, r2
3003ac78:	e1a03002 	mov	r3, r2
3003ac7c:	e1a03183 	lsl	r3, r3, #3
3003ac80:	e0833002 	add	r3, r3, r2
3003ac84:	e1a03083 	lsl	r3, r3, #1
3003ac88:	e0632001 	rsb	r2, r3, r1
3003ac8c:	e1a03000 	mov	r3, r0
3003ac90:	e1a03183 	lsl	r3, r3, #3
3003ac94:	e0833000 	add	r3, r3, r0
3003ac98:	e1a03083 	lsl	r3, r3, #1
3003ac9c:	e0833002 	add	r3, r3, r2
3003aca0:	e79c3103 	ldr	r3, [ip, r3, lsl #2]
3003aca4:	e3530000 	cmp	r3, #0
3003aca8:	0a000009 	beq	3003acd4 <III_stereo+0xfc0>
                     {  sfbcnt = sfb;
3003acac:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003acb0:	e59c3220 	ldr	r3, [ip, #544]	; 0x220
3003acb4:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003acb8:	e5803240 	str	r3, [r0, #576]	; 0x240
                        sfb = -10;
3003acbc:	e3e03009 	mvn	r3, #9
3003acc0:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003acc4:	e5813220 	str	r3, [r1, #544]	; 0x220
                        lines = -10;
3003acc8:	e3e03009 	mvn	r3, #9
3003accc:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003acd0:	e5823244 	str	r3, [r2, #580]	; 0x244
                     }
                     lines--;
3003acd4:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003acd8:	e5943244 	ldr	r3, [r4, #580]	; 0x244
3003acdc:	e2433001 	sub	r3, r3, #1
3003ace0:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003ace4:	e58c3244 	str	r3, [ip, #580]	; 0x244
                     i--;
3003ace8:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003acec:	e5903224 	ldr	r3, [r0, #548]	; 0x224
3003acf0:	e2433001 	sub	r3, r3, #1
3003acf4:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003acf8:	e5813224 	str	r3, [r1, #548]	; 0x224
               sfbcnt = -1;
               for( sfb=12; sfb >=0; sfb-- )
               {  int lines;
                  lines = sfBandIndex[sfreq].s[sfb+1]-sfBandIndex[sfreq].s[sfb];
                  i = 3*sfBandIndex[sfreq].s[sfb] + (j+1) * lines - 1;
                  while ( lines > 0 )
3003acfc:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003ad00:	e5923244 	ldr	r3, [r2, #580]	; 0x244
3003ad04:	e3530000 	cmp	r3, #0
3003ad08:	caffffc6 	bgt	3003ac28 <III_stereo+0xf14>
         }
	  else{
		for ( j=0; j<3; j++ )
            {  int sfbcnt;
               sfbcnt = -1;
               for( sfb=12; sfb >=0; sfb-- )
3003ad0c:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003ad10:	e5943220 	ldr	r3, [r4, #544]	; 0x220
3003ad14:	e2433001 	sub	r3, r3, #1
3003ad18:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003ad1c:	e58c3220 	str	r3, [ip, #544]	; 0x220
3003ad20:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003ad24:	e5903220 	ldr	r3, [r0, #544]	; 0x220
3003ad28:	e3530000 	cmp	r3, #0
3003ad2c:	aaffff78 	bge	3003ab14 <III_stereo+0xe00>
                     }
                     lines--;
                     i--;
                  }
               }
               sfb = sfbcnt + 1;
3003ad30:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003ad34:	e5913240 	ldr	r3, [r1, #576]	; 0x240
3003ad38:	e2833001 	add	r3, r3, #1
3003ad3c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003ad40:	e5823220 	str	r3, [r2, #544]	; 0x220
               while( sfb<12 )
3003ad44:	ea0000b4 	b	3003b01c <III_stereo+0x1308>
3003ad48:	382d7361 	.word	0x382d7361
3003ad4c:	3fd0c152 	.word	0x3fd0c152
3003ad50:	38e38e39 	.word	0x38e38e39
3003ad54:	300c7eb4 	.word	0x300c7eb4
               {  sb = sfBandIndex[sfreq].s[sfb+1]-sfBandIndex[sfreq].s[sfb];
3003ad58:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003ad5c:	e5932210 	ldr	r2, [r3, #528]	; 0x210
3003ad60:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003ad64:	e5943220 	ldr	r3, [r4, #544]	; 0x220
3003ad68:	e2830001 	add	r0, r3, #1
3003ad6c:	e51f1020 	ldr	r1, [pc, #-32]	; 3003ad54 <III_stereo+0x1040>
3003ad70:	e1a03002 	mov	r3, r2
3003ad74:	e1a03183 	lsl	r3, r3, #3
3003ad78:	e0833002 	add	r3, r3, r2
3003ad7c:	e1a03103 	lsl	r3, r3, #2
3003ad80:	e0833002 	add	r3, r3, r2
3003ad84:	e0833000 	add	r3, r3, r0
3003ad88:	e2832016 	add	r2, r3, #22
3003ad8c:	e3a03004 	mov	r3, #4
3003ad90:	e1a02102 	lsl	r2, r2, #2
3003ad94:	e0822001 	add	r2, r2, r1
3003ad98:	e0823003 	add	r3, r2, r3
3003ad9c:	e5931000 	ldr	r1, [r3]
3003ada0:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003ada4:	e59c2210 	ldr	r2, [ip, #528]	; 0x210
3003ada8:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003adac:	e590c220 	ldr	ip, [r0, #544]	; 0x220
3003adb0:	e51f0064 	ldr	r0, [pc, #-100]	; 3003ad54 <III_stereo+0x1040>
3003adb4:	e1a03002 	mov	r3, r2
3003adb8:	e1a03183 	lsl	r3, r3, #3
3003adbc:	e0833002 	add	r3, r3, r2
3003adc0:	e1a03103 	lsl	r3, r3, #2
3003adc4:	e0833002 	add	r3, r3, r2
3003adc8:	e083300c 	add	r3, r3, ip
3003adcc:	e2832016 	add	r2, r3, #22
3003add0:	e3a03004 	mov	r3, #4
3003add4:	e1a02102 	lsl	r2, r2, #2
3003add8:	e0822000 	add	r2, r2, r0
3003addc:	e0823003 	add	r3, r2, r3
3003ade0:	e5933000 	ldr	r3, [r3]
3003ade4:	e0633001 	rsb	r3, r3, r1
3003ade8:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003adec:	e581322c 	str	r3, [r1, #556]	; 0x22c
                  i = 3*sfBandIndex[sfreq].s[sfb] + j * sb;
3003adf0:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003adf4:	e5932210 	ldr	r2, [r3, #528]	; 0x210
3003adf8:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003adfc:	e5940220 	ldr	r0, [r4, #544]	; 0x220
3003ae00:	e51f10b4 	ldr	r1, [pc, #-180]	; 3003ad54 <III_stereo+0x1040>
3003ae04:	e1a03002 	mov	r3, r2
3003ae08:	e1a03183 	lsl	r3, r3, #3
3003ae0c:	e0833002 	add	r3, r3, r2
3003ae10:	e1a03103 	lsl	r3, r3, #2
3003ae14:	e0833002 	add	r3, r3, r2
3003ae18:	e0833000 	add	r3, r3, r0
3003ae1c:	e2832016 	add	r2, r3, #22
3003ae20:	e3a03004 	mov	r3, #4
3003ae24:	e1a02102 	lsl	r2, r2, #2
3003ae28:	e0822001 	add	r2, r2, r1
3003ae2c:	e0823003 	add	r3, r2, r3
3003ae30:	e5932000 	ldr	r2, [r3]
3003ae34:	e1a03002 	mov	r3, r2
3003ae38:	e1a03083 	lsl	r3, r3, #1
3003ae3c:	e0832002 	add	r2, r3, r2
3003ae40:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003ae44:	e59c3228 	ldr	r3, [ip, #552]	; 0x228
3003ae48:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003ae4c:	e590122c 	ldr	r1, [r0, #556]	; 0x22c
3003ae50:	e0030391 	mul	r3, r1, r3
3003ae54:	e0823003 	add	r3, r2, r3
3003ae58:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003ae5c:	e5813224 	str	r3, [r1, #548]	; 0x224
                  for ( ; sb > 0; sb--)
3003ae60:	ea000064 	b	3003aff8 <III_stereo+0x12e4>
                  {  is_pos[i] = (*scalefac)[1].s[j][sfb];
3003ae64:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003ae68:	e5921224 	ldr	r1, [r2, #548]	; 0x224
3003ae6c:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003ae70:	e5932228 	ldr	r2, [r3, #552]	; 0x228
3003ae74:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003ae78:	e594c220 	ldr	ip, [r4, #544]	; 0x220
3003ae7c:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003ae80:	e243300f 	sub	r3, r3, #15
3003ae84:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003ae88:	e2844018 	add	r4, r4, #24
3003ae8c:	e7940003 	ldr	r0, [r4, r3]
3003ae90:	e1a03002 	mov	r3, r2
3003ae94:	e1a03083 	lsl	r3, r3, #1
3003ae98:	e0833002 	add	r3, r3, r2
3003ae9c:	e1a03103 	lsl	r3, r3, #2
3003aea0:	e0833002 	add	r3, r3, r2
3003aea4:	e083300c 	add	r3, r3, ip
3003aea8:	e2832054 	add	r2, r3, #84	; 0x54
3003aeac:	e3a03004 	mov	r3, #4
3003aeb0:	e1a02102 	lsl	r2, r2, #2
3003aeb4:	e0822000 	add	r2, r2, r0
3003aeb8:	e0823003 	add	r3, r2, r3
3003aebc:	e5932000 	ldr	r2, [r3]
3003aec0:	e3e03d25 	mvn	r3, #2368	; 0x940
3003aec4:	e2433007 	sub	r3, r3, #7
3003aec8:	e1a01101 	lsl	r1, r1, #2
3003aecc:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003aed0:	e28cc018 	add	ip, ip, #24
3003aed4:	e081100c 	add	r1, r1, ip
3003aed8:	e0813003 	add	r3, r1, r3
3003aedc:	e5832000 	str	r2, [r3]
                     if ( is_pos[i] != 7 )
3003aee0:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003aee4:	e5902224 	ldr	r2, [r0, #548]	; 0x224
3003aee8:	e3e03d25 	mvn	r3, #2368	; 0x940
3003aeec:	e2433007 	sub	r3, r3, #7
3003aef0:	e1a02102 	lsl	r2, r2, #2
3003aef4:	e28d1d49 	add	r1, sp, #4672	; 0x1240
3003aef8:	e2811018 	add	r1, r1, #24
3003aefc:	e0822001 	add	r2, r2, r1
3003af00:	e0823003 	add	r3, r2, r3
3003af04:	e5933000 	ldr	r3, [r3]
3003af08:	e3530007 	cmp	r3, #7
3003af0c:	0a00002f 	beq	3003afd0 <III_stereo+0x12bc>
                        is_ratio[i] = (int)(1024*tan( is_pos[i] * (PI / 12)));
3003af10:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003af14:	e5925224 	ldr	r5, [r2, #548]	; 0x224
3003af18:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003af1c:	e5932224 	ldr	r2, [r3, #548]	; 0x224
3003af20:	e3e03d25 	mvn	r3, #2368	; 0x940
3003af24:	e2433007 	sub	r3, r3, #7
3003af28:	e1a02102 	lsl	r2, r2, #2
3003af2c:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003af30:	e2844018 	add	r4, r4, #24
3003af34:	e0822004 	add	r2, r2, r4
3003af38:	e0823003 	add	r3, r2, r3
3003af3c:	e5933000 	ldr	r3, [r3]
3003af40:	e1a00003 	mov	r0, r3
3003af44:	eb0024bd 	bl	30044240 <__aeabi_i2d>
3003af48:	e1a03000 	mov	r3, r0
3003af4c:	e1a04001 	mov	r4, r1
3003af50:	e1a00003 	mov	r0, r3
3003af54:	e1a01004 	mov	r1, r4
3003af58:	e28f3e3a 	add	r3, pc, #928	; 0x3a0
3003af5c:	e893000c 	ldm	r3, {r2, r3}
3003af60:	eb0024ed 	bl	3004431c <__aeabi_dmul>
3003af64:	e1a03000 	mov	r3, r0
3003af68:	e1a04001 	mov	r4, r1
3003af6c:	e1a00003 	mov	r0, r3
3003af70:	e1a01004 	mov	r1, r4
3003af74:	ebffe90f 	bl	300353b8 <tan>
3003af78:	e1a03000 	mov	r3, r0
3003af7c:	e1a04001 	mov	r4, r1
3003af80:	e1a00003 	mov	r0, r3
3003af84:	e1a01004 	mov	r1, r4
3003af88:	e3a02000 	mov	r2, #0
3003af8c:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003af90:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003af94:	eb0024e0 	bl	3004431c <__aeabi_dmul>
3003af98:	e1a03000 	mov	r3, r0
3003af9c:	e1a04001 	mov	r4, r1
3003afa0:	e1a00003 	mov	r0, r3
3003afa4:	e1a01004 	mov	r1, r4
3003afa8:	eb002653 	bl	300448fc <__aeabi_d2iz>
3003afac:	e1a02000 	mov	r2, r0
3003afb0:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003afb4:	e2433007 	sub	r3, r3, #7
3003afb8:	e1a01105 	lsl	r1, r5, #2
3003afbc:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003afc0:	e28cc018 	add	ip, ip, #24
3003afc4:	e081100c 	add	r1, r1, ip
3003afc8:	e0813003 	add	r3, r1, r3
3003afcc:	e5832000 	str	r2, [r3]
                     i++;
3003afd0:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003afd4:	e5903224 	ldr	r3, [r0, #548]	; 0x224
3003afd8:	e2833001 	add	r3, r3, #1
3003afdc:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003afe0:	e5813224 	str	r3, [r1, #548]	; 0x224
               }
               sfb = sfbcnt + 1;
               while( sfb<12 )
               {  sb = sfBandIndex[sfreq].s[sfb+1]-sfBandIndex[sfreq].s[sfb];
                  i = 3*sfBandIndex[sfreq].s[sfb] + j * sb;
                  for ( ; sb > 0; sb--)
3003afe4:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003afe8:	e592322c 	ldr	r3, [r2, #556]	; 0x22c
3003afec:	e2433001 	sub	r3, r3, #1
3003aff0:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003aff4:	e584322c 	str	r3, [r4, #556]	; 0x22c
3003aff8:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003affc:	e59c322c 	ldr	r3, [ip, #556]	; 0x22c
3003b000:	e3530000 	cmp	r3, #0
3003b004:	caffff96 	bgt	3003ae64 <III_stereo+0x1150>
                  {  is_pos[i] = (*scalefac)[1].s[j][sfb];
                     if ( is_pos[i] != 7 )
                        is_ratio[i] = (int)(1024*tan( is_pos[i] * (PI / 12)));
                     i++;
                  }
                  sfb++;
3003b008:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b00c:	e5903220 	ldr	r3, [r0, #544]	; 0x220
3003b010:	e2833001 	add	r3, r3, #1
3003b014:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003b018:	e5813220 	str	r3, [r1, #544]	; 0x220
                     lines--;
                     i--;
                  }
               }
               sfb = sfbcnt + 1;
               while( sfb<12 )
3003b01c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003b020:	e5923220 	ldr	r3, [r2, #544]	; 0x220
3003b024:	e353000b 	cmp	r3, #11
3003b028:	daffff4a 	ble	3003ad58 <III_stereo+0x1044>
                     i++;
                  }
                  sfb++;
               }

               sb = sfBandIndex[sfreq].s[11]-sfBandIndex[sfreq].s[10];
3003b02c:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003b030:	e5932210 	ldr	r2, [r3, #528]	; 0x210
3003b034:	e59f02cc 	ldr	r0, [pc, #716]	; 3003b308 <III_stereo+0x15f4>
3003b038:	e3a01088 	mov	r1, #136	; 0x88
3003b03c:	e1a03002 	mov	r3, r2
3003b040:	e1a03183 	lsl	r3, r3, #3
3003b044:	e0833002 	add	r3, r3, r2
3003b048:	e1a03103 	lsl	r3, r3, #2
3003b04c:	e0833002 	add	r3, r3, r2
3003b050:	e1a03103 	lsl	r3, r3, #2
3003b054:	e0833000 	add	r3, r3, r0
3003b058:	e0833001 	add	r3, r3, r1
3003b05c:	e5931000 	ldr	r1, [r3]
3003b060:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b064:	e5942210 	ldr	r2, [r4, #528]	; 0x210
3003b068:	e59fc298 	ldr	ip, [pc, #664]	; 3003b308 <III_stereo+0x15f4>
3003b06c:	e3a00084 	mov	r0, #132	; 0x84
3003b070:	e1a03002 	mov	r3, r2
3003b074:	e1a03183 	lsl	r3, r3, #3
3003b078:	e0833002 	add	r3, r3, r2
3003b07c:	e1a03103 	lsl	r3, r3, #2
3003b080:	e0833002 	add	r3, r3, r2
3003b084:	e1a03103 	lsl	r3, r3, #2
3003b088:	e083300c 	add	r3, r3, ip
3003b08c:	e0833000 	add	r3, r3, r0
3003b090:	e5933000 	ldr	r3, [r3]
3003b094:	e0633001 	rsb	r3, r3, r1
3003b098:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003b09c:	e58c322c 	str	r3, [ip, #556]	; 0x22c
               sfb = 3*sfBandIndex[sfreq].s[10] + j * sb;
3003b0a0:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b0a4:	e5902210 	ldr	r2, [r0, #528]	; 0x210
3003b0a8:	e59f0258 	ldr	r0, [pc, #600]	; 3003b308 <III_stereo+0x15f4>
3003b0ac:	e3a01084 	mov	r1, #132	; 0x84
3003b0b0:	e1a03002 	mov	r3, r2
3003b0b4:	e1a03183 	lsl	r3, r3, #3
3003b0b8:	e0833002 	add	r3, r3, r2
3003b0bc:	e1a03103 	lsl	r3, r3, #2
3003b0c0:	e0833002 	add	r3, r3, r2
3003b0c4:	e1a03103 	lsl	r3, r3, #2
3003b0c8:	e0833000 	add	r3, r3, r0
3003b0cc:	e0833001 	add	r3, r3, r1
3003b0d0:	e5932000 	ldr	r2, [r3]
3003b0d4:	e1a03002 	mov	r3, r2
3003b0d8:	e1a03083 	lsl	r3, r3, #1
3003b0dc:	e0832002 	add	r2, r3, r2
3003b0e0:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003b0e4:	e5913228 	ldr	r3, [r1, #552]	; 0x228
3003b0e8:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b0ec:	e594122c 	ldr	r1, [r4, #556]	; 0x22c
3003b0f0:	e0030391 	mul	r3, r1, r3
3003b0f4:	e0823003 	add	r3, r2, r3
3003b0f8:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003b0fc:	e58c3220 	str	r3, [ip, #544]	; 0x220
               sb = sfBandIndex[sfreq].s[12]-sfBandIndex[sfreq].s[11];
3003b100:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b104:	e5902210 	ldr	r2, [r0, #528]	; 0x210
3003b108:	e59f01f8 	ldr	r0, [pc, #504]	; 3003b308 <III_stereo+0x15f4>
3003b10c:	e3a0108c 	mov	r1, #140	; 0x8c
3003b110:	e1a03002 	mov	r3, r2
3003b114:	e1a03183 	lsl	r3, r3, #3
3003b118:	e0833002 	add	r3, r3, r2
3003b11c:	e1a03103 	lsl	r3, r3, #2
3003b120:	e0833002 	add	r3, r3, r2
3003b124:	e1a03103 	lsl	r3, r3, #2
3003b128:	e0833000 	add	r3, r3, r0
3003b12c:	e0833001 	add	r3, r3, r1
3003b130:	e5931000 	ldr	r1, [r3]
3003b134:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003b138:	e5932210 	ldr	r2, [r3, #528]	; 0x210
3003b13c:	e59fc1c4 	ldr	ip, [pc, #452]	; 3003b308 <III_stereo+0x15f4>
3003b140:	e3a00088 	mov	r0, #136	; 0x88
3003b144:	e1a03002 	mov	r3, r2
3003b148:	e1a03183 	lsl	r3, r3, #3
3003b14c:	e0833002 	add	r3, r3, r2
3003b150:	e1a03103 	lsl	r3, r3, #2
3003b154:	e0833002 	add	r3, r3, r2
3003b158:	e1a03103 	lsl	r3, r3, #2
3003b15c:	e083300c 	add	r3, r3, ip
3003b160:	e0833000 	add	r3, r3, r0
3003b164:	e5933000 	ldr	r3, [r3]
3003b168:	e0633001 	rsb	r3, r3, r1
3003b16c:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b170:	e584322c 	str	r3, [r4, #556]	; 0x22c
               i = 3*sfBandIndex[sfreq].s[11] + j * sb;
3003b174:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003b178:	e59c2210 	ldr	r2, [ip, #528]	; 0x210
3003b17c:	e59f0184 	ldr	r0, [pc, #388]	; 3003b308 <III_stereo+0x15f4>
3003b180:	e3a01088 	mov	r1, #136	; 0x88
3003b184:	e1a03002 	mov	r3, r2
3003b188:	e1a03183 	lsl	r3, r3, #3
3003b18c:	e0833002 	add	r3, r3, r2
3003b190:	e1a03103 	lsl	r3, r3, #2
3003b194:	e0833002 	add	r3, r3, r2
3003b198:	e1a03103 	lsl	r3, r3, #2
3003b19c:	e0833000 	add	r3, r3, r0
3003b1a0:	e0833001 	add	r3, r3, r1
3003b1a4:	e5932000 	ldr	r2, [r3]
3003b1a8:	e1a03002 	mov	r3, r2
3003b1ac:	e1a03083 	lsl	r3, r3, #1
3003b1b0:	e0832002 	add	r2, r3, r2
3003b1b4:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b1b8:	e5903228 	ldr	r3, [r0, #552]	; 0x228
3003b1bc:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b1c0:	e594122c 	ldr	r1, [r4, #556]	; 0x22c
3003b1c4:	e0030391 	mul	r3, r1, r3
3003b1c8:	e0823003 	add	r3, r2, r3
3003b1cc:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003b1d0:	e58c3224 	str	r3, [ip, #548]	; 0x224
               for ( ; sb > 0; sb-- )
3003b1d4:	ea000031 	b	3003b2a0 <III_stereo+0x158c>
               {  is_pos[i] = is_pos[sfb];
3003b1d8:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b1dc:	e5901224 	ldr	r1, [r0, #548]	; 0x224
3003b1e0:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003b1e4:	e5932220 	ldr	r2, [r3, #544]	; 0x220
3003b1e8:	e3e03d25 	mvn	r3, #2368	; 0x940
3003b1ec:	e2433007 	sub	r3, r3, #7
3003b1f0:	e1a02102 	lsl	r2, r2, #2
3003b1f4:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003b1f8:	e2844018 	add	r4, r4, #24
3003b1fc:	e0822004 	add	r2, r2, r4
3003b200:	e0823003 	add	r3, r2, r3
3003b204:	e5932000 	ldr	r2, [r3]
3003b208:	e3e03d25 	mvn	r3, #2368	; 0x940
3003b20c:	e2433007 	sub	r3, r3, #7
3003b210:	e1a01101 	lsl	r1, r1, #2
3003b214:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003b218:	e28cc018 	add	ip, ip, #24
3003b21c:	e081100c 	add	r1, r1, ip
3003b220:	e0813003 	add	r3, r1, r3
3003b224:	e5832000 	str	r2, [r3]
                  is_ratio[i] = is_ratio[sfb];
3003b228:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b22c:	e5901224 	ldr	r1, [r0, #548]	; 0x224
3003b230:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003b234:	e5932220 	ldr	r2, [r3, #544]	; 0x220
3003b238:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003b23c:	e2433007 	sub	r3, r3, #7
3003b240:	e1a02102 	lsl	r2, r2, #2
3003b244:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003b248:	e2844018 	add	r4, r4, #24
3003b24c:	e0822004 	add	r2, r2, r4
3003b250:	e0823003 	add	r3, r2, r3
3003b254:	e5932000 	ldr	r2, [r3]
3003b258:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003b25c:	e2433007 	sub	r3, r3, #7
3003b260:	e1a01101 	lsl	r1, r1, #2
3003b264:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003b268:	e28cc018 	add	ip, ip, #24
3003b26c:	e081100c 	add	r1, r1, ip
3003b270:	e0813003 	add	r3, r1, r3
3003b274:	e5832000 	str	r2, [r3]
                  i++;
3003b278:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b27c:	e5903224 	ldr	r3, [r0, #548]	; 0x224
3003b280:	e2833001 	add	r3, r3, #1
3003b284:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003b288:	e5813224 	str	r3, [r1, #548]	; 0x224

               sb = sfBandIndex[sfreq].s[11]-sfBandIndex[sfreq].s[10];
               sfb = 3*sfBandIndex[sfreq].s[10] + j * sb;
               sb = sfBandIndex[sfreq].s[12]-sfBandIndex[sfreq].s[11];
               i = 3*sfBandIndex[sfreq].s[11] + j * sb;
               for ( ; sb > 0; sb-- )
3003b28c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003b290:	e592322c 	ldr	r3, [r2, #556]	; 0x22c
3003b294:	e2433001 	sub	r3, r3, #1
3003b298:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b29c:	e584322c 	str	r3, [r4, #556]	; 0x22c
3003b2a0:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003b2a4:	e59c322c 	ldr	r3, [ip, #556]	; 0x22c
3003b2a8:	e3530000 	cmp	r3, #0
3003b2ac:	caffffc9 	bgt	3003b1d8 <III_stereo+0x14c4>
                   }
                }
            }
         }
	  else{
		for ( j=0; j<3; j++ )
3003b2b0:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b2b4:	e5903228 	ldr	r3, [r0, #552]	; 0x228
3003b2b8:	e2833001 	add	r3, r3, #1
3003b2bc:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003b2c0:	e5813228 	str	r3, [r1, #552]	; 0x228
3003b2c4:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003b2c8:	e5923228 	ldr	r3, [r2, #552]	; 0x228
3003b2cc:	e3530002 	cmp	r3, #2
3003b2d0:	dafffe08 	ble	3003aaf8 <III_stereo+0xde4>
   /* intialization */
   for ( i=0; i<576; i++ )
      is_pos[i] = 7;

   if ((stereo == 2) && i_stereo )
   {  if (gr_info->window_switching_flag && (gr_info->block_type == 2))
3003b2d4:	ea00014a 	b	3003b804 <III_stereo+0x1af0>
               }
            }
         }
      }
else {
		i = 31;
3003b2d8:	e3a0301f 	mov	r3, #31
3003b2dc:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b2e0:	e5843224 	str	r3, [r4, #548]	; 0x224
         ss = 17;
3003b2e4:	e3a03011 	mov	r3, #17
3003b2e8:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003b2ec:	e58c3230 	str	r3, [ip, #560]	; 0x230
         sb = 0;
3003b2f0:	e3a03000 	mov	r3, #0
3003b2f4:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b2f8:	e580322c 	str	r3, [r0, #556]	; 0x22c
         while ( i >= 0 )
3003b2fc:	ea000035 	b	3003b3d8 <III_stereo+0x16c4>
3003b300:	382d7361 	.word	0x382d7361
3003b304:	3fd0c152 	.word	0x3fd0c152
3003b308:	300c7eb4 	.word	0x300c7eb4
         {  if ( xr[1][i][ss] != 0)
3003b30c:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003b310:	e243300b 	sub	r3, r3, #11
3003b314:	e28d1d49 	add	r1, sp, #4672	; 0x1240
3003b318:	e2811018 	add	r1, r1, #24
3003b31c:	e7913003 	ldr	r3, [r1, r3]
3003b320:	e2831c09 	add	r1, r3, #2304	; 0x900
3003b324:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003b328:	e5932224 	ldr	r2, [r3, #548]	; 0x224
3003b32c:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b330:	e5940230 	ldr	r0, [r4, #560]	; 0x230
3003b334:	e1a03002 	mov	r3, r2
3003b338:	e1a03183 	lsl	r3, r3, #3
3003b33c:	e0833002 	add	r3, r3, r2
3003b340:	e1a03083 	lsl	r3, r3, #1
3003b344:	e0833000 	add	r3, r3, r0
3003b348:	e7913103 	ldr	r3, [r1, r3, lsl #2]
3003b34c:	e3530000 	cmp	r3, #0
3003b350:	0a00000f 	beq	3003b394 <III_stereo+0x1680>
            {  sb = i*18+ss;
3003b354:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003b358:	e59c2224 	ldr	r2, [ip, #548]	; 0x224
3003b35c:	e1a03002 	mov	r3, r2
3003b360:	e1a03183 	lsl	r3, r3, #3
3003b364:	e0833002 	add	r3, r3, r2
3003b368:	e1a03083 	lsl	r3, r3, #1
3003b36c:	e1a02003 	mov	r2, r3
3003b370:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b374:	e5903230 	ldr	r3, [r0, #560]	; 0x230
3003b378:	e0823003 	add	r3, r2, r3
3003b37c:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003b380:	e581322c 	str	r3, [r1, #556]	; 0x22c
               i = -1;
3003b384:	e3e03000 	mvn	r3, #0
3003b388:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003b38c:	e5823224 	str	r3, [r2, #548]	; 0x224
3003b390:	ea000010 	b	3003b3d8 <III_stereo+0x16c4>
            } else
            {  ss--;
3003b394:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b398:	e5943230 	ldr	r3, [r4, #560]	; 0x230
3003b39c:	e2433001 	sub	r3, r3, #1
3003b3a0:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003b3a4:	e58c3230 	str	r3, [ip, #560]	; 0x230
               if ( ss < 0 )
3003b3a8:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b3ac:	e5903230 	ldr	r3, [r0, #560]	; 0x230
3003b3b0:	e3530000 	cmp	r3, #0
3003b3b4:	aa000007 	bge	3003b3d8 <III_stereo+0x16c4>
               {  i--;
3003b3b8:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003b3bc:	e5913224 	ldr	r3, [r1, #548]	; 0x224
3003b3c0:	e2433001 	sub	r3, r3, #1
3003b3c4:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003b3c8:	e5823224 	str	r3, [r2, #548]	; 0x224
                  ss = 17;
3003b3cc:	e3a03011 	mov	r3, #17
3003b3d0:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b3d4:	e5843230 	str	r3, [r4, #560]	; 0x230
      }
else {
		i = 31;
         ss = 17;
         sb = 0;
         while ( i >= 0 )
3003b3d8:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003b3dc:	e59c3224 	ldr	r3, [ip, #548]	; 0x224
3003b3e0:	e3530000 	cmp	r3, #0
3003b3e4:	aaffffc8 	bge	3003b30c <III_stereo+0x15f8>
               {  i--;
                  ss = 17;
               }
            }
         }
         i = 0;
3003b3e8:	e3a03000 	mov	r3, #0
3003b3ec:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b3f0:	e5803224 	str	r3, [r0, #548]	; 0x224
         while ( sfBandIndex[sfreq].l[i] <= sb )
3003b3f4:	ea000004 	b	3003b40c <III_stereo+0x16f8>
            i++;
3003b3f8:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003b3fc:	e5913224 	ldr	r3, [r1, #548]	; 0x224
3003b400:	e2833001 	add	r3, r3, #1
3003b404:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003b408:	e5823224 	str	r3, [r2, #548]	; 0x224
                  ss = 17;
               }
            }
         }
         i = 0;
         while ( sfBandIndex[sfreq].l[i] <= sb )
3003b40c:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003b410:	e5932210 	ldr	r2, [r3, #528]	; 0x210
3003b414:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b418:	e5940224 	ldr	r0, [r4, #548]	; 0x224
3003b41c:	e51f111c 	ldr	r1, [pc, #-284]	; 3003b308 <III_stereo+0x15f4>
3003b420:	e1a03002 	mov	r3, r2
3003b424:	e1a03183 	lsl	r3, r3, #3
3003b428:	e0833002 	add	r3, r3, r2
3003b42c:	e1a03103 	lsl	r3, r3, #2
3003b430:	e0833002 	add	r3, r3, r2
3003b434:	e0833000 	add	r3, r3, r0
3003b438:	e7912103 	ldr	r2, [r1, r3, lsl #2]
3003b43c:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003b440:	e59c322c 	ldr	r3, [ip, #556]	; 0x22c
3003b444:	e1520003 	cmp	r2, r3
3003b448:	daffffea 	ble	3003b3f8 <III_stereo+0x16e4>
            i++;
         sfb = i;
3003b44c:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b450:	e5903224 	ldr	r3, [r0, #548]	; 0x224
3003b454:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003b458:	e5813220 	str	r3, [r1, #544]	; 0x220
         i = sfBandIndex[sfreq].l[i];
3003b45c:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003b460:	e5932210 	ldr	r2, [r3, #528]	; 0x210
3003b464:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b468:	e5940224 	ldr	r0, [r4, #548]	; 0x224
3003b46c:	e51f116c 	ldr	r1, [pc, #-364]	; 3003b308 <III_stereo+0x15f4>
3003b470:	e1a03002 	mov	r3, r2
3003b474:	e1a03183 	lsl	r3, r3, #3
3003b478:	e0833002 	add	r3, r3, r2
3003b47c:	e1a03103 	lsl	r3, r3, #2
3003b480:	e0833002 	add	r3, r3, r2
3003b484:	e0833000 	add	r3, r3, r0
3003b488:	e7913103 	ldr	r3, [r1, r3, lsl #2]
3003b48c:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003b490:	e58c3224 	str	r3, [ip, #548]	; 0x224
         for ( ; sfb<21; sfb++ )
3003b494:	ea00007e 	b	3003b694 <III_stereo+0x1980>
         {  sb = sfBandIndex[sfreq].l[sfb+1] - sfBandIndex[sfreq].l[sfb];
3003b498:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b49c:	e5902210 	ldr	r2, [r0, #528]	; 0x210
3003b4a0:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003b4a4:	e5913220 	ldr	r3, [r1, #544]	; 0x220
3003b4a8:	e2830001 	add	r0, r3, #1
3003b4ac:	e51f11ac 	ldr	r1, [pc, #-428]	; 3003b308 <III_stereo+0x15f4>
3003b4b0:	e1a03002 	mov	r3, r2
3003b4b4:	e1a03183 	lsl	r3, r3, #3
3003b4b8:	e0833002 	add	r3, r3, r2
3003b4bc:	e1a03103 	lsl	r3, r3, #2
3003b4c0:	e0833002 	add	r3, r3, r2
3003b4c4:	e0833000 	add	r3, r3, r0
3003b4c8:	e7911103 	ldr	r1, [r1, r3, lsl #2]
3003b4cc:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003b4d0:	e5932210 	ldr	r2, [r3, #528]	; 0x210
3003b4d4:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b4d8:	e594c220 	ldr	ip, [r4, #544]	; 0x220
3003b4dc:	e51f01dc 	ldr	r0, [pc, #-476]	; 3003b308 <III_stereo+0x15f4>
3003b4e0:	e1a03002 	mov	r3, r2
3003b4e4:	e1a03183 	lsl	r3, r3, #3
3003b4e8:	e0833002 	add	r3, r3, r2
3003b4ec:	e1a03103 	lsl	r3, r3, #2
3003b4f0:	e0833002 	add	r3, r3, r2
3003b4f4:	e083300c 	add	r3, r3, ip
3003b4f8:	e7903103 	ldr	r3, [r0, r3, lsl #2]
3003b4fc:	e0633001 	rsb	r3, r3, r1
3003b500:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003b504:	e58c322c 	str	r3, [ip, #556]	; 0x22c
            for ( ; sb > 0; sb--)
3003b508:	ea000058 	b	3003b670 <III_stereo+0x195c>
            {  is_pos[i] = (*scalefac)[1].l[sfb];
3003b50c:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b510:	e5901224 	ldr	r1, [r0, #548]	; 0x224
3003b514:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003b518:	e5932220 	ldr	r2, [r3, #544]	; 0x220
3003b51c:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003b520:	e243300f 	sub	r3, r3, #15
3003b524:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003b528:	e2844018 	add	r4, r4, #24
3003b52c:	e7943003 	ldr	r3, [r4, r3]
3003b530:	e282203e 	add	r2, r2, #62	; 0x3e
3003b534:	e7932102 	ldr	r2, [r3, r2, lsl #2]
3003b538:	e3e03d25 	mvn	r3, #2368	; 0x940
3003b53c:	e2433007 	sub	r3, r3, #7
3003b540:	e1a01101 	lsl	r1, r1, #2
3003b544:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003b548:	e28cc018 	add	ip, ip, #24
3003b54c:	e081100c 	add	r1, r1, ip
3003b550:	e0813003 	add	r3, r1, r3
3003b554:	e5832000 	str	r2, [r3]
               if ( is_pos[i] != 7 )
3003b558:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b55c:	e5902224 	ldr	r2, [r0, #548]	; 0x224
3003b560:	e3e03d25 	mvn	r3, #2368	; 0x940
3003b564:	e2433007 	sub	r3, r3, #7
3003b568:	e1a02102 	lsl	r2, r2, #2
3003b56c:	e28d1d49 	add	r1, sp, #4672	; 0x1240
3003b570:	e2811018 	add	r1, r1, #24
3003b574:	e0822001 	add	r2, r2, r1
3003b578:	e0823003 	add	r3, r2, r3
3003b57c:	e5933000 	ldr	r3, [r3]
3003b580:	e3530007 	cmp	r3, #7
3003b584:	0a00002f 	beq	3003b648 <III_stereo+0x1934>
                  is_ratio[i] = (int)(1024*tan( is_pos[i] * (PI / 12)));
3003b588:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003b58c:	e5925224 	ldr	r5, [r2, #548]	; 0x224
3003b590:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003b594:	e5932224 	ldr	r2, [r3, #548]	; 0x224
3003b598:	e3e03d25 	mvn	r3, #2368	; 0x940
3003b59c:	e2433007 	sub	r3, r3, #7
3003b5a0:	e1a02102 	lsl	r2, r2, #2
3003b5a4:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003b5a8:	e2844018 	add	r4, r4, #24
3003b5ac:	e0822004 	add	r2, r2, r4
3003b5b0:	e0823003 	add	r3, r2, r3
3003b5b4:	e5933000 	ldr	r3, [r3]
3003b5b8:	e1a00003 	mov	r0, r3
3003b5bc:	eb00231f 	bl	30044240 <__aeabi_i2d>
3003b5c0:	e1a03000 	mov	r3, r0
3003b5c4:	e1a04001 	mov	r4, r1
3003b5c8:	e1a00003 	mov	r0, r3
3003b5cc:	e1a01004 	mov	r1, r4
3003b5d0:	e28f3e26 	add	r3, pc, #608	; 0x260
3003b5d4:	e893000c 	ldm	r3, {r2, r3}
3003b5d8:	eb00234f 	bl	3004431c <__aeabi_dmul>
3003b5dc:	e1a03000 	mov	r3, r0
3003b5e0:	e1a04001 	mov	r4, r1
3003b5e4:	e1a00003 	mov	r0, r3
3003b5e8:	e1a01004 	mov	r1, r4
3003b5ec:	ebffe771 	bl	300353b8 <tan>
3003b5f0:	e1a03000 	mov	r3, r0
3003b5f4:	e1a04001 	mov	r4, r1
3003b5f8:	e1a00003 	mov	r0, r3
3003b5fc:	e1a01004 	mov	r1, r4
3003b600:	e3a02000 	mov	r2, #0
3003b604:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003b608:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003b60c:	eb002342 	bl	3004431c <__aeabi_dmul>
3003b610:	e1a03000 	mov	r3, r0
3003b614:	e1a04001 	mov	r4, r1
3003b618:	e1a00003 	mov	r0, r3
3003b61c:	e1a01004 	mov	r1, r4
3003b620:	eb0024b5 	bl	300448fc <__aeabi_d2iz>
3003b624:	e1a02000 	mov	r2, r0
3003b628:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003b62c:	e2433007 	sub	r3, r3, #7
3003b630:	e1a01105 	lsl	r1, r5, #2
3003b634:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003b638:	e28cc018 	add	ip, ip, #24
3003b63c:	e081100c 	add	r1, r1, ip
3003b640:	e0813003 	add	r3, r1, r3
3003b644:	e5832000 	str	r2, [r3]
               i++;
3003b648:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b64c:	e5903224 	ldr	r3, [r0, #548]	; 0x224
3003b650:	e2833001 	add	r3, r3, #1
3003b654:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003b658:	e5813224 	str	r3, [r1, #548]	; 0x224
            i++;
         sfb = i;
         i = sfBandIndex[sfreq].l[i];
         for ( ; sfb<21; sfb++ )
         {  sb = sfBandIndex[sfreq].l[sfb+1] - sfBandIndex[sfreq].l[sfb];
            for ( ; sb > 0; sb--)
3003b65c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003b660:	e592322c 	ldr	r3, [r2, #556]	; 0x22c
3003b664:	e2433001 	sub	r3, r3, #1
3003b668:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b66c:	e584322c 	str	r3, [r4, #556]	; 0x22c
3003b670:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003b674:	e59c322c 	ldr	r3, [ip, #556]	; 0x22c
3003b678:	e3530000 	cmp	r3, #0
3003b67c:	caffffa2 	bgt	3003b50c <III_stereo+0x17f8>
         i = 0;
         while ( sfBandIndex[sfreq].l[i] <= sb )
            i++;
         sfb = i;
         i = sfBandIndex[sfreq].l[i];
         for ( ; sfb<21; sfb++ )
3003b680:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b684:	e5903220 	ldr	r3, [r0, #544]	; 0x220
3003b688:	e2833001 	add	r3, r3, #1
3003b68c:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003b690:	e5813220 	str	r3, [r1, #544]	; 0x220
3003b694:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003b698:	e5923220 	ldr	r3, [r2, #544]	; 0x220
3003b69c:	e3530014 	cmp	r3, #20
3003b6a0:	daffff7c 	ble	3003b498 <III_stereo+0x1784>
               if ( is_pos[i] != 7 )
                  is_ratio[i] = (int)(1024*tan( is_pos[i] * (PI / 12)));
               i++;
            }
         }
         sfb = sfBandIndex[sfreq].l[20];
3003b6a4:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003b6a8:	e5932210 	ldr	r2, [r3, #528]	; 0x210
3003b6ac:	e59f018c 	ldr	r0, [pc, #396]	; 3003b840 <III_stereo+0x1b2c>
3003b6b0:	e3a01050 	mov	r1, #80	; 0x50
3003b6b4:	e1a03002 	mov	r3, r2
3003b6b8:	e1a03183 	lsl	r3, r3, #3
3003b6bc:	e0833002 	add	r3, r3, r2
3003b6c0:	e1a03103 	lsl	r3, r3, #2
3003b6c4:	e0833002 	add	r3, r3, r2
3003b6c8:	e1a03103 	lsl	r3, r3, #2
3003b6cc:	e0833000 	add	r3, r3, r0
3003b6d0:	e0833001 	add	r3, r3, r1
3003b6d4:	e5933000 	ldr	r3, [r3]
3003b6d8:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b6dc:	e5843220 	str	r3, [r4, #544]	; 0x220
         for ( sb = 576 - sfBandIndex[sfreq].l[21]; sb > 0; sb-- )
3003b6e0:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003b6e4:	e59c2210 	ldr	r2, [ip, #528]	; 0x210
3003b6e8:	e59f0150 	ldr	r0, [pc, #336]	; 3003b840 <III_stereo+0x1b2c>
3003b6ec:	e3a01054 	mov	r1, #84	; 0x54
3003b6f0:	e1a03002 	mov	r3, r2
3003b6f4:	e1a03183 	lsl	r3, r3, #3
3003b6f8:	e0833002 	add	r3, r3, r2
3003b6fc:	e1a03103 	lsl	r3, r3, #2
3003b700:	e0833002 	add	r3, r3, r2
3003b704:	e1a03103 	lsl	r3, r3, #2
3003b708:	e0833000 	add	r3, r3, r0
3003b70c:	e0833001 	add	r3, r3, r1
3003b710:	e5933000 	ldr	r3, [r3]
3003b714:	e2633d09 	rsb	r3, r3, #576	; 0x240
3003b718:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b71c:	e580322c 	str	r3, [r0, #556]	; 0x22c
3003b720:	ea000031 	b	3003b7ec <III_stereo+0x1ad8>
         {  is_pos[i] = is_pos[sfb];
3003b724:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003b728:	e5921224 	ldr	r1, [r2, #548]	; 0x224
3003b72c:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003b730:	e5932220 	ldr	r2, [r3, #544]	; 0x220
3003b734:	e3e03d25 	mvn	r3, #2368	; 0x940
3003b738:	e2433007 	sub	r3, r3, #7
3003b73c:	e1a02102 	lsl	r2, r2, #2
3003b740:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003b744:	e2844018 	add	r4, r4, #24
3003b748:	e0822004 	add	r2, r2, r4
3003b74c:	e0823003 	add	r3, r2, r3
3003b750:	e5932000 	ldr	r2, [r3]
3003b754:	e3e03d25 	mvn	r3, #2368	; 0x940
3003b758:	e2433007 	sub	r3, r3, #7
3003b75c:	e1a01101 	lsl	r1, r1, #2
3003b760:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003b764:	e28cc018 	add	ip, ip, #24
3003b768:	e081100c 	add	r1, r1, ip
3003b76c:	e0813003 	add	r3, r1, r3
3003b770:	e5832000 	str	r2, [r3]
            is_ratio[i] = is_ratio[sfb];
3003b774:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b778:	e5901224 	ldr	r1, [r0, #548]	; 0x224
3003b77c:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003b780:	e5932220 	ldr	r2, [r3, #544]	; 0x220
3003b784:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003b788:	e2433007 	sub	r3, r3, #7
3003b78c:	e1a02102 	lsl	r2, r2, #2
3003b790:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003b794:	e2844018 	add	r4, r4, #24
3003b798:	e0822004 	add	r2, r2, r4
3003b79c:	e0823003 	add	r3, r2, r3
3003b7a0:	e5932000 	ldr	r2, [r3]
3003b7a4:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003b7a8:	e2433007 	sub	r3, r3, #7
3003b7ac:	e1a01101 	lsl	r1, r1, #2
3003b7b0:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003b7b4:	e28cc018 	add	ip, ip, #24
3003b7b8:	e081100c 	add	r1, r1, ip
3003b7bc:	e0813003 	add	r3, r1, r3
3003b7c0:	e5832000 	str	r2, [r3]
            i++;
3003b7c4:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b7c8:	e5903224 	ldr	r3, [r0, #548]	; 0x224
3003b7cc:	e2833001 	add	r3, r3, #1
3003b7d0:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003b7d4:	e5813224 	str	r3, [r1, #548]	; 0x224
                  is_ratio[i] = (int)(1024*tan( is_pos[i] * (PI / 12)));
               i++;
            }
         }
         sfb = sfBandIndex[sfreq].l[20];
         for ( sb = 576 - sfBandIndex[sfreq].l[21]; sb > 0; sb-- )
3003b7d8:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003b7dc:	e592322c 	ldr	r3, [r2, #556]	; 0x22c
3003b7e0:	e2433001 	sub	r3, r3, #1
3003b7e4:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b7e8:	e584322c 	str	r3, [r4, #556]	; 0x22c
3003b7ec:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003b7f0:	e59c322c 	ldr	r3, [ip, #556]	; 0x22c
3003b7f4:	e3530000 	cmp	r3, #0
3003b7f8:	caffffc9 	bgt	3003b724 <III_stereo+0x1a10>
3003b7fc:	ea000000 	b	3003b804 <III_stereo+0x1af0>
   /* intialization */
   for ( i=0; i<576; i++ )
      is_pos[i] = 7;

   if ((stereo == 2) && i_stereo )
   {  if (gr_info->window_switching_flag && (gr_info->block_type == 2))
3003b800:	e1a00000 	nop			; (mov r0, r0)
         }
      }
   }


   if (stereo==2)
3003b804:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b808:	e5903214 	ldr	r3, [r0, #532]	; 0x214
3003b80c:	e3530002 	cmp	r3, #2
3003b810:	1a000168 	bne	3003bdb8 <III_stereo+0x20a4>
      for(sb=0;sb<SBLIMIT;sb++)
3003b814:	e3a03000 	mov	r3, #0
3003b818:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003b81c:	e581322c 	str	r3, [r1, #556]	; 0x22c
3003b820:	ea000160 	b	3003bda8 <III_stereo+0x2094>
         for(ss=0;ss<SSLIMIT;ss++)
3003b824:	e3a03000 	mov	r3, #0
3003b828:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003b82c:	e5823230 	str	r3, [r2, #560]	; 0x230
3003b830:	ea000153 	b	3003bd84 <III_stereo+0x2070>
3003b834:	e1a00000 	nop			; (mov r0, r0)
3003b838:	382d7361 	.word	0x382d7361
3003b83c:	3fd0c152 	.word	0x3fd0c152
3003b840:	300c7eb4 	.word	0x300c7eb4
		 {
            double xr0,xr1;
			i = (sb*18)+ss;
3003b844:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003b848:	e593222c 	ldr	r2, [r3, #556]	; 0x22c
3003b84c:	e1a03002 	mov	r3, r2
3003b850:	e1a03183 	lsl	r3, r3, #3
3003b854:	e0833002 	add	r3, r3, r2
3003b858:	e1a03083 	lsl	r3, r3, #1
3003b85c:	e1a02003 	mov	r2, r3
3003b860:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b864:	e5943230 	ldr	r3, [r4, #560]	; 0x230
3003b868:	e0823003 	add	r3, r2, r3
3003b86c:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003b870:	e58c3224 	str	r3, [ip, #548]	; 0x224
			xr0=xr[0][sb][ss];
3003b874:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b878:	e590222c 	ldr	r2, [r0, #556]	; 0x22c
3003b87c:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003b880:	e5910230 	ldr	r0, [r1, #560]	; 0x230
3003b884:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003b888:	e243300b 	sub	r3, r3, #11
3003b88c:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003b890:	e2844018 	add	r4, r4, #24
3003b894:	e7941003 	ldr	r1, [r4, r3]
3003b898:	e1a03002 	mov	r3, r2
3003b89c:	e1a03183 	lsl	r3, r3, #3
3003b8a0:	e0833002 	add	r3, r3, r2
3003b8a4:	e1a03083 	lsl	r3, r3, #1
3003b8a8:	e0833000 	add	r3, r3, r0
3003b8ac:	e7913103 	ldr	r3, [r1, r3, lsl #2]
3003b8b0:	e1a00003 	mov	r0, r3
3003b8b4:	eb002261 	bl	30044240 <__aeabi_i2d>
3003b8b8:	e1a03000 	mov	r3, r0
3003b8bc:	e1a04001 	mov	r4, r1
3003b8c0:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003b8c4:	e28cc010 	add	ip, ip, #16
3003b8c8:	e90c0018 	stmdb	ip, {r3, r4}
			xr1=xr[1][sb][ss];
3003b8cc:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003b8d0:	e243300b 	sub	r3, r3, #11
3003b8d4:	e28d0d49 	add	r0, sp, #4672	; 0x1240
3003b8d8:	e2800018 	add	r0, r0, #24
3003b8dc:	e7903003 	ldr	r3, [r0, r3]
3003b8e0:	e2831c09 	add	r1, r3, #2304	; 0x900
3003b8e4:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003b8e8:	e593222c 	ldr	r2, [r3, #556]	; 0x22c
3003b8ec:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b8f0:	e5940230 	ldr	r0, [r4, #560]	; 0x230
3003b8f4:	e1a03002 	mov	r3, r2
3003b8f8:	e1a03183 	lsl	r3, r3, #3
3003b8fc:	e0833002 	add	r3, r3, r2
3003b900:	e1a03083 	lsl	r3, r3, #1
3003b904:	e0833000 	add	r3, r3, r0
3003b908:	e7913103 	ldr	r3, [r1, r3, lsl #2]
3003b90c:	e1a00003 	mov	r0, r3
3003b910:	eb00224a 	bl	30044240 <__aeabi_i2d>
3003b914:	e1a03000 	mov	r3, r0
3003b918:	e1a04001 	mov	r4, r1
3003b91c:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003b920:	e28cc010 	add	ip, ip, #16
3003b924:	e88c0018 	stm	ip, {r3, r4}
            if ( is_pos[i] == 7 ) {
3003b928:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003b92c:	e5902224 	ldr	r2, [r0, #548]	; 0x224
3003b930:	e3e03d25 	mvn	r3, #2368	; 0x940
3003b934:	e2433007 	sub	r3, r3, #7
3003b938:	e1a02102 	lsl	r2, r2, #2
3003b93c:	e28d1d49 	add	r1, sp, #4672	; 0x1240
3003b940:	e2811018 	add	r1, r1, #24
3003b944:	e0822001 	add	r2, r2, r1
3003b948:	e0823003 	add	r3, r2, r3
3003b94c:	e5933000 	ldr	r3, [r3]
3003b950:	e3530007 	cmp	r3, #7
3003b954:	1a000089 	bne	3003bb80 <III_stereo+0x1e6c>
               if ( ms_stereo ) {
3003b958:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003b95c:	e5923218 	ldr	r3, [r2, #536]	; 0x218
3003b960:	e3530000 	cmp	r3, #0
3003b964:	0a00005b 	beq	3003bad8 <III_stereo+0x1dc4>
                  //xr[0][sb][ss] = (xr0+xr1)/1.41421356;
                  //xr[1][sb][ss] = (xr0-xr1)/1.41421356;
				  xr[0][sb][ss] = ((xr0+xr1)*1024)/1448;
3003b968:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003b96c:	e593522c 	ldr	r5, [r3, #556]	; 0x22c
3003b970:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003b974:	e5946230 	ldr	r6, [r4, #560]	; 0x230
3003b978:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003b97c:	e28cc010 	add	ip, ip, #16
3003b980:	e91c0003 	ldmdb	ip, {r0, r1}
3003b984:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003b988:	e2844010 	add	r4, r4, #16
3003b98c:	e894000c 	ldm	r4, {r2, r3}
3003b990:	eb00215d 	bl	30043f0c <__adddf3>
3003b994:	e1a03000 	mov	r3, r0
3003b998:	e1a04001 	mov	r4, r1
3003b99c:	e1a00003 	mov	r0, r3
3003b9a0:	e1a01004 	mov	r1, r4
3003b9a4:	e3a02000 	mov	r2, #0
3003b9a8:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003b9ac:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003b9b0:	eb002259 	bl	3004431c <__aeabi_dmul>
3003b9b4:	e1a03000 	mov	r3, r0
3003b9b8:	e1a04001 	mov	r4, r1
3003b9bc:	e1a00003 	mov	r0, r3
3003b9c0:	e1a01004 	mov	r1, r4
3003b9c4:	e3a02000 	mov	r2, #0
3003b9c8:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003b9cc:	e2833896 	add	r3, r3, #9830400	; 0x960000
3003b9d0:	e2833a0a 	add	r3, r3, #40960	; 0xa000
3003b9d4:	eb0022f4 	bl	300445ac <__aeabi_ddiv>
3003b9d8:	e1a03000 	mov	r3, r0
3003b9dc:	e1a04001 	mov	r4, r1
3003b9e0:	e1a00003 	mov	r0, r3
3003b9e4:	e1a01004 	mov	r1, r4
3003b9e8:	eb0023c3 	bl	300448fc <__aeabi_d2iz>
3003b9ec:	e1a01000 	mov	r1, r0
3003b9f0:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003b9f4:	e243300b 	sub	r3, r3, #11
3003b9f8:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003b9fc:	e28cc018 	add	ip, ip, #24
3003ba00:	e79c2003 	ldr	r2, [ip, r3]
3003ba04:	e1a03005 	mov	r3, r5
3003ba08:	e1a03183 	lsl	r3, r3, #3
3003ba0c:	e0833005 	add	r3, r3, r5
3003ba10:	e1a03083 	lsl	r3, r3, #1
3003ba14:	e0833006 	add	r3, r3, r6
3003ba18:	e7821103 	str	r1, [r2, r3, lsl #2]
                  xr[1][sb][ss] = ((xr0-xr1)*1024)/1448;
3003ba1c:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003ba20:	e243300b 	sub	r3, r3, #11
3003ba24:	e28d0d49 	add	r0, sp, #4672	; 0x1240
3003ba28:	e2800018 	add	r0, r0, #24
3003ba2c:	e7903003 	ldr	r3, [r0, r3]
3003ba30:	e2836c09 	add	r6, r3, #2304	; 0x900
3003ba34:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003ba38:	e591522c 	ldr	r5, [r1, #556]	; 0x22c
3003ba3c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003ba40:	e5927230 	ldr	r7, [r2, #560]	; 0x230
3003ba44:	e28d3d49 	add	r3, sp, #4672	; 0x1240
3003ba48:	e2833010 	add	r3, r3, #16
3003ba4c:	e9130003 	ldmdb	r3, {r0, r1}
3003ba50:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003ba54:	e2844010 	add	r4, r4, #16
3003ba58:	e894000c 	ldm	r4, {r2, r3}
3003ba5c:	eb002129 	bl	30043f08 <__aeabi_dsub>
3003ba60:	e1a03000 	mov	r3, r0
3003ba64:	e1a04001 	mov	r4, r1
3003ba68:	e1a00003 	mov	r0, r3
3003ba6c:	e1a01004 	mov	r1, r4
3003ba70:	e3a02000 	mov	r2, #0
3003ba74:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003ba78:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003ba7c:	eb002226 	bl	3004431c <__aeabi_dmul>
3003ba80:	e1a03000 	mov	r3, r0
3003ba84:	e1a04001 	mov	r4, r1
3003ba88:	e1a00003 	mov	r0, r3
3003ba8c:	e1a01004 	mov	r1, r4
3003ba90:	e3a02000 	mov	r2, #0
3003ba94:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003ba98:	e2833896 	add	r3, r3, #9830400	; 0x960000
3003ba9c:	e2833a0a 	add	r3, r3, #40960	; 0xa000
3003baa0:	eb0022c1 	bl	300445ac <__aeabi_ddiv>
3003baa4:	e1a03000 	mov	r3, r0
3003baa8:	e1a04001 	mov	r4, r1
3003baac:	e1a00003 	mov	r0, r3
3003bab0:	e1a01004 	mov	r1, r4
3003bab4:	eb002390 	bl	300448fc <__aeabi_d2iz>
3003bab8:	e1a02000 	mov	r2, r0
3003babc:	e1a03005 	mov	r3, r5
3003bac0:	e1a03183 	lsl	r3, r3, #3
3003bac4:	e0833005 	add	r3, r3, r5
3003bac8:	e1a03083 	lsl	r3, r3, #1
3003bacc:	e0833007 	add	r3, r3, r7
3003bad0:	e7862103 	str	r2, [r6, r3, lsl #2]
			   }
               else {
                  xr[0][sb][ss] = xr0;
                  xr[1][sb][ss] = xr1;
3003bad4:	ea0000a5 	b	3003bd70 <III_stereo+0x205c>
                  //xr[1][sb][ss] = (xr0-xr1)/1.41421356;
				  xr[0][sb][ss] = ((xr0+xr1)*1024)/1448;
                  xr[1][sb][ss] = ((xr0-xr1)*1024)/1448;
			   }
               else {
                  xr[0][sb][ss] = xr0;
3003bad8:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003badc:	e59c422c 	ldr	r4, [ip, #556]	; 0x22c
3003bae0:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003bae4:	e5905230 	ldr	r5, [r0, #560]	; 0x230
3003bae8:	e28d2d49 	add	r2, sp, #4672	; 0x1240
3003baec:	e2822010 	add	r2, r2, #16
3003baf0:	e9120003 	ldmdb	r2, {r0, r1}
3003baf4:	eb002380 	bl	300448fc <__aeabi_d2iz>
3003baf8:	e1a01000 	mov	r1, r0
3003bafc:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003bb00:	e243300b 	sub	r3, r3, #11
3003bb04:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003bb08:	e28cc018 	add	ip, ip, #24
3003bb0c:	e79c2003 	ldr	r2, [ip, r3]
3003bb10:	e1a03004 	mov	r3, r4
3003bb14:	e1a03183 	lsl	r3, r3, #3
3003bb18:	e0833004 	add	r3, r3, r4
3003bb1c:	e1a03083 	lsl	r3, r3, #1
3003bb20:	e0833005 	add	r3, r3, r5
3003bb24:	e7821103 	str	r1, [r2, r3, lsl #2]
                  xr[1][sb][ss] = xr1;
3003bb28:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003bb2c:	e243300b 	sub	r3, r3, #11
3003bb30:	e28d0d49 	add	r0, sp, #4672	; 0x1240
3003bb34:	e2800018 	add	r0, r0, #24
3003bb38:	e7903003 	ldr	r3, [r0, r3]
3003bb3c:	e2835c09 	add	r5, r3, #2304	; 0x900
3003bb40:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003bb44:	e591422c 	ldr	r4, [r1, #556]	; 0x22c
3003bb48:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003bb4c:	e5926230 	ldr	r6, [r2, #560]	; 0x230
3003bb50:	e28d3d49 	add	r3, sp, #4672	; 0x1240
3003bb54:	e2833010 	add	r3, r3, #16
3003bb58:	e8930003 	ldm	r3, {r0, r1}
3003bb5c:	eb002366 	bl	300448fc <__aeabi_d2iz>
3003bb60:	e1a02000 	mov	r2, r0
3003bb64:	e1a03004 	mov	r3, r4
3003bb68:	e1a03183 	lsl	r3, r3, #3
3003bb6c:	e0833004 	add	r3, r3, r4
3003bb70:	e1a03083 	lsl	r3, r3, #1
3003bb74:	e0833006 	add	r3, r3, r6
3003bb78:	e7852103 	str	r2, [r5, r3, lsl #2]
3003bb7c:	ea00007b 	b	3003bd70 <III_stereo+0x205c>
               }
            }
            else if (i_stereo ) {
3003bb80:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003bb84:	e594321c 	ldr	r3, [r4, #540]	; 0x21c
3003bb88:	e3530000 	cmp	r3, #0
3003bb8c:	0a000077 	beq	3003bd70 <III_stereo+0x205c>
               //xr[0][sb][ss] = xr0 * (is_ratio[i]/(1+is_ratio[i]));
               //xr[1][sb][ss] = xr0 * (1/(1+is_ratio[i]));
			   xr[0][sb][ss] = (xr0 * (is_ratio[i]*1024/(1024+is_ratio[i])))/1024;
3003bb90:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003bb94:	e59c522c 	ldr	r5, [ip, #556]	; 0x22c
3003bb98:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003bb9c:	e5906230 	ldr	r6, [r0, #560]	; 0x230
3003bba0:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003bba4:	e5912224 	ldr	r2, [r1, #548]	; 0x224
3003bba8:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003bbac:	e2433007 	sub	r3, r3, #7
3003bbb0:	e1a02102 	lsl	r2, r2, #2
3003bbb4:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003bbb8:	e2844018 	add	r4, r4, #24
3003bbbc:	e0822004 	add	r2, r2, r4
3003bbc0:	e0823003 	add	r3, r2, r3
3003bbc4:	e5933000 	ldr	r3, [r3]
3003bbc8:	e1a02503 	lsl	r2, r3, #10
3003bbcc:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003bbd0:	e59c1224 	ldr	r1, [ip, #548]	; 0x224
3003bbd4:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003bbd8:	e2433007 	sub	r3, r3, #7
3003bbdc:	e1a01101 	lsl	r1, r1, #2
3003bbe0:	e28d0d49 	add	r0, sp, #4672	; 0x1240
3003bbe4:	e2800018 	add	r0, r0, #24
3003bbe8:	e0811000 	add	r1, r1, r0
3003bbec:	e0813003 	add	r3, r1, r3
3003bbf0:	e5933000 	ldr	r3, [r3]
3003bbf4:	e2833b01 	add	r3, r3, #1024	; 0x400
3003bbf8:	e1a00002 	mov	r0, r2
3003bbfc:	e1a01003 	mov	r1, r3
3003bc00:	eb00206b 	bl	30043db4 <__aeabi_idiv>
3003bc04:	e1a03000 	mov	r3, r0
3003bc08:	e1a00003 	mov	r0, r3
3003bc0c:	eb00218b 	bl	30044240 <__aeabi_i2d>
3003bc10:	e1a03000 	mov	r3, r0
3003bc14:	e1a04001 	mov	r4, r1
3003bc18:	e1a00003 	mov	r0, r3
3003bc1c:	e1a01004 	mov	r1, r4
3003bc20:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003bc24:	e2844010 	add	r4, r4, #16
3003bc28:	e914000c 	ldmdb	r4, {r2, r3}
3003bc2c:	eb0021ba 	bl	3004431c <__aeabi_dmul>
3003bc30:	e1a03000 	mov	r3, r0
3003bc34:	e1a04001 	mov	r4, r1
3003bc38:	e1a00003 	mov	r0, r3
3003bc3c:	e1a01004 	mov	r1, r4
3003bc40:	e3a02000 	mov	r2, #0
3003bc44:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003bc48:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003bc4c:	eb002256 	bl	300445ac <__aeabi_ddiv>
3003bc50:	e1a03000 	mov	r3, r0
3003bc54:	e1a04001 	mov	r4, r1
3003bc58:	e1a00003 	mov	r0, r3
3003bc5c:	e1a01004 	mov	r1, r4
3003bc60:	eb002325 	bl	300448fc <__aeabi_d2iz>
3003bc64:	e1a01000 	mov	r1, r0
3003bc68:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003bc6c:	e243300b 	sub	r3, r3, #11
3003bc70:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003bc74:	e28cc018 	add	ip, ip, #24
3003bc78:	e79c2003 	ldr	r2, [ip, r3]
3003bc7c:	e1a03005 	mov	r3, r5
3003bc80:	e1a03183 	lsl	r3, r3, #3
3003bc84:	e0833005 	add	r3, r3, r5
3003bc88:	e1a03083 	lsl	r3, r3, #1
3003bc8c:	e0833006 	add	r3, r3, r6
3003bc90:	e7821103 	str	r1, [r2, r3, lsl #2]
               xr[1][sb][ss] = (xr0 * (1024*1024/(1024+is_ratio[i])))/1024;
3003bc94:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003bc98:	e243300b 	sub	r3, r3, #11
3003bc9c:	e28d0d49 	add	r0, sp, #4672	; 0x1240
3003bca0:	e2800018 	add	r0, r0, #24
3003bca4:	e7903003 	ldr	r3, [r0, r3]
3003bca8:	e2836c09 	add	r6, r3, #2304	; 0x900
3003bcac:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003bcb0:	e591522c 	ldr	r5, [r1, #556]	; 0x22c
3003bcb4:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003bcb8:	e5927230 	ldr	r7, [r2, #560]	; 0x230
3003bcbc:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003bcc0:	e5932224 	ldr	r2, [r3, #548]	; 0x224
3003bcc4:	e3e03d49 	mvn	r3, #4672	; 0x1240
3003bcc8:	e2433007 	sub	r3, r3, #7
3003bccc:	e1a02102 	lsl	r2, r2, #2
3003bcd0:	e28d4d49 	add	r4, sp, #4672	; 0x1240
3003bcd4:	e2844018 	add	r4, r4, #24
3003bcd8:	e0822004 	add	r2, r2, r4
3003bcdc:	e0823003 	add	r3, r2, r3
3003bce0:	e5933000 	ldr	r3, [r3]
3003bce4:	e2833b01 	add	r3, r3, #1024	; 0x400
3003bce8:	e3a00601 	mov	r0, #1048576	; 0x100000
3003bcec:	e1a01003 	mov	r1, r3
3003bcf0:	eb00202f 	bl	30043db4 <__aeabi_idiv>
3003bcf4:	e1a03000 	mov	r3, r0
3003bcf8:	e1a00003 	mov	r0, r3
3003bcfc:	eb00214f 	bl	30044240 <__aeabi_i2d>
3003bd00:	e1a03000 	mov	r3, r0
3003bd04:	e1a04001 	mov	r4, r1
3003bd08:	e1a00003 	mov	r0, r3
3003bd0c:	e1a01004 	mov	r1, r4
3003bd10:	e28dcd49 	add	ip, sp, #4672	; 0x1240
3003bd14:	e28cc010 	add	ip, ip, #16
3003bd18:	e91c000c 	ldmdb	ip, {r2, r3}
3003bd1c:	eb00217e 	bl	3004431c <__aeabi_dmul>
3003bd20:	e1a03000 	mov	r3, r0
3003bd24:	e1a04001 	mov	r4, r1
3003bd28:	e1a00003 	mov	r0, r3
3003bd2c:	e1a01004 	mov	r1, r4
3003bd30:	e3a02000 	mov	r2, #0
3003bd34:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003bd38:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003bd3c:	eb00221a 	bl	300445ac <__aeabi_ddiv>
3003bd40:	e1a03000 	mov	r3, r0
3003bd44:	e1a04001 	mov	r4, r1
3003bd48:	e1a00003 	mov	r0, r3
3003bd4c:	e1a01004 	mov	r1, r4
3003bd50:	eb0022e9 	bl	300448fc <__aeabi_d2iz>
3003bd54:	e1a02000 	mov	r2, r0
3003bd58:	e1a03005 	mov	r3, r5
3003bd5c:	e1a03183 	lsl	r3, r3, #3
3003bd60:	e0833005 	add	r3, r3, r5
3003bd64:	e1a03083 	lsl	r3, r3, #1
3003bd68:	e0833007 	add	r3, r3, r7
3003bd6c:	e7862103 	str	r2, [r6, r3, lsl #2]
   }


   if (stereo==2)
      for(sb=0;sb<SBLIMIT;sb++)
         for(ss=0;ss<SSLIMIT;ss++)
3003bd70:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003bd74:	e5903230 	ldr	r3, [r0, #560]	; 0x230
3003bd78:	e2833001 	add	r3, r3, #1
3003bd7c:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003bd80:	e5813230 	str	r3, [r1, #560]	; 0x230
3003bd84:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003bd88:	e5923230 	ldr	r3, [r2, #560]	; 0x230
3003bd8c:	e3530011 	cmp	r3, #17
3003bd90:	dafffeab 	ble	3003b844 <III_stereo+0x1b30>
      }
   }


   if (stereo==2)
      for(sb=0;sb<SBLIMIT;sb++)
3003bd94:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3003bd98:	e594322c 	ldr	r3, [r4, #556]	; 0x22c
3003bd9c:	e2833001 	add	r3, r3, #1
3003bda0:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003bda4:	e58c322c 	str	r3, [ip, #556]	; 0x22c
3003bda8:	e28d0a01 	add	r0, sp, #4096	; 0x1000
3003bdac:	e590322c 	ldr	r3, [r0, #556]	; 0x22c
3003bdb0:	e353001f 	cmp	r3, #31
3003bdb4:	dafffe9a 	ble	3003b824 <III_stereo+0x1b10>
//            else 
//               printf("Error in streo processing\n");
            
         }

} 
3003bdb8:	e28ddf97 	add	sp, sp, #604	; 0x25c
3003bdbc:	e28dda01 	add	sp, sp, #4096	; 0x1000
3003bdc0:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
3003bdc4:	e12fff1e 	bx	lr

3003bdc8 <III_antialias>:


int cs[8] = {868, 896, 971, 1007, 1019, 1023, 1024, 1024};
int ca[8] = {-521, -479, -320, -186, -97, -42, -15, -3.8};
void III_antialias(int hybridIn[SBLIMIT][SSLIMIT], struct Granule *gr_info)
{
3003bdc8:	e24dd020 	sub	sp, sp, #32
3003bdcc:	e58d0004 	str	r0, [sp, #4]
3003bdd0:	e58d1000 	str	r1, [sp]
   static int    init = 1;
   //static double ca[8],cs[8];
   int  bu,bd;  /* upper and lower butterfly inputs */
   int  ss,sb,sblim;

   if (init) {
3003bdd4:	e59f321c 	ldr	r3, [pc, #540]	; 3003bff8 <III_antialias+0x230>
3003bdd8:	e5933000 	ldr	r3, [r3]
3003bddc:	e3530000 	cmp	r3, #0
3003bde0:	0a000002 	beq	3003bdf0 <III_antialias+0x28>
      for (i=0;i<8;i++) {
         sq=sqrt(1.0+Ci[i]*Ci[i]);
         cs[i] = 1.0/sq;
         ca[i] = Ci[i]/sq;
      }*/
      init = 0;
3003bde4:	e59f320c 	ldr	r3, [pc, #524]	; 3003bff8 <III_antialias+0x230>
3003bde8:	e3a02000 	mov	r2, #0
3003bdec:	e5832000 	str	r2, [r3]
   }

   /* clear all inputs */


   if  (gr_info->window_switching_flag && (gr_info->block_type == 2) &&
3003bdf0:	e59d3000 	ldr	r3, [sp]
3003bdf4:	e5933010 	ldr	r3, [r3, #16]
3003bdf8:	e3530000 	cmp	r3, #0
3003bdfc:	0a000007 	beq	3003be20 <III_antialias+0x58>
3003be00:	e59d3000 	ldr	r3, [sp]
3003be04:	e5933014 	ldr	r3, [r3, #20]
3003be08:	e3530002 	cmp	r3, #2
3003be0c:	1a000003 	bne	3003be20 <III_antialias+0x58>
       !gr_info->mixed_block_flag ) return;
3003be10:	e59d3000 	ldr	r3, [sp]
3003be14:	e5933018 	ldr	r3, [r3, #24]
   }

   /* clear all inputs */


   if  (gr_info->window_switching_flag && (gr_info->block_type == 2) &&
3003be18:	e3530000 	cmp	r3, #0
3003be1c:	0a000072 	beq	3003bfec <III_antialias+0x224>
       !gr_info->mixed_block_flag ) return;

   if ( gr_info->window_switching_flag && gr_info->mixed_block_flag &&
3003be20:	e59d3000 	ldr	r3, [sp]
3003be24:	e5933010 	ldr	r3, [r3, #16]
3003be28:	e3530000 	cmp	r3, #0
3003be2c:	0a00000a 	beq	3003be5c <III_antialias+0x94>
3003be30:	e59d3000 	ldr	r3, [sp]
3003be34:	e5933018 	ldr	r3, [r3, #24]
3003be38:	e3530000 	cmp	r3, #0
3003be3c:	0a000006 	beq	3003be5c <III_antialias+0x94>
     (gr_info->block_type == 2))
3003be40:	e59d3000 	ldr	r3, [sp]
3003be44:	e5933014 	ldr	r3, [r3, #20]


   if  (gr_info->window_switching_flag && (gr_info->block_type == 2) &&
       !gr_info->mixed_block_flag ) return;

   if ( gr_info->window_switching_flag && gr_info->mixed_block_flag &&
3003be48:	e3530002 	cmp	r3, #2
3003be4c:	1a000002 	bne	3003be5c <III_antialias+0x94>
     (gr_info->block_type == 2))
      sblim = 1;
3003be50:	e3a03001 	mov	r3, #1
3003be54:	e58d301c 	str	r3, [sp, #28]


   if  (gr_info->window_switching_flag && (gr_info->block_type == 2) &&
       !gr_info->mixed_block_flag ) return;

   if ( gr_info->window_switching_flag && gr_info->mixed_block_flag &&
3003be58:	ea000001 	b	3003be64 <III_antialias+0x9c>
     (gr_info->block_type == 2))
      sblim = 1;
   else
      sblim = SBLIMIT-1;
3003be5c:	e3a0301f 	mov	r3, #31
3003be60:	e58d301c 	str	r3, [sp, #28]

   /* 31 alias-reduction operations between each pair of sub-bands */
   /* with 8 butterflies between each pair                         */

   for(sb=0;sb<sblim;sb++)
3003be64:	e3a03000 	mov	r3, #0
3003be68:	e58d3018 	str	r3, [sp, #24]
3003be6c:	ea000059 	b	3003bfd8 <III_antialias+0x210>
      for(ss=0;ss<8;ss++)
3003be70:	e3a03000 	mov	r3, #0
3003be74:	e58d3014 	str	r3, [sp, #20]
3003be78:	ea000050 	b	3003bfc0 <III_antialias+0x1f8>
	  {
         bu = hybridIn[sb][17-ss];
3003be7c:	e59d2018 	ldr	r2, [sp, #24]
3003be80:	e1a03002 	mov	r3, r2
3003be84:	e1a03183 	lsl	r3, r3, #3
3003be88:	e0833002 	add	r3, r3, r2
3003be8c:	e1a03183 	lsl	r3, r3, #3
3003be90:	e1a02003 	mov	r2, r3
3003be94:	e59d3004 	ldr	r3, [sp, #4]
3003be98:	e0823003 	add	r3, r2, r3
3003be9c:	e59d2014 	ldr	r2, [sp, #20]
3003bea0:	e2622011 	rsb	r2, r2, #17
3003bea4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3003bea8:	e58d300c 	str	r3, [sp, #12]
         bd = hybridIn[sb+1][ss];
3003beac:	e59d3018 	ldr	r3, [sp, #24]
3003beb0:	e2832001 	add	r2, r3, #1
3003beb4:	e1a03002 	mov	r3, r2
3003beb8:	e1a03183 	lsl	r3, r3, #3
3003bebc:	e0833002 	add	r3, r3, r2
3003bec0:	e1a03183 	lsl	r3, r3, #3
3003bec4:	e1a02003 	mov	r2, r3
3003bec8:	e59d3004 	ldr	r3, [sp, #4]
3003becc:	e0823003 	add	r3, r2, r3
3003bed0:	e59d2014 	ldr	r2, [sp, #20]
3003bed4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3003bed8:	e58d3010 	str	r3, [sp, #16]

         hybridIn[sb][17-ss] = ((bu * cs[ss]) - (bd * ca[ss]))/1024;  // /1024
3003bedc:	e59d2018 	ldr	r2, [sp, #24]
3003bee0:	e1a03002 	mov	r3, r2
3003bee4:	e1a03183 	lsl	r3, r3, #3
3003bee8:	e0833002 	add	r3, r3, r2
3003beec:	e1a03183 	lsl	r3, r3, #3
3003bef0:	e1a02003 	mov	r2, r3
3003bef4:	e59d3004 	ldr	r3, [sp, #4]
3003bef8:	e0821003 	add	r1, r2, r3
3003befc:	e59d3014 	ldr	r3, [sp, #20]
3003bf00:	e2630011 	rsb	r0, r3, #17
3003bf04:	e59d2014 	ldr	r2, [sp, #20]
3003bf08:	e59f30ec 	ldr	r3, [pc, #236]	; 3003bffc <III_antialias+0x234>
3003bf0c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3003bf10:	e59d200c 	ldr	r2, [sp, #12]
3003bf14:	e0020293 	mul	r2, r3, r2
3003bf18:	e59dc014 	ldr	ip, [sp, #20]
3003bf1c:	e59f30dc 	ldr	r3, [pc, #220]	; 3003c000 <III_antialias+0x238>
3003bf20:	e793310c 	ldr	r3, [r3, ip, lsl #2]
3003bf24:	e59dc010 	ldr	ip, [sp, #16]
3003bf28:	e003039c 	mul	r3, ip, r3
3003bf2c:	e0633002 	rsb	r3, r3, r2
3003bf30:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003bf34:	e2822003 	add	r2, r2, #3
3003bf38:	e3530000 	cmp	r3, #0
3003bf3c:	b1a03002 	movlt	r3, r2
3003bf40:	e1a03543 	asr	r3, r3, #10
3003bf44:	e7813100 	str	r3, [r1, r0, lsl #2]
		 hybridIn[sb+1][ss] = ((bd * cs[ss]) + (bu * ca[ss]))/1024;
3003bf48:	e59d3018 	ldr	r3, [sp, #24]
3003bf4c:	e2832001 	add	r2, r3, #1
3003bf50:	e1a03002 	mov	r3, r2
3003bf54:	e1a03183 	lsl	r3, r3, #3
3003bf58:	e0833002 	add	r3, r3, r2
3003bf5c:	e1a03183 	lsl	r3, r3, #3
3003bf60:	e1a02003 	mov	r2, r3
3003bf64:	e59d3004 	ldr	r3, [sp, #4]
3003bf68:	e0821003 	add	r1, r2, r3
3003bf6c:	e59d0014 	ldr	r0, [sp, #20]
3003bf70:	e59d2014 	ldr	r2, [sp, #20]
3003bf74:	e59f3080 	ldr	r3, [pc, #128]	; 3003bffc <III_antialias+0x234>
3003bf78:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3003bf7c:	e59d2010 	ldr	r2, [sp, #16]
3003bf80:	e0020293 	mul	r2, r3, r2
3003bf84:	e59dc014 	ldr	ip, [sp, #20]
3003bf88:	e59f3070 	ldr	r3, [pc, #112]	; 3003c000 <III_antialias+0x238>
3003bf8c:	e793310c 	ldr	r3, [r3, ip, lsl #2]
3003bf90:	e59dc00c 	ldr	ip, [sp, #12]
3003bf94:	e003039c 	mul	r3, ip, r3
3003bf98:	e0823003 	add	r3, r2, r3
3003bf9c:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003bfa0:	e2822003 	add	r2, r2, #3
3003bfa4:	e3530000 	cmp	r3, #0
3003bfa8:	b1a03002 	movlt	r3, r2
3003bfac:	e1a03543 	asr	r3, r3, #10
3003bfb0:	e7813100 	str	r3, [r1, r0, lsl #2]

   /* 31 alias-reduction operations between each pair of sub-bands */
   /* with 8 butterflies between each pair                         */

   for(sb=0;sb<sblim;sb++)
      for(ss=0;ss<8;ss++)
3003bfb4:	e59d3014 	ldr	r3, [sp, #20]
3003bfb8:	e2833001 	add	r3, r3, #1
3003bfbc:	e58d3014 	str	r3, [sp, #20]
3003bfc0:	e59d3014 	ldr	r3, [sp, #20]
3003bfc4:	e3530007 	cmp	r3, #7
3003bfc8:	daffffab 	ble	3003be7c <III_antialias+0xb4>
      sblim = SBLIMIT-1;

   /* 31 alias-reduction operations between each pair of sub-bands */
   /* with 8 butterflies between each pair                         */

   for(sb=0;sb<sblim;sb++)
3003bfcc:	e59d3018 	ldr	r3, [sp, #24]
3003bfd0:	e2833001 	add	r3, r3, #1
3003bfd4:	e58d3018 	str	r3, [sp, #24]
3003bfd8:	e59d2018 	ldr	r2, [sp, #24]
3003bfdc:	e59d301c 	ldr	r3, [sp, #28]
3003bfe0:	e1520003 	cmp	r2, r3
3003bfe4:	baffffa1 	blt	3003be70 <III_antialias+0xa8>
3003bfe8:	ea000000 	b	3003bff0 <III_antialias+0x228>

   /* clear all inputs */


   if  (gr_info->window_switching_flag && (gr_info->block_type == 2) &&
       !gr_info->mixed_block_flag ) return;
3003bfec:	e1a00000 	nop			; (mov r0, r0)
         bd = hybridIn[sb+1][ss];

         hybridIn[sb][17-ss] = ((bu * cs[ss]) - (bd * ca[ss]))/1024;  // /1024
		 hybridIn[sb+1][ss] = ((bd * cs[ss]) + (bu * ca[ss]))/1024;
      }
}
3003bff0:	e28dd020 	add	sp, sp, #32
3003bff4:	e12fff1e 	bx	lr
3003bff8:	300c91a8 	.word	0x300c91a8
3003bffc:	300c9168 	.word	0x300c9168
3003c000:	300c9188 	.word	0x300c9188

3003c004 <buffer_CRC>:
    fwrite(pcm,2,SBLIMIT*SSLIMIT*2,outFile);
}

*/
void  buffer_CRC()
{
3003c004:	e92d4008 	push	{r3, lr}
    getbit(16);
3003c008:	e3a00010 	mov	r0, #16
3003c00c:	ebffe7ca 	bl	30035f3c <getbit>
}
3003c010:	e8bd4008 	pop	{r3, lr}
3003c014:	e12fff1e 	bx	lr

3003c018 <main_data_slots>:

extern int bitrate[3][15];
extern double s_freq[4];
/* Return the number of slots for main data of current frame, */
int main_data_slots()
{
3003c018:	e92d4010 	push	{r4, lr}
3003c01c:	e24dd008 	sub	sp, sp, #8
	unsigned int nSlots; 
 
	nSlots = (unsigned int)((144 * bitrate[2][fr_ps.header->bitrate_index])
3003c020:	e59f3108 	ldr	r3, [pc, #264]	; 3003c130 <main_data_slots+0x118>
3003c024:	e5933000 	ldr	r3, [r3]
3003c028:	e593200c 	ldr	r2, [r3, #12]
3003c02c:	e59f3100 	ldr	r3, [pc, #256]	; 3003c134 <main_data_slots+0x11c>
3003c030:	e282201e 	add	r2, r2, #30
3003c034:	e7932102 	ldr	r2, [r3, r2, lsl #2]
3003c038:	e1a03002 	mov	r3, r2
3003c03c:	e1a03183 	lsl	r3, r3, #3
3003c040:	e0833002 	add	r3, r3, r2
3003c044:	e1a03203 	lsl	r3, r3, #4
3003c048:	e1a00003 	mov	r0, r3
3003c04c:	eb00207b 	bl	30044240 <__aeabi_i2d>
3003c050:	e1a02001 	mov	r2, r1
3003c054:	e1a01000 	mov	r1, r0
			/ s_freq[fr_ps.header->sampling_frequency]);
3003c058:	e59f30d0 	ldr	r3, [pc, #208]	; 3003c130 <main_data_slots+0x118>
3003c05c:	e5933000 	ldr	r3, [r3]
3003c060:	e5930010 	ldr	r0, [r3, #16]
3003c064:	e59f30cc 	ldr	r3, [pc, #204]	; 3003c138 <main_data_slots+0x120>
3003c068:	e1a00180 	lsl	r0, r0, #3
3003c06c:	e0803003 	add	r3, r0, r3
3003c070:	e8930018 	ldm	r3, {r3, r4}
/* Return the number of slots for main data of current frame, */
int main_data_slots()
{
	unsigned int nSlots; 
 
	nSlots = (unsigned int)((144 * bitrate[2][fr_ps.header->bitrate_index])
3003c074:	e1a00001 	mov	r0, r1
3003c078:	e1a01002 	mov	r1, r2
3003c07c:	e1a02003 	mov	r2, r3
3003c080:	e1a03004 	mov	r3, r4
3003c084:	eb002148 	bl	300445ac <__aeabi_ddiv>
3003c088:	e1a03000 	mov	r3, r0
3003c08c:	e1a04001 	mov	r4, r1
3003c090:	e1a00003 	mov	r0, r3
3003c094:	e1a01004 	mov	r1, r4
3003c098:	eb00222e 	bl	30044958 <__aeabi_d2uiz>
3003c09c:	e1a03000 	mov	r3, r0
3003c0a0:	e58d3004 	str	r3, [sp, #4]
			/ s_freq[fr_ps.header->sampling_frequency]);
	if (fr_ps.header->padding) nSlots++;
3003c0a4:	e59f3084 	ldr	r3, [pc, #132]	; 3003c130 <main_data_slots+0x118>
3003c0a8:	e5933000 	ldr	r3, [r3]
3003c0ac:	e5933014 	ldr	r3, [r3, #20]
3003c0b0:	e3530000 	cmp	r3, #0
3003c0b4:	0a000002 	beq	3003c0c4 <main_data_slots+0xac>
3003c0b8:	e59d3004 	ldr	r3, [sp, #4]
3003c0bc:	e2833001 	add	r3, r3, #1
3003c0c0:	e58d3004 	str	r3, [sp, #4]
	nSlots -= 4;                         //��ȥ4�ֽڵ�ͷ
3003c0c4:	e59d3004 	ldr	r3, [sp, #4]
3003c0c8:	e2433004 	sub	r3, r3, #4
3003c0cc:	e58d3004 	str	r3, [sp, #4]
	if (fr_ps.header->error_protection)  //����CRC ���2�ֽ�
3003c0d0:	e59f3058 	ldr	r3, [pc, #88]	; 3003c130 <main_data_slots+0x118>
3003c0d4:	e5933000 	ldr	r3, [r3]
3003c0d8:	e5933008 	ldr	r3, [r3, #8]
3003c0dc:	e3530000 	cmp	r3, #0
3003c0e0:	0a000002 	beq	3003c0f0 <main_data_slots+0xd8>
		nSlots -= 2;
3003c0e4:	e59d3004 	ldr	r3, [sp, #4]
3003c0e8:	e2433002 	sub	r3, r3, #2
3003c0ec:	e58d3004 	str	r3, [sp, #4]
	if (fr_ps.stereo == 1)               //�����-17�ֽڵ�side ��Ϣ
3003c0f0:	e59f3038 	ldr	r3, [pc, #56]	; 3003c130 <main_data_slots+0x118>
3003c0f4:	e5933008 	ldr	r3, [r3, #8]
3003c0f8:	e3530001 	cmp	r3, #1
3003c0fc:	1a000003 	bne	3003c110 <main_data_slots+0xf8>
		nSlots -= 17;
3003c100:	e59d3004 	ldr	r3, [sp, #4]
3003c104:	e2433011 	sub	r3, r3, #17
3003c108:	e58d3004 	str	r3, [sp, #4]
3003c10c:	ea000002 	b	3003c11c <main_data_slots+0x104>
	else
		nSlots -=32;                     //�����-32�ֽڵ�side ��Ϣ
3003c110:	e59d3004 	ldr	r3, [sp, #4]
3003c114:	e2433020 	sub	r3, r3, #32
3003c118:	e58d3004 	str	r3, [sp, #4]
	return(nSlots);
3003c11c:	e59d3004 	ldr	r3, [sp, #4]
}
3003c120:	e1a00003 	mov	r0, r3
3003c124:	e28dd008 	add	sp, sp, #8
3003c128:	e8bd4010 	pop	{r4, lr}
3003c12c:	e12fff1e 	bx	lr
3003c130:	302be81c 	.word	0x302be81c
3003c134:	300c6454 	.word	0x300c6454
3003c138:	300c6418 	.word	0x300c6418
3003c13c:	e1a00000 	nop			; (mov r0, r0)

3003c140 <Granule_subband_synthesis>:
void matrix_mul8(int in1[8][8],
		int in2[8][8],
		int out[8][8]);

void Granule_subband_synthesis(int ch, int s[SBLIMIT][SSLIMIT], short SAM[2][SSLIMIT][SBLIMIT])
{
3003c140:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3003c144:	e24dd0bc 	sub	sp, sp, #188	; 0xbc
3003c148:	e58d000c 	str	r0, [sp, #12]
3003c14c:	e58d1008 	str	r1, [sp, #8]
3003c150:	e58d2004 	str	r2, [sp, #4]
    int i, j, t, k;
	long is;
    int band[32];
    int *v, sum, *d;
	short *S=&SAM[0][0][0];
3003c154:	e59d3004 	ldr	r3, [sp, #4]
3003c158:	e58d30b4 	str	r3, [sp, #180]	; 0xb4
       PCM samples, so the result of 18 of these is 18*32=576 samples.
     */

    /* go through each time window */
	
    for(t = 0; t < 18; t++)
3003c15c:	e3a03000 	mov	r3, #0
3003c160:	e58d309c 	str	r3, [sp, #156]	; 0x9c
3003c164:	ea000095 	b	3003c3c0 <Granule_subband_synthesis+0x280>
	{
	/* extract the subband strengths */
  	    v = &s[0][t];
3003c168:	e59d2008 	ldr	r2, [sp, #8]
3003c16c:	e59d309c 	ldr	r3, [sp, #156]	; 0x9c
3003c170:	e1a03103 	lsl	r3, r3, #2
3003c174:	e0823003 	add	r3, r2, r3
3003c178:	e58d30a8 	str	r3, [sp, #168]	; 0xa8
		for(i = 0; i < 32; i++)
3003c17c:	e3a03000 	mov	r3, #0
3003c180:	e58d3094 	str	r3, [sp, #148]	; 0x94
3003c184:	ea00000e 	b	3003c1c4 <Granule_subband_synthesis+0x84>
		{
	      band[i] = *v;
3003c188:	e59d1094 	ldr	r1, [sp, #148]	; 0x94
3003c18c:	e59d30a8 	ldr	r3, [sp, #168]	; 0xa8
3003c190:	e5932000 	ldr	r2, [r3]
3003c194:	e3e030a3 	mvn	r3, #163	; 0xa3
3003c198:	e1a01101 	lsl	r1, r1, #2
3003c19c:	e28d00b8 	add	r0, sp, #184	; 0xb8
3003c1a0:	e0811000 	add	r1, r1, r0
3003c1a4:	e0813003 	add	r3, r1, r3
3003c1a8:	e5832000 	str	r2, [r3]
	      v = &v[18];
3003c1ac:	e59d30a8 	ldr	r3, [sp, #168]	; 0xa8
3003c1b0:	e2833048 	add	r3, r3, #72	; 0x48
3003c1b4:	e58d30a8 	str	r3, [sp, #168]	; 0xa8
	
    for(t = 0; t < 18; t++)
	{
	/* extract the subband strengths */
  	    v = &s[0][t];
		for(i = 0; i < 32; i++)
3003c1b8:	e59d3094 	ldr	r3, [sp, #148]	; 0x94
3003c1bc:	e2833001 	add	r3, r3, #1
3003c1c0:	e58d3094 	str	r3, [sp, #148]	; 0x94
3003c1c4:	e59d3094 	ldr	r3, [sp, #148]	; 0x94
3003c1c8:	e353001f 	cmp	r3, #31
3003c1cc:	daffffed 	ble	3003c188 <Granule_subband_synthesis+0x48>
		{
	      band[i] = *v;
	      v = &v[18];
		}
	/* advance the buffer position */
	   Granule_sbsynth_Vptr[ch] = (Granule_sbsynth_Vptr[ch] - 64) & 0x3ff;
3003c1d0:	e59d100c 	ldr	r1, [sp, #12]
3003c1d4:	e59d200c 	ldr	r2, [sp, #12]
3003c1d8:	e59f31f8 	ldr	r3, [pc, #504]	; 3003c3d8 <Granule_subband_synthesis+0x298>
3003c1dc:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3003c1e0:	e2433040 	sub	r3, r3, #64	; 0x40
3003c1e4:	e1a03b03 	lsl	r3, r3, #22
3003c1e8:	e1a03b23 	lsr	r3, r3, #22
3003c1ec:	e59f21e4 	ldr	r2, [pc, #484]	; 3003c3d8 <Granule_subband_synthesis+0x298>
3003c1f0:	e7823101 	str	r3, [r2, r1, lsl #2]
	   v = &Granule_sbsynth_V[ch][Granule_sbsynth_Vptr[ch]];
3003c1f4:	e59f21e0 	ldr	r2, [pc, #480]	; 3003c3dc <Granule_subband_synthesis+0x29c>
3003c1f8:	e59d300c 	ldr	r3, [sp, #12]
3003c1fc:	e1a01503 	lsl	r1, r3, #10
3003c200:	e59d000c 	ldr	r0, [sp, #12]
3003c204:	e59f31cc 	ldr	r3, [pc, #460]	; 3003c3d8 <Granule_subband_synthesis+0x298>
3003c208:	e7933100 	ldr	r3, [r3, r0, lsl #2]
3003c20c:	e0813003 	add	r3, r1, r3
3003c210:	e1a03103 	lsl	r3, r3, #2
3003c214:	e0823003 	add	r3, r2, r3
3003c218:	e58d30a8 	str	r3, [sp, #168]	; 0xa8

	   fast_idct(band, v);
3003c21c:	e28d3014 	add	r3, sp, #20
3003c220:	e1a00003 	mov	r0, r3
3003c224:	e59d10a8 	ldr	r1, [sp, #168]	; 0xa8
3003c228:	eb0002d8 	bl	3003cd90 <fast_idct>
	/* 32*16=512 mac's */
    /*      15          */
    /* Sj =SIGM W(j+32i) */
    /*     i=0          */

	  v = &Granule_sbsynth_V[ch][0];
3003c22c:	e59f21a8 	ldr	r2, [pc, #424]	; 3003c3dc <Granule_subband_synthesis+0x29c>
3003c230:	e59d300c 	ldr	r3, [sp, #12]
3003c234:	e1a03603 	lsl	r3, r3, #12
3003c238:	e0823003 	add	r3, r2, r3
3003c23c:	e58d30a8 	str	r3, [sp, #168]	; 0xa8
      for (j = 0; j < 32; j++) 
3003c240:	e3a03000 	mov	r3, #0
3003c244:	e58d3098 	str	r3, [sp, #152]	; 0x98
3003c248:	ea000056 	b	3003c3a8 <Granule_subband_synthesis+0x268>
	  {
        d = &D_coex[j];
3003c24c:	e59d3098 	ldr	r3, [sp, #152]	; 0x98
3003c250:	e1a02103 	lsl	r2, r3, #2
3003c254:	e59f3184 	ldr	r3, [pc, #388]	; 3003c3e0 <Granule_subband_synthesis+0x2a0>
3003c258:	e0823003 	add	r3, r2, r3
3003c25c:	e58d30b0 	str	r3, [sp, #176]	; 0xb0
	    k = j + Granule_sbsynth_Vptr[ch];
3003c260:	e59d200c 	ldr	r2, [sp, #12]
3003c264:	e59f316c 	ldr	r3, [pc, #364]	; 3003c3d8 <Granule_subband_synthesis+0x298>
3003c268:	e7932102 	ldr	r2, [r3, r2, lsl #2]
3003c26c:	e59d3098 	ldr	r3, [sp, #152]	; 0x98
3003c270:	e0823003 	add	r3, r2, r3
3003c274:	e58d30a0 	str	r3, [sp, #160]	; 0xa0
	    sum = 0.0f;
3003c278:	e3a03000 	mov	r3, #0
3003c27c:	e58d30ac 	str	r3, [sp, #172]	; 0xac
	    for(i = 0; i < 8; i++) 
3003c280:	e3a03000 	mov	r3, #0
3003c284:	e58d3094 	str	r3, [sp, #148]	; 0x94
3003c288:	ea000026 	b	3003c328 <Granule_subband_synthesis+0x1e8>
		{
	      sum += d[0] * v[k];
3003c28c:	e59d30b0 	ldr	r3, [sp, #176]	; 0xb0
3003c290:	e5933000 	ldr	r3, [r3]
3003c294:	e59d20a0 	ldr	r2, [sp, #160]	; 0xa0
3003c298:	e1a01102 	lsl	r1, r2, #2
3003c29c:	e59d20a8 	ldr	r2, [sp, #168]	; 0xa8
3003c2a0:	e0812002 	add	r2, r1, r2
3003c2a4:	e5922000 	ldr	r2, [r2]
3003c2a8:	e0030392 	mul	r3, r2, r3
3003c2ac:	e59d20ac 	ldr	r2, [sp, #172]	; 0xac
3003c2b0:	e0823003 	add	r3, r2, r3
3003c2b4:	e58d30ac 	str	r3, [sp, #172]	; 0xac
	      k = (k + 96) & 0x3ff;
3003c2b8:	e59d30a0 	ldr	r3, [sp, #160]	; 0xa0
3003c2bc:	e2833060 	add	r3, r3, #96	; 0x60
3003c2c0:	e1a03b03 	lsl	r3, r3, #22
3003c2c4:	e1a03b23 	lsr	r3, r3, #22
3003c2c8:	e58d30a0 	str	r3, [sp, #160]	; 0xa0
	      sum += d[32] * v[k];
3003c2cc:	e59d30b0 	ldr	r3, [sp, #176]	; 0xb0
3003c2d0:	e2833080 	add	r3, r3, #128	; 0x80
3003c2d4:	e5933000 	ldr	r3, [r3]
3003c2d8:	e59d20a0 	ldr	r2, [sp, #160]	; 0xa0
3003c2dc:	e1a01102 	lsl	r1, r2, #2
3003c2e0:	e59d20a8 	ldr	r2, [sp, #168]	; 0xa8
3003c2e4:	e0812002 	add	r2, r1, r2
3003c2e8:	e5922000 	ldr	r2, [r2]
3003c2ec:	e0030392 	mul	r3, r2, r3
3003c2f0:	e59d20ac 	ldr	r2, [sp, #172]	; 0xac
3003c2f4:	e0823003 	add	r3, r2, r3
3003c2f8:	e58d30ac 	str	r3, [sp, #172]	; 0xac
	      k = (k + 32) & 0x3ff; 
3003c2fc:	e59d30a0 	ldr	r3, [sp, #160]	; 0xa0
3003c300:	e2833020 	add	r3, r3, #32
3003c304:	e1a03b03 	lsl	r3, r3, #22
3003c308:	e1a03b23 	lsr	r3, r3, #22
3003c30c:	e58d30a0 	str	r3, [sp, #160]	; 0xa0
	      d = &d[64];
3003c310:	e59d30b0 	ldr	r3, [sp, #176]	; 0xb0
3003c314:	e2833c01 	add	r3, r3, #256	; 0x100
3003c318:	e58d30b0 	str	r3, [sp, #176]	; 0xb0
      for (j = 0; j < 32; j++) 
	  {
        d = &D_coex[j];
	    k = j + Granule_sbsynth_Vptr[ch];
	    sum = 0.0f;
	    for(i = 0; i < 8; i++) 
3003c31c:	e59d3094 	ldr	r3, [sp, #148]	; 0x94
3003c320:	e2833001 	add	r3, r3, #1
3003c324:	e58d3094 	str	r3, [sp, #148]	; 0x94
3003c328:	e59d3094 	ldr	r3, [sp, #148]	; 0x94
3003c32c:	e3530007 	cmp	r3, #7
3003c330:	daffffd5 	ble	3003c28c <Granule_subband_synthesis+0x14c>
	      k = (k + 32) & 0x3ff; 
	      d = &d[64];
		}
	
	  /* convert to integer, and clip the output */
 	    is = (long)(sum*32768);
3003c334:	e59d30ac 	ldr	r3, [sp, #172]	; 0xac
3003c338:	e1a03783 	lsl	r3, r3, #15
3003c33c:	e58d30a4 	str	r3, [sp, #164]	; 0xa4
	
	    if(is >= 32768) 
3003c340:	e59d20a4 	ldr	r2, [sp, #164]	; 0xa4
3003c344:	e3a03c7f 	mov	r3, #32512	; 0x7f00
3003c348:	e28330ff 	add	r3, r3, #255	; 0xff
3003c34c:	e1520003 	cmp	r2, r3
3003c350:	da000003 	ble	3003c364 <Granule_subband_synthesis+0x224>
	      is = 32767;
3003c354:	e3a03c7f 	mov	r3, #32512	; 0x7f00
3003c358:	e28330ff 	add	r3, r3, #255	; 0xff
3003c35c:	e58d30a4 	str	r3, [sp, #164]	; 0xa4
3003c360:	ea000005 	b	3003c37c <Granule_subband_synthesis+0x23c>
	    else if(is < -32768)
3003c364:	e59d30a4 	ldr	r3, [sp, #164]	; 0xa4
3003c368:	e3730902 	cmn	r3, #32768	; 0x8000
3003c36c:	aa000002 	bge	3003c37c <Granule_subband_synthesis+0x23c>
	      is = -32768;
3003c370:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
3003c374:	e1a03843 	asr	r3, r3, #16
3003c378:	e58d30a4 	str	r3, [sp, #164]	; 0xa4
	    *S = (short)is;
3003c37c:	e59d30a4 	ldr	r3, [sp, #164]	; 0xa4
3003c380:	e1a03803 	lsl	r3, r3, #16
3003c384:	e1a02823 	lsr	r2, r3, #16
3003c388:	e59d30b4 	ldr	r3, [sp, #180]	; 0xb4
3003c38c:	e1c320b0 	strh	r2, [r3]
	    S++;
3003c390:	e59d30b4 	ldr	r3, [sp, #180]	; 0xb4
3003c394:	e2833002 	add	r3, r3, #2
3003c398:	e58d30b4 	str	r3, [sp, #180]	; 0xb4
    /*      15          */
    /* Sj =SIGM W(j+32i) */
    /*     i=0          */

	  v = &Granule_sbsynth_V[ch][0];
      for (j = 0; j < 32; j++) 
3003c39c:	e59d3098 	ldr	r3, [sp, #152]	; 0x98
3003c3a0:	e2833001 	add	r3, r3, #1
3003c3a4:	e58d3098 	str	r3, [sp, #152]	; 0x98
3003c3a8:	e59d3098 	ldr	r3, [sp, #152]	; 0x98
3003c3ac:	e353001f 	cmp	r3, #31
3003c3b0:	daffffa5 	ble	3003c24c <Granule_subband_synthesis+0x10c>
       PCM samples, so the result of 18 of these is 18*32=576 samples.
     */

    /* go through each time window */
	
    for(t = 0; t < 18; t++)
3003c3b4:	e59d309c 	ldr	r3, [sp, #156]	; 0x9c
3003c3b8:	e2833001 	add	r3, r3, #1
3003c3bc:	e58d309c 	str	r3, [sp, #156]	; 0x9c
3003c3c0:	e59d309c 	ldr	r3, [sp, #156]	; 0x9c
3003c3c4:	e3530011 	cmp	r3, #17
3003c3c8:	daffff66 	ble	3003c168 <Granule_subband_synthesis+0x28>
	      is = -32768;
	    *S = (short)is;
	    S++;
	  }
    }
}
3003c3cc:	e28dd0bc 	add	sp, sp, #188	; 0xbc
3003c3d0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3003c3d4:	e12fff1e 	bx	lr
3003c3d8:	300c99b0 	.word	0x300c99b0
3003c3dc:	300e5980 	.word	0x300e5980
3003c3e0:	300c91b0 	.word	0x300c91b0

3003c3e4 <Granule_subband_synthesis2>:
	We need a buffer of 1024 floats per channel.

   */

void Granule_subband_synthesis2(int s1[SBLIMIT][SSLIMIT],int s2[SBLIMIT][SSLIMIT],short  SAM[2][SSLIMIT][SBLIMIT])
{
3003c3e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3003c3e8:	e24ddf51 	sub	sp, sp, #324	; 0x144
3003c3ec:	e58d000c 	str	r0, [sp, #12]
3003c3f0:	e58d1008 	str	r1, [sp, #8]
3003c3f4:	e58d2004 	str	r2, [sp, #4]
    int i, j, t, k;
    int band[64];
    int *v1, *v2, sum, sum2, *d;
	int *v;
	long is;
	short *S=&SAM[0][0][0];
3003c3f8:	e59d3004 	ldr	r3, [sp, #4]
3003c3fc:	e58d313c 	str	r3, [sp, #316]	; 0x13c
		for(j=0; j<SSLIMIT; j++) {
			s1[i][j] *= 10;
			s2[i][j] *= 10;
		}
		*/
    for(t = 0; t < 18; t++) 
3003c400:	e3a03000 	mov	r3, #0
3003c404:	e58d3118 	str	r3, [sp, #280]	; 0x118
3003c408:	ea0000f4 	b	3003c7e0 <Granule_subband_synthesis2+0x3fc>
	{

	/* extract the subband strengths */

	   v1 = &s1[0][t];
3003c40c:	e59d200c 	ldr	r2, [sp, #12]
3003c410:	e59d3118 	ldr	r3, [sp, #280]	; 0x118
3003c414:	e1a03103 	lsl	r3, r3, #2
3003c418:	e0823003 	add	r3, r2, r3
3003c41c:	e58d3120 	str	r3, [sp, #288]	; 0x120
	   v2 = &s2[0][t];
3003c420:	e59d2008 	ldr	r2, [sp, #8]
3003c424:	e59d3118 	ldr	r3, [sp, #280]	; 0x118
3003c428:	e1a03103 	lsl	r3, r3, #2
3003c42c:	e0823003 	add	r3, r2, r3
3003c430:	e58d3124 	str	r3, [sp, #292]	; 0x124
	   for(i = 0; i < 32; i++)
3003c434:	e3a03000 	mov	r3, #0
3003c438:	e58d3110 	str	r3, [sp, #272]	; 0x110
3003c43c:	ea00001d 	b	3003c4b8 <Granule_subband_synthesis2+0xd4>
	   {
	     band[i] = *v1;
3003c440:	e59d1110 	ldr	r1, [sp, #272]	; 0x110
3003c444:	e59d3120 	ldr	r3, [sp, #288]	; 0x120
3003c448:	e5932000 	ldr	r2, [r3]
3003c44c:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
3003c450:	e1a03b43 	asr	r3, r3, #22
3003c454:	e1a01101 	lsl	r1, r1, #2
3003c458:	e28d0d05 	add	r0, sp, #320	; 0x140
3003c45c:	e0811000 	add	r1, r1, r0
3003c460:	e0813003 	add	r3, r1, r3
3003c464:	e5832000 	str	r2, [r3]
	     band[i+32] = *v2;
3003c468:	e59d3110 	ldr	r3, [sp, #272]	; 0x110
3003c46c:	e2831020 	add	r1, r3, #32
3003c470:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003c474:	e5932000 	ldr	r2, [r3]
3003c478:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
3003c47c:	e1a03b43 	asr	r3, r3, #22
3003c480:	e1a01101 	lsl	r1, r1, #2
3003c484:	e28d0d05 	add	r0, sp, #320	; 0x140
3003c488:	e0811000 	add	r1, r1, r0
3003c48c:	e0813003 	add	r3, r1, r3
3003c490:	e5832000 	str	r2, [r3]
	     v1 = &v1[18];
3003c494:	e59d3120 	ldr	r3, [sp, #288]	; 0x120
3003c498:	e2833048 	add	r3, r3, #72	; 0x48
3003c49c:	e58d3120 	str	r3, [sp, #288]	; 0x120
	     v2 = &v2[18];
3003c4a0:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003c4a4:	e2833048 	add	r3, r3, #72	; 0x48
3003c4a8:	e58d3124 	str	r3, [sp, #292]	; 0x124

	/* extract the subband strengths */

	   v1 = &s1[0][t];
	   v2 = &s2[0][t];
	   for(i = 0; i < 32; i++)
3003c4ac:	e59d3110 	ldr	r3, [sp, #272]	; 0x110
3003c4b0:	e2833001 	add	r3, r3, #1
3003c4b4:	e58d3110 	str	r3, [sp, #272]	; 0x110
3003c4b8:	e59d3110 	ldr	r3, [sp, #272]	; 0x110
3003c4bc:	e353001f 	cmp	r3, #31
3003c4c0:	daffffde 	ble	3003c440 <Granule_subband_synthesis2+0x5c>
	     v2 = &v2[18];
	   }

	/* advance the buffer position */

 	  Granule_sbsynth_Vptr[0] = (Granule_sbsynth_Vptr[0] - 64) & 0x3ff;
3003c4c4:	e59f332c 	ldr	r3, [pc, #812]	; 3003c7f8 <Granule_subband_synthesis2+0x414>
3003c4c8:	e5933000 	ldr	r3, [r3]
3003c4cc:	e2433040 	sub	r3, r3, #64	; 0x40
3003c4d0:	e1a03b03 	lsl	r3, r3, #22
3003c4d4:	e1a03b23 	lsr	r3, r3, #22
3003c4d8:	e59f2318 	ldr	r2, [pc, #792]	; 3003c7f8 <Granule_subband_synthesis2+0x414>
3003c4dc:	e5823000 	str	r3, [r2]
	  v = &(Granule_sbsynth_V[0][Granule_sbsynth_Vptr[0]]);
3003c4e0:	e59f2314 	ldr	r2, [pc, #788]	; 3003c7fc <Granule_subband_synthesis2+0x418>
3003c4e4:	e59f330c 	ldr	r3, [pc, #780]	; 3003c7f8 <Granule_subband_synthesis2+0x414>
3003c4e8:	e5933000 	ldr	r3, [r3]
3003c4ec:	e1a03103 	lsl	r3, r3, #2
3003c4f0:	e0823003 	add	r3, r2, r3
3003c4f4:	e58d3134 	str	r3, [sp, #308]	; 0x134
	
	/* calculate 64 values for each channel and insert them into the 1024 wide buffer */

	  fast_idct(band, v);
3003c4f8:	e28d3010 	add	r3, sp, #16
3003c4fc:	e1a00003 	mov	r0, r3
3003c500:	e59d1134 	ldr	r1, [sp, #308]	; 0x134
3003c504:	eb000221 	bl	3003cd90 <fast_idct>
	
	/*     15          */
	/* Sj = E W(j+32i) */
	/*    i=0          */
	
	  v = &Granule_sbsynth_V[0][0];
3003c508:	e59f32ec 	ldr	r3, [pc, #748]	; 3003c7fc <Granule_subband_synthesis2+0x418>
3003c50c:	e58d3134 	str	r3, [sp, #308]	; 0x134
	  for (j = 0; j < 32; j++)
3003c510:	e3a03000 	mov	r3, #0
3003c514:	e58d3114 	str	r3, [sp, #276]	; 0x114
3003c518:	ea0000aa 	b	3003c7c8 <Granule_subband_synthesis2+0x3e4>
	  { 
	    d = &D_coex[j];
3003c51c:	e59d3114 	ldr	r3, [sp, #276]	; 0x114
3003c520:	e1a02103 	lsl	r2, r3, #2
3003c524:	e59f32d4 	ldr	r3, [pc, #724]	; 3003c800 <Granule_subband_synthesis2+0x41c>
3003c528:	e0823003 	add	r3, r2, r3
3003c52c:	e58d3130 	str	r3, [sp, #304]	; 0x130
	    k = j + Granule_sbsynth_Vptr[0];
3003c530:	e59f32c0 	ldr	r3, [pc, #704]	; 3003c7f8 <Granule_subband_synthesis2+0x414>
3003c534:	e5932000 	ldr	r2, [r3]
3003c538:	e59d3114 	ldr	r3, [sp, #276]	; 0x114
3003c53c:	e0823003 	add	r3, r2, r3
3003c540:	e58d311c 	str	r3, [sp, #284]	; 0x11c
	    
	    sum = 0;
3003c544:	e3a03000 	mov	r3, #0
3003c548:	e58d3128 	str	r3, [sp, #296]	; 0x128
	    sum2 = 0;
3003c54c:	e3a03000 	mov	r3, #0
3003c550:	e58d312c 	str	r3, [sp, #300]	; 0x12c
	    for(i = 0; i < 8; i++) 
3003c554:	e3a03000 	mov	r3, #0
3003c558:	e58d3110 	str	r3, [sp, #272]	; 0x110
3003c55c:	ea000053 	b	3003c6b0 <Granule_subband_synthesis2+0x2cc>
		{
		   sum += (d[0] * v[k])/10240;
3003c560:	e59d3130 	ldr	r3, [sp, #304]	; 0x130
3003c564:	e5933000 	ldr	r3, [r3]
3003c568:	e59d211c 	ldr	r2, [sp, #284]	; 0x11c
3003c56c:	e1a01102 	lsl	r1, r2, #2
3003c570:	e59d2134 	ldr	r2, [sp, #308]	; 0x134
3003c574:	e0812002 	add	r2, r1, r2
3003c578:	e5922000 	ldr	r2, [r2]
3003c57c:	e0030392 	mul	r3, r2, r3
3003c580:	e59f227c 	ldr	r2, [pc, #636]	; 3003c804 <Granule_subband_synthesis2+0x420>
3003c584:	e0c21293 	smull	r1, r2, r3, r2
3003c588:	e1a02642 	asr	r2, r2, #12
3003c58c:	e1a03fc3 	asr	r3, r3, #31
3003c590:	e0633002 	rsb	r3, r3, r2
3003c594:	e59d2128 	ldr	r2, [sp, #296]	; 0x128
3003c598:	e0823003 	add	r3, r2, r3
3003c59c:	e58d3128 	str	r3, [sp, #296]	; 0x128
		   sum2 += (d[0] * v[k+1024])/10240;
3003c5a0:	e59d3130 	ldr	r3, [sp, #304]	; 0x130
3003c5a4:	e5933000 	ldr	r3, [r3]
3003c5a8:	e59d211c 	ldr	r2, [sp, #284]	; 0x11c
3003c5ac:	e2822b01 	add	r2, r2, #1024	; 0x400
3003c5b0:	e1a01102 	lsl	r1, r2, #2
3003c5b4:	e59d2134 	ldr	r2, [sp, #308]	; 0x134
3003c5b8:	e0812002 	add	r2, r1, r2
3003c5bc:	e5922000 	ldr	r2, [r2]
3003c5c0:	e0030392 	mul	r3, r2, r3
3003c5c4:	e59f2238 	ldr	r2, [pc, #568]	; 3003c804 <Granule_subband_synthesis2+0x420>
3003c5c8:	e0c20293 	smull	r0, r2, r3, r2
3003c5cc:	e1a02642 	asr	r2, r2, #12
3003c5d0:	e1a03fc3 	asr	r3, r3, #31
3003c5d4:	e0633002 	rsb	r3, r3, r2
3003c5d8:	e59d212c 	ldr	r2, [sp, #300]	; 0x12c
3003c5dc:	e0823003 	add	r3, r2, r3
3003c5e0:	e58d312c 	str	r3, [sp, #300]	; 0x12c
		   k = (k + 96) & 0x3ff;
3003c5e4:	e59d311c 	ldr	r3, [sp, #284]	; 0x11c
3003c5e8:	e2833060 	add	r3, r3, #96	; 0x60
3003c5ec:	e1a03b03 	lsl	r3, r3, #22
3003c5f0:	e1a03b23 	lsr	r3, r3, #22
3003c5f4:	e58d311c 	str	r3, [sp, #284]	; 0x11c

		   sum += (d[32] * v[k])/10240;
3003c5f8:	e59d3130 	ldr	r3, [sp, #304]	; 0x130
3003c5fc:	e2833080 	add	r3, r3, #128	; 0x80
3003c600:	e5933000 	ldr	r3, [r3]
3003c604:	e59d211c 	ldr	r2, [sp, #284]	; 0x11c
3003c608:	e1a01102 	lsl	r1, r2, #2
3003c60c:	e59d2134 	ldr	r2, [sp, #308]	; 0x134
3003c610:	e0812002 	add	r2, r1, r2
3003c614:	e5922000 	ldr	r2, [r2]
3003c618:	e0030392 	mul	r3, r2, r3
3003c61c:	e59f21e0 	ldr	r2, [pc, #480]	; 3003c804 <Granule_subband_synthesis2+0x420>
3003c620:	e0c21293 	smull	r1, r2, r3, r2
3003c624:	e1a02642 	asr	r2, r2, #12
3003c628:	e1a03fc3 	asr	r3, r3, #31
3003c62c:	e0633002 	rsb	r3, r3, r2
3003c630:	e59d2128 	ldr	r2, [sp, #296]	; 0x128
3003c634:	e0823003 	add	r3, r2, r3
3003c638:	e58d3128 	str	r3, [sp, #296]	; 0x128
		   sum2 += (d[32] * v[k+1024])/10240;
3003c63c:	e59d3130 	ldr	r3, [sp, #304]	; 0x130
3003c640:	e2833080 	add	r3, r3, #128	; 0x80
3003c644:	e5933000 	ldr	r3, [r3]
3003c648:	e59d211c 	ldr	r2, [sp, #284]	; 0x11c
3003c64c:	e2822b01 	add	r2, r2, #1024	; 0x400
3003c650:	e1a01102 	lsl	r1, r2, #2
3003c654:	e59d2134 	ldr	r2, [sp, #308]	; 0x134
3003c658:	e0812002 	add	r2, r1, r2
3003c65c:	e5922000 	ldr	r2, [r2]
3003c660:	e0030392 	mul	r3, r2, r3
3003c664:	e59f2198 	ldr	r2, [pc, #408]	; 3003c804 <Granule_subband_synthesis2+0x420>
3003c668:	e0c20293 	smull	r0, r2, r3, r2
3003c66c:	e1a02642 	asr	r2, r2, #12
3003c670:	e1a03fc3 	asr	r3, r3, #31
3003c674:	e0633002 	rsb	r3, r3, r2
3003c678:	e59d212c 	ldr	r2, [sp, #300]	; 0x12c
3003c67c:	e0823003 	add	r3, r2, r3
3003c680:	e58d312c 	str	r3, [sp, #300]	; 0x12c
		   k = (k + 32) & 0x3ff; 
3003c684:	e59d311c 	ldr	r3, [sp, #284]	; 0x11c
3003c688:	e2833020 	add	r3, r3, #32
3003c68c:	e1a03b03 	lsl	r3, r3, #22
3003c690:	e1a03b23 	lsr	r3, r3, #22
3003c694:	e58d311c 	str	r3, [sp, #284]	; 0x11c
		   d = &d[64];
3003c698:	e59d3130 	ldr	r3, [sp, #304]	; 0x130
3003c69c:	e2833c01 	add	r3, r3, #256	; 0x100
3003c6a0:	e58d3130 	str	r3, [sp, #304]	; 0x130
	    d = &D_coex[j];
	    k = j + Granule_sbsynth_Vptr[0];
	    
	    sum = 0;
	    sum2 = 0;
	    for(i = 0; i < 8; i++) 
3003c6a4:	e59d3110 	ldr	r3, [sp, #272]	; 0x110
3003c6a8:	e2833001 	add	r3, r3, #1
3003c6ac:	e58d3110 	str	r3, [sp, #272]	; 0x110
3003c6b0:	e59d3110 	ldr	r3, [sp, #272]	; 0x110
3003c6b4:	e3530007 	cmp	r3, #7
3003c6b8:	daffffa8 	ble	3003c560 <Granule_subband_synthesis2+0x17c>
		   d = &d[64];
	    }
	    /* convert to integer, and clip the output */
//      if(j%2)
	  {
		is=(long) (sum*32768)/10240;
3003c6bc:	e59d3128 	ldr	r3, [sp, #296]	; 0x128
3003c6c0:	e1a03783 	lsl	r3, r3, #15
3003c6c4:	e59f2138 	ldr	r2, [pc, #312]	; 3003c804 <Granule_subband_synthesis2+0x420>
3003c6c8:	e0c21293 	smull	r1, r2, r3, r2
3003c6cc:	e1a02642 	asr	r2, r2, #12
3003c6d0:	e1a03fc3 	asr	r3, r3, #31
3003c6d4:	e0633002 	rsb	r3, r3, r2
3003c6d8:	e58d3138 	str	r3, [sp, #312]	; 0x138
// OVERFLOW_CHECKING
	    if(is >= 32768) 
3003c6dc:	e59d2138 	ldr	r2, [sp, #312]	; 0x138
3003c6e0:	e3a03c7f 	mov	r3, #32512	; 0x7f00
3003c6e4:	e28330ff 	add	r3, r3, #255	; 0xff
3003c6e8:	e1520003 	cmp	r2, r3
3003c6ec:	da000003 	ble	3003c700 <Granule_subband_synthesis2+0x31c>
		  *S = 32767;	
3003c6f0:	e59d313c 	ldr	r3, [sp, #316]	; 0x13c
3003c6f4:	e3e02902 	mvn	r2, #32768	; 0x8000
3003c6f8:	e1c320b0 	strh	r2, [r3]
3003c6fc:	ea00000b 	b	3003c730 <Granule_subband_synthesis2+0x34c>
		else if(is < -32768) 
3003c700:	e59d3138 	ldr	r3, [sp, #312]	; 0x138
3003c704:	e3730902 	cmn	r3, #32768	; 0x8000
3003c708:	aa000003 	bge	3003c71c <Granule_subband_synthesis2+0x338>
		  *S = -32768;
3003c70c:	e59d313c 	ldr	r3, [sp, #316]	; 0x13c
3003c710:	e3a02902 	mov	r2, #32768	; 0x8000
3003c714:	e1c320b0 	strh	r2, [r3]
3003c718:	ea000004 	b	3003c730 <Granule_subband_synthesis2+0x34c>
		else 
  		  *S = (short)is;
3003c71c:	e59d3138 	ldr	r3, [sp, #312]	; 0x138
3003c720:	e1a03803 	lsl	r3, r3, #16
3003c724:	e1a02823 	lsr	r2, r3, #16
3003c728:	e59d313c 	ldr	r3, [sp, #316]	; 0x13c
3003c72c:	e1c320b0 	strh	r2, [r3]

		S++;
3003c730:	e59d313c 	ldr	r3, [sp, #316]	; 0x13c
3003c734:	e2833002 	add	r3, r3, #2
3003c738:	e58d313c 	str	r3, [sp, #316]	; 0x13c
	    
		is=(long) (sum*32768)/10240;
3003c73c:	e59d3128 	ldr	r3, [sp, #296]	; 0x128
3003c740:	e1a03783 	lsl	r3, r3, #15
3003c744:	e59f20b8 	ldr	r2, [pc, #184]	; 3003c804 <Granule_subband_synthesis2+0x420>
3003c748:	e0c20293 	smull	r0, r2, r3, r2
3003c74c:	e1a02642 	asr	r2, r2, #12
3003c750:	e1a03fc3 	asr	r3, r3, #31
3003c754:	e0633002 	rsb	r3, r3, r2
3003c758:	e58d3138 	str	r3, [sp, #312]	; 0x138
	    if(is >= 32768) 
3003c75c:	e59d2138 	ldr	r2, [sp, #312]	; 0x138
3003c760:	e3a03c7f 	mov	r3, #32512	; 0x7f00
3003c764:	e28330ff 	add	r3, r3, #255	; 0xff
3003c768:	e1520003 	cmp	r2, r3
3003c76c:	da000003 	ble	3003c780 <Granule_subband_synthesis2+0x39c>
		  *(S) = 32767;
3003c770:	e59d313c 	ldr	r3, [sp, #316]	; 0x13c
3003c774:	e3e02902 	mvn	r2, #32768	; 0x8000
3003c778:	e1c320b0 	strh	r2, [r3]
3003c77c:	ea00000b 	b	3003c7b0 <Granule_subband_synthesis2+0x3cc>
		else if(is < -32768) 
3003c780:	e59d3138 	ldr	r3, [sp, #312]	; 0x138
3003c784:	e3730902 	cmn	r3, #32768	; 0x8000
3003c788:	aa000003 	bge	3003c79c <Granule_subband_synthesis2+0x3b8>
		  *(S) = -32768;
3003c78c:	e59d313c 	ldr	r3, [sp, #316]	; 0x13c
3003c790:	e3a02902 	mov	r2, #32768	; 0x8000
3003c794:	e1c320b0 	strh	r2, [r3]
3003c798:	ea000004 	b	3003c7b0 <Granule_subband_synthesis2+0x3cc>
		else 
		  *(S) = (short)is;
3003c79c:	e59d3138 	ldr	r3, [sp, #312]	; 0x138
3003c7a0:	e1a03803 	lsl	r3, r3, #16
3003c7a4:	e1a02823 	lsr	r2, r3, #16
3003c7a8:	e59d313c 	ldr	r3, [sp, #316]	; 0x13c
3003c7ac:	e1c320b0 	strh	r2, [r3]

	    S++;
3003c7b0:	e59d313c 	ldr	r3, [sp, #316]	; 0x13c
3003c7b4:	e2833002 	add	r3, r3, #2
3003c7b8:	e58d313c 	str	r3, [sp, #316]	; 0x13c
	/*     15          */
	/* Sj = E W(j+32i) */
	/*    i=0          */
	
	  v = &Granule_sbsynth_V[0][0];
	  for (j = 0; j < 32; j++)
3003c7bc:	e59d3114 	ldr	r3, [sp, #276]	; 0x114
3003c7c0:	e2833001 	add	r3, r3, #1
3003c7c4:	e58d3114 	str	r3, [sp, #276]	; 0x114
3003c7c8:	e59d3114 	ldr	r3, [sp, #276]	; 0x114
3003c7cc:	e353001f 	cmp	r3, #31
3003c7d0:	daffff51 	ble	3003c51c <Granule_subband_synthesis2+0x138>
		for(j=0; j<SSLIMIT; j++) {
			s1[i][j] *= 10;
			s2[i][j] *= 10;
		}
		*/
    for(t = 0; t < 18; t++) 
3003c7d4:	e59d3118 	ldr	r3, [sp, #280]	; 0x118
3003c7d8:	e2833001 	add	r3, r3, #1
3003c7dc:	e58d3118 	str	r3, [sp, #280]	; 0x118
3003c7e0:	e59d3118 	ldr	r3, [sp, #280]	; 0x118
3003c7e4:	e3530011 	cmp	r3, #17
3003c7e8:	daffff07 	ble	3003c40c <Granule_subband_synthesis2+0x28>
	    S++;

	  }
	  }
    }
}
3003c7ec:	e28ddf51 	add	sp, sp, #324	; 0x144
3003c7f0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3003c7f4:	e12fff1e 	bx	lr
3003c7f8:	300c99b0 	.word	0x300c99b0
3003c7fc:	300e5980 	.word	0x300e5980
3003c800:	300c91b0 	.word	0x300c91b0
3003c804:	66666667 	.word	0x66666667

3003c808 <fast_idct_init>:


void fast_idct_init()
{
3003c808:	e92d4070 	push	{r4, r5, r6, lr}
3003c80c:	e24ddc05 	sub	sp, sp, #1280	; 0x500
3003c810:	e24dd008 	sub	sp, sp, #8
    int t16[16][16], t8[8][8];


    /* create the 16 matrixes */

    for(i = 0; i < 16; i++) {
3003c814:	e3a03000 	mov	r3, #0
3003c818:	e58d3500 	str	r3, [sp, #1280]	; 0x500
3003c81c:	ea000092 	b	3003ca6c <fast_idct_init+0x264>
	  for(j = 0; j < 16; j++) 
3003c820:	e3a03000 	mov	r3, #0
3003c824:	e58d3504 	str	r3, [sp, #1284]	; 0x504
3003c828:	ea000089 	b	3003ca54 <fast_idct_init+0x24c>
	  {
	    A16[i][j] = (int)(cos((2*j+1)*i*PI/32)*10240);
3003c82c:	e59d6500 	ldr	r6, [sp, #1280]	; 0x500
3003c830:	e59d5504 	ldr	r5, [sp, #1284]	; 0x504
3003c834:	e59d3504 	ldr	r3, [sp, #1284]	; 0x504
3003c838:	e1a03083 	lsl	r3, r3, #1
3003c83c:	e2833001 	add	r3, r3, #1
3003c840:	e59d2500 	ldr	r2, [sp, #1280]	; 0x500
3003c844:	e0030392 	mul	r3, r2, r3
3003c848:	e1a00003 	mov	r0, r3
3003c84c:	eb001e7b 	bl	30044240 <__aeabi_i2d>
3003c850:	e1a03000 	mov	r3, r0
3003c854:	e1a04001 	mov	r4, r1
3003c858:	e1a00003 	mov	r0, r3
3003c85c:	e1a01004 	mov	r1, r4
3003c860:	e28f3fca 	add	r3, pc, #808	; 0x328
3003c864:	e893000c 	ldm	r3, {r2, r3}
3003c868:	eb001eab 	bl	3004431c <__aeabi_dmul>
3003c86c:	e1a03000 	mov	r3, r0
3003c870:	e1a04001 	mov	r4, r1
3003c874:	e1a00003 	mov	r0, r3
3003c878:	e1a01004 	mov	r1, r4
3003c87c:	e3a02000 	mov	r2, #0
3003c880:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003c884:	e2833501 	add	r3, r3, #4194304	; 0x400000
3003c888:	eb001f47 	bl	300445ac <__aeabi_ddiv>
3003c88c:	e1a03000 	mov	r3, r0
3003c890:	e1a04001 	mov	r4, r1
3003c894:	e1a00003 	mov	r0, r3
3003c898:	e1a01004 	mov	r1, r4
3003c89c:	ebffe2af 	bl	30035360 <cos>
3003c8a0:	e1a03000 	mov	r3, r0
3003c8a4:	e1a04001 	mov	r4, r1
3003c8a8:	e1a00003 	mov	r0, r3
3003c8ac:	e1a01004 	mov	r1, r4
3003c8b0:	e3a02000 	mov	r2, #0
3003c8b4:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003c8b8:	e2833731 	add	r3, r3, #12845056	; 0xc40000
3003c8bc:	eb001e96 	bl	3004431c <__aeabi_dmul>
3003c8c0:	e1a03000 	mov	r3, r0
3003c8c4:	e1a04001 	mov	r4, r1
3003c8c8:	e1a00003 	mov	r0, r3
3003c8cc:	e1a01004 	mov	r1, r4
3003c8d0:	eb002009 	bl	300448fc <__aeabi_d2iz>
3003c8d4:	e1a01000 	mov	r1, r0
3003c8d8:	e59f32b8 	ldr	r3, [pc, #696]	; 3003cb98 <fast_idct_init+0x390>
3003c8dc:	e1a02206 	lsl	r2, r6, #4
3003c8e0:	e0822005 	add	r2, r2, r5
3003c8e4:	e7831102 	str	r1, [r3, r2, lsl #2]
	    if(i == j || j == (i + 1))
3003c8e8:	e59d2500 	ldr	r2, [sp, #1280]	; 0x500
3003c8ec:	e59d3504 	ldr	r3, [sp, #1284]	; 0x504
3003c8f0:	e1520003 	cmp	r2, r3
3003c8f4:	0a000004 	beq	3003c90c <fast_idct_init+0x104>
3003c8f8:	e59d3500 	ldr	r3, [sp, #1280]	; 0x500
3003c8fc:	e2832001 	add	r2, r3, #1
3003c900:	e59d3504 	ldr	r3, [sp, #1284]	; 0x504
3003c904:	e1520003 	cmp	r2, r3
3003c908:	1a000007 	bne	3003c92c <fast_idct_init+0x124>
		  G16[i][j] = 10240;
3003c90c:	e59d1500 	ldr	r1, [sp, #1280]	; 0x500
3003c910:	e59d2504 	ldr	r2, [sp, #1284]	; 0x504
3003c914:	e59f3280 	ldr	r3, [pc, #640]	; 3003cb9c <fast_idct_init+0x394>
3003c918:	e1a01201 	lsl	r1, r1, #4
3003c91c:	e0812002 	add	r2, r1, r2
3003c920:	e3a01b0a 	mov	r1, #10240	; 0x2800
3003c924:	e7831102 	str	r1, [r3, r2, lsl #2]

    for(i = 0; i < 16; i++) {
	  for(j = 0; j < 16; j++) 
	  {
	    A16[i][j] = (int)(cos((2*j+1)*i*PI/32)*10240);
	    if(i == j || j == (i + 1))
3003c928:	ea000006 	b	3003c948 <fast_idct_init+0x140>
		  G16[i][j] = 10240;
	    else
		  G16[i][j] = 0;
3003c92c:	e59d1500 	ldr	r1, [sp, #1280]	; 0x500
3003c930:	e59d2504 	ldr	r2, [sp, #1284]	; 0x504
3003c934:	e59f3260 	ldr	r3, [pc, #608]	; 3003cb9c <fast_idct_init+0x394>
3003c938:	e1a01201 	lsl	r1, r1, #4
3003c93c:	e0812002 	add	r2, r1, r2
3003c940:	e3a01000 	mov	r1, #0
3003c944:	e7831102 	str	r1, [r3, r2, lsl #2]
	    if(i == j)
3003c948:	e59d2500 	ldr	r2, [sp, #1280]	; 0x500
3003c94c:	e59d3504 	ldr	r3, [sp, #1284]	; 0x504
3003c950:	e1520003 	cmp	r2, r3
3003c954:	1a000034 	bne	3003ca2c <fast_idct_init+0x224>
		  H16[i][j] = (int)((10240/(2*cos((2*i+1)*PI/64))));
3003c958:	e59d6500 	ldr	r6, [sp, #1280]	; 0x500
3003c95c:	e59d5504 	ldr	r5, [sp, #1284]	; 0x504
3003c960:	e59d3500 	ldr	r3, [sp, #1280]	; 0x500
3003c964:	e1a03083 	lsl	r3, r3, #1
3003c968:	e2833001 	add	r3, r3, #1
3003c96c:	e1a00003 	mov	r0, r3
3003c970:	eb001e32 	bl	30044240 <__aeabi_i2d>
3003c974:	e1a03000 	mov	r3, r0
3003c978:	e1a04001 	mov	r4, r1
3003c97c:	e1a00003 	mov	r0, r3
3003c980:	e1a01004 	mov	r1, r4
3003c984:	e28f3f81 	add	r3, pc, #516	; 0x204
3003c988:	e893000c 	ldm	r3, {r2, r3}
3003c98c:	eb001e62 	bl	3004431c <__aeabi_dmul>
3003c990:	e1a03000 	mov	r3, r0
3003c994:	e1a04001 	mov	r4, r1
3003c998:	e1a00003 	mov	r0, r3
3003c99c:	e1a01004 	mov	r1, r4
3003c9a0:	e3a02000 	mov	r2, #0
3003c9a4:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003c9a8:	e2833605 	add	r3, r3, #5242880	; 0x500000
3003c9ac:	eb001efe 	bl	300445ac <__aeabi_ddiv>
3003c9b0:	e1a03000 	mov	r3, r0
3003c9b4:	e1a04001 	mov	r4, r1
3003c9b8:	e1a00003 	mov	r0, r3
3003c9bc:	e1a01004 	mov	r1, r4
3003c9c0:	ebffe266 	bl	30035360 <cos>
3003c9c4:	e1a03000 	mov	r3, r0
3003c9c8:	e1a04001 	mov	r4, r1
3003c9cc:	e1a00003 	mov	r0, r3
3003c9d0:	e1a01004 	mov	r1, r4
3003c9d4:	e1a02003 	mov	r2, r3
3003c9d8:	e1a03004 	mov	r3, r4
3003c9dc:	eb001d4a 	bl	30043f0c <__adddf3>
3003c9e0:	e1a03000 	mov	r3, r0
3003c9e4:	e1a04001 	mov	r4, r1
3003c9e8:	e3a00000 	mov	r0, #0
3003c9ec:	e3a01101 	mov	r1, #1073741824	; 0x40000000
3003c9f0:	e2811731 	add	r1, r1, #12845056	; 0xc40000
3003c9f4:	e1a02003 	mov	r2, r3
3003c9f8:	e1a03004 	mov	r3, r4
3003c9fc:	eb001eea 	bl	300445ac <__aeabi_ddiv>
3003ca00:	e1a03000 	mov	r3, r0
3003ca04:	e1a04001 	mov	r4, r1
3003ca08:	e1a00003 	mov	r0, r3
3003ca0c:	e1a01004 	mov	r1, r4
3003ca10:	eb001fb9 	bl	300448fc <__aeabi_d2iz>
3003ca14:	e1a01000 	mov	r1, r0
3003ca18:	e59f3180 	ldr	r3, [pc, #384]	; 3003cba0 <fast_idct_init+0x398>
3003ca1c:	e1a02206 	lsl	r2, r6, #4
3003ca20:	e0822005 	add	r2, r2, r5
3003ca24:	e7831102 	str	r1, [r3, r2, lsl #2]
3003ca28:	ea000006 	b	3003ca48 <fast_idct_init+0x240>
	    else
		  H16[i][j] = 0;
3003ca2c:	e59d1500 	ldr	r1, [sp, #1280]	; 0x500
3003ca30:	e59d2504 	ldr	r2, [sp, #1284]	; 0x504
3003ca34:	e59f3164 	ldr	r3, [pc, #356]	; 3003cba0 <fast_idct_init+0x398>
3003ca38:	e1a01201 	lsl	r1, r1, #4
3003ca3c:	e0812002 	add	r2, r1, r2
3003ca40:	e3a01000 	mov	r1, #0
3003ca44:	e7831102 	str	r1, [r3, r2, lsl #2]


    /* create the 16 matrixes */

    for(i = 0; i < 16; i++) {
	  for(j = 0; j < 16; j++) 
3003ca48:	e59d3504 	ldr	r3, [sp, #1284]	; 0x504
3003ca4c:	e2833001 	add	r3, r3, #1
3003ca50:	e58d3504 	str	r3, [sp, #1284]	; 0x504
3003ca54:	e59d3504 	ldr	r3, [sp, #1284]	; 0x504
3003ca58:	e353000f 	cmp	r3, #15
3003ca5c:	daffff72 	ble	3003c82c <fast_idct_init+0x24>
    int t16[16][16], t8[8][8];


    /* create the 16 matrixes */

    for(i = 0; i < 16; i++) {
3003ca60:	e59d3500 	ldr	r3, [sp, #1280]	; 0x500
3003ca64:	e2833001 	add	r3, r3, #1
3003ca68:	e58d3500 	str	r3, [sp, #1280]	; 0x500
3003ca6c:	e59d3500 	ldr	r3, [sp, #1280]	; 0x500
3003ca70:	e353000f 	cmp	r3, #15
3003ca74:	daffff69 	ble	3003c820 <fast_idct_init+0x18>
	  }
    }

    /* create the 8 matrixes */

    for(i = 0; i < 8; i++) {
3003ca78:	e3a03000 	mov	r3, #0
3003ca7c:	e58d3500 	str	r3, [sp, #1280]	; 0x500
3003ca80:	ea000099 	b	3003ccec <fast_idct_init+0x4e4>
	  for(j = 0; j < 8; j++) 
3003ca84:	e3a03000 	mov	r3, #0
3003ca88:	e58d3504 	str	r3, [sp, #1284]	; 0x504
3003ca8c:	ea000090 	b	3003ccd4 <fast_idct_init+0x4cc>
	  {
	    A8[i][j] = (int)(cos((2*j+1)*i*PI/16)*10240);
3003ca90:	e59d6500 	ldr	r6, [sp, #1280]	; 0x500
3003ca94:	e59d5504 	ldr	r5, [sp, #1284]	; 0x504
3003ca98:	e59d3504 	ldr	r3, [sp, #1284]	; 0x504
3003ca9c:	e1a03083 	lsl	r3, r3, #1
3003caa0:	e2833001 	add	r3, r3, #1
3003caa4:	e59d2500 	ldr	r2, [sp, #1280]	; 0x500
3003caa8:	e0030392 	mul	r3, r2, r3
3003caac:	e1a00003 	mov	r0, r3
3003cab0:	eb001de2 	bl	30044240 <__aeabi_i2d>
3003cab4:	e1a03000 	mov	r3, r0
3003cab8:	e1a04001 	mov	r4, r1
3003cabc:	e1a00003 	mov	r0, r3
3003cac0:	e1a01004 	mov	r1, r4
3003cac4:	e28f30c4 	add	r3, pc, #196	; 0xc4
3003cac8:	e893000c 	ldm	r3, {r2, r3}
3003cacc:	eb001e12 	bl	3004431c <__aeabi_dmul>
3003cad0:	e1a03000 	mov	r3, r0
3003cad4:	e1a04001 	mov	r4, r1
3003cad8:	e1a00003 	mov	r0, r3
3003cadc:	e1a01004 	mov	r1, r4
3003cae0:	e3a02000 	mov	r2, #0
3003cae4:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003cae8:	e2833603 	add	r3, r3, #3145728	; 0x300000
3003caec:	eb001eae 	bl	300445ac <__aeabi_ddiv>
3003caf0:	e1a03000 	mov	r3, r0
3003caf4:	e1a04001 	mov	r4, r1
3003caf8:	e1a00003 	mov	r0, r3
3003cafc:	e1a01004 	mov	r1, r4
3003cb00:	ebffe216 	bl	30035360 <cos>
3003cb04:	e1a03000 	mov	r3, r0
3003cb08:	e1a04001 	mov	r4, r1
3003cb0c:	e1a00003 	mov	r0, r3
3003cb10:	e1a01004 	mov	r1, r4
3003cb14:	e3a02000 	mov	r2, #0
3003cb18:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003cb1c:	e2833731 	add	r3, r3, #12845056	; 0xc40000
3003cb20:	eb001dfd 	bl	3004431c <__aeabi_dmul>
3003cb24:	e1a03000 	mov	r3, r0
3003cb28:	e1a04001 	mov	r4, r1
3003cb2c:	e1a00003 	mov	r0, r3
3003cb30:	e1a01004 	mov	r1, r4
3003cb34:	eb001f70 	bl	300448fc <__aeabi_d2iz>
3003cb38:	e1a01000 	mov	r1, r0
3003cb3c:	e59f3060 	ldr	r3, [pc, #96]	; 3003cba4 <fast_idct_init+0x39c>
3003cb40:	e1a02186 	lsl	r2, r6, #3
3003cb44:	e0822005 	add	r2, r2, r5
3003cb48:	e7831102 	str	r1, [r3, r2, lsl #2]
	    if(i == j || j == (i + 1))
3003cb4c:	e59d2500 	ldr	r2, [sp, #1280]	; 0x500
3003cb50:	e59d3504 	ldr	r3, [sp, #1284]	; 0x504
3003cb54:	e1520003 	cmp	r2, r3
3003cb58:	0a000004 	beq	3003cb70 <fast_idct_init+0x368>
3003cb5c:	e59d3500 	ldr	r3, [sp, #1280]	; 0x500
3003cb60:	e2832001 	add	r2, r3, #1
3003cb64:	e59d3504 	ldr	r3, [sp, #1284]	; 0x504
3003cb68:	e1520003 	cmp	r2, r3
3003cb6c:	1a00000e 	bne	3003cbac <fast_idct_init+0x3a4>
		  G8[i][j] = 10240;
3003cb70:	e59d1500 	ldr	r1, [sp, #1280]	; 0x500
3003cb74:	e59d2504 	ldr	r2, [sp, #1284]	; 0x504
3003cb78:	e59f3028 	ldr	r3, [pc, #40]	; 3003cba8 <fast_idct_init+0x3a0>
3003cb7c:	e1a01181 	lsl	r1, r1, #3
3003cb80:	e0812002 	add	r2, r1, r2
3003cb84:	e3a01b0a 	mov	r1, #10240	; 0x2800
3003cb88:	e7831102 	str	r1, [r3, r2, lsl #2]

    for(i = 0; i < 8; i++) {
	  for(j = 0; j < 8; j++) 
	  {
	    A8[i][j] = (int)(cos((2*j+1)*i*PI/16)*10240);
	    if(i == j || j == (i + 1))
3003cb8c:	ea00000d 	b	3003cbc8 <fast_idct_init+0x3c0>
3003cb90:	54442d11 	.word	0x54442d11
3003cb94:	400921fb 	.word	0x400921fb
3003cb98:	300e7980 	.word	0x300e7980
3003cb9c:	300e7e80 	.word	0x300e7e80
3003cba0:	300e8380 	.word	0x300e8380
3003cba4:	300e7d80 	.word	0x300e7d80
3003cba8:	300e8280 	.word	0x300e8280
		  G8[i][j] = 10240;
	    else
		  G8[i][j] = 0;
3003cbac:	e59d1500 	ldr	r1, [sp, #1280]	; 0x500
3003cbb0:	e59d2504 	ldr	r2, [sp, #1284]	; 0x504
3003cbb4:	e51f3014 	ldr	r3, [pc, #-20]	; 3003cba8 <fast_idct_init+0x3a0>
3003cbb8:	e1a01181 	lsl	r1, r1, #3
3003cbbc:	e0812002 	add	r2, r1, r2
3003cbc0:	e3a01000 	mov	r1, #0
3003cbc4:	e7831102 	str	r1, [r3, r2, lsl #2]
	    if(i == j)
3003cbc8:	e59d2500 	ldr	r2, [sp, #1280]	; 0x500
3003cbcc:	e59d3504 	ldr	r3, [sp, #1284]	; 0x504
3003cbd0:	e1520003 	cmp	r2, r3
3003cbd4:	1a000034 	bne	3003ccac <fast_idct_init+0x4a4>
		  H8[i][j] = (int)(10240/(2*cos((2*i+1)*PI/32)));
3003cbd8:	e59d6500 	ldr	r6, [sp, #1280]	; 0x500
3003cbdc:	e59d5504 	ldr	r5, [sp, #1284]	; 0x504
3003cbe0:	e59d3500 	ldr	r3, [sp, #1280]	; 0x500
3003cbe4:	e1a03083 	lsl	r3, r3, #1
3003cbe8:	e2833001 	add	r3, r3, #1
3003cbec:	e1a00003 	mov	r0, r3
3003cbf0:	eb001d92 	bl	30044240 <__aeabi_i2d>
3003cbf4:	e1a03000 	mov	r3, r0
3003cbf8:	e1a04001 	mov	r4, r1
3003cbfc:	e1a00003 	mov	r0, r3
3003cc00:	e1a01004 	mov	r1, r4
3003cc04:	e28f3f57 	add	r3, pc, #348	; 0x15c
3003cc08:	e893000c 	ldm	r3, {r2, r3}
3003cc0c:	eb001dc2 	bl	3004431c <__aeabi_dmul>
3003cc10:	e1a03000 	mov	r3, r0
3003cc14:	e1a04001 	mov	r4, r1
3003cc18:	e1a00003 	mov	r0, r3
3003cc1c:	e1a01004 	mov	r1, r4
3003cc20:	e3a02000 	mov	r2, #0
3003cc24:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003cc28:	e2833501 	add	r3, r3, #4194304	; 0x400000
3003cc2c:	eb001e5e 	bl	300445ac <__aeabi_ddiv>
3003cc30:	e1a03000 	mov	r3, r0
3003cc34:	e1a04001 	mov	r4, r1
3003cc38:	e1a00003 	mov	r0, r3
3003cc3c:	e1a01004 	mov	r1, r4
3003cc40:	ebffe1c6 	bl	30035360 <cos>
3003cc44:	e1a03000 	mov	r3, r0
3003cc48:	e1a04001 	mov	r4, r1
3003cc4c:	e1a00003 	mov	r0, r3
3003cc50:	e1a01004 	mov	r1, r4
3003cc54:	e1a02003 	mov	r2, r3
3003cc58:	e1a03004 	mov	r3, r4
3003cc5c:	eb001caa 	bl	30043f0c <__adddf3>
3003cc60:	e1a03000 	mov	r3, r0
3003cc64:	e1a04001 	mov	r4, r1
3003cc68:	e3a00000 	mov	r0, #0
3003cc6c:	e3a01101 	mov	r1, #1073741824	; 0x40000000
3003cc70:	e2811731 	add	r1, r1, #12845056	; 0xc40000
3003cc74:	e1a02003 	mov	r2, r3
3003cc78:	e1a03004 	mov	r3, r4
3003cc7c:	eb001e4a 	bl	300445ac <__aeabi_ddiv>
3003cc80:	e1a03000 	mov	r3, r0
3003cc84:	e1a04001 	mov	r4, r1
3003cc88:	e1a00003 	mov	r0, r3
3003cc8c:	e1a01004 	mov	r1, r4
3003cc90:	eb001f19 	bl	300448fc <__aeabi_d2iz>
3003cc94:	e1a01000 	mov	r1, r0
3003cc98:	e59f30d0 	ldr	r3, [pc, #208]	; 3003cd70 <fast_idct_init+0x568>
3003cc9c:	e1a02186 	lsl	r2, r6, #3
3003cca0:	e0822005 	add	r2, r2, r5
3003cca4:	e7831102 	str	r1, [r3, r2, lsl #2]
3003cca8:	ea000006 	b	3003ccc8 <fast_idct_init+0x4c0>
	    else
		  H8[i][j] = 0;
3003ccac:	e59d1500 	ldr	r1, [sp, #1280]	; 0x500
3003ccb0:	e59d2504 	ldr	r2, [sp, #1284]	; 0x504
3003ccb4:	e59f30b4 	ldr	r3, [pc, #180]	; 3003cd70 <fast_idct_init+0x568>
3003ccb8:	e1a01181 	lsl	r1, r1, #3
3003ccbc:	e0812002 	add	r2, r1, r2
3003ccc0:	e3a01000 	mov	r1, #0
3003ccc4:	e7831102 	str	r1, [r3, r2, lsl #2]
    }

    /* create the 8 matrixes */

    for(i = 0; i < 8; i++) {
	  for(j = 0; j < 8; j++) 
3003ccc8:	e59d3504 	ldr	r3, [sp, #1284]	; 0x504
3003cccc:	e2833001 	add	r3, r3, #1
3003ccd0:	e58d3504 	str	r3, [sp, #1284]	; 0x504
3003ccd4:	e59d3504 	ldr	r3, [sp, #1284]	; 0x504
3003ccd8:	e3530007 	cmp	r3, #7
3003ccdc:	daffff6b 	ble	3003ca90 <fast_idct_init+0x288>
	  }
    }

    /* create the 8 matrixes */

    for(i = 0; i < 8; i++) {
3003cce0:	e59d3500 	ldr	r3, [sp, #1280]	; 0x500
3003cce4:	e2833001 	add	r3, r3, #1
3003cce8:	e58d3500 	str	r3, [sp, #1280]	; 0x500
3003ccec:	e59d3500 	ldr	r3, [sp, #1280]	; 0x500
3003ccf0:	e3530007 	cmp	r3, #7
3003ccf4:	daffff62 	ble	3003ca84 <fast_idct_init+0x27c>
	  }
    }

    /* generate the B matrixes */

    matrix_mul16(A16, H16, t16);
3003ccf8:	e28d3f42 	add	r3, sp, #264	; 0x108
3003ccfc:	e2433008 	sub	r3, r3, #8
3003cd00:	e59f006c 	ldr	r0, [pc, #108]	; 3003cd74 <fast_idct_init+0x56c>
3003cd04:	e59f106c 	ldr	r1, [pc, #108]	; 3003cd78 <fast_idct_init+0x570>
3003cd08:	e1a02003 	mov	r2, r3
3003cd0c:	eb0001e9 	bl	3003d4b8 <matrix_mul16>
    matrix_mul16(G16, t16, B16);
3003cd10:	e28d3f42 	add	r3, sp, #264	; 0x108
3003cd14:	e2433008 	sub	r3, r3, #8
3003cd18:	e59f005c 	ldr	r0, [pc, #92]	; 3003cd7c <fast_idct_init+0x574>
3003cd1c:	e1a01003 	mov	r1, r3
3003cd20:	e59f2058 	ldr	r2, [pc, #88]	; 3003cd80 <fast_idct_init+0x578>
3003cd24:	eb0001e3 	bl	3003d4b8 <matrix_mul16>

    matrix_mul8(A8, H8, t8);
3003cd28:	e28d3008 	add	r3, sp, #8
3003cd2c:	e2433008 	sub	r3, r3, #8
3003cd30:	e59f004c 	ldr	r0, [pc, #76]	; 3003cd84 <fast_idct_init+0x57c>
3003cd34:	e59f1034 	ldr	r1, [pc, #52]	; 3003cd70 <fast_idct_init+0x568>
3003cd38:	e1a02003 	mov	r2, r3
3003cd3c:	eb000227 	bl	3003d5e0 <matrix_mul8>
    matrix_mul8(G8, t8, B8);
3003cd40:	e28d3008 	add	r3, sp, #8
3003cd44:	e2433008 	sub	r3, r3, #8
3003cd48:	e59f0038 	ldr	r0, [pc, #56]	; 3003cd88 <fast_idct_init+0x580>
3003cd4c:	e1a01003 	mov	r1, r3
3003cd50:	e59f2034 	ldr	r2, [pc, #52]	; 3003cd8c <fast_idct_init+0x584>
3003cd54:	eb000221 	bl	3003d5e0 <matrix_mul8>
}
3003cd58:	e28ddf42 	add	sp, sp, #264	; 0x108
3003cd5c:	e28ddb01 	add	sp, sp, #1024	; 0x400
3003cd60:	e8bd4070 	pop	{r4, r5, r6, lr}
3003cd64:	e12fff1e 	bx	lr
3003cd68:	54442d11 	.word	0x54442d11
3003cd6c:	400921fb 	.word	0x400921fb
3003cd70:	300e8780 	.word	0x300e8780
3003cd74:	300e7980 	.word	0x300e7980
3003cd78:	300e8380 	.word	0x300e8380
3003cd7c:	300e7e80 	.word	0x300e7e80
3003cd80:	300e8880 	.word	0x300e8880
3003cd84:	300e7d80 	.word	0x300e7d80
3003cd88:	300e8280 	.word	0x300e8280
3003cd8c:	300e8c80 	.word	0x300e8c80

3003cd90 <fast_idct>:
   This two-level configuration uses 384 muls and 432 adds, compared
   to the direct 32x32 DCT which uses 1024 muls and 992 adds.
*/

void fast_idct(int *in, int *out)
{
3003cd90:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3003cd94:	e24ddf57 	sub	sp, sp, #348	; 0x15c
3003cd98:	e58d0004 	str	r0, [sp, #4]
3003cd9c:	e58d1000 	str	r1, [sp]
    int even[16], odd[16], ee[8], eo[8];
    int s1, s2;
    int t[32];
    int i, j;
	static int init=1;
	if(mp3_fastsb_first == 1) {
3003cda0:	e59f36f8 	ldr	r3, [pc, #1784]	; 3003d4a0 <fast_idct+0x710>
3003cda4:	e5933000 	ldr	r3, [r3]
3003cda8:	e3530001 	cmp	r3, #1
3003cdac:	1a000005 	bne	3003cdc8 <fast_idct+0x38>
		mp3_fastsb_first = 0;
3003cdb0:	e59f36e8 	ldr	r3, [pc, #1768]	; 3003d4a0 <fast_idct+0x710>
3003cdb4:	e3a02000 	mov	r2, #0
3003cdb8:	e5832000 	str	r2, [r3]
		init = 1;
3003cdbc:	e59f36e0 	ldr	r3, [pc, #1760]	; 3003d4a4 <fast_idct+0x714>
3003cdc0:	e3a02001 	mov	r2, #1
3003cdc4:	e5832000 	str	r2, [r3]
	}

    if(init)
3003cdc8:	e59f36d4 	ldr	r3, [pc, #1748]	; 3003d4a4 <fast_idct+0x714>
3003cdcc:	e5933000 	ldr	r3, [r3]
3003cdd0:	e3530000 	cmp	r3, #0
3003cdd4:	0a000003 	beq	3003cde8 <fast_idct+0x58>
	{
		fast_idct_init();
3003cdd8:	ebfffe8a 	bl	3003c808 <fast_idct_init>
		init=0;
3003cddc:	e59f36c0 	ldr	r3, [pc, #1728]	; 3003d4a4 <fast_idct+0x714>
3003cde0:	e3a02000 	mov	r2, #0
3003cde4:	e5832000 	str	r2, [r3]
	}
	/* input butterflies - level 1 */
    /* 32 adds */

    for(i = 0; i < 16; i++) {
3003cde8:	e3a03000 	mov	r3, #0
3003cdec:	e58d3150 	str	r3, [sp, #336]	; 0x150
3003cdf0:	ea000028 	b	3003ce98 <fast_idct+0x108>
	   even[i] = in[i] + in[31-i];
3003cdf4:	e59d1150 	ldr	r1, [sp, #336]	; 0x150
3003cdf8:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003cdfc:	e1a02103 	lsl	r2, r3, #2
3003ce00:	e59d3004 	ldr	r3, [sp, #4]
3003ce04:	e0823003 	add	r3, r2, r3
3003ce08:	e5932000 	ldr	r2, [r3]
3003ce0c:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003ce10:	e263301f 	rsb	r3, r3, #31
3003ce14:	e1a00103 	lsl	r0, r3, #2
3003ce18:	e59d3004 	ldr	r3, [sp, #4]
3003ce1c:	e0803003 	add	r3, r0, r3
3003ce20:	e5933000 	ldr	r3, [r3]
3003ce24:	e0822003 	add	r2, r2, r3
3003ce28:	e3e0304f 	mvn	r3, #79	; 0x4f
3003ce2c:	e1a01101 	lsl	r1, r1, #2
3003ce30:	e28d0f56 	add	r0, sp, #344	; 0x158
3003ce34:	e0811000 	add	r1, r1, r0
3003ce38:	e0813003 	add	r3, r1, r3
3003ce3c:	e5832000 	str	r2, [r3]
	   odd[i] = in[i] - in[31-i];
3003ce40:	e59d1150 	ldr	r1, [sp, #336]	; 0x150
3003ce44:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003ce48:	e1a02103 	lsl	r2, r3, #2
3003ce4c:	e59d3004 	ldr	r3, [sp, #4]
3003ce50:	e0823003 	add	r3, r2, r3
3003ce54:	e5932000 	ldr	r2, [r3]
3003ce58:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003ce5c:	e263301f 	rsb	r3, r3, #31
3003ce60:	e1a00103 	lsl	r0, r3, #2
3003ce64:	e59d3004 	ldr	r3, [sp, #4]
3003ce68:	e0803003 	add	r3, r0, r3
3003ce6c:	e5933000 	ldr	r3, [r3]
3003ce70:	e0632002 	rsb	r2, r3, r2
3003ce74:	e3e0308f 	mvn	r3, #143	; 0x8f
3003ce78:	e1a01101 	lsl	r1, r1, #2
3003ce7c:	e28dcf56 	add	ip, sp, #344	; 0x158
3003ce80:	e081100c 	add	r1, r1, ip
3003ce84:	e0813003 	add	r3, r1, r3
3003ce88:	e5832000 	str	r2, [r3]
		init=0;
	}
	/* input butterflies - level 1 */
    /* 32 adds */

    for(i = 0; i < 16; i++) {
3003ce8c:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003ce90:	e2833001 	add	r3, r3, #1
3003ce94:	e58d3150 	str	r3, [sp, #336]	; 0x150
3003ce98:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003ce9c:	e353000f 	cmp	r3, #15
3003cea0:	daffffd3 	ble	3003cdf4 <fast_idct+0x64>
    }

    /* input butterflies - level 2 */
    /* 16 adds */

    for(i = 0; i < 8; i++) {
3003cea4:	e3a03000 	mov	r3, #0
3003cea8:	e58d3150 	str	r3, [sp, #336]	; 0x150
3003ceac:	ea000030 	b	3003cf74 <fast_idct+0x1e4>
	   ee[i] = even[i] + even[15-i];
3003ceb0:	e59d1150 	ldr	r1, [sp, #336]	; 0x150
3003ceb4:	e59d2150 	ldr	r2, [sp, #336]	; 0x150
3003ceb8:	e3e0304f 	mvn	r3, #79	; 0x4f
3003cebc:	e1a02102 	lsl	r2, r2, #2
3003cec0:	e28d0f56 	add	r0, sp, #344	; 0x158
3003cec4:	e0822000 	add	r2, r2, r0
3003cec8:	e0823003 	add	r3, r2, r3
3003cecc:	e5932000 	ldr	r2, [r3]
3003ced0:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003ced4:	e263000f 	rsb	r0, r3, #15
3003ced8:	e3e0304f 	mvn	r3, #79	; 0x4f
3003cedc:	e1a00100 	lsl	r0, r0, #2
3003cee0:	e28dcf56 	add	ip, sp, #344	; 0x158
3003cee4:	e080000c 	add	r0, r0, ip
3003cee8:	e0803003 	add	r3, r0, r3
3003ceec:	e5933000 	ldr	r3, [r3]
3003cef0:	e0822003 	add	r2, r2, r3
3003cef4:	e3e030af 	mvn	r3, #175	; 0xaf
3003cef8:	e1a01101 	lsl	r1, r1, #2
3003cefc:	e28d0f56 	add	r0, sp, #344	; 0x158
3003cf00:	e0811000 	add	r1, r1, r0
3003cf04:	e0813003 	add	r3, r1, r3
3003cf08:	e5832000 	str	r2, [r3]
	   eo[i] = even[i] - even[15-i];
3003cf0c:	e59d1150 	ldr	r1, [sp, #336]	; 0x150
3003cf10:	e59d2150 	ldr	r2, [sp, #336]	; 0x150
3003cf14:	e3e0304f 	mvn	r3, #79	; 0x4f
3003cf18:	e1a02102 	lsl	r2, r2, #2
3003cf1c:	e28dcf56 	add	ip, sp, #344	; 0x158
3003cf20:	e082200c 	add	r2, r2, ip
3003cf24:	e0823003 	add	r3, r2, r3
3003cf28:	e5932000 	ldr	r2, [r3]
3003cf2c:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003cf30:	e263000f 	rsb	r0, r3, #15
3003cf34:	e3e0304f 	mvn	r3, #79	; 0x4f
3003cf38:	e1a00100 	lsl	r0, r0, #2
3003cf3c:	e28dcf56 	add	ip, sp, #344	; 0x158
3003cf40:	e080000c 	add	r0, r0, ip
3003cf44:	e0803003 	add	r3, r0, r3
3003cf48:	e5933000 	ldr	r3, [r3]
3003cf4c:	e0632002 	rsb	r2, r3, r2
3003cf50:	e3e030cf 	mvn	r3, #207	; 0xcf
3003cf54:	e1a01101 	lsl	r1, r1, #2
3003cf58:	e28d0f56 	add	r0, sp, #344	; 0x158
3003cf5c:	e0811000 	add	r1, r1, r0
3003cf60:	e0813003 	add	r3, r1, r3
3003cf64:	e5832000 	str	r2, [r3]
    }

    /* input butterflies - level 2 */
    /* 16 adds */

    for(i = 0; i < 8; i++) {
3003cf68:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003cf6c:	e2833001 	add	r3, r3, #1
3003cf70:	e58d3150 	str	r3, [sp, #336]	; 0x150
3003cf74:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003cf78:	e3530007 	cmp	r3, #7
3003cf7c:	daffffcb 	ble	3003ceb0 <fast_idct+0x120>

    /* multiply the even_even vector (ee) with the ee matrix (A8) */
    /* multiply the even_odd vector (eo) with the eo matrix (B8) */
    /* 128 muls, 128 adds */

    for(i = 0; i < 8; i++) {
3003cf80:	e3a03000 	mov	r3, #0
3003cf84:	e58d3150 	str	r3, [sp, #336]	; 0x150
3003cf88:	ea00007d 	b	3003d184 <fast_idct+0x3f4>
	  s1 = 0;
3003cf8c:	e3a03000 	mov	r3, #0
3003cf90:	e58d3148 	str	r3, [sp, #328]	; 0x148
	  s2 = 0;
3003cf94:	e3a03000 	mov	r3, #0
3003cf98:	e58d314c 	str	r3, [sp, #332]	; 0x14c
	  for(j = 0; j < 8; j += 2) 
3003cf9c:	e3a03000 	mov	r3, #0
3003cfa0:	e58d3154 	str	r3, [sp, #340]	; 0x154
3003cfa4:	ea00005a 	b	3003d114 <fast_idct+0x384>
	  {
	    s1 += A8[i][j] * ee[j]/10240 +
3003cfa8:	e59d1150 	ldr	r1, [sp, #336]	; 0x150
3003cfac:	e59d2154 	ldr	r2, [sp, #340]	; 0x154
3003cfb0:	e59f34f0 	ldr	r3, [pc, #1264]	; 3003d4a8 <fast_idct+0x718>
3003cfb4:	e1a01181 	lsl	r1, r1, #3
3003cfb8:	e0812002 	add	r2, r1, r2
3003cfbc:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3003cfc0:	e59d1154 	ldr	r1, [sp, #340]	; 0x154
3003cfc4:	e3e020af 	mvn	r2, #175	; 0xaf
3003cfc8:	e1a01101 	lsl	r1, r1, #2
3003cfcc:	e28dcf56 	add	ip, sp, #344	; 0x158
3003cfd0:	e081100c 	add	r1, r1, ip
3003cfd4:	e0812002 	add	r2, r1, r2
3003cfd8:	e5922000 	ldr	r2, [r2]
3003cfdc:	e0030392 	mul	r3, r2, r3
3003cfe0:	e59f24c4 	ldr	r2, [pc, #1220]	; 3003d4ac <fast_idct+0x71c>
3003cfe4:	e0c20293 	smull	r0, r2, r3, r2
3003cfe8:	e1a02642 	asr	r2, r2, #12
3003cfec:	e1a03fc3 	asr	r3, r3, #31
3003cff0:	e0632002 	rsb	r2, r3, r2
		A8[i][j+1] * ee[j+1]/10240;
3003cff4:	e59d0150 	ldr	r0, [sp, #336]	; 0x150
3003cff8:	e59d3154 	ldr	r3, [sp, #340]	; 0x154
3003cffc:	e2831001 	add	r1, r3, #1
3003d000:	e59f34a0 	ldr	r3, [pc, #1184]	; 3003d4a8 <fast_idct+0x718>
3003d004:	e1a00180 	lsl	r0, r0, #3
3003d008:	e0801001 	add	r1, r0, r1
3003d00c:	e7933101 	ldr	r3, [r3, r1, lsl #2]
3003d010:	e59d1154 	ldr	r1, [sp, #340]	; 0x154
3003d014:	e2810001 	add	r0, r1, #1
3003d018:	e3e010af 	mvn	r1, #175	; 0xaf
3003d01c:	e1a00100 	lsl	r0, r0, #2
3003d020:	e28dcf56 	add	ip, sp, #344	; 0x158
3003d024:	e080000c 	add	r0, r0, ip
3003d028:	e0801001 	add	r1, r0, r1
3003d02c:	e5911000 	ldr	r1, [r1]
3003d030:	e0030391 	mul	r3, r1, r3
3003d034:	e59f1470 	ldr	r1, [pc, #1136]	; 3003d4ac <fast_idct+0x71c>
3003d038:	e0c10193 	smull	r0, r1, r3, r1
3003d03c:	e1a01641 	asr	r1, r1, #12
3003d040:	e1a03fc3 	asr	r3, r3, #31
3003d044:	e0633001 	rsb	r3, r3, r1
    for(i = 0; i < 8; i++) {
	  s1 = 0;
	  s2 = 0;
	  for(j = 0; j < 8; j += 2) 
	  {
	    s1 += A8[i][j] * ee[j]/10240 +
3003d048:	e0823003 	add	r3, r2, r3
3003d04c:	e59d2148 	ldr	r2, [sp, #328]	; 0x148
3003d050:	e0823003 	add	r3, r2, r3
3003d054:	e58d3148 	str	r3, [sp, #328]	; 0x148
		A8[i][j+1] * ee[j+1]/10240;
	    s2 += B8[i][j] * eo[j]/10240 +
3003d058:	e59d1150 	ldr	r1, [sp, #336]	; 0x150
3003d05c:	e59d2154 	ldr	r2, [sp, #340]	; 0x154
3003d060:	e59f3448 	ldr	r3, [pc, #1096]	; 3003d4b0 <fast_idct+0x720>
3003d064:	e1a01181 	lsl	r1, r1, #3
3003d068:	e0812002 	add	r2, r1, r2
3003d06c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3003d070:	e59d1154 	ldr	r1, [sp, #340]	; 0x154
3003d074:	e3e020cf 	mvn	r2, #207	; 0xcf
3003d078:	e1a01101 	lsl	r1, r1, #2
3003d07c:	e28dcf56 	add	ip, sp, #344	; 0x158
3003d080:	e081100c 	add	r1, r1, ip
3003d084:	e0812002 	add	r2, r1, r2
3003d088:	e5922000 	ldr	r2, [r2]
3003d08c:	e0030392 	mul	r3, r2, r3
3003d090:	e59f2414 	ldr	r2, [pc, #1044]	; 3003d4ac <fast_idct+0x71c>
3003d094:	e0c20293 	smull	r0, r2, r3, r2
3003d098:	e1a02642 	asr	r2, r2, #12
3003d09c:	e1a03fc3 	asr	r3, r3, #31
3003d0a0:	e0632002 	rsb	r2, r3, r2
		B8[i][j+1] * eo[j+1]/10240;
3003d0a4:	e59d0150 	ldr	r0, [sp, #336]	; 0x150
3003d0a8:	e59d3154 	ldr	r3, [sp, #340]	; 0x154
3003d0ac:	e2831001 	add	r1, r3, #1
3003d0b0:	e59f33f8 	ldr	r3, [pc, #1016]	; 3003d4b0 <fast_idct+0x720>
3003d0b4:	e1a00180 	lsl	r0, r0, #3
3003d0b8:	e0801001 	add	r1, r0, r1
3003d0bc:	e7933101 	ldr	r3, [r3, r1, lsl #2]
3003d0c0:	e59d1154 	ldr	r1, [sp, #340]	; 0x154
3003d0c4:	e2810001 	add	r0, r1, #1
3003d0c8:	e3e010cf 	mvn	r1, #207	; 0xcf
3003d0cc:	e1a00100 	lsl	r0, r0, #2
3003d0d0:	e28dcf56 	add	ip, sp, #344	; 0x158
3003d0d4:	e080000c 	add	r0, r0, ip
3003d0d8:	e0801001 	add	r1, r0, r1
3003d0dc:	e5911000 	ldr	r1, [r1]
3003d0e0:	e0030391 	mul	r3, r1, r3
3003d0e4:	e59f13c0 	ldr	r1, [pc, #960]	; 3003d4ac <fast_idct+0x71c>
3003d0e8:	e0c10193 	smull	r0, r1, r3, r1
3003d0ec:	e1a01641 	asr	r1, r1, #12
3003d0f0:	e1a03fc3 	asr	r3, r3, #31
3003d0f4:	e0633001 	rsb	r3, r3, r1
	  s2 = 0;
	  for(j = 0; j < 8; j += 2) 
	  {
	    s1 += A8[i][j] * ee[j]/10240 +
		A8[i][j+1] * ee[j+1]/10240;
	    s2 += B8[i][j] * eo[j]/10240 +
3003d0f8:	e0823003 	add	r3, r2, r3
3003d0fc:	e59d214c 	ldr	r2, [sp, #332]	; 0x14c
3003d100:	e0823003 	add	r3, r2, r3
3003d104:	e58d314c 	str	r3, [sp, #332]	; 0x14c
    /* 128 muls, 128 adds */

    for(i = 0; i < 8; i++) {
	  s1 = 0;
	  s2 = 0;
	  for(j = 0; j < 8; j += 2) 
3003d108:	e59d3154 	ldr	r3, [sp, #340]	; 0x154
3003d10c:	e2833002 	add	r3, r3, #2
3003d110:	e58d3154 	str	r3, [sp, #340]	; 0x154
3003d114:	e59d3154 	ldr	r3, [sp, #340]	; 0x154
3003d118:	e3530007 	cmp	r3, #7
3003d11c:	daffffa1 	ble	3003cfa8 <fast_idct+0x218>
	    s1 += A8[i][j] * ee[j]/10240 +
		A8[i][j+1] * ee[j+1]/10240;
	    s2 += B8[i][j] * eo[j]/10240 +
		B8[i][j+1] * eo[j+1]/10240;
	  }
	  t[i*4] = s1;
3003d120:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003d124:	e1a02103 	lsl	r2, r3, #2
3003d128:	e3a0332b 	mov	r3, #-1409286144	; 0xac000000
3003d12c:	e1a03b43 	asr	r3, r3, #22
3003d130:	e1a02102 	lsl	r2, r2, #2
3003d134:	e28d1f56 	add	r1, sp, #344	; 0x158
3003d138:	e0822001 	add	r2, r2, r1
3003d13c:	e0823003 	add	r3, r2, r3
3003d140:	e59d2148 	ldr	r2, [sp, #328]	; 0x148
3003d144:	e5832000 	str	r2, [r3]
	  t[i*4+2] = s2;
3003d148:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003d14c:	e1a03083 	lsl	r3, r3, #1
3003d150:	e2833001 	add	r3, r3, #1
3003d154:	e1a02083 	lsl	r2, r3, #1
3003d158:	e3a0332b 	mov	r3, #-1409286144	; 0xac000000
3003d15c:	e1a03b43 	asr	r3, r3, #22
3003d160:	e1a02102 	lsl	r2, r2, #2
3003d164:	e28dcf56 	add	ip, sp, #344	; 0x158
3003d168:	e082200c 	add	r2, r2, ip
3003d16c:	e0823003 	add	r3, r2, r3
3003d170:	e59d214c 	ldr	r2, [sp, #332]	; 0x14c
3003d174:	e5832000 	str	r2, [r3]

    /* multiply the even_even vector (ee) with the ee matrix (A8) */
    /* multiply the even_odd vector (eo) with the eo matrix (B8) */
    /* 128 muls, 128 adds */

    for(i = 0; i < 8; i++) {
3003d178:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003d17c:	e2833001 	add	r3, r3, #1
3003d180:	e58d3150 	str	r3, [sp, #336]	; 0x150
3003d184:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003d188:	e3530007 	cmp	r3, #7
3003d18c:	daffff7e 	ble	3003cf8c <fast_idct+0x1fc>


    /* multiply the odd vector (odd) with the odd matrix (B16) */
    /* 256 muls, 256 adds */

    for(i = 0; i < 16; i++) 
3003d190:	e3a03000 	mov	r3, #0
3003d194:	e58d3150 	str	r3, [sp, #336]	; 0x150
3003d198:	ea000070 	b	3003d360 <fast_idct+0x5d0>
	{
	  s1 = 0;
3003d19c:	e3a03000 	mov	r3, #0
3003d1a0:	e58d3148 	str	r3, [sp, #328]	; 0x148
	  for(j = 0; j < 16; j += 4) 
3003d1a4:	e3a03000 	mov	r3, #0
3003d1a8:	e58d3154 	str	r3, [sp, #340]	; 0x154
3003d1ac:	ea00005a 	b	3003d31c <fast_idct+0x58c>
	  {
	    s1 += B16[i][j] * odd[j]/10240 +
3003d1b0:	e59d1150 	ldr	r1, [sp, #336]	; 0x150
3003d1b4:	e59d2154 	ldr	r2, [sp, #340]	; 0x154
3003d1b8:	e59f32f4 	ldr	r3, [pc, #756]	; 3003d4b4 <fast_idct+0x724>
3003d1bc:	e1a01201 	lsl	r1, r1, #4
3003d1c0:	e0812002 	add	r2, r1, r2
3003d1c4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3003d1c8:	e59d1154 	ldr	r1, [sp, #340]	; 0x154
3003d1cc:	e3e0208f 	mvn	r2, #143	; 0x8f
3003d1d0:	e1a01101 	lsl	r1, r1, #2
3003d1d4:	e28d0f56 	add	r0, sp, #344	; 0x158
3003d1d8:	e0811000 	add	r1, r1, r0
3003d1dc:	e0812002 	add	r2, r1, r2
3003d1e0:	e5922000 	ldr	r2, [r2]
3003d1e4:	e0030392 	mul	r3, r2, r3
3003d1e8:	e59f22bc 	ldr	r2, [pc, #700]	; 3003d4ac <fast_idct+0x71c>
3003d1ec:	e0c21293 	smull	r1, r2, r3, r2
3003d1f0:	e1a02642 	asr	r2, r2, #12
3003d1f4:	e1a03fc3 	asr	r3, r3, #31
3003d1f8:	e0632002 	rsb	r2, r3, r2
		B16[i][j+1] * odd[j+1]/10240 +
3003d1fc:	e59d0150 	ldr	r0, [sp, #336]	; 0x150
3003d200:	e59d3154 	ldr	r3, [sp, #340]	; 0x154
3003d204:	e2831001 	add	r1, r3, #1
3003d208:	e59f32a4 	ldr	r3, [pc, #676]	; 3003d4b4 <fast_idct+0x724>
3003d20c:	e1a00200 	lsl	r0, r0, #4
3003d210:	e0801001 	add	r1, r0, r1
3003d214:	e7933101 	ldr	r3, [r3, r1, lsl #2]
3003d218:	e59d1154 	ldr	r1, [sp, #340]	; 0x154
3003d21c:	e2810001 	add	r0, r1, #1
3003d220:	e3e0108f 	mvn	r1, #143	; 0x8f
3003d224:	e1a00100 	lsl	r0, r0, #2
3003d228:	e28dcf56 	add	ip, sp, #344	; 0x158
3003d22c:	e080000c 	add	r0, r0, ip
3003d230:	e0801001 	add	r1, r0, r1
3003d234:	e5911000 	ldr	r1, [r1]
3003d238:	e0030391 	mul	r3, r1, r3
3003d23c:	e59f1268 	ldr	r1, [pc, #616]	; 3003d4ac <fast_idct+0x71c>
3003d240:	e0c10193 	smull	r0, r1, r3, r1
3003d244:	e1a01641 	asr	r1, r1, #12
3003d248:	e1a03fc3 	asr	r3, r3, #31
3003d24c:	e0633001 	rsb	r3, r3, r1
3003d250:	e0822003 	add	r2, r2, r3
		B16[i][j+2] * odd[j+2]/10240 +
3003d254:	e59d0150 	ldr	r0, [sp, #336]	; 0x150
3003d258:	e59d3154 	ldr	r3, [sp, #340]	; 0x154
3003d25c:	e2831002 	add	r1, r3, #2
3003d260:	e59f324c 	ldr	r3, [pc, #588]	; 3003d4b4 <fast_idct+0x724>
3003d264:	e1a00200 	lsl	r0, r0, #4
3003d268:	e0801001 	add	r1, r0, r1
3003d26c:	e7933101 	ldr	r3, [r3, r1, lsl #2]
3003d270:	e59d1154 	ldr	r1, [sp, #340]	; 0x154
3003d274:	e2810002 	add	r0, r1, #2
3003d278:	e3e0108f 	mvn	r1, #143	; 0x8f
3003d27c:	e1a00100 	lsl	r0, r0, #2
3003d280:	e28dcf56 	add	ip, sp, #344	; 0x158
3003d284:	e080000c 	add	r0, r0, ip
3003d288:	e0801001 	add	r1, r0, r1
3003d28c:	e5911000 	ldr	r1, [r1]
3003d290:	e0030391 	mul	r3, r1, r3
3003d294:	e59f1210 	ldr	r1, [pc, #528]	; 3003d4ac <fast_idct+0x71c>
3003d298:	e0c10193 	smull	r0, r1, r3, r1
3003d29c:	e1a01641 	asr	r1, r1, #12
3003d2a0:	e1a03fc3 	asr	r3, r3, #31
3003d2a4:	e0633001 	rsb	r3, r3, r1
3003d2a8:	e0822003 	add	r2, r2, r3
		B16[i][j+3] * odd[j+3]/10240;
3003d2ac:	e59d0150 	ldr	r0, [sp, #336]	; 0x150
3003d2b0:	e59d3154 	ldr	r3, [sp, #340]	; 0x154
3003d2b4:	e2831003 	add	r1, r3, #3
3003d2b8:	e59f31f4 	ldr	r3, [pc, #500]	; 3003d4b4 <fast_idct+0x724>
3003d2bc:	e1a00200 	lsl	r0, r0, #4
3003d2c0:	e0801001 	add	r1, r0, r1
3003d2c4:	e7933101 	ldr	r3, [r3, r1, lsl #2]
3003d2c8:	e59d1154 	ldr	r1, [sp, #340]	; 0x154
3003d2cc:	e2810003 	add	r0, r1, #3
3003d2d0:	e3e0108f 	mvn	r1, #143	; 0x8f
3003d2d4:	e1a00100 	lsl	r0, r0, #2
3003d2d8:	e28dcf56 	add	ip, sp, #344	; 0x158
3003d2dc:	e080000c 	add	r0, r0, ip
3003d2e0:	e0801001 	add	r1, r0, r1
3003d2e4:	e5911000 	ldr	r1, [r1]
3003d2e8:	e0030391 	mul	r3, r1, r3
3003d2ec:	e59f11b8 	ldr	r1, [pc, #440]	; 3003d4ac <fast_idct+0x71c>
3003d2f0:	e0c10193 	smull	r0, r1, r3, r1
3003d2f4:	e1a01641 	asr	r1, r1, #12
3003d2f8:	e1a03fc3 	asr	r3, r3, #31
3003d2fc:	e0633001 	rsb	r3, r3, r1
    for(i = 0; i < 16; i++) 
	{
	  s1 = 0;
	  for(j = 0; j < 16; j += 4) 
	  {
	    s1 += B16[i][j] * odd[j]/10240 +
3003d300:	e0823003 	add	r3, r2, r3
3003d304:	e59d2148 	ldr	r2, [sp, #328]	; 0x148
3003d308:	e0823003 	add	r3, r2, r3
3003d30c:	e58d3148 	str	r3, [sp, #328]	; 0x148
    /* 256 muls, 256 adds */

    for(i = 0; i < 16; i++) 
	{
	  s1 = 0;
	  for(j = 0; j < 16; j += 4) 
3003d310:	e59d3154 	ldr	r3, [sp, #340]	; 0x154
3003d314:	e2833004 	add	r3, r3, #4
3003d318:	e58d3154 	str	r3, [sp, #340]	; 0x154
3003d31c:	e59d3154 	ldr	r3, [sp, #340]	; 0x154
3003d320:	e353000f 	cmp	r3, #15
3003d324:	daffffa1 	ble	3003d1b0 <fast_idct+0x420>
	    s1 += B16[i][j] * odd[j]/10240 +
		B16[i][j+1] * odd[j+1]/10240 +
		B16[i][j+2] * odd[j+2]/10240 +
		B16[i][j+3] * odd[j+3]/10240;
	  }
	  t[i*2+1] = s1;
3003d328:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003d32c:	e1a03083 	lsl	r3, r3, #1
3003d330:	e2832001 	add	r2, r3, #1
3003d334:	e3a0332b 	mov	r3, #-1409286144	; 0xac000000
3003d338:	e1a03b43 	asr	r3, r3, #22
3003d33c:	e1a02102 	lsl	r2, r2, #2
3003d340:	e28d1f56 	add	r1, sp, #344	; 0x158
3003d344:	e0822001 	add	r2, r2, r1
3003d348:	e0823003 	add	r3, r2, r3
3003d34c:	e59d2148 	ldr	r2, [sp, #328]	; 0x148
3003d350:	e5832000 	str	r2, [r3]


    /* multiply the odd vector (odd) with the odd matrix (B16) */
    /* 256 muls, 256 adds */

    for(i = 0; i < 16; i++) 
3003d354:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003d358:	e2833001 	add	r3, r3, #1
3003d35c:	e58d3150 	str	r3, [sp, #336]	; 0x150
3003d360:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003d364:	e353000f 	cmp	r3, #15
3003d368:	daffff8b 	ble	3003d19c <fast_idct+0x40c>
    }

    /* the output vector t now is expanded to 64 values using the
       symmetric property of the cosinus function */

    for(i = 0; i < 16; i++) 
3003d36c:	e3a03000 	mov	r3, #0
3003d370:	e58d3150 	str	r3, [sp, #336]	; 0x150
3003d374:	ea00003f 	b	3003d478 <fast_idct+0x6e8>
	{
	  out[i] = t[i+16];
3003d378:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003d37c:	e1a02103 	lsl	r2, r3, #2
3003d380:	e59d3000 	ldr	r3, [sp]
3003d384:	e0822003 	add	r2, r2, r3
3003d388:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003d38c:	e2831010 	add	r1, r3, #16
3003d390:	e3a0332b 	mov	r3, #-1409286144	; 0xac000000
3003d394:	e1a03b43 	asr	r3, r3, #22
3003d398:	e1a01101 	lsl	r1, r1, #2
3003d39c:	e28dcf56 	add	ip, sp, #344	; 0x158
3003d3a0:	e081100c 	add	r1, r1, ip
3003d3a4:	e0813003 	add	r3, r1, r3
3003d3a8:	e5933000 	ldr	r3, [r3]
3003d3ac:	e5823000 	str	r3, [r2]
	  out[i+17] = -t[31-i];
3003d3b0:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003d3b4:	e2833011 	add	r3, r3, #17
3003d3b8:	e1a02103 	lsl	r2, r3, #2
3003d3bc:	e59d3000 	ldr	r3, [sp]
3003d3c0:	e0822003 	add	r2, r2, r3
3003d3c4:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003d3c8:	e263101f 	rsb	r1, r3, #31
3003d3cc:	e3a0332b 	mov	r3, #-1409286144	; 0xac000000
3003d3d0:	e1a03b43 	asr	r3, r3, #22
3003d3d4:	e1a01101 	lsl	r1, r1, #2
3003d3d8:	e28d0f56 	add	r0, sp, #344	; 0x158
3003d3dc:	e0811000 	add	r1, r1, r0
3003d3e0:	e0813003 	add	r3, r1, r3
3003d3e4:	e5933000 	ldr	r3, [r3]
3003d3e8:	e2633000 	rsb	r3, r3, #0
3003d3ec:	e5823000 	str	r3, [r2]
	  out[i+32] = -t[16-i];
3003d3f0:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003d3f4:	e2833020 	add	r3, r3, #32
3003d3f8:	e1a02103 	lsl	r2, r3, #2
3003d3fc:	e59d3000 	ldr	r3, [sp]
3003d400:	e0822003 	add	r2, r2, r3
3003d404:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003d408:	e2631010 	rsb	r1, r3, #16
3003d40c:	e3a0332b 	mov	r3, #-1409286144	; 0xac000000
3003d410:	e1a03b43 	asr	r3, r3, #22
3003d414:	e1a01101 	lsl	r1, r1, #2
3003d418:	e28dcf56 	add	ip, sp, #344	; 0x158
3003d41c:	e081100c 	add	r1, r1, ip
3003d420:	e0813003 	add	r3, r1, r3
3003d424:	e5933000 	ldr	r3, [r3]
3003d428:	e2633000 	rsb	r3, r3, #0
3003d42c:	e5823000 	str	r3, [r2]
	  out[i+48] = -t[i];
3003d430:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003d434:	e2833030 	add	r3, r3, #48	; 0x30
3003d438:	e1a02103 	lsl	r2, r3, #2
3003d43c:	e59d3000 	ldr	r3, [sp]
3003d440:	e0822003 	add	r2, r2, r3
3003d444:	e59d1150 	ldr	r1, [sp, #336]	; 0x150
3003d448:	e3a0332b 	mov	r3, #-1409286144	; 0xac000000
3003d44c:	e1a03b43 	asr	r3, r3, #22
3003d450:	e1a01101 	lsl	r1, r1, #2
3003d454:	e28d0f56 	add	r0, sp, #344	; 0x158
3003d458:	e0811000 	add	r1, r1, r0
3003d45c:	e0813003 	add	r3, r1, r3
3003d460:	e5933000 	ldr	r3, [r3]
3003d464:	e2633000 	rsb	r3, r3, #0
3003d468:	e5823000 	str	r3, [r2]
    }

    /* the output vector t now is expanded to 64 values using the
       symmetric property of the cosinus function */

    for(i = 0; i < 16; i++) 
3003d46c:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003d470:	e2833001 	add	r3, r3, #1
3003d474:	e58d3150 	str	r3, [sp, #336]	; 0x150
3003d478:	e59d3150 	ldr	r3, [sp, #336]	; 0x150
3003d47c:	e353000f 	cmp	r3, #15
3003d480:	daffffbc 	ble	3003d378 <fast_idct+0x5e8>
	  out[i] = t[i+16];
	  out[i+17] = -t[31-i];
	  out[i+32] = -t[16-i];
	  out[i+48] = -t[i];
    }
    out[16] = 0;
3003d484:	e59d3000 	ldr	r3, [sp]
3003d488:	e2833040 	add	r3, r3, #64	; 0x40
3003d48c:	e3a02000 	mov	r2, #0
3003d490:	e5832000 	str	r2, [r3]
}
3003d494:	e28ddf57 	add	sp, sp, #348	; 0x15c
3003d498:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3003d49c:	e12fff1e 	bx	lr
3003d4a0:	300c9a90 	.word	0x300c9a90
3003d4a4:	300c99b8 	.word	0x300c99b8
3003d4a8:	300e7d80 	.word	0x300e7d80
3003d4ac:	66666667 	.word	0x66666667
3003d4b0:	300e8c80 	.word	0x300e8c80
3003d4b4:	300e8880 	.word	0x300e8880

3003d4b8 <matrix_mul16>:

void matrix_mul16(int in1[16][16],
		  int in2[16][16],
		  int out[16][16])
{
3003d4b8:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
3003d4bc:	e24dd024 	sub	sp, sp, #36	; 0x24
3003d4c0:	e58d000c 	str	r0, [sp, #12]
3003d4c4:	e58d1008 	str	r1, [sp, #8]
3003d4c8:	e58d2004 	str	r2, [sp, #4]
    int i,j,z;

    for(i = 0; i < 16; i++) {
3003d4cc:	e3a03000 	mov	r3, #0
3003d4d0:	e58d3014 	str	r3, [sp, #20]
3003d4d4:	ea00003a 	b	3003d5c4 <matrix_mul16+0x10c>
	  for(j = 0; j < 16; j++)
3003d4d8:	e3a03000 	mov	r3, #0
3003d4dc:	e58d3018 	str	r3, [sp, #24]
3003d4e0:	ea000031 	b	3003d5ac <matrix_mul16+0xf4>
	  {
	    out[i][j] = 0;
3003d4e4:	e59d3014 	ldr	r3, [sp, #20]
3003d4e8:	e1a02303 	lsl	r2, r3, #6
3003d4ec:	e59d3004 	ldr	r3, [sp, #4]
3003d4f0:	e0823003 	add	r3, r2, r3
3003d4f4:	e59d2018 	ldr	r2, [sp, #24]
3003d4f8:	e3a01000 	mov	r1, #0
3003d4fc:	e7831102 	str	r1, [r3, r2, lsl #2]
	    for(z = 0; z < 16; z++)
3003d500:	e3a03000 	mov	r3, #0
3003d504:	e58d301c 	str	r3, [sp, #28]
3003d508:	ea000021 	b	3003d594 <matrix_mul16+0xdc>
		  out[i][j] = out[i][j]+ in1[i][z] * in2[z][j]/10240;
3003d50c:	e59d3014 	ldr	r3, [sp, #20]
3003d510:	e1a02303 	lsl	r2, r3, #6
3003d514:	e59d3004 	ldr	r3, [sp, #4]
3003d518:	e0822003 	add	r2, r2, r3
3003d51c:	e59d1018 	ldr	r1, [sp, #24]
3003d520:	e59d3014 	ldr	r3, [sp, #20]
3003d524:	e1a00303 	lsl	r0, r3, #6
3003d528:	e59d3004 	ldr	r3, [sp, #4]
3003d52c:	e0803003 	add	r3, r0, r3
3003d530:	e59d0018 	ldr	r0, [sp, #24]
3003d534:	e7930100 	ldr	r0, [r3, r0, lsl #2]
3003d538:	e59d3014 	ldr	r3, [sp, #20]
3003d53c:	e1a0c303 	lsl	ip, r3, #6
3003d540:	e59d300c 	ldr	r3, [sp, #12]
3003d544:	e08c3003 	add	r3, ip, r3
3003d548:	e59dc01c 	ldr	ip, [sp, #28]
3003d54c:	e793310c 	ldr	r3, [r3, ip, lsl #2]
3003d550:	e59dc01c 	ldr	ip, [sp, #28]
3003d554:	e1a0430c 	lsl	r4, ip, #6
3003d558:	e59dc008 	ldr	ip, [sp, #8]
3003d55c:	e084c00c 	add	ip, r4, ip
3003d560:	e59d4018 	ldr	r4, [sp, #24]
3003d564:	e79cc104 	ldr	ip, [ip, r4, lsl #2]
3003d568:	e003039c 	mul	r3, ip, r3
3003d56c:	e59fc068 	ldr	ip, [pc, #104]	; 3003d5dc <matrix_mul16+0x124>
3003d570:	e0cc4c93 	smull	r4, ip, r3, ip
3003d574:	e1a0c64c 	asr	ip, ip, #12
3003d578:	e1a03fc3 	asr	r3, r3, #31
3003d57c:	e063300c 	rsb	r3, r3, ip
3003d580:	e0803003 	add	r3, r0, r3
3003d584:	e7823101 	str	r3, [r2, r1, lsl #2]

    for(i = 0; i < 16; i++) {
	  for(j = 0; j < 16; j++)
	  {
	    out[i][j] = 0;
	    for(z = 0; z < 16; z++)
3003d588:	e59d301c 	ldr	r3, [sp, #28]
3003d58c:	e2833001 	add	r3, r3, #1
3003d590:	e58d301c 	str	r3, [sp, #28]
3003d594:	e59d301c 	ldr	r3, [sp, #28]
3003d598:	e353000f 	cmp	r3, #15
3003d59c:	daffffda 	ble	3003d50c <matrix_mul16+0x54>
		  int out[16][16])
{
    int i,j,z;

    for(i = 0; i < 16; i++) {
	  for(j = 0; j < 16; j++)
3003d5a0:	e59d3018 	ldr	r3, [sp, #24]
3003d5a4:	e2833001 	add	r3, r3, #1
3003d5a8:	e58d3018 	str	r3, [sp, #24]
3003d5ac:	e59d3018 	ldr	r3, [sp, #24]
3003d5b0:	e353000f 	cmp	r3, #15
3003d5b4:	daffffca 	ble	3003d4e4 <matrix_mul16+0x2c>
		  int in2[16][16],
		  int out[16][16])
{
    int i,j,z;

    for(i = 0; i < 16; i++) {
3003d5b8:	e59d3014 	ldr	r3, [sp, #20]
3003d5bc:	e2833001 	add	r3, r3, #1
3003d5c0:	e58d3014 	str	r3, [sp, #20]
3003d5c4:	e59d3014 	ldr	r3, [sp, #20]
3003d5c8:	e353000f 	cmp	r3, #15
3003d5cc:	daffffc1 	ble	3003d4d8 <matrix_mul16+0x20>
	    out[i][j] = 0;
	    for(z = 0; z < 16; z++)
		  out[i][j] = out[i][j]+ in1[i][z] * in2[z][j]/10240;
	  }
    } 
}
3003d5d0:	e28dd024 	add	sp, sp, #36	; 0x24
3003d5d4:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
3003d5d8:	e12fff1e 	bx	lr
3003d5dc:	66666667 	.word	0x66666667

3003d5e0 <matrix_mul8>:

void matrix_mul8(int in1[8][8],
		 int in2[8][8],
		 int out[8][8])
{
3003d5e0:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
3003d5e4:	e24dd024 	sub	sp, sp, #36	; 0x24
3003d5e8:	e58d000c 	str	r0, [sp, #12]
3003d5ec:	e58d1008 	str	r1, [sp, #8]
3003d5f0:	e58d2004 	str	r2, [sp, #4]
    int i,j,z;

    for(i = 0; i < 8; i++) {
3003d5f4:	e3a03000 	mov	r3, #0
3003d5f8:	e58d3014 	str	r3, [sp, #20]
3003d5fc:	ea00003a 	b	3003d6ec <matrix_mul8+0x10c>
	  for(j = 0; j < 8; j++)  
3003d600:	e3a03000 	mov	r3, #0
3003d604:	e58d3018 	str	r3, [sp, #24]
3003d608:	ea000031 	b	3003d6d4 <matrix_mul8+0xf4>
	  {
	    out[i][j] = 0;
3003d60c:	e59d3014 	ldr	r3, [sp, #20]
3003d610:	e1a02283 	lsl	r2, r3, #5
3003d614:	e59d3004 	ldr	r3, [sp, #4]
3003d618:	e0823003 	add	r3, r2, r3
3003d61c:	e59d2018 	ldr	r2, [sp, #24]
3003d620:	e3a01000 	mov	r1, #0
3003d624:	e7831102 	str	r1, [r3, r2, lsl #2]
	    for(z = 0; z < 8; z++)
3003d628:	e3a03000 	mov	r3, #0
3003d62c:	e58d301c 	str	r3, [sp, #28]
3003d630:	ea000021 	b	3003d6bc <matrix_mul8+0xdc>
	 	  out[i][j] = out[i][j] + in1[i][z] * in2[z][j]/10240;
3003d634:	e59d3014 	ldr	r3, [sp, #20]
3003d638:	e1a02283 	lsl	r2, r3, #5
3003d63c:	e59d3004 	ldr	r3, [sp, #4]
3003d640:	e0822003 	add	r2, r2, r3
3003d644:	e59d1018 	ldr	r1, [sp, #24]
3003d648:	e59d3014 	ldr	r3, [sp, #20]
3003d64c:	e1a00283 	lsl	r0, r3, #5
3003d650:	e59d3004 	ldr	r3, [sp, #4]
3003d654:	e0803003 	add	r3, r0, r3
3003d658:	e59d0018 	ldr	r0, [sp, #24]
3003d65c:	e7930100 	ldr	r0, [r3, r0, lsl #2]
3003d660:	e59d3014 	ldr	r3, [sp, #20]
3003d664:	e1a0c283 	lsl	ip, r3, #5
3003d668:	e59d300c 	ldr	r3, [sp, #12]
3003d66c:	e08c3003 	add	r3, ip, r3
3003d670:	e59dc01c 	ldr	ip, [sp, #28]
3003d674:	e793310c 	ldr	r3, [r3, ip, lsl #2]
3003d678:	e59dc01c 	ldr	ip, [sp, #28]
3003d67c:	e1a0428c 	lsl	r4, ip, #5
3003d680:	e59dc008 	ldr	ip, [sp, #8]
3003d684:	e084c00c 	add	ip, r4, ip
3003d688:	e59d4018 	ldr	r4, [sp, #24]
3003d68c:	e79cc104 	ldr	ip, [ip, r4, lsl #2]
3003d690:	e003039c 	mul	r3, ip, r3
3003d694:	e59fc068 	ldr	ip, [pc, #104]	; 3003d704 <matrix_mul8+0x124>
3003d698:	e0cc4c93 	smull	r4, ip, r3, ip
3003d69c:	e1a0c64c 	asr	ip, ip, #12
3003d6a0:	e1a03fc3 	asr	r3, r3, #31
3003d6a4:	e063300c 	rsb	r3, r3, ip
3003d6a8:	e0803003 	add	r3, r0, r3
3003d6ac:	e7823101 	str	r3, [r2, r1, lsl #2]

    for(i = 0; i < 8; i++) {
	  for(j = 0; j < 8; j++)  
	  {
	    out[i][j] = 0;
	    for(z = 0; z < 8; z++)
3003d6b0:	e59d301c 	ldr	r3, [sp, #28]
3003d6b4:	e2833001 	add	r3, r3, #1
3003d6b8:	e58d301c 	str	r3, [sp, #28]
3003d6bc:	e59d301c 	ldr	r3, [sp, #28]
3003d6c0:	e3530007 	cmp	r3, #7
3003d6c4:	daffffda 	ble	3003d634 <matrix_mul8+0x54>
		 int out[8][8])
{
    int i,j,z;

    for(i = 0; i < 8; i++) {
	  for(j = 0; j < 8; j++)  
3003d6c8:	e59d3018 	ldr	r3, [sp, #24]
3003d6cc:	e2833001 	add	r3, r3, #1
3003d6d0:	e58d3018 	str	r3, [sp, #24]
3003d6d4:	e59d3018 	ldr	r3, [sp, #24]
3003d6d8:	e3530007 	cmp	r3, #7
3003d6dc:	daffffca 	ble	3003d60c <matrix_mul8+0x2c>
		 int in2[8][8],
		 int out[8][8])
{
    int i,j,z;

    for(i = 0; i < 8; i++) {
3003d6e0:	e59d3014 	ldr	r3, [sp, #20]
3003d6e4:	e2833001 	add	r3, r3, #1
3003d6e8:	e58d3014 	str	r3, [sp, #20]
3003d6ec:	e59d3014 	ldr	r3, [sp, #20]
3003d6f0:	e3530007 	cmp	r3, #7
3003d6f4:	daffffc1 	ble	3003d600 <matrix_mul8+0x20>
	    out[i][j] = 0;
	    for(z = 0; z < 8; z++)
	 	  out[i][j] = out[i][j] + in1[i][z] * in2[z][j]/10240;
	  }
    }
}
3003d6f8:	e28dd024 	add	sp, sp, #36	; 0x24
3003d6fc:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
3003d700:	e12fff1e 	bx	lr
3003d704:	66666667 	.word	0x66666667

3003d708 <Granule_imdct>:

577, -607, -645, -694, -757, -841, -952, -1108, -1337, -1702, -2365, -3922, -11737
};

void Granule_imdct(struct Granule *gr, int ch, int XX[SBLIMIT][SSLIMIT])
{
3003d708:	e92d4030 	push	{r4, r5, lr}
3003d70c:	e24ddf4f 	sub	sp, sp, #316	; 0x13c
3003d710:	e58d000c 	str	r0, [sp, #12]
3003d714:	e58d1008 	str	r1, [sp, #8]
3003d718:	e58d2004 	str	r2, [sp, #4]
    int x[36], t[18];
    int  *prev, *z, *twid,*X;
    int odd_i, two_odd_i, four_odd_i, eight_odd_i;
	static int init=1;

	for(i=0; i<SBLIMIT; i++)
3003d71c:	e3a03000 	mov	r3, #0
3003d720:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003d724:	ea000023 	b	3003d7b8 <Granule_imdct+0xb0>
		for(j=0; j<SSLIMIT; j++)
3003d728:	e3a03000 	mov	r3, #0
3003d72c:	e58d30f4 	str	r3, [sp, #244]	; 0xf4
3003d730:	ea00001a 	b	3003d7a0 <Granule_imdct+0x98>
			XX[i][j] *= 10;
3003d734:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003d738:	e1a03002 	mov	r3, r2
3003d73c:	e1a03183 	lsl	r3, r3, #3
3003d740:	e0833002 	add	r3, r3, r2
3003d744:	e1a03183 	lsl	r3, r3, #3
3003d748:	e1a02003 	mov	r2, r3
3003d74c:	e59d3004 	ldr	r3, [sp, #4]
3003d750:	e0821003 	add	r1, r2, r3
3003d754:	e59d00f4 	ldr	r0, [sp, #244]	; 0xf4
3003d758:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003d75c:	e1a03002 	mov	r3, r2
3003d760:	e1a03183 	lsl	r3, r3, #3
3003d764:	e0833002 	add	r3, r3, r2
3003d768:	e1a03183 	lsl	r3, r3, #3
3003d76c:	e1a02003 	mov	r2, r3
3003d770:	e59d3004 	ldr	r3, [sp, #4]
3003d774:	e0823003 	add	r3, r2, r3
3003d778:	e59d20f4 	ldr	r2, [sp, #244]	; 0xf4
3003d77c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
3003d780:	e1a03002 	mov	r3, r2
3003d784:	e1a03103 	lsl	r3, r3, #2
3003d788:	e0833002 	add	r3, r3, r2
3003d78c:	e1a03083 	lsl	r3, r3, #1
3003d790:	e7813100 	str	r3, [r1, r0, lsl #2]
    int  *prev, *z, *twid,*X;
    int odd_i, two_odd_i, four_odd_i, eight_odd_i;
	static int init=1;

	for(i=0; i<SBLIMIT; i++)
		for(j=0; j<SSLIMIT; j++)
3003d794:	e59d30f4 	ldr	r3, [sp, #244]	; 0xf4
3003d798:	e2833001 	add	r3, r3, #1
3003d79c:	e58d30f4 	str	r3, [sp, #244]	; 0xf4
3003d7a0:	e59d30f4 	ldr	r3, [sp, #244]	; 0xf4
3003d7a4:	e3530011 	cmp	r3, #17
3003d7a8:	daffffe1 	ble	3003d734 <Granule_imdct+0x2c>
    int x[36], t[18];
    int  *prev, *z, *twid,*X;
    int odd_i, two_odd_i, four_odd_i, eight_odd_i;
	static int init=1;

	for(i=0; i<SBLIMIT; i++)
3003d7ac:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003d7b0:	e2833001 	add	r3, r3, #1
3003d7b4:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003d7b8:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003d7bc:	e353001f 	cmp	r3, #31
3003d7c0:	daffffd8 	ble	3003d728 <Granule_imdct+0x20>
		for(j=0; j<SSLIMIT; j++)
			XX[i][j] *= 10;

	X=&XX[0][0];
3003d7c4:	e59d3004 	ldr	r3, [sp, #4]
3003d7c8:	e58d3124 	str	r3, [sp, #292]	; 0x124
	if(mp3_fast_first == 1) {
3003d7cc:	e59f344c 	ldr	r3, [pc, #1100]	; 3003dc20 <Granule_imdct+0x518>
3003d7d0:	e5933000 	ldr	r3, [r3]
3003d7d4:	e3530001 	cmp	r3, #1
3003d7d8:	1a000005 	bne	3003d7f4 <Granule_imdct+0xec>
		mp3_fast_first = 0;
3003d7dc:	e59f343c 	ldr	r3, [pc, #1084]	; 3003dc20 <Granule_imdct+0x518>
3003d7e0:	e3a02000 	mov	r2, #0
3003d7e4:	e5832000 	str	r2, [r3]
		init = 1;
3003d7e8:	e59f3434 	ldr	r3, [pc, #1076]	; 3003dc24 <Granule_imdct+0x51c>
3003d7ec:	e3a02001 	mov	r2, #1
3003d7f0:	e5832000 	str	r2, [r3]
	}

    if(init)
3003d7f4:	e59f3428 	ldr	r3, [pc, #1064]	; 3003dc24 <Granule_imdct+0x51c>
3003d7f8:	e5933000 	ldr	r3, [r3]
3003d7fc:	e3530000 	cmp	r3, #0
3003d800:	0a0002d5 	beq	3003e35c <Granule_imdct+0xc54>
	{

	/* block_type 0 (normal window) */
      for(i = 0; i < 36; i++)
3003d804:	e3a03000 	mov	r3, #0
3003d808:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003d80c:	ea000029 	b	3003d8b8 <Granule_imdct+0x1b0>
	    Granule_imdct_win[0][i] = (int)(1024*sin(PI/36 * (i + 0.5)));
3003d810:	e59d50f0 	ldr	r5, [sp, #240]	; 0xf0
3003d814:	e59d00f0 	ldr	r0, [sp, #240]	; 0xf0
3003d818:	eb001a88 	bl	30044240 <__aeabi_i2d>
3003d81c:	e1a03000 	mov	r3, r0
3003d820:	e1a04001 	mov	r4, r1
3003d824:	e1a00003 	mov	r0, r3
3003d828:	e1a01004 	mov	r1, r4
3003d82c:	e3a02000 	mov	r2, #0
3003d830:	e3a035ff 	mov	r3, #1069547520	; 0x3fc00000
3003d834:	e2833602 	add	r3, r3, #2097152	; 0x200000
3003d838:	eb0019b3 	bl	30043f0c <__adddf3>
3003d83c:	e1a03000 	mov	r3, r0
3003d840:	e1a04001 	mov	r4, r1
3003d844:	e1a00003 	mov	r0, r3
3003d848:	e1a01004 	mov	r1, r4
3003d84c:	e28f3fef 	add	r3, pc, #956	; 0x3bc
3003d850:	e893000c 	ldm	r3, {r2, r3}
3003d854:	eb001ab0 	bl	3004431c <__aeabi_dmul>
3003d858:	e1a03000 	mov	r3, r0
3003d85c:	e1a04001 	mov	r4, r1
3003d860:	e1a00003 	mov	r0, r3
3003d864:	e1a01004 	mov	r1, r4
3003d868:	ebffde4d 	bl	300351a4 <sin>
3003d86c:	e1a03000 	mov	r3, r0
3003d870:	e1a04001 	mov	r4, r1
3003d874:	e1a00003 	mov	r0, r3
3003d878:	e1a01004 	mov	r1, r4
3003d87c:	e3a02000 	mov	r2, #0
3003d880:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003d884:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003d888:	eb001aa3 	bl	3004431c <__aeabi_dmul>
3003d88c:	e1a03000 	mov	r3, r0
3003d890:	e1a04001 	mov	r4, r1
3003d894:	e1a00003 	mov	r0, r3
3003d898:	e1a01004 	mov	r1, r4
3003d89c:	eb001c16 	bl	300448fc <__aeabi_d2iz>
3003d8a0:	e1a02000 	mov	r2, r0
3003d8a4:	e59f337c 	ldr	r3, [pc, #892]	; 3003dc28 <Granule_imdct+0x520>
3003d8a8:	e7832105 	str	r2, [r3, r5, lsl #2]

    if(init)
	{

	/* block_type 0 (normal window) */
      for(i = 0; i < 36; i++)
3003d8ac:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003d8b0:	e2833001 	add	r3, r3, #1
3003d8b4:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003d8b8:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003d8bc:	e3530023 	cmp	r3, #35	; 0x23
3003d8c0:	daffffd2 	ble	3003d810 <Granule_imdct+0x108>
	    Granule_imdct_win[0][i] = (int)(1024*sin(PI/36 * (i + 0.5)));
    
    /* block_type 1 (start block) */

      for(i = 0; i < 18; i++)
3003d8c4:	e3a03000 	mov	r3, #0
3003d8c8:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003d8cc:	ea00002a 	b	3003d97c <Granule_imdct+0x274>
	    Granule_imdct_win[1][i] = (int)(1024*sin(PI/36 * (i + 0.5)));
3003d8d0:	e59d50f0 	ldr	r5, [sp, #240]	; 0xf0
3003d8d4:	e59d00f0 	ldr	r0, [sp, #240]	; 0xf0
3003d8d8:	eb001a58 	bl	30044240 <__aeabi_i2d>
3003d8dc:	e1a03000 	mov	r3, r0
3003d8e0:	e1a04001 	mov	r4, r1
3003d8e4:	e1a00003 	mov	r0, r3
3003d8e8:	e1a01004 	mov	r1, r4
3003d8ec:	e3a02000 	mov	r2, #0
3003d8f0:	e3a035ff 	mov	r3, #1069547520	; 0x3fc00000
3003d8f4:	e2833602 	add	r3, r3, #2097152	; 0x200000
3003d8f8:	eb001983 	bl	30043f0c <__adddf3>
3003d8fc:	e1a03000 	mov	r3, r0
3003d900:	e1a04001 	mov	r4, r1
3003d904:	e1a00003 	mov	r0, r3
3003d908:	e1a01004 	mov	r1, r4
3003d90c:	e28f3fbf 	add	r3, pc, #764	; 0x2fc
3003d910:	e893000c 	ldm	r3, {r2, r3}
3003d914:	eb001a80 	bl	3004431c <__aeabi_dmul>
3003d918:	e1a03000 	mov	r3, r0
3003d91c:	e1a04001 	mov	r4, r1
3003d920:	e1a00003 	mov	r0, r3
3003d924:	e1a01004 	mov	r1, r4
3003d928:	ebffde1d 	bl	300351a4 <sin>
3003d92c:	e1a03000 	mov	r3, r0
3003d930:	e1a04001 	mov	r4, r1
3003d934:	e1a00003 	mov	r0, r3
3003d938:	e1a01004 	mov	r1, r4
3003d93c:	e3a02000 	mov	r2, #0
3003d940:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003d944:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003d948:	eb001a73 	bl	3004431c <__aeabi_dmul>
3003d94c:	e1a03000 	mov	r3, r0
3003d950:	e1a04001 	mov	r4, r1
3003d954:	e1a00003 	mov	r0, r3
3003d958:	e1a01004 	mov	r1, r4
3003d95c:	eb001be6 	bl	300448fc <__aeabi_d2iz>
3003d960:	e1a01000 	mov	r1, r0
3003d964:	e59f32bc 	ldr	r3, [pc, #700]	; 3003dc28 <Granule_imdct+0x520>
3003d968:	e2852024 	add	r2, r5, #36	; 0x24
3003d96c:	e7831102 	str	r1, [r3, r2, lsl #2]
      for(i = 0; i < 36; i++)
	    Granule_imdct_win[0][i] = (int)(1024*sin(PI/36 * (i + 0.5)));
    
    /* block_type 1 (start block) */

      for(i = 0; i < 18; i++)
3003d970:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003d974:	e2833001 	add	r3, r3, #1
3003d978:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003d97c:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003d980:	e3530011 	cmp	r3, #17
3003d984:	daffffd1 	ble	3003d8d0 <Granule_imdct+0x1c8>
	    Granule_imdct_win[1][i] = (int)(1024*sin(PI/36 * (i + 0.5)));

      for(i = 18; i < 24; i++)
3003d988:	e3a03012 	mov	r3, #18
3003d98c:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003d990:	ea000007 	b	3003d9b4 <Granule_imdct+0x2ac>
	    Granule_imdct_win[1][i] = 1;
3003d994:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003d998:	e59f3288 	ldr	r3, [pc, #648]	; 3003dc28 <Granule_imdct+0x520>
3003d99c:	e2822024 	add	r2, r2, #36	; 0x24
3003d9a0:	e3a01001 	mov	r1, #1
3003d9a4:	e7831102 	str	r1, [r3, r2, lsl #2]
    /* block_type 1 (start block) */

      for(i = 0; i < 18; i++)
	    Granule_imdct_win[1][i] = (int)(1024*sin(PI/36 * (i + 0.5)));

      for(i = 18; i < 24; i++)
3003d9a8:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003d9ac:	e2833001 	add	r3, r3, #1
3003d9b0:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003d9b4:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003d9b8:	e3530017 	cmp	r3, #23
3003d9bc:	dafffff4 	ble	3003d994 <Granule_imdct+0x28c>
	    Granule_imdct_win[1][i] = 1;

      for(i = 24; i < 30; i++)
3003d9c0:	e3a03018 	mov	r3, #24
3003d9c4:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003d9c8:	ea00002c 	b	3003da80 <Granule_imdct+0x378>
	    Granule_imdct_win[1][i] =  (int)(1024*sin(PI/12 * (i - 18 + 0.5)));
3003d9cc:	e59d50f0 	ldr	r5, [sp, #240]	; 0xf0
3003d9d0:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003d9d4:	e2433012 	sub	r3, r3, #18
3003d9d8:	e1a00003 	mov	r0, r3
3003d9dc:	eb001a17 	bl	30044240 <__aeabi_i2d>
3003d9e0:	e1a03000 	mov	r3, r0
3003d9e4:	e1a04001 	mov	r4, r1
3003d9e8:	e1a00003 	mov	r0, r3
3003d9ec:	e1a01004 	mov	r1, r4
3003d9f0:	e3a02000 	mov	r2, #0
3003d9f4:	e3a035ff 	mov	r3, #1069547520	; 0x3fc00000
3003d9f8:	e2833602 	add	r3, r3, #2097152	; 0x200000
3003d9fc:	eb001942 	bl	30043f0c <__adddf3>
3003da00:	e1a03000 	mov	r3, r0
3003da04:	e1a04001 	mov	r4, r1
3003da08:	e1a00003 	mov	r0, r3
3003da0c:	e1a01004 	mov	r1, r4
3003da10:	e28f3c02 	add	r3, pc, #512	; 0x200
3003da14:	e893000c 	ldm	r3, {r2, r3}
3003da18:	eb001a3f 	bl	3004431c <__aeabi_dmul>
3003da1c:	e1a03000 	mov	r3, r0
3003da20:	e1a04001 	mov	r4, r1
3003da24:	e1a00003 	mov	r0, r3
3003da28:	e1a01004 	mov	r1, r4
3003da2c:	ebffdddc 	bl	300351a4 <sin>
3003da30:	e1a03000 	mov	r3, r0
3003da34:	e1a04001 	mov	r4, r1
3003da38:	e1a00003 	mov	r0, r3
3003da3c:	e1a01004 	mov	r1, r4
3003da40:	e3a02000 	mov	r2, #0
3003da44:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003da48:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003da4c:	eb001a32 	bl	3004431c <__aeabi_dmul>
3003da50:	e1a03000 	mov	r3, r0
3003da54:	e1a04001 	mov	r4, r1
3003da58:	e1a00003 	mov	r0, r3
3003da5c:	e1a01004 	mov	r1, r4
3003da60:	eb001ba5 	bl	300448fc <__aeabi_d2iz>
3003da64:	e1a01000 	mov	r1, r0
3003da68:	e59f31b8 	ldr	r3, [pc, #440]	; 3003dc28 <Granule_imdct+0x520>
3003da6c:	e2852024 	add	r2, r5, #36	; 0x24
3003da70:	e7831102 	str	r1, [r3, r2, lsl #2]
	    Granule_imdct_win[1][i] = (int)(1024*sin(PI/36 * (i + 0.5)));

      for(i = 18; i < 24; i++)
	    Granule_imdct_win[1][i] = 1;

      for(i = 24; i < 30; i++)
3003da74:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003da78:	e2833001 	add	r3, r3, #1
3003da7c:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003da80:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003da84:	e353001d 	cmp	r3, #29
3003da88:	daffffcf 	ble	3003d9cc <Granule_imdct+0x2c4>
	    Granule_imdct_win[1][i] =  (int)(1024*sin(PI/12 * (i - 18 + 0.5)));

      for(i = 30; i < 36; i++)
3003da8c:	e3a0301e 	mov	r3, #30
3003da90:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003da94:	ea000007 	b	3003dab8 <Granule_imdct+0x3b0>
	    Granule_imdct_win[1][i] =  0;
3003da98:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003da9c:	e59f3184 	ldr	r3, [pc, #388]	; 3003dc28 <Granule_imdct+0x520>
3003daa0:	e2822024 	add	r2, r2, #36	; 0x24
3003daa4:	e3a01000 	mov	r1, #0
3003daa8:	e7831102 	str	r1, [r3, r2, lsl #2]
	    Granule_imdct_win[1][i] = 1;

      for(i = 24; i < 30; i++)
	    Granule_imdct_win[1][i] =  (int)(1024*sin(PI/12 * (i - 18 + 0.5)));

      for(i = 30; i < 36; i++)
3003daac:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003dab0:	e2833001 	add	r3, r3, #1
3003dab4:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003dab8:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003dabc:	e3530023 	cmp	r3, #35	; 0x23
3003dac0:	dafffff4 	ble	3003da98 <Granule_imdct+0x390>
	    Granule_imdct_win[1][i] =  0;
    
    /* block_type 3 (stop block) */

      for(i = 0; i < 6; i++)
3003dac4:	e3a03000 	mov	r3, #0
3003dac8:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003dacc:	ea000007 	b	3003daf0 <Granule_imdct+0x3e8>
	    Granule_imdct_win[3][i] =  0;
3003dad0:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003dad4:	e59f314c 	ldr	r3, [pc, #332]	; 3003dc28 <Granule_imdct+0x520>
3003dad8:	e282206c 	add	r2, r2, #108	; 0x6c
3003dadc:	e3a01000 	mov	r1, #0
3003dae0:	e7831102 	str	r1, [r3, r2, lsl #2]
      for(i = 30; i < 36; i++)
	    Granule_imdct_win[1][i] =  0;
    
    /* block_type 3 (stop block) */

      for(i = 0; i < 6; i++)
3003dae4:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003dae8:	e2833001 	add	r3, r3, #1
3003daec:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003daf0:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003daf4:	e3530005 	cmp	r3, #5
3003daf8:	dafffff4 	ble	3003dad0 <Granule_imdct+0x3c8>
	    Granule_imdct_win[3][i] =  0;

      for(i = 6; i < 12; i++)
3003dafc:	e3a03006 	mov	r3, #6
3003db00:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003db04:	ea00002c 	b	3003dbbc <Granule_imdct+0x4b4>
	    Granule_imdct_win[3][i] =  (int)(1024*sin(PI/12 * (i - 6 + 0.5)));
3003db08:	e59d50f0 	ldr	r5, [sp, #240]	; 0xf0
3003db0c:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003db10:	e2433006 	sub	r3, r3, #6
3003db14:	e1a00003 	mov	r0, r3
3003db18:	eb0019c8 	bl	30044240 <__aeabi_i2d>
3003db1c:	e1a03000 	mov	r3, r0
3003db20:	e1a04001 	mov	r4, r1
3003db24:	e1a00003 	mov	r0, r3
3003db28:	e1a01004 	mov	r1, r4
3003db2c:	e3a02000 	mov	r2, #0
3003db30:	e3a035ff 	mov	r3, #1069547520	; 0x3fc00000
3003db34:	e2833602 	add	r3, r3, #2097152	; 0x200000
3003db38:	eb0018f3 	bl	30043f0c <__adddf3>
3003db3c:	e1a03000 	mov	r3, r0
3003db40:	e1a04001 	mov	r4, r1
3003db44:	e1a00003 	mov	r0, r3
3003db48:	e1a01004 	mov	r1, r4
3003db4c:	e28f30c4 	add	r3, pc, #196	; 0xc4
3003db50:	e893000c 	ldm	r3, {r2, r3}
3003db54:	eb0019f0 	bl	3004431c <__aeabi_dmul>
3003db58:	e1a03000 	mov	r3, r0
3003db5c:	e1a04001 	mov	r4, r1
3003db60:	e1a00003 	mov	r0, r3
3003db64:	e1a01004 	mov	r1, r4
3003db68:	ebffdd8d 	bl	300351a4 <sin>
3003db6c:	e1a03000 	mov	r3, r0
3003db70:	e1a04001 	mov	r4, r1
3003db74:	e1a00003 	mov	r0, r3
3003db78:	e1a01004 	mov	r1, r4
3003db7c:	e3a02000 	mov	r2, #0
3003db80:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003db84:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003db88:	eb0019e3 	bl	3004431c <__aeabi_dmul>
3003db8c:	e1a03000 	mov	r3, r0
3003db90:	e1a04001 	mov	r4, r1
3003db94:	e1a00003 	mov	r0, r3
3003db98:	e1a01004 	mov	r1, r4
3003db9c:	eb001b56 	bl	300448fc <__aeabi_d2iz>
3003dba0:	e1a01000 	mov	r1, r0
3003dba4:	e59f307c 	ldr	r3, [pc, #124]	; 3003dc28 <Granule_imdct+0x520>
3003dba8:	e285206c 	add	r2, r5, #108	; 0x6c
3003dbac:	e7831102 	str	r1, [r3, r2, lsl #2]
    /* block_type 3 (stop block) */

      for(i = 0; i < 6; i++)
	    Granule_imdct_win[3][i] =  0;

      for(i = 6; i < 12; i++)
3003dbb0:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003dbb4:	e2833001 	add	r3, r3, #1
3003dbb8:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003dbbc:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003dbc0:	e353000b 	cmp	r3, #11
3003dbc4:	daffffcf 	ble	3003db08 <Granule_imdct+0x400>
	    Granule_imdct_win[3][i] =  (int)(1024*sin(PI/12 * (i - 6 + 0.5)));

      for(i = 12; i < 18; i++)
3003dbc8:	e3a0300c 	mov	r3, #12
3003dbcc:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003dbd0:	ea000007 	b	3003dbf4 <Granule_imdct+0x4ec>
	    Granule_imdct_win[3][i] =  1;
3003dbd4:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003dbd8:	e59f3048 	ldr	r3, [pc, #72]	; 3003dc28 <Granule_imdct+0x520>
3003dbdc:	e282206c 	add	r2, r2, #108	; 0x6c
3003dbe0:	e3a01001 	mov	r1, #1
3003dbe4:	e7831102 	str	r1, [r3, r2, lsl #2]
	    Granule_imdct_win[3][i] =  0;

      for(i = 6; i < 12; i++)
	    Granule_imdct_win[3][i] =  (int)(1024*sin(PI/12 * (i - 6 + 0.5)));

      for(i = 12; i < 18; i++)
3003dbe8:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003dbec:	e2833001 	add	r3, r3, #1
3003dbf0:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003dbf4:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003dbf8:	e3530011 	cmp	r3, #17
3003dbfc:	dafffff4 	ble	3003dbd4 <Granule_imdct+0x4cc>
	    Granule_imdct_win[3][i] =  1;

      for(i = 18; i < 36; i++)
3003dc00:	e3a03012 	mov	r3, #18
3003dc04:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003dc08:	ea000032 	b	3003dcd8 <Granule_imdct+0x5d0>
3003dc0c:	e1a00000 	nop			; (mov r0, r0)
3003dc10:	4ae74481 	.word	0x4ae74481
3003dc14:	3fb65718 	.word	0x3fb65718
3003dc18:	382d7361 	.word	0x382d7361
3003dc1c:	3fd0c152 	.word	0x3fd0c152
3003dc20:	300c9a8c 	.word	0x300c9a8c
3003dc24:	300c9a84 	.word	0x300c9a84
3003dc28:	300e8d80 	.word	0x300e8d80
	    Granule_imdct_win[3][i] =  (int)(1024*sin(PI/36 * (i + 0.5)));
3003dc2c:	e59d50f0 	ldr	r5, [sp, #240]	; 0xf0
3003dc30:	e59d00f0 	ldr	r0, [sp, #240]	; 0xf0
3003dc34:	eb001981 	bl	30044240 <__aeabi_i2d>
3003dc38:	e1a03000 	mov	r3, r0
3003dc3c:	e1a04001 	mov	r4, r1
3003dc40:	e1a00003 	mov	r0, r3
3003dc44:	e1a01004 	mov	r1, r4
3003dc48:	e3a02000 	mov	r2, #0
3003dc4c:	e3a035ff 	mov	r3, #1069547520	; 0x3fc00000
3003dc50:	e2833602 	add	r3, r3, #2097152	; 0x200000
3003dc54:	eb0018ac 	bl	30043f0c <__adddf3>
3003dc58:	e1a03000 	mov	r3, r0
3003dc5c:	e1a04001 	mov	r4, r1
3003dc60:	e1a00003 	mov	r0, r3
3003dc64:	e1a01004 	mov	r1, r4
3003dc68:	e28f3f62 	add	r3, pc, #392	; 0x188
3003dc6c:	e893000c 	ldm	r3, {r2, r3}
3003dc70:	eb0019a9 	bl	3004431c <__aeabi_dmul>
3003dc74:	e1a03000 	mov	r3, r0
3003dc78:	e1a04001 	mov	r4, r1
3003dc7c:	e1a00003 	mov	r0, r3
3003dc80:	e1a01004 	mov	r1, r4
3003dc84:	ebffdd46 	bl	300351a4 <sin>
3003dc88:	e1a03000 	mov	r3, r0
3003dc8c:	e1a04001 	mov	r4, r1
3003dc90:	e1a00003 	mov	r0, r3
3003dc94:	e1a01004 	mov	r1, r4
3003dc98:	e3a02000 	mov	r2, #0
3003dc9c:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003dca0:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003dca4:	eb00199c 	bl	3004431c <__aeabi_dmul>
3003dca8:	e1a03000 	mov	r3, r0
3003dcac:	e1a04001 	mov	r4, r1
3003dcb0:	e1a00003 	mov	r0, r3
3003dcb4:	e1a01004 	mov	r1, r4
3003dcb8:	eb001b0f 	bl	300448fc <__aeabi_d2iz>
3003dcbc:	e1a01000 	mov	r1, r0
3003dcc0:	e59f3140 	ldr	r3, [pc, #320]	; 3003de08 <Granule_imdct+0x700>
3003dcc4:	e285206c 	add	r2, r5, #108	; 0x6c
3003dcc8:	e7831102 	str	r1, [r3, r2, lsl #2]
	    Granule_imdct_win[3][i] =  (int)(1024*sin(PI/12 * (i - 6 + 0.5)));

      for(i = 12; i < 18; i++)
	    Granule_imdct_win[3][i] =  1;

      for(i = 18; i < 36; i++)
3003dccc:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003dcd0:	e2833001 	add	r3, r3, #1
3003dcd4:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003dcd8:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003dcdc:	e3530023 	cmp	r3, #35	; 0x23
3003dce0:	daffffd1 	ble	3003dc2c <Granule_imdct+0x524>
	    Granule_imdct_win[3][i] =  (int)(1024*sin(PI/36 * (i + 0.5)));
    
    /* block_type 2 (short block) */

      for(i = 0; i < 12; i++)
3003dce4:	e3a03000 	mov	r3, #0
3003dce8:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003dcec:	ea00002a 	b	3003dd9c <Granule_imdct+0x694>
	    Granule_imdct_win[2][i] =  (int)(1024*sin(PI/12 * (i + 0.5)));
3003dcf0:	e59d50f0 	ldr	r5, [sp, #240]	; 0xf0
3003dcf4:	e59d00f0 	ldr	r0, [sp, #240]	; 0xf0
3003dcf8:	eb001950 	bl	30044240 <__aeabi_i2d>
3003dcfc:	e1a03000 	mov	r3, r0
3003dd00:	e1a04001 	mov	r4, r1
3003dd04:	e1a00003 	mov	r0, r3
3003dd08:	e1a01004 	mov	r1, r4
3003dd0c:	e3a02000 	mov	r2, #0
3003dd10:	e3a035ff 	mov	r3, #1069547520	; 0x3fc00000
3003dd14:	e2833602 	add	r3, r3, #2097152	; 0x200000
3003dd18:	eb00187b 	bl	30043f0c <__adddf3>
3003dd1c:	e1a03000 	mov	r3, r0
3003dd20:	e1a04001 	mov	r4, r1
3003dd24:	e1a00003 	mov	r0, r3
3003dd28:	e1a01004 	mov	r1, r4
3003dd2c:	e28f30cc 	add	r3, pc, #204	; 0xcc
3003dd30:	e893000c 	ldm	r3, {r2, r3}
3003dd34:	eb001978 	bl	3004431c <__aeabi_dmul>
3003dd38:	e1a03000 	mov	r3, r0
3003dd3c:	e1a04001 	mov	r4, r1
3003dd40:	e1a00003 	mov	r0, r3
3003dd44:	e1a01004 	mov	r1, r4
3003dd48:	ebffdd15 	bl	300351a4 <sin>
3003dd4c:	e1a03000 	mov	r3, r0
3003dd50:	e1a04001 	mov	r4, r1
3003dd54:	e1a00003 	mov	r0, r3
3003dd58:	e1a01004 	mov	r1, r4
3003dd5c:	e3a02000 	mov	r2, #0
3003dd60:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003dd64:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003dd68:	eb00196b 	bl	3004431c <__aeabi_dmul>
3003dd6c:	e1a03000 	mov	r3, r0
3003dd70:	e1a04001 	mov	r4, r1
3003dd74:	e1a00003 	mov	r0, r3
3003dd78:	e1a01004 	mov	r1, r4
3003dd7c:	eb001ade 	bl	300448fc <__aeabi_d2iz>
3003dd80:	e1a01000 	mov	r1, r0
3003dd84:	e59f307c 	ldr	r3, [pc, #124]	; 3003de08 <Granule_imdct+0x700>
3003dd88:	e2852048 	add	r2, r5, #72	; 0x48
3003dd8c:	e7831102 	str	r1, [r3, r2, lsl #2]
      for(i = 18; i < 36; i++)
	    Granule_imdct_win[3][i] =  (int)(1024*sin(PI/36 * (i + 0.5)));
    
    /* block_type 2 (short block) */

      for(i = 0; i < 12; i++)
3003dd90:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003dd94:	e2833001 	add	r3, r3, #1
3003dd98:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003dd9c:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003dda0:	e353000b 	cmp	r3, #11
3003dda4:	daffffd1 	ble	3003dcf0 <Granule_imdct+0x5e8>
	    Granule_imdct_win[2][i] =  (int)(1024*sin(PI/12 * (i + 0.5)));

      for(i = 12; i < 36; i++)
3003dda8:	e3a0300c 	mov	r3, #12
3003ddac:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003ddb0:	ea000007 	b	3003ddd4 <Granule_imdct+0x6cc>
	    Granule_imdct_win[2][i] =  0 ;
3003ddb4:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003ddb8:	e59f3048 	ldr	r3, [pc, #72]	; 3003de08 <Granule_imdct+0x700>
3003ddbc:	e2822048 	add	r2, r2, #72	; 0x48
3003ddc0:	e3a01000 	mov	r1, #0
3003ddc4:	e7831102 	str	r1, [r3, r2, lsl #2]
    /* block_type 2 (short block) */

      for(i = 0; i < 12; i++)
	    Granule_imdct_win[2][i] =  (int)(1024*sin(PI/12 * (i + 0.5)));

      for(i = 12; i < 36; i++)
3003ddc8:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003ddcc:	e2833001 	add	r3, r3, #1
3003ddd0:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003ddd4:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003ddd8:	e3530023 	cmp	r3, #35	; 0x23
3003dddc:	dafffff4 	ble	3003ddb4 <Granule_imdct+0x6ac>
	    Granule_imdct_win[2][i] =  0 ;
      
      j = 0;
3003dde0:	e3a03000 	mov	r3, #0
3003dde4:	e58d30f4 	str	r3, [sp, #244]	; 0xf4
      for(i = 0; i < 9; i++) 
3003dde8:	e3a03000 	mov	r3, #0
3003ddec:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003ddf0:	ea000135 	b	3003e2cc <Granule_imdct+0xbc4>
3003ddf4:	e1a00000 	nop			; (mov r0, r0)
3003ddf8:	4ae74481 	.word	0x4ae74481
3003ddfc:	3fb65718 	.word	0x3fb65718
3003de00:	382d7361 	.word	0x382d7361
3003de04:	3fd0c152 	.word	0x3fd0c152
3003de08:	300e8d80 	.word	0x300e8d80
	  {
  	    odd_i = (i << 1) + 1;
3003de0c:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003de10:	e1a03083 	lsl	r3, r3, #1
3003de14:	e2833001 	add	r3, r3, #1
3003de18:	e58d3128 	str	r3, [sp, #296]	; 0x128
	    two_odd_i = odd_i << 1;
3003de1c:	e59d3128 	ldr	r3, [sp, #296]	; 0x128
3003de20:	e1a03083 	lsl	r3, r3, #1
3003de24:	e58d312c 	str	r3, [sp, #300]	; 0x12c
	    four_odd_i = odd_i << 2;
3003de28:	e59d3128 	ldr	r3, [sp, #296]	; 0x128
3003de2c:	e1a03103 	lsl	r3, r3, #2
3003de30:	e58d3130 	str	r3, [sp, #304]	; 0x130
	    Granule_9x9_idct[j++] =  (int)(1024*cos(PI/18 * odd_i));
3003de34:	e59d50f4 	ldr	r5, [sp, #244]	; 0xf4
3003de38:	e59d0128 	ldr	r0, [sp, #296]	; 0x128
3003de3c:	eb0018ff 	bl	30044240 <__aeabi_i2d>
3003de40:	e1a03000 	mov	r3, r0
3003de44:	e1a04001 	mov	r4, r1
3003de48:	e1a00003 	mov	r0, r3
3003de4c:	e1a01004 	mov	r1, r4
3003de50:	e28f3e3f 	add	r3, pc, #1008	; 0x3f0
3003de54:	e893000c 	ldm	r3, {r2, r3}
3003de58:	eb00192f 	bl	3004431c <__aeabi_dmul>
3003de5c:	e1a03000 	mov	r3, r0
3003de60:	e1a04001 	mov	r4, r1
3003de64:	e1a00003 	mov	r0, r3
3003de68:	e1a01004 	mov	r1, r4
3003de6c:	ebffdd3b 	bl	30035360 <cos>
3003de70:	e1a03000 	mov	r3, r0
3003de74:	e1a04001 	mov	r4, r1
3003de78:	e1a00003 	mov	r0, r3
3003de7c:	e1a01004 	mov	r1, r4
3003de80:	e3a02000 	mov	r2, #0
3003de84:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003de88:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003de8c:	eb001922 	bl	3004431c <__aeabi_dmul>
3003de90:	e1a03000 	mov	r3, r0
3003de94:	e1a04001 	mov	r4, r1
3003de98:	e1a00003 	mov	r0, r3
3003de9c:	e1a01004 	mov	r1, r4
3003dea0:	eb001a95 	bl	300448fc <__aeabi_d2iz>
3003dea4:	e1a02000 	mov	r2, r0
3003dea8:	e59f33a0 	ldr	r3, [pc, #928]	; 3003e250 <Granule_imdct+0xb48>
3003deac:	e7832105 	str	r2, [r3, r5, lsl #2]
3003deb0:	e59d30f4 	ldr	r3, [sp, #244]	; 0xf4
3003deb4:	e2833001 	add	r3, r3, #1
3003deb8:	e58d30f4 	str	r3, [sp, #244]	; 0xf4
	    Granule_9x9_idct[j++] =  (int)(1024*cos(PI/18 * two_odd_i));
3003debc:	e59d50f4 	ldr	r5, [sp, #244]	; 0xf4
3003dec0:	e59d012c 	ldr	r0, [sp, #300]	; 0x12c
3003dec4:	eb0018dd 	bl	30044240 <__aeabi_i2d>
3003dec8:	e1a03000 	mov	r3, r0
3003decc:	e1a04001 	mov	r4, r1
3003ded0:	e1a00003 	mov	r0, r3
3003ded4:	e1a01004 	mov	r1, r4
3003ded8:	e28f3fda 	add	r3, pc, #872	; 0x368
3003dedc:	e893000c 	ldm	r3, {r2, r3}
3003dee0:	eb00190d 	bl	3004431c <__aeabi_dmul>
3003dee4:	e1a03000 	mov	r3, r0
3003dee8:	e1a04001 	mov	r4, r1
3003deec:	e1a00003 	mov	r0, r3
3003def0:	e1a01004 	mov	r1, r4
3003def4:	ebffdd19 	bl	30035360 <cos>
3003def8:	e1a03000 	mov	r3, r0
3003defc:	e1a04001 	mov	r4, r1
3003df00:	e1a00003 	mov	r0, r3
3003df04:	e1a01004 	mov	r1, r4
3003df08:	e3a02000 	mov	r2, #0
3003df0c:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003df10:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003df14:	eb001900 	bl	3004431c <__aeabi_dmul>
3003df18:	e1a03000 	mov	r3, r0
3003df1c:	e1a04001 	mov	r4, r1
3003df20:	e1a00003 	mov	r0, r3
3003df24:	e1a01004 	mov	r1, r4
3003df28:	eb001a73 	bl	300448fc <__aeabi_d2iz>
3003df2c:	e1a02000 	mov	r2, r0
3003df30:	e59f3318 	ldr	r3, [pc, #792]	; 3003e250 <Granule_imdct+0xb48>
3003df34:	e7832105 	str	r2, [r3, r5, lsl #2]
3003df38:	e59d30f4 	ldr	r3, [sp, #244]	; 0xf4
3003df3c:	e2833001 	add	r3, r3, #1
3003df40:	e58d30f4 	str	r3, [sp, #244]	; 0xf4
	    eight_odd_i = two_odd_i << 2;
3003df44:	e59d312c 	ldr	r3, [sp, #300]	; 0x12c
3003df48:	e1a03103 	lsl	r3, r3, #2
3003df4c:	e58d3134 	str	r3, [sp, #308]	; 0x134
	    Granule_9x9_idct[j++] =  (int)(1024*cos(PI/18 * (four_odd_i - odd_i)));
3003df50:	e59d50f4 	ldr	r5, [sp, #244]	; 0xf4
3003df54:	e59d2130 	ldr	r2, [sp, #304]	; 0x130
3003df58:	e59d3128 	ldr	r3, [sp, #296]	; 0x128
3003df5c:	e0633002 	rsb	r3, r3, r2
3003df60:	e1a00003 	mov	r0, r3
3003df64:	eb0018b5 	bl	30044240 <__aeabi_i2d>
3003df68:	e1a03000 	mov	r3, r0
3003df6c:	e1a04001 	mov	r4, r1
3003df70:	e1a00003 	mov	r0, r3
3003df74:	e1a01004 	mov	r1, r4
3003df78:	e28f3fb2 	add	r3, pc, #712	; 0x2c8
3003df7c:	e893000c 	ldm	r3, {r2, r3}
3003df80:	eb0018e5 	bl	3004431c <__aeabi_dmul>
3003df84:	e1a03000 	mov	r3, r0
3003df88:	e1a04001 	mov	r4, r1
3003df8c:	e1a00003 	mov	r0, r3
3003df90:	e1a01004 	mov	r1, r4
3003df94:	ebffdcf1 	bl	30035360 <cos>
3003df98:	e1a03000 	mov	r3, r0
3003df9c:	e1a04001 	mov	r4, r1
3003dfa0:	e1a00003 	mov	r0, r3
3003dfa4:	e1a01004 	mov	r1, r4
3003dfa8:	e3a02000 	mov	r2, #0
3003dfac:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003dfb0:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003dfb4:	eb0018d8 	bl	3004431c <__aeabi_dmul>
3003dfb8:	e1a03000 	mov	r3, r0
3003dfbc:	e1a04001 	mov	r4, r1
3003dfc0:	e1a00003 	mov	r0, r3
3003dfc4:	e1a01004 	mov	r1, r4
3003dfc8:	eb001a4b 	bl	300448fc <__aeabi_d2iz>
3003dfcc:	e1a02000 	mov	r2, r0
3003dfd0:	e59f3278 	ldr	r3, [pc, #632]	; 3003e250 <Granule_imdct+0xb48>
3003dfd4:	e7832105 	str	r2, [r3, r5, lsl #2]
3003dfd8:	e59d30f4 	ldr	r3, [sp, #244]	; 0xf4
3003dfdc:	e2833001 	add	r3, r3, #1
3003dfe0:	e58d30f4 	str	r3, [sp, #244]	; 0xf4
	    Granule_9x9_idct[j++] =  (int)(1024*cos(PI/18 * four_odd_i));
3003dfe4:	e59d50f4 	ldr	r5, [sp, #244]	; 0xf4
3003dfe8:	e59d0130 	ldr	r0, [sp, #304]	; 0x130
3003dfec:	eb001893 	bl	30044240 <__aeabi_i2d>
3003dff0:	e1a03000 	mov	r3, r0
3003dff4:	e1a04001 	mov	r4, r1
3003dff8:	e1a00003 	mov	r0, r3
3003dffc:	e1a01004 	mov	r1, r4
3003e000:	e28f3d09 	add	r3, pc, #576	; 0x240
3003e004:	e893000c 	ldm	r3, {r2, r3}
3003e008:	eb0018c3 	bl	3004431c <__aeabi_dmul>
3003e00c:	e1a03000 	mov	r3, r0
3003e010:	e1a04001 	mov	r4, r1
3003e014:	e1a00003 	mov	r0, r3
3003e018:	e1a01004 	mov	r1, r4
3003e01c:	ebffdccf 	bl	30035360 <cos>
3003e020:	e1a03000 	mov	r3, r0
3003e024:	e1a04001 	mov	r4, r1
3003e028:	e1a00003 	mov	r0, r3
3003e02c:	e1a01004 	mov	r1, r4
3003e030:	e3a02000 	mov	r2, #0
3003e034:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003e038:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003e03c:	eb0018b6 	bl	3004431c <__aeabi_dmul>
3003e040:	e1a03000 	mov	r3, r0
3003e044:	e1a04001 	mov	r4, r1
3003e048:	e1a00003 	mov	r0, r3
3003e04c:	e1a01004 	mov	r1, r4
3003e050:	eb001a29 	bl	300448fc <__aeabi_d2iz>
3003e054:	e1a02000 	mov	r2, r0
3003e058:	e59f31f0 	ldr	r3, [pc, #496]	; 3003e250 <Granule_imdct+0xb48>
3003e05c:	e7832105 	str	r2, [r3, r5, lsl #2]
3003e060:	e59d30f4 	ldr	r3, [sp, #244]	; 0xf4
3003e064:	e2833001 	add	r3, r3, #1
3003e068:	e58d30f4 	str	r3, [sp, #244]	; 0xf4
	    Granule_9x9_idct[j++] =  (int)(1024*cos(PI/18 * (four_odd_i + odd_i)));
3003e06c:	e59d50f4 	ldr	r5, [sp, #244]	; 0xf4
3003e070:	e59d2130 	ldr	r2, [sp, #304]	; 0x130
3003e074:	e59d3128 	ldr	r3, [sp, #296]	; 0x128
3003e078:	e0823003 	add	r3, r2, r3
3003e07c:	e1a00003 	mov	r0, r3
3003e080:	eb00186e 	bl	30044240 <__aeabi_i2d>
3003e084:	e1a03000 	mov	r3, r0
3003e088:	e1a04001 	mov	r4, r1
3003e08c:	e1a00003 	mov	r0, r3
3003e090:	e1a01004 	mov	r1, r4
3003e094:	e28f3f6b 	add	r3, pc, #428	; 0x1ac
3003e098:	e893000c 	ldm	r3, {r2, r3}
3003e09c:	eb00189e 	bl	3004431c <__aeabi_dmul>
3003e0a0:	e1a03000 	mov	r3, r0
3003e0a4:	e1a04001 	mov	r4, r1
3003e0a8:	e1a00003 	mov	r0, r3
3003e0ac:	e1a01004 	mov	r1, r4
3003e0b0:	ebffdcaa 	bl	30035360 <cos>
3003e0b4:	e1a03000 	mov	r3, r0
3003e0b8:	e1a04001 	mov	r4, r1
3003e0bc:	e1a00003 	mov	r0, r3
3003e0c0:	e1a01004 	mov	r1, r4
3003e0c4:	e3a02000 	mov	r2, #0
3003e0c8:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003e0cc:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003e0d0:	eb001891 	bl	3004431c <__aeabi_dmul>
3003e0d4:	e1a03000 	mov	r3, r0
3003e0d8:	e1a04001 	mov	r4, r1
3003e0dc:	e1a00003 	mov	r0, r3
3003e0e0:	e1a01004 	mov	r1, r4
3003e0e4:	eb001a04 	bl	300448fc <__aeabi_d2iz>
3003e0e8:	e1a02000 	mov	r2, r0
3003e0ec:	e59f315c 	ldr	r3, [pc, #348]	; 3003e250 <Granule_imdct+0xb48>
3003e0f0:	e7832105 	str	r2, [r3, r5, lsl #2]
3003e0f4:	e59d30f4 	ldr	r3, [sp, #244]	; 0xf4
3003e0f8:	e2833001 	add	r3, r3, #1
3003e0fc:	e58d30f4 	str	r3, [sp, #244]	; 0xf4
	    Granule_9x9_idct[j++] =  (int)(1024*cos(PI/18 * (four_odd_i + two_odd_i)));
3003e100:	e59d50f4 	ldr	r5, [sp, #244]	; 0xf4
3003e104:	e59d2130 	ldr	r2, [sp, #304]	; 0x130
3003e108:	e59d312c 	ldr	r3, [sp, #300]	; 0x12c
3003e10c:	e0823003 	add	r3, r2, r3
3003e110:	e1a00003 	mov	r0, r3
3003e114:	eb001849 	bl	30044240 <__aeabi_i2d>
3003e118:	e1a03000 	mov	r3, r0
3003e11c:	e1a04001 	mov	r4, r1
3003e120:	e1a00003 	mov	r0, r3
3003e124:	e1a01004 	mov	r1, r4
3003e128:	e28f3f46 	add	r3, pc, #280	; 0x118
3003e12c:	e893000c 	ldm	r3, {r2, r3}
3003e130:	eb001879 	bl	3004431c <__aeabi_dmul>
3003e134:	e1a03000 	mov	r3, r0
3003e138:	e1a04001 	mov	r4, r1
3003e13c:	e1a00003 	mov	r0, r3
3003e140:	e1a01004 	mov	r1, r4
3003e144:	ebffdc85 	bl	30035360 <cos>
3003e148:	e1a03000 	mov	r3, r0
3003e14c:	e1a04001 	mov	r4, r1
3003e150:	e1a00003 	mov	r0, r3
3003e154:	e1a01004 	mov	r1, r4
3003e158:	e3a02000 	mov	r2, #0
3003e15c:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003e160:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003e164:	eb00186c 	bl	3004431c <__aeabi_dmul>
3003e168:	e1a03000 	mov	r3, r0
3003e16c:	e1a04001 	mov	r4, r1
3003e170:	e1a00003 	mov	r0, r3
3003e174:	e1a01004 	mov	r1, r4
3003e178:	eb0019df 	bl	300448fc <__aeabi_d2iz>
3003e17c:	e1a02000 	mov	r2, r0
3003e180:	e59f30c8 	ldr	r3, [pc, #200]	; 3003e250 <Granule_imdct+0xb48>
3003e184:	e7832105 	str	r2, [r3, r5, lsl #2]
3003e188:	e59d30f4 	ldr	r3, [sp, #244]	; 0xf4
3003e18c:	e2833001 	add	r3, r3, #1
3003e190:	e58d30f4 	str	r3, [sp, #244]	; 0xf4
	    Granule_9x9_idct[j++] =  (int)(1024*cos(PI/18 * (eight_odd_i - odd_i)));
3003e194:	e59d50f4 	ldr	r5, [sp, #244]	; 0xf4
3003e198:	e59d2134 	ldr	r2, [sp, #308]	; 0x134
3003e19c:	e59d3128 	ldr	r3, [sp, #296]	; 0x128
3003e1a0:	e0633002 	rsb	r3, r3, r2
3003e1a4:	e1a00003 	mov	r0, r3
3003e1a8:	eb001824 	bl	30044240 <__aeabi_i2d>
3003e1ac:	e1a03000 	mov	r3, r0
3003e1b0:	e1a04001 	mov	r4, r1
3003e1b4:	e1a00003 	mov	r0, r3
3003e1b8:	e1a01004 	mov	r1, r4
3003e1bc:	e28f3084 	add	r3, pc, #132	; 0x84
3003e1c0:	e893000c 	ldm	r3, {r2, r3}
3003e1c4:	eb001854 	bl	3004431c <__aeabi_dmul>
3003e1c8:	e1a03000 	mov	r3, r0
3003e1cc:	e1a04001 	mov	r4, r1
3003e1d0:	e1a00003 	mov	r0, r3
3003e1d4:	e1a01004 	mov	r1, r4
3003e1d8:	ebffdc60 	bl	30035360 <cos>
3003e1dc:	e1a03000 	mov	r3, r0
3003e1e0:	e1a04001 	mov	r4, r1
3003e1e4:	e1a00003 	mov	r0, r3
3003e1e8:	e1a01004 	mov	r1, r4
3003e1ec:	e3a02000 	mov	r2, #0
3003e1f0:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003e1f4:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003e1f8:	eb001847 	bl	3004431c <__aeabi_dmul>
3003e1fc:	e1a03000 	mov	r3, r0
3003e200:	e1a04001 	mov	r4, r1
3003e204:	e1a00003 	mov	r0, r3
3003e208:	e1a01004 	mov	r1, r4
3003e20c:	eb0019ba 	bl	300448fc <__aeabi_d2iz>
3003e210:	e1a02000 	mov	r2, r0
3003e214:	e59f3034 	ldr	r3, [pc, #52]	; 3003e250 <Granule_imdct+0xb48>
3003e218:	e7832105 	str	r2, [r3, r5, lsl #2]
3003e21c:	e59d30f4 	ldr	r3, [sp, #244]	; 0xf4
3003e220:	e2833001 	add	r3, r3, #1
3003e224:	e58d30f4 	str	r3, [sp, #244]	; 0xf4
	    Granule_9x9_idct[j++] =  (int)(1024*cos(PI/18 * eight_odd_i));
3003e228:	e59d50f4 	ldr	r5, [sp, #244]	; 0xf4
3003e22c:	e59d0134 	ldr	r0, [sp, #308]	; 0x134
3003e230:	eb001802 	bl	30044240 <__aeabi_i2d>
3003e234:	e1a03000 	mov	r3, r0
3003e238:	e1a04001 	mov	r4, r1
3003e23c:	e1a00003 	mov	r0, r3
3003e240:	e1a01004 	mov	r1, r4
3003e244:	ea000002 	b	3003e254 <Granule_imdct+0xb4c>
3003e248:	4ae74481 	.word	0x4ae74481
3003e24c:	3fc65718 	.word	0x3fc65718
3003e250:	300e8fc0 	.word	0x300e8fc0
3003e254:	e28f3f6f 	add	r3, pc, #444	; 0x1bc
3003e258:	e893000c 	ldm	r3, {r2, r3}
3003e25c:	eb00182e 	bl	3004431c <__aeabi_dmul>
3003e260:	e1a03000 	mov	r3, r0
3003e264:	e1a04001 	mov	r4, r1
3003e268:	e1a00003 	mov	r0, r3
3003e26c:	e1a01004 	mov	r1, r4
3003e270:	ebffdc3a 	bl	30035360 <cos>
3003e274:	e1a03000 	mov	r3, r0
3003e278:	e1a04001 	mov	r4, r1
3003e27c:	e1a00003 	mov	r0, r3
3003e280:	e1a01004 	mov	r1, r4
3003e284:	e3a02000 	mov	r2, #0
3003e288:	e3a03101 	mov	r3, #1073741824	; 0x40000000
3003e28c:	e2833609 	add	r3, r3, #9437184	; 0x900000
3003e290:	eb001821 	bl	3004431c <__aeabi_dmul>
3003e294:	e1a03000 	mov	r3, r0
3003e298:	e1a04001 	mov	r4, r1
3003e29c:	e1a00003 	mov	r0, r3
3003e2a0:	e1a01004 	mov	r1, r4
3003e2a4:	eb001994 	bl	300448fc <__aeabi_d2iz>
3003e2a8:	e1a02000 	mov	r2, r0
3003e2ac:	e59f3178 	ldr	r3, [pc, #376]	; 3003e42c <Granule_imdct+0xd24>
3003e2b0:	e7832105 	str	r2, [r3, r5, lsl #2]
3003e2b4:	e59d30f4 	ldr	r3, [sp, #244]	; 0xf4
3003e2b8:	e2833001 	add	r3, r3, #1
3003e2bc:	e58d30f4 	str	r3, [sp, #244]	; 0xf4

      for(i = 12; i < 36; i++)
	    Granule_imdct_win[2][i] =  0 ;
      
      j = 0;
      for(i = 0; i < 9; i++) 
3003e2c0:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003e2c4:	e2833001 	add	r3, r3, #1
3003e2c8:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003e2cc:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003e2d0:	e3530008 	cmp	r3, #8
3003e2d4:	dafffecc 	ble	3003de0c <Granule_imdct+0x704>
	    Granule_9x9_idct[j++] =  (int)(1024*cos(PI/18 * (four_odd_i + two_odd_i)));
	    Granule_9x9_idct[j++] =  (int)(1024*cos(PI/18 * (eight_odd_i - odd_i)));
	    Granule_9x9_idct[j++] =  (int)(1024*cos(PI/18 * eight_odd_i));
	  }

     for(j = 0;  j< 2; j++)
3003e2d8:	e3a03000 	mov	r3, #0
3003e2dc:	e58d30f4 	str	r3, [sp, #244]	; 0xf4
3003e2e0:	ea000017 	b	3003e344 <Granule_imdct+0xc3c>
  	   for(i = 0; i < 576; i++)
3003e2e4:	e3a03000 	mov	r3, #0
3003e2e8:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003e2ec:	ea00000c 	b	3003e324 <Granule_imdct+0xc1c>
	     Granule_imdct_previous[j][i] = 0;
3003e2f0:	e59d20f4 	ldr	r2, [sp, #244]	; 0xf4
3003e2f4:	e59d00f0 	ldr	r0, [sp, #240]	; 0xf0
3003e2f8:	e59f1120 	ldr	r1, [pc, #288]	; 3003e420 <Granule_imdct+0xd18>
3003e2fc:	e1a03002 	mov	r3, r2
3003e300:	e1a03183 	lsl	r3, r3, #3
3003e304:	e0833002 	add	r3, r3, r2
3003e308:	e1a03303 	lsl	r3, r3, #6
3003e30c:	e0833000 	add	r3, r3, r0
3003e310:	e3a02000 	mov	r2, #0
3003e314:	e7812103 	str	r2, [r1, r3, lsl #2]
	    Granule_9x9_idct[j++] =  (int)(1024*cos(PI/18 * (eight_odd_i - odd_i)));
	    Granule_9x9_idct[j++] =  (int)(1024*cos(PI/18 * eight_odd_i));
	  }

     for(j = 0;  j< 2; j++)
  	   for(i = 0; i < 576; i++)
3003e318:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003e31c:	e2833001 	add	r3, r3, #1
3003e320:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003e324:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003e328:	e3a03f8f 	mov	r3, #572	; 0x23c
3003e32c:	e2833003 	add	r3, r3, #3
3003e330:	e1520003 	cmp	r2, r3
3003e334:	daffffed 	ble	3003e2f0 <Granule_imdct+0xbe8>
	    Granule_9x9_idct[j++] =  (int)(1024*cos(PI/18 * (four_odd_i + two_odd_i)));
	    Granule_9x9_idct[j++] =  (int)(1024*cos(PI/18 * (eight_odd_i - odd_i)));
	    Granule_9x9_idct[j++] =  (int)(1024*cos(PI/18 * eight_odd_i));
	  }

     for(j = 0;  j< 2; j++)
3003e338:	e59d30f4 	ldr	r3, [sp, #244]	; 0xf4
3003e33c:	e2833001 	add	r3, r3, #1
3003e340:	e58d30f4 	str	r3, [sp, #244]	; 0xf4
3003e344:	e59d30f4 	ldr	r3, [sp, #244]	; 0xf4
3003e348:	e3530001 	cmp	r3, #1
3003e34c:	daffffe4 	ble	3003e2e4 <Granule_imdct+0xbdc>
  	   for(i = 0; i < 576; i++)
	     Granule_imdct_previous[j][i] = 0;

	  init=0;
3003e350:	e59f30cc 	ldr	r3, [pc, #204]	; 3003e424 <Granule_imdct+0xd1c>
3003e354:	e3a02000 	mov	r2, #0
3003e358:	e5832000 	str	r2, [r3]
	}
	
	prev = Granule_imdct_previous[ch];
3003e35c:	e59f10bc 	ldr	r1, [pc, #188]	; 3003e420 <Granule_imdct+0xd18>
3003e360:	e59d2008 	ldr	r2, [sp, #8]
3003e364:	e1a03002 	mov	r3, r2
3003e368:	e1a03183 	lsl	r3, r3, #3
3003e36c:	e0833002 	add	r3, r3, r2
3003e370:	e1a03403 	lsl	r3, r3, #8
3003e374:	e0813003 	add	r3, r1, r3
3003e378:	e58d3118 	str	r3, [sp, #280]	; 0x118

    /* process each subband */

    for(sb = 0; sb < SBLIMIT; sb++)
3003e37c:	e3a03000 	mov	r3, #0
3003e380:	e58d30ec 	str	r3, [sp, #236]	; 0xec
3003e384:	ea000543 	b	3003f898 <Granule_imdct+0x2190>
	{

	  for(i = 0; i < 36; i++)
3003e388:	e3a03000 	mov	r3, #0
3003e38c:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003e390:	ea00000a 	b	3003e3c0 <Granule_imdct+0xcb8>
	     x[i] =  0;
3003e394:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003e398:	e3e030db 	mvn	r3, #219	; 0xdb
3003e39c:	e1a02102 	lsl	r2, r2, #2
3003e3a0:	e28d0f4e 	add	r0, sp, #312	; 0x138
3003e3a4:	e0822000 	add	r2, r2, r0
3003e3a8:	e0823003 	add	r3, r2, r3
3003e3ac:	e3a02000 	mov	r2, #0
3003e3b0:	e5832000 	str	r2, [r3]
    /* process each subband */

    for(sb = 0; sb < SBLIMIT; sb++)
	{

	  for(i = 0; i < 36; i++)
3003e3b4:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003e3b8:	e2833001 	add	r3, r3, #1
3003e3bc:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003e3c0:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003e3c4:	e3530023 	cmp	r3, #35	; 0x23
3003e3c8:	dafffff1 	ble	3003e394 <Granule_imdct+0xc8c>
	     x[i] =  0;
	
	/* decode the block_type - it's in block_type, but we have to think
	   about the mixed blocks lower 2 subbands */
	
	if(gr->block_type == 2 &&
3003e3cc:	e59d300c 	ldr	r3, [sp, #12]
3003e3d0:	e5933014 	ldr	r3, [r3, #20]
3003e3d4:	e3530002 	cmp	r3, #2
3003e3d8:	1a00028f 	bne	3003ee1c <Granule_imdct+0x1714>
3003e3dc:	e59d300c 	ldr	r3, [sp, #12]
3003e3e0:	e5933010 	ldr	r3, [r3, #16]
3003e3e4:	e3530000 	cmp	r3, #0
3003e3e8:	0a000006 	beq	3003e408 <Granule_imdct+0xd00>
3003e3ec:	e59d300c 	ldr	r3, [sp, #12]
3003e3f0:	e5933018 	ldr	r3, [r3, #24]
3003e3f4:	e3530000 	cmp	r3, #0
3003e3f8:	0a000002 	beq	3003e408 <Granule_imdct+0xd00>
3003e3fc:	e59d30ec 	ldr	r3, [sp, #236]	; 0xec
3003e400:	e3530001 	cmp	r3, #1
3003e404:	da000284 	ble	3003ee1c <Granule_imdct+0x1714>
	     gr->mixed_block_flag && sb < 2))
	{

    /* process the 3 windows separately, each window has 12 values */

      for(window = 0; window < 3; window++)
3003e408:	e3a03000 	mov	r3, #0
3003e40c:	e58d3100 	str	r3, [sp, #256]	; 0x100
3003e410:	ea00027d 	b	3003ee0c <Granule_imdct+0x1704>
3003e414:	e1a00000 	nop			; (mov r0, r0)
3003e418:	4ae74481 	.word	0x4ae74481
3003e41c:	3fc65718 	.word	0x3fc65718
3003e420:	300e90e0 	.word	0x300e90e0
3003e424:	300c9a84 	.word	0x300c9a84
3003e428:	300c99bc 	.word	0x300c99bc
3003e42c:	300e8fc0 	.word	0x300e8fc0
3003e430:	300c9a18 	.word	0x300c9a18
	  {
		/* 30*3=90 adds, 25*3=75 muls */

		X[15+window] += X[12+window];
3003e434:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e438:	e283300f 	add	r3, r3, #15
3003e43c:	e1a02103 	lsl	r2, r3, #2
3003e440:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e444:	e0823003 	add	r3, r2, r3
3003e448:	e59d2100 	ldr	r2, [sp, #256]	; 0x100
3003e44c:	e282200f 	add	r2, r2, #15
3003e450:	e1a01102 	lsl	r1, r2, #2
3003e454:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003e458:	e0812002 	add	r2, r1, r2
3003e45c:	e5921000 	ldr	r1, [r2]
3003e460:	e59d2100 	ldr	r2, [sp, #256]	; 0x100
3003e464:	e282200c 	add	r2, r2, #12
3003e468:	e1a00102 	lsl	r0, r2, #2
3003e46c:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003e470:	e0802002 	add	r2, r0, r2
3003e474:	e5922000 	ldr	r2, [r2]
3003e478:	e0812002 	add	r2, r1, r2
3003e47c:	e5832000 	str	r2, [r3]
		X[12+window] += X[9+window];
3003e480:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e484:	e283300c 	add	r3, r3, #12
3003e488:	e1a02103 	lsl	r2, r3, #2
3003e48c:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e490:	e0823003 	add	r3, r2, r3
3003e494:	e59d2100 	ldr	r2, [sp, #256]	; 0x100
3003e498:	e282200c 	add	r2, r2, #12
3003e49c:	e1a01102 	lsl	r1, r2, #2
3003e4a0:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003e4a4:	e0812002 	add	r2, r1, r2
3003e4a8:	e5921000 	ldr	r1, [r2]
3003e4ac:	e59d2100 	ldr	r2, [sp, #256]	; 0x100
3003e4b0:	e2822009 	add	r2, r2, #9
3003e4b4:	e1a00102 	lsl	r0, r2, #2
3003e4b8:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003e4bc:	e0802002 	add	r2, r0, r2
3003e4c0:	e5922000 	ldr	r2, [r2]
3003e4c4:	e0812002 	add	r2, r1, r2
3003e4c8:	e5832000 	str	r2, [r3]
		X[9+window] += X[6+window];
3003e4cc:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e4d0:	e2833009 	add	r3, r3, #9
3003e4d4:	e1a02103 	lsl	r2, r3, #2
3003e4d8:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e4dc:	e0823003 	add	r3, r2, r3
3003e4e0:	e59d2100 	ldr	r2, [sp, #256]	; 0x100
3003e4e4:	e2822009 	add	r2, r2, #9
3003e4e8:	e1a01102 	lsl	r1, r2, #2
3003e4ec:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003e4f0:	e0812002 	add	r2, r1, r2
3003e4f4:	e5921000 	ldr	r1, [r2]
3003e4f8:	e59d2100 	ldr	r2, [sp, #256]	; 0x100
3003e4fc:	e2822006 	add	r2, r2, #6
3003e500:	e1a00102 	lsl	r0, r2, #2
3003e504:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003e508:	e0802002 	add	r2, r0, r2
3003e50c:	e5922000 	ldr	r2, [r2]
3003e510:	e0812002 	add	r2, r1, r2
3003e514:	e5832000 	str	r2, [r3]
		X[6+window] += X[3+window];
3003e518:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e51c:	e2833006 	add	r3, r3, #6
3003e520:	e1a02103 	lsl	r2, r3, #2
3003e524:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e528:	e0823003 	add	r3, r2, r3
3003e52c:	e59d2100 	ldr	r2, [sp, #256]	; 0x100
3003e530:	e2822006 	add	r2, r2, #6
3003e534:	e1a01102 	lsl	r1, r2, #2
3003e538:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003e53c:	e0812002 	add	r2, r1, r2
3003e540:	e5921000 	ldr	r1, [r2]
3003e544:	e59d2100 	ldr	r2, [sp, #256]	; 0x100
3003e548:	e2822003 	add	r2, r2, #3
3003e54c:	e1a00102 	lsl	r0, r2, #2
3003e550:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003e554:	e0802002 	add	r2, r0, r2
3003e558:	e5922000 	ldr	r2, [r2]
3003e55c:	e0812002 	add	r2, r1, r2
3003e560:	e5832000 	str	r2, [r3]
		X[3+window] += X[window];
3003e564:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e568:	e2833003 	add	r3, r3, #3
3003e56c:	e1a02103 	lsl	r2, r3, #2
3003e570:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e574:	e0823003 	add	r3, r2, r3
3003e578:	e59d2100 	ldr	r2, [sp, #256]	; 0x100
3003e57c:	e2822003 	add	r2, r2, #3
3003e580:	e1a01102 	lsl	r1, r2, #2
3003e584:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003e588:	e0812002 	add	r2, r1, r2
3003e58c:	e5921000 	ldr	r1, [r2]
3003e590:	e59d2100 	ldr	r2, [sp, #256]	; 0x100
3003e594:	e1a00102 	lsl	r0, r2, #2
3003e598:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003e59c:	e0802002 	add	r2, r0, r2
3003e5a0:	e5922000 	ldr	r2, [r2]
3003e5a4:	e0812002 	add	r2, r1, r2
3003e5a8:	e5832000 	str	r2, [r3]

		X[15+window] += X[9+window];
3003e5ac:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e5b0:	e283300f 	add	r3, r3, #15
3003e5b4:	e1a02103 	lsl	r2, r3, #2
3003e5b8:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e5bc:	e0823003 	add	r3, r2, r3
3003e5c0:	e59d2100 	ldr	r2, [sp, #256]	; 0x100
3003e5c4:	e282200f 	add	r2, r2, #15
3003e5c8:	e1a01102 	lsl	r1, r2, #2
3003e5cc:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003e5d0:	e0812002 	add	r2, r1, r2
3003e5d4:	e5921000 	ldr	r1, [r2]
3003e5d8:	e59d2100 	ldr	r2, [sp, #256]	; 0x100
3003e5dc:	e2822009 	add	r2, r2, #9
3003e5e0:	e1a00102 	lsl	r0, r2, #2
3003e5e4:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003e5e8:	e0802002 	add	r2, r0, r2
3003e5ec:	e5922000 	ldr	r2, [r2]
3003e5f0:	e0812002 	add	r2, r1, r2
3003e5f4:	e5832000 	str	r2, [r3]
		X[9+window] += X[3+window];
3003e5f8:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e5fc:	e2833009 	add	r3, r3, #9
3003e600:	e1a02103 	lsl	r2, r3, #2
3003e604:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e608:	e0823003 	add	r3, r2, r3
3003e60c:	e59d2100 	ldr	r2, [sp, #256]	; 0x100
3003e610:	e2822009 	add	r2, r2, #9
3003e614:	e1a01102 	lsl	r1, r2, #2
3003e618:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003e61c:	e0812002 	add	r2, r1, r2
3003e620:	e5921000 	ldr	r1, [r2]
3003e624:	e59d2100 	ldr	r2, [sp, #256]	; 0x100
3003e628:	e2822003 	add	r2, r2, #3
3003e62c:	e1a00102 	lsl	r0, r2, #2
3003e630:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003e634:	e0802002 	add	r2, r0, r2
3003e638:	e5922000 	ldr	r2, [r2]
3003e63c:	e0812002 	add	r2, r1, r2
3003e640:	e5832000 	str	r2, [r3]

		twid = Granule_twiddles_short;
3003e644:	e51f3224 	ldr	r3, [pc, #-548]	; 3003e428 <Granule_imdct+0xd20>
3003e648:	e58d3120 	str	r3, [sp, #288]	; 0x120

		/* do a 3x3 IDCT on the even part */

		pp1 = (X[6+window] * twid[0])/1024;
3003e64c:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e650:	e2833006 	add	r3, r3, #6
3003e654:	e1a02103 	lsl	r2, r3, #2
3003e658:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e65c:	e0823003 	add	r3, r2, r3
3003e660:	e5933000 	ldr	r3, [r3]
3003e664:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003e668:	e5922000 	ldr	r2, [r2]
3003e66c:	e0030392 	mul	r3, r2, r3
3003e670:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003e674:	e2822003 	add	r2, r2, #3
3003e678:	e3530000 	cmp	r3, #0
3003e67c:	b1a03002 	movlt	r3, r2
3003e680:	e1a03543 	asr	r3, r3, #10
3003e684:	e58d3110 	str	r3, [sp, #272]	; 0x110
		sum = X[window] + (X[12+window] * twid[1])/1024;
3003e688:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e68c:	e1a02103 	lsl	r2, r3, #2
3003e690:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e694:	e0823003 	add	r3, r2, r3
3003e698:	e5931000 	ldr	r1, [r3]
3003e69c:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e6a0:	e283300c 	add	r3, r3, #12
3003e6a4:	e1a02103 	lsl	r2, r3, #2
3003e6a8:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e6ac:	e0823003 	add	r3, r2, r3
3003e6b0:	e5933000 	ldr	r3, [r3]
3003e6b4:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003e6b8:	e2822004 	add	r2, r2, #4
3003e6bc:	e5922000 	ldr	r2, [r2]
3003e6c0:	e0030392 	mul	r3, r2, r3
3003e6c4:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003e6c8:	e2822003 	add	r2, r2, #3
3003e6cc:	e3530000 	cmp	r3, #0
3003e6d0:	b1a03002 	movlt	r3, r2
3003e6d4:	e1a03543 	asr	r3, r3, #10
3003e6d8:	e0813003 	add	r3, r1, r3
3003e6dc:	e58d3108 	str	r3, [sp, #264]	; 0x108
		t[1] = X[window] - X[12+window];
3003e6e0:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e6e4:	e1a02103 	lsl	r2, r3, #2
3003e6e8:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e6ec:	e0823003 	add	r3, r2, r3
3003e6f0:	e5932000 	ldr	r2, [r3]
3003e6f4:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e6f8:	e283300c 	add	r3, r3, #12
3003e6fc:	e1a01103 	lsl	r1, r3, #2
3003e700:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e704:	e0813003 	add	r3, r1, r3
3003e708:	e5933000 	ldr	r3, [r3]
3003e70c:	e0633002 	rsb	r3, r3, r2
3003e710:	e58d3018 	str	r3, [sp, #24]
		t[0] = sum + pp1;
3003e714:	e59d2108 	ldr	r2, [sp, #264]	; 0x108
3003e718:	e59d3110 	ldr	r3, [sp, #272]	; 0x110
3003e71c:	e0823003 	add	r3, r2, r3
3003e720:	e58d3014 	str	r3, [sp, #20]
		t[2] = sum - pp1;
3003e724:	e59d2108 	ldr	r2, [sp, #264]	; 0x108
3003e728:	e59d3110 	ldr	r3, [sp, #272]	; 0x110
3003e72c:	e0633002 	rsb	r3, r3, r2
3003e730:	e58d301c 	str	r3, [sp, #28]

		/* 3x3 IDCT for odd part */

		pp1 = (X[9+window] * twid[0])/1024;
3003e734:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e738:	e2833009 	add	r3, r3, #9
3003e73c:	e1a02103 	lsl	r2, r3, #2
3003e740:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e744:	e0823003 	add	r3, r2, r3
3003e748:	e5933000 	ldr	r3, [r3]
3003e74c:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003e750:	e5922000 	ldr	r2, [r2]
3003e754:	e0030392 	mul	r3, r2, r3
3003e758:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003e75c:	e2822003 	add	r2, r2, #3
3003e760:	e3530000 	cmp	r3, #0
3003e764:	b1a03002 	movlt	r3, r2
3003e768:	e1a03543 	asr	r3, r3, #10
3003e76c:	e58d3110 	str	r3, [sp, #272]	; 0x110
		sum = X[3+window] + (X[15+window] * twid[1])/1024;
3003e770:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e774:	e2833003 	add	r3, r3, #3
3003e778:	e1a02103 	lsl	r2, r3, #2
3003e77c:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e780:	e0823003 	add	r3, r2, r3
3003e784:	e5931000 	ldr	r1, [r3]
3003e788:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e78c:	e283300f 	add	r3, r3, #15
3003e790:	e1a02103 	lsl	r2, r3, #2
3003e794:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e798:	e0823003 	add	r3, r2, r3
3003e79c:	e5933000 	ldr	r3, [r3]
3003e7a0:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003e7a4:	e2822004 	add	r2, r2, #4
3003e7a8:	e5922000 	ldr	r2, [r2]
3003e7ac:	e0030392 	mul	r3, r2, r3
3003e7b0:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003e7b4:	e2822003 	add	r2, r2, #3
3003e7b8:	e3530000 	cmp	r3, #0
3003e7bc:	b1a03002 	movlt	r3, r2
3003e7c0:	e1a03543 	asr	r3, r3, #10
3003e7c4:	e0813003 	add	r3, r1, r3
3003e7c8:	e58d3108 	str	r3, [sp, #264]	; 0x108
		t[4] = X[3+window] - X[15+window];
3003e7cc:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e7d0:	e2833003 	add	r3, r3, #3
3003e7d4:	e1a02103 	lsl	r2, r3, #2
3003e7d8:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e7dc:	e0823003 	add	r3, r2, r3
3003e7e0:	e5932000 	ldr	r2, [r3]
3003e7e4:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003e7e8:	e283300f 	add	r3, r3, #15
3003e7ec:	e1a01103 	lsl	r1, r3, #2
3003e7f0:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003e7f4:	e0813003 	add	r3, r1, r3
3003e7f8:	e5933000 	ldr	r3, [r3]
3003e7fc:	e0633002 	rsb	r3, r3, r2
3003e800:	e58d3024 	str	r3, [sp, #36]	; 0x24
		t[5] = sum + pp1;
3003e804:	e59d2108 	ldr	r2, [sp, #264]	; 0x108
3003e808:	e59d3110 	ldr	r3, [sp, #272]	; 0x110
3003e80c:	e0823003 	add	r3, r2, r3
3003e810:	e58d3028 	str	r3, [sp, #40]	; 0x28
		t[3] = sum - pp1;
3003e814:	e59d2108 	ldr	r2, [sp, #264]	; 0x108
3003e818:	e59d3110 	ldr	r3, [sp, #272]	; 0x110
3003e81c:	e0633002 	rsb	r3, r3, r2
3003e820:	e58d3020 	str	r3, [sp, #32]

		/* scale the odd part */

		t[3] = (t[3]*twid[2])/1024;
3003e824:	e59d3020 	ldr	r3, [sp, #32]
3003e828:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003e82c:	e2822008 	add	r2, r2, #8
3003e830:	e5922000 	ldr	r2, [r2]
3003e834:	e0030392 	mul	r3, r2, r3
3003e838:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003e83c:	e2822003 	add	r2, r2, #3
3003e840:	e3530000 	cmp	r3, #0
3003e844:	b1a03002 	movlt	r3, r2
3003e848:	e1a03543 	asr	r3, r3, #10
3003e84c:	e58d3020 	str	r3, [sp, #32]
		t[4] = (t[4]*twid[3])/1024;
3003e850:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3003e854:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003e858:	e282200c 	add	r2, r2, #12
3003e85c:	e5922000 	ldr	r2, [r2]
3003e860:	e0030392 	mul	r3, r2, r3
3003e864:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003e868:	e2822003 	add	r2, r2, #3
3003e86c:	e3530000 	cmp	r3, #0
3003e870:	b1a03002 	movlt	r3, r2
3003e874:	e1a03543 	asr	r3, r3, #10
3003e878:	e58d3024 	str	r3, [sp, #36]	; 0x24
		t[5] = (t[5]*twid[4])/1024;
3003e87c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3003e880:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003e884:	e2822010 	add	r2, r2, #16
3003e888:	e5922000 	ldr	r2, [r2]
3003e88c:	e0030392 	mul	r3, r2, r3
3003e890:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003e894:	e2822003 	add	r2, r2, #3
3003e898:	e3530000 	cmp	r3, #0
3003e89c:	b1a03002 	movlt	r3, r2
3003e8a0:	e1a03543 	asr	r3, r3, #10
3003e8a4:	e58d3028 	str	r3, [sp, #40]	; 0x28

		save = t[0];
3003e8a8:	e59d3014 	ldr	r3, [sp, #20]
3003e8ac:	e58d3104 	str	r3, [sp, #260]	; 0x104
		t[0] += t[5];
3003e8b0:	e59d2014 	ldr	r2, [sp, #20]
3003e8b4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3003e8b8:	e0823003 	add	r3, r2, r3
3003e8bc:	e58d3014 	str	r3, [sp, #20]
		t[5] = save - t[5];
3003e8c0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3003e8c4:	e59d2104 	ldr	r2, [sp, #260]	; 0x104
3003e8c8:	e0633002 	rsb	r3, r3, r2
3003e8cc:	e58d3028 	str	r3, [sp, #40]	; 0x28

		save = t[1];
3003e8d0:	e59d3018 	ldr	r3, [sp, #24]
3003e8d4:	e58d3104 	str	r3, [sp, #260]	; 0x104
		t[1] += t[4];
3003e8d8:	e59d2018 	ldr	r2, [sp, #24]
3003e8dc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3003e8e0:	e0823003 	add	r3, r2, r3
3003e8e4:	e58d3018 	str	r3, [sp, #24]
		t[4] = save - t[4];
3003e8e8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3003e8ec:	e59d2104 	ldr	r2, [sp, #260]	; 0x104
3003e8f0:	e0633002 	rsb	r3, r3, r2
3003e8f4:	e58d3024 	str	r3, [sp, #36]	; 0x24

		save = t[2];
3003e8f8:	e59d301c 	ldr	r3, [sp, #28]
3003e8fc:	e58d3104 	str	r3, [sp, #260]	; 0x104
		t[2] += t[3];
3003e900:	e59d201c 	ldr	r2, [sp, #28]
3003e904:	e59d3020 	ldr	r3, [sp, #32]
3003e908:	e0823003 	add	r3, r2, r3
3003e90c:	e58d301c 	str	r3, [sp, #28]
		t[3] = save - t[3];
3003e910:	e59d3020 	ldr	r3, [sp, #32]
3003e914:	e59d2104 	ldr	r2, [sp, #260]	; 0x104
3003e918:	e0633002 	rsb	r3, r3, r2
3003e91c:	e58d3020 	str	r3, [sp, #32]

		t[0]  = (t[0]*twid[5])/1024;
3003e920:	e59d3014 	ldr	r3, [sp, #20]
3003e924:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003e928:	e2822014 	add	r2, r2, #20
3003e92c:	e5922000 	ldr	r2, [r2]
3003e930:	e0030392 	mul	r3, r2, r3
3003e934:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003e938:	e2822003 	add	r2, r2, #3
3003e93c:	e3530000 	cmp	r3, #0
3003e940:	b1a03002 	movlt	r3, r2
3003e944:	e1a03543 	asr	r3, r3, #10
3003e948:	e58d3014 	str	r3, [sp, #20]
		t[1]  = (t[1]*twid[6])/1024;
3003e94c:	e59d3018 	ldr	r3, [sp, #24]
3003e950:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003e954:	e2822018 	add	r2, r2, #24
3003e958:	e5922000 	ldr	r2, [r2]
3003e95c:	e0030392 	mul	r3, r2, r3
3003e960:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003e964:	e2822003 	add	r2, r2, #3
3003e968:	e3530000 	cmp	r3, #0
3003e96c:	b1a03002 	movlt	r3, r2
3003e970:	e1a03543 	asr	r3, r3, #10
3003e974:	e58d3018 	str	r3, [sp, #24]
		t[2]  = (t[2]*twid[7])/1024;
3003e978:	e59d301c 	ldr	r3, [sp, #28]
3003e97c:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003e980:	e282201c 	add	r2, r2, #28
3003e984:	e5922000 	ldr	r2, [r2]
3003e988:	e0030392 	mul	r3, r2, r3
3003e98c:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003e990:	e2822003 	add	r2, r2, #3
3003e994:	e3530000 	cmp	r3, #0
3003e998:	b1a03002 	movlt	r3, r2
3003e99c:	e1a03543 	asr	r3, r3, #10
3003e9a0:	e58d301c 	str	r3, [sp, #28]
		t[3]  = (t[3]*twid[8])/1024;
3003e9a4:	e59d3020 	ldr	r3, [sp, #32]
3003e9a8:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003e9ac:	e2822020 	add	r2, r2, #32
3003e9b0:	e5922000 	ldr	r2, [r2]
3003e9b4:	e0030392 	mul	r3, r2, r3
3003e9b8:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003e9bc:	e2822003 	add	r2, r2, #3
3003e9c0:	e3530000 	cmp	r3, #0
3003e9c4:	b1a03002 	movlt	r3, r2
3003e9c8:	e1a03543 	asr	r3, r3, #10
3003e9cc:	e58d3020 	str	r3, [sp, #32]
		t[4]  = (t[4]*twid[9])/1024;
3003e9d0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3003e9d4:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003e9d8:	e2822024 	add	r2, r2, #36	; 0x24
3003e9dc:	e5922000 	ldr	r2, [r2]
3003e9e0:	e0030392 	mul	r3, r2, r3
3003e9e4:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003e9e8:	e2822003 	add	r2, r2, #3
3003e9ec:	e3530000 	cmp	r3, #0
3003e9f0:	b1a03002 	movlt	r3, r2
3003e9f4:	e1a03543 	asr	r3, r3, #10
3003e9f8:	e58d3024 	str	r3, [sp, #36]	; 0x24
		t[5]  = (t[5]*twid[10])/1024;
3003e9fc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3003ea00:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003ea04:	e2822028 	add	r2, r2, #40	; 0x28
3003ea08:	e5922000 	ldr	r2, [r2]
3003ea0c:	e0030392 	mul	r3, r2, r3
3003ea10:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003ea14:	e2822003 	add	r2, r2, #3
3003ea18:	e3530000 	cmp	r3, #0
3003ea1c:	b1a03002 	movlt	r3, r2
3003ea20:	e1a03543 	asr	r3, r3, #10
3003ea24:	e58d3028 	str	r3, [sp, #40]	; 0x28

		t[6]  = -(t[2] * twid[15])/1024;
3003ea28:	e59d301c 	ldr	r3, [sp, #28]
3003ea2c:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003ea30:	e282203c 	add	r2, r2, #60	; 0x3c
3003ea34:	e5922000 	ldr	r2, [r2]
3003ea38:	e0030392 	mul	r3, r2, r3
3003ea3c:	e2633000 	rsb	r3, r3, #0
3003ea40:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003ea44:	e2822003 	add	r2, r2, #3
3003ea48:	e3530000 	cmp	r3, #0
3003ea4c:	b1a03002 	movlt	r3, r2
3003ea50:	e1a03543 	asr	r3, r3, #10
3003ea54:	e58d302c 	str	r3, [sp, #44]	; 0x2c
		t[7]  = -(t[1] * twid[13])/1024;
3003ea58:	e59d3018 	ldr	r3, [sp, #24]
3003ea5c:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003ea60:	e2822034 	add	r2, r2, #52	; 0x34
3003ea64:	e5922000 	ldr	r2, [r2]
3003ea68:	e0030392 	mul	r3, r2, r3
3003ea6c:	e2633000 	rsb	r3, r3, #0
3003ea70:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003ea74:	e2822003 	add	r2, r2, #3
3003ea78:	e3530000 	cmp	r3, #0
3003ea7c:	b1a03002 	movlt	r3, r2
3003ea80:	e1a03543 	asr	r3, r3, #10
3003ea84:	e58d3030 	str	r3, [sp, #48]	; 0x30
		t[8]  = -(t[0] * twid[11])/1024;
3003ea88:	e59d3014 	ldr	r3, [sp, #20]
3003ea8c:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003ea90:	e282202c 	add	r2, r2, #44	; 0x2c
3003ea94:	e5922000 	ldr	r2, [r2]
3003ea98:	e0030392 	mul	r3, r2, r3
3003ea9c:	e2633000 	rsb	r3, r3, #0
3003eaa0:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003eaa4:	e2822003 	add	r2, r2, #3
3003eaa8:	e3530000 	cmp	r3, #0
3003eaac:	b1a03002 	movlt	r3, r2
3003eab0:	e1a03543 	asr	r3, r3, #10
3003eab4:	e58d3034 	str	r3, [sp, #52]	; 0x34
		t[9]  = -(t[0] * twid[12])/1024;
3003eab8:	e59d3014 	ldr	r3, [sp, #20]
3003eabc:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003eac0:	e2822030 	add	r2, r2, #48	; 0x30
3003eac4:	e5922000 	ldr	r2, [r2]
3003eac8:	e0030392 	mul	r3, r2, r3
3003eacc:	e2633000 	rsb	r3, r3, #0
3003ead0:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003ead4:	e2822003 	add	r2, r2, #3
3003ead8:	e3530000 	cmp	r3, #0
3003eadc:	b1a03002 	movlt	r3, r2
3003eae0:	e1a03543 	asr	r3, r3, #10
3003eae4:	e58d3038 	str	r3, [sp, #56]	; 0x38
		t[10] = -(t[1] * twid[14])/1024;
3003eae8:	e59d3018 	ldr	r3, [sp, #24]
3003eaec:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003eaf0:	e2822038 	add	r2, r2, #56	; 0x38
3003eaf4:	e5922000 	ldr	r2, [r2]
3003eaf8:	e0030392 	mul	r3, r2, r3
3003eafc:	e2633000 	rsb	r3, r3, #0
3003eb00:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003eb04:	e2822003 	add	r2, r2, #3
3003eb08:	e3530000 	cmp	r3, #0
3003eb0c:	b1a03002 	movlt	r3, r2
3003eb10:	e1a03543 	asr	r3, r3, #10
3003eb14:	e58d303c 	str	r3, [sp, #60]	; 0x3c
		t[11] = -(t[2] * twid[16])/1024;
3003eb18:	e59d301c 	ldr	r3, [sp, #28]
3003eb1c:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003eb20:	e2822040 	add	r2, r2, #64	; 0x40
3003eb24:	e5922000 	ldr	r2, [r2]
3003eb28:	e0030392 	mul	r3, r2, r3
3003eb2c:	e2633000 	rsb	r3, r3, #0
3003eb30:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003eb34:	e2822003 	add	r2, r2, #3
3003eb38:	e3530000 	cmp	r3, #0
3003eb3c:	b1a03002 	movlt	r3, r2
3003eb40:	e1a03543 	asr	r3, r3, #10
3003eb44:	e58d3040 	str	r3, [sp, #64]	; 0x40
		
		t[0]  =  t[3];
3003eb48:	e59d3020 	ldr	r3, [sp, #32]
3003eb4c:	e58d3014 	str	r3, [sp, #20]
		t[1]  =  (t[4] * twid[17])/1024;
3003eb50:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3003eb54:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003eb58:	e2822044 	add	r2, r2, #68	; 0x44
3003eb5c:	e5922000 	ldr	r2, [r2]
3003eb60:	e0030392 	mul	r3, r2, r3
3003eb64:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003eb68:	e2822003 	add	r2, r2, #3
3003eb6c:	e3530000 	cmp	r3, #0
3003eb70:	b1a03002 	movlt	r3, r2
3003eb74:	e1a03543 	asr	r3, r3, #10
3003eb78:	e58d3018 	str	r3, [sp, #24]
		t[2]  =  (t[5] * twid[18])/1024;
3003eb7c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3003eb80:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003eb84:	e2822048 	add	r2, r2, #72	; 0x48
3003eb88:	e5922000 	ldr	r2, [r2]
3003eb8c:	e0030392 	mul	r3, r2, r3
3003eb90:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003eb94:	e2822003 	add	r2, r2, #3
3003eb98:	e3530000 	cmp	r3, #0
3003eb9c:	b1a03002 	movlt	r3, r2
3003eba0:	e1a03543 	asr	r3, r3, #10
3003eba4:	e58d301c 	str	r3, [sp, #28]
		
		t[3]  = -(t[5] * twid[19])/1024;
3003eba8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3003ebac:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003ebb0:	e282204c 	add	r2, r2, #76	; 0x4c
3003ebb4:	e5922000 	ldr	r2, [r2]
3003ebb8:	e0030392 	mul	r3, r2, r3
3003ebbc:	e2633000 	rsb	r3, r3, #0
3003ebc0:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003ebc4:	e2822003 	add	r2, r2, #3
3003ebc8:	e3530000 	cmp	r3, #0
3003ebcc:	b1a03002 	movlt	r3, r2
3003ebd0:	e1a03543 	asr	r3, r3, #10
3003ebd4:	e58d3020 	str	r3, [sp, #32]
		t[4]  = -(t[4] * twid[20])/1024;
3003ebd8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3003ebdc:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003ebe0:	e2822050 	add	r2, r2, #80	; 0x50
3003ebe4:	e5922000 	ldr	r2, [r2]
3003ebe8:	e0030392 	mul	r3, r2, r3
3003ebec:	e2633000 	rsb	r3, r3, #0
3003ebf0:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003ebf4:	e2822003 	add	r2, r2, #3
3003ebf8:	e3530000 	cmp	r3, #0
3003ebfc:	b1a03002 	movlt	r3, r2
3003ec00:	e1a03543 	asr	r3, r3, #10
3003ec04:	e58d3024 	str	r3, [sp, #36]	; 0x24
		t[5]  = -(t[0] * twid[21])/1024;
3003ec08:	e59d3014 	ldr	r3, [sp, #20]
3003ec0c:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003ec10:	e2822054 	add	r2, r2, #84	; 0x54
3003ec14:	e5922000 	ldr	r2, [r2]
3003ec18:	e0030392 	mul	r3, r2, r3
3003ec1c:	e2633000 	rsb	r3, r3, #0
3003ec20:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003ec24:	e2822003 	add	r2, r2, #3
3003ec28:	e3530000 	cmp	r3, #0
3003ec2c:	b1a03002 	movlt	r3, r2
3003ec30:	e1a03543 	asr	r3, r3, #10
3003ec34:	e58d3028 	str	r3, [sp, #40]	; 0x28
		
		t[0] = (t[0]*twid[22])/1024;
3003ec38:	e59d3014 	ldr	r3, [sp, #20]
3003ec3c:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003ec40:	e2822058 	add	r2, r2, #88	; 0x58
3003ec44:	e5922000 	ldr	r2, [r2]
3003ec48:	e0030392 	mul	r3, r2, r3
3003ec4c:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003ec50:	e2822003 	add	r2, r2, #3
3003ec54:	e3530000 	cmp	r3, #0
3003ec58:	b1a03002 	movlt	r3, r2
3003ec5c:	e1a03543 	asr	r3, r3, #10
3003ec60:	e58d3014 	str	r3, [sp, #20]

		z = &x[window * 6 + 6];
3003ec64:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003ec68:	e2832001 	add	r2, r3, #1
3003ec6c:	e1a03002 	mov	r3, r2
3003ec70:	e1a03083 	lsl	r3, r3, #1
3003ec74:	e0833002 	add	r3, r3, r2
3003ec78:	e1a03183 	lsl	r3, r3, #3
3003ec7c:	e28d205c 	add	r2, sp, #92	; 0x5c
3003ec80:	e0823003 	add	r3, r2, r3
3003ec84:	e58d311c 	str	r3, [sp, #284]	; 0x11c
		z[0]  += t[0];
3003ec88:	e59d311c 	ldr	r3, [sp, #284]	; 0x11c
3003ec8c:	e5932000 	ldr	r2, [r3]
3003ec90:	e59d3014 	ldr	r3, [sp, #20]
3003ec94:	e0822003 	add	r2, r2, r3
3003ec98:	e59d311c 	ldr	r3, [sp, #284]	; 0x11c
3003ec9c:	e5832000 	str	r2, [r3]
		z[1]  += t[1];
3003eca0:	e59d311c 	ldr	r3, [sp, #284]	; 0x11c
3003eca4:	e2833004 	add	r3, r3, #4
3003eca8:	e59d211c 	ldr	r2, [sp, #284]	; 0x11c
3003ecac:	e2822004 	add	r2, r2, #4
3003ecb0:	e5921000 	ldr	r1, [r2]
3003ecb4:	e59d2018 	ldr	r2, [sp, #24]
3003ecb8:	e0812002 	add	r2, r1, r2
3003ecbc:	e5832000 	str	r2, [r3]
		z[2]  += t[2];
3003ecc0:	e59d311c 	ldr	r3, [sp, #284]	; 0x11c
3003ecc4:	e2833008 	add	r3, r3, #8
3003ecc8:	e59d211c 	ldr	r2, [sp, #284]	; 0x11c
3003eccc:	e2822008 	add	r2, r2, #8
3003ecd0:	e5921000 	ldr	r1, [r2]
3003ecd4:	e59d201c 	ldr	r2, [sp, #28]
3003ecd8:	e0812002 	add	r2, r1, r2
3003ecdc:	e5832000 	str	r2, [r3]
		z[3]  += t[3];
3003ece0:	e59d311c 	ldr	r3, [sp, #284]	; 0x11c
3003ece4:	e283300c 	add	r3, r3, #12
3003ece8:	e59d211c 	ldr	r2, [sp, #284]	; 0x11c
3003ecec:	e282200c 	add	r2, r2, #12
3003ecf0:	e5921000 	ldr	r1, [r2]
3003ecf4:	e59d2020 	ldr	r2, [sp, #32]
3003ecf8:	e0812002 	add	r2, r1, r2
3003ecfc:	e5832000 	str	r2, [r3]
		z[4]  += t[4];
3003ed00:	e59d311c 	ldr	r3, [sp, #284]	; 0x11c
3003ed04:	e2833010 	add	r3, r3, #16
3003ed08:	e59d211c 	ldr	r2, [sp, #284]	; 0x11c
3003ed0c:	e2822010 	add	r2, r2, #16
3003ed10:	e5921000 	ldr	r1, [r2]
3003ed14:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
3003ed18:	e0812002 	add	r2, r1, r2
3003ed1c:	e5832000 	str	r2, [r3]
		z[5]  += t[5];
3003ed20:	e59d311c 	ldr	r3, [sp, #284]	; 0x11c
3003ed24:	e2833014 	add	r3, r3, #20
3003ed28:	e59d211c 	ldr	r2, [sp, #284]	; 0x11c
3003ed2c:	e2822014 	add	r2, r2, #20
3003ed30:	e5921000 	ldr	r1, [r2]
3003ed34:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
3003ed38:	e0812002 	add	r2, r1, r2
3003ed3c:	e5832000 	str	r2, [r3]
		z[6]  += t[6];
3003ed40:	e59d311c 	ldr	r3, [sp, #284]	; 0x11c
3003ed44:	e2833018 	add	r3, r3, #24
3003ed48:	e59d211c 	ldr	r2, [sp, #284]	; 0x11c
3003ed4c:	e2822018 	add	r2, r2, #24
3003ed50:	e5921000 	ldr	r1, [r2]
3003ed54:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
3003ed58:	e0812002 	add	r2, r1, r2
3003ed5c:	e5832000 	str	r2, [r3]
		z[7]  += t[7];
3003ed60:	e59d311c 	ldr	r3, [sp, #284]	; 0x11c
3003ed64:	e283301c 	add	r3, r3, #28
3003ed68:	e59d211c 	ldr	r2, [sp, #284]	; 0x11c
3003ed6c:	e282201c 	add	r2, r2, #28
3003ed70:	e5921000 	ldr	r1, [r2]
3003ed74:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
3003ed78:	e0812002 	add	r2, r1, r2
3003ed7c:	e5832000 	str	r2, [r3]
		z[8]  += t[8];
3003ed80:	e59d311c 	ldr	r3, [sp, #284]	; 0x11c
3003ed84:	e2833020 	add	r3, r3, #32
3003ed88:	e59d211c 	ldr	r2, [sp, #284]	; 0x11c
3003ed8c:	e2822020 	add	r2, r2, #32
3003ed90:	e5921000 	ldr	r1, [r2]
3003ed94:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3003ed98:	e0812002 	add	r2, r1, r2
3003ed9c:	e5832000 	str	r2, [r3]
		z[9]  += t[9];
3003eda0:	e59d311c 	ldr	r3, [sp, #284]	; 0x11c
3003eda4:	e2833024 	add	r3, r3, #36	; 0x24
3003eda8:	e59d211c 	ldr	r2, [sp, #284]	; 0x11c
3003edac:	e2822024 	add	r2, r2, #36	; 0x24
3003edb0:	e5921000 	ldr	r1, [r2]
3003edb4:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
3003edb8:	e0812002 	add	r2, r1, r2
3003edbc:	e5832000 	str	r2, [r3]
		z[10]  += t[10];
3003edc0:	e59d311c 	ldr	r3, [sp, #284]	; 0x11c
3003edc4:	e2833028 	add	r3, r3, #40	; 0x28
3003edc8:	e59d211c 	ldr	r2, [sp, #284]	; 0x11c
3003edcc:	e2822028 	add	r2, r2, #40	; 0x28
3003edd0:	e5921000 	ldr	r1, [r2]
3003edd4:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3003edd8:	e0812002 	add	r2, r1, r2
3003eddc:	e5832000 	str	r2, [r3]
		z[11]  += t[11];
3003ede0:	e59d311c 	ldr	r3, [sp, #284]	; 0x11c
3003ede4:	e283302c 	add	r3, r3, #44	; 0x2c
3003ede8:	e59d211c 	ldr	r2, [sp, #284]	; 0x11c
3003edec:	e282202c 	add	r2, r2, #44	; 0x2c
3003edf0:	e5921000 	ldr	r1, [r2]
3003edf4:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
3003edf8:	e0812002 	add	r2, r1, r2
3003edfc:	e5832000 	str	r2, [r3]
	     gr->mixed_block_flag && sb < 2))
	{

    /* process the 3 windows separately, each window has 12 values */

      for(window = 0; window < 3; window++)
3003ee00:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003ee04:	e2833001 	add	r3, r3, #1
3003ee08:	e58d3100 	str	r3, [sp, #256]	; 0x100
3003ee0c:	e59d3100 	ldr	r3, [sp, #256]	; 0x100
3003ee10:	e3530002 	cmp	r3, #2
3003ee14:	dafffd86 	ble	3003e434 <Granule_imdct+0xd2c>
	     x[i] =  0;
	
	/* decode the block_type - it's in block_type, but we have to think
	   about the mixed blocks lower 2 subbands */
	
	if(gr->block_type == 2 &&
3003ee18:	ea000276 	b	3003f7f8 <Granule_imdct+0x20f0>
	}
	else
	{
	    /* uses 207 muls, 189 adds */
		 
	    X[17] += X[16];
3003ee1c:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003ee20:	e2833044 	add	r3, r3, #68	; 0x44
3003ee24:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003ee28:	e2822044 	add	r2, r2, #68	; 0x44
3003ee2c:	e5921000 	ldr	r1, [r2]
3003ee30:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003ee34:	e2822040 	add	r2, r2, #64	; 0x40
3003ee38:	e5922000 	ldr	r2, [r2]
3003ee3c:	e0812002 	add	r2, r1, r2
3003ee40:	e5832000 	str	r2, [r3]
	    X[16] += X[15];
3003ee44:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003ee48:	e2833040 	add	r3, r3, #64	; 0x40
3003ee4c:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003ee50:	e2822040 	add	r2, r2, #64	; 0x40
3003ee54:	e5921000 	ldr	r1, [r2]
3003ee58:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003ee5c:	e282203c 	add	r2, r2, #60	; 0x3c
3003ee60:	e5922000 	ldr	r2, [r2]
3003ee64:	e0812002 	add	r2, r1, r2
3003ee68:	e5832000 	str	r2, [r3]
	    X[15] += X[14];
3003ee6c:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003ee70:	e283303c 	add	r3, r3, #60	; 0x3c
3003ee74:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003ee78:	e282203c 	add	r2, r2, #60	; 0x3c
3003ee7c:	e5921000 	ldr	r1, [r2]
3003ee80:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003ee84:	e2822038 	add	r2, r2, #56	; 0x38
3003ee88:	e5922000 	ldr	r2, [r2]
3003ee8c:	e0812002 	add	r2, r1, r2
3003ee90:	e5832000 	str	r2, [r3]
	    X[14] += X[13];
3003ee94:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003ee98:	e2833038 	add	r3, r3, #56	; 0x38
3003ee9c:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003eea0:	e2822038 	add	r2, r2, #56	; 0x38
3003eea4:	e5921000 	ldr	r1, [r2]
3003eea8:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003eeac:	e2822034 	add	r2, r2, #52	; 0x34
3003eeb0:	e5922000 	ldr	r2, [r2]
3003eeb4:	e0812002 	add	r2, r1, r2
3003eeb8:	e5832000 	str	r2, [r3]
	    X[13] += X[12];
3003eebc:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003eec0:	e2833034 	add	r3, r3, #52	; 0x34
3003eec4:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003eec8:	e2822034 	add	r2, r2, #52	; 0x34
3003eecc:	e5921000 	ldr	r1, [r2]
3003eed0:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003eed4:	e2822030 	add	r2, r2, #48	; 0x30
3003eed8:	e5922000 	ldr	r2, [r2]
3003eedc:	e0812002 	add	r2, r1, r2
3003eee0:	e5832000 	str	r2, [r3]
	    X[12] += X[11];
3003eee4:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003eee8:	e2833030 	add	r3, r3, #48	; 0x30
3003eeec:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003eef0:	e2822030 	add	r2, r2, #48	; 0x30
3003eef4:	e5921000 	ldr	r1, [r2]
3003eef8:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003eefc:	e282202c 	add	r2, r2, #44	; 0x2c
3003ef00:	e5922000 	ldr	r2, [r2]
3003ef04:	e0812002 	add	r2, r1, r2
3003ef08:	e5832000 	str	r2, [r3]
	    X[11] += X[10];
3003ef0c:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003ef10:	e283302c 	add	r3, r3, #44	; 0x2c
3003ef14:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003ef18:	e282202c 	add	r2, r2, #44	; 0x2c
3003ef1c:	e5921000 	ldr	r1, [r2]
3003ef20:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003ef24:	e2822028 	add	r2, r2, #40	; 0x28
3003ef28:	e5922000 	ldr	r2, [r2]
3003ef2c:	e0812002 	add	r2, r1, r2
3003ef30:	e5832000 	str	r2, [r3]
	    X[10] += X[9];
3003ef34:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003ef38:	e2833028 	add	r3, r3, #40	; 0x28
3003ef3c:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003ef40:	e2822028 	add	r2, r2, #40	; 0x28
3003ef44:	e5921000 	ldr	r1, [r2]
3003ef48:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003ef4c:	e2822024 	add	r2, r2, #36	; 0x24
3003ef50:	e5922000 	ldr	r2, [r2]
3003ef54:	e0812002 	add	r2, r1, r2
3003ef58:	e5832000 	str	r2, [r3]
	    X[9] += X[8];
3003ef5c:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003ef60:	e2833024 	add	r3, r3, #36	; 0x24
3003ef64:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003ef68:	e2822024 	add	r2, r2, #36	; 0x24
3003ef6c:	e5921000 	ldr	r1, [r2]
3003ef70:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003ef74:	e2822020 	add	r2, r2, #32
3003ef78:	e5922000 	ldr	r2, [r2]
3003ef7c:	e0812002 	add	r2, r1, r2
3003ef80:	e5832000 	str	r2, [r3]
	    X[8] += X[7];
3003ef84:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003ef88:	e2833020 	add	r3, r3, #32
3003ef8c:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003ef90:	e2822020 	add	r2, r2, #32
3003ef94:	e5921000 	ldr	r1, [r2]
3003ef98:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003ef9c:	e282201c 	add	r2, r2, #28
3003efa0:	e5922000 	ldr	r2, [r2]
3003efa4:	e0812002 	add	r2, r1, r2
3003efa8:	e5832000 	str	r2, [r3]
	    X[7] += X[6];
3003efac:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003efb0:	e283301c 	add	r3, r3, #28
3003efb4:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003efb8:	e282201c 	add	r2, r2, #28
3003efbc:	e5921000 	ldr	r1, [r2]
3003efc0:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003efc4:	e2822018 	add	r2, r2, #24
3003efc8:	e5922000 	ldr	r2, [r2]
3003efcc:	e0812002 	add	r2, r1, r2
3003efd0:	e5832000 	str	r2, [r3]
	    X[6] += X[5];
3003efd4:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003efd8:	e2833018 	add	r3, r3, #24
3003efdc:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003efe0:	e2822018 	add	r2, r2, #24
3003efe4:	e5921000 	ldr	r1, [r2]
3003efe8:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003efec:	e2822014 	add	r2, r2, #20
3003eff0:	e5922000 	ldr	r2, [r2]
3003eff4:	e0812002 	add	r2, r1, r2
3003eff8:	e5832000 	str	r2, [r3]
	    X[5] += X[4];
3003effc:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f000:	e2833014 	add	r3, r3, #20
3003f004:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f008:	e2822014 	add	r2, r2, #20
3003f00c:	e5921000 	ldr	r1, [r2]
3003f010:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f014:	e2822010 	add	r2, r2, #16
3003f018:	e5922000 	ldr	r2, [r2]
3003f01c:	e0812002 	add	r2, r1, r2
3003f020:	e5832000 	str	r2, [r3]
	    X[4] += X[3];
3003f024:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f028:	e2833010 	add	r3, r3, #16
3003f02c:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f030:	e2822010 	add	r2, r2, #16
3003f034:	e5921000 	ldr	r1, [r2]
3003f038:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f03c:	e282200c 	add	r2, r2, #12
3003f040:	e5922000 	ldr	r2, [r2]
3003f044:	e0812002 	add	r2, r1, r2
3003f048:	e5832000 	str	r2, [r3]
	    X[3] += X[2];
3003f04c:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f050:	e283300c 	add	r3, r3, #12
3003f054:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f058:	e282200c 	add	r2, r2, #12
3003f05c:	e5921000 	ldr	r1, [r2]
3003f060:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f064:	e2822008 	add	r2, r2, #8
3003f068:	e5922000 	ldr	r2, [r2]
3003f06c:	e0812002 	add	r2, r1, r2
3003f070:	e5832000 	str	r2, [r3]
	    X[2] += X[1];
3003f074:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f078:	e2833008 	add	r3, r3, #8
3003f07c:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f080:	e2822008 	add	r2, r2, #8
3003f084:	e5921000 	ldr	r1, [r2]
3003f088:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f08c:	e2822004 	add	r2, r2, #4
3003f090:	e5922000 	ldr	r2, [r2]
3003f094:	e0812002 	add	r2, r1, r2
3003f098:	e5832000 	str	r2, [r3]
	    X[1] += X[0];
3003f09c:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f0a0:	e2833004 	add	r3, r3, #4
3003f0a4:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f0a8:	e2822004 	add	r2, r2, #4
3003f0ac:	e5921000 	ldr	r1, [r2]
3003f0b0:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f0b4:	e5922000 	ldr	r2, [r2]
3003f0b8:	e0812002 	add	r2, r1, r2
3003f0bc:	e5832000 	str	r2, [r3]

	    X[17] += X[15];
3003f0c0:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f0c4:	e2833044 	add	r3, r3, #68	; 0x44
3003f0c8:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f0cc:	e2822044 	add	r2, r2, #68	; 0x44
3003f0d0:	e5921000 	ldr	r1, [r2]
3003f0d4:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f0d8:	e282203c 	add	r2, r2, #60	; 0x3c
3003f0dc:	e5922000 	ldr	r2, [r2]
3003f0e0:	e0812002 	add	r2, r1, r2
3003f0e4:	e5832000 	str	r2, [r3]
	    X[15] += X[13];
3003f0e8:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f0ec:	e283303c 	add	r3, r3, #60	; 0x3c
3003f0f0:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f0f4:	e282203c 	add	r2, r2, #60	; 0x3c
3003f0f8:	e5921000 	ldr	r1, [r2]
3003f0fc:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f100:	e2822034 	add	r2, r2, #52	; 0x34
3003f104:	e5922000 	ldr	r2, [r2]
3003f108:	e0812002 	add	r2, r1, r2
3003f10c:	e5832000 	str	r2, [r3]
	    X[13] += X[11];
3003f110:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f114:	e2833034 	add	r3, r3, #52	; 0x34
3003f118:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f11c:	e2822034 	add	r2, r2, #52	; 0x34
3003f120:	e5921000 	ldr	r1, [r2]
3003f124:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f128:	e282202c 	add	r2, r2, #44	; 0x2c
3003f12c:	e5922000 	ldr	r2, [r2]
3003f130:	e0812002 	add	r2, r1, r2
3003f134:	e5832000 	str	r2, [r3]
	    X[11] += X[9];
3003f138:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f13c:	e283302c 	add	r3, r3, #44	; 0x2c
3003f140:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f144:	e282202c 	add	r2, r2, #44	; 0x2c
3003f148:	e5921000 	ldr	r1, [r2]
3003f14c:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f150:	e2822024 	add	r2, r2, #36	; 0x24
3003f154:	e5922000 	ldr	r2, [r2]
3003f158:	e0812002 	add	r2, r1, r2
3003f15c:	e5832000 	str	r2, [r3]
	    X[9] += X[7];
3003f160:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f164:	e2833024 	add	r3, r3, #36	; 0x24
3003f168:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f16c:	e2822024 	add	r2, r2, #36	; 0x24
3003f170:	e5921000 	ldr	r1, [r2]
3003f174:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f178:	e282201c 	add	r2, r2, #28
3003f17c:	e5922000 	ldr	r2, [r2]
3003f180:	e0812002 	add	r2, r1, r2
3003f184:	e5832000 	str	r2, [r3]
	    X[7] += X[5];
3003f188:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f18c:	e283301c 	add	r3, r3, #28
3003f190:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f194:	e282201c 	add	r2, r2, #28
3003f198:	e5921000 	ldr	r1, [r2]
3003f19c:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f1a0:	e2822014 	add	r2, r2, #20
3003f1a4:	e5922000 	ldr	r2, [r2]
3003f1a8:	e0812002 	add	r2, r1, r2
3003f1ac:	e5832000 	str	r2, [r3]
	    X[5] += X[3];
3003f1b0:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f1b4:	e2833014 	add	r3, r3, #20
3003f1b8:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f1bc:	e2822014 	add	r2, r2, #20
3003f1c0:	e5921000 	ldr	r1, [r2]
3003f1c4:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f1c8:	e282200c 	add	r2, r2, #12
3003f1cc:	e5922000 	ldr	r2, [r2]
3003f1d0:	e0812002 	add	r2, r1, r2
3003f1d4:	e5832000 	str	r2, [r3]
	    X[3] += X[1];
3003f1d8:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f1dc:	e283300c 	add	r3, r3, #12
3003f1e0:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f1e4:	e282200c 	add	r2, r2, #12
3003f1e8:	e5921000 	ldr	r1, [r2]
3003f1ec:	e59d2124 	ldr	r2, [sp, #292]	; 0x124
3003f1f0:	e2822004 	add	r2, r2, #4
3003f1f4:	e5922000 	ldr	r2, [r2]
3003f1f8:	e0812002 	add	r2, r1, r2
3003f1fc:	e5832000 	str	r2, [r3]

	    for(i = 0, j = 0; i < 9; i++, j += 8)
3003f200:	e3a03000 	mov	r3, #0
3003f204:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003f208:	e3a03000 	mov	r3, #0
3003f20c:	e58d30f4 	str	r3, [sp, #244]	; 0xf4
3003f210:	ea000053 	b	3003f364 <Granule_imdct+0x1c5c>
		{
            sum = X[0];
3003f214:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f218:	e5933000 	ldr	r3, [r3]
3003f21c:	e58d3108 	str	r3, [sp, #264]	; 0x108
			sum2 = X[1];
3003f220:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f224:	e2833004 	add	r3, r3, #4
3003f228:	e5933000 	ldr	r3, [r3]
3003f22c:	e58d310c 	str	r3, [sp, #268]	; 0x10c
			for(l = 0, k = 0; l < 16; l += 2, k++) 
3003f230:	e3a03000 	mov	r3, #0
3003f234:	e58d30fc 	str	r3, [sp, #252]	; 0xfc
3003f238:	e3a03000 	mov	r3, #0
3003f23c:	e58d30f8 	str	r3, [sp, #248]	; 0xf8
3003f240:	ea00002b 	b	3003f2f4 <Granule_imdct+0x1bec>
			{
			    s = Granule_9x9_idct[j+k];
3003f244:	e59d20f4 	ldr	r2, [sp, #244]	; 0xf4
3003f248:	e59d30f8 	ldr	r3, [sp, #248]	; 0xf8
3003f24c:	e0822003 	add	r2, r2, r3
3003f250:	e51f3e2c 	ldr	r3, [pc, #-3628]	; 3003e42c <Granule_imdct+0xd24>
3003f254:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3003f258:	e58d3114 	str	r3, [sp, #276]	; 0x114
			    sum = sum + (X[2+l]*s)/1024;
3003f25c:	e59d30fc 	ldr	r3, [sp, #252]	; 0xfc
3003f260:	e2833002 	add	r3, r3, #2
3003f264:	e1a02103 	lsl	r2, r3, #2
3003f268:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f26c:	e0823003 	add	r3, r2, r3
3003f270:	e5933000 	ldr	r3, [r3]
3003f274:	e59d2114 	ldr	r2, [sp, #276]	; 0x114
3003f278:	e0030392 	mul	r3, r2, r3
3003f27c:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003f280:	e2822003 	add	r2, r2, #3
3003f284:	e3530000 	cmp	r3, #0
3003f288:	b1a03002 	movlt	r3, r2
3003f28c:	e1a03543 	asr	r3, r3, #10
3003f290:	e59d2108 	ldr	r2, [sp, #264]	; 0x108
3003f294:	e0823003 	add	r3, r2, r3
3003f298:	e58d3108 	str	r3, [sp, #264]	; 0x108
			    sum2 = sum2 + (X[3+l]*s)/1024;
3003f29c:	e59d30fc 	ldr	r3, [sp, #252]	; 0xfc
3003f2a0:	e2833003 	add	r3, r3, #3
3003f2a4:	e1a02103 	lsl	r2, r3, #2
3003f2a8:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f2ac:	e0823003 	add	r3, r2, r3
3003f2b0:	e5933000 	ldr	r3, [r3]
3003f2b4:	e59d2114 	ldr	r2, [sp, #276]	; 0x114
3003f2b8:	e0030392 	mul	r3, r2, r3
3003f2bc:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003f2c0:	e2822003 	add	r2, r2, #3
3003f2c4:	e3530000 	cmp	r3, #0
3003f2c8:	b1a03002 	movlt	r3, r2
3003f2cc:	e1a03543 	asr	r3, r3, #10
3003f2d0:	e59d210c 	ldr	r2, [sp, #268]	; 0x10c
3003f2d4:	e0823003 	add	r3, r2, r3
3003f2d8:	e58d310c 	str	r3, [sp, #268]	; 0x10c

	    for(i = 0, j = 0; i < 9; i++, j += 8)
		{
            sum = X[0];
			sum2 = X[1];
			for(l = 0, k = 0; l < 16; l += 2, k++) 
3003f2dc:	e59d30fc 	ldr	r3, [sp, #252]	; 0xfc
3003f2e0:	e2833002 	add	r3, r3, #2
3003f2e4:	e58d30fc 	str	r3, [sp, #252]	; 0xfc
3003f2e8:	e59d30f8 	ldr	r3, [sp, #248]	; 0xf8
3003f2ec:	e2833001 	add	r3, r3, #1
3003f2f0:	e58d30f8 	str	r3, [sp, #248]	; 0xf8
3003f2f4:	e59d30fc 	ldr	r3, [sp, #252]	; 0xfc
3003f2f8:	e353000f 	cmp	r3, #15
3003f2fc:	daffffd0 	ble	3003f244 <Granule_imdct+0x1b3c>
			{
			    s = Granule_9x9_idct[j+k];
			    sum = sum + (X[2+l]*s)/1024;
			    sum2 = sum2 + (X[3+l]*s)/1024;
			}
			t[i] = sum;
3003f300:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003f304:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
3003f308:	e1a03b43 	asr	r3, r3, #22
3003f30c:	e1a02102 	lsl	r2, r2, #2
3003f310:	e28d1f4e 	add	r1, sp, #312	; 0x138
3003f314:	e0822001 	add	r2, r2, r1
3003f318:	e0823003 	add	r3, r2, r3
3003f31c:	e59d2108 	ldr	r2, [sp, #264]	; 0x108
3003f320:	e5832000 	str	r2, [r3]
			t[17-i] = sum2;
3003f324:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f328:	e2632011 	rsb	r2, r3, #17
3003f32c:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
3003f330:	e1a03b43 	asr	r3, r3, #22
3003f334:	e1a02102 	lsl	r2, r2, #2
3003f338:	e28dcf4e 	add	ip, sp, #312	; 0x138
3003f33c:	e082200c 	add	r2, r2, ip
3003f340:	e0823003 	add	r3, r2, r3
3003f344:	e59d210c 	ldr	r2, [sp, #268]	; 0x10c
3003f348:	e5832000 	str	r2, [r3]
	    X[9] += X[7];
	    X[7] += X[5];
	    X[5] += X[3];
	    X[3] += X[1];

	    for(i = 0, j = 0; i < 9; i++, j += 8)
3003f34c:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f350:	e2833001 	add	r3, r3, #1
3003f354:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003f358:	e59d30f4 	ldr	r3, [sp, #244]	; 0xf4
3003f35c:	e2833008 	add	r3, r3, #8
3003f360:	e58d30f4 	str	r3, [sp, #244]	; 0xf4
3003f364:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f368:	e3530008 	cmp	r3, #8
3003f36c:	daffffa8 	ble	3003f214 <Granule_imdct+0x1b0c>
			}
			t[i] = sum;
			t[17-i] = sum2;
	    }

	    twid = Granule_twiddles_normal;
3003f370:	e51f3f48 	ldr	r3, [pc, #-3912]	; 3003e430 <Granule_imdct+0xd28>
3003f374:	e58d3120 	str	r3, [sp, #288]	; 0x120
	    
	    for(i = 0; i < 9; i++)
3003f378:	e3a03000 	mov	r3, #0
3003f37c:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003f380:	ea000020 	b	3003f408 <Granule_imdct+0x1d00>
		  t[9+i] =  (t[9+i]*twid[i])/1024;
3003f384:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f388:	e2831009 	add	r1, r3, #9
3003f38c:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f390:	e2832009 	add	r2, r3, #9
3003f394:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
3003f398:	e1a03b43 	asr	r3, r3, #22
3003f39c:	e1a02102 	lsl	r2, r2, #2
3003f3a0:	e28d0f4e 	add	r0, sp, #312	; 0x138
3003f3a4:	e0822000 	add	r2, r2, r0
3003f3a8:	e0823003 	add	r3, r2, r3
3003f3ac:	e5933000 	ldr	r3, [r3]
3003f3b0:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003f3b4:	e1a00102 	lsl	r0, r2, #2
3003f3b8:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003f3bc:	e0802002 	add	r2, r0, r2
3003f3c0:	e5922000 	ldr	r2, [r2]
3003f3c4:	e0030392 	mul	r3, r2, r3
3003f3c8:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003f3cc:	e2822003 	add	r2, r2, #3
3003f3d0:	e3530000 	cmp	r3, #0
3003f3d4:	b1a03002 	movlt	r3, r2
3003f3d8:	e1a03543 	asr	r3, r3, #10
3003f3dc:	e1a02003 	mov	r2, r3
3003f3e0:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
3003f3e4:	e1a03b43 	asr	r3, r3, #22
3003f3e8:	e1a01101 	lsl	r1, r1, #2
3003f3ec:	e28dcf4e 	add	ip, sp, #312	; 0x138
3003f3f0:	e081100c 	add	r1, r1, ip
3003f3f4:	e0813003 	add	r3, r1, r3
3003f3f8:	e5832000 	str	r2, [r3]
			t[17-i] = sum2;
	    }

	    twid = Granule_twiddles_normal;
	    
	    for(i = 0; i < 9; i++)
3003f3fc:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f400:	e2833001 	add	r3, r3, #1
3003f404:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003f408:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f40c:	e3530008 	cmp	r3, #8
3003f410:	daffffdb 	ble	3003f384 <Granule_imdct+0x1c7c>
		  t[9+i] =  (t[9+i]*twid[i])/1024;

	    for(i = 0; i < 9; i++) 
3003f414:	e3a03000 	mov	r3, #0
3003f418:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003f41c:	ea000039 	b	3003f508 <Granule_imdct+0x1e00>
		{
  		  save = t[i];
3003f420:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003f424:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
3003f428:	e1a03b43 	asr	r3, r3, #22
3003f42c:	e1a02102 	lsl	r2, r2, #2
3003f430:	e28d0f4e 	add	r0, sp, #312	; 0x138
3003f434:	e0822000 	add	r2, r2, r0
3003f438:	e0823003 	add	r3, r2, r3
3003f43c:	e5933000 	ldr	r3, [r3]
3003f440:	e58d3104 	str	r3, [sp, #260]	; 0x104
		  t[i] += t[17-i];
3003f444:	e59d10f0 	ldr	r1, [sp, #240]	; 0xf0
3003f448:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003f44c:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
3003f450:	e1a03b43 	asr	r3, r3, #22
3003f454:	e1a02102 	lsl	r2, r2, #2
3003f458:	e28dcf4e 	add	ip, sp, #312	; 0x138
3003f45c:	e082200c 	add	r2, r2, ip
3003f460:	e0823003 	add	r3, r2, r3
3003f464:	e5932000 	ldr	r2, [r3]
3003f468:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f46c:	e2630011 	rsb	r0, r3, #17
3003f470:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
3003f474:	e1a03b43 	asr	r3, r3, #22
3003f478:	e1a00100 	lsl	r0, r0, #2
3003f47c:	e28dcf4e 	add	ip, sp, #312	; 0x138
3003f480:	e080000c 	add	r0, r0, ip
3003f484:	e0803003 	add	r3, r0, r3
3003f488:	e5933000 	ldr	r3, [r3]
3003f48c:	e0822003 	add	r2, r2, r3
3003f490:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
3003f494:	e1a03b43 	asr	r3, r3, #22
3003f498:	e1a01101 	lsl	r1, r1, #2
3003f49c:	e28d0f4e 	add	r0, sp, #312	; 0x138
3003f4a0:	e0811000 	add	r1, r1, r0
3003f4a4:	e0813003 	add	r3, r1, r3
3003f4a8:	e5832000 	str	r2, [r3]
		  t[17-i] = save - t[17-i];
3003f4ac:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f4b0:	e2631011 	rsb	r1, r3, #17
3003f4b4:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f4b8:	e2632011 	rsb	r2, r3, #17
3003f4bc:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
3003f4c0:	e1a03b43 	asr	r3, r3, #22
3003f4c4:	e1a02102 	lsl	r2, r2, #2
3003f4c8:	e28dcf4e 	add	ip, sp, #312	; 0x138
3003f4cc:	e082200c 	add	r2, r2, ip
3003f4d0:	e0823003 	add	r3, r2, r3
3003f4d4:	e5933000 	ldr	r3, [r3]
3003f4d8:	e59d2104 	ldr	r2, [sp, #260]	; 0x104
3003f4dc:	e0632002 	rsb	r2, r3, r2
3003f4e0:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
3003f4e4:	e1a03b43 	asr	r3, r3, #22
3003f4e8:	e1a01101 	lsl	r1, r1, #2
3003f4ec:	e28d0f4e 	add	r0, sp, #312	; 0x138
3003f4f0:	e0811000 	add	r1, r1, r0
3003f4f4:	e0813003 	add	r3, r1, r3
3003f4f8:	e5832000 	str	r2, [r3]
	    twid = Granule_twiddles_normal;
	    
	    for(i = 0; i < 9; i++)
		  t[9+i] =  (t[9+i]*twid[i])/1024;

	    for(i = 0; i < 9; i++) 
3003f4fc:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f500:	e2833001 	add	r3, r3, #1
3003f504:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003f508:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f50c:	e3530008 	cmp	r3, #8
3003f510:	daffffc2 	ble	3003f420 <Granule_imdct+0x1d18>
  		  save = t[i];
		  t[i] += t[17-i];
		  t[17-i] = save - t[17-i];
	    }

	    for(i = 0; i < 18; i++)
3003f514:	e3a03000 	mov	r3, #0
3003f518:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003f51c:	ea00001f 	b	3003f5a0 <Granule_imdct+0x1e98>
		  t[i] =  (t[i]*twid[9+i])/1024;
3003f520:	e59d10f0 	ldr	r1, [sp, #240]	; 0xf0
3003f524:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003f528:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
3003f52c:	e1a03b43 	asr	r3, r3, #22
3003f530:	e1a02102 	lsl	r2, r2, #2
3003f534:	e28dcf4e 	add	ip, sp, #312	; 0x138
3003f538:	e082200c 	add	r2, r2, ip
3003f53c:	e0823003 	add	r3, r2, r3
3003f540:	e5933000 	ldr	r3, [r3]
3003f544:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003f548:	e2822009 	add	r2, r2, #9
3003f54c:	e1a00102 	lsl	r0, r2, #2
3003f550:	e59d2120 	ldr	r2, [sp, #288]	; 0x120
3003f554:	e0802002 	add	r2, r0, r2
3003f558:	e5922000 	ldr	r2, [r2]
3003f55c:	e0030392 	mul	r3, r2, r3
3003f560:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003f564:	e2822003 	add	r2, r2, #3
3003f568:	e3530000 	cmp	r3, #0
3003f56c:	b1a03002 	movlt	r3, r2
3003f570:	e1a03543 	asr	r3, r3, #10
3003f574:	e1a02003 	mov	r2, r3
3003f578:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
3003f57c:	e1a03b43 	asr	r3, r3, #22
3003f580:	e1a01101 	lsl	r1, r1, #2
3003f584:	e28d0f4e 	add	r0, sp, #312	; 0x138
3003f588:	e0811000 	add	r1, r1, r0
3003f58c:	e0813003 	add	r3, r1, r3
3003f590:	e5832000 	str	r2, [r3]
  		  save = t[i];
		  t[i] += t[17-i];
		  t[17-i] = save - t[17-i];
	    }

	    for(i = 0; i < 18; i++)
3003f594:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f598:	e2833001 	add	r3, r3, #1
3003f59c:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003f5a0:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f5a4:	e3530011 	cmp	r3, #17
3003f5a8:	daffffdc 	ble	3003f520 <Granule_imdct+0x1e18>
		  t[i] =  (t[i]*twid[9+i])/1024;
	    /* correct the transform into the 18x36 IMDCT we need */
	    /* 36 muls */

	    for(i = 0; i < 9; i++)
3003f5ac:	e3a03000 	mov	r3, #0
3003f5b0:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003f5b4:	ea00008c 	b	3003f7ec <Granule_imdct+0x20e4>
		{
		  x[i] = -(t[i+9] * Granule_imdct_win[gr->block_type][i])/1024;
3003f5b8:	e59d10f0 	ldr	r1, [sp, #240]	; 0xf0
3003f5bc:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f5c0:	e2832009 	add	r2, r3, #9
3003f5c4:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
3003f5c8:	e1a03b43 	asr	r3, r3, #22
3003f5cc:	e1a02102 	lsl	r2, r2, #2
3003f5d0:	e28dcf4e 	add	ip, sp, #312	; 0x138
3003f5d4:	e082200c 	add	r2, r2, ip
3003f5d8:	e0823003 	add	r3, r2, r3
3003f5dc:	e5930000 	ldr	r0, [r3]
3003f5e0:	e59d300c 	ldr	r3, [sp, #12]
3003f5e4:	e5932014 	ldr	r2, [r3, #20]
3003f5e8:	e59d40f0 	ldr	r4, [sp, #240]	; 0xf0
3003f5ec:	e59fc2bc 	ldr	ip, [pc, #700]	; 3003f8b0 <Granule_imdct+0x21a8>
3003f5f0:	e1a03002 	mov	r3, r2
3003f5f4:	e1a03183 	lsl	r3, r3, #3
3003f5f8:	e0833002 	add	r3, r3, r2
3003f5fc:	e1a03103 	lsl	r3, r3, #2
3003f600:	e0833004 	add	r3, r3, r4
3003f604:	e79c3103 	ldr	r3, [ip, r3, lsl #2]
3003f608:	e0030390 	mul	r3, r0, r3
3003f60c:	e2633000 	rsb	r3, r3, #0
3003f610:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003f614:	e2822003 	add	r2, r2, #3
3003f618:	e3530000 	cmp	r3, #0
3003f61c:	b1a03002 	movlt	r3, r2
3003f620:	e1a03543 	asr	r3, r3, #10
3003f624:	e1a02003 	mov	r2, r3
3003f628:	e3e030db 	mvn	r3, #219	; 0xdb
3003f62c:	e1a01101 	lsl	r1, r1, #2
3003f630:	e28d0f4e 	add	r0, sp, #312	; 0x138
3003f634:	e0811000 	add	r1, r1, r0
3003f638:	e0813003 	add	r3, r1, r3
3003f63c:	e5832000 	str	r2, [r3]
		  x[i+9] = (t[17-i] * Granule_imdct_win[gr->block_type][i+9])/1024;
3003f640:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f644:	e2831009 	add	r1, r3, #9
3003f648:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f64c:	e2632011 	rsb	r2, r3, #17
3003f650:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
3003f654:	e1a03b43 	asr	r3, r3, #22
3003f658:	e1a02102 	lsl	r2, r2, #2
3003f65c:	e28dcf4e 	add	ip, sp, #312	; 0x138
3003f660:	e082200c 	add	r2, r2, ip
3003f664:	e0823003 	add	r3, r2, r3
3003f668:	e5930000 	ldr	r0, [r3]
3003f66c:	e59d300c 	ldr	r3, [sp, #12]
3003f670:	e5932014 	ldr	r2, [r3, #20]
3003f674:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f678:	e2834009 	add	r4, r3, #9
3003f67c:	e59fc22c 	ldr	ip, [pc, #556]	; 3003f8b0 <Granule_imdct+0x21a8>
3003f680:	e1a03002 	mov	r3, r2
3003f684:	e1a03183 	lsl	r3, r3, #3
3003f688:	e0833002 	add	r3, r3, r2
3003f68c:	e1a03103 	lsl	r3, r3, #2
3003f690:	e0833004 	add	r3, r3, r4
3003f694:	e79c3103 	ldr	r3, [ip, r3, lsl #2]
3003f698:	e0030390 	mul	r3, r0, r3
3003f69c:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003f6a0:	e2822003 	add	r2, r2, #3
3003f6a4:	e3530000 	cmp	r3, #0
3003f6a8:	b1a03002 	movlt	r3, r2
3003f6ac:	e1a03543 	asr	r3, r3, #10
3003f6b0:	e1a02003 	mov	r2, r3
3003f6b4:	e3e030db 	mvn	r3, #219	; 0xdb
3003f6b8:	e1a01101 	lsl	r1, r1, #2
3003f6bc:	e28d0f4e 	add	r0, sp, #312	; 0x138
3003f6c0:	e0811000 	add	r1, r1, r0
3003f6c4:	e0813003 	add	r3, r1, r3
3003f6c8:	e5832000 	str	r2, [r3]
		  x[i+18] = (t[8-i] * Granule_imdct_win[gr->block_type][i+18])/1024;
3003f6cc:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f6d0:	e2831012 	add	r1, r3, #18
3003f6d4:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f6d8:	e2632008 	rsb	r2, r3, #8
3003f6dc:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
3003f6e0:	e1a03b43 	asr	r3, r3, #22
3003f6e4:	e1a02102 	lsl	r2, r2, #2
3003f6e8:	e28dcf4e 	add	ip, sp, #312	; 0x138
3003f6ec:	e082200c 	add	r2, r2, ip
3003f6f0:	e0823003 	add	r3, r2, r3
3003f6f4:	e5930000 	ldr	r0, [r3]
3003f6f8:	e59d300c 	ldr	r3, [sp, #12]
3003f6fc:	e5932014 	ldr	r2, [r3, #20]
3003f700:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f704:	e2834012 	add	r4, r3, #18
3003f708:	e59fc1a0 	ldr	ip, [pc, #416]	; 3003f8b0 <Granule_imdct+0x21a8>
3003f70c:	e1a03002 	mov	r3, r2
3003f710:	e1a03183 	lsl	r3, r3, #3
3003f714:	e0833002 	add	r3, r3, r2
3003f718:	e1a03103 	lsl	r3, r3, #2
3003f71c:	e0833004 	add	r3, r3, r4
3003f720:	e79c3103 	ldr	r3, [ip, r3, lsl #2]
3003f724:	e0030390 	mul	r3, r0, r3
3003f728:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003f72c:	e2822003 	add	r2, r2, #3
3003f730:	e3530000 	cmp	r3, #0
3003f734:	b1a03002 	movlt	r3, r2
3003f738:	e1a03543 	asr	r3, r3, #10
3003f73c:	e1a02003 	mov	r2, r3
3003f740:	e3e030db 	mvn	r3, #219	; 0xdb
3003f744:	e1a01101 	lsl	r1, r1, #2
3003f748:	e28d0f4e 	add	r0, sp, #312	; 0x138
3003f74c:	e0811000 	add	r1, r1, r0
3003f750:	e0813003 	add	r3, r1, r3
3003f754:	e5832000 	str	r2, [r3]
		  x[i+27] = (t[i] * Granule_imdct_win[gr->block_type][i+27])/1024;
3003f758:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f75c:	e283101b 	add	r1, r3, #27
3003f760:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003f764:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
3003f768:	e1a03b43 	asr	r3, r3, #22
3003f76c:	e1a02102 	lsl	r2, r2, #2
3003f770:	e28dcf4e 	add	ip, sp, #312	; 0x138
3003f774:	e082200c 	add	r2, r2, ip
3003f778:	e0823003 	add	r3, r2, r3
3003f77c:	e5930000 	ldr	r0, [r3]
3003f780:	e59d300c 	ldr	r3, [sp, #12]
3003f784:	e5932014 	ldr	r2, [r3, #20]
3003f788:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f78c:	e283401b 	add	r4, r3, #27
3003f790:	e59fc118 	ldr	ip, [pc, #280]	; 3003f8b0 <Granule_imdct+0x21a8>
3003f794:	e1a03002 	mov	r3, r2
3003f798:	e1a03183 	lsl	r3, r3, #3
3003f79c:	e0833002 	add	r3, r3, r2
3003f7a0:	e1a03103 	lsl	r3, r3, #2
3003f7a4:	e0833004 	add	r3, r3, r4
3003f7a8:	e79c3103 	ldr	r3, [ip, r3, lsl #2]
3003f7ac:	e0030390 	mul	r3, r0, r3
3003f7b0:	e2832fff 	add	r2, r3, #1020	; 0x3fc
3003f7b4:	e2822003 	add	r2, r2, #3
3003f7b8:	e3530000 	cmp	r3, #0
3003f7bc:	b1a03002 	movlt	r3, r2
3003f7c0:	e1a03543 	asr	r3, r3, #10
3003f7c4:	e1a02003 	mov	r2, r3
3003f7c8:	e3e030db 	mvn	r3, #219	; 0xdb
3003f7cc:	e1a01101 	lsl	r1, r1, #2
3003f7d0:	e28d0f4e 	add	r0, sp, #312	; 0x138
3003f7d4:	e0811000 	add	r1, r1, r0
3003f7d8:	e0813003 	add	r3, r1, r3
3003f7dc:	e5832000 	str	r2, [r3]
	    for(i = 0; i < 18; i++)
		  t[i] =  (t[i]*twid[9+i])/1024;
	    /* correct the transform into the 18x36 IMDCT we need */
	    /* 36 muls */

	    for(i = 0; i < 9; i++)
3003f7e0:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f7e4:	e2833001 	add	r3, r3, #1
3003f7e8:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003f7ec:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f7f0:	e3530008 	cmp	r3, #8
3003f7f4:	daffff6f 	ble	3003f5b8 <Granule_imdct+0x1eb0>
	    }

	}
	
	/* Overlap and add with previous block */
  	    for(i = 0; i < 18; i++) 
3003f7f8:	e3a03000 	mov	r3, #0
3003f7fc:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003f800:	ea00001e 	b	3003f880 <Granule_imdct+0x2178>
		{
	      *(X++) = x[i] + *prev;  /* produce an output value */
3003f804:	e59d20f0 	ldr	r2, [sp, #240]	; 0xf0
3003f808:	e3e030db 	mvn	r3, #219	; 0xdb
3003f80c:	e1a02102 	lsl	r2, r2, #2
3003f810:	e28d1f4e 	add	r1, sp, #312	; 0x138
3003f814:	e0822001 	add	r2, r2, r1
3003f818:	e0823003 	add	r3, r2, r3
3003f81c:	e5932000 	ldr	r2, [r3]
3003f820:	e59d3118 	ldr	r3, [sp, #280]	; 0x118
3003f824:	e5933000 	ldr	r3, [r3]
3003f828:	e0822003 	add	r2, r2, r3
3003f82c:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f830:	e5832000 	str	r2, [r3]
3003f834:	e59d3124 	ldr	r3, [sp, #292]	; 0x124
3003f838:	e2833004 	add	r3, r3, #4
3003f83c:	e58d3124 	str	r3, [sp, #292]	; 0x124
	      *(prev++) = x[i+18]; 
3003f840:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f844:	e2832012 	add	r2, r3, #18
3003f848:	e3e030db 	mvn	r3, #219	; 0xdb
3003f84c:	e1a02102 	lsl	r2, r2, #2
3003f850:	e28dcf4e 	add	ip, sp, #312	; 0x138
3003f854:	e082200c 	add	r2, r2, ip
3003f858:	e0823003 	add	r3, r2, r3
3003f85c:	e5932000 	ldr	r2, [r3]
3003f860:	e59d3118 	ldr	r3, [sp, #280]	; 0x118
3003f864:	e5832000 	str	r2, [r3]
3003f868:	e59d3118 	ldr	r3, [sp, #280]	; 0x118
3003f86c:	e2833004 	add	r3, r3, #4
3003f870:	e58d3118 	str	r3, [sp, #280]	; 0x118
	    }

	}
	
	/* Overlap and add with previous block */
  	    for(i = 0; i < 18; i++) 
3003f874:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f878:	e2833001 	add	r3, r3, #1
3003f87c:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
3003f880:	e59d30f0 	ldr	r3, [sp, #240]	; 0xf0
3003f884:	e3530011 	cmp	r3, #17
3003f888:	daffffdd 	ble	3003f804 <Granule_imdct+0x20fc>
	
	prev = Granule_imdct_previous[ch];

    /* process each subband */

    for(sb = 0; sb < SBLIMIT; sb++)
3003f88c:	e59d30ec 	ldr	r3, [sp, #236]	; 0xec
3003f890:	e2833001 	add	r3, r3, #1
3003f894:	e58d30ec 	str	r3, [sp, #236]	; 0xec
3003f898:	e59d30ec 	ldr	r3, [sp, #236]	; 0xec
3003f89c:	e353001f 	cmp	r3, #31
3003f8a0:	dafffab8 	ble	3003e388 <Granule_imdct+0xc80>
	      *(X++) = x[i] + *prev;  /* produce an output value */
	      *(prev++) = x[i+18]; 
		}
    }	
    
}
3003f8a4:	e28ddf4f 	add	sp, sp, #316	; 0x13c
3003f8a8:	e8bd4030 	pop	{r4, r5, lr}
3003f8ac:	e12fff1e 	bx	lr
3003f8b0:	300e8d80 	.word	0x300e8d80

3003f8b4 <Granule_freqinverse>:

void Granule_freqinverse(int X[SBLIMIT][SSLIMIT])
{
3003f8b4:	e24dd018 	sub	sp, sp, #24
3003f8b8:	e58d0004 	str	r0, [sp, #4]
    int sb, dct;
	int *x;
    x = &X[0][SSLIMIT];
3003f8bc:	e59d3004 	ldr	r3, [sp, #4]
3003f8c0:	e2833048 	add	r3, r3, #72	; 0x48
3003f8c4:	e58d3014 	str	r3, [sp, #20]
    for(sb = 1; sb < SBLIMIT; sb += 2) 
3003f8c8:	e3a03001 	mov	r3, #1
3003f8cc:	e58d300c 	str	r3, [sp, #12]
3003f8d0:	ea000019 	b	3003f93c <Granule_freqinverse+0x88>
	{
	  for(dct = 1; dct < SSLIMIT; dct += 2)
3003f8d4:	e3a03001 	mov	r3, #1
3003f8d8:	e58d3010 	str	r3, [sp, #16]
3003f8dc:	ea00000d 	b	3003f918 <Granule_freqinverse+0x64>
	    x[dct] = -x[dct];
3003f8e0:	e59d3010 	ldr	r3, [sp, #16]
3003f8e4:	e1a02103 	lsl	r2, r3, #2
3003f8e8:	e59d3014 	ldr	r3, [sp, #20]
3003f8ec:	e0823003 	add	r3, r2, r3
3003f8f0:	e59d2010 	ldr	r2, [sp, #16]
3003f8f4:	e1a01102 	lsl	r1, r2, #2
3003f8f8:	e59d2014 	ldr	r2, [sp, #20]
3003f8fc:	e0812002 	add	r2, r1, r2
3003f900:	e5922000 	ldr	r2, [r2]
3003f904:	e2622000 	rsb	r2, r2, #0
3003f908:	e5832000 	str	r2, [r3]
    int sb, dct;
	int *x;
    x = &X[0][SSLIMIT];
    for(sb = 1; sb < SBLIMIT; sb += 2) 
	{
	  for(dct = 1; dct < SSLIMIT; dct += 2)
3003f90c:	e59d3010 	ldr	r3, [sp, #16]
3003f910:	e2833002 	add	r3, r3, #2
3003f914:	e58d3010 	str	r3, [sp, #16]
3003f918:	e59d3010 	ldr	r3, [sp, #16]
3003f91c:	e3530011 	cmp	r3, #17
3003f920:	daffffee 	ble	3003f8e0 <Granule_freqinverse+0x2c>
	    x[dct] = -x[dct];
	  x = &x[2 * SSLIMIT];
3003f924:	e59d3014 	ldr	r3, [sp, #20]
3003f928:	e2833090 	add	r3, r3, #144	; 0x90
3003f92c:	e58d3014 	str	r3, [sp, #20]
void Granule_freqinverse(int X[SBLIMIT][SSLIMIT])
{
    int sb, dct;
	int *x;
    x = &X[0][SSLIMIT];
    for(sb = 1; sb < SBLIMIT; sb += 2) 
3003f930:	e59d300c 	ldr	r3, [sp, #12]
3003f934:	e2833002 	add	r3, r3, #2
3003f938:	e58d300c 	str	r3, [sp, #12]
3003f93c:	e59d300c 	ldr	r3, [sp, #12]
3003f940:	e353001f 	cmp	r3, #31
3003f944:	daffffe2 	ble	3003f8d4 <Granule_freqinverse+0x20>
	{
	  for(dct = 1; dct < SSLIMIT; dct += 2)
	    x[dct] = -x[dct];
	  x = &x[2 * SSLIMIT];
    }
}
3003f948:	e28dd018 	add	sp, sp, #24
3003f94c:	e12fff1e 	bx	lr

3003f950 <mp3_decoder>:
int mp3_fast_first = 1;
int mp3_fastsb_first = 1;
int mp3_freq = 44100;

void mp3_decoder(void)
{
3003f950:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3003f954:	e24ddd76 	sub	sp, sp, #7552	; 0x1d80
3003f958:	e24dd014 	sub	sp, sp, #20
	int i;
	int pcm_dma_buf_cur = 0;
3003f95c:	e3a03000 	mov	r3, #0
3003f960:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003f964:	e5813d64 	str	r3, [r1, #3428]	; 0xd64
	int   frameNum=0;
3003f968:	e3a03000 	mov	r3, #0
3003f96c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003f970:	e5823d68 	str	r3, [r2, #3432]	; 0xd68
	int first = 1;
3003f974:	e3a03001 	mov	r3, #1
3003f978:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003f97c:	e58c3d6c 	str	r3, [ip, #3436]	; 0xd6c
	III_side_info_t III_side_info;
	III_scalefac_t III_scalefac;
	int mp3_frame_first = 1;
3003f980:	e3a03001 	mov	r3, #1
3003f984:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003f988:	e58e3d70 	str	r3, [lr, #3440]	; 0xd70
	layer info;
	acoral_slice_policy_data_t data;
	data.cpu = 0;
3003f98c:	e3a03000 	mov	r3, #0
3003f990:	e28d1c1b 	add	r1, sp, #6912	; 0x1b00
3003f994:	e5c13010 	strb	r3, [r1, #16]
	data.prio = 25;
3003f998:	e3a03019 	mov	r3, #25
3003f99c:	e28d2c1b 	add	r2, sp, #6912	; 0x1b00
3003f9a0:	e5c23011 	strb	r3, [r2, #17]
	data.slice = 100;
3003f9a4:	e3a03064 	mov	r3, #100	; 0x64
3003f9a8:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003f9ac:	e58c3b14 	str	r3, [ip, #2836]	; 0xb14
	//int first = 1;
	mp3_first = 1;
3003f9b0:	e59f39d8 	ldr	r3, [pc, #2520]	; 30040390 <mp3_decoder+0xa40>
3003f9b4:	e3a02001 	mov	r2, #1
3003f9b8:	e5832000 	str	r2, [r3]
	mp3_fast_first = 1;
3003f9bc:	e59f39d0 	ldr	r3, [pc, #2512]	; 30040394 <mp3_decoder+0xa44>
3003f9c0:	e3a02001 	mov	r2, #1
3003f9c4:	e5832000 	str	r2, [r3]
	mp3_fastsb_first = 1;
3003f9c8:	e59f39c8 	ldr	r3, [pc, #2504]	; 30040398 <mp3_decoder+0xa48>
3003f9cc:	e3a02001 	mov	r2, #1
3003f9d0:	e5832000 	str	r2, [r3]

	//mp3_dat = acoral_open("2.mp3", O_RDWR);
	fr_ps.header = &info; 
3003f9d4:	e59f39c0 	ldr	r3, [pc, #2496]	; 3004039c <mp3_decoder+0xa4c>
3003f9d8:	e28d2c1b 	add	r2, sp, #6912	; 0x1b00
3003f9dc:	e2822018 	add	r2, r2, #24
3003f9e0:	e5832000 	str	r2, [r3]
    open_bit_stream_r();
3003f9e4:	ebffd8cb 	bl	30035d18 <open_bit_stream_r>
    //frameNum=0;
    totpos=0;
3003f9e8:	e59f39b0 	ldr	r3, [pc, #2480]	; 300403a0 <mp3_decoder+0xa50>
3003f9ec:	e3a02000 	mov	r2, #0
3003f9f0:	e5832000 	str	r2, [r3]
    buf_byte_idx=0;
3003f9f4:	e59f39a8 	ldr	r3, [pc, #2472]	; 300403a4 <mp3_decoder+0xa54>
3003f9f8:	e3a02000 	mov	r2, #0
3003f9fc:	e5832000 	str	r2, [r3]
    i = 0;
3003fa00:	e3a03000 	mov	r3, #0
3003fa04:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003fa08:	e58e3d60 	str	r3, [lr, #3424]	; 0xd60

    acoral_print("start ~\n");
3003fa0c:	e59f0994 	ldr	r0, [pc, #2452]	; 300403a8 <mp3_decoder+0xa58>
3003fa10:	ebff2e0a 	bl	3000b240 <acoral_print>
    //pcm_player_id = acoral_create_thread(mp3_pcm_player,8192*16,NULL,"pcm_player",20,0);

    while(!bs.eobs) {
3003fa14:	ea000251 	b	30040360 <mp3_decoder+0xa10>
next_frame:
		if (!seek_sync(SYNC_WORD)) {
3003fa18:	e3a00eff 	mov	r0, #4080	; 0xff0
3003fa1c:	e280000f 	add	r0, r0, #15
3003fa20:	ebffd8d9 	bl	30035d8c <seek_sync>
3003fa24:	e1a03000 	mov	r3, r0
3003fa28:	e3530000 	cmp	r3, #0
3003fa2c:	0a000250 	beq	30040374 <mp3_decoder+0xa24>
//			printf("\nFrame cannot be located\n");
			break;
		}
		if(frameNum < 30) {
3003fa30:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003fa34:	e5913d68 	ldr	r3, [r1, #3432]	; 0xd68
3003fa38:	e353001d 	cmp	r3, #29
3003fa3c:	ca000005 	bgt	3003fa58 <mp3_decoder+0x108>
			frameNum ++;
3003fa40:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003fa44:	e5923d68 	ldr	r3, [r2, #3432]	; 0xd68
3003fa48:	e2833001 	add	r3, r3, #1
3003fa4c:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003fa50:	e58c3d68 	str	r3, [ip, #3432]	; 0xd68
			goto next_frame;
3003fa54:	eaffffef 	b	3003fa18 <mp3_decoder+0xc8>
		}

		decode_info( );
3003fa58:	ebffdf7a 	bl	30037848 <decode_info>

		hdr_to_frps();
3003fa5c:	ebffd90a 	bl	30035e8c <hdr_to_frps>

		acoral_print("f1 :%d\n", frameNum);
3003fa60:	e59f0944 	ldr	r0, [pc, #2372]	; 300403ac <mp3_decoder+0xa5c>
3003fa64:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003fa68:	e59e1d68 	ldr	r1, [lr, #3432]	; 0xd68
3003fa6c:	ebff2df3 	bl	3000b240 <acoral_print>
        frameNum++;
3003fa70:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003fa74:	e5913d68 	ldr	r3, [r1, #3432]	; 0xd68
3003fa78:	e2833001 	add	r3, r3, #1
3003fa7c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003fa80:	e5823d68 	str	r3, [r2, #3432]	; 0xd68

		if (info.error_protection)
3003fa84:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003fa88:	e59c3b20 	ldr	r3, [ip, #2848]	; 0xb20
3003fa8c:	e3530000 	cmp	r3, #0
3003fa90:	0a000000 	beq	3003fa98 <mp3_decoder+0x148>
			buffer_CRC();
3003fa94:	ebfff15a 	bl	3003c004 <buffer_CRC>
		switch (info.lay) {
3003fa98:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003fa9c:	e59e3b1c 	ldr	r3, [lr, #2844]	; 0xb1c
3003faa0:	e3530003 	cmp	r3, #3
3003faa4:	1a00022b 	bne	30040358 <mp3_decoder+0xa08>
		{
			int nSlots, main_data_end, flush_main;
			int bytes_to_discard, gr, ch;

			static int frame_start = 0;
			if(mp3_frame_first) {
3003faa8:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003faac:	e5913d70 	ldr	r3, [r1, #3440]	; 0xd70
3003fab0:	e3530000 	cmp	r3, #0
3003fab4:	0a000024 	beq	3003fb4c <mp3_decoder+0x1fc>
				mp3_frame_first = 0;
3003fab8:	e3a03000 	mov	r3, #0
3003fabc:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003fac0:	e5823d70 	str	r3, [r2, #3440]	; 0xd70
				buf_bit_idx = 8;
3003fac4:	e59f38e4 	ldr	r3, [pc, #2276]	; 300403b0 <mp3_decoder+0xa60>
3003fac8:	e3a02008 	mov	r2, #8
3003facc:	e5832000 	str	r2, [r3]
				frame_start = 0;
3003fad0:	e59f38dc 	ldr	r3, [pc, #2268]	; 300403b4 <mp3_decoder+0xa64>
3003fad4:	e3a02000 	mov	r2, #0
3003fad8:	e5832000 	str	r2, [r3]
				offset = 0;
3003fadc:	e59f38d4 	ldr	r3, [pc, #2260]	; 300403b8 <mp3_decoder+0xa68>
3003fae0:	e3a02000 	mov	r2, #0
3003fae4:	e5832000 	str	r2, [r3]
				if(info.sampling_frequency == 0)
3003fae8:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003faec:	e59c3b28 	ldr	r3, [ip, #2856]	; 0xb28
3003faf0:	e3530000 	cmp	r3, #0
3003faf4:	1a000004 	bne	3003fb0c <mp3_decoder+0x1bc>
					mp3_freq = 44100;
3003faf8:	e59f28bc 	ldr	r2, [pc, #2236]	; 300403bc <mp3_decoder+0xa6c>
3003fafc:	e3a03b2b 	mov	r3, #44032	; 0xac00
3003fb00:	e2833044 	add	r3, r3, #68	; 0x44
3003fb04:	e5823000 	str	r3, [r2]
3003fb08:	ea00000f 	b	3003fb4c <mp3_decoder+0x1fc>
				else if(info.sampling_frequency == 1)
3003fb0c:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003fb10:	e59e3b28 	ldr	r3, [lr, #2856]	; 0xb28
3003fb14:	e3530001 	cmp	r3, #1
3003fb18:	1a000004 	bne	3003fb30 <mp3_decoder+0x1e0>
					mp3_freq = 48000;
3003fb1c:	e59f2898 	ldr	r2, [pc, #2200]	; 300403bc <mp3_decoder+0xa6c>
3003fb20:	e3a03cbb 	mov	r3, #47872	; 0xbb00
3003fb24:	e2833080 	add	r3, r3, #128	; 0x80
3003fb28:	e5823000 	str	r3, [r2]
3003fb2c:	ea000006 	b	3003fb4c <mp3_decoder+0x1fc>
				else if(info.sampling_frequency == 2)
3003fb30:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003fb34:	e5913b28 	ldr	r3, [r1, #2856]	; 0xb28
3003fb38:	e3530002 	cmp	r3, #2
3003fb3c:	1a000002 	bne	3003fb4c <mp3_decoder+0x1fc>
					mp3_freq = 32000;
3003fb40:	e59f3874 	ldr	r3, [pc, #2164]	; 300403bc <mp3_decoder+0xa6c>
3003fb44:	e3a02c7d 	mov	r2, #32000	; 0x7d00
3003fb48:	e5832000 	str	r2, [r3]
			}

			III_get_side_info(&III_side_info);
3003fb4c:	e28d3c1d 	add	r3, sp, #7424	; 0x1d00
3003fb50:	e2833038 	add	r3, r3, #56	; 0x38
3003fb54:	e1a00003 	mov	r0, r3
3003fb58:	ebffdf8e 	bl	30037998 <III_get_side_info>
			nSlots = main_data_slots();
3003fb5c:	ebfff12d 	bl	3003c018 <main_data_slots>
3003fb60:	e1a03000 	mov	r3, r0
3003fb64:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003fb68:	e5823d74 	str	r3, [r2, #3444]	; 0xd74

			for (; nSlots > 0; nSlots--)  /* read main data. */
3003fb6c:	ea00000a 	b	3003fb9c <mp3_decoder+0x24c>
				hputbuf((unsigned char) getbit(8));
3003fb70:	e3a00008 	mov	r0, #8
3003fb74:	ebffd8f0 	bl	30035f3c <getbit>
3003fb78:	e1a03000 	mov	r3, r0
3003fb7c:	e20330ff 	and	r3, r3, #255	; 0xff
3003fb80:	e1a00003 	mov	r0, r3
3003fb84:	ebffde8d 	bl	300375c0 <hputbuf>
			}

			III_get_side_info(&III_side_info);
			nSlots = main_data_slots();

			for (; nSlots > 0; nSlots--)  /* read main data. */
3003fb88:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003fb8c:	e59c3d74 	ldr	r3, [ip, #3444]	; 0xd74
3003fb90:	e2433001 	sub	r3, r3, #1
3003fb94:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003fb98:	e58e3d74 	str	r3, [lr, #3444]	; 0xd74
3003fb9c:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003fba0:	e5913d74 	ldr	r3, [r1, #3444]	; 0xd74
3003fba4:	e3530000 	cmp	r3, #0
3003fba8:	cafffff0 	bgt	3003fb70 <mp3_decoder+0x220>
				hputbuf((unsigned char) getbit(8));
			main_data_end = totpos / 8; /*of privious frame*/
3003fbac:	e59f37ec 	ldr	r3, [pc, #2028]	; 300403a0 <mp3_decoder+0xa50>
3003fbb0:	e5933000 	ldr	r3, [r3]
3003fbb4:	e1a031a3 	lsr	r3, r3, #3
3003fbb8:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003fbbc:	e5823d78 	str	r3, [r2, #3448]	; 0xd78
			if ( flush_main=(totpos % bitsPerSlot) )
3003fbc0:	e59f37d8 	ldr	r3, [pc, #2008]	; 300403a0 <mp3_decoder+0xa50>
3003fbc4:	e5933000 	ldr	r3, [r3]
3003fbc8:	e2033007 	and	r3, r3, #7
3003fbcc:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003fbd0:	e58c3d7c 	str	r3, [ip, #3452]	; 0xd7c
3003fbd4:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003fbd8:	e59e3d7c 	ldr	r3, [lr, #3452]	; 0xd7c
3003fbdc:	e3530000 	cmp	r3, #0
3003fbe0:	0a000009 	beq	3003fc0c <mp3_decoder+0x2bc>
			{
				hgetbits((int)(bitsPerSlot - flush_main));
3003fbe4:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003fbe8:	e5913d7c 	ldr	r3, [r1, #3452]	; 0xd7c
3003fbec:	e2633008 	rsb	r3, r3, #8
3003fbf0:	e1a00003 	mov	r0, r3
3003fbf4:	ebffde84 	bl	3003760c <hgetbits>
				main_data_end ++;
3003fbf8:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003fbfc:	e5923d78 	ldr	r3, [r2, #3448]	; 0xd78
3003fc00:	e2833001 	add	r3, r3, #1
3003fc04:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003fc08:	e58c3d78 	str	r3, [ip, #3448]	; 0xd78
			}
			bytes_to_discard = frame_start - main_data_end - III_side_info.main_data_begin ;
3003fc0c:	e59f37a0 	ldr	r3, [pc, #1952]	; 300403b4 <mp3_decoder+0xa64>
3003fc10:	e5932000 	ldr	r2, [r3]
3003fc14:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003fc18:	e59e3d78 	ldr	r3, [lr, #3448]	; 0xd78
3003fc1c:	e0633002 	rsb	r3, r3, r2
3003fc20:	e1a02003 	mov	r2, r3
3003fc24:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003fc28:	e5913d38 	ldr	r3, [r1, #3384]	; 0xd38
3003fc2c:	e0633002 	rsb	r3, r3, r2
3003fc30:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003fc34:	e5823d80 	str	r3, [r2, #3456]	; 0xd80
			/*    ���=1  */
			if( main_data_end > BITSTREAM_BUFSIZE )
3003fc38:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003fc3c:	e59c3d78 	ldr	r3, [ip, #3448]	; 0xd78
3003fc40:	e3530b02 	cmp	r3, #2048	; 0x800
3003fc44:	da000006 	ble	3003fc64 <mp3_decoder+0x314>
			{
				frame_start -= BITSTREAM_BUFSIZE;
3003fc48:	e59f3764 	ldr	r3, [pc, #1892]	; 300403b4 <mp3_decoder+0xa64>
3003fc4c:	e5933000 	ldr	r3, [r3]
3003fc50:	e2432b02 	sub	r2, r3, #2048	; 0x800
3003fc54:	e59f3758 	ldr	r3, [pc, #1880]	; 300403b4 <mp3_decoder+0xa64>
3003fc58:	e5832000 	str	r2, [r3]
				rewindNbytes( BITSTREAM_BUFSIZE);               //  totpos-=4096*8
3003fc5c:	e3a00b02 	mov	r0, #2048	; 0x800
3003fc60:	ebffdee1 	bl	300377ec <rewindNbytes>
			}

			frame_start += main_data_slots();
3003fc64:	ebfff0eb 	bl	3003c018 <main_data_slots>
3003fc68:	e1a02000 	mov	r2, r0
3003fc6c:	e59f3740 	ldr	r3, [pc, #1856]	; 300403b4 <mp3_decoder+0xa64>
3003fc70:	e5933000 	ldr	r3, [r3]
3003fc74:	e0822003 	add	r2, r2, r3
3003fc78:	e59f3734 	ldr	r3, [pc, #1844]	; 300403b4 <mp3_decoder+0xa64>
3003fc7c:	e5832000 	str	r2, [r3]
			if (bytes_to_discard < 0) {
3003fc80:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003fc84:	e59e3d80 	ldr	r3, [lr, #3456]	; 0xd80
3003fc88:	e3530000 	cmp	r3, #0
3003fc8c:	aa000009 	bge	3003fcb8 <mp3_decoder+0x368>
//				printf("Not enough main data to decode frame %d.  Frame discarded.\n",
//						frameNum - 1); 
				acoral_print("discard!!!!\n");
3003fc90:	e59f0728 	ldr	r0, [pc, #1832]	; 300403c0 <mp3_decoder+0xa70>
3003fc94:	ebff2d69 	bl	3000b240 <acoral_print>
				break;
3003fc98:	ea0001b0 	b	30040360 <mp3_decoder+0xa10>
			}
			for (; bytes_to_discard > 0; bytes_to_discard--)
				hgetbits(8);
3003fc9c:	e3a00008 	mov	r0, #8
3003fca0:	ebffde59 	bl	3003760c <hgetbits>
//				printf("Not enough main data to decode frame %d.  Frame discarded.\n",
//						frameNum - 1); 
				acoral_print("discard!!!!\n");
				break;
			}
			for (; bytes_to_discard > 0; bytes_to_discard--)
3003fca4:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003fca8:	e5913d80 	ldr	r3, [r1, #3456]	; 0xd80
3003fcac:	e2433001 	sub	r3, r3, #1
3003fcb0:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003fcb4:	e5823d80 	str	r3, [r2, #3456]	; 0xd80
3003fcb8:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003fcbc:	e59c3d80 	ldr	r3, [ip, #3456]	; 0xd80
3003fcc0:	e3530000 	cmp	r3, #0
3003fcc4:	cafffff4 	bgt	3003fc9c <mp3_decoder+0x34c>
				hgetbits(8);

			for (gr=0;gr<2;gr++)
3003fcc8:	e3a03000 	mov	r3, #0
3003fccc:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003fcd0:	e58e3d84 	str	r3, [lr, #3460]	; 0xd84
3003fcd4:	ea00019a 	b	30040344 <mp3_decoder+0x9f4>
			{
				int tmp[2][SBLIMIT][SSLIMIT];
  			    //������
				for (ch=0; ch<fr_ps.stereo; ch++)
3003fcd8:	e3a03000 	mov	r3, #0
3003fcdc:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003fce0:	e5813d88 	str	r3, [r1, #3464]	; 0xd88
3003fce4:	ea00004a 	b	3003fe14 <mp3_decoder+0x4c4>
				{
				    int is[SBLIMIT][SSLIMIT];   /*����������� Ƶ����*/
				    int part2_start;
	 			    part2_start=totpos;
3003fce8:	e59f36b0 	ldr	r3, [pc, #1712]	; 300403a0 <mp3_decoder+0xa50>
3003fcec:	e5933000 	ldr	r3, [r3]
3003fcf0:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003fcf4:	e5823d8c 	str	r3, [r2, #3468]	; 0xd8c

					III_get_scale_factors(&III_scalefac,&III_side_info, gr, ch);
3003fcf8:	e28d2d6d 	add	r2, sp, #6976	; 0x1b40
3003fcfc:	e2822008 	add	r2, r2, #8
3003fd00:	e28d3c1d 	add	r3, sp, #7424	; 0x1d00
3003fd04:	e2833038 	add	r3, r3, #56	; 0x38
3003fd08:	e1a00002 	mov	r0, r2
3003fd0c:	e1a01003 	mov	r1, r3
3003fd10:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003fd14:	e5932d84 	ldr	r2, [r3, #3460]	; 0xd84
3003fd18:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003fd1c:	e59c3d88 	ldr	r3, [ip, #3464]	; 0xd88
3003fd20:	ebffe146 	bl	30038240 <III_get_scale_factors>


					III_hufman_decode(&grle[ch][gr],part2_start,is);
3003fd24:	e59f1698 	ldr	r1, [pc, #1688]	; 300403c4 <mp3_decoder+0xa74>
3003fd28:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003fd2c:	e59e2d88 	ldr	r2, [lr, #3464]	; 0xd88
3003fd30:	e1a03002 	mov	r3, r2
3003fd34:	e1a03183 	lsl	r3, r3, #3
3003fd38:	e0833002 	add	r3, r3, r2
3003fd3c:	e1a03203 	lsl	r3, r3, #4
3003fd40:	e1a00003 	mov	r0, r3
3003fd44:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003fd48:	e5932d84 	ldr	r2, [r3, #3460]	; 0xd84
3003fd4c:	e1a03002 	mov	r3, r2
3003fd50:	e1a03183 	lsl	r3, r3, #3
3003fd54:	e0833002 	add	r3, r3, r2
3003fd58:	e1a03183 	lsl	r3, r3, #3
3003fd5c:	e0803003 	add	r3, r0, r3
3003fd60:	e0812003 	add	r2, r1, r3
3003fd64:	e28d3c12 	add	r3, sp, #4608	; 0x1200
3003fd68:	e2833010 	add	r3, r3, #16
3003fd6c:	e1a00002 	mov	r0, r2
3003fd70:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003fd74:	e59c1d8c 	ldr	r1, [ip, #3468]	; 0xd8c
3003fd78:	e1a02003 	mov	r2, r3
3003fd7c:	ebffd9cb 	bl	300364b0 <III_hufman_decode>

					III_dequantize_sample(is, tmp[ch], &III_scalefac, &grle[ch][gr], ch);
3003fd80:	e28d1010 	add	r1, sp, #16
3003fd84:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003fd88:	e59e2d88 	ldr	r2, [lr, #3464]	; 0xd88
3003fd8c:	e1a03002 	mov	r3, r2
3003fd90:	e1a03183 	lsl	r3, r3, #3
3003fd94:	e0833002 	add	r3, r3, r2
3003fd98:	e1a03403 	lsl	r3, r3, #8
3003fd9c:	e0811003 	add	r1, r1, r3
3003fda0:	e59f061c 	ldr	r0, [pc, #1564]	; 300403c4 <mp3_decoder+0xa74>
3003fda4:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003fda8:	e5932d88 	ldr	r2, [r3, #3464]	; 0xd88
3003fdac:	e1a03002 	mov	r3, r2
3003fdb0:	e1a03183 	lsl	r3, r3, #3
3003fdb4:	e0833002 	add	r3, r3, r2
3003fdb8:	e1a03203 	lsl	r3, r3, #4
3003fdbc:	e1a0c003 	mov	ip, r3
3003fdc0:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003fdc4:	e59e2d84 	ldr	r2, [lr, #3460]	; 0xd84
3003fdc8:	e1a03002 	mov	r3, r2
3003fdcc:	e1a03183 	lsl	r3, r3, #3
3003fdd0:	e0833002 	add	r3, r3, r2
3003fdd4:	e1a03183 	lsl	r3, r3, #3
3003fdd8:	e08c3003 	add	r3, ip, r3
3003fddc:	e0803003 	add	r3, r0, r3
3003fde0:	e28d0c12 	add	r0, sp, #4608	; 0x1200
3003fde4:	e2800010 	add	r0, r0, #16
3003fde8:	e28d2d6d 	add	r2, sp, #6976	; 0x1b40
3003fdec:	e2822008 	add	r2, r2, #8
3003fdf0:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003fdf4:	e59ecd88 	ldr	ip, [lr, #3464]	; 0xd88
3003fdf8:	e58dc000 	str	ip, [sp]
3003fdfc:	ebffe284 	bl	30038814 <III_dequantize_sample>

			for (gr=0;gr<2;gr++)
			{
				int tmp[2][SBLIMIT][SSLIMIT];
  			    //������
				for (ch=0; ch<fr_ps.stereo; ch++)
3003fe00:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003fe04:	e5913d88 	ldr	r3, [r1, #3464]	; 0xd88
3003fe08:	e2833001 	add	r3, r3, #1
3003fe0c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003fe10:	e5823d88 	str	r3, [r2, #3464]	; 0xd88
3003fe14:	e59f3580 	ldr	r3, [pc, #1408]	; 3004039c <mp3_decoder+0xa4c>
3003fe18:	e5932008 	ldr	r2, [r3, #8]
3003fe1c:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003fe20:	e59c3d88 	ldr	r3, [ip, #3464]	; 0xd88
3003fe24:	e1520003 	cmp	r2, r3
3003fe28:	caffffae 	bgt	3003fce8 <mp3_decoder+0x398>

					III_dequantize_sample(is, tmp[ch], &III_scalefac, &grle[ch][gr], ch);

				}

				III_stereo(tmp, &III_scalefac, &grle[0][gr]);
3003fe2c:	e59f1590 	ldr	r1, [pc, #1424]	; 300403c4 <mp3_decoder+0xa74>
3003fe30:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003fe34:	e59e2d84 	ldr	r2, [lr, #3460]	; 0xd84
3003fe38:	e1a03002 	mov	r3, r2
3003fe3c:	e1a03183 	lsl	r3, r3, #3
3003fe40:	e0833002 	add	r3, r3, r2
3003fe44:	e1a03183 	lsl	r3, r3, #3
3003fe48:	e0813003 	add	r3, r1, r3
3003fe4c:	e28d1010 	add	r1, sp, #16
3003fe50:	e28d2d6d 	add	r2, sp, #6976	; 0x1b40
3003fe54:	e2822008 	add	r2, r2, #8
3003fe58:	e1a00001 	mov	r0, r1
3003fe5c:	e1a01002 	mov	r1, r2
3003fe60:	e1a02003 	mov	r2, r3
3003fe64:	ebffe7aa 	bl	30039d14 <III_stereo>

				for (ch=0; ch<fr_ps.stereo; ch++)
3003fe68:	e3a03000 	mov	r3, #0
3003fe6c:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3003fe70:	e5813d88 	str	r3, [r1, #3464]	; 0xd88
3003fe74:	ea000061 	b	30040000 <mp3_decoder+0x6b0>
				{
					III_reorder(tmp[ch], &grle[ch][gr]);
3003fe78:	e28d1010 	add	r1, sp, #16
3003fe7c:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003fe80:	e5932d88 	ldr	r2, [r3, #3464]	; 0xd88
3003fe84:	e1a03002 	mov	r3, r2
3003fe88:	e1a03183 	lsl	r3, r3, #3
3003fe8c:	e0833002 	add	r3, r3, r2
3003fe90:	e1a03403 	lsl	r3, r3, #8
3003fe94:	e0811003 	add	r1, r1, r3
3003fe98:	e59f0524 	ldr	r0, [pc, #1316]	; 300403c4 <mp3_decoder+0xa74>
3003fe9c:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003fea0:	e59c2d88 	ldr	r2, [ip, #3464]	; 0xd88
3003fea4:	e1a03002 	mov	r3, r2
3003fea8:	e1a03183 	lsl	r3, r3, #3
3003feac:	e0833002 	add	r3, r3, r2
3003feb0:	e1a03203 	lsl	r3, r3, #4
3003feb4:	e1a0c003 	mov	ip, r3
3003feb8:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003febc:	e59e2d84 	ldr	r2, [lr, #3460]	; 0xd84
3003fec0:	e1a03002 	mov	r3, r2
3003fec4:	e1a03183 	lsl	r3, r3, #3
3003fec8:	e0833002 	add	r3, r3, r2
3003fecc:	e1a03183 	lsl	r3, r3, #3
3003fed0:	e08c3003 	add	r3, ip, r3
3003fed4:	e0803003 	add	r3, r0, r3
3003fed8:	e1a00001 	mov	r0, r1
3003fedc:	e1a01003 	mov	r1, r3
3003fee0:	ebffe5db 	bl	30039654 <III_reorder>
					//���������
					III_antialias(tmp[ch],&grle[ch][gr]);
3003fee4:	e28d1010 	add	r1, sp, #16
3003fee8:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003feec:	e5932d88 	ldr	r2, [r3, #3464]	; 0xd88
3003fef0:	e1a03002 	mov	r3, r2
3003fef4:	e1a03183 	lsl	r3, r3, #3
3003fef8:	e0833002 	add	r3, r3, r2
3003fefc:	e1a03403 	lsl	r3, r3, #8
3003ff00:	e0811003 	add	r1, r1, r3
3003ff04:	e59f04b8 	ldr	r0, [pc, #1208]	; 300403c4 <mp3_decoder+0xa74>
3003ff08:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003ff0c:	e59c2d88 	ldr	r2, [ip, #3464]	; 0xd88
3003ff10:	e1a03002 	mov	r3, r2
3003ff14:	e1a03183 	lsl	r3, r3, #3
3003ff18:	e0833002 	add	r3, r3, r2
3003ff1c:	e1a03203 	lsl	r3, r3, #4
3003ff20:	e1a0c003 	mov	ip, r3
3003ff24:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003ff28:	e59e2d84 	ldr	r2, [lr, #3460]	; 0xd84
3003ff2c:	e1a03002 	mov	r3, r2
3003ff30:	e1a03183 	lsl	r3, r3, #3
3003ff34:	e0833002 	add	r3, r3, r2
3003ff38:	e1a03183 	lsl	r3, r3, #3
3003ff3c:	e08c3003 	add	r3, ip, r3
3003ff40:	e0803003 	add	r3, r0, r3
3003ff44:	e1a00001 	mov	r0, r1
3003ff48:	e1a01003 	mov	r1, r3
3003ff4c:	ebffef9d 	bl	3003bdc8 <III_antialias>
					//IMDCT �Ӵ� ���� 
                    Granule_imdct(&grle[ch][gr], ch, tmp[ch]);
3003ff50:	e59f146c 	ldr	r1, [pc, #1132]	; 300403c4 <mp3_decoder+0xa74>
3003ff54:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003ff58:	e5932d88 	ldr	r2, [r3, #3464]	; 0xd88
3003ff5c:	e1a03002 	mov	r3, r2
3003ff60:	e1a03183 	lsl	r3, r3, #3
3003ff64:	e0833002 	add	r3, r3, r2
3003ff68:	e1a03203 	lsl	r3, r3, #4
3003ff6c:	e1a00003 	mov	r0, r3
3003ff70:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003ff74:	e59c2d84 	ldr	r2, [ip, #3460]	; 0xd84
3003ff78:	e1a03002 	mov	r3, r2
3003ff7c:	e1a03183 	lsl	r3, r3, #3
3003ff80:	e0833002 	add	r3, r3, r2
3003ff84:	e1a03183 	lsl	r3, r3, #3
3003ff88:	e0803003 	add	r3, r0, r3
3003ff8c:	e0811003 	add	r1, r1, r3
3003ff90:	e28d0010 	add	r0, sp, #16
3003ff94:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003ff98:	e59e2d88 	ldr	r2, [lr, #3464]	; 0xd88
3003ff9c:	e1a03002 	mov	r3, r2
3003ffa0:	e1a03183 	lsl	r3, r3, #3
3003ffa4:	e0833002 	add	r3, r3, r2
3003ffa8:	e1a03403 	lsl	r3, r3, #8
3003ffac:	e0803003 	add	r3, r0, r3
3003ffb0:	e1a00001 	mov	r0, r1
3003ffb4:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3003ffb8:	e5921d88 	ldr	r1, [r2, #3464]	; 0xd88
3003ffbc:	e1a02003 	mov	r2, r3
3003ffc0:	ebfff5d0 	bl	3003d708 <Granule_imdct>
					//����Ƶ�ʵ���  X(-1)

                    Granule_freqinverse(tmp[ch]);
3003ffc4:	e28d1010 	add	r1, sp, #16
3003ffc8:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3003ffcc:	e5932d88 	ldr	r2, [r3, #3464]	; 0xd88
3003ffd0:	e1a03002 	mov	r3, r2
3003ffd4:	e1a03183 	lsl	r3, r3, #3
3003ffd8:	e0833002 	add	r3, r3, r2
3003ffdc:	e1a03403 	lsl	r3, r3, #8
3003ffe0:	e0813003 	add	r3, r1, r3
3003ffe4:	e1a00003 	mov	r0, r3
3003ffe8:	ebfffe31 	bl	3003f8b4 <Granule_freqinverse>

				}

				III_stereo(tmp, &III_scalefac, &grle[0][gr]);

				for (ch=0; ch<fr_ps.stereo; ch++)
3003ffec:	e28dca01 	add	ip, sp, #4096	; 0x1000
3003fff0:	e59c3d88 	ldr	r3, [ip, #3464]	; 0xd88
3003fff4:	e2833001 	add	r3, r3, #1
3003fff8:	e28dea01 	add	lr, sp, #4096	; 0x1000
3003fffc:	e58e3d88 	str	r3, [lr, #3464]	; 0xd88
30040000:	e59f3394 	ldr	r3, [pc, #916]	; 3004039c <mp3_decoder+0xa4c>
30040004:	e5932008 	ldr	r2, [r3, #8]
30040008:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3004000c:	e5913d88 	ldr	r3, [r1, #3464]	; 0xd88
30040010:	e1520003 	cmp	r2, r3
30040014:	caffff97 	bgt	3003fe78 <mp3_decoder+0x528>
             if(fr_ps.stereo == 2)
                	Granule_subband_synthesis2(tmp[0],tmp[1],pcm_sample);
             else   // ���������
                	Granule_subband_synthesis( 0,tmp[0],pcm_sample);
			*/
			 if(hdr[pcm_dma_buf_cur].used)
30040018:	e28d3a01 	add	r3, sp, #4096	; 0x1000
3004001c:	e5932d64 	ldr	r2, [r3, #3428]	; 0xd64
30040020:	e59f03a0 	ldr	r0, [pc, #928]	; 300403c8 <mp3_decoder+0xa78>
30040024:	e3a01024 	mov	r1, #36	; 0x24
30040028:	e1a03002 	mov	r3, r2
3004002c:	e1a03103 	lsl	r3, r3, #2
30040030:	e0833002 	add	r3, r3, r2
30040034:	e1a03083 	lsl	r3, r3, #1
30040038:	e0833002 	add	r3, r3, r2
3004003c:	e1a03103 	lsl	r3, r3, #2
30040040:	e0833000 	add	r3, r3, r0
30040044:	e0833001 	add	r3, r3, r1
30040048:	e5933000 	ldr	r3, [r3]
3004004c:	e3530000 	cmp	r3, #0
30040050:	0a00000b 	beq	30040084 <mp3_decoder+0x734>
				 acoral_sem_pend(pcm_dma_buf_playdone_eve+pcm_dma_buf_cur, 0);
30040054:	e28dca01 	add	ip, sp, #4096	; 0x1000
30040058:	e59c2d64 	ldr	r2, [ip, #3428]	; 0xd64
3004005c:	e1a03002 	mov	r3, r2
30040060:	e1a03183 	lsl	r3, r3, #3
30040064:	e0833002 	add	r3, r3, r2
30040068:	e1a03103 	lsl	r3, r3, #2
3004006c:	e1a02003 	mov	r2, r3
30040070:	e59f3354 	ldr	r3, [pc, #852]	; 300403cc <mp3_decoder+0xa7c>
30040074:	e0823003 	add	r3, r2, r3
30040078:	e1a00003 	mov	r0, r3
3004007c:	e3a01000 	mov	r1, #0
30040080:	ebff1d8e 	bl	300076c0 <acoral_sem_pend>
             if(fr_ps.stereo == 2)
30040084:	e59f3310 	ldr	r3, [pc, #784]	; 3004039c <mp3_decoder+0xa4c>
30040088:	e5933008 	ldr	r3, [r3, #8]
3004008c:	e3530002 	cmp	r3, #2
30040090:	1a00000e 	bne	300400d0 <mp3_decoder+0x780>
                 Granule_subband_synthesis2(tmp[0],tmp[1],pcm_dma_buf+2*i);
30040094:	e28d0010 	add	r0, sp, #16
30040098:	e28d3010 	add	r3, sp, #16
3004009c:	e2831c09 	add	r1, r3, #2304	; 0x900
300400a0:	e28dea01 	add	lr, sp, #4096	; 0x1000
300400a4:	e59e2d60 	ldr	r2, [lr, #3424]	; 0xd60
300400a8:	e1a03002 	mov	r3, r2
300400ac:	e1a03183 	lsl	r3, r3, #3
300400b0:	e0833002 	add	r3, r3, r2
300400b4:	e1a03403 	lsl	r3, r3, #8
300400b8:	e1a02003 	mov	r2, r3
300400bc:	e59f330c 	ldr	r3, [pc, #780]	; 300403d0 <mp3_decoder+0xa80>
300400c0:	e0823003 	add	r3, r2, r3
300400c4:	e1a02003 	mov	r2, r3
300400c8:	ebfff0c5 	bl	3003c3e4 <Granule_subband_synthesis2>
300400cc:	ea00000c 	b	30040104 <mp3_decoder+0x7b4>
             else
                 Granule_subband_synthesis( 0,tmp[0],pcm_dma_buf+2*i);
300400d0:	e28d1010 	add	r1, sp, #16
300400d4:	e28d3a01 	add	r3, sp, #4096	; 0x1000
300400d8:	e5932d60 	ldr	r2, [r3, #3424]	; 0xd60
300400dc:	e1a03002 	mov	r3, r2
300400e0:	e1a03183 	lsl	r3, r3, #3
300400e4:	e0833002 	add	r3, r3, r2
300400e8:	e1a03403 	lsl	r3, r3, #8
300400ec:	e1a02003 	mov	r2, r3
300400f0:	e59f32d8 	ldr	r3, [pc, #728]	; 300403d0 <mp3_decoder+0xa80>
300400f4:	e0823003 	add	r3, r2, r3
300400f8:	e3a00000 	mov	r0, #0
300400fc:	e1a02003 	mov	r2, r3
30040100:	ebfff00e 	bl	3003c140 <Granule_subband_synthesis>

                //acoral_write(pcm_dat, pcm_sample, 2*SBLIMIT*SSLIMIT*2);
                //acoral_flush();


             i ++;
30040104:	e28dca01 	add	ip, sp, #4096	; 0x1000
30040108:	e59c3d60 	ldr	r3, [ip, #3424]	; 0xd60
3004010c:	e2833001 	add	r3, r3, #1
30040110:	e28dea01 	add	lr, sp, #4096	; 0x1000
30040114:	e58e3d60 	str	r3, [lr, #3424]	; 0xd60
             if(i%10 == 0) {
30040118:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3004011c:	e5921d60 	ldr	r1, [r2, #3424]	; 0xd60
30040120:	e59f32ac 	ldr	r3, [pc, #684]	; 300403d4 <mp3_decoder+0xa84>
30040124:	e0c3c391 	smull	ip, r3, r1, r3
30040128:	e1a02143 	asr	r2, r3, #2
3004012c:	e1a03fc1 	asr	r3, r1, #31
30040130:	e0632002 	rsb	r2, r3, r2
30040134:	e1a03002 	mov	r3, r2
30040138:	e1a03103 	lsl	r3, r3, #2
3004013c:	e0833002 	add	r3, r3, r2
30040140:	e1a03083 	lsl	r3, r3, #1
30040144:	e0632001 	rsb	r2, r3, r1
30040148:	e3520000 	cmp	r2, #0
3004014c:	1a000039 	bne	30040238 <mp3_decoder+0x8e8>
            	 hdr[pcm_dma_buf_cur].used = 1;
30040150:	e28dea01 	add	lr, sp, #4096	; 0x1000
30040154:	e59e2d64 	ldr	r2, [lr, #3428]	; 0xd64
30040158:	e59f0268 	ldr	r0, [pc, #616]	; 300403c8 <mp3_decoder+0xa78>
3004015c:	e3a01024 	mov	r1, #36	; 0x24
30040160:	e1a03002 	mov	r3, r2
30040164:	e1a03103 	lsl	r3, r3, #2
30040168:	e0833002 	add	r3, r3, r2
3004016c:	e1a03083 	lsl	r3, r3, #1
30040170:	e0833002 	add	r3, r3, r2
30040174:	e1a03103 	lsl	r3, r3, #2
30040178:	e0833000 	add	r3, r3, r0
3004017c:	e0833001 	add	r3, r3, r1
30040180:	e3a02001 	mov	r2, #1
30040184:	e5832000 	str	r2, [r3]
            	 hdr[pcm_dma_buf_cur].update = 1;
30040188:	e28d1a01 	add	r1, sp, #4096	; 0x1000
3004018c:	e5912d64 	ldr	r2, [r1, #3428]	; 0xd64
30040190:	e59f0230 	ldr	r0, [pc, #560]	; 300403c8 <mp3_decoder+0xa78>
30040194:	e3a01028 	mov	r1, #40	; 0x28
30040198:	e1a03002 	mov	r3, r2
3004019c:	e1a03103 	lsl	r3, r3, #2
300401a0:	e0833002 	add	r3, r3, r2
300401a4:	e1a03083 	lsl	r3, r3, #1
300401a8:	e0833002 	add	r3, r3, r2
300401ac:	e1a03103 	lsl	r3, r3, #2
300401b0:	e0833000 	add	r3, r3, r0
300401b4:	e0833001 	add	r3, r3, r1
300401b8:	e3a02001 	mov	r2, #1
300401bc:	e5832000 	str	r2, [r3]
            	 if(acoral_sem_getnum(pcm_dma_buf_update_eve+pcm_dma_buf_cur))
300401c0:	e28d3a01 	add	r3, sp, #4096	; 0x1000
300401c4:	e5932d64 	ldr	r2, [r3, #3428]	; 0xd64
300401c8:	e1a03002 	mov	r3, r2
300401cc:	e1a03183 	lsl	r3, r3, #3
300401d0:	e0833002 	add	r3, r3, r2
300401d4:	e1a03103 	lsl	r3, r3, #2
300401d8:	e1a02003 	mov	r2, r3
300401dc:	e59f31f4 	ldr	r3, [pc, #500]	; 300403d8 <mp3_decoder+0xa88>
300401e0:	e0823003 	add	r3, r2, r3
300401e4:	e1a00003 	mov	r0, r3
300401e8:	ebff1de1 	bl	30007974 <acoral_sem_getnum>
300401ec:	e1a03000 	mov	r3, r0
300401f0:	e3530000 	cmp	r3, #0
300401f4:	0a00000a 	beq	30040224 <mp3_decoder+0x8d4>
            		 acoral_sem_post(pcm_dma_buf_update_eve+pcm_dma_buf_cur);
300401f8:	e28dca01 	add	ip, sp, #4096	; 0x1000
300401fc:	e59c2d64 	ldr	r2, [ip, #3428]	; 0xd64
30040200:	e1a03002 	mov	r3, r2
30040204:	e1a03183 	lsl	r3, r3, #3
30040208:	e0833002 	add	r3, r3, r2
3004020c:	e1a03103 	lsl	r3, r3, #2
30040210:	e1a02003 	mov	r2, r3
30040214:	e59f31bc 	ldr	r3, [pc, #444]	; 300403d8 <mp3_decoder+0xa88>
30040218:	e0823003 	add	r3, r2, r3
3004021c:	e1a00003 	mov	r0, r3
30040220:	ebff1d91 	bl	3000786c <acoral_sem_post>
            	 pcm_dma_buf_cur ++;
30040224:	e28dea01 	add	lr, sp, #4096	; 0x1000
30040228:	e59e3d64 	ldr	r3, [lr, #3428]	; 0xd64
3004022c:	e2833001 	add	r3, r3, #1
30040230:	e28d1a01 	add	r1, sp, #4096	; 0x1000
30040234:	e5813d64 	str	r3, [r1, #3428]	; 0xd64
             }
             if(first && pcm_dma_buf_cur==6) {
30040238:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3004023c:	e5923d6c 	ldr	r3, [r2, #3436]	; 0xd6c
30040240:	e3530000 	cmp	r3, #0
30040244:	0a00002b 	beq	300402f8 <mp3_decoder+0x9a8>
30040248:	e28dca01 	add	ip, sp, #4096	; 0x1000
3004024c:	e59c3d64 	ldr	r3, [ip, #3428]	; 0xd64
30040250:	e3530006 	cmp	r3, #6
30040254:	1a000027 	bne	300402f8 <mp3_decoder+0x9a8>
            	 first = 0;
30040258:	e3a03000 	mov	r3, #0
3004025c:	e28dea01 	add	lr, sp, #4096	; 0x1000
30040260:	e58e3d6c 	str	r3, [lr, #3436]	; 0xd6c
            	 if(play_model == Local)
30040264:	e59f3170 	ldr	r3, [pc, #368]	; 300403dc <mp3_decoder+0xa8c>
30040268:	e5933000 	ldr	r3, [r3]
3004026c:	e3530015 	cmp	r3, #21
30040270:	1a00000f 	bne	300402b4 <mp3_decoder+0x964>
            		 pcm_player_id = acoral_create_thread_ext(mp3_pcm_player, 8192*16, 0, "mp3_pcm_player", NULL,ACORAL_SCHED_POLICY_SLICE, &data);
30040274:	e59f3164 	ldr	r3, [pc, #356]	; 300403e0 <mp3_decoder+0xa90>
30040278:	e3a02000 	mov	r2, #0
3004027c:	e58d2000 	str	r2, [sp]
30040280:	e3a02018 	mov	r2, #24
30040284:	e58d2004 	str	r2, [sp, #4]
30040288:	e28d2c1b 	add	r2, sp, #6912	; 0x1b00
3004028c:	e2822010 	add	r2, r2, #16
30040290:	e58d2008 	str	r2, [sp, #8]
30040294:	e1a00003 	mov	r0, r3
30040298:	e3a01802 	mov	r1, #131072	; 0x20000
3004029c:	e3a02000 	mov	r2, #0
300402a0:	e59f313c 	ldr	r3, [pc, #316]	; 300403e4 <mp3_decoder+0xa94>
300402a4:	ebff0662 	bl	30001c34 <create_thread_ext>
300402a8:	e1a02000 	mov	r2, r0
300402ac:	e59f3134 	ldr	r3, [pc, #308]	; 300403e8 <mp3_decoder+0xa98>
300402b0:	e5832000 	str	r2, [r3]

            	 if(play_model == Online)
300402b4:	e59f3120 	ldr	r3, [pc, #288]	; 300403dc <mp3_decoder+0xa8c>
300402b8:	e5933000 	ldr	r3, [r3]
300402bc:	e3530016 	cmp	r3, #22
300402c0:	1a00000c 	bne	300402f8 <mp3_decoder+0x9a8>
            	 	 pcm_player_id = acoral_create_thread(mp3_pcm_player,8192*16,NULL,"mp3_pcm_player",20,0);
300402c4:	e59f3114 	ldr	r3, [pc, #276]	; 300403e0 <mp3_decoder+0xa90>
300402c8:	e3a02014 	mov	r2, #20
300402cc:	e58d2000 	str	r2, [sp]
300402d0:	e3a02000 	mov	r2, #0
300402d4:	e58d2004 	str	r2, [sp, #4]
300402d8:	e1a00003 	mov	r0, r3
300402dc:	e3a01802 	mov	r1, #131072	; 0x20000
300402e0:	e3a02000 	mov	r2, #0
300402e4:	e59f30f8 	ldr	r3, [pc, #248]	; 300403e4 <mp3_decoder+0xa94>
300402e8:	ebff0b2d 	bl	30002fa4 <create_comm_thread>
300402ec:	e1a02000 	mov	r2, r0
300402f0:	e59f30f0 	ldr	r3, [pc, #240]	; 300403e8 <mp3_decoder+0xa98>
300402f4:	e5832000 	str	r2, [r3]
             }
             if(i == 100)
300402f8:	e28d1a01 	add	r1, sp, #4096	; 0x1000
300402fc:	e5913d60 	ldr	r3, [r1, #3424]	; 0xd60
30040300:	e3530064 	cmp	r3, #100	; 0x64
30040304:	1a000002 	bne	30040314 <mp3_decoder+0x9c4>
            	 i = 0;
30040308:	e3a03000 	mov	r3, #0
3004030c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
30040310:	e5823d60 	str	r3, [r2, #3424]	; 0xd60
             if(pcm_dma_buf_cur == pcm_dma_buf_size) {
30040314:	e28dca01 	add	ip, sp, #4096	; 0x1000
30040318:	e59c3d64 	ldr	r3, [ip, #3428]	; 0xd64
3004031c:	e353000a 	cmp	r3, #10
30040320:	1a000002 	bne	30040330 <mp3_decoder+0x9e0>
             		pcm_dma_buf_cur = 0;
30040324:	e3a03000 	mov	r3, #0
30040328:	e28dea01 	add	lr, sp, #4096	; 0x1000
3004032c:	e58e3d64 	str	r3, [lr, #3428]	; 0xd64
				break;
			}
			for (; bytes_to_discard > 0; bytes_to_discard--)
				hgetbits(8);

			for (gr=0;gr<2;gr++)
30040330:	e28d1a01 	add	r1, sp, #4096	; 0x1000
30040334:	e5913d84 	ldr	r3, [r1, #3460]	; 0xd84
30040338:	e2833001 	add	r3, r3, #1
3004033c:	e28d2a01 	add	r2, sp, #4096	; 0x1000
30040340:	e5823d84 	str	r3, [r2, #3460]	; 0xd84
30040344:	e28dca01 	add	ip, sp, #4096	; 0x1000
30040348:	e59c3d84 	ldr	r3, [ip, #3460]	; 0xd84
3004034c:	e3530001 	cmp	r3, #1
30040350:	dafffe60 	ble	3003fcd8 <mp3_decoder+0x388>
             		pcm_dma_buf_cur = 0;
             }

			}
		} 
		break;  
30040354:	ea000001 	b	30040360 <mp3_decoder+0xa10>
		default:
			acoral_print("\nOnly layer III supported!\n");
30040358:	e59f008c 	ldr	r0, [pc, #140]	; 300403ec <mp3_decoder+0xa9c>
3004035c:	ebff2bb7 	bl	3000b240 <acoral_print>
    i = 0;

    acoral_print("start ~\n");
    //pcm_player_id = acoral_create_thread(mp3_pcm_player,8192*16,NULL,"pcm_player",20,0);

    while(!bs.eobs) {
30040360:	e59f3088 	ldr	r3, [pc, #136]	; 300403f0 <mp3_decoder+0xaa0>
30040364:	e5933018 	ldr	r3, [r3, #24]
30040368:	e3530000 	cmp	r3, #0
3004036c:	0afffda9 	beq	3003fa18 <mp3_decoder+0xc8>
30040370:	ea000000 	b	30040378 <mp3_decoder+0xa28>
next_frame:
		if (!seek_sync(SYNC_WORD)) {
//			printf("\nFrame cannot be located\n");
			break;
30040374:	e1a00000 	nop			; (mov r0, r0)
		//if(frameNum >= 1000)
		  //       	break;
	}
	//acoral_close(pcm_dat);
	//acoral_close(mp3_dat);
	acoral_print("\nDecoding done.\n");
30040378:	e59f0074 	ldr	r0, [pc, #116]	; 300403f4 <mp3_decoder+0xaa4>
3004037c:	ebff2baf 	bl	3000b240 <acoral_print>
	while(1) {
			acoral_delay_self(5000);
30040380:	e3a00d4e 	mov	r0, #4992	; 0x1380
30040384:	e2800008 	add	r0, r0, #8
30040388:	ebff097d 	bl	30002984 <acoral_delay_self>
		}
3004038c:	eafffffb 	b	30040380 <mp3_decoder+0xa30>
30040390:	300c9a88 	.word	0x300c9a88
30040394:	300c9a8c 	.word	0x300c9a8c
30040398:	300c9a90 	.word	0x300c9a90
3004039c:	302be81c 	.word	0x302be81c
300403a0:	300ea2e0 	.word	0x300ea2e0
300403a4:	3012b634 	.word	0x3012b634
300403a8:	300461b8 	.word	0x300461b8
300403ac:	300461c4 	.word	0x300461c4
300403b0:	300c7eb0 	.word	0x300c7eb0
300403b4:	300ea2e4 	.word	0x300ea2e4
300403b8:	302be268 	.word	0x302be268
300403bc:	300c9a94 	.word	0x300c9a94
300403c0:	300461cc 	.word	0x300461cc
300403c4:	302bd948 	.word	0x302bd948
300403c8:	302bf84c 	.word	0x302bf84c
300403cc:	301f57a8 	.word	0x301f57a8
300403d0:	302bfa04 	.word	0x302bfa04
300403d4:	66666667 	.word	0x66666667
300403d8:	302be6b0 	.word	0x302be6b0
300403dc:	300c5fa0 	.word	0x300c5fa0
300403e0:	30032f40 	.word	0x30032f40
300403e4:	300461dc 	.word	0x300461dc
300403e8:	300eaab0 	.word	0x300eaab0
300403ec:	300461ec 	.word	0x300461ec
300403f0:	302f7e28 	.word	0x302f7e28
300403f4:	30046208 	.word	0x30046208

300403f8 <acoral_get_drv_ctrl_by_name>:
#define DRV_MAIN_ID_SHIFT 5
#define DRV_MAIN_ID(id) (id>>DRV_MAIN_ID_SHIFT)
#define DRV_CHK_ID(id) (DRV_MAIN_ID(id)>=0&&DRV_MAIN_ID(id)<ACORAL_DEV_NUM)
acoral_pool_ctrl_t acoral_drv_pool_ctrl;
acoral_drv_ctrl_t *drv_table[ACORAL_DEV_NUM];
acoral_drv_ctrl_t *acoral_get_drv_ctrl_by_name(acoral_char *name){
300403f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300403fc:	e24dd014 	sub	sp, sp, #20
30040400:	e58d0004 	str	r0, [sp, #4]
  	acoral_u32 i;
	acoral_drv_ctrl_t *ctrl;
	for(i=0;i<ACORAL_DEV_NUM;i++){
30040404:	e3a03000 	mov	r3, #0
30040408:	e58d3008 	str	r3, [sp, #8]
3004040c:	ea000013 	b	30040460 <acoral_get_drv_ctrl_by_name+0x68>
	  	ctrl=drv_table[i];	    
30040410:	e59d2008 	ldr	r2, [sp, #8]
30040414:	e59f3064 	ldr	r3, [pc, #100]	; 30040480 <acoral_get_drv_ctrl_by_name+0x88>
30040418:	e7933102 	ldr	r3, [r3, r2, lsl #2]
3004041c:	e58d300c 	str	r3, [sp, #12]
		if(ctrl!=NULL&&!acoral_str_cmp(ctrl->name,name))
30040420:	e59d300c 	ldr	r3, [sp, #12]
30040424:	e3530000 	cmp	r3, #0
30040428:	0a000009 	beq	30040454 <acoral_get_drv_ctrl_by_name+0x5c>
3004042c:	e59d300c 	ldr	r3, [sp, #12]
30040430:	e593300c 	ldr	r3, [r3, #12]
30040434:	e1a00003 	mov	r0, r3
30040438:	e59d1004 	ldr	r1, [sp, #4]
3004043c:	ebff2cf1 	bl	3000b808 <acoral_str_cmp>
30040440:	e1a03000 	mov	r3, r0
30040444:	e3530000 	cmp	r3, #0
30040448:	1a000001 	bne	30040454 <acoral_get_drv_ctrl_by_name+0x5c>
		   return ctrl;
3004044c:	e59d300c 	ldr	r3, [sp, #12]
30040450:	ea000006 	b	30040470 <acoral_get_drv_ctrl_by_name+0x78>
acoral_pool_ctrl_t acoral_drv_pool_ctrl;
acoral_drv_ctrl_t *drv_table[ACORAL_DEV_NUM];
acoral_drv_ctrl_t *acoral_get_drv_ctrl_by_name(acoral_char *name){
  	acoral_u32 i;
	acoral_drv_ctrl_t *ctrl;
	for(i=0;i<ACORAL_DEV_NUM;i++){
30040454:	e59d3008 	ldr	r3, [sp, #8]
30040458:	e2833001 	add	r3, r3, #1
3004045c:	e58d3008 	str	r3, [sp, #8]
30040460:	e59d3008 	ldr	r3, [sp, #8]
30040464:	e3530013 	cmp	r3, #19
30040468:	9affffe8 	bls	30040410 <acoral_get_drv_ctrl_by_name+0x18>
	  	ctrl=drv_table[i];	    
		if(ctrl!=NULL&&!acoral_str_cmp(ctrl->name,name))
		   return ctrl;
	}
	return NULL;
3004046c:	e3a03000 	mov	r3, #0
}
30040470:	e1a00003 	mov	r0, r3
30040474:	e28dd014 	add	sp, sp, #20
30040478:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3004047c:	e12fff1e 	bx	lr
30040480:	300ea334 	.word	0x300ea334

30040484 <acoral_drv_register>:

acoral_err acoral_drv_register(acoral_dev_ops_t *ops,acoral_char *name){
30040484:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30040488:	e24dd01c 	sub	sp, sp, #28
3004048c:	e58d0004 	str	r0, [sp, #4]
30040490:	e58d1000 	str	r1, [sp]
	acoral_u32 i;
	acoral_drv_ctrl_t *tmp,*ctrl;
	ctrl=acoral_alloc_drv();
30040494:	eb000107 	bl	300408b8 <acoral_alloc_drv>
30040498:	e1a03000 	mov	r3, r0
3004049c:	e58d3014 	str	r3, [sp, #20]
	if(ctrl==NULL)
300404a0:	e59d3014 	ldr	r3, [sp, #20]
300404a4:	e3530000 	cmp	r3, #0
300404a8:	1a000001 	bne	300404b4 <acoral_drv_register+0x30>
		return ACORAL_ERR_NO_DRV_RES;
300404ac:	e3a03005 	mov	r3, #5
300404b0:	ea000024 	b	30040548 <acoral_drv_register+0xc4>
	ctrl->name=name;
300404b4:	e59d3014 	ldr	r3, [sp, #20]
300404b8:	e59d2000 	ldr	r2, [sp]
300404bc:	e583200c 	str	r2, [r3, #12]
	ctrl->ops=ops;
300404c0:	e59d3014 	ldr	r3, [sp, #20]
300404c4:	e59d2004 	ldr	r2, [sp, #4]
300404c8:	e5832004 	str	r2, [r3, #4]
	for(i=0;i<ACORAL_DEV_NUM;i++){
300404cc:	e3a03000 	mov	r3, #0
300404d0:	e58d300c 	str	r3, [sp, #12]
300404d4:	ea000012 	b	30040524 <acoral_drv_register+0xa0>
	  	tmp=drv_table[i];	    
300404d8:	e59d200c 	ldr	r2, [sp, #12]
300404dc:	e59f3074 	ldr	r3, [pc, #116]	; 30040558 <acoral_drv_register+0xd4>
300404e0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
300404e4:	e58d3010 	str	r3, [sp, #16]
		if(tmp==NULL){
300404e8:	e59d3010 	ldr	r3, [sp, #16]
300404ec:	e3530000 	cmp	r3, #0
300404f0:	1a000008 	bne	30040518 <acoral_drv_register+0x94>
			drv_table[i]=ctrl;
300404f4:	e59d200c 	ldr	r2, [sp, #12]
300404f8:	e59f3058 	ldr	r3, [pc, #88]	; 30040558 <acoral_drv_register+0xd4>
300404fc:	e59d1014 	ldr	r1, [sp, #20]
30040500:	e7831102 	str	r1, [r3, r2, lsl #2]
			ctrl->drv_id=i<<DRV_MAIN_ID_SHIFT;
30040504:	e59d300c 	ldr	r3, [sp, #12]
30040508:	e1a02283 	lsl	r2, r3, #5
3004050c:	e59d3014 	ldr	r3, [sp, #20]
30040510:	e5832008 	str	r2, [r3, #8]
			break;
30040514:	ea000005 	b	30040530 <acoral_drv_register+0xac>
	ctrl=acoral_alloc_drv();
	if(ctrl==NULL)
		return ACORAL_ERR_NO_DRV_RES;
	ctrl->name=name;
	ctrl->ops=ops;
	for(i=0;i<ACORAL_DEV_NUM;i++){
30040518:	e59d300c 	ldr	r3, [sp, #12]
3004051c:	e2833001 	add	r3, r3, #1
30040520:	e58d300c 	str	r3, [sp, #12]
30040524:	e59d300c 	ldr	r3, [sp, #12]
30040528:	e3530013 	cmp	r3, #19
3004052c:	9affffe9 	bls	300404d8 <acoral_drv_register+0x54>
			drv_table[i]=ctrl;
			ctrl->drv_id=i<<DRV_MAIN_ID_SHIFT;
			break;
		}
	}
	if(i==ACORAL_DEV_NUM)
30040530:	e59d300c 	ldr	r3, [sp, #12]
30040534:	e3530014 	cmp	r3, #20
30040538:	1a000001 	bne	30040544 <acoral_drv_register+0xc0>
		return ACORAL_ERR_DRV_FULL;
3004053c:	e3a03005 	mov	r3, #5
30040540:	ea000000 	b	30040548 <acoral_drv_register+0xc4>
	return 0;
30040544:	e3a03000 	mov	r3, #0
}
30040548:	e1a00003 	mov	r0, r3
3004054c:	e28dd01c 	add	sp, sp, #28
30040550:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30040554:	e12fff1e 	bx	lr
30040558:	300ea334 	.word	0x300ea334

3004055c <acoral_drv_unregister>:

void acoral_drv_unregister(acoral_id res_id){
3004055c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30040560:	e24dd014 	sub	sp, sp, #20
30040564:	e58d0004 	str	r0, [sp, #4]
	acoral_drv_ctrl_t *ctrl=(acoral_drv_ctrl_t *)acoral_get_res_by_id(res_id);
30040568:	e59d0004 	ldr	r0, [sp, #4]
3004056c:	ebff0cc5 	bl	30003888 <acoral_get_res_by_id>
30040570:	e1a03000 	mov	r3, r0
30040574:	e58d300c 	str	r3, [sp, #12]
	if(ctrl->ops!=NULL&&ctrl->ops->close!=NULL)
30040578:	e59d300c 	ldr	r3, [sp, #12]
3004057c:	e5933004 	ldr	r3, [r3, #4]
30040580:	e3530000 	cmp	r3, #0
30040584:	0a000009 	beq	300405b0 <acoral_drv_unregister+0x54>
30040588:	e59d300c 	ldr	r3, [sp, #12]
3004058c:	e5933004 	ldr	r3, [r3, #4]
30040590:	e5933010 	ldr	r3, [r3, #16]
30040594:	e3530000 	cmp	r3, #0
30040598:	0a000004 	beq	300405b0 <acoral_drv_unregister+0x54>
		ctrl->ops->close();
3004059c:	e59d300c 	ldr	r3, [sp, #12]
300405a0:	e5933004 	ldr	r3, [r3, #4]
300405a4:	e5933010 	ldr	r3, [r3, #16]
300405a8:	e1a0e00f 	mov	lr, pc
300405ac:	e12fff13 	bx	r3
	drv_table[DRV_MAIN_ID(ctrl->drv_id)]=NULL;
300405b0:	e59d300c 	ldr	r3, [sp, #12]
300405b4:	e5933008 	ldr	r3, [r3, #8]
300405b8:	e1a022a3 	lsr	r2, r3, #5
300405bc:	e59f301c 	ldr	r3, [pc, #28]	; 300405e0 <acoral_drv_unregister+0x84>
300405c0:	e3a01000 	mov	r1, #0
300405c4:	e7831102 	str	r1, [r3, r2, lsl #2]
	acoral_release_res((acoral_res_t *)ctrl);
300405c8:	e59d300c 	ldr	r3, [sp, #12]
300405cc:	e1a00003 	mov	r0, r3
300405d0:	ebff0c18 	bl	30003638 <acoral_release_res>
}
300405d4:	e28dd014 	add	sp, sp, #20
300405d8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300405dc:	e12fff1e 	bx	lr
300405e0:	300ea334 	.word	0x300ea334

300405e4 <acoral_dev_open>:

acoral_id acoral_dev_open(acoral_char *name){
300405e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300405e8:	e24dd014 	sub	sp, sp, #20
300405ec:	e58d0004 	str	r0, [sp, #4]
	acoral_drv_ctrl_t *ctrl=acoral_get_drv_ctrl_by_name(name);
300405f0:	e59d0004 	ldr	r0, [sp, #4]
300405f4:	ebffff7f 	bl	300403f8 <acoral_get_drv_ctrl_by_name>
300405f8:	e1a03000 	mov	r3, r0
300405fc:	e58d300c 	str	r3, [sp, #12]
	if(ctrl==NULL)
30040600:	e59d300c 	ldr	r3, [sp, #12]
30040604:	e3530000 	cmp	r3, #0
30040608:	1a000001 	bne	30040614 <acoral_dev_open+0x30>
		return ACORAL_DEV_ERR_ID;
3004060c:	e3e03000 	mvn	r3, #0
30040610:	ea000014 	b	30040668 <acoral_dev_open+0x84>
	if(ctrl->ops!=NULL&&ctrl->ops->open!=NULL){
30040614:	e59d300c 	ldr	r3, [sp, #12]
30040618:	e5933004 	ldr	r3, [r3, #4]
3004061c:	e3530000 	cmp	r3, #0
30040620:	0a00000e 	beq	30040660 <acoral_dev_open+0x7c>
30040624:	e59d300c 	ldr	r3, [sp, #12]
30040628:	e5933004 	ldr	r3, [r3, #4]
3004062c:	e5933000 	ldr	r3, [r3]
30040630:	e3530000 	cmp	r3, #0
30040634:	0a000009 	beq	30040660 <acoral_dev_open+0x7c>
		if(ctrl->ops->open()!=0)
30040638:	e59d300c 	ldr	r3, [sp, #12]
3004063c:	e5933004 	ldr	r3, [r3, #4]
30040640:	e5933000 	ldr	r3, [r3]
30040644:	e1a0e00f 	mov	lr, pc
30040648:	e12fff13 	bx	r3
3004064c:	e1a03000 	mov	r3, r0
30040650:	e3530000 	cmp	r3, #0
30040654:	0a000001 	beq	30040660 <acoral_dev_open+0x7c>
			return ACORAL_DEV_ERR_ID;
30040658:	e3e03000 	mvn	r3, #0
3004065c:	ea000001 	b	30040668 <acoral_dev_open+0x84>
	}
	return ctrl->res.id;
30040660:	e59d300c 	ldr	r3, [sp, #12]
30040664:	e5933000 	ldr	r3, [r3]
}
30040668:	e1a00003 	mov	r0, r3
3004066c:	e28dd014 	add	sp, sp, #20
30040670:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30040674:	e12fff1e 	bx	lr

30040678 <acoral_dev_write>:

acoral_32 acoral_dev_write(acoral_id id,void *data,acoral_size size,acoral_size offset,acoral_time time_out){
30040678:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3004067c:	e24dd01c 	sub	sp, sp, #28
30040680:	e58d000c 	str	r0, [sp, #12]
30040684:	e58d1008 	str	r1, [sp, #8]
30040688:	e58d2004 	str	r2, [sp, #4]
3004068c:	e58d3000 	str	r3, [sp]
	acoral_drv_ctrl_t *ctrl=(acoral_drv_ctrl_t *)acoral_get_res_by_id(id);
30040690:	e59d000c 	ldr	r0, [sp, #12]
30040694:	ebff0c7b 	bl	30003888 <acoral_get_res_by_id>
30040698:	e1a03000 	mov	r3, r0
3004069c:	e58d3014 	str	r3, [sp, #20]
	if(ctrl!=NULL&&ctrl->ops!=NULL&&ctrl->ops->write!=NULL)
300406a0:	e59d3014 	ldr	r3, [sp, #20]
300406a4:	e3530000 	cmp	r3, #0
300406a8:	0a000013 	beq	300406fc <acoral_dev_write+0x84>
300406ac:	e59d3014 	ldr	r3, [sp, #20]
300406b0:	e5933004 	ldr	r3, [r3, #4]
300406b4:	e3530000 	cmp	r3, #0
300406b8:	0a00000f 	beq	300406fc <acoral_dev_write+0x84>
300406bc:	e59d3014 	ldr	r3, [sp, #20]
300406c0:	e5933004 	ldr	r3, [r3, #4]
300406c4:	e5933008 	ldr	r3, [r3, #8]
300406c8:	e3530000 	cmp	r3, #0
300406cc:	0a00000a 	beq	300406fc <acoral_dev_write+0x84>
		return ctrl->ops->write(data,size,offset,time_out);
300406d0:	e59d3014 	ldr	r3, [sp, #20]
300406d4:	e5933004 	ldr	r3, [r3, #4]
300406d8:	e593c008 	ldr	ip, [r3, #8]
300406dc:	e59d0008 	ldr	r0, [sp, #8]
300406e0:	e59d1004 	ldr	r1, [sp, #4]
300406e4:	e59d2000 	ldr	r2, [sp]
300406e8:	e59d3020 	ldr	r3, [sp, #32]
300406ec:	e1a0e00f 	mov	lr, pc
300406f0:	e12fff1c 	bx	ip
300406f4:	e1a03000 	mov	r3, r0
300406f8:	ea000000 	b	30040700 <acoral_dev_write+0x88>
	return 0;
300406fc:	e3a03000 	mov	r3, #0
}
30040700:	e1a00003 	mov	r0, r3
30040704:	e28dd01c 	add	sp, sp, #28
30040708:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3004070c:	e12fff1e 	bx	lr

30040710 <acoral_dev_read>:

acoral_32 acoral_dev_read(acoral_id id,void *data,acoral_size size,acoral_size offset,acoral_time time_out){
30040710:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30040714:	e24dd01c 	sub	sp, sp, #28
30040718:	e58d000c 	str	r0, [sp, #12]
3004071c:	e58d1008 	str	r1, [sp, #8]
30040720:	e58d2004 	str	r2, [sp, #4]
30040724:	e58d3000 	str	r3, [sp]
	acoral_drv_ctrl_t *ctrl=(acoral_drv_ctrl_t *)acoral_get_res_by_id(id);
30040728:	e59d000c 	ldr	r0, [sp, #12]
3004072c:	ebff0c55 	bl	30003888 <acoral_get_res_by_id>
30040730:	e1a03000 	mov	r3, r0
30040734:	e58d3014 	str	r3, [sp, #20]
	if(ctrl!=NULL&&ctrl->ops!=NULL&&ctrl->ops->read!=NULL)
30040738:	e59d3014 	ldr	r3, [sp, #20]
3004073c:	e3530000 	cmp	r3, #0
30040740:	0a000013 	beq	30040794 <acoral_dev_read+0x84>
30040744:	e59d3014 	ldr	r3, [sp, #20]
30040748:	e5933004 	ldr	r3, [r3, #4]
3004074c:	e3530000 	cmp	r3, #0
30040750:	0a00000f 	beq	30040794 <acoral_dev_read+0x84>
30040754:	e59d3014 	ldr	r3, [sp, #20]
30040758:	e5933004 	ldr	r3, [r3, #4]
3004075c:	e5933004 	ldr	r3, [r3, #4]
30040760:	e3530000 	cmp	r3, #0
30040764:	0a00000a 	beq	30040794 <acoral_dev_read+0x84>
		return ctrl->ops->read(data,size,offset,time_out);
30040768:	e59d3014 	ldr	r3, [sp, #20]
3004076c:	e5933004 	ldr	r3, [r3, #4]
30040770:	e593c004 	ldr	ip, [r3, #4]
30040774:	e59d0008 	ldr	r0, [sp, #8]
30040778:	e59d1004 	ldr	r1, [sp, #4]
3004077c:	e59d2000 	ldr	r2, [sp]
30040780:	e59d3020 	ldr	r3, [sp, #32]
30040784:	e1a0e00f 	mov	lr, pc
30040788:	e12fff1c 	bx	ip
3004078c:	e1a03000 	mov	r3, r0
30040790:	ea000000 	b	30040798 <acoral_dev_read+0x88>
	return 0;
30040794:	e3a03000 	mov	r3, #0
}
30040798:	e1a00003 	mov	r0, r3
3004079c:	e28dd01c 	add	sp, sp, #28
300407a0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300407a4:	e12fff1e 	bx	lr

300407a8 <acoral_dev_config>:

acoral_32 acoral_dev_config(acoral_id id,acoral_u32 cmd,void *data,acoral_time tm_out){
300407a8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300407ac:	e24dd01c 	sub	sp, sp, #28
300407b0:	e58d000c 	str	r0, [sp, #12]
300407b4:	e58d1008 	str	r1, [sp, #8]
300407b8:	e58d2004 	str	r2, [sp, #4]
300407bc:	e58d3000 	str	r3, [sp]
	acoral_drv_ctrl_t *ctrl=(acoral_drv_ctrl_t *)acoral_get_res_by_id(id);
300407c0:	e59d000c 	ldr	r0, [sp, #12]
300407c4:	ebff0c2f 	bl	30003888 <acoral_get_res_by_id>
300407c8:	e1a03000 	mov	r3, r0
300407cc:	e58d3014 	str	r3, [sp, #20]
	if(ctrl!=NULL&&ctrl->ops!=NULL&&ctrl->ops->config!=NULL)
300407d0:	e59d3014 	ldr	r3, [sp, #20]
300407d4:	e3530000 	cmp	r3, #0
300407d8:	0a000012 	beq	30040828 <acoral_dev_config+0x80>
300407dc:	e59d3014 	ldr	r3, [sp, #20]
300407e0:	e5933004 	ldr	r3, [r3, #4]
300407e4:	e3530000 	cmp	r3, #0
300407e8:	0a00000e 	beq	30040828 <acoral_dev_config+0x80>
300407ec:	e59d3014 	ldr	r3, [sp, #20]
300407f0:	e5933004 	ldr	r3, [r3, #4]
300407f4:	e593300c 	ldr	r3, [r3, #12]
300407f8:	e3530000 	cmp	r3, #0
300407fc:	0a000009 	beq	30040828 <acoral_dev_config+0x80>
		return ctrl->ops->config(cmd,data,tm_out);
30040800:	e59d3014 	ldr	r3, [sp, #20]
30040804:	e5933004 	ldr	r3, [r3, #4]
30040808:	e593300c 	ldr	r3, [r3, #12]
3004080c:	e59d0008 	ldr	r0, [sp, #8]
30040810:	e59d1004 	ldr	r1, [sp, #4]
30040814:	e59d2000 	ldr	r2, [sp]
30040818:	e1a0e00f 	mov	lr, pc
3004081c:	e12fff13 	bx	r3
30040820:	e1a03000 	mov	r3, r0
30040824:	ea000000 	b	3004082c <acoral_dev_config+0x84>
	return 0;	
30040828:	e3a03000 	mov	r3, #0
}
3004082c:	e1a00003 	mov	r0, r3
30040830:	e28dd01c 	add	sp, sp, #28
30040834:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30040838:	e12fff1e 	bx	lr

3004083c <acoral_dev_close>:
acoral_32 acoral_dev_close(acoral_id id){
3004083c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30040840:	e24dd014 	sub	sp, sp, #20
30040844:	e58d0004 	str	r0, [sp, #4]
	acoral_drv_ctrl_t *ctrl=(acoral_drv_ctrl_t *)acoral_get_res_by_id(id);
30040848:	e59d0004 	ldr	r0, [sp, #4]
3004084c:	ebff0c0d 	bl	30003888 <acoral_get_res_by_id>
30040850:	e1a03000 	mov	r3, r0
30040854:	e58d300c 	str	r3, [sp, #12]
	if(ctrl!=NULL&&ctrl->ops!=NULL&&ctrl->ops->close!=NULL)
30040858:	e59d300c 	ldr	r3, [sp, #12]
3004085c:	e3530000 	cmp	r3, #0
30040860:	0a00000f 	beq	300408a4 <acoral_dev_close+0x68>
30040864:	e59d300c 	ldr	r3, [sp, #12]
30040868:	e5933004 	ldr	r3, [r3, #4]
3004086c:	e3530000 	cmp	r3, #0
30040870:	0a00000b 	beq	300408a4 <acoral_dev_close+0x68>
30040874:	e59d300c 	ldr	r3, [sp, #12]
30040878:	e5933004 	ldr	r3, [r3, #4]
3004087c:	e5933010 	ldr	r3, [r3, #16]
30040880:	e3530000 	cmp	r3, #0
30040884:	0a000006 	beq	300408a4 <acoral_dev_close+0x68>
		return ctrl->ops->close();
30040888:	e59d300c 	ldr	r3, [sp, #12]
3004088c:	e5933004 	ldr	r3, [r3, #4]
30040890:	e5933010 	ldr	r3, [r3, #16]
30040894:	e1a0e00f 	mov	lr, pc
30040898:	e12fff13 	bx	r3
3004089c:	e1a03000 	mov	r3, r0
300408a0:	ea000000 	b	300408a8 <acoral_dev_close+0x6c>
	return 0;
300408a4:	e3a03000 	mov	r3, #0
}
300408a8:	e1a00003 	mov	r0, r3
300408ac:	e28dd014 	add	sp, sp, #20
300408b0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300408b4:	e12fff1e 	bx	lr

300408b8 <acoral_alloc_drv>:

acoral_drv_ctrl_t *acoral_alloc_drv(){
300408b8:	e92d4008 	push	{r3, lr}
  	return (acoral_drv_ctrl_t *)acoral_get_res(&acoral_drv_pool_ctrl);
300408bc:	e59f0010 	ldr	r0, [pc, #16]	; 300408d4 <acoral_alloc_drv+0x1c>
300408c0:	ebff0b11 	bl	3000350c <acoral_get_res>
300408c4:	e1a03000 	mov	r3, r0
}
300408c8:	e1a00003 	mov	r0, r3
300408cc:	e8bd4008 	pop	{r3, lr}
300408d0:	e12fff1e 	bx	lr
300408d4:	300eaaec 	.word	0x300eaaec

300408d8 <acoral_drv_pool_init>:


void acoral_drv_pool_init(){
300408d8:	e92d4008 	push	{r3, lr}
	acoral_drv_pool_ctrl.type=ACORAL_RES_DRIVER;
300408dc:	e59f3038 	ldr	r3, [pc, #56]	; 3004091c <acoral_drv_pool_init+0x44>
300408e0:	e3a02004 	mov	r2, #4
300408e4:	e5832000 	str	r2, [r3]
	acoral_drv_pool_ctrl.size=sizeof(acoral_drv_ctrl_t);
300408e8:	e59f302c 	ldr	r3, [pc, #44]	; 3004091c <acoral_drv_pool_init+0x44>
300408ec:	e3a02010 	mov	r2, #16
300408f0:	e5832004 	str	r2, [r3, #4]
	acoral_drv_pool_ctrl.num_per_pool=10;
300408f4:	e59f3020 	ldr	r3, [pc, #32]	; 3004091c <acoral_drv_pool_init+0x44>
300408f8:	e3a0200a 	mov	r2, #10
300408fc:	e5832008 	str	r2, [r3, #8]
	acoral_drv_pool_ctrl.max_pools=3;
30040900:	e59f3014 	ldr	r3, [pc, #20]	; 3004091c <acoral_drv_pool_init+0x44>
30040904:	e3a02003 	mov	r2, #3
30040908:	e5832010 	str	r2, [r3, #16]
	acoral_pool_ctrl_init(&acoral_drv_pool_ctrl);
3004090c:	e59f0008 	ldr	r0, [pc, #8]	; 3004091c <acoral_drv_pool_init+0x44>
30040910:	ebff0c5c 	bl	30003a88 <acoral_pool_ctrl_init>
}
30040914:	e8bd4008 	pop	{r3, lr}
30040918:	e12fff1e 	bx	lr
3004091c:	300eaaec 	.word	0x300eaaec

30040920 <acoral_drv_sys_init>:

void acoral_drv_sys_init(){
30040920:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30040924:	e24dd00c 	sub	sp, sp, #12
	acoral_u32 i;
	for(i=0;i<ACORAL_DEV_NUM;i++)
30040928:	e3a03000 	mov	r3, #0
3004092c:	e58d3004 	str	r3, [sp, #4]
30040930:	ea000006 	b	30040950 <acoral_drv_sys_init+0x30>
	  	drv_table[i]=NULL;	    
30040934:	e59d2004 	ldr	r2, [sp, #4]
30040938:	e59f3030 	ldr	r3, [pc, #48]	; 30040970 <acoral_drv_sys_init+0x50>
3004093c:	e3a01000 	mov	r1, #0
30040940:	e7831102 	str	r1, [r3, r2, lsl #2]
	acoral_pool_ctrl_init(&acoral_drv_pool_ctrl);
}

void acoral_drv_sys_init(){
	acoral_u32 i;
	for(i=0;i<ACORAL_DEV_NUM;i++)
30040944:	e59d3004 	ldr	r3, [sp, #4]
30040948:	e2833001 	add	r3, r3, #1
3004094c:	e58d3004 	str	r3, [sp, #4]
30040950:	e59d3004 	ldr	r3, [sp, #4]
30040954:	e3530013 	cmp	r3, #19
30040958:	9afffff5 	bls	30040934 <acoral_drv_sys_init+0x14>
	  	drv_table[i]=NULL;	    
	acoral_drv_pool_init();
3004095c:	ebffffdd 	bl	300408d8 <acoral_drv_pool_init>
	brd_driver_init();
30040960:	eb000003 	bl	30040974 <brd_driver_init>
}
30040964:	e28dd00c 	add	sp, sp, #12
30040968:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3004096c:	e12fff1e 	bx	lr
30040970:	300ea334 	.word	0x300ea334

30040974 <brd_driver_init>:
#include<autocfg.h>
void brd_driver_init(){
30040974:	e92d4008 	push	{r3, lr}
#ifdef CFG_DRV_CON_UART
	con_uart_init();
30040978:	eb00008c 	bl	30040bb0 <con_uart_init>
#endif
#ifdef CFG_DRV_CON_TELNET
	con_telnet_init();
3004097c:	eb000147 	bl	30040ea0 <con_telnet_init>
#endif
#ifdef CFG_DRV_SDI
        sd_init();
30040980:	eb000a23 	bl	30043214 <sd_init>
#ifdef CFG_DRV_TS
	ts_init();
#endif

#ifdef CFG_DRV_NET_DM9000
	dm9000_init();
30040984:	eb000cab 	bl	30043c38 <dm9000_init>
#endif
}
30040988:	e8bd4008 	pop	{r3, lr}
3004098c:	e12fff1e 	bx	lr

30040990 <uart_write>:
#define put_char(ch) uart_write(ch)
#define get_char(ch) uart_read(ch)
acoral_dev_ops_t console_ops;
void uart_init();

void uart_write(acoral_u8 ch){
30040990:	e24dd008 	sub	sp, sp, #8
30040994:	e1a03000 	mov	r3, r0
30040998:	e5cd3007 	strb	r3, [sp, #7]
	while(!(rUTRSTAT0 & 0x4));
3004099c:	e3a03205 	mov	r3, #1342177280	; 0x50000000
300409a0:	e2833010 	add	r3, r3, #16
300409a4:	e5933000 	ldr	r3, [r3]
300409a8:	e2033004 	and	r3, r3, #4
300409ac:	e3530000 	cmp	r3, #0
300409b0:	0afffff9 	beq	3004099c <uart_write+0xc>
	WrUTXH0(ch);
300409b4:	e3a03205 	mov	r3, #1342177280	; 0x50000000
300409b8:	e2833020 	add	r3, r3, #32
300409bc:	e5dd2007 	ldrb	r2, [sp, #7]
300409c0:	e5c32000 	strb	r2, [r3]
}
300409c4:	e28dd008 	add	sp, sp, #8
300409c8:	e12fff1e 	bx	lr

300409cc <uart_read>:

void uart_read(acoral_char *ch){
300409cc:	e24dd008 	sub	sp, sp, #8
300409d0:	e58d0004 	str	r0, [sp, #4]
	while(!(rUTRSTAT0 & 0x1));
300409d4:	e3a03205 	mov	r3, #1342177280	; 0x50000000
300409d8:	e2833010 	add	r3, r3, #16
300409dc:	e5933000 	ldr	r3, [r3]
300409e0:	e2033001 	and	r3, r3, #1
300409e4:	e3530000 	cmp	r3, #0
300409e8:	0afffff9 	beq	300409d4 <uart_read+0x8>
	*ch=RdURXH0();
300409ec:	e3a03205 	mov	r3, #1342177280	; 0x50000000
300409f0:	e2833024 	add	r3, r3, #36	; 0x24
300409f4:	e5d33000 	ldrb	r3, [r3]
300409f8:	e20320ff 	and	r2, r3, #255	; 0xff
300409fc:	e59d3004 	ldr	r3, [sp, #4]
30040a00:	e5c32000 	strb	r2, [r3]
}
30040a04:	e28dd008 	add	sp, sp, #8
30040a08:	e12fff1e 	bx	lr

30040a0c <console_write>:

acoral_32 console_write(void *data,acoral_u32 size,acoral_time tm_out){
30040a0c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30040a10:	e24dd01c 	sub	sp, sp, #28
30040a14:	e58d000c 	str	r0, [sp, #12]
30040a18:	e58d1008 	str	r1, [sp, #8]
30040a1c:	e58d2004 	str	r2, [sp, #4]
	acoral_u32 i;
  	char p;
	for(i=0;i<size;i++){
30040a20:	e3a03000 	mov	r3, #0
30040a24:	e58d3010 	str	r3, [sp, #16]
30040a28:	ea00000f 	b	30040a6c <console_write+0x60>
		p=*((acoral_char *)data+i);
30040a2c:	e59d200c 	ldr	r2, [sp, #12]
30040a30:	e59d3010 	ldr	r3, [sp, #16]
30040a34:	e0823003 	add	r3, r2, r3
30040a38:	e5d33000 	ldrb	r3, [r3]
30040a3c:	e5cd3017 	strb	r3, [sp, #23]
		if(p=='\n')
30040a40:	e5dd3017 	ldrb	r3, [sp, #23]
30040a44:	e353000a 	cmp	r3, #10
30040a48:	1a000001 	bne	30040a54 <console_write+0x48>
			put_char('\r');
30040a4c:	e3a0000d 	mov	r0, #13
30040a50:	ebffffce 	bl	30040990 <uart_write>
		put_char(p);
30040a54:	e5dd3017 	ldrb	r3, [sp, #23]
30040a58:	e1a00003 	mov	r0, r3
30040a5c:	ebffffcb 	bl	30040990 <uart_write>
}

acoral_32 console_write(void *data,acoral_u32 size,acoral_time tm_out){
	acoral_u32 i;
  	char p;
	for(i=0;i<size;i++){
30040a60:	e59d3010 	ldr	r3, [sp, #16]
30040a64:	e2833001 	add	r3, r3, #1
30040a68:	e58d3010 	str	r3, [sp, #16]
30040a6c:	e59d2010 	ldr	r2, [sp, #16]
30040a70:	e59d3008 	ldr	r3, [sp, #8]
30040a74:	e1520003 	cmp	r2, r3
30040a78:	3affffeb 	bcc	30040a2c <console_write+0x20>
		p=*((acoral_char *)data+i);
		if(p=='\n')
			put_char('\r');
		put_char(p);
	}
}
30040a7c:	e28dd01c 	add	sp, sp, #28
30040a80:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30040a84:	e12fff1e 	bx	lr

30040a88 <console_read>:

acoral_32 console_read(void *data,acoral_size size,acoral_size offset,acoral_time tm_out){
30040a88:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30040a8c:	e24dd01c 	sub	sp, sp, #28
30040a90:	e58d000c 	str	r0, [sp, #12]
30040a94:	e58d1008 	str	r1, [sp, #8]
30040a98:	e58d2004 	str	r2, [sp, #4]
30040a9c:	e58d3000 	str	r3, [sp]
	acoral_u32 i;
  	acoral_char *p;
	for(i=0;i<size;i++){
30040aa0:	e3a03000 	mov	r3, #0
30040aa4:	e58d3010 	str	r3, [sp, #16]
30040aa8:	ea000008 	b	30040ad0 <console_read+0x48>
		p=(acoral_char *)data+i;
30040aac:	e59d200c 	ldr	r2, [sp, #12]
30040ab0:	e59d3010 	ldr	r3, [sp, #16]
30040ab4:	e0823003 	add	r3, r2, r3
30040ab8:	e58d3014 	str	r3, [sp, #20]
		get_char(p);
30040abc:	e59d0014 	ldr	r0, [sp, #20]
30040ac0:	ebffffc1 	bl	300409cc <uart_read>
}

acoral_32 console_read(void *data,acoral_size size,acoral_size offset,acoral_time tm_out){
	acoral_u32 i;
  	acoral_char *p;
	for(i=0;i<size;i++){
30040ac4:	e59d3010 	ldr	r3, [sp, #16]
30040ac8:	e2833001 	add	r3, r3, #1
30040acc:	e58d3010 	str	r3, [sp, #16]
30040ad0:	e59d2010 	ldr	r2, [sp, #16]
30040ad4:	e59d3008 	ldr	r3, [sp, #8]
30040ad8:	e1520003 	cmp	r2, r3
30040adc:	3afffff2 	bcc	30040aac <console_read+0x24>
		p=(acoral_char *)data+i;
		get_char(p);
	}
	return size;
30040ae0:	e59d3008 	ldr	r3, [sp, #8]
}
30040ae4:	e1a00003 	mov	r0, r3
30040ae8:	e28dd01c 	add	sp, sp, #28
30040aec:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30040af0:	e12fff1e 	bx	lr

30040af4 <console_config>:

acoral_32 console_config(acoral_u32 cmd,void *data,acoral_time time_out){
30040af4:	e24dd010 	sub	sp, sp, #16
30040af8:	e58d000c 	str	r0, [sp, #12]
30040afc:	e58d1008 	str	r1, [sp, #8]
30040b00:	e58d2004 	str	r2, [sp, #4]
	switch(cmd){
30040b04:	e59d300c 	ldr	r3, [sp, #12]
30040b08:	e3530001 	cmp	r3, #1
30040b0c:	1a000002 	bne	30040b1c <console_config+0x28>
		case CONSOLE_ECHO:
			*(acoral_u8 *)data=1;
30040b10:	e59d3008 	ldr	r3, [sp, #8]
30040b14:	e3a02001 	mov	r2, #1
30040b18:	e5c32000 	strb	r2, [r3]
		default:
			break;
	}		
}
30040b1c:	e28dd010 	add	sp, sp, #16
30040b20:	e12fff1e 	bx	lr

30040b24 <console_open>:

acoral_32 console_open(){
30040b24:	e92d4008 	push	{r3, lr}
	uart_init();
30040b28:	eb000003 	bl	30040b3c <uart_init>
	return 0;
30040b2c:	e3a03000 	mov	r3, #0
}
30040b30:	e1a00003 	mov	r0, r3
30040b34:	e8bd4008 	pop	{r3, lr}
30040b38:	e12fff1e 	bx	lr

30040b3c <uart_init>:

void uart_init(){
	rUCON0=0x245;	
30040b3c:	e3a02245 	mov	r2, #1342177284	; 0x50000004
30040b40:	e3a03f91 	mov	r3, #580	; 0x244
30040b44:	e2833001 	add	r3, r3, #1
30040b48:	e5823000 	str	r3, [r2]
	rULCON0=0x3;	
30040b4c:	e3a03205 	mov	r3, #1342177280	; 0x50000000
30040b50:	e3a02003 	mov	r2, #3
30040b54:	e5832000 	str	r2, [r3]
	rUFCON0=0x0;	
30040b58:	e3a03285 	mov	r3, #1342177288	; 0x50000008
30040b5c:	e3a02000 	mov	r2, #0
30040b60:	e5832000 	str	r2, [r3]
	rUMCON0=0x0;	
30040b64:	e3a032c5 	mov	r3, #1342177292	; 0x5000000c
30040b68:	e3a02000 	mov	r2, #0
30040b6c:	e5832000 	str	r2, [r3]
	rUBRDIV0=(PCLK /(CFG_BAUD_RATE * 16))-1;
30040b70:	e3a03205 	mov	r3, #1342177280	; 0x50000000
30040b74:	e2833028 	add	r3, r3, #40	; 0x28
30040b78:	e3a0201a 	mov	r2, #26
30040b7c:	e5832000 	str	r2, [r3]
    rGPHCON = 0x0016faaa;
30040b80:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30040b84:	e2822070 	add	r2, r2, #112	; 0x70
30040b88:	e3a0395b 	mov	r3, #1490944	; 0x16c000
30040b8c:	e2833dea 	add	r3, r3, #14976	; 0x3a80
30040b90:	e283302a 	add	r3, r3, #42	; 0x2a
30040b94:	e5823000 	str	r3, [r2]
	rGPHUP  = 0x7ff;    /* The pull up function is disabled GPH[10:0]*/
30040b98:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30040b9c:	e2833078 	add	r3, r3, #120	; 0x78
30040ba0:	e3a02e7f 	mov	r2, #2032	; 0x7f0
30040ba4:	e282200f 	add	r2, r2, #15
30040ba8:	e5832000 	str	r2, [r3]
}
30040bac:	e12fff1e 	bx	lr

30040bb0 <con_uart_init>:

void con_uart_init(){
30040bb0:	e92d4008 	push	{r3, lr}
	console_ops.open=console_open;
30040bb4:	e59f203c 	ldr	r2, [pc, #60]	; 30040bf8 <con_uart_init+0x48>
30040bb8:	e59f303c 	ldr	r3, [pc, #60]	; 30040bfc <con_uart_init+0x4c>
30040bbc:	e5832000 	str	r2, [r3]
	console_ops.write=console_write;
30040bc0:	e59f2038 	ldr	r2, [pc, #56]	; 30040c00 <con_uart_init+0x50>
30040bc4:	e59f3030 	ldr	r3, [pc, #48]	; 30040bfc <con_uart_init+0x4c>
30040bc8:	e5832008 	str	r2, [r3, #8]
	console_ops.read=console_read;
30040bcc:	e59f3028 	ldr	r3, [pc, #40]	; 30040bfc <con_uart_init+0x4c>
30040bd0:	e59f202c 	ldr	r2, [pc, #44]	; 30040c04 <con_uart_init+0x54>
30040bd4:	e5832004 	str	r2, [r3, #4]
	console_ops.config=console_config;
30040bd8:	e59f301c 	ldr	r3, [pc, #28]	; 30040bfc <con_uart_init+0x4c>
30040bdc:	e59f2024 	ldr	r2, [pc, #36]	; 30040c08 <con_uart_init+0x58>
30040be0:	e583200c 	str	r2, [r3, #12]
  	acoral_drv_register(&console_ops,"console");
30040be4:	e59f0010 	ldr	r0, [pc, #16]	; 30040bfc <con_uart_init+0x4c>
30040be8:	e59f101c 	ldr	r1, [pc, #28]	; 30040c0c <con_uart_init+0x5c>
30040bec:	ebfffe24 	bl	30040484 <acoral_drv_register>
}
30040bf0:	e8bd4008 	pop	{r3, lr}
30040bf4:	e12fff1e 	bx	lr
30040bf8:	30040b24 	.word	0x30040b24
30040bfc:	3012a7f8 	.word	0x3012a7f8
30040c00:	30040a0c 	.word	0x30040a0c
30040c04:	30040a88 	.word	0x30040a88
30040c08:	30040af4 	.word	0x30040af4
30040c0c:	3004621c 	.word	0x3004621c

30040c10 <con_telnet_write>:
struct netconn *my_conn;
static struct netbuf *con_buf;
acoral_16 len;
acoral_u8 *net_data;

acoral_32 con_telnet_write(void *data,acoral_u32 size,acoral_time tm_out){
30040c10:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30040c14:	e24dd014 	sub	sp, sp, #20
30040c18:	e58d000c 	str	r0, [sp, #12]
30040c1c:	e58d1008 	str	r1, [sp, #8]
30040c20:	e58d2004 	str	r2, [sp, #4]
	netconn_write(my_conn,data,size,NETCONN_COPY);
30040c24:	e59f302c 	ldr	r3, [pc, #44]	; 30040c58 <con_telnet_write+0x48>
30040c28:	e5932000 	ldr	r2, [r3]
30040c2c:	e59d3008 	ldr	r3, [sp, #8]
30040c30:	e1a00002 	mov	r0, r2
30040c34:	e59d100c 	ldr	r1, [sp, #12]
30040c38:	e1a02003 	mov	r2, r3
30040c3c:	e3a03001 	mov	r3, #1
30040c40:	ebff31f8 	bl	3000d428 <netconn_write>
	return size;	
30040c44:	e59d3008 	ldr	r3, [sp, #8]
}
30040c48:	e1a00003 	mov	r0, r3
30040c4c:	e28dd014 	add	sp, sp, #20
30040c50:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30040c54:	e12fff1e 	bx	lr
30040c58:	3012d6d8 	.word	0x3012d6d8

30040c5c <con_telnet_read>:

acoral_32 con_telnet_read(void *data,acoral_size size,acoral_size offset,acoral_time tm_out){
30040c5c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30040c60:	e24dd01c 	sub	sp, sp, #28
30040c64:	e58d000c 	str	r0, [sp, #12]
30040c68:	e58d1008 	str	r1, [sp, #8]
30040c6c:	e58d2004 	str	r2, [sp, #4]
30040c70:	e58d3000 	str	r3, [sp]
  	acoral_u8 *p;
	acoral_u32 i;
	if(con_buf==NULL){
30040c74:	e59f3178 	ldr	r3, [pc, #376]	; 30040df4 <con_telnet_read+0x198>
30040c78:	e5933000 	ldr	r3, [r3]
30040c7c:	e3530000 	cmp	r3, #0
30040c80:	1a000014 	bne	30040cd8 <con_telnet_read+0x7c>
		con_buf=netconn_recv(my_conn);
30040c84:	e59f316c 	ldr	r3, [pc, #364]	; 30040df8 <con_telnet_read+0x19c>
30040c88:	e5933000 	ldr	r3, [r3]
30040c8c:	e1a00003 	mov	r0, r3
30040c90:	ebff3100 	bl	3000d098 <netconn_recv>
30040c94:	e1a02000 	mov	r2, r0
30040c98:	e59f3154 	ldr	r3, [pc, #340]	; 30040df4 <con_telnet_read+0x198>
30040c9c:	e5832000 	str	r2, [r3]
		if(con_buf==NULL)
30040ca0:	e59f314c 	ldr	r3, [pc, #332]	; 30040df4 <con_telnet_read+0x198>
30040ca4:	e5933000 	ldr	r3, [r3]
30040ca8:	e3530000 	cmp	r3, #0
30040cac:	1a000001 	bne	30040cb8 <con_telnet_read+0x5c>
			return 0;
30040cb0:	e3a03000 	mov	r3, #0
30040cb4:	ea00004a 	b	30040de4 <con_telnet_read+0x188>
		netbuf_data(con_buf, &net_data, &len);
30040cb8:	e59f3134 	ldr	r3, [pc, #308]	; 30040df4 <con_telnet_read+0x198>
30040cbc:	e5931000 	ldr	r1, [r3]
30040cc0:	e59f2134 	ldr	r2, [pc, #308]	; 30040dfc <con_telnet_read+0x1a0>
30040cc4:	e59f3134 	ldr	r3, [pc, #308]	; 30040e00 <con_telnet_read+0x1a4>
30040cc8:	e1a00001 	mov	r0, r1
30040ccc:	e1a01002 	mov	r1, r2
30040cd0:	e1a02003 	mov	r2, r3
30040cd4:	ebff3a04 	bl	3000f4ec <netbuf_data>
	}
	for(i=0;i<size;i++){
30040cd8:	e3a03000 	mov	r3, #0
30040cdc:	e58d3014 	str	r3, [sp, #20]
30040ce0:	ea00003a 	b	30040dd0 <con_telnet_read+0x174>
		if(len-->0){
30040ce4:	e59f3114 	ldr	r3, [pc, #276]	; 30040e00 <con_telnet_read+0x1a4>
30040ce8:	e1d330b0 	ldrh	r3, [r3]
30040cec:	e1a02803 	lsl	r2, r3, #16
30040cf0:	e1a02842 	asr	r2, r2, #16
30040cf4:	e3520000 	cmp	r2, #0
30040cf8:	d3a02000 	movle	r2, #0
30040cfc:	c3a02001 	movgt	r2, #1
30040d00:	e20220ff 	and	r2, r2, #255	; 0xff
30040d04:	e2433001 	sub	r3, r3, #1
30040d08:	e1a03803 	lsl	r3, r3, #16
30040d0c:	e1a01823 	lsr	r1, r3, #16
30040d10:	e59f30e8 	ldr	r3, [pc, #232]	; 30040e00 <con_telnet_read+0x1a4>
30040d14:	e1c310b0 	strh	r1, [r3]
30040d18:	e3520000 	cmp	r2, #0
30040d1c:	0a00000c 	beq	30040d54 <con_telnet_read+0xf8>
			p=(acoral_u8 *)data+i;
30040d20:	e59d200c 	ldr	r2, [sp, #12]
30040d24:	e59d3014 	ldr	r3, [sp, #20]
30040d28:	e0823003 	add	r3, r2, r3
30040d2c:	e58d3010 	str	r3, [sp, #16]
			*p=*net_data++;
30040d30:	e59f30c4 	ldr	r3, [pc, #196]	; 30040dfc <con_telnet_read+0x1a0>
30040d34:	e5933000 	ldr	r3, [r3]
30040d38:	e5d31000 	ldrb	r1, [r3]
30040d3c:	e59d2010 	ldr	r2, [sp, #16]
30040d40:	e5c21000 	strb	r1, [r2]
30040d44:	e2832001 	add	r2, r3, #1
30040d48:	e59f30ac 	ldr	r3, [pc, #172]	; 30040dfc <con_telnet_read+0x1a0>
30040d4c:	e5832000 	str	r2, [r3]
30040d50:	ea00001b 	b	30040dc4 <con_telnet_read+0x168>
		}else{
			if(netbuf_next(con_buf)>= 0){
30040d54:	e59f3098 	ldr	r3, [pc, #152]	; 30040df4 <con_telnet_read+0x198>
30040d58:	e5933000 	ldr	r3, [r3]
30040d5c:	e1a00003 	mov	r0, r3
30040d60:	ebff39fb 	bl	3000f554 <netbuf_next>
30040d64:	e1a03000 	mov	r3, r0
30040d68:	e20330ff 	and	r3, r3, #255	; 0xff
30040d6c:	e1a03c03 	lsl	r3, r3, #24
30040d70:	e1a03c43 	asr	r3, r3, #24
30040d74:	e3530000 	cmp	r3, #0
30040d78:	ba000008 	blt	30040da0 <con_telnet_read+0x144>
				netbuf_data(con_buf, &net_data, &len);
30040d7c:	e59f3070 	ldr	r3, [pc, #112]	; 30040df4 <con_telnet_read+0x198>
30040d80:	e5931000 	ldr	r1, [r3]
30040d84:	e59f2070 	ldr	r2, [pc, #112]	; 30040dfc <con_telnet_read+0x1a0>
30040d88:	e59f3070 	ldr	r3, [pc, #112]	; 30040e00 <con_telnet_read+0x1a4>
30040d8c:	e1a00001 	mov	r0, r1
30040d90:	e1a01002 	mov	r1, r2
30040d94:	e1a02003 	mov	r2, r3
30040d98:	ebff39d3 	bl	3000f4ec <netbuf_data>
30040d9c:	ea000008 	b	30040dc4 <con_telnet_read+0x168>
			}
			else{
				netbuf_delete(con_buf);
30040da0:	e59f304c 	ldr	r3, [pc, #76]	; 30040df4 <con_telnet_read+0x198>
30040da4:	e5933000 	ldr	r3, [r3]
30040da8:	e1a00003 	mov	r0, r3
30040dac:	ebff392e 	bl	3000f26c <netbuf_delete>
				con_buf=NULL;
30040db0:	e59f303c 	ldr	r3, [pc, #60]	; 30040df4 <con_telnet_read+0x198>
30040db4:	e3a02000 	mov	r2, #0
30040db8:	e5832000 	str	r2, [r3]
				return i;
30040dbc:	e59d3014 	ldr	r3, [sp, #20]
30040dc0:	ea000007 	b	30040de4 <con_telnet_read+0x188>
		con_buf=netconn_recv(my_conn);
		if(con_buf==NULL)
			return 0;
		netbuf_data(con_buf, &net_data, &len);
	}
	for(i=0;i<size;i++){
30040dc4:	e59d3014 	ldr	r3, [sp, #20]
30040dc8:	e2833001 	add	r3, r3, #1
30040dcc:	e58d3014 	str	r3, [sp, #20]
30040dd0:	e59d2014 	ldr	r2, [sp, #20]
30040dd4:	e59d3008 	ldr	r3, [sp, #8]
30040dd8:	e1520003 	cmp	r2, r3
30040ddc:	3affffc0 	bcc	30040ce4 <con_telnet_read+0x88>
				con_buf=NULL;
				return i;
			}
		}	
	}
	return i;
30040de0:	e59d3014 	ldr	r3, [sp, #20]
}
30040de4:	e1a00003 	mov	r0, r3
30040de8:	e28dd01c 	add	sp, sp, #28
30040dec:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30040df0:	e12fff1e 	bx	lr
30040df4:	300ea2e8 	.word	0x300ea2e8
30040df8:	3012d6d8 	.word	0x3012d6d8
30040dfc:	3012d72c 	.word	0x3012d72c
30040e00:	302f7e20 	.word	0x302f7e20

30040e04 <con_telnet_config>:

acoral_32 con_telnet_config(acoral_u32 cmd,void *data,acoral_time time_out){
30040e04:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30040e08:	e24dd014 	sub	sp, sp, #20
30040e0c:	e58d000c 	str	r0, [sp, #12]
30040e10:	e58d1008 	str	r1, [sp, #8]
30040e14:	e58d2004 	str	r2, [sp, #4]
	switch(cmd){
30040e18:	e59d300c 	ldr	r3, [sp, #12]
30040e1c:	e2433001 	sub	r3, r3, #1
30040e20:	e3530003 	cmp	r3, #3
30040e24:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30040e28:	ea000017 	b	30040e8c <con_telnet_config+0x88>
30040e2c:	30040e3c 	.word	0x30040e3c
30040e30:	30040e4c 	.word	0x30040e4c
30040e34:	30040e7c 	.word	0x30040e7c
30040e38:	30040e5c 	.word	0x30040e5c
		case CONSOLE_ECHO:
			*(acoral_u8 *)data=0;
30040e3c:	e59d3008 	ldr	r3, [sp, #8]
30040e40:	e3a02000 	mov	r2, #0
30040e44:	e5c32000 	strb	r2, [r3]
			break;
30040e48:	ea00000f 	b	30040e8c <con_telnet_config+0x88>
		case CONSOLE_SET_PRIV_DATA:
			my_conn=(struct netconn *)data;
30040e4c:	e59d2008 	ldr	r2, [sp, #8]
30040e50:	e59f3040 	ldr	r3, [pc, #64]	; 30040e98 <con_telnet_config+0x94>
30040e54:	e5832000 	str	r2, [r3]
			break;
30040e58:	ea00000b 	b	30040e8c <con_telnet_config+0x88>
		case CONSOLE_BUF_CLEAR:
			netbuf_delete(con_buf);
30040e5c:	e59f3038 	ldr	r3, [pc, #56]	; 30040e9c <con_telnet_config+0x98>
30040e60:	e5933000 	ldr	r3, [r3]
30040e64:	e1a00003 	mov	r0, r3
30040e68:	ebff38ff 	bl	3000f26c <netbuf_delete>
			con_buf=NULL;
30040e6c:	e59f3028 	ldr	r3, [pc, #40]	; 30040e9c <con_telnet_config+0x98>
30040e70:	e3a02000 	mov	r2, #0
30040e74:	e5832000 	str	r2, [r3]
			break;
30040e78:	ea000003 	b	30040e8c <con_telnet_config+0x88>
		case CONSOLE_EXIT:
			netconn_delete(my_conn);
30040e7c:	e59f3014 	ldr	r3, [pc, #20]	; 30040e98 <con_telnet_config+0x94>
30040e80:	e5933000 	ldr	r3, [r3]
30040e84:	e1a00003 	mov	r0, r3
30040e88:	ebff2fcd 	bl	3000cdc4 <netconn_delete>
			break;
		default:
			break;
	}		
}
30040e8c:	e28dd014 	add	sp, sp, #20
30040e90:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30040e94:	e12fff1e 	bx	lr
30040e98:	3012d6d8 	.word	0x3012d6d8
30040e9c:	300ea2e8 	.word	0x300ea2e8

30040ea0 <con_telnet_init>:

void con_telnet_init(){
30040ea0:	e92d4008 	push	{r3, lr}
	con_telnet_ops.write=con_telnet_write;
30040ea4:	e59f2048 	ldr	r2, [pc, #72]	; 30040ef4 <con_telnet_init+0x54>
30040ea8:	e59f3048 	ldr	r3, [pc, #72]	; 30040ef8 <con_telnet_init+0x58>
30040eac:	e5832008 	str	r2, [r3, #8]
	con_telnet_ops.read=con_telnet_read;
30040eb0:	e59f3040 	ldr	r3, [pc, #64]	; 30040ef8 <con_telnet_init+0x58>
30040eb4:	e59f2040 	ldr	r2, [pc, #64]	; 30040efc <con_telnet_init+0x5c>
30040eb8:	e5832004 	str	r2, [r3, #4]
	con_telnet_ops.config=con_telnet_config;
30040ebc:	e59f3034 	ldr	r3, [pc, #52]	; 30040ef8 <con_telnet_init+0x58>
30040ec0:	e59f2038 	ldr	r2, [pc, #56]	; 30040f00 <con_telnet_init+0x60>
30040ec4:	e583200c 	str	r2, [r3, #12]
	con_telnet_ops.open=NULL;
30040ec8:	e59f3028 	ldr	r3, [pc, #40]	; 30040ef8 <con_telnet_init+0x58>
30040ecc:	e3a02000 	mov	r2, #0
30040ed0:	e5832000 	str	r2, [r3]
	con_buf=NULL;
30040ed4:	e59f3028 	ldr	r3, [pc, #40]	; 30040f04 <con_telnet_init+0x64>
30040ed8:	e3a02000 	mov	r2, #0
30040edc:	e5832000 	str	r2, [r3]
  	acoral_drv_register(&con_telnet_ops,"con_telnet");
30040ee0:	e59f0010 	ldr	r0, [pc, #16]	; 30040ef8 <con_telnet_init+0x58>
30040ee4:	e59f101c 	ldr	r1, [pc, #28]	; 30040f08 <con_telnet_init+0x68>
30040ee8:	ebfffd65 	bl	30040484 <acoral_drv_register>
}
30040eec:	e8bd4008 	pop	{r3, lr}
30040ef0:	e12fff1e 	bx	lr
30040ef4:	30040c10 	.word	0x30040c10
30040ef8:	300ea384 	.word	0x300ea384
30040efc:	30040c5c 	.word	0x30040c5c
30040f00:	30040e04 	.word	0x30040e04
30040f04:	300ea2e8 	.word	0x300ea2e8
30040f08:	30046224 	.word	0x30046224

30040f0c <SDI_Init>:
*********************************************************
*   					 函数
*********************************************************
*/

acoral_u32 SDI_Init(void) {
30040f0c:	e92d4008 	push	{r3, lr}
    rGPEUP  = 0xf83f;     // SDCMD, SDDAT[3:0] => PU En.
30040f10:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30040f14:	e2833048 	add	r3, r3, #72	; 0x48
30040f18:	e3a02b3e 	mov	r2, #63488	; 0xf800
30040f1c:	e282203f 	add	r2, r2, #63	; 0x3f
30040f20:	e5832000 	str	r2, [r3]
    rGPECON = 0xaaaaaaaa;	//SDCMD, SDDAT[3:0]
30040f24:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30040f28:	e2822040 	add	r2, r2, #64	; 0x40
30040f2c:	e3a03caa 	mov	r3, #43520	; 0xaa00
30040f30:	e28330aa 	add	r3, r3, #170	; 0xaa
30040f34:	e1833803 	orr	r3, r3, r3, lsl #16
30040f38:	e5823000 	str	r3, [r2]
    return SD_card_init(&CardInf);
30040f3c:	e59f0010 	ldr	r0, [pc, #16]	; 30040f54 <SDI_Init+0x48>
30040f40:	eb000059 	bl	300410ac <SD_card_init>
30040f44:	e1a03000 	mov	r3, r0
}
30040f48:	e1a00003 	mov	r0, r3
30040f4c:	e8bd4008 	pop	{r3, lr}
30040f50:	e12fff1e 	bx	lr
30040f54:	3012d6e8 	.word	0x3012d6e8

30040f58 <Delay>:


void Delay(int time) {
30040f58:	e24dd010 	sub	sp, sp, #16
30040f5c:	e58d0004 	str	r0, [sp, #4]
	acoral_u32 val = (PCLK>>3)/1000-1;
30040f60:	e3a03d61 	mov	r3, #6208	; 0x1840
30040f64:	e2833029 	add	r3, r3, #41	; 0x29
30040f68:	e58d300c 	str	r3, [sp, #12]

	rTCFG0 &= ~(0xff<<8);
30040f6c:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30040f70:	e3a02451 	mov	r2, #1358954496	; 0x51000000
30040f74:	e5922000 	ldr	r2, [r2]
30040f78:	e3c22cff 	bic	r2, r2, #65280	; 0xff00
30040f7c:	e5832000 	str	r2, [r3]
	rTCFG0 |= 3<<8;			//prescaler = 3+1
30040f80:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30040f84:	e3a02451 	mov	r2, #1358954496	; 0x51000000
30040f88:	e5922000 	ldr	r2, [r2]
30040f8c:	e3822c03 	orr	r2, r2, #768	; 0x300
30040f90:	e5832000 	str	r2, [r3]
	rTCFG1 &= ~(0xf<<12);
30040f94:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30040f98:	e2833004 	add	r3, r3, #4
30040f9c:	e3a02451 	mov	r2, #1358954496	; 0x51000000
30040fa0:	e2822004 	add	r2, r2, #4
30040fa4:	e5922000 	ldr	r2, [r2]
30040fa8:	e3c22a0f 	bic	r2, r2, #61440	; 0xf000
30040fac:	e5832000 	str	r2, [r3]
	rTCFG1 |= 0<<12;		//mux = 1/2
30040fb0:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30040fb4:	e2833004 	add	r3, r3, #4
30040fb8:	e3a02451 	mov	r2, #1358954496	; 0x51000000
30040fbc:	e2822004 	add	r2, r2, #4
30040fc0:	e5922000 	ldr	r2, [r2]
30040fc4:	e5832000 	str	r2, [r3]

	rTCNTB3 = val;
30040fc8:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30040fcc:	e2833030 	add	r3, r3, #48	; 0x30
30040fd0:	e59d200c 	ldr	r2, [sp, #12]
30040fd4:	e5832000 	str	r2, [r3]
	rTCMPB3 = val>>1;		// 50%
30040fd8:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30040fdc:	e2833034 	add	r3, r3, #52	; 0x34
30040fe0:	e59d200c 	ldr	r2, [sp, #12]
30040fe4:	e1a020a2 	lsr	r2, r2, #1
30040fe8:	e5832000 	str	r2, [r3]
	rTCON &= ~(0xf<<16);
30040fec:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30040ff0:	e2833008 	add	r3, r3, #8
30040ff4:	e3a02451 	mov	r2, #1358954496	; 0x51000000
30040ff8:	e2822008 	add	r2, r2, #8
30040ffc:	e5922000 	ldr	r2, [r2]
30041000:	e3c2280f 	bic	r2, r2, #983040	; 0xf0000
30041004:	e5832000 	str	r2, [r3]
	rTCON |= 0xb<<16;		//interval, inv-off, update TCNTB3&TCMPB3, start timer 3
30041008:	e3a03451 	mov	r3, #1358954496	; 0x51000000
3004100c:	e2833008 	add	r3, r3, #8
30041010:	e3a02451 	mov	r2, #1358954496	; 0x51000000
30041014:	e2822008 	add	r2, r2, #8
30041018:	e5922000 	ldr	r2, [r2]
3004101c:	e382280b 	orr	r2, r2, #720896	; 0xb0000
30041020:	e5832000 	str	r2, [r3]
	rTCON &= ~(2<<16);		//clear manual update bit
30041024:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30041028:	e2833008 	add	r3, r3, #8
3004102c:	e3a02451 	mov	r2, #1358954496	; 0x51000000
30041030:	e2822008 	add	r2, r2, #8
30041034:	e5922000 	ldr	r2, [r2]
30041038:	e3c22802 	bic	r2, r2, #131072	; 0x20000
3004103c:	e5832000 	str	r2, [r3]
	while(time--) {
30041040:	ea00000d 	b	3004107c <Delay+0x124>
		while(rTCNTO3>=val>>1);
30041044:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30041048:	e2833038 	add	r3, r3, #56	; 0x38
3004104c:	e5932000 	ldr	r2, [r3]
30041050:	e59d300c 	ldr	r3, [sp, #12]
30041054:	e1a030a3 	lsr	r3, r3, #1
30041058:	e1520003 	cmp	r2, r3
3004105c:	2afffff8 	bcs	30041044 <Delay+0xec>
		while(rTCNTO3<val>>1);
30041060:	e3a03451 	mov	r3, #1358954496	; 0x51000000
30041064:	e2833038 	add	r3, r3, #56	; 0x38
30041068:	e5932000 	ldr	r2, [r3]
3004106c:	e59d300c 	ldr	r3, [sp, #12]
30041070:	e1a030a3 	lsr	r3, r3, #1
30041074:	e1520003 	cmp	r2, r3
30041078:	3afffff8 	bcc	30041060 <Delay+0x108>
	rTCNTB3 = val;
	rTCMPB3 = val>>1;		// 50%
	rTCON &= ~(0xf<<16);
	rTCON |= 0xb<<16;		//interval, inv-off, update TCNTB3&TCMPB3, start timer 3
	rTCON &= ~(2<<16);		//clear manual update bit
	while(time--) {
3004107c:	e59d3004 	ldr	r3, [sp, #4]
30041080:	e3530000 	cmp	r3, #0
30041084:	03a03000 	moveq	r3, #0
30041088:	13a03001 	movne	r3, #1
3004108c:	e20330ff 	and	r3, r3, #255	; 0xff
30041090:	e59d2004 	ldr	r2, [sp, #4]
30041094:	e2422001 	sub	r2, r2, #1
30041098:	e58d2004 	str	r2, [sp, #4]
3004109c:	e3530000 	cmp	r3, #0
300410a0:	1affffe7 	bne	30041044 <Delay+0xec>
		while(rTCNTO3>=val>>1);
		while(rTCNTO3<val>>1);
	};
}
300410a4:	e28dd010 	add	sp, sp, #16
300410a8:	e12fff1e 	bx	lr

300410ac <SD_card_init>:

acoral_32 SD_card_init(card_desc *CardInfo) {
300410ac:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300410b0:	e24dd014 	sub	sp, sp, #20
300410b4:	e58d0004 	str	r0, [sp, #4]
		//-- SD controller & card initialize

		int i;
		card_desc *pCardInfo = CardInfo;
300410b8:	e59d3004 	ldr	r3, [sp, #4]
300410bc:	e58d300c 	str	r3, [sp, #12]
		pCardInfo->RCA = 0;
300410c0:	e59d300c 	ldr	r3, [sp, #12]
300410c4:	e3a02000 	mov	r2, #0
300410c8:	e583201c 	str	r2, [r3, #28]

		/* Important notice for MMC test condition */
		/* Cmd & Data lines must be enabled by pull up resister */

		SD_Set_IOPort();
300410cc:	eb00013a 	bl	300415bc <SD_Set_IOPort>

		rSDIPRE = PCLK/(INICLK) - 1;	// 400KHz
300410d0:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300410d4:	e2833004 	add	r3, r3, #4
300410d8:	e3a020a5 	mov	r2, #165	; 0xa5
300410dc:	e5832000 	str	r2, [r3]
		acoral_print("Initial Frequency is %dKHz\n",(PCLK/(rSDIPRE+1))/1000 );
300410e0:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300410e4:	e2833004 	add	r3, r3, #4
300410e8:	e5933000 	ldr	r3, [r3]
300410ec:	e2833001 	add	r3, r3, #1
300410f0:	e3a00cc3 	mov	r0, #49920	; 0xc300
300410f4:	e2800050 	add	r0, r0, #80	; 0x50
300410f8:	e1a01003 	mov	r1, r3
300410fc:	eb000ae7 	bl	30043ca0 <__aeabi_uidiv>
30041100:	e1a03000 	mov	r3, r0
30041104:	e59f0408 	ldr	r0, [pc, #1032]	; 30041514 <SD_card_init+0x468>
30041108:	e1a01003 	mov	r1, r3
3004110c:	ebff284b 	bl	3000b240 <acoral_print>

		rSDICON = (1<<4)|1; 			// Type B, clk enable
30041110:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041114:	e3a02011 	mov	r2, #17
30041118:	e5832000 	str	r2, [r3]
		rSDIFSTA = rSDIFSTA|(1<<16);	// YH 040223 FIFO reset
3004111c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041120:	e2833038 	add	r3, r3, #56	; 0x38
30041124:	e3a0245a 	mov	r2, #1509949440	; 0x5a000000
30041128:	e2822038 	add	r2, r2, #56	; 0x38
3004112c:	e5922000 	ldr	r2, [r2]
30041130:	e3822801 	orr	r2, r2, #65536	; 0x10000
30041134:	e5832000 	str	r2, [r3]
		rSDIBSIZE = 0x200;				// 512byte(128word)
30041138:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004113c:	e2833028 	add	r3, r3, #40	; 0x28
30041140:	e3a02c02 	mov	r2, #512	; 0x200
30041144:	e5832000 	str	r2, [r3]
		rSDIDTIMER = MAX_DATABUSY_TIMEOUT;			// Set timeout count
30041148:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004114c:	e2833024 	add	r3, r3, #36	; 0x24
30041150:	e3a02502 	mov	r2, #8388608	; 0x800000
30041154:	e2422001 	sub	r2, r2, #1
30041158:	e5832000 	str	r2, [r3]

		for(i = 0; i < 0x1000; i++);	// Wait 74 SDCLK for MMC card
3004115c:	e3a03000 	mov	r3, #0
30041160:	e58d3008 	str	r3, [sp, #8]
30041164:	ea000002 	b	30041174 <SD_card_init+0xc8>
30041168:	e59d3008 	ldr	r3, [sp, #8]
3004116c:	e2833001 	add	r3, r3, #1
30041170:	e58d3008 	str	r3, [sp, #8]
30041174:	e59d2008 	ldr	r2, [sp, #8]
30041178:	e3a03eff 	mov	r3, #4080	; 0xff0
3004117c:	e283300f 	add	r3, r3, #15
30041180:	e1520003 	cmp	r2, r3
30041184:	dafffff7 	ble	30041168 <SD_card_init+0xbc>

		CMD0();
30041188:	eb00018f 	bl	300417cc <CMD0>
		//acoral_print("Card is in idle\n");

		//-- Check MMC card OCR
		if (Chk_MMC_OCR() == ENUM_CARD_TYPE_MMC)	//ACMD1
3004118c:	eb000226 	bl	30041a2c <Chk_MMC_OCR>
30041190:	e1a03000 	mov	r3, r0
30041194:	e3530000 	cmp	r3, #0
30041198:	1a000005 	bne	300411b4 <SD_card_init+0x108>
		{
			acoral_print("MMC check end!!\nIn MMC ready\n");
3004119c:	e59f0374 	ldr	r0, [pc, #884]	; 30041518 <SD_card_init+0x46c>
300411a0:	ebff2826 	bl	3000b240 <acoral_print>
			pCardInfo->Card_Type = ENUM_CARD_TYPE_MMC;
300411a4:	e59d300c 	ldr	r3, [sp, #12]
300411a8:	e3a02000 	mov	r2, #0
300411ac:	e5c32000 	strb	r2, [r3]
			goto RECMD2;
300411b0:	ea00001b 	b	30041224 <SD_card_init+0x178>
		}
		else
		{
			pCardInfo->Card_Type = ENUM_CARD_TYPE_SD;
300411b4:	e59d300c 	ldr	r3, [sp, #12]
300411b8:	e3a02001 	mov	r2, #1
300411bc:	e5c32000 	strb	r2, [r3]
		}

		//-- Check SD card OCR

		if (!CMD8())
300411c0:	eb000193 	bl	30041814 <CMD8>
300411c4:	e1a03000 	mov	r3, r0
300411c8:	e3530000 	cmp	r3, #0
300411cc:	1a000001 	bne	300411d8 <SD_card_init+0x12c>
		{
			return 0;
300411d0:	e3a03000 	mov	r3, #0
300411d4:	ea0000ca 	b	30041504 <SD_card_init+0x458>
		}

		i = Chk_SD_OCR();	//ACMD41
300411d8:	eb000265 	bl	30041b74 <Chk_SD_OCR>
300411dc:	e1a03000 	mov	r3, r0
300411e0:	e58d3008 	str	r3, [sp, #8]
		if (i == 1)
300411e4:	e59d3008 	ldr	r3, [sp, #8]
300411e8:	e3530001 	cmp	r3, #1
300411ec:	1a000003 	bne	30041200 <SD_card_init+0x154>
		{
			//acoral_print("----SD Card is Ready----\n");
			pCardInfo->Card_Capacity_Stat = ENUM_High_Capacity;
300411f0:	e59d300c 	ldr	r3, [sp, #12]
300411f4:	e3a02000 	mov	r2, #0
300411f8:	e5c32001 	strb	r2, [r3, #1]
300411fc:	ea000008 	b	30041224 <SD_card_init+0x178>
		}
		else if (i == 2)
30041200:	e59d3008 	ldr	r3, [sp, #8]
30041204:	e3530002 	cmp	r3, #2
30041208:	1a000003 	bne	3004121c <SD_card_init+0x170>
		{
			pCardInfo->Card_Capacity_Stat = ENUM_Standard_Capacity;
3004120c:	e59d300c 	ldr	r3, [sp, #12]
30041210:	e3a02001 	mov	r2, #1
30041214:	e5c32001 	strb	r2, [r3, #1]
30041218:	ea000001 	b	30041224 <SD_card_init+0x178>
		}
		else
		{
			return 0;
3004121c:	e3a03000 	mov	r3, #0
30041220:	ea0000b7 	b	30041504 <SD_card_init+0x458>
		}


	RECMD2:
		//-- Check attached cards, it makes card identification state
		if(CMD2())			//Get_CID
30041224:	eb0001ac 	bl	300418dc <CMD2>
30041228:	e1a03000 	mov	r3, r0
3004122c:	e3530000 	cmp	r3, #0
30041230:	0a00005e 	beq	300413b0 <SD_card_init+0x304>
		{
			pCardInfo->Maker_ID = ((rSDIRSP0 & 0xff000000) >> 24);
30041234:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041238:	e2833014 	add	r3, r3, #20
3004123c:	e5933000 	ldr	r3, [r3]
30041240:	e1a03c23 	lsr	r3, r3, #24
30041244:	e1a02003 	mov	r2, r3
30041248:	e59d300c 	ldr	r3, [sp, #12]
3004124c:	e5832004 	str	r2, [r3, #4]
			pCardInfo->Product_Name[0] = (rSDIRSP0&0xff0000)>>16;
30041250:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041254:	e2833014 	add	r3, r3, #20
30041258:	e5933000 	ldr	r3, [r3]
3004125c:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
30041260:	e1a03823 	lsr	r3, r3, #16
30041264:	e20320ff 	and	r2, r3, #255	; 0xff
30041268:	e59d300c 	ldr	r3, [sp, #12]
3004126c:	e5c32008 	strb	r2, [r3, #8]
			pCardInfo->Product_Name[1] = (rSDIRSP0&0xff00)>>8;
30041270:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041274:	e2833014 	add	r3, r3, #20
30041278:	e5933000 	ldr	r3, [r3]
3004127c:	e2033cff 	and	r3, r3, #65280	; 0xff00
30041280:	e1a03423 	lsr	r3, r3, #8
30041284:	e20320ff 	and	r2, r3, #255	; 0xff
30041288:	e59d300c 	ldr	r3, [sp, #12]
3004128c:	e5c32009 	strb	r2, [r3, #9]
			pCardInfo->Product_Name[2] = rSDIRSP0&0xff;
30041290:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041294:	e2833014 	add	r3, r3, #20
30041298:	e5933000 	ldr	r3, [r3]
3004129c:	e20320ff 	and	r2, r3, #255	; 0xff
300412a0:	e59d300c 	ldr	r3, [sp, #12]
300412a4:	e5c3200a 	strb	r2, [r3, #10]
			pCardInfo->Product_Name[3] = (rSDIRSP1 & 0xff000000) >> 24;
300412a8:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300412ac:	e2833018 	add	r3, r3, #24
300412b0:	e5933000 	ldr	r3, [r3]
300412b4:	e1a03c23 	lsr	r3, r3, #24
300412b8:	e20320ff 	and	r2, r3, #255	; 0xff
300412bc:	e59d300c 	ldr	r3, [sp, #12]
300412c0:	e5c3200b 	strb	r2, [r3, #11]
			pCardInfo->Product_Name[4] = (rSDIRSP1&0xff0000)>>16;
300412c4:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300412c8:	e2833018 	add	r3, r3, #24
300412cc:	e5933000 	ldr	r3, [r3]
300412d0:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
300412d4:	e1a03823 	lsr	r3, r3, #16
300412d8:	e20320ff 	and	r2, r3, #255	; 0xff
300412dc:	e59d300c 	ldr	r3, [sp, #12]
300412e0:	e5c3200c 	strb	r2, [r3, #12]
			pCardInfo->Product_Name[5] = (rSDIRSP1&0xff00)>>8;
300412e4:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300412e8:	e2833018 	add	r3, r3, #24
300412ec:	e5933000 	ldr	r3, [r3]
300412f0:	e2033cff 	and	r3, r3, #65280	; 0xff00
300412f4:	e1a03423 	lsr	r3, r3, #8
300412f8:	e20320ff 	and	r2, r3, #255	; 0xff
300412fc:	e59d300c 	ldr	r3, [sp, #12]
30041300:	e5c3200d 	strb	r2, [r3, #13]
			pCardInfo->Product_Name[6] = rSDIRSP1&0xff;
30041304:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041308:	e2833018 	add	r3, r3, #24
3004130c:	e5933000 	ldr	r3, [r3]
30041310:	e20320ff 	and	r2, r3, #255	; 0xff
30041314:	e59d300c 	ldr	r3, [sp, #12]
30041318:	e5c3200e 	strb	r2, [r3, #14]
			pCardInfo->Product_Name[7] = 0;
3004131c:	e59d300c 	ldr	r3, [sp, #12]
30041320:	e3a02000 	mov	r2, #0
30041324:	e5c3200f 	strb	r2, [r3, #15]
			pCardInfo->Serial_Num = ((rSDIRSP2 & 0xffffff) << 8) | ((rSDIRSP3 & 0xff000000) >> 24);
30041328:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004132c:	e283301c 	add	r3, r3, #28
30041330:	e5933000 	ldr	r3, [r3]
30041334:	e1a02403 	lsl	r2, r3, #8
30041338:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004133c:	e2833020 	add	r3, r3, #32
30041340:	e5933000 	ldr	r3, [r3]
30041344:	e1a03c23 	lsr	r3, r3, #24
30041348:	e1823003 	orr	r3, r2, r3
3004134c:	e1a02003 	mov	r2, r3
30041350:	e59d300c 	ldr	r3, [sp, #12]
30041354:	e5832010 	str	r2, [r3, #16]
			pCardInfo->Manufacturing_Date[0] = 2000+((rSDIRSP3&0xff000)>>12);
30041358:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004135c:	e2833020 	add	r3, r3, #32
30041360:	e5933000 	ldr	r3, [r3]
30041364:	e2033aff 	and	r3, r3, #1044480	; 0xff000
30041368:	e1a03623 	lsr	r3, r3, #12
3004136c:	e2833e7d 	add	r3, r3, #2000	; 0x7d0
30041370:	e1a02003 	mov	r2, r3
30041374:	e59d300c 	ldr	r3, [sp, #12]
30041378:	e5832014 	str	r2, [r3, #20]
			pCardInfo->Manufacturing_Date[1] = (rSDIRSP3&0xf00)>>8;
3004137c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041380:	e2833020 	add	r3, r3, #32
30041384:	e5933000 	ldr	r3, [r3]
30041388:	e2033c0f 	and	r3, r3, #3840	; 0xf00
3004138c:	e1a03423 	lsr	r3, r3, #8
30041390:	e1a02003 	mov	r2, r3
30041394:	e59d300c 	ldr	r3, [sp, #12]
30041398:	e5832018 	str	r2, [r3, #24]
		else
		{
			return 0;
		}

		if(CMD3() != 0) 	// Get_RCA
3004139c:	eb000188 	bl	300419c4 <CMD3>
300413a0:	e1a03000 	mov	r3, r0
300413a4:	e3530000 	cmp	r3, #0
300413a8:	1a000002 	bne	300413b8 <SD_card_init+0x30c>
300413ac:	ea00003e 	b	300414ac <SD_card_init+0x400>
			pCardInfo->Manufacturing_Date[0] = 2000+((rSDIRSP3&0xff000)>>12);
			pCardInfo->Manufacturing_Date[1] = (rSDIRSP3&0xf00)>>8;
		}
		else
		{
			return 0;
300413b0:	e3a03000 	mov	r3, #0
300413b4:	ea000052 	b	30041504 <SD_card_init+0x458>
		}

		if(CMD3() != 0) 	// Get_RCA
		{
			if(pCardInfo->Card_Type == ENUM_CARD_TYPE_MMC)
300413b8:	e59d300c 	ldr	r3, [sp, #12]
300413bc:	e5d33000 	ldrb	r3, [r3]
300413c0:	e3530000 	cmp	r3, #0
300413c4:	1a000014 	bne	3004141c <SD_card_init+0x370>
			{
				pCardInfo->RCA = 1;
300413c8:	e59d300c 	ldr	r3, [sp, #12]
300413cc:	e3a02001 	mov	r2, #1
300413d0:	e583201c 	str	r2, [r3, #28]

				rSDIPRE=(PCLK/MMCCLK)-1;	// YH 0812, Normal clock=20MHz
300413d4:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300413d8:	e2833004 	add	r3, r3, #4
300413dc:	e3a02002 	mov	r2, #2
300413e0:	e5832000 	str	r2, [r3]
				acoral_print("MMC Frequency is %dHz\n",(PCLK/(rSDIPRE+1)));
300413e4:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300413e8:	e2833004 	add	r3, r3, #4
300413ec:	e5933000 	ldr	r3, [r3]
300413f0:	e2833001 	add	r3, r3, #1
300413f4:	e3a007be 	mov	r0, #49807360	; 0x2f80000
300413f8:	e2800a2f 	add	r0, r0, #192512	; 0x2f000
300413fc:	e2800080 	add	r0, r0, #128	; 0x80
30041400:	e1a01003 	mov	r1, r3
30041404:	eb000a25 	bl	30043ca0 <__aeabi_uidiv>
30041408:	e1a03000 	mov	r3, r0
3004140c:	e59f0108 	ldr	r0, [pc, #264]	; 3004151c <SD_card_init+0x470>
30041410:	e1a01003 	mov	r1, r3
30041414:	ebff2789 	bl	3000b240 <acoral_print>
30041418:	ea00001a 	b	30041488 <SD_card_init+0x3dc>
			}
			else
			{
				pCardInfo->RCA = ( rSDIRSP0 & 0xffff0000 )>>16;
3004141c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041420:	e2833014 	add	r3, r3, #20
30041424:	e5933000 	ldr	r3, [r3]
30041428:	e1a03823 	lsr	r3, r3, #16
3004142c:	e1a02003 	mov	r2, r3
30041430:	e59d300c 	ldr	r3, [sp, #12]
30041434:	e583201c 	str	r2, [r3, #28]
				acoral_print("RCA = 0x%x\n",pCardInfo->RCA);
30041438:	e59d300c 	ldr	r3, [sp, #12]
3004143c:	e593301c 	ldr	r3, [r3, #28]
30041440:	e59f00d8 	ldr	r0, [pc, #216]	; 30041520 <SD_card_init+0x474>
30041444:	e1a01003 	mov	r1, r3
30041448:	ebff277c 	bl	3000b240 <acoral_print>

				rSDIPRE = (PCLK/SDCLK) - 1; 	// Normal clock=25MHz
3004144c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041450:	e2833004 	add	r3, r3, #4
30041454:	e3a02001 	mov	r2, #1
30041458:	e5832000 	str	r2, [r3]
				acoral_print("Now SD Frequency is %dMHz\n",(PCLK/(rSDIPRE+1))/1000000);
3004145c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041460:	e2833004 	add	r3, r3, #4
30041464:	e5933000 	ldr	r3, [r3]
30041468:	e2833001 	add	r3, r3, #1
3004146c:	e3a00032 	mov	r0, #50	; 0x32
30041470:	e1a01003 	mov	r1, r3
30041474:	eb000a09 	bl	30043ca0 <__aeabi_uidiv>
30041478:	e1a03000 	mov	r3, r0
3004147c:	e59f00a0 	ldr	r0, [pc, #160]	; 30041524 <SD_card_init+0x478>
30041480:	e1a01003 	mov	r1, r3
30041484:	ebff276d 	bl	3000b240 <acoral_print>
			return 0;
		}

		//CMD13();			// Get card status

		Card_Select(pCardInfo->RCA);	// 选中当前卡
30041488:	e59d300c 	ldr	r3, [sp, #12]
3004148c:	e593301c 	ldr	r3, [r3, #28]
30041490:	e1a00003 	mov	r0, r3
30041494:	eb00021d 	bl	30041d10 <Card_Select>

		//--设置总线位数
		if(pCardInfo->Card_Type == ENUM_CARD_TYPE_SD)
30041498:	e59d300c 	ldr	r3, [sp, #12]
3004149c:	e5d33000 	ldrb	r3, [r3]
300414a0:	e3530001 	cmp	r3, #1
300414a4:	0a000002 	beq	300414b4 <SD_card_init+0x408>
300414a8:	ea000007 	b	300414cc <SD_card_init+0x420>
			}

		}
		else
		{
			return 0;
300414ac:	e3a03000 	mov	r3, #0
300414b0:	ea000013 	b	30041504 <SD_card_init+0x458>
		Card_Select(pCardInfo->RCA);	// 选中当前卡

		//--设置总线位数
		if(pCardInfo->Card_Type == ENUM_CARD_TYPE_SD)
		{
			SetBus(pCardInfo->RCA, Wide);
300414b4:	e59d300c 	ldr	r3, [sp, #12]
300414b8:	e593301c 	ldr	r3, [r3, #28]
300414bc:	e1a00003 	mov	r0, r3
300414c0:	e3a01001 	mov	r1, #1
300414c4:	eb0002aa 	bl	30041f74 <SetBus>
300414c8:	ea000003 	b	300414dc <SD_card_init+0x430>
		}
		else
		{
			Set_1bit_bus(pCardInfo->RCA);
300414cc:	e59d300c 	ldr	r3, [sp, #12]
300414d0:	e593301c 	ldr	r3, [r3, #28]
300414d4:	e1a00003 	mov	r0, r3
300414d8:	eb0002dc 	bl	30042050 <Set_1bit_bus>
		}


		if(!CMD9(CardInf.RCA))			// Get CSD
300414dc:	e59f3044 	ldr	r3, [pc, #68]	; 30041528 <SD_card_init+0x47c>
300414e0:	e593301c 	ldr	r3, [r3, #28]
300414e4:	e1a00003 	mov	r0, r3
300414e8:	eb000260 	bl	30041e70 <CMD9>
300414ec:	e1a03000 	mov	r3, r0
300414f0:	e3530000 	cmp	r3, #0
300414f4:	1a000001 	bne	30041500 <SD_card_init+0x454>
		{
			acoral_print("Get CSD Failed!!!\n");
300414f8:	e59f002c 	ldr	r0, [pc, #44]	; 3004152c <SD_card_init+0x480>
300414fc:	ebff274f 	bl	3000b240 <acoral_print>
		}


		return 1;
30041500:	e3a03001 	mov	r3, #1

}
30041504:	e1a00003 	mov	r0, r3
30041508:	e28dd014 	add	sp, sp, #20
3004150c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30041510:	e12fff1e 	bx	lr
30041514:	30046230 	.word	0x30046230
30041518:	3004624c 	.word	0x3004624c
3004151c:	3004626c 	.word	0x3004626c
30041520:	30046284 	.word	0x30046284
30041524:	30046290 	.word	0x30046290
30041528:	3012d6e8 	.word	0x3012d6e8
3004152c:	300462ac 	.word	0x300462ac

30041530 <Check_Card_In>:



acoral_u32 Check_Card_In(void)
{
30041530:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30041534:	e24dd00c 	sub	sp, sp, #12
	int CardIn;
	acoral_u32	save_rGPGCON = rGPGCON;
30041538:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3004153c:	e2833060 	add	r3, r3, #96	; 0x60
30041540:	e5933000 	ldr	r3, [r3]
30041544:	e58d3004 	str	r3, [sp, #4]

	rGPGCON = (rGPGCON & 0xfffcffff); 				// CDSD,GPG8 =>In
30041548:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3004154c:	e2833060 	add	r3, r3, #96	; 0x60
30041550:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30041554:	e2822060 	add	r2, r2, #96	; 0x60
30041558:	e5922000 	ldr	r2, [r2]
3004155c:	e3c22803 	bic	r2, r2, #196608	; 0x30000
30041560:	e5832000 	str	r2, [r3]
	Delay(50);
30041564:	e3a00032 	mov	r0, #50	; 0x32
30041568:	ebfffe7a 	bl	30040f58 <Delay>

	if(rGPGDAT & (1<<8))
3004156c:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30041570:	e2833064 	add	r3, r3, #100	; 0x64
30041574:	e5933000 	ldr	r3, [r3]
30041578:	e2033c01 	and	r3, r3, #256	; 0x100
3004157c:	e3530000 	cmp	r3, #0
30041580:	0a000002 	beq	30041590 <Check_Card_In+0x60>
	{
		CardIn = 0;
30041584:	e3a03000 	mov	r3, #0
30041588:	e58d3000 	str	r3, [sp]
3004158c:	ea000001 	b	30041598 <Check_Card_In+0x68>
	}
	else
	{
		CardIn = 1;
30041590:	e3a03001 	mov	r3, #1
30041594:	e58d3000 	str	r3, [sp]
	}

	rGPGCON = save_rGPGCON;
30041598:	e3a03456 	mov	r3, #1442840576	; 0x56000000
3004159c:	e2833060 	add	r3, r3, #96	; 0x60
300415a0:	e59d2004 	ldr	r2, [sp, #4]
300415a4:	e5832000 	str	r2, [r3]

	return CardIn;
300415a8:	e59d3000 	ldr	r3, [sp]
}
300415ac:	e1a00003 	mov	r0, r3
300415b0:	e28dd00c 	add	sp, sp, #12
300415b4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300415b8:	e12fff1e 	bx	lr

300415bc <SD_Set_IOPort>:

void SD_Set_IOPort(void)
{
	rGPECON = ((rGPECON & 0xffb003ff) | 0xffeaabff);	// SDCLK, SDCMD, SDDAT[3:0]
300415bc:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300415c0:	e2822040 	add	r2, r2, #64	; 0x40
300415c4:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300415c8:	e2833040 	add	r3, r3, #64	; 0x40
300415cc:	e5933000 	ldr	r3, [r3]
300415d0:	e2033601 	and	r3, r3, #1048576	; 0x100000
300415d4:	e38334ff 	orr	r3, r3, #-16777216	; 0xff000000
300415d8:	e38338ea 	orr	r3, r3, #15335424	; 0xea0000
300415dc:	e3833cab 	orr	r3, r3, #43776	; 0xab00
300415e0:	e38330ff 	orr	r3, r3, #255	; 0xff
300415e4:	e5823000 	str	r3, [r2]
    rGPEUP  = (rGPEUP & 0xf83f);     					// SDCMD, SDDAT[3:0] => PU En.
300415e8:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300415ec:	e2822048 	add	r2, r2, #72	; 0x48
300415f0:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300415f4:	e2833048 	add	r3, r3, #72	; 0x48
300415f8:	e5933000 	ldr	r3, [r3]
300415fc:	e3c33d1f 	bic	r3, r3, #1984	; 0x7c0
30041600:	e1a03803 	lsl	r3, r3, #16
30041604:	e1a03823 	lsr	r3, r3, #16
30041608:	e5823000 	str	r3, [r2]
}
3004160c:	e12fff1e 	bx	lr

30041610 <Chk_CMDend>:


static int Chk_CMDend(int cmd, int be_resp)
{
30041610:	e24dd010 	sub	sp, sp, #16
30041614:	e58d0004 	str	r0, [sp, #4]
30041618:	e58d1000 	str	r1, [sp]
    int finish0;

    if(!be_resp)    // No response
3004161c:	e59d3000 	ldr	r3, [sp]
30041620:	e3530000 	cmp	r3, #0
30041624:	1a000012 	bne	30041674 <Chk_CMDend+0x64>
    {
    	finish0 = rSDICSTA;
30041628:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004162c:	e2833010 	add	r3, r3, #16
30041630:	e5933000 	ldr	r3, [r3]
30041634:	e58d300c 	str	r3, [sp, #12]
		while((finish0 & 0x800) != 0x800)	// Check cmd end
30041638:	ea000003 	b	3004164c <Chk_CMDend+0x3c>
		{
	    	finish0 = rSDICSTA;
3004163c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041640:	e2833010 	add	r3, r3, #16
30041644:	e5933000 	ldr	r3, [r3]
30041648:	e58d300c 	str	r3, [sp, #12]
    int finish0;

    if(!be_resp)    // No response
    {
    	finish0 = rSDICSTA;
		while((finish0 & 0x800) != 0x800)	// Check cmd end
3004164c:	e59d300c 	ldr	r3, [sp, #12]
30041650:	e2033b02 	and	r3, r3, #2048	; 0x800
30041654:	e3530000 	cmp	r3, #0
30041658:	0afffff7 	beq	3004163c <Chk_CMDend+0x2c>
		{
	    	finish0 = rSDICSTA;
	    }

		rSDICSTA = finish0;// Clear cmd end state
3004165c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041660:	e2833010 	add	r3, r3, #16
30041664:	e59d200c 	ldr	r2, [sp, #12]
30041668:	e5832000 	str	r2, [r3]

		return 1;
3004166c:	e3a03001 	mov	r3, #1
30041670:	ea000052 	b	300417c0 <Chk_CMDend+0x1b0>
    }
    else	// With response
    {
    	finish0 = rSDICSTA;
30041674:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041678:	e2833010 	add	r3, r3, #16
3004167c:	e5933000 	ldr	r3, [r3]
30041680:	e58d300c 	str	r3, [sp, #12]
		while( !( ((finish0&0x200)==0x200) | ((finish0&0x400)==0x400) ))    // Check time/rsp end
30041684:	ea000003 	b	30041698 <Chk_CMDend+0x88>
	//	while( !( ((finish0&0x200)==0x200) | ((finish0&0x400)==0x800) ))	// Check cmd/rsp end
		{
			finish0 = rSDICSTA;
30041688:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004168c:	e2833010 	add	r3, r3, #16
30041690:	e5933000 	ldr	r3, [r3]
30041694:	e58d300c 	str	r3, [sp, #12]
		return 1;
    }
    else	// With response
    {
    	finish0 = rSDICSTA;
		while( !( ((finish0&0x200)==0x200) | ((finish0&0x400)==0x400) ))    // Check time/rsp end
30041698:	e59d300c 	ldr	r3, [sp, #12]
3004169c:	e2033c02 	and	r3, r3, #512	; 0x200
300416a0:	e3530000 	cmp	r3, #0
300416a4:	13a03000 	movne	r3, #0
300416a8:	03a03001 	moveq	r3, #1
300416ac:	e20320ff 	and	r2, r3, #255	; 0xff
300416b0:	e59d300c 	ldr	r3, [sp, #12]
300416b4:	e2033b01 	and	r3, r3, #1024	; 0x400
300416b8:	e3530000 	cmp	r3, #0
300416bc:	13a03000 	movne	r3, #0
300416c0:	03a03001 	moveq	r3, #1
300416c4:	e20330ff 	and	r3, r3, #255	; 0xff
300416c8:	e0023003 	and	r3, r2, r3
300416cc:	e20330ff 	and	r3, r3, #255	; 0xff
300416d0:	e3530000 	cmp	r3, #0
300416d4:	1affffeb 	bne	30041688 <Chk_CMDend+0x78>
		{
			finish0 = rSDICSTA;
		}
		//acoral_print("CMD%d:rSDICSTA=0x%x\n", cmd, rSDICSTA);	//YH 0811

		if((cmd==1) | (cmd==41))	// CRC no check, CMD9 is a long Resp. command.
300416d8:	e59d3004 	ldr	r3, [sp, #4]
300416dc:	e3530001 	cmp	r3, #1
300416e0:	13a03000 	movne	r3, #0
300416e4:	03a03001 	moveq	r3, #1
300416e8:	e20320ff 	and	r2, r3, #255	; 0xff
300416ec:	e59d3004 	ldr	r3, [sp, #4]
300416f0:	e3530029 	cmp	r3, #41	; 0x29
300416f4:	13a03000 	movne	r3, #0
300416f8:	03a03001 	moveq	r3, #1
300416fc:	e20330ff 	and	r3, r3, #255	; 0xff
30041700:	e1823003 	orr	r3, r2, r3
30041704:	e20330ff 	and	r3, r3, #255	; 0xff
30041708:	e3530000 	cmp	r3, #0
3004170c:	0a000018 	beq	30041774 <Chk_CMDend+0x164>

		{
		    if( (finish0 & 0xf00) != 0xa00 )  // Check error
30041710:	e59d300c 	ldr	r3, [sp, #12]
30041714:	e2033c0f 	and	r3, r3, #3840	; 0xf00
30041718:	e3530c0a 	cmp	r3, #2560	; 0xa00
3004171c:	0a00000f 	beq	30041760 <Chk_CMDend+0x150>
		    {
				//acoral_print("Error:  CMD%d:rSDICSTA=0x%x, rSDIRSP0=0x%x\n",cmd, rSDICSTA, rSDIRSP0);
				rSDICSTA=finish0;   // Clear error state
30041720:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041724:	e2833010 	add	r3, r3, #16
30041728:	e59d200c 	ldr	r2, [sp, #12]
3004172c:	e5832000 	str	r2, [r3]

				if(((finish0&0x800) == 0x800))
30041730:	e59d300c 	ldr	r3, [sp, #12]
30041734:	e2033b02 	and	r3, r3, #2048	; 0x800
30041738:	e3530000 	cmp	r3, #0
3004173c:	0a000001 	beq	30041748 <Chk_CMDend+0x138>
				{
			    	return 1;	// CMD end
30041740:	e3a03001 	mov	r3, #1
30041744:	ea00001d 	b	300417c0 <Chk_CMDend+0x1b0>
			    }
				if(((finish0&0x400) == 0x400))
30041748:	e59d300c 	ldr	r3, [sp, #12]
3004174c:	e2033b01 	and	r3, r3, #1024	; 0x400
30041750:	e3530000 	cmp	r3, #0
30041754:	0a000001 	beq	30041760 <Chk_CMDend+0x150>
				{
			    	return 0;	// Timeout error
30041758:	e3a03000 	mov	r3, #0
3004175c:	ea000017 	b	300417c0 <Chk_CMDend+0x1b0>
			    }
	    	 }

		    rSDICSTA = finish0;	// Clear cmd & rsp end state
30041760:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041764:	e2833010 	add	r3, r3, #16
30041768:	e59d200c 	ldr	r2, [sp, #12]
3004176c:	e5832000 	str	r2, [r3]
30041770:	ea000011 	b	300417bc <Chk_CMDend+0x1ac>
		}
		else	// CRC check
		{

		    if( (finish0&0x1f00) != 0xa00 )	// Check error
30041774:	e59d300c 	ldr	r3, [sp, #12]
30041778:	e2033c1f 	and	r3, r3, #7936	; 0x1f00
3004177c:	e3530c0a 	cmp	r3, #2560	; 0xa00
30041780:	0a000009 	beq	300417ac <Chk_CMDend+0x19c>
		    {
				//acoral_print("Error:  CMD%d:rSDICSTA=0x%x, rSDIRSP0=0x%x\n",cmd, rSDICSTA, rSDIRSP0);
				rSDICSTA = finish0;   	// Clear error state
30041784:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041788:	e2833010 	add	r3, r3, #16
3004178c:	e59d200c 	ldr	r2, [sp, #12]
30041790:	e5832000 	str	r2, [r3]

				if((finish0 & 0x400) == 0x400)
30041794:	e59d300c 	ldr	r3, [sp, #12]
30041798:	e2033b01 	and	r3, r3, #1024	; 0x400
3004179c:	e3530000 	cmp	r3, #0
300417a0:	0a000001 	beq	300417ac <Chk_CMDend+0x19c>
				{
			    	return 0;			// Timeout error
300417a4:	e3a03000 	mov	r3, #0
300417a8:	ea000004 	b	300417c0 <Chk_CMDend+0x1b0>
			    }
	    	}
	    	//acoral_print("ok:  CMD%d:rSDICSTA=0x%x, rSDIRSP0=0x%x\n",cmd, rSDICSTA, rSDIRSP0);
		    rSDICSTA = finish0;
300417ac:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300417b0:	e2833010 	add	r3, r3, #16
300417b4:	e59d200c 	ldr	r2, [sp, #12]
300417b8:	e5832000 	str	r2, [r3]
		}

		return 1;
300417bc:	e3a03001 	mov	r3, #1
    }
}
300417c0:	e1a00003 	mov	r0, r3
300417c4:	e28dd010 	add	sp, sp, #16
300417c8:	e12fff1e 	bx	lr

300417cc <CMD0>:

static void CMD0(void)
{
300417cc:	e92d4008 	push	{r3, lr}
    //-- Make card idle state
    rSDICARG = 0x0;	    		// CMD0(stuff bit)
300417d0:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300417d4:	e2833008 	add	r3, r3, #8
300417d8:	e3a02000 	mov	r2, #0
300417dc:	e5832000 	str	r2, [r3]
    rSDICCON = (1<<8) | 0x40;   // No_resp, start, CMD0
300417e0:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300417e4:	e283300c 	add	r3, r3, #12
300417e8:	e3a02d05 	mov	r2, #320	; 0x140
300417ec:	e5832000 	str	r2, [r3]

    //-- Check end of CMD0
    Chk_CMDend(0, 0);
300417f0:	e3a00000 	mov	r0, #0
300417f4:	e3a01000 	mov	r1, #0
300417f8:	ebffff84 	bl	30041610 <Chk_CMDend>
    rSDICSTA = 0x800;	    	// Clear cmd_end(no rsp)
300417fc:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041800:	e2833010 	add	r3, r3, #16
30041804:	e3a02b02 	mov	r2, #2048	; 0x800
30041808:	e5832000 	str	r2, [r3]
}
3004180c:	e8bd4008 	pop	{r3, lr}
30041810:	e12fff1e 	bx	lr

30041814 <CMD8>:

static int CMD8(void)//SEND_IF_COND
{
30041814:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30041818:	e24dd00c 	sub	sp, sp, #12
    int i = 0;
3004181c:	e3a03000 	mov	r3, #0
30041820:	e58d3004 	str	r3, [sp, #4]
    for (i = 0; i < 50; i++)			//CMD8
30041824:	e3a03000 	mov	r3, #0
30041828:	e58d3004 	str	r3, [sp, #4]
3004182c:	ea000022 	b	300418bc <CMD8+0xa8>
    {
    	rSDICARG = 0x1AA;						//CMD8(SD VHS:2.7V~3.6V)
30041830:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041834:	e2833008 	add	r3, r3, #8
30041838:	e3a02f6a 	mov	r2, #424	; 0x1a8
3004183c:	e2822002 	add	r2, r2, #2
30041840:	e5832000 	str	r2, [r3]
    	rSDICCON = (0x1<<9) | (0x1<<8) | 0x48;	//sht_resp, wait_resp, start, CMD8
30041844:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041848:	e283300c 	add	r3, r3, #12
3004184c:	e3a02fd2 	mov	r2, #840	; 0x348
30041850:	e5832000 	str	r2, [r3]

    	if ( Chk_CMDend(8, 1) & (rSDIRSP0 == 0x1aa) )
30041854:	e3a00008 	mov	r0, #8
30041858:	e3a01001 	mov	r1, #1
3004185c:	ebffff6b 	bl	30041610 <Chk_CMDend>
30041860:	e1a02000 	mov	r2, r0
30041864:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041868:	e2833014 	add	r3, r3, #20
3004186c:	e5931000 	ldr	r1, [r3]
30041870:	e3a03f6a 	mov	r3, #424	; 0x1a8
30041874:	e2833002 	add	r3, r3, #2
30041878:	e1510003 	cmp	r1, r3
3004187c:	13a03000 	movne	r3, #0
30041880:	03a03001 	moveq	r3, #1
30041884:	e0023003 	and	r3, r2, r3
30041888:	e3530000 	cmp	r3, #0
3004188c:	0a000005 	beq	300418a8 <CMD8+0x94>
    	{
    		rSDICSTA = 0xa00;		// Clear cmd_end(with rsp)
30041890:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041894:	e2833010 	add	r3, r3, #16
30041898:	e3a02c0a 	mov	r2, #2560	; 0xa00
3004189c:	e5832000 	str	r2, [r3]
			return 1;
300418a0:	e3a03001 	mov	r3, #1
300418a4:	ea000008 	b	300418cc <CMD8+0xb8>
		}
		Delay(200); 			// Wait Card power up status
300418a8:	e3a000c8 	mov	r0, #200	; 0xc8
300418ac:	ebfffda9 	bl	30040f58 <Delay>
}

static int CMD8(void)//SEND_IF_COND
{
    int i = 0;
    for (i = 0; i < 50; i++)			//CMD8
300418b0:	e59d3004 	ldr	r3, [sp, #4]
300418b4:	e2833001 	add	r3, r3, #1
300418b8:	e58d3004 	str	r3, [sp, #4]
300418bc:	e59d3004 	ldr	r3, [sp, #4]
300418c0:	e3530031 	cmp	r3, #49	; 0x31
300418c4:	daffffd9 	ble	30041830 <CMD8+0x1c>
    		rSDICSTA = 0xa00;		// Clear cmd_end(with rsp)
			return 1;
		}
		Delay(200); 			// Wait Card power up status
	}
	return 0;
300418c8:	e3a03000 	mov	r3, #0
}
300418cc:	e1a00003 	mov	r0, r3
300418d0:	e28dd00c 	add	sp, sp, #12
300418d4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300418d8:	e12fff1e 	bx	lr

300418dc <CMD2>:

static int CMD2(void)// ALL_SEND_CID
{
300418dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300418e0:	e24dd00c 	sub	sp, sp, #12
	int  Serial_Num;	//SD卡ID

	rSDICARG = 0x0;   		// CMD2(stuff bit)
300418e4:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300418e8:	e2833008 	add	r3, r3, #8
300418ec:	e3a02000 	mov	r2, #0
300418f0:	e5832000 	str	r2, [r3]
    rSDICCON = (0x1<<10) | (0x1<<9) | (0x1<<8) | 0x42; //lng_resp, wait_resp, start, CMD2
300418f4:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300418f8:	e283300c 	add	r3, r3, #12
300418fc:	e3a02d1d 	mov	r2, #1856	; 0x740
30041900:	e2822002 	add	r2, r2, #2
30041904:	e5832000 	str	r2, [r3]

    //-- Check end of CMD2
    if(!Chk_CMDend(2, 1))
30041908:	e3a00002 	mov	r0, #2
3004190c:	e3a01001 	mov	r1, #1
30041910:	ebffff3e 	bl	30041610 <Chk_CMDend>
30041914:	e1a03000 	mov	r3, r0
30041918:	e3530000 	cmp	r3, #0
3004191c:	1a000001 	bne	30041928 <CMD2+0x4c>
    {
		return 0;			// Fail
30041920:	e3a03000 	mov	r3, #0
30041924:	ea000020 	b	300419ac <CMD2+0xd0>
	}
    rSDICSTA = 0xa00;		// Clear cmd_end(with rsp)
30041928:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004192c:	e2833010 	add	r3, r3, #16
30041930:	e3a02c0a 	mov	r2, #2560	; 0xa00
30041934:	e5832000 	str	r2, [r3]

	Serial_Num = ((rSDIRSP2&0xffffff) << 8) | ((rSDIRSP3&0xff000000) >> 24);
30041938:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004193c:	e283301c 	add	r3, r3, #28
30041940:	e5933000 	ldr	r3, [r3]
30041944:	e1a02403 	lsl	r2, r3, #8
30041948:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004194c:	e2833020 	add	r3, r3, #32
30041950:	e5933000 	ldr	r3, [r3]
30041954:	e1a03c23 	lsr	r3, r3, #24
30041958:	e1823003 	orr	r3, r2, r3
3004195c:	e58d3004 	str	r3, [sp, #4]
    acoral_print("Card Id  = 0x%x\n",Serial_Num);
30041960:	e59f0054 	ldr	r0, [pc, #84]	; 300419bc <CMD2+0xe0>
30041964:	e59d1004 	ldr	r1, [sp, #4]
30041968:	ebff2634 	bl	3000b240 <acoral_print>
    //acoral_print("Capacity = %c%c%c\n",(rSDIRSP1&0xff0000)>>16,(rSDIRSP1&0xff00)>>8,rSDIRSP1&0xff);
    acoral_print("The manufacturing date is %d.%d\n",2000+((rSDIRSP3&0xff000)>>12) ,(rSDIRSP3&0xf00)>>8);
3004196c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041970:	e2833020 	add	r3, r3, #32
30041974:	e5933000 	ldr	r3, [r3]
30041978:	e2033aff 	and	r3, r3, #1044480	; 0xff000
3004197c:	e1a03623 	lsr	r3, r3, #12
30041980:	e2832e7d 	add	r2, r3, #2000	; 0x7d0
30041984:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041988:	e2833020 	add	r3, r3, #32
3004198c:	e5933000 	ldr	r3, [r3]
30041990:	e2033c0f 	and	r3, r3, #3840	; 0xf00
30041994:	e1a03423 	lsr	r3, r3, #8
30041998:	e59f0020 	ldr	r0, [pc, #32]	; 300419c0 <CMD2+0xe4>
3004199c:	e1a01002 	mov	r1, r2
300419a0:	e1a02003 	mov	r2, r3
300419a4:	ebff2625 	bl	3000b240 <acoral_print>

	return Serial_Num;		// Success
300419a8:	e59d3004 	ldr	r3, [sp, #4]
}
300419ac:	e1a00003 	mov	r0, r3
300419b0:	e28dd00c 	add	sp, sp, #12
300419b4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300419b8:	e12fff1e 	bx	lr
300419bc:	300462c0 	.word	0x300462c0
300419c0:	300462d4 	.word	0x300462d4

300419c4 <CMD3>:

static int CMD3(void)		// SEND_RCA
{
300419c4:	e92d4008 	push	{r3, lr}
    rSDICARG = 0x0;	    				// CMD3(MMC:Set RCA, SD:Ask RCA-->SBZ)
300419c8:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300419cc:	e2833008 	add	r3, r3, #8
300419d0:	e3a02000 	mov	r2, #0
300419d4:	e5832000 	str	r2, [r3]
    rSDICCON = (0x1<<9)|(0x1<<8)|0x43;	// sht_resp, wait_resp, start, CMD3
300419d8:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300419dc:	e283300c 	add	r3, r3, #12
300419e0:	e3a02d0d 	mov	r2, #832	; 0x340
300419e4:	e2822003 	add	r2, r2, #3
300419e8:	e5832000 	str	r2, [r3]

    //-- Check end of CMD3
    if(!Chk_CMDend(3, 1))
300419ec:	e3a00003 	mov	r0, #3
300419f0:	e3a01001 	mov	r1, #1
300419f4:	ebffff05 	bl	30041610 <Chk_CMDend>
300419f8:	e1a03000 	mov	r3, r0
300419fc:	e3530000 	cmp	r3, #0
30041a00:	1a000001 	bne	30041a0c <CMD3+0x48>
    {
		return 0;
30041a04:	e3a03000 	mov	r3, #0
30041a08:	ea000004 	b	30041a20 <CMD3+0x5c>
	}
    rSDICSTA = 0xa00;						// Clear cmd_end(with rsp)
30041a0c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041a10:	e2833010 	add	r3, r3, #16
30041a14:	e3a02c0a 	mov	r2, #2560	; 0xa00
30041a18:	e5832000 	str	r2, [r3]

    return 1;
30041a1c:	e3a03001 	mov	r3, #1
}
30041a20:	e1a00003 	mov	r0, r3
30041a24:	e8bd4008 	pop	{r3, lr}
30041a28:	e12fff1e 	bx	lr

30041a2c <Chk_MMC_OCR>:

static int Chk_MMC_OCR(void)
{
30041a2c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30041a30:	e24dd00c 	sub	sp, sp, #12
    int i;
    Delay(1000);
30041a34:	e3a00ffa 	mov	r0, #1000	; 0x3e8
30041a38:	ebfffd46 	bl	30040f58 <Delay>
    //-- Negotiate operating condition for MMC, it makes card ready state
    for(i = 0; i < 50; i++)	//Negotiation time is dependent on CARD Vendors.
30041a3c:	e3a03000 	mov	r3, #0
30041a40:	e58d3004 	str	r3, [sp, #4]
30041a44:	ea000020 	b	30041acc <Chk_MMC_OCR+0xa0>
    {
		//rSDICARG=0xffc000;	    	    //CMD1(MMC OCR:2.6V~3.6V)
		rSDICARG = 0xff8000;	    	    	//CMD1(SD OCR:2.7V~3.6V)
30041a48:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041a4c:	e2833008 	add	r3, r3, #8
30041a50:	e3a028ff 	mov	r2, #16711680	; 0xff0000
30041a54:	e2822902 	add	r2, r2, #32768	; 0x8000
30041a58:	e5832000 	str	r2, [r3]
    	rSDICCON = (0x1<<9)|(0x1<<8)|0x41;    	//sht_resp, wait_resp, start, CMD1
30041a5c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041a60:	e283300c 	add	r3, r3, #12
30041a64:	e3a02d0d 	mov	r2, #832	; 0x340
30041a68:	e2822001 	add	r2, r2, #1
30041a6c:	e5832000 	str	r2, [r3]

    	//-- Check end of CMD1
		if(Chk_CMDend(1, 1) && (rSDIRSP0>>16)==0x80ff) //YH 0903 [31]:Card Power up status bit (busy)
30041a70:	e3a00001 	mov	r0, #1
30041a74:	e3a01001 	mov	r1, #1
30041a78:	ebfffee4 	bl	30041610 <Chk_CMDend>
30041a7c:	e1a03000 	mov	r3, r0
30041a80:	e3530000 	cmp	r3, #0
30041a84:	0a00000d 	beq	30041ac0 <Chk_MMC_OCR+0x94>
30041a88:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041a8c:	e2833014 	add	r3, r3, #20
30041a90:	e5933000 	ldr	r3, [r3]
30041a94:	e1a02823 	lsr	r2, r3, #16
30041a98:	e3a03c81 	mov	r3, #33024	; 0x8100
30041a9c:	e2433001 	sub	r3, r3, #1
30041aa0:	e1520003 	cmp	r2, r3
30041aa4:	1a000005 	bne	30041ac0 <Chk_MMC_OCR+0x94>
		//if(Chk_CMDend(1, 1) & rSDIRSP0==0x80ff8000)
		{
		    rSDICSTA = 0xa00;	// Clear cmd_end(with rsp)
30041aa8:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041aac:	e2833010 	add	r3, r3, #16
30041ab0:	e3a02c0a 	mov	r2, #2560	; 0xa00
30041ab4:	e5832000 	str	r2, [r3]
		    return 0;			// Success,MMC
30041ab8:	e3a03000 	mov	r3, #0
30041abc:	ea00000a 	b	30041aec <Chk_MMC_OCR+0xc0>
static int Chk_MMC_OCR(void)
{
    int i;
    Delay(1000);
    //-- Negotiate operating condition for MMC, it makes card ready state
    for(i = 0; i < 50; i++)	//Negotiation time is dependent on CARD Vendors.
30041ac0:	e59d3004 	ldr	r3, [sp, #4]
30041ac4:	e2833001 	add	r3, r3, #1
30041ac8:	e58d3004 	str	r3, [sp, #4]
30041acc:	e59d3004 	ldr	r3, [sp, #4]
30041ad0:	e3530031 	cmp	r3, #49	; 0x31
30041ad4:	daffffdb 	ble	30041a48 <Chk_MMC_OCR+0x1c>
		{
		    rSDICSTA = 0xa00;	// Clear cmd_end(with rsp)
		    return 0;			// Success,MMC
		}
    }
    rSDICSTA = 0xf00;	// Clear cmd_end(with rsp)
30041ad8:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041adc:	e2833010 	add	r3, r3, #16
30041ae0:	e3a02c0f 	mov	r2, #3840	; 0xf00
30041ae4:	e5832000 	str	r2, [r3]
    return 1;			// Fail,SD
30041ae8:	e3a03001 	mov	r3, #1
}
30041aec:	e1a00003 	mov	r0, r3
30041af0:	e28dd00c 	add	sp, sp, #12
30041af4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30041af8:	e12fff1e 	bx	lr

30041afc <CMD55>:

static int CMD55(int iRCA)
{
30041afc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30041b00:	e24dd00c 	sub	sp, sp, #12
30041b04:	e58d0004 	str	r0, [sp, #4]
    //--Make ACMD
    rSDICARG = iRCA<<16;					//CMD7(RCA,stuff bit)
30041b08:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041b0c:	e2833008 	add	r3, r3, #8
30041b10:	e59d2004 	ldr	r2, [sp, #4]
30041b14:	e1a02802 	lsl	r2, r2, #16
30041b18:	e5832000 	str	r2, [r3]
    rSDICCON = (0x1<<9) | (0x1<<8) | 0x77;	//sht_resp, wait_resp, start, CMD55
30041b1c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041b20:	e283300c 	add	r3, r3, #12
30041b24:	e3a02fdd 	mov	r2, #884	; 0x374
30041b28:	e2822003 	add	r2, r2, #3
30041b2c:	e5832000 	str	r2, [r3]

    //-- Check end of CMD55
    if(!Chk_CMDend(55, 1))
30041b30:	e3a00037 	mov	r0, #55	; 0x37
30041b34:	e3a01001 	mov	r1, #1
30041b38:	ebfffeb4 	bl	30041610 <Chk_CMDend>
30041b3c:	e1a03000 	mov	r3, r0
30041b40:	e3530000 	cmp	r3, #0
30041b44:	1a000001 	bne	30041b50 <CMD55+0x54>
    {
		return 0;
30041b48:	e3a03000 	mov	r3, #0
30041b4c:	ea000004 	b	30041b64 <CMD55+0x68>
	}

    rSDICSTA = 0xa00;	// Clear cmd_end(with rsp)
30041b50:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041b54:	e2833010 	add	r3, r3, #16
30041b58:	e3a02c0a 	mov	r2, #2560	; 0xa00
30041b5c:	e5832000 	str	r2, [r3]
    return 1;
30041b60:	e3a03001 	mov	r3, #1
}
30041b64:	e1a00003 	mov	r0, r3
30041b68:	e28dd00c 	add	sp, sp, #12
30041b6c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30041b70:	e12fff1e 	bx	lr

30041b74 <Chk_SD_OCR>:

static int Chk_SD_OCR(void)	//ACMD41
{
30041b74:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30041b78:	e24dd00c 	sub	sp, sp, #12
    int i;

    //-- Negotiate operating condition for SD, it makes card ready state
    Delay(1000);
30041b7c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
30041b80:	ebfffcf4 	bl	30040f58 <Delay>
    for(i=0;i<50;i++)			//If this time is short, init. can be fail.
30041b84:	e3a03000 	mov	r3, #0
30041b88:	e58d3004 	str	r3, [sp, #4]
30041b8c:	ea00004a 	b	30041cbc <Chk_SD_OCR+0x148>
    {
		//-- 检测是否为SDHC
    	CMD55(0);    			// Make ACMD
30041b90:	e3a00000 	mov	r0, #0
30041b94:	ebffffd8 	bl	30041afc <CMD55>
    	rSDICARG = 0xc0ff8000;	//ACMD41(SD OCR:2.7V~3.6V,HCS=1)
30041b98:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041b9c:	e2833008 	add	r3, r3, #8
30041ba0:	e3a024c1 	mov	r2, #-1056964608	; 0xc1000000
30041ba4:	e2422902 	sub	r2, r2, #32768	; 0x8000
30041ba8:	e5832000 	str	r2, [r3]
		//rSDICARG=0xffc000;	//ACMD41(MMC OCR:2.6V~3.6V)
    	rSDICCON = (0x1<<9)|(0x1<<8)|0x69;//sht_resp, wait_resp, start, ACMD41
30041bac:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041bb0:	e283300c 	add	r3, r3, #12
30041bb4:	e3a02fda 	mov	r2, #872	; 0x368
30041bb8:	e2822001 	add	r2, r2, #1
30041bbc:	e5832000 	str	r2, [r3]

		//-- Check end of ACMD41
    	if( Chk_CMDend(41, 1) && (rSDIRSP0==0xc0ff8000) )
30041bc0:	e3a00029 	mov	r0, #41	; 0x29
30041bc4:	e3a01001 	mov	r1, #1
30041bc8:	ebfffe90 	bl	30041610 <Chk_CMDend>
30041bcc:	e1a03000 	mov	r3, r0
30041bd0:	e3530000 	cmp	r3, #0
30041bd4:	0a00000e 	beq	30041c14 <Chk_SD_OCR+0xa0>
30041bd8:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041bdc:	e2833014 	add	r3, r3, #20
30041be0:	e5932000 	ldr	r2, [r3]
30041be4:	e3a034c1 	mov	r3, #-1056964608	; 0xc1000000
30041be8:	e2433902 	sub	r3, r3, #32768	; 0x8000
30041bec:	e1520003 	cmp	r2, r3
30041bf0:	1a000007 	bne	30041c14 <Chk_SD_OCR+0xa0>
		{
			acoral_print("SDHC Card...\n");
30041bf4:	e59f0108 	ldr	r0, [pc, #264]	; 30041d04 <Chk_SD_OCR+0x190>
30041bf8:	ebff2590 	bl	3000b240 <acoral_print>
		    rSDICSTA = 0xa00;		// Clear cmd_end(with rsp)
30041bfc:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041c00:	e2833010 	add	r3, r3, #16
30041c04:	e3a02c0a 	mov	r2, #2560	; 0xa00
30041c08:	e5832000 	str	r2, [r3]
		    return 1;			// Success
30041c0c:	e3a03001 	mov	r3, #1
30041c10:	ea000037 	b	30041cf4 <Chk_SD_OCR+0x180>
		}

		//-- 检测是否为SD1.0
		CMD55(0);    			// Make ACMD
30041c14:	e3a00000 	mov	r0, #0
30041c18:	ebffffb7 	bl	30041afc <CMD55>
    	rSDICARG = 0x80ff8000;	//ACMD41(SD OCR:2.7V~3.6V,HCS=0)
30041c1c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041c20:	e2833008 	add	r3, r3, #8
30041c24:	e3a02481 	mov	r2, #-2130706432	; 0x81000000
30041c28:	e2422902 	sub	r2, r2, #32768	; 0x8000
30041c2c:	e5832000 	str	r2, [r3]
    	rSDICCON = (0x1<<9) | (0x1<<8) | 0x69;//sht_resp, wait_resp, start, ACMD41
30041c30:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041c34:	e283300c 	add	r3, r3, #12
30041c38:	e3a02fda 	mov	r2, #872	; 0x368
30041c3c:	e2822001 	add	r2, r2, #1
30041c40:	e5832000 	str	r2, [r3]

		//-- Check end of ACMD41
    	if( Chk_CMDend(41, 1) && (rSDIRSP0==0x80ff8000) )
30041c44:	e3a00029 	mov	r0, #41	; 0x29
30041c48:	e3a01001 	mov	r1, #1
30041c4c:	ebfffe6f 	bl	30041610 <Chk_CMDend>
30041c50:	e1a03000 	mov	r3, r0
30041c54:	e3530000 	cmp	r3, #0
30041c58:	0a000012 	beq	30041ca8 <Chk_SD_OCR+0x134>
30041c5c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041c60:	e2833014 	add	r3, r3, #20
30041c64:	e5932000 	ldr	r2, [r3]
30041c68:	e3a03481 	mov	r3, #-2130706432	; 0x81000000
30041c6c:	e2433902 	sub	r3, r3, #32768	; 0x8000
30041c70:	e1520003 	cmp	r2, r3
30041c74:	1a00000b 	bne	30041ca8 <Chk_SD_OCR+0x134>
		{
			acoral_print("SD1.0 Card...\n",rSDIRSP0);
30041c78:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041c7c:	e2833014 	add	r3, r3, #20
30041c80:	e5933000 	ldr	r3, [r3]
30041c84:	e59f007c 	ldr	r0, [pc, #124]	; 30041d08 <Chk_SD_OCR+0x194>
30041c88:	e1a01003 	mov	r1, r3
30041c8c:	ebff256b 	bl	3000b240 <acoral_print>
		    rSDICSTA = 0xa00;		// Clear cmd_end(with rsp)
30041c90:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041c94:	e2833010 	add	r3, r3, #16
30041c98:	e3a02c0a 	mov	r2, #2560	; 0xa00
30041c9c:	e5832000 	str	r2, [r3]
		    return 2;			// Success
30041ca0:	e3a03002 	mov	r3, #2
30041ca4:	ea000012 	b	30041cf4 <Chk_SD_OCR+0x180>
		}

		Delay(200); 			// Wait Card power up status
30041ca8:	e3a000c8 	mov	r0, #200	; 0xc8
30041cac:	ebfffca9 	bl	30040f58 <Delay>
{
    int i;

    //-- Negotiate operating condition for SD, it makes card ready state
    Delay(1000);
    for(i=0;i<50;i++)			//If this time is short, init. can be fail.
30041cb0:	e59d3004 	ldr	r3, [sp, #4]
30041cb4:	e2833001 	add	r3, r3, #1
30041cb8:	e58d3004 	str	r3, [sp, #4]
30041cbc:	e59d3004 	ldr	r3, [sp, #4]
30041cc0:	e3530031 	cmp	r3, #49	; 0x31
30041cc4:	daffffb1 	ble	30041b90 <Chk_SD_OCR+0x1c>

		Delay(200); 			// Wait Card power up status

    }

    acoral_print("Error: ACMD41 SDIRSP0=0x%x\n",rSDIRSP0);
30041cc8:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041ccc:	e2833014 	add	r3, r3, #20
30041cd0:	e5933000 	ldr	r3, [r3]
30041cd4:	e59f0030 	ldr	r0, [pc, #48]	; 30041d0c <Chk_SD_OCR+0x198>
30041cd8:	e1a01003 	mov	r1, r3
30041cdc:	ebff2557 	bl	3000b240 <acoral_print>
    rSDICSTA = 0xa00;	// Clear cmd_end(with rsp)
30041ce0:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041ce4:	e2833010 	add	r3, r3, #16
30041ce8:	e3a02c0a 	mov	r2, #2560	; 0xa00
30041cec:	e5832000 	str	r2, [r3]
    return 0;		// Fail
30041cf0:	e3a03000 	mov	r3, #0
}
30041cf4:	e1a00003 	mov	r0, r3
30041cf8:	e28dd00c 	add	sp, sp, #12
30041cfc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30041d00:	e12fff1e 	bx	lr
30041d04:	300462f8 	.word	0x300462f8
30041d08:	30046308 	.word	0x30046308
30041d0c:	30046318 	.word	0x30046318

30041d10 <Card_Select>:

int Card_Select( int iRCA)
{
30041d10:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30041d14:	e24dd014 	sub	sp, sp, #20
30041d18:	e58d0004 	str	r0, [sp, #4]
    //-- Card select
    int i = 0;
30041d1c:	e3a03000 	mov	r3, #0
30041d20:	e58d300c 	str	r3, [sp, #12]
	do
	{
		rSDICARG = iRCA<<16;					// CMD7(RCA,stuff bit)
30041d24:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041d28:	e2833008 	add	r3, r3, #8
30041d2c:	e59d2004 	ldr	r2, [sp, #4]
30041d30:	e1a02802 	lsl	r2, r2, #16
30041d34:	e5832000 	str	r2, [r3]
		rSDICCON = (0x1<<9) | (0x1<<8) | 0x47;  // sht_resp, wait_resp, start, CMD7
30041d38:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041d3c:	e283300c 	add	r3, r3, #12
30041d40:	e3a02fd1 	mov	r2, #836	; 0x344
30041d44:	e2822003 	add	r2, r2, #3
30041d48:	e5832000 	str	r2, [r3]
		i++;
30041d4c:	e59d300c 	ldr	r3, [sp, #12]
30041d50:	e2833001 	add	r3, r3, #1
30041d54:	e58d300c 	str	r3, [sp, #12]
	}
	//-- Check end of CMD7
	while(!Chk_CMDend(7, 1) && (i < 100));
30041d58:	e3a00007 	mov	r0, #7
30041d5c:	e3a01001 	mov	r1, #1
30041d60:	ebfffe2a 	bl	30041610 <Chk_CMDend>
30041d64:	e1a03000 	mov	r3, r0
30041d68:	e3530000 	cmp	r3, #0
30041d6c:	1a000002 	bne	30041d7c <Card_Select+0x6c>
30041d70:	e59d300c 	ldr	r3, [sp, #12]
30041d74:	e3530063 	cmp	r3, #99	; 0x63
30041d78:	daffffe9 	ble	30041d24 <Card_Select+0x14>

	rSDICSTA = 0xa00;			// Clear cmd_end(with rsp)
30041d7c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041d80:	e2833010 	add	r3, r3, #16
30041d84:	e3a02c0a 	mov	r2, #2560	; 0xa00
30041d88:	e5832000 	str	r2, [r3]

	if (i == 100)
30041d8c:	e59d300c 	ldr	r3, [sp, #12]
30041d90:	e3530064 	cmp	r3, #100	; 0x64
30041d94:	1a000001 	bne	30041da0 <Card_Select+0x90>
	{
		return 0;
30041d98:	e3a03000 	mov	r3, #0
30041d9c:	ea000008 	b	30041dc4 <Card_Select+0xb4>
	}

	//--State(transfer) check
	if( (rSDIRSP0 & 0x1e00) != 0x800 )
30041da0:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041da4:	e2833014 	add	r3, r3, #20
30041da8:	e5933000 	ldr	r3, [r3]
30041dac:	e2033c1e 	and	r3, r3, #7680	; 0x1e00
30041db0:	e3530b02 	cmp	r3, #2048	; 0x800
30041db4:	0a000001 	beq	30041dc0 <Card_Select+0xb0>
	{
	    return 0;
30041db8:	e3a03000 	mov	r3, #0
30041dbc:	ea000000 	b	30041dc4 <Card_Select+0xb4>
	}
	return 1;
30041dc0:	e3a03001 	mov	r3, #1
}
30041dc4:	e1a00003 	mov	r0, r3
30041dc8:	e28dd014 	add	sp, sp, #20
30041dcc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30041dd0:	e12fff1e 	bx	lr

30041dd4 <Card_Deselect>:

int Card_Deselect( void)
{
30041dd4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30041dd8:	e24dd00c 	sub	sp, sp, #12
	//-- Card deselect
	int i = 0;
30041ddc:	e3a03000 	mov	r3, #0
30041de0:	e58d3004 	str	r3, [sp, #4]
	do
	{
		rSDICARG = 0<<16;			//CMD7(RCA,stuff bit)
30041de4:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041de8:	e2833008 	add	r3, r3, #8
30041dec:	e3a02000 	mov	r2, #0
30041df0:	e5832000 	str	r2, [r3]
		rSDICCON = (0x1<<8)|0x47;	//no_resp, start, CMD7
30041df4:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041df8:	e283300c 	add	r3, r3, #12
30041dfc:	e3a02f51 	mov	r2, #324	; 0x144
30041e00:	e2822003 	add	r2, r2, #3
30041e04:	e5832000 	str	r2, [r3]
		i++;
30041e08:	e59d3004 	ldr	r3, [sp, #4]
30041e0c:	e2833001 	add	r3, r3, #1
30041e10:	e58d3004 	str	r3, [sp, #4]
	}
	//-- Check end of CMD7
	while(!Chk_CMDend(7, 0) && (i < 100));
30041e14:	e3a00007 	mov	r0, #7
30041e18:	e3a01000 	mov	r1, #0
30041e1c:	ebfffdfb 	bl	30041610 <Chk_CMDend>
30041e20:	e1a03000 	mov	r3, r0
30041e24:	e3530000 	cmp	r3, #0
30041e28:	1a000002 	bne	30041e38 <Card_Deselect+0x64>
30041e2c:	e59d3004 	ldr	r3, [sp, #4]
30041e30:	e3530063 	cmp	r3, #99	; 0x63
30041e34:	daffffea 	ble	30041de4 <Card_Deselect+0x10>

	rSDICSTA = 0x800;			// Clear cmd_end(no rsp)
30041e38:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041e3c:	e2833010 	add	r3, r3, #16
30041e40:	e3a02b02 	mov	r2, #2048	; 0x800
30041e44:	e5832000 	str	r2, [r3]
	if (i == 100)
30041e48:	e59d3004 	ldr	r3, [sp, #4]
30041e4c:	e3530064 	cmp	r3, #100	; 0x64
30041e50:	1a000001 	bne	30041e5c <Card_Deselect+0x88>
	{
		return 0;
30041e54:	e3a03000 	mov	r3, #0
30041e58:	ea000000 	b	30041e60 <Card_Deselect+0x8c>
	}

	return 1;
30041e5c:	e3a03001 	mov	r3, #1
}
30041e60:	e1a00003 	mov	r0, r3
30041e64:	e28dd00c 	add	sp, sp, #12
30041e68:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30041e6c:	e12fff1e 	bx	lr

30041e70 <CMD9>:

static int CMD9(int iRCA)	//SEND_CSD
{
30041e70:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30041e74:	e24dd00c 	sub	sp, sp, #12
30041e78:	e58d0004 	str	r0, [sp, #4]
    Card_Deselect();	// Card deselect
30041e7c:	ebffffd4 	bl	30041dd4 <Card_Deselect>

    rSDICARG = iRCA<<16;								// CMD9(RCA,stuff bit)
30041e80:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041e84:	e2833008 	add	r3, r3, #8
30041e88:	e59d2004 	ldr	r2, [sp, #4]
30041e8c:	e1a02802 	lsl	r2, r2, #16
30041e90:	e5832000 	str	r2, [r3]
    rSDICCON = (0x1<<10)|(0x1<<9)|(0x1<<8)|0x49;	// long_resp, wait_resp, start, CMD9
30041e94:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041e98:	e283300c 	add	r3, r3, #12
30041e9c:	e3a02d1d 	mov	r2, #1856	; 0x740
30041ea0:	e2822009 	add	r2, r2, #9
30041ea4:	e5832000 	str	r2, [r3]

    //-- Check end of CMD9
    if (!Chk_CMDend(9, 1))
30041ea8:	e3a00009 	mov	r0, #9
30041eac:	e3a01001 	mov	r1, #1
30041eb0:	ebfffdd6 	bl	30041610 <Chk_CMDend>
30041eb4:	e1a03000 	mov	r3, r0
30041eb8:	e3530000 	cmp	r3, #0
30041ebc:	1a000001 	bne	30041ec8 <CMD9+0x58>
    {
		return 0;
30041ec0:	e3a03000 	mov	r3, #0
30041ec4:	ea000025 	b	30041f60 <CMD9+0xf0>
	}
	if ((rSDIRSP0&0xf0000000)>>28 == 4)				//CSD Version 2.0
30041ec8:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041ecc:	e2833014 	add	r3, r3, #20
30041ed0:	e5933000 	ldr	r3, [r3]
30041ed4:	e1a03e23 	lsr	r3, r3, #28
30041ed8:	e3530004 	cmp	r3, #4
30041edc:	1a000007 	bne	30041f00 <CMD9+0x90>
	{
		acoral_print("Memory Capacity= %dMB\n",( (rSDIRSP2&0xffff0000)>>16 )>>1 );
30041ee0:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041ee4:	e283301c 	add	r3, r3, #28
30041ee8:	e5933000 	ldr	r3, [r3]
30041eec:	e1a038a3 	lsr	r3, r3, #17
30041ef0:	e59f0078 	ldr	r0, [pc, #120]	; 30041f70 <CMD9+0x100>
30041ef4:	e1a01003 	mov	r1, r3
30041ef8:	ebff24d0 	bl	3000b240 <acoral_print>
30041efc:	ea000014 	b	30041f54 <CMD9+0xe4>
	}
	else if ((rSDIRSP0&0xf0000000)>>28 == 0)		//CSD Version 1.0
30041f00:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041f04:	e2833014 	add	r3, r3, #20
30041f08:	e5933000 	ldr	r3, [r3]
30041f0c:	e1a03e23 	lsr	r3, r3, #28
30041f10:	e3530000 	cmp	r3, #0
30041f14:	1a00000e 	bne	30041f54 <CMD9+0xe4>
	{
		acoral_print("Memory Capacity= %dMB\n",(((rSDIRSP1&0x3ff)<<2) | (rSDIRSP2&0xc0000000))>>1);
30041f18:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041f1c:	e2833018 	add	r3, r3, #24
30041f20:	e5933000 	ldr	r3, [r3]
30041f24:	e1a03b03 	lsl	r3, r3, #22
30041f28:	e1a03b23 	lsr	r3, r3, #22
30041f2c:	e1a02103 	lsl	r2, r3, #2
30041f30:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041f34:	e283301c 	add	r3, r3, #28
30041f38:	e5933000 	ldr	r3, [r3]
30041f3c:	e2033103 	and	r3, r3, #-1073741824	; 0xc0000000
30041f40:	e1823003 	orr	r3, r2, r3
30041f44:	e1a030a3 	lsr	r3, r3, #1
30041f48:	e59f0020 	ldr	r0, [pc, #32]	; 30041f70 <CMD9+0x100>
30041f4c:	e1a01003 	mov	r1, r3
30041f50:	ebff24ba 	bl	3000b240 <acoral_print>
	}

	//acoral_print("CSD register :\n");
    //acoral_print("SDIRSP0=0x%x\nSDIRSP1=0x%x\nSDIRSP2=0x%x\nSDIRSP3=0x%x\n", rSDIRSP0,rSDIRSP1,rSDIRSP2,rSDIRSP3);

    Card_Select(iRCA);	// Card select
30041f54:	e59d0004 	ldr	r0, [sp, #4]
30041f58:	ebffff6c 	bl	30041d10 <Card_Select>

    return 1;
30041f5c:	e3a03001 	mov	r3, #1
}
30041f60:	e1a00003 	mov	r0, r3
30041f64:	e28dd00c 	add	sp, sp, #12
30041f68:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30041f6c:	e12fff1e 	bx	lr
30041f70:	30046334 	.word	0x30046334

30041f74 <SetBus>:

static int SetBus(int iRCA,enum_sd_bus_width iWide)
{
30041f74:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30041f78:	e24dd014 	sub	sp, sp, #20
30041f7c:	e58d0004 	str	r0, [sp, #4]
30041f80:	e1a03001 	mov	r3, r1
30041f84:	e5cd3003 	strb	r3, [sp, #3]
	int i = 0;
30041f88:	e3a03000 	mov	r3, #0
30041f8c:	e58d300c 	str	r3, [sp, #12]
	do
	{
	    CMD55(iRCA);	// Make ACMD
30041f90:	e59d0004 	ldr	r0, [sp, #4]
30041f94:	ebfffed8 	bl	30041afc <CMD55>
	    //-- CMD6 implement
	    rSDICARG = iWide << 1;	    			//Wide 0: 1bit, 1: 4bit
30041f98:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041f9c:	e2833008 	add	r3, r3, #8
30041fa0:	e5dd2003 	ldrb	r2, [sp, #3]
30041fa4:	e1a02082 	lsl	r2, r2, #1
30041fa8:	e5832000 	str	r2, [r3]
	    rSDICCON = (0x1 << 9) | (0x1 << 8) | 0x46;	//sht_resp, wait_resp, start, CMD46
30041fac:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041fb0:	e283300c 	add	r3, r3, #12
30041fb4:	e3a02fd1 	mov	r2, #836	; 0x344
30041fb8:	e2822002 	add	r2, r2, #2
30041fbc:	e5832000 	str	r2, [r3]
	    i++;
30041fc0:	e59d300c 	ldr	r3, [sp, #12]
30041fc4:	e2833001 	add	r3, r3, #1
30041fc8:	e58d300c 	str	r3, [sp, #12]
	}
    while((i < 50) && (!Chk_CMDend(6, 1)));   	// ACMD6
30041fcc:	e59d300c 	ldr	r3, [sp, #12]
30041fd0:	e3530031 	cmp	r3, #49	; 0x31
30041fd4:	ca000005 	bgt	30041ff0 <SetBus+0x7c>
30041fd8:	e3a00006 	mov	r0, #6
30041fdc:	e3a01001 	mov	r1, #1
30041fe0:	ebfffd8a 	bl	30041610 <Chk_CMDend>
30041fe4:	e1a03000 	mov	r3, r0
30041fe8:	e3530000 	cmp	r3, #0
30041fec:	0affffe7 	beq	30041f90 <SetBus+0x1c>

    rSDICSTA = 0xa00;	    // Clear cmd_end(with rsp)
30041ff0:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30041ff4:	e2833010 	add	r3, r3, #16
30041ff8:	e3a02c0a 	mov	r2, #2560	; 0xa00
30041ffc:	e5832000 	str	r2, [r3]

    if (i < 50)
30042000:	e59d300c 	ldr	r3, [sp, #12]
30042004:	e3530031 	cmp	r3, #49	; 0x31
30042008:	ca000009 	bgt	30042034 <SetBus+0xc0>
    {
    	if (iWide)
3004200c:	e5dd3003 	ldrb	r3, [sp, #3]
30042010:	e3530000 	cmp	r3, #0
30042014:	0a000002 	beq	30042024 <SetBus+0xb0>
    	{
	    	acoral_print("**** 4bit bus ****\n");
30042018:	e59f0028 	ldr	r0, [pc, #40]	; 30042048 <SetBus+0xd4>
3004201c:	ebff2487 	bl	3000b240 <acoral_print>
30042020:	ea000001 	b	3004202c <SetBus+0xb8>
	    }
    	else
    	{
    		acoral_print("**** 1bit bus ****\n");
30042024:	e59f0020 	ldr	r0, [pc, #32]	; 3004204c <SetBus+0xd8>
30042028:	ebff2484 	bl	3000b240 <acoral_print>
    	}
	    return	1;
3004202c:	e3a03001 	mov	r3, #1
30042030:	ea000000 	b	30042038 <SetBus+0xc4>
    }
    else
    {
    	return 0;
30042034:	e3a03000 	mov	r3, #0
    }
}
30042038:	e1a00003 	mov	r0, r3
3004203c:	e28dd014 	add	sp, sp, #20
30042040:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30042044:	e12fff1e 	bx	lr
30042048:	3004634c 	.word	0x3004634c
3004204c:	30046360 	.word	0x30046360

30042050 <Set_1bit_bus>:

static int Set_1bit_bus(int iRCA)
{
30042050:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30042054:	e24dd014 	sub	sp, sp, #20
30042058:	e58d0004 	str	r0, [sp, #4]
   	int i = 0;
3004205c:	e3a03000 	mov	r3, #0
30042060:	e58d300c 	str	r3, [sp, #12]
	do
	{
	    CMD55(iRCA);	// Make ACMD
30042064:	e59d0004 	ldr	r0, [sp, #4]
30042068:	ebfffea3 	bl	30041afc <CMD55>
	    //-- CMD6 implement
	    rSDICARG = 0 << 1;	    				//Wide 0: 1bit, 1: 4bit
3004206c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042070:	e2833008 	add	r3, r3, #8
30042074:	e3a02000 	mov	r2, #0
30042078:	e5832000 	str	r2, [r3]
	    rSDICCON = (0x1<<9) | (0x1<<8) | 0x46;	//sht_resp, wait_resp, start, CMD46
3004207c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042080:	e283300c 	add	r3, r3, #12
30042084:	e3a02fd1 	mov	r2, #836	; 0x344
30042088:	e2822002 	add	r2, r2, #2
3004208c:	e5832000 	str	r2, [r3]
	    i++;
30042090:	e59d300c 	ldr	r3, [sp, #12]
30042094:	e2833001 	add	r3, r3, #1
30042098:	e58d300c 	str	r3, [sp, #12]
	}
    while((i<50) && (!Chk_CMDend(6, 1)));   	// ACMD6
3004209c:	e59d300c 	ldr	r3, [sp, #12]
300420a0:	e3530031 	cmp	r3, #49	; 0x31
300420a4:	ca000005 	bgt	300420c0 <Set_1bit_bus+0x70>
300420a8:	e3a00006 	mov	r0, #6
300420ac:	e3a01001 	mov	r1, #1
300420b0:	ebfffd56 	bl	30041610 <Chk_CMDend>
300420b4:	e1a03000 	mov	r3, r0
300420b8:	e3530000 	cmp	r3, #0
300420bc:	0affffe8 	beq	30042064 <Set_1bit_bus+0x14>

    rSDICSTA = 0xa00;	    // Clear cmd_end(with rsp)
300420c0:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300420c4:	e2833010 	add	r3, r3, #16
300420c8:	e3a02c0a 	mov	r2, #2560	; 0xa00
300420cc:	e5832000 	str	r2, [r3]

    if (i < 50)
300420d0:	e59d300c 	ldr	r3, [sp, #12]
300420d4:	e3530031 	cmp	r3, #49	; 0x31
300420d8:	ca000003 	bgt	300420ec <Set_1bit_bus+0x9c>
    {
	    acoral_print("****1bit bus****\n");
300420dc:	e59f001c 	ldr	r0, [pc, #28]	; 30042100 <Set_1bit_bus+0xb0>
300420e0:	ebff2456 	bl	3000b240 <acoral_print>
	    return	1;
300420e4:	e3a03001 	mov	r3, #1
300420e8:	ea000000 	b	300420f0 <Set_1bit_bus+0xa0>
    }
    else
    {
    	return 0;
300420ec:	e3a03000 	mov	r3, #0
    }
}
300420f0:	e1a00003 	mov	r0, r3
300420f4:	e28dd014 	add	sp, sp, #20
300420f8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300420fc:	e12fff1e 	bx	lr
30042100:	30046374 	.word	0x30046374

30042104 <Chk_DATend>:



static int Chk_DATend(void)
{
30042104:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30042108:	e24dd00c 	sub	sp, sp, #12
    int i=0,finish;
3004210c:	e3a03000 	mov	r3, #0
30042110:	e58d3000 	str	r3, [sp]

    finish = rSDIDSTA;
30042114:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042118:	e2833034 	add	r3, r3, #52	; 0x34
3004211c:	e5933000 	ldr	r3, [r3]
30042120:	e58d3004 	str	r3, [sp, #4]

    while( !( ((finish&0x10) == 0x10) | ((finish&0x20) ==0x20) | (i>500) ))		// Chek timeout or data end
30042124:	ea000006 	b	30042144 <Chk_DATend+0x40>
	{
		finish = rSDIDSTA;
30042128:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004212c:	e2833034 	add	r3, r3, #52	; 0x34
30042130:	e5933000 	ldr	r3, [r3]
30042134:	e58d3004 	str	r3, [sp, #4]
		i++;
30042138:	e59d3000 	ldr	r3, [sp]
3004213c:	e2833001 	add	r3, r3, #1
30042140:	e58d3000 	str	r3, [sp]
{
    int i=0,finish;

    finish = rSDIDSTA;

    while( !( ((finish&0x10) == 0x10) | ((finish&0x20) ==0x20) | (i>500) ))		// Chek timeout or data end
30042144:	e59d3004 	ldr	r3, [sp, #4]
30042148:	e2033010 	and	r3, r3, #16
3004214c:	e3530000 	cmp	r3, #0
30042150:	03a03000 	moveq	r3, #0
30042154:	13a03001 	movne	r3, #1
30042158:	e20320ff 	and	r2, r3, #255	; 0xff
3004215c:	e59d3004 	ldr	r3, [sp, #4]
30042160:	e2033020 	and	r3, r3, #32
30042164:	e3530000 	cmp	r3, #0
30042168:	03a03000 	moveq	r3, #0
3004216c:	13a03001 	movne	r3, #1
30042170:	e20330ff 	and	r3, r3, #255	; 0xff
30042174:	e1823003 	orr	r3, r2, r3
30042178:	e20330ff 	and	r3, r3, #255	; 0xff
3004217c:	e1a02003 	mov	r2, r3
30042180:	e59d3000 	ldr	r3, [sp]
30042184:	e3530f7d 	cmp	r3, #500	; 0x1f4
30042188:	d3a03000 	movle	r3, #0
3004218c:	c3a03001 	movgt	r3, #1
30042190:	e1823003 	orr	r3, r2, r3
30042194:	e3530000 	cmp	r3, #0
30042198:	0affffe2 	beq	30042128 <Chk_DATend+0x24>
	{
		finish = rSDIDSTA;
		i++;
	}
	if( ((finish&0x2) == 0x2) || ((finish&0x1) == 0x1) )
3004219c:	e59d3004 	ldr	r3, [sp, #4]
300421a0:	e2033002 	and	r3, r3, #2
300421a4:	e3530000 	cmp	r3, #0
300421a8:	1a000004 	bne	300421c0 <Chk_DATend+0xbc>
300421ac:	e59d3004 	ldr	r3, [sp, #4]
300421b0:	e2033001 	and	r3, r3, #1
300421b4:	e20330ff 	and	r3, r3, #255	; 0xff
300421b8:	e3530000 	cmp	r3, #0
300421bc:	0a000001 	beq	300421c8 <Chk_DATend+0xc4>
		{
			Delay(200);
300421c0:	e3a000c8 	mov	r0, #200	; 0xc8
300421c4:	ebfffb63 	bl	30040f58 <Delay>
		}
    if( (finish&0xf0) != 0x10 )				//wangq,reserved 位也可能为1!!
300421c8:	e59d3004 	ldr	r3, [sp, #4]
300421cc:	e20330f0 	and	r3, r3, #240	; 0xf0
300421d0:	e3530010 	cmp	r3, #16
300421d4:	0a000005 	beq	300421f0 <Chk_DATend+0xec>
    {
        //acoral_print("DATA Error:SDIDatSta=0x%x\n", finish);
        //rSDIDSTA=0xec;  // Clear error state
        rSDIDSTA = 0xf8;  // Clear error state,wangq
300421d8:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300421dc:	e2833034 	add	r3, r3, #52	; 0x34
300421e0:	e3a020f8 	mov	r2, #248	; 0xf8
300421e4:	e5832000 	str	r2, [r3]
        return 0;
300421e8:	e3a03000 	mov	r3, #0
300421ec:	ea000000 	b	300421f4 <Chk_DATend+0xf0>
    }
    return 1;
300421f0:	e3a03001 	mov	r3, #1
}
300421f4:	e1a00003 	mov	r0, r3
300421f8:	e28dd00c 	add	sp, sp, #12
300421fc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30042200:	e12fff1e 	bx	lr

30042204 <Chk_BUSYend>:

static int Chk_BUSYend(void)
{
30042204:	e24dd008 	sub	sp, sp, #8
    int finish;

    finish = rSDIDSTA;
30042208:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004220c:	e2833034 	add	r3, r3, #52	; 0x34
30042210:	e5933000 	ldr	r3, [r3]
30042214:	e58d3004 	str	r3, [sp, #4]
    while( !( ((finish&0x08)==0x08) | ((finish&0x20)==0x20) ))
30042218:	ea000003 	b	3004222c <Chk_BUSYend+0x28>
    {
		finish = rSDIDSTA;
3004221c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042220:	e2833034 	add	r3, r3, #52	; 0x34
30042224:	e5933000 	ldr	r3, [r3]
30042228:	e58d3004 	str	r3, [sp, #4]
static int Chk_BUSYend(void)
{
    int finish;

    finish = rSDIDSTA;
    while( !( ((finish&0x08)==0x08) | ((finish&0x20)==0x20) ))
3004222c:	e59d3004 	ldr	r3, [sp, #4]
30042230:	e2033008 	and	r3, r3, #8
30042234:	e3530000 	cmp	r3, #0
30042238:	13a03000 	movne	r3, #0
3004223c:	03a03001 	moveq	r3, #1
30042240:	e20320ff 	and	r2, r3, #255	; 0xff
30042244:	e59d3004 	ldr	r3, [sp, #4]
30042248:	e2033020 	and	r3, r3, #32
3004224c:	e3530000 	cmp	r3, #0
30042250:	13a03000 	movne	r3, #0
30042254:	03a03001 	moveq	r3, #1
30042258:	e20330ff 	and	r3, r3, #255	; 0xff
3004225c:	e0023003 	and	r3, r2, r3
30042260:	e20330ff 	and	r3, r3, #255	; 0xff
30042264:	e3530000 	cmp	r3, #0
30042268:	1affffeb 	bne	3004221c <Chk_BUSYend+0x18>
    {
		finish = rSDIDSTA;
	}

    if( (finish&0xf8) != 0x08 )
3004226c:	e59d3004 	ldr	r3, [sp, #4]
30042270:	e20330f8 	and	r3, r3, #248	; 0xf8
30042274:	e3530008 	cmp	r3, #8
30042278:	0a000005 	beq	30042294 <Chk_BUSYend+0x90>
    {
       // acoral_print("DATA Error:SDIDSTA=0x%x\n", finish);
        //rSDIDSTA=0xf4;  //clear error state
        rSDIDSTA = 0xf8;  //clear error state,wangq
3004227c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042280:	e2833034 	add	r3, r3, #52	; 0x34
30042284:	e3a020f8 	mov	r2, #248	; 0xf8
30042288:	e5832000 	str	r2, [r3]
        return 0;
3004228c:	e3a03000 	mov	r3, #0
30042290:	ea000000 	b	30042298 <Chk_BUSYend+0x94>
    }
    return 1;
30042294:	e3a03001 	mov	r3, #1
}
30042298:	e1a00003 	mov	r0, r3
3004229c:	e28dd008 	add	sp, sp, #8
300422a0:	e12fff1e 	bx	lr

300422a4 <SD_Rd_Block>:




acoral_u32 SD_Rd_Block(card_desc *CardInfo, acoral_u32 mode, acoral_u32 addr, acoral_u32* Rx_buffer, acoral_u32 blocknum)
{
300422a4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300422a8:	e24dd024 	sub	sp, sp, #36	; 0x24
300422ac:	e58d000c 	str	r0, [sp, #12]
300422b0:	e58d1008 	str	r1, [sp, #8]
300422b4:	e58d2004 	str	r2, [sp, #4]
300422b8:	e58d3000 	str	r3, [sp]
    int status;
    int i = 0;
300422bc:	e3a03000 	mov	r3, #0
300422c0:	e58d3014 	str	r3, [sp, #20]
    int rd_cnt = 0;
300422c4:	e3a03000 	mov	r3, #0
300422c8:	e58d3018 	str	r3, [sp, #24]
	const acoral_u32	cc = 1;
300422cc:	e3a03001 	mov	r3, #1
300422d0:	e58d301c 	str	r3, [sp, #28]
	//-----  Reset the FIFO -----
	rSDIFSTA = rSDIFSTA|(1<<16);	// FIFO reset
300422d4:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300422d8:	e2833038 	add	r3, r3, #56	; 0x38
300422dc:	e3a0245a 	mov	r2, #1509949440	; 0x5a000000
300422e0:	e2822038 	add	r2, r2, #56	; 0x38
300422e4:	e5922000 	ldr	r2, [r2]
300422e8:	e3822801 	orr	r2, r2, #65536	; 0x10000
300422ec:	e5832000 	str	r2, [r3]

    if(mode!=2)
300422f0:	e59d3008 	ldr	r3, [sp, #8]
300422f4:	e3530002 	cmp	r3, #2
300422f8:	0a000005 	beq	30042314 <SD_Rd_Block+0x70>
		rSDIDCON=(2<<22)|(1<<19)|(1<<17)|(Wide<<16)|(1<<14)|(2<<12)|(blocknum<<0);	//YH 040220
300422fc:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042300:	e283302c 	add	r3, r3, #44	; 0x2c
30042304:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30042308:	e382288b 	orr	r2, r2, #9109504	; 0x8b0000
3004230c:	e3822a06 	orr	r2, r2, #24576	; 0x6000
30042310:	e5832000 	str	r2, [r3]
		//Word Rx, Rx after cmd, blk, 4bit bus, Rx start, blk num, data start, data transmit mode

    rSDICARG = addr;				// CMD17/18(addr)读地址
30042314:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042318:	e2833008 	add	r3, r3, #8
3004231c:	e59d2004 	ldr	r2, [sp, #4]
30042320:	e5832000 	str	r2, [r3]

    switch(mode)
30042324:	e59d3008 	ldr	r3, [sp, #8]
30042328:	e3530000 	cmp	r3, #0
3004232c:	0a000002 	beq	3004233c <SD_Rd_Block+0x98>
30042330:	e3530001 	cmp	r3, #1
30042334:	0a000060 	beq	300424bc <SD_Rd_Block+0x218>
30042338:	ea000061 	b	300424c4 <SD_Rd_Block+0x220>
    {
	case POL:
	    if(blocknum<2)	// SINGLE_READ
3004233c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30042340:	e3530001 	cmp	r3, #1
30042344:	8a000017 	bhi	300423a8 <SD_Rd_Block+0x104>
	    {
			do
			{
				rSDICCON=(0x1<<9)|(0x1<<8)|0x51;	// sht_resp, wait_resp, dat, start, CMD17
30042348:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004234c:	e283300c 	add	r3, r3, #12
30042350:	e3a02e35 	mov	r2, #848	; 0x350
30042354:	e2822001 	add	r2, r2, #1
30042358:	e5832000 	str	r2, [r3]
				i++;
3004235c:	e59d3014 	ldr	r3, [sp, #20]
30042360:	e2833001 	add	r3, r3, #1
30042364:	e58d3014 	str	r3, [sp, #20]
			}
			while(!Chk_CMDend(17, 1) && (i<50));	//-- Check end of CMD17
30042368:	e3a00011 	mov	r0, #17
3004236c:	e3a01001 	mov	r1, #1
30042370:	ebfffca6 	bl	30041610 <Chk_CMDend>
30042374:	e1a03000 	mov	r3, r0
30042378:	e3530000 	cmp	r3, #0
3004237c:	1a000002 	bne	3004238c <SD_Rd_Block+0xe8>
30042380:	e59d3014 	ldr	r3, [sp, #20]
30042384:	e3530031 	cmp	r3, #49	; 0x31
30042388:	daffffee 	ble	30042348 <SD_Rd_Block+0xa4>
			if(i == 50)
3004238c:	e59d3014 	ldr	r3, [sp, #20]
30042390:	e3530032 	cmp	r3, #50	; 0x32
30042394:	1a00001b 	bne	30042408 <SD_Rd_Block+0x164>
			{
				acoral_print("CMD18 Failed\n");
30042398:	e59f022c 	ldr	r0, [pc, #556]	; 300425cc <SD_Rd_Block+0x328>
3004239c:	ebff23a7 	bl	3000b240 <acoral_print>
				return 0;
300423a0:	e3a03000 	mov	r3, #0
300423a4:	ea000084 	b	300425bc <SD_Rd_Block+0x318>
	    }
	    else		// MULTI_READ
	    {
			do
			{
				rSDICCON=(0x1<<9)|(0x1<<8)|0x52;    // sht_resp, wait_resp, dat, start, CMD18
300423a8:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300423ac:	e283300c 	add	r3, r3, #12
300423b0:	e3a02e35 	mov	r2, #848	; 0x350
300423b4:	e2822002 	add	r2, r2, #2
300423b8:	e5832000 	str	r2, [r3]
				i++;
300423bc:	e59d3014 	ldr	r3, [sp, #20]
300423c0:	e2833001 	add	r3, r3, #1
300423c4:	e58d3014 	str	r3, [sp, #20]
			}
			while(!Chk_CMDend(18, 1) && (i<50));	//-- Check end of CMD18
300423c8:	e3a00012 	mov	r0, #18
300423cc:	e3a01001 	mov	r1, #1
300423d0:	ebfffc8e 	bl	30041610 <Chk_CMDend>
300423d4:	e1a03000 	mov	r3, r0
300423d8:	e3530000 	cmp	r3, #0
300423dc:	1a000002 	bne	300423ec <SD_Rd_Block+0x148>
300423e0:	e59d3014 	ldr	r3, [sp, #20]
300423e4:	e3530031 	cmp	r3, #49	; 0x31
300423e8:	daffffee 	ble	300423a8 <SD_Rd_Block+0x104>
			if(i == 50)
300423ec:	e59d3014 	ldr	r3, [sp, #20]
300423f0:	e3530032 	cmp	r3, #50	; 0x32
300423f4:	1a000004 	bne	3004240c <SD_Rd_Block+0x168>
			{
				acoral_print("CMD18 Failed\n");
300423f8:	e59f01cc 	ldr	r0, [pc, #460]	; 300425cc <SD_Rd_Block+0x328>
300423fc:	ebff238f 	bl	3000b240 <acoral_print>
				return 0;
30042400:	e3a03000 	mov	r3, #0
30042404:	ea00006c 	b	300425bc <SD_Rd_Block+0x318>
			}
			while(!Chk_CMDend(17, 1) && (i<50));	//-- Check end of CMD17
			if(i == 50)
			{
				acoral_print("CMD18 Failed\n");
				return 0;
30042408:	e1a00000 	nop			; (mov r0, r0)
				acoral_print("CMD18 Failed\n");
				return 0;
		    }
	    }

	    rSDICSTA = 0xa00;	// Clear cmd_end(with rsp)
3004240c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042410:	e2833010 	add	r3, r3, #16
30042414:	e3a02c0a 	mov	r2, #2560	; 0xa00
30042418:	e5832000 	str	r2, [r3]

	    while(rd_cnt < (128*blocknum))	// 512*block bytes
3004241c:	ea000020 	b	300424a4 <SD_Rd_Block+0x200>
	    {
	    	//acoral_print("***rd_cnt:%d dat:%d\n",rd_cnt,rSDIDAT);
			if ((rSDIDSTA & 0x20) == 0x20) 			// Check timeout
30042420:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042424:	e2833034 	add	r3, r3, #52	; 0x34
30042428:	e5933000 	ldr	r3, [r3]
3004242c:	e2033020 	and	r3, r3, #32
30042430:	e3530000 	cmp	r3, #0
30042434:	0a000007 	beq	30042458 <SD_Rd_Block+0x1b4>
			{
			    //rSDIDSTA=(0x1<<0x5);  			// Clear timeout flag
			    rSDIDSTA = (0x1<<5);  			// Clear timeout flag,wangq
30042438:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004243c:	e2833034 	add	r3, r3, #52	; 0x34
30042440:	e3a02020 	mov	r2, #32
30042444:	e5832000 	str	r2, [r3]

			    acoral_print("Read Error,timeout!!!\n");
30042448:	e59f0180 	ldr	r0, [pc, #384]	; 300425d0 <SD_Rd_Block+0x32c>
3004244c:	ebff237b 	bl	3000b240 <acoral_print>
			    break;
30042450:	e1a00000 	nop			; (mov r0, r0)
				    rd_cnt++;
			    }
			}

	    }
	    break;
30042454:	ea00001a 	b	300424c4 <SD_Rd_Block+0x220>
			    rSDIDSTA = (0x1<<5);  			// Clear timeout flag,wangq

			    acoral_print("Read Error,timeout!!!\n");
			    break;
			}
			status = rSDIFSTA;
30042458:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004245c:	e2833038 	add	r3, r3, #56	; 0x38
30042460:	e5933000 	ldr	r3, [r3]
30042464:	e58d3010 	str	r3, [sp, #16]
			if((status&0x1000) == 0x1000)			// Is Rx data?
30042468:	e59d3010 	ldr	r3, [sp, #16]
3004246c:	e2033a01 	and	r3, r3, #4096	; 0x1000
30042470:	e3530000 	cmp	r3, #0
30042474:	0a00000a 	beq	300424a4 <SD_Rd_Block+0x200>
			{
				//acoral_print("Number of data(byte) in FIFO:%d \n",status&0x7f);
				//for(i=0; i < (status&0x7f); i++)
				{
				    *(Rx_buffer+rd_cnt) = rSDIDAT;
30042478:	e59d3018 	ldr	r3, [sp, #24]
3004247c:	e1a02103 	lsl	r2, r3, #2
30042480:	e59d3000 	ldr	r3, [sp]
30042484:	e0822003 	add	r2, r2, r3
30042488:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004248c:	e2833040 	add	r3, r3, #64	; 0x40
30042490:	e5933000 	ldr	r3, [r3]
30042494:	e5823000 	str	r3, [r2]
				    //acoral_print("rd_cnt:%d dat:%d\n", rd_cnt, *(Rx_buffer+rd_cnt));
				    rd_cnt++;
30042498:	e59d3018 	ldr	r3, [sp, #24]
3004249c:	e2833001 	add	r3, r3, #1
300424a0:	e58d3018 	str	r3, [sp, #24]
		    }
	    }

	    rSDICSTA = 0xa00;	// Clear cmd_end(with rsp)

	    while(rd_cnt < (128*blocknum))	// 512*block bytes
300424a4:	e59d2018 	ldr	r2, [sp, #24]
300424a8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300424ac:	e1a03383 	lsl	r3, r3, #7
300424b0:	e1520003 	cmp	r2, r3
300424b4:	3affffd9 	bcc	30042420 <SD_Rd_Block+0x17c>
				    rd_cnt++;
			    }
			}

	    }
	    break;
300424b8:	ea000001 	b	300424c4 <SD_Rd_Block+0x220>

	case INT:
		return 0;
300424bc:	e3a03000 	mov	r3, #0
300424c0:	ea00003d 	b	300425bc <SD_Rd_Block+0x318>
	default:
	    break;
    }

    //-- Check end of DATA
    for (i = 0; i < 50; i++)
300424c4:	e3a03000 	mov	r3, #0
300424c8:	e58d3014 	str	r3, [sp, #20]
300424cc:	e59d3014 	ldr	r3, [sp, #20]
300424d0:	e3530031 	cmp	r3, #49	; 0x31
300424d4:	ca000008 	bgt	300424fc <SD_Rd_Block+0x258>
    {
	    if(Chk_DATend())
300424d8:	ebffff09 	bl	30042104 <Chk_DATend>
300424dc:	e1a03000 	mov	r3, r0
300424e0:	e3530000 	cmp	r3, #0
300424e4:	1a000003 	bne	300424f8 <SD_Rd_Block+0x254>
		{
			break;
		}
	    else
	    {
			acoral_print("Read Dat Error!!\n");
300424e8:	e59f00e4 	ldr	r0, [pc, #228]	; 300425d4 <SD_Rd_Block+0x330>
300424ec:	ebff2353 	bl	3000b240 <acoral_print>
			return 0;
300424f0:	e3a03000 	mov	r3, #0
300424f4:	ea000030 	b	300425bc <SD_Rd_Block+0x318>
    //-- Check end of DATA
    for (i = 0; i < 50; i++)
    {
	    if(Chk_DATend())
		{
			break;
300424f8:	e1a00000 	nop			; (mov r0, r0)
			acoral_print("Read Dat Error!!\n");
			return 0;
		}
	}

	rSDIDCON = rSDIDCON&~(7<<12);		//YH 040220, Clear Data Transfer mode => no operation, Cleata Data Transfer start
300424fc:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042500:	e283302c 	add	r3, r3, #44	; 0x2c
30042504:	e3a0245a 	mov	r2, #1509949440	; 0x5a000000
30042508:	e282202c 	add	r2, r2, #44	; 0x2c
3004250c:	e5922000 	ldr	r2, [r2]
30042510:	e3c22a07 	bic	r2, r2, #28672	; 0x7000
30042514:	e5832000 	str	r2, [r3]
	rSDIFSTA = rSDIFSTA&0x200;		//Clear Rx FIFO Last data Ready, YH 040221
30042518:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004251c:	e2833038 	add	r3, r3, #56	; 0x38
30042520:	e3a0245a 	mov	r2, #1509949440	; 0x5a000000
30042524:	e2822038 	add	r2, r2, #56	; 0x38
30042528:	e5922000 	ldr	r2, [r2]
3004252c:	e2022c02 	and	r2, r2, #512	; 0x200
30042530:	e5832000 	str	r2, [r3]
    rSDIDSTA = 0x10;					// Clear data Tx/Rx end detect
30042534:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042538:	e2833034 	add	r3, r3, #52	; 0x34
3004253c:	e3a02010 	mov	r2, #16
30042540:	e5832000 	str	r2, [r3]

    if(blocknum > 1)
30042544:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30042548:	e3530001 	cmp	r3, #1
3004254c:	9a000019 	bls	300425b8 <SD_Rd_Block+0x314>
    {
    	i = 0;
30042550:	e3a03000 	mov	r3, #0
30042554:	e58d3014 	str	r3, [sp, #20]
		do
		{
			//--Stop cmd(CMD12)
			rSDICARG = 0x0;	    			//CMD12(stuff bit)
30042558:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004255c:	e2833008 	add	r3, r3, #8
30042560:	e3a02000 	mov	r2, #0
30042564:	e5832000 	str	r2, [r3]
			rSDICCON = (0x1<<9)|(0x1<<8)|0x4c;//sht_resp, wait_resp, start, CMD12
30042568:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004256c:	e283300c 	add	r3, r3, #12
30042570:	e3a02fd3 	mov	r2, #844	; 0x34c
30042574:	e5832000 	str	r2, [r3]
			i++;
30042578:	e59d3014 	ldr	r3, [sp, #20]
3004257c:	e2833001 	add	r3, r3, #1
30042580:	e58d3014 	str	r3, [sp, #20]
		}
		//-- Check end of CMD12
		while(!Chk_CMDend(12, 1) && (i < 100));
30042584:	e3a0000c 	mov	r0, #12
30042588:	e3a01001 	mov	r1, #1
3004258c:	ebfffc1f 	bl	30041610 <Chk_CMDend>
30042590:	e1a03000 	mov	r3, r0
30042594:	e3530000 	cmp	r3, #0
30042598:	1a000002 	bne	300425a8 <SD_Rd_Block+0x304>
3004259c:	e59d3014 	ldr	r3, [sp, #20]
300425a0:	e3530063 	cmp	r3, #99	; 0x63
300425a4:	daffffeb 	ble	30042558 <SD_Rd_Block+0x2b4>

		rSDICSTA = 0xa00;	// Clear cmd_end(with rsp)
300425a8:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300425ac:	e2833010 	add	r3, r3, #16
300425b0:	e3a02c0a 	mov	r2, #2560	; 0xa00
300425b4:	e5832000 	str	r2, [r3]
    }
    //CMD13();

    return 1;
300425b8:	e3a03001 	mov	r3, #1
}
300425bc:	e1a00003 	mov	r0, r3
300425c0:	e28dd024 	add	sp, sp, #36	; 0x24
300425c4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300425c8:	e12fff1e 	bx	lr
300425cc:	30046388 	.word	0x30046388
300425d0:	30046398 	.word	0x30046398
300425d4:	300463b0 	.word	0x300463b0

300425d8 <SD_Wt_Block>:

acoral_u32 SD_Wt_Block(card_desc *CardInfo, acoral_u32 mode, acoral_u32 addr, acoral_u32* Tx_buffer, acoral_u32 blocknum)
{
300425d8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300425dc:	e24dd024 	sub	sp, sp, #36	; 0x24
300425e0:	e58d000c 	str	r0, [sp, #12]
300425e4:	e58d1008 	str	r1, [sp, #8]
300425e8:	e58d2004 	str	r2, [sp, #4]
300425ec:	e58d3000 	str	r3, [sp]
    int status;
    int i = 0;
300425f0:	e3a03000 	mov	r3, #0
300425f4:	e58d3018 	str	r3, [sp, #24]
    int wt_cnt = 0;
300425f8:	e3a03000 	mov	r3, #0
300425fc:	e58d301c 	str	r3, [sp, #28]
	//const acoral_u32 cc = 1;

	rSDIFSTA = rSDIFSTA | (1<<16);		//YH 040223 FIFO reset
30042600:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042604:	e2833038 	add	r3, r3, #56	; 0x38
30042608:	e3a0245a 	mov	r2, #1509949440	; 0x5a000000
3004260c:	e2822038 	add	r2, r2, #56	; 0x38
30042610:	e5922000 	ldr	r2, [r2]
30042614:	e3822801 	orr	r2, r2, #65536	; 0x10000
30042618:	e5832000 	str	r2, [r3]

    if (mode != 2)
3004261c:	e59d3008 	ldr	r3, [sp, #8]
30042620:	e3530002 	cmp	r3, #2
30042624:	0a000005 	beq	30042640 <SD_Wt_Block+0x68>
    {
		//rSDIDCON=(2<<22)|(1<<20)|(1<<17)|(Wide<<16)|(3<<12)|(block<<0);
		rSDIDCON=(2<<22)|(1<<20)|(1<<17)|(Wide<<16)|(1<<14)|(3<<12)|(blocknum<<0);	//YH 040220
30042628:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004262c:	e283302c 	add	r3, r3, #44	; 0x2c
30042630:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30042634:	e3822893 	orr	r2, r2, #9633792	; 0x930000
30042638:	e3822a07 	orr	r2, r2, #28672	; 0x7000
3004263c:	e5832000 	str	r2, [r3]

		    //Word Tx, Tx after rsp, blk, 4bit bus, Tx start,Data transmit mode, blk num
	}

    rSDICARG = addr;	    			// CMD24/25(addr)写入地址
30042640:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042644:	e2833008 	add	r3, r3, #8
30042648:	e59d2004 	ldr	r2, [sp, #4]
3004264c:	e5832000 	str	r2, [r3]

    switch(mode)
30042650:	e59d3008 	ldr	r3, [sp, #8]
30042654:	e3530000 	cmp	r3, #0
30042658:	0a000002 	beq	30042668 <SD_Wt_Block+0x90>
3004265c:	e3530001 	cmp	r3, #1
30042660:	0a000048 	beq	30042788 <SD_Wt_Block+0x1b0>
30042664:	ea000049 	b	30042790 <SD_Wt_Block+0x1b8>
    {
	case POL:
	    if(blocknum < 2)	// SINGLE_WRITE
30042668:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3004266c:	e3530001 	cmp	r3, #1
30042670:	8a000010 	bhi	300426b8 <SD_Wt_Block+0xe0>
	    {
			do
			{
				rSDICCON = (0x1<<9)|(0x1<<8)|0x58;	//sht_resp, wait_resp, dat, start, CMD24
30042674:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042678:	e283300c 	add	r3, r3, #12
3004267c:	e3a02fd6 	mov	r2, #856	; 0x358
30042680:	e5832000 	str	r2, [r3]
				i++;
30042684:	e59d3018 	ldr	r3, [sp, #24]
30042688:	e2833001 	add	r3, r3, #1
3004268c:	e58d3018 	str	r3, [sp, #24]
			}
			while(!Chk_CMDend(24, 1) && (i < 50));				//-- Check end of CMD24
30042690:	e3a00018 	mov	r0, #24
30042694:	e3a01001 	mov	r1, #1
30042698:	ebfffbdc 	bl	30041610 <Chk_CMDend>
3004269c:	e1a03000 	mov	r3, r0
300426a0:	e3530000 	cmp	r3, #0
300426a4:	1a000014 	bne	300426fc <SD_Wt_Block+0x124>
300426a8:	e59d3018 	ldr	r3, [sp, #24]
300426ac:	e3530031 	cmp	r3, #49	; 0x31
300426b0:	daffffef 	ble	30042674 <SD_Wt_Block+0x9c>
300426b4:	ea000010 	b	300426fc <SD_Wt_Block+0x124>
	    }
	    else				// MULTI_WRITE
	    {
	    	do
			{
				rSDICCON=(0x1<<9)|(0x1<<8)|0x59;	//sht_resp, wait_resp, dat, start, CMD25
300426b8:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300426bc:	e283300c 	add	r3, r3, #12
300426c0:	e3a02fd6 	mov	r2, #856	; 0x358
300426c4:	e2822001 	add	r2, r2, #1
300426c8:	e5832000 	str	r2, [r3]
				i++;
300426cc:	e59d3018 	ldr	r3, [sp, #24]
300426d0:	e2833001 	add	r3, r3, #1
300426d4:	e58d3018 	str	r3, [sp, #24]
			}
			while(!Chk_CMDend(25, 1) && (i < 50));				//-- Check end of CMD25
300426d8:	e3a00019 	mov	r0, #25
300426dc:	e3a01001 	mov	r1, #1
300426e0:	ebfffbca 	bl	30041610 <Chk_CMDend>
300426e4:	e1a03000 	mov	r3, r0
300426e8:	e3530000 	cmp	r3, #0
300426ec:	1a000002 	bne	300426fc <SD_Wt_Block+0x124>
300426f0:	e59d3018 	ldr	r3, [sp, #24]
300426f4:	e3530031 	cmp	r3, #49	; 0x31
300426f8:	daffffee 	ble	300426b8 <SD_Wt_Block+0xe0>

	    }

	    rSDICSTA = 0xa00;							// Clear cmd_end(with rsp)
300426fc:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042700:	e2833010 	add	r3, r3, #16
30042704:	e3a02c0a 	mov	r2, #2560	; 0xa00
30042708:	e5832000 	str	r2, [r3]

	    i = 0;
3004270c:	e3a03000 	mov	r3, #0
30042710:	e58d3018 	str	r3, [sp, #24]
	    while(wt_cnt < 128*blocknum)
30042714:	ea000015 	b	30042770 <SD_Wt_Block+0x198>
	    {
			status = rSDIFSTA;
30042718:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004271c:	e2833038 	add	r3, r3, #56	; 0x38
30042720:	e5933000 	ldr	r3, [r3]
30042724:	e58d3014 	str	r3, [sp, #20]
			if((status&0x2000) == 0x2000)
30042728:	e59d3014 	ldr	r3, [sp, #20]
3004272c:	e2033a02 	and	r3, r3, #8192	; 0x2000
30042730:	e3530000 	cmp	r3, #0
30042734:	0a00000d 	beq	30042770 <SD_Wt_Block+0x198>
			{
			    rSDIDAT = *(Tx_buffer + i);
30042738:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004273c:	e2833040 	add	r3, r3, #64	; 0x40
30042740:	e59d2018 	ldr	r2, [sp, #24]
30042744:	e1a01102 	lsl	r1, r2, #2
30042748:	e59d2000 	ldr	r2, [sp]
3004274c:	e0812002 	add	r2, r1, r2
30042750:	e5922000 	ldr	r2, [r2]
30042754:	e5832000 	str	r2, [r3]
			    i++;
30042758:	e59d3018 	ldr	r3, [sp, #24]
3004275c:	e2833001 	add	r3, r3, #1
30042760:	e58d3018 	str	r3, [sp, #24]
			    wt_cnt++;
30042764:	e59d301c 	ldr	r3, [sp, #28]
30042768:	e2833001 	add	r3, r3, #1
3004276c:	e58d301c 	str	r3, [sp, #28]
	    }

	    rSDICSTA = 0xa00;							// Clear cmd_end(with rsp)

	    i = 0;
	    while(wt_cnt < 128*blocknum)
30042770:	e59d201c 	ldr	r2, [sp, #28]
30042774:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30042778:	e1a03383 	lsl	r3, r3, #7
3004277c:	e1520003 	cmp	r2, r3
30042780:	3affffe4 	bcc	30042718 <SD_Wt_Block+0x140>
			    wt_cnt++;
				//acoral_print("Dat=%d, wt_cnt=%d\n",*(Tx_buffer+i),wt_cnt);
			}
	    }

	    break;
30042784:	ea000001 	b	30042790 <SD_Wt_Block+0x1b8>

	case INT:
		return 0;
30042788:	e3a03000 	mov	r3, #0
3004278c:	ea00004c 	b	300428c4 <SD_Wt_Block+0x2ec>
	default:
	    break;
    }

    //-- Check end of DATA
    for (i = 0; i < 50; i++)
30042790:	e3a03000 	mov	r3, #0
30042794:	e58d3018 	str	r3, [sp, #24]
30042798:	ea000006 	b	300427b8 <SD_Wt_Block+0x1e0>
    {
	    if(Chk_DATend())
3004279c:	ebfffe58 	bl	30042104 <Chk_DATend>
300427a0:	e1a03000 	mov	r3, r0
300427a4:	e3530000 	cmp	r3, #0
300427a8:	1a000006 	bne	300427c8 <SD_Wt_Block+0x1f0>
	default:
	    break;
    }

    //-- Check end of DATA
    for (i = 0; i < 50; i++)
300427ac:	e59d3018 	ldr	r3, [sp, #24]
300427b0:	e2833001 	add	r3, r3, #1
300427b4:	e58d3018 	str	r3, [sp, #24]
300427b8:	e59d3018 	ldr	r3, [sp, #24]
300427bc:	e3530031 	cmp	r3, #49	; 0x31
300427c0:	dafffff5 	ble	3004279c <SD_Wt_Block+0x1c4>
300427c4:	ea000000 	b	300427cc <SD_Wt_Block+0x1f4>
    {
	    if(Chk_DATend())
		{
			break;
300427c8:	e1a00000 	nop			; (mov r0, r0)
		}

	}
	if (i == 50)
300427cc:	e59d3018 	ldr	r3, [sp, #24]
300427d0:	e3530032 	cmp	r3, #50	; 0x32
300427d4:	1a000003 	bne	300427e8 <SD_Wt_Block+0x210>
	{
		acoral_print("Write Dat Error!!\n");
300427d8:	e59f00f4 	ldr	r0, [pc, #244]	; 300428d4 <SD_Wt_Block+0x2fc>
300427dc:	ebff2297 	bl	3000b240 <acoral_print>
		return 0;
300427e0:	e3a03000 	mov	r3, #0
300427e4:	ea000036 	b	300428c4 <SD_Wt_Block+0x2ec>
	}

	rSDIDCON = rSDIDCON & ~(7<<12);			//YH 040220, Clear Data Transfer mode => no operation, Cleata Data Transfer start
300427e8:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300427ec:	e283302c 	add	r3, r3, #44	; 0x2c
300427f0:	e3a0245a 	mov	r2, #1509949440	; 0x5a000000
300427f4:	e282202c 	add	r2, r2, #44	; 0x2c
300427f8:	e5922000 	ldr	r2, [r2]
300427fc:	e3c22a07 	bic	r2, r2, #28672	; 0x7000
30042800:	e5832000 	str	r2, [r3]
    rSDIDSTA = 0x10;						// Clear data Tx/Rx end
30042804:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042808:	e2833034 	add	r3, r3, #52	; 0x34
3004280c:	e3a02010 	mov	r2, #16
30042810:	e5832000 	str	r2, [r3]

    if((blocknum > 1) )
30042814:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30042818:	e3530001 	cmp	r3, #1
3004281c:	9a000027 	bls	300428c0 <SD_Wt_Block+0x2e8>
    {
		//--Stop cmd(CMD12)
		i = 0;
30042820:	e3a03000 	mov	r3, #0
30042824:	e58d3018 	str	r3, [sp, #24]
		do
		{
			rSDIDCON=(1<<18)|(1<<17)|(Wide<<16)|(1<<14)|(1<<12)|(blocknum<<0); 	//YH  040220
30042828:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004282c:	e283302c 	add	r3, r3, #44	; 0x2c
30042830:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30042834:	e3822a75 	orr	r2, r2, #479232	; 0x75000
30042838:	e5832000 	str	r2, [r3]


			rSDICARG = 0x0;	    				//CMD12(stuff bit)
3004283c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042840:	e2833008 	add	r3, r3, #8
30042844:	e3a02000 	mov	r2, #0
30042848:	e5832000 	str	r2, [r3]
			rSDICCON=(0x1<<9)|(0x1<<8)|0x4c;    //sht_resp, wait_resp, start, CMD12
3004284c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042850:	e283300c 	add	r3, r3, #12
30042854:	e3a02fd3 	mov	r2, #844	; 0x34c
30042858:	e5832000 	str	r2, [r3]
		}
		//-- Check end of CMD12
		while(!Chk_CMDend(12, 1) && (i < 50));
3004285c:	e3a0000c 	mov	r0, #12
30042860:	e3a01001 	mov	r1, #1
30042864:	ebfffb69 	bl	30041610 <Chk_CMDend>
30042868:	e1a03000 	mov	r3, r0
3004286c:	e3530000 	cmp	r3, #0
30042870:	1a000002 	bne	30042880 <SD_Wt_Block+0x2a8>
30042874:	e59d3018 	ldr	r3, [sp, #24]
30042878:	e3530031 	cmp	r3, #49	; 0x31
3004287c:	daffffe9 	ble	30042828 <SD_Wt_Block+0x250>

		rSDICSTA = 0xa00;						// Clear cmd_end(with rsp)
30042880:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042884:	e2833010 	add	r3, r3, #16
30042888:	e3a02c0a 	mov	r2, #2560	; 0xa00
3004288c:	e5832000 	str	r2, [r3]

		//-- Check end of DATA(with busy state)
		if(!Chk_BUSYend())
30042890:	ebfffe5b 	bl	30042204 <Chk_BUSYend>
30042894:	e1a03000 	mov	r3, r0
30042898:	e3530000 	cmp	r3, #0
3004289c:	1a000003 	bne	300428b0 <SD_Wt_Block+0x2d8>
		{
		    acoral_print("Chk_BUSYend Error!!\n");
300428a0:	e59f0030 	ldr	r0, [pc, #48]	; 300428d8 <SD_Wt_Block+0x300>
300428a4:	ebff2265 	bl	3000b240 <acoral_print>
		    return 0;
300428a8:	e3a03000 	mov	r3, #0
300428ac:	ea000004 	b	300428c4 <SD_Wt_Block+0x2ec>
		}

		rSDIDSTA = 0x08;						//! Should be cleared by writing '1'.
300428b0:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300428b4:	e2833034 	add	r3, r3, #52	; 0x34
300428b8:	e3a02008 	mov	r2, #8
300428bc:	e5832000 	str	r2, [r3]
    }
    return 1;
300428c0:	e3a03001 	mov	r3, #1

    //CMD13();
}
300428c4:	e1a00003 	mov	r0, r3
300428c8:	e28dd024 	add	sp, sp, #36	; 0x24
300428cc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300428d0:	e12fff1e 	bx	lr
300428d4:	300463c4 	.word	0x300463c4
300428d8:	300463d8 	.word	0x300463d8

300428dc <SD_Get_CardStat>:



int SD_Get_CardStat(int iRCA)//CMD13
{
300428dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300428e0:	e24dd014 	sub	sp, sp, #20
300428e4:	e58d0004 	str	r0, [sp, #4]
    int response0;
	unsigned int cc = 1;
300428e8:	e3a03001 	mov	r3, #1
300428ec:	e58d300c 	str	r3, [sp, #12]
    rSDICARG = iRCA<<16;					// CMD13(RCA,stuff bit)
300428f0:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300428f4:	e2833008 	add	r3, r3, #8
300428f8:	e59d2004 	ldr	r2, [sp, #4]
300428fc:	e1a02802 	lsl	r2, r2, #16
30042900:	e5832000 	str	r2, [r3]
    rSDICCON = (0x1<<9) | (0x1<<8) | 0x4d;	// sht_resp, wait_resp, start, CMD13
30042904:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042908:	e283300c 	add	r3, r3, #12
3004290c:	e3a02fd3 	mov	r2, #844	; 0x34c
30042910:	e2822001 	add	r2, r2, #1
30042914:	e5832000 	str	r2, [r3]

    //-- Check end of CMD13
    if(!Chk_CMDend(13, 1))
30042918:	e3a0000d 	mov	r0, #13
3004291c:	e3a01001 	mov	r1, #1
30042920:	ebfffb3a 	bl	30041610 <Chk_CMDend>
30042924:	e1a03000 	mov	r3, r0
30042928:	e3530000 	cmp	r3, #0
3004292c:	1a000001 	bne	30042938 <SD_Get_CardStat+0x5c>
    {
		return -1;
30042930:	e3e03000 	mvn	r3, #0
30042934:	ea0000ad 	b	30042bf0 <SD_Get_CardStat+0x314>
	}
    //acoral_print("rSDIRSP0=0x%x\n", rSDIRSP0);

    if (rSDIRSP0 & (cc << 31))
30042938:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
3004293c:	e2833014 	add	r3, r3, #20
30042940:	e5932000 	ldr	r2, [r3]
30042944:	e59d300c 	ldr	r3, [sp, #12]
30042948:	e1a03f83 	lsl	r3, r3, #31
3004294c:	e0023003 	and	r3, r2, r3
30042950:	e3530000 	cmp	r3, #0
30042954:	0a000002 	beq	30042964 <SD_Get_CardStat+0x88>
    {
		acoral_print("Error: OUT_OF_RANGE!\n");
30042958:	e59f02a0 	ldr	r0, [pc, #672]	; 30042c00 <SD_Get_CardStat+0x324>
3004295c:	ebff2237 	bl	3000b240 <acoral_print>
30042960:	ea000061 	b	30042aec <SD_Get_CardStat+0x210>
	}
	else if (rSDIRSP0 & (cc << 30))
30042964:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042968:	e2833014 	add	r3, r3, #20
3004296c:	e5932000 	ldr	r2, [r3]
30042970:	e59d300c 	ldr	r3, [sp, #12]
30042974:	e1a03f03 	lsl	r3, r3, #30
30042978:	e0023003 	and	r3, r2, r3
3004297c:	e3530000 	cmp	r3, #0
30042980:	0a000002 	beq	30042990 <SD_Get_CardStat+0xb4>
    {
		acoral_print("Error: ADDRESS_ERROR!\n");
30042984:	e59f0278 	ldr	r0, [pc, #632]	; 30042c04 <SD_Get_CardStat+0x328>
30042988:	ebff222c 	bl	3000b240 <acoral_print>
3004298c:	ea000056 	b	30042aec <SD_Get_CardStat+0x210>
	}
	else if (rSDIRSP0 & (cc << 29))
30042990:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042994:	e2833014 	add	r3, r3, #20
30042998:	e5932000 	ldr	r2, [r3]
3004299c:	e59d300c 	ldr	r3, [sp, #12]
300429a0:	e1a03e83 	lsl	r3, r3, #29
300429a4:	e0023003 	and	r3, r2, r3
300429a8:	e3530000 	cmp	r3, #0
300429ac:	0a000002 	beq	300429bc <SD_Get_CardStat+0xe0>
    {
		acoral_print("Error: BLOCK_LEN_ERROR!\n");
300429b0:	e59f0250 	ldr	r0, [pc, #592]	; 30042c08 <SD_Get_CardStat+0x32c>
300429b4:	ebff2221 	bl	3000b240 <acoral_print>
300429b8:	ea00004b 	b	30042aec <SD_Get_CardStat+0x210>
	}
	else if (rSDIRSP0 & (cc << 28))
300429bc:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300429c0:	e2833014 	add	r3, r3, #20
300429c4:	e5932000 	ldr	r2, [r3]
300429c8:	e59d300c 	ldr	r3, [sp, #12]
300429cc:	e1a03e03 	lsl	r3, r3, #28
300429d0:	e0023003 	and	r3, r2, r3
300429d4:	e3530000 	cmp	r3, #0
300429d8:	0a000002 	beq	300429e8 <SD_Get_CardStat+0x10c>
    {
		acoral_print("Error: ERASE_SEQUENCE_ERROR!\n");
300429dc:	e59f0228 	ldr	r0, [pc, #552]	; 30042c0c <SD_Get_CardStat+0x330>
300429e0:	ebff2216 	bl	3000b240 <acoral_print>
300429e4:	ea000040 	b	30042aec <SD_Get_CardStat+0x210>
	}
	else if (rSDIRSP0 & (cc << 27))
300429e8:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
300429ec:	e2833014 	add	r3, r3, #20
300429f0:	e5932000 	ldr	r2, [r3]
300429f4:	e59d300c 	ldr	r3, [sp, #12]
300429f8:	e1a03d83 	lsl	r3, r3, #27
300429fc:	e0023003 	and	r3, r2, r3
30042a00:	e3530000 	cmp	r3, #0
30042a04:	0a000002 	beq	30042a14 <SD_Get_CardStat+0x138>
    {
		acoral_print("Error: ERASE_INVALID_BLOCKS_ERROR!\n");
30042a08:	e59f0200 	ldr	r0, [pc, #512]	; 30042c10 <SD_Get_CardStat+0x334>
30042a0c:	ebff220b 	bl	3000b240 <acoral_print>
30042a10:	ea000035 	b	30042aec <SD_Get_CardStat+0x210>
	}
	else if (rSDIRSP0 & (cc << 26))
30042a14:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042a18:	e2833014 	add	r3, r3, #20
30042a1c:	e5932000 	ldr	r2, [r3]
30042a20:	e59d300c 	ldr	r3, [sp, #12]
30042a24:	e1a03d03 	lsl	r3, r3, #26
30042a28:	e0023003 	and	r3, r2, r3
30042a2c:	e3530000 	cmp	r3, #0
30042a30:	0a000002 	beq	30042a40 <SD_Get_CardStat+0x164>
    {
		acoral_print("Error: WP_VIOLATION_ERROR!\n");
30042a34:	e59f01d8 	ldr	r0, [pc, #472]	; 30042c14 <SD_Get_CardStat+0x338>
30042a38:	ebff2200 	bl	3000b240 <acoral_print>
30042a3c:	ea00002a 	b	30042aec <SD_Get_CardStat+0x210>
	}
	else if (rSDIRSP0 & (cc << 25))
30042a40:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042a44:	e2833014 	add	r3, r3, #20
30042a48:	e5932000 	ldr	r2, [r3]
30042a4c:	e59d300c 	ldr	r3, [sp, #12]
30042a50:	e1a03c83 	lsl	r3, r3, #25
30042a54:	e0023003 	and	r3, r2, r3
30042a58:	e3530000 	cmp	r3, #0
30042a5c:	0a000002 	beq	30042a6c <SD_Get_CardStat+0x190>
    {
		acoral_print("CARD_IS_LOCKED!\n");
30042a60:	e59f01b0 	ldr	r0, [pc, #432]	; 30042c18 <SD_Get_CardStat+0x33c>
30042a64:	ebff21f5 	bl	3000b240 <acoral_print>
30042a68:	ea00001f 	b	30042aec <SD_Get_CardStat+0x210>
	}
	else if (rSDIRSP0 & (cc << 24))
30042a6c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042a70:	e2833014 	add	r3, r3, #20
30042a74:	e5932000 	ldr	r2, [r3]
30042a78:	e59d300c 	ldr	r3, [sp, #12]
30042a7c:	e1a03c03 	lsl	r3, r3, #24
30042a80:	e0023003 	and	r3, r2, r3
30042a84:	e3530000 	cmp	r3, #0
30042a88:	0a000002 	beq	30042a98 <SD_Get_CardStat+0x1bc>
    {
		acoral_print("Error: LOCK_UNLOCK_FAILED!\n");
30042a8c:	e59f0188 	ldr	r0, [pc, #392]	; 30042c1c <SD_Get_CardStat+0x340>
30042a90:	ebff21ea 	bl	3000b240 <acoral_print>
30042a94:	ea000014 	b	30042aec <SD_Get_CardStat+0x210>
	}
	else if (rSDIRSP0 & (cc << 23))
30042a98:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042a9c:	e2833014 	add	r3, r3, #20
30042aa0:	e5932000 	ldr	r2, [r3]
30042aa4:	e59d300c 	ldr	r3, [sp, #12]
30042aa8:	e1a03b83 	lsl	r3, r3, #23
30042aac:	e0023003 	and	r3, r2, r3
30042ab0:	e3530000 	cmp	r3, #0
30042ab4:	0a000002 	beq	30042ac4 <SD_Get_CardStat+0x1e8>
    {
		acoral_print("Error: COM_CRC_ERROR!\n");
30042ab8:	e59f0160 	ldr	r0, [pc, #352]	; 30042c20 <SD_Get_CardStat+0x344>
30042abc:	ebff21df 	bl	3000b240 <acoral_print>
30042ac0:	ea000009 	b	30042aec <SD_Get_CardStat+0x210>
	}
	else if (rSDIRSP0 & (cc << 22))
30042ac4:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042ac8:	e2833014 	add	r3, r3, #20
30042acc:	e5932000 	ldr	r2, [r3]
30042ad0:	e59d300c 	ldr	r3, [sp, #12]
30042ad4:	e1a03b03 	lsl	r3, r3, #22
30042ad8:	e0023003 	and	r3, r2, r3
30042adc:	e3530000 	cmp	r3, #0
30042ae0:	0a000001 	beq	30042aec <SD_Get_CardStat+0x210>
    {
		acoral_print("Error: ILLEGAL_COMMAND!\n");
30042ae4:	e59f0138 	ldr	r0, [pc, #312]	; 30042c24 <SD_Get_CardStat+0x348>
30042ae8:	ebff21d4 	bl	3000b240 <acoral_print>
	}

    if(rSDIRSP0 & 0x100)
30042aec:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042af0:	e2833014 	add	r3, r3, #20
30042af4:	e5933000 	ldr	r3, [r3]
30042af8:	e2033c01 	and	r3, r3, #256	; 0x100
30042afc:	e3530000 	cmp	r3, #0
30042b00:	0a000001 	beq	30042b0c <SD_Get_CardStat+0x230>
    {
		acoral_print("Ready for Data,");
30042b04:	e59f011c 	ldr	r0, [pc, #284]	; 30042c28 <SD_Get_CardStat+0x34c>
30042b08:	ebff21cc 	bl	3000b240 <acoral_print>
	}

    response0 = rSDIRSP0;
30042b0c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042b10:	e2833014 	add	r3, r3, #20
30042b14:	e5933000 	ldr	r3, [r3]
30042b18:	e58d3008 	str	r3, [sp, #8]
    response0 &= 0x1e00;	//wangq
30042b1c:	e59d3008 	ldr	r3, [sp, #8]
30042b20:	e2033c1e 	and	r3, r3, #7680	; 0x1e00
30042b24:	e58d3008 	str	r3, [sp, #8]
    response0 = (response0 >> 9);
30042b28:	e59d3008 	ldr	r3, [sp, #8]
30042b2c:	e1a034c3 	asr	r3, r3, #9
30042b30:	e58d3008 	str	r3, [sp, #8]
    switch (response0)
30042b34:	e59d3008 	ldr	r3, [sp, #8]
30042b38:	e3530008 	cmp	r3, #8
30042b3c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
30042b40:	ea000023 	b	30042bd4 <SD_Get_CardStat+0x2f8>
30042b44:	30042b68 	.word	0x30042b68
30042b48:	30042b74 	.word	0x30042b74
30042b4c:	30042b80 	.word	0x30042b80
30042b50:	30042b8c 	.word	0x30042b8c
30042b54:	30042b98 	.word	0x30042b98
30042b58:	30042ba4 	.word	0x30042ba4
30042b5c:	30042bb0 	.word	0x30042bb0
30042b60:	30042bbc 	.word	0x30042bbc
30042b64:	30042bc8 	.word	0x30042bc8
    {
    	case 0:
    		acoral_print("Current Status = 'Idle'\n");
30042b68:	e59f00bc 	ldr	r0, [pc, #188]	; 30042c2c <SD_Get_CardStat+0x350>
30042b6c:	ebff21b3 	bl	3000b240 <acoral_print>
    		break;
30042b70:	ea000019 	b	30042bdc <SD_Get_CardStat+0x300>
    	case 1:
    		acoral_print("Current Status = 'Ready'\n");
30042b74:	e59f00b4 	ldr	r0, [pc, #180]	; 30042c30 <SD_Get_CardStat+0x354>
30042b78:	ebff21b0 	bl	3000b240 <acoral_print>
    		break;
30042b7c:	ea000016 	b	30042bdc <SD_Get_CardStat+0x300>
    	case 2:
    		acoral_print("Current Status = 'Ident'\n");
30042b80:	e59f00ac 	ldr	r0, [pc, #172]	; 30042c34 <SD_Get_CardStat+0x358>
30042b84:	ebff21ad 	bl	3000b240 <acoral_print>
    		break;
30042b88:	ea000013 	b	30042bdc <SD_Get_CardStat+0x300>
    	case 3:
    		acoral_print("Current Status = 'stby:Stand-by'\n");
30042b8c:	e59f00a4 	ldr	r0, [pc, #164]	; 30042c38 <SD_Get_CardStat+0x35c>
30042b90:	ebff21aa 	bl	3000b240 <acoral_print>
    		break;
30042b94:	ea000010 	b	30042bdc <SD_Get_CardStat+0x300>
    	case 4:
    		acoral_print("Current Status = 'tran:Transfer'\n");
30042b98:	e59f009c 	ldr	r0, [pc, #156]	; 30042c3c <SD_Get_CardStat+0x360>
30042b9c:	ebff21a7 	bl	3000b240 <acoral_print>
    		break;
30042ba0:	ea00000d 	b	30042bdc <SD_Get_CardStat+0x300>
    	case 5:
    		acoral_print("Current Status = 'data:Sending data'\n");
30042ba4:	e59f0094 	ldr	r0, [pc, #148]	; 30042c40 <SD_Get_CardStat+0x364>
30042ba8:	ebff21a4 	bl	3000b240 <acoral_print>
    		break;
30042bac:	ea00000a 	b	30042bdc <SD_Get_CardStat+0x300>
    	case 6:
    		acoral_print("Current Status = 'rcv:Receive data'\n");
30042bb0:	e59f008c 	ldr	r0, [pc, #140]	; 30042c44 <SD_Get_CardStat+0x368>
30042bb4:	ebff21a1 	bl	3000b240 <acoral_print>
    		break;
30042bb8:	ea000007 	b	30042bdc <SD_Get_CardStat+0x300>
    	case 7:
    		acoral_print("Current Status = 'prg:Programming'\n");
30042bbc:	e59f0084 	ldr	r0, [pc, #132]	; 30042c48 <SD_Get_CardStat+0x36c>
30042bc0:	ebff219e 	bl	3000b240 <acoral_print>
    		break;
30042bc4:	ea000004 	b	30042bdc <SD_Get_CardStat+0x300>
    	case 8:
    		acoral_print("Current Status = 'dis:Disconnect'\n");
30042bc8:	e59f007c 	ldr	r0, [pc, #124]	; 30042c4c <SD_Get_CardStat+0x370>
30042bcc:	ebff219b 	bl	3000b240 <acoral_print>
    		break;
30042bd0:	ea000001 	b	30042bdc <SD_Get_CardStat+0x300>
    	default:
    		acoral_print("Current Status = 'Reserved'\n");
30042bd4:	e59f0074 	ldr	r0, [pc, #116]	; 30042c50 <SD_Get_CardStat+0x374>
30042bd8:	ebff2198 	bl	3000b240 <acoral_print>
    		break;

    }

    rSDICSTA = 0xa00;	// Clear cmd_end(with rsp)
30042bdc:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042be0:	e2833010 	add	r3, r3, #16
30042be4:	e3a02c0a 	mov	r2, #2560	; 0xa00
30042be8:	e5832000 	str	r2, [r3]

    return response0;
30042bec:	e59d3008 	ldr	r3, [sp, #8]
}
30042bf0:	e1a00003 	mov	r0, r3
30042bf4:	e28dd014 	add	sp, sp, #20
30042bf8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30042bfc:	e12fff1e 	bx	lr
30042c00:	300463f0 	.word	0x300463f0
30042c04:	30046408 	.word	0x30046408
30042c08:	30046420 	.word	0x30046420
30042c0c:	3004643c 	.word	0x3004643c
30042c10:	3004645c 	.word	0x3004645c
30042c14:	30046480 	.word	0x30046480
30042c18:	3004649c 	.word	0x3004649c
30042c1c:	300464b0 	.word	0x300464b0
30042c20:	300464cc 	.word	0x300464cc
30042c24:	300464e4 	.word	0x300464e4
30042c28:	30046500 	.word	0x30046500
30042c2c:	30046510 	.word	0x30046510
30042c30:	3004652c 	.word	0x3004652c
30042c34:	30046548 	.word	0x30046548
30042c38:	30046564 	.word	0x30046564
30042c3c:	30046588 	.word	0x30046588
30042c40:	300465ac 	.word	0x300465ac
30042c44:	300465d4 	.word	0x300465d4
30042c48:	300465fc 	.word	0x300465fc
30042c4c:	30046620 	.word	0x30046620
30042c50:	30046644 	.word	0x30046644

30042c54 <sd_open>:


acoral_dev_ops_t sd_ops;
acoral_32 sd_open(){
30042c54:	e92d4008 	push	{r3, lr}
	return !SDI_Init();
30042c58:	ebfff8ab 	bl	30040f0c <SDI_Init>
30042c5c:	e1a03000 	mov	r3, r0
30042c60:	e3530000 	cmp	r3, #0
30042c64:	13a03000 	movne	r3, #0
30042c68:	03a03001 	moveq	r3, #1
}
30042c6c:	e1a00003 	mov	r0, r3
30042c70:	e8bd4008 	pop	{r3, lr}
30042c74:	e12fff1e 	bx	lr

30042c78 <Write_One_Block>:

#define SDCard_BlockSize	9

acoral_u8 Write_One_Block(acoral_u32 Addr,acoral_u32* TxBuffer)
{
30042c78:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30042c7c:	e24dd01c 	sub	sp, sp, #28
30042c80:	e58d0004 	str	r0, [sp, #4]
30042c84:	e58d1000 	str	r1, [sp]
	acoral_u16 i = 0;
30042c88:	e3a03000 	mov	r3, #0
30042c8c:	e1cd30be 	strh	r3, [sp, #14]
	acoral_u32 status = 0;
30042c90:	e3a03000 	mov	r3, #0
30042c94:	e58d3010 	str	r3, [sp, #16]
	acoral_u16 BlockSize;                             //瀹氫箟鍧楀ぇ灏?
	acoral_u16 BlockNumber;

	    BlockSize = 1<< SDCard_BlockSize;         //浠yte涓哄崟浣?
30042c98:	e3a03c02 	mov	r3, #512	; 0x200
30042c9c:	e1cd31b4 	strh	r3, [sp, #20]
	    BlockNumber = ((Addr >>  SDCard_BlockSize) +1) &0x0fff;
30042ca0:	e59d3004 	ldr	r3, [sp, #4]
30042ca4:	e1a034a3 	lsr	r3, r3, #9
30042ca8:	e1a03803 	lsl	r3, r3, #16
30042cac:	e1a03823 	lsr	r3, r3, #16
30042cb0:	e2833001 	add	r3, r3, #1
30042cb4:	e1a03803 	lsl	r3, r3, #16
30042cb8:	e1a03823 	lsr	r3, r3, #16
30042cbc:	e1a03a03 	lsl	r3, r3, #20
30042cc0:	e1a03a23 	lsr	r3, r3, #20
30042cc4:	e1cd31b6 	strh	r3, [sp, #22]

	    rSDIDTIMER=0x7fffff;                    // Set timeout count
30042cc8:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042ccc:	e2833024 	add	r3, r3, #36	; 0x24
30042cd0:	e3a02502 	mov	r2, #8388608	; 0x800000
30042cd4:	e2422001 	sub	r2, r2, #1
30042cd8:	e5832000 	str	r2, [r3]
	    rSDIBSIZE=0x200;                        // 512 byte(128 word)
30042cdc:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042ce0:	e2833028 	add	r3, r3, #40	; 0x28
30042ce4:	e3a02c02 	mov	r2, #512	; 0x200
30042ce8:	e5832000 	str	r2, [r3]
	    rSDIFSTA = rSDIFSTA|(1<<16);             // FIFO reset
30042cec:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042cf0:	e2833038 	add	r3, r3, #56	; 0x38
30042cf4:	e3a0245a 	mov	r2, #1509949440	; 0x5a000000
30042cf8:	e2822038 	add	r2, r2, #56	; 0x38
30042cfc:	e5922000 	ldr	r2, [r2]
30042d00:	e3822801 	orr	r2, r2, #65536	; 0x10000
30042d04:	e5832000 	str	r2, [r3]
	    rSDIDCON = BlockNumber|(3<<12)|(1<<14)|(1<<16)|(1<<17)|(1<<20)|(0<<22);
30042d08:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042d0c:	e283302c 	add	r3, r3, #44	; 0x2c
30042d10:	e1dd21b6 	ldrh	r2, [sp, #22]
30042d14:	e3822a07 	orr	r2, r2, #28672	; 0x7000
30042d18:	e1a02802 	lsl	r2, r2, #16
30042d1c:	e1a02822 	lsr	r2, r2, #16
30042d20:	e3822813 	orr	r2, r2, #1245184	; 0x130000
30042d24:	e5832000 	str	r2, [r3]

	    rSDICARG = Addr;
30042d28:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042d2c:	e2833008 	add	r3, r3, #8
30042d30:	e59d2004 	ldr	r2, [sp, #4]
30042d34:	e5832000 	str	r2, [r3]
	    do{
	    	rSDICCON = (0x1<<9)|(0x1<<8)|0x58;	//sht_resp, wait_resp, dat, start, CMD24
30042d38:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042d3c:	e283300c 	add	r3, r3, #12
30042d40:	e3a02fd6 	mov	r2, #856	; 0x358
30042d44:	e5832000 	str	r2, [r3]
	         i++;
30042d48:	e1dd30be 	ldrh	r3, [sp, #14]
30042d4c:	e2833001 	add	r3, r3, #1
30042d50:	e1cd30be 	strh	r3, [sp, #14]
	     }while(!Chk_CMDend(24, 1) && (i < 50));				//-- Check end of CMD24
30042d54:	e3a00018 	mov	r0, #24
30042d58:	e3a01001 	mov	r1, #1
30042d5c:	ebfffa2b 	bl	30041610 <Chk_CMDend>
30042d60:	e1a03000 	mov	r3, r0
30042d64:	e3530000 	cmp	r3, #0
30042d68:	1a000016 	bne	30042dc8 <Write_One_Block+0x150>
30042d6c:	e1dd30be 	ldrh	r3, [sp, #14]
30042d70:	e3530031 	cmp	r3, #49	; 0x31
30042d74:	9affffef 	bls	30042d38 <Write_One_Block+0xc0>

	    /* 寮€濮嬩紶閫掓暟鎹埌缂撳啿鍖?*/
	    while(i < BlockSize)
30042d78:	ea000012 	b	30042dc8 <Write_One_Block+0x150>
	    {

	        status=rSDIFSTA;
30042d7c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042d80:	e2833038 	add	r3, r3, #56	; 0x38
30042d84:	e5933000 	ldr	r3, [r3]
30042d88:	e58d3010 	str	r3, [sp, #16]
	        if((status&0x2000)==0x2000)            //濡傛灉鍙戦€丗IFO鍙敤锛屽嵆FIFO鏈弧
30042d8c:	e59d3010 	ldr	r3, [sp, #16]
30042d90:	e2033a02 	and	r3, r3, #8192	; 0x2000
30042d94:	e3530000 	cmp	r3, #0
30042d98:	0a00000a 	beq	30042dc8 <Write_One_Block+0x150>
	        {
	            rSDIDAT = *TxBuffer;
30042d9c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042da0:	e2833040 	add	r3, r3, #64	; 0x40
30042da4:	e59d2000 	ldr	r2, [sp]
30042da8:	e5922000 	ldr	r2, [r2]
30042dac:	e5832000 	str	r2, [r3]
	            TxBuffer++;
30042db0:	e59d3000 	ldr	r3, [sp]
30042db4:	e2833004 	add	r3, r3, #4
30042db8:	e58d3000 	str	r3, [sp]
	            i++;
30042dbc:	e1dd30be 	ldrh	r3, [sp, #14]
30042dc0:	e2833001 	add	r3, r3, #1
30042dc4:	e1cd30be 	strh	r3, [sp, #14]
	    	rSDICCON = (0x1<<9)|(0x1<<8)|0x58;	//sht_resp, wait_resp, dat, start, CMD24
	         i++;
	     }while(!Chk_CMDend(24, 1) && (i < 50));				//-- Check end of CMD24

	    /* 寮€濮嬩紶閫掓暟鎹埌缂撳啿鍖?*/
	    while(i < BlockSize)
30042dc8:	e1dd20be 	ldrh	r2, [sp, #14]
30042dcc:	e1dd31b4 	ldrh	r3, [sp, #20]
30042dd0:	e1520003 	cmp	r2, r3
30042dd4:	3affffe8 	bcc	30042d7c <Write_One_Block+0x104>
	            TxBuffer++;
	            i++;
	        }
	    }

	    status = rSDIDSTA;
30042dd8:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042ddc:	e2833034 	add	r3, r3, #52	; 0x34
30042de0:	e5933000 	ldr	r3, [r3]
30042de4:	e58d3010 	str	r3, [sp, #16]
	    Delay(1);
30042de8:	e3a00001 	mov	r0, #1
30042dec:	ebfff859 	bl	30040f58 <Delay>
	    rSDIDCON=rSDIDCON&~(7<<12);                //缁撴潫SDMMC妯″潡鐨勫彂閫?
30042df0:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042df4:	e283302c 	add	r3, r3, #44	; 0x2c
30042df8:	e3a0245a 	mov	r2, #1509949440	; 0x5a000000
30042dfc:	e282202c 	add	r2, r2, #44	; 0x2c
30042e00:	e5922000 	ldr	r2, [r2]
30042e04:	e3c22a07 	bic	r2, r2, #28672	; 0x7000
30042e08:	e5832000 	str	r2, [r3]
	    rSDIDSTA = status;
30042e0c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042e10:	e2833034 	add	r3, r3, #52	; 0x34
30042e14:	e59d2010 	ldr	r2, [sp, #16]
30042e18:	e5832000 	str	r2, [r3]

	    /* 纭SD鍗¤繘鍏ヤ簡绌洪棽鐘舵€?-SDIO鎬荤嚎绌洪棽 */
	    rSDIDCON=(0<<18)|(1<<17)|(1<<16)|(1<<14)|(1<<12)|(BlockNumber<<0);
30042e1c:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042e20:	e283302c 	add	r3, r3, #44	; 0x2c
30042e24:	e1dd21b6 	ldrh	r2, [sp, #22]
30042e28:	e3822a35 	orr	r2, r2, #217088	; 0x35000
30042e2c:	e5832000 	str	r2, [r3]
	    rSDIDTIMER=0x7fffff;                    // Set timeout count
30042e30:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042e34:	e2833024 	add	r3, r3, #36	; 0x24
30042e38:	e3a02502 	mov	r2, #8388608	; 0x800000
30042e3c:	e2422001 	sub	r2, r2, #1
30042e40:	e5832000 	str	r2, [r3]
	    status = rSDIDSTA;
30042e44:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042e48:	e2833034 	add	r3, r3, #52	; 0x34
30042e4c:	e5933000 	ldr	r3, [r3]
30042e50:	e58d3010 	str	r3, [sp, #16]
	    while( !( ((status&0x08)==0x08) | ((status&0x20)==0x20)| ((status&0x800)==0x800) )){
30042e54:	ea000003 	b	30042e68 <Write_One_Block+0x1f0>
	        status=rSDIDSTA;
30042e58:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042e5c:	e2833034 	add	r3, r3, #52	; 0x34
30042e60:	e5933000 	ldr	r3, [r3]
30042e64:	e58d3010 	str	r3, [sp, #16]

	    /* 纭SD鍗¤繘鍏ヤ簡绌洪棽鐘舵€?-SDIO鎬荤嚎绌洪棽 */
	    rSDIDCON=(0<<18)|(1<<17)|(1<<16)|(1<<14)|(1<<12)|(BlockNumber<<0);
	    rSDIDTIMER=0x7fffff;                    // Set timeout count
	    status = rSDIDSTA;
	    while( !( ((status&0x08)==0x08) | ((status&0x20)==0x20)| ((status&0x800)==0x800) )){
30042e68:	e59d3010 	ldr	r3, [sp, #16]
30042e6c:	e2033008 	and	r3, r3, #8
30042e70:	e3530000 	cmp	r3, #0
30042e74:	03a03000 	moveq	r3, #0
30042e78:	13a03001 	movne	r3, #1
30042e7c:	e20320ff 	and	r2, r3, #255	; 0xff
30042e80:	e59d3010 	ldr	r3, [sp, #16]
30042e84:	e2033020 	and	r3, r3, #32
30042e88:	e3530000 	cmp	r3, #0
30042e8c:	03a03000 	moveq	r3, #0
30042e90:	13a03001 	movne	r3, #1
30042e94:	e20330ff 	and	r3, r3, #255	; 0xff
30042e98:	e1823003 	orr	r3, r2, r3
30042e9c:	e20330ff 	and	r3, r3, #255	; 0xff
30042ea0:	e1a02003 	mov	r2, r3
30042ea4:	e59d3010 	ldr	r3, [sp, #16]
30042ea8:	e2033b02 	and	r3, r3, #2048	; 0x800
30042eac:	e3530000 	cmp	r3, #0
30042eb0:	03a03000 	moveq	r3, #0
30042eb4:	13a03001 	movne	r3, #1
30042eb8:	e1823003 	orr	r3, r2, r3
30042ebc:	e3530000 	cmp	r3, #0
30042ec0:	0affffe4 	beq	30042e58 <Write_One_Block+0x1e0>
	        status=rSDIDSTA;
	    }

	    if( (status&0x20) == 0x20 ){
30042ec4:	e59d3010 	ldr	r3, [sp, #16]
30042ec8:	e2033020 	and	r3, r3, #32
30042ecc:	e3530000 	cmp	r3, #0
30042ed0:	0a000005 	beq	30042eec <Write_One_Block+0x274>
	        rSDIDSTA = status;
30042ed4:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042ed8:	e2833034 	add	r3, r3, #52	; 0x34
30042edc:	e59d2010 	ldr	r2, [sp, #16]
30042ee0:	e5832000 	str	r2, [r3]
	        return 0;
30042ee4:	e3a03000 	mov	r3, #0
30042ee8:	ea000004 	b	30042f00 <Write_One_Block+0x288>
	    }
	    rSDIDSTA = status;
30042eec:	e3a0345a 	mov	r3, #1509949440	; 0x5a000000
30042ef0:	e2833034 	add	r3, r3, #52	; 0x34
30042ef4:	e59d2010 	ldr	r2, [sp, #16]
30042ef8:	e5832000 	str	r2, [r3]
	      return 1;
30042efc:	e3a03001 	mov	r3, #1
}
30042f00:	e1a00003 	mov	r0, r3
30042f04:	e28dd01c 	add	sp, sp, #28
30042f08:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30042f0c:	e12fff1e 	bx	lr

30042f10 <sd_write_block>:



acoral_32 sd_write_block(void *data,acoral_size size,acoral_size offset,acoral_time tm_out){
30042f10:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30042f14:	e24ddf89 	sub	sp, sp, #548	; 0x224
30042f18:	e58d000c 	str	r0, [sp, #12]
30042f1c:	e58d1008 	str	r1, [sp, #8]
30042f20:	e58d2004 	str	r2, [sp, #4]
30042f24:	e58d3000 	str	r3, [sp]
	acoral_32 ret,sdblock_num;
	acoral_u8 *write_data;
	acoral_u8 tmp[512];
	acoral_u32 i;
	sdblock_num=size/512;
30042f28:	e59d3008 	ldr	r3, [sp, #8]
30042f2c:	e1a034a3 	lsr	r3, r3, #9
30042f30:	e58d3214 	str	r3, [sp, #532]	; 0x214
	write_data=(acoral_u8 *)data;
30042f34:	e59d300c 	ldr	r3, [sp, #12]
30042f38:	e58d3218 	str	r3, [sp, #536]	; 0x218
	for(;sdblock_num>0;sdblock_num--)
30042f3c:	ea00004c 	b	30043074 <sd_write_block+0x164>
	{
		for(i=0; i<512; ) {
30042f40:	e3a03000 	mov	r3, #0
30042f44:	e58d321c 	str	r3, [sp, #540]	; 0x21c
30042f48:	ea000034 	b	30043020 <sd_write_block+0x110>
					tmp[i+3] = write_data[i];
30042f4c:	e59d321c 	ldr	r3, [sp, #540]	; 0x21c
30042f50:	e2831003 	add	r1, r3, #3
30042f54:	e59d2218 	ldr	r2, [sp, #536]	; 0x218
30042f58:	e59d321c 	ldr	r3, [sp, #540]	; 0x21c
30042f5c:	e0823003 	add	r3, r2, r3
30042f60:	e5d32000 	ldrb	r2, [r3]
30042f64:	e3a034be 	mov	r3, #-1107296256	; 0xbe000000
30042f68:	e1a03ac3 	asr	r3, r3, #21
30042f6c:	e28d0e22 	add	r0, sp, #544	; 0x220
30042f70:	e0801001 	add	r1, r0, r1
30042f74:	e0813003 	add	r3, r1, r3
30042f78:	e5c32000 	strb	r2, [r3]
					tmp[i+2] = write_data[i+1];
30042f7c:	e59d321c 	ldr	r3, [sp, #540]	; 0x21c
30042f80:	e2831002 	add	r1, r3, #2
30042f84:	e59d321c 	ldr	r3, [sp, #540]	; 0x21c
30042f88:	e2832001 	add	r2, r3, #1
30042f8c:	e59d3218 	ldr	r3, [sp, #536]	; 0x218
30042f90:	e0823003 	add	r3, r2, r3
30042f94:	e5d32000 	ldrb	r2, [r3]
30042f98:	e3a034be 	mov	r3, #-1107296256	; 0xbe000000
30042f9c:	e1a03ac3 	asr	r3, r3, #21
30042fa0:	e28d0e22 	add	r0, sp, #544	; 0x220
30042fa4:	e0801001 	add	r1, r0, r1
30042fa8:	e0813003 	add	r3, r1, r3
30042fac:	e5c32000 	strb	r2, [r3]
					tmp[i+1] = write_data[i+2];
30042fb0:	e59d321c 	ldr	r3, [sp, #540]	; 0x21c
30042fb4:	e2831001 	add	r1, r3, #1
30042fb8:	e59d321c 	ldr	r3, [sp, #540]	; 0x21c
30042fbc:	e2832002 	add	r2, r3, #2
30042fc0:	e59d3218 	ldr	r3, [sp, #536]	; 0x218
30042fc4:	e0823003 	add	r3, r2, r3
30042fc8:	e5d32000 	ldrb	r2, [r3]
30042fcc:	e3a034be 	mov	r3, #-1107296256	; 0xbe000000
30042fd0:	e1a03ac3 	asr	r3, r3, #21
30042fd4:	e28d0e22 	add	r0, sp, #544	; 0x220
30042fd8:	e0801001 	add	r1, r0, r1
30042fdc:	e0813003 	add	r3, r1, r3
30042fe0:	e5c32000 	strb	r2, [r3]
					tmp[i] = write_data[i+3];
30042fe4:	e59d121c 	ldr	r1, [sp, #540]	; 0x21c
30042fe8:	e59d321c 	ldr	r3, [sp, #540]	; 0x21c
30042fec:	e2832003 	add	r2, r3, #3
30042ff0:	e59d3218 	ldr	r3, [sp, #536]	; 0x218
30042ff4:	e0823003 	add	r3, r2, r3
30042ff8:	e5d32000 	ldrb	r2, [r3]
30042ffc:	e3a034be 	mov	r3, #-1107296256	; 0xbe000000
30043000:	e1a03ac3 	asr	r3, r3, #21
30043004:	e28d0e22 	add	r0, sp, #544	; 0x220
30043008:	e0801001 	add	r1, r0, r1
3004300c:	e0813003 	add	r3, r1, r3
30043010:	e5c32000 	strb	r2, [r3]
					i += 4;
30043014:	e59d321c 	ldr	r3, [sp, #540]	; 0x21c
30043018:	e2833004 	add	r3, r3, #4
3004301c:	e58d321c 	str	r3, [sp, #540]	; 0x21c
	acoral_u32 i;
	sdblock_num=size/512;
	write_data=(acoral_u8 *)data;
	for(;sdblock_num>0;sdblock_num--)
	{
		for(i=0; i<512; ) {
30043020:	e59d221c 	ldr	r2, [sp, #540]	; 0x21c
30043024:	e3a03f7f 	mov	r3, #508	; 0x1fc
30043028:	e2833003 	add	r3, r3, #3
3004302c:	e1520003 	cmp	r2, r3
30043030:	9affffc5 	bls	30042f4c <sd_write_block+0x3c>
								}*/
		//Delay(200); //must have a delay time.... why?
		//acoral_print("writing...please wait~\n");
		//Erase_Block(offset/512+8192, offset/512+8192);
		//SD_Wt_Block(&CardInf, POL, offset/512+8192, (acoral_u32 *)tmp, 1);
		Write_One_Block(offset/512+8192,(acoral_u32 *)tmp);
30043034:	e59d3004 	ldr	r3, [sp, #4]
30043038:	e1a034a3 	lsr	r3, r3, #9
3004303c:	e2832a02 	add	r2, r3, #8192	; 0x2000
30043040:	e28d3010 	add	r3, sp, #16
30043044:	e1a00002 	mov	r0, r2
30043048:	e1a01003 	mov	r1, r3
3004304c:	ebffff09 	bl	30042c78 <Write_One_Block>
		//Wt_Block(offset,(acoral_acoral_u32 *)write_data,1);
		write_data=write_data+512;
30043050:	e59d3218 	ldr	r3, [sp, #536]	; 0x218
30043054:	e2833c02 	add	r3, r3, #512	; 0x200
30043058:	e58d3218 	str	r3, [sp, #536]	; 0x218
		offset+=512;
3004305c:	e59d3004 	ldr	r3, [sp, #4]
30043060:	e2833c02 	add	r3, r3, #512	; 0x200
30043064:	e58d3004 	str	r3, [sp, #4]
	acoral_u8 *write_data;
	acoral_u8 tmp[512];
	acoral_u32 i;
	sdblock_num=size/512;
	write_data=(acoral_u8 *)data;
	for(;sdblock_num>0;sdblock_num--)
30043068:	e59d3214 	ldr	r3, [sp, #532]	; 0x214
3004306c:	e2433001 	sub	r3, r3, #1
30043070:	e58d3214 	str	r3, [sp, #532]	; 0x214
30043074:	e59d3214 	ldr	r3, [sp, #532]	; 0x214
30043078:	e3530000 	cmp	r3, #0
3004307c:	caffffaf 	bgt	30042f40 <sd_write_block+0x30>
		//Wt_Block(offset,(acoral_acoral_u32 *)write_data,1);
		write_data=write_data+512;
		offset+=512;
		//Delay(1000);
	}
	return 0;
30043080:	e3a03000 	mov	r3, #0
}
30043084:	e1a00003 	mov	r0, r3
30043088:	e28ddf89 	add	sp, sp, #548	; 0x224
3004308c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30043090:	e12fff1e 	bx	lr

30043094 <sd_read_block>:

acoral_32 sd_read_block(void *data,acoral_size size,acoral_size offset,acoral_time tm_out){
30043094:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30043098:	e24dd034 	sub	sp, sp, #52	; 0x34
3004309c:	e58d0014 	str	r0, [sp, #20]
300430a0:	e58d1010 	str	r1, [sp, #16]
300430a4:	e58d200c 	str	r2, [sp, #12]
300430a8:	e58d3008 	str	r3, [sp, #8]
	acoral_32 ret,sdblock_num;
	acoral_u8 *write_data;
	sdblock_num=size/512;
300430ac:	e59d3010 	ldr	r3, [sp, #16]
300430b0:	e1a034a3 	lsr	r3, r3, #9
300430b4:	e58d3024 	str	r3, [sp, #36]	; 0x24
	write_data=(acoral_u8 *)data;
300430b8:	e59d3014 	ldr	r3, [sp, #20]
300430bc:	e58d3028 	str	r3, [sp, #40]	; 0x28
			else
			{
				acoral_print("\nRead 0 Block is Fail!\n");
			}*/
			acoral_u8 tmp[4];
	for(;sdblock_num>0;sdblock_num--)
300430c0:	ea00004a 	b	300431f0 <sd_read_block+0x15c>
	{
		//Rd_Block(offset,(acoral_acoral_u32 *)write_data,1);
		//Read_One_Block(offset/512+8192,(acoral_acoral_u32 *)write_data);
		SD_Rd_Block(&CardInf, POL, offset/512+8192, (acoral_u32 *)write_data, 1);
300430c4:	e59d300c 	ldr	r3, [sp, #12]
300430c8:	e1a034a3 	lsr	r3, r3, #9
300430cc:	e2832a02 	add	r2, r3, #8192	; 0x2000
300430d0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300430d4:	e3a01001 	mov	r1, #1
300430d8:	e58d1000 	str	r1, [sp]
300430dc:	e59f012c 	ldr	r0, [pc, #300]	; 30043210 <sd_read_block+0x17c>
300430e0:	e3a01000 	mov	r1, #0
300430e4:	ebfffc6e 	bl	300422a4 <SD_Rd_Block>
		for(i=0; i<512; ) {
300430e8:	e3a03000 	mov	r3, #0
300430ec:	e58d302c 	str	r3, [sp, #44]	; 0x2c
300430f0:	ea000030 	b	300431b8 <sd_read_block+0x124>
			tmp[0] = write_data[i];
300430f4:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
300430f8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300430fc:	e0823003 	add	r3, r2, r3
30043100:	e5d33000 	ldrb	r3, [r3]
30043104:	e5cd301c 	strb	r3, [sp, #28]
			tmp[1] = write_data[i+1];
30043108:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3004310c:	e2832001 	add	r2, r3, #1
30043110:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30043114:	e0823003 	add	r3, r2, r3
30043118:	e5d33000 	ldrb	r3, [r3]
3004311c:	e5cd301d 	strb	r3, [sp, #29]
			tmp[2] = write_data[i+2];
30043120:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30043124:	e2832002 	add	r2, r3, #2
30043128:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3004312c:	e0823003 	add	r3, r2, r3
30043130:	e5d33000 	ldrb	r3, [r3]
30043134:	e5cd301e 	strb	r3, [sp, #30]
			tmp[3] = write_data[i+3];
30043138:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
3004313c:	e2832003 	add	r2, r3, #3
30043140:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30043144:	e0823003 	add	r3, r2, r3
30043148:	e5d33000 	ldrb	r3, [r3]
3004314c:	e5cd301f 	strb	r3, [sp, #31]

			write_data[i] = tmp[3];
30043150:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
30043154:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30043158:	e0823003 	add	r3, r2, r3
3004315c:	e5dd201f 	ldrb	r2, [sp, #31]
30043160:	e5c32000 	strb	r2, [r3]
			write_data[i+1] = tmp[2];
30043164:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30043168:	e2832001 	add	r2, r3, #1
3004316c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30043170:	e0823003 	add	r3, r2, r3
30043174:	e5dd201e 	ldrb	r2, [sp, #30]
30043178:	e5c32000 	strb	r2, [r3]
			write_data[i+2] = tmp[1];
3004317c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30043180:	e2832002 	add	r2, r3, #2
30043184:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
30043188:	e0823003 	add	r3, r2, r3
3004318c:	e5dd201d 	ldrb	r2, [sp, #29]
30043190:	e5c32000 	strb	r2, [r3]
			write_data[i+3] = tmp[0];
30043194:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
30043198:	e2832003 	add	r2, r3, #3
3004319c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300431a0:	e0823003 	add	r3, r2, r3
300431a4:	e5dd201c 	ldrb	r2, [sp, #28]
300431a8:	e5c32000 	strb	r2, [r3]

			i += 4;
300431ac:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
300431b0:	e2833004 	add	r3, r3, #4
300431b4:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	for(;sdblock_num>0;sdblock_num--)
	{
		//Rd_Block(offset,(acoral_acoral_u32 *)write_data,1);
		//Read_One_Block(offset/512+8192,(acoral_acoral_u32 *)write_data);
		SD_Rd_Block(&CardInf, POL, offset/512+8192, (acoral_u32 *)write_data, 1);
		for(i=0; i<512; ) {
300431b8:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
300431bc:	e3a03f7f 	mov	r3, #508	; 0x1fc
300431c0:	e2833003 	add	r3, r3, #3
300431c4:	e1520003 	cmp	r2, r3
300431c8:	9affffc9 	bls	300430f4 <sd_read_block+0x60>
							i += 4;
							if(i%16==0)
								acoral_print("\n");
						}*/

		write_data=write_data+512;
300431cc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
300431d0:	e2833c02 	add	r3, r3, #512	; 0x200
300431d4:	e58d3028 	str	r3, [sp, #40]	; 0x28
		offset+=512;
300431d8:	e59d300c 	ldr	r3, [sp, #12]
300431dc:	e2833c02 	add	r3, r3, #512	; 0x200
300431e0:	e58d300c 	str	r3, [sp, #12]
			else
			{
				acoral_print("\nRead 0 Block is Fail!\n");
			}*/
			acoral_u8 tmp[4];
	for(;sdblock_num>0;sdblock_num--)
300431e4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300431e8:	e2433001 	sub	r3, r3, #1
300431ec:	e58d3024 	str	r3, [sp, #36]	; 0x24
300431f0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
300431f4:	e3530000 	cmp	r3, #0
300431f8:	caffffb1 	bgt	300430c4 <sd_read_block+0x30>
						}*/

		write_data=write_data+512;
		offset+=512;
	}
	return 0;
300431fc:	e3a03000 	mov	r3, #0
}
30043200:	e1a00003 	mov	r0, r3
30043204:	e28dd034 	add	sp, sp, #52	; 0x34
30043208:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3004320c:	e12fff1e 	bx	lr
30043210:	3012d6e8 	.word	0x3012d6e8

30043214 <sd_init>:

void sd_init(){
30043214:	e92d4008 	push	{r3, lr}
	sd_ops.write=sd_write_block;
30043218:	e59f303c 	ldr	r3, [pc, #60]	; 3004325c <sd_init+0x48>
3004321c:	e59f203c 	ldr	r2, [pc, #60]	; 30043260 <sd_init+0x4c>
30043220:	e5832008 	str	r2, [r3, #8]
	sd_ops.read=sd_read_block;
30043224:	e59f3030 	ldr	r3, [pc, #48]	; 3004325c <sd_init+0x48>
30043228:	e59f2034 	ldr	r2, [pc, #52]	; 30043264 <sd_init+0x50>
3004322c:	e5832004 	str	r2, [r3, #4]
	sd_ops.open=sd_open;
30043230:	e59f2030 	ldr	r2, [pc, #48]	; 30043268 <sd_init+0x54>
30043234:	e59f3020 	ldr	r3, [pc, #32]	; 3004325c <sd_init+0x48>
30043238:	e5832000 	str	r2, [r3]
	sd_ops.close=NULL;
3004323c:	e59f3018 	ldr	r3, [pc, #24]	; 3004325c <sd_init+0x48>
30043240:	e3a02000 	mov	r2, #0
30043244:	e5832010 	str	r2, [r3, #16]
  	acoral_drv_register(&sd_ops,"disk");
30043248:	e59f000c 	ldr	r0, [pc, #12]	; 3004325c <sd_init+0x48>
3004324c:	e59f1018 	ldr	r1, [pc, #24]	; 3004326c <sd_init+0x58>
30043250:	ebfff48b 	bl	30040484 <acoral_drv_register>
}
30043254:	e8bd4008 	pop	{r3, lr}
30043258:	e12fff1e 	bx	lr
3004325c:	302bf830 	.word	0x302bf830
30043260:	30042f10 	.word	0x30042f10
30043264:	30043094 	.word	0x30043094
30043268:	30042c54 	.word	0x30042c54
3004326c:	30046664 	.word	0x30046664

30043270 <udelay>:
/*===========================
 *
 *  时延函数
 */
void udelay(u32_t t)
{
30043270:	e24dd010 	sub	sp, sp, #16
30043274:	e58d0004 	str	r0, [sp, #4]
   u32_t i;
   for(;t>0;t--)
30043278:	ea00000b 	b	300432ac <udelay+0x3c>
   {
     for(i=0;i<100;i++){}
3004327c:	e3a03000 	mov	r3, #0
30043280:	e58d300c 	str	r3, [sp, #12]
30043284:	ea000002 	b	30043294 <udelay+0x24>
30043288:	e59d300c 	ldr	r3, [sp, #12]
3004328c:	e2833001 	add	r3, r3, #1
30043290:	e58d300c 	str	r3, [sp, #12]
30043294:	e59d300c 	ldr	r3, [sp, #12]
30043298:	e3530063 	cmp	r3, #99	; 0x63
3004329c:	9afffff9 	bls	30043288 <udelay+0x18>
 *  时延函数
 */
void udelay(u32_t t)
{
   u32_t i;
   for(;t>0;t--)
300432a0:	e59d3004 	ldr	r3, [sp, #4]
300432a4:	e2433001 	sub	r3, r3, #1
300432a8:	e58d3004 	str	r3, [sp, #4]
300432ac:	e59d3004 	ldr	r3, [sp, #4]
300432b0:	e3530000 	cmp	r3, #0
300432b4:	1afffff0 	bne	3004327c <udelay+0xc>
   {
     for(i=0;i<100;i++){}
   }
}
300432b8:	e28dd010 	add	sp, sp, #16
300432bc:	e12fff1e 	bx	lr

300432c0 <Eint7_ISR>:
/*===========================
 *
 *   中断处理函数
 */
void Eint7_ISR(acoral_vector vector)
{
300432c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300432c4:	e24dd00c 	sub	sp, sp, #12
300432c8:	e58d0004 	str	r0, [sp, #4]
	
	rEINTMSK |=(1<<vector);
300432cc:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300432d0:	e28330a4 	add	r3, r3, #164	; 0xa4
300432d4:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300432d8:	e28220a4 	add	r2, r2, #164	; 0xa4
300432dc:	e5921000 	ldr	r1, [r2]
300432e0:	e3a00001 	mov	r0, #1
300432e4:	e59d2004 	ldr	r2, [sp, #4]
300432e8:	e1a02210 	lsl	r2, r0, r2
300432ec:	e1812002 	orr	r2, r1, r2
300432f0:	e5832000 	str	r2, [r3]
	
	//ethernetif_input(&dm9000);
	acoral_sem_post(&dm9k_recv_sem);
300432f4:	e59f0050 	ldr	r0, [pc, #80]	; 3004334c <Eint7_ISR+0x8c>
300432f8:	ebff115b 	bl	3000786c <acoral_sem_post>
		Printf("%x ",Buffer[i]);
		if((i%5)==4) Printf("\r\n");
	}
*/
    
	rEINTPND |= 0x1<<7;
300432fc:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30043300:	e28330a8 	add	r3, r3, #168	; 0xa8
30043304:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30043308:	e28220a8 	add	r2, r2, #168	; 0xa8
3004330c:	e5922000 	ldr	r2, [r2]
30043310:	e3822080 	orr	r2, r2, #128	; 0x80
30043314:	e5832000 	str	r2, [r3]
	ClearPending(0x1<<4);
30043318:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
3004331c:	e3a02010 	mov	r2, #16
30043320:	e5832000 	str	r2, [r3]
30043324:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30043328:	e2833010 	add	r3, r3, #16
3004332c:	e3a02010 	mov	r2, #16
30043330:	e5832000 	str	r2, [r3]
30043334:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
30043338:	e2833010 	add	r3, r3, #16
3004333c:	e5933000 	ldr	r3, [r3]
	

}
30043340:	e28dd00c 	add	sp, sp, #12
30043344:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30043348:	e12fff1e 	bx	lr
3004334c:	300ea2f4 	.word	0x300ea2f4

30043350 <IOSetInit>:
/*==========================
 *
 * s3c2440 中断相关寄存器初始化
 */
void IOSetInit(void)
{
30043350:	e92d4008 	push	{r3, lr}
	acoral_intr_set_type(IRQ_EINT7,ACORAL_EXPERT_INTR);
30043354:	e3a00007 	mov	r0, #7
30043358:	e3a01002 	mov	r1, #2
3004335c:	ebff0409 	bl	30004388 <acoral_intr_set_type>
	acoral_intr_attach(IRQ_EINT7,Eint7_ISR);
30043360:	e3a00007 	mov	r0, #7
30043364:	e59f10a8 	ldr	r1, [pc, #168]	; 30043414 <IOSetInit+0xc4>
30043368:	ebff0285 	bl	30003d84 <acoral_intr_attach>
	
	rGPFCON  = (rGPFCON & (~(0x03<<14))) | (0x02<<14);	       
3004336c:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30043370:	e2833050 	add	r3, r3, #80	; 0x50
30043374:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30043378:	e2822050 	add	r2, r2, #80	; 0x50
3004337c:	e5922000 	ldr	r2, [r2]
30043380:	e3c22903 	bic	r2, r2, #49152	; 0xc000
30043384:	e3822902 	orr	r2, r2, #32768	; 0x8000
30043388:	e5832000 	str	r2, [r3]
	rEXTINT0 = (rEXTINT0 & (~(0x07<<28))) | (0x01<<28);
3004338c:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30043390:	e2833088 	add	r3, r3, #136	; 0x88
30043394:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30043398:	e2822088 	add	r2, r2, #136	; 0x88
3004339c:	e5922000 	ldr	r2, [r2]
300433a0:	e3c22207 	bic	r2, r2, #1879048192	; 0x70000000
300433a4:	e3822201 	orr	r2, r2, #268435456	; 0x10000000
300433a8:	e5832000 	str	r2, [r3]
	rEINTMSK = rEINTMSK & (~(0x01<<7));         
300433ac:	e3a03456 	mov	r3, #1442840576	; 0x56000000
300433b0:	e28330a4 	add	r3, r3, #164	; 0xa4
300433b4:	e3a02456 	mov	r2, #1442840576	; 0x56000000
300433b8:	e28220a4 	add	r2, r2, #164	; 0xa4
300433bc:	e5922000 	ldr	r2, [r2]
300433c0:	e3c22080 	bic	r2, r2, #128	; 0x80
300433c4:	e5832000 	str	r2, [r3]
	
	ClearPending((0x1<<4));
300433c8:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
300433cc:	e3a02010 	mov	r2, #16
300433d0:	e5832000 	str	r2, [r3]
300433d4:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
300433d8:	e2833010 	add	r3, r3, #16
300433dc:	e3a02010 	mov	r2, #16
300433e0:	e5832000 	str	r2, [r3]
300433e4:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
300433e8:	e2833010 	add	r3, r3, #16
300433ec:	e5933000 	ldr	r3, [r3]
	rINTMSK  = rINTMSK & (~(0x1<<4));
300433f0:	e3a0344a 	mov	r3, #1241513984	; 0x4a000000
300433f4:	e2833008 	add	r3, r3, #8
300433f8:	e3a0244a 	mov	r2, #1241513984	; 0x4a000000
300433fc:	e2822008 	add	r2, r2, #8
30043400:	e5922000 	ldr	r2, [r2]
30043404:	e3c22010 	bic	r2, r2, #16
30043408:	e5832000 	str	r2, [r3]
}
3004340c:	e8bd4008 	pop	{r3, lr}
30043410:	e12fff1e 	bx	lr
30043414:	300432c0 	.word	0x300432c0

30043418 <dm9000_reg_write>:
/*======================
 *
 *  寄存器写数据
 */
void dm9000_reg_write(u16_t reg, u16_t data)
{  
30043418:	e24dd008 	sub	sp, sp, #8
3004341c:	e1a02000 	mov	r2, r0
30043420:	e1a03001 	mov	r3, r1
30043424:	e1cd20b6 	strh	r2, [sp, #6]
30043428:	e1cd30b4 	strh	r3, [sp, #4]
//	udelay(20);
	DM_ADD = reg;
3004342c:	e3a03202 	mov	r3, #536870912	; 0x20000000
30043430:	e2833c03 	add	r3, r3, #768	; 0x300
30043434:	e1dd20b6 	ldrh	r2, [sp, #6]
30043438:	e1c320b0 	strh	r2, [r3]
//	udelay(20);
	DM_CMD = data;
3004343c:	e3a03202 	mov	r3, #536870912	; 0x20000000
30043440:	e2833fc1 	add	r3, r3, #772	; 0x304
30043444:	e1dd20b4 	ldrh	r2, [sp, #4]
30043448:	e1c320b0 	strh	r2, [r3]
	
}
3004344c:	e28dd008 	add	sp, sp, #8
30043450:	e12fff1e 	bx	lr

30043454 <dm9000_reg_read>:
/*======================
 *
 *  寄存器读数据 8bit
 */
u8_t dm9000_reg_read(u16_t reg)
{
30043454:	e24dd008 	sub	sp, sp, #8
30043458:	e1a03000 	mov	r3, r0
3004345c:	e1cd30b6 	strh	r3, [sp, #6]
  //  udelay(20);
    DM_ADD = reg;
30043460:	e3a03202 	mov	r3, #536870912	; 0x20000000
30043464:	e2833c03 	add	r3, r3, #768	; 0x300
30043468:	e1dd20b6 	ldrh	r2, [sp, #6]
3004346c:	e1c320b0 	strh	r2, [r3]
  //  udelay(20);
    return DM_CMD;
30043470:	e3a03202 	mov	r3, #536870912	; 0x20000000
30043474:	e2833fc1 	add	r3, r3, #772	; 0x304
30043478:	e1d330b0 	ldrh	r3, [r3]
3004347c:	e1a03803 	lsl	r3, r3, #16
30043480:	e1a03823 	lsr	r3, r3, #16
30043484:	e20330ff 	and	r3, r3, #255	; 0xff
}
30043488:	e1a00003 	mov	r0, r3
3004348c:	e28dd008 	add	sp, sp, #8
30043490:	e12fff1e 	bx	lr

30043494 <dm9000_reg_read16>:
/*=====================
 *
 *  寄存器读数据 16bit
 */
u16_t dm9000_reg_read16(u16_t reg)
{
30043494:	e24dd008 	sub	sp, sp, #8
30043498:	e1a03000 	mov	r3, r0
3004349c:	e1cd30b6 	strh	r3, [sp, #6]
  //  udelay(20);
    DM_ADD = reg;
300434a0:	e3a03202 	mov	r3, #536870912	; 0x20000000
300434a4:	e2833c03 	add	r3, r3, #768	; 0x300
300434a8:	e1dd20b6 	ldrh	r2, [sp, #6]
300434ac:	e1c320b0 	strh	r2, [r3]
  //  udelay(20);
    return DM_CMD;
300434b0:	e3a03202 	mov	r3, #536870912	; 0x20000000
300434b4:	e2833fc1 	add	r3, r3, #772	; 0x304
300434b8:	e1d330b0 	ldrh	r3, [r3]
300434bc:	e1a03803 	lsl	r3, r3, #16
300434c0:	e1a03823 	lsr	r3, r3, #16
}
300434c4:	e1a00003 	mov	r0, r3
300434c8:	e28dd008 	add	sp, sp, #8
300434cc:	e12fff1e 	bx	lr

300434d0 <hw_init>:
/*================================
 *
 *  dm9000 网卡初始化
 */
void hw_init(u8_t * mac_addr)
{
300434d0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300434d4:	e24dd014 	sub	sp, sp, #20
300434d8:	e58d0004 	str	r0, [sp, #4]
	u32_t i;
	IOSetInit();  
300434dc:	ebffff9b 	bl	30043350 <IOSetInit>
	
	dm9000_reg_write(DM9000_GPCR, 0x01);
300434e0:	e3a0001e 	mov	r0, #30
300434e4:	e3a01001 	mov	r1, #1
300434e8:	ebffffca 	bl	30043418 <dm9000_reg_write>
	dm9000_reg_write(DM9000_GPR,  0x00);
300434ec:	e3a0001f 	mov	r0, #31
300434f0:	e3a01000 	mov	r1, #0
300434f4:	ebffffc7 	bl	30043418 <dm9000_reg_write>
	udelay(5000);					
300434f8:	e3a00d4e 	mov	r0, #4992	; 0x1380
300434fc:	e2800008 	add	r0, r0, #8
30043500:	ebffff5a 	bl	30043270 <udelay>
	
	dm9000_reg_write(DM9000_NCR,  0x03);
30043504:	e3a00000 	mov	r0, #0
30043508:	e3a01003 	mov	r1, #3
3004350c:	ebffffc1 	bl	30043418 <dm9000_reg_write>
	udelay(3000);			
30043510:	e3a00ebb 	mov	r0, #2992	; 0xbb0
30043514:	e2800008 	add	r0, r0, #8
30043518:	ebffff54 	bl	30043270 <udelay>
	dm9000_reg_write(DM9000_NCR,  0x00);
3004351c:	e3a00000 	mov	r0, #0
30043520:	e3a01000 	mov	r1, #0
30043524:	ebffffbb 	bl	30043418 <dm9000_reg_write>
	dm9000_reg_write(DM9000_NCR,  0x03);
30043528:	e3a00000 	mov	r0, #0
3004352c:	e3a01003 	mov	r1, #3
30043530:	ebffffb8 	bl	30043418 <dm9000_reg_write>
	udelay(3000);
30043534:	e3a00ebb 	mov	r0, #2992	; 0xbb0
30043538:	e2800008 	add	r0, r0, #8
3004353c:	ebffff4b 	bl	30043270 <udelay>
	dm9000_reg_write(DM9000_NCR,  0x00);
30043540:	e3a00000 	mov	r0, #0
30043544:	e3a01000 	mov	r1, #0
30043548:	ebffffb2 	bl	30043418 <dm9000_reg_write>
	
	
	dm9000_reg_write(DM9000_NSR,  0x2c);
3004354c:	e3a00001 	mov	r0, #1
30043550:	e3a0102c 	mov	r1, #44	; 0x2c
30043554:	ebffffaf 	bl	30043418 <dm9000_reg_write>
	dm9000_reg_write(DM9000_ISR,  0xbf);
30043558:	e3a000fe 	mov	r0, #254	; 0xfe
3004355c:	e3a010bf 	mov	r1, #191	; 0xbf
30043560:	ebffffac 	bl	30043418 <dm9000_reg_write>
	
    dm9000_reg_write(DM9000_RCR,  0x39);
30043564:	e3a00005 	mov	r0, #5
30043568:	e3a01039 	mov	r1, #57	; 0x39
3004356c:	ebffffa9 	bl	30043418 <dm9000_reg_write>
    dm9000_reg_write(DM9000_TCR,  0x00);
30043570:	e3a00002 	mov	r0, #2
30043574:	e3a01000 	mov	r1, #0
30043578:	ebffffa6 	bl	30043418 <dm9000_reg_write>
    dm9000_reg_write(DM9000_BPTR, 0x3f);
3004357c:	e3a00008 	mov	r0, #8
30043580:	e3a0103f 	mov	r1, #63	; 0x3f
30043584:	ebffffa3 	bl	30043418 <dm9000_reg_write>
    dm9000_reg_write(DM9000_FCTR, 0x38);
30043588:	e3a00009 	mov	r0, #9
3004358c:	e3a01038 	mov	r1, #56	; 0x38
30043590:	ebffffa0 	bl	30043418 <dm9000_reg_write>
    dm9000_reg_write(DM9000_FCR,  0xff);
30043594:	e3a0000a 	mov	r0, #10
30043598:	e3a010ff 	mov	r1, #255	; 0xff
3004359c:	ebffff9d 	bl	30043418 <dm9000_reg_write>
    dm9000_reg_write(DM9000_SMCR, 0x00);	
300435a0:	e3a0002f 	mov	r0, #47	; 0x2f
300435a4:	e3a01000 	mov	r1, #0
300435a8:	ebffff9a 	bl	30043418 <dm9000_reg_write>
    
	for(i=0; i<6; i++)
300435ac:	e3a03000 	mov	r3, #0
300435b0:	e58d300c 	str	r3, [sp, #12]
300435b4:	ea00000f 	b	300435f8 <hw_init+0x128>
		dm9000_reg_write(DM9000_PAR + i, mac_addr[i]);
300435b8:	e59d300c 	ldr	r3, [sp, #12]
300435bc:	e1a03803 	lsl	r3, r3, #16
300435c0:	e1a03823 	lsr	r3, r3, #16
300435c4:	e2833010 	add	r3, r3, #16
300435c8:	e1a03803 	lsl	r3, r3, #16
300435cc:	e1a02823 	lsr	r2, r3, #16
300435d0:	e59d1004 	ldr	r1, [sp, #4]
300435d4:	e59d300c 	ldr	r3, [sp, #12]
300435d8:	e0813003 	add	r3, r1, r3
300435dc:	e5d33000 	ldrb	r3, [r3]
300435e0:	e1a00002 	mov	r0, r2
300435e4:	e1a01003 	mov	r1, r3
300435e8:	ebffff8a 	bl	30043418 <dm9000_reg_write>
    dm9000_reg_write(DM9000_BPTR, 0x3f);
    dm9000_reg_write(DM9000_FCTR, 0x38);
    dm9000_reg_write(DM9000_FCR,  0xff);
    dm9000_reg_write(DM9000_SMCR, 0x00);	
    
	for(i=0; i<6; i++)
300435ec:	e59d300c 	ldr	r3, [sp, #12]
300435f0:	e2833001 	add	r3, r3, #1
300435f4:	e58d300c 	str	r3, [sp, #12]
300435f8:	e59d300c 	ldr	r3, [sp, #12]
300435fc:	e3530005 	cmp	r3, #5
30043600:	9affffec 	bls	300435b8 <hw_init+0xe8>
		dm9000_reg_write(DM9000_PAR + i, mac_addr[i]);
	
	dm9000_reg_write(DM9000_NSR,  0x2c);
30043604:	e3a00001 	mov	r0, #1
30043608:	e3a0102c 	mov	r1, #44	; 0x2c
3004360c:	ebffff81 	bl	30043418 <dm9000_reg_write>
	dm9000_reg_write(DM9000_ISR,  0x3f);
30043610:	e3a000fe 	mov	r0, #254	; 0xfe
30043614:	e3a0103f 	mov	r1, #63	; 0x3f
30043618:	ebffff7e 	bl	30043418 <dm9000_reg_write>
	dm9000_reg_write(DM9000_IMR, 0x81);
3004361c:	e3a000ff 	mov	r0, #255	; 0xff
30043620:	e3a01081 	mov	r1, #129	; 0x81
30043624:	ebffff7b 	bl	30043418 <dm9000_reg_write>
	udelay(10000);
30043628:	e3a00c27 	mov	r0, #9984	; 0x2700
3004362c:	e2800010 	add	r0, r0, #16
30043630:	ebffff0e 	bl	30043270 <udelay>
	acoral_prints("\r\nDM9000 init");
30043634:	e59f000c 	ldr	r0, [pc, #12]	; 30043648 <hw_init+0x178>
30043638:	ebff1f23 	bl	3000b2cc <acoral_prints>
}
3004363c:	e28dd014 	add	sp, sp, #20
30043640:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30043644:	e12fff1e 	bx	lr
30043648:	3004666c 	.word	0x3004666c

3004364c <hw_sendPacket>:
/*================================
 *
 *  数据发送函数
 */
void   hw_sendPacket(struct pbuf *p)
{
3004364c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30043650:	e24dd024 	sub	sp, sp, #36	; 0x24
30043654:	e58d0004 	str	r0, [sp, #4]
	u16_t tmp;
	u8_t* dat;
	u8_t data;;

	
	dm9000_reg_write(DM9000_IMR,0x80);
30043658:	e3a000ff 	mov	r0, #255	; 0xff
3004365c:	e3a01080 	mov	r1, #128	; 0x80
30043660:	ebffff6c 	bl	30043418 <dm9000_reg_write>
	//if (p->tot_len > 1514)
	//	return;

/**/
	// 写帧长
	len = p->tot_len;
30043664:	e59d3004 	ldr	r3, [sp, #4]
30043668:	e1d330b8 	ldrh	r3, [r3, #8]
3004366c:	e58d300c 	str	r3, [sp, #12]
	dm9000_reg_write(DM9000_TXPLH, (len>>8) & 0x0ff);
30043670:	e59d300c 	ldr	r3, [sp, #12]
30043674:	e1a03423 	lsr	r3, r3, #8
30043678:	e1a03803 	lsl	r3, r3, #16
3004367c:	e1a03823 	lsr	r3, r3, #16
30043680:	e20330ff 	and	r3, r3, #255	; 0xff
30043684:	e3a000fd 	mov	r0, #253	; 0xfd
30043688:	e1a01003 	mov	r1, r3
3004368c:	ebffff61 	bl	30043418 <dm9000_reg_write>
	dm9000_reg_write(DM9000_TXPLL, len & 0x0ff);
30043690:	e59d300c 	ldr	r3, [sp, #12]
30043694:	e1a03803 	lsl	r3, r3, #16
30043698:	e1a03823 	lsr	r3, r3, #16
3004369c:	e20330ff 	and	r3, r3, #255	; 0xff
300436a0:	e3a000fc 	mov	r0, #252	; 0xfc
300436a4:	e1a01003 	mov	r1, r3
300436a8:	ebffff5a 	bl	30043418 <dm9000_reg_write>
	
	// 发送数据
	DM_ADD = DM9000_MWCMD;
300436ac:	e3a03202 	mov	r3, #536870912	; 0x20000000
300436b0:	e2833c03 	add	r3, r3, #768	; 0x300
300436b4:	e3a020f8 	mov	r2, #248	; 0xf8
300436b8:	e1c320b0 	strh	r2, [r3]
	for(q = p; q != NULL; q = q->next)
300436bc:	e59d3004 	ldr	r3, [sp, #4]
300436c0:	e58d3008 	str	r3, [sp, #8]
300436c4:	ea000030 	b	3004378c <hw_sendPacket+0x140>
	{
		dat = (u8_t*) q->payload;
300436c8:	e59d3008 	ldr	r3, [sp, #8]
300436cc:	e5933004 	ldr	r3, [r3, #4]
300436d0:	e58d3018 	str	r3, [sp, #24]
		len = q->len;
300436d4:	e59d3008 	ldr	r3, [sp, #8]
300436d8:	e1d330ba 	ldrh	r3, [r3, #10]
300436dc:	e58d300c 	str	r3, [sp, #12]
		for(i=0; i < (len); i+=2)
300436e0:	e3a03000 	mov	r3, #0
300436e4:	e58d3010 	str	r3, [sp, #16]
300436e8:	ea000020 	b	30043770 <hw_sendPacket+0x124>
		{
			//udelay(20);
			udelay(1);
300436ec:	e3a00001 	mov	r0, #1
300436f0:	ebfffede 	bl	30043270 <udelay>
			tmp = 0x0;
300436f4:	e3a03000 	mov	r3, #0
300436f8:	e1cd31b6 	strh	r3, [sp, #22]
			tmp |= *dat;
300436fc:	e59d3018 	ldr	r3, [sp, #24]
30043700:	e5d33000 	ldrb	r3, [r3]
30043704:	e1a02003 	mov	r2, r3
30043708:	e1dd31b6 	ldrh	r3, [sp, #22]
3004370c:	e1823003 	orr	r3, r2, r3
30043710:	e1cd31b6 	strh	r3, [sp, #22]
			dat++;
30043714:	e59d3018 	ldr	r3, [sp, #24]
30043718:	e2833001 	add	r3, r3, #1
3004371c:	e58d3018 	str	r3, [sp, #24]
			tmp |= *dat<< 8;
30043720:	e59d3018 	ldr	r3, [sp, #24]
30043724:	e5d33000 	ldrb	r3, [r3]
30043728:	e1a03403 	lsl	r3, r3, #8
3004372c:	e1a03803 	lsl	r3, r3, #16
30043730:	e1a02823 	lsr	r2, r3, #16
30043734:	e1dd31b6 	ldrh	r3, [sp, #22]
30043738:	e1823003 	orr	r3, r2, r3
3004373c:	e1a03803 	lsl	r3, r3, #16
30043740:	e1a03823 	lsr	r3, r3, #16
30043744:	e1cd31b6 	strh	r3, [sp, #22]
			dat ++;
30043748:	e59d3018 	ldr	r3, [sp, #24]
3004374c:	e2833001 	add	r3, r3, #1
30043750:	e58d3018 	str	r3, [sp, #24]
			DM_CMD = tmp;
30043754:	e3a03202 	mov	r3, #536870912	; 0x20000000
30043758:	e2833fc1 	add	r3, r3, #772	; 0x304
3004375c:	e1dd21b6 	ldrh	r2, [sp, #22]
30043760:	e1c320b0 	strh	r2, [r3]
	DM_ADD = DM9000_MWCMD;
	for(q = p; q != NULL; q = q->next)
	{
		dat = (u8_t*) q->payload;
		len = q->len;
		for(i=0; i < (len); i+=2)
30043764:	e59d3010 	ldr	r3, [sp, #16]
30043768:	e2833002 	add	r3, r3, #2
3004376c:	e58d3010 	str	r3, [sp, #16]
30043770:	e59d2010 	ldr	r2, [sp, #16]
30043774:	e59d300c 	ldr	r3, [sp, #12]
30043778:	e1520003 	cmp	r2, r3
3004377c:	3affffda 	bcc	300436ec <hw_sendPacket+0xa0>
	dm9000_reg_write(DM9000_TXPLH, (len>>8) & 0x0ff);
	dm9000_reg_write(DM9000_TXPLL, len & 0x0ff);
	
	// 发送数据
	DM_ADD = DM9000_MWCMD;
	for(q = p; q != NULL; q = q->next)
30043780:	e59d3008 	ldr	r3, [sp, #8]
30043784:	e5933000 	ldr	r3, [r3]
30043788:	e58d3008 	str	r3, [sp, #8]
3004378c:	e59d3008 	ldr	r3, [sp, #8]
30043790:	e3530000 	cmp	r3, #0
30043794:	1affffcb 	bne	300436c8 <hw_sendPacket+0x7c>
			DM_CMD = tmp;
		}
	}

	//发送到网络
	dm9000_reg_write(DM9000_TCR, 0x01);	
30043798:	e3a00002 	mov	r0, #2
3004379c:	e3a01001 	mov	r1, #1
300437a0:	ebffff1c 	bl	30043418 <dm9000_reg_write>
300437a4:	ea000000 	b	300437ac <hw_sendPacket+0x160>
	while(1)
	{
		udelay(1000);
		data = dm9000_reg_read(DM9000_TCR);//DM9000_NSR
		if((data&0x01) == 0x00) break;
	}
300437a8:	e1a00000 	nop			; (mov r0, r0)
	//发送到网络
	dm9000_reg_write(DM9000_TCR, 0x01);	
	//等待发送完毕
	while(1)
	{
		udelay(1000);
300437ac:	e3a00ffa 	mov	r0, #1000	; 0x3e8
300437b0:	ebfffeae 	bl	30043270 <udelay>
		data = dm9000_reg_read(DM9000_TCR);//DM9000_NSR
300437b4:	e3a00002 	mov	r0, #2
300437b8:	ebffff25 	bl	30043454 <dm9000_reg_read>
300437bc:	e1a03000 	mov	r3, r0
300437c0:	e5cd301f 	strb	r3, [sp, #31]
		if((data&0x01) == 0x00) break;
300437c4:	e5dd301f 	ldrb	r3, [sp, #31]
300437c8:	e2033001 	and	r3, r3, #1
300437cc:	e3530000 	cmp	r3, #0
300437d0:	1afffff4 	bne	300437a8 <hw_sendPacket+0x15c>
	}
	dm9000_reg_write(DM9000_NSR, 0x2c);	
300437d4:	e3a00001 	mov	r0, #1
300437d8:	e3a0102c 	mov	r1, #44	; 0x2c
300437dc:	ebffff0d 	bl	30043418 <dm9000_reg_write>

		}
		Printf("\r\n+++++++++++++++++++++\r\n");
	*/		

    dm9000_reg_write(DM9000_IMR, 0x81);	
300437e0:	e3a000ff 	mov	r0, #255	; 0xff
300437e4:	e3a01081 	mov	r1, #129	; 0x81
300437e8:	ebffff0a 	bl	30043418 <dm9000_reg_write>

}
300437ec:	e28dd024 	add	sp, sp, #36	; 0x24
300437f0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
300437f4:	e12fff1e 	bx	lr

300437f8 <hw_getPacket>:
/*================================
 *
 *  数据接收函数
 */
struct pbuf* hw_getPacket (/*struct netif *netif,*/ u32_t* flag)
{
300437f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
300437fc:	e24dd02c 	sub	sp, sp, #44	; 0x2c
30043800:	e58d0004 	str	r0, [sp, #4]
	u8_t* dat;
	
	// test for mem alloc. by pegasus
	//static int num_pbuf_alloc = 0;	
	
	ready = 0;						
30043804:	e3a03000 	mov	r3, #0
30043808:	e5cd301f 	strb	r3, [sp, #31]
	status = 0;					
3004380c:	e3a03000 	mov	r3, #0
30043810:	e1cd31b8 	strh	r3, [sp, #24]
	len = 0; 				
30043814:	e3a03000 	mov	r3, #0
30043818:	e1cd31ba 	strh	r3, [sp, #26]
	*flag = 0;
3004381c:	e59d3004 	ldr	r3, [sp, #4]
30043820:	e3a02000 	mov	r2, #0
30043824:	e5832000 	str	r2, [r3]
	
 	if(dm9000_reg_read(DM9000_ISR) & 0x01)          
30043828:	e3a000fe 	mov	r0, #254	; 0xfe
3004382c:	ebffff08 	bl	30043454 <dm9000_reg_read>
30043830:	e1a03000 	mov	r3, r0
30043834:	e2033001 	and	r3, r3, #1
30043838:	e20330ff 	and	r3, r3, #255	; 0xff
3004383c:	e3530000 	cmp	r3, #0
30043840:	0a000002 	beq	30043850 <hw_getPacket+0x58>
    {
        dm9000_reg_write(DM9000_ISR, 0x01);	
30043844:	e3a000fe 	mov	r0, #254	; 0xfe
30043848:	e3a01001 	mov	r1, #1
3004384c:	ebfffef1 	bl	30043418 <dm9000_reg_write>
    }


	ready = dm9000_reg_read16(DM9000_MRCMDX); 
30043850:	e3a000f0 	mov	r0, #240	; 0xf0
30043854:	ebffff0e 	bl	30043494 <dm9000_reg_read16>
30043858:	e1a03000 	mov	r3, r0
3004385c:	e5cd301f 	strb	r3, [sp, #31]
    ready = dm9000_reg_read16(DM9000_MRCMDX);
30043860:	e3a000f0 	mov	r0, #240	; 0xf0
30043864:	ebffff0a 	bl	30043494 <dm9000_reg_read16>
30043868:	e1a03000 	mov	r3, r0
3004386c:	e5cd301f 	strb	r3, [sp, #31]
 
 	if ( (ready&0x0ff) > 0x01)
30043870:	e5dd301f 	ldrb	r3, [sp, #31]
30043874:	e3530001 	cmp	r3, #1
30043878:	9a00000d 	bls	300438b4 <hw_getPacket+0xbc>
 	{
 		dm9000_reg_write(DM9000_RCR,  0x39);	//接收控制
3004387c:	e3a00005 	mov	r0, #5
30043880:	e3a01039 	mov	r1, #57	; 0x39
30043884:	ebfffee3 	bl	30043418 <dm9000_reg_write>
 		dm9000_reg_write(DM9000_ISR,  0x3f);	//清除所有中断标志位
30043888:	e3a000fe 	mov	r0, #254	; 0xfe
3004388c:	e3a0103f 	mov	r1, #63	; 0x3f
30043890:	ebfffee0 	bl	30043418 <dm9000_reg_write>
 		dm9000_reg_write(DM9000_IMR, 0x81);		//中断使能
30043894:	e3a000ff 	mov	r0, #255	; 0xff
30043898:	e3a01081 	mov	r1, #129	; 0x81
3004389c:	ebfffedd 	bl	30043418 <dm9000_reg_write>
 		*flag = 0;
300438a0:	e59d3004 	ldr	r3, [sp, #4]
300438a4:	e3a02000 	mov	r2, #0
300438a8:	e5832000 	str	r2, [r3]
 		return NULL;
300438ac:	e3a03000 	mov	r3, #0
300438b0:	ea000099 	b	30043b1c <hw_getPacket+0x324>
 	}
 	
 	if ((ready & 0x001) == 0x00)
300438b4:	e5dd301f 	ldrb	r3, [sp, #31]
300438b8:	e2033001 	and	r3, r3, #1
300438bc:	e3530000 	cmp	r3, #0
300438c0:	1a000004 	bne	300438d8 <hw_getPacket+0xe0>
 	{
 		*flag = 0;
300438c4:	e59d3004 	ldr	r3, [sp, #4]
300438c8:	e3a02000 	mov	r2, #0
300438cc:	e5832000 	str	r2, [r3]
 		return NULL;
300438d0:	e3a03000 	mov	r3, #0
300438d4:	ea000090 	b	30043b1c <hw_getPacket+0x324>
 	}


    DM_ADD=DM9000_MRCMD;
300438d8:	e3a03202 	mov	r3, #536870912	; 0x20000000
300438dc:	e2833c03 	add	r3, r3, #768	; 0x300
300438e0:	e3a020f2 	mov	r2, #242	; 0xf2
300438e4:	e1c320b0 	strh	r2, [r3]
    status = DM_CMD;
300438e8:	e3a03202 	mov	r3, #536870912	; 0x20000000
300438ec:	e2833fc1 	add	r3, r3, #772	; 0x304
300438f0:	e1d330b0 	ldrh	r3, [r3]
300438f4:	e1cd31b8 	strh	r3, [sp, #24]
    len = DM_CMD;
300438f8:	e3a03202 	mov	r3, #536870912	; 0x20000000
300438fc:	e2833fc1 	add	r3, r3, #772	; 0x304
30043900:	e1d330b0 	ldrh	r3, [r3]
30043904:	e1cd31ba 	strh	r3, [sp, #26]
    if((len < 1522) || (len > 0x40))
30043908:	e1dd21ba 	ldrh	r2, [sp, #26]
3004390c:	e3a03e5f 	mov	r3, #1520	; 0x5f0
30043910:	e2833001 	add	r3, r3, #1
30043914:	e1520003 	cmp	r2, r3
30043918:	9a000002 	bls	30043928 <hw_getPacket+0x130>
3004391c:	e1dd31ba 	ldrh	r3, [sp, #26]
30043920:	e3530040 	cmp	r3, #64	; 0x40
30043924:	9a000068 	bls	30043acc <hw_getPacket+0x2d4>
    	#if ETH_PAD_SIZE
       		pbuf_header(p, -ETH_PAD_SIZE);
       	#endif
       	
       	//alocate a pbuf chain of pbufs from the pool
       	p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
30043928:	e1dd31ba 	ldrh	r3, [sp, #26]
3004392c:	e3a00003 	mov	r0, #3
30043930:	e1a01003 	mov	r1, r3
30043934:	e3a02003 	mov	r2, #3
30043938:	ebff489e 	bl	30015bb8 <pbuf_alloc>
3004393c:	e1a03000 	mov	r3, r0
30043940:	e58d300c 	str	r3, [sp, #12]
       	
       	if (p == NULL)
30043944:	e59d300c 	ldr	r3, [sp, #12]
30043948:	e3530000 	cmp	r3, #0
3004394c:	1a000022 	bne	300439dc <hw_getPacket+0x1e4>
       	{
       	    LINK_STATS_INC(link.memerr);
30043950:	e59f31d4 	ldr	r3, [pc, #468]	; 30043b2c <hw_getPacket+0x334>
30043954:	e1d330be 	ldrh	r3, [r3, #14]
30043958:	e2833001 	add	r3, r3, #1
3004395c:	e1a03803 	lsl	r3, r3, #16
30043960:	e1a02823 	lsr	r2, r3, #16
30043964:	e59f31c0 	ldr	r3, [pc, #448]	; 30043b2c <hw_getPacket+0x334>
30043968:	e1c320be 	strh	r2, [r3, #14]
    		LINK_STATS_INC(link.drop);
3004396c:	e59f31b8 	ldr	r3, [pc, #440]	; 30043b2c <hw_getPacket+0x334>
30043970:	e1d330b8 	ldrh	r3, [r3, #8]
30043974:	e2833001 	add	r3, r3, #1
30043978:	e1a03803 	lsl	r3, r3, #16
3004397c:	e1a02823 	lsr	r2, r3, #16
30043980:	e59f31a4 	ldr	r3, [pc, #420]	; 30043b2c <hw_getPacket+0x334>
30043984:	e1c320b8 	strh	r2, [r3, #8]
    		
			/* dump the err data */
			for(i=0; i < len; i+=2) // 16 bit mode
30043988:	e3a03000 	mov	r3, #0
3004398c:	e1cd31b4 	strh	r3, [sp, #20]
30043990:	ea000008 	b	300439b8 <hw_getPacket+0x1c0>
   		 	{
    			//udelay(20);
    			udelay(1);
30043994:	e3a00001 	mov	r0, #1
30043998:	ebfffe34 	bl	30043270 <udelay>
       			tmp = DM_CMD;
3004399c:	e3a03202 	mov	r3, #536870912	; 0x20000000
300439a0:	e2833fc1 	add	r3, r3, #772	; 0x304
300439a4:	e1d330b0 	ldrh	r3, [r3]
300439a8:	e1cd31b6 	strh	r3, [sp, #22]
       	{
       	    LINK_STATS_INC(link.memerr);
    		LINK_STATS_INC(link.drop);
    		
			/* dump the err data */
			for(i=0; i < len; i+=2) // 16 bit mode
300439ac:	e1dd31b4 	ldrh	r3, [sp, #20]
300439b0:	e2833002 	add	r3, r3, #2
300439b4:	e1cd31b4 	strh	r3, [sp, #20]
300439b8:	e1dd21b4 	ldrh	r2, [sp, #20]
300439bc:	e1dd31ba 	ldrh	r3, [sp, #26]
300439c0:	e1520003 	cmp	r2, r3
300439c4:	3afffff2 	bcc	30043994 <hw_getPacket+0x19c>
    			//udelay(20);
    			udelay(1);
       			tmp = DM_CMD;
    		}
    		
       		*flag = 1;
300439c8:	e59d3004 	ldr	r3, [sp, #4]
300439cc:	e3a02001 	mov	r2, #1
300439d0:	e5832000 	str	r2, [r3]
       		return p;
300439d4:	e59d300c 	ldr	r3, [sp, #12]
300439d8:	ea00004f 	b	30043b1c <hw_getPacket+0x324>
       	}
       	// test for mem alloc. by pegasus
       	//acoral_print("\nnum_pbuf_alloc == %d \n", ++num_pbuf_alloc);
       	
       	for (q = p; q != NULL; q = q->next)
300439dc:	e59d300c 	ldr	r3, [sp, #12]
300439e0:	e58d3010 	str	r3, [sp, #16]
300439e4:	ea000029 	b	30043a90 <hw_getPacket+0x298>
       	{
       		dat = (u8_t*)q->payload;
300439e8:	e59d3010 	ldr	r3, [sp, #16]
300439ec:	e5933004 	ldr	r3, [r3, #4]
300439f0:	e58d3024 	str	r3, [sp, #36]	; 0x24
       		plen= q->len;
300439f4:	e59d3010 	ldr	r3, [sp, #16]
300439f8:	e1d330ba 	ldrh	r3, [r3, #10]
300439fc:	e1cd31bc 	strh	r3, [sp, #28]
       		
        	for(i=0; i < plen; i+=2) // 16 bit mode
30043a00:	e3a03000 	mov	r3, #0
30043a04:	e1cd31b4 	strh	r3, [sp, #20]
30043a08:	ea000019 	b	30043a74 <hw_getPacket+0x27c>
        	{
           	    udelay(1);
30043a0c:	e3a00001 	mov	r0, #1
30043a10:	ebfffe16 	bl	30043270 <udelay>
            	tmp = DM_CMD;
30043a14:	e3a03202 	mov	r3, #536870912	; 0x20000000
30043a18:	e2833fc1 	add	r3, r3, #772	; 0x304
30043a1c:	e1d330b0 	ldrh	r3, [r3]
30043a20:	e1cd31b6 	strh	r3, [sp, #22]
            	*dat++ = tmp & 0x0ff;
30043a24:	e1dd31b6 	ldrh	r3, [sp, #22]
30043a28:	e20320ff 	and	r2, r3, #255	; 0xff
30043a2c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30043a30:	e5c32000 	strb	r2, [r3]
30043a34:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30043a38:	e2833001 	add	r3, r3, #1
30043a3c:	e58d3024 	str	r3, [sp, #36]	; 0x24
            	*dat++ = (tmp >> 8) & 0x0ff;
30043a40:	e1dd31b6 	ldrh	r3, [sp, #22]
30043a44:	e1a03423 	lsr	r3, r3, #8
30043a48:	e1a03803 	lsl	r3, r3, #16
30043a4c:	e1a03823 	lsr	r3, r3, #16
30043a50:	e20320ff 	and	r2, r3, #255	; 0xff
30043a54:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30043a58:	e5c32000 	strb	r2, [r3]
30043a5c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
30043a60:	e2833001 	add	r3, r3, #1
30043a64:	e58d3024 	str	r3, [sp, #36]	; 0x24
       	for (q = p; q != NULL; q = q->next)
       	{
       		dat = (u8_t*)q->payload;
       		plen= q->len;
       		
        	for(i=0; i < plen; i+=2) // 16 bit mode
30043a68:	e1dd31b4 	ldrh	r3, [sp, #20]
30043a6c:	e2833002 	add	r3, r3, #2
30043a70:	e1cd31b4 	strh	r3, [sp, #20]
30043a74:	e1dd21b4 	ldrh	r2, [sp, #20]
30043a78:	e1dd31bc 	ldrh	r3, [sp, #28]
30043a7c:	e1520003 	cmp	r2, r3
30043a80:	3affffe1 	bcc	30043a0c <hw_getPacket+0x214>
       		return p;
       	}
       	// test for mem alloc. by pegasus
       	//acoral_print("\nnum_pbuf_alloc == %d \n", ++num_pbuf_alloc);
       	
       	for (q = p; q != NULL; q = q->next)
30043a84:	e59d3010 	ldr	r3, [sp, #16]
30043a88:	e5933000 	ldr	r3, [r3]
30043a8c:	e58d3010 	str	r3, [sp, #16]
30043a90:	e59d3010 	ldr	r3, [sp, #16]
30043a94:	e3530000 	cmp	r3, #0
30043a98:	1affffd2 	bne	300439e8 <hw_getPacket+0x1f0>
				
		#if ETH_PAD_SIZE
			pbuf_header(p, ETH_PAD_SIZE);
		#endif

		LINK_STATS_INC(link.recv);
30043a9c:	e59f3088 	ldr	r3, [pc, #136]	; 30043b2c <hw_getPacket+0x334>
30043aa0:	e1d330b4 	ldrh	r3, [r3, #4]
30043aa4:	e2833001 	add	r3, r3, #1
30043aa8:	e1a03803 	lsl	r3, r3, #16
30043aac:	e1a02823 	lsr	r2, r3, #16
30043ab0:	e59f3074 	ldr	r3, [pc, #116]	; 30043b2c <hw_getPacket+0x334>
30043ab4:	e1c320b4 	strh	r2, [r3, #4]
		*flag = 1;
30043ab8:	e59d3004 	ldr	r3, [sp, #4]
30043abc:	e3a02001 	mov	r2, #1
30043ac0:	e5832000 	str	r2, [r3]
		return p;
30043ac4:	e59d300c 	ldr	r3, [sp, #12]
30043ac8:	ea000013 	b	30043b1c <hw_getPacket+0x324>
	}
	
	/* dump the err data */
	for(i=0; i < len; i+=2) // 16 bit mode
30043acc:	e3a03000 	mov	r3, #0
30043ad0:	e1cd31b4 	strh	r3, [sp, #20]
30043ad4:	ea000008 	b	30043afc <hw_getPacket+0x304>
    {
    	udelay(20);
30043ad8:	e3a00014 	mov	r0, #20
30043adc:	ebfffde3 	bl	30043270 <udelay>
       	tmp = DM_CMD;
30043ae0:	e3a03202 	mov	r3, #536870912	; 0x20000000
30043ae4:	e2833fc1 	add	r3, r3, #772	; 0x304
30043ae8:	e1d330b0 	ldrh	r3, [r3]
30043aec:	e1cd31b6 	strh	r3, [sp, #22]
		*flag = 1;
		return p;
	}
	
	/* dump the err data */
	for(i=0; i < len; i+=2) // 16 bit mode
30043af0:	e1dd31b4 	ldrh	r3, [sp, #20]
30043af4:	e2833002 	add	r3, r3, #2
30043af8:	e1cd31b4 	strh	r3, [sp, #20]
30043afc:	e1dd21b4 	ldrh	r2, [sp, #20]
30043b00:	e1dd31ba 	ldrh	r3, [sp, #26]
30043b04:	e1520003 	cmp	r2, r3
30043b08:	3afffff2 	bcc	30043ad8 <hw_getPacket+0x2e0>
    {
    	udelay(20);
       	tmp = DM_CMD;
    }
	*flag = 1;
30043b0c:	e59d3004 	ldr	r3, [sp, #4]
30043b10:	e3a02001 	mov	r2, #1
30043b14:	e5832000 	str	r2, [r3]
    return NULL;
30043b18:	e3a03000 	mov	r3, #0
}
30043b1c:	e1a00003 	mov	r0, r3
30043b20:	e28dd02c 	add	sp, sp, #44	; 0x2c
30043b24:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30043b28:	e12fff1e 	bx	lr
30043b2c:	302be570 	.word	0x302be570

30043b30 <hw_dm9k_config>:

/**/


acoral_32 hw_dm9k_config(acoral_u32 cmd,void *data,acoral_time tm_out)
{
30043b30:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30043b34:	e24dd014 	sub	sp, sp, #20
30043b38:	e58d000c 	str	r0, [sp, #12]
30043b3c:	e58d1008 	str	r1, [sp, #8]
30043b40:	e58d2004 	str	r2, [sp, #4]
	if (cmd == NET_DEV_INIT)
30043b44:	e59d300c 	ldr	r3, [sp, #12]
30043b48:	e3530001 	cmp	r3, #1
30043b4c:	1a000002 	bne	30043b5c <hw_dm9k_config+0x2c>
	{
		hw_init((u8_t*)data);
30043b50:	e59d3008 	ldr	r3, [sp, #8]
30043b54:	e1a00003 	mov	r0, r3
30043b58:	ebfffe5c 	bl	300434d0 <hw_init>
	}
	acoral_sem_init(&dm9k_recv_sem, 0);
30043b5c:	e59f0018 	ldr	r0, [pc, #24]	; 30043b7c <hw_dm9k_config+0x4c>
30043b60:	e3a01000 	mov	r1, #0
30043b64:	ebff0e41 	bl	30007470 <acoral_sem_init>
	return 0;
30043b68:	e3a03000 	mov	r3, #0
}
30043b6c:	e1a00003 	mov	r0, r3
30043b70:	e28dd014 	add	sp, sp, #20
30043b74:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30043b78:	e12fff1e 	bx	lr
30043b7c:	300ea2f4 	.word	0x300ea2f4

30043b80 <hw_dm9k_read>:

acoral_32 hw_dm9k_read (void *data,acoral_size size,acoral_size offset,acoral_time tm_out)
{
30043b80:	e92d4010 	push	{r4, lr}
30043b84:	e24dd010 	sub	sp, sp, #16
30043b88:	e58d000c 	str	r0, [sp, #12]
30043b8c:	e58d1008 	str	r1, [sp, #8]
30043b90:	e58d2004 	str	r2, [sp, #4]
30043b94:	e58d3000 	str	r3, [sp]
	if (flag == 0){
30043b98:	e59f3058 	ldr	r3, [pc, #88]	; 30043bf8 <hw_dm9k_read+0x78>
30043b9c:	e5933000 	ldr	r3, [r3]
30043ba0:	e3530000 	cmp	r3, #0
30043ba4:	1a000009 	bne	30043bd0 <hw_dm9k_read+0x50>
		 rEINTMSK &=~(1<<7);
30043ba8:	e3a03456 	mov	r3, #1442840576	; 0x56000000
30043bac:	e28330a4 	add	r3, r3, #164	; 0xa4
30043bb0:	e3a02456 	mov	r2, #1442840576	; 0x56000000
30043bb4:	e28220a4 	add	r2, r2, #164	; 0xa4
30043bb8:	e5922000 	ldr	r2, [r2]
30043bbc:	e3c22080 	bic	r2, r2, #128	; 0x80
30043bc0:	e5832000 	str	r2, [r3]
		 acoral_sem_pend(&dm9k_recv_sem, 0);
30043bc4:	e59f0030 	ldr	r0, [pc, #48]	; 30043bfc <hw_dm9k_read+0x7c>
30043bc8:	e3a01000 	mov	r1, #0
30043bcc:	ebff0ebb 	bl	300076c0 <acoral_sem_pend>
	}
	*(void **)data = (void*)hw_getPacket (/*struct netif *netif,*/ &flag);
30043bd0:	e59d400c 	ldr	r4, [sp, #12]
30043bd4:	e59f001c 	ldr	r0, [pc, #28]	; 30043bf8 <hw_dm9k_read+0x78>
30043bd8:	ebffff06 	bl	300437f8 <hw_getPacket>
30043bdc:	e1a03000 	mov	r3, r0
30043be0:	e5843000 	str	r3, [r4]
	
	return 0;
30043be4:	e3a03000 	mov	r3, #0
}
30043be8:	e1a00003 	mov	r0, r3
30043bec:	e28dd010 	add	sp, sp, #16
30043bf0:	e8bd4010 	pop	{r4, lr}
30043bf4:	e12fff1e 	bx	lr
30043bf8:	300ea318 	.word	0x300ea318
30043bfc:	300ea2f4 	.word	0x300ea2f4

30043c00 <hw_dm9k_write>:

acoral_32 hw_dm9k_write(void *data,acoral_size size,acoral_size offset,acoral_time tm_out)
{
30043c00:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
30043c04:	e24dd014 	sub	sp, sp, #20
30043c08:	e58d000c 	str	r0, [sp, #12]
30043c0c:	e58d1008 	str	r1, [sp, #8]
30043c10:	e58d2004 	str	r2, [sp, #4]
30043c14:	e58d3000 	str	r3, [sp]
	hw_sendPacket((struct pbuf *)data);
30043c18:	e59d300c 	ldr	r3, [sp, #12]
30043c1c:	e1a00003 	mov	r0, r3
30043c20:	ebfffe89 	bl	3004364c <hw_sendPacket>
	return 0;
30043c24:	e3a03000 	mov	r3, #0
}
30043c28:	e1a00003 	mov	r0, r3
30043c2c:	e28dd014 	add	sp, sp, #20
30043c30:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
30043c34:	e12fff1e 	bx	lr

30043c38 <dm9000_init>:

void dm9000_init(){
30043c38:	e92d4008 	push	{r3, lr}
	//acoral_prints("\r\ndm9kinit\r\n");
	hw_dm9k_ops.write  = hw_dm9k_write;
30043c3c:	e59f3048 	ldr	r3, [pc, #72]	; 30043c8c <dm9000_init+0x54>
30043c40:	e59f2048 	ldr	r2, [pc, #72]	; 30043c90 <dm9000_init+0x58>
30043c44:	e5832008 	str	r2, [r3, #8]
	hw_dm9k_ops.read   = hw_dm9k_read;
30043c48:	e59f303c 	ldr	r3, [pc, #60]	; 30043c8c <dm9000_init+0x54>
30043c4c:	e59f2040 	ldr	r2, [pc, #64]	; 30043c94 <dm9000_init+0x5c>
30043c50:	e5832004 	str	r2, [r3, #4]
	hw_dm9k_ops.config = hw_dm9k_config;
30043c54:	e59f3030 	ldr	r3, [pc, #48]	; 30043c8c <dm9000_init+0x54>
30043c58:	e59f2038 	ldr	r2, [pc, #56]	; 30043c98 <dm9000_init+0x60>
30043c5c:	e583200c 	str	r2, [r3, #12]
	hw_dm9k_ops.open   = NULL;
30043c60:	e59f3024 	ldr	r3, [pc, #36]	; 30043c8c <dm9000_init+0x54>
30043c64:	e3a02000 	mov	r2, #0
30043c68:	e5832000 	str	r2, [r3]
	hw_dm9k_ops.close  = NULL;
30043c6c:	e59f3018 	ldr	r3, [pc, #24]	; 30043c8c <dm9000_init+0x54>
30043c70:	e3a02000 	mov	r2, #0
30043c74:	e5832010 	str	r2, [r3, #16]
  	acoral_drv_register(&hw_dm9k_ops,"netdev");
30043c78:	e59f000c 	ldr	r0, [pc, #12]	; 30043c8c <dm9000_init+0x54>
30043c7c:	e59f1018 	ldr	r1, [pc, #24]	; 30043c9c <dm9000_init+0x64>
30043c80:	ebfff1ff 	bl	30040484 <acoral_drv_register>
}
30043c84:	e8bd4008 	pop	{r3, lr}
30043c88:	e12fff1e 	bx	lr
30043c8c:	3012d68c 	.word	0x3012d68c
30043c90:	30043c00 	.word	0x30043c00
30043c94:	30043b80 	.word	0x30043b80
30043c98:	30043b30 	.word	0x30043b30
30043c9c:	3004667c 	.word	0x3004667c

30043ca0 <__aeabi_uidiv>:
30043ca0:	e2512001 	subs	r2, r1, #1
30043ca4:	012fff1e 	bxeq	lr
30043ca8:	3a000036 	bcc	30043d88 <__aeabi_uidiv+0xe8>
30043cac:	e1500001 	cmp	r0, r1
30043cb0:	9a000022 	bls	30043d40 <__aeabi_uidiv+0xa0>
30043cb4:	e1110002 	tst	r1, r2
30043cb8:	0a000023 	beq	30043d4c <__aeabi_uidiv+0xac>
30043cbc:	e311020e 	tst	r1, #-536870912	; 0xe0000000
30043cc0:	01a01181 	lsleq	r1, r1, #3
30043cc4:	03a03008 	moveq	r3, #8
30043cc8:	13a03001 	movne	r3, #1
30043ccc:	e3510201 	cmp	r1, #268435456	; 0x10000000
30043cd0:	31510000 	cmpcc	r1, r0
30043cd4:	31a01201 	lslcc	r1, r1, #4
30043cd8:	31a03203 	lslcc	r3, r3, #4
30043cdc:	3afffffa 	bcc	30043ccc <__aeabi_uidiv+0x2c>
30043ce0:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
30043ce4:	31510000 	cmpcc	r1, r0
30043ce8:	31a01081 	lslcc	r1, r1, #1
30043cec:	31a03083 	lslcc	r3, r3, #1
30043cf0:	3afffffa 	bcc	30043ce0 <__aeabi_uidiv+0x40>
30043cf4:	e3a02000 	mov	r2, #0
30043cf8:	e1500001 	cmp	r0, r1
30043cfc:	20400001 	subcs	r0, r0, r1
30043d00:	21822003 	orrcs	r2, r2, r3
30043d04:	e15000a1 	cmp	r0, r1, lsr #1
30043d08:	204000a1 	subcs	r0, r0, r1, lsr #1
30043d0c:	218220a3 	orrcs	r2, r2, r3, lsr #1
30043d10:	e1500121 	cmp	r0, r1, lsr #2
30043d14:	20400121 	subcs	r0, r0, r1, lsr #2
30043d18:	21822123 	orrcs	r2, r2, r3, lsr #2
30043d1c:	e15001a1 	cmp	r0, r1, lsr #3
30043d20:	204001a1 	subcs	r0, r0, r1, lsr #3
30043d24:	218221a3 	orrcs	r2, r2, r3, lsr #3
30043d28:	e3500000 	cmp	r0, #0
30043d2c:	11b03223 	lsrsne	r3, r3, #4
30043d30:	11a01221 	lsrne	r1, r1, #4
30043d34:	1affffef 	bne	30043cf8 <__aeabi_uidiv+0x58>
30043d38:	e1a00002 	mov	r0, r2
30043d3c:	e12fff1e 	bx	lr
30043d40:	03a00001 	moveq	r0, #1
30043d44:	13a00000 	movne	r0, #0
30043d48:	e12fff1e 	bx	lr
30043d4c:	e3510801 	cmp	r1, #65536	; 0x10000
30043d50:	21a01821 	lsrcs	r1, r1, #16
30043d54:	23a02010 	movcs	r2, #16
30043d58:	33a02000 	movcc	r2, #0
30043d5c:	e3510c01 	cmp	r1, #256	; 0x100
30043d60:	21a01421 	lsrcs	r1, r1, #8
30043d64:	22822008 	addcs	r2, r2, #8
30043d68:	e3510010 	cmp	r1, #16
30043d6c:	21a01221 	lsrcs	r1, r1, #4
30043d70:	22822004 	addcs	r2, r2, #4
30043d74:	e3510004 	cmp	r1, #4
30043d78:	82822003 	addhi	r2, r2, #3
30043d7c:	908220a1 	addls	r2, r2, r1, lsr #1
30043d80:	e1a00230 	lsr	r0, r0, r2
30043d84:	e12fff1e 	bx	lr
30043d88:	e3500000 	cmp	r0, #0
30043d8c:	13e00000 	mvnne	r0, #0
30043d90:	ea000059 	b	30043efc <__aeabi_idiv0>

30043d94 <__aeabi_uidivmod>:
30043d94:	e3510000 	cmp	r1, #0
30043d98:	0afffffa 	beq	30043d88 <__aeabi_uidiv+0xe8>
30043d9c:	e92d4003 	push	{r0, r1, lr}
30043da0:	ebffffbe 	bl	30043ca0 <__aeabi_uidiv>
30043da4:	e8bd4006 	pop	{r1, r2, lr}
30043da8:	e0030092 	mul	r3, r2, r0
30043dac:	e0411003 	sub	r1, r1, r3
30043db0:	e12fff1e 	bx	lr

30043db4 <__aeabi_idiv>:
30043db4:	e3510000 	cmp	r1, #0
30043db8:	0a000043 	beq	30043ecc <.divsi3_nodiv0+0x110>

30043dbc <.divsi3_nodiv0>:
30043dbc:	e020c001 	eor	ip, r0, r1
30043dc0:	42611000 	rsbmi	r1, r1, #0
30043dc4:	e2512001 	subs	r2, r1, #1
30043dc8:	0a000027 	beq	30043e6c <.divsi3_nodiv0+0xb0>
30043dcc:	e1b03000 	movs	r3, r0
30043dd0:	42603000 	rsbmi	r3, r0, #0
30043dd4:	e1530001 	cmp	r3, r1
30043dd8:	9a000026 	bls	30043e78 <.divsi3_nodiv0+0xbc>
30043ddc:	e1110002 	tst	r1, r2
30043de0:	0a000028 	beq	30043e88 <.divsi3_nodiv0+0xcc>
30043de4:	e311020e 	tst	r1, #-536870912	; 0xe0000000
30043de8:	01a01181 	lsleq	r1, r1, #3
30043dec:	03a02008 	moveq	r2, #8
30043df0:	13a02001 	movne	r2, #1
30043df4:	e3510201 	cmp	r1, #268435456	; 0x10000000
30043df8:	31510003 	cmpcc	r1, r3
30043dfc:	31a01201 	lslcc	r1, r1, #4
30043e00:	31a02202 	lslcc	r2, r2, #4
30043e04:	3afffffa 	bcc	30043df4 <.divsi3_nodiv0+0x38>
30043e08:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
30043e0c:	31510003 	cmpcc	r1, r3
30043e10:	31a01081 	lslcc	r1, r1, #1
30043e14:	31a02082 	lslcc	r2, r2, #1
30043e18:	3afffffa 	bcc	30043e08 <.divsi3_nodiv0+0x4c>
30043e1c:	e3a00000 	mov	r0, #0
30043e20:	e1530001 	cmp	r3, r1
30043e24:	20433001 	subcs	r3, r3, r1
30043e28:	21800002 	orrcs	r0, r0, r2
30043e2c:	e15300a1 	cmp	r3, r1, lsr #1
30043e30:	204330a1 	subcs	r3, r3, r1, lsr #1
30043e34:	218000a2 	orrcs	r0, r0, r2, lsr #1
30043e38:	e1530121 	cmp	r3, r1, lsr #2
30043e3c:	20433121 	subcs	r3, r3, r1, lsr #2
30043e40:	21800122 	orrcs	r0, r0, r2, lsr #2
30043e44:	e15301a1 	cmp	r3, r1, lsr #3
30043e48:	204331a1 	subcs	r3, r3, r1, lsr #3
30043e4c:	218001a2 	orrcs	r0, r0, r2, lsr #3
30043e50:	e3530000 	cmp	r3, #0
30043e54:	11b02222 	lsrsne	r2, r2, #4
30043e58:	11a01221 	lsrne	r1, r1, #4
30043e5c:	1affffef 	bne	30043e20 <.divsi3_nodiv0+0x64>
30043e60:	e35c0000 	cmp	ip, #0
30043e64:	42600000 	rsbmi	r0, r0, #0
30043e68:	e12fff1e 	bx	lr
30043e6c:	e13c0000 	teq	ip, r0
30043e70:	42600000 	rsbmi	r0, r0, #0
30043e74:	e12fff1e 	bx	lr
30043e78:	33a00000 	movcc	r0, #0
30043e7c:	01a00fcc 	asreq	r0, ip, #31
30043e80:	03800001 	orreq	r0, r0, #1
30043e84:	e12fff1e 	bx	lr
30043e88:	e3510801 	cmp	r1, #65536	; 0x10000
30043e8c:	21a01821 	lsrcs	r1, r1, #16
30043e90:	23a02010 	movcs	r2, #16
30043e94:	33a02000 	movcc	r2, #0
30043e98:	e3510c01 	cmp	r1, #256	; 0x100
30043e9c:	21a01421 	lsrcs	r1, r1, #8
30043ea0:	22822008 	addcs	r2, r2, #8
30043ea4:	e3510010 	cmp	r1, #16
30043ea8:	21a01221 	lsrcs	r1, r1, #4
30043eac:	22822004 	addcs	r2, r2, #4
30043eb0:	e3510004 	cmp	r1, #4
30043eb4:	82822003 	addhi	r2, r2, #3
30043eb8:	908220a1 	addls	r2, r2, r1, lsr #1
30043ebc:	e35c0000 	cmp	ip, #0
30043ec0:	e1a00233 	lsr	r0, r3, r2
30043ec4:	42600000 	rsbmi	r0, r0, #0
30043ec8:	e12fff1e 	bx	lr
30043ecc:	e3500000 	cmp	r0, #0
30043ed0:	c3e00102 	mvngt	r0, #-2147483648	; 0x80000000
30043ed4:	b3a00102 	movlt	r0, #-2147483648	; 0x80000000
30043ed8:	ea000007 	b	30043efc <__aeabi_idiv0>

30043edc <__aeabi_idivmod>:
30043edc:	e3510000 	cmp	r1, #0
30043ee0:	0afffff9 	beq	30043ecc <.divsi3_nodiv0+0x110>
30043ee4:	e92d4003 	push	{r0, r1, lr}
30043ee8:	ebffffb3 	bl	30043dbc <.divsi3_nodiv0>
30043eec:	e8bd4006 	pop	{r1, r2, lr}
30043ef0:	e0030092 	mul	r3, r2, r0
30043ef4:	e0411003 	sub	r1, r1, r3
30043ef8:	e12fff1e 	bx	lr

30043efc <__aeabi_idiv0>:
30043efc:	e12fff1e 	bx	lr

30043f00 <__aeabi_drsub>:
30043f00:	e2211102 	eor	r1, r1, #-2147483648	; 0x80000000
30043f04:	ea000000 	b	30043f0c <__adddf3>

30043f08 <__aeabi_dsub>:
30043f08:	e2233102 	eor	r3, r3, #-2147483648	; 0x80000000

30043f0c <__adddf3>:
30043f0c:	e92d4030 	push	{r4, r5, lr}
30043f10:	e1a04081 	lsl	r4, r1, #1
30043f14:	e1a05083 	lsl	r5, r3, #1
30043f18:	e1340005 	teq	r4, r5
30043f1c:	01300002 	teqeq	r0, r2
30043f20:	1194c000 	orrsne	ip, r4, r0
30043f24:	1195c002 	orrsne	ip, r5, r2
30043f28:	11f0cac4 	mvnsne	ip, r4, asr #21
30043f2c:	11f0cac5 	mvnsne	ip, r5, asr #21
30043f30:	0a00008c 	beq	30044168 <__adddf3+0x25c>
30043f34:	e1a04aa4 	lsr	r4, r4, #21
30043f38:	e0745aa5 	rsbs	r5, r4, r5, lsr #21
30043f3c:	b2655000 	rsblt	r5, r5, #0
30043f40:	da000006 	ble	30043f60 <__adddf3+0x54>
30043f44:	e0844005 	add	r4, r4, r5
30043f48:	e0202002 	eor	r2, r0, r2
30043f4c:	e0213003 	eor	r3, r1, r3
30043f50:	e0220000 	eor	r0, r2, r0
30043f54:	e0231001 	eor	r1, r3, r1
30043f58:	e0202002 	eor	r2, r0, r2
30043f5c:	e0213003 	eor	r3, r1, r3
30043f60:	e3550036 	cmp	r5, #54	; 0x36
30043f64:	88bd4030 	pophi	{r4, r5, lr}
30043f68:	812fff1e 	bxhi	lr
30043f6c:	e3110102 	tst	r1, #-2147483648	; 0x80000000
30043f70:	e1a01601 	lsl	r1, r1, #12
30043f74:	e3a0c601 	mov	ip, #1048576	; 0x100000
30043f78:	e18c1621 	orr	r1, ip, r1, lsr #12
30043f7c:	0a000001 	beq	30043f88 <__adddf3+0x7c>
30043f80:	e2700000 	rsbs	r0, r0, #0
30043f84:	e2e11000 	rsc	r1, r1, #0
30043f88:	e3130102 	tst	r3, #-2147483648	; 0x80000000
30043f8c:	e1a03603 	lsl	r3, r3, #12
30043f90:	e18c3623 	orr	r3, ip, r3, lsr #12
30043f94:	0a000001 	beq	30043fa0 <__adddf3+0x94>
30043f98:	e2722000 	rsbs	r2, r2, #0
30043f9c:	e2e33000 	rsc	r3, r3, #0
30043fa0:	e1340005 	teq	r4, r5
30043fa4:	0a000069 	beq	30044150 <__adddf3+0x244>
30043fa8:	e2444001 	sub	r4, r4, #1
30043fac:	e275e020 	rsbs	lr, r5, #32
30043fb0:	ba000005 	blt	30043fcc <__adddf3+0xc0>
30043fb4:	e1a0ce12 	lsl	ip, r2, lr
30043fb8:	e0900532 	adds	r0, r0, r2, lsr r5
30043fbc:	e2a11000 	adc	r1, r1, #0
30043fc0:	e0900e13 	adds	r0, r0, r3, lsl lr
30043fc4:	e0b11553 	adcs	r1, r1, r3, asr r5
30043fc8:	ea000006 	b	30043fe8 <__adddf3+0xdc>
30043fcc:	e2455020 	sub	r5, r5, #32
30043fd0:	e28ee020 	add	lr, lr, #32
30043fd4:	e3520001 	cmp	r2, #1
30043fd8:	e1a0ce13 	lsl	ip, r3, lr
30043fdc:	238cc002 	orrcs	ip, ip, #2
30043fe0:	e0900553 	adds	r0, r0, r3, asr r5
30043fe4:	e0b11fc3 	adcs	r1, r1, r3, asr #31
30043fe8:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
30043fec:	5a000002 	bpl	30043ffc <__adddf3+0xf0>
30043ff0:	e27cc000 	rsbs	ip, ip, #0
30043ff4:	e2f00000 	rscs	r0, r0, #0
30043ff8:	e2e11000 	rsc	r1, r1, #0
30043ffc:	e3510601 	cmp	r1, #1048576	; 0x100000
30044000:	3a00000f 	bcc	30044044 <__adddf3+0x138>
30044004:	e3510602 	cmp	r1, #2097152	; 0x200000
30044008:	3a000006 	bcc	30044028 <__adddf3+0x11c>
3004400c:	e1b010a1 	lsrs	r1, r1, #1
30044010:	e1b00060 	rrxs	r0, r0
30044014:	e1a0c06c 	rrx	ip, ip
30044018:	e2844001 	add	r4, r4, #1
3004401c:	e1a02a84 	lsl	r2, r4, #21
30044020:	e3720501 	cmn	r2, #4194304	; 0x400000
30044024:	2a00006b 	bcs	300441d8 <__adddf3+0x2cc>
30044028:	e35c0102 	cmp	ip, #-2147483648	; 0x80000000
3004402c:	01b0c0a0 	lsrseq	ip, r0, #1
30044030:	e2b00000 	adcs	r0, r0, #0
30044034:	e0a11a04 	adc	r1, r1, r4, lsl #20
30044038:	e1811005 	orr	r1, r1, r5
3004403c:	e8bd4030 	pop	{r4, r5, lr}
30044040:	e12fff1e 	bx	lr
30044044:	e1b0c08c 	lsls	ip, ip, #1
30044048:	e0b00000 	adcs	r0, r0, r0
3004404c:	e0a11001 	adc	r1, r1, r1
30044050:	e3110601 	tst	r1, #1048576	; 0x100000
30044054:	e2444001 	sub	r4, r4, #1
30044058:	1afffff2 	bne	30044028 <__adddf3+0x11c>
3004405c:	e3310000 	teq	r1, #0
30044060:	13a03014 	movne	r3, #20
30044064:	03a03034 	moveq	r3, #52	; 0x34
30044068:	01a01000 	moveq	r1, r0
3004406c:	03a00000 	moveq	r0, #0
30044070:	e1a02001 	mov	r2, r1
30044074:	e3520801 	cmp	r2, #65536	; 0x10000
30044078:	21a02822 	lsrcs	r2, r2, #16
3004407c:	22433010 	subcs	r3, r3, #16
30044080:	e3520c01 	cmp	r2, #256	; 0x100
30044084:	21a02422 	lsrcs	r2, r2, #8
30044088:	22433008 	subcs	r3, r3, #8
3004408c:	e3520010 	cmp	r2, #16
30044090:	21a02222 	lsrcs	r2, r2, #4
30044094:	22433004 	subcs	r3, r3, #4
30044098:	e3520004 	cmp	r2, #4
3004409c:	22433002 	subcs	r3, r3, #2
300440a0:	304330a2 	subcc	r3, r3, r2, lsr #1
300440a4:	e04331a2 	sub	r3, r3, r2, lsr #3
300440a8:	e2532020 	subs	r2, r3, #32
300440ac:	aa000007 	bge	300440d0 <__adddf3+0x1c4>
300440b0:	e292200c 	adds	r2, r2, #12
300440b4:	da000004 	ble	300440cc <__adddf3+0x1c0>
300440b8:	e282c014 	add	ip, r2, #20
300440bc:	e262200c 	rsb	r2, r2, #12
300440c0:	e1a00c11 	lsl	r0, r1, ip
300440c4:	e1a01231 	lsr	r1, r1, r2
300440c8:	ea000004 	b	300440e0 <__adddf3+0x1d4>
300440cc:	e2822014 	add	r2, r2, #20
300440d0:	d262c020 	rsble	ip, r2, #32
300440d4:	e1a01211 	lsl	r1, r1, r2
300440d8:	d1811c30 	orrle	r1, r1, r0, lsr ip
300440dc:	d1a00210 	lslle	r0, r0, r2
300440e0:	e0544003 	subs	r4, r4, r3
300440e4:	a0811a04 	addge	r1, r1, r4, lsl #20
300440e8:	a1811005 	orrge	r1, r1, r5
300440ec:	a8bd4030 	popge	{r4, r5, lr}
300440f0:	a12fff1e 	bxge	lr
300440f4:	e1e04004 	mvn	r4, r4
300440f8:	e254401f 	subs	r4, r4, #31
300440fc:	aa00000f 	bge	30044140 <__adddf3+0x234>
30044100:	e294400c 	adds	r4, r4, #12
30044104:	ca000006 	bgt	30044124 <__adddf3+0x218>
30044108:	e2844014 	add	r4, r4, #20
3004410c:	e2642020 	rsb	r2, r4, #32
30044110:	e1a00430 	lsr	r0, r0, r4
30044114:	e1800211 	orr	r0, r0, r1, lsl r2
30044118:	e1851431 	orr	r1, r5, r1, lsr r4
3004411c:	e8bd4030 	pop	{r4, r5, lr}
30044120:	e12fff1e 	bx	lr
30044124:	e264400c 	rsb	r4, r4, #12
30044128:	e2642020 	rsb	r2, r4, #32
3004412c:	e1a00230 	lsr	r0, r0, r2
30044130:	e1800411 	orr	r0, r0, r1, lsl r4
30044134:	e1a01005 	mov	r1, r5
30044138:	e8bd4030 	pop	{r4, r5, lr}
3004413c:	e12fff1e 	bx	lr
30044140:	e1a00431 	lsr	r0, r1, r4
30044144:	e1a01005 	mov	r1, r5
30044148:	e8bd4030 	pop	{r4, r5, lr}
3004414c:	e12fff1e 	bx	lr
30044150:	e3340000 	teq	r4, #0
30044154:	e2233601 	eor	r3, r3, #1048576	; 0x100000
30044158:	02211601 	eoreq	r1, r1, #1048576	; 0x100000
3004415c:	02844001 	addeq	r4, r4, #1
30044160:	12455001 	subne	r5, r5, #1
30044164:	eaffff8f 	b	30043fa8 <__adddf3+0x9c>
30044168:	e1f0cac4 	mvns	ip, r4, asr #21
3004416c:	11f0cac5 	mvnsne	ip, r5, asr #21
30044170:	0a00001d 	beq	300441ec <__adddf3+0x2e0>
30044174:	e1340005 	teq	r4, r5
30044178:	01300002 	teqeq	r0, r2
3004417c:	0a000004 	beq	30044194 <__adddf3+0x288>
30044180:	e194c000 	orrs	ip, r4, r0
30044184:	01a01003 	moveq	r1, r3
30044188:	01a00002 	moveq	r0, r2
3004418c:	e8bd4030 	pop	{r4, r5, lr}
30044190:	e12fff1e 	bx	lr
30044194:	e1310003 	teq	r1, r3
30044198:	13a01000 	movne	r1, #0
3004419c:	13a00000 	movne	r0, #0
300441a0:	18bd4030 	popne	{r4, r5, lr}
300441a4:	112fff1e 	bxne	lr
300441a8:	e1b0caa4 	lsrs	ip, r4, #21
300441ac:	1a000004 	bne	300441c4 <__adddf3+0x2b8>
300441b0:	e1b00080 	lsls	r0, r0, #1
300441b4:	e0b11001 	adcs	r1, r1, r1
300441b8:	23811102 	orrcs	r1, r1, #-2147483648	; 0x80000000
300441bc:	e8bd4030 	pop	{r4, r5, lr}
300441c0:	e12fff1e 	bx	lr
300441c4:	e2944501 	adds	r4, r4, #4194304	; 0x400000
300441c8:	32811601 	addcc	r1, r1, #1048576	; 0x100000
300441cc:	38bd4030 	popcc	{r4, r5, lr}
300441d0:	312fff1e 	bxcc	lr
300441d4:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
300441d8:	e385147f 	orr	r1, r5, #2130706432	; 0x7f000000
300441dc:	e381160f 	orr	r1, r1, #15728640	; 0xf00000
300441e0:	e3a00000 	mov	r0, #0
300441e4:	e8bd4030 	pop	{r4, r5, lr}
300441e8:	e12fff1e 	bx	lr
300441ec:	e1f0cac4 	mvns	ip, r4, asr #21
300441f0:	11a01003 	movne	r1, r3
300441f4:	11a00002 	movne	r0, r2
300441f8:	01f0cac5 	mvnseq	ip, r5, asr #21
300441fc:	11a03001 	movne	r3, r1
30044200:	11a02000 	movne	r2, r0
30044204:	e1904601 	orrs	r4, r0, r1, lsl #12
30044208:	01925603 	orrseq	r5, r2, r3, lsl #12
3004420c:	01310003 	teqeq	r1, r3
30044210:	13811702 	orrne	r1, r1, #524288	; 0x80000
30044214:	e8bd4030 	pop	{r4, r5, lr}
30044218:	e12fff1e 	bx	lr

3004421c <__aeabi_ui2d>:
3004421c:	e3300000 	teq	r0, #0
30044220:	03a01000 	moveq	r1, #0
30044224:	012fff1e 	bxeq	lr
30044228:	e92d4030 	push	{r4, r5, lr}
3004422c:	e3a04b01 	mov	r4, #1024	; 0x400
30044230:	e2844032 	add	r4, r4, #50	; 0x32
30044234:	e3a05000 	mov	r5, #0
30044238:	e3a01000 	mov	r1, #0
3004423c:	eaffff86 	b	3004405c <__adddf3+0x150>

30044240 <__aeabi_i2d>:
30044240:	e3300000 	teq	r0, #0
30044244:	03a01000 	moveq	r1, #0
30044248:	012fff1e 	bxeq	lr
3004424c:	e92d4030 	push	{r4, r5, lr}
30044250:	e3a04b01 	mov	r4, #1024	; 0x400
30044254:	e2844032 	add	r4, r4, #50	; 0x32
30044258:	e2105102 	ands	r5, r0, #-2147483648	; 0x80000000
3004425c:	42600000 	rsbmi	r0, r0, #0
30044260:	e3a01000 	mov	r1, #0
30044264:	eaffff7c 	b	3004405c <__adddf3+0x150>

30044268 <__aeabi_f2d>:
30044268:	e1b02080 	lsls	r2, r0, #1
3004426c:	e1a011c2 	asr	r1, r2, #3
30044270:	e1a01061 	rrx	r1, r1
30044274:	e1a00e02 	lsl	r0, r2, #28
30044278:	121234ff 	andsne	r3, r2, #-16777216	; 0xff000000
3004427c:	133304ff 	teqne	r3, #-16777216	; 0xff000000
30044280:	1221130e 	eorne	r1, r1, #939524096	; 0x38000000
30044284:	112fff1e 	bxne	lr
30044288:	e3320000 	teq	r2, #0
3004428c:	133304ff 	teqne	r3, #-16777216	; 0xff000000
30044290:	012fff1e 	bxeq	lr
30044294:	e92d4030 	push	{r4, r5, lr}
30044298:	e3a04d0e 	mov	r4, #896	; 0x380
3004429c:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
300442a0:	e3c11102 	bic	r1, r1, #-2147483648	; 0x80000000
300442a4:	eaffff6c 	b	3004405c <__adddf3+0x150>

300442a8 <__aeabi_ul2d>:
300442a8:	e1902001 	orrs	r2, r0, r1
300442ac:	012fff1e 	bxeq	lr
300442b0:	e92d4030 	push	{r4, r5, lr}
300442b4:	e3a05000 	mov	r5, #0
300442b8:	ea000006 	b	300442d8 <__aeabi_l2d+0x1c>

300442bc <__aeabi_l2d>:
300442bc:	e1902001 	orrs	r2, r0, r1
300442c0:	012fff1e 	bxeq	lr
300442c4:	e92d4030 	push	{r4, r5, lr}
300442c8:	e2115102 	ands	r5, r1, #-2147483648	; 0x80000000
300442cc:	5a000001 	bpl	300442d8 <__aeabi_l2d+0x1c>
300442d0:	e2700000 	rsbs	r0, r0, #0
300442d4:	e2e11000 	rsc	r1, r1, #0
300442d8:	e3a04b01 	mov	r4, #1024	; 0x400
300442dc:	e2844032 	add	r4, r4, #50	; 0x32
300442e0:	e1b0cb21 	lsrs	ip, r1, #22
300442e4:	0affff44 	beq	30043ffc <__adddf3+0xf0>
300442e8:	e3a02003 	mov	r2, #3
300442ec:	e1b0c1ac 	lsrs	ip, ip, #3
300442f0:	12822003 	addne	r2, r2, #3
300442f4:	e1b0c1ac 	lsrs	ip, ip, #3
300442f8:	12822003 	addne	r2, r2, #3
300442fc:	e08221ac 	add	r2, r2, ip, lsr #3
30044300:	e2623020 	rsb	r3, r2, #32
30044304:	e1a0c310 	lsl	ip, r0, r3
30044308:	e1a00230 	lsr	r0, r0, r2
3004430c:	e1800311 	orr	r0, r0, r1, lsl r3
30044310:	e1a01231 	lsr	r1, r1, r2
30044314:	e0844002 	add	r4, r4, r2
30044318:	eaffff37 	b	30043ffc <__adddf3+0xf0>

3004431c <__aeabi_dmul>:
3004431c:	e92d4070 	push	{r4, r5, r6, lr}
30044320:	e3a0c0ff 	mov	ip, #255	; 0xff
30044324:	e38ccc07 	orr	ip, ip, #1792	; 0x700
30044328:	e01c4a21 	ands	r4, ip, r1, lsr #20
3004432c:	101c5a23 	andsne	r5, ip, r3, lsr #20
30044330:	1134000c 	teqne	r4, ip
30044334:	1135000c 	teqne	r5, ip
30044338:	0b000075 	bleq	30044514 <__aeabi_dmul+0x1f8>
3004433c:	e0844005 	add	r4, r4, r5
30044340:	e0216003 	eor	r6, r1, r3
30044344:	e1c11a8c 	bic	r1, r1, ip, lsl #21
30044348:	e1c33a8c 	bic	r3, r3, ip, lsl #21
3004434c:	e1905601 	orrs	r5, r0, r1, lsl #12
30044350:	11925603 	orrsne	r5, r2, r3, lsl #12
30044354:	e3811601 	orr	r1, r1, #1048576	; 0x100000
30044358:	e3833601 	orr	r3, r3, #1048576	; 0x100000
3004435c:	0a00001d 	beq	300443d8 <__aeabi_dmul+0xbc>
30044360:	e08ec290 	umull	ip, lr, r0, r2
30044364:	e3a05000 	mov	r5, #0
30044368:	e0a5e291 	umlal	lr, r5, r1, r2
3004436c:	e2062102 	and	r2, r6, #-2147483648	; 0x80000000
30044370:	e0a5e390 	umlal	lr, r5, r0, r3
30044374:	e3a06000 	mov	r6, #0
30044378:	e0a65391 	umlal	r5, r6, r1, r3
3004437c:	e33c0000 	teq	ip, #0
30044380:	138ee001 	orrne	lr, lr, #1
30044384:	e24440ff 	sub	r4, r4, #255	; 0xff
30044388:	e3560c02 	cmp	r6, #512	; 0x200
3004438c:	e2c44c03 	sbc	r4, r4, #768	; 0x300
30044390:	2a000002 	bcs	300443a0 <__aeabi_dmul+0x84>
30044394:	e1b0e08e 	lsls	lr, lr, #1
30044398:	e0b55005 	adcs	r5, r5, r5
3004439c:	e0a66006 	adc	r6, r6, r6
300443a0:	e1821586 	orr	r1, r2, r6, lsl #11
300443a4:	e1811aa5 	orr	r1, r1, r5, lsr #21
300443a8:	e1a00585 	lsl	r0, r5, #11
300443ac:	e1800aae 	orr	r0, r0, lr, lsr #21
300443b0:	e1a0e58e 	lsl	lr, lr, #11
300443b4:	e254c0fd 	subs	ip, r4, #253	; 0xfd
300443b8:	835c0c07 	cmphi	ip, #1792	; 0x700
300443bc:	8a000011 	bhi	30044408 <__aeabi_dmul+0xec>
300443c0:	e35e0102 	cmp	lr, #-2147483648	; 0x80000000
300443c4:	01b0e0a0 	lsrseq	lr, r0, #1
300443c8:	e2b00000 	adcs	r0, r0, #0
300443cc:	e0a11a04 	adc	r1, r1, r4, lsl #20
300443d0:	e8bd4070 	pop	{r4, r5, r6, lr}
300443d4:	e12fff1e 	bx	lr
300443d8:	e2066102 	and	r6, r6, #-2147483648	; 0x80000000
300443dc:	e1861001 	orr	r1, r6, r1
300443e0:	e1800002 	orr	r0, r0, r2
300443e4:	e0211003 	eor	r1, r1, r3
300443e8:	e05440ac 	subs	r4, r4, ip, lsr #1
300443ec:	c074500c 	rsbsgt	r5, r4, ip
300443f0:	c1811a04 	orrgt	r1, r1, r4, lsl #20
300443f4:	c8bd4070 	popgt	{r4, r5, r6, lr}
300443f8:	c12fff1e 	bxgt	lr
300443fc:	e3811601 	orr	r1, r1, #1048576	; 0x100000
30044400:	e3a0e000 	mov	lr, #0
30044404:	e2544001 	subs	r4, r4, #1
30044408:	ca00005d 	bgt	30044584 <__aeabi_dmul+0x268>
3004440c:	e3740036 	cmn	r4, #54	; 0x36
30044410:	d3a00000 	movle	r0, #0
30044414:	d2011102 	andle	r1, r1, #-2147483648	; 0x80000000
30044418:	d8bd4070 	pople	{r4, r5, r6, lr}
3004441c:	d12fff1e 	bxle	lr
30044420:	e2644000 	rsb	r4, r4, #0
30044424:	e2544020 	subs	r4, r4, #32
30044428:	aa00001a 	bge	30044498 <__aeabi_dmul+0x17c>
3004442c:	e294400c 	adds	r4, r4, #12
30044430:	ca00000c 	bgt	30044468 <__aeabi_dmul+0x14c>
30044434:	e2844014 	add	r4, r4, #20
30044438:	e2645020 	rsb	r5, r4, #32
3004443c:	e1a03510 	lsl	r3, r0, r5
30044440:	e1a00430 	lsr	r0, r0, r4
30044444:	e1800511 	orr	r0, r0, r1, lsl r5
30044448:	e2012102 	and	r2, r1, #-2147483648	; 0x80000000
3004444c:	e3c11102 	bic	r1, r1, #-2147483648	; 0x80000000
30044450:	e0900fa3 	adds	r0, r0, r3, lsr #31
30044454:	e0a21431 	adc	r1, r2, r1, lsr r4
30044458:	e19ee083 	orrs	lr, lr, r3, lsl #1
3004445c:	01c00fa3 	biceq	r0, r0, r3, lsr #31
30044460:	e8bd4070 	pop	{r4, r5, r6, lr}
30044464:	e12fff1e 	bx	lr
30044468:	e264400c 	rsb	r4, r4, #12
3004446c:	e2645020 	rsb	r5, r4, #32
30044470:	e1a03410 	lsl	r3, r0, r4
30044474:	e1a00530 	lsr	r0, r0, r5
30044478:	e1800411 	orr	r0, r0, r1, lsl r4
3004447c:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
30044480:	e0900fa3 	adds	r0, r0, r3, lsr #31
30044484:	e2a11000 	adc	r1, r1, #0
30044488:	e19ee083 	orrs	lr, lr, r3, lsl #1
3004448c:	01c00fa3 	biceq	r0, r0, r3, lsr #31
30044490:	e8bd4070 	pop	{r4, r5, r6, lr}
30044494:	e12fff1e 	bx	lr
30044498:	e2645020 	rsb	r5, r4, #32
3004449c:	e18ee510 	orr	lr, lr, r0, lsl r5
300444a0:	e1a03430 	lsr	r3, r0, r4
300444a4:	e1833511 	orr	r3, r3, r1, lsl r5
300444a8:	e1a00431 	lsr	r0, r1, r4
300444ac:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
300444b0:	e1c00431 	bic	r0, r0, r1, lsr r4
300444b4:	e0800fa3 	add	r0, r0, r3, lsr #31
300444b8:	e19ee083 	orrs	lr, lr, r3, lsl #1
300444bc:	01c00fa3 	biceq	r0, r0, r3, lsr #31
300444c0:	e8bd4070 	pop	{r4, r5, r6, lr}
300444c4:	e12fff1e 	bx	lr
300444c8:	e3340000 	teq	r4, #0
300444cc:	1a000008 	bne	300444f4 <__aeabi_dmul+0x1d8>
300444d0:	e2016102 	and	r6, r1, #-2147483648	; 0x80000000
300444d4:	e1b00080 	lsls	r0, r0, #1
300444d8:	e0a11001 	adc	r1, r1, r1
300444dc:	e3110601 	tst	r1, #1048576	; 0x100000
300444e0:	02444001 	subeq	r4, r4, #1
300444e4:	0afffffa 	beq	300444d4 <__aeabi_dmul+0x1b8>
300444e8:	e1811006 	orr	r1, r1, r6
300444ec:	e3350000 	teq	r5, #0
300444f0:	112fff1e 	bxne	lr
300444f4:	e2036102 	and	r6, r3, #-2147483648	; 0x80000000
300444f8:	e1b02082 	lsls	r2, r2, #1
300444fc:	e0a33003 	adc	r3, r3, r3
30044500:	e3130601 	tst	r3, #1048576	; 0x100000
30044504:	02455001 	subeq	r5, r5, #1
30044508:	0afffffa 	beq	300444f8 <__aeabi_dmul+0x1dc>
3004450c:	e1833006 	orr	r3, r3, r6
30044510:	e12fff1e 	bx	lr
30044514:	e134000c 	teq	r4, ip
30044518:	e00c5a23 	and	r5, ip, r3, lsr #20
3004451c:	1135000c 	teqne	r5, ip
30044520:	0a000007 	beq	30044544 <__aeabi_dmul+0x228>
30044524:	e1906081 	orrs	r6, r0, r1, lsl #1
30044528:	11926083 	orrsne	r6, r2, r3, lsl #1
3004452c:	1affffe5 	bne	300444c8 <__aeabi_dmul+0x1ac>
30044530:	e0211003 	eor	r1, r1, r3
30044534:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
30044538:	e3a00000 	mov	r0, #0
3004453c:	e8bd4070 	pop	{r4, r5, r6, lr}
30044540:	e12fff1e 	bx	lr
30044544:	e1906081 	orrs	r6, r0, r1, lsl #1
30044548:	01a00002 	moveq	r0, r2
3004454c:	01a01003 	moveq	r1, r3
30044550:	11926083 	orrsne	r6, r2, r3, lsl #1
30044554:	0a000010 	beq	3004459c <__aeabi_dmul+0x280>
30044558:	e134000c 	teq	r4, ip
3004455c:	1a000001 	bne	30044568 <__aeabi_dmul+0x24c>
30044560:	e1906601 	orrs	r6, r0, r1, lsl #12
30044564:	1a00000c 	bne	3004459c <__aeabi_dmul+0x280>
30044568:	e135000c 	teq	r5, ip
3004456c:	1a000003 	bne	30044580 <__aeabi_dmul+0x264>
30044570:	e1926603 	orrs	r6, r2, r3, lsl #12
30044574:	11a00002 	movne	r0, r2
30044578:	11a01003 	movne	r1, r3
3004457c:	1a000006 	bne	3004459c <__aeabi_dmul+0x280>
30044580:	e0211003 	eor	r1, r1, r3
30044584:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
30044588:	e381147f 	orr	r1, r1, #2130706432	; 0x7f000000
3004458c:	e381160f 	orr	r1, r1, #15728640	; 0xf00000
30044590:	e3a00000 	mov	r0, #0
30044594:	e8bd4070 	pop	{r4, r5, r6, lr}
30044598:	e12fff1e 	bx	lr
3004459c:	e381147f 	orr	r1, r1, #2130706432	; 0x7f000000
300445a0:	e381173e 	orr	r1, r1, #16252928	; 0xf80000
300445a4:	e8bd4070 	pop	{r4, r5, r6, lr}
300445a8:	e12fff1e 	bx	lr

300445ac <__aeabi_ddiv>:
300445ac:	e92d4070 	push	{r4, r5, r6, lr}
300445b0:	e3a0c0ff 	mov	ip, #255	; 0xff
300445b4:	e38ccc07 	orr	ip, ip, #1792	; 0x700
300445b8:	e01c4a21 	ands	r4, ip, r1, lsr #20
300445bc:	101c5a23 	andsne	r5, ip, r3, lsr #20
300445c0:	1134000c 	teqne	r4, ip
300445c4:	1135000c 	teqne	r5, ip
300445c8:	0b00005e 	bleq	30044748 <__aeabi_ddiv+0x19c>
300445cc:	e0444005 	sub	r4, r4, r5
300445d0:	e021e003 	eor	lr, r1, r3
300445d4:	e1925603 	orrs	r5, r2, r3, lsl #12
300445d8:	e1a01601 	lsl	r1, r1, #12
300445dc:	0a00004c 	beq	30044714 <__aeabi_ddiv+0x168>
300445e0:	e1a03603 	lsl	r3, r3, #12
300445e4:	e3a05201 	mov	r5, #268435456	; 0x10000000
300445e8:	e1853223 	orr	r3, r5, r3, lsr #4
300445ec:	e1833c22 	orr	r3, r3, r2, lsr #24
300445f0:	e1a02402 	lsl	r2, r2, #8
300445f4:	e1855221 	orr	r5, r5, r1, lsr #4
300445f8:	e1855c20 	orr	r5, r5, r0, lsr #24
300445fc:	e1a06400 	lsl	r6, r0, #8
30044600:	e20e1102 	and	r1, lr, #-2147483648	; 0x80000000
30044604:	e1550003 	cmp	r5, r3
30044608:	01560002 	cmpeq	r6, r2
3004460c:	e2a440fd 	adc	r4, r4, #253	; 0xfd
30044610:	e2844c03 	add	r4, r4, #768	; 0x300
30044614:	2a000001 	bcs	30044620 <__aeabi_ddiv+0x74>
30044618:	e1b030a3 	lsrs	r3, r3, #1
3004461c:	e1a02062 	rrx	r2, r2
30044620:	e0566002 	subs	r6, r6, r2
30044624:	e0c55003 	sbc	r5, r5, r3
30044628:	e1b030a3 	lsrs	r3, r3, #1
3004462c:	e1a02062 	rrx	r2, r2
30044630:	e3a00601 	mov	r0, #1048576	; 0x100000
30044634:	e3a0c702 	mov	ip, #524288	; 0x80000
30044638:	e056e002 	subs	lr, r6, r2
3004463c:	e0d5e003 	sbcs	lr, r5, r3
30044640:	20466002 	subcs	r6, r6, r2
30044644:	21a0500e 	movcs	r5, lr
30044648:	2180000c 	orrcs	r0, r0, ip
3004464c:	e1b030a3 	lsrs	r3, r3, #1
30044650:	e1a02062 	rrx	r2, r2
30044654:	e056e002 	subs	lr, r6, r2
30044658:	e0d5e003 	sbcs	lr, r5, r3
3004465c:	20466002 	subcs	r6, r6, r2
30044660:	21a0500e 	movcs	r5, lr
30044664:	218000ac 	orrcs	r0, r0, ip, lsr #1
30044668:	e1b030a3 	lsrs	r3, r3, #1
3004466c:	e1a02062 	rrx	r2, r2
30044670:	e056e002 	subs	lr, r6, r2
30044674:	e0d5e003 	sbcs	lr, r5, r3
30044678:	20466002 	subcs	r6, r6, r2
3004467c:	21a0500e 	movcs	r5, lr
30044680:	2180012c 	orrcs	r0, r0, ip, lsr #2
30044684:	e1b030a3 	lsrs	r3, r3, #1
30044688:	e1a02062 	rrx	r2, r2
3004468c:	e056e002 	subs	lr, r6, r2
30044690:	e0d5e003 	sbcs	lr, r5, r3
30044694:	20466002 	subcs	r6, r6, r2
30044698:	21a0500e 	movcs	r5, lr
3004469c:	218001ac 	orrcs	r0, r0, ip, lsr #3
300446a0:	e195e006 	orrs	lr, r5, r6
300446a4:	0a00000d 	beq	300446e0 <__aeabi_ddiv+0x134>
300446a8:	e1a05205 	lsl	r5, r5, #4
300446ac:	e1855e26 	orr	r5, r5, r6, lsr #28
300446b0:	e1a06206 	lsl	r6, r6, #4
300446b4:	e1a03183 	lsl	r3, r3, #3
300446b8:	e1833ea2 	orr	r3, r3, r2, lsr #29
300446bc:	e1a02182 	lsl	r2, r2, #3
300446c0:	e1b0c22c 	lsrs	ip, ip, #4
300446c4:	1affffdb 	bne	30044638 <__aeabi_ddiv+0x8c>
300446c8:	e3110601 	tst	r1, #1048576	; 0x100000
300446cc:	1a000006 	bne	300446ec <__aeabi_ddiv+0x140>
300446d0:	e1811000 	orr	r1, r1, r0
300446d4:	e3a00000 	mov	r0, #0
300446d8:	e3a0c102 	mov	ip, #-2147483648	; 0x80000000
300446dc:	eaffffd5 	b	30044638 <__aeabi_ddiv+0x8c>
300446e0:	e3110601 	tst	r1, #1048576	; 0x100000
300446e4:	01811000 	orreq	r1, r1, r0
300446e8:	03a00000 	moveq	r0, #0
300446ec:	e254c0fd 	subs	ip, r4, #253	; 0xfd
300446f0:	835c0c07 	cmphi	ip, #1792	; 0x700
300446f4:	8affff43 	bhi	30044408 <__aeabi_dmul+0xec>
300446f8:	e055c003 	subs	ip, r5, r3
300446fc:	0056c002 	subseq	ip, r6, r2
30044700:	01b0c0a0 	lsrseq	ip, r0, #1
30044704:	e2b00000 	adcs	r0, r0, #0
30044708:	e0a11a04 	adc	r1, r1, r4, lsl #20
3004470c:	e8bd4070 	pop	{r4, r5, r6, lr}
30044710:	e12fff1e 	bx	lr
30044714:	e20ee102 	and	lr, lr, #-2147483648	; 0x80000000
30044718:	e18e1621 	orr	r1, lr, r1, lsr #12
3004471c:	e09440ac 	adds	r4, r4, ip, lsr #1
30044720:	c074500c 	rsbsgt	r5, r4, ip
30044724:	c1811a04 	orrgt	r1, r1, r4, lsl #20
30044728:	c8bd4070 	popgt	{r4, r5, r6, lr}
3004472c:	c12fff1e 	bxgt	lr
30044730:	e3811601 	orr	r1, r1, #1048576	; 0x100000
30044734:	e3a0e000 	mov	lr, #0
30044738:	e2544001 	subs	r4, r4, #1
3004473c:	eaffff31 	b	30044408 <__aeabi_dmul+0xec>
30044740:	e185e006 	orr	lr, r5, r6
30044744:	eaffff2f 	b	30044408 <__aeabi_dmul+0xec>
30044748:	e00c5a23 	and	r5, ip, r3, lsr #20
3004474c:	e134000c 	teq	r4, ip
30044750:	0135000c 	teqeq	r5, ip
30044754:	0affff90 	beq	3004459c <__aeabi_dmul+0x280>
30044758:	e134000c 	teq	r4, ip
3004475c:	1a000006 	bne	3004477c <__aeabi_ddiv+0x1d0>
30044760:	e1904601 	orrs	r4, r0, r1, lsl #12
30044764:	1affff8c 	bne	3004459c <__aeabi_dmul+0x280>
30044768:	e135000c 	teq	r5, ip
3004476c:	1affff83 	bne	30044580 <__aeabi_dmul+0x264>
30044770:	e1a00002 	mov	r0, r2
30044774:	e1a01003 	mov	r1, r3
30044778:	eaffff87 	b	3004459c <__aeabi_dmul+0x280>
3004477c:	e135000c 	teq	r5, ip
30044780:	1a000004 	bne	30044798 <__aeabi_ddiv+0x1ec>
30044784:	e1925603 	orrs	r5, r2, r3, lsl #12
30044788:	0affff68 	beq	30044530 <__aeabi_dmul+0x214>
3004478c:	e1a00002 	mov	r0, r2
30044790:	e1a01003 	mov	r1, r3
30044794:	eaffff80 	b	3004459c <__aeabi_dmul+0x280>
30044798:	e1906081 	orrs	r6, r0, r1, lsl #1
3004479c:	11926083 	orrsne	r6, r2, r3, lsl #1
300447a0:	1affff48 	bne	300444c8 <__aeabi_dmul+0x1ac>
300447a4:	e1904081 	orrs	r4, r0, r1, lsl #1
300447a8:	1affff74 	bne	30044580 <__aeabi_dmul+0x264>
300447ac:	e1925083 	orrs	r5, r2, r3, lsl #1
300447b0:	1affff5e 	bne	30044530 <__aeabi_dmul+0x214>
300447b4:	eaffff78 	b	3004459c <__aeabi_dmul+0x280>

300447b8 <__gedf2>:
300447b8:	e3e0c000 	mvn	ip, #0
300447bc:	ea000002 	b	300447cc <__cmpdf2+0x4>

300447c0 <__ledf2>:
300447c0:	e3a0c001 	mov	ip, #1
300447c4:	ea000000 	b	300447cc <__cmpdf2+0x4>

300447c8 <__cmpdf2>:
300447c8:	e3a0c001 	mov	ip, #1
300447cc:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
300447d0:	e1a0c081 	lsl	ip, r1, #1
300447d4:	e1f0cacc 	mvns	ip, ip, asr #21
300447d8:	e1a0c083 	lsl	ip, r3, #1
300447dc:	11f0cacc 	mvnsne	ip, ip, asr #21
300447e0:	0a00000e 	beq	30044820 <__cmpdf2+0x58>
300447e4:	e28dd004 	add	sp, sp, #4
300447e8:	e190c081 	orrs	ip, r0, r1, lsl #1
300447ec:	0192c083 	orrseq	ip, r2, r3, lsl #1
300447f0:	11310003 	teqne	r1, r3
300447f4:	01300002 	teqeq	r0, r2
300447f8:	03a00000 	moveq	r0, #0
300447fc:	012fff1e 	bxeq	lr
30044800:	e3700000 	cmn	r0, #0
30044804:	e1310003 	teq	r1, r3
30044808:	51510003 	cmppl	r1, r3
3004480c:	01500002 	cmpeq	r0, r2
30044810:	21a00fc3 	asrcs	r0, r3, #31
30044814:	31e00fc3 	mvncc	r0, r3, asr #31
30044818:	e3800001 	orr	r0, r0, #1
3004481c:	e12fff1e 	bx	lr
30044820:	e1a0c081 	lsl	ip, r1, #1
30044824:	e1f0cacc 	mvns	ip, ip, asr #21
30044828:	1a000001 	bne	30044834 <__cmpdf2+0x6c>
3004482c:	e190c601 	orrs	ip, r0, r1, lsl #12
30044830:	1a000004 	bne	30044848 <__cmpdf2+0x80>
30044834:	e1a0c083 	lsl	ip, r3, #1
30044838:	e1f0cacc 	mvns	ip, ip, asr #21
3004483c:	1affffe8 	bne	300447e4 <__cmpdf2+0x1c>
30044840:	e192c603 	orrs	ip, r2, r3, lsl #12
30044844:	0affffe6 	beq	300447e4 <__cmpdf2+0x1c>
30044848:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
3004484c:	e12fff1e 	bx	lr

30044850 <__aeabi_cdrcmple>:
30044850:	e1a0c000 	mov	ip, r0
30044854:	e1a00002 	mov	r0, r2
30044858:	e1a0200c 	mov	r2, ip
3004485c:	e1a0c001 	mov	ip, r1
30044860:	e1a01003 	mov	r1, r3
30044864:	e1a0300c 	mov	r3, ip
30044868:	eaffffff 	b	3004486c <__aeabi_cdcmpeq>

3004486c <__aeabi_cdcmpeq>:
3004486c:	e92d4001 	push	{r0, lr}
30044870:	ebffffd4 	bl	300447c8 <__cmpdf2>
30044874:	e3500000 	cmp	r0, #0
30044878:	43700000 	cmnmi	r0, #0
3004487c:	e8bd4001 	pop	{r0, lr}
30044880:	e12fff1e 	bx	lr

30044884 <__aeabi_dcmpeq>:
30044884:	e52de008 	str	lr, [sp, #-8]!
30044888:	ebfffff7 	bl	3004486c <__aeabi_cdcmpeq>
3004488c:	03a00001 	moveq	r0, #1
30044890:	13a00000 	movne	r0, #0
30044894:	e49de008 	ldr	lr, [sp], #8
30044898:	e12fff1e 	bx	lr

3004489c <__aeabi_dcmplt>:
3004489c:	e52de008 	str	lr, [sp, #-8]!
300448a0:	ebfffff1 	bl	3004486c <__aeabi_cdcmpeq>
300448a4:	33a00001 	movcc	r0, #1
300448a8:	23a00000 	movcs	r0, #0
300448ac:	e49de008 	ldr	lr, [sp], #8
300448b0:	e12fff1e 	bx	lr

300448b4 <__aeabi_dcmple>:
300448b4:	e52de008 	str	lr, [sp, #-8]!
300448b8:	ebffffeb 	bl	3004486c <__aeabi_cdcmpeq>
300448bc:	93a00001 	movls	r0, #1
300448c0:	83a00000 	movhi	r0, #0
300448c4:	e49de008 	ldr	lr, [sp], #8
300448c8:	e12fff1e 	bx	lr

300448cc <__aeabi_dcmpge>:
300448cc:	e52de008 	str	lr, [sp, #-8]!
300448d0:	ebffffde 	bl	30044850 <__aeabi_cdrcmple>
300448d4:	93a00001 	movls	r0, #1
300448d8:	83a00000 	movhi	r0, #0
300448dc:	e49de008 	ldr	lr, [sp], #8
300448e0:	e12fff1e 	bx	lr

300448e4 <__aeabi_dcmpgt>:
300448e4:	e52de008 	str	lr, [sp, #-8]!
300448e8:	ebffffd8 	bl	30044850 <__aeabi_cdrcmple>
300448ec:	33a00001 	movcc	r0, #1
300448f0:	23a00000 	movcs	r0, #0
300448f4:	e49de008 	ldr	lr, [sp], #8
300448f8:	e12fff1e 	bx	lr

300448fc <__aeabi_d2iz>:
300448fc:	e1a02081 	lsl	r2, r1, #1
30044900:	e2922602 	adds	r2, r2, #2097152	; 0x200000
30044904:	2a00000c 	bcs	3004493c <__aeabi_d2iz+0x40>
30044908:	5a000009 	bpl	30044934 <__aeabi_d2iz+0x38>
3004490c:	e3e03e3e 	mvn	r3, #992	; 0x3e0
30044910:	e0532ac2 	subs	r2, r3, r2, asr #21
30044914:	9a00000a 	bls	30044944 <__aeabi_d2iz+0x48>
30044918:	e1a03581 	lsl	r3, r1, #11
3004491c:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
30044920:	e1833aa0 	orr	r3, r3, r0, lsr #21
30044924:	e3110102 	tst	r1, #-2147483648	; 0x80000000
30044928:	e1a00233 	lsr	r0, r3, r2
3004492c:	12600000 	rsbne	r0, r0, #0
30044930:	e12fff1e 	bx	lr
30044934:	e3a00000 	mov	r0, #0
30044938:	e12fff1e 	bx	lr
3004493c:	e1900601 	orrs	r0, r0, r1, lsl #12
30044940:	1a000002 	bne	30044950 <__aeabi_d2iz+0x54>
30044944:	e2110102 	ands	r0, r1, #-2147483648	; 0x80000000
30044948:	03e00102 	mvneq	r0, #-2147483648	; 0x80000000
3004494c:	e12fff1e 	bx	lr
30044950:	e3a00000 	mov	r0, #0
30044954:	e12fff1e 	bx	lr

30044958 <__aeabi_d2uiz>:
30044958:	e1b02081 	lsls	r2, r1, #1
3004495c:	2a00000a 	bcs	3004498c <__aeabi_d2uiz+0x34>
30044960:	e2922602 	adds	r2, r2, #2097152	; 0x200000
30044964:	2a00000a 	bcs	30044994 <__aeabi_d2uiz+0x3c>
30044968:	5a000007 	bpl	3004498c <__aeabi_d2uiz+0x34>
3004496c:	e3e03e3e 	mvn	r3, #992	; 0x3e0
30044970:	e0532ac2 	subs	r2, r3, r2, asr #21
30044974:	4a000008 	bmi	3004499c <__aeabi_d2uiz+0x44>
30044978:	e1a03581 	lsl	r3, r1, #11
3004497c:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
30044980:	e1833aa0 	orr	r3, r3, r0, lsr #21
30044984:	e1a00233 	lsr	r0, r3, r2
30044988:	e12fff1e 	bx	lr
3004498c:	e3a00000 	mov	r0, #0
30044990:	e12fff1e 	bx	lr
30044994:	e1900601 	orrs	r0, r0, r1, lsl #12
30044998:	1a000001 	bne	300449a4 <__aeabi_d2uiz+0x4c>
3004499c:	e3e00000 	mvn	r0, #0
300449a0:	e12fff1e 	bx	lr
300449a4:	e3a00000 	mov	r0, #0
300449a8:	e12fff1e 	bx	lr

300449ac <__aeabi_frsub>:
300449ac:	e2200102 	eor	r0, r0, #-2147483648	; 0x80000000
300449b0:	ea000000 	b	300449b8 <__addsf3>

300449b4 <__aeabi_fsub>:
300449b4:	e2211102 	eor	r1, r1, #-2147483648	; 0x80000000

300449b8 <__addsf3>:
300449b8:	e1b02080 	lsls	r2, r0, #1
300449bc:	11b03081 	lslsne	r3, r1, #1
300449c0:	11320003 	teqne	r2, r3
300449c4:	11f0cc42 	mvnsne	ip, r2, asr #24
300449c8:	11f0cc43 	mvnsne	ip, r3, asr #24
300449cc:	0a000047 	beq	30044af0 <__addsf3+0x138>
300449d0:	e1a02c22 	lsr	r2, r2, #24
300449d4:	e0723c23 	rsbs	r3, r2, r3, lsr #24
300449d8:	c0822003 	addgt	r2, r2, r3
300449dc:	c0201001 	eorgt	r1, r0, r1
300449e0:	c0210000 	eorgt	r0, r1, r0
300449e4:	c0201001 	eorgt	r1, r0, r1
300449e8:	b2633000 	rsblt	r3, r3, #0
300449ec:	e3530019 	cmp	r3, #25
300449f0:	812fff1e 	bxhi	lr
300449f4:	e3100102 	tst	r0, #-2147483648	; 0x80000000
300449f8:	e3800502 	orr	r0, r0, #8388608	; 0x800000
300449fc:	e3c004ff 	bic	r0, r0, #-16777216	; 0xff000000
30044a00:	12600000 	rsbne	r0, r0, #0
30044a04:	e3110102 	tst	r1, #-2147483648	; 0x80000000
30044a08:	e3811502 	orr	r1, r1, #8388608	; 0x800000
30044a0c:	e3c114ff 	bic	r1, r1, #-16777216	; 0xff000000
30044a10:	12611000 	rsbne	r1, r1, #0
30044a14:	e1320003 	teq	r2, r3
30044a18:	0a00002e 	beq	30044ad8 <__addsf3+0x120>
30044a1c:	e2422001 	sub	r2, r2, #1
30044a20:	e0900351 	adds	r0, r0, r1, asr r3
30044a24:	e2633020 	rsb	r3, r3, #32
30044a28:	e1a01311 	lsl	r1, r1, r3
30044a2c:	e2003102 	and	r3, r0, #-2147483648	; 0x80000000
30044a30:	5a000001 	bpl	30044a3c <__addsf3+0x84>
30044a34:	e2711000 	rsbs	r1, r1, #0
30044a38:	e2e00000 	rsc	r0, r0, #0
30044a3c:	e3500502 	cmp	r0, #8388608	; 0x800000
30044a40:	3a00000b 	bcc	30044a74 <__addsf3+0xbc>
30044a44:	e3500401 	cmp	r0, #16777216	; 0x1000000
30044a48:	3a000004 	bcc	30044a60 <__addsf3+0xa8>
30044a4c:	e1b000a0 	lsrs	r0, r0, #1
30044a50:	e1a01061 	rrx	r1, r1
30044a54:	e2822001 	add	r2, r2, #1
30044a58:	e35200fe 	cmp	r2, #254	; 0xfe
30044a5c:	2a000038 	bcs	30044b44 <__addsf3+0x18c>
30044a60:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
30044a64:	e0a00b82 	adc	r0, r0, r2, lsl #23
30044a68:	03c00001 	biceq	r0, r0, #1
30044a6c:	e1800003 	orr	r0, r0, r3
30044a70:	e12fff1e 	bx	lr
30044a74:	e1b01081 	lsls	r1, r1, #1
30044a78:	e0a00000 	adc	r0, r0, r0
30044a7c:	e3100502 	tst	r0, #8388608	; 0x800000
30044a80:	e2422001 	sub	r2, r2, #1
30044a84:	1afffff5 	bne	30044a60 <__addsf3+0xa8>
30044a88:	e1b0c620 	lsrs	ip, r0, #12
30044a8c:	01a00600 	lsleq	r0, r0, #12
30044a90:	0242200c 	subeq	r2, r2, #12
30044a94:	e31008ff 	tst	r0, #16711680	; 0xff0000
30044a98:	01a00400 	lsleq	r0, r0, #8
30044a9c:	02422008 	subeq	r2, r2, #8
30044aa0:	e310060f 	tst	r0, #15728640	; 0xf00000
30044aa4:	01a00200 	lsleq	r0, r0, #4
30044aa8:	02422004 	subeq	r2, r2, #4
30044aac:	e3100503 	tst	r0, #12582912	; 0xc00000
30044ab0:	01a00100 	lsleq	r0, r0, #2
30044ab4:	02422002 	subeq	r2, r2, #2
30044ab8:	e3500502 	cmp	r0, #8388608	; 0x800000
30044abc:	31a00080 	lslcc	r0, r0, #1
30044ac0:	e2d22000 	sbcs	r2, r2, #0
30044ac4:	a0800b82 	addge	r0, r0, r2, lsl #23
30044ac8:	b2622000 	rsblt	r2, r2, #0
30044acc:	a1800003 	orrge	r0, r0, r3
30044ad0:	b1830230 	orrlt	r0, r3, r0, lsr r2
30044ad4:	e12fff1e 	bx	lr
30044ad8:	e3320000 	teq	r2, #0
30044adc:	e2211502 	eor	r1, r1, #8388608	; 0x800000
30044ae0:	02200502 	eoreq	r0, r0, #8388608	; 0x800000
30044ae4:	02822001 	addeq	r2, r2, #1
30044ae8:	12433001 	subne	r3, r3, #1
30044aec:	eaffffca 	b	30044a1c <__addsf3+0x64>
30044af0:	e1a03081 	lsl	r3, r1, #1
30044af4:	e1f0cc42 	mvns	ip, r2, asr #24
30044af8:	11f0cc43 	mvnsne	ip, r3, asr #24
30044afc:	0a000013 	beq	30044b50 <__addsf3+0x198>
30044b00:	e1320003 	teq	r2, r3
30044b04:	0a000002 	beq	30044b14 <__addsf3+0x15c>
30044b08:	e3320000 	teq	r2, #0
30044b0c:	01a00001 	moveq	r0, r1
30044b10:	e12fff1e 	bx	lr
30044b14:	e1300001 	teq	r0, r1
30044b18:	13a00000 	movne	r0, #0
30044b1c:	112fff1e 	bxne	lr
30044b20:	e31204ff 	tst	r2, #-16777216	; 0xff000000
30044b24:	1a000002 	bne	30044b34 <__addsf3+0x17c>
30044b28:	e1b00080 	lsls	r0, r0, #1
30044b2c:	23800102 	orrcs	r0, r0, #-2147483648	; 0x80000000
30044b30:	e12fff1e 	bx	lr
30044b34:	e2922402 	adds	r2, r2, #33554432	; 0x2000000
30044b38:	32800502 	addcc	r0, r0, #8388608	; 0x800000
30044b3c:	312fff1e 	bxcc	lr
30044b40:	e2003102 	and	r3, r0, #-2147483648	; 0x80000000
30044b44:	e383047f 	orr	r0, r3, #2130706432	; 0x7f000000
30044b48:	e3800502 	orr	r0, r0, #8388608	; 0x800000
30044b4c:	e12fff1e 	bx	lr
30044b50:	e1f02c42 	mvns	r2, r2, asr #24
30044b54:	11a00001 	movne	r0, r1
30044b58:	01f03c43 	mvnseq	r3, r3, asr #24
30044b5c:	11a01000 	movne	r1, r0
30044b60:	e1b02480 	lsls	r2, r0, #9
30044b64:	01b03481 	lslseq	r3, r1, #9
30044b68:	01300001 	teqeq	r0, r1
30044b6c:	13800501 	orrne	r0, r0, #4194304	; 0x400000
30044b70:	e12fff1e 	bx	lr

30044b74 <__aeabi_ui2f>:
30044b74:	e3a03000 	mov	r3, #0
30044b78:	ea000001 	b	30044b84 <__aeabi_i2f+0x8>

30044b7c <__aeabi_i2f>:
30044b7c:	e2103102 	ands	r3, r0, #-2147483648	; 0x80000000
30044b80:	42600000 	rsbmi	r0, r0, #0
30044b84:	e1b0c000 	movs	ip, r0
30044b88:	012fff1e 	bxeq	lr
30044b8c:	e383344b 	orr	r3, r3, #1258291200	; 0x4b000000
30044b90:	e1a01000 	mov	r1, r0
30044b94:	e3a00000 	mov	r0, #0
30044b98:	ea00000f 	b	30044bdc <__aeabi_l2f+0x30>

30044b9c <__aeabi_ul2f>:
30044b9c:	e1902001 	orrs	r2, r0, r1
30044ba0:	012fff1e 	bxeq	lr
30044ba4:	e3a03000 	mov	r3, #0
30044ba8:	ea000005 	b	30044bc4 <__aeabi_l2f+0x18>

30044bac <__aeabi_l2f>:
30044bac:	e1902001 	orrs	r2, r0, r1
30044bb0:	012fff1e 	bxeq	lr
30044bb4:	e2113102 	ands	r3, r1, #-2147483648	; 0x80000000
30044bb8:	5a000001 	bpl	30044bc4 <__aeabi_l2f+0x18>
30044bbc:	e2700000 	rsbs	r0, r0, #0
30044bc0:	e2e11000 	rsc	r1, r1, #0
30044bc4:	e1b0c001 	movs	ip, r1
30044bc8:	01a0c000 	moveq	ip, r0
30044bcc:	01a01000 	moveq	r1, r0
30044bd0:	03a00000 	moveq	r0, #0
30044bd4:	e383345b 	orr	r3, r3, #1526726656	; 0x5b000000
30044bd8:	02433201 	subeq	r3, r3, #268435456	; 0x10000000
30044bdc:	e2433502 	sub	r3, r3, #8388608	; 0x800000
30044be0:	e3a02017 	mov	r2, #23
30044be4:	e35c0801 	cmp	ip, #65536	; 0x10000
30044be8:	21a0c82c 	lsrcs	ip, ip, #16
30044bec:	22422010 	subcs	r2, r2, #16
30044bf0:	e35c0c01 	cmp	ip, #256	; 0x100
30044bf4:	21a0c42c 	lsrcs	ip, ip, #8
30044bf8:	22422008 	subcs	r2, r2, #8
30044bfc:	e35c0010 	cmp	ip, #16
30044c00:	21a0c22c 	lsrcs	ip, ip, #4
30044c04:	22422004 	subcs	r2, r2, #4
30044c08:	e35c0004 	cmp	ip, #4
30044c0c:	22422002 	subcs	r2, r2, #2
30044c10:	304220ac 	subcc	r2, r2, ip, lsr #1
30044c14:	e05221ac 	subs	r2, r2, ip, lsr #3
30044c18:	e0433b82 	sub	r3, r3, r2, lsl #23
30044c1c:	ba000006 	blt	30044c3c <__aeabi_l2f+0x90>
30044c20:	e0833211 	add	r3, r3, r1, lsl r2
30044c24:	e1a0c210 	lsl	ip, r0, r2
30044c28:	e2622020 	rsb	r2, r2, #32
30044c2c:	e35c0102 	cmp	ip, #-2147483648	; 0x80000000
30044c30:	e0a30230 	adc	r0, r3, r0, lsr r2
30044c34:	03c00001 	biceq	r0, r0, #1
30044c38:	e12fff1e 	bx	lr
30044c3c:	e2822020 	add	r2, r2, #32
30044c40:	e1a0c211 	lsl	ip, r1, r2
30044c44:	e2622020 	rsb	r2, r2, #32
30044c48:	e190008c 	orrs	r0, r0, ip, lsl #1
30044c4c:	e0a30231 	adc	r0, r3, r1, lsr r2
30044c50:	01c00fac 	biceq	r0, r0, ip, lsr #31
30044c54:	e12fff1e 	bx	lr

30044c58 <__aeabi_fmul>:
30044c58:	e3a0c0ff 	mov	ip, #255	; 0xff
30044c5c:	e01c2ba0 	ands	r2, ip, r0, lsr #23
30044c60:	101c3ba1 	andsne	r3, ip, r1, lsr #23
30044c64:	1132000c 	teqne	r2, ip
30044c68:	1133000c 	teqne	r3, ip
30044c6c:	0a00003e 	beq	30044d6c <__aeabi_fmul+0x114>
30044c70:	e0822003 	add	r2, r2, r3
30044c74:	e020c001 	eor	ip, r0, r1
30044c78:	e1b00480 	lsls	r0, r0, #9
30044c7c:	11b01481 	lslsne	r1, r1, #9
30044c80:	0a000010 	beq	30044cc8 <__aeabi_fmul+0x70>
30044c84:	e3a03302 	mov	r3, #134217728	; 0x8000000
30044c88:	e18302a0 	orr	r0, r3, r0, lsr #5
30044c8c:	e18312a1 	orr	r1, r3, r1, lsr #5
30044c90:	e0813190 	umull	r3, r1, r0, r1
30044c94:	e20c0102 	and	r0, ip, #-2147483648	; 0x80000000
30044c98:	e3510502 	cmp	r1, #8388608	; 0x800000
30044c9c:	31a01081 	lslcc	r1, r1, #1
30044ca0:	31811fa3 	orrcc	r1, r1, r3, lsr #31
30044ca4:	31a03083 	lslcc	r3, r3, #1
30044ca8:	e1800001 	orr	r0, r0, r1
30044cac:	e2c2207f 	sbc	r2, r2, #127	; 0x7f
30044cb0:	e35200fd 	cmp	r2, #253	; 0xfd
30044cb4:	8a00000f 	bhi	30044cf8 <__aeabi_fmul+0xa0>
30044cb8:	e3530102 	cmp	r3, #-2147483648	; 0x80000000
30044cbc:	e0a00b82 	adc	r0, r0, r2, lsl #23
30044cc0:	03c00001 	biceq	r0, r0, #1
30044cc4:	e12fff1e 	bx	lr
30044cc8:	e3300000 	teq	r0, #0
30044ccc:	e20cc102 	and	ip, ip, #-2147483648	; 0x80000000
30044cd0:	01a01481 	lsleq	r1, r1, #9
30044cd4:	e18c04a0 	orr	r0, ip, r0, lsr #9
30044cd8:	e18004a1 	orr	r0, r0, r1, lsr #9
30044cdc:	e252207f 	subs	r2, r2, #127	; 0x7f
30044ce0:	c27230ff 	rsbsgt	r3, r2, #255	; 0xff
30044ce4:	c1800b82 	orrgt	r0, r0, r2, lsl #23
30044ce8:	c12fff1e 	bxgt	lr
30044cec:	e3800502 	orr	r0, r0, #8388608	; 0x800000
30044cf0:	e3a03000 	mov	r3, #0
30044cf4:	e2522001 	subs	r2, r2, #1
30044cf8:	ca000035 	bgt	30044dd4 <__aeabi_fmul+0x17c>
30044cfc:	e3720019 	cmn	r2, #25
30044d00:	d2000102 	andle	r0, r0, #-2147483648	; 0x80000000
30044d04:	d12fff1e 	bxle	lr
30044d08:	e2622000 	rsb	r2, r2, #0
30044d0c:	e1b01080 	lsls	r1, r0, #1
30044d10:	e1a01231 	lsr	r1, r1, r2
30044d14:	e2622020 	rsb	r2, r2, #32
30044d18:	e1a0c210 	lsl	ip, r0, r2
30044d1c:	e1b00061 	rrxs	r0, r1
30044d20:	e2a00000 	adc	r0, r0, #0
30044d24:	e193308c 	orrs	r3, r3, ip, lsl #1
30044d28:	01c00fac 	biceq	r0, r0, ip, lsr #31
30044d2c:	e12fff1e 	bx	lr
30044d30:	e3320000 	teq	r2, #0
30044d34:	e200c102 	and	ip, r0, #-2147483648	; 0x80000000
30044d38:	01a00080 	lsleq	r0, r0, #1
30044d3c:	03100502 	tsteq	r0, #8388608	; 0x800000
30044d40:	02422001 	subeq	r2, r2, #1
30044d44:	0afffffb 	beq	30044d38 <__aeabi_fmul+0xe0>
30044d48:	e180000c 	orr	r0, r0, ip
30044d4c:	e3330000 	teq	r3, #0
30044d50:	e201c102 	and	ip, r1, #-2147483648	; 0x80000000
30044d54:	01a01081 	lsleq	r1, r1, #1
30044d58:	03110502 	tsteq	r1, #8388608	; 0x800000
30044d5c:	02433001 	subeq	r3, r3, #1
30044d60:	0afffffb 	beq	30044d54 <__aeabi_fmul+0xfc>
30044d64:	e181100c 	orr	r1, r1, ip
30044d68:	eaffffc0 	b	30044c70 <__aeabi_fmul+0x18>
30044d6c:	e00c3ba1 	and	r3, ip, r1, lsr #23
30044d70:	e132000c 	teq	r2, ip
30044d74:	1133000c 	teqne	r3, ip
30044d78:	0a000005 	beq	30044d94 <__aeabi_fmul+0x13c>
30044d7c:	e3d0c102 	bics	ip, r0, #-2147483648	; 0x80000000
30044d80:	13d1c102 	bicsne	ip, r1, #-2147483648	; 0x80000000
30044d84:	1affffe9 	bne	30044d30 <__aeabi_fmul+0xd8>
30044d88:	e0200001 	eor	r0, r0, r1
30044d8c:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
30044d90:	e12fff1e 	bx	lr
30044d94:	e3300000 	teq	r0, #0
30044d98:	13300102 	teqne	r0, #-2147483648	; 0x80000000
30044d9c:	01a00001 	moveq	r0, r1
30044da0:	13310000 	teqne	r1, #0
30044da4:	13310102 	teqne	r1, #-2147483648	; 0x80000000
30044da8:	0a00000d 	beq	30044de4 <__aeabi_fmul+0x18c>
30044dac:	e132000c 	teq	r2, ip
30044db0:	1a000001 	bne	30044dbc <__aeabi_fmul+0x164>
30044db4:	e1b02480 	lsls	r2, r0, #9
30044db8:	1a000009 	bne	30044de4 <__aeabi_fmul+0x18c>
30044dbc:	e133000c 	teq	r3, ip
30044dc0:	1a000002 	bne	30044dd0 <__aeabi_fmul+0x178>
30044dc4:	e1b03481 	lsls	r3, r1, #9
30044dc8:	11a00001 	movne	r0, r1
30044dcc:	1a000004 	bne	30044de4 <__aeabi_fmul+0x18c>
30044dd0:	e0200001 	eor	r0, r0, r1
30044dd4:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
30044dd8:	e380047f 	orr	r0, r0, #2130706432	; 0x7f000000
30044ddc:	e3800502 	orr	r0, r0, #8388608	; 0x800000
30044de0:	e12fff1e 	bx	lr
30044de4:	e380047f 	orr	r0, r0, #2130706432	; 0x7f000000
30044de8:	e3800503 	orr	r0, r0, #12582912	; 0xc00000
30044dec:	e12fff1e 	bx	lr

30044df0 <__aeabi_fdiv>:
30044df0:	e3a0c0ff 	mov	ip, #255	; 0xff
30044df4:	e01c2ba0 	ands	r2, ip, r0, lsr #23
30044df8:	101c3ba1 	andsne	r3, ip, r1, lsr #23
30044dfc:	1132000c 	teqne	r2, ip
30044e00:	1133000c 	teqne	r3, ip
30044e04:	0a00003a 	beq	30044ef4 <__aeabi_fdiv+0x104>
30044e08:	e0422003 	sub	r2, r2, r3
30044e0c:	e020c001 	eor	ip, r0, r1
30044e10:	e1b01481 	lsls	r1, r1, #9
30044e14:	e1a00480 	lsl	r0, r0, #9
30044e18:	0a00001c 	beq	30044e90 <__aeabi_fdiv+0xa0>
30044e1c:	e3a03201 	mov	r3, #268435456	; 0x10000000
30044e20:	e1831221 	orr	r1, r3, r1, lsr #4
30044e24:	e1833220 	orr	r3, r3, r0, lsr #4
30044e28:	e20c0102 	and	r0, ip, #-2147483648	; 0x80000000
30044e2c:	e1530001 	cmp	r3, r1
30044e30:	31a03083 	lslcc	r3, r3, #1
30044e34:	e2a2207d 	adc	r2, r2, #125	; 0x7d
30044e38:	e3a0c502 	mov	ip, #8388608	; 0x800000
30044e3c:	e1530001 	cmp	r3, r1
30044e40:	20433001 	subcs	r3, r3, r1
30044e44:	2180000c 	orrcs	r0, r0, ip
30044e48:	e15300a1 	cmp	r3, r1, lsr #1
30044e4c:	204330a1 	subcs	r3, r3, r1, lsr #1
30044e50:	218000ac 	orrcs	r0, r0, ip, lsr #1
30044e54:	e1530121 	cmp	r3, r1, lsr #2
30044e58:	20433121 	subcs	r3, r3, r1, lsr #2
30044e5c:	2180012c 	orrcs	r0, r0, ip, lsr #2
30044e60:	e15301a1 	cmp	r3, r1, lsr #3
30044e64:	204331a1 	subcs	r3, r3, r1, lsr #3
30044e68:	218001ac 	orrcs	r0, r0, ip, lsr #3
30044e6c:	e1b03203 	lsls	r3, r3, #4
30044e70:	11b0c22c 	lsrsne	ip, ip, #4
30044e74:	1afffff0 	bne	30044e3c <__aeabi_fdiv+0x4c>
30044e78:	e35200fd 	cmp	r2, #253	; 0xfd
30044e7c:	8affff9d 	bhi	30044cf8 <__aeabi_fmul+0xa0>
30044e80:	e1530001 	cmp	r3, r1
30044e84:	e0a00b82 	adc	r0, r0, r2, lsl #23
30044e88:	03c00001 	biceq	r0, r0, #1
30044e8c:	e12fff1e 	bx	lr
30044e90:	e20cc102 	and	ip, ip, #-2147483648	; 0x80000000
30044e94:	e18c04a0 	orr	r0, ip, r0, lsr #9
30044e98:	e292207f 	adds	r2, r2, #127	; 0x7f
30044e9c:	c27230ff 	rsbsgt	r3, r2, #255	; 0xff
30044ea0:	c1800b82 	orrgt	r0, r0, r2, lsl #23
30044ea4:	c12fff1e 	bxgt	lr
30044ea8:	e3800502 	orr	r0, r0, #8388608	; 0x800000
30044eac:	e3a03000 	mov	r3, #0
30044eb0:	e2522001 	subs	r2, r2, #1
30044eb4:	eaffff8f 	b	30044cf8 <__aeabi_fmul+0xa0>
30044eb8:	e3320000 	teq	r2, #0
30044ebc:	e200c102 	and	ip, r0, #-2147483648	; 0x80000000
30044ec0:	01a00080 	lsleq	r0, r0, #1
30044ec4:	03100502 	tsteq	r0, #8388608	; 0x800000
30044ec8:	02422001 	subeq	r2, r2, #1
30044ecc:	0afffffb 	beq	30044ec0 <__aeabi_fdiv+0xd0>
30044ed0:	e180000c 	orr	r0, r0, ip
30044ed4:	e3330000 	teq	r3, #0
30044ed8:	e201c102 	and	ip, r1, #-2147483648	; 0x80000000
30044edc:	01a01081 	lsleq	r1, r1, #1
30044ee0:	03110502 	tsteq	r1, #8388608	; 0x800000
30044ee4:	02433001 	subeq	r3, r3, #1
30044ee8:	0afffffb 	beq	30044edc <__aeabi_fdiv+0xec>
30044eec:	e181100c 	orr	r1, r1, ip
30044ef0:	eaffffc4 	b	30044e08 <__aeabi_fdiv+0x18>
30044ef4:	e00c3ba1 	and	r3, ip, r1, lsr #23
30044ef8:	e132000c 	teq	r2, ip
30044efc:	1a000005 	bne	30044f18 <__aeabi_fdiv+0x128>
30044f00:	e1b02480 	lsls	r2, r0, #9
30044f04:	1affffb6 	bne	30044de4 <__aeabi_fmul+0x18c>
30044f08:	e133000c 	teq	r3, ip
30044f0c:	1affffaf 	bne	30044dd0 <__aeabi_fmul+0x178>
30044f10:	e1a00001 	mov	r0, r1
30044f14:	eaffffb2 	b	30044de4 <__aeabi_fmul+0x18c>
30044f18:	e133000c 	teq	r3, ip
30044f1c:	1a000003 	bne	30044f30 <__aeabi_fdiv+0x140>
30044f20:	e1b03481 	lsls	r3, r1, #9
30044f24:	0affff97 	beq	30044d88 <__aeabi_fmul+0x130>
30044f28:	e1a00001 	mov	r0, r1
30044f2c:	eaffffac 	b	30044de4 <__aeabi_fmul+0x18c>
30044f30:	e3d0c102 	bics	ip, r0, #-2147483648	; 0x80000000
30044f34:	13d1c102 	bicsne	ip, r1, #-2147483648	; 0x80000000
30044f38:	1affffde 	bne	30044eb8 <__aeabi_fdiv+0xc8>
30044f3c:	e3d02102 	bics	r2, r0, #-2147483648	; 0x80000000
30044f40:	1affffa2 	bne	30044dd0 <__aeabi_fmul+0x178>
30044f44:	e3d13102 	bics	r3, r1, #-2147483648	; 0x80000000
30044f48:	1affff8e 	bne	30044d88 <__aeabi_fmul+0x130>
30044f4c:	eaffffa4 	b	30044de4 <__aeabi_fmul+0x18c>

30044f50 <__gesf2>:
30044f50:	e3e0c000 	mvn	ip, #0
30044f54:	ea000002 	b	30044f64 <__cmpsf2+0x4>

30044f58 <__lesf2>:
30044f58:	e3a0c001 	mov	ip, #1
30044f5c:	ea000000 	b	30044f64 <__cmpsf2+0x4>

30044f60 <__cmpsf2>:
30044f60:	e3a0c001 	mov	ip, #1
30044f64:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
30044f68:	e1a02080 	lsl	r2, r0, #1
30044f6c:	e1a03081 	lsl	r3, r1, #1
30044f70:	e1f0cc42 	mvns	ip, r2, asr #24
30044f74:	11f0cc43 	mvnsne	ip, r3, asr #24
30044f78:	0a000007 	beq	30044f9c <__cmpsf2+0x3c>
30044f7c:	e28dd004 	add	sp, sp, #4
30044f80:	e192c0a3 	orrs	ip, r2, r3, lsr #1
30044f84:	11300001 	teqne	r0, r1
30044f88:	50520003 	subspl	r0, r2, r3
30044f8c:	81a00fc1 	asrhi	r0, r1, #31
30044f90:	31e00fc1 	mvncc	r0, r1, asr #31
30044f94:	13800001 	orrne	r0, r0, #1
30044f98:	e12fff1e 	bx	lr
30044f9c:	e1f0cc42 	mvns	ip, r2, asr #24
30044fa0:	1a000001 	bne	30044fac <__cmpsf2+0x4c>
30044fa4:	e1b0c480 	lsls	ip, r0, #9
30044fa8:	1a000003 	bne	30044fbc <__cmpsf2+0x5c>
30044fac:	e1f0cc43 	mvns	ip, r3, asr #24
30044fb0:	1afffff1 	bne	30044f7c <__cmpsf2+0x1c>
30044fb4:	e1b0c481 	lsls	ip, r1, #9
30044fb8:	0affffef 	beq	30044f7c <__cmpsf2+0x1c>
30044fbc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
30044fc0:	e12fff1e 	bx	lr

30044fc4 <__aeabi_cfrcmple>:
30044fc4:	e1a0c000 	mov	ip, r0
30044fc8:	e1a00001 	mov	r0, r1
30044fcc:	e1a0100c 	mov	r1, ip
30044fd0:	eaffffff 	b	30044fd4 <__aeabi_cfcmpeq>

30044fd4 <__aeabi_cfcmpeq>:
30044fd4:	e92d400f 	push	{r0, r1, r2, r3, lr}
30044fd8:	ebffffe0 	bl	30044f60 <__cmpsf2>
30044fdc:	e3500000 	cmp	r0, #0
30044fe0:	43700000 	cmnmi	r0, #0
30044fe4:	e8bd400f 	pop	{r0, r1, r2, r3, lr}
30044fe8:	e12fff1e 	bx	lr

30044fec <__aeabi_fcmpeq>:
30044fec:	e52de008 	str	lr, [sp, #-8]!
30044ff0:	ebfffff7 	bl	30044fd4 <__aeabi_cfcmpeq>
30044ff4:	03a00001 	moveq	r0, #1
30044ff8:	13a00000 	movne	r0, #0
30044ffc:	e49de008 	ldr	lr, [sp], #8
30045000:	e12fff1e 	bx	lr

30045004 <__aeabi_fcmplt>:
30045004:	e52de008 	str	lr, [sp, #-8]!
30045008:	ebfffff1 	bl	30044fd4 <__aeabi_cfcmpeq>
3004500c:	33a00001 	movcc	r0, #1
30045010:	23a00000 	movcs	r0, #0
30045014:	e49de008 	ldr	lr, [sp], #8
30045018:	e12fff1e 	bx	lr

3004501c <__aeabi_fcmple>:
3004501c:	e52de008 	str	lr, [sp, #-8]!
30045020:	ebffffeb 	bl	30044fd4 <__aeabi_cfcmpeq>
30045024:	93a00001 	movls	r0, #1
30045028:	83a00000 	movhi	r0, #0
3004502c:	e49de008 	ldr	lr, [sp], #8
30045030:	e12fff1e 	bx	lr

30045034 <__aeabi_fcmpge>:
30045034:	e52de008 	str	lr, [sp, #-8]!
30045038:	ebffffe1 	bl	30044fc4 <__aeabi_cfrcmple>
3004503c:	93a00001 	movls	r0, #1
30045040:	83a00000 	movhi	r0, #0
30045044:	e49de008 	ldr	lr, [sp], #8
30045048:	e12fff1e 	bx	lr

3004504c <__aeabi_fcmpgt>:
3004504c:	e52de008 	str	lr, [sp, #-8]!
30045050:	ebffffdb 	bl	30044fc4 <__aeabi_cfrcmple>
30045054:	33a00001 	movcc	r0, #1
30045058:	23a00000 	movcs	r0, #0
3004505c:	e49de008 	ldr	lr, [sp], #8
30045060:	e12fff1e 	bx	lr
30045064:	72724544 	.word	0x72724544
30045068:	0000000a 	.word	0x0000000a
3004506c:	6d656164 	.word	0x6d656164
30045070:	00006e6f 	.word	0x00006e6f
30045074:	736e6f63 	.word	0x736e6f63
30045078:	00656c6f 	.word	0x00656c6f
3004507c:	656c6469 	.word	0x656c6469
30045080:	00000000 	.word	0x00000000
30045084:	69206e69 	.word	0x69206e69
30045088:	0074696e 	.word	0x0074696e
3004508c:	74696e69 	.word	0x74696e69
30045090:	00000000 	.word	0x00000000
30045094:	6f6c6c41 	.word	0x6f6c6c41
30045098:	68742063 	.word	0x68742063
3004509c:	64616572 	.word	0x64616572
300450a0:	2073253a 	.word	0x2073253a
300450a4:	6c696166 	.word	0x6c696166
300450a8:	0000000a 	.word	0x0000000a
300450ac:	74206f4e 	.word	0x74206f4e
300450b0:	61657268 	.word	0x61657268
300450b4:	6f702064 	.word	0x6f702064
300450b8:	7963696c 	.word	0x7963696c
300450bc:	70757320 	.word	0x70757320
300450c0:	74726f70 	.word	0x74726f70
300450c4:	0a64253a 	.word	0x0a64253a
300450c8:	00000000 	.word	0x00000000
300450cc:	65657341 	.word	0x65657341
300450d0:	493a7472 	.word	0x493a7472
300450d4:	6573206e 	.word	0x6573206e
300450d8:	7463656c 	.word	0x7463656c
300450dc:	72687420 	.word	0x72687420
300450e0:	00646165 	.word	0x00646165
300450e4:	6f6c6c41 	.word	0x6f6c6c41
300450e8:	68742063 	.word	0x68742063
300450ec:	64616572 	.word	0x64616572
300450f0:	2073253a 	.word	0x2073253a
300450f4:	6c696166 	.word	0x6c696166
300450f8:	0000000a 	.word	0x0000000a
300450fc:	74206f4e 	.word	0x74206f4e
30045100:	61657268 	.word	0x61657268
30045104:	74732064 	.word	0x74732064
30045108:	3a6b6361 	.word	0x3a6b6361
3004510c:	000a7325 	.word	0x000a7325
30045110:	6d6d6f63 	.word	0x6d6d6f63
30045114:	00000000 	.word	0x00000000
30045118:	20736552 	.word	0x20736552
3004511c:	656c6552 	.word	0x656c6552
30045120:	0a657361 	.word	0x0a657361
30045124:	00000000 	.word	0x00000000
30045128:	20736552 	.word	0x20736552
3004512c:	656c6572 	.word	0x656c6572
30045130:	20657361 	.word	0x20657361
30045134:	0a727245 	.word	0x0a727245
30045138:	00000000 	.word	0x00000000
3004513c:	20727245 	.word	0x20727245
30045140:	0a736552 	.word	0x0a736552
30045144:	00000000 	.word	0x00000000
30045148:	000a7325 	.word	0x000a7325
3004514c:	20727245 	.word	0x20727245
30045150:	27736572 	.word	0x27736572
30045154:	64692073 	.word	0x64692073
30045158:	0a78253a 	.word	0x0a78253a
3004515c:	00000000 	.word	0x00000000
30045160:	65637845 	.word	0x65637845
30045164:	6f697470 	.word	0x6f697470
30045168:	636f206e 	.word	0x636f206e
3004516c:	0a727563 	.word	0x0a727563
30045170:	00000000 	.word	0x00000000
30045174:	2a2a2a2a 	.word	0x2a2a2a2a
30045178:	2a2a2a2a 	.word	0x2a2a2a2a
3004517c:	2a2a2a2a 	.word	0x2a2a2a2a
30045180:	2a2a2a2a 	.word	0x2a2a2a2a
30045184:	000a2a2a 	.word	0x000a2a2a
30045188:	3a555043 	.word	0x3a555043
3004518c:	000a6425 	.word	0x000a6425
30045190:	65726854 	.word	0x65726854
30045194:	6e206461 	.word	0x6e206461
30045198:	3a656d61 	.word	0x3a656d61
3004519c:	000a7325 	.word	0x000a7325
300451a0:	65726854 	.word	0x65726854
300451a4:	70206461 	.word	0x70206461
300451a8:	3a6f6972 	.word	0x3a6f6972
300451ac:	000a6425 	.word	0x000a6425
300451b0:	65726854 	.word	0x65726854
300451b4:	73206461 	.word	0x73206461
300451b8:	6b636174 	.word	0x6b636174
300451bc:	7a69735f 	.word	0x7a69735f
300451c0:	64253a65 	.word	0x64253a65
300451c4:	0000000a 	.word	0x0000000a
300451c8:	65726854 	.word	0x65726854
300451cc:	73206461 	.word	0x73206461
300451d0:	6b636174 	.word	0x6b636174
300451d4:	7475625f 	.word	0x7475625f
300451d8:	3a6d6f74 	.word	0x3a6d6f74
300451dc:	78257830 	.word	0x78257830
300451e0:	0000000a 	.word	0x0000000a
300451e4:	65726854 	.word	0x65726854
300451e8:	73206461 	.word	0x73206461
300451ec:	6b636174 	.word	0x6b636174
300451f0:	2578303a 	.word	0x2578303a
300451f4:	00000a78 	.word	0x00000a78
300451f8:	303a6350 	.word	0x303a6350
300451fc:	0a782578 	.word	0x0a782578
30045200:	00000000 	.word	0x00000000
30045204:	63617453 	.word	0x63617453
30045208:	78303a6b 	.word	0x78303a6b
3004520c:	000a7825 	.word	0x000a7825
30045210:	74206e69 	.word	0x74206e69
30045214:	20656d69 	.word	0x20656d69
30045218:	6c616564 	.word	0x6c616564
3004521c:	00000000 	.word	0x00000000
30045220:	74206e69 	.word	0x74206e69
30045224:	20656d69 	.word	0x20656d69
30045228:	6c616564 	.word	0x6c616564
3004522c:	726f6620 	.word	0x726f6620
30045230:	00000000 	.word	0x00000000
30045234:	74206e69 	.word	0x74206e69
30045238:	6f656d69 	.word	0x6f656d69
3004523c:	64207475 	.word	0x64207475
30045240:	006c6165 	.word	0x006c6165
30045244:	6574756d 	.word	0x6574756d
30045248:	554e2078 	.word	0x554e2078
3004524c:	000a4c4c 	.word	0x000a4c4c
30045250:	6574756d 	.word	0x6574756d
30045254:	72702078 	.word	0x72702078
30045258:	65206f69 	.word	0x65206f69
3004525c:	000a7272 	.word	0x000a7272
30045260:	6576654c 	.word	0x6576654c
30045264:	0d64256c 	.word	0x0d64256c
30045268:	0000000a 	.word	0x0000000a
3004526c:	6d746962 	.word	0x6d746962
30045270:	003a7061 	.word	0x003a7061
30045274:	00207825 	.word	0x00207825
30045278:	00000a0d 	.word	0x00000a0d
3004527c:	65657246 	.word	0x65657246
30045280:	6f6c4220 	.word	0x6f6c4220
30045284:	68206b63 	.word	0x68206b63
30045288:	3a646165 	.word	0x3a646165
3004528c:	0a0d6425 	.word	0x0a0d6425
30045290:	00000000 	.word	0x00000000
30045294:	65657246 	.word	0x65657246
30045298:	6d654d20 	.word	0x6d654d20
3004529c:	6f6c4220 	.word	0x6f6c4220
300452a0:	4e206b63 	.word	0x4e206b63
300452a4:	65626d75 	.word	0x65626d75
300452a8:	64253a72 	.word	0x64253a72
300452ac:	00000a0d 	.word	0x00000a0d
300452b0:	61766e49 	.word	0x61766e49
300452b4:	2064696c 	.word	0x2064696c
300452b8:	65657246 	.word	0x65657246
300452bc:	64644120 	.word	0x64644120
300452c0:	73736572 	.word	0x73736572
300452c4:	2578303a 	.word	0x2578303a
300452c8:	00000a78 	.word	0x00000a78
300452cc:	72646441 	.word	0x72646441
300452d0:	3a737365 	.word	0x3a737365
300452d4:	78257830 	.word	0x78257830
300452d8:	76616820 	.word	0x76616820
300452dc:	65622065 	.word	0x65622065
300452e0:	66206e65 	.word	0x66206e65
300452e4:	64656572 	.word	0x64656572
300452e8:	0000000a 	.word	0x0000000a
300452ec:	20727245 	.word	0x20727245
300452f0:	72646461 	.word	0x72646461
300452f4:	20737365 	.word	0x20737365
300452f8:	30207369 	.word	0x30207369
300452fc:	2c782578 	.word	0x2c782578
30045300:	657a6973 	.word	0x657a6973
30045304:	6f687320 	.word	0x6f687320
30045308:	20646c75 	.word	0x20646c75
3004530c:	20746f6e 	.word	0x20746f6e
30045310:	30206562 	.word	0x30206562
30045314:	00000000 	.word	0x00000000
30045318:	61766e49 	.word	0x61766e49
3004531c:	6564696c 	.word	0x6564696c
30045320:	65724620 	.word	0x65724620
30045324:	64612065 	.word	0x64612065
30045328:	73657264 	.word	0x73657264
3004532c:	78303a73 	.word	0x78303a73
30045330:	000a7825 	.word	0x000a7825
30045334:	72646441 	.word	0x72646441
30045338:	3a737365 	.word	0x3a737365
3004533c:	78257830 	.word	0x78257830
30045340:	76616820 	.word	0x76616820
30045344:	65622065 	.word	0x65622065
30045348:	66206e65 	.word	0x66206e65
3004534c:	64656572 	.word	0x64656572
30045350:	0000000a 	.word	0x0000000a
30045354:	20727265 	.word	0x20727265
30045358:	72646461 	.word	0x72646461
3004535c:	20737365 	.word	0x20737365
30045360:	30207369 	.word	0x30207369
30045364:	2c782578 	.word	0x2c782578
30045368:	657a6973 	.word	0x657a6973
3004536c:	6f687320 	.word	0x6f687320
30045370:	20646c75 	.word	0x20646c75
30045374:	20746f6e 	.word	0x20746f6e
30045378:	30206562 	.word	0x30206562
3004537c:	00000000 	.word	0x00000000
30045380:	206d654d 	.word	0x206d654d
30045384:	74696e49 	.word	0x74696e49
30045388:	72724520 	.word	0x72724520
3004538c:	6f732c20 	.word	0x6f732c20
30045390:	206f6e20 	.word	0x206f6e20
30045394:	206d656d 	.word	0x206d656d
30045398:	63617073 	.word	0x63617073
3004539c:	6f742065 	.word	0x6f742065
300453a0:	6c616d20 	.word	0x6c616d20
300453a4:	0d636f6c 	.word	0x0d636f6c
300453a8:	0000000a 	.word	0x0000000a
300453ac:	20727245 	.word	0x20727245
300453b0:	72646461 	.word	0x72646461
300453b4:	20737365 	.word	0x20737365
300453b8:	30207369 	.word	0x30207369
300453bc:	2c782578 	.word	0x2c782578
300453c0:	657a6973 	.word	0x657a6973
300453c4:	6f687320 	.word	0x6f687320
300453c8:	20646c75 	.word	0x20646c75
300453cc:	20746f6e 	.word	0x20746f6e
300453d0:	30206562 	.word	0x30206562
300453d4:	00000a0d 	.word	0x00000a0d
300453d8:	20656854 	.word	0x20656854
300453dc:	72646461 	.word	0x72646461
300453e0:	20737365 	.word	0x20737365
300453e4:	30207369 	.word	0x30207369
300453e8:	2c782578 	.word	0x2c782578
300453ec:	20656874 	.word	0x20656874
300453f0:	636f6c62 	.word	0x636f6c62
300453f4:	7369206b 	.word	0x7369206b
300453f8:	65737520 	.word	0x65737520
300453fc:	6e612064 	.word	0x6e612064
30045400:	74692064 	.word	0x74692064
30045404:	73207327 	.word	0x73207327
30045408:	20657a69 	.word	0x20657a69
3004540c:	25207369 	.word	0x25207369
30045410:	000a0d64 	.word	0x000a0d64
30045414:	20656854 	.word	0x20656854
30045418:	72646461 	.word	0x72646461
3004541c:	20737365 	.word	0x20737365
30045420:	30207369 	.word	0x30207369
30045424:	2c782578 	.word	0x2c782578
30045428:	20656874 	.word	0x20656874
3004542c:	636f6c62 	.word	0x636f6c62
30045430:	7369206b 	.word	0x7369206b
30045434:	756e7520 	.word	0x756e7520
30045438:	20646573 	.word	0x20646573
3004543c:	20646e61 	.word	0x20646e61
30045440:	73277469 	.word	0x73277469
30045444:	7a697320 	.word	0x7a697320
30045448:	73692065 	.word	0x73692065
3004544c:	0d642520 	.word	0x0d642520
30045450:	0000000a 	.word	0x0000000a
30045454:	20727245 	.word	0x20727245
30045458:	206d6553 	.word	0x206d6553
3004545c:	74736f70 	.word	0x74736f70
30045460:	0000000a 	.word	0x0000000a
30045464:	2064690a 	.word	0x2064690a
30045468:	6425203d 	.word	0x6425203d
3004546c:	00000000 	.word	0x00000000
30045470:	6177200a 	.word	0x6177200a
30045474:	74207469 	.word	0x74207469
30045478:	61657268 	.word	0x61657268
3004547c:	6d207364 	.word	0x6d207364
30045480:	3d206d75 	.word	0x3d206d75
30045484:	00642520 	.word	0x00642520
30045488:	6c206f4e 	.word	0x6c206f4e
3004548c:	6c657665 	.word	0x6c657665
30045490:	656d2032 	.word	0x656d2032
30045494:	7073206d 	.word	0x7073206d
30045498:	20656361 	.word	0x20656361
3004549c:	20726f66 	.word	0x20726f66
300454a0:	76697270 	.word	0x76697270
300454a4:	5f657461 	.word	0x5f657461
300454a8:	61746164 	.word	0x61746164
300454ac:	0a73253a 	.word	0x0a73253a
300454b0:	00000000 	.word	0x00000000
300454b4:	74204d52 	.word	0x74204d52
300454b8:	61657268 	.word	0x61657268
300454bc:	73252064 	.word	0x73252064
300454c0:	72724520 	.word	0x72724520
300454c4:	6972502c 	.word	0x6972502c
300454c8:	7369206f 	.word	0x7369206f
300454cc:	746f6e20 	.word	0x746f6e20
300454d0:	6f6e6520 	.word	0x6f6e6520
300454d4:	0a686775 	.word	0x0a686775
300454d8:	00000000 	.word	0x00000000
300454dc:	63736944 	.word	0x63736944
300454e0:	20647261 	.word	0x20647261
300454e4:	65726874 	.word	0x65726874
300454e8:	25206461 	.word	0x25206461
300454ec:	00000a73 	.word	0x00000a73
300454f0:	00006d72 	.word	0x00006d72
300454f4:	6c206f4e 	.word	0x6c206f4e
300454f8:	6c657665 	.word	0x6c657665
300454fc:	656d2032 	.word	0x656d2032
30045500:	7073206d 	.word	0x7073206d
30045504:	20656361 	.word	0x20656361
30045508:	20726f66 	.word	0x20726f66
3004550c:	76697270 	.word	0x76697270
30045510:	5f657461 	.word	0x5f657461
30045514:	61746164 	.word	0x61746164
30045518:	0a73253a 	.word	0x0a73253a
3004551c:	00000000 	.word	0x00000000
30045520:	74206f4e 	.word	0x74206f4e
30045524:	61657268 	.word	0x61657268
30045528:	74732064 	.word	0x74732064
3004552c:	3a6b6361 	.word	0x3a6b6361
30045530:	000a7325 	.word	0x000a7325
30045534:	70206e69 	.word	0x70206e69
30045538:	6f697265 	.word	0x6f697265
3004553c:	68742064 	.word	0x68742064
30045540:	64616572 	.word	0x64616572
30045544:	61656420 	.word	0x61656420
30045548:	0000006c 	.word	0x0000006c
3004554c:	70206e69 	.word	0x70206e69
30045550:	6f697265 	.word	0x6f697265
30045554:	68742064 	.word	0x68742064
30045558:	64616572 	.word	0x64616572
3004555c:	61656420 	.word	0x61656420
30045560:	0000206c 	.word	0x0000206c
30045564:	69726570 	.word	0x69726570
30045568:	0000646f 	.word	0x0000646f
3004556c:	6c206f4e 	.word	0x6c206f4e
30045570:	6c657665 	.word	0x6c657665
30045574:	656d2032 	.word	0x656d2032
30045578:	7073206d 	.word	0x7073206d
3004557c:	20656361 	.word	0x20656361
30045580:	20726f66 	.word	0x20726f66
30045584:	76697270 	.word	0x76697270
30045588:	5f657461 	.word	0x5f657461
3004558c:	61746164 	.word	0x61746164
30045590:	0a73253a 	.word	0x0a73253a
30045594:	00000000 	.word	0x00000000
30045598:	74206f4e 	.word	0x74206f4e
3004559c:	61657268 	.word	0x61657268
300455a0:	74732064 	.word	0x74732064
300455a4:	3a6b6361 	.word	0x3a6b6361
300455a8:	000a7325 	.word	0x000a7325
300455ac:	63696c73 	.word	0x63696c73
300455b0:	00000065 	.word	0x00000065
300455b4:	6f6c6c41 	.word	0x6f6c6c41
300455b8:	6f502063 	.word	0x6f502063
300455bc:	20786973 	.word	0x20786973
300455c0:	65726874 	.word	0x65726874
300455c4:	66206461 	.word	0x66206461
300455c8:	0a6c6961 	.word	0x0a6c6961
300455cc:	00000000 	.word	0x00000000
300455d0:	6d206f4e 	.word	0x6d206f4e
300455d4:	73206d65 	.word	0x73206d65
300455d8:	65636170 	.word	0x65636170
300455dc:	726f6620 	.word	0x726f6620
300455e0:	736f7020 	.word	0x736f7020
300455e4:	70207869 	.word	0x70207869
300455e8:	61766972 	.word	0x61766972
300455ec:	645f6574 	.word	0x645f6574
300455f0:	3a617461 	.word	0x3a617461
300455f4:	000a7325 	.word	0x000a7325
300455f8:	74206f4e 	.word	0x74206f4e
300455fc:	61657268 	.word	0x61657268
30045600:	74732064 	.word	0x74732064
30045604:	3a6b6361 	.word	0x3a6b6361
30045608:	000a7325 	.word	0x000a7325
3004560c:	69736f70 	.word	0x69736f70
30045610:	00000078 	.word	0x00000078
30045614:	74666f73 	.word	0x74666f73
30045618:	616c6564 	.word	0x616c6564
3004561c:	00000079 	.word	0x00000079

30045620 <small_digits>:
30045620:	33323130 37363534 62613938 66656463     0123456789abcdef
30045630:	6a696867 6e6d6c6b 7271706f 76757473     ghijklmnopqrstuv
30045640:	7a797877 00000000                       wxyz....

30045648 <large_digits>:
30045648:	33323130 37363534 42413938 46454443     0123456789ABCDEF
30045658:	4a494847 4e4d4c4b 5251504f 56555453     GHIJKLMNOPQRSTUV
30045668:	5a595857 00000000 4c554e3c 00003e4c     WXYZ....<NULL>..
30045678:	736e6f63 00656c6f 76636552 61746144     console.RecvData
30045688:	00000000                                ....

3004568c <err_to_errno_table>:
3004568c:	00000000 0000000c 00000069 00000071     ........i...q...
3004569c:	00000067 00000068 0000006c 0000006b     g...h...l...k...
300456ac:	00000016 00000005 00000062 ffffffff     ........b.......
300456bc:	ffffffff 0000006e 00000073 69706374     ....n...s...tcpi
300456cc:	00000070                                p...

300456d0 <ip_addr_any>:
300456d0:	00000000                                ....

300456d4 <ip_addr_broadcast>:
300456d4:	ffffffff                                ....

300456d8 <memp_sizes>:
300456d8:	0020001c 002000a4 00100014 0014002c     .. ... .....,...
300456e8:	00080014 00100010 00001048              ........H...

300456f4 <memp_num>:
300456f4:	00040004 00080005 00020010 00080004     ................
30045704:	001e0008 00100003 00000010              ............

30045710 <tcp_backoff>:
30045710:	04030201 07070605 07070707 00000007     ................

30045720 <tcp_persist_backoff>:
30045720:	180c0603 00786030 3d3d0a0d 7074756f     ....0`x...==outp
30045730:	2d2d7475 000a0d39 7064750a 6275703a     ut--9....udp:pub
30045740:	20736920 20746f6e 6c6c756e 0000000a      is not null....

30045750 <ethbroadcast>:
30045750:	ffffffff 0000ffff                       ........

30045758 <ethzero>:
	...
30045760:	6874650a 656e7265 6e695f74 31747570     .ethernet_input1
30045770:	203d3d20 000a6425 6874650a 656e7265      == %d...etherne
30045780:	6e695f74 32747570 203d3d20 000a6425     t_input2 == %d..
30045790:	6474656e 00007665 20746f4e 6e756f46     netdev..Not Foun
300457a0:	654e2064 65442074 65636976 0000000a     d Net Device....
300457b0:	0000002e                                ....

300457b4 <Root>:
300457b4:	5a903eeb 2e31474c 00202030 00010102     .>.ZLG1.0  .....
300457c4:	4000e002 0009f00b 00020012 00000000     ...@............
300457d4:	00000000 64290000 4e18d52a 414e204f     ......)d*..NO NA
300457e4:	2020454d 41462020 20202054 7df12020     ME    FAT     .}
300457f4:	8ec933fa 7bfcbcd1 78bd0716 0076c500     .3.....{...x..v.
30045804:	5516561e 890522bf 4e89007e fc0bb102     .V.U."..~..N....
30045814:	1f06a4f3 c67c00bd 8b0ffe45 45881846     ......|.E...F..E
30045824:	6638fbf9 cd047c24 8a3c7213 f7981046     ..8f$|...r<.F...
30045834:	46031666 1e56131c 130e4603 895250d1     f..F..V..F...PR.
30045844:	5689fc46 0020b8fe f711768b 0b5e8be6     F..V.. ..v....^.
30045854:	f748c303 fc4601f3 5afe4e11 0700bb58     ..H...F..N.ZX...
30045864:	01b1fb8b 720094e8 742d3847 560bb119     .......rG8-t...V
30045874:	f33e768b 4a745ea6 030b744e 15c783f9     .v>..^tJNt......
30045884:	e572fb3b c92bd7eb 877dd8b8 d83c3e46     ;.r...+...}.F><.
30045894:	80be9975 0398ac7d c084acf0 ff3c1774     u...}.......t.<.
300458a4:	0eb40974 cd0007bb beeeeb10 e5eb7d83     t............}..
300458b4:	eb7d81be cdc033e0 8f1f5e16 02448f04     ..}..3...^....D.
300458c4:	82be19cd 0f7d8b7d 7202ff83 48c78bc8     ....}.}....r...H
300458d4:	0d4e8a48 4603e1f7 fe5613fc 530700bb     H.N....F..V....S
300458e4:	16e804b1 c8725b00 5a4d3f81 bf81a775     .....[r..?MZu...
300458f4:	4a420200 00ea9f75 50007002 92915152     ..BJu....p.PRQ..
30045904:	76f7d233 76f79118 ca874218 8a1a76f7     3..v...v.B...v..
30045914:	24568af2 ccd0e88a cc0accd0 cd0201b8     ..V$............
30045924:	585a5913 75400972 5e034201 c3cce20b     .YZXr.@u.B.^....
30045934:	27011803 6e490a0d 696c6176 79732064     ...'..Invalid sy
30045944:	6d657473 73696420 0a0dff6b 6b736944     stem disk...Disk
30045954:	4f2f4920 72726520 0dff726f 7065520a      I/O error...Rep
30045964:	6563616c 65687420 73696420 61202c6b     lace the disk, a
30045974:	7420646e 206e6568 73657270 6e612073     nd then press an
30045984:	656b2079 000a0d79 20204f49 20202020     y key...IO      
30045994:	4d535953 534f4453 53202020 01805359     SYSMSDOS   SYS..
300459a4:	4e495700 544f4f42 53595320 aa550000     .WINBOOT SYS..U.
300459b4:	6b736964 00000000 00003a41 726f6361     disk....A:..acor
300459c4:	6e5f6c61 6d5f7465 00003370 6c756f43     al_net_mp3..Coul
300459d4:	6f6e2064 6f662074 20646e75 27732527     d not found '%s'
300459e4:	6d6f6320 646e616d 00000a0d 20756f79      command....you 
300459f4:	206e6163 65707974 65682720 0d27706c     can type 'help'.
30045a04:	0000000a 6c656873 0000006c 20656854     ....shell...The 
30045a14:	65726874 68206461 20657661 43206f6e     thread have no C
30045a24:	6f736e6f 000a656c 00000a0d 726f4361     onsole......aCor
30045a34:	3e3a6c61 00000000 736d656d 006e6163     al:>....memscan.
30045a44:	77656956 65687420 72696620 4c207473     View the first L
30045a54:	6c657665 6d654d20 2079726f 616e614d     evel Memory Mana
30045a64:	6e656d67 6e492074 00006f66 736d656d     gment Info..mems
30045a74:	326e6163 00000000 77656956 65687420     can2....View the
30045a84:	63657320 65646e6f 76654c20 4d206c65      seconde Level M
30045a94:	726f6d65 614d2079 6d67616e 20746e65     emory Managment 
30045aa4:	6f666e49 00000000 20207325 000a7325     Info....%s  %s..
30045ab4:	706c6568 00000000 77656956 6c6c6120     help....View all
30045ac4:	65685320 43206c6c 616d6d6f 6920646e      Shell Command i
30045ad4:	006f666e 74697865 00000000 74697845     nfo.exit....Exit
30045ae4:	65685320 00006c6c 79530909 6d657473      Shell....System
30045af4:	72685420 20646165 6f666e49 74616d72      Thread Informat
30045b04:	0d6e6f69 0000000a 2d2d2d2d 2d2d2d2d     ion.....--------
30045b14:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
30045b24:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
30045b34:	2d2d2d2d 2d2d2d2d 2d2d2d2d 0a0d2d2d     --------------..
30045b44:	00000000 656d614e 79540909 09096570     ....Name..Type..
30045b54:	736e6f43 09656c6f 61745309 0a0d6574     Console..State..
30045b64:	00000000 09097325 00000000 6d6d6f43     ....%s......Comm
30045b74:	09096e6f 00000000 63696c53 00090965     on......Slice...
30045b84:	69726550 0909646f 00000000 09094d52     Period......RM..
30045b94:	00000000 69736f50 00090978 09096425     ....Posix...%d..
30045ba4:	00000000 6e6e7552 09676e69 00000009     ....Running.....
30045bb4:	64616552 00090979 616c6544 00090979     Ready...Delay...
30045bc4:	65656c53 00090970 65657246 0909657a     Sleep...Freeze..
30045bd4:	00000000 6f727245 00090972 00000a0d     ....Error.......
30045be4:	00007464 77656956 6c6c6120 72687420     dt..View all thr
30045bf4:	20646165 6f666e69 00000000 5f6e6f63     ead info....con_
30045c04:	6e6c6574 00007465 73206f4e 6c6c6568     telnet..No shell
30045c14:	70755320 74726f70 6c69772c 7845206c      Support,will Ex
30045c24:	00007469 6e6c6574 00007465 67617355     it..telnet..Usag
30045c34:	736c2065 61503c20 616e6874 0a3e656d     e ls <Pathname>.
30045c44:	00000000 003e7325 00006463 6e616843     ....%s>.cd..Chan
30045c54:	63206567 65727275 6420746e 00007269     ge current dir..
30045c64:	64303125 65747942 00000073 00726964     %10dBytes...dir.
30045c74:	656c6966 00000000 00007325 000a7325     file....%s..%s..
30045c84:	3e73250a 00000000 0000736c 7473694c     .%s>....ls..List
30045c94:	6c696620 69642f65 6e692072 72756320      file/dir in cur
30045ca4:	746e6572 72696420 00000000 67617355     rent dir....Usag
30045cb4:	6b6d2065 20726964 7461503c 6d616e68     e mkdir <Pathnam
30045cc4:	0a213e65 00000000 69646b6d 00000072     e>!.....mkdir...
30045cd4:	656b616d 64206120 69207269 7563206e     make a dir in cu
30045ce4:	6e657272 69642074 00000072 67617355     rrent dir...Usag
30045cf4:	6d722065 20726964 7461503c 6d616e68     e rmdir <Pathnam
30045d04:	0a213e65 00000000 656c6564 64206574     e>!.....delete d
30045d14:	253a7269 72652073 21726f72 2073250a     ir:%s error!.%s 
30045d24:	7473756d 20656220 74706d65 000a2179     must be empty!..
30045d34:	69646d72 00000072 656c6564 61206574     rmdir...delete a
30045d44:	72696420 206e6920 72727563 20746e65      dir in current 
30045d54:	00726964 67617355 72632065 65746165     dir.Usage create
30045d64:	72733c20 6d616e63 3c203e65 67726174      <srcname> <targ
30045d74:	616e7465 213e656d 0000000a 79706f63     etname>!....copy
30045d84:	6c696620 73253a65 72726520 0a21726f      file:%s error!.
30045d94:	00000000 00007063 79706f63 66206120     ....cp..copy a f
30045da4:	20656c69 63206e69 65727275 6420746e     ile in current d
30045db4:	00007269 67617355 72632065 65746165     ir..Usage create
30045dc4:	69463c20 616e656c 213e656d 0000000a      <Filename>!....
30045dd4:	61657263 66206574 3a656c69 65207325     create file:%s e
30045de4:	726f7272 00000a21 61657263 00006574     rror!...create..
30045df4:	61657263 61206574 6c696620 6e692065     create a file in
30045e04:	72756320 746e6572 72696420 00000000      current dir....
30045e14:	67617355 6d722065 69463c20 616e656c     Usage rm <Filena
30045e24:	213e656d 0000000a 00006d72 656c6564     me>!....rm..dele
30045e34:	61206574 6c696620 6e692065 72756320     te a file in cur
30045e44:	746e6572 72696420 00000000 7777772f     rent dir..../www
30045e54:	00000000 65646e69 74682e78 0000006d     ....index.htm...
30045e64:	00746567 74736f70 00000000              get.post....

30045e70 <C.0.2321>:
30045e70:	30045e64 30045e68 25203a78 3a792064     d^.0h^.0x: %d y:
30045e80:	0a642520 00000000 5f6c6f76 0a636e69      %d.....vol_inc.
30045e90:	00000000 5f6c6f76 0a636564 00000000     ....vol_dec.....
30045ea0:	7478656e 0000000a 0a657270 00000000     next....pre.....
30045eb0:	706f7473 6174735f 000a7472 61636f6c     stop_start..loca
30045ec0:	00000a6c 696c6e6f 000a656e 61636f6c     l...online..loca
30045ed0:	706d5f6c 69665f33 725f656c 00646165     l_mp3_file_read.
30045ee0:	61636f6c 61775f6c 69665f76 725f656c     local_wav_file_r
30045ef0:	00646165 65696c63 0000746e 70737573     ead.client..susp
30045f00:	6f746365 68745f72 64616572 00000000     ector_thread....
30045f10:	6e616863 20646567 000a2021 73277469     changed ! ..it's
30045f20:	726c6120 79646165 636f4c20 0a216c61      already Local!.
30045f30:	00000000 73277469 726c6120 79646165     ....it's already
30045f40:	6c6e6f20 20656e69 21212121 0000000a      online !!!!....
30045f50:	7365540a 46542074 434c2054 000a2144     .Test TFT LCD!..
30045f60:	63756f74 61705f68 65745f64 00007473     touch_pad_test..
30045f70:	5f79656b 74736574 00000000 6e69616d     key_test....main
30045f80:	7268745f 00646165 6d61530a 20656c70     _thread..Sample 
30045f90:	65746152 25203d20 43202c64 6e6e6168     Rate = %d, Chann
30045fa0:	20736c65 6425203d 6425202c 73746942     els = %d, %dBits
30045fb0:	53726550 6c706d61 73202c65 20657a69     PerSample, size 
30045fc0:	6425203d 0000000a 7272650a 25203d20     = %d.....err = %
30045fd0:	00000a78 20776f4e 79616c70 20676e69     x...Now playing 
30045fe0:	20656874 656c6966 0000000a 73657250     the file....Pres
30045ff0:	45272073 20274353 71206f74 2c746975     s 'ESC' to quit,
30046000:	272b2720 206f7420 20636e69 756c6f76      '+' to inc volu
30046010:	202c656d 20272d27 64206f74 76206365     me, '-' to dec v
30046020:	6d756c6f 27202c65 7420276d 756d206f     olume, 'm' to mu
30046030:	202c6574 20277027 70206f74 65737561     te, 'p' to pause
30046040:	0000000a 61772e31 00000076 6d61530a     ....1.wav....Sam
30046050:	20656c70 65746152 25203d20 43202c64     ple Rate = %d, C
30046060:	6e6e6168 20736c65 6425203d 6425202c     hannels = %d, %d
30046070:	73746942 53726550 6c706d61 73202c65     BitsPerSample, s
30046080:	20657a69 6425203d 0000000a 5f33706d     ize = %d....mp3_
30046090:	6f636564 00726564 6d61530a 20656c70     decoder..Sample 
300460a0:	65746152 25203d20 43202c64 6e6e6168     Rate = %d, Chann
300460b0:	20736c65 6425203d 6425202c 73746942     els = %d, %dBits
300460c0:	53726550 6c706d61 73202c65 20657a69     PerSample, size 
300460d0:	6425203d 0000000a 656c6966 6d63705f     = %d....file_pcm
300460e0:	616c705f 00726579 000a6425 656c6966     _player.%d..file
300460f0:	656d616e 7325203a 0000000a 6c696166     name: %s....fail
30046100:	74206465 7263206f 65746165 636f7320     ed to create soc
30046110:	64665f6b 00000a21 2e323931 2e383631     k_fd!...192.168.
30046120:	00312e31 6e6e6f63 20746365 000a2121     1.1.connect !!..
30046130:	69636572 36396576 25203a20 69202064     recive96 : %d  i
30046140:	3a6f666e 78322520 0000000a 74696177     nfo: %2x....wait
30046150:	726f6620 78656e20 6f732074 007e676e      for next song~.
30046160:	72657473 00006f65 74732d6a 6f657265     stereo..j-stereo
30046170:	00000000 6c617564 0068632d 676e6973     ....dual-ch.sing
30046180:	632d656c 00000068 00000049 00004949     le-ch...I...II..
30046190:	00494949                                III.

30046194 <C.169.1969>:
30046194:	00000000 00000001 00000003 00000007     ................
300461a4:	0000000f 0000001f 0000003f 0000007f     ........?.......
300461b4:	000000ff 72617473 0a7e2074 00000000     ....start ~.....
300461c4:	3a203166 000a6425 63736964 21647261     f1 :%d..discard!
300461d4:	0a212121 00000000 5f33706d 5f6d6370     !!!.....mp3_pcm_
300461e4:	79616c70 00007265 6c6e4f0a 616c2079     player...Only la
300461f4:	20726579 20494949 70707573 6574726f     yer III supporte
30046204:	000a2164 6365440a 6e69646f 6f642067     d!...Decoding do
30046214:	0a2e656e 00000000 736e6f63 00656c6f     ne......console.
30046224:	5f6e6f63 6e6c6574 00007465 74696e49     con_telnet..Init
30046234:	206c6169 71657246 636e6575 73692079     ial Frequency is
30046244:	4b642520 000a7a48 20434d4d 63656863      %dKHz..MMC chec
30046254:	6e65206b 0a212164 4d206e49 7220434d     k end!!.In MMC r
30046264:	79646165 0000000a 20434d4d 71657246     eady....MMC Freq
30046274:	636e6575 73692079 48642520 00000a7a     uency is %dHz...
30046284:	20414352 7830203d 000a7825 20776f4e     RCA = 0x%x..Now 
30046294:	46204453 75716572 79636e65 20736920     SD Frequency is 
300462a4:	484d6425 00000a7a 20746547 20445343     %dMHz...Get CSD 
300462b4:	6c696146 21216465 00000a21 64726143     Failed!!!...Card
300462c4:	20644920 30203d20 0a782578 00000000      Id  = 0x%x.....
300462d4:	20656854 756e616d 74636166 6e697275     The manufacturin
300462e4:	61642067 69206574 64252073 0a64252e     g date is %d.%d.
300462f4:	00000000 43484453 72614320 2e2e2e64     ....SDHC Card...
30046304:	0000000a 2e314453 61432030 2e2e6472     ....SD1.0 Card..
30046314:	00000a2e 6f727245 41203a72 34444d43     ....Error: ACMD4
30046324:	44532031 50535249 78303d30 000a7825     1 SDIRSP0=0x%x..
30046334:	6f6d654d 43207972 63617061 3d797469     Memory Capacity=
30046344:	4d642520 00000a42 2a2a2a2a 69623420      %dMB...**** 4bi
30046354:	75622074 2a2a2073 000a2a2a 2a2a2a2a     t bus ****..****
30046364:	69623120 75622074 2a2a2073 000a2a2a      1bit bus ****..
30046374:	2a2a2a2a 74696231 73756220 2a2a2a2a     ****1bit bus****
30046384:	0000000a 31444d43 61462038 64656c69     ....CMD18 Failed
30046394:	0000000a 64616552 72724520 742c726f     ....Read Error,t
300463a4:	6f656d69 21217475 00000a21 64616552     imeout!!!...Read
300463b4:	74614420 72724520 2121726f 0000000a      Dat Error!!....
300463c4:	74697257 61442065 72452074 21726f72     Write Dat Error!
300463d4:	00000a21 5f6b6843 59535542 20646e65     !...Chk_BUSYend 
300463e4:	6f727245 0a212172 00000000 6f727245     Error!!.....Erro
300463f4:	4f203a72 4f5f5455 41525f46 2145474e     r: OUT_OF_RANGE!
30046404:	0000000a 6f727245 41203a72 45524444     ....Error: ADDRE
30046414:	455f5353 524f5252 00000a21 6f727245     SS_ERROR!...Erro
30046424:	42203a72 4b434f4c 4e454c5f 5252455f     r: BLOCK_LEN_ERR
30046434:	0a21524f 00000000 6f727245 45203a72     OR!.....Error: E
30046444:	45534152 5145535f 434e4555 52455f45     RASE_SEQUENCE_ER
30046454:	21524f52 0000000a 6f727245 45203a72     ROR!....Error: E
30046464:	45534152 564e495f 44494c41 4f4c425f     RASE_INVALID_BLO
30046474:	5f534b43 4f525245 000a2152 6f727245     CKS_ERROR!..Erro
30046484:	57203a72 49565f50 54414c4f 5f4e4f49     r: WP_VIOLATION_
30046494:	4f525245 000a2152 44524143 5f53495f     ERROR!..CARD_IS_
300464a4:	4b434f4c 0a214445 00000000 6f727245     LOCKED!.....Erro
300464b4:	4c203a72 5f4b434f 4f4c4e55 465f4b43     r: LOCK_UNLOCK_F
300464c4:	454c4941 000a2144 6f727245 43203a72     AILED!..Error: C
300464d4:	435f4d4f 455f4352 524f5252 00000a21     OM_CRC_ERROR!...
300464e4:	6f727245 49203a72 47454c4c 435f4c41     Error: ILLEGAL_C
300464f4:	414d4d4f 0a21444e 00000000 64616552     OMMAND!.....Read
30046504:	6f662079 61442072 002c6174 72727543     y for Data,.Curr
30046514:	20746e65 74617453 3d207375 64492720     ent Status = 'Id
30046524:	0a27656c 00000000 72727543 20746e65     le'.....Current 
30046534:	74617453 3d207375 65522720 27796461     Status = 'Ready'
30046544:	0000000a 72727543 20746e65 74617453     ....Current Stat
30046554:	3d207375 64492720 27746e65 0000000a     us = 'Ident'....
30046564:	72727543 20746e65 74617453 3d207375     Current Status =
30046574:	74732720 533a7962 646e6174 2779622d      'stby:Stand-by'
30046584:	0000000a 72727543 20746e65 74617453     ....Current Stat
30046594:	3d207375 72742720 543a6e61 736e6172     us = 'tran:Trans
300465a4:	27726566 0000000a 72727543 20746e65     fer'....Current 
300465b4:	74617453 3d207375 61642720 533a6174     Status = 'data:S
300465c4:	69646e65 6420676e 27617461 0000000a     ending data'....
300465d4:	72727543 20746e65 74617453 3d207375     Current Status =
300465e4:	63722720 65523a76 76696563 61642065      'rcv:Receive da
300465f4:	0a276174 00000000 72727543 20746e65     ta'.....Current 
30046604:	74617453 3d207375 72702720 72503a67     Status = 'prg:Pr
30046614:	6172676f 6e696d6d 000a2767 72727543     ogramming'..Curr
30046624:	20746e65 74617453 3d207375 69642720     ent Status = 'di
30046634:	69443a73 6e6f6373 7463656e 00000a27     s:Disconnect'...
30046644:	72727543 20746e65 74617453 3d207375     Current Status =
30046654:	65522720 76726573 0a276465 00000000      'Reserved'.....
30046664:	6b736964 00000000 4d440a0d 30303039     disk......DM9000
30046674:	696e6920 00000074 6474656e 00007665      init...netdev..
